{"sha": "2cf683edc0c0481906749517cbefe631f7ed79d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjZjY4M2VkYzBjMDQ4MTkwNjc0OTUxN2NiZWZlNjMxZjdlZDc5ZDk=", "commit": {"author": {"name": "moe", "email": "35686186+csmoe@users.noreply.github.com", "date": "2018-02-17T14:22:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-02-17T14:22:26Z"}, "message": "Merge branch 'master' into inform_type_annotations", "tree": {"sha": "8d2e8a91d176ed9193747a0d85f91b57d3c13ddb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d2e8a91d176ed9193747a0d85f91b57d3c13ddb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2cf683edc0c0481906749517cbefe631f7ed79d9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJaiDqiCRBK7hj4Ov3rIwAAdHIIAFF2gZxDWj+7seY9SzGBmqNY\ny2CHpNs2xCnHcviUDSeOdy4tcoNC3IJUSxjom1Xb7ytGBlQpmyb5QOyEJ3aSPlRU\ndAgPXMuk5Ftl6ikbKI5CDFf86GcSsLFpVrWTkQXYb2UdFJql7FodO0RW4sOZyoM8\nE5tC3JWxcIVd01ORXL4xiJlLrNWCEFc3rNQKNpI7ROR6a8azWKGoEwpgardS/dKW\nxZupnN1U5Vpr7RkGH1aWpBcauUzrMImoOQXkgCY+q/6vo1RW1YSuRtuC3jTeo47r\nxhGfyjNGGDwfeWmYStwwZAZjnrVdU5PGgNBhzrGulpVYYhNThHBCdsoSlKF5TJs=\n=RpuC\n-----END PGP SIGNATURE-----\n", "payload": "tree 8d2e8a91d176ed9193747a0d85f91b57d3c13ddb\nparent 0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec\nparent b85bd51c944f8cbe3a9c4cc95b61e08e5f338052\nauthor moe <35686186+csmoe@users.noreply.github.com> 1518877346 +0800\ncommitter GitHub <noreply@github.com> 1518877346 +0800\n\nMerge branch 'master' into inform_type_annotations"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2cf683edc0c0481906749517cbefe631f7ed79d9", "html_url": "https://github.com/rust-lang/rust/commit/2cf683edc0c0481906749517cbefe631f7ed79d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2cf683edc0c0481906749517cbefe631f7ed79d9/comments", "author": {"login": "csmoe", "id": 35686186, "node_id": "MDQ6VXNlcjM1Njg2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/35686186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csmoe", "html_url": "https://github.com/csmoe", "followers_url": "https://api.github.com/users/csmoe/followers", "following_url": "https://api.github.com/users/csmoe/following{/other_user}", "gists_url": "https://api.github.com/users/csmoe/gists{/gist_id}", "starred_url": "https://api.github.com/users/csmoe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csmoe/subscriptions", "organizations_url": "https://api.github.com/users/csmoe/orgs", "repos_url": "https://api.github.com/users/csmoe/repos", "events_url": "https://api.github.com/users/csmoe/events{/privacy}", "received_events_url": "https://api.github.com/users/csmoe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec", "url": "https://api.github.com/repos/rust-lang/rust/commits/0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec", "html_url": "https://github.com/rust-lang/rust/commit/0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec"}, {"sha": "b85bd51c944f8cbe3a9c4cc95b61e08e5f338052", "url": "https://api.github.com/repos/rust-lang/rust/commits/b85bd51c944f8cbe3a9c4cc95b61e08e5f338052", "html_url": "https://github.com/rust-lang/rust/commit/b85bd51c944f8cbe3a9c4cc95b61e08e5f338052"}], "stats": {"total": 3379, "additions": 1976, "deletions": 1403}, "files": [{"sha": "280da056995068fd58d6a8e1082f94f3d88be2f9", "filename": ".travis.yml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -56,7 +56,7 @@ matrix:\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n       os: osx\n-      osx_image: xcode8.3\n+      osx_image: xcode9.2\n       if: branch = auto\n \n     - env: >\n@@ -70,7 +70,7 @@ matrix:\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n       os: osx\n-      osx_image: xcode8.3\n+      osx_image: xcode9.2\n       if: branch = auto\n \n     # OSX builders producing releases. These do not run the full test suite and"}, {"sha": "7a9d256be282f6db5704a3746e834f0eb49b3551", "filename": "RELEASES.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -78,6 +78,7 @@ Compatibility Notes\n - [`column!()` macro is one-based instead of zero-based][46977]\n - [`fmt::Arguments` can no longer be shared across threads][45198]\n - [Access to `#[repr(packed)]` struct fields is now unsafe][44884]\n+- [Cargo sets a different working directory for the compiler][cargo/4788]\n \n [44884]: https://github.com/rust-lang/rust/pull/44884\n [45198]: https://github.com/rust-lang/rust/pull/45198\n@@ -106,6 +107,7 @@ Compatibility Notes\n [47080]: https://github.com/rust-lang/rust/pull/47080\n [47084]: https://github.com/rust-lang/rust/pull/47084\n [cargo/4743]: https://github.com/rust-lang/cargo/pull/4743\n+[cargo/4788]: https://github.com/rust-lang/cargo/pull/4788\n [cargo/4817]: https://github.com/rust-lang/cargo/pull/4817\n [`RefCell::replace`]: https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.replace\n [`RefCell::swap`]: https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.swap"}, {"sha": "4b3099eed016b48716c5a2d97f46347ecec9d168", "filename": "src/Cargo.lock", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -328,6 +328,26 @@ dependencies = [\n  \"url 1.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"clippy_lints\"\n+version = \"0.0.186\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"if_chain 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itertools 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"matches 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"pulldown-cmark 0.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quine-mc_cluskey 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex-syntax 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"semver 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-normalization 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"url 1.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"cmake\"\n version = \"0.1.29\"\n@@ -1003,7 +1023,7 @@ dependencies = [\n \n [[package]]\n name = \"languageserver-types\"\n-version = \"0.27.0\"\n+version = \"0.30.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"enum_primitive 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1640,17 +1660,20 @@ name = \"rls\"\n version = \"0.125.0\"\n dependencies = [\n  \"cargo 0.26.0\",\n+ \"clippy_lints 0.0.186 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.5.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"failure 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"json 0.11.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"jsonrpc-core 8.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"languageserver-types 0.27.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"languageserver-types 0.30.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"racer 2.0.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rayon 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rls-analysis 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rls-data 0.14.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-analysis 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-blacklist 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-data 0.15.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-rustc 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-vfs 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1663,27 +1686,21 @@ dependencies = [\n \n [[package]]\n name = \"rls-analysis\"\n-version = \"0.10.0\"\n+version = \"0.11.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"derive-new 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"radix_trie 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rls-data 0.14.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-data 0.15.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n-name = \"rls-data\"\n-version = \"0.14.0\"\n+name = \"rls-blacklist\"\n+version = \"0.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n \n [[package]]\n name = \"rls-data\"\n@@ -1692,6 +1709,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -2986,6 +3005,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d4c819a1287eb618df47cc647173c5c4c66ba19d888a6e50d605672aed3140de\"\n \"checksum chrono 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7c20ebe0b2b08b0aeddba49c609fe7957ba2e33449882cb186a180bc60682fa9\"\n \"checksum clap 2.29.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"110d43e343eb29f4f51c1db31beb879d546db27998577e5715270a54bcf41d3f\"\n+\"checksum clippy_lints 0.0.186 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a3864104a4e6092e644b985dd7543e5f24e99aa7262f5ee400bcb17cfeec1bf5\"\n \"checksum cmake 0.1.29 (registry+https://github.com/rust-lang/crates.io-index)\" = \"56d741ea7a69e577f6d06b36b7dff4738f680593dc27a701ffa8506b73ce28bb\"\n \"checksum coco 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c06169f5beb7e31c7c67ebf5540b8b472d23e3eade3b2ec7d1f5b504a85f91bd\"\n \"checksum commoncrypto 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d056a8586ba25a1e4d61cb090900e495952c7886786fc55f909ab2f819b69007\"\n@@ -3050,7 +3070,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum jsonrpc-core 8.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ddf83704f4e79979a424d1082dd2c1e52683058056c9280efa19ac5f6bc9033c\"\n \"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n \"checksum kuchiki 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e03098e8e719c92b7794515dfd5c1724e2b12f5ce1788e61cfa4663f82eba8d8\"\n-\"checksum languageserver-types 0.27.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8a2036fc8576a22689b7e3171c07eb8e8f700678d7a8a53f6f65abbeb35261e1\"\n+\"checksum languageserver-types 0.30.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1541f9b22687f060511d213036e1f058797c48e3501e177f01cb6e88de802f5b\"\n \"checksum lazy_static 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"76f033c7ad61445c5b347c7382dd1237847eb1bce590fe50365dcb33d546be73\"\n \"checksum lazy_static 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c8f31047daa365f19be14b47c29df4f7c3b581832407daabe6ae77397619237d\"\n \"checksum lazycell 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3b585b7a6811fb03aa10e74b278a0f00f8dd9b45dc681f148bb29fa5cb61859b\"\n@@ -3114,8 +3134,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum regex 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"744554e01ccbd98fff8c457c3b092cd67af62a555a43bfe97ae8a0451f7799fa\"\n \"checksum regex-syntax 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f9ec002c35e86791825ed294b50008eea9ddfc8def4420124fbc6b08db834957\"\n \"checksum regex-syntax 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8e931c58b93d86f080c734bfd2bce7dd0079ae2331235818133c8be7f422e20e\"\n-\"checksum rls-analysis 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"38841e3c5271715a574ac220d9b408b59ed9e2626909c3bc54b5853b4eaadb7b\"\n-\"checksum rls-data 0.14.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8024f1feaca72d0aa4ae1e2a8d454a31b9a33ed02f8d0e9c8559bf53c267ec3c\"\n+\"checksum rls-analysis 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"30b08808959205a5cf23c68ace2d9d6defdd6867f3cd5d62981cf50fb52f8882\"\n+\"checksum rls-blacklist 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"56fb7b8e4850b988fbcf277fbdb1eff36879070d02fc1ca243b559273866973d\"\n \"checksum rls-data 0.15.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bea04462e94b5512a78499837eecb7db182ff082144cd1b4bc32ef5d43de6510\"\n \"checksum rls-rustc 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"85cfb9dde19e313da3e47738008f8a472e470cc42d910b71595a9238494701f2\"\n \"checksum rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5d7c7046dc6a92f2ae02ed302746db4382e75131b9ce20ce967259f6b5867a6a\""}, {"sha": "66a1c97246200d5c68a94817625929bdac17d22a", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 111, "deletions": 46, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -95,7 +95,7 @@ pub struct RunConfig<'a> {\n     pub builder: &'a Builder<'a>,\n     pub host: Interned<String>,\n     pub target: Interned<String>,\n-    pub path: Option<&'a Path>,\n+    pub path: PathBuf,\n }\n \n struct StepDescription {\n@@ -105,6 +105,32 @@ struct StepDescription {\n     only_build: bool,\n     should_run: fn(ShouldRun) -> ShouldRun,\n     make_run: fn(RunConfig),\n+    name: &'static str,\n+}\n+\n+#[derive(Debug, Clone, PartialOrd, Ord, PartialEq, Eq)]\n+struct PathSet {\n+    set: BTreeSet<PathBuf>,\n+}\n+\n+impl PathSet {\n+    fn empty() -> PathSet {\n+        PathSet { set: BTreeSet::new() }\n+    }\n+\n+    fn one<P: Into<PathBuf>>(path: P) -> PathSet {\n+        let mut set = BTreeSet::new();\n+        set.insert(path.into());\n+        PathSet { set }\n+    }\n+\n+    fn has(&self, needle: &Path) -> bool {\n+        self.set.iter().any(|p| p.ends_with(needle))\n+    }\n+\n+    fn path(&self, builder: &Builder) -> PathBuf {\n+        self.set.iter().next().unwrap_or(&builder.build.src).to_path_buf()\n+    }\n }\n \n impl StepDescription {\n@@ -116,10 +142,18 @@ impl StepDescription {\n             only_build: S::ONLY_BUILD,\n             should_run: S::should_run,\n             make_run: S::make_run,\n+            name: unsafe { ::std::intrinsics::type_name::<S>() },\n         }\n     }\n \n-    fn maybe_run(&self, builder: &Builder, path: Option<&Path>) {\n+    fn maybe_run(&self, builder: &Builder, pathset: &PathSet) {\n+        if builder.config.exclude.iter().any(|e| pathset.has(e)) {\n+            eprintln!(\"Skipping {:?} because it is excluded\", pathset);\n+            return;\n+        } else if !builder.config.exclude.is_empty() {\n+            eprintln!(\"{:?} not skipped for {:?} -- not in {:?}\", pathset,\n+                self.name, builder.config.exclude);\n+        }\n         let build = builder.build;\n         let hosts = if self.only_build_targets || self.only_build {\n             build.build_triple()\n@@ -144,7 +178,7 @@ impl StepDescription {\n             for target in targets {\n                 let run = RunConfig {\n                     builder,\n-                    path,\n+                    path: pathset.path(builder),\n                     host: *host,\n                     target: *target,\n                 };\n@@ -157,24 +191,33 @@ impl StepDescription {\n         let should_runs = v.iter().map(|desc| {\n             (desc.should_run)(ShouldRun::new(builder))\n         }).collect::<Vec<_>>();\n+\n+        // sanity checks on rules\n+        for (desc, should_run) in v.iter().zip(&should_runs) {\n+            assert!(!should_run.paths.is_empty(),\n+                \"{:?} should have at least one pathset\", desc.name);\n+        }\n+\n         if paths.is_empty() {\n             for (desc, should_run) in v.iter().zip(should_runs) {\n                 if desc.default && should_run.is_really_default {\n-                    desc.maybe_run(builder, None);\n+                    for pathset in &should_run.paths {\n+                        desc.maybe_run(builder, pathset);\n+                    }\n                 }\n             }\n         } else {\n             for path in paths {\n                 let mut attempted_run = false;\n                 for (desc, should_run) in v.iter().zip(&should_runs) {\n-                    if should_run.run(path) {\n+                    if let Some(pathset) = should_run.pathset_for_path(path) {\n                         attempted_run = true;\n-                        desc.maybe_run(builder, Some(path));\n+                        desc.maybe_run(builder, pathset);\n                     }\n                 }\n \n                 if !attempted_run {\n-                    eprintln!(\"Warning: no rules matched {}.\", path.display());\n+                    panic!(\"Error: no rules matched {}.\", path.display());\n                 }\n             }\n         }\n@@ -185,7 +228,7 @@ impl StepDescription {\n pub struct ShouldRun<'a> {\n     pub builder: &'a Builder<'a>,\n     // use a BTreeSet to maintain sort order\n-    paths: BTreeSet<PathBuf>,\n+    paths: BTreeSet<PathSet>,\n \n     // If this is a default rule, this is an additional constraint placed on\n     // it's run. Generally something like compiler docs being enabled.\n@@ -206,25 +249,46 @@ impl<'a> ShouldRun<'a> {\n         self\n     }\n \n+    // Unlike `krate` this will create just one pathset. As such, it probably shouldn't actually\n+    // ever be used, but as we transition to having all rules properly handle passing krate(...) by\n+    // actually doing something different for every crate passed.\n+    pub fn all_krates(mut self, name: &str) -> Self {\n+        let mut set = BTreeSet::new();\n+        for krate in self.builder.in_tree_crates(name) {\n+            set.insert(PathBuf::from(&krate.path));\n+        }\n+        self.paths.insert(PathSet { set });\n+        self\n+    }\n+\n     pub fn krate(mut self, name: &str) -> Self {\n-        for (_, krate_path) in self.builder.crates(name) {\n-            self.paths.insert(PathBuf::from(krate_path));\n+        for krate in self.builder.in_tree_crates(name) {\n+            self.paths.insert(PathSet::one(&krate.path));\n         }\n         self\n     }\n \n-    pub fn path(mut self, path: &str) -> Self {\n-        self.paths.insert(PathBuf::from(path));\n+    // single, non-aliased path\n+    pub fn path(self, path: &str) -> Self {\n+        self.paths(&[path])\n+    }\n+\n+    // multiple aliases for the same job\n+    pub fn paths(mut self, paths: &[&str]) -> Self {\n+        self.paths.insert(PathSet {\n+            set: paths.iter().map(PathBuf::from).collect(),\n+        });\n         self\n     }\n \n     // allows being more explicit about why should_run in Step returns the value passed to it\n-    pub fn never(self) -> ShouldRun<'a> {\n+    pub fn never(mut self) -> ShouldRun<'a> {\n+        self.paths.insert(PathSet::empty());\n         self\n     }\n \n-    fn run(&self, path: &Path) -> bool {\n-        self.paths.iter().any(|p| path.ends_with(p))\n+    fn pathset_for_path(&self, path: &Path) -> Option<&PathSet> {\n+        self.paths.iter().find(|pathset| pathset.has(path))\n     }\n }\n \n@@ -254,19 +318,23 @@ impl<'a> Builder<'a> {\n                 tool::RustInstaller, tool::Cargo, tool::Rls, tool::Rustdoc, tool::Clippy,\n                 native::Llvm, tool::Rustfmt, tool::Miri),\n             Kind::Check => describe!(check::Std, check::Test, check::Rustc),\n-            Kind::Test => describe!(test::Tidy, test::Bootstrap, test::DefaultCompiletest,\n-                test::HostCompiletest, test::Crate, test::CrateLibrustc, test::Rustdoc,\n-                test::Linkcheck, test::Cargotest, test::Cargo, test::Rls, test::Docs,\n-                test::ErrorIndex, test::Distcheck, test::Rustfmt, test::Miri, test::Clippy,\n-                test::RustdocJS, test::RustdocTheme),\n+            Kind::Test => describe!(test::Tidy, test::Bootstrap, test::Ui, test::RunPass,\n+                test::CompileFail, test::ParseFail, test::RunFail, test::RunPassValgrind,\n+                test::MirOpt, test::Codegen, test::CodegenUnits, test::Incremental, test::Debuginfo,\n+                test::UiFullDeps, test::RunPassFullDeps, test::RunFailFullDeps,\n+                test::CompileFailFullDeps, test::IncrementalFullDeps, test::Rustdoc, test::Pretty,\n+                test::RunPassPretty, test::RunFailPretty, test::RunPassValgrindPretty,\n+                test::RunPassFullDepsPretty, test::RunFailFullDepsPretty, test::RunMake,\n+                test::Crate, test::CrateLibrustc, test::Rustdoc, test::Linkcheck, test::Cargotest,\n+                test::Cargo, test::Rls, test::Docs, test::ErrorIndex, test::Distcheck,\n+                test::Rustfmt, test::Miri, test::Clippy, test::RustdocJS, test::RustdocTheme),\n             Kind::Bench => describe!(test::Crate, test::CrateLibrustc),\n             Kind::Doc => describe!(doc::UnstableBook, doc::UnstableBookGen, doc::TheBook,\n                 doc::Standalone, doc::Std, doc::Test, doc::Rustc, doc::ErrorIndex, doc::Nomicon,\n                 doc::Reference, doc::Rustdoc, doc::RustByExample, doc::CargoBook),\n             Kind::Dist => describe!(dist::Docs, dist::Mingw, dist::Rustc, dist::DebuggerScripts,\n                 dist::Std, dist::Analysis, dist::Src, dist::PlainSourceTarball, dist::Cargo,\n-                dist::Rls, dist::Rustfmt, dist::Extended, dist::HashSign,\n-                dist::DontDistWithMiriEnabled),\n+                dist::Rls, dist::Rustfmt, dist::Extended, dist::HashSign),\n             Kind::Install => describe!(install::Docs, install::Std, install::Cargo, install::Rls,\n                 install::Rustfmt, install::Analysis, install::Src, install::Rustc),\n         }\n@@ -297,8 +365,10 @@ impl<'a> Builder<'a> {\n             should_run = (desc.should_run)(should_run);\n         }\n         let mut help = String::from(\"Available paths:\\n\");\n-        for path in should_run.paths {\n-            help.push_str(format!(\"    ./x.py {} {}\\n\", subcommand, path.display()).as_str());\n+        for pathset in should_run.paths {\n+            for path in pathset.set {\n+                help.push_str(format!(\"    ./x.py {} {}\\n\", subcommand, path.display()).as_str());\n+            }\n         }\n         Some(help)\n     }\n@@ -315,6 +385,12 @@ impl<'a> Builder<'a> {\n             Subcommand::Clean { .. } => panic!(),\n         };\n \n+        if let Some(path) = paths.get(0) {\n+            if path == Path::new(\"nonexistent/path/to/trigger/cargo/metadata\") {\n+                return;\n+            }\n+        }\n+\n         let builder = Builder {\n             build,\n             top_stage: build.config.stage.unwrap_or(2),\n@@ -323,6 +399,12 @@ impl<'a> Builder<'a> {\n             stack: RefCell::new(Vec::new()),\n         };\n \n+        if kind == Kind::Dist {\n+            assert!(!build.config.test_miri, \"Do not distribute with miri enabled.\\n\\\n+                The distributed libraries would include all MIR (increasing binary size).\n+                The distributed MIR would include validation statements.\");\n+        }\n+\n         StepDescription::run(&Builder::get_step_descriptions(builder.kind), &builder, paths);\n     }\n \n@@ -600,25 +682,9 @@ impl<'a> Builder<'a> {\n         //\n         // FIXME: the guard against msvc shouldn't need to be here\n         if !target.contains(\"msvc\") {\n-            let ccache = self.config.ccache.as_ref();\n-            let ccacheify = |s: &Path| {\n-                let ccache = match ccache {\n-                    Some(ref s) => s,\n-                    None => return s.display().to_string(),\n-                };\n-                // FIXME: the cc-rs crate only recognizes the literal strings\n-                // `ccache` and `sccache` when doing caching compilations, so we\n-                // mirror that here. It should probably be fixed upstream to\n-                // accept a new env var or otherwise work with custom ccache\n-                // vars.\n-                match &ccache[..] {\n-                    \"ccache\" | \"sccache\" => format!(\"{} {}\", ccache, s.display()),\n-                    _ => s.display().to_string(),\n-                }\n-            };\n-            let cc = ccacheify(&self.cc(target));\n-            cargo.env(format!(\"CC_{}\", target), &cc)\n-                 .env(\"CC\", &cc);\n+            let cc = self.cc(target);\n+            cargo.env(format!(\"CC_{}\", target), cc)\n+                 .env(\"CC\", cc);\n \n             let cflags = self.cflags(target).join(\" \");\n             cargo.env(format!(\"CFLAGS_{}\", target), cflags.clone())\n@@ -633,9 +699,8 @@ impl<'a> Builder<'a> {\n             }\n \n             if let Ok(cxx) = self.cxx(target) {\n-                let cxx = ccacheify(&cxx);\n-                cargo.env(format!(\"CXX_{}\", target), &cxx)\n-                     .env(\"CXX\", &cxx)\n+                cargo.env(format!(\"CXX_{}\", target), cxx)\n+                     .env(\"CXX\", cxx)\n                      .env(format!(\"CXXFLAGS_{}\", target), cflags.clone())\n                      .env(\"CXXFLAGS\", cflags);\n             }"}, {"sha": "767ee4016c6f1d6df08505e8f323b6f9a61a167c", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -26,7 +26,7 @@ impl Step for Std {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/libstd\").krate(\"std\")\n+        run.all_krates(\"std\")\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -67,7 +67,7 @@ impl Step for Rustc {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/librustc\").krate(\"rustc-main\")\n+        run.all_krates(\"rustc-main\")\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -114,7 +114,7 @@ impl Step for Test {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/libtest\").krate(\"test\")\n+        run.all_krates(\"test\")\n     }\n \n     fn make_run(run: RunConfig) {"}, {"sha": "2dcc0e0e7cd9f0110a583a93ad1450cb7ca3d08a", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -48,7 +48,7 @@ impl Step for Std {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/libstd\").krate(\"std\")\n+        run.all_krates(\"std\")\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -320,7 +320,7 @@ impl Step for Test {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/libtest\").krate(\"test\")\n+        run.all_krates(\"test\")\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -436,7 +436,7 @@ impl Step for Rustc {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/librustc\").krate(\"rustc-main\")\n+        run.all_krates(\"rustc-main\")\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -593,7 +593,7 @@ impl Step for CodegenBackend {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/librustc_trans\")\n+        run.all_krates(\"rustc_trans\")\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -828,7 +828,7 @@ impl Step for Assemble {\n     type Output = Compiler;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/rustc\")\n+        run.all_krates(\"rustc-main\")\n     }\n \n     /// Prepare a new compiler from the artifacts in `stage`"}, {"sha": "812ca6d64fb6a792545749b84857175a6c36db92", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -56,6 +56,7 @@ pub struct Config {\n     pub sanitizers: bool,\n     pub profiler: bool,\n     pub ignore_git: bool,\n+    pub exclude: Vec<PathBuf>,\n \n     pub run_host_only: bool,\n \n@@ -311,6 +312,7 @@ impl Config {\n         let flags = Flags::parse(&args);\n         let file = flags.config.clone();\n         let mut config = Config::default();\n+        config.exclude = flags.exclude;\n         config.llvm_enabled = true;\n         config.llvm_optimize = true;\n         config.llvm_version_check = true;"}, {"sha": "e7aed7eb4fead3de97f477fc3339542e0a9f7d59", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -1233,31 +1233,6 @@ impl Step for Rustfmt {\n     }\n }\n \n-\n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct DontDistWithMiriEnabled;\n-\n-impl Step for DontDistWithMiriEnabled {\n-    type Output = PathBuf;\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        let build_miri = run.builder.build.config.test_miri;\n-        run.default_condition(build_miri)\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(DontDistWithMiriEnabled);\n-    }\n-\n-    fn run(self, _: &Builder) -> PathBuf {\n-        panic!(\"Do not distribute with miri enabled.\\n\\\n-                The distributed libraries would include all MIR (increasing binary size).\n-                The distributed MIR would include validation statements.\");\n-    }\n-}\n-\n-\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Extended {\n     stage: u32,"}, {"sha": "55d9723527e6db26ac617f8fe77ea9acbcfc1fcf", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -429,7 +429,7 @@ impl Step for Std {\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n-        run.krate(\"std\").default_condition(builder.build.config.docs)\n+        run.all_krates(\"std\").default_condition(builder.build.config.docs)\n     }\n \n     fn make_run(run: RunConfig) {"}, {"sha": "42b949527e09dda2bec9818903aa65bd974fb795", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -42,6 +42,7 @@ pub struct Flags {\n     pub jobs: Option<u32>,\n     pub cmd: Subcommand,\n     pub incremental: bool,\n+    pub exclude: Vec<PathBuf>,\n }\n \n pub enum Subcommand {\n@@ -109,6 +110,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n         opts.optopt(\"\", \"build\", \"build target of the stage0 compiler\", \"BUILD\");\n         opts.optmulti(\"\", \"host\", \"host targets to build\", \"HOST\");\n         opts.optmulti(\"\", \"target\", \"target targets to build\", \"TARGET\");\n+        opts.optmulti(\"\", \"exclude\", \"build paths to exclude\", \"PATH\");\n         opts.optopt(\"\", \"on-fail\", \"command to run on failure\", \"CMD\");\n         opts.optopt(\"\", \"stage\", \"stage to build\", \"N\");\n         opts.optopt(\"\", \"keep-stage\", \"stage to keep without recompiling\", \"N\");\n@@ -273,7 +275,10 @@ Arguments:\n         };\n         // Get any optional paths which occur after the subcommand\n         let cwd = t!(env::current_dir());\n-        let paths = matches.free[1..].iter().map(|p| cwd.join(p)).collect::<Vec<_>>();\n+        let src = matches.opt_str(\"src\").map(PathBuf::from)\n+            .or_else(|| env::var_os(\"SRC\").map(PathBuf::from))\n+            .unwrap_or(cwd.clone());\n+        let paths = matches.free[1..].iter().map(|p| p.into()).collect::<Vec<PathBuf>>();\n \n         let cfg_file = matches.opt_str(\"config\").map(PathBuf::from).or_else(|| {\n             if fs::metadata(\"config.toml\").is_ok() {\n@@ -358,11 +363,6 @@ Arguments:\n             stage = Some(1);\n         }\n \n-        let cwd = t!(env::current_dir());\n-        let src = matches.opt_str(\"src\").map(PathBuf::from)\n-            .or_else(|| env::var_os(\"SRC\").map(PathBuf::from))\n-            .unwrap_or(cwd);\n-\n         Flags {\n             verbose: matches.opt_count(\"verbose\"),\n             stage,\n@@ -374,10 +374,12 @@ Arguments:\n             target: split(matches.opt_strs(\"target\"))\n                 .into_iter().map(|x| INTERNER.intern_string(x)).collect::<Vec<_>>(),\n             config: cfg_file,\n-            src,\n             jobs: matches.opt_str(\"jobs\").map(|j| j.parse().unwrap()),\n             cmd,\n             incremental: matches.opt_present(\"incremental\"),\n+            exclude: split(matches.opt_strs(\"exclude\"))\n+                .into_iter().map(|p| p.into()).collect::<Vec<_>>(),\n+            src,\n         }\n     }\n }"}, {"sha": "afd740ce5484549f32ee7735514162726f3ed671", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -113,9 +113,8 @@\n //! More documentation can be found in each respective module below, and you can\n //! also check out the `src/bootstrap/README.md` file for more information.\n \n-#![deny(warnings)]\n-#![allow(stable_features)]\n-#![feature(associated_consts)]\n+//#![deny(warnings)]\n+#![feature(core_intrinsics)]\n \n #[macro_use]\n extern crate build_helper;\n@@ -267,6 +266,18 @@ struct Crate {\n     bench_step: String,\n }\n \n+impl Crate {\n+    fn is_local(&self, build: &Build) -> bool {\n+        self.path.starts_with(&build.config.src) &&\n+        !self.path.to_string_lossy().ends_with(\"_shim\")\n+    }\n+\n+    fn local_path(&self, build: &Build) -> PathBuf {\n+        assert!(self.is_local(build));\n+        self.path.strip_prefix(&build.config.src).unwrap().into()\n+    }\n+}\n+\n /// The various \"modes\" of invoking Cargo.\n ///\n /// These entries currently correspond to the various output directories of the\n@@ -949,22 +960,18 @@ impl Build {\n         }\n     }\n \n-    /// Get a list of crates from a root crate.\n-    ///\n-    /// Returns Vec<(crate, path to crate, is_root_crate)>\n-    fn crates(&self, root: &str) -> Vec<(Interned<String>, &Path)> {\n-        let interned = INTERNER.intern_string(root.to_owned());\n+    fn in_tree_crates(&self, root: &str) -> Vec<&Crate> {\n         let mut ret = Vec::new();\n-        let mut list = vec![interned];\n+        let mut list = vec![INTERNER.intern_str(root)];\n         let mut visited = HashSet::new();\n         while let Some(krate) = list.pop() {\n             let krate = &self.crates[&krate];\n-            // If we can't strip prefix, then out-of-tree path\n-            let path = krate.path.strip_prefix(&self.src).unwrap_or(&krate.path);\n-            ret.push((krate.name, path));\n-            for dep in &krate.deps {\n-                if visited.insert(dep) && dep != \"build_helper\" {\n-                    list.push(*dep);\n+            if krate.is_local(self) {\n+                ret.push(krate);\n+                for dep in &krate.deps {\n+                    if visited.insert(dep) && dep != \"build_helper\" {\n+                        list.push(*dep);\n+                    }\n                 }\n             }\n         }"}, {"sha": "29cd23bdbb1978398043dd06b45a9d94502b26f1", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -51,9 +51,7 @@ impl Step for Llvm {\n     }\n \n     fn make_run(run: RunConfig) {\n-        let emscripten = run.path.map(|p| {\n-            p.ends_with(\"llvm-emscripten\")\n-        }).unwrap_or(false);\n+        let emscripten = run.path.ends_with(\"llvm-emscripten\");\n         run.builder.ensure(Llvm {\n             target: run.target,\n             emscripten,\n@@ -159,6 +157,14 @@ impl Step for Llvm {\n            .define(\"LLVM_TARGET_ARCH\", target.split('-').next().unwrap())\n            .define(\"LLVM_DEFAULT_TARGET_TRIPLE\", target);\n \n+        // By default, LLVM will automatically find OCaml and, if it finds it,\n+        // install the LLVM bindings in LLVM_OCAML_INSTALL_PATH, which defaults\n+        // to /usr/bin/ocaml.\n+        // This causes problem for non-root builds of Rust. Side-step the issue\n+        // by setting LLVM_OCAML_INSTALL_PATH to a relative path, so it installs\n+        // in the prefix.\n+        cfg.define(\"LLVM_OCAML_INSTALL_PATH\",\n+            env::var_os(\"LLVM_OCAML_INSTALL_PATH\").unwrap_or_else(|| \"usr/lib/ocaml\".into()));\n \n         // This setting makes the LLVM tools link to the dynamic LLVM library,\n         // which saves both memory during parallel links and overall disk space"}, {"sha": "64ede4f4ecc885f071969a6f516db5eb63a6a10d", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 298, "deletions": 245, "changes": 543, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -13,7 +13,6 @@\n //! This file implements the various regression test suites that we execute on\n //! our CI.\n \n-use std::collections::HashSet;\n use std::env;\n use std::ffi::OsString;\n use std::iter;\n@@ -26,6 +25,7 @@ use std::io::Read;\n use build_helper::{self, output};\n \n use builder::{Kind, RunConfig, ShouldRun, Builder, Compiler, Step};\n+use Crate as CargoCrate;\n use cache::{INTERNER, Interned};\n use compile;\n use dist;\n@@ -550,181 +550,214 @@ fn testdir(build: &Build, host: Interned<String>) -> PathBuf {\n     build.out.join(host).join(\"test\")\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-struct Test {\n-    path: &'static str,\n-    mode: &'static str,\n-    suite: &'static str,\n+macro_rules! default_test {\n+    ($name:ident { path: $path:expr, mode: $mode:expr, suite: $suite:expr }) => {\n+        test!($name { path: $path, mode: $mode, suite: $suite, default: true, host: false });\n+    }\n }\n \n-static DEFAULT_COMPILETESTS: &[Test] = &[\n-    Test { path: \"src/test/ui\", mode: \"ui\", suite: \"ui\" },\n-    Test { path: \"src/test/run-pass\", mode: \"run-pass\", suite: \"run-pass\" },\n-    Test { path: \"src/test/compile-fail\", mode: \"compile-fail\", suite: \"compile-fail\" },\n-    Test { path: \"src/test/parse-fail\", mode: \"parse-fail\", suite: \"parse-fail\" },\n-    Test { path: \"src/test/run-fail\", mode: \"run-fail\", suite: \"run-fail\" },\n-    Test {\n-        path: \"src/test/run-pass-valgrind\",\n-        mode: \"run-pass-valgrind\",\n-        suite: \"run-pass-valgrind\"\n-    },\n-    Test { path: \"src/test/mir-opt\", mode: \"mir-opt\", suite: \"mir-opt\" },\n-    Test { path: \"src/test/codegen\", mode: \"codegen\", suite: \"codegen\" },\n-    Test { path: \"src/test/codegen-units\", mode: \"codegen-units\", suite: \"codegen-units\" },\n-    Test { path: \"src/test/incremental\", mode: \"incremental\", suite: \"incremental\" },\n-\n-    // What this runs varies depending on the native platform being apple\n-    Test { path: \"src/test/debuginfo\", mode: \"debuginfo-XXX\", suite: \"debuginfo\" },\n-];\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct DefaultCompiletest {\n-    compiler: Compiler,\n-    target: Interned<String>,\n-    mode: &'static str,\n-    suite: &'static str,\n+macro_rules! host_test {\n+    ($name:ident { path: $path:expr, mode: $mode:expr, suite: $suite:expr }) => {\n+        test!($name { path: $path, mode: $mode, suite: $suite, default: true, host: true });\n+    }\n }\n \n-impl Step for DefaultCompiletest {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(mut run: ShouldRun) -> ShouldRun {\n-        for test in DEFAULT_COMPILETESTS {\n-            run = run.path(test.path);\n+macro_rules! test {\n+    ($name:ident {\n+        path: $path:expr,\n+        mode: $mode:expr,\n+        suite: $suite:expr,\n+        default: $default:expr,\n+        host: $host:expr\n+    }) => {\n+        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+        pub struct $name {\n+            pub compiler: Compiler,\n+            pub target: Interned<String>,\n         }\n-        run\n-    }\n \n-    fn make_run(run: RunConfig) {\n-        let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n+        impl Step for $name {\n+            type Output = ();\n+            const DEFAULT: bool = $default;\n+            const ONLY_HOSTS: bool = $host;\n \n-        let test = run.path.map(|path| {\n-            DEFAULT_COMPILETESTS.iter().find(|&&test| {\n-                path.ends_with(test.path)\n-            }).unwrap_or_else(|| {\n-                panic!(\"make_run in compile test to receive test path, received {:?}\", path);\n-            })\n-        });\n-\n-        if let Some(test) = test {\n-            run.builder.ensure(DefaultCompiletest {\n-                compiler,\n-                target: run.target,\n-                mode: test.mode,\n-                suite: test.suite,\n-            });\n-        } else {\n-            for test in DEFAULT_COMPILETESTS {\n-                run.builder.ensure(DefaultCompiletest {\n-                    compiler,\n-                    target: run.target,\n-                    mode: test.mode,\n-                    suite: test.suite\n-                });\n+            fn should_run(run: ShouldRun) -> ShouldRun {\n+                run.path($path)\n             }\n-        }\n-    }\n-\n-    fn run(self, builder: &Builder) {\n-        builder.ensure(Compiletest {\n-            compiler: self.compiler,\n-            target: self.target,\n-            mode: self.mode,\n-            suite: self.suite,\n-        })\n-    }\n-}\n-\n-// Also default, but host-only.\n-static HOST_COMPILETESTS: &[Test] = &[\n-    Test { path: \"src/test/ui-fulldeps\", mode: \"ui\", suite: \"ui-fulldeps\" },\n-    Test { path: \"src/test/run-pass-fulldeps\", mode: \"run-pass\", suite: \"run-pass-fulldeps\" },\n-    Test { path: \"src/test/run-fail-fulldeps\", mode: \"run-fail\", suite: \"run-fail-fulldeps\" },\n-    Test {\n-        path: \"src/test/compile-fail-fulldeps\",\n-        mode: \"compile-fail\",\n-        suite: \"compile-fail-fulldeps\",\n-    },\n-    Test {\n-        path: \"src/test/incremental-fulldeps\",\n-        mode: \"incremental\",\n-        suite: \"incremental-fulldeps\",\n-    },\n-    Test { path: \"src/test/rustdoc\", mode: \"rustdoc\", suite: \"rustdoc\" },\n-\n-    Test { path: \"src/test/pretty\", mode: \"pretty\", suite: \"pretty\" },\n-    Test { path: \"src/test/run-pass/pretty\", mode: \"pretty\", suite: \"run-pass\" },\n-    Test { path: \"src/test/run-fail/pretty\", mode: \"pretty\", suite: \"run-fail\" },\n-    Test { path: \"src/test/run-pass-valgrind/pretty\", mode: \"pretty\", suite: \"run-pass-valgrind\" },\n-    Test { path: \"src/test/run-pass-fulldeps/pretty\", mode: \"pretty\", suite: \"run-pass-fulldeps\" },\n-    Test { path: \"src/test/run-fail-fulldeps/pretty\", mode: \"pretty\", suite: \"run-fail-fulldeps\" },\n-    Test { path: \"src/test/run-make\", mode: \"run-make\", suite: \"run-make\" },\n-];\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct HostCompiletest {\n-    compiler: Compiler,\n-    target: Interned<String>,\n-    mode: &'static str,\n-    suite: &'static str,\n-}\n+            fn make_run(run: RunConfig) {\n+                let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n \n-impl Step for HostCompiletest {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(mut run: ShouldRun) -> ShouldRun {\n-        for test in HOST_COMPILETESTS {\n-            run = run.path(test.path);\n-        }\n-        run\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n-\n-        let test = run.path.map(|path| {\n-            HOST_COMPILETESTS.iter().find(|&&test| {\n-                path.ends_with(test.path)\n-            }).unwrap_or_else(|| {\n-                panic!(\"make_run in compile test to receive test path, received {:?}\", path);\n-            })\n-        });\n-\n-        if let Some(test) = test {\n-            run.builder.ensure(HostCompiletest {\n-                compiler,\n-                target: run.target,\n-                mode: test.mode,\n-                suite: test.suite,\n-            });\n-        } else {\n-            for test in HOST_COMPILETESTS {\n-                if test.mode == \"pretty\" {\n-                    continue;\n-                }\n-                run.builder.ensure(HostCompiletest {\n+                run.builder.ensure($name {\n                     compiler,\n                     target: run.target,\n-                    mode: test.mode,\n-                    suite: test.suite\n                 });\n             }\n-        }\n-    }\n \n-    fn run(self, builder: &Builder) {\n-        builder.ensure(Compiletest {\n-            compiler: self.compiler,\n-            target: self.target,\n-            mode: self.mode,\n-            suite: self.suite,\n-        })\n+            fn run(self, builder: &Builder) {\n+                builder.ensure(Compiletest {\n+                    compiler: self.compiler,\n+                    target: self.target,\n+                    mode: $mode,\n+                    suite: $suite,\n+                })\n+            }\n+        }\n     }\n }\n \n+default_test!(Ui {\n+    path: \"src/test/ui\",\n+    mode: \"ui\",\n+    suite: \"ui\"\n+});\n+\n+default_test!(RunPass {\n+    path: \"src/test/run-pass\",\n+    mode: \"run-pass\",\n+    suite: \"run-pass\"\n+});\n+\n+default_test!(CompileFail {\n+    path: \"src/test/compile-fail\",\n+    mode: \"compile-fail\",\n+    suite: \"compile-fail\"\n+});\n+\n+default_test!(ParseFail {\n+    path: \"src/test/parse-fail\",\n+    mode: \"parse-fail\",\n+    suite: \"parse-fail\"\n+});\n+\n+default_test!(RunFail {\n+    path: \"src/test/run-fail\",\n+    mode: \"run-fail\",\n+    suite: \"run-fail\"\n+});\n+\n+default_test!(RunPassValgrind {\n+    path: \"src/test/run-pass-valgrind\",\n+    mode: \"run-pass-valgrind\",\n+    suite: \"run-pass-valgrind\"\n+});\n+\n+default_test!(MirOpt {\n+    path: \"src/test/mir-opt\",\n+    mode: \"mir-opt\",\n+    suite: \"mir-opt\"\n+});\n+\n+default_test!(Codegen {\n+    path: \"src/test/codegen\",\n+    mode: \"codegen\",\n+    suite: \"codegen\"\n+});\n+\n+default_test!(CodegenUnits {\n+    path: \"src/test/codegen-units\",\n+    mode: \"codegen-units\",\n+    suite: \"codegen-units\"\n+});\n+\n+default_test!(Incremental {\n+    path: \"src/test/incremental\",\n+    mode: \"incremental\",\n+    suite: \"incremental\"\n+});\n+\n+default_test!(Debuginfo {\n+    path: \"src/test/debuginfo\",\n+    // What this runs varies depending on the native platform being apple\n+    mode: \"debuginfo-XXX\",\n+    suite: \"debuginfo\"\n+});\n+\n+host_test!(UiFullDeps {\n+    path: \"src/test/ui-fulldeps\",\n+    mode: \"ui\",\n+    suite: \"ui-fulldeps\"\n+});\n+\n+host_test!(RunPassFullDeps {\n+    path: \"src/test/run-pass-fulldeps\",\n+    mode: \"run-pass\",\n+    suite: \"run-pass-fulldeps\"\n+});\n+\n+host_test!(RunFailFullDeps {\n+    path: \"src/test/run-fail-fulldeps\",\n+    mode: \"run-fail\",\n+    suite: \"run-fail-fulldeps\"\n+});\n+\n+host_test!(CompileFailFullDeps {\n+    path: \"src/test/compile-fail-fulldeps\",\n+    mode: \"compile-fail\",\n+    suite: \"compile-fail-fulldeps\"\n+});\n+\n+host_test!(IncrementalFullDeps {\n+    path: \"src/test/incremental-fulldeps\",\n+    mode: \"incremental\",\n+    suite: \"incremental-fulldeps\"\n+});\n+\n+host_test!(Rustdoc {\n+    path: \"src/test/rustdoc\",\n+    mode: \"rustdoc\",\n+    suite: \"rustdoc\"\n+});\n+\n+test!(Pretty {\n+    path: \"src/test/pretty\",\n+    mode: \"pretty\",\n+    suite: \"pretty\",\n+    default: false,\n+    host: true\n+});\n+test!(RunPassPretty {\n+    path: \"src/test/run-pass/pretty\",\n+    mode: \"pretty\",\n+    suite: \"run-pass\",\n+    default: false,\n+    host: true\n+});\n+test!(RunFailPretty {\n+    path: \"src/test/run-fail/pretty\",\n+    mode: \"pretty\",\n+    suite: \"run-fail\",\n+    default: false,\n+    host: true\n+});\n+test!(RunPassValgrindPretty {\n+    path: \"src/test/run-pass-valgrind/pretty\",\n+    mode: \"pretty\",\n+    suite: \"run-pass-valgrind\",\n+    default: false,\n+    host: true\n+});\n+test!(RunPassFullDepsPretty {\n+    path: \"src/test/run-pass-fulldeps/pretty\",\n+    mode: \"pretty\",\n+    suite: \"run-pass-fulldeps\",\n+    default: false,\n+    host: true\n+});\n+test!(RunFailFullDepsPretty {\n+    path: \"src/test/run-fail-fulldeps/pretty\",\n+    mode: \"pretty\",\n+    suite: \"run-fail-fulldeps\",\n+    default: false,\n+    host: true\n+});\n+\n+host_test!(RunMake {\n+    path: \"src/test/run-make\",\n+    mode: \"run-make\",\n+    suite: \"run-make\"\n+});\n+\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n struct Compiletest {\n     compiler: Compiler,\n@@ -902,7 +935,7 @@ impl Step for Compiletest {\n             }\n         }\n         if suite == \"run-make\" && !build.config.llvm_enabled {\n-            println!(\"Ignoring run-make test suite as they generally don't work without LLVM\");\n+            println!(\"Ignoring run-make test suite as they generally dont work without LLVM\");\n             return;\n         }\n \n@@ -1099,7 +1132,7 @@ pub struct CrateLibrustc {\n     compiler: Compiler,\n     target: Interned<String>,\n     test_kind: TestKind,\n-    krate: Option<Interned<String>>,\n+    krate: Interned<String>,\n }\n \n impl Step for CrateLibrustc {\n@@ -1115,35 +1148,26 @@ impl Step for CrateLibrustc {\n         let builder = run.builder;\n         let compiler = builder.compiler(builder.top_stage, run.host);\n \n-        let make = |name: Option<Interned<String>>| {\n-            let test_kind = if builder.kind == Kind::Test {\n-                TestKind::Test\n-            } else if builder.kind == Kind::Bench {\n-                TestKind::Bench\n-            } else {\n-                panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n-            };\n-\n-            builder.ensure(CrateLibrustc {\n-                compiler,\n-                target: run.target,\n-                test_kind,\n-                krate: name,\n-            });\n-        };\n+        for krate in builder.in_tree_crates(\"rustc-main\") {\n+            if run.path.ends_with(&krate.path) {\n+                let test_kind = if builder.kind == Kind::Test {\n+                    TestKind::Test\n+                } else if builder.kind == Kind::Bench {\n+                    TestKind::Bench\n+                } else {\n+                    panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n+                };\n \n-        if let Some(path) = run.path {\n-            for (name, krate_path) in builder.crates(\"rustc-main\") {\n-                if path.ends_with(krate_path) {\n-                    make(Some(name));\n-                }\n+                builder.ensure(CrateLibrustc {\n+                    compiler,\n+                    target: run.target,\n+                    test_kind,\n+                    krate: krate.name,\n+                });\n             }\n-        } else {\n-            make(None);\n         }\n     }\n \n-\n     fn run(self, builder: &Builder) {\n         builder.ensure(Crate {\n             compiler: self.compiler,\n@@ -1155,28 +1179,96 @@ impl Step for CrateLibrustc {\n     }\n }\n \n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct CrateNotDefault {\n+    compiler: Compiler,\n+    target: Interned<String>,\n+    test_kind: TestKind,\n+    krate: &'static str,\n+}\n+\n+impl Step for CrateNotDefault {\n+    type Output = ();\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/liballoc_jemalloc\")\n+            .path(\"src/librustc_asan\")\n+            .path(\"src/librustc_lsan\")\n+            .path(\"src/librustc_msan\")\n+            .path(\"src/librustc_tsan\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        let builder = run.builder;\n+        let compiler = builder.compiler(builder.top_stage, run.host);\n+\n+        let test_kind = if builder.kind == Kind::Test {\n+            TestKind::Test\n+        } else if builder.kind == Kind::Bench {\n+            TestKind::Bench\n+        } else {\n+            panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n+        };\n+\n+        builder.ensure(CrateNotDefault {\n+            compiler,\n+            target: run.target,\n+            test_kind,\n+            krate: match run.path {\n+                _ if run.path.ends_with(\"src/liballoc_jemalloc\") => \"alloc_jemalloc\",\n+                _ if run.path.ends_with(\"src/librustc_asan\") => \"rustc_asan\",\n+                _ if run.path.ends_with(\"src/librustc_lsan\") => \"rustc_lsan\",\n+                _ if run.path.ends_with(\"src/librustc_msan\") => \"rustc_msan\",\n+                _ if run.path.ends_with(\"src/librustc_tsan\") => \"rustc_tsan\",\n+                _ => panic!(\"unexpected path {:?}\", run.path),\n+            },\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder) {\n+        builder.ensure(Crate {\n+            compiler: self.compiler,\n+            target: self.target,\n+            mode: Mode::Libstd,\n+            test_kind: self.test_kind,\n+            krate: INTERNER.intern_str(self.krate),\n+        });\n+    }\n+}\n+\n+\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Crate {\n     compiler: Compiler,\n     target: Interned<String>,\n     mode: Mode,\n     test_kind: TestKind,\n-    krate: Option<Interned<String>>,\n+    krate: Interned<String>,\n }\n \n impl Step for Crate {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.krate(\"std\").krate(\"test\")\n+    fn should_run(mut run: ShouldRun) -> ShouldRun {\n+        let builder = run.builder;\n+        run = run.krate(\"test\");\n+        for krate in run.builder.in_tree_crates(\"std\") {\n+            if krate.is_local(&run.builder) &&\n+                !krate.name.contains(\"jemalloc\") &&\n+                !(krate.name.starts_with(\"rustc_\") && krate.name.ends_with(\"san\")) &&\n+                krate.name != \"dlmalloc\" {\n+                run = run.path(krate.local_path(&builder).to_str().unwrap());\n+            }\n+        }\n+        run\n     }\n \n     fn make_run(run: RunConfig) {\n         let builder = run.builder;\n         let compiler = builder.compiler(builder.top_stage, run.host);\n \n-        let make = |mode: Mode, name: Option<Interned<String>>| {\n+        let make = |mode: Mode, krate: &CargoCrate| {\n             let test_kind = if builder.kind == Kind::Test {\n                 TestKind::Test\n             } else if builder.kind == Kind::Bench {\n@@ -1190,29 +1282,24 @@ impl Step for Crate {\n                 target: run.target,\n                 mode,\n                 test_kind,\n-                krate: name,\n+                krate: krate.name,\n             });\n         };\n \n-        if let Some(path) = run.path {\n-            for (name, krate_path) in builder.crates(\"std\") {\n-                if path.ends_with(krate_path) {\n-                    make(Mode::Libstd, Some(name));\n-                }\n+        for krate in builder.in_tree_crates(\"std\") {\n+            if run.path.ends_with(&krate.local_path(&builder)) {\n+                make(Mode::Libstd, krate);\n             }\n-            for (name, krate_path) in builder.crates(\"test\") {\n-                if path.ends_with(krate_path) {\n-                    make(Mode::Libtest, Some(name));\n-                }\n+        }\n+        for krate in builder.in_tree_crates(\"test\") {\n+            if run.path.ends_with(&krate.local_path(&builder)) {\n+                make(Mode::Libtest, krate);\n             }\n-        } else {\n-            make(Mode::Libstd, None);\n-            make(Mode::Libtest, None);\n         }\n     }\n \n-    /// Run all unit tests plus documentation tests for an entire crate DAG defined\n-    /// by a `Cargo.toml`\n+    /// Run all unit tests plus documentation tests for a given crate defined\n+    /// by a `Cargo.toml` (single manifest)\n     ///\n     /// This is what runs tests for crates like the standard library, compiler, etc.\n     /// It essentially is the driver for running `cargo test`.\n@@ -1241,27 +1328,23 @@ impl Step for Crate {\n         };\n \n         let mut cargo = builder.cargo(compiler, mode, target, test_kind.subcommand());\n-        let (name, root) = match mode {\n+        match mode {\n             Mode::Libstd => {\n                 compile::std_cargo(build, &compiler, target, &mut cargo);\n-                (\"libstd\", \"std\")\n             }\n             Mode::Libtest => {\n                 compile::test_cargo(build, &compiler, target, &mut cargo);\n-                (\"libtest\", \"test\")\n             }\n             Mode::Librustc => {\n                 builder.ensure(compile::Rustc { compiler, target });\n                 compile::rustc_cargo(build, &mut cargo);\n-                (\"librustc\", \"rustc-main\")\n             }\n             _ => panic!(\"can only test libraries\"),\n         };\n-        let root = INTERNER.intern_string(String::from(root));\n         let _folder = build.fold_output(|| {\n-            format!(\"{}_stage{}-{}\", test_kind.subcommand(), compiler.stage, name)\n+            format!(\"{}_stage{}-{}\", test_kind.subcommand(), compiler.stage, krate)\n         });\n-        println!(\"{} {} stage{} ({} -> {})\", test_kind, name, compiler.stage,\n+        println!(\"{} {} stage{} ({} -> {})\", test_kind, krate, compiler.stage,\n                 &compiler.host, target);\n \n         // Build up the base `cargo test` command.\n@@ -1273,37 +1356,7 @@ impl Step for Crate {\n             cargo.arg(\"--no-fail-fast\");\n         }\n \n-        match krate {\n-            Some(krate) => {\n-                cargo.arg(\"-p\").arg(krate);\n-            }\n-            None => {\n-                let mut visited = HashSet::new();\n-                let mut next = vec![root];\n-                while let Some(name) = next.pop() {\n-                    // Right now jemalloc and the sanitizer crates are\n-                    // target-specific crate in the sense that it's not present\n-                    // on all platforms. Custom skip it here for now, but if we\n-                    // add more this probably wants to get more generalized.\n-                    //\n-                    // Also skip `build_helper` as it's not compiled normally\n-                    // for target during the bootstrap and it's just meant to be\n-                    // a helper crate, not tested. If it leaks through then it\n-                    // ends up messing with various mtime calculations and such.\n-                    if !name.contains(\"jemalloc\") &&\n-                       *name != *\"build_helper\" &&\n-                       !(name.starts_with(\"rustc_\") && name.ends_with(\"san\")) &&\n-                       name != \"dlmalloc\" {\n-                        cargo.arg(\"-p\").arg(&format!(\"{}:0.0.0\", name));\n-                    }\n-                    for dep in build.crates[&name].deps.iter() {\n-                        if visited.insert(dep) {\n-                            next.push(*dep);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n+        cargo.arg(\"-p\").arg(krate);\n \n         // The tests are going to run with the *target* libraries, so we need to\n         // ensure that those libraries show up in the LD_LIBRARY_PATH equivalent.\n@@ -1355,18 +1408,18 @@ impl Step for Crate {\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Rustdoc {\n+pub struct CrateRustdoc {\n     host: Interned<String>,\n     test_kind: TestKind,\n }\n \n-impl Step for Rustdoc {\n+impl Step for CrateRustdoc {\n     type Output = ();\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/librustdoc\").path(\"src/tools/rustdoc\")\n+        run.paths(&[\"src/librustdoc\", \"src/tools/rustdoc\"])\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -1380,7 +1433,7 @@ impl Step for Rustdoc {\n             panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n         };\n \n-        builder.ensure(Rustdoc {\n+        builder.ensure(CrateRustdoc {\n             host: run.host,\n             test_kind,\n         });"}, {"sha": "5c7f8ef73217f62141e5afb84998a98b4db0b0cc", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -805,22 +805,7 @@ impl<T> Vec<T> {\n     pub fn retain<F>(&mut self, mut f: F)\n         where F: FnMut(&T) -> bool\n     {\n-        let len = self.len();\n-        let mut del = 0;\n-        {\n-            let v = &mut **self;\n-\n-            for i in 0..len {\n-                if !f(&v[i]) {\n-                    del += 1;\n-                } else if del > 0 {\n-                    v.swap(i - del, i);\n-                }\n-            }\n-        }\n-        if del > 0 {\n-            self.truncate(len - del);\n-        }\n+        self.drain_filter(|x| !f(x));\n     }\n \n     /// Removes all but the first of consecutive elements in the vector that resolve to the same"}, {"sha": "266ea0740a5bdd262a38bbd88fb55fc3d2a7a96e", "filename": "src/libcompiler_builtins", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -1 +1 @@\n-Subproject commit 345447948f7a51eca970fa036cefd613d54a4f79\n+Subproject commit 266ea0740a5bdd262a38bbd88fb55fc3d2a7a96e"}, {"sha": "1a2da83429af9ef160021d984ef5787cade8ae9f", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -333,6 +333,8 @@ pub use self::range::Step;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::sources::{Repeat, repeat};\n+#[unstable(feature = \"iterator_repeat_with\", issue = \"48169\")]\n+pub use self::sources::{RepeatWith, repeat_with};\n #[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n pub use self::sources::{Empty, empty};\n #[stable(feature = \"iter_once\", since = \"1.2.0\")]\n@@ -593,15 +595,15 @@ impl<'a, I, T: 'a> FusedIterator for Cloned<I>\n {}\n \n #[doc(hidden)]\n-default unsafe impl<'a, I, T: 'a> TrustedRandomAccess for Cloned<I>\n+unsafe impl<'a, I, T: 'a> TrustedRandomAccess for Cloned<I>\n     where I: TrustedRandomAccess<Item=&'a T>, T: Clone\n {\n-    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n+    default unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n         self.it.get_unchecked(i).clone()\n     }\n \n     #[inline]\n-    fn may_have_side_effect() -> bool { true }\n+    default fn may_have_side_effect() -> bool { true }\n }\n \n #[doc(hidden)]"}, {"sha": "3e9d799c089486b95c78cb022f834d4f521379bb", "filename": "src/libcore/iter/sources.rs", "status": "modified", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibcore%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibcore%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fsources.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -57,6 +57,12 @@ unsafe impl<A: Clone> TrustedLen for Repeat<A> {}\n ///\n /// [`take`]: trait.Iterator.html#method.take\n ///\n+/// If the element type of the iterator you need does not implement `Clone`,\n+/// or if you do not want to keep the repeated element in memory, you can\n+/// instead use the [`repeat_with`] function.\n+///\n+/// [`repeat_with`]: fn.repeat_with.html\n+///\n /// # Examples\n ///\n /// Basic usage:\n@@ -99,6 +105,115 @@ pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n     Repeat{element: elt}\n }\n \n+/// An iterator that repeats elements of type `A` endlessly by\n+/// applying the provided closure `F: FnMut() -> A`.\n+///\n+/// This `struct` is created by the [`repeat_with`] function.\n+/// See its documentation for more.\n+///\n+/// [`repeat_with`]: fn.repeat_with.html\n+#[derive(Copy, Clone, Debug)]\n+#[unstable(feature = \"iterator_repeat_with\", issue = \"48169\")]\n+pub struct RepeatWith<F> {\n+    repeater: F\n+}\n+\n+#[unstable(feature = \"iterator_repeat_with\", issue = \"48169\")]\n+impl<A, F: FnMut() -> A> Iterator for RepeatWith<F> {\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> { Some((self.repeater)()) }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) { (usize::MAX, None) }\n+}\n+\n+#[unstable(feature = \"iterator_repeat_with\", issue = \"48169\")]\n+impl<A, F: FnMut() -> A> DoubleEndedIterator for RepeatWith<F> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> { self.next() }\n+}\n+\n+#[unstable(feature = \"fused\", issue = \"35602\")]\n+impl<A, F: FnMut() -> A> FusedIterator for RepeatWith<F> {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<A, F: FnMut() -> A> TrustedLen for RepeatWith<F> {}\n+\n+/// Creates a new iterator that repeats elements of type `A` endlessly by\n+/// applying the provided closure, the repeater, `F: FnMut() -> A`.\n+///\n+/// The `repeat_with()` function calls the repeater over and over and over and\n+/// over and over and \ud83d\udd01.\n+///\n+/// Infinite iterators like `repeat_with()` are often used with adapters like\n+/// [`take`], in order to make them finite.\n+///\n+/// [`take`]: trait.Iterator.html#method.take\n+///\n+/// If the element type of the iterator you need implements `Clone`, and\n+/// it is OK to keep the source element in memory, you should instead use\n+/// the [`repeat`] function.\n+///\n+/// [`repeat`]: fn.repeat.html\n+///\n+/// An iterator produced by `repeat_with()` is a `DoubleEndedIterator`.\n+/// It is important to not that reversing `repeat_with(f)` will produce\n+/// the exact same sequence as the non-reversed iterator. In other words,\n+/// `repeat_with(f).rev().collect::<Vec<_>>()` is equivalent to\n+/// `repeat_with(f).collect::<Vec<_>>()`.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// #![feature(iterator_repeat_with)]\n+///\n+/// use std::iter;\n+///\n+/// // let's assume we have some value of a type that is not `Clone`\n+/// // or which don't want to have in memory just yet because it is expensive:\n+/// #[derive(PartialEq, Debug)]\n+/// struct Expensive;\n+///\n+/// // a particular value forever:\n+/// let mut things = iter::repeat_with(|| Expensive);\n+///\n+/// assert_eq!(Some(Expensive), things.next());\n+/// assert_eq!(Some(Expensive), things.next());\n+/// assert_eq!(Some(Expensive), things.next());\n+/// assert_eq!(Some(Expensive), things.next());\n+/// assert_eq!(Some(Expensive), things.next());\n+/// ```\n+///\n+/// Using mutation and going finite:\n+///\n+/// ```rust\n+/// #![feature(iterator_repeat_with)]\n+///\n+/// use std::iter;\n+///\n+/// // From the zeroth to the third power of two:\n+/// let mut curr = 1;\n+/// let mut pow2 = iter::repeat_with(|| { let tmp = curr; curr *= 2; tmp })\n+///                     .take(4);\n+///\n+/// assert_eq!(Some(1), pow2.next());\n+/// assert_eq!(Some(2), pow2.next());\n+/// assert_eq!(Some(4), pow2.next());\n+/// assert_eq!(Some(8), pow2.next());\n+///\n+/// // ... and now we're done\n+/// assert_eq!(None, pow2.next());\n+/// ```\n+#[inline]\n+#[unstable(feature = \"iterator_repeat_with\", issue = \"48169\")]\n+pub fn repeat_with<A, F: FnMut() -> A>(repeater: F) -> RepeatWith<F> {\n+    RepeatWith { repeater }\n+}\n+\n /// An iterator that yields nothing.\n ///\n /// This `struct` is created by the [`empty`] function. See its documentation for more."}, {"sha": "860742d9eab6047b3fc6ff0510401d33cfdda949", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -706,7 +706,7 @@ pub trait ExactSizeIterator: Iterator {\n     /// ```\n     /// #![feature(exact_size_is_empty)]\n     ///\n-    /// let mut one_element = 0..1;\n+    /// let mut one_element = std::iter::once(0);\n     /// assert!(!one_element.is_empty());\n     ///\n     /// assert_eq!(one_element.next(), Some(0));"}, {"sha": "447e144bf0fd6083b43a7ec4f4a99284994d18da", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -92,6 +92,7 @@\n #![feature(unwind_attributes)]\n #![feature(doc_spotlight)]\n #![feature(rustc_const_unstable)]\n+#![feature(iterator_repeat_with)]\n \n #[prelude_import]\n #[allow(unused)]"}, {"sha": "98e0f71eb935679b9ca97b4aab715b7c534305e2", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -63,9 +63,13 @@ impl<T: ?Sized> !Send for *mut T { }\n /// struct BarUse(Bar<[i32]>); // OK\n /// ```\n ///\n-/// The one exception is the implicit `Self` type of a trait, which does not\n-/// get an implicit `Sized` bound. This is because a `Sized` bound prevents\n-/// the trait from being used to form a [trait object]:\n+/// The one exception is the implicit `Self` type of a trait. A trait does not\n+/// have an implicit `Sized` bound as this is incompatible with [trait object]s\n+/// where, by definition, the trait needs to work with all possible implementors,\n+/// and thus could be any size.\n+///\n+/// Although Rust will let you bind `Sized` to a trait, you won't\n+/// be able to use it to form a trait object later:\n ///\n /// ```\n /// # #![allow(unused_variables)]"}, {"sha": "21d4a486b983313cf407a9efe2cb282a2e7369f0", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -2881,7 +2881,7 @@ pub enum FpCategory {\n            issue = \"32110\")]\n pub trait Float: Sized {\n     /// Type used by `to_bits` and `from_bits`.\n-    #[stable(feature = \"core_float_bits\", since = \"1.24.0\")]\n+    #[stable(feature = \"core_float_bits\", since = \"1.25.0\")]\n     type Bits;\n \n     /// Returns `true` if this value is NaN and false otherwise.\n@@ -2947,10 +2947,10 @@ pub trait Float: Sized {\n     fn min(self, other: Self) -> Self;\n \n     /// Raw transmutation to integer.\n-    #[stable(feature = \"core_float_bits\", since=\"1.24.0\")]\n+    #[stable(feature = \"core_float_bits\", since=\"1.25.0\")]\n     fn to_bits(self) -> Self::Bits;\n     /// Raw transmutation from integer.\n-    #[stable(feature = \"core_float_bits\", since=\"1.24.0\")]\n+    #[stable(feature = \"core_float_bits\", since=\"1.25.0\")]\n     fn from_bits(v: Self::Bits) -> Self;\n }\n "}, {"sha": "1d9c0f873b34a2baa51e2b0460d6540345818e7a", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 81, "deletions": 9, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -60,19 +60,19 @@ impl fmt::Debug for RangeFull {\n /// (`start..end`).\n ///\n /// The `Range` `start..end` contains all values with `x >= start` and\n-/// `x < end`.\n+/// `x < end`.  It is empty unless `start < end`.\n ///\n /// # Examples\n ///\n /// ```\n /// assert_eq!((3..5), std::ops::Range { start: 3, end: 5 });\n /// assert_eq!(3 + 4 + 5, (3..6).sum());\n ///\n-/// let arr = [0, 1, 2, 3];\n-/// assert_eq!(arr[ .. ], [0,1,2,3]);\n-/// assert_eq!(arr[ ..3], [0,1,2  ]);\n-/// assert_eq!(arr[1.. ], [  1,2,3]);\n-/// assert_eq!(arr[1..3], [  1,2  ]);  // Range\n+/// let arr = ['a', 'b', 'c', 'd'];\n+/// assert_eq!(arr[ .. ], ['a', 'b', 'c', 'd']);\n+/// assert_eq!(arr[ ..3], ['a', 'b', 'c',    ]);\n+/// assert_eq!(arr[1.. ], [     'b', 'c', 'd']);\n+/// assert_eq!(arr[1..3], [     'b', 'c'     ]);  // Range\n /// ```\n #[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -92,7 +92,6 @@ impl<Idx: fmt::Debug> fmt::Debug for Range<Idx> {\n     }\n }\n \n-#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n impl<Idx: PartialOrd<Idx>> Range<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///\n@@ -109,9 +108,37 @@ impl<Idx: PartialOrd<Idx>> Range<Idx> {\n     /// assert!(!(3..3).contains(3));\n     /// assert!(!(3..2).contains(3));\n     /// ```\n+    #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n     pub fn contains(&self, item: Idx) -> bool {\n         (self.start <= item) && (item < self.end)\n     }\n+\n+    /// Returns `true` if the range contains no items.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(range_is_empty)]\n+    ///\n+    /// assert!(!(3..5).is_empty());\n+    /// assert!( (3..3).is_empty());\n+    /// assert!( (3..2).is_empty());\n+    /// ```\n+    ///\n+    /// The range is empty if either side is incomparable:\n+    ///\n+    /// ```\n+    /// #![feature(range_is_empty,inclusive_range_syntax)]\n+    ///\n+    /// use std::f32::NAN;\n+    /// assert!(!(3.0..5.0).is_empty());\n+    /// assert!( (3.0..NAN).is_empty());\n+    /// assert!( (NAN..5.0).is_empty());\n+    /// ```\n+    #[unstable(feature = \"range_is_empty\", reason = \"recently added\", issue = \"48111\")]\n+    pub fn is_empty(&self) -> bool {\n+        !(self.start < self.end)\n+    }\n }\n \n /// A range only bounded inclusively below (`start..`).\n@@ -244,7 +271,14 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n /// An range bounded inclusively below and above (`start..=end`).\n ///\n /// The `RangeInclusive` `start..=end` contains all values with `x >= start`\n-/// and `x <= end`.\n+/// and `x <= end`.  It is empty unless `start <= end`.\n+///\n+/// This iterator is [fused], but the specific values of `start` and `end` after\n+/// iteration has finished are **unspecified** other than that [`.is_empty()`]\n+/// will return `true` once no more values will be produced.\n+///\n+/// [fused]: ../iter/trait.FusedIterator.html\n+/// [`.is_empty()`]: #method.is_empty\n ///\n /// # Examples\n ///\n@@ -280,7 +314,6 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n     }\n }\n \n-#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///\n@@ -298,9 +331,48 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// assert!( (3..=3).contains(3));\n     /// assert!(!(3..=2).contains(3));\n     /// ```\n+    #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n     pub fn contains(&self, item: Idx) -> bool {\n         self.start <= item && item <= self.end\n     }\n+\n+    /// Returns `true` if the range contains no items.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(range_is_empty,inclusive_range_syntax)]\n+    ///\n+    /// assert!(!(3..=5).is_empty());\n+    /// assert!(!(3..=3).is_empty());\n+    /// assert!( (3..=2).is_empty());\n+    /// ```\n+    ///\n+    /// The range is empty if either side is incomparable:\n+    ///\n+    /// ```\n+    /// #![feature(range_is_empty,inclusive_range_syntax)]\n+    ///\n+    /// use std::f32::NAN;\n+    /// assert!(!(3.0..=5.0).is_empty());\n+    /// assert!( (3.0..=NAN).is_empty());\n+    /// assert!( (NAN..=5.0).is_empty());\n+    /// ```\n+    ///\n+    /// This method returns `true` after iteration has finished:\n+    ///\n+    /// ```\n+    /// #![feature(range_is_empty,inclusive_range_syntax)]\n+    ///\n+    /// let mut r = 3..=5;\n+    /// for _ in r.by_ref() {}\n+    /// // Precise field values are unspecified here\n+    /// assert!(r.is_empty());\n+    /// ```\n+    #[unstable(feature = \"range_is_empty\", reason = \"recently added\", issue = \"48111\")]\n+    pub fn is_empty(&self) -> bool {\n+        !(self.start <= self.end)\n+    }\n }\n \n /// A range only bounded inclusively above (`..=end`)."}, {"sha": "b266771b818e5b71d5627ba3f4641216e402359a", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -2573,7 +2573,7 @@ impl<T: ?Sized> Clone for NonNull<T> {\n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n impl<T: ?Sized> Copy for NonNull<T> { }\n \n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n impl<T: ?Sized, U: ?Sized> CoerceUnsized<NonNull<U>> for NonNull<T> where T: Unsize<U> { }\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n@@ -2621,7 +2621,7 @@ impl<T: ?Sized> hash::Hash for NonNull<T> {\n     }\n }\n \n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n impl<T: ?Sized> From<Unique<T>> for NonNull<T> {\n     fn from(unique: Unique<T>) -> Self {\n         NonNull { pointer: unique.pointer }"}, {"sha": "ac390313a6797a8e9470efe0d9de8ff7e372134f", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -1246,15 +1246,18 @@ macro_rules! iterator {\n             {\n                 // The addition might panic on overflow\n                 // Use the len of the slice to hint optimizer to remove result index bounds check.\n-                let n = make_slice!(self.ptr, self.end).len();\n+                let _n = make_slice!(self.ptr, self.end).len();\n                 self.try_fold(0, move |i, x| {\n                     if predicate(x) { Err(i) }\n                     else { Ok(i + 1) }\n                 }).err()\n-                    .map(|i| {\n-                        unsafe { assume(i < n) };\n-                        i\n-                    })\n+                    // // FIXME(#48116/#45964):\n+                    // // This assume() causes misoptimization on LLVM 6.\n+                    // // Commented out until it is fixed again.\n+                    // .map(|i| {\n+                    //     unsafe { assume(i < n) };\n+                    //     i\n+                    // })\n             }\n \n             #[inline]\n@@ -1271,10 +1274,13 @@ macro_rules! iterator {\n                     if predicate(x) { Err(i) }\n                     else { Ok(i) }\n                 }).err()\n-                    .map(|i| {\n-                        unsafe { assume(i < n) };\n-                        i\n-                    })\n+                    // // FIXME(#48116/#45964):\n+                    // // This assume() causes misoptimization on LLVM 6.\n+                    // // Commented out until it is fixed again.\n+                    // .map(|i| {\n+                    //     unsafe { assume(i < n) };\n+                    //     i\n+                    // })\n             }\n         }\n "}, {"sha": "f91c919d7447d6111d258a79532d6ef8fd8c29e1", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 97, "deletions": 9, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -1322,42 +1322,84 @@ fn test_range() {\n                (isize::MAX as usize + 2, Some(isize::MAX as usize + 2)));\n }\n \n+#[test]\n+fn test_range_exhaustion() {\n+    let mut r = 10..10;\n+    assert!(r.is_empty());\n+    assert_eq!(r.next(), None);\n+    assert_eq!(r.next_back(), None);\n+    assert_eq!(r, 10..10);\n+\n+    let mut r = 10..12;\n+    assert_eq!(r.next(), Some(10));\n+    assert_eq!(r.next(), Some(11));\n+    assert!(r.is_empty());\n+    assert_eq!(r, 12..12);\n+    assert_eq!(r.next(), None);\n+\n+    let mut r = 10..12;\n+    assert_eq!(r.next_back(), Some(11));\n+    assert_eq!(r.next_back(), Some(10));\n+    assert!(r.is_empty());\n+    assert_eq!(r, 10..10);\n+    assert_eq!(r.next_back(), None);\n+\n+    let mut r = 100..10;\n+    assert!(r.is_empty());\n+    assert_eq!(r.next(), None);\n+    assert_eq!(r.next_back(), None);\n+    assert_eq!(r, 100..10);\n+}\n+\n #[test]\n fn test_range_inclusive_exhaustion() {\n     let mut r = 10..=10;\n     assert_eq!(r.next(), Some(10));\n-    assert_eq!(r, 1..=0);\n+    assert!(r.is_empty());\n+    assert_eq!(r.next(), None);\n+    assert_eq!(r.next(), None);\n \n     let mut r = 10..=10;\n     assert_eq!(r.next_back(), Some(10));\n-    assert_eq!(r, 1..=0);\n+    assert!(r.is_empty());\n+    assert_eq!(r.next_back(), None);\n \n     let mut r = 10..=12;\n     assert_eq!(r.next(), Some(10));\n     assert_eq!(r.next(), Some(11));\n     assert_eq!(r.next(), Some(12));\n-    assert_eq!(r, 1..=0);\n+    assert!(r.is_empty());\n+    assert_eq!(r.next(), None);\n \n     let mut r = 10..=12;\n     assert_eq!(r.next_back(), Some(12));\n     assert_eq!(r.next_back(), Some(11));\n     assert_eq!(r.next_back(), Some(10));\n-    assert_eq!(r, 1..=0);\n+    assert!(r.is_empty());\n+    assert_eq!(r.next_back(), None);\n \n     let mut r = 10..=12;\n     assert_eq!(r.nth(2), Some(12));\n-    assert_eq!(r, 1..=0);\n+    assert!(r.is_empty());\n+    assert_eq!(r.next(), None);\n \n     let mut r = 10..=12;\n     assert_eq!(r.nth(5), None);\n-    assert_eq!(r, 1..=0);\n+    assert!(r.is_empty());\n+    assert_eq!(r.next(), None);\n \n     let mut r = 100..=10;\n     assert_eq!(r.next(), None);\n+    assert!(r.is_empty());\n+    assert_eq!(r.next(), None);\n+    assert_eq!(r.next(), None);\n     assert_eq!(r, 100..=10);\n \n     let mut r = 100..=10;\n     assert_eq!(r.next_back(), None);\n+    assert!(r.is_empty());\n+    assert_eq!(r.next_back(), None);\n+    assert_eq!(r.next_back(), None);\n     assert_eq!(r, 100..=10);\n }\n \n@@ -1428,9 +1470,10 @@ fn test_range_inclusive_nth() {\n     assert_eq!(r.nth(2), Some(15));\n     assert_eq!(r, 16..=20);\n     assert_eq!(r.is_empty(), false);\n+    assert_eq!(ExactSizeIterator::is_empty(&r), false);\n     assert_eq!(r.nth(10), None);\n     assert_eq!(r.is_empty(), true);\n-    assert_eq!(r, 1..=0);  // We may not want to document/promise this detail\n+    assert_eq!(ExactSizeIterator::is_empty(&r), true);\n }\n \n #[test]\n@@ -1514,11 +1557,11 @@ fn test_range_inclusive_folds() {\n \n     let mut it = 10..=20;\n     assert_eq!(it.try_fold(0, |a,b| Some(a+b)), Some(165));\n-    assert_eq!(it, 1..=0);\n+    assert!(it.is_empty());\n \n     let mut it = 10..=20;\n     assert_eq!(it.try_rfold(0, |a,b| Some(a+b)), Some(165));\n-    assert_eq!(it, 1..=0);\n+    assert!(it.is_empty());\n }\n \n #[test]\n@@ -1549,6 +1592,51 @@ fn test_repeat_take_collect() {\n     assert_eq!(v, vec![42, 42, 42]);\n }\n \n+#[test]\n+fn test_repeat_with() {\n+    #[derive(PartialEq, Debug)]\n+    struct NotClone(usize);\n+    let mut it = repeat_with(|| NotClone(42));\n+    assert_eq!(it.next(), Some(NotClone(42)));\n+    assert_eq!(it.next(), Some(NotClone(42)));\n+    assert_eq!(it.next(), Some(NotClone(42)));\n+    assert_eq!(repeat_with(|| NotClone(42)).size_hint(), (usize::MAX, None));\n+}\n+\n+#[test]\n+fn test_repeat_with_rev() {\n+    let mut curr = 1;\n+    let mut pow2 = repeat_with(|| { let tmp = curr; curr *= 2; tmp })\n+                    .rev().take(4);\n+    assert_eq!(pow2.next(), Some(1));\n+    assert_eq!(pow2.next(), Some(2));\n+    assert_eq!(pow2.next(), Some(4));\n+    assert_eq!(pow2.next(), Some(8));\n+    assert_eq!(pow2.next(), None);\n+}\n+\n+#[test]\n+fn test_repeat_with_take() {\n+    let mut it = repeat_with(|| 42).take(3);\n+    assert_eq!(it.next(), Some(42));\n+    assert_eq!(it.next(), Some(42));\n+    assert_eq!(it.next(), Some(42));\n+    assert_eq!(it.next(), None);\n+    is_trusted_len(repeat_with(|| 42).take(3));\n+    assert_eq!(repeat_with(|| 42).take(3).size_hint(), (3, Some(3)));\n+    assert_eq!(repeat_with(|| 42).take(0).size_hint(), (0, Some(0)));\n+    assert_eq!(repeat_with(|| 42).take(usize::MAX).size_hint(),\n+               (usize::MAX, Some(usize::MAX)));\n+}\n+\n+#[test]\n+fn test_repeat_with_take_collect() {\n+    let mut curr = 1;\n+    let v: Vec<_> = repeat_with(|| { let tmp = curr; curr *= 2; tmp })\n+                      .take(5).collect();\n+    assert_eq!(v, vec![1, 2, 4, 8, 16]);\n+}\n+\n #[test]\n fn test_fuse() {\n     let mut it = 0..3;"}, {"sha": "3e901a9d442ce29bc8460e2c582fa417c859b93e", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -27,8 +27,10 @@\n #![feature(iterator_try_fold)]\n #![feature(iter_rfind)]\n #![feature(iter_rfold)]\n+#![feature(iterator_repeat_with)]\n #![feature(nonzero)]\n #![feature(pattern)]\n+#![feature(range_is_empty)]\n #![feature(raw)]\n #![feature(refcell_replace_swap)]\n #![feature(sip_hash_13)]"}, {"sha": "bed08f86d72c124e4851f46364ddaf4eaee80b74", "filename": "src/libcore/tests/ops.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibcore%2Ftests%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibcore%2Ftests%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fops.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -68,3 +68,27 @@ fn test_range_inclusive() {\n     assert_eq!(r.size_hint(), (0, Some(0)));\n     assert_eq!(r.next(), None);\n }\n+\n+\n+#[test]\n+fn test_range_is_empty() {\n+    use core::f32::*;\n+\n+    assert!(!(0.0 .. 10.0).is_empty());\n+    assert!( (-0.0 .. 0.0).is_empty());\n+    assert!( (10.0 .. 0.0).is_empty());\n+\n+    assert!(!(NEG_INFINITY .. INFINITY).is_empty());\n+    assert!( (EPSILON .. NAN).is_empty());\n+    assert!( (NAN .. EPSILON).is_empty());\n+    assert!( (NAN .. NAN).is_empty());\n+\n+    assert!(!(0.0 ..= 10.0).is_empty());\n+    assert!(!(-0.0 ..= 0.0).is_empty());\n+    assert!( (10.0 ..= 0.0).is_empty());\n+\n+    assert!(!(NEG_INFINITY ..= INFINITY).is_empty());\n+    assert!( (EPSILON ..= NAN).is_empty());\n+    assert!( (NAN ..= EPSILON).is_empty());\n+    assert!( (NAN ..= NAN).is_empty());\n+}"}, {"sha": "b8d0719b9b992b565daf45d68b161b9e68dfff87", "filename": "src/libcore/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibcore%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibcore%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftime.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -7,7 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![stable(feature = \"duration_core\", since = \"1.24.0\")]\n+#![stable(feature = \"duration_core\", since = \"1.25.0\")]\n \n //! Temporal quantification.\n //!\n@@ -58,7 +58,7 @@ const MICROS_PER_SEC: u64 = 1_000_000;\n ///\n /// let ten_millis = Duration::from_millis(10);\n /// ```\n-#[stable(feature = \"duration_core\", since = \"1.24.0\")]\n+#[stable(feature = \"duration\", since = \"1.3.0\")]\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash, Default)]\n pub struct Duration {\n     secs: u64,"}, {"sha": "99b1e5783e01e18f698307b13181978f3bc23c53", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -9,14 +9,15 @@\n // except according to those terms.\n \n use super::*;\n-\n use dep_graph::{DepGraph, DepKind, DepNodeIndex};\n+use hir::def_id::{LOCAL_CRATE, CrateNum};\n use hir::intravisit::{Visitor, NestedVisitorMap};\n use hir::svh::Svh;\n use middle::cstore::CrateStore;\n use session::CrateDisambiguator;\n use std::iter::repeat;\n use syntax::ast::{NodeId, CRATE_NODE_ID};\n+use syntax::codemap::CodeMap;\n use syntax_pos::Span;\n \n use ich::StableHashingContext;\n@@ -123,6 +124,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n     pub(super) fn finalize_and_compute_crate_hash(self,\n                                                   crate_disambiguator: CrateDisambiguator,\n                                                   cstore: &CrateStore,\n+                                                  codemap: &CodeMap,\n                                                   commandline_args_hash: u64)\n                                                   -> (Vec<MapEntry<'hir>>, Svh) {\n         let mut node_hashes: Vec<_> = self\n@@ -147,11 +149,25 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             (name1, dis1).cmp(&(name2, dis2))\n         });\n \n+        // We hash the final, remapped names of all local source files so we\n+        // don't have to include the path prefix remapping commandline args.\n+        // If we included the full mapping in the SVH, we could only have\n+        // reproducible builds by compiling from the same directory. So we just\n+        // hash the result of the mapping instead of the mapping itself.\n+        let mut source_file_names: Vec<_> = codemap\n+            .files()\n+            .iter()\n+            .filter(|filemap| CrateNum::from_u32(filemap.crate_of_origin) == LOCAL_CRATE)\n+            .map(|filemap| filemap.name_hash)\n+            .collect();\n+\n+        source_file_names.sort_unstable();\n+\n         let (_, crate_dep_node_index) = self\n             .dep_graph\n             .with_task(DepNode::new_no_params(DepKind::Krate),\n                        &self.hcx,\n-                       ((node_hashes, upstream_crates),\n+                       (((node_hashes, upstream_crates), source_file_names),\n                         (commandline_args_hash,\n                          crate_disambiguator.to_fingerprint())),\n                        identity_fn);"}, {"sha": "b6b3e8955351c48a4a6d7db511e8fd7985162dd2", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -1065,6 +1065,7 @@ pub fn map_crate<'hir>(sess: &::session::Session,\n         let cmdline_args = sess.opts.dep_tracking_hash();\n         collector.finalize_and_compute_crate_hash(crate_disambiguator,\n                                                   cstore,\n+                                                  sess.codemap(),\n                                                   cmdline_args)\n     };\n "}, {"sha": "cfbf233297cf82d32fa4e656232b1d52b86ebac1", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -1269,9 +1269,9 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"set the optimization fuel quota for a crate\"),\n     print_fuel: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"make Rustc print the total optimization fuel used by a crate\"),\n-    remap_path_prefix_from: Vec<PathBuf> = (vec![], parse_pathbuf_push, [TRACKED],\n+    remap_path_prefix_from: Vec<PathBuf> = (vec![], parse_pathbuf_push, [UNTRACKED],\n         \"add a source pattern to the file path remapping config\"),\n-    remap_path_prefix_to: Vec<PathBuf> = (vec![], parse_pathbuf_push, [TRACKED],\n+    remap_path_prefix_to: Vec<PathBuf> = (vec![], parse_pathbuf_push, [UNTRACKED],\n         \"add a mapping target to the file path remapping config\"),\n     force_unstable_if_unmarked: bool = (false, parse_bool, [TRACKED],\n         \"force all crates to be `rustc_private` unstable\"),\n@@ -1320,6 +1320,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"The epoch to build Rust with. Newer epochs may include features\n          that require breaking changes. The default epoch is 2015 (the first\n          epoch). Crates compiled with different epochs can be linked together.\"),\n+    run_dsymutil: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+          \"run `dsymutil` and delete intermediate object files\"),\n }\n \n pub fn default_lib_output() -> CrateType {\n@@ -1717,7 +1719,7 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n     }\n \n     let remap_path_prefix_sources = debugging_opts.remap_path_prefix_from.len();\n-    let remap_path_prefix_targets = debugging_opts.remap_path_prefix_from.len();\n+    let remap_path_prefix_targets = debugging_opts.remap_path_prefix_to.len();\n \n     if remap_path_prefix_targets < remap_path_prefix_sources {\n         for source in &debugging_opts.remap_path_prefix_from[remap_path_prefix_targets..] {"}, {"sha": "21ffe6b895e72cca62aefae16ae84a78a278fab1", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -78,6 +78,11 @@ pub use self::on_disk_cache::OnDiskCache;\n // a way that memoizes and does dep-graph tracking,\n // wrapping around the actual chain of providers that\n // the driver creates (using several `rustc_*` crates).\n+//\n+// The result of query must implement Clone. They must also implement ty::maps::values::Value\n+// which produces an appropiate error value if the query resulted in a query cycle.\n+// Queries marked with `fatal_cycle` do not need that implementation\n+// as they will raise an fatal error on query cycles instead.\n define_maps! { <'tcx>\n     /// Records the type of every item.\n     [] fn type_of: TypeOfItem(DefId) -> Ty<'tcx>,\n@@ -267,13 +272,13 @@ define_maps! { <'tcx>\n     [] fn dylib_dependency_formats: DylibDepFormats(CrateNum)\n                                     -> Rc<Vec<(CrateNum, LinkagePreference)>>,\n \n-    [] fn is_panic_runtime: IsPanicRuntime(CrateNum) -> bool,\n-    [] fn is_compiler_builtins: IsCompilerBuiltins(CrateNum) -> bool,\n-    [] fn has_global_allocator: HasGlobalAllocator(CrateNum) -> bool,\n-    [] fn is_sanitizer_runtime: IsSanitizerRuntime(CrateNum) -> bool,\n-    [] fn is_profiler_runtime: IsProfilerRuntime(CrateNum) -> bool,\n-    [] fn panic_strategy: GetPanicStrategy(CrateNum) -> PanicStrategy,\n-    [] fn is_no_builtins: IsNoBuiltins(CrateNum) -> bool,\n+    [fatal_cycle] fn is_panic_runtime: IsPanicRuntime(CrateNum) -> bool,\n+    [fatal_cycle] fn is_compiler_builtins: IsCompilerBuiltins(CrateNum) -> bool,\n+    [fatal_cycle] fn has_global_allocator: HasGlobalAllocator(CrateNum) -> bool,\n+    [fatal_cycle] fn is_sanitizer_runtime: IsSanitizerRuntime(CrateNum) -> bool,\n+    [fatal_cycle] fn is_profiler_runtime: IsProfilerRuntime(CrateNum) -> bool,\n+    [fatal_cycle] fn panic_strategy: GetPanicStrategy(CrateNum) -> PanicStrategy,\n+    [fatal_cycle] fn is_no_builtins: IsNoBuiltins(CrateNum) -> bool,\n \n     [] fn extern_crate: ExternCrate(DefId) -> Rc<Option<ExternCrate>>,\n "}, {"sha": "f02c7cbd0ea3e8dcf6d36bbd9201cd97e541a44c", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -183,6 +183,19 @@ macro_rules! profq_key {\n     }\n }\n \n+macro_rules! handle_cycle_error {\n+    ([][$this: expr]) => {{\n+        Value::from_cycle_error($this.global_tcx())\n+    }};\n+    ([fatal_cycle$(, $modifiers:ident)*][$this:expr]) => {{\n+        $this.tcx.sess.abort_if_errors();\n+        unreachable!();\n+    }};\n+    ([$other:ident$(, $modifiers:ident)*][$($args:tt)*]) => {\n+        handle_cycle_error!([$($modifiers),*][$($args)*])\n+    };\n+}\n+\n macro_rules! define_maps {\n     (<$tcx:tt>\n      $($(#[$attr:meta])*\n@@ -564,7 +577,7 @@ macro_rules! define_maps {\n             pub fn $name(self, key: $K) -> $V {\n                 queries::$name::try_get(self.tcx, self.span, key).unwrap_or_else(|mut e| {\n                     e.emit();\n-                    Value::from_cycle_error(self.global_tcx())\n+                    handle_cycle_error!([$($modifiers)*][self])\n                 })\n             })*\n         }\n@@ -583,7 +596,7 @@ macro_rules! define_maps {\n \n macro_rules! define_map_struct {\n     (tcx: $tcx:tt,\n-     input: ($(([$(modifiers:tt)*] [$($attr:tt)*] [$name:ident]))*)) => {\n+     input: ($(([$($modifiers:tt)*] [$($attr:tt)*] [$name:ident]))*)) => {\n         pub struct Maps<$tcx> {\n             providers: IndexVec<CrateNum, Providers<$tcx>>,\n             query_stack: RefCell<Vec<(Span, Query<$tcx>)>>,"}, {"sha": "961c2650afdefc995bc256deece40915defc071c", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -1297,6 +1297,13 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n+    pub fn is_ty_infer(&self) -> bool {\n+        match self.sty {\n+            TyInfer(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n     pub fn is_phantom_data(&self) -> bool {\n         if let TyAdt(def, _) = self.sty {\n             def.is_phantom_data()"}, {"sha": "b8a1fe99105406b63edbe42f6bb6e343a38578d6", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -660,6 +660,15 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n         disambiguator,\n     );\n \n+    if sess.opts.incremental.is_some() {\n+        time(time_passes, \"garbage collect incremental cache directory\", || {\n+            if let Err(e) = rustc_incremental::garbage_collect_session_directories(sess) {\n+                warn!(\"Error while trying to garbage collect incremental \\\n+                       compilation cache directory: {}\", e);\n+            }\n+        });\n+    }\n+\n     // If necessary, compute the dependency graph (in the background).\n     let future_dep_graph = if sess.opts.build_dep_graph() {\n         Some(rustc_incremental::load_dep_graph(sess, time_passes))"}, {"sha": "65fbd9d0bf8f1a213a02dbe72347c60a1c1def77", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -46,3 +46,4 @@ pub use persist::in_incr_comp_dir;\n pub use persist::prepare_session_directory;\n pub use persist::finalize_session_directory;\n pub use persist::delete_workproduct_files;\n+pub use persist::garbage_collect_session_directories;"}, {"sha": "795825f180c9dfdcb0658b1c2a1e6898043fff7a", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -603,7 +603,7 @@ fn timestamp_to_string(timestamp: SystemTime) -> String {\n }\n \n fn string_to_timestamp(s: &str) -> Result<SystemTime, ()> {\n-    let micros_since_unix_epoch = u64::from_str_radix(s, 36);\n+    let micros_since_unix_epoch = u64::from_str_radix(s, INT_ENCODE_BASE as u32);\n \n     if micros_since_unix_epoch.is_err() {\n         return Err(())\n@@ -733,6 +733,20 @@ pub fn garbage_collect_session_directories(sess: &Session) -> io::Result<()> {\n                                 })\n                                 .collect();\n \n+    // Delete all session directories that don't have a lock file.\n+    for directory_name in session_directories {\n+        if !lock_file_to_session_dir.values().any(|dir| *dir == directory_name) {\n+            let path = crate_directory.join(directory_name);\n+            if let Err(err) = safe_remove_dir_all(&path) {\n+                sess.warn(&format!(\"Failed to garbage collect invalid incremental \\\n+                                    compilation session directory `{}`: {}\",\n+                                    path.display(),\n+                                    err));\n+            }\n+        }\n+    }\n+\n+    // Now garbage collect the valid session directories.\n     let mut deletion_candidates = vec![];\n     let mut definitely_delete = vec![];\n "}, {"sha": "2f864aaefba89df6fb0a9075260e1ba0f8d53344", "filename": "src/librustc_incremental/persist/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -20,9 +20,10 @@ mod save;\n mod work_product;\n mod file_format;\n \n-pub use self::fs::prepare_session_directory;\n pub use self::fs::finalize_session_directory;\n+pub use self::fs::garbage_collect_session_directories;\n pub use self::fs::in_incr_comp_dir;\n+pub use self::fs::prepare_session_directory;\n pub use self::load::dep_graph_tcx_init;\n pub use self::load::load_dep_graph;\n pub use self::load::load_query_result_cache;"}, {"sha": "f734f3182a93139b29a84a249c251c59646e1837", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -11,6 +11,7 @@\n #![allow(non_snake_case)]\n \n use rustc::hir::def_id::DefId;\n+use rustc::hir::map as hir_map;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, AdtKind, Ty, TyCtxt};\n use rustc::ty::layout::{self, LayoutOf};\n@@ -176,6 +177,22 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                             _ => bug!(),\n                         };\n                         if lit_val < min || lit_val > max {\n+                            let parent_id = cx.tcx.hir.get_parent_node(e.id);\n+                            if let hir_map::NodeExpr(parent_expr) = cx.tcx.hir.get(parent_id) {\n+                                if let hir::ExprCast(..) = parent_expr.node {\n+                                    if let ty::TyChar = cx.tables.expr_ty(parent_expr).sty {\n+                                        let mut err = cx.struct_span_lint(\n+                                                             OVERFLOWING_LITERALS,\n+                                                             parent_expr.span,\n+                                                             \"only u8 can be casted into char\");\n+                                        err.span_suggestion(parent_expr.span,\n+                                                            &\"use a char literal instead\",\n+                                                            format!(\"'\\\\u{{{:X}}}'\", lit_val));\n+                                        err.emit();\n+                                        return\n+                                    }\n+                                }\n+                            }\n                             cx.span_lint(OVERFLOWING_LITERALS,\n                                          e.span,\n                                          &format!(\"literal out of range for {:?}\", t));"}, {"sha": "54e3f544acb68b0258186b0729245a02b324070a", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -155,6 +155,7 @@ fn main() {\n     cfg.file(\"../rustllvm/PassWrapper.cpp\")\n        .file(\"../rustllvm/RustWrapper.cpp\")\n        .file(\"../rustllvm/ArchiveWrapper.cpp\")\n+       .file(\"../rustllvm/Linker.cpp\")\n        .cpp(true)\n        .cpp_link_stdlib(None) // we handle this below\n        .compile(\"rustllvm\");"}, {"sha": "e71bef512cf067c84956d197d93394565fac9476", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -444,6 +444,9 @@ pub type RustArchiveMemberRef = *mut RustArchiveMember_opaque;\n #[allow(missing_copy_implementations)]\n pub enum OperandBundleDef_opaque {}\n pub type OperandBundleDefRef = *mut OperandBundleDef_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum Linker_opaque {}\n+pub type LinkerRef = *mut Linker_opaque;\n \n pub type DiagnosticHandler = unsafe extern \"C\" fn(DiagnosticInfoRef, *mut c_void);\n pub type InlineAsmDiagHandler = unsafe extern \"C\" fn(SMDiagnosticRef, *const c_void, c_uint);\n@@ -1608,7 +1611,6 @@ extern \"C\" {\n     pub fn LLVMRustPrintPasses();\n     pub fn LLVMRustSetNormalizedTarget(M: ModuleRef, triple: *const c_char);\n     pub fn LLVMRustAddAlwaysInlinePass(P: PassManagerBuilderRef, AddLifetimes: bool);\n-    pub fn LLVMRustLinkInExternalBitcode(M: ModuleRef, bc: *const c_char, len: size_t) -> bool;\n     pub fn LLVMRustRunRestrictionPass(M: ModuleRef, syms: *const *const c_char, len: size_t);\n     pub fn LLVMRustMarkAllFunctionsNounwind(M: ModuleRef);\n \n@@ -1724,4 +1726,10 @@ extern \"C\" {\n                                            CU2: *mut *mut c_void);\n     pub fn LLVMRustThinLTOPatchDICompileUnit(M: ModuleRef, CU: *mut c_void);\n     pub fn LLVMRustThinLTORemoveAvailableExternally(M: ModuleRef);\n+\n+    pub fn LLVMRustLinkerNew(M: ModuleRef) -> LinkerRef;\n+    pub fn LLVMRustLinkerAdd(linker: LinkerRef,\n+                             bytecode: *const c_char,\n+                             bytecode_len: usize) -> bool;\n+    pub fn LLVMRustLinkerFree(linker: LinkerRef);\n }"}, {"sha": "650f99828ae483592fc4b4fb9ab4f5158183be70", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 73, "deletions": 7, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -463,13 +463,20 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 target: _,\n                 unwind: _,\n             } => {\n-                self.access_place(\n-                    ContextKind::Drop.new(loc),\n-                    (drop_place, span),\n-                    (Deep, Write(WriteKind::StorageDeadOrDrop)),\n-                    LocalMutationIsAllowed::Yes,\n-                    flow_state,\n-                );\n+                let gcx = self.tcx.global_tcx();\n+\n+                // Compute the type with accurate region information.\n+                let drop_place_ty = drop_place.ty(self.mir, self.tcx);\n+\n+                // Erase the regions.\n+                let drop_place_ty = self.tcx.erase_regions(&drop_place_ty).to_ty(self.tcx);\n+\n+                // \"Lift\" into the gcx -- once regions are erased, this type should be in the\n+                // global arenas; this \"lift\" operation basically just asserts that is true, but\n+                // that is useful later.\n+                let drop_place_ty = gcx.lift(&drop_place_ty).unwrap();\n+\n+                self.visit_terminator_drop(loc, term, flow_state, drop_place, drop_place_ty, span);\n             }\n             TerminatorKind::DropAndReplace {\n                 location: ref drop_place,\n@@ -717,6 +724,65 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n              self.tcx.sess.opts.debugging_opts.two_phase_beyond_autoref)\n     }\n \n+    /// Invokes `access_place` as appropriate for dropping the value\n+    /// at `drop_place`. Note that the *actual* `Drop` in the MIR is\n+    /// always for a variable (e.g., `Drop(x)`) -- but we recursively\n+    /// break this variable down into subpaths (e.g., `Drop(x.foo)`)\n+    /// to indicate more precisely which fields might actually be\n+    /// accessed by a destructor.\n+    fn visit_terminator_drop(\n+        &mut self,\n+        loc: Location,\n+        term: &Terminator<'tcx>,\n+        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n+        drop_place: &Place<'tcx>,\n+        erased_drop_place_ty: ty::Ty<'gcx>,\n+        span: Span,\n+    ) {\n+        match erased_drop_place_ty.sty {\n+            // When a struct is being dropped, we need to check\n+            // whether it has a destructor, if it does, then we can\n+            // call it, if it does not then we need to check the\n+            // individual fields instead. This way if `foo` has a\n+            // destructor but `bar` does not, we will only check for\n+            // borrows of `x.foo` and not `x.bar`. See #47703.\n+            ty::TyAdt(def, substs) if def.is_struct() && !def.has_dtor(self.tcx) => {\n+                for (index, field) in def.all_fields().enumerate() {\n+                    let gcx = self.tcx.global_tcx();\n+                    let field_ty = field.ty(gcx, substs);\n+                    let field_ty = gcx.normalize_associated_type_in_env(&field_ty, self.param_env);\n+                    let place = drop_place.clone().field(Field::new(index), field_ty);\n+\n+                    self.visit_terminator_drop(\n+                        loc,\n+                        term,\n+                        flow_state,\n+                        &place,\n+                        field_ty,\n+                        span,\n+                    );\n+                }\n+            },\n+            _ => {\n+                // We have now refined the type of the value being\n+                // dropped (potentially) to just the type of a\n+                // subfield; so check whether that field's type still\n+                // \"needs drop\". If so, we assume that the destructor\n+                // may access any data it likes (i.e., a Deep Write).\n+                let gcx = self.tcx.global_tcx();\n+                if erased_drop_place_ty.needs_drop(gcx, self.param_env) {\n+                    self.access_place(\n+                        ContextKind::Drop.new(loc),\n+                        (drop_place, span),\n+                        (Deep, Write(WriteKind::StorageDeadOrDrop)),\n+                        LocalMutationIsAllowed::Yes,\n+                        flow_state,\n+                    );\n+                }\n+            },\n+        }\n+    }\n+\n     /// Checks an access to the given place to see if it is allowed. Examines the set of borrows\n     /// that are in scope, as well as which paths have been initialized, to ensure that (a) the\n     /// place is initialized and (b) it is not borrowed in some way that would prevent this"}, {"sha": "7cc4ba84895251ec5303a99e86882d8135a87f78", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -238,7 +238,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         self.tcx.data_layout.pointer_size.bytes()\n     }\n \n-    pub fn endianess(&self) -> layout::Endian {\n+    pub fn endianness(&self) -> layout::Endian {\n         self.tcx.data_layout.endian\n     }\n \n@@ -722,7 +722,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n \n     pub fn read_primval(&self, ptr: MemoryPointer, ptr_align: Align, size: u64, signed: bool) -> EvalResult<'tcx, PrimVal> {\n         self.check_relocation_edges(ptr, size)?; // Make sure we don't read part of a pointer as a pointer\n-        let endianess = self.endianess();\n+        let endianness = self.endianness();\n         let bytes = self.get_bytes_unchecked(ptr, size, ptr_align.min(self.int_align(size)))?;\n         // Undef check happens *after* we established that the alignment is correct.\n         // We must not return Ok() for unaligned pointers!\n@@ -731,9 +731,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         }\n         // Now we do the actual reading\n         let bytes = if signed {\n-            read_target_int(endianess, bytes).unwrap() as u128\n+            read_target_int(endianness, bytes).unwrap() as u128\n         } else {\n-            read_target_uint(endianess, bytes).unwrap()\n+            read_target_uint(endianness, bytes).unwrap()\n         };\n         // See if we got a pointer\n         if size != self.pointer_size() {\n@@ -756,7 +756,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     }\n \n     pub fn write_primval(&mut self, ptr: MemoryPointer, ptr_align: Align, val: PrimVal, size: u64, signed: bool) -> EvalResult<'tcx> {\n-        let endianess = self.endianess();\n+        let endianness = self.endianness();\n \n         let bytes = match val {\n             PrimVal::Ptr(val) => {\n@@ -788,9 +788,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             let align = self.int_align(size);\n             let dst = self.get_bytes_mut(ptr, size, ptr_align.min(align))?;\n             if signed {\n-                write_target_int(endianess, dst, bytes as i128).unwrap();\n+                write_target_int(endianness, dst, bytes as i128).unwrap();\n             } else {\n-                write_target_uint(endianess, dst, bytes).unwrap();\n+                write_target_uint(endianness, dst, bytes).unwrap();\n             }\n         }\n \n@@ -941,41 +941,41 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n-// Methods to access integers in the target endianess\n+// Methods to access integers in the target endianness\n ////////////////////////////////////////////////////////////////////////////////\n \n fn write_target_uint(\n-    endianess: layout::Endian,\n+    endianness: layout::Endian,\n     mut target: &mut [u8],\n     data: u128,\n ) -> Result<(), io::Error> {\n     let len = target.len();\n-    match endianess {\n+    match endianness {\n         layout::Endian::Little => target.write_uint128::<LittleEndian>(data, len),\n         layout::Endian::Big => target.write_uint128::<BigEndian>(data, len),\n     }\n }\n fn write_target_int(\n-    endianess: layout::Endian,\n+    endianness: layout::Endian,\n     mut target: &mut [u8],\n     data: i128,\n ) -> Result<(), io::Error> {\n     let len = target.len();\n-    match endianess {\n+    match endianness {\n         layout::Endian::Little => target.write_int128::<LittleEndian>(data, len),\n         layout::Endian::Big => target.write_int128::<BigEndian>(data, len),\n     }\n }\n \n-fn read_target_uint(endianess: layout::Endian, mut source: &[u8]) -> Result<u128, io::Error> {\n-    match endianess {\n+fn read_target_uint(endianness: layout::Endian, mut source: &[u8]) -> Result<u128, io::Error> {\n+    match endianness {\n         layout::Endian::Little => source.read_uint128::<LittleEndian>(source.len()),\n         layout::Endian::Big => source.read_uint128::<BigEndian>(source.len()),\n     }\n }\n \n-fn read_target_int(endianess: layout::Endian, mut source: &[u8]) -> Result<i128, io::Error> {\n-    match endianess {\n+fn read_target_int(endianness: layout::Endian, mut source: &[u8]) -> Result<i128, io::Error> {\n+    match endianness {\n         layout::Endian::Little => source.read_int128::<LittleEndian>(source.len()),\n         layout::Endian::Big => source.read_int128::<BigEndian>(source.len()),\n     }"}, {"sha": "7ed250e94c52f595a01df323c29251dfc1c35d7b", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -44,6 +44,7 @@ pub mod copy_prop;\n pub mod generator;\n pub mod inline;\n pub mod lower_128bit;\n+pub mod uniform_array_move_out;\n \n pub(crate) fn provide(providers: &mut Providers) {\n     self::qualify_consts::provide(providers);\n@@ -197,6 +198,7 @@ fn mir_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Stea\n         simplify::SimplifyCfg::new(\"initial\"),\n         type_check::TypeckMir,\n         rustc_peek::SanityCheck,\n+        uniform_array_move_out::UniformArrayMoveOut,\n     ];\n     tcx.alloc_steal_mir(mir)\n }\n@@ -253,6 +255,7 @@ fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n \n         lower_128bit::Lower128Bit,\n \n+\n         // Optimizations begin.\n         inline::Inline,\n         instcombine::InstCombine,"}, {"sha": "0db5ecf0eb2702f29a890313c3932e5e06514ed8", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -0,0 +1,153 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This pass converts move out from array by Subslice and\n+// ConstIndex{.., from_end: true} to ConstIndex move out(s) from begin\n+// of array. It allows detect error by mir borrowck and elaborate\n+// drops for array without additional work.\n+//\n+// Example:\n+//\n+// let a = [ box 1,box 2, box 3];\n+// if b {\n+//  let [_a.., _] = a;\n+// } else {\n+//  let [.., _b] = a;\n+// }\n+//\n+//  mir statement _10 = move _2[:-1]; replaced by:\n+//  StorageLive(_12);\n+//  _12 = move _2[0 of 3];\n+//  StorageLive(_13);\n+//  _13 = move _2[1 of 3];\n+//  _10 = [move _12, move _13]\n+//  StorageDead(_12);\n+//  StorageDead(_13);\n+//\n+//  and mir statement _11 = move _2[-1 of 1]; replaced by:\n+//  _11 = move _2[2 of 3];\n+//\n+// FIXME: convert to Subslice back for performance reason\n+// FIXME: integrate this transformation to the mir build\n+\n+use rustc::ty;\n+use rustc::ty::TyCtxt;\n+use rustc::mir::*;\n+use rustc::mir::visit::Visitor;\n+use transform::{MirPass, MirSource};\n+use util::patch::MirPatch;\n+\n+pub struct UniformArrayMoveOut;\n+\n+impl MirPass for UniformArrayMoveOut {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          _src: MirSource,\n+                          mir: &mut Mir<'tcx>) {\n+        let mut patch = MirPatch::new(mir);\n+        {\n+            let mut visitor = UniformArrayMoveOutVisitor{mir, patch: &mut patch, tcx};\n+            visitor.visit_mir(mir);\n+        }\n+        patch.apply(mir);\n+    }\n+}\n+\n+struct UniformArrayMoveOutVisitor<'a, 'tcx: 'a> {\n+    mir: &'a Mir<'tcx>,\n+    patch: &'a mut MirPatch<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for UniformArrayMoveOutVisitor<'a, 'tcx> {\n+    fn visit_statement(&mut self,\n+                       block: BasicBlock,\n+                       statement: &Statement<'tcx>,\n+                       location: Location) {\n+        if let StatementKind::Assign(ref dst_place,\n+                                     Rvalue::Use(Operand::Move(ref src_place))) = statement.kind {\n+            if let Place::Projection(ref proj) = *src_place {\n+                if let ProjectionElem::ConstantIndex{offset: _,\n+                                                     min_length: _,\n+                                                     from_end: false} = proj.elem {\n+                    // no need to transformation\n+                } else {\n+                    let place_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                    if let ty::TyArray(item_ty, const_size) = place_ty.sty {\n+                        if let Some(size) = const_size.val.to_const_int().and_then(|v| v.to_u64()) {\n+                            assert!(size <= (u32::max_value() as u64),\n+                                    \"unform array move out doesn't supported\n+                                     for array bigger then u32\");\n+                            self.uniform(location, dst_place, proj, item_ty, size as u32);\n+                        }\n+                    }\n+\n+                }\n+            }\n+        }\n+        return self.super_statement(block, statement, location);\n+    }\n+}\n+\n+impl<'a, 'tcx> UniformArrayMoveOutVisitor<'a, 'tcx> {\n+    fn uniform(&mut self,\n+               location: Location,\n+               dst_place: &Place<'tcx>,\n+               proj: &PlaceProjection<'tcx>,\n+               item_ty: &'tcx ty::TyS<'tcx>,\n+               size: u32) {\n+        match proj.elem {\n+            // uniform _10 = move _2[:-1];\n+            ProjectionElem::Subslice{from, to} => {\n+                self.patch.make_nop(location);\n+                let temps : Vec<_> = (from..(size-to)).map(|i| {\n+                    let temp = self.patch.new_temp(item_ty, self.mir.source_info(location).span);\n+                    self.patch.add_statement(location, StatementKind::StorageLive(temp));\n+                    self.patch.add_assign(location,\n+                                          Place::Local(temp),\n+                                          Rvalue::Use(\n+                                              Operand::Move(\n+                                                  Place::Projection(box PlaceProjection{\n+                                                      base: proj.base.clone(),\n+                                                      elem: ProjectionElem::ConstantIndex{\n+                                                          offset: i,\n+                                                          min_length: size,\n+                                                          from_end: false}\n+                                                  }))));\n+                    temp\n+                }).collect();\n+                self.patch.add_assign(location,\n+                                      dst_place.clone(),\n+                                      Rvalue::Aggregate(box AggregateKind::Array(item_ty),\n+                                      temps.iter().map(\n+                                          |x| Operand::Move(Place::Local(*x))).collect()\n+                                      ));\n+                for temp in temps {\n+                    self.patch.add_statement(location, StatementKind::StorageDead(temp));\n+                }\n+            }\n+            // _11 = move _2[-1 of 1];\n+            ProjectionElem::ConstantIndex{offset, min_length: _, from_end: true} => {\n+                self.patch.make_nop(location);\n+                self.patch.add_assign(location,\n+                                      dst_place.clone(),\n+                                      Rvalue::Use(\n+                                          Operand::Move(\n+                                              Place::Projection(box PlaceProjection{\n+                                                  base: proj.base.clone(),\n+                                                  elem: ProjectionElem::ConstantIndex{\n+                                                      offset: size - offset,\n+                                                      min_length: size,\n+                                                      from_end: false }}))));\n+            }\n+            _ => {}\n+        }\n+    }\n+}"}, {"sha": "f1bdcfcd22f935ade79d9c33c6595647ed88fec3", "filename": "src/librustc_mir/util/patch.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpatch.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -23,6 +23,7 @@ pub struct MirPatch<'tcx> {\n     new_locals: Vec<LocalDecl<'tcx>>,\n     resume_block: BasicBlock,\n     next_local: usize,\n+    make_nop: Vec<Location>,\n }\n \n impl<'tcx> MirPatch<'tcx> {\n@@ -33,7 +34,8 @@ impl<'tcx> MirPatch<'tcx> {\n             new_statements: vec![],\n             new_locals: vec![],\n             next_local: mir.local_decls.len(),\n-            resume_block: START_BLOCK\n+            resume_block: START_BLOCK,\n+            make_nop: vec![]\n         };\n \n         // make sure the MIR we create has a resume block. It is\n@@ -131,7 +133,15 @@ impl<'tcx> MirPatch<'tcx> {\n         self.add_statement(loc, StatementKind::Assign(place, rv));\n     }\n \n+    pub fn make_nop(&mut self, loc: Location) {\n+        self.make_nop.push(loc);\n+    }\n+\n     pub fn apply(self, mir: &mut Mir<'tcx>) {\n+        debug!(\"MirPatch: make nops at: {:?}\", self.make_nop);\n+        for loc in self.make_nop {\n+            mir.make_statement_nop(loc);\n+        }\n         debug!(\"MirPatch: {:?} new temps, starting from index {}: {:?}\",\n                self.new_locals.len(), mir.local_decls.len(), self.new_locals);\n         debug!(\"MirPatch: {} new blocks, starting from index {}\","}, {"sha": "a8070c553bdbcb34dd8bde7bf8435abc2d21ba12", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -1026,6 +1026,8 @@ fn import_path_to_string(names: &[SpannedIdent],\n         if names.is_empty() {\n             import_directive_subclass_to_string(subclass)\n         } else {\n+            // FIXME: Remove this entire logic after #48116 is fixed.\n+            //\n             // Note that this code looks a little wonky, it's currently here to\n             // hopefully help debug #48116, but otherwise isn't intended to\n             // cause any problems.\n@@ -1034,8 +1036,17 @@ fn import_path_to_string(names: &[SpannedIdent],\n                 names_to_string(names),\n                 import_directive_subclass_to_string(subclass),\n             );\n-            assert!(!names.is_empty());\n-            assert!(!x.starts_with(\"::\"));\n+            if names.is_empty() || x.starts_with(\"::\") {\n+                span_bug!(\n+                    span,\n+                    \"invalid name `{}` at {:?}; global = {}, names = {:?}, subclass = {:?}\",\n+                    x,\n+                    span,\n+                    global,\n+                    names,\n+                    subclass\n+                );\n+            }\n             return x\n         }\n     }"}, {"sha": "8309c91ab2573bcf4ee7f349cd9e7b45f79b3d05", "filename": "src/librustc_trans/attributes.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_trans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_trans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fattributes.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -142,7 +142,7 @@ pub fn provide(providers: &mut Providers) {\n         assert_eq!(cnum, LOCAL_CRATE);\n         Rc::new(llvm_util::target_feature_whitelist(tcx.sess)\n             .iter()\n-            .map(|c| c.to_str().unwrap().to_string())\n+            .map(|c| c.to_string())\n             .collect())\n     };\n \n@@ -212,7 +212,8 @@ fn from_target_feature(\n         let value = value.as_str();\n         for feature in value.split(',') {\n             if whitelist.contains(feature) {\n-                target_features.push(format!(\"+{}\", feature));\n+                let llvm_feature = llvm_util::to_llvm_feature(feature);\n+                target_features.push(format!(\"+{}\", llvm_feature));\n                 continue\n             }\n "}, {"sha": "4fe294a790fc4467edaedbd686672d48535e3f09", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 55, "deletions": 3, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -166,7 +166,9 @@ pub(crate) fn link_binary(sess: &Session,\n \n     // Remove the temporary object file and metadata if we aren't saving temps\n     if !sess.opts.cg.save_temps {\n-        if sess.opts.output_types.should_trans() {\n+        if sess.opts.output_types.should_trans() &&\n+            !preserve_objects_for_their_debuginfo(sess)\n+        {\n             for obj in trans.modules.iter().filter_map(|m| m.object.as_ref()) {\n                 remove(sess, obj);\n             }\n@@ -190,6 +192,52 @@ pub(crate) fn link_binary(sess: &Session,\n     out_filenames\n }\n \n+/// Returns a boolean indicating whether we should preserve the object files on\n+/// the filesystem for their debug information. This is often useful with\n+/// split-dwarf like schemes.\n+fn preserve_objects_for_their_debuginfo(sess: &Session) -> bool {\n+    // If the objects don't have debuginfo there's nothing to preserve.\n+    if sess.opts.debuginfo == NoDebugInfo {\n+        return false\n+    }\n+\n+    // If we're only producing artifacts that are archives, no need to preserve\n+    // the objects as they're losslessly contained inside the archives.\n+    let output_linked = sess.crate_types.borrow()\n+        .iter()\n+        .any(|x| *x != config::CrateTypeRlib && *x != config::CrateTypeStaticlib);\n+    if !output_linked {\n+        return false\n+    }\n+\n+    // If we're on OSX then the equivalent of split dwarf is turned on by\n+    // default. The final executable won't actually have any debug information\n+    // except it'll have pointers to elsewhere. Historically we've always run\n+    // `dsymutil` to \"link all the dwarf together\" but this is actually sort of\n+    // a bummer for incremental compilation! (the whole point of split dwarf is\n+    // that you don't do this sort of dwarf link).\n+    //\n+    // Basically as a result this just means that if we're on OSX and we're\n+    // *not* running dsymutil then the object files are the only source of truth\n+    // for debug information, so we must preserve them.\n+    if sess.target.target.options.is_like_osx {\n+        match sess.opts.debugging_opts.run_dsymutil {\n+            // dsymutil is not being run, preserve objects\n+            Some(false) => return true,\n+\n+            // dsymutil is being run, no need to preserve the objects\n+            Some(true) => return false,\n+\n+            // The default historical behavior was to always run dsymutil, so\n+            // we're preserving that temporarily, but we're likely to switch the\n+            // default soon.\n+            None => return false,\n+        }\n+    }\n+\n+    false\n+}\n+\n fn filename_for_metadata(sess: &Session, crate_name: &str, outputs: &OutputFilenames) -> PathBuf {\n     let out_filename = outputs.single_output_file.clone()\n         .unwrap_or(outputs\n@@ -736,8 +784,12 @@ fn link_natively(sess: &Session,\n \n \n     // On macOS, debuggers need this utility to get run to do some munging of\n-    // the symbols\n-    if sess.target.target.options.is_like_osx && sess.opts.debuginfo != NoDebugInfo {\n+    // the symbols. Note, though, that if the object files are being preserved\n+    // for their debug information there's no need for us to run dsymutil.\n+    if sess.target.target.options.is_like_osx &&\n+        sess.opts.debuginfo != NoDebugInfo &&\n+        !preserve_objects_for_their_debuginfo(sess)\n+    {\n         match Command::new(\"dsymutil\").arg(out_filename).output() {\n             Ok(..) => {}\n             Err(e) => sess.fatal(&format!(\"failed to run dsymutil: {}\", e)),"}, {"sha": "a33270380196f5ec9ec5774eeecbd55ad5922029", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -247,22 +247,20 @@ fn fat_lto(cgcx: &CodegenContext,\n     // know much about the memory management here so we err on the side of being\n     // save and persist everything with the original module.\n     let mut serialized_bitcode = Vec::new();\n+    let mut linker = Linker::new(llmod);\n     for (bc_decoded, name) in serialized_modules {\n         info!(\"linking {:?}\", name);\n-        time(cgcx.time_passes, &format!(\"ll link {:?}\", name), || unsafe {\n+        time(cgcx.time_passes, &format!(\"ll link {:?}\", name), || {\n             let data = bc_decoded.data();\n-            if llvm::LLVMRustLinkInExternalBitcode(llmod,\n-                                                   data.as_ptr() as *const libc::c_char,\n-                                                   data.len() as libc::size_t) {\n-                Ok(())\n-            } else {\n+            linker.add(&data).map_err(|()| {\n                 let msg = format!(\"failed to load bc of {:?}\", name);\n-                Err(write::llvm_err(&diag_handler, msg))\n-            }\n+                write::llvm_err(&diag_handler, msg)\n+            })\n         })?;\n         timeline.record(&format!(\"link {:?}\", name));\n         serialized_bitcode.push(bc_decoded);\n     }\n+    drop(linker);\n     cgcx.save_temp_bitcode(&module, \"lto.input\");\n \n     // Internalize everything that *isn't* in our whitelist to help strip out\n@@ -289,6 +287,32 @@ fn fat_lto(cgcx: &CodegenContext,\n     }])\n }\n \n+struct Linker(llvm::LinkerRef);\n+\n+impl Linker {\n+    fn new(llmod: ModuleRef) -> Linker {\n+        unsafe { Linker(llvm::LLVMRustLinkerNew(llmod)) }\n+    }\n+\n+    fn add(&mut self, bytecode: &[u8]) -> Result<(), ()> {\n+        unsafe {\n+            if llvm::LLVMRustLinkerAdd(self.0,\n+                                       bytecode.as_ptr() as *const libc::c_char,\n+                                       bytecode.len()) {\n+                Ok(())\n+            } else {\n+                Err(())\n+            }\n+        }\n+    }\n+}\n+\n+impl Drop for Linker {\n+    fn drop(&mut self) {\n+        unsafe { llvm::LLVMRustLinkerFree(self.0); }\n+    }\n+}\n+\n /// Prepare \"thin\" LTO to get run on these modules.\n ///\n /// The general structure of ThinLTO is quite different from the structure of"}, {"sha": "b25562252e72e86cc70585acd9ac74a24faf7986", "filename": "src/librustc_trans/llvm_util.rs", "status": "modified", "additions": 39, "deletions": 35, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_trans%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_trans%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fllvm_util.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -14,7 +14,7 @@ use llvm;\n use rustc::session::Session;\n use rustc::session::config::PrintRequest;\n use libc::c_int;\n-use std::ffi::{CStr, CString};\n+use std::ffi::CString;\n \n use std::sync::atomic::{AtomicBool, Ordering};\n use std::sync::Once;\n@@ -79,57 +79,61 @@ unsafe fn configure_llvm(sess: &Session) {\n // detection code will walk past the end of the feature array,\n // leading to crashes.\n \n-const ARM_WHITELIST: &'static [&'static str] = &[\"neon\\0\", \"v7\\0\", \"vfp2\\0\", \"vfp3\\0\", \"vfp4\\0\"];\n+const ARM_WHITELIST: &'static [&'static str] = &[\"neon\", \"v7\", \"vfp2\", \"vfp3\", \"vfp4\"];\n \n-const AARCH64_WHITELIST: &'static [&'static str] = &[\"neon\\0\", \"v7\\0\"];\n+const AARCH64_WHITELIST: &'static [&'static str] = &[\"neon\", \"v7\"];\n \n-const X86_WHITELIST: &'static [&'static str] = &[\"avx\\0\", \"avx2\\0\", \"bmi\\0\", \"bmi2\\0\", \"sse\\0\",\n-                                                 \"sse2\\0\", \"sse3\\0\", \"sse4.1\\0\", \"sse4.2\\0\",\n-                                                 \"ssse3\\0\", \"tbm\\0\", \"lzcnt\\0\", \"popcnt\\0\",\n-                                                 \"sse4a\\0\", \"rdrnd\\0\", \"rdseed\\0\", \"fma\\0\",\n-                                                 \"xsave\\0\", \"xsaveopt\\0\", \"xsavec\\0\",\n-                                                 \"xsaves\\0\", \"aes\\0\",\n-                                                 \"avx512bw\\0\", \"avx512cd\\0\",\n-                                                 \"avx512dq\\0\", \"avx512er\\0\",\n-                                                 \"avx512f\\0\", \"avx512ifma\\0\",\n-                                                 \"avx512pf\\0\", \"avx512vbmi\\0\",\n-                                                 \"avx512vl\\0\", \"avx512vpopcntdq\\0\",\n-                                                 \"mmx\\0\", \"fxsr\\0\"];\n+const X86_WHITELIST: &'static [&'static str] = &[\"avx\", \"avx2\", \"bmi\", \"bmi2\", \"sse\",\n+                                                 \"sse2\", \"sse3\", \"sse4.1\", \"sse4.2\",\n+                                                 \"ssse3\", \"tbm\", \"lzcnt\", \"popcnt\",\n+                                                 \"sse4a\", \"rdrnd\", \"rdseed\", \"fma\",\n+                                                 \"xsave\", \"xsaveopt\", \"xsavec\",\n+                                                 \"xsaves\", \"aes\", \"pclmulqdq\",\n+                                                 \"avx512bw\", \"avx512cd\",\n+                                                 \"avx512dq\", \"avx512er\",\n+                                                 \"avx512f\", \"avx512ifma\",\n+                                                 \"avx512pf\", \"avx512vbmi\",\n+                                                 \"avx512vl\", \"avx512vpopcntdq\",\n+                                                 \"mmx\", \"fxsr\"];\n \n-const HEXAGON_WHITELIST: &'static [&'static str] = &[\"hvx\\0\", \"hvx-double\\0\"];\n+const HEXAGON_WHITELIST: &'static [&'static str] = &[\"hvx\", \"hvx-double\"];\n \n-const POWERPC_WHITELIST: &'static [&'static str] = &[\"altivec\\0\",\n-                                                     \"power8-altivec\\0\", \"power9-altivec\\0\",\n-                                                     \"power8-vector\\0\", \"power9-vector\\0\",\n-                                                     \"vsx\\0\"];\n+const POWERPC_WHITELIST: &'static [&'static str] = &[\"altivec\",\n+                                                     \"power8-altivec\", \"power9-altivec\",\n+                                                     \"power8-vector\", \"power9-vector\",\n+                                                     \"vsx\"];\n \n-const MIPS_WHITELIST: &'static [&'static str] = &[\"msa\\0\"];\n+const MIPS_WHITELIST: &'static [&'static str] = &[\"msa\"];\n+\n+pub fn to_llvm_feature(s: &str) -> &str {\n+    match s {\n+        \"pclmulqdq\" => \"pclmul\",\n+        s => s,\n+    }\n+}\n \n pub fn target_features(sess: &Session) -> Vec<Symbol> {\n-    let whitelist = target_feature_whitelist(sess);\n     let target_machine = create_target_machine(sess);\n-    let mut features = Vec::new();\n-    for feat in whitelist {\n-        if unsafe { llvm::LLVMRustHasFeature(target_machine, feat.as_ptr()) } {\n-            features.push(Symbol::intern(feat.to_str().unwrap()));\n-        }\n-    }\n-    features\n+    target_feature_whitelist(sess)\n+        .iter()\n+        .filter(|feature| {\n+            let llvm_feature = to_llvm_feature(feature);\n+            let cstr = CString::new(llvm_feature).unwrap();\n+            unsafe { llvm::LLVMRustHasFeature(target_machine, cstr.as_ptr()) }\n+        })\n+        .map(|feature| Symbol::intern(feature)).collect()\n }\n \n-pub fn target_feature_whitelist(sess: &Session) -> Vec<&CStr> {\n-    let whitelist = match &*sess.target.target.arch {\n+pub fn target_feature_whitelist(sess: &Session) -> &'static [&'static str] {\n+    match &*sess.target.target.arch {\n         \"arm\" => ARM_WHITELIST,\n         \"aarch64\" => AARCH64_WHITELIST,\n         \"x86\" | \"x86_64\" => X86_WHITELIST,\n         \"hexagon\" => HEXAGON_WHITELIST,\n         \"mips\" | \"mips64\" => MIPS_WHITELIST,\n         \"powerpc\" | \"powerpc64\" => POWERPC_WHITELIST,\n         _ => &[],\n-    };\n-    whitelist.iter().map(|m| {\n-        CStr::from_bytes_with_nul(m.as_bytes()).unwrap()\n-    }).collect()\n+    }\n }\n \n pub fn print_version() {"}, {"sha": "91fa3c5da6991035e776c754f3a6a0ebc6d74616", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 45, "deletions": 93, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -871,10 +871,21 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             fcx\n         };\n \n-        fcx.select_all_obligations_and_apply_defaults();\n-        fcx.closure_analyze(body);\n+        // All type checking constraints were added, try to fallback unsolved variables.\n+        fcx.select_obligations_where_possible();\n+        for ty in &fcx.unsolved_variables() {\n+            fcx.fallback_if_possible(ty);\n+        }\n         fcx.select_obligations_where_possible();\n+\n+        // Even though coercion casts provide type hints, we check casts after fallback for\n+        // backwards compatibility. This makes fallback a stronger type hint than a cast coercion.\n         fcx.check_casts();\n+\n+        // Closure and generater analysis may run after fallback\n+        // because they don't constrain other type variables.\n+        fcx.closure_analyze(body);\n+        assert!(fcx.deferred_call_resolutions.borrow().is_empty());\n         fcx.resolve_generator_interiors(def_id);\n         fcx.select_all_obligations_or_error();\n \n@@ -1395,7 +1406,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             .map(|node_item| !node_item.node.is_from_trait())\n             .unwrap_or(false);\n \n-        if !is_implemented {\n+        if !is_implemented && !tcx.impl_is_default(impl_id) {\n             if !trait_item.defaultness.has_value() {\n                 missing_items.push(trait_item);\n             } else if associated_type_overridden {\n@@ -2143,74 +2154,32 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Apply \"fallbacks\" to some types\n-    /// unconstrained types get replaced with ! or  () (depending on whether\n-    /// feature(never_type) is enabled), unconstrained ints with i32, and\n-    /// unconstrained floats with f64.\n-    fn default_type_parameters(&self) {\n+    // Tries to apply a fallback to `ty` if it is an unsolved variable.\n+    // Non-numerics get replaced with ! or () (depending on whether\n+    // feature(never_type) is enabled), unconstrained ints with i32,\n+    // unconstrained floats with f64.\n+    // Fallback becomes very dubious if we have encountered type-checking errors.\n+    // In that case, fallback to TyError.\n+    fn fallback_if_possible(&self, ty: Ty<'tcx>) {\n         use rustc::ty::error::UnconstrainedNumeric::Neither;\n         use rustc::ty::error::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat};\n \n-        // Defaulting inference variables becomes very dubious if we have\n-        // encountered type-checking errors. Therefore, if we think we saw\n-        // some errors in this function, just resolve all uninstanted type\n-        // varibles to TyError.\n-        if self.is_tainted_by_errors() {\n-            for ty in &self.unsolved_variables() {\n-                if let ty::TyInfer(_) = self.shallow_resolve(ty).sty {\n-                    debug!(\"default_type_parameters: defaulting `{:?}` to error\", ty);\n-                    self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx().types.err);\n-                }\n-            }\n-            return;\n-        }\n-\n-        for ty in &self.unsolved_variables() {\n-            let resolved = self.resolve_type_vars_if_possible(ty);\n-            if self.type_var_diverges(resolved) {\n-                debug!(\"default_type_parameters: defaulting `{:?}` to `!` because it diverges\",\n-                       resolved);\n-                self.demand_eqtype(syntax_pos::DUMMY_SP, *ty,\n-                                   self.tcx.mk_diverging_default());\n-            } else {\n-                match self.type_is_unconstrained_numeric(resolved) {\n-                    UnconstrainedInt => {\n-                        debug!(\"default_type_parameters: defaulting `{:?}` to `i32`\",\n-                               resolved);\n-                        self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.types.i32)\n-                    },\n-                    UnconstrainedFloat => {\n-                        debug!(\"default_type_parameters: defaulting `{:?}` to `f32`\",\n-                               resolved);\n-                        self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.types.f64)\n-                    }\n-                    Neither => { }\n-                }\n-            }\n-        }\n-    }\n-\n-    // Implements type inference fallback algorithm\n-    fn select_all_obligations_and_apply_defaults(&self) {\n-        self.select_obligations_where_possible();\n-        self.default_type_parameters();\n-        self.select_obligations_where_possible();\n+        assert!(ty.is_ty_infer());\n+        let fallback = match self.type_is_unconstrained_numeric(ty) {\n+            _ if self.is_tainted_by_errors() => self.tcx().types.err,\n+            UnconstrainedInt => self.tcx.types.i32,\n+            UnconstrainedFloat => self.tcx.types.f64,\n+            Neither if self.type_var_diverges(ty) => self.tcx.mk_diverging_default(),\n+            Neither => return\n+        };\n+        debug!(\"default_type_parameters: defaulting `{:?}` to `{:?}`\", ty, fallback);\n+        self.demand_eqtype(syntax_pos::DUMMY_SP, ty, fallback);\n     }\n \n     fn select_all_obligations_or_error(&self) {\n         debug!(\"select_all_obligations_or_error\");\n-\n-        // upvar inference should have ensured that all deferred call\n-        // resolutions are handled by now.\n-        assert!(self.deferred_call_resolutions.borrow().is_empty());\n-\n-        self.select_all_obligations_and_apply_defaults();\n-\n-        let mut fulfillment_cx = self.fulfillment_cx.borrow_mut();\n-\n-        match fulfillment_cx.select_all_or_error(self) {\n-            Ok(()) => { }\n-            Err(errors) => { self.report_fulfillment_errors(&errors, self.inh.body_id); }\n+        if let Err(errors) = self.fulfillment_cx.borrow_mut().select_all_or_error(&self) {\n+            self.report_fulfillment_errors(&errors, self.inh.body_id);\n         }\n     }\n \n@@ -5074,37 +5043,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         });\n     }\n \n-    fn structurally_resolve_type_or_else<F>(&self, sp: Span, ty: Ty<'tcx>, f: F)\n-                                            -> Ty<'tcx>\n-        where F: Fn() -> Ty<'tcx>\n-    {\n-        let mut ty = self.resolve_type_vars_with_obligations(ty);\n-\n-        if ty.is_ty_var() {\n-            let alternative = f();\n-\n-            // If not, error.\n-            if alternative.is_ty_var() || alternative.references_error() {\n-                if !self.is_tainted_by_errors() {\n-                    self.need_type_info((**self).body_id, sp, ty);\n-                }\n-                self.demand_suptype(sp, self.tcx.types.err, ty);\n-                ty = self.tcx.types.err;\n-            } else {\n-                self.demand_suptype(sp, alternative, ty);\n-                ty = alternative;\n-            }\n-        }\n-\n-        ty\n-    }\n-\n-    // Resolves `typ` by a single level if `typ` is a type variable.  If no\n-    // resolution is possible, then an error is reported.\n+    // Resolves `typ` by a single level if `typ` is a type variable.\n+    // If no resolution is possible, then an error is reported.\n+    // Numeric inference variables may be left unresolved.\n     pub fn structurally_resolved_type(&self, sp: Span, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.structurally_resolve_type_or_else(sp, ty, || {\n+        let ty = self.resolve_type_vars_with_obligations(ty);\n+        if !ty.is_ty_var() {\n+            ty\n+        } else {\n+            if !self.is_tainted_by_errors() {\n+                self.need_type_info((**self).body_id, sp, ty);\n+            }\n+            self.demand_suptype(sp, self.tcx.types.err, ty);\n             self.tcx.types.err\n-        })\n+        }\n     }\n \n     fn with_breakable_ctxt<F: FnOnce() -> R, R>(&self, id: ast::NodeId,"}, {"sha": "1c8d22e4666a6dd4b9884e2bbfe4878f9028838d", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -1364,6 +1364,7 @@ fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let node = tcx.hir.get(node_id);\n \n     let mut is_trait = None;\n+    let mut is_default_impl_trait = None;\n \n     let icx = ItemCtxt::new(tcx, def_id);\n     let no_generics = hir::Generics::empty();\n@@ -1373,8 +1374,13 @@ fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         NodeItem(item) => {\n             match item.node {\n+                ItemImpl(_, _, defaultness, ref generics, ..) => {\n+                    if defaultness.is_default() {\n+                        is_default_impl_trait = tcx.impl_trait_ref(def_id);\n+                    }\n+                    generics\n+                }\n                 ItemFn(.., ref generics, _) |\n-                ItemImpl(_, _, _, ref generics, ..) |\n                 ItemTy(_, ref generics) |\n                 ItemEnum(_, ref generics) |\n                 ItemStruct(_, ref generics) |\n@@ -1446,6 +1452,18 @@ fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         predicates.push(trait_ref.to_poly_trait_ref().to_predicate());\n     }\n \n+    // In default impls, we can assume that the self type implements\n+    // the trait. So in:\n+    //\n+    //     default impl Foo for Bar { .. }\n+    //\n+    // we add a default where clause `Foo: Bar`. We do a similar thing for traits\n+    // (see below). Recall that a default impl is not itself an impl, but rather a\n+    // set of defaults that can be incorporated into another impl.\n+    if let Some(trait_ref) = is_default_impl_trait {\n+        predicates.push(trait_ref.to_poly_trait_ref().to_predicate());\n+    }\n+\n     // Collect the region predicates that were declared inline as\n     // well. In the case of parameters declared on a fn or method, we\n     // have to be careful to only iterate over early-bound regions."}, {"sha": "2d0fe55f70d265a039f973c9da82ab3fc860d1c0", "filename": "src/librustdoc/html/static/themes/dark.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -130,7 +130,7 @@ pre {\n .content .highlighted.primitive { background-color: #00708a; }\n \n .content span.enum, .content a.enum, .block a.current.enum { color: #82b089; }\n-.content span.struct, .content a.struct, .block a.current.struct { color: #ff794d; }\n+.content span.struct, .content a.struct, .block a.current.struct { color: #2dbfb8; }\n .content span.type, .content a.type, .block a.current.type { color: #ff7f00; }\n .content span.foreigntype, .content a.foreigntype, .block a.current.foreigntype { color: #dd7de8; }\n .content span.macro, .content a.macro, .block a.current.macro { color: #09bd00; }"}, {"sha": "2334a2728554ea66dd8d345264a59e1e03ce843e", "filename": "src/librustdoc/html/static/themes/main.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fmain.css?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -130,7 +130,7 @@ pre {\n .content .highlighted.primitive { background-color: #9aecff; }\n \n .content span.enum, .content a.enum, .block a.current.enum { color: #508157; }\n-.content span.struct, .content a.struct, .block a.current.struct { color: #df3600; }\n+.content span.struct, .content a.struct, .block a.current.struct { color: #ad448e; }\n .content span.type, .content a.type, .block a.current.type { color: #ba5d00; }\n .content span.foreigntype, .content a.foreigntype, .block a.current.foreigntype { color: #cd00e2; }\n .content span.macro, .content a.macro, .block a.current.macro { color: #068000; }"}, {"sha": "a82ff915093c6ca0952bee2f672bb4cbb7e85df2", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 38, "deletions": 26, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -398,8 +398,9 @@ pub struct HashMap<K, V, S = RandomState> {\n }\n \n /// Search for a pre-hashed key.\n+/// If you don't already know the hash, use search or search_mut instead\n #[inline]\n-fn search_hashed<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F) -> InternalEntry<K, V, M>\n+fn search_hashed<K, V, M, F>(table: M, hash: SafeHash, is_match: F) -> InternalEntry<K, V, M>\n     where M: Deref<Target = RawTable<K, V>>,\n           F: FnMut(&K) -> bool\n {\n@@ -410,6 +411,18 @@ fn search_hashed<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F) -> Inter\n         return InternalEntry::TableIsEmpty;\n     }\n \n+    search_hashed_nonempty(table, hash, is_match)\n+}\n+\n+/// Search for a pre-hashed key when the hash map is known to be non-empty.\n+#[inline]\n+fn search_hashed_nonempty<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F)\n+    -> InternalEntry<K, V, M>\n+    where M: Deref<Target = RawTable<K, V>>,\n+          F: FnMut(&K) -> bool\n+{\n+    // Do not check the capacity as an extra branch could slow the lookup.\n+\n     let size = table.size();\n     let mut probe = Bucket::new(table, hash);\n     let mut displacement = 0;\n@@ -543,24 +556,36 @@ impl<K, V, S> HashMap<K, V, S>\n     }\n \n     /// Search for a key, yielding the index if it's found in the hashtable.\n-    /// If you already have the hash for the key lying around, use\n-    /// search_hashed.\n+    /// If you already have the hash for the key lying around, or if you need an\n+    /// InternalEntry, use search_hashed or search_hashed_nonempty.\n     #[inline]\n-    fn search<'a, Q: ?Sized>(&'a self, q: &Q) -> InternalEntry<K, V, &'a RawTable<K, V>>\n+    fn search<'a, Q: ?Sized>(&'a self, q: &Q)\n+        -> Option<FullBucket<K, V, &'a RawTable<K, V>>>\n         where K: Borrow<Q>,\n               Q: Eq + Hash\n     {\n+        if self.is_empty() {\n+            return None;\n+        }\n+\n         let hash = self.make_hash(q);\n-        search_hashed(&self.table, hash, |k| q.eq(k.borrow()))\n+        search_hashed_nonempty(&self.table, hash, |k| q.eq(k.borrow()))\n+            .into_occupied_bucket()\n     }\n \n     #[inline]\n-    fn search_mut<'a, Q: ?Sized>(&'a mut self, q: &Q) -> InternalEntry<K, V, &'a mut RawTable<K, V>>\n+    fn search_mut<'a, Q: ?Sized>(&'a mut self, q: &Q)\n+        -> Option<FullBucket<K, V, &'a mut RawTable<K, V>>>\n         where K: Borrow<Q>,\n               Q: Eq + Hash\n     {\n+        if self.is_empty() {\n+            return None;\n+        }\n+\n         let hash = self.make_hash(q);\n-        search_hashed(&mut self.table, hash, |k| q.eq(k.borrow()))\n+        search_hashed_nonempty(&mut self.table, hash, |k| q.eq(k.borrow()))\n+            .into_occupied_bucket()\n     }\n \n     // The caller should ensure that invariants by Robin Hood Hashing hold\n@@ -1118,7 +1143,7 @@ impl<K, V, S> HashMap<K, V, S>\n         where K: Borrow<Q>,\n               Q: Hash + Eq\n     {\n-        self.search(k).into_occupied_bucket().map(|bucket| bucket.into_refs().1)\n+        self.search(k).map(|bucket| bucket.into_refs().1)\n     }\n \n     /// Returns true if the map contains a value for the specified key.\n@@ -1145,7 +1170,7 @@ impl<K, V, S> HashMap<K, V, S>\n         where K: Borrow<Q>,\n               Q: Hash + Eq\n     {\n-        self.search(k).into_occupied_bucket().is_some()\n+        self.search(k).is_some()\n     }\n \n     /// Returns a mutable reference to the value corresponding to the key.\n@@ -1174,7 +1199,7 @@ impl<K, V, S> HashMap<K, V, S>\n         where K: Borrow<Q>,\n               Q: Hash + Eq\n     {\n-        self.search_mut(k).into_occupied_bucket().map(|bucket| bucket.into_mut_refs().1)\n+        self.search_mut(k).map(|bucket| bucket.into_mut_refs().1)\n     }\n \n     /// Inserts a key-value pair into the map.\n@@ -1234,11 +1259,7 @@ impl<K, V, S> HashMap<K, V, S>\n         where K: Borrow<Q>,\n               Q: Hash + Eq\n     {\n-        if self.table.size() == 0 {\n-            return None;\n-        }\n-\n-        self.search_mut(k).into_occupied_bucket().map(|bucket| pop_internal(bucket).1)\n+        self.search_mut(k).map(|bucket| pop_internal(bucket).1)\n     }\n \n     /// Removes a key from the map, returning the stored key and value if the\n@@ -1269,12 +1290,7 @@ impl<K, V, S> HashMap<K, V, S>\n         where K: Borrow<Q>,\n               Q: Hash + Eq\n     {\n-        if self.table.size() == 0 {\n-            return None;\n-        }\n-\n         self.search_mut(k)\n-            .into_occupied_bucket()\n             .map(|bucket| {\n                 let (k, v, _) = pop_internal(bucket);\n                 (k, v)\n@@ -2632,15 +2648,11 @@ impl<K, S, Q: ?Sized> super::Recover<Q> for HashMap<K, (), S>\n \n     #[inline]\n     fn get(&self, key: &Q) -> Option<&K> {\n-        self.search(key).into_occupied_bucket().map(|bucket| bucket.into_refs().0)\n+        self.search(key).map(|bucket| bucket.into_refs().0)\n     }\n \n     fn take(&mut self, key: &Q) -> Option<K> {\n-        if self.table.size() == 0 {\n-            return None;\n-        }\n-\n-        self.search_mut(key).into_occupied_bucket().map(|bucket| pop_internal(bucket).0)\n+        self.search_mut(key).map(|bucket| pop_internal(bucket).0)\n     }\n \n     #[inline]"}, {"sha": "c4946b6b2824d3eed6e6d20567e2fa195ff2c511", "filename": "src/libstd/env.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -723,6 +723,12 @@ pub fn args_os() -> ArgsOs {\n     ArgsOs { inner: sys::args::args() }\n }\n \n+#[stable(feature = \"env_unimpl_send_sync\", since = \"1.25.0\")]\n+impl !Send for Args {}\n+\n+#[stable(feature = \"env_unimpl_send_sync\", since = \"1.25.0\")]\n+impl !Sync for Args {}\n+\n #[stable(feature = \"env\", since = \"1.0.0\")]\n impl Iterator for Args {\n     type Item = String;\n@@ -754,6 +760,12 @@ impl fmt::Debug for Args {\n     }\n }\n \n+#[stable(feature = \"env_unimpl_send_sync\", since = \"1.25.0\")]\n+impl !Send for ArgsOs {}\n+\n+#[stable(feature = \"env_unimpl_send_sync\", since = \"1.25.0\")]\n+impl !Sync for ArgsOs {}\n+\n #[stable(feature = \"env\", since = \"1.0.0\")]\n impl Iterator for ArgsOs {\n     type Item = OsString;"}, {"sha": "a760922115aef330ebb44463d4412c687e1cbbc4", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -1023,7 +1023,7 @@ impl f32 {\n     /// This is currently identical to `transmute::<u32, f32>(v)` on all platforms.\n     /// It turns out this is incredibly portable, for two reasons:\n     ///\n-    /// * Floats and Ints have the same endianess on all supported platforms.\n+    /// * Floats and Ints have the same endianness on all supported platforms.\n     /// * IEEE-754 very precisely specifies the bit layout of floats.\n     ///\n     /// However there is one caveat: prior to the 2008 version of IEEE-754, how"}, {"sha": "6f34f176a971155b09c2d3e5ecad66cd56002ac7", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -978,7 +978,7 @@ impl f64 {\n     /// This is currently identical to `transmute::<u64, f64>(v)` on all platforms.\n     /// It turns out this is incredibly portable, for two reasons:\n     ///\n-    /// * Floats and Ints have the same endianess on all supported platforms.\n+    /// * Floats and Ints have the same endianness on all supported platforms.\n     /// * IEEE-754 very precisely specifies the bit layout of floats.\n     ///\n     /// However there is one caveat: prior to the 2008 version of IEEE-754, how"}, {"sha": "76bcb5fedc94aed53fe7c86454897938808c2e31", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -296,7 +296,7 @@ impl<'a> Write for Cursor<&'a mut [u8]> {\n     fn flush(&mut self) -> io::Result<()> { Ok(()) }\n }\n \n-#[unstable(feature = \"cursor_mut_vec\", issue = \"30132\")]\n+#[stable(feature = \"cursor_mut_vec\", since = \"1.25.0\")]\n impl<'a> Write for Cursor<&'a mut Vec<u8>> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         vec_write(&mut self.pos, self.inner, buf)"}, {"sha": "e03a182653e5a451810c99820ed16ea8b1de4fe5", "filename": "src/libstd/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -576,7 +576,7 @@ impl<'a> AsRef<OsStr> for Component<'a> {\n     }\n }\n \n-#[stable(feature = \"path_component_asref\", since = \"1.24.0\")]\n+#[stable(feature = \"path_component_asref\", since = \"1.25.0\")]\n impl<'a> AsRef<Path> for Component<'a> {\n     fn as_ref(&self) -> &Path {\n         self.as_os_str().as_ref()"}, {"sha": "ff6f32fc3be0bb7808319ccc756159e1abcfee69", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -690,14 +690,16 @@ impl CodeMap {\n             return 1;\n         }\n \n+        let src = local_begin.fm.external_src.borrow();\n+\n         // We need to extend the snippet to the end of the src rather than to end_index so when\n         // searching forwards for boundaries we've got somewhere to search.\n         let snippet = if let Some(ref src) = local_begin.fm.src {\n             let len = src.len();\n-            (&src[start_index..len]).to_string()\n-        } else if let Some(src) = local_begin.fm.external_src.borrow().get_source() {\n+            (&src[start_index..len])\n+        } else if let Some(src) = src.get_source() {\n             let len = src.len();\n-            (&src[start_index..len]).to_string()\n+            (&src[start_index..len])\n         } else {\n             return 1;\n         };"}, {"sha": "3b137f9570a390f138b9e9540acc19bd34ba13e5", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -541,7 +541,7 @@ declare_features! (\n     // instead of just the platforms on which it is the C ABI\n     (accepted, abi_sysv64, \"1.24.0\", Some(36167)),\n     // Allows `repr(align(16))` struct attribute (RFC 1358)\n-    (accepted, repr_align, \"1.24.0\", Some(33626)),\n+    (accepted, repr_align, \"1.25.0\", Some(33626)),\n     // allow '|' at beginning of match arms (RFC 1925)\n     (accepted, match_beginning_vert, \"1.25.0\", Some(44101)),\n     // Nested groups in `use` (RFC 2128)"}, {"sha": "ac582627f88fdb34f6022c557180cbb169c1b9ba", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -4859,19 +4859,30 @@ impl<'a> Parser<'a> {\n                 |p| {\n                     if p.token == token::DotDotDot {\n                         p.bump();\n+                        variadic = true;\n                         if allow_variadic {\n                             if p.token != token::CloseDelim(token::Paren) {\n                                 let span = p.span;\n                                 p.span_err(span,\n                                     \"`...` must be last in argument list for variadic function\");\n                             }\n+                            Ok(None)\n                         } else {\n-                            let span = p.span;\n-                            p.span_err(span,\n-                                       \"only foreign functions are allowed to be variadic\");\n+                            let span = p.prev_span;\n+                            if p.token == token::CloseDelim(token::Paren) {\n+                                // continue parsing to present any further errors\n+                                p.struct_span_err(\n+                                    span,\n+                                    \"only foreign functions are allowed to be variadic\"\n+                                ).emit();\n+                                Ok(Some(dummy_arg(span)))\n+                           } else {\n+                               // this function definition looks beyond recovery, stop parsing\n+                                p.span_err(span,\n+                                           \"only foreign functions are allowed to be variadic\");\n+                                Ok(None)\n+                            }\n                         }\n-                        variadic = true;\n-                        Ok(None)\n                     } else {\n                         match p.parse_arg_general(named_args) {\n                             Ok(arg) => Ok(Some(arg)),"}, {"sha": "534e4b910902e89ce567eb364a3bf4b5e2b3600f", "filename": "src/rustllvm/Linker.cpp", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Frustllvm%2FLinker.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Frustllvm%2FLinker.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FLinker.cpp?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -0,0 +1,72 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#include \"llvm/Linker/Linker.h\"\n+\n+#include \"rustllvm.h\"\n+\n+using namespace llvm;\n+\n+struct RustLinker {\n+  Linker L;\n+  LLVMContext &Ctx;\n+\n+  RustLinker(Module &M) :\n+    L(M),\n+    Ctx(M.getContext())\n+  {}\n+};\n+\n+extern \"C\" RustLinker*\n+LLVMRustLinkerNew(LLVMModuleRef DstRef) {\n+  Module *Dst = unwrap(DstRef);\n+\n+  auto Ret = llvm::make_unique<RustLinker>(*Dst);\n+  return Ret.release();\n+}\n+\n+extern \"C\" void\n+LLVMRustLinkerFree(RustLinker *L) {\n+  delete L;\n+}\n+\n+extern \"C\" bool\n+LLVMRustLinkerAdd(RustLinker *L, char *BC, size_t Len) {\n+  std::unique_ptr<MemoryBuffer> Buf =\n+      MemoryBuffer::getMemBufferCopy(StringRef(BC, Len));\n+\n+#if LLVM_VERSION_GE(4, 0)\n+  Expected<std::unique_ptr<Module>> SrcOrError =\n+      llvm::getLazyBitcodeModule(Buf->getMemBufferRef(), L->Ctx);\n+  if (!SrcOrError) {\n+    LLVMRustSetLastError(toString(SrcOrError.takeError()).c_str());\n+    return false;\n+  }\n+\n+  auto Src = std::move(*SrcOrError);\n+#else\n+  ErrorOr<std::unique_ptr<Module>> Src =\n+      llvm::getLazyBitcodeModule(std::move(Buf), L->Ctx);\n+  if (!Src) {\n+    LLVMRustSetLastError(Src.getError().message().c_str());\n+    return false;\n+  }\n+#endif\n+\n+#if LLVM_VERSION_GE(4, 0)\n+  if (L->L.linkInModule(std::move(Src))) {\n+#else\n+  if (L->L.linkInModule(std::move(Src.get()))) {\n+#endif\n+    LLVMRustSetLastError(\"\");\n+    return false;\n+  }\n+  return true;\n+}"}, {"sha": "27d5496f57628c4c7d6c05c41a6fee03f12357c3", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -916,46 +916,6 @@ extern \"C\" void LLVMRustWriteValueToString(LLVMValueRef V,\n   }\n }\n \n-extern \"C\" bool LLVMRustLinkInExternalBitcode(LLVMModuleRef DstRef, char *BC,\n-                                              size_t Len) {\n-  Module *Dst = unwrap(DstRef);\n-\n-  std::unique_ptr<MemoryBuffer> Buf =\n-      MemoryBuffer::getMemBufferCopy(StringRef(BC, Len));\n-\n-#if LLVM_VERSION_GE(4, 0)\n-  Expected<std::unique_ptr<Module>> SrcOrError =\n-      llvm::getLazyBitcodeModule(Buf->getMemBufferRef(), Dst->getContext());\n-  if (!SrcOrError) {\n-    LLVMRustSetLastError(toString(SrcOrError.takeError()).c_str());\n-    return false;\n-  }\n-\n-  auto Src = std::move(*SrcOrError);\n-#else\n-  ErrorOr<std::unique_ptr<Module>> Src =\n-      llvm::getLazyBitcodeModule(std::move(Buf), Dst->getContext());\n-  if (!Src) {\n-    LLVMRustSetLastError(Src.getError().message().c_str());\n-    return false;\n-  }\n-#endif\n-\n-  std::string Err;\n-\n-  raw_string_ostream Stream(Err);\n-  DiagnosticPrinterRawOStream DP(Stream);\n-#if LLVM_VERSION_GE(4, 0)\n-  if (Linker::linkModules(*Dst, std::move(Src))) {\n-#else\n-  if (Linker::linkModules(*Dst, std::move(Src.get()))) {\n-#endif\n-    LLVMRustSetLastError(Err.c_str());\n-    return false;\n-  }\n-  return true;\n-}\n-\n // Note that the two following functions look quite similar to the\n // LLVMGetSectionName function. Sadly, it appears that this function only\n // returns a char* pointer, which isn't guaranteed to be null-terminated. The"}, {"sha": "e01161734623217ecd2dc7c2bf104c358877575a", "filename": "src/test/compile-fail/borrowck/borrowck-move-out-from-array.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-out-from-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-out-from-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-out-from-array.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: ast mir\n+//[mir]compile-flags: -Z borrowck=mir\n+\n+#![feature(box_syntax, slice_patterns, advanced_slice_patterns)]\n+\n+fn move_out_from_begin_and_end() {\n+    let a = [box 1, box 2];\n+    let [_, _x] = a;\n+    let [.., _y] = a; //[ast]~ ERROR [E0382]\n+                      //[mir]~^ ERROR [E0382]\n+}\n+\n+fn move_out_by_const_index_and_subslice() {\n+    let a = [box 1, box 2];\n+    let [_x, _] = a;\n+    let [_y..] = a; //[ast]~ ERROR [E0382]\n+                    //[mir]~^ ERROR [E0382]\n+}\n+\n+fn main() {}"}, {"sha": "ad55f44255b48eec4d3896f532ccd9c4893acf2e", "filename": "src/test/compile-fail/specialization/defaultimpl/specialization-default-projection.rs", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fdefaultimpl%2Fspecialization-default-projection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fdefaultimpl%2Fspecialization-default-projection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fdefaultimpl%2Fspecialization-default-projection.rs?ref=0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec", "patch": "@@ -1,46 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(specialization)]\n-\n-// Make sure we can't project defaulted associated types\n-\n-trait Foo {\n-    type Assoc;\n-}\n-\n-default impl<T> Foo for T {\n-    type Assoc = ();\n-}\n-\n-impl Foo for u8 {\n-    type Assoc = String;\n-}\n-\n-fn generic<T>() -> <T as Foo>::Assoc {\n-    // `T` could be some downstream crate type that specializes (or,\n-    // for that matter, `u8`).\n-\n-    () //~ ERROR mismatched types\n-}\n-\n-fn monomorphic() -> () {\n-    // Even though we know that `()` is not specialized in a\n-    // downstream crate, typeck refuses to project here.\n-\n-    generic::<()>() //~ ERROR mismatched types\n-}\n-\n-fn main() {\n-    // No error here, we CAN project from `u8`, as there is no `default`\n-    // in that impl.\n-    let s: String = generic::<u8>();\n-    println!(\"{}\", s); // bad news if this all compiles\n-}"}, {"sha": "7353f7ac8c5c0c38bed49d14b7e70d24f7874660", "filename": "src/test/compile-fail/specialization/defaultimpl/specialization-default-types.rs", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fdefaultimpl%2Fspecialization-default-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fdefaultimpl%2Fspecialization-default-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fdefaultimpl%2Fspecialization-default-types.rs?ref=0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec", "patch": "@@ -1,45 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// It should not be possible to use the concrete value of a defaulted\n-// associated type in the impl defining it -- otherwise, what happens\n-// if it's overridden?\n-\n-#![feature(specialization)]\n-\n-trait Example {\n-    type Output;\n-    fn generate(self) -> Self::Output;\n-}\n-\n-default impl<T> Example for T {\n-    type Output = Box<T>;\n-    fn generate(self) -> Self::Output {\n-        Box::new(self) //~ ERROR mismatched types\n-    }\n-}\n-\n-impl Example for bool {\n-    type Output = bool;\n-    fn generate(self) -> bool { self }\n-}\n-\n-fn trouble<T>(t: T) -> Box<T> {\n-    Example::generate(t) //~ ERROR mismatched types\n-}\n-\n-fn weaponize() -> bool {\n-    let b: Box<bool> = trouble(true);\n-    *b\n-}\n-\n-fn main() {\n-    weaponize();\n-}"}, {"sha": "eacec2e40f073e44ff875e2b2d88fbda6424f92f", "filename": "src/test/compile-fail/specialization/defaultimpl/specialization-trait-item-not-implemented.rs", "status": "renamed", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fdefaultimpl%2Fspecialization-trait-item-not-implemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fdefaultimpl%2Fspecialization-trait-item-not-implemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fdefaultimpl%2Fspecialization-trait-item-not-implemented.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -8,30 +8,26 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that non-method associated functions can be specialized\n+// Tests that default impls do not have to supply all items but regular impls do.\n \n #![feature(specialization)]\n \n trait Foo {\n-    fn mk() -> Self;\n+    fn foo_one(&self) -> &'static str;\n+    fn foo_two(&self) -> &'static str;\n }\n \n-default impl<T: Default> Foo for T {\n-    fn mk() -> T {\n-        T::default()\n-    }\n-}\n+struct MyStruct;\n \n-impl Foo for Vec<u8> {\n-    fn mk() -> Vec<u8> {\n-        vec![0]\n+default impl<T> Foo for T {\n+    fn foo_one(&self) -> &'static str {\n+        \"generic\"\n     }\n }\n \n-fn main() {\n-    let v1: Vec<i32> = Foo::mk();\n-    let v2: Vec<u8> = Foo::mk();\n+impl Foo for MyStruct {}\n+//~^ ERROR not all trait items implemented, missing: `foo_two` [E0046]\n \n-    assert!(v1.len() == 0);\n-    assert!(v2.len() == 1);\n+fn main() {\n+    println!(\"{}\", MyStruct.foo_one());\n }", "previous_filename": "src/test/run-pass/specialization/defaultimpl/assoc-fns.rs"}, {"sha": "04ddf9ebb17717be054945af5c3f45b9fe962a79", "filename": "src/test/compile-fail/specialization/defaultimpl/specialization-trait-not-implemented.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fdefaultimpl%2Fspecialization-trait-not-implemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fdefaultimpl%2Fspecialization-trait-not-implemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fdefaultimpl%2Fspecialization-trait-not-implemented.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that:\n+// - default impls do not have to supply all items and\n+// - a default impl does not count as an impl (in this case, an incomplete default impl).\n+\n+#![feature(specialization)]\n+\n+trait Foo {\n+    fn foo_one(&self) -> &'static str;\n+    fn foo_two(&self) -> &'static str;\n+}\n+\n+struct MyStruct;\n+\n+default impl<T> Foo for T {\n+    fn foo_one(&self) -> &'static str {\n+        \"generic\"\n+    }\n+}\n+\n+\n+fn main() {\n+    println!(\"{}\", MyStruct.foo_one());\n+    //~^ ERROR no method named `foo_one` found for type `MyStruct` in the current scope\n+}"}, {"sha": "445a59a373e56f1ee962c5f90dacc4ce37e0c461", "filename": "src/test/compile-fail/specialization/defaultimpl/specialization-wfcheck.rs", "status": "renamed", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fdefaultimpl%2Fspecialization-wfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fdefaultimpl%2Fspecialization-wfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fdefaultimpl%2Fspecialization-wfcheck.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,25 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(specialization)]\n-\n-// Regression test for ICE when combining specialized associated types and type\n-// aliases\n-\n-trait Id_ {\n-    type Out;\n-}\n+// Tests that a default impl still has to have a WF trait ref.\n \n-type Id<T> = <T as Id_>::Out;\n-\n-default impl<T> Id_ for T {\n-    type Out = T;\n-}\n+#![feature(specialization)]\n \n-fn test_proection() {\n-    let x: Id<bool> = panic!();\n-}\n+trait Foo<'a, T: Eq + 'a> { }\n \n-fn main() {\n+default impl<U> Foo<'static, U> for () {}\n+//~^ ERROR the trait bound `U: std::cmp::Eq` is not satisfied\n \n-}\n+fn main(){}", "previous_filename": "src/test/run-pass/specialization/defaultimpl/projection-alias.rs"}, {"sha": "4a310255aac576a3d3d7ede99bff59ef38f2fb87", "filename": "src/test/mir-opt/uniform_array_move_out.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(box_syntax, slice_patterns, advanced_slice_patterns)]\n+\n+fn move_out_from_end() {\n+    let a = [box 1, box 2];\n+    let [.., _y] = a;\n+}\n+\n+fn move_out_by_subslice() {\n+    let a = [box 1, box 2];\n+    let [_y..] = a;\n+}\n+\n+fn main() {\n+    move_out_by_subslice();\n+    move_out_from_end();\n+}\n+\n+// END RUST SOURCE\n+\n+// START rustc.move_out_from_end.UniformArrayMoveOut.before.mir\n+//     StorageLive(_6);\n+//      _6 = move _1[-1 of 1];\n+//      _0 = ();\n+// END rustc.move_out_from_end.UniformArrayMoveOut.before.mir\n+\n+// START rustc.move_out_from_end.UniformArrayMoveOut.after.mir\n+//     StorageLive(_6);\n+//      _6 = move _1[1 of 2];\n+//      nop;\n+//      _0 = ();\n+// END rustc.move_out_from_end.UniformArrayMoveOut.after.mir\n+\n+// START rustc.move_out_by_subslice.UniformArrayMoveOut.before.mir\n+//     StorageLive(_6);\n+//      _6 = move _1[0:];\n+// END rustc.move_out_by_subslice.UniformArrayMoveOut.before.mir\n+\n+// START rustc.move_out_by_subslice.UniformArrayMoveOut.after.mir\n+//     StorageLive(_6);\n+//     StorageLive(_7);\n+//     _7 = move _1[0 of 2];\n+//     StorageLive(_8);\n+//     _8 = move _1[1 of 2];\n+//     _6 = [move _7, move _8];\n+//     StorageDead(_7);\n+//     StorageDead(_8);\n+//     nop;\n+//     _0 = ();\n+// END rustc.move_out_by_subslice.UniformArrayMoveOut.after.mir"}, {"sha": "aa6752ffc35b077c1929d5490179584c5abf036d", "filename": "src/test/run-pass/cast-does-fallback.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftest%2Frun-pass%2Fcast-does-fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftest%2Frun-pass%2Fcast-does-fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcast-does-fallback.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn main() {\n+    // Test that these type check correctly.\n+    (&42u8 >> 4) as usize;\n+    (&42u8 << 4) as usize;\n+\n+    let cap = 512 * 512;\n+    cap as u8;\n+    // Assert `cap` did not get inferred to `u8` and overflowed.\n+    assert_ne!(cap, 0);\n+}"}, {"sha": "4d0bd3f3412f1f7fd0933363af3779e4b0cd4807", "filename": "src/test/run-pass/dynamic-drop.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -225,6 +225,43 @@ fn slice_pattern_one_of(a: &Allocator, i: usize) {\n     };\n }\n \n+fn subslice_pattern_from_end(a: &Allocator, arg: bool) {\n+    let a = [a.alloc(), a.alloc(), a.alloc()];\n+    if arg {\n+        let[.., _x, _] = a;\n+    } else {\n+        let[_, _y..] = a;\n+    }\n+}\n+\n+fn subslice_pattern_from_end_with_drop(a: &Allocator, arg: bool, arg2: bool) {\n+    let a = [a.alloc(), a.alloc(), a.alloc(), a.alloc(), a.alloc()];\n+    if arg2 {\n+        drop(a);\n+        return;\n+    }\n+\n+    if arg {\n+        let[.., _x, _] = a;\n+    } else {\n+        let[_, _y..] = a;\n+    }\n+}\n+\n+fn slice_pattern_reassign(a: &Allocator) {\n+    let mut ar = [a.alloc(), a.alloc()];\n+    let[_, _x] = ar;\n+    ar = [a.alloc(), a.alloc()];\n+    let[.., _y] = ar;\n+}\n+\n+fn subslice_pattern_reassign(a: &Allocator) {\n+    let mut ar = [a.alloc(), a.alloc(), a.alloc()];\n+    let[_, _, _x] = ar;\n+    ar = [a.alloc(), a.alloc(), a.alloc()];\n+    let[_, _y..] = ar;\n+}\n+\n fn run_test<F>(mut f: F)\n     where F: FnMut(&Allocator)\n {\n@@ -303,5 +340,14 @@ fn main() {\n     run_test(|a| slice_pattern_one_of(a, 2));\n     run_test(|a| slice_pattern_one_of(a, 3));\n \n+    run_test(|a| subslice_pattern_from_end(a, true));\n+    run_test(|a| subslice_pattern_from_end(a, false));\n+    run_test(|a| subslice_pattern_from_end_with_drop(a, true, true));\n+    run_test(|a| subslice_pattern_from_end_with_drop(a, true, false));\n+    run_test(|a| subslice_pattern_from_end_with_drop(a, false, true));\n+    run_test(|a| subslice_pattern_from_end_with_drop(a, false, false));\n+    run_test(|a| slice_pattern_reassign(a));\n+    run_test(|a| subslice_pattern_reassign(a));\n+\n     run_test_nopanic(|a| union1(a));\n }"}, {"sha": "facdee5cc176fb8935a516ff425bdcb7dbd8b04b", "filename": "src/test/run-pass/issue-47703-1.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftest%2Frun-pass%2Fissue-47703-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftest%2Frun-pass%2Fissue-47703-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-47703-1.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(nll)]\n+\n+struct AtomicRefMut<'a> {\n+    value: &'a mut i32,\n+    borrow: AtomicBorrowRefMut,\n+}\n+\n+struct AtomicBorrowRefMut {\n+}\n+\n+impl Drop for AtomicBorrowRefMut {\n+    fn drop(&mut self) {\n+    }\n+}\n+\n+fn map(orig: AtomicRefMut) -> AtomicRefMut {\n+    AtomicRefMut {\n+        value: orig.value,\n+        borrow: orig.borrow,\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "2146986377a0522f3263830511e1220bcb3756aa", "filename": "src/test/run-pass/issue-47703.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftest%2Frun-pass%2Fissue-47703.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftest%2Frun-pass%2Fissue-47703.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-47703.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(nll)]\n+\n+struct MyStruct<'a> {\n+    field: &'a mut (),\n+    field2: WithDrop\n+}\n+\n+struct WithDrop;\n+\n+impl Drop for WithDrop {\n+    fn drop(&mut self) {}\n+}\n+\n+impl<'a> MyStruct<'a> {\n+    fn consume(self) -> &'a mut () { self.field }\n+}\n+\n+fn main() {}"}, {"sha": "71dd7c99009ea5a0920c0e35bf943e69c4316b55", "filename": "src/test/run-pass/specialization/defaultimpl/auxiliary/cross_crate.rs", "status": "removed", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fauxiliary%2Fcross_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fauxiliary%2Fcross_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fauxiliary%2Fcross_crate.rs?ref=0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec", "patch": "@@ -1,82 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(specialization)]\n-\n-pub trait Foo {\n-    fn foo(&self) -> &'static str;\n-}\n-\n-default impl<T> Foo for T {\n-    fn foo(&self) -> &'static str {\n-        \"generic\"\n-    }\n-}\n-\n-default impl<T: Clone> Foo for T {\n-    fn foo(&self) -> &'static str {\n-        \"generic Clone\"\n-    }\n-}\n-\n-default impl<T, U> Foo for (T, U) where T: Clone, U: Clone {\n-    fn foo(&self) -> &'static str {\n-        \"generic pair\"\n-    }\n-}\n-\n-default impl<T: Clone> Foo for (T, T) {\n-    fn foo(&self) -> &'static str {\n-        \"generic uniform pair\"\n-    }\n-}\n-\n-default impl Foo for (u8, u32) {\n-    fn foo(&self) -> &'static str {\n-        \"(u8, u32)\"\n-    }\n-}\n-\n-default impl Foo for (u8, u8) {\n-    fn foo(&self) -> &'static str {\n-        \"(u8, u8)\"\n-    }\n-}\n-\n-default impl<T: Clone> Foo for Vec<T> {\n-    fn foo(&self) -> &'static str {\n-        \"generic Vec\"\n-    }\n-}\n-\n-impl Foo for Vec<i32> {\n-    fn foo(&self) -> &'static str {\n-        \"Vec<i32>\"\n-    }\n-}\n-\n-impl Foo for String {\n-    fn foo(&self) -> &'static str {\n-        \"String\"\n-    }\n-}\n-\n-impl Foo for i32 {\n-    fn foo(&self) -> &'static str {\n-        \"i32\"\n-    }\n-}\n-\n-pub trait MyMarker {}\n-default impl<T: Clone + MyMarker> Foo for T {\n-    fn foo(&self) -> &'static str {\n-        \"generic Clone + MyMarker\"\n-    }\n-}"}, {"sha": "9d0ea64fed428d6cefe7beb02a8ddd0ee5f1ad4d", "filename": "src/test/run-pass/specialization/defaultimpl/auxiliary/cross_crate_defaults.rs", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fauxiliary%2Fcross_crate_defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fauxiliary%2Fcross_crate_defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fauxiliary%2Fcross_crate_defaults.rs?ref=0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec", "patch": "@@ -1,49 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-#![feature(specialization)]\n-\n-// First, test only use of explicit `default` items:\n-\n-pub trait Foo {\n-    fn foo(&self) -> bool;\n-}\n-\n-default impl<T> Foo for T {\n-    fn foo(&self) -> bool { false }\n-}\n-\n-impl Foo for i32 {}\n-\n-impl Foo for i64 {\n-    fn foo(&self) -> bool { true }\n-}\n-\n-// Next, test mixture of explicit `default` and provided methods:\n-\n-pub trait Bar {\n-    fn bar(&self) -> i32 { 0 }\n-}\n-\n-impl<T> Bar for T {} // use the provided method\n-\n-impl Bar for i32 {\n-    fn bar(&self) -> i32 { 1 }\n-}\n-impl<'a> Bar for &'a str {}\n-\n-default impl<T> Bar for Vec<T> {\n-    fn bar(&self) -> i32 { 2 }\n-}\n-impl Bar for Vec<i32> {}\n-impl Bar for Vec<i64> {\n-    fn bar(&self) -> i32 { 3 }\n-}"}, {"sha": "7daecc842f3f9fd8a2140a3785db00b2f34cbffc", "filename": "src/test/run-pass/specialization/defaultimpl/basics-unsafe.rs", "status": "removed", "additions": 0, "deletions": 106, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fbasics-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fbasics-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fbasics-unsafe.rs?ref=0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec", "patch": "@@ -1,106 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(specialization)]\n-\n-// Tests a variety of basic specialization scenarios and method\n-// dispatch for them.\n-\n-unsafe trait Foo {\n-    fn foo(&self) -> &'static str;\n-}\n-\n-default unsafe impl<T> Foo for T {\n-    fn foo(&self) -> &'static str {\n-        \"generic\"\n-    }\n-}\n-\n-default unsafe impl<T: Clone> Foo for T {\n-    fn foo(&self) -> &'static str {\n-        \"generic Clone\"\n-    }\n-}\n-\n-default unsafe impl<T, U> Foo for (T, U) where T: Clone, U: Clone {\n-    fn foo(&self) -> &'static str {\n-        \"generic pair\"\n-    }\n-}\n-\n-default unsafe impl<T: Clone> Foo for (T, T) {\n-    fn foo(&self) -> &'static str {\n-        \"generic uniform pair\"\n-    }\n-}\n-\n-default unsafe impl Foo for (u8, u32) {\n-    fn foo(&self) -> &'static str {\n-        \"(u8, u32)\"\n-    }\n-}\n-\n-default unsafe impl Foo for (u8, u8) {\n-    fn foo(&self) -> &'static str {\n-        \"(u8, u8)\"\n-    }\n-}\n-\n-default unsafe impl<T: Clone> Foo for Vec<T> {\n-    fn foo(&self) -> &'static str {\n-        \"generic Vec\"\n-    }\n-}\n-\n-default unsafe impl Foo for Vec<i32> {\n-    fn foo(&self) -> &'static str {\n-        \"Vec<i32>\"\n-    }\n-}\n-\n-default unsafe impl Foo for String {\n-    fn foo(&self) -> &'static str {\n-        \"String\"\n-    }\n-}\n-\n-default unsafe impl Foo for i32 {\n-    fn foo(&self) -> &'static str {\n-        \"i32\"\n-    }\n-}\n-\n-struct NotClone;\n-\n-unsafe trait MyMarker {}\n-default unsafe impl<T: Clone + MyMarker> Foo for T {\n-    fn foo(&self) -> &'static str {\n-        \"generic Clone + MyMarker\"\n-    }\n-}\n-\n-#[derive(Clone)]\n-struct MarkedAndClone;\n-unsafe impl MyMarker for MarkedAndClone {}\n-\n-fn  main() {\n-    assert!(NotClone.foo() == \"generic\");\n-    assert!(0u8.foo() == \"generic Clone\");\n-    assert!(vec![NotClone].foo() == \"generic\");\n-    assert!(vec![0u8].foo() == \"generic Vec\");\n-    assert!(vec![0i32].foo() == \"Vec<i32>\");\n-    assert!(0i32.foo() == \"i32\");\n-    assert!(String::new().foo() == \"String\");\n-    assert!(((), 0).foo() == \"generic pair\");\n-    assert!(((), ()).foo() == \"generic uniform pair\");\n-    assert!((0u8, 0u32).foo() == \"(u8, u32)\");\n-    assert!((0u8, 0u8).foo() == \"(u8, u8)\");\n-    assert!(MarkedAndClone.foo() == \"generic Clone + MyMarker\");\n-}"}, {"sha": "594f1e4fcdfc26b834c9bea5f57cd3482653b6d0", "filename": "src/test/run-pass/specialization/defaultimpl/basics.rs", "status": "removed", "additions": 0, "deletions": 106, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fbasics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fbasics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fbasics.rs?ref=0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec", "patch": "@@ -1,106 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(specialization)]\n-\n-// Tests a variety of basic specialization scenarios and method\n-// dispatch for them.\n-\n-trait Foo {\n-    fn foo(&self) -> &'static str;\n-}\n-\n-default impl<T> Foo for T {\n-    fn foo(&self) -> &'static str {\n-        \"generic\"\n-    }\n-}\n-\n-default impl<T: Clone> Foo for T {\n-    fn foo(&self) -> &'static str {\n-        \"generic Clone\"\n-    }\n-}\n-\n-default impl<T, U> Foo for (T, U) where T: Clone, U: Clone {\n-    fn foo(&self) -> &'static str {\n-        \"generic pair\"\n-    }\n-}\n-\n-default impl<T: Clone> Foo for (T, T) {\n-    fn foo(&self) -> &'static str {\n-        \"generic uniform pair\"\n-    }\n-}\n-\n-default impl Foo for (u8, u32) {\n-    fn foo(&self) -> &'static str {\n-        \"(u8, u32)\"\n-    }\n-}\n-\n-default impl Foo for (u8, u8) {\n-    fn foo(&self) -> &'static str {\n-        \"(u8, u8)\"\n-    }\n-}\n-\n-default impl<T: Clone> Foo for Vec<T> {\n-    fn foo(&self) -> &'static str {\n-        \"generic Vec\"\n-    }\n-}\n-\n-impl Foo for Vec<i32> {\n-    fn foo(&self) -> &'static str {\n-        \"Vec<i32>\"\n-    }\n-}\n-\n-impl Foo for String {\n-    fn foo(&self) -> &'static str {\n-        \"String\"\n-    }\n-}\n-\n-impl Foo for i32 {\n-    fn foo(&self) -> &'static str {\n-        \"i32\"\n-    }\n-}\n-\n-struct NotClone;\n-\n-trait MyMarker {}\n-default impl<T: Clone + MyMarker> Foo for T {\n-    fn foo(&self) -> &'static str {\n-        \"generic Clone + MyMarker\"\n-    }\n-}\n-\n-#[derive(Clone)]\n-struct MarkedAndClone;\n-impl MyMarker for MarkedAndClone {}\n-\n-fn  main() {\n-    assert!(NotClone.foo() == \"generic\");\n-    assert!(0u8.foo() == \"generic Clone\");\n-    assert!(vec![NotClone].foo() == \"generic\");\n-    assert!(vec![0u8].foo() == \"generic Vec\");\n-    assert!(vec![0i32].foo() == \"Vec<i32>\");\n-    assert!(0i32.foo() == \"i32\");\n-    assert!(String::new().foo() == \"String\");\n-    assert!(((), 0).foo() == \"generic pair\");\n-    assert!(((), ()).foo() == \"generic uniform pair\");\n-    assert!((0u8, 0u32).foo() == \"(u8, u32)\");\n-    assert!((0u8, 0u8).foo() == \"(u8, u8)\");\n-    assert!(MarkedAndClone.foo() == \"generic Clone + MyMarker\");\n-}"}, {"sha": "19e1af15bdd5627ce8bd0f7dc7f5e26e716d21f8", "filename": "src/test/run-pass/specialization/defaultimpl/cross-crate-defaults.rs", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fcross-crate-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fcross-crate-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fcross-crate-defaults.rs?ref=0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec", "patch": "@@ -1,49 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// aux-build:cross_crate_defaults.rs\n-\n-#![feature(specialization)]\n-\n-extern crate cross_crate_defaults;\n-\n-use cross_crate_defaults::*;\n-\n-struct LocalDefault;\n-struct LocalOverride;\n-\n-impl Foo for LocalDefault {}\n-\n-impl Foo for LocalOverride {\n-    fn foo(&self) -> bool { true }\n-}\n-\n-fn test_foo() {\n-    assert!(!0i8.foo());\n-    assert!(!0i32.foo());\n-    assert!(0i64.foo());\n-\n-    assert!(!LocalDefault.foo());\n-    assert!(LocalOverride.foo());\n-}\n-\n-fn test_bar() {\n-    assert!(0u8.bar() == 0);\n-    assert!(0i32.bar() == 1);\n-    assert!(\"hello\".bar() == 0);\n-    assert!(vec![()].bar() == 2);\n-    assert!(vec![0i32].bar() == 2);\n-    assert!(vec![0i64].bar() == 3);\n-}\n-\n-fn main() {\n-    test_foo();\n-    test_bar();\n-}"}, {"sha": "67cc694ae12c7087121c76cacbf2a749273923a5", "filename": "src/test/run-pass/specialization/defaultimpl/cross-crate-no-gate.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fcross-crate-no-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fcross-crate-no-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fcross-crate-no-gate.rs?ref=0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec", "patch": "@@ -1,29 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that specialization works even if only the upstream crate enables it\n-\n-// aux-build:cross_crate.rs\n-\n-extern crate cross_crate;\n-\n-use cross_crate::*;\n-\n-fn  main() {\n-    assert!(0u8.foo() == \"generic Clone\");\n-    assert!(vec![0u8].foo() == \"generic Vec\");\n-    assert!(vec![0i32].foo() == \"Vec<i32>\");\n-    assert!(0i32.foo() == \"i32\");\n-    assert!(String::new().foo() == \"String\");\n-    assert!(((), 0).foo() == \"generic pair\");\n-    assert!(((), ()).foo() == \"generic uniform pair\");\n-    assert!((0u8, 0u32).foo() == \"(u8, u32)\");\n-    assert!((0u8, 0u8).foo() == \"(u8, u8)\");\n-}"}, {"sha": "f1ad105db8f7c2bcd49476daca8e1ac14dedfbf0", "filename": "src/test/run-pass/specialization/defaultimpl/cross-crate.rs", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fcross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fcross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fcross-crate.rs?ref=0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec", "patch": "@@ -1,58 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// aux-build:cross_crate.rs\n-\n-#![feature(specialization)]\n-\n-extern crate cross_crate;\n-\n-use cross_crate::*;\n-\n-struct NotClone;\n-\n-#[derive(Clone)]\n-struct MarkedAndClone;\n-impl MyMarker for MarkedAndClone {}\n-\n-struct MyType<T>(T);\n-default impl<T> Foo for MyType<T> {\n-    fn foo(&self) -> &'static str {\n-        \"generic MyType\"\n-    }\n-}\n-\n-impl Foo for MyType<u8> {\n-    fn foo(&self) -> &'static str {\n-        \"MyType<u8>\"\n-    }\n-}\n-\n-struct MyOtherType;\n-impl Foo for MyOtherType {}\n-\n-fn  main() {\n-    assert!(NotClone.foo() == \"generic\");\n-    assert!(0u8.foo() == \"generic Clone\");\n-    assert!(vec![NotClone].foo() == \"generic\");\n-    assert!(vec![0u8].foo() == \"generic Vec\");\n-    assert!(vec![0i32].foo() == \"Vec<i32>\");\n-    assert!(0i32.foo() == \"i32\");\n-    assert!(String::new().foo() == \"String\");\n-    assert!(((), 0).foo() == \"generic pair\");\n-    assert!(((), ()).foo() == \"generic uniform pair\");\n-    assert!((0u8, 0u32).foo() == \"(u8, u32)\");\n-    assert!((0u8, 0u8).foo() == \"(u8, u8)\");\n-    assert!(MarkedAndClone.foo() == \"generic Clone + MyMarker\");\n-\n-    assert!(MyType(()).foo() == \"generic MyType\");\n-    assert!(MyType(0u8).foo() == \"MyType<u8>\");\n-    assert!(MyOtherType.foo() == \"generic\");\n-}"}, {"sha": "4ac9afc1c897fa27e4fcfe357475985563a4f588", "filename": "src/test/run-pass/specialization/defaultimpl/default-methods.rs", "status": "removed", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fdefault-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fdefault-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fdefault-methods.rs?ref=0be2dc8d9b4765e59cf9bbf3d342de00fa1b9aec", "patch": "@@ -1,94 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(specialization)]\n-\n-// Test that default methods are cascaded correctly\n-\n-// First, test only use of explicit `default` items:\n-\n-trait Foo {\n-    fn foo(&self) -> bool;\n-}\n-\n-// Specialization tree for Foo:\n-//\n-//        T\n-//       / \\\n-//    i32   i64\n-\n-default impl<T> Foo for T {\n-    fn foo(&self) -> bool { false }\n-}\n-\n-impl Foo for i32 {}\n-\n-impl Foo for i64 {\n-    fn foo(&self) -> bool { true }\n-}\n-\n-fn test_foo() {\n-    assert!(!0i8.foo());\n-    assert!(!0i32.foo());\n-    assert!(0i64.foo());\n-}\n-\n-// Next, test mixture of explicit `default` and provided methods:\n-\n-trait Bar {\n-    fn bar(&self) -> i32 { 0 }\n-}\n-\n-// Specialization tree for Bar.\n-// Uses of $ designate that method is provided\n-//\n-//           $Bar   (the trait)\n-//             |\n-//             T\n-//            /|\\\n-//           / | \\\n-//          /  |  \\\n-//         /   |   \\\n-//        /    |    \\\n-//       /     |     \\\n-//     $i32   &str  $Vec<T>\n-//                    /\\\n-//                   /  \\\n-//            Vec<i32>  $Vec<i64>\n-\n-// use the provided method\n-impl<T> Bar for T {}\n-\n-impl Bar for i32 {\n-    fn bar(&self) -> i32 { 1 }\n-}\n-impl<'a> Bar for &'a str {}\n-\n-default impl<T> Bar for Vec<T> {\n-    fn bar(&self) -> i32 { 2 }\n-}\n-impl Bar for Vec<i32> {}\n-impl Bar for Vec<i64> {\n-    fn bar(&self) -> i32 { 3 }\n-}\n-\n-fn test_bar() {\n-    assert!(0u8.bar() == 0);\n-    assert!(0i32.bar() == 1);\n-    assert!(\"hello\".bar() == 0);\n-    assert!(vec![()].bar() == 2);\n-    assert!(vec![0i32].bar() == 2);\n-    assert!(vec![0i64].bar() == 3);\n-}\n-\n-fn main() {\n-    test_foo();\n-    test_bar();\n-}"}, {"sha": "fc7312020053ebd9714beab7a8edbb3c26650ea8", "filename": "src/test/run-pass/specialization/defaultimpl/specialization-trait-item-not-implemented.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fspecialization-trait-item-not-implemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fspecialization-trait-item-not-implemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fspecialization-trait-item-not-implemented.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that we can combine a default impl that supplies one method with a\n+// full impl that supplies the other, and they can invoke one another.\n+\n+#![feature(specialization)]\n+\n+trait Foo {\n+    fn foo_one(&self) -> &'static str;\n+    fn foo_two(&self) -> &'static str;\n+    fn foo_three(&self) -> &'static str;\n+}\n+\n+struct MyStruct;\n+\n+default impl<T> Foo for T {\n+    fn foo_one(&self) -> &'static str {\n+        self.foo_three()\n+    }\n+}\n+\n+impl Foo for MyStruct {\n+    fn foo_two(&self) -> &'static str {\n+        self.foo_one()\n+    }\n+\n+    fn foo_three(&self) -> &'static str {\n+        \"generic\"\n+    }\n+}\n+\n+fn main() {\n+    assert!(MyStruct.foo_two() == \"generic\");\n+}"}, {"sha": "cd8ade5e51a1b748597ea000d83d6c17719e1a49", "filename": "src/test/ui/cast_char.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftest%2Fui%2Fcast_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftest%2Fui%2Fcast_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast_char.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(overflowing_literals)]\n+\n+fn main() {\n+    const XYZ: char = 0x1F888 as char;\n+    //~^ ERROR only u8 can be casted into char\n+    const XY: char = 129160 as char;\n+    //~^ ERROR only u8 can be casted into char\n+    const ZYX: char = '\\u{01F888}';\n+    println!(\"{}\", XYZ);\n+}"}, {"sha": "e42a38dace9d21aa48af4d79c02c324e35ba1e3a", "filename": "src/test/ui/cast_char.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftest%2Fui%2Fcast_char.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftest%2Fui%2Fcast_char.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast_char.stderr?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -0,0 +1,20 @@\n+error: only u8 can be casted into char\n+  --> $DIR/cast_char.rs:14:23\n+   |\n+14 |     const XYZ: char = 0x1F888 as char;\n+   |                       ^^^^^^^^^^^^^^^ help: use a char literal instead: `'/u{1F888}'`\n+   |\n+note: lint level defined here\n+  --> $DIR/cast_char.rs:11:9\n+   |\n+11 | #![deny(overflowing_literals)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: only u8 can be casted into char\n+  --> $DIR/cast_char.rs:16:22\n+   |\n+16 |     const XY: char = 129160 as char;\n+   |                      ^^^^^^^^^^^^^^ help: use a char literal instead: `'/u{1F888}'`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "3d421e00b08e44163d11adb8770f0db58f129cde", "filename": "src/test/ui/invalid-variadic-function.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftest%2Fui%2Finvalid-variadic-function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftest%2Fui%2Finvalid-variadic-function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-variadic-function.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern \"C\" fn foo(x: u8, ...);\n+//~^ ERROR only foreign functions are allowed to be variadic\n+//~| ERROR expected one of `->`, `where`, or `{`, found `;`"}, {"sha": "15a908b3f00f22f12b6f97f14661d00b663da95d", "filename": "src/test/ui/invalid-variadic-function.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftest%2Fui%2Finvalid-variadic-function.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftest%2Fui%2Finvalid-variadic-function.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-variadic-function.stderr?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -0,0 +1,14 @@\n+error: only foreign functions are allowed to be variadic\n+  --> $DIR/invalid-variadic-function.rs:11:26\n+   |\n+11 | extern \"C\" fn foo(x: u8, ...);\n+   |                          ^^^\n+\n+error: expected one of `->`, `where`, or `{`, found `;`\n+  --> $DIR/invalid-variadic-function.rs:11:30\n+   |\n+11 | extern \"C\" fn foo(x: u8, ...);\n+   |                              ^ expected one of `->`, `where`, or `{` here\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "486c0d81e3f407d0c3424cd049f3ea21df3e025a", "filename": "src/tools/compiletest/src/read2.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -58,9 +58,12 @@ mod imp {\n         fds[0].events = libc::POLLIN;\n         fds[1].fd = err_pipe.as_raw_fd();\n         fds[1].events = libc::POLLIN;\n-        loop {\n+        let mut nfds = 2;\n+        let mut errfd = 1;\n+\n+        while nfds > 0 {\n             // wait for either pipe to become readable using `select`\n-            let r = unsafe { libc::poll(fds.as_mut_ptr(), 2, -1) };\n+            let r = unsafe { libc::poll(fds.as_mut_ptr(), nfds, -1) };\n             if r == -1 {\n                 let err = io::Error::last_os_error();\n                 if err.kind() == io::ErrorKind::Interrupted {\n@@ -86,19 +89,20 @@ mod imp {\n                     }\n                 }\n             };\n-            if !out_done && fds[0].revents != 0 && handle(out_pipe.read_to_end(&mut out))? {\n-                out_done = true;\n-            }\n-            data(true, &mut out, out_done);\n-            if !err_done && fds[1].revents != 0 && handle(err_pipe.read_to_end(&mut err))? {\n+            if !err_done && fds[errfd].revents != 0 && handle(err_pipe.read_to_end(&mut err))? {\n                 err_done = true;\n+                nfds -= 1;\n             }\n             data(false, &mut err, err_done);\n-\n-            if out_done && err_done {\n-                return Ok(())\n+            if !out_done && fds[0].revents != 0 && handle(out_pipe.read_to_end(&mut out))? {\n+                out_done = true;\n+                fds[0].fd = err_pipe.as_raw_fd();\n+                errfd = 0;\n+                nfds -= 1;\n             }\n+            data(true, &mut out, out_done);\n         }\n+        Ok(())\n     }\n }\n "}, {"sha": "bef085e17ea160eb8703745deb55a935e0475a9d", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -250,6 +250,7 @@ impl<'test> TestCx<'test> {\n     fn run_cfail_test(&self) {\n         let proc_res = self.compile_test();\n         self.check_if_test_should_compile(&proc_res);\n+        self.check_no_compiler_crash(&proc_res);\n \n         let output_to_check = self.get_output(&proc_res);\n         let expected_errors = errors::load_errors(&self.testpaths.file, self.revision);\n@@ -262,7 +263,6 @@ impl<'test> TestCx<'test> {\n             self.check_error_patterns(&output_to_check, &proc_res);\n         }\n \n-        self.check_no_compiler_crash(&proc_res);\n         self.check_forbid_output(&output_to_check, &proc_res);\n     }\n "}, {"sha": "f01491115e821e10217574ad4091b08015b7b1c8", "filename": "src/tools/rls", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frls?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -1 +1 @@\n-Subproject commit dee42bda8156a28ead609080e27b02173bb9c29e\n+Subproject commit f01491115e821e10217574ad4091b08015b7b1c8"}, {"sha": "4dedf6bfe779bccb906eb8549fe00d6304136c4d", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf683edc0c0481906749517cbefe631f7ed79d9/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=2cf683edc0c0481906749517cbefe631f7ed79d9", "patch": "@@ -41,6 +41,7 @@ static EXCEPTIONS: &'static [&'static str] = &[\n     \"fuchsia-zircon\", // BSD-3-Clause, rustdoc, rustc, cargo (jobserver & tempdir)\n     \"cssparser-macros\", // MPL-2.0, rustdoc\n     \"selectors\", // MPL-2.0, rustdoc\n+    \"clippy_lints\", // MPL-2.0 rls\n ];\n \n pub fn check(path: &Path, bad: &mut bool) {"}]}