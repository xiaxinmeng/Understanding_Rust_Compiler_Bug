{"sha": "5e2c11034f9255f8b7bc7ded527d1db5175985f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlMmMxMTAzNGY5MjU1ZjhiN2JjN2RlZDUyN2QxZGI1MTc1OTg1Zjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-10T23:32:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-10T23:32:12Z"}, "message": "Auto merge of #60793 - Xanewok:raw-string-cleanup, r=petrochenkov\n\nlexer: Disallow bare CR in raw byte strings\n\nHandles bare CR ~but doesn't translate `\\r\\n` to `\\n` yet in raw strings yet~ and translates CRLF to LF in raw strings.\n\nAs a side-note I think it'd be good to change the `unescape_` to return plain iterators to reduce some boilerplate (e.g. `has_error` could benefit from collecting `Result<T>` and aborting early on errors) but will do that separately, unless I missed something here that prevents it.\n\n@matklad @petrochenkov thoughts?", "tree": {"sha": "0443ccac9ab63e6334eeddd541541e170944d26d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0443ccac9ab63e6334eeddd541541e170944d26d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e2c11034f9255f8b7bc7ded527d1db5175985f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e2c11034f9255f8b7bc7ded527d1db5175985f8", "html_url": "https://github.com/rust-lang/rust/commit/5e2c11034f9255f8b7bc7ded527d1db5175985f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e2c11034f9255f8b7bc7ded527d1db5175985f8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02564de47b40e953b5144dfd37450c16a84672f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/02564de47b40e953b5144dfd37450c16a84672f1", "html_url": "https://github.com/rust-lang/rust/commit/02564de47b40e953b5144dfd37450c16a84672f1"}, {"sha": "630d5f355fc85fc2c3bab28a278c517d945d328d", "url": "https://api.github.com/repos/rust-lang/rust/commits/630d5f355fc85fc2c3bab28a278c517d945d328d", "html_url": "https://github.com/rust-lang/rust/commit/630d5f355fc85fc2c3bab28a278c517d945d328d"}], "stats": {"total": 315, "additions": 180, "deletions": 135}, "files": [{"sha": "9df2898696ea62d8d041a5eb9d2dc944fd65ee73", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 58, "deletions": 100, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/5e2c11034f9255f8b7bc7ded527d1db5175985f8/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2c11034f9255f8b7bc7ded527d1db5175985f8/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=5e2c11034f9255f8b7bc7ded527d1db5175985f8", "patch": "@@ -130,7 +130,7 @@ impl<'a> StringReader<'a> {\n         self.ch.is_none()\n     }\n \n-    fn fail_unterminated_raw_string(&self, pos: BytePos, hash_count: u16) {\n+    fn fail_unterminated_raw_string(&self, pos: BytePos, hash_count: u16) -> ! {\n         let mut err = self.struct_span_fatal(pos, pos, \"unterminated raw string\");\n         err.span_label(self.mk_sp(pos, pos), \"unterminated raw string\");\n \n@@ -292,15 +292,6 @@ impl<'a> StringReader<'a> {\n         self.sess.span_diagnostic.struct_span_fatal(self.mk_sp(from_pos, to_pos), &m[..])\n     }\n \n-    /// Report a lexical error spanning [`from_pos`, `to_pos`), appending an\n-    /// escaped character to the error message\n-    fn err_span_char(&self, from_pos: BytePos, to_pos: BytePos, m: &str, c: char) {\n-        let mut m = m.to_string();\n-        m.push_str(\": \");\n-        push_escaped_char(&mut m, c);\n-        self.err_span_(from_pos, to_pos, &m[..]);\n-    }\n-\n     /// Advance peek_token to refer to the next token, and\n     /// possibly update the interner.\n     fn advance_token(&mut self) -> Result<(), ()> {\n@@ -1070,7 +1061,13 @@ impl<'a> StringReader<'a> {\n                         self.validate_byte_str_escape(start_with_quote);\n                         (token::ByteStr, symbol)\n                     },\n-                    Some('r') => self.scan_raw_byte_string(),\n+                    Some('r') => {\n+                        let (start, end, hash_count) = self.scan_raw_string();\n+                        let symbol = self.name_from_to(start, end);\n+                        self.validate_raw_byte_str_escape(start, end);\n+\n+                        (token::ByteStrRaw(hash_count), symbol)\n+                    }\n                     _ => unreachable!(),  // Should have been a token::Ident above.\n                 };\n                 let suffix = self.scan_optional_raw_name();\n@@ -1086,79 +1083,9 @@ impl<'a> StringReader<'a> {\n                 Ok(TokenKind::lit(token::Str, symbol, suffix))\n             }\n             'r' => {\n-                let start_bpos = self.pos;\n-                self.bump();\n-                let mut hash_count: u16 = 0;\n-                while self.ch_is('#') {\n-                    if hash_count == 65535 {\n-                        let bpos = self.next_pos;\n-                        self.fatal_span_(start_bpos,\n-                                         bpos,\n-                                         \"too many `#` symbols: raw strings may be \\\n-                                         delimited by up to 65535 `#` symbols\").raise();\n-                    }\n-                    self.bump();\n-                    hash_count += 1;\n-                }\n-\n-                if self.is_eof() {\n-                    self.fail_unterminated_raw_string(start_bpos, hash_count);\n-                } else if !self.ch_is('\"') {\n-                    let last_bpos = self.pos;\n-                    let curr_char = self.ch.unwrap();\n-                    self.fatal_span_char(start_bpos,\n-                                         last_bpos,\n-                                         \"found invalid character; only `#` is allowed \\\n-                                         in raw string delimitation\",\n-                                         curr_char).raise();\n-                }\n-                self.bump();\n-                let content_start_bpos = self.pos;\n-                let mut content_end_bpos;\n-                let mut valid = true;\n-                'outer: loop {\n-                    if self.is_eof() {\n-                        self.fail_unterminated_raw_string(start_bpos, hash_count);\n-                    }\n-                    // if self.ch_is('\"') {\n-                    // content_end_bpos = self.pos;\n-                    // for _ in 0..hash_count {\n-                    // self.bump();\n-                    // if !self.ch_is('#') {\n-                    // continue 'outer;\n-                    let c = self.ch.unwrap();\n-                    match c {\n-                        '\"' => {\n-                            content_end_bpos = self.pos;\n-                            for _ in 0..hash_count {\n-                                self.bump();\n-                                if !self.ch_is('#') {\n-                                    continue 'outer;\n-                                }\n-                            }\n-                            break;\n-                        }\n-                        '\\r' => {\n-                            if !self.nextch_is('\\n') {\n-                                let last_bpos = self.pos;\n-                                self.err_span_(start_bpos,\n-                                               last_bpos,\n-                                               \"bare CR not allowed in raw string, use \\\\r \\\n-                                                instead\");\n-                                valid = false;\n-                            }\n-                        }\n-                        _ => (),\n-                    }\n-                    self.bump();\n-                }\n-\n-                self.bump();\n-                let symbol = if valid {\n-                    self.name_from_to(content_start_bpos, content_end_bpos)\n-                } else {\n-                    Symbol::intern(\"??\")\n-                };\n+                let (start, end, hash_count) = self.scan_raw_string();\n+                let symbol = self.name_from_to(start, end);\n+                self.validate_raw_str_escape(start, end);\n                 let suffix = self.scan_optional_raw_name();\n \n                 Ok(TokenKind::lit(token::StrRaw(hash_count), symbol, suffix))\n@@ -1315,16 +1242,18 @@ impl<'a> StringReader<'a> {\n         id\n     }\n \n-    fn scan_raw_byte_string(&mut self) -> (token::LitKind, Symbol) {\n+    /// Scans a raw (byte) string, returning byte position range for `\"<literal>\"`\n+    /// (including quotes) along with `#` character count in `(b)r##...\"<literal>\"##...`;\n+    fn scan_raw_string(&mut self) -> (BytePos, BytePos, u16) {\n         let start_bpos = self.pos;\n         self.bump();\n-        let mut hash_count = 0;\n+        let mut hash_count: u16 = 0;\n         while self.ch_is('#') {\n             if hash_count == 65535 {\n                 let bpos = self.next_pos;\n                 self.fatal_span_(start_bpos,\n                                  bpos,\n-                                 \"too many `#` symbols: raw byte strings may be \\\n+                                 \"too many `#` symbols: raw strings may be \\\n                                  delimited by up to 65535 `#` symbols\").raise();\n             }\n             self.bump();\n@@ -1334,13 +1263,13 @@ impl<'a> StringReader<'a> {\n         if self.is_eof() {\n             self.fail_unterminated_raw_string(start_bpos, hash_count);\n         } else if !self.ch_is('\"') {\n-            let pos = self.pos;\n-            let ch = self.ch.unwrap();\n+            let last_bpos = self.pos;\n+            let curr_char = self.ch.unwrap();\n             self.fatal_span_char(start_bpos,\n-                                        pos,\n-                                        \"found invalid character; only `#` is allowed in raw \\\n-                                         string delimitation\",\n-                                        ch).raise();\n+                                 last_bpos,\n+                                 \"found invalid character; only `#` is allowed \\\n+                                 in raw string delimitation\",\n+                                 curr_char).raise();\n         }\n         self.bump();\n         let content_start_bpos = self.pos;\n@@ -1360,19 +1289,14 @@ impl<'a> StringReader<'a> {\n                     }\n                     break;\n                 }\n-                Some(c) => {\n-                    if c > '\\x7F' {\n-                        let pos = self.pos;\n-                        self.err_span_char(pos, pos, \"raw byte string must be ASCII\", c);\n-                    }\n-                }\n+                _ => (),\n             }\n             self.bump();\n         }\n \n         self.bump();\n \n-        (token::ByteStrRaw(hash_count), self.name_from_to(content_start_bpos, content_end_bpos))\n+        (content_start_bpos, content_end_bpos, hash_count)\n     }\n \n     fn validate_char_escape(&self, start_with_quote: BytePos) {\n@@ -1422,6 +1346,40 @@ impl<'a> StringReader<'a> {\n         });\n     }\n \n+    fn validate_raw_str_escape(&self, content_start: BytePos, content_end: BytePos) {\n+        self.with_str_from_to(content_start, content_end, |lit: &str| {\n+            unescape::unescape_raw_str(lit, &mut |range, c| {\n+                if let Err(err) = c {\n+                    emit_unescape_error(\n+                        &self.sess.span_diagnostic,\n+                        lit,\n+                        self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n+                        unescape::Mode::Str,\n+                        range,\n+                        err,\n+                    )\n+                }\n+            })\n+        });\n+    }\n+\n+    fn validate_raw_byte_str_escape(&self, content_start: BytePos, content_end: BytePos) {\n+        self.with_str_from_to(content_start, content_end, |lit: &str| {\n+            unescape::unescape_raw_byte_str(lit, &mut |range, c| {\n+                if let Err(err) = c {\n+                    emit_unescape_error(\n+                        &self.sess.span_diagnostic,\n+                        lit,\n+                        self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n+                        unescape::Mode::ByteStr,\n+                        range,\n+                        err,\n+                    )\n+                }\n+            })\n+        });\n+    }\n+\n     fn validate_byte_str_escape(&self, start_with_quote: BytePos) {\n         self.with_str_from_to(start_with_quote + BytePos(1), self.pos - BytePos(1), |lit| {\n             unescape::unescape_byte_str(lit, &mut |range, c| {"}, {"sha": "ef55bf6b929336511e4dc5f3fb5d0317e500535f", "filename": "src/libsyntax/parse/literal.rs", "status": "modified", "additions": 34, "deletions": 26, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5e2c11034f9255f8b7bc7ded527d1db5175985f8/src%2Flibsyntax%2Fparse%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2c11034f9255f8b7bc7ded527d1db5175985f8/src%2Flibsyntax%2Fparse%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fliteral.rs?ref=5e2c11034f9255f8b7bc7ded527d1db5175985f8", "patch": "@@ -4,7 +4,9 @@ use crate::ast::{self, Lit, LitKind};\n use crate::parse::parser::Parser;\n use crate::parse::PResult;\n use crate::parse::token::{self, Token, TokenKind};\n-use crate::parse::unescape::{unescape_str, unescape_char, unescape_byte_str, unescape_byte};\n+use crate::parse::unescape::{unescape_char, unescape_byte};\n+use crate::parse::unescape::{unescape_str, unescape_byte_str};\n+use crate::parse::unescape::{unescape_raw_str, unescape_raw_byte_str};\n use crate::print::pprust;\n use crate::symbol::{kw, sym, Symbol};\n use crate::tokenstream::{TokenStream, TokenTree};\n@@ -141,7 +143,17 @@ impl LitKind {\n                 // Ditto.\n                 let s = symbol.as_str();\n                 let symbol = if s.contains('\\r') {\n-                    Symbol::intern(&raw_str_lit(&s))\n+                    let mut buf = String::with_capacity(s.len());\n+                    let mut error = Ok(());\n+                    unescape_raw_str(&s, &mut |_, unescaped_char| {\n+                        match unescaped_char {\n+                            Ok(c) => buf.push(c),\n+                            Err(_) => error = Err(LitError::LexerError),\n+                        }\n+                    });\n+                    error?;\n+                    buf.shrink_to_fit();\n+                    Symbol::intern(&buf)\n                 } else {\n                     symbol\n                 };\n@@ -161,7 +173,26 @@ impl LitKind {\n                 buf.shrink_to_fit();\n                 LitKind::ByteStr(Lrc::new(buf))\n             }\n-            token::ByteStrRaw(_) => LitKind::ByteStr(Lrc::new(symbol.to_string().into_bytes())),\n+            token::ByteStrRaw(_) => {\n+                let s = symbol.as_str();\n+                let bytes = if s.contains('\\r') {\n+                    let mut buf = Vec::with_capacity(s.len());\n+                    let mut error = Ok(());\n+                    unescape_raw_byte_str(&s, &mut |_, unescaped_byte| {\n+                        match unescaped_byte {\n+                            Ok(c) => buf.push(c),\n+                            Err(_) => error = Err(LitError::LexerError),\n+                        }\n+                    });\n+                    error?;\n+                    buf.shrink_to_fit();\n+                    buf\n+                } else {\n+                    symbol.to_string().into_bytes()\n+                };\n+\n+                LitKind::ByteStr(Lrc::new(bytes))\n+            },\n             token::Err => LitKind::Err(symbol),\n         })\n     }\n@@ -353,29 +384,6 @@ crate fn expect_no_suffix(diag: &Handler, sp: Span, kind: &str, suffix: Option<S\n     }\n }\n \n-/// Parses a string representing a raw string literal into its final form. The\n-/// only operation this does is convert embedded CRLF into a single LF.\n-fn raw_str_lit(lit: &str) -> String {\n-    debug!(\"raw_str_lit: {:?}\", lit);\n-    let mut res = String::with_capacity(lit.len());\n-\n-    let mut chars = lit.chars().peekable();\n-    while let Some(c) = chars.next() {\n-        if c == '\\r' {\n-            if *chars.peek().unwrap() != '\\n' {\n-                panic!(\"lexer accepted bare CR\");\n-            }\n-            chars.next();\n-            res.push('\\n');\n-        } else {\n-            res.push(c);\n-        }\n-    }\n-\n-    res.shrink_to_fit();\n-    res\n-}\n-\n // Checks if `s` looks like i32 or u1234 etc.\n fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n     s.len() > 1 && s.starts_with(first_chars) && s[1..].chars().all(|c| c.is_ascii_digit())"}, {"sha": "22cce67b5eeb7b5202fd5b4ae50fae1bfa832617", "filename": "src/libsyntax/parse/unescape.rs", "status": "modified", "additions": 59, "deletions": 2, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/5e2c11034f9255f8b7bc7ded527d1db5175985f8/src%2Flibsyntax%2Fparse%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2c11034f9255f8b7bc7ded527d1db5175985f8/src%2Flibsyntax%2Fparse%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Funescape.rs?ref=5e2c11034f9255f8b7bc7ded527d1db5175985f8", "patch": "@@ -1,4 +1,4 @@\n-//! Utilities for validating  string and char literals and turning them into\n+//! Utilities for validating string and char literals and turning them into\n //! values they represent.\n \n use std::str::Chars;\n@@ -12,6 +12,7 @@ pub(crate) enum EscapeError {\n     LoneSlash,\n     InvalidEscape,\n     BareCarriageReturn,\n+    BareCarriageReturnInRawString,\n     EscapeOnlyChar,\n \n     TooShortHexEscape,\n@@ -29,6 +30,7 @@ pub(crate) enum EscapeError {\n \n     UnicodeEscapeInByte,\n     NonAsciiCharInByte,\n+    NonAsciiCharInByteString,\n }\n \n /// Takes a contents of a char literal (without quotes), and returns an\n@@ -66,6 +68,30 @@ where\n     })\n }\n \n+/// Takes a contents of a string literal (without quotes) and produces a\n+/// sequence of characters or errors.\n+/// NOTE: Raw strings do not perform any explicit character escaping, here we\n+/// only translate CRLF to LF and produce errors on bare CR.\n+pub(crate) fn unescape_raw_str<F>(literal_text: &str, callback: &mut F)\n+where\n+    F: FnMut(Range<usize>, Result<char, EscapeError>),\n+{\n+    unescape_raw_str_or_byte_str(literal_text, Mode::Str, callback)\n+}\n+\n+/// Takes a contents of a string literal (without quotes) and produces a\n+/// sequence of characters or errors.\n+/// NOTE: Raw strings do not perform any explicit character escaping, here we\n+/// only translate CRLF to LF and produce errors on bare CR.\n+pub(crate) fn unescape_raw_byte_str<F>(literal_text: &str, callback: &mut F)\n+where\n+    F: FnMut(Range<usize>, Result<u8, EscapeError>),\n+{\n+    unescape_raw_str_or_byte_str(literal_text, Mode::ByteStr, &mut |range, char| {\n+        callback(range, char.map(byte_from_char))\n+    })\n+}\n+\n #[derive(Debug, Clone, Copy)]\n pub(crate) enum Mode {\n     Char,\n@@ -254,9 +280,40 @@ where\n     }\n }\n \n+/// Takes a contents of a string literal (without quotes) and produces a\n+/// sequence of characters or errors.\n+/// NOTE: Raw strings do not perform any explicit character escaping, here we\n+/// only translate CRLF to LF and produce errors on bare CR.\n+fn unescape_raw_str_or_byte_str<F>(literal_text: &str, mode: Mode, callback: &mut F)\n+where\n+    F: FnMut(Range<usize>, Result<char, EscapeError>),\n+{\n+    assert!(mode.in_double_quotes());\n+    let initial_len = literal_text.len();\n+\n+    let mut chars = literal_text.chars();\n+    while let Some(curr) = chars.next() {\n+        let start = initial_len - chars.as_str().len() - curr.len_utf8();\n+\n+        let result = match (curr, chars.clone().next()) {\n+            ('\\r', Some('\\n')) => {\n+                chars.next();\n+                Ok('\\n')\n+            },\n+            ('\\r', _) => Err(EscapeError::BareCarriageReturnInRawString),\n+            (c, _) if mode.is_bytes() && !c.is_ascii() =>\n+                Err(EscapeError::NonAsciiCharInByteString),\n+            (c, _) => Ok(c),\n+        };\n+        let end = initial_len - chars.as_str().len();\n+\n+        callback(start..end, result);\n+    }\n+}\n+\n fn byte_from_char(c: char) -> u8 {\n     let res = c as u32;\n-    assert!(res <= u8::max_value() as u32, \"guaranteed because of Mode::Byte\");\n+    assert!(res <= u8::max_value() as u32, \"guaranteed because of Mode::Byte(Str)\");\n     res as u8\n }\n "}, {"sha": "71b41161ad8c6fd00553ad0f21e526a818e04c42", "filename": "src/libsyntax/parse/unescape_error_reporting.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e2c11034f9255f8b7bc7ded527d1db5175985f8/src%2Flibsyntax%2Fparse%2Funescape_error_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2c11034f9255f8b7bc7ded527d1db5175985f8/src%2Flibsyntax%2Fparse%2Funescape_error_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Funescape_error_reporting.rs?ref=5e2c11034f9255f8b7bc7ded527d1db5175985f8", "patch": "@@ -80,6 +80,11 @@ pub(crate) fn emit_unescape_error(\n             };\n             handler.span_err(span, msg);\n         }\n+        EscapeError::BareCarriageReturnInRawString => {\n+            assert!(mode.in_double_quotes());\n+            let msg = \"bare CR not allowed in raw string\";\n+            handler.span_err(span, msg);\n+        }\n         EscapeError::InvalidEscape => {\n             let (c, span) = last_char();\n \n@@ -124,6 +129,11 @@ pub(crate) fn emit_unescape_error(\n             handler.span_err(span, \"byte constant must be ASCII. \\\n                                     Use a \\\\xHH escape for a non-ASCII byte\")\n         }\n+        EscapeError::NonAsciiCharInByteString => {\n+            assert!(mode.is_bytes());\n+            let (_c, span) = last_char();\n+            handler.span_err(span, \"raw byte string must be ASCII\")\n+        }\n         EscapeError::OutOfRangeHexEscape => {\n             handler.span_err(span, \"this form of character escape may only be used \\\n                                     with characters in the range [\\\\x00-\\\\x7f]\")"}, {"sha": "f9d1b17b8dd823a2c5debdeea4b62425b8db5b8e", "filename": "src/test/run-pass/lexer-crlf-line-endings-string-literal-doc-comment.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e2c11034f9255f8b7bc7ded527d1db5175985f8/src%2Ftest%2Frun-pass%2Flexer-crlf-line-endings-string-literal-doc-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2c11034f9255f8b7bc7ded527d1db5175985f8/src%2Ftest%2Frun-pass%2Flexer-crlf-line-endings-string-literal-doc-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flexer-crlf-line-endings-string-literal-doc-comment.rs?ref=5e2c11034f9255f8b7bc7ded527d1db5175985f8", "patch": "@@ -30,6 +30,9 @@ literal\";\n     let s = r\"string\r\n literal\";\r\n     assert_eq!(s, \"string\\nliteral\");\r\n+    let s = br\"byte string\r\n+literal\";\r\n+    assert_eq!(s, \"byte string\\nliteral\".as_bytes());\r\n \r\n     // validate that our source file has CRLF endings\r\n     let source = include_str!(\"lexer-crlf-line-endings-string-literal-doc-comment.rs\");\r"}, {"sha": "b0fe4b6acd48443a7d939b0900b69c3f7ed9edf8", "filename": "src/test/ui/parser/lex-bare-cr-string-literal-doc-comment.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e2c11034f9255f8b7bc7ded527d1db5175985f8/src%2Ftest%2Fui%2Fparser%2Flex-bare-cr-string-literal-doc-comment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e2c11034f9255f8b7bc7ded527d1db5175985f8/src%2Ftest%2Fui%2Fparser%2Flex-bare-cr-string-literal-doc-comment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flex-bare-cr-string-literal-doc-comment.stderr?ref=5e2c11034f9255f8b7bc7ded527d1db5175985f8", "patch": "@@ -28,11 +28,11 @@ error: bare CR not allowed in string, use \\r instead\n LL |     let _s = \"foo\rbar\";\n    |                  ^\n \n-error: bare CR not allowed in raw string, use \\r instead\n-  --> $DIR/lex-bare-cr-string-literal-doc-comment.rs:24:14\n+error: bare CR not allowed in raw string\n+  --> $DIR/lex-bare-cr-string-literal-doc-comment.rs:24:19\n    |\n LL |     let _s = r\"bar\rfoo\";\n-   |              ^^^^^\n+   |                   ^\n \n error: unknown character escape: \\r\n   --> $DIR/lex-bare-cr-string-literal-doc-comment.rs:27:19"}, {"sha": "534afabdf777e30023b6ebae60771942822d6763", "filename": "src/test/ui/parser/raw-byte-string-literals.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e2c11034f9255f8b7bc7ded527d1db5175985f8/src%2Ftest%2Fui%2Fparser%2Fraw-byte-string-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2c11034f9255f8b7bc7ded527d1db5175985f8/src%2Ftest%2Fui%2Fparser%2Fraw-byte-string-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw-byte-string-literals.rs?ref=5e2c11034f9255f8b7bc7ded527d1db5175985f8", "patch": "@@ -1,4 +1,7 @@\n+// ignore-tidy-cr\n+// compile-flags: -Z continue-parse-after-error\n pub fn main() {\n+    br\"a\r\"; //~ ERROR bare CR not allowed in raw string\n     br\"\u00e9\";  //~ ERROR raw byte string must be ASCII\n     br##~\"a\"~##;  //~ ERROR only `#` is allowed in raw string delimitation\n }"}, {"sha": "4880d1fdbe8a730b9d673174acc711047038b0f1", "filename": "src/test/ui/parser/raw-byte-string-literals.stderr", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5e2c11034f9255f8b7bc7ded527d1db5175985f8/src%2Ftest%2Fui%2Fparser%2Fraw-byte-string-literals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e2c11034f9255f8b7bc7ded527d1db5175985f8/src%2Ftest%2Fui%2Fparser%2Fraw-byte-string-literals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw-byte-string-literals.stderr?ref=5e2c11034f9255f8b7bc7ded527d1db5175985f8", "patch": "@@ -1,14 +1,20 @@\n-error: raw byte string must be ASCII: \\u{e9}\n-  --> $DIR/raw-byte-string-literals.rs:2:8\n+error: bare CR not allowed in raw string\n+  --> $DIR/raw-byte-string-literals.rs:4:9\n+   |\n+LL |     br\"a\r\";\n+   |         ^\n+\n+error: raw byte string must be ASCII\n+  --> $DIR/raw-byte-string-literals.rs:5:8\n    |\n LL |     br\"\u00e9\";\n    |        ^\n \n error: found invalid character; only `#` is allowed in raw string delimitation: ~\n-  --> $DIR/raw-byte-string-literals.rs:3:6\n+  --> $DIR/raw-byte-string-literals.rs:6:6\n    |\n LL |     br##~\"a\"~##;\n    |      ^^^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n "}]}