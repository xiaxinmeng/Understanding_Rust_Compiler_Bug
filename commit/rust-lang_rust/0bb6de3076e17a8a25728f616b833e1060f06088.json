{"sha": "0bb6de3076e17a8a25728f616b833e1060f06088", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiYjZkZTMwNzZlMTdhOGEyNTcyOGY2MTZiODMzZTEwNjBmMDYwODg=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-15T20:29:34Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-17T07:53:08Z"}, "message": "De-@ move maps and rework parts of trans.", "tree": {"sha": "ab4ba01475f20856614171f7240d17fec975079e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab4ba01475f20856614171f7240d17fec975079e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0bb6de3076e17a8a25728f616b833e1060f06088", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0bb6de3076e17a8a25728f616b833e1060f06088", "html_url": "https://github.com/rust-lang/rust/commit/0bb6de3076e17a8a25728f616b833e1060f06088", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0bb6de3076e17a8a25728f616b833e1060f06088/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f64d4126b982b88368dc39c45e28aae5301e6a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f64d4126b982b88368dc39c45e28aae5301e6a2", "html_url": "https://github.com/rust-lang/rust/commit/3f64d4126b982b88368dc39c45e28aae5301e6a2"}], "stats": {"total": 2050, "additions": 982, "deletions": 1068}, "files": [{"sha": "13625993200765f7e16df4a1abff858baee73237", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -559,7 +559,7 @@ fn get_symbol_hash(ccx: &CrateContext, t: ty::t) -> ~str {\n \n     let mut type_hashcodes = ccx.type_hashcodes.borrow_mut();\n     let mut symbol_hasher = ccx.symbol_hasher.borrow_mut();\n-    let hash = symbol_hash(ccx.tcx, symbol_hasher.get(), t, &ccx.link_meta);\n+    let hash = symbol_hash(ccx.tcx(), symbol_hasher.get(), t, &ccx.link_meta);\n     type_hashcodes.get().insert(t, hash.clone());\n     hash\n }\n@@ -694,7 +694,7 @@ pub fn mangle_exported_name(ccx: &CrateContext, path: PathElems,\n pub fn mangle_internal_name_by_type_only(ccx: &CrateContext,\n                                          t: ty::t,\n                                          name: &str) -> ~str {\n-    let s = ppaux::ty_to_short_str(ccx.tcx, t);\n+    let s = ppaux::ty_to_short_str(ccx.tcx(), t);\n     let path = [PathName(token::intern(name)),\n                 PathName(token::intern(s))];\n     let hash = get_symbol_hash(ccx, t);\n@@ -704,7 +704,7 @@ pub fn mangle_internal_name_by_type_only(ccx: &CrateContext,\n pub fn mangle_internal_name_by_type_and_seq(ccx: &CrateContext,\n                                             t: ty::t,\n                                             name: &str) -> ~str {\n-    let s = ppaux::ty_to_str(ccx.tcx, t);\n+    let s = ppaux::ty_to_str(ccx.tcx(), t);\n     let path = [PathName(token::intern(s)),\n                 gensym_name(name)];\n     let hash = get_symbol_hash(ccx, t);"}, {"sha": "7ffbab4c9b37a594651dc3c5d22a607d5e67f52c", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -35,6 +35,7 @@ use std::cell::{Cell, RefCell};\n use std::io;\n use std::io::fs;\n use std::io::MemReader;\n+use std::mem::drop;\n use std::os;\n use std::vec_ng::Vec;\n use std::vec_ng;\n@@ -357,17 +358,20 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n \n     time(time_passes, \"match checking\", (), |_|\n          middle::check_match::check_crate(&ty_cx, method_map,\n-                                          moves_map, krate));\n+                                          &moves_map, krate));\n \n     time(time_passes, \"liveness checking\", (), |_|\n          middle::liveness::check_crate(&ty_cx, method_map,\n-                                       capture_map, krate));\n+                                       &capture_map, krate));\n \n     let root_map =\n         time(time_passes, \"borrow checking\", (), |_|\n              middle::borrowck::check_crate(&ty_cx, method_map,\n-                                           moves_map, moved_variables_set,\n-                                           capture_map, krate));\n+                                           &moves_map, &moved_variables_set,\n+                                           &capture_map, krate));\n+\n+    drop(moves_map);\n+    drop(moved_variables_set);\n \n     time(time_passes, \"kind checking\", (), |_|\n          kind::check_crate(&ty_cx, method_map, krate));\n@@ -396,7 +400,7 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n             root_map: root_map,\n             method_map: method_map,\n             vtable_map: vtable_map,\n-            capture_map: capture_map\n+            capture_map: RefCell::new(capture_map)\n         },\n         reachable: reachable_map\n     }\n@@ -414,10 +418,13 @@ pub struct CrateTranslation {\n /// Run the translation phase to LLVM, after which the AST and analysis can\n /// be discarded.\n pub fn phase_4_translate_to_llvm(krate: ast::Crate,\n-                                 analysis: &CrateAnalysis,\n-                                 outputs: &OutputFilenames) -> CrateTranslation {\n-    time(analysis.ty_cx.sess.time_passes(), \"translation\", krate, |krate|\n-         trans::base::trans_crate(krate, analysis, outputs))\n+                                 analysis: CrateAnalysis,\n+                                 outputs: &OutputFilenames) -> (ty::ctxt, CrateTranslation) {\n+    // Option dance to work around the lack of stack once closures.\n+    let time_passes = analysis.ty_cx.sess.time_passes();\n+    let mut analysis = Some(analysis);\n+    time(time_passes, \"translation\", krate, |krate|\n+         trans::base::trans_crate(krate, analysis.take_unwrap(), outputs))\n }\n \n /// Run LLVM itself, producing a bitcode file, assembly file or object file\n@@ -582,9 +589,9 @@ pub fn compile_input(sess: Session, cfg: ast::CrateConfig, input: &Input,\n \n         let analysis = phase_3_run_analysis_passes(sess, &expanded_crate, ast_map);\n         if stop_after_phase_3(&analysis.ty_cx.sess) { return; }\n-        let trans = phase_4_translate_to_llvm(expanded_crate,\n-                                              &analysis, &outputs);\n-        (outputs, trans, analysis.ty_cx.sess)\n+        let (tcx, trans) = phase_4_translate_to_llvm(expanded_crate,\n+                                                     analysis, &outputs);\n+        (outputs, trans, tcx.sess)\n     };\n     phase_5_run_llvm_passes(&sess, &trans, &outputs);\n     if stop_after_phase_5(&sess) { return; }"}, {"sha": "da16a345763ec7b8a4a45471fc09bfe50a1038eb", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -34,6 +34,7 @@ use syntax;\n \n use std::libc;\n use std::cast;\n+use std::cell::RefCell;\n use std::io::Seek;\n use std::rc::Rc;\n use std::vec_ng::Vec;\n@@ -53,13 +54,13 @@ pub struct Maps {\n     root_map: middle::borrowck::root_map,\n     method_map: middle::typeck::MethodMap,\n     vtable_map: middle::typeck::vtable_map,\n-    capture_map: middle::moves::CaptureMap,\n+    capture_map: RefCell<middle::moves::CaptureMap>,\n }\n \n struct DecodeContext<'a> {\n     cdata: @cstore::crate_metadata,\n     tcx: &'a ty::ctxt,\n-    maps: Maps\n+    maps: &'a Maps\n }\n \n struct ExtendedDecodeContext<'a> {\n@@ -82,7 +83,7 @@ trait tr_intern {\n pub fn encode_inlined_item(ecx: &e::EncodeContext,\n                            ebml_w: &mut writer::Encoder,\n                            ii: e::InlinedItemRef,\n-                           maps: Maps) {\n+                           maps: &Maps) {\n     let id = match ii {\n         e::IIItemRef(i) => i.id,\n         e::IIForeignRef(i) => i.id,\n@@ -115,7 +116,7 @@ pub fn encode_exported_macro(ebml_w: &mut writer::Encoder, i: &ast::Item) {\n \n pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n                            tcx: &ty::ctxt,\n-                           maps: Maps,\n+                           maps: &Maps,\n                            path: Vec<ast_map::PathElem>,\n                            par_doc: ebml::Doc)\n                            -> Result<ast::InlinedItem, Vec<ast_map::PathElem>> {\n@@ -906,7 +907,7 @@ impl<'a> write_tag_and_id for writer::Encoder<'a> {\n struct SideTableEncodingIdVisitor<'a,'b> {\n     ecx_ptr: *libc::c_void,\n     new_ebml_w: &'a mut writer::Encoder<'b>,\n-    maps: Maps,\n+    maps: &'a Maps,\n }\n \n impl<'a,'b> ast_util::IdVisitingOperation for\n@@ -929,7 +930,7 @@ impl<'a,'b> ast_util::IdVisitingOperation for\n }\n \n fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n-                             maps: Maps,\n+                             maps: &Maps,\n                              ebml_w: &mut writer::Encoder,\n                              ii: &ast::InlinedItem) {\n     ebml_w.start_tag(c::tag_table as uint);\n@@ -951,7 +952,7 @@ fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n }\n \n fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n-                             maps: Maps,\n+                             maps: &Maps,\n                              ebml_w: &mut writer::Encoder,\n                              id: ast::NodeId) {\n     let tcx = ecx.tcx;\n@@ -1075,20 +1076,16 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         }\n     }\n \n-    {\n-        let capture_map = maps.capture_map.borrow();\n-        let r = capture_map.get().find(&id);\n-        for &cap_vars in r.iter() {\n-            ebml_w.tag(c::tag_table_capture_map, |ebml_w| {\n-                ebml_w.id(id);\n-                ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                    ebml_w.emit_from_vec(cap_vars.deref().as_slice(),\n-                                         |ebml_w, cap_var| {\n-                        cap_var.encode(ebml_w);\n-                    })\n+    for &cap_vars in maps.capture_map.borrow().get().find(&id).iter() {\n+        ebml_w.tag(c::tag_table_capture_map, |ebml_w| {\n+            ebml_w.id(id);\n+            ebml_w.tag(c::tag_table_val, |ebml_w| {\n+                ebml_w.emit_from_vec(cap_vars.deref().as_slice(),\n+                                        |ebml_w, cap_var| {\n+                    cap_var.encode(ebml_w);\n                 })\n             })\n-        }\n+        })\n     }\n }\n "}, {"sha": "5faf9c9986baeb8a24404ff5763c578727397cd4", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -715,9 +715,7 @@ impl<'a> CheckLoanCtxt<'a> {\n     fn check_captured_variables(&self,\n                                 closure_id: ast::NodeId,\n                                 span: Span) {\n-        let capture_map = self.bccx.capture_map.borrow();\n-        let cap_vars = capture_map.get().get(&closure_id);\n-        for cap_var in cap_vars.deref().iter() {\n+        for cap_var in self.bccx.capture_map.get(&closure_id).deref().iter() {\n             let var_id = ast_util::def_id_of_def(cap_var.def).node;\n             let var_path = @LpVar(var_id);\n             self.check_if_path_is_moved(closure_id, span,"}, {"sha": "3d5ea0e89b2e6224ae6f3cedcc87e0885b48e249", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -47,9 +47,7 @@ pub fn gather_move_from_pat(bccx: &BorrowckCtxt,\n pub fn gather_captures(bccx: &BorrowckCtxt,\n                        move_data: &MoveData,\n                        closure_expr: &ast::Expr) {\n-    let capture_map = bccx.capture_map.borrow();\n-    let captured_vars = capture_map.get().get(&closure_expr.id);\n-    for captured_var in captured_vars.deref().iter() {\n+    for captured_var in bccx.capture_map.get(&closure_expr.id).deref().iter() {\n         match captured_var.mode {\n             moves::CapMove => {\n                 let cmt = bccx.cat_captured_var(closure_expr.id,"}, {"sha": "7f810aabf0fdf711ffa5f202fc4aa54e0853bce7", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -261,10 +261,7 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n         match cmt.guarantor().cat {\n             mc::cat_local(id) |\n             mc::cat_arg(id) => {\n-                let moved_variables_set = self.bccx\n-                                              .moved_variables_set\n-                                              .borrow();\n-                moved_variables_set.get().contains(&id)\n+                self.bccx.moved_variables_set.contains(&id)\n             }\n             mc::cat_rvalue(..) |\n             mc::cat_static_item |"}, {"sha": "3c3c4371ebb01472d90867287ee2b7d6388c7c06", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -440,9 +440,7 @@ impl<'a> GatherLoanCtxt<'a> {\n \n     fn guarantee_captures(&mut self,\n                           closure_expr: &ast::Expr) {\n-        let capture_map = self.bccx.capture_map.borrow();\n-        let captured_vars = capture_map.get().get(&closure_expr.id);\n-        for captured_var in captured_vars.deref().iter() {\n+        for captured_var in self.bccx.capture_map.get(&closure_expr.id).deref().iter() {\n             match captured_var.mode {\n                 moves::CapCopy | moves::CapMove => { continue; }\n                 moves::CapRef => { }"}, {"sha": "bb6956556b57e38e4b92ea0380957d52121b1150", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -18,6 +18,7 @@ use middle::typeck;\n use middle::moves;\n use middle::dataflow::DataFlowContext;\n use middle::dataflow::DataFlowOperator;\n+use util::nodemap::NodeSet;\n use util::ppaux::{note_and_explain_region, Repr, UserString};\n \n use std::cell::{Cell, RefCell};\n@@ -72,9 +73,9 @@ impl<'a> Visitor<()> for BorrowckCtxt<'a> {\n \n pub fn check_crate(tcx: &ty::ctxt,\n                    method_map: typeck::MethodMap,\n-                   moves_map: moves::MovesMap,\n-                   moved_variables_set: moves::MovedVariablesSet,\n-                   capture_map: moves::CaptureMap,\n+                   moves_map: &NodeSet,\n+                   moved_variables_set: &NodeSet,\n+                   capture_map: &moves::CaptureMap,\n                    krate: &ast::Crate)\n                    -> root_map {\n     let mut bccx = BorrowckCtxt {\n@@ -157,9 +158,9 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n pub struct BorrowckCtxt<'a> {\n     tcx: &'a ty::ctxt,\n     method_map: typeck::MethodMap,\n-    moves_map: moves::MovesMap,\n-    moved_variables_set: moves::MovedVariablesSet,\n-    capture_map: moves::CaptureMap,\n+    moves_map: &'a NodeSet,\n+    moved_variables_set: &'a NodeSet,\n+    capture_map: &'a moves::CaptureMap,\n     root_map: root_map,\n \n     // Statistics:\n@@ -416,8 +417,7 @@ impl<'a> BorrowckCtxt<'a> {\n     }\n \n     pub fn is_move(&self, id: ast::NodeId) -> bool {\n-        let moves_map = self.moves_map.borrow();\n-        moves_map.get().contains(&id)\n+        self.moves_map.contains(&id)\n     }\n \n     pub fn mc(&self) -> mc::MemCategorizationContext<TcxTyper<'a>> {"}, {"sha": "610abe749c615092ea642b14e0f17dfabfe16bb0", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -16,7 +16,7 @@ use middle::pat_util::*;\n use middle::ty::*;\n use middle::ty;\n use middle::typeck::MethodMap;\n-use middle::moves;\n+use util::nodemap::NodeSet;\n use util::ppaux::ty_to_str;\n \n use std::cmp;\n@@ -33,7 +33,7 @@ use syntax::visit::{Visitor, FnKind};\n struct MatchCheckCtxt<'a> {\n     tcx: &'a ty::ctxt,\n     method_map: MethodMap,\n-    moves_map: moves::MovesMap\n+    moves_map: &'a NodeSet\n }\n \n impl<'a> Visitor<()> for MatchCheckCtxt<'a> {\n@@ -50,7 +50,7 @@ impl<'a> Visitor<()> for MatchCheckCtxt<'a> {\n \n pub fn check_crate(tcx: &ty::ctxt,\n                    method_map: MethodMap,\n-                   moves_map: moves::MovesMap,\n+                   moves_map: &NodeSet,\n                    krate: &Crate) {\n     let mut cx = MatchCheckCtxt {\n         tcx: tcx,\n@@ -953,8 +953,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                     by_ref_span = Some(span);\n                 }\n                 BindByValue(_) => {\n-                    let moves_map = cx.moves_map.borrow();\n-                    if moves_map.get().contains(&id) {\n+                    if cx.moves_map.contains(&id) {\n                         any_by_move = true;\n                     }\n                 }\n@@ -991,8 +990,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n             if pat_is_binding(def_map, p) {\n                 match p.node {\n                     PatIdent(_, _, sub) => {\n-                        let moves_map = cx.moves_map.borrow();\n-                        if moves_map.get().contains(&p.id) {\n+                        if cx.moves_map.contains(&p.id) {\n                             check_move(p, sub);\n                         }\n                     }"}, {"sha": "c5a466f599df02ba6ad42e6377dfb31d1e5d5dd9", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -126,23 +126,18 @@ pub fn lookup_variant_by_id(tcx: &ty::ctxt,\n             }\n         }\n     } else {\n-        {\n-            let extern_const_variants = tcx.extern_const_variants.borrow();\n-            match extern_const_variants.get().find(&variant_def) {\n-                Some(&e) => return e,\n-                None => {}\n-            }\n+        match tcx.extern_const_variants.borrow().get().find(&variant_def) {\n+            Some(&e) => return e,\n+            None => {}\n         }\n         let maps = astencode::Maps {\n             root_map: @RefCell::new(HashMap::new()),\n             method_map: @RefCell::new(FnvHashMap::new()),\n             vtable_map: @RefCell::new(NodeMap::new()),\n-            capture_map: @RefCell::new(NodeMap::new())\n+            capture_map: RefCell::new(NodeMap::new())\n         };\n         let e = match csearch::maybe_get_item_ast(tcx, enum_def,\n-            |a, b, c, d| astencode::decode_inlined_item(a, b,\n-                                                        maps,\n-                                                        c, d)) {\n+            |a, b, c, d| astencode::decode_inlined_item(a, b, &maps, c, d)) {\n             csearch::found(ast::IIItem(item)) => match item.node {\n                 ItemEnum(ast::EnumDef { variants: ref variants }, _) => {\n                     variant_expr(variants.as_slice(), variant_def.node)\n@@ -151,12 +146,8 @@ pub fn lookup_variant_by_id(tcx: &ty::ctxt,\n             },\n             _ => None\n         };\n-        {\n-            let mut extern_const_variants = tcx.extern_const_variants\n-                                               .borrow_mut();\n-            extern_const_variants.get().insert(variant_def, e);\n-            return e;\n-        }\n+        tcx.extern_const_variants.borrow_mut().get().insert(variant_def, e);\n+        return e;\n     }\n }\n \n@@ -187,10 +178,10 @@ pub fn lookup_const_by_id(tcx: &ty::ctxt, def_id: ast::DefId)\n             root_map: @RefCell::new(HashMap::new()),\n             method_map: @RefCell::new(FnvHashMap::new()),\n             vtable_map: @RefCell::new(NodeMap::new()),\n-            capture_map: @RefCell::new(NodeMap::new())\n+            capture_map: RefCell::new(NodeMap::new())\n         };\n         let e = match csearch::maybe_get_item_ast(tcx, def_id,\n-            |a, b, c, d| astencode::decode_inlined_item(a, b, maps, c, d)) {\n+            |a, b, c, d| astencode::decode_inlined_item(a, b, &maps, c, d)) {\n             csearch::found(ast::IIItem(item)) => match item.node {\n                 ItemStatic(_, ast::MutImmutable, const_expr) => Some(const_expr),\n                 _ => None"}, {"sha": "69932a147953e685908ba7a3754068898a8eb042", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -173,7 +173,7 @@ impl<'a> Visitor<()> for IrMaps<'a> {\n \n pub fn check_crate(tcx: &ty::ctxt,\n                    method_map: typeck::MethodMap,\n-                   capture_map: moves::CaptureMap,\n+                   capture_map: &moves::CaptureMap,\n                    krate: &Crate) {\n     visit::walk_crate(&mut IrMaps(tcx, method_map, capture_map), krate, ());\n     tcx.sess.abort_if_errors();\n@@ -249,7 +249,7 @@ enum VarKind {\n struct IrMaps<'a> {\n     tcx: &'a ty::ctxt,\n     method_map: typeck::MethodMap,\n-    capture_map: moves::CaptureMap,\n+    capture_map: &'a moves::CaptureMap,\n \n     num_live_nodes: uint,\n     num_vars: uint,\n@@ -262,7 +262,7 @@ struct IrMaps<'a> {\n \n fn IrMaps<'a>(tcx: &'a ty::ctxt,\n               method_map: typeck::MethodMap,\n-              capture_map: moves::CaptureMap)\n+              capture_map: &'a moves::CaptureMap)\n               -> IrMaps<'a> {\n     IrMaps {\n         tcx: tcx,\n@@ -473,7 +473,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n         // in better error messages than just pointing at the closure\n         // construction site.\n         let mut call_caps = Vec::new();\n-        for cv in ir.capture_map.borrow().get().get(&expr.id).deref().iter() {\n+        for cv in ir.capture_map.get(&expr.id).deref().iter() {\n             match moves::moved_variable_node_id_from_def(cv.def) {\n               Some(rv) => {\n                 let cv_ln = ir.add_live_node(FreeVarNode(cv.span));"}, {"sha": "3d476832fd6bcc72fd28c249886db0b680be58ac", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 24, "deletions": 52, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -137,7 +137,6 @@ use util::common::indenter;\n use util::ppaux::UserString;\n use util::nodemap::{NodeMap, NodeSet};\n \n-use std::cell::RefCell;\n use std::rc::Rc;\n use std::vec_ng::Vec;\n use syntax::ast::*;\n@@ -160,23 +159,19 @@ pub struct CaptureVar {\n     mode: CaptureMode // How variable is being accessed\n }\n \n-pub type CaptureMap = @RefCell<NodeMap<Rc<Vec<CaptureVar> >>>;\n-\n-pub type MovesMap = @RefCell<NodeSet>;\n-\n-/**\n- * Set of variable node-ids that are moved.\n- *\n- * Note: The `VariableMovesMap` stores expression ids that\n- * are moves, whereas this set stores the ids of the variables\n- * that are moved at some point */\n-pub type MovedVariablesSet = @RefCell<NodeSet>;\n+pub type CaptureMap = NodeMap<Rc<Vec<CaptureVar>>>;\n \n /** See the section Output on the module comment for explanation. */\n #[deriving(Clone)]\n pub struct MoveMaps {\n-    moves_map: MovesMap,\n-    moved_variables_set: MovedVariablesSet,\n+    moves_map: NodeSet,\n+    /**\n+     * Set of variable node-ids that are moved.\n+     *\n+     * Note: The `moves_map` stores expression ids that are moves,\n+     * whereas this set stores the ids of the variables that are\n+     * moved at some point */\n+    moved_variables_set: NodeSet,\n     capture_map: CaptureMap\n }\n \n@@ -216,14 +211,13 @@ pub fn compute_moves(tcx: &ty::ctxt,\n         tcx: tcx,\n         method_map: method_map,\n         move_maps: MoveMaps {\n-            moves_map: @RefCell::new(NodeSet::new()),\n-            capture_map: @RefCell::new(NodeMap::new()),\n-            moved_variables_set: @RefCell::new(NodeSet::new())\n+            moves_map: NodeSet::new(),\n+            moved_variables_set: NodeSet::new(),\n+            capture_map: NodeMap::new()\n         }\n     };\n-    let visit_cx = &mut visit_cx;\n-    visit::walk_crate(visit_cx, krate, ());\n-    return visit_cx.move_maps;\n+    visit::walk_crate(&mut visit_cx, krate, ());\n+    visit_cx.move_maps\n }\n \n pub fn moved_variable_node_id_from_def(def: Def) -> Option<NodeId> {\n@@ -284,7 +278,7 @@ impl<'a> VisitContext<'a> {\n         let expr_ty = ty::expr_ty_adjusted(self.tcx, expr,\n                                            self.method_map.borrow().get());\n         if ty::type_moves_by_default(self.tcx, expr_ty) {\n-            self.move_maps.moves_map.borrow_mut().get().insert(expr.id);\n+            self.move_maps.moves_map.insert(expr.id);\n             self.use_expr(expr, Move);\n         } else {\n             self.use_expr(expr, Read);\n@@ -349,20 +343,15 @@ impl<'a> VisitContext<'a> {\n                         let def = def_map.get().get_copy(&expr.id);\n                         let r = moved_variable_node_id_from_def(def);\n                         for &id in r.iter() {\n-                            let mut moved_variables_set =\n-                                self.move_maps\n-                                    .moved_variables_set\n-                                    .borrow_mut();\n-                            moved_variables_set.get().insert(id);\n+                            self.move_maps.moved_variables_set.insert(id);\n                         }\n                     }\n                     Read => {}\n                 }\n             }\n \n             ExprUnary(UnDeref, base) => {      // *base\n-                if !self.use_overloaded_operator(expr, base, [])\n-                {\n+                if !self.use_overloaded_operator(expr, base, []) {\n                     // Moving out of *base moves out of base.\n                     self.use_expr(base, comp_mode);\n                 }\n@@ -374,8 +363,7 @@ impl<'a> VisitContext<'a> {\n             }\n \n             ExprIndex(lhs, rhs) => {           // lhs[rhs]\n-                if !self.use_overloaded_operator(expr, lhs, [rhs])\n-                {\n+                if !self.use_overloaded_operator(expr, lhs, [rhs]) {\n                     self.use_expr(lhs, comp_mode);\n                     self.consume_expr(rhs);\n                 }\n@@ -400,12 +388,7 @@ impl<'a> VisitContext<'a> {\n                 // closures should be noncopyable, they shouldn't move by default;\n                 // calling a closure should only consume it if it's once.\n                 if mode == Move {\n-                    {\n-                        let mut moves_map = self.move_maps\n-                                                .moves_map\n-                                                .borrow_mut();\n-                        moves_map.get().insert(callee.id);\n-                    }\n+                    self.move_maps.moves_map.insert(callee.id);\n                 }\n                 self.use_expr(callee, mode);\n                 self.use_fn_args(args.as_slice());\n@@ -520,15 +503,13 @@ impl<'a> VisitContext<'a> {\n             ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n \n             ExprUnary(_, lhs) => {\n-                if !self.use_overloaded_operator(expr, lhs, [])\n-                {\n+                if !self.use_overloaded_operator(expr, lhs, []) {\n                     self.consume_expr(lhs);\n                 }\n             }\n \n             ExprBinary(_, lhs, rhs) => {\n-                if !self.use_overloaded_operator(expr, lhs, [rhs])\n-                {\n+                if !self.use_overloaded_operator(expr, lhs, [rhs]) {\n                     self.consume_expr(lhs);\n                     self.consume_expr(rhs);\n                 }\n@@ -574,12 +555,7 @@ impl<'a> VisitContext<'a> {\n                     self.use_pat(a.pat);\n                 }\n                 let cap_vars = self.compute_captures(expr.id);\n-                {\n-                    let mut capture_map = self.move_maps\n-                                              .capture_map\n-                                              .borrow_mut();\n-                    capture_map.get().insert(expr.id, cap_vars);\n-                }\n+                self.move_maps.capture_map.insert(expr.id, cap_vars);\n                 self.consume_block(body);\n             }\n \n@@ -657,16 +633,12 @@ impl<'a> VisitContext<'a> {\n                    id, bm, binding_moves);\n \n             if binding_moves {\n-                {\n-                    let mut moves_map = self.move_maps.moves_map.borrow_mut();\n-                    moves_map.get().insert(id);\n-                }\n+                self.move_maps.moves_map.insert(id);\n             }\n         })\n     }\n \n-    pub fn use_fn_args(&mut self,\n-                       arg_exprs: &[@Expr]) {\n+    pub fn use_fn_args(&mut self, arg_exprs: &[@Expr]) {\n         //! Uses the argument expressions.\n         for arg_expr in arg_exprs.iter() {\n             self.use_fn_arg(*arg_expr);"}, {"sha": "7d69db92af2f1524dff36d23e6715d1411c07ebb", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -359,7 +359,7 @@ fn variant_opt(bcx: &Block, pat_id: ast::NodeId) -> Opt {\n     let def_map = ccx.tcx.def_map.borrow();\n     match def_map.get().get_copy(&pat_id) {\n         ast::DefVariant(enum_id, var_id, _) => {\n-            let variants = ty::enum_variants(ccx.tcx, enum_id);\n+            let variants = ty::enum_variants(ccx.tcx(), enum_id);\n             for v in (*variants).iter() {\n                 if var_id == v.id {\n                     return var(v.disr_val,\n@@ -960,7 +960,7 @@ fn get_options(bcx: &Block, m: &[Match], col: uint) -> Vec<Opt> {\n         let cur = *br.pats.get(col);\n         match cur.node {\n             ast::PatLit(l) => {\n-                add_to_set(ccx.tcx, &mut found, lit(ExprLit(l)));\n+                add_to_set(ccx.tcx(), &mut found, lit(ExprLit(l)));\n             }\n             ast::PatIdent(..) => {\n                 // This is one of: an enum variant, a unit-like struct, or a\n@@ -971,15 +971,15 @@ fn get_options(bcx: &Block, m: &[Match], col: uint) -> Vec<Opt> {\n                 };\n                 match opt_def {\n                     Some(ast::DefVariant(..)) => {\n-                        add_to_set(ccx.tcx, &mut found,\n+                        add_to_set(ccx.tcx(), &mut found,\n                                    variant_opt(bcx, cur.id));\n                     }\n                     Some(ast::DefStruct(..)) => {\n-                        add_to_set(ccx.tcx, &mut found,\n+                        add_to_set(ccx.tcx(), &mut found,\n                                    lit(UnitLikeStructLit(cur.id)));\n                     }\n                     Some(ast::DefStatic(const_did, false)) => {\n-                        add_to_set(ccx.tcx, &mut found,\n+                        add_to_set(ccx.tcx(), &mut found,\n                                    lit(ConstLit(const_did)));\n                     }\n                     _ => {}\n@@ -995,18 +995,18 @@ fn get_options(bcx: &Block, m: &[Match], col: uint) -> Vec<Opt> {\n                 match opt_def {\n                     Some(ast::DefFn(..)) |\n                     Some(ast::DefVariant(..)) => {\n-                        add_to_set(ccx.tcx, &mut found,\n+                        add_to_set(ccx.tcx(), &mut found,\n                                    variant_opt(bcx, cur.id));\n                     }\n                     Some(ast::DefStatic(const_did, false)) => {\n-                        add_to_set(ccx.tcx, &mut found,\n+                        add_to_set(ccx.tcx(), &mut found,\n                                    lit(ConstLit(const_did)));\n                     }\n                     _ => {}\n                 }\n             }\n             ast::PatRange(l1, l2) => {\n-                add_to_set(ccx.tcx, &mut found, range(l1, l2));\n+                add_to_set(ccx.tcx(), &mut found, range(l1, l2));\n             }\n             ast::PatVec(ref before, slice, ref after) => {\n                 let (len, vec_opt) = match slice {\n@@ -2224,7 +2224,7 @@ fn bind_irrefutable_pat<'a>(\n             match def_map.get().find(&pat.id) {\n                 Some(&ast::DefVariant(enum_id, var_id, _)) => {\n                     let repr = adt::represent_node(bcx, pat.id);\n-                    let vinfo = ty::enum_variant_with_id(ccx.tcx,\n+                    let vinfo = ty::enum_variant_with_id(ccx.tcx(),\n                                                          enum_id,\n                                                          var_id);\n                     let args = extract_variant_args(bcx,"}, {"sha": "eb57ad022b6557e89496b23d428d515cf341fe82", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -118,7 +118,7 @@ pub fn represent_node(bcx: &Block, node: ast::NodeId) -> @Repr {\n \n /// Decides how to represent a given type.\n pub fn represent_type(cx: &CrateContext, t: ty::t) -> @Repr {\n-    debug!(\"Representing: {}\", ty_to_str(cx.tcx, t));\n+    debug!(\"Representing: {}\", ty_to_str(cx.tcx(), t));\n     {\n         let adt_reprs = cx.adt_reprs.borrow();\n         match adt_reprs.get().find(&t) {\n@@ -140,19 +140,19 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n             return Univariant(mk_struct(cx, elems.as_slice(), false), false)\n         }\n         ty::ty_struct(def_id, ref substs) => {\n-            let fields = ty::lookup_struct_fields(cx.tcx, def_id);\n+            let fields = ty::lookup_struct_fields(cx.tcx(), def_id);\n             let mut ftys = fields.map(|field| {\n-                ty::lookup_field_type(cx.tcx, def_id, field.id, substs)\n+                ty::lookup_field_type(cx.tcx(), def_id, field.id, substs)\n             });\n-            let packed = ty::lookup_packed(cx.tcx, def_id);\n-            let dtor = ty::ty_dtor(cx.tcx, def_id).has_drop_flag();\n+            let packed = ty::lookup_packed(cx.tcx(), def_id);\n+            let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n             if dtor { ftys.push(ty::mk_bool()); }\n \n             return Univariant(mk_struct(cx, ftys.as_slice(), packed), dtor)\n         }\n         ty::ty_enum(def_id, ref substs) => {\n-            let cases = get_cases(cx.tcx, def_id, substs);\n-            let hint = ty::lookup_repr_hint(cx.tcx, def_id);\n+            let cases = get_cases(cx.tcx(), def_id, substs);\n+            let hint = ty::lookup_repr_hint(cx.tcx(), def_id);\n \n             if cases.len() == 0 {\n                 // Uninhabitable; represent as unit\n@@ -179,7 +179,7 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n             if !cases.iter().enumerate().all(|(i,c)| c.discr == (i as Disr)) {\n                 cx.sess().bug(format!(\"non-C-like enum {} with specified \\\n                                       discriminants\",\n-                                      ty::item_path_str(cx.tcx, def_id)))\n+                                      ty::item_path_str(cx.tcx(), def_id)))\n             }\n \n             if cases.len() == 1 {\n@@ -286,7 +286,7 @@ fn get_cases(tcx: &ty::ctxt, def_id: ast::DefId, substs: &ty::substs) -> Vec<Cas\n \n fn mk_struct(cx: &CrateContext, tys: &[ty::t], packed: bool) -> Struct {\n     let lltys = tys.map(|&ty| type_of::sizing_type_of(cx, ty));\n-    let llty_rec = Type::struct_(lltys, packed);\n+    let llty_rec = Type::struct_(cx, lltys, packed);\n     Struct {\n         size: machine::llsize_of_alloc(cx, llty_rec) /*bad*/as u64,\n         align: machine::llalign_of_min(cx, llty_rec) /*bad*/as u64,\n@@ -415,10 +415,10 @@ fn generic_type_of(cx: &CrateContext, r: &Repr, name: Option<&str>, sizing: bool\n         Univariant(ref st, _) | NullablePointer{ nonnull: ref st, .. } => {\n             match name {\n                 None => {\n-                    Type::struct_(struct_llfields(cx, st, sizing).as_slice(),\n+                    Type::struct_(cx, struct_llfields(cx, st, sizing).as_slice(),\n                                   st.packed)\n                 }\n-                Some(name) => { assert_eq!(sizing, false); Type::named_struct(name) }\n+                Some(name) => { assert_eq!(sizing, false); Type::named_struct(cx, name) }\n             }\n         }\n         General(ity, ref sts) => {\n@@ -441,12 +441,12 @@ fn generic_type_of(cx: &CrateContext, r: &Repr, name: Option<&str>, sizing: bool\n             let discr_size = machine::llsize_of_alloc(cx, discr_ty) as u64;\n             let align_units = (size + align - 1) / align - 1;\n             let pad_ty = match align {\n-                1 => Type::array(&Type::i8(), align_units),\n-                2 => Type::array(&Type::i16(), align_units),\n-                4 => Type::array(&Type::i32(), align_units),\n-                8 if machine::llalign_of_min(cx, Type::i64()) == 8 =>\n-                                 Type::array(&Type::i64(), align_units),\n-                a if a.count_ones() == 1 => Type::array(&Type::vector(&Type::i32(), a / 4),\n+                1 => Type::array(&Type::i8(cx), align_units),\n+                2 => Type::array(&Type::i16(cx), align_units),\n+                4 => Type::array(&Type::i32(cx), align_units),\n+                8 if machine::llalign_of_min(cx, Type::i64(cx)) == 8 =>\n+                                 Type::array(&Type::i64(cx), align_units),\n+                a if a.count_ones() == 1 => Type::array(&Type::vector(&Type::i32(cx), a / 4),\n                                                               align_units),\n                 _ => fail!(\"unsupported enum alignment: {:?}\", align)\n             };\n@@ -456,9 +456,9 @@ fn generic_type_of(cx: &CrateContext, r: &Repr, name: Option<&str>, sizing: bool\n                            Type::array(&discr_ty, align / discr_size - 1),\n                            pad_ty);\n             match name {\n-                None => Type::struct_(fields.as_slice(), false),\n+                None => Type::struct_(cx, fields.as_slice(), false),\n                 Some(name) => {\n-                    let mut llty = Type::named_struct(name);\n+                    let mut llty = Type::named_struct(cx, name);\n                     llty.set_struct_body(fields.as_slice(), false);\n                     llty\n                 }\n@@ -514,7 +514,7 @@ pub fn trans_get_discr(bcx: &Block, r: &Repr, scrutinee: ValueRef, cast_to: Opti\n             signed = ity.is_signed();\n         }\n         Univariant(..) => {\n-            val = C_u8(0);\n+            val = C_u8(bcx.ccx(), 0);\n             signed = false;\n         }\n         NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, .. } => {\n@@ -581,7 +581,7 @@ pub fn trans_case<'a>(bcx: &'a Block<'a>, r: &Repr, discr: Disr)\n         }\n         NullablePointer{ .. } => {\n             assert!(discr == 0 || discr == 1);\n-            _match::single_result(rslt(bcx, C_i1(discr != 0)))\n+            _match::single_result(rslt(bcx, C_i1(bcx.ccx(), discr != 0)))\n         }\n     }\n }\n@@ -604,7 +604,7 @@ pub fn trans_start_init(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr) {\n         }\n         Univariant(ref st, true) => {\n             assert_eq!(discr, 0);\n-            Store(bcx, C_bool(true),\n+            Store(bcx, C_bool(bcx.ccx(), true),\n                   GEPi(bcx, val, [0, st.fields.len() - 1]))\n         }\n         Univariant(..) => {\n@@ -706,7 +706,7 @@ fn struct_field_ptr(bcx: &Block, st: &Struct, val: ValueRef, ix: uint,\n \n     let val = if needs_cast {\n         let fields = st.fields.map(|&ty| type_of::type_of(ccx, ty));\n-        let real_ty = Type::struct_(fields.as_slice(), st.packed);\n+        let real_ty = Type::struct_(ccx, fields.as_slice(), st.packed);\n         PointerCast(bcx, val, real_ty.ptr_to())\n     } else {\n         val\n@@ -761,31 +761,31 @@ pub fn trans_const(ccx: &CrateContext, r: &Repr, discr: Disr,\n                                               vec_ng::append(\n                                                   vec!(lldiscr),\n                                                   vals).as_slice());\n-            C_struct(vec_ng::append(\n+            C_struct(ccx, vec_ng::append(\n                         contents,\n-                        &[padding(max_sz - case.size)]).as_slice(),\n+                        &[padding(ccx, max_sz - case.size)]).as_slice(),\n                      false)\n         }\n         Univariant(ref st, _dro) => {\n             assert!(discr == 0);\n             let contents = build_const_struct(ccx, st, vals);\n-            C_struct(contents.as_slice(), st.packed)\n+            C_struct(ccx, contents.as_slice(), st.packed)\n         }\n         NullablePointer{ nonnull: ref nonnull, nndiscr, .. } => {\n             if discr == nndiscr {\n-                C_struct(build_const_struct(ccx,\n-                                            nonnull,\n-                                            vals.as_slice()).as_slice(),\n+                C_struct(ccx, build_const_struct(ccx,\n+                                                 nonnull,\n+                                                 vals).as_slice(),\n                          false)\n             } else {\n                 let vals = nonnull.fields.map(|&ty| {\n                     // Always use null even if it's not the `ptrfield`th\n                     // field; see #8506.\n                     C_null(type_of::sizing_type_of(ccx, ty))\n                 }).move_iter().collect::<Vec<ValueRef> >();\n-                C_struct(build_const_struct(ccx,\n-                                            nonnull,\n-                                            vals.as_slice()).as_slice(),\n+                C_struct(ccx, build_const_struct(ccx,\n+                                                 nonnull,\n+                                                 vals.as_slice()).as_slice(),\n                          false)\n             }\n         }\n@@ -817,7 +817,7 @@ fn build_const_struct(ccx: &CrateContext, st: &Struct, vals: &[ValueRef])\n         let target_offset = roundup(offset, type_align);\n         offset = roundup(offset, val_align);\n         if offset != target_offset {\n-            cfields.push(padding(target_offset - offset));\n+            cfields.push(padding(ccx, target_offset - offset));\n             offset = target_offset;\n         }\n         assert!(!is_undef(vals[i]));\n@@ -828,8 +828,8 @@ fn build_const_struct(ccx: &CrateContext, st: &Struct, vals: &[ValueRef])\n     return cfields;\n }\n \n-fn padding(size: u64) -> ValueRef {\n-    C_undef(Type::array(&Type::i8(), size))\n+fn padding(ccx: &CrateContext, size: u64) -> ValueRef {\n+    C_undef(Type::array(&Type::i8(ccx), size))\n }\n \n // FIXME this utility routine should be somewhere more general"}, {"sha": "7b04b51910188be220abb972e956c287294706f0", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -86,11 +86,11 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n \n     // Depending on how many outputs we have, the return type is different\n     let output_type = if num_outputs == 0 {\n-        Type::void()\n+        Type::void(bcx.ccx())\n     } else if num_outputs == 1 {\n         *output_types.get(0)\n     } else {\n-        Type::struct_(output_types.as_slice(), false)\n+        Type::struct_(bcx.ccx(), output_types.as_slice(), false)\n     };\n \n     let dialect = match ia.dialect {"}, {"sha": "bcf0b5d5f64bdeed095b67c75454c194613ecdc6", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 235, "deletions": 275, "changes": 510, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -34,7 +34,6 @@ use driver::driver::{CrateAnalysis, CrateTranslation};\n use lib::llvm::{ModuleRef, ValueRef, BasicBlockRef};\n use lib::llvm::{llvm, Vector};\n use lib;\n-use metadata::common::LinkMeta;\n use metadata::{csearch, encoder};\n use middle::astencode;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n@@ -73,7 +72,6 @@ use util::sha2::Sha256;\n use util::nodemap::NodeMap;\n \n use arena::TypedArena;\n-use collections::HashMap;\n use std::c_str::ToCStr;\n use std::cell::{Cell, RefCell};\n use std::libc::c_uint;\n@@ -93,8 +91,6 @@ use syntax::{ast, ast_util, ast_map};\n \n use time;\n \n-pub use middle::trans::context::task_llcx;\n-\n local_data_key!(task_local_insn_key: Vec<&'static str> )\n \n pub fn with_insn_ctxt(blk: |&[&'static str]|) {\n@@ -136,14 +132,14 @@ pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n }\n \n pub struct StatRecorder<'a> {\n-    ccx: &'a CrateContext<'a>,\n+    ccx: &'a CrateContext,\n     name: Option<~str>,\n     start: u64,\n     istart: uint,\n }\n \n impl<'a> StatRecorder<'a> {\n-    pub fn new(ccx: &'a CrateContext<'a>, name: ~str) -> StatRecorder<'a> {\n+    pub fn new(ccx: &'a CrateContext, name: ~str) -> StatRecorder<'a> {\n         let start = if ccx.sess().trans_stats() {\n             time::precise_time_ns()\n         } else {\n@@ -393,7 +389,11 @@ pub fn malloc_raw_dyn<'a>(\n         let r = callee::trans_lang_call(\n             bcx,\n             langcall,\n-            [PointerCast(bcx, drop_glue, Type::glue_fn(Type::i8p()).ptr_to()), size, llalign],\n+            [\n+                PointerCast(bcx, drop_glue, Type::glue_fn(ccx, Type::i8p(ccx)).ptr_to()),\n+                size,\n+                llalign\n+            ],\n             None);\n         rslt(r.bcx, PointerCast(r.bcx, r.val, llty))\n     }\n@@ -547,14 +547,14 @@ pub fn get_res_dtor(ccx: &CrateContext,\n             tps: Vec::from_slice(substs),\n         };\n \n-        let vtables = typeck::check::vtable::trans_resolve_method(ccx.tcx, did.node, &tsubsts);\n+        let vtables = typeck::check::vtable::trans_resolve_method(ccx.tcx(), did.node, &tsubsts);\n         let (val, _) = monomorphize::monomorphic_fn(ccx, did, &tsubsts, vtables, None, None);\n \n         val\n     } else if did.krate == ast::LOCAL_CRATE {\n         get_item_val(ccx, did.node)\n     } else {\n-        let tcx = ccx.tcx;\n+        let tcx = ccx.tcx();\n         let name = csearch::get_symbol(&ccx.sess().cstore, did);\n         let class_ty = ty::subst_tps(tcx,\n                                      substs,\n@@ -624,8 +624,8 @@ pub fn compare_scalar_values<'a>(\n         // We don't need to do actual comparisons for nil.\n         // () == () holds but () < () does not.\n         match op {\n-          ast::BiEq | ast::BiLe | ast::BiGe => return C_i1(true),\n-          ast::BiNe | ast::BiLt | ast::BiGt => return C_i1(false),\n+          ast::BiEq | ast::BiLe | ast::BiGe => return C_i1(cx.ccx(), true),\n+          ast::BiNe | ast::BiLt | ast::BiGt => return C_i1(cx.ccx(), false),\n           // refinements would be nice\n           _ => die(cx)\n         }\n@@ -744,7 +744,7 @@ pub fn iter_structural_ty<'r,\n           let ccx = fcx.ccx;\n \n           let repr = adt::represent_type(ccx, t);\n-          let variants = ty::enum_variants(ccx.tcx, tid);\n+          let variants = ty::enum_variants(ccx.tcx(), tid);\n           let n_variants = (*variants).len();\n \n           // NB: we must hit the discriminant first so that structural\n@@ -865,7 +865,7 @@ pub fn fail_if_zero<'a>(\n       }\n       _ => {\n         cx.sess().bug(~\"fail-if-zero on unexpected type: \" +\n-                      ty_to_str(cx.ccx().tcx, rhs_t));\n+                      ty_to_str(cx.tcx(), rhs_t));\n       }\n     };\n     with_cond(cx, is_zero, |bcx| {\n@@ -920,7 +920,7 @@ pub fn invoke<'a>(\n               -> (ValueRef, &'a Block<'a>) {\n     let _icx = push_ctxt(\"invoke_\");\n     if bcx.unreachable.get() {\n-        return (C_null(Type::i8()), bcx);\n+        return (C_null(Type::i8(bcx.ccx())), bcx);\n     }\n \n     match bcx.opt_node_id {\n@@ -983,7 +983,7 @@ pub fn need_invoke(bcx: &Block) -> bool {\n \n pub fn do_spill(bcx: &Block, v: ValueRef, t: ty::t) -> ValueRef {\n     if ty::type_is_bot(t) {\n-        return C_null(Type::i8p());\n+        return C_null(Type::i8p(bcx.ccx()));\n     }\n     let llptr = alloc_ty(bcx, t, \"\");\n     Store(bcx, v, llptr);\n@@ -1085,11 +1085,11 @@ pub fn call_memcpy(cx: &Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef,\n         X86_64 => \"llvm.memcpy.p0i8.p0i8.i64\"\n     };\n     let memcpy = ccx.intrinsics.get_copy(&key);\n-    let src_ptr = PointerCast(cx, src, Type::i8p());\n-    let dst_ptr = PointerCast(cx, dst, Type::i8p());\n+    let src_ptr = PointerCast(cx, src, Type::i8p(ccx));\n+    let dst_ptr = PointerCast(cx, dst, Type::i8p(ccx));\n     let size = IntCast(cx, n_bytes, ccx.int_type);\n-    let align = C_i32(align as i32);\n-    let volatile = C_i1(false);\n+    let align = C_i32(ccx, align as i32);\n+    let volatile = C_i1(ccx, false);\n     Call(cx, memcpy, [dst_ptr, src_ptr, size, align, volatile], []);\n }\n \n@@ -1130,11 +1130,11 @@ fn memzero(b: &Builder, llptr: ValueRef, ty: Type) {\n     };\n \n     let llintrinsicfn = ccx.intrinsics.get_copy(&intrinsic_key);\n-    let llptr = b.pointercast(llptr, Type::i8().ptr_to());\n-    let llzeroval = C_u8(0);\n+    let llptr = b.pointercast(llptr, Type::i8(ccx).ptr_to());\n+    let llzeroval = C_u8(ccx, 0);\n     let size = machine::llsize_of(ccx, ty);\n-    let align = C_i32(llalign_of_min(ccx, ty) as i32);\n-    let volatile = C_i1(false);\n+    let align = C_i32(ccx, llalign_of_min(ccx, ty) as i32);\n+    let volatile = C_i1(ccx, false);\n     b.call(llintrinsicfn, [llptr, llzeroval, size, align, volatile], []);\n }\n \n@@ -1183,24 +1183,6 @@ pub struct BasicBlocks {\n     sa: BasicBlockRef,\n }\n \n-pub fn mk_staticallocas_basic_block(llfn: ValueRef) -> BasicBlockRef {\n-    unsafe {\n-        let cx = task_llcx();\n-        \"static_allocas\".with_c_str(|buf| {\n-            llvm::LLVMAppendBasicBlockInContext(cx, llfn, buf)\n-        })\n-    }\n-}\n-\n-pub fn mk_return_basic_block(llfn: ValueRef) -> BasicBlockRef {\n-    unsafe {\n-        let cx = task_llcx();\n-        \"return\".with_c_str(|buf| {\n-            llvm::LLVMAppendBasicBlockInContext(cx, llfn, buf)\n-        })\n-    }\n-}\n-\n // Creates and returns space for, or returns the argument representing, the\n // slot where the return value of the function must go.\n pub fn make_return_pointer(fcx: &FunctionContext, output_type: ty::t)\n@@ -1225,7 +1207,7 @@ pub fn make_return_pointer(fcx: &FunctionContext, output_type: ty::t)\n //\n // Be warned! You must call `init_function` before doing anything with the\n // returned function context.\n-pub fn new_fn_ctxt<'a>(ccx: &'a CrateContext<'a>,\n+pub fn new_fn_ctxt<'a>(ccx: &'a CrateContext,\n                        llfndecl: ValueRef,\n                        id: ast::NodeId,\n                        has_env: bool,\n@@ -1238,12 +1220,12 @@ pub fn new_fn_ctxt<'a>(ccx: &'a CrateContext<'a>,\n \n     debug!(\"new_fn_ctxt(path={}, id={}, param_substs={})\",\n            if id == -1 { ~\"\" } else { ccx.tcx.map.path_to_str(id) },\n-           id, param_substs.repr(ccx.tcx));\n+           id, param_substs.repr(ccx.tcx()));\n \n     let substd_output_type = match param_substs {\n         None => output_type,\n         Some(substs) => {\n-            ty::subst_tps(ccx.tcx,\n+            ty::subst_tps(ccx.tcx(),\n                           substs.tys.as_slice(),\n                           substs.self_ty,\n                           output_type)\n@@ -1296,14 +1278,14 @@ pub fn init_function<'a>(\n     // Use a dummy instruction as the insertion point for all allocas.\n     // This is later removed in FunctionContext::cleanup.\n     fcx.alloca_insert_pt.set(Some(unsafe {\n-        Load(entry_bcx, C_null(Type::i8p()));\n+        Load(entry_bcx, C_null(Type::i8p(fcx.ccx)));\n         llvm::LLVMGetFirstInstruction(entry_bcx.llbb)\n     }));\n \n     let substd_output_type = match param_substs {\n         None => output_type,\n         Some(substs) => {\n-            ty::subst_tps(fcx.ccx.tcx,\n+            ty::subst_tps(fcx.ccx.tcx(),\n                           substs.tys.as_slice(),\n                           substs.self_ty,\n                           output_type)\n@@ -1458,9 +1440,9 @@ pub fn trans_closure(ccx: &CrateContext,\n     set_uwtable(llfndecl);\n \n     debug!(\"trans_closure(..., param_substs={})\",\n-           param_substs.repr(ccx.tcx));\n+           param_substs.repr(ccx.tcx()));\n \n-    let has_env = match ty::get(ty::node_id_to_type(ccx.tcx, id)).sty {\n+    let has_env = match ty::get(ty::node_id_to_type(ccx.tcx(), id)).sty {\n         ty::ty_closure(_) => true,\n         _ => false\n     };\n@@ -1551,9 +1533,9 @@ pub fn trans_fn(ccx: &CrateContext,\n                 id: ast::NodeId,\n                 attrs: &[ast::Attribute]) {\n     let _s = StatRecorder::new(ccx, ccx.tcx.map.path_to_str(id));\n-    debug!(\"trans_fn(param_substs={})\", param_substs.repr(ccx.tcx));\n+    debug!(\"trans_fn(param_substs={})\", param_substs.repr(ccx.tcx()));\n     let _icx = push_ctxt(\"trans_fn\");\n-    let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, id));\n+    let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx(), id));\n     trans_closure(ccx, decl, body, llfndecl,\n                   param_substs, id, attrs, output_type, |bcx| bcx);\n }\n@@ -1607,17 +1589,17 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: &CrateContext,\n         }\n     };\n \n-    let ctor_ty = ty::subst_tps(ccx.tcx,\n+    let ctor_ty = ty::subst_tps(ccx.tcx(),\n                                 ty_param_substs,\n                                 None,\n-                                ty::node_id_to_type(ccx.tcx, ctor_id));\n+                                ty::node_id_to_type(ccx.tcx(), ctor_id));\n \n     let result_ty = match ty::get(ctor_ty).sty {\n         ty::ty_bare_fn(ref bft) => bft.sig.output,\n         _ => ccx.sess().bug(\n             format!(\"trans_enum_variant_or_tuple_like_struct: \\\n                   unexpected ctor return type {}\",\n-                 ty_to_str(ccx.tcx, ctor_ty)))\n+                 ty_to_str(ccx.tcx(), ctor_ty)))\n     };\n \n     let arena = TypedArena::new();\n@@ -1671,7 +1653,7 @@ pub fn trans_enum_def(ccx: &CrateContext, enum_definition: &ast::EnumDef,\n }\n \n pub struct TransItemVisitor<'a> {\n-    ccx: &'a CrateContext<'a>,\n+    ccx: &'a CrateContext,\n }\n \n impl<'a> Visitor<()> for TransItemVisitor<'a> {\n@@ -1712,7 +1694,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n       }\n       ast::ItemEnum(ref enum_definition, ref generics) => {\n         if !generics.is_type_parameterized() {\n-            let vi = ty::enum_variants(ccx.tcx, local_def(item.id));\n+            let vi = ty::enum_variants(ccx.tcx(), local_def(item.id));\n             let mut i = 0;\n             trans_enum_def(ccx, enum_definition, item.id, vi, &mut i);\n         }\n@@ -1858,7 +1840,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n     fn create_entry_fn(ccx: &CrateContext,\n                        rust_main: ValueRef,\n                        use_start_lang_item: bool) {\n-        let llfty = Type::func([ccx.int_type, Type::i8().ptr_to().ptr_to()],\n+        let llfty = Type::func([ccx.int_type, Type::i8p(ccx).ptr_to()],\n                                &ccx.int_type);\n \n         let llfn = decl_cdecl_fn(ccx.llmod, \"main\", llfty, ty::mk_nil());\n@@ -1879,14 +1861,14 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n                 let start_fn = if start_def_id.krate == ast::LOCAL_CRATE {\n                     get_item_val(ccx, start_def_id.node)\n                 } else {\n-                    let start_fn_type = csearch::get_type(ccx.tcx,\n+                    let start_fn_type = csearch::get_type(ccx.tcx(),\n                                                           start_def_id).ty;\n                     trans_external_path(ccx, start_def_id, start_fn_type)\n                 };\n \n                 let args = {\n                     let opaque_rust_main = \"rust_main\".with_c_str(|buf| {\n-                        llvm::LLVMBuildPointerCast(bld, rust_main, Type::i8p().to_ref(), buf)\n+                        llvm::LLVMBuildPointerCast(bld, rust_main, Type::i8p(ccx).to_ref(), buf)\n                     });\n \n                     vec!(\n@@ -1950,7 +1932,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             let item = ccx.tcx.map.get(id);\n             let val = match item {\n                 ast_map::NodeItem(i) => {\n-                    let ty = ty::node_id_to_type(ccx.tcx, i.id);\n+                    let ty = ty::node_id_to_type(ccx.tcx(), i.id);\n                     let sym = exported_name(ccx, id, ty, i.attrs.as_slice());\n \n                     let v = match i.node {\n@@ -2108,7 +2090,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     match v.node.kind {\n                         ast::TupleVariantKind(ref args) => {\n                             assert!(args.len() != 0u);\n-                            let ty = ty::node_id_to_type(ccx.tcx, id);\n+                            let ty = ty::node_id_to_type(ccx.tcx(), id);\n                             let parent = ccx.tcx.map.get_parent(id);\n                             let enm = ccx.tcx.map.expect_item(parent);\n                             let sym = exported_name(ccx,\n@@ -2141,7 +2123,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                         Some(ctor_id) => {\n                             let parent = ccx.tcx.map.get_parent(id);\n                             let struct_item = ccx.tcx.map.expect_item(parent);\n-                            let ty = ty::node_id_to_type(ccx.tcx, ctor_id);\n+                            let ty = ty::node_id_to_type(ccx.tcx(), ctor_id);\n                             let sym = exported_name(ccx,\n                                                     id,\n                                                     ty,\n@@ -2177,7 +2159,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n \n fn register_method(ccx: &CrateContext, id: ast::NodeId,\n                    m: &ast::Method) -> ValueRef {\n-    let mty = ty::node_id_to_type(ccx.tcx, id);\n+    let mty = ty::node_id_to_type(ccx.tcx(), id);\n \n     let sym = exported_name(ccx, id, mty, m.attrs.as_slice());\n \n@@ -2197,184 +2179,166 @@ pub fn p2i(ccx: &CrateContext, v: ValueRef) -> ValueRef {\n     }\n }\n \n-macro_rules! ifn (\n-    ($intrinsics:ident, $name:expr, $args:expr, $ret:expr) => ({\n-        let name = $name;\n-        // HACK(eddyb) dummy output type, shouln't affect anything.\n-        let f = decl_cdecl_fn(llmod, name, Type::func($args, &$ret), ty::mk_nil());\n-        $intrinsics.insert(name, f);\n-    })\n-)\n-\n-pub fn declare_intrinsics(llmod: ModuleRef) -> HashMap<&'static str, ValueRef> {\n-    let i8p = Type::i8p();\n-    let mut intrinsics = HashMap::new();\n-\n-    ifn!(intrinsics, \"llvm.memcpy.p0i8.p0i8.i32\",\n-         [i8p, i8p, Type::i32(), Type::i32(), Type::i1()], Type::void());\n-    ifn!(intrinsics, \"llvm.memcpy.p0i8.p0i8.i64\",\n-         [i8p, i8p, Type::i64(), Type::i32(), Type::i1()], Type::void());\n-    ifn!(intrinsics, \"llvm.memmove.p0i8.p0i8.i32\",\n-         [i8p, i8p, Type::i32(), Type::i32(), Type::i1()], Type::void());\n-    ifn!(intrinsics, \"llvm.memmove.p0i8.p0i8.i64\",\n-         [i8p, i8p, Type::i64(), Type::i32(), Type::i1()], Type::void());\n-    ifn!(intrinsics, \"llvm.memset.p0i8.i32\",\n-         [i8p, Type::i8(), Type::i32(), Type::i32(), Type::i1()], Type::void());\n-    ifn!(intrinsics, \"llvm.memset.p0i8.i64\",\n-         [i8p, Type::i8(), Type::i64(), Type::i32(), Type::i1()], Type::void());\n-\n-    ifn!(intrinsics, \"llvm.trap\", [], Type::void());\n-    ifn!(intrinsics, \"llvm.debugtrap\", [], Type::void());\n-    ifn!(intrinsics, \"llvm.frameaddress\", [Type::i32()], i8p);\n-\n-    ifn!(intrinsics, \"llvm.powi.f32\", [Type::f32(), Type::i32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.powi.f64\", [Type::f64(), Type::i32()], Type::f64());\n-    ifn!(intrinsics, \"llvm.pow.f32\",  [Type::f32(), Type::f32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.pow.f64\",  [Type::f64(), Type::f64()], Type::f64());\n-\n-    ifn!(intrinsics, \"llvm.sqrt.f32\", [Type::f32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.sqrt.f64\", [Type::f64()], Type::f64());\n-    ifn!(intrinsics, \"llvm.sin.f32\",  [Type::f32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.sin.f64\",  [Type::f64()], Type::f64());\n-    ifn!(intrinsics, \"llvm.cos.f32\",  [Type::f32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.cos.f64\",  [Type::f64()], Type::f64());\n-    ifn!(intrinsics, \"llvm.exp.f32\",  [Type::f32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.exp.f64\",  [Type::f64()], Type::f64());\n-    ifn!(intrinsics, \"llvm.exp2.f32\", [Type::f32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.exp2.f64\", [Type::f64()], Type::f64());\n-    ifn!(intrinsics, \"llvm.log.f32\",  [Type::f32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.log.f64\",  [Type::f64()], Type::f64());\n-    ifn!(intrinsics, \"llvm.log10.f32\",[Type::f32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.log10.f64\",[Type::f64()], Type::f64());\n-    ifn!(intrinsics, \"llvm.log2.f32\", [Type::f32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.log2.f64\", [Type::f64()], Type::f64());\n-\n-    ifn!(intrinsics, \"llvm.fma.f32\",  [Type::f32(), Type::f32(), Type::f32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.fma.f64\",  [Type::f64(), Type::f64(), Type::f64()], Type::f64());\n-\n-    ifn!(intrinsics, \"llvm.fabs.f32\", [Type::f32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.fabs.f64\", [Type::f64()], Type::f64());\n-\n-    ifn!(intrinsics, \"llvm.floor.f32\",[Type::f32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.floor.f64\",[Type::f64()], Type::f64());\n-    ifn!(intrinsics, \"llvm.ceil.f32\", [Type::f32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.ceil.f64\", [Type::f64()], Type::f64());\n-    ifn!(intrinsics, \"llvm.trunc.f32\",[Type::f32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.trunc.f64\",[Type::f64()], Type::f64());\n-\n-    ifn!(intrinsics, \"llvm.rint.f32\", [Type::f32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.rint.f64\", [Type::f64()], Type::f64());\n-    ifn!(intrinsics, \"llvm.nearbyint.f32\", [Type::f32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.nearbyint.f64\", [Type::f64()], Type::f64());\n-\n-    ifn!(intrinsics, \"llvm.ctpop.i8\", [Type::i8()], Type::i8());\n-    ifn!(intrinsics, \"llvm.ctpop.i16\",[Type::i16()], Type::i16());\n-    ifn!(intrinsics, \"llvm.ctpop.i32\",[Type::i32()], Type::i32());\n-    ifn!(intrinsics, \"llvm.ctpop.i64\",[Type::i64()], Type::i64());\n-\n-    ifn!(intrinsics, \"llvm.ctlz.i8\",  [Type::i8() , Type::i1()], Type::i8());\n-    ifn!(intrinsics, \"llvm.ctlz.i16\", [Type::i16(), Type::i1()], Type::i16());\n-    ifn!(intrinsics, \"llvm.ctlz.i32\", [Type::i32(), Type::i1()], Type::i32());\n-    ifn!(intrinsics, \"llvm.ctlz.i64\", [Type::i64(), Type::i1()], Type::i64());\n-\n-    ifn!(intrinsics, \"llvm.cttz.i8\",  [Type::i8() , Type::i1()], Type::i8());\n-    ifn!(intrinsics, \"llvm.cttz.i16\", [Type::i16(), Type::i1()], Type::i16());\n-    ifn!(intrinsics, \"llvm.cttz.i32\", [Type::i32(), Type::i1()], Type::i32());\n-    ifn!(intrinsics, \"llvm.cttz.i64\", [Type::i64(), Type::i1()], Type::i64());\n-\n-    ifn!(intrinsics, \"llvm.bswap.i16\",[Type::i16()], Type::i16());\n-    ifn!(intrinsics, \"llvm.bswap.i32\",[Type::i32()], Type::i32());\n-    ifn!(intrinsics, \"llvm.bswap.i64\",[Type::i64()], Type::i64());\n-\n-    ifn!(intrinsics, \"llvm.sadd.with.overflow.i8\",\n-        [Type::i8(), Type::i8()], Type::struct_([Type::i8(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.sadd.with.overflow.i16\",\n-        [Type::i16(), Type::i16()], Type::struct_([Type::i16(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.sadd.with.overflow.i32\",\n-        [Type::i32(), Type::i32()], Type::struct_([Type::i32(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.sadd.with.overflow.i64\",\n-        [Type::i64(), Type::i64()], Type::struct_([Type::i64(), Type::i1()], false));\n-\n-    ifn!(intrinsics, \"llvm.uadd.with.overflow.i8\",\n-        [Type::i8(), Type::i8()], Type::struct_([Type::i8(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.uadd.with.overflow.i16\",\n-        [Type::i16(), Type::i16()], Type::struct_([Type::i16(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.uadd.with.overflow.i32\",\n-        [Type::i32(), Type::i32()], Type::struct_([Type::i32(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.uadd.with.overflow.i64\",\n-        [Type::i64(), Type::i64()], Type::struct_([Type::i64(), Type::i1()], false));\n-\n-    ifn!(intrinsics, \"llvm.ssub.with.overflow.i8\",\n-        [Type::i8(), Type::i8()], Type::struct_([Type::i8(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.ssub.with.overflow.i16\",\n-        [Type::i16(), Type::i16()], Type::struct_([Type::i16(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.ssub.with.overflow.i32\",\n-        [Type::i32(), Type::i32()], Type::struct_([Type::i32(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.ssub.with.overflow.i64\",\n-        [Type::i64(), Type::i64()], Type::struct_([Type::i64(), Type::i1()], false));\n-\n-    ifn!(intrinsics, \"llvm.usub.with.overflow.i8\",\n-        [Type::i8(), Type::i8()], Type::struct_([Type::i8(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.usub.with.overflow.i16\",\n-        [Type::i16(), Type::i16()], Type::struct_([Type::i16(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.usub.with.overflow.i32\",\n-        [Type::i32(), Type::i32()], Type::struct_([Type::i32(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.usub.with.overflow.i64\",\n-        [Type::i64(), Type::i64()], Type::struct_([Type::i64(), Type::i1()], false));\n-\n-    ifn!(intrinsics, \"llvm.smul.with.overflow.i8\",\n-        [Type::i8(), Type::i8()], Type::struct_([Type::i8(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.smul.with.overflow.i16\",\n-        [Type::i16(), Type::i16()], Type::struct_([Type::i16(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.smul.with.overflow.i32\",\n-        [Type::i32(), Type::i32()], Type::struct_([Type::i32(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.smul.with.overflow.i64\",\n-        [Type::i64(), Type::i64()], Type::struct_([Type::i64(), Type::i1()], false));\n-\n-    ifn!(intrinsics, \"llvm.umul.with.overflow.i8\",\n-        [Type::i8(), Type::i8()], Type::struct_([Type::i8(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.umul.with.overflow.i16\",\n-        [Type::i16(), Type::i16()], Type::struct_([Type::i16(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.umul.with.overflow.i32\",\n-        [Type::i32(), Type::i32()], Type::struct_([Type::i32(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.umul.with.overflow.i64\",\n-        [Type::i64(), Type::i64()], Type::struct_([Type::i64(), Type::i1()], false));\n-\n-    ifn!(intrinsics, \"llvm.expect.i1\", [Type::i1(), Type::i1()], Type::i1());\n+\n+pub fn declare_intrinsics(ccx: &mut CrateContext) {\n+    macro_rules! ifn (\n+        ($name:expr fn() -> $ret:expr) => ({\n+            let name = $name;\n+            // HACK(eddyb) dummy output type, shouln't affect anything.\n+            let f = decl_cdecl_fn(ccx.llmod, name, Type::func([], &$ret), ty::mk_nil());\n+            ccx.intrinsics.insert(name, f);\n+        });\n+        ($name:expr fn($($arg:expr),*) -> $ret:expr) => ({\n+            let name = $name;\n+            // HACK(eddyb) dummy output type, shouln't affect anything.\n+            let f = decl_cdecl_fn(ccx.llmod, name,\n+                                  Type::func([$($arg),*], &$ret), ty::mk_nil());\n+            ccx.intrinsics.insert(name, f);\n+        })\n+    )\n+    macro_rules! mk_struct (\n+        ($($field_ty:expr),*) => (Type::struct_(ccx, [$($field_ty),*], false))\n+    )\n+\n+    let i8p = Type::i8p(ccx);\n+    let void = Type::void(ccx);\n+    let i1 = Type::i1(ccx);\n+    let t_i8 = Type::i8(ccx);\n+    let t_i16 = Type::i16(ccx);\n+    let t_i32 = Type::i32(ccx);\n+    let t_i64 = Type::i64(ccx);\n+    let t_f32 = Type::f32(ccx);\n+    let t_f64 = Type::f64(ccx);\n+\n+    ifn!(\"llvm.memcpy.p0i8.p0i8.i32\" fn(i8p, i8p, t_i32, t_i32, i1) -> void);\n+    ifn!(\"llvm.memcpy.p0i8.p0i8.i64\" fn(i8p, i8p, t_i64, t_i32, i1) -> void);\n+    ifn!(\"llvm.memmove.p0i8.p0i8.i32\" fn(i8p, i8p, t_i32, t_i32, i1) -> void);\n+    ifn!(\"llvm.memmove.p0i8.p0i8.i64\" fn(i8p, i8p, t_i64, t_i32, i1) -> void);\n+    ifn!(\"llvm.memset.p0i8.i32\" fn(i8p, t_i8, t_i32, t_i32, i1) -> void);\n+    ifn!(\"llvm.memset.p0i8.i64\" fn(i8p, t_i8, t_i64, t_i32, i1) -> void);\n+\n+    ifn!(\"llvm.trap\" fn() -> void);\n+    ifn!(\"llvm.debugtrap\" fn() -> void);\n+    ifn!(\"llvm.frameaddress\" fn(t_i32) -> i8p);\n+\n+    ifn!(\"llvm.powi.f32\" fn(t_f32, t_i32) -> t_f32);\n+    ifn!(\"llvm.powi.f64\" fn(t_f64, t_i32) -> t_f64);\n+    ifn!(\"llvm.pow.f32\" fn(t_f32, t_f32) -> t_f32);\n+    ifn!(\"llvm.pow.f64\" fn(t_f64, t_f64) -> t_f64);\n+\n+    ifn!(\"llvm.sqrt.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.sqrt.f64\" fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.sin.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.sin.f64\" fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.cos.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.cos.f64\" fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.exp.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.exp.f64\" fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.exp2.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.exp2.f64\" fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.log.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.log.f64\" fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.log10.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.log10.f64\" fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.log2.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.log2.f64\" fn(t_f64) -> t_f64);\n+\n+    ifn!(\"llvm.fma.f32\" fn(t_f32, t_f32, t_f32) -> t_f32);\n+    ifn!(\"llvm.fma.f64\" fn(t_f64, t_f64, t_f64) -> t_f64);\n+\n+    ifn!(\"llvm.fabs.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.fabs.f64\" fn(t_f64) -> t_f64);\n+\n+    ifn!(\"llvm.floor.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.floor.f64\" fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.ceil.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.ceil.f64\" fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.trunc.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.trunc.f64\" fn(t_f64) -> t_f64);\n+\n+    ifn!(\"llvm.rint.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.rint.f64\" fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.nearbyint.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.nearbyint.f64\" fn(t_f64) -> t_f64);\n+\n+    ifn!(\"llvm.ctpop.i8\" fn(t_i8) -> t_i8);\n+    ifn!(\"llvm.ctpop.i16\" fn(t_i16) -> t_i16);\n+    ifn!(\"llvm.ctpop.i32\" fn(t_i32) -> t_i32);\n+    ifn!(\"llvm.ctpop.i64\" fn(t_i64) -> t_i64);\n+\n+    ifn!(\"llvm.ctlz.i8\" fn(t_i8 , i1) -> t_i8);\n+    ifn!(\"llvm.ctlz.i16\" fn(t_i16, i1) -> t_i16);\n+    ifn!(\"llvm.ctlz.i32\" fn(t_i32, i1) -> t_i32);\n+    ifn!(\"llvm.ctlz.i64\" fn(t_i64, i1) -> t_i64);\n+\n+    ifn!(\"llvm.cttz.i8\" fn(t_i8 , i1) -> t_i8);\n+    ifn!(\"llvm.cttz.i16\" fn(t_i16, i1) -> t_i16);\n+    ifn!(\"llvm.cttz.i32\" fn(t_i32, i1) -> t_i32);\n+    ifn!(\"llvm.cttz.i64\" fn(t_i64, i1) -> t_i64);\n+\n+    ifn!(\"llvm.bswap.i16\" fn(t_i16) -> t_i16);\n+    ifn!(\"llvm.bswap.i32\" fn(t_i32) -> t_i32);\n+    ifn!(\"llvm.bswap.i64\" fn(t_i64) -> t_i64);\n+\n+    ifn!(\"llvm.sadd.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+    ifn!(\"llvm.sadd.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+    ifn!(\"llvm.sadd.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+    ifn!(\"llvm.sadd.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+\n+    ifn!(\"llvm.uadd.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+    ifn!(\"llvm.uadd.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+    ifn!(\"llvm.uadd.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+    ifn!(\"llvm.uadd.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+\n+    ifn!(\"llvm.ssub.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+    ifn!(\"llvm.ssub.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+    ifn!(\"llvm.ssub.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+    ifn!(\"llvm.ssub.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+\n+    ifn!(\"llvm.usub.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+    ifn!(\"llvm.usub.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+    ifn!(\"llvm.usub.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+    ifn!(\"llvm.usub.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+\n+    ifn!(\"llvm.smul.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+    ifn!(\"llvm.smul.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+    ifn!(\"llvm.smul.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+    ifn!(\"llvm.smul.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+\n+    ifn!(\"llvm.umul.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+    ifn!(\"llvm.umul.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+    ifn!(\"llvm.umul.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+    ifn!(\"llvm.umul.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+\n+    ifn!(\"llvm.expect.i1\" fn(i1, i1) -> i1);\n \n     // Some intrinsics were introduced in later versions of LLVM, but they have\n     // fallbacks in libc or libm and such. Currently, all of these intrinsics\n     // were introduced in LLVM 3.4, so we case on that.\n     macro_rules! compatible_ifn (\n-        ($intrinsics:ident, $name:expr, $cname:expr, $args:expr, $ret:expr) => ({\n+        ($name:expr, $cname:ident ($($arg:expr),*) -> $ret:expr) => ({\n             let name = $name;\n             if unsafe { llvm::LLVMVersionMinor() >= 4 } {\n-                ifn!($intrinsics, $name, $args, $ret);\n+                ifn!(name fn($($arg),*) -> $ret);\n             } else {\n-                let f = decl_cdecl_fn(llmod, $cname,\n-                                      Type::func($args, &$ret),\n+                let f = decl_cdecl_fn(ccx.llmod, stringify!($cname),\n+                                      Type::func([$($arg),*], &$ret),\n                                       ty::mk_nil());\n-                $intrinsics.insert(name, f);\n+                ccx.intrinsics.insert(name, f);\n             }\n         })\n     )\n \n-    compatible_ifn!(intrinsics, \"llvm.copysign.f32\", \"copysignf\",\n-                    [Type::f32(), Type::f32()], Type::f32());\n-    compatible_ifn!(intrinsics, \"llvm.copysign.f64\", \"copysign\",\n-                    [Type::f64(), Type::f64()], Type::f64());\n-    compatible_ifn!(intrinsics, \"llvm.round.f32\", \"roundf\",\n-                    [Type::f32()], Type::f32());\n-    compatible_ifn!(intrinsics, \"llvm.round.f64\", \"round\",\n-                    [Type::f64()], Type::f64());\n+    compatible_ifn!(\"llvm.copysign.f32\", copysignf(t_f32, t_f32) -> t_f32);\n+    compatible_ifn!(\"llvm.copysign.f64\", copysign(t_f64, t_f64) -> t_f64);\n+    compatible_ifn!(\"llvm.round.f32\", roundf(t_f32) -> t_f32);\n+    compatible_ifn!(\"llvm.round.f64\", round(t_f64) -> t_f64);\n \n-    return intrinsics;\n-}\n \n-pub fn declare_dbg_intrinsics(llmod: ModuleRef, intrinsics: &mut HashMap<&'static str, ValueRef>) {\n-    ifn!(intrinsics, \"llvm.dbg.declare\", [Type::metadata(), Type::metadata()], Type::void());\n-    ifn!(intrinsics,\n-         \"llvm.dbg.value\",   [Type::metadata(), Type::i64(), Type::metadata()], Type::void());\n+    if ccx.sess().opts.debuginfo != NoDebugInfo {\n+        ifn!(\"llvm.dbg.declare\" fn(Type::metadata(ccx), Type::metadata(ccx)) -> void);\n+        ifn!(\"llvm.dbg.value\" fn(Type::metadata(ccx), t_i64, Type::metadata(ccx)) -> void);\n+    }\n }\n \n pub fn trap(bcx: &Block) {\n@@ -2389,40 +2353,39 @@ pub fn symname(name: &str, hash: &str, vers: &str) -> ~str {\n     link::exported_name(ast_map::Values(path.iter()).chain(None), hash, vers)\n }\n \n-pub fn decl_crate_map(sess: &Session, mapmeta: LinkMeta,\n-                      llmod: ModuleRef) -> (~str, ValueRef) {\n-    let targ_cfg = sess.targ_cfg;\n-    let int_type = Type::int(targ_cfg.arch);\n+pub fn decl_crate_map(ccx: &mut CrateContext) {\n     let mut n_subcrates = 1;\n-    let cstore = &sess.cstore;\n-    while cstore.have_crate_data(n_subcrates) { n_subcrates += 1; }\n-    let is_top = !sess.building_library.get() || sess.opts.cg.gen_crate_map;\n+    while ccx.sess().cstore.have_crate_data(n_subcrates) {\n+        n_subcrates += 1;\n+    }\n+    let is_top = !ccx.sess().building_library.get() || ccx.sess().opts.cg.gen_crate_map;\n     let sym_name = if is_top {\n         ~\"_rust_crate_map_toplevel\"\n     } else {\n-        symname(\"_rust_crate_map_\" + mapmeta.crateid.name,\n-                mapmeta.crate_hash.as_str(),\n-                mapmeta.crateid.version_or_default())\n+        symname(\"_rust_crate_map_\" + ccx.link_meta.crateid.name,\n+                ccx.link_meta.crate_hash.as_str(),\n+                ccx.link_meta.crateid.version_or_default())\n     };\n \n-    let maptype = Type::struct_([\n-        Type::i32(),        // version\n-        int_type.ptr_to(),  // event loop factory\n+    let maptype = Type::struct_(ccx, [\n+        Type::i32(ccx),        // version\n+        ccx.int_type.ptr_to(), // event loop factory\n     ], false);\n     let map = sym_name.with_c_str(|buf| {\n         unsafe {\n-            llvm::LLVMAddGlobal(llmod, maptype.to_ref(), buf)\n+            llvm::LLVMAddGlobal(ccx.llmod, maptype.to_ref(), buf)\n         }\n     });\n     lib::llvm::SetLinkage(map, lib::llvm::ExternalLinkage);\n \n     // On windows we'd like to export the toplevel cratemap\n     // such that we can find it from libstd.\n-    if targ_cfg.os == OsWin32 && is_top {\n+    if ccx.sess().targ_cfg.os == OsWin32 && is_top {\n         unsafe { llvm::LLVMRustSetDLLExportStorageClass(map) }\n     }\n \n-    return (sym_name, map);\n+    ccx.crate_map_name = sym_name;\n+    ccx.crate_map = map;\n }\n \n pub fn fill_crate_map(ccx: &CrateContext, map: ValueRef) {\n@@ -2442,8 +2405,8 @@ pub fn fill_crate_map(ccx: &CrateContext, map: ValueRef) {\n         None => C_null(ccx.int_type.ptr_to())\n     };\n     unsafe {\n-        llvm::LLVMSetInitializer(map, C_struct(\n-            [C_i32(2),\n+        llvm::LLVMSetInitializer(map, C_struct(ccx,\n+            [C_i32(ccx, 2),\n             event_loop_factory,\n         ], false));\n     }\n@@ -2457,7 +2420,7 @@ pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r CrateContext, ie: encoder::EncodeI\n         let link_meta = &cx.link_meta;\n         encoder::EncodeParams {\n             diag: diag,\n-            tcx: cx.tcx,\n+            tcx: cx.tcx(),\n             reexports2: cx.exp_map2,\n             item_symbols: item_symbols,\n             non_inlineable_statics: &cx.non_inlineable_statics,\n@@ -2475,14 +2438,14 @@ pub fn write_metadata(cx: &CrateContext, krate: &ast::Crate) -> Vec<u8> {\n     }\n \n     let encode_inlined_item: encoder::EncodeInlinedItem =\n-        |ecx, ebml_w, ii| astencode::encode_inlined_item(ecx, ebml_w, ii, cx.maps);\n+        |ecx, ebml_w, ii| astencode::encode_inlined_item(ecx, ebml_w, ii, &cx.maps);\n \n     let encode_parms = crate_ctxt_to_encode_parms(cx, encode_inlined_item);\n     let metadata = encoder::encode_metadata(encode_parms, krate);\n     let compressed = encoder::metadata_encoding_version +\n                         flate::deflate_bytes(metadata.as_slice()).as_slice();\n-    let llmeta = C_bytes(compressed);\n-    let llconst = C_struct([llmeta], false);\n+    let llmeta = C_bytes(cx, compressed);\n+    let llconst = C_struct(cx, [llmeta], false);\n     let name = format!(\"rust_metadata_{}_{}_{}\", cx.link_meta.crateid.name,\n                        cx.link_meta.crateid.version_or_default(), cx.link_meta.crate_hash);\n     let llglobal = name.with_c_str(|buf| {\n@@ -2500,8 +2463,10 @@ pub fn write_metadata(cx: &CrateContext, krate: &ast::Crate) -> Vec<u8> {\n }\n \n pub fn trans_crate(krate: ast::Crate,\n-                   analysis: &CrateAnalysis,\n-                   output: &OutputFilenames) -> CrateTranslation {\n+                   analysis: CrateAnalysis,\n+                   output: &OutputFilenames) -> (ty::ctxt, CrateTranslation) {\n+    let CrateAnalysis { ty_cx: tcx, exp_map2, maps, reachable, .. } = analysis;\n+\n     // Before we touch LLVM, make sure that multithreading is enabled.\n     unsafe {\n         use sync::one::{Once, ONCE_INIT};\n@@ -2516,7 +2481,7 @@ pub fn trans_crate(krate: ast::Crate,\n         });\n \n         if POISONED {\n-            analysis.ty_cx.sess.bug(\"couldn't enable multi-threaded LLVM\");\n+            tcx.sess.bug(\"couldn't enable multi-threaded LLVM\");\n         }\n     }\n \n@@ -2532,19 +2497,14 @@ pub fn trans_crate(krate: ast::Crate,\n     // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n     let llmod_id = link_meta.crateid.name + \".rs\";\n \n-    let ccx = &CrateContext::new(llmod_id,\n-                                 &analysis.ty_cx,\n-                                 analysis.exp_map2,\n-                                 analysis.maps,\n-                                 Sha256::new(),\n-                                 link_meta,\n-                                 &analysis.reachable);\n+    let ccx = CrateContext::new(llmod_id, tcx, exp_map2, maps,\n+                                Sha256::new(), link_meta, reachable);\n     {\n         let _icx = push_ctxt(\"text\");\n-        trans_mod(ccx, &krate.module);\n+        trans_mod(&ccx, &krate.module);\n     }\n \n-    fill_crate_map(ccx, ccx.crate_map);\n+    fill_crate_map(&ccx, ccx.crate_map);\n \n     // win32: wart with exporting crate_map symbol\n     // We set the crate map (_rust_crate_map_toplevel) to use dll_export\n@@ -2564,13 +2524,13 @@ pub fn trans_crate(krate: ast::Crate,\n         })\n     }\n \n-    glue::emit_tydescs(ccx);\n+    glue::emit_tydescs(&ccx);\n     if ccx.sess().opts.debuginfo != NoDebugInfo {\n-        debuginfo::finalize(ccx);\n+        debuginfo::finalize(&ccx);\n     }\n \n     // Translate the metadata.\n-    let metadata = write_metadata(ccx, &krate);\n+    let metadata = write_metadata(&ccx, &krate);\n     if ccx.sess().trans_stats() {\n         println!(\"--- trans stats ---\");\n         println!(\"n_static_tydescs: {}\", ccx.stats.n_static_tydescs.get());\n@@ -2583,16 +2543,14 @@ pub fn trans_crate(krate: ast::Crate,\n         println!(\"n_inlines: {}\", ccx.stats.n_inlines.get());\n         println!(\"n_closures: {}\", ccx.stats.n_closures.get());\n         println!(\"fn stats:\");\n-        {\n-            let mut fn_stats = ccx.stats.fn_stats.borrow_mut();\n-            fn_stats.get().sort_by(|&(_, _, insns_a), &(_, _, insns_b)| {\n-                insns_b.cmp(&insns_a)\n-            });\n-            for tuple in fn_stats.get().iter() {\n-                match *tuple {\n-                    (ref name, ms, insns) => {\n-                        println!(\"{} insns, {} ms, {}\", insns, ms, *name);\n-                    }\n+        let mut fn_stats = ccx.stats.fn_stats.borrow_mut();\n+        fn_stats.get().sort_by(|&(_, _, insns_a), &(_, _, insns_b)| {\n+            insns_b.cmp(&insns_a)\n+        });\n+        for tuple in fn_stats.get().iter() {\n+            match *tuple {\n+                (ref name, ms, insns) => {\n+                    println!(\"{} insns, {} ms, {}\", insns, ms, *name);\n                 }\n             }\n         }\n@@ -2624,12 +2582,14 @@ pub fn trans_crate(krate: ast::Crate,\n     reachable.push(~\"rust_eh_personality\"); // referenced from .eh_frame section on some platforms\n     reachable.push(~\"rust_eh_personality_catch\"); // referenced from rt/rust_try.ll\n \n-    CrateTranslation {\n+    let metadata_module = ccx.metadata_llmod;\n+\n+    (ccx.tcx, CrateTranslation {\n         context: llcx,\n         module: llmod,\n         link: link_meta,\n-        metadata_module: ccx.metadata_llmod,\n+        metadata_module: metadata_module,\n         metadata: metadata,\n         reachable: reachable,\n-    }\n+    })\n }"}, {"sha": "79e22ea345529d3ac6767844da8f6564d9cf0b36", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 58, "deletions": 20, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -115,7 +115,7 @@ pub fn Invoke(cx: &Block,\n               attributes: &[(uint, lib::llvm::Attribute)])\n               -> ValueRef {\n     if cx.unreachable.get() {\n-        return C_null(Type::i8());\n+        return C_null(Type::i8(cx.ccx()));\n     }\n     check_not_terminated(cx);\n     terminate(cx, \"Invoke\");\n@@ -300,14 +300,18 @@ pub fn Not(cx: &Block, v: ValueRef) -> ValueRef {\n /* Memory */\n pub fn Malloc(cx: &Block, ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::i8p(cx.ccx()).to_ref());\n+        }\n         B(cx).malloc(ty)\n     }\n }\n \n pub fn ArrayMalloc(cx: &Block, ty: Type, val: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::i8p(cx.ccx()).to_ref());\n+        }\n         B(cx).array_malloc(ty, val)\n     }\n }\n@@ -357,7 +361,9 @@ pub fn Load(cx: &Block, pointer_val: ValueRef) -> ValueRef {\n \n pub fn VolatileLoad(cx: &Block, pointer_val: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n+        }\n         B(cx).volatile_load(pointer_val)\n     }\n }\n@@ -408,7 +414,9 @@ pub fn AtomicStore(cx: &Block, val: ValueRef, ptr: ValueRef, order: AtomicOrderi\n \n pub fn GEP(cx: &Block, pointer: ValueRef, indices: &[ValueRef]) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::nil(cx.ccx()).ptr_to().to_ref());\n+        }\n         B(cx).gep(pointer, indices)\n     }\n }\n@@ -418,35 +426,45 @@ pub fn GEP(cx: &Block, pointer: ValueRef, indices: &[ValueRef]) -> ValueRef {\n #[inline]\n pub fn GEPi(cx: &Block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::nil(cx.ccx()).ptr_to().to_ref());\n+        }\n         B(cx).gepi(base, ixs)\n     }\n }\n \n pub fn InBoundsGEP(cx: &Block, pointer: ValueRef, indices: &[ValueRef]) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::nil(cx.ccx()).ptr_to().to_ref());\n+        }\n         B(cx).inbounds_gep(pointer, indices)\n     }\n }\n \n pub fn StructGEP(cx: &Block, pointer: ValueRef, idx: uint) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::nil(cx.ccx()).ptr_to().to_ref());\n+        }\n         B(cx).struct_gep(pointer, idx)\n     }\n }\n \n pub fn GlobalString(cx: &Block, _str: *c_char) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::i8p(cx.ccx()).to_ref());\n+        }\n         B(cx).global_string(_str)\n     }\n }\n \n pub fn GlobalStringPtr(cx: &Block, _str: *c_char) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::i8p(cx.ccx()).to_ref());\n+        }\n         B(cx).global_string_ptr(_str)\n     }\n }\n@@ -591,15 +609,19 @@ pub fn FPCast(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n pub fn ICmp(cx: &Block, op: IntPredicate, lhs: ValueRef, rhs: ValueRef)\n      -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::i1(cx.ccx()).to_ref());\n+        }\n         B(cx).icmp(op, lhs, rhs)\n     }\n }\n \n pub fn FCmp(cx: &Block, op: RealPredicate, lhs: ValueRef, rhs: ValueRef)\n      -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::i1(cx.ccx()).to_ref());\n+        }\n         B(cx).fcmp(op, lhs, rhs)\n     }\n }\n@@ -686,58 +708,74 @@ pub fn VAArg(cx: &Block, list: ValueRef, ty: Type) -> ValueRef {\n \n pub fn ExtractElement(cx: &Block, vec_val: ValueRef, index: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n+        }\n         B(cx).extract_element(vec_val, index)\n     }\n }\n \n pub fn InsertElement(cx: &Block, vec_val: ValueRef, elt_val: ValueRef,\n                      index: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n+        }\n         B(cx).insert_element(vec_val, elt_val, index)\n     }\n }\n \n pub fn ShuffleVector(cx: &Block, v1: ValueRef, v2: ValueRef,\n                      mask: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n+        }\n         B(cx).shuffle_vector(v1, v2, mask)\n     }\n }\n \n pub fn VectorSplat(cx: &Block, num_elts: uint, elt_val: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n+        }\n         B(cx).vector_splat(num_elts, elt_val)\n     }\n }\n \n pub fn ExtractValue(cx: &Block, agg_val: ValueRef, index: uint) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n+        }\n         B(cx).extract_value(agg_val, index)\n     }\n }\n \n pub fn InsertValue(cx: &Block, agg_val: ValueRef, elt_val: ValueRef, index: uint) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n+        }\n         B(cx).insert_value(agg_val, elt_val, index)\n     }\n }\n \n pub fn IsNull(cx: &Block, val: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::i1(cx.ccx()).to_ref());\n+        }\n         B(cx).is_null(val)\n     }\n }\n \n pub fn IsNotNull(cx: &Block, val: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::i1(cx.ccx()).to_ref());\n+        }\n         B(cx).is_not_null(val)\n     }\n }"}, {"sha": "bc99a0ac5595abb5a5eda595325fe1ee3f08f718", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -25,7 +25,7 @@ use syntax::codemap::Span;\n \n pub struct Builder<'a> {\n     llbuilder: BuilderRef,\n-    ccx: &'a CrateContext<'a>,\n+    ccx: &'a CrateContext,\n }\n \n // This is a really awful way to get a zero-length c-string, but better (and a\n@@ -536,13 +536,13 @@ impl<'a> Builder<'a> {\n         // Small vector optimization. This should catch 100% of the cases that\n         // we care about.\n         if ixs.len() < 16 {\n-            let mut small_vec = [ C_i32(0), ..16 ];\n+            let mut small_vec = [ C_i32(self.ccx, 0), ..16 ];\n             for (small_vec_e, &ix) in small_vec.mut_iter().zip(ixs.iter()) {\n-                *small_vec_e = C_i32(ix as i32);\n+                *small_vec_e = C_i32(self.ccx, ix as i32);\n             }\n             self.inbounds_gep(base, small_vec.slice(0, ixs.len()))\n         } else {\n-            let v = ixs.iter().map(|i| C_i32(*i as i32)).collect::<Vec<ValueRef> >();\n+            let v = ixs.iter().map(|i| C_i32(self.ccx, *i as i32)).collect::<Vec<ValueRef>>();\n             self.count_insn(\"gepi\");\n             self.inbounds_gep(base, v.as_slice())\n         }\n@@ -762,7 +762,7 @@ impl<'a> Builder<'a> {\n             self.count_insn(\"inlineasm\");\n             let asm = comment_text.with_c_str(|c| {\n                 unsafe {\n-                    llvm::LLVMConstInlineAsm(Type::func([], &Type::void()).to_ref(),\n+                    llvm::LLVMConstInlineAsm(Type::func([], &Type::void(self.ccx)).to_ref(),\n                                              c, noname(), False, False)\n                 }\n             });\n@@ -860,8 +860,9 @@ impl<'a> Builder<'a> {\n         unsafe {\n             let elt_ty = val_ty(elt);\n             let undef = llvm::LLVMGetUndef(Type::vector(&elt_ty, num_elts as u64).to_ref());\n-            let vec = self.insert_element(undef, elt, C_i32(0));\n-            self.shuffle_vector(vec, undef, C_null(Type::vector(&Type::i32(), num_elts as u64)))\n+            let vec = self.insert_element(undef, elt, C_i32(self.ccx, 0));\n+            let vec_i32_ty = Type::vector(&Type::i32(self.ccx), num_elts as u64);\n+            self.shuffle_vector(vec, undef, C_null(vec_i32_ty))\n         }\n     }\n "}, {"sha": "83805cf844f3174e2489c335fa1d8d8ec6e5ad29", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -85,34 +85,34 @@ fn ty_size(ty: Type) -> uint {\n     }\n }\n \n-fn classify_ret_ty(ty: Type) -> ArgType {\n+fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n         return ArgType::direct(ty, None, None, None);\n     }\n     let size = ty_size(ty);\n     if size <= 4 {\n         let llty = if size <= 1 {\n-            Type::i8()\n+            Type::i8(ccx)\n         } else if size <= 2 {\n-            Type::i16()\n+            Type::i16(ccx)\n         } else {\n-            Type::i32()\n+            Type::i32(ccx)\n         };\n         return ArgType::direct(ty, Some(llty), None, None);\n     }\n     ArgType::indirect(ty, Some(StructRetAttribute))\n }\n \n-fn classify_arg_ty(ty: Type) -> ArgType {\n+fn classify_arg_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n         return ArgType::direct(ty, None, None, None);\n     }\n     let align = ty_align(ty);\n     let size = ty_size(ty);\n     let llty = if align <= 4 {\n-        Type::array(&Type::i32(), ((size + 3) / 4) as u64)\n+        Type::array(&Type::i32(ccx), ((size + 3) / 4) as u64)\n     } else {\n-        Type::array(&Type::i64(), ((size + 7) / 8) as u64)\n+        Type::array(&Type::i64(ccx), ((size + 7) / 8) as u64)\n     };\n     ArgType::direct(ty, Some(llty), None, None)\n }\n@@ -127,20 +127,20 @@ fn is_reg_ty(ty: Type) -> bool {\n     }\n }\n \n-pub fn compute_abi_info(_ccx: &CrateContext,\n+pub fn compute_abi_info(ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {\n     let mut arg_tys = Vec::new();\n     for &aty in atys.iter() {\n-        let ty = classify_arg_ty(aty);\n+        let ty = classify_arg_ty(ccx, aty);\n         arg_tys.push(ty);\n     }\n \n     let ret_ty = if ret_def {\n-        classify_ret_ty(rty)\n+        classify_ret_ty(ccx, rty)\n     } else {\n-        ArgType::direct(Type::void(), None, None, None)\n+        ArgType::direct(Type::void(ccx), None, None, None)\n     };\n \n     return FnType {"}, {"sha": "68d9bb82a6c243516c33f97bfa2eeb46d2fff5c6", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -15,7 +15,6 @@ use std::cmp;\n use lib::llvm::{llvm, Integer, Pointer, Float, Double, Struct, Array};\n use lib::llvm::StructRetAttribute;\n use middle::trans::context::CrateContext;\n-use middle::trans::context::task_llcx;\n use middle::trans::cabi::*;\n use middle::trans::type_::Type;\n \n@@ -94,7 +93,7 @@ fn classify_ret_ty(ty: Type) -> ArgType {\n     }\n }\n \n-fn classify_arg_ty(ty: Type, offset: &mut uint) -> ArgType {\n+fn classify_arg_ty(ccx: &CrateContext, ty: Type, offset: &mut uint) -> ArgType {\n     let orig_offset = *offset;\n     let size = ty_size(ty) * 8;\n     let mut align = ty_align(ty);\n@@ -108,8 +107,8 @@ fn classify_arg_ty(ty: Type, offset: &mut uint) -> ArgType {\n     } else {\n         ArgType::direct(\n             ty,\n-            Some(struct_ty(ty)),\n-            padding_ty(align, orig_offset),\n+            Some(struct_ty(ccx, ty)),\n+            padding_ty(ccx, align, orig_offset),\n             None\n         )\n     }\n@@ -125,16 +124,16 @@ fn is_reg_ty(ty: Type) -> bool {\n     };\n }\n \n-fn padding_ty(align: uint, offset: uint) -> Option<Type> {\n+fn padding_ty(ccx: &CrateContext, align: uint, offset: uint) -> Option<Type> {\n     if ((align - 1 ) & offset) > 0 {\n-        return Some(Type::i32());\n+        Some(Type::i32(ccx))\n+    } else {\n+        None\n     }\n-\n-    return None;\n }\n \n-fn coerce_to_int(size: uint) -> Vec<Type> {\n-    let int_ty = Type::i32();\n+fn coerce_to_int(ccx: &CrateContext, size: uint) -> Vec<Type> {\n+    let int_ty = Type::i32(ccx);\n     let mut args = Vec::new();\n \n     let mut n = size / 32;\n@@ -146,35 +145,34 @@ fn coerce_to_int(size: uint) -> Vec<Type> {\n     let r = size % 32;\n     if r > 0 {\n         unsafe {\n-            args.push(Type::from_ref(llvm::LLVMIntTypeInContext(task_llcx(), r as c_uint)));\n+            args.push(Type::from_ref(llvm::LLVMIntTypeInContext(ccx.llcx, r as c_uint)));\n         }\n     }\n \n     args\n }\n \n-fn struct_ty(ty: Type) -> Type {\n+fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n     let size = ty_size(ty) * 8;\n-    let fields = coerce_to_int(size);\n-    return Type::struct_(fields.as_slice(), false);\n+    Type::struct_(ccx, coerce_to_int(ccx, size).as_slice(), false)\n }\n \n-pub fn compute_abi_info(_ccx: &CrateContext,\n+pub fn compute_abi_info(ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {\n     let ret_ty = if ret_def {\n         classify_ret_ty(rty)\n     } else {\n-        ArgType::direct(Type::void(), None, None, None)\n+        ArgType::direct(Type::void(ccx), None, None, None)\n     };\n \n     let sret = ret_ty.is_indirect();\n     let mut arg_tys = Vec::new();\n     let mut offset = if sret { 4 } else { 0 };\n \n     for aty in atys.iter() {\n-        let ty = classify_arg_ty(*aty, &mut offset);\n+        let ty = classify_arg_ty(ccx, *aty, &mut offset);\n         arg_tys.push(ty);\n     };\n "}, {"sha": "b2cb6970597872d1c6445f9a24e3eae72e46a670", "filename": "src/librustc/middle/trans/cabi_x86.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -25,7 +25,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n \n     let ret_ty;\n     if !ret_def {\n-        ret_ty = ArgType::direct(Type::void(), None, None, None);\n+        ret_ty = ArgType::direct(Type::void(ccx), None, None, None);\n     } else if rty.kind() == Struct {\n         // Returning a structure. Most often, this will use\n         // a hidden first argument. On some platforms, though,\n@@ -39,10 +39,10 @@ pub fn compute_abi_info(ccx: &CrateContext,\n         let strategy = match ccx.sess().targ_cfg.os {\n             OsWin32 | OsMacos => {\n                 match llsize_of_alloc(ccx, rty) {\n-                    1 => RetValue(Type::i8()),\n-                    2 => RetValue(Type::i16()),\n-                    4 => RetValue(Type::i32()),\n-                    8 => RetValue(Type::i64()),\n+                    1 => RetValue(Type::i8(ccx)),\n+                    2 => RetValue(Type::i16(ccx)),\n+                    4 => RetValue(Type::i32(ccx)),\n+                    8 => RetValue(Type::i64(ccx)),\n                     _ => RetPointer\n                 }\n             }"}, {"sha": "c1ae28005d9b5fa76492b3acd87991b9b4734cbf", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -291,7 +291,7 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n     return cls;\n }\n \n-fn llreg_ty(cls: &[RegClass]) -> Type {\n+fn llreg_ty(ccx: &CrateContext, cls: &[RegClass]) -> Type {\n     fn llvec_len(cls: &[RegClass]) -> uint {\n         let mut len = 1u;\n         for c in cls.iter() {\n@@ -309,33 +309,34 @@ fn llreg_ty(cls: &[RegClass]) -> Type {\n     while i < e {\n         match cls[i] {\n             Int => {\n-                tys.push(Type::i64());\n+                tys.push(Type::i64(ccx));\n             }\n             SSEFv => {\n                 let vec_len = llvec_len(cls.tailn(i + 1u));\n-                let vec_ty = Type::vector(&Type::f32(), (vec_len * 2u) as u64);\n+                let vec_ty = Type::vector(&Type::f32(ccx), (vec_len * 2u) as u64);\n                 tys.push(vec_ty);\n                 i += vec_len;\n                 continue;\n             }\n             SSEFs => {\n-                tys.push(Type::f32());\n+                tys.push(Type::f32(ccx));\n             }\n             SSEDs => {\n-                tys.push(Type::f64());\n+                tys.push(Type::f64(ccx));\n             }\n             _ => fail!(\"llregtype: unhandled class\")\n         }\n         i += 1u;\n     }\n-    return Type::struct_(tys.as_slice(), false);\n+    return Type::struct_(ccx, tys.as_slice(), false);\n }\n \n-pub fn compute_abi_info(_ccx: &CrateContext,\n+pub fn compute_abi_info(ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {\n-    fn x86_64_ty(ty: Type,\n+    fn x86_64_ty(ccx: &CrateContext,\n+                 ty: Type,\n                  is_mem_cls: |cls: &[RegClass]| -> bool,\n                  attr: Attribute)\n                  -> ArgType {\n@@ -345,7 +346,7 @@ pub fn compute_abi_info(_ccx: &CrateContext,\n                 ArgType::indirect(ty, Some(attr))\n             } else {\n                 ArgType::direct(ty,\n-                                Some(llreg_ty(cls.as_slice())),\n+                                Some(llreg_ty(ccx, cls.as_slice())),\n                                 None,\n                                 None)\n             }\n@@ -356,14 +357,14 @@ pub fn compute_abi_info(_ccx: &CrateContext,\n \n     let mut arg_tys = Vec::new();\n     for t in atys.iter() {\n-        let ty = x86_64_ty(*t, |cls| cls.is_pass_byval(), ByValAttribute);\n+        let ty = x86_64_ty(ccx, *t, |cls| cls.is_pass_byval(), ByValAttribute);\n         arg_tys.push(ty);\n     }\n \n     let ret_ty = if ret_def {\n-        x86_64_ty(rty, |cls| cls.is_ret_bysret(), StructRetAttribute)\n+        x86_64_ty(ccx, rty, |cls| cls.is_ret_bysret(), StructRetAttribute)\n     } else {\n-        ArgType::direct(Type::void(), None, None, None)\n+        ArgType::direct(Type::void(ccx), None, None, None)\n     };\n \n     return FnType {"}, {"sha": "61a855a7f0976259c1eb622c40b7f27d8bd24322", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -267,15 +267,15 @@ pub fn trans_fn_ref_with_vtables(\n \n     let _icx = push_ctxt(\"trans_fn_ref_with_vtables\");\n     let ccx = bcx.ccx();\n-    let tcx = ccx.tcx;\n+    let tcx = bcx.tcx();\n \n     debug!(\"trans_fn_ref_with_vtables(bcx={}, def_id={}, node={:?}, \\\n             type_params={}, vtables={})\",\n            bcx.to_str(),\n-           def_id.repr(bcx.tcx()),\n+           def_id.repr(tcx),\n            node,\n-           type_params.repr(bcx.tcx()),\n-           vtables.repr(bcx.tcx()));\n+           type_params.repr(tcx),\n+           vtables.repr(tcx));\n \n     assert!(type_params.iter().all(|t| !ty::type_needs_infer(*t)));\n \n@@ -366,12 +366,12 @@ pub fn trans_fn_ref_with_vtables(\n     } else if def_id.krate == ast::LOCAL_CRATE {\n         let map_node = session::expect(\n             ccx.sess(),\n-            ccx.tcx.map.find(def_id.node),\n+            tcx.map.find(def_id.node),\n             || format!(\"local item should be in ast map\"));\n \n         match map_node {\n             ast_map::NodeForeignItem(_) => {\n-                ccx.tcx.map.get_foreign_abis(def_id.node).is_intrinsic()\n+                tcx.map.get_foreign_abis(def_id.node).is_intrinsic()\n             }\n             _ => false\n         }\n@@ -502,9 +502,9 @@ pub fn trans_lang_call<'a>(\n                        dest: Option<expr::Dest>)\n                        -> Result<'a> {\n     let fty = if did.krate == ast::LOCAL_CRATE {\n-        ty::node_id_to_type(bcx.ccx().tcx, did.node)\n+        ty::node_id_to_type(bcx.tcx(), did.node)\n     } else {\n-        csearch::get_type(bcx.ccx().tcx, did).ty\n+        csearch::get_type(bcx.tcx(), did).ty\n     };\n     callee::trans_call_inner(bcx,\n                              None,\n@@ -649,7 +649,7 @@ pub fn trans_call_inner<'a>(\n     };\n \n     let mut llresult = unsafe {\n-        llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref())\n+        llvm::LLVMGetUndef(Type::nil(ccx).ptr_to().to_ref())\n     };\n \n     // The code below invokes the function, using either the Rust"}, {"sha": "1acc746b197a13516f600bb765d29d45d68ecbae", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -205,7 +205,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n                 _ => {}\n             }\n         }\n-        self.ccx.tcx.sess.bug(\"no loop scope found\");\n+        self.ccx.sess().bug(\"no loop scope found\");\n     }\n \n     fn normal_exit_block(&'a self,\n@@ -238,18 +238,18 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n          * instance of `ty`\n          */\n \n-        if !ty::type_needs_drop(self.ccx.tcx, ty) { return; }\n+        if !ty::type_needs_drop(self.ccx.tcx(), ty) { return; }\n         let drop = ~DropValue {\n             is_immediate: false,\n-            on_unwind: ty::type_needs_unwind_cleanup(self.ccx.tcx, ty),\n+            on_unwind: ty::type_needs_unwind_cleanup(self.ccx.tcx(), ty),\n             val: val,\n             ty: ty\n         };\n \n         debug!(\"schedule_drop_mem({:?}, val={}, ty={})\",\n                cleanup_scope,\n                self.ccx.tn.val_to_str(val),\n-               ty.repr(self.ccx.tcx));\n+               ty.repr(self.ccx.tcx()));\n \n         self.schedule_clean(cleanup_scope, drop as ~Cleanup);\n     }\n@@ -262,18 +262,18 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n          * Schedules a (deep) drop of `val`, which is an instance of `ty`\n          */\n \n-        if !ty::type_needs_drop(self.ccx.tcx, ty) { return; }\n+        if !ty::type_needs_drop(self.ccx.tcx(), ty) { return; }\n         let drop = ~DropValue {\n             is_immediate: true,\n-            on_unwind: ty::type_needs_unwind_cleanup(self.ccx.tcx, ty),\n+            on_unwind: ty::type_needs_unwind_cleanup(self.ccx.tcx(), ty),\n             val: val,\n             ty: ty\n         };\n \n         debug!(\"schedule_drop_immediate({:?}, val={}, ty={})\",\n                cleanup_scope,\n                self.ccx.tn.val_to_str(val),\n-               ty.repr(self.ccx.tcx));\n+               ty.repr(self.ccx.tcx()));\n \n         self.schedule_clean(cleanup_scope, drop as ~Cleanup);\n     }\n@@ -330,7 +330,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n             }\n         }\n \n-        self.ccx.tcx.sess.bug(\n+        self.ccx.sess().bug(\n             format!(\"no cleanup scope {} found\",\n                     self.ccx.tcx.map.node_to_str(cleanup_scope)));\n     }\n@@ -540,7 +540,7 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n                     }\n \n                     LoopExit(id, _) => {\n-                        self.ccx.tcx.sess.bug(format!(\n+                        self.ccx.sess().bug(format!(\n                                 \"cannot exit from scope {:?}, \\\n                                 not in scope\", id));\n                     }\n@@ -669,7 +669,9 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n         // The landing pad return type (the type being propagated). Not sure what\n         // this represents but it's determined by the personality function and\n         // this is what the EH proposal example uses.\n-        let llretty = Type::struct_([Type::i8p(), Type::i32()], false);\n+        let llretty = Type::struct_(self.ccx,\n+                                    [Type::i8p(self.ccx), Type::i32(self.ccx)],\n+                                    false);\n \n         // The exception handling personality function.\n         let def_id = common::langcall(pad_bcx, None, \"\", EhPersonalityLangItem);"}, {"sha": "05375ebeb31a2209080162768ce0211136caa980", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -161,8 +161,7 @@ fn allocate_cbox<'a>(bcx: &'a Block<'a>,\n                      cdata_ty: ty::t)\n                      -> Result<'a> {\n     let _icx = push_ctxt(\"closure::allocate_cbox\");\n-    let ccx = bcx.ccx();\n-    let tcx = ccx.tcx;\n+    let tcx = bcx.tcx();\n \n     // Allocate and initialize the box:\n     match sigil {\n@@ -197,7 +196,7 @@ pub fn store_environment<'a>(\n                          -> ClosureResult<'a> {\n     let _icx = push_ctxt(\"closure::store_environment\");\n     let ccx = bcx.ccx();\n-    let tcx = ccx.tcx;\n+    let tcx = ccx.tcx();\n \n     // compute the type of the closure\n     let cdata_ty = mk_closure_tys(tcx, bound_values.as_slice());\n@@ -343,7 +342,7 @@ fn load_environment<'a>(bcx: &'a Block<'a>, cdata_ty: ty::t,\n \n fn fill_fn_pair(bcx: &Block, pair: ValueRef, llfn: ValueRef, llenvptr: ValueRef) {\n     Store(bcx, llfn, GEPi(bcx, pair, [0u, abi::fn_field_code]));\n-    let llenvptr = PointerCast(bcx, llenvptr, Type::i8p());\n+    let llenvptr = PointerCast(bcx, llenvptr, Type::i8p(bcx.ccx()));\n     Store(bcx, llenvptr, GEPi(bcx, pair, [0u, abi::fn_field_box]));\n }\n \n@@ -433,7 +432,7 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n         }\n     }\n \n-    let tcx = ccx.tcx;\n+    let tcx = ccx.tcx();\n \n     debug!(\"get_wrapper_for_bare_fn(closure_ty={})\", closure_ty.repr(tcx));\n \n@@ -510,7 +509,7 @@ pub fn make_closure_from_bare_fn<'a>(bcx: &'a Block<'a>,\n                                      -> DatumBlock<'a, Expr>  {\n     let scratch = rvalue_scratch_datum(bcx, closure_ty, \"__adjust\");\n     let wrapper = get_wrapper_for_bare_fn(bcx.ccx(), closure_ty, def, fn_ptr, true);\n-    fill_fn_pair(bcx, scratch.val, wrapper, C_null(Type::i8p()));\n+    fill_fn_pair(bcx, scratch.val, wrapper, C_null(Type::i8p(bcx.ccx())));\n \n     DatumBlock(bcx, scratch.to_expr_datum())\n }"}, {"sha": "43f7397f190910b643b6b75bd10a2c71e6df4023", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 42, "deletions": 49, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -18,7 +18,6 @@ use lib::llvm::{True, False, Bool};\n use lib::llvm::llvm;\n use lib;\n use middle::lang_items::LangItem;\n-use middle::trans::base;\n use middle::trans::build;\n use middle::trans::cleanup;\n use middle::trans::datum;\n@@ -49,7 +48,7 @@ pub use middle::trans::context::CrateContext;\n fn type_is_newtype_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n     match ty::get(ty).sty {\n         ty::ty_struct(def_id, ref substs) => {\n-            let fields = ty::struct_fields(ccx.tcx, def_id, substs);\n+            let fields = ty::struct_fields(ccx.tcx(), def_id, substs);\n             fields.len() == 1 &&\n                 fields.get(0).ident.name ==\n                     token::special_idents::unnamed_field.name &&\n@@ -62,7 +61,7 @@ fn type_is_newtype_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n pub fn type_is_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n     use middle::trans::machine::llsize_of_alloc;\n     use middle::trans::type_of::sizing_type_of;\n-    let tcx = ccx.tcx;\n+    let tcx = ccx.tcx();\n     let simple = ty::type_is_scalar(ty) || ty::type_is_boxed(ty) ||\n         ty::type_is_unique(ty) || ty::type_is_region_ptr(ty) ||\n         type_is_newtype_immediate(ccx, ty) || ty::type_is_bot(ty) ||\n@@ -100,7 +99,7 @@ pub fn return_type_is_void(ccx: &CrateContext, ty: ty::t) -> bool {\n      * return type (in order to aid with C ABI compatibility).\n      */\n \n-    ty::type_is_nil(ty) || ty::type_is_bot(ty) || ty::type_is_empty(ccx.tcx, ty)\n+    ty::type_is_nil(ty) || ty::type_is_bot(ty) || ty::type_is_empty(ccx.tcx(), ty)\n }\n \n /// Generates a unique symbol based off the name given. This is used to create\n@@ -286,7 +285,7 @@ pub struct FunctionContext<'a> {\n     block_arena: &'a TypedArena<Block<'a>>,\n \n     // This function's enclosing crate context.\n-    ccx: &'a CrateContext<'a>,\n+    ccx: &'a CrateContext,\n \n     // Used and maintained by the debuginfo module.\n     debug_context: debuginfo::FunctionDebugContext,\n@@ -330,7 +329,12 @@ impl<'a> FunctionContext<'a> {\n \n     pub fn get_llreturn(&self) -> BasicBlockRef {\n         if self.llreturn.get().is_none() {\n-            self.llreturn.set(Some(base::mk_return_basic_block(self.llfn)));\n+\n+            self.llreturn.set(Some(unsafe {\n+                \"return\".with_c_str(|buf| {\n+                    llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx, self.llfn, buf)\n+                })\n+            }))\n         }\n \n         self.llreturn.get().unwrap()\n@@ -435,9 +439,9 @@ impl<'a> Block<'a> {\n         })\n     }\n \n-    pub fn ccx(&self) -> &'a CrateContext<'a> { self.fcx.ccx }\n+    pub fn ccx(&self) -> &'a CrateContext { self.fcx.ccx }\n     pub fn tcx(&self) -> &'a ty::ctxt {\n-        self.fcx.ccx.tcx\n+        &self.fcx.ccx.tcx\n     }\n     pub fn sess(&self) -> &'a Session { self.fcx.ccx.sess() }\n \n@@ -540,40 +544,40 @@ pub fn C_floating(s: &str, t: Type) -> ValueRef {\n     }\n }\n \n-pub fn C_nil() -> ValueRef {\n-    C_struct([], false)\n+pub fn C_nil(ccx: &CrateContext) -> ValueRef {\n+    C_struct(ccx, [], false)\n }\n \n-pub fn C_bool(val: bool) -> ValueRef {\n-    C_integral(Type::bool(), val as u64, false)\n+pub fn C_bool(ccx: &CrateContext, val: bool) -> ValueRef {\n+    C_integral(Type::bool(ccx), val as u64, false)\n }\n \n-pub fn C_i1(val: bool) -> ValueRef {\n-    C_integral(Type::i1(), val as u64, false)\n+pub fn C_i1(ccx: &CrateContext, val: bool) -> ValueRef {\n+    C_integral(Type::i1(ccx), val as u64, false)\n }\n \n-pub fn C_i32(i: i32) -> ValueRef {\n-    return C_integral(Type::i32(), i as u64, true);\n+pub fn C_i32(ccx: &CrateContext, i: i32) -> ValueRef {\n+    C_integral(Type::i32(ccx), i as u64, true)\n }\n \n-pub fn C_i64(i: i64) -> ValueRef {\n-    return C_integral(Type::i64(), i as u64, true);\n+pub fn C_i64(ccx: &CrateContext, i: i64) -> ValueRef {\n+    C_integral(Type::i64(ccx), i as u64, true)\n }\n \n-pub fn C_u64(i: u64) -> ValueRef {\n-    return C_integral(Type::i64(), i, false);\n+pub fn C_u64(ccx: &CrateContext, i: u64) -> ValueRef {\n+    C_integral(Type::i64(ccx), i, false)\n }\n \n-pub fn C_int(cx: &CrateContext, i: int) -> ValueRef {\n-    return C_integral(cx.int_type, i as u64, true);\n+pub fn C_int(ccx: &CrateContext, i: int) -> ValueRef {\n+    C_integral(ccx.int_type, i as u64, true)\n }\n \n-pub fn C_uint(cx: &CrateContext, i: uint) -> ValueRef {\n-    return C_integral(cx.int_type, i as u64, false);\n+pub fn C_uint(ccx: &CrateContext, i: uint) -> ValueRef {\n+    C_integral(ccx.int_type, i as u64, false)\n }\n \n-pub fn C_u8(i: uint) -> ValueRef {\n-    return C_integral(Type::i8(), i as u64, false);\n+pub fn C_u8(ccx: &CrateContext, i: uint) -> ValueRef {\n+    C_integral(Type::i8(ccx), i as u64, false)\n }\n \n \n@@ -613,15 +617,15 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString) -> ValueRef {\n pub fn C_str_slice(cx: &CrateContext, s: InternedString) -> ValueRef {\n     unsafe {\n         let len = s.get().len();\n-        let cs = llvm::LLVMConstPointerCast(C_cstr(cx, s), Type::i8p().to_ref());\n-        C_struct([cs, C_uint(cx, len)], false)\n+        let cs = llvm::LLVMConstPointerCast(C_cstr(cx, s), Type::i8p(cx).to_ref());\n+        C_struct(cx, [cs, C_uint(cx, len)], false)\n     }\n }\n \n pub fn C_binary_slice(cx: &CrateContext, data: &[u8]) -> ValueRef {\n     unsafe {\n         let len = data.len();\n-        let lldata = C_bytes(data);\n+        let lldata = C_bytes(cx, data);\n \n         let gsym = token::gensym(\"binary\");\n         let g = format!(\"binary{}\", gsym).with_c_str(|buf| {\n@@ -631,25 +635,14 @@ pub fn C_binary_slice(cx: &CrateContext, data: &[u8]) -> ValueRef {\n         llvm::LLVMSetGlobalConstant(g, True);\n         lib::llvm::SetLinkage(g, lib::llvm::InternalLinkage);\n \n-        let cs = llvm::LLVMConstPointerCast(g, Type::i8p().to_ref());\n-        C_struct([cs, C_uint(cx, len)], false)\n-    }\n-}\n-\n-pub fn C_zero_byte_arr(size: uint) -> ValueRef {\n-    unsafe {\n-        let mut i = 0u;\n-        let mut elts: Vec<ValueRef> = Vec::new();\n-        while i < size { elts.push(C_u8(0u)); i += 1u; }\n-        return llvm::LLVMConstArray(Type::i8().to_ref(),\n-                                    elts.as_ptr(), elts.len() as c_uint);\n+        let cs = llvm::LLVMConstPointerCast(g, Type::i8p(cx).to_ref());\n+        C_struct(cx, [cs, C_uint(cx, len)], false)\n     }\n }\n \n-pub fn C_struct(elts: &[ValueRef], packed: bool) -> ValueRef {\n+pub fn C_struct(ccx: &CrateContext, elts: &[ValueRef], packed: bool) -> ValueRef {\n     unsafe {\n-\n-        llvm::LLVMConstStructInContext(base::task_llcx(),\n+        llvm::LLVMConstStructInContext(ccx.llcx,\n                                        elts.as_ptr(), elts.len() as c_uint,\n                                        packed as Bool)\n     }\n@@ -667,10 +660,10 @@ pub fn C_array(ty: Type, elts: &[ValueRef]) -> ValueRef {\n     }\n }\n \n-pub fn C_bytes(bytes: &[u8]) -> ValueRef {\n+pub fn C_bytes(ccx: &CrateContext, bytes: &[u8]) -> ValueRef {\n     unsafe {\n         let ptr = bytes.as_ptr() as *c_char;\n-        return llvm::LLVMConstStringInContext(base::task_llcx(), ptr, bytes.len() as c_uint, True);\n+        return llvm::LLVMConstStringInContext(ccx.llcx, ptr, bytes.len() as c_uint, True);\n     }\n }\n \n@@ -853,7 +846,7 @@ pub fn node_vtables(bcx: &Block, id: ast::NodeId)\n // vtables. This should eliminate any vtable_params.\n pub fn resolve_vtables_in_fn_ctxt(fcx: &FunctionContext, vts: typeck::vtable_res)\n     -> typeck::vtable_res {\n-    resolve_vtables_under_param_substs(fcx.ccx.tcx,\n+    resolve_vtables_under_param_substs(fcx.ccx.tcx(),\n                                        fcx.param_substs,\n                                        vts)\n }\n@@ -951,14 +944,14 @@ pub fn filename_and_line_num_from_span(bcx: &Block, span: Span)\n     let loc = bcx.sess().parse_sess.cm.lookup_char_pos(span.lo);\n     let filename_cstr = C_cstr(bcx.ccx(),\n                                token::intern_and_get_ident(loc.file.name));\n-    let filename = build::PointerCast(bcx, filename_cstr, Type::i8p());\n+    let filename = build::PointerCast(bcx, filename_cstr, Type::i8p(bcx.ccx()));\n     let line = C_int(bcx.ccx(), loc.line as int);\n     (filename, line)\n }\n \n // Casts a Rust bool value to an i1.\n pub fn bool_to_i1(bcx: &Block, llval: ValueRef) -> ValueRef {\n-    build::ICmp(bcx, lib::llvm::IntNE, llval, C_bool(false))\n+    build::ICmp(bcx, lib::llvm::IntNE, llval, C_bool(bcx.ccx(), false))\n }\n \n pub fn langcall(bcx: &Block,"}, {"sha": "d9868637b8f35949bc7b8ab4f0dcfbdead35b6ca", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 48, "deletions": 49, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -41,11 +41,11 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: ast::Lit)\n     -> ValueRef {\n     let _icx = push_ctxt(\"trans_lit\");\n     match lit.node {\n-        ast::LitChar(i) => C_integral(Type::char(), i as u64, false),\n+        ast::LitChar(i) => C_integral(Type::char(cx), i as u64, false),\n         ast::LitInt(i, t) => C_integral(Type::int_from_ty(cx, t), i as u64, true),\n         ast::LitUint(u, t) => C_integral(Type::uint_from_ty(cx, t), u, false),\n         ast::LitIntUnsuffixed(i) => {\n-            let lit_int_ty = ty::node_id_to_type(cx.tcx, e.id);\n+            let lit_int_ty = ty::node_id_to_type(cx.tcx(), e.id);\n             match ty::get(lit_int_ty).sty {\n                 ty::ty_int(t) => {\n                     C_integral(Type::int_from_ty(cx, t), i as u64, true)\n@@ -55,26 +55,26 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: ast::Lit)\n                 }\n                 _ => cx.sess().span_bug(lit.span,\n                         format!(\"integer literal has type {} (expected int or uint)\",\n-                                ty_to_str(cx.tcx, lit_int_ty)))\n+                                ty_to_str(cx.tcx(), lit_int_ty)))\n             }\n         }\n         ast::LitFloat(ref fs, t) => {\n-            C_floating(fs.get(), Type::float_from_ty(t))\n+            C_floating(fs.get(), Type::float_from_ty(cx, t))\n         }\n         ast::LitFloatUnsuffixed(ref fs) => {\n-            let lit_float_ty = ty::node_id_to_type(cx.tcx, e.id);\n+            let lit_float_ty = ty::node_id_to_type(cx.tcx(), e.id);\n             match ty::get(lit_float_ty).sty {\n                 ty::ty_float(t) => {\n-                    C_floating(fs.get(), Type::float_from_ty(t))\n+                    C_floating(fs.get(), Type::float_from_ty(cx, t))\n                 }\n                 _ => {\n                     cx.sess().span_bug(lit.span,\n                         \"floating point literal doesn't have the right type\");\n                 }\n             }\n         }\n-        ast::LitBool(b) => C_bool(b),\n-        ast::LitNil => C_nil(),\n+        ast::LitBool(b) => C_bool(cx, b),\n+        ast::LitNil => C_nil(cx),\n         ast::LitStr(ref s, _) => C_str_slice(cx, (*s).clone()),\n         ast::LitBinary(ref data) => C_binary_slice(cx, data.deref().as_slice()),\n     }\n@@ -91,13 +91,13 @@ pub fn const_ptrcast(cx: &CrateContext, a: ValueRef, t: Type) -> ValueRef {\n \n fn const_vec(cx: &CrateContext, e: &ast::Expr,\n              es: &[@ast::Expr], is_local: bool) -> (ValueRef, Type, bool) {\n-    let vec_ty = ty::expr_ty(cx.tcx, e);\n-    let unit_ty = ty::sequence_element_type(cx.tcx, vec_ty);\n+    let vec_ty = ty::expr_ty(cx.tcx(), e);\n+    let unit_ty = ty::sequence_element_type(cx.tcx(), vec_ty);\n     let llunitty = type_of::type_of(cx, unit_ty);\n     let (vs, inlineable) = vec::unzip(es.iter().map(|e| const_expr(cx, *e, is_local)));\n     // If the vector contains enums, an LLVM array won't work.\n     let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n-        C_struct(vs, false)\n+        C_struct(cx, vs, false)\n     } else {\n         C_array(llunitty, vs)\n     };\n@@ -148,14 +148,14 @@ fn const_deref(cx: &CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n                 }\n                 _ => {\n                     cx.sess().bug(format!(\"unexpected dereferenceable type {}\",\n-                                          ty_to_str(cx.tcx, t)))\n+                                          ty_to_str(cx.tcx(), t)))\n                 }\n             };\n             (dv, mt.ty)\n         }\n         None => {\n             cx.sess().bug(format!(\"can't dereference const of type {}\",\n-                                  ty_to_str(cx.tcx, t)))\n+                                  ty_to_str(cx.tcx(), t)))\n         }\n     }\n }\n@@ -189,8 +189,8 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n     let (llconst, inlineable) = const_expr_unadjusted(cx, e, is_local);\n     let mut llconst = llconst;\n     let mut inlineable = inlineable;\n-    let ety = ty::expr_ty(cx.tcx, e);\n-    let ety_adjusted = ty::expr_ty_adjusted(cx.tcx, e,\n+    let ety = ty::expr_ty(cx.tcx(), e);\n+    let ety_adjusted = ty::expr_ty_adjusted(cx.tcx(), e,\n                                             cx.maps.method_map.borrow().get());\n     let adjustment = {\n         let adjustments = cx.tcx.adjustments.borrow();\n@@ -201,13 +201,13 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n         Some(adj) => {\n             match *adj {\n                 ty::AutoAddEnv(ty::ReStatic, ast::BorrowedSigil) => {\n-                    let def = ty::resolve_expr(cx.tcx, e);\n+                    let def = ty::resolve_expr(cx.tcx(), e);\n                     let wrapper = closure::get_wrapper_for_bare_fn(cx,\n                                                                    ety_adjusted,\n                                                                    def,\n                                                                    llconst,\n                                                                    is_local);\n-                    llconst = C_struct([wrapper, C_null(Type::i8p())], false)\n+                    llconst = C_struct(cx, [wrapper, C_null(Type::i8p(cx))], false)\n                 }\n                 ty::AutoAddEnv(ref r, ref s) => {\n                     cx.sess()\n@@ -255,9 +255,8 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n                                     assert_eq!(abi::slice_elt_base, 0);\n                                     assert_eq!(abi::slice_elt_len, 1);\n                                     match ty::get(ty).sty {\n-                                        ty::ty_vec(_,\n-                                                   ty::vstore_fixed(len)) => {\n-                                            llconst = C_struct([\n+                                        ty::ty_vec(_, ty::vstore_fixed(len)) => {\n+                                            llconst = C_struct(cx, [\n                                                 llptr,\n                                                 C_uint(cx, len)\n                                             ], false);\n@@ -290,7 +289,7 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n             llvm::LLVMDumpValue(C_undef(llty));\n         }\n         cx.sess().bug(format!(\"const {} of type {} has size {} instead of {}\",\n-                         e.repr(cx.tcx), ty_to_str(cx.tcx, ety),\n+                         e.repr(cx.tcx()), ty_to_str(cx.tcx(), ety),\n                          csize, tsize));\n     }\n     (llconst, inlineable)\n@@ -321,7 +320,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n \n             /* Neither type is bottom, and we expect them to be unified\n              * already, so the following is safe. */\n-            let ty = ty::expr_ty(cx.tcx, e1);\n+            let ty = ty::expr_ty(cx.tcx(), e1);\n             let is_float = ty::type_is_fp(ty);\n             let signed = ty::type_is_signed(ty);\n             return (match b {\n@@ -397,7 +396,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n           },\n           ast::ExprUnary(u, e) => {\n             let (te, _) = const_expr(cx, e, is_local);\n-            let ty = ty::expr_ty(cx.tcx, e);\n+            let ty = ty::expr_ty(cx.tcx(), e);\n             let is_float = ty::type_is_fp(ty);\n             return (match u {\n               ast::UnBox | ast::UnUniq | ast::UnDeref => {\n@@ -409,9 +408,9 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                     ty::ty_bool => {\n                         // Somewhat questionable, but I believe this is\n                         // correct.\n-                        let te = llvm::LLVMConstTrunc(te, Type::i1().to_ref());\n+                        let te = llvm::LLVMConstTrunc(te, Type::i1(cx).to_ref());\n                         let te = llvm::LLVMConstNot(te);\n-                        llvm::LLVMConstZExt(te, Type::bool().to_ref())\n+                        llvm::LLVMConstZExt(te, Type::bool(cx).to_ref())\n                     }\n                     _ => llvm::LLVMConstNot(te),\n                 }\n@@ -423,21 +422,21 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n             }, true)\n           }\n           ast::ExprField(base, field, _) => {\n-              let bt = ty::expr_ty_adjusted(cx.tcx, base,\n+              let bt = ty::expr_ty_adjusted(cx.tcx(), base,\n                                             cx.maps.method_map.borrow().get());\n               let brepr = adt::represent_type(cx, bt);\n               let (bv, inlineable) = const_expr(cx, base, is_local);\n-              expr::with_field_tys(cx.tcx, bt, None, |discr, field_tys| {\n-                  let ix = ty::field_idx_strict(cx.tcx, field.name, field_tys);\n+              expr::with_field_tys(cx.tcx(), bt, None, |discr, field_tys| {\n+                  let ix = ty::field_idx_strict(cx.tcx(), field.name, field_tys);\n                   (adt::const_get_field(cx, brepr, bv, discr, ix), inlineable)\n               })\n           }\n \n           ast::ExprIndex(base, index) => {\n-              let bt = ty::expr_ty_adjusted(cx.tcx, base,\n+              let bt = ty::expr_ty_adjusted(cx.tcx(), base,\n                                             cx.maps.method_map.borrow().get());\n               let (bv, inlineable) = const_expr(cx, base, is_local);\n-              let iv = match const_eval::eval_const_expr(cx.tcx, index) {\n+              let iv = match const_eval::eval_const_expr(cx.tcx(), index) {\n                   const_eval::const_int(i) => i as u64,\n                   const_eval::const_uint(u) => u,\n                   _ => cx.sess().span_bug(index.span,\n@@ -474,9 +473,9 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n               (const_get_elt(cx, arr, [iv as c_uint]), inlineable)\n           }\n           ast::ExprCast(base, _) => {\n-            let ety = ty::expr_ty(cx.tcx, e);\n+            let ety = ty::expr_ty(cx.tcx(), e);\n             let llty = type_of::type_of(cx, ety);\n-            let basety = ty::expr_ty(cx.tcx, base);\n+            let basety = ty::expr_ty(cx.tcx(), base);\n             let (v, inlineable) = const_expr(cx, base, is_local);\n             return (match (expr::cast_type_kind(basety),\n                            expr::cast_type_kind(ety)) {\n@@ -532,15 +531,15 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n               (const_addr_of(cx, e), false)\n           }\n           ast::ExprTup(ref es) => {\n-              let ety = ty::expr_ty(cx.tcx, e);\n+              let ety = ty::expr_ty(cx.tcx(), e);\n               let repr = adt::represent_type(cx, ety);\n               let (vals, inlineable) = map_list(es.as_slice());\n               (adt::trans_const(cx, repr, 0, vals.as_slice()), inlineable)\n           }\n           ast::ExprStruct(_, ref fs, ref base_opt) => {\n-              let ety = ty::expr_ty(cx.tcx, e);\n+              let ety = ty::expr_ty(cx.tcx(), e);\n               let repr = adt::represent_type(cx, ety);\n-              let tcx = cx.tcx;\n+              let tcx = cx.tcx();\n \n               let base_val = match *base_opt {\n                 Some(base) => Some(const_expr(cx, base, is_local)),\n@@ -596,23 +595,23 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                 llvm::LLVMSetGlobalConstant(gv, True);\n                 SetLinkage(gv, PrivateLinkage);\n                 let p = const_ptrcast(cx, gv, llunitty);\n-                (C_struct([p, C_uint(cx, es.len())], false), false)\n+                (C_struct(cx, [p, C_uint(cx, es.len())], false), false)\n               }\n               _ => cx.sess().span_bug(e.span, \"bad const-slice expr\")\n             }\n           }\n           ast::ExprRepeat(elem, count, _) => {\n-            let vec_ty = ty::expr_ty(cx.tcx, e);\n-            let unit_ty = ty::sequence_element_type(cx.tcx, vec_ty);\n+            let vec_ty = ty::expr_ty(cx.tcx(), e);\n+            let unit_ty = ty::sequence_element_type(cx.tcx(), vec_ty);\n             let llunitty = type_of::type_of(cx, unit_ty);\n-            let n = match const_eval::eval_const_expr(cx.tcx, count) {\n+            let n = match const_eval::eval_const_expr(cx.tcx(), count) {\n                 const_eval::const_int(i)  => i as uint,\n                 const_eval::const_uint(i) => i as uint,\n                 _ => cx.sess().span_bug(count.span, \"count must be integral const expression.\")\n             };\n             let vs = vec::from_elem(n, const_expr(cx, elem, is_local).val0());\n             let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n-                C_struct(vs, false)\n+                C_struct(cx, vs, false)\n             } else {\n                 C_array(llunitty, vs)\n             };\n@@ -622,15 +621,15 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n             // Assert that there are no type parameters in this path.\n             assert!(pth.segments.iter().all(|seg| seg.types.is_empty()));\n \n-            let tcx = cx.tcx;\n+            let tcx = cx.tcx();\n             let opt_def = {\n                 let def_map = tcx.def_map.borrow();\n                 def_map.get().find_copy(&e.id)\n             };\n             match opt_def {\n                 Some(ast::DefFn(def_id, _purity)) => {\n                     if !ast_util::is_local(def_id) {\n-                        let ty = csearch::get_type(cx.tcx, def_id).ty;\n+                        let ty = csearch::get_type(cx.tcx(), def_id).ty;\n                         (base::trans_external_path(cx, def_id, ty), true)\n                     } else {\n                         assert!(ast_util::is_local(def_id));\n@@ -641,15 +640,15 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                     get_const_val(cx, def_id)\n                 }\n                 Some(ast::DefVariant(enum_did, variant_did, _)) => {\n-                    let ety = ty::expr_ty(cx.tcx, e);\n+                    let ety = ty::expr_ty(cx.tcx(), e);\n                     let repr = adt::represent_type(cx, ety);\n-                    let vinfo = ty::enum_variant_with_id(cx.tcx,\n+                    let vinfo = ty::enum_variant_with_id(cx.tcx(),\n                                                          enum_did,\n                                                          variant_did);\n                     (adt::trans_const(cx, repr, vinfo.disr_val, []), true)\n                 }\n                 Some(ast::DefStruct(_)) => {\n-                    let ety = ty::expr_ty(cx.tcx, e);\n+                    let ety = ty::expr_ty(cx.tcx(), e);\n                     let llty = type_of::type_of(cx, ety);\n                     (C_null(llty), true)\n                 }\n@@ -659,23 +658,23 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n             }\n           }\n           ast::ExprCall(callee, ref args) => {\n-              let tcx = cx.tcx;\n+              let tcx = cx.tcx();\n               let opt_def = {\n                   let def_map = tcx.def_map.borrow();\n                   def_map.get().find_copy(&callee.id)\n               };\n               match opt_def {\n                   Some(ast::DefStruct(_)) => {\n-                      let ety = ty::expr_ty(cx.tcx, e);\n+                      let ety = ty::expr_ty(cx.tcx(), e);\n                       let repr = adt::represent_type(cx, ety);\n                       let (arg_vals, inlineable) = map_list(args.as_slice());\n                       (adt::trans_const(cx, repr, 0, arg_vals.as_slice()),\n                        inlineable)\n                   }\n                   Some(ast::DefVariant(enum_did, variant_did, _)) => {\n-                      let ety = ty::expr_ty(cx.tcx, e);\n+                      let ety = ty::expr_ty(cx.tcx(), e);\n                       let repr = adt::represent_type(cx, ety);\n-                      let vinfo = ty::enum_variant_with_id(cx.tcx,\n+                      let vinfo = ty::enum_variant_with_id(cx.tcx(),\n                                                            enum_did,\n                                                            variant_did);\n                       let (arg_vals, inlineable) = map_list(args.as_slice());"}, {"sha": "b9c7cb93e12f64b95ac905ba262096aabef4b19a", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 88, "deletions": 107, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -31,14 +31,14 @@ use util::nodemap::{NodeMap, NodeSet, DefIdMap};\n \n use std::cell::{Cell, RefCell};\n use std::c_str::ToCStr;\n-use std::local_data;\n use std::libc::c_uint;\n+use std::ptr;\n use std::vec_ng::Vec;\n use collections::{HashMap, HashSet};\n use syntax::ast;\n use syntax::parse::token::InternedString;\n \n-pub struct CrateContext<'a> {\n+pub struct CrateContext {\n     llmod: ModuleRef,\n     llcx: ContextRef,\n     metadata_llmod: ModuleRef,\n@@ -48,7 +48,7 @@ pub struct CrateContext<'a> {\n     intrinsics: HashMap<&'static str, ValueRef>,\n     item_vals: RefCell<NodeMap<ValueRef>>,\n     exp_map2: resolve::ExportMap2,\n-    reachable: &'a NodeSet,\n+    reachable: NodeSet,\n     item_symbols: RefCell<NodeMap<~str>>,\n     link_meta: LinkMeta,\n     drop_glues: RefCell<HashMap<ty::t, ValueRef>>,\n@@ -100,10 +100,9 @@ pub struct CrateContext<'a> {\n     symbol_hasher: RefCell<Sha256>,\n     type_hashcodes: RefCell<HashMap<ty::t, ~str>>,\n     all_llvm_symbols: RefCell<HashSet<~str>>,\n-    tcx: &'a ty::ctxt,\n+    tcx: ty::ctxt,\n     maps: astencode::Maps,\n     stats: @Stats,\n-    tydesc_type: Type,\n     int_type: Type,\n     opaque_vec_type: Type,\n     builder: BuilderRef_res,\n@@ -116,18 +115,17 @@ pub struct CrateContext<'a> {\n     dbg_cx: Option<debuginfo::CrateDebugContext>,\n }\n \n-impl<'a> CrateContext<'a> {\n+impl CrateContext {\n     pub fn new(name: &str,\n-               tcx: &'a ty::ctxt,\n+               tcx: ty::ctxt,\n                emap2: resolve::ExportMap2,\n                maps: astencode::Maps,\n                symbol_hasher: Sha256,\n                link_meta: LinkMeta,\n-               reachable: &'a NodeSet)\n-               -> CrateContext<'a> {\n+               reachable: NodeSet)\n+               -> CrateContext {\n         unsafe {\n             let llcx = llvm::LLVMContextCreate();\n-            set_task_llcx(llcx);\n             let llmod = name.with_c_str(|buf| {\n                 llvm::LLVMModuleCreateWithNameInContext(buf, llcx)\n             });\n@@ -144,97 +142,98 @@ impl<'a> CrateContext<'a> {\n                 llvm::LLVMRustSetNormalizedTarget(llmod, buf);\n                 llvm::LLVMRustSetNormalizedTarget(metadata_llmod, buf);\n             });\n-            let targ_cfg = tcx.sess.targ_cfg;\n \n             let td = mk_target_data(tcx.sess.targ_cfg.target_strs.data_layout);\n-            let tn = TypeNames::new();\n \n-            let mut intrinsics = base::declare_intrinsics(llmod);\n-            if tcx.sess.opts.debuginfo != NoDebugInfo {\n-                base::declare_dbg_intrinsics(llmod, &mut intrinsics);\n-            }\n-            let int_type = Type::int(targ_cfg.arch);\n-            let tydesc_type = Type::tydesc(targ_cfg.arch);\n-            let opaque_vec_type = Type::opaque_vec(targ_cfg.arch);\n-\n-            let mut str_slice_ty = Type::named_struct(\"str_slice\");\n-            str_slice_ty.set_struct_body([Type::i8p(), int_type], false);\n-\n-            tn.associate_type(\"tydesc\", &tydesc_type);\n-            tn.associate_type(\"str_slice\", &str_slice_ty);\n-\n-            let (crate_map_name, crate_map) = decl_crate_map(&tcx.sess, link_meta.clone(), llmod);\n             let dbg_cx = if tcx.sess.opts.debuginfo != NoDebugInfo {\n                 Some(debuginfo::CrateDebugContext::new(llmod))\n             } else {\n                 None\n             };\n \n-            if tcx.sess.count_llvm_insns() {\n+            let mut ccx = CrateContext {\n+                llmod: llmod,\n+                llcx: llcx,\n+                metadata_llmod: metadata_llmod,\n+                td: td,\n+                tn: TypeNames::new(),\n+                externs: RefCell::new(HashMap::new()),\n+                intrinsics: HashMap::new(),\n+                item_vals: RefCell::new(NodeMap::new()),\n+                exp_map2: emap2,\n+                reachable: reachable,\n+                item_symbols: RefCell::new(NodeMap::new()),\n+                link_meta: link_meta,\n+                drop_glues: RefCell::new(HashMap::new()),\n+                tydescs: RefCell::new(HashMap::new()),\n+                finished_tydescs: Cell::new(false),\n+                external: RefCell::new(DefIdMap::new()),\n+                external_srcs: RefCell::new(NodeMap::new()),\n+                non_inlineable_statics: RefCell::new(NodeSet::new()),\n+                monomorphized: RefCell::new(HashMap::new()),\n+                monomorphizing: RefCell::new(DefIdMap::new()),\n+                vtables: RefCell::new(HashMap::new()),\n+                const_cstr_cache: RefCell::new(HashMap::new()),\n+                const_globals: RefCell::new(HashMap::new()),\n+                const_values: RefCell::new(NodeMap::new()),\n+                extern_const_values: RefCell::new(DefIdMap::new()),\n+                impl_method_cache: RefCell::new(HashMap::new()),\n+                closure_bare_wrapper_cache: RefCell::new(HashMap::new()),\n+                lltypes: RefCell::new(HashMap::new()),\n+                llsizingtypes: RefCell::new(HashMap::new()),\n+                adt_reprs: RefCell::new(HashMap::new()),\n+                symbol_hasher: RefCell::new(symbol_hasher),\n+                type_hashcodes: RefCell::new(HashMap::new()),\n+                all_llvm_symbols: RefCell::new(HashSet::new()),\n+                tcx: tcx,\n+                maps: maps,\n+                stats: @Stats {\n+                    n_static_tydescs: Cell::new(0u),\n+                    n_glues_created: Cell::new(0u),\n+                    n_null_glues: Cell::new(0u),\n+                    n_real_glues: Cell::new(0u),\n+                    n_fns: Cell::new(0u),\n+                    n_monos: Cell::new(0u),\n+                    n_inlines: Cell::new(0u),\n+                    n_closures: Cell::new(0u),\n+                    n_llvm_insns: Cell::new(0u),\n+                    llvm_insns: RefCell::new(HashMap::new()),\n+                    fn_stats: RefCell::new(Vec::new()),\n+                },\n+                int_type: Type::from_ref(ptr::null()),\n+                opaque_vec_type: Type::from_ref(ptr::null()),\n+                builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n+                crate_map: ptr::null(),\n+                crate_map_name: ~\"\",\n+                uses_gc: false,\n+                dbg_cx: dbg_cx,\n+            };\n+\n+            ccx.int_type = Type::int(&ccx);\n+            ccx.opaque_vec_type = Type::opaque_vec(&ccx);\n+\n+            ccx.tn.associate_type(\"tydesc\", &Type::tydesc(&ccx));\n+\n+            let mut str_slice_ty = Type::named_struct(&ccx, \"str_slice\");\n+            str_slice_ty.set_struct_body([Type::i8p(&ccx), ccx.int_type], false);\n+            ccx.tn.associate_type(\"str_slice\", &str_slice_ty);\n+\n+            decl_crate_map(&mut ccx);\n+\n+            base::declare_intrinsics(&mut ccx);\n+\n+            if ccx.sess().count_llvm_insns() {\n                 base::init_insn_ctxt()\n             }\n \n-            CrateContext {\n-                 llmod: llmod,\n-                 llcx: llcx,\n-                 metadata_llmod: metadata_llmod,\n-                 td: td,\n-                 tn: tn,\n-                 externs: RefCell::new(HashMap::new()),\n-                 intrinsics: intrinsics,\n-                 item_vals: RefCell::new(NodeMap::new()),\n-                 exp_map2: emap2,\n-                 reachable: reachable,\n-                 item_symbols: RefCell::new(NodeMap::new()),\n-                 link_meta: link_meta,\n-                 drop_glues: RefCell::new(HashMap::new()),\n-                 tydescs: RefCell::new(HashMap::new()),\n-                 finished_tydescs: Cell::new(false),\n-                 external: RefCell::new(DefIdMap::new()),\n-                 external_srcs: RefCell::new(NodeMap::new()),\n-                 non_inlineable_statics: RefCell::new(NodeSet::new()),\n-                 monomorphized: RefCell::new(HashMap::new()),\n-                 monomorphizing: RefCell::new(DefIdMap::new()),\n-                 vtables: RefCell::new(HashMap::new()),\n-                 const_cstr_cache: RefCell::new(HashMap::new()),\n-                 const_globals: RefCell::new(HashMap::new()),\n-                 const_values: RefCell::new(NodeMap::new()),\n-                 extern_const_values: RefCell::new(DefIdMap::new()),\n-                 impl_method_cache: RefCell::new(HashMap::new()),\n-                 closure_bare_wrapper_cache: RefCell::new(HashMap::new()),\n-                 lltypes: RefCell::new(HashMap::new()),\n-                 llsizingtypes: RefCell::new(HashMap::new()),\n-                 adt_reprs: RefCell::new(HashMap::new()),\n-                 symbol_hasher: RefCell::new(symbol_hasher),\n-                 type_hashcodes: RefCell::new(HashMap::new()),\n-                 all_llvm_symbols: RefCell::new(HashSet::new()),\n-                 tcx: tcx,\n-                 maps: maps,\n-                 stats: @Stats {\n-                   n_static_tydescs: Cell::new(0u),\n-                   n_glues_created: Cell::new(0u),\n-                   n_null_glues: Cell::new(0u),\n-                   n_real_glues: Cell::new(0u),\n-                   n_fns: Cell::new(0u),\n-                   n_monos: Cell::new(0u),\n-                   n_inlines: Cell::new(0u),\n-                   n_closures: Cell::new(0u),\n-                   n_llvm_insns: Cell::new(0u),\n-                   llvm_insns: RefCell::new(HashMap::new()),\n-                   fn_stats: RefCell::new(Vec::new()),\n-                 },\n-                 tydesc_type: tydesc_type,\n-                 int_type: int_type,\n-                 opaque_vec_type: opaque_vec_type,\n-                 builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n-                 crate_map: crate_map,\n-                 crate_map_name: crate_map_name,\n-                 uses_gc: false,\n-                 dbg_cx: dbg_cx,\n-            }\n+            ccx\n         }\n     }\n \n+    pub fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+        &self.tcx\n+    }\n+\n     pub fn sess<'a>(&'a self) -> &'a Session {\n         &self.tcx.sess\n     }\n@@ -249,7 +248,7 @@ impl<'a> CrateContext<'a> {\n         debug!(\"const_inbounds_gepi: pointer={} indices={:?}\",\n                self.tn.val_to_str(pointer), indices);\n         let v: Vec<ValueRef> =\n-            indices.iter().map(|i| C_i32(*i as i32)).collect();\n+            indices.iter().map(|i| C_i32(self, *i as i32)).collect();\n         unsafe {\n             llvm::LLVMConstInBoundsGEP(pointer,\n                                        v.as_ptr(),\n@@ -272,26 +271,8 @@ impl<'a> CrateContext<'a> {\n                                     self.int_type.to_ref())\n         }\n     }\n-}\n \n-#[unsafe_destructor]\n-impl<'a> Drop for CrateContext<'a> {\n-    fn drop(&mut self) {\n-        unset_task_llcx();\n+    pub fn tydesc_type(&self) -> Type {\n+        self.tn.find_type(\"tydesc\").unwrap()\n     }\n }\n-\n-local_data_key!(task_local_llcx_key: @ContextRef)\n-\n-pub fn task_llcx() -> ContextRef {\n-    let opt = local_data::get(task_local_llcx_key, |k| k.map(|k| *k));\n-    *opt.expect(\"task-local LLVMContextRef wasn't ever set!\")\n-}\n-\n-fn set_task_llcx(c: ContextRef) {\n-    local_data::set(task_local_llcx_key, @c);\n-}\n-\n-fn unset_task_llcx() {\n-    local_data::pop(task_local_llcx_key);\n-}"}, {"sha": "43e1e219e6fe710c626f9a69a38e30d6874bda4d", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -339,8 +339,8 @@ pub fn trans_fail<'a>(\n     let v_filename = C_cstr(bcx.ccx(),\n                             token::intern_and_get_ident(loc.file.name));\n     let v_line = loc.line as int;\n-    let v_str = PointerCast(bcx, v_fail_str, Type::i8p());\n-    let v_filename = PointerCast(bcx, v_filename, Type::i8p());\n+    let v_str = PointerCast(bcx, v_fail_str, Type::i8p(ccx));\n+    let v_filename = PointerCast(bcx, v_filename, Type::i8p(ccx));\n     let args = vec!(v_str, v_filename, C_int(ccx, v_line));\n     let did = langcall(bcx, Some(sp), \"\", FailFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,"}, {"sha": "c334971db5934ab44d99ea00d20cee1d0da9d4d0", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -635,7 +635,7 @@ impl<K:KindOps> Datum<K> {\n     pub fn to_str(&self, ccx: &CrateContext) -> ~str {\n         format!(\"Datum({}, {}, {:?})\",\n              ccx.tn.val_to_str(self.val),\n-             ty_to_str(ccx.tcx, self.ty),\n+             ty_to_str(ccx.tcx(), self.ty),\n              self.kind)\n     }\n \n@@ -709,7 +709,7 @@ impl<'a> DatumBlock<'a, Expr> {\n         self.datum.shallow_copy(self.bcx, dst)\n     }\n \n-    pub fn ccx(&self) -> &'a CrateContext<'a> {\n+    pub fn ccx(&self) -> &'a CrateContext {\n         self.bcx.ccx()\n     }\n "}, {"sha": "630512c8f69e9e65ab281c090bee1783d2b3be43", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 40, "deletions": 37, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -369,10 +369,10 @@ pub fn create_captured_var_metadata(bcx: &Block,\n     let byte_offset_of_var_in_env = machine::llelement_offset(cx, llvm_env_data_type, env_index);\n \n     let address_operations = unsafe {\n-        [llvm::LLVMDIBuilderCreateOpDeref(Type::i64().to_ref()),\n-         llvm::LLVMDIBuilderCreateOpPlus(Type::i64().to_ref()),\n-         C_i64(byte_offset_of_var_in_env as i64),\n-         llvm::LLVMDIBuilderCreateOpDeref(Type::i64().to_ref())]\n+        [llvm::LLVMDIBuilderCreateOpDeref(Type::i64(cx).to_ref()),\n+         llvm::LLVMDIBuilderCreateOpPlus(Type::i64(cx).to_ref()),\n+         C_i64(cx, byte_offset_of_var_in_env as i64),\n+         llvm::LLVMDIBuilderCreateOpDeref(Type::i64(cx).to_ref())]\n     };\n \n     let address_op_count = match closure_sigil {\n@@ -719,11 +719,11 @@ pub fn create_function_debug_context(cx: &CrateContext,\n             _ => {\n                 assert_type_for_node_id(cx, fn_ast_id, error_span);\n \n-                let return_type = ty::node_id_to_type(cx.tcx, fn_ast_id);\n+                let return_type = ty::node_id_to_type(cx.tcx(), fn_ast_id);\n                 let return_type = match param_substs {\n                     None => return_type,\n                     Some(substs) => {\n-                        ty::subst_tps(cx.tcx,\n+                        ty::subst_tps(cx.tcx(),\n                                       substs.tys.as_slice(),\n                                       substs.self_ty,\n                                       return_type)\n@@ -737,11 +737,11 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         // Arguments types\n         for arg in fn_decl.inputs.iter() {\n             assert_type_for_node_id(cx, arg.pat.id, arg.pat.span);\n-            let arg_type = ty::node_id_to_type(cx.tcx, arg.pat.id);\n+            let arg_type = ty::node_id_to_type(cx.tcx(), arg.pat.id);\n             let arg_type = match param_substs {\n                 None => arg_type,\n                 Some(substs) => {\n-                    ty::subst_tps(cx.tcx,\n+                    ty::subst_tps(cx.tcx(),\n                                   substs.tys.as_slice(),\n                                   substs.self_ty,\n                                   arg_type)\n@@ -782,7 +782,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         if has_self_type {\n             let actual_self_type = self_type.unwrap();\n             // Add self type name to <...> clause of function name\n-            let actual_self_type_name = ppaux::ty_to_str(cx.tcx, actual_self_type);\n+            let actual_self_type_name = ppaux::ty_to_str(cx.tcx(), actual_self_type);\n             name_to_append_suffix_to.push_str(actual_self_type_name);\n \n             if generics.is_type_parameterized() {\n@@ -826,7 +826,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         for (index, &ast::TyParam{ ident: ident, .. }) in generics.ty_params.iter().enumerate() {\n             let actual_type = *actual_types.get(index);\n             // Add actual type name to <...> clause of function name\n-            let actual_type_name = ppaux::ty_to_str(cx.tcx, actual_type);\n+            let actual_type_name = ppaux::ty_to_str(cx.tcx(), actual_type);\n             name_to_append_suffix_to.push_str(actual_type_name);\n \n             if index != generics.ty_params.len() - 1 {\n@@ -1118,7 +1118,7 @@ fn pointer_type_metadata(cx: &CrateContext,\n                       -> DIType {\n     let pointer_llvm_type = type_of::type_of(cx, pointer_type);\n     let (pointer_size, pointer_align) = size_and_align_of(cx, pointer_llvm_type);\n-    let name = ppaux::ty_to_str(cx.tcx, pointer_type);\n+    let name = ppaux::ty_to_str(cx.tcx(), pointer_type);\n     let ptr_metadata = name.with_c_str(|name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreatePointerType(\n@@ -1190,7 +1190,7 @@ fn prepare_struct_metadata(cx: &CrateContext,\n                            substs: &ty::substs,\n                            span: Span)\n                         -> RecursiveTypeDescription {\n-    let struct_name = ppaux::ty_to_str(cx.tcx, struct_type);\n+    let struct_name = ppaux::ty_to_str(cx.tcx(), struct_type);\n     let struct_llvm_type = type_of::type_of(cx, struct_type);\n \n     let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, def_id);\n@@ -1205,7 +1205,7 @@ fn prepare_struct_metadata(cx: &CrateContext,\n                                                   file_metadata,\n                                                   definition_span);\n \n-    let fields = ty::struct_fields(cx.tcx, def_id, substs);\n+    let fields = ty::struct_fields(cx.tcx(), def_id, substs);\n \n     UnfinishedMetadata {\n         cache_id: cache_id_for_type(struct_type),\n@@ -1288,7 +1288,7 @@ fn prepare_tuple_metadata(cx: &CrateContext,\n                           component_types: &[ty::t],\n                           span: Span)\n                        -> RecursiveTypeDescription {\n-    let tuple_name = ppaux::ty_to_str(cx.tcx, tuple_type);\n+    let tuple_name = ppaux::ty_to_str(cx.tcx(), tuple_type);\n     let tuple_llvm_type = type_of::type_of(cx, tuple_type);\n \n     let loc = span_start(cx, span);\n@@ -1393,9 +1393,9 @@ fn describe_enum_variant(cx: &CrateContext,\n                          span: Span)\n                       -> (DICompositeType, Type, MemberDescriptionFactory) {\n     let variant_llvm_type =\n-        Type::struct_(struct_def.fields\n-                                .map(|&t| type_of::type_of(cx, t))\n-                                .as_slice(),\n+        Type::struct_(cx, struct_def.fields\n+                                    .map(|&t| type_of::type_of(cx, t))\n+                                    .as_slice(),\n                       struct_def.packed);\n     // Could some consistency checks here: size, align, field count, discr type\n \n@@ -1448,17 +1448,17 @@ fn prepare_enum_metadata(cx: &CrateContext,\n                          enum_def_id: ast::DefId,\n                          span: Span)\n                       -> RecursiveTypeDescription {\n-    let enum_name = ppaux::ty_to_str(cx.tcx, enum_type);\n+    let enum_name = ppaux::ty_to_str(cx.tcx(), enum_type);\n \n     let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, enum_def_id);\n     let loc = span_start(cx, definition_span);\n     let file_metadata = file_metadata(cx, loc.file.name);\n \n     // For empty enums there is an early exit. Just describe it as an empty struct with the\n     // appropriate type name\n-    if ty::type_is_empty(cx.tcx, enum_type) {\n+    if ty::type_is_empty(cx.tcx(), enum_type) {\n         let empty_type_metadata = composite_type_metadata(cx,\n-                                                          Type::nil(),\n+                                                          Type::nil(cx),\n                                                           enum_name,\n                                                           [],\n                                                           containing_scope,\n@@ -1468,7 +1468,7 @@ fn prepare_enum_metadata(cx: &CrateContext,\n         return FinalMetadata(empty_type_metadata);\n     }\n \n-    let variants = ty::enum_variants(cx.tcx, enum_def_id);\n+    let variants = ty::enum_variants(cx.tcx(), enum_def_id);\n \n     let enumerators_metadata: Vec<DIDescriptor> = variants\n         .iter()\n@@ -1754,7 +1754,7 @@ fn boxed_type_metadata(cx: &CrateContext,\n                                   content_llvm_type));\n \n     let int_type = ty::mk_int();\n-    let nil_pointer_type = ty::mk_nil_ptr(cx.tcx);\n+    let nil_pointer_type = ty::mk_nil_ptr(cx.tcx());\n     let nil_pointer_type_metadata = type_metadata(cx, nil_pointer_type, codemap::DUMMY_SP);\n \n     let member_descriptions = [\n@@ -1811,8 +1811,8 @@ fn boxed_type_metadata(cx: &CrateContext,\n         member_llvm_types.len() == 5 &&\n         member_llvm_types[0] == cx.int_type &&\n         member_llvm_types[1] == Type::generic_glue_fn(cx).ptr_to() &&\n-        member_llvm_types[2] == Type::i8().ptr_to() &&\n-        member_llvm_types[3] == Type::i8().ptr_to() &&\n+        member_llvm_types[2] == Type::i8(cx).ptr_to() &&\n+        member_llvm_types[3] == Type::i8(cx).ptr_to() &&\n         member_llvm_types[4] == content_llvm_type\n     }\n }\n@@ -1853,8 +1853,8 @@ fn vec_metadata(cx: &CrateContext,\n     let element_llvm_type = type_of::type_of(cx, element_type);\n     let (element_size, element_align) = size_and_align_of(cx, element_llvm_type);\n \n-    let vec_llvm_type = Type::vec(cx.sess().targ_cfg.arch, &element_llvm_type);\n-    let vec_type_name: &str = format!(\"[{}]\", ppaux::ty_to_str(cx.tcx, element_type));\n+    let vec_llvm_type = Type::vec(cx, &element_llvm_type);\n+    let vec_type_name: &str = format!(\"[{}]\", ppaux::ty_to_str(cx.tcx(), element_type));\n \n     let member_llvm_types = vec_llvm_type.field_types();\n \n@@ -1913,14 +1913,17 @@ fn vec_slice_metadata(cx: &CrateContext,\n     debug!(\"vec_slice_metadata: {:?}\", ty::get(vec_type));\n \n     let slice_llvm_type = type_of::type_of(cx, vec_type);\n-    let slice_type_name = ppaux::ty_to_str(cx.tcx, vec_type);\n+    let slice_type_name = ppaux::ty_to_str(cx.tcx(), vec_type);\n \n     let member_llvm_types = slice_llvm_type.field_types();\n     assert!(slice_layout_is_correct(cx,\n                                     member_llvm_types.as_slice(),\n                                     element_type));\n \n-    let data_ptr_type = ty::mk_ptr(cx.tcx, ty::mt { ty: element_type, mutbl: ast::MutImmutable });\n+    let data_ptr_type = ty::mk_ptr(cx.tcx(), ty::mt {\n+        ty: element_type,\n+        mutbl: ast::MutImmutable\n+    });\n \n     let member_descriptions = [\n         MemberDescription {\n@@ -2001,13 +2004,13 @@ fn trait_metadata(cx: &CrateContext,\n     // The implementation provided here is a stub. It makes sure that the trait type is\n     // assigned the correct name, size, namespace, and source location. But it does not describe\n     // the trait's methods.\n-    let last = ty::with_path(cx.tcx, def_id, |mut path| path.last().unwrap());\n+    let last = ty::with_path(cx.tcx(), def_id, |mut path| path.last().unwrap());\n     let ident_string = token::get_name(last.name());\n-    let name = ppaux::trait_store_to_str(cx.tcx, trait_store) +\n+    let name = ppaux::trait_store_to_str(cx.tcx(), trait_store) +\n                ppaux::mutability_to_str(mutability) +\n                ident_string.get();\n     // Add type and region parameters\n-    let name = ppaux::parameterized(cx.tcx, name, &substs.regions,\n+    let name = ppaux::parameterized(cx.tcx(), name, &substs.regions,\n                                     substs.tps.as_slice(), def_id, true);\n \n     let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, def_id);\n@@ -2044,7 +2047,7 @@ fn type_metadata(cx: &CrateContext,\n                                       pointer_type: ty::t,\n                                       type_in_box: ty::t)\n                                    -> DIType {\n-        let content_type_name: &str = ppaux::ty_to_str(cx.tcx, type_in_box);\n+        let content_type_name: &str = ppaux::ty_to_str(cx.tcx(), type_in_box);\n         let content_llvm_type = type_of::type_of(cx, type_in_box);\n         let content_type_metadata = type_metadata(\n             cx,\n@@ -2127,9 +2130,9 @@ fn type_metadata(cx: &CrateContext,\n             trait_metadata(cx, def_id, t, substs, trait_store, mutability, bounds)\n         },\n         ty::ty_struct(def_id, ref substs) => {\n-            if ty::type_is_simd(cx.tcx, t) {\n-                let element_type = ty::simd_type(cx.tcx, t);\n-                let len = ty::simd_size(cx.tcx, t);\n+            if ty::type_is_simd(cx.tcx(), t) {\n+                let element_type = ty::simd_type(cx.tcx(), t);\n+                let len = ty::simd_size(cx.tcx(), t);\n                 fixed_vec_metadata(cx, element_type, len, usage_site_span)\n             } else {\n                 prepare_struct_metadata(cx, t, def_id, substs, usage_site_span).finalize(cx)\n@@ -2176,7 +2179,7 @@ fn set_debug_location(cx: &CrateContext, debug_location: DebugLocation) {\n         KnownLocation { scope, line, .. } => {\n             let col = 0; // Always set the column to zero like Clang and GCC\n             debug!(\"setting debug location to {} {}\", line, col);\n-            let elements = [C_i32(line as i32), C_i32(col as i32), scope, ptr::null()];\n+            let elements = [C_i32(cx, line as i32), C_i32(cx, col as i32), scope, ptr::null()];\n             unsafe {\n                 metadata_node = llvm::LLVMMDNodeInContext(debug_context(cx).llcontext,\n                                                           elements.as_ptr(),\n@@ -2748,7 +2751,7 @@ impl NamespaceTreeNode {\n }\n \n fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> @NamespaceTreeNode {\n-    ty::with_path(cx.tcx, def_id, |path| {\n+    ty::with_path(cx.tcx(), def_id, |path| {\n         // prepend crate name if not already present\n         let krate = if def_id.krate == ast::LOCAL_CRATE {\n             let crate_namespace_ident = token::str_to_ident(cx.link_meta.crateid.name);"}, {"sha": "a38322ef0dcb94ce8c48e4f216db7cc59a9611f8", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -523,7 +523,7 @@ fn trans_index<'a>(bcx: &'a Block<'a>,\n \n     let bounds_check = ICmp(bcx, lib::llvm::IntUGE, ix_val, len);\n     let expect = ccx.intrinsics.get_copy(&(\"llvm.expect.i1\"));\n-    let expected = Call(bcx, expect, [bounds_check, C_i1(false)], []);\n+    let expected = Call(bcx, expect, [bounds_check, C_i1(ccx, false)], []);\n     let bcx = with_cond(bcx, expected, |bcx| {\n             controlflow::trans_fail_bounds_check(bcx, index_expr.span, ix_val, len)\n         });\n@@ -816,7 +816,6 @@ fn trans_def_dps_unadjusted<'a>(\n                             dest: Dest)\n                             -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_def_dps_unadjusted\");\n-    let ccx = bcx.ccx();\n \n     let lldest = match dest {\n         SaveIn(lldest) => lldest,\n@@ -825,7 +824,7 @@ fn trans_def_dps_unadjusted<'a>(\n \n     match def {\n         ast::DefVariant(tid, vid, _) => {\n-            let variant_info = ty::enum_variant_with_id(ccx.tcx, tid, vid);\n+            let variant_info = ty::enum_variant_with_id(bcx.tcx(), tid, vid);\n             if variant_info.args.len() > 0u {\n                 // N-ary variant.\n                 let llfn = callee::trans_fn_ref(bcx, vid, ExprId(ref_expr.id));\n@@ -834,7 +833,7 @@ fn trans_def_dps_unadjusted<'a>(\n             } else {\n                 // Nullary variant.\n                 let ty = expr_ty(bcx, ref_expr);\n-                let repr = adt::represent_type(ccx, ty);\n+                let repr = adt::represent_type(bcx.ccx(), ty);\n                 adt::trans_start_init(bcx, repr, lldest,\n                                       variant_info.disr_val);\n                 return bcx;\n@@ -843,8 +842,8 @@ fn trans_def_dps_unadjusted<'a>(\n         ast::DefStruct(_) => {\n             let ty = expr_ty(bcx, ref_expr);\n             match ty::get(ty).sty {\n-                ty::ty_struct(did, _) if ty::has_dtor(ccx.tcx, did) => {\n-                    let repr = adt::represent_type(ccx, ty);\n+                ty::ty_struct(did, _) if ty::has_dtor(bcx.tcx(), did) => {\n+                    let repr = adt::represent_type(bcx.ccx(), ty);\n                     adt::trans_start_init(bcx, repr, lldest, 0);\n                 }\n                 _ => {}\n@@ -1150,6 +1149,7 @@ fn trans_unary<'a>(bcx: &'a Block<'a>,\n                    op: ast::UnOp,\n                    sub_expr: &ast::Expr)\n                    -> DatumBlock<'a, Expr> {\n+    let ccx = bcx.ccx();\n     let mut bcx = bcx;\n     let _icx = push_ctxt(\"trans_unary_datum\");\n \n@@ -1160,7 +1160,7 @@ fn trans_unary<'a>(bcx: &'a Block<'a>,\n     // Otherwise, we should be in the RvalueDpsExpr path.\n     assert!(\n         op == ast::UnDeref ||\n-        !bcx.ccx().maps.method_map.borrow().get().contains_key(&method_call));\n+        !ccx.maps.method_map.borrow().get().contains_key(&method_call));\n \n     let un_ty = expr_ty(bcx, expr);\n \n@@ -1172,8 +1172,8 @@ fn trans_unary<'a>(bcx: &'a Block<'a>,\n                 let llcond = ICmp(bcx,\n                                   lib::llvm::IntEQ,\n                                   val,\n-                                  C_bool(false));\n-                Select(bcx, llcond, C_bool(true), C_bool(false))\n+                                  C_bool(ccx, false));\n+                Select(bcx, llcond, C_bool(ccx, true), C_bool(ccx, false))\n             } else {\n                 // Note: `Not` is bitwise, not suitable for logical not.\n                 Not(bcx, datum.to_llscalarish(bcx))\n@@ -1361,15 +1361,15 @@ fn trans_eager_binop<'a>(\n       }\n       ast::BiEq | ast::BiNe | ast::BiLt | ast::BiGe | ast::BiLe | ast::BiGt => {\n         if ty::type_is_bot(rhs_t) {\n-            C_bool(false)\n+            C_bool(bcx.ccx(), false)\n         } else {\n             if !ty::type_is_scalar(rhs_t) {\n                 bcx.tcx().sess.span_bug(binop_expr.span,\n                                         \"non-scalar comparison\");\n             }\n             let cmpr = base::compare_scalar_types(bcx, lhs, rhs, rhs_t, op);\n             bcx = cmpr.bcx;\n-            ZExt(bcx, cmpr.val, Type::i8())\n+            ZExt(bcx, cmpr.val, Type::i8(bcx.ccx()))\n         }\n       }\n       _ => {\n@@ -1421,8 +1421,8 @@ fn trans_lazy_binop<'a>(\n     }\n \n     Br(past_rhs, join.llbb);\n-    let phi = Phi(join, Type::bool(), [lhs, rhs], [past_lhs.llbb,\n-                                                   past_rhs.llbb]);\n+    let phi = Phi(join, Type::bool(bcx.ccx()), [lhs, rhs],\n+                  [past_lhs.llbb, past_rhs.llbb]);\n \n     return immediate_rvalue_bcx(join, phi, binop_ty).to_expr_datumblock();\n }\n@@ -1612,22 +1612,22 @@ fn trans_imm_cast<'a>(bcx: &'a Block<'a>,\n                 bcx, datum.to_lvalue_datum(bcx, \"trans_imm_cast\", expr.id));\n             let llexpr_ptr = datum.to_llref();\n             let lldiscrim_a =\n-                adt::trans_get_discr(bcx, repr, llexpr_ptr, Some(Type::i64()));\n+                adt::trans_get_discr(bcx, repr, llexpr_ptr, Some(Type::i64(ccx)));\n             match k_out {\n                 cast_integral => int_cast(bcx, ll_t_out,\n                                           val_ty(lldiscrim_a),\n                                           lldiscrim_a, true),\n                 cast_float => SIToFP(bcx, lldiscrim_a, ll_t_out),\n                 _ => ccx.sess().bug(format!(\"translating unsupported cast: \\\n                                             {} ({:?}) -> {} ({:?})\",\n-                                            t_in.repr(ccx.tcx), k_in,\n-                                            t_out.repr(ccx.tcx), k_out))\n+                                            t_in.repr(bcx.tcx()), k_in,\n+                                            t_out.repr(bcx.tcx()), k_out))\n             }\n         }\n         _ => ccx.sess().bug(format!(\"translating unsupported cast: \\\n                                     {} ({:?}) -> {} ({:?})\",\n-                                    t_in.repr(ccx.tcx), k_in,\n-                                    t_out.repr(ccx.tcx), k_out))\n+                                    t_in.repr(bcx.tcx()), k_in,\n+                                    t_out.repr(bcx.tcx()), k_out))\n     };\n     return immediate_rvalue_bcx(bcx, newval, t_out).to_expr_datumblock();\n }"}, {"sha": "fdc33666e8abb5b26a043d36464c65984bd4b915", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -134,7 +134,7 @@ pub fn llvm_linkage_by_name(name: &str) -> Option<Linkage> {\n \n pub fn register_static(ccx: &CrateContext,\n                        foreign_item: &ast::ForeignItem) -> ValueRef {\n-    let ty = ty::node_id_to_type(ccx.tcx, foreign_item.id);\n+    let ty = ty::node_id_to_type(ccx.tcx(), foreign_item.id);\n     let llty = type_of::type_of(ccx, ty);\n \n     // Treat the crate map static specially in order to\n@@ -215,7 +215,7 @@ pub fn register_foreign_item_fn(ccx: &CrateContext, abis: AbiSet,\n     debug!(\"register_foreign_item_fn(abis={}, \\\n             path={}, \\\n             foreign_item.id={})\",\n-           abis.repr(ccx.tcx),\n+           abis.repr(ccx.tcx()),\n            ccx.tcx.map.path_to_str(foreign_item.id),\n            foreign_item.id);\n \n@@ -225,7 +225,7 @@ pub fn register_foreign_item_fn(ccx: &CrateContext, abis: AbiSet,\n             ccx.sess().span_fatal(foreign_item.span,\n                 format!(\"ABI `{}` has no suitable calling convention \\\n                       for target architecture\",\n-                      abis.user_string(ccx.tcx)));\n+                      abis.user_string(ccx.tcx())));\n         }\n     };\n \n@@ -240,7 +240,7 @@ pub fn register_foreign_item_fn(ccx: &CrateContext, abis: AbiSet,\n     }\n \n     // Create the LLVM value for the C extern fn\n-    let llfn_ty = lltype_for_fn_from_foreign_types(&tys);\n+    let llfn_ty = lltype_for_fn_from_foreign_types(ccx, &tys);\n \n     let llfn;\n     {\n@@ -386,7 +386,7 @@ pub fn trans_native_call<'a>(\n             ccx.sess().fatal(\n                 format!(\"ABI string `{}` has no suitable ABI \\\n                         for target architecture\",\n-                        fn_abis.user_string(ccx.tcx)));\n+                        fn_abis.user_string(ccx.tcx())));\n         }\n     };\n \n@@ -440,8 +440,8 @@ pub fn trans_native_call<'a>(\n             //   bitcasting to the struct type yields invalid cast errors.\n             let llscratch = base::alloca(bcx, llforeign_ret_ty, \"__cast\");\n             Store(bcx, llforeign_retval, llscratch);\n-            let llscratch_i8 = BitCast(bcx, llscratch, Type::i8().ptr_to());\n-            let llretptr_i8 = BitCast(bcx, llretptr, Type::i8().ptr_to());\n+            let llscratch_i8 = BitCast(bcx, llscratch, Type::i8(ccx).ptr_to());\n+            let llretptr_i8 = BitCast(bcx, llretptr, Type::i8(ccx).ptr_to());\n             let llrust_size = machine::llsize_of_store(ccx, llrust_ret_ty);\n             let llforeign_align = machine::llalign_of_min(ccx, llforeign_ret_ty);\n             let llrust_align = machine::llalign_of_min(ccx, llrust_ret_ty);\n@@ -507,8 +507,8 @@ pub fn register_rust_fn_with_foreign_abi(ccx: &CrateContext,\n     let _icx = push_ctxt(\"foreign::register_foreign_fn\");\n \n     let tys = foreign_types_for_id(ccx, node_id);\n-    let llfn_ty = lltype_for_fn_from_foreign_types(&tys);\n-    let t = ty::node_id_to_type(ccx.tcx, node_id);\n+    let llfn_ty = lltype_for_fn_from_foreign_types(ccx, &tys);\n+    let t = ty::node_id_to_type(ccx.tcx(), node_id);\n     let (cconv, output) = match ty::get(t).sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n             let c = llvm_calling_convention(ccx, fn_ty.abis);\n@@ -547,7 +547,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n                      id: ast::NodeId)\n                      -> ValueRef {\n         let _icx = push_ctxt(\"foreign::foreign::build_rust_fn\");\n-        let tcx = ccx.tcx;\n+        let tcx = ccx.tcx();\n         let t = ty::node_id_to_type(tcx, id);\n \n         let ps = ccx.tcx.map.with_path(id, |path| {\n@@ -590,7 +590,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n                             tys: &ForeignTypes) {\n         let _icx = push_ctxt(\n             \"foreign::trans_rust_fn_with_foreign_abi::build_wrap_fn\");\n-        let tcx = ccx.tcx;\n+        let tcx = ccx.tcx();\n \n         debug!(\"build_wrap_fn(llrustfn={}, llwrapfn={})\",\n                ccx.tn.val_to_str(llrustfn),\n@@ -853,7 +853,7 @@ fn foreign_signature(ccx: &CrateContext, fn_sig: &ty::FnSig, arg_tys: &[ty::t])\n \n fn foreign_types_for_id(ccx: &CrateContext,\n                         id: ast::NodeId) -> ForeignTypes {\n-    foreign_types_for_fn_ty(ccx, ty::node_id_to_type(ccx.tcx, id))\n+    foreign_types_for_fn_ty(ccx, ty::node_id_to_type(ccx.tcx(), id))\n }\n \n fn foreign_types_for_fn_ty(ccx: &CrateContext,\n@@ -873,7 +873,7 @@ fn foreign_types_for_fn_ty(ccx: &CrateContext,\n            llsig={} -> {}, \\\n            fn_ty={} -> {}, \\\n            ret_def={}\",\n-           ty.repr(ccx.tcx),\n+           ty.repr(ccx.tcx()),\n            ccx.tn.types_to_str(llsig.llarg_tys.as_slice()),\n            ccx.tn.type_to_str(llsig.llret_ty),\n            ccx.tn.types_to_str(fn_ty.arg_tys.map(|t| t.ty).as_slice()),\n@@ -888,13 +888,13 @@ fn foreign_types_for_fn_ty(ccx: &CrateContext,\n     }\n }\n \n-fn lltype_for_fn_from_foreign_types(tys: &ForeignTypes) -> Type {\n+fn lltype_for_fn_from_foreign_types(ccx: &CrateContext, tys: &ForeignTypes) -> Type {\n     let mut llargument_tys = Vec::new();\n \n     let ret_ty = tys.fn_ty.ret_ty;\n     let llreturn_ty = if ret_ty.is_indirect() {\n         llargument_tys.push(ret_ty.ty.ptr_to());\n-        Type::void()\n+        Type::void(ccx)\n     } else {\n         match ret_ty.cast {\n             Some(ty) => ty,\n@@ -929,8 +929,7 @@ fn lltype_for_fn_from_foreign_types(tys: &ForeignTypes) -> Type {\n }\n \n pub fn lltype_for_foreign_fn(ccx: &CrateContext, ty: ty::t) -> Type {\n-    let fn_types = foreign_types_for_fn_ty(ccx, ty);\n-    lltype_for_fn_from_foreign_types(&fn_types)\n+    lltype_for_fn_from_foreign_types(ccx, &foreign_types_for_fn_ty(ccx, ty))\n }\n \n fn add_argument_attributes(tys: &ForeignTypes,"}, {"sha": "3a1572559dd00664c26f14041976e4d6a789bc18", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 24, "deletions": 31, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -46,7 +46,7 @@ pub fn trans_free<'a>(cx: &'a Block<'a>, v: ValueRef) -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_free\");\n     callee::trans_lang_call(cx,\n         langcall(cx, None, \"\", FreeFnLangItem),\n-        [PointerCast(cx, v, Type::i8p())],\n+        [PointerCast(cx, v, Type::i8p(cx.ccx()))],\n         Some(expr::Ignore)).bcx\n }\n \n@@ -55,7 +55,7 @@ pub fn trans_exchange_free<'a>(cx: &'a Block<'a>, v: ValueRef)\n     let _icx = push_ctxt(\"trans_exchange_free\");\n     callee::trans_lang_call(cx,\n         langcall(cx, None, \"\", ExchangeFreeFnLangItem),\n-        [PointerCast(cx, v, Type::i8p())],\n+        [PointerCast(cx, v, Type::i8p(cx.ccx()))],\n         Some(expr::Ignore)).bcx\n }\n \n@@ -74,7 +74,7 @@ pub fn take_ty<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n }\n \n fn get_drop_glue_type(ccx: &CrateContext, t: ty::t) -> ty::t {\n-    let tcx = ccx.tcx;\n+    let tcx = ccx.tcx();\n     if !ty::type_needs_drop(tcx, t) {\n         return ty::mk_i8();\n     }\n@@ -128,21 +128,15 @@ pub fn drop_ty_immediate<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n \n pub fn get_drop_glue(ccx: &CrateContext, t: ty::t) -> ValueRef {\n     let t = get_drop_glue_type(ccx, t);\n-    {\n-        let drop_glues = ccx.drop_glues.borrow();\n-        match drop_glues.get().find(&t) {\n-            Some(&glue) => return glue,\n-            _ => { }\n-        }\n+    match ccx.drop_glues.borrow().get().find(&t) {\n+        Some(&glue) => return glue,\n+        _ => { }\n     }\n \n-    let llfnty = Type::glue_fn(type_of(ccx, t).ptr_to());\n+    let llfnty = Type::glue_fn(ccx, type_of(ccx, t).ptr_to());\n     let glue = declare_generic_glue(ccx, t, llfnty, \"drop\");\n \n-    {\n-        let mut drop_glues = ccx.drop_glues.borrow_mut();\n-        drop_glues.get().insert(t, glue);\n-    }\n+    ccx.drop_glues.borrow_mut().get().insert(t, glue);\n \n     make_generic_glue(ccx, t, glue, make_drop_glue, \"drop\");\n \n@@ -152,16 +146,16 @@ pub fn get_drop_glue(ccx: &CrateContext, t: ty::t) -> ValueRef {\n pub fn lazily_emit_visit_glue(ccx: &CrateContext, ti: @tydesc_info) {\n     let _icx = push_ctxt(\"lazily_emit_visit_glue\");\n \n-    let llfnty = Type::glue_fn(type_of(ccx, ti.ty).ptr_to());\n+    let llfnty = Type::glue_fn(ccx, type_of(ccx, ti.ty).ptr_to());\n \n     match ti.visit_glue.get() {\n         Some(_) => (),\n         None => {\n-            debug!(\"+++ lazily_emit_tydesc_glue VISIT {}\", ppaux::ty_to_str(ccx.tcx, ti.ty));\n+            debug!(\"+++ lazily_emit_tydesc_glue VISIT {}\", ppaux::ty_to_str(ccx.tcx(), ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, \"visit\");\n             ti.visit_glue.set(Some(glue_fn));\n             make_generic_glue(ccx, ti.ty, glue_fn, make_visit_glue, \"visit\");\n-            debug!(\"--- lazily_emit_tydesc_glue VISIT {}\", ppaux::ty_to_str(ccx.tcx, ti.ty));\n+            debug!(\"--- lazily_emit_tydesc_glue VISIT {}\", ppaux::ty_to_str(ccx.tcx(), ti.ty));\n         }\n     }\n }\n@@ -185,7 +179,7 @@ pub fn call_visit_glue(bcx: &Block, v: ValueRef, tydesc: ValueRef,\n \n     // When static type info is available, avoid casting to a generic pointer.\n     let llrawptr = if static_glue_fn.is_none() {\n-        PointerCast(bcx, v, Type::i8p())\n+        PointerCast(bcx, v, Type::i8p(ccx))\n     } else {\n         v\n     };\n@@ -283,7 +277,6 @@ fn trans_struct_drop<'a>(bcx: &'a Block<'a>,\n fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'a> {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_drop_glue\");\n-    let ccx = bcx.ccx();\n     match ty::get(t).sty {\n         ty::ty_box(body_ty) => {\n             decr_refcnt_maybe_free(bcx, v0, body_ty)\n@@ -323,27 +316,27 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n             with_cond(bcx, IsNotNull(bcx, Load(bcx, lluniquevalue)), |bcx| {\n                 let dtor_ptr = Load(bcx, GEPi(bcx, v0, [0, abi::trt_field_vtable]));\n                 let dtor = Load(bcx, dtor_ptr);\n-                Call(bcx, dtor, [PointerCast(bcx, lluniquevalue, Type::i8p())], []);\n+                Call(bcx, dtor, [PointerCast(bcx, lluniquevalue, Type::i8p(bcx.ccx()))], []);\n                 bcx\n             })\n         }\n         ty::ty_closure(ref f) if f.sigil == ast::OwnedSigil => {\n             let box_cell_v = GEPi(bcx, v0, [0u, abi::fn_field_box]);\n             let env = Load(bcx, box_cell_v);\n-            let env_ptr_ty = Type::at_box(ccx, Type::i8()).ptr_to();\n+            let env_ptr_ty = Type::at_box(bcx.ccx(), Type::i8(bcx.ccx())).ptr_to();\n             let env = PointerCast(bcx, env, env_ptr_ty);\n             with_cond(bcx, IsNotNull(bcx, env), |bcx| {\n                 let dtor_ptr = GEPi(bcx, env, [0u, abi::box_field_tydesc]);\n                 let dtor = Load(bcx, dtor_ptr);\n                 let cdata = GEPi(bcx, env, [0u, abi::box_field_body]);\n-                Call(bcx, dtor, [PointerCast(bcx, cdata, Type::i8p())], []);\n+                Call(bcx, dtor, [PointerCast(bcx, cdata, Type::i8p(bcx.ccx()))], []);\n \n                 // Free the environment itself\n                 trans_exchange_free(bcx, env)\n             })\n         }\n         _ => {\n-            if ty::type_needs_drop(ccx.tcx, t) &&\n+            if ty::type_needs_drop(bcx.tcx(), t) &&\n                 ty::type_is_structural(t) {\n                 iter_structural_ty(bcx, v0, t, drop_ty)\n             } else {\n@@ -405,21 +398,21 @@ pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> @tydesc_info {\n \n     if ccx.sess().count_type_sizes() {\n         println!(\"{}\\t{}\", llsize_of_real(ccx, llty),\n-                 ppaux::ty_to_str(ccx.tcx, t));\n+                 ppaux::ty_to_str(ccx.tcx(), t));\n     }\n \n     let llsize = llsize_of(ccx, llty);\n     let llalign = llalign_of(ccx, llty);\n     let name = mangle_internal_name_by_type_and_seq(ccx, t, \"tydesc\");\n-    debug!(\"+++ declare_tydesc {} {}\", ppaux::ty_to_str(ccx.tcx, t), name);\n+    debug!(\"+++ declare_tydesc {} {}\", ppaux::ty_to_str(ccx.tcx(), t), name);\n     let gvar = name.with_c_str(|buf| {\n         unsafe {\n-            llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type.to_ref(), buf)\n+            llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type().to_ref(), buf)\n         }\n     });\n     note_unique_llvm_symbol(ccx, name);\n \n-    let ty_name = token::intern_and_get_ident(ppaux::ty_to_str(ccx.tcx, t));\n+    let ty_name = token::intern_and_get_ident(ppaux::ty_to_str(ccx.tcx(), t));\n     let ty_name = C_str_slice(ccx, ty_name);\n \n     let inf = @tydesc_info {\n@@ -430,15 +423,15 @@ pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> @tydesc_info {\n         name: ty_name,\n         visit_glue: Cell::new(None),\n     };\n-    debug!(\"--- declare_tydesc {}\", ppaux::ty_to_str(ccx.tcx, t));\n+    debug!(\"--- declare_tydesc {}\", ppaux::ty_to_str(ccx.tcx(), t));\n     return inf;\n }\n \n fn declare_generic_glue(ccx: &CrateContext, t: ty::t, llfnty: Type,\n                         name: &str) -> ValueRef {\n     let _icx = push_ctxt(\"declare_generic_glue\");\n     let fn_nm = mangle_internal_name_by_type_and_seq(ccx, t, ~\"glue_\" + name);\n-    debug!(\"{} is for type {}\", fn_nm, ppaux::ty_to_str(ccx.tcx, t));\n+    debug!(\"{} is for type {}\", fn_nm, ppaux::ty_to_str(ccx.tcx(), t));\n     let llfn = decl_cdecl_fn(ccx.llmod, fn_nm, llfnty, ty::mk_nil());\n     note_unique_llvm_symbol(ccx, fn_nm);\n     return llfn;\n@@ -452,7 +445,7 @@ fn make_generic_glue(ccx: &CrateContext,\n                      name: &str)\n                      -> ValueRef {\n     let _icx = push_ctxt(\"make_generic_glue\");\n-    let glue_name = format!(\"glue {} {}\", name, ty_to_short_str(ccx.tcx, t));\n+    let glue_name = format!(\"glue {} {}\", name, ty_to_short_str(ccx.tcx(), t));\n     let _s = StatRecorder::new(ccx, glue_name);\n \n     let arena = TypedArena::new();\n@@ -511,7 +504,7 @@ pub fn emit_tydescs(ccx: &CrateContext) {\n               }\n             };\n \n-        let tydesc = C_named_struct(ccx.tydesc_type,\n+        let tydesc = C_named_struct(ccx.tydesc_type(),\n                                     [ti.size, // size\n                                      ti.align, // align\n                                      drop_glue, // drop_glue"}, {"sha": "ee810a652dc987587e0abc793eca2c90793c4344", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -28,7 +28,7 @@ pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             Some(&Some(node_id)) => {\n                 // Already inline\n                 debug!(\"maybe_instantiate_inline({}): already inline as node id {}\",\n-                       ty::item_path_str(ccx.tcx, fn_id), node_id);\n+                       ty::item_path_str(ccx.tcx(), fn_id), node_id);\n                 return local_def(node_id);\n             }\n             Some(&None) => {\n@@ -42,8 +42,8 @@ pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n \n     let csearch_result =\n         csearch::maybe_get_item_ast(\n-            ccx.tcx, fn_id,\n-            |a,b,c,d| astencode::decode_inlined_item(a, b, ccx.maps, c, d));\n+            ccx.tcx(), fn_id,\n+            |a,b,c,d| astencode::decode_inlined_item(a, b, &ccx.maps, c, d));\n     return match csearch_result {\n         csearch::not_found => {\n             let mut external = ccx.external.borrow_mut();\n@@ -104,8 +104,8 @@ pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n           let mut my_id = 0;\n           match item.node {\n             ast::ItemEnum(_, _) => {\n-              let vs_here = ty::enum_variants(ccx.tcx, local_def(item.id));\n-              let vs_there = ty::enum_variants(ccx.tcx, parent_id);\n+              let vs_here = ty::enum_variants(ccx.tcx(), local_def(item.id));\n+              let vs_there = ty::enum_variants(ccx.tcx(), parent_id);\n               for (here, there) in vs_here.iter().zip(vs_there.iter()) {\n                   if there.id == fn_id { my_id = here.id.node; }\n                   let mut external = ccx.external.borrow_mut();\n@@ -146,7 +146,7 @@ pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n           // impl type. But we aren't going to translate anyways, so don't.\n           if is_provided { return local_def(mth.id); }\n \n-            let impl_tpt = ty::lookup_item_type(ccx.tcx, impl_did);\n+            let impl_tpt = ty::lookup_item_type(ccx.tcx(), impl_did);\n             let num_type_params =\n                 impl_tpt.generics.type_param_defs().len() +\n                 mth.generics.ty_params.len();"}, {"sha": "98e63641c12fbfa0834b440d01e89c1036cb58dc", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -99,7 +99,7 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n         // convert `i1` to a `bool`, and write to the out parameter\n         let val = Call(bcx, llfn, [a, b], []);\n         let result = ExtractValue(bcx, val, 0);\n-        let overflow = ZExt(bcx, ExtractValue(bcx, val, 1), Type::bool());\n+        let overflow = ZExt(bcx, ExtractValue(bcx, val, 1), Type::bool(bcx.ccx()));\n         let ret = C_undef(type_of::type_of(bcx.ccx(), t));\n         let ret = InsertValue(bcx, ret, result, 0);\n         let ret = InsertValue(bcx, ret, overflow, 1);\n@@ -133,7 +133,7 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n     fn copy_intrinsic(bcx: &Block, allow_overlap: bool, tp_ty: ty::t) {\n         let ccx = bcx.ccx();\n         let lltp_ty = type_of::type_of(ccx, tp_ty);\n-        let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n+        let align = C_i32(ccx, machine::llalign_of_min(ccx, lltp_ty) as i32);\n         let size = machine::llsize_of(ccx, lltp_ty);\n         let int_size = machine::llbitsize_of_real(ccx, ccx.int_type);\n         let name = if allow_overlap {\n@@ -152,19 +152,19 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n \n         let decl = bcx.fcx.llfn;\n         let first_real_arg = bcx.fcx.arg_pos(0u);\n-        let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n-        let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), Type::i8p());\n+        let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p(ccx));\n+        let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), Type::i8p(ccx));\n         let count = get_param(decl, first_real_arg + 2);\n-        let volatile = C_i1(false);\n-        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n+        let volatile = C_i1(ccx, false);\n+        let llfn = ccx.intrinsics.get_copy(&name);\n         Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile], []);\n         RetVoid(bcx);\n     }\n \n     fn memset_intrinsic(bcx: &Block, tp_ty: ty::t) {\n         let ccx = bcx.ccx();\n         let lltp_ty = type_of::type_of(ccx, tp_ty);\n-        let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n+        let align = C_i32(ccx, machine::llalign_of_min(ccx, lltp_ty) as i32);\n         let size = machine::llsize_of(ccx, lltp_ty);\n         let name = if machine::llbitsize_of_real(ccx, ccx.int_type) == 32 {\n             \"llvm.memset.p0i8.i32\"\n@@ -174,24 +174,24 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n \n         let decl = bcx.fcx.llfn;\n         let first_real_arg = bcx.fcx.arg_pos(0u);\n-        let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n+        let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p(ccx));\n         let val = get_param(decl, first_real_arg + 1);\n         let count = get_param(decl, first_real_arg + 2);\n-        let volatile = C_i1(false);\n-        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n+        let volatile = C_i1(ccx, false);\n+        let llfn = ccx.intrinsics.get_copy(&name);\n         Call(bcx, llfn, [dst_ptr, val, Mul(bcx, size, count), align, volatile], []);\n         RetVoid(bcx);\n     }\n \n     fn count_zeros_intrinsic(bcx: &Block, name: &'static str) {\n         let x = get_param(bcx.fcx.llfn, bcx.fcx.arg_pos(0u));\n-        let y = C_i1(false);\n+        let y = C_i1(bcx.ccx(), false);\n         let llfn = bcx.ccx().intrinsics.get_copy(&name);\n         let llcall = Call(bcx, llfn, [x, y], []);\n         Ret(bcx, llcall);\n     }\n \n-    let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, item.id));\n+    let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx(), item.id));\n \n     let arena = TypedArena::new();\n     let fcx = new_fn_ctxt(ccx, decl, item.id, false, output_type,\n@@ -328,12 +328,13 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n         }\n         \"type_id\" => {\n             let hash = ty::hash_crate_independent(\n-                ccx.tcx,\n+                ccx.tcx(),\n                 *substs.tys.get(0),\n                 &ccx.link_meta.crate_hash);\n             // NB: This needs to be kept in lockstep with the TypeId struct in\n             //     libstd/unstable/intrinsics.rs\n-            let val = C_named_struct(type_of::type_of(ccx, output_type), [C_u64(hash)]);\n+            let val = C_named_struct(type_of::type_of(ccx, output_type),\n+                                     [C_u64(ccx, hash)]);\n             match bcx.fcx.llretptr.get() {\n                 Some(ptr) => {\n                     Store(bcx, val, ptr);\n@@ -381,9 +382,9 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n                     format!(\"transmute called on types with different sizes: \\\n                              {intype} ({insize, plural, =1{# bit} other{# bits}}) to \\\n                              {outtype} ({outsize, plural, =1{# bit} other{# bits}})\",\n-                            intype = ty_to_str(ccx.tcx, in_type),\n+                            intype = ty_to_str(ccx.tcx(), in_type),\n                             insize = in_type_size as uint,\n-                            outtype = ty_to_str(ccx.tcx, out_type),\n+                            outtype = ty_to_str(ccx.tcx(), out_type),\n                             outsize = out_type_size as uint));\n             }\n \n@@ -421,8 +422,8 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n                     // code bloat when `transmute` is used on large structural\n                     // types.\n                     let lldestptr = fcx.llretptr.get().unwrap();\n-                    let lldestptr = PointerCast(bcx, lldestptr, Type::i8p());\n-                    let llsrcptr = PointerCast(bcx, llsrcval, Type::i8p());\n+                    let lldestptr = PointerCast(bcx, lldestptr, Type::i8p(ccx));\n+                    let llsrcptr = PointerCast(bcx, llsrcval, Type::i8p(ccx));\n \n                     let llsize = llsize_of(ccx, llintype);\n                     call_memcpy(bcx, lldestptr, llsrcptr, llsize, 1);\n@@ -434,16 +435,16 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n         }\n         \"needs_drop\" => {\n             let tp_ty = *substs.tys.get(0);\n-            Ret(bcx, C_bool(ty::type_needs_drop(ccx.tcx, tp_ty)));\n+            Ret(bcx, C_bool(ccx, ty::type_needs_drop(ccx.tcx(), tp_ty)));\n         }\n         \"owns_managed\" => {\n             let tp_ty = *substs.tys.get(0);\n-            Ret(bcx, C_bool(ty::type_contents(ccx.tcx, tp_ty).owns_managed()));\n+            Ret(bcx, C_bool(ccx, ty::type_contents(ccx.tcx(), tp_ty).owns_managed()));\n         }\n         \"visit_tydesc\" => {\n             let td = get_param(decl, first_real_arg);\n             let visitor = get_param(decl, first_real_arg + 1u);\n-            let td = PointerCast(bcx, td, ccx.tydesc_type.ptr_to());\n+            let td = PointerCast(bcx, td, ccx.tydesc_type().ptr_to());\n             glue::call_visit_glue(bcx, visitor, td, None);\n             RetVoid(bcx);\n         }"}, {"sha": "cd33bcf6031d18fe5d691c3d8b1f9e38ba559766", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -51,7 +51,7 @@ pub fn trans_impl(ccx: &CrateContext,\n                   generics: &ast::Generics,\n                   id: ast::NodeId) {\n     let _icx = push_ctxt(\"meth::trans_impl\");\n-    let tcx = ccx.tcx;\n+    let tcx = ccx.tcx();\n \n     debug!(\"trans_impl(name={}, id={:?})\", name.repr(tcx), id);\n \n@@ -270,7 +270,7 @@ fn trans_monomorphized_callee<'a>(bcx: &'a Block<'a>,\n     match vtbl {\n       typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n           let ccx = bcx.ccx();\n-          let mname = ty::trait_method(ccx.tcx, trait_id, n_method).ident;\n+          let mname = ty::trait_method(ccx.tcx(), trait_id, n_method).ident;\n           let mth_id = method_with_name(bcx.ccx(), impl_did, mname.name);\n \n           // create a concatenated set of substitutions which includes\n@@ -319,16 +319,16 @@ fn combine_impl_and_methods_tps(bcx: &Block,\n     * mapped to. */\n \n     let ccx = bcx.ccx();\n-    let method = ty::method(ccx.tcx, mth_did);\n+    let method = ty::method(ccx.tcx(), mth_did);\n     let n_m_tps = method.generics.type_param_defs().len();\n     let node_substs = node_id_type_params(bcx, node);\n-    debug!(\"rcvr_substs={:?}\", rcvr_substs.repr(ccx.tcx));\n+    debug!(\"rcvr_substs={:?}\", rcvr_substs.repr(ccx.tcx()));\n     let ty_substs\n         = vec_ng::append(Vec::from_slice(rcvr_substs),\n                          node_substs.tailn(node_substs.len() - n_m_tps));\n     debug!(\"n_m_tps={:?}\", n_m_tps);\n-    debug!(\"node_substs={:?}\", node_substs.repr(ccx.tcx));\n-    debug!(\"ty_substs={:?}\", ty_substs.repr(ccx.tcx));\n+    debug!(\"node_substs={:?}\", node_substs.repr(ccx.tcx()));\n+    debug!(\"ty_substs={:?}\", ty_substs.repr(ccx.tcx()));\n \n \n     // Now, do the same work for the vtables.  The vtables might not\n@@ -415,7 +415,7 @@ pub fn trans_trait_callee_from_llval<'a>(bcx: &'a Block<'a>,\n     debug!(\"(translating trait callee) loading second index from pair\");\n     let llboxptr = GEPi(bcx, llpair, [0u, abi::trt_field_box]);\n     let llbox = Load(bcx, llboxptr);\n-    let llself = PointerCast(bcx, llbox, Type::i8p());\n+    let llself = PointerCast(bcx, llbox, Type::i8p(ccx));\n \n     // Load the function from the vtable and cast it to the expected type.\n     debug!(\"(translating trait callee) loading method\");\n@@ -432,7 +432,7 @@ pub fn trans_trait_callee_from_llval<'a>(bcx: &'a Block<'a>,\n                         PointerCast(bcx,\n                                     GEPi(bcx, llpair,\n                                          [0u, abi::trt_field_vtable]),\n-                                    Type::vtable().ptr_to().ptr_to()));\n+                                    Type::vtable(ccx).ptr_to().ptr_to()));\n     let mptr = Load(bcx, GEPi(bcx, llvtable, [0u, n_method + 1]));\n     let mptr = PointerCast(bcx, mptr, llcallee_ty.ptr_to());\n \n@@ -526,7 +526,7 @@ pub fn make_vtable(ccx: &CrateContext,\n             components.push(ptr)\n         }\n \n-        let tbl = C_struct(components.as_slice(), false);\n+        let tbl = C_struct(ccx, components.as_slice(), false);\n         let sym = token::gensym(\"vtable\");\n         let vt_gvar = format!(\"vtable{}\", sym).with_c_str(|buf| {\n             llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl).to_ref(), buf)\n@@ -544,7 +544,7 @@ fn emit_vtable_methods(bcx: &Block,\n                        vtables: typeck::vtable_res)\n                        -> Vec<ValueRef> {\n     let ccx = bcx.ccx();\n-    let tcx = ccx.tcx;\n+    let tcx = ccx.tcx();\n \n     let trt_id = match ty::impl_trait_ref(tcx, impl_id) {\n         Some(t_id) => t_id.def_id,\n@@ -568,7 +568,7 @@ fn emit_vtable_methods(bcx: &Block,\n            ty::type_has_self(ty::mk_bare_fn(tcx, m.fty.clone())) {\n             debug!(\"(making impl vtable) method has self or type params: {}\",\n                    token::get_ident(ident));\n-            C_null(Type::nil().ptr_to())\n+            C_null(Type::nil(ccx).ptr_to())\n         } else {\n             trans_fn_ref_with_vtables(bcx, m_id, ExprId(0), substs, Some(vtables))\n         }"}, {"sha": "0d9b6a087f947f79c5c6392e6f4dba73dc3242f3", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -41,10 +41,10 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n             vtables={}, \\\n             self_vtable={}, \\\n             ref_id={:?})\",\n-           fn_id.repr(ccx.tcx),\n-           real_substs.repr(ccx.tcx),\n-           vtables.repr(ccx.tcx),\n-           self_vtables.repr(ccx.tcx),\n+           fn_id.repr(ccx.tcx()),\n+           real_substs.repr(ccx.tcx()),\n+           vtables.repr(ccx.tcx()),\n+           self_vtables.repr(ccx.tcx()),\n            ref_id);\n \n     assert!(real_substs.tps.iter().all(|t| !ty::type_needs_infer(*t)));\n@@ -71,23 +71,23 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n             fn_id={}, \\\n             psubsts={}, \\\n             hash_id={:?})\",\n-           fn_id.repr(ccx.tcx),\n-           psubsts.repr(ccx.tcx),\n+           fn_id.repr(ccx.tcx()),\n+           psubsts.repr(ccx.tcx()),\n            hash_id);\n \n     {\n         let monomorphized = ccx.monomorphized.borrow();\n         match monomorphized.get().find(&hash_id) {\n           Some(&val) => {\n             debug!(\"leaving monomorphic fn {}\",\n-                   ty::item_path_str(ccx.tcx, fn_id));\n+                   ty::item_path_str(ccx.tcx(), fn_id));\n             return (val, must_cast);\n           }\n           None => ()\n         }\n     }\n \n-    let tpt = ty::lookup_item_type(ccx.tcx, fn_id);\n+    let tpt = ty::lookup_item_type(ccx.tcx(), fn_id);\n     let llitem_ty = tpt.ty;\n \n     // We need to do special handling of the substitutions if we are\n@@ -123,9 +123,9 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         _ => {}\n     }\n \n-    debug!(\"monomorphic_fn about to subst into {}\", llitem_ty.repr(ccx.tcx));\n+    debug!(\"monomorphic_fn about to subst into {}\", llitem_ty.repr(ccx.tcx()));\n     let mono_ty = match is_static_provided {\n-        None => ty::subst_tps(ccx.tcx, psubsts.tys.as_slice(),\n+        None => ty::subst_tps(ccx.tcx(), psubsts.tys.as_slice(),\n                               psubsts.self_ty, llitem_ty),\n         Some(num_method_ty_params) => {\n             // Static default methods are a little unfortunate, in\n@@ -146,9 +146,9 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n             let substs = psubsts.tys.slice(0, idx) +\n                 &[psubsts.self_ty.unwrap()] + psubsts.tys.tailn(idx);\n             debug!(\"static default: changed substitution to {}\",\n-                   substs.repr(ccx.tcx));\n+                   substs.repr(ccx.tcx()));\n \n-            ty::subst_tps(ccx.tcx, substs, None, llitem_ty)\n+            ty::subst_tps(ccx.tcx(), substs, None, llitem_ty)\n         }\n     };\n \n@@ -224,7 +224,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         }\n         ast_map::NodeVariant(v) => {\n             let parent = ccx.tcx.map.get_parent(fn_id.node);\n-            let tvs = ty::enum_variants(ccx.tcx, local_def(parent));\n+            let tvs = ty::enum_variants(ccx.tcx(), local_def(parent));\n             let this_tv = *tvs.iter().find(|tv| { tv.id.node == fn_id.node}).unwrap();\n             let d = mk_lldecl();\n             set_inline_hint(d);\n@@ -290,7 +290,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         monomorphizing.get().insert(fn_id, depth);\n     }\n \n-    debug!(\"leaving monomorphic fn {}\", ty::item_path_str(ccx.tcx, fn_id));\n+    debug!(\"leaving monomorphic fn {}\", ty::item_path_str(ccx.tcx(), fn_id));\n     (lldecl, must_cast)\n }\n \n@@ -303,7 +303,7 @@ pub fn make_mono_id(ccx: &CrateContext,\n     let precise_param_ids: Vec<(ty::t, Option<@Vec<mono_id> >)> = match substs.vtables {\n       Some(vts) => {\n         debug!(\"make_mono_id vtables={} substs={}\",\n-               vts.repr(ccx.tcx), substs.tys.repr(ccx.tcx));\n+               vts.repr(ccx.tcx()), substs.tys.repr(ccx.tcx()));\n         let vts_iter = substs.self_vtables.iter().chain(vts.iter());\n         vts_iter.zip(substs_iter).map(|(vtable, subst)| {\n             let v = vtable.map(|vt| meth::vtable_id(ccx, vt));"}, {"sha": "397361b83e06add12eae033f7f4df6314afe548b", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -54,7 +54,7 @@ impl<'a> Reflector<'a> {\n     }\n \n     pub fn c_bool(&mut self, b: bool) -> ValueRef {\n-        C_bool(b)\n+        C_bool(self.bcx.ccx(), b)\n     }\n \n     pub fn c_slice(&mut self, s: InternedString) -> ValueRef {\n@@ -65,7 +65,7 @@ impl<'a> Reflector<'a> {\n         let str_ty = ty::mk_str(bcx.tcx(), str_vstore);\n         let scratch = rvalue_scratch_datum(bcx, str_ty, \"\");\n         let len = C_uint(bcx.ccx(), s.get().len());\n-        let c_str = PointerCast(bcx, C_cstr(bcx.ccx(), s), Type::i8p());\n+        let c_str = PointerCast(bcx, C_cstr(bcx.ccx(), s), Type::i8p(bcx.ccx()));\n         Store(bcx, c_str, GEPi(bcx, scratch.val, [ 0, 0 ]));\n         Store(bcx, len, GEPi(bcx, scratch.val, [ 0, 1 ]));\n         scratch.val\n@@ -151,8 +151,8 @@ impl<'a> Reflector<'a> {\n     // Entrypoint\n     pub fn visit_ty(&mut self, t: ty::t) {\n         let bcx = self.bcx;\n-        let tcx = bcx.ccx().tcx;\n-        debug!(\"reflect::visit_ty {}\", ty_to_str(bcx.ccx().tcx, t));\n+        let tcx = bcx.tcx();\n+        debug!(\"reflect::visit_ty {}\", ty_to_str(bcx.tcx(), t));\n \n         match ty::get(t).sty {\n           ty::ty_bot => self.leaf(\"bot\"),\n@@ -285,10 +285,10 @@ impl<'a> Reflector<'a> {\n           ty::ty_enum(did, ref substs) => {\n             let ccx = bcx.ccx();\n             let repr = adt::represent_type(bcx.ccx(), t);\n-            let variants = ty::substd_enum_variants(ccx.tcx, did, substs);\n+            let variants = ty::substd_enum_variants(ccx.tcx(), did, substs);\n             let llptrty = type_of(ccx, t).ptr_to();\n-            let opaquety = ty::get_opaque_ty(ccx.tcx).unwrap();\n-            let opaqueptrty = ty::mk_ptr(ccx.tcx, ty::mt { ty: opaquety,\n+            let opaquety = ty::get_opaque_ty(ccx.tcx()).unwrap();\n+            let opaqueptrty = ty::mk_ptr(ccx.tcx(), ty::mt { ty: opaquety,\n                                                            mutbl: ast::MutImmutable });\n \n             let make_get_disr = || {\n@@ -311,7 +311,7 @@ impl<'a> Reflector<'a> {\n                 };\n                 let bcx = fcx.entry_bcx.get().unwrap();\n                 let arg = BitCast(bcx, arg, llptrty);\n-                let ret = adt::trans_get_discr(bcx, repr, arg, Some(Type::i64()));\n+                let ret = adt::trans_get_discr(bcx, repr, arg, Some(Type::i64(ccx)));\n                 Store(bcx, ret, fcx.llretptr.get().unwrap());\n                 match fcx.llreturn.get() {\n                     Some(llreturn) => Br(bcx, llreturn),\n@@ -328,23 +328,23 @@ impl<'a> Reflector<'a> {\n             self.bracketed(\"enum\", enum_args.as_slice(), |this| {\n                 for (i, v) in variants.iter().enumerate() {\n                     let name = token::get_ident(v.name);\n-                    let variant_args = vec!(this.c_uint(i),\n-                                         C_u64(v.disr_val),\n+                    let variant_args = [this.c_uint(i),\n+                                         C_u64(ccx, v.disr_val),\n                                          this.c_uint(v.args.len()),\n-                                         this.c_slice(name));\n+                                         this.c_slice(name)];\n                     this.bracketed(\"enum_variant\",\n-                                   variant_args.as_slice(),\n+                                   variant_args,\n                                    |this| {\n                         for (j, a) in v.args.iter().enumerate() {\n                             let bcx = this.bcx;\n                             let null = C_null(llptrty);\n                             let ptr = adt::trans_field_ptr(bcx, repr, null, v.disr_val, j);\n                             let offset = p2i(ccx, ptr);\n-                            let field_args = vec!(this.c_uint(j),\n+                            let field_args = [this.c_uint(j),\n                                                offset,\n-                                               this.c_tydesc(*a));\n+                                               this.c_tydesc(*a)];\n                             this.visit(\"enum_variant_field\",\n-                                       field_args.as_slice());\n+                                       field_args);\n                         }\n                     })\n                 }\n@@ -393,7 +393,7 @@ pub fn emit_calls_to_trait_visit_ty<'a>(\n                                     -> &'a Block<'a> {\n     let fcx = bcx.fcx;\n     let final = fcx.new_temp_block(\"final\");\n-    let tydesc_ty = ty::get_tydesc_ty(bcx.ccx().tcx).unwrap();\n+    let tydesc_ty = ty::get_tydesc_ty(bcx.tcx()).unwrap();\n     let tydesc_ty = type_of(bcx.ccx(), tydesc_ty);\n     let mut r = Reflector {\n         visitor_val: visitor_val,"}, {"sha": "1a54c25e364080065351c57dbe33002f5b0539f0", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -71,7 +71,7 @@ pub fn get_dataptr(bcx: &Block, vptr: ValueRef) -> ValueRef {\n pub fn pointer_add_byte(bcx: &Block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"tvec::pointer_add_byte\");\n     let old_ty = val_ty(ptr);\n-    let bptr = PointerCast(bcx, ptr, Type::i8p());\n+    let bptr = PointerCast(bcx, ptr, Type::i8p(bcx.ccx()));\n     return PointerCast(bcx, InBoundsGEP(bcx, bptr, [bytes]), old_ty);\n }\n \n@@ -154,8 +154,8 @@ impl VecTypes {\n     pub fn to_str(&self, ccx: &CrateContext) -> ~str {\n         format!(\"VecTypes \\\\{vec_ty={}, unit_ty={}, llunit_ty={}, llunit_size={}, \\\n                  llunit_alloc_size={}\\\\}\",\n-             ty_to_str(ccx.tcx, self.vec_ty),\n-             ty_to_str(ccx.tcx, self.unit_ty),\n+             ty_to_str(ccx.tcx(), self.vec_ty),\n+             ty_to_str(ccx.tcx(), self.unit_ty),\n              ccx.tn.type_to_str(self.llunit_ty),\n              ccx.tn.val_to_str(self.llunit_size),\n              self.llunit_alloc_size)\n@@ -290,7 +290,7 @@ pub fn trans_lit_str<'a>(\n                 let bytes = str_lit.get().len();\n                 let llbytes = C_uint(bcx.ccx(), bytes);\n                 let llcstr = C_cstr(bcx.ccx(), str_lit);\n-                let llcstr = llvm::LLVMConstPointerCast(llcstr, Type::i8p().to_ref());\n+                let llcstr = llvm::LLVMConstPointerCast(llcstr, Type::i8p(bcx.ccx()).to_ref());\n                 Store(bcx, llcstr,\n                       GEPi(bcx, lldest, [0u, abi::slice_elt_base]));\n                 Store(bcx, llbytes,\n@@ -322,7 +322,7 @@ pub fn trans_uniq_vstore<'a>(bcx: &'a Block<'a>,\n                     let llptrval = C_cstr(bcx.ccx(), (*s).clone());\n                     let llptrval = PointerCast(bcx,\n                                                llptrval,\n-                                               Type::i8p());\n+                                               Type::i8p(bcx.ccx()));\n                     let llsizeval = C_uint(bcx.ccx(), s.get().len());\n                     let typ = ty::mk_str(bcx.tcx(), ty::vstore_uniq);\n                     let lldestval = rvalue_scratch_datum(bcx,"}, {"sha": "bd1a7498d21866860fd8a445d08d3630162e6d5b", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 80, "deletions": 87, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -14,10 +14,9 @@ use lib::llvm::{llvm, TypeRef, Bool, False, True, TypeKind};\n use lib::llvm::{Float, Double, X86_FP80, PPC_FP128, FP128};\n \n use middle::trans::context::CrateContext;\n-use middle::trans::base;\n \n use syntax::ast;\n-use syntax::abi::{Architecture, X86, X86_64, Arm, Mips};\n+use syntax::abi::{X86, X86_64, Arm, Mips};\n \n use std::c_str::ToCStr;\n use std::cast;\n@@ -51,100 +50,94 @@ impl Type {\n         self.rf\n     }\n \n-    pub fn void() -> Type {\n-        ty!(llvm::LLVMVoidTypeInContext(base::task_llcx()))\n+    pub fn void(ccx: &CrateContext) -> Type {\n+        ty!(llvm::LLVMVoidTypeInContext(ccx.llcx))\n     }\n \n-    pub fn nil() -> Type {\n-        Type::empty_struct()\n+    pub fn nil(ccx: &CrateContext) -> Type {\n+        Type::empty_struct(ccx)\n     }\n \n-    pub fn metadata() -> Type {\n-        ty!(llvm::LLVMMetadataTypeInContext(base::task_llcx()))\n+    pub fn metadata(ccx: &CrateContext) -> Type {\n+        ty!(llvm::LLVMMetadataTypeInContext(ccx.llcx))\n     }\n \n-    pub fn i1() -> Type {\n-        ty!(llvm::LLVMInt1TypeInContext(base::task_llcx()))\n+    pub fn i1(ccx: &CrateContext) -> Type {\n+        ty!(llvm::LLVMInt1TypeInContext(ccx.llcx))\n     }\n \n-    pub fn i8() -> Type {\n-        ty!(llvm::LLVMInt8TypeInContext(base::task_llcx()))\n+    pub fn i8(ccx: &CrateContext) -> Type {\n+        ty!(llvm::LLVMInt8TypeInContext(ccx.llcx))\n     }\n \n-    pub fn i16() -> Type {\n-        ty!(llvm::LLVMInt16TypeInContext(base::task_llcx()))\n+    pub fn i16(ccx: &CrateContext) -> Type {\n+        ty!(llvm::LLVMInt16TypeInContext(ccx.llcx))\n     }\n \n-    pub fn i32() -> Type {\n-        ty!(llvm::LLVMInt32TypeInContext(base::task_llcx()))\n+    pub fn i32(ccx: &CrateContext) -> Type {\n+        ty!(llvm::LLVMInt32TypeInContext(ccx.llcx))\n     }\n \n-    pub fn i64() -> Type {\n-        ty!(llvm::LLVMInt64TypeInContext(base::task_llcx()))\n+    pub fn i64(ccx: &CrateContext) -> Type {\n+        ty!(llvm::LLVMInt64TypeInContext(ccx.llcx))\n     }\n \n-    pub fn f32() -> Type {\n-        ty!(llvm::LLVMFloatTypeInContext(base::task_llcx()))\n+    pub fn f32(ccx: &CrateContext) -> Type {\n+        ty!(llvm::LLVMFloatTypeInContext(ccx.llcx))\n     }\n \n-    pub fn f64() -> Type {\n-        ty!(llvm::LLVMDoubleTypeInContext(base::task_llcx()))\n+    pub fn f64(ccx: &CrateContext) -> Type {\n+        ty!(llvm::LLVMDoubleTypeInContext(ccx.llcx))\n     }\n \n-    pub fn bool() -> Type {\n-        Type::i8()\n+    pub fn bool(ccx: &CrateContext) -> Type {\n+        Type::i8(ccx)\n     }\n \n-    pub fn char() -> Type {\n-        Type::i32()\n+    pub fn char(ccx: &CrateContext) -> Type {\n+        Type::i32(ccx)\n     }\n \n-    pub fn i8p() -> Type {\n-        Type::i8().ptr_to()\n+    pub fn i8p(ccx: &CrateContext) -> Type {\n+        Type::i8(ccx).ptr_to()\n     }\n \n-    pub fn int(arch: Architecture) -> Type {\n-        match arch {\n-            X86 | Arm | Mips => Type::i32(),\n-            X86_64 => Type::i64()\n+    pub fn int(ccx: &CrateContext) -> Type {\n+        match ccx.tcx.sess.targ_cfg.arch {\n+            X86 | Arm | Mips => Type::i32(ccx),\n+            X86_64 => Type::i64(ccx)\n         }\n     }\n \n-    pub fn float(_: Architecture) -> Type {\n-        // All architectures currently just use doubles as the default\n-        // float size\n-        Type::f64()\n-    }\n-\n-    pub fn int_from_ty(ctx: &CrateContext, t: ast::IntTy) -> Type {\n+    pub fn int_from_ty(ccx: &CrateContext, t: ast::IntTy) -> Type {\n         match t {\n-            ast::TyI => ctx.int_type,\n-            ast::TyI8 => Type::i8(),\n-            ast::TyI16 => Type::i16(),\n-            ast::TyI32 => Type::i32(),\n-            ast::TyI64 => Type::i64()\n+            ast::TyI => ccx.int_type,\n+            ast::TyI8 => Type::i8(ccx),\n+            ast::TyI16 => Type::i16(ccx),\n+            ast::TyI32 => Type::i32(ccx),\n+            ast::TyI64 => Type::i64(ccx)\n         }\n     }\n \n-    pub fn uint_from_ty(ctx: &CrateContext, t: ast::UintTy) -> Type {\n+    pub fn uint_from_ty(ccx: &CrateContext, t: ast::UintTy) -> Type {\n         match t {\n-            ast::TyU => ctx.int_type,\n-            ast::TyU8 => Type::i8(),\n-            ast::TyU16 => Type::i16(),\n-            ast::TyU32 => Type::i32(),\n-            ast::TyU64 => Type::i64()\n+            ast::TyU => ccx.int_type,\n+            ast::TyU8 => Type::i8(ccx),\n+            ast::TyU16 => Type::i16(ccx),\n+            ast::TyU32 => Type::i32(ccx),\n+            ast::TyU64 => Type::i64(ccx)\n         }\n     }\n \n-    pub fn float_from_ty(t: ast::FloatTy) -> Type {\n+    pub fn float_from_ty(ccx: &CrateContext, t: ast::FloatTy) -> Type {\n         match t {\n-            ast::TyF32 => Type::f32(),\n-            ast::TyF64 => Type::f64()\n+            ast::TyF32 => Type::f32(ccx),\n+            ast::TyF64 => Type::f64(ccx)\n         }\n     }\n \n-    pub fn size_t(arch: Architecture) -> Type {\n-        Type::int(arch)\n+    pub fn size_t(ccx: &CrateContext) -> Type {\n+        Type::int(ccx)\n     }\n \n     pub fn func(args: &[Type], ret: &Type) -> Type {\n@@ -163,23 +156,23 @@ impl Type {\n         ty!(llvm::LLVMPointerType(ty.to_ref(), 0 as c_uint))\n     }\n \n-    pub fn struct_(els: &[Type], packed: bool) -> Type {\n+    pub fn struct_(ccx: &CrateContext, els: &[Type], packed: bool) -> Type {\n         let els : &[TypeRef] = unsafe { cast::transmute(els) };\n-        ty!(llvm::LLVMStructTypeInContext(base::task_llcx(), els.as_ptr(),\n-                                          els.len() as c_uint, packed as Bool))\n+        ty!(llvm::LLVMStructTypeInContext(ccx.llcx, els.as_ptr(),\n+                                          els.len() as c_uint,\n+                                          packed as Bool))\n     }\n \n-    pub fn named_struct(name: &str) -> Type {\n-        let ctx = base::task_llcx();\n-        ty!(name.with_c_str(|s| llvm::LLVMStructCreateNamed(ctx, s)))\n+    pub fn named_struct(ccx: &CrateContext, name: &str) -> Type {\n+        ty!(name.with_c_str(|s| llvm::LLVMStructCreateNamed(ccx.llcx, s)))\n     }\n \n-    pub fn empty_struct() -> Type {\n-        Type::struct_([], false)\n+    pub fn empty_struct(ccx: &CrateContext) -> Type {\n+        Type::struct_(ccx, [], false)\n     }\n \n-    pub fn vtable() -> Type {\n-        Type::array(&Type::i8p().ptr_to(), 1)\n+    pub fn vtable(ccx: &CrateContext) -> Type {\n+        Type::array(&Type::i8p(ccx).ptr_to(), 1)\n     }\n \n     pub fn generic_glue_fn(cx: &CrateContext) -> Type {\n@@ -188,21 +181,21 @@ impl Type {\n             None => ()\n         }\n \n-        let ty = Type::glue_fn(Type::i8p());\n+        let ty = Type::glue_fn(cx, Type::i8p(cx));\n         cx.tn.associate_type(\"glue_fn\", &ty);\n \n-        return ty;\n+        ty\n     }\n \n-    pub fn glue_fn(t: Type) -> Type {\n-        Type::func([t], &Type::void())\n+    pub fn glue_fn(ccx: &CrateContext, t: Type) -> Type {\n+        Type::func([t], &Type::void(ccx))\n     }\n \n-    pub fn tydesc(arch: Architecture) -> Type {\n-        let mut tydesc = Type::named_struct(\"tydesc\");\n-        let glue_fn_ty = Type::glue_fn(Type::i8p()).ptr_to();\n+    pub fn tydesc(ccx: &CrateContext) -> Type {\n+        let mut tydesc = Type::named_struct(ccx, \"tydesc\");\n+        let glue_fn_ty = Type::glue_fn(ccx, Type::i8p(ccx)).ptr_to();\n \n-        let int_ty = Type::int(arch);\n+        let int_ty = Type::int(ccx);\n \n         // Must mirror:\n         //\n@@ -212,10 +205,10 @@ impl Type {\n                      int_ty,     // align\n                      glue_fn_ty, // drop\n                      glue_fn_ty, // visit\n-                     Type::struct_([Type::i8p(), Type::int(arch)], false)]; // name\n+                     Type::struct_(ccx, [Type::i8p(ccx), Type::int(ccx)], false)]; // name\n         tydesc.set_struct_body(elems, false);\n \n-        return tydesc;\n+        tydesc\n     }\n \n     pub fn array(ty: &Type, len: u64) -> Type {\n@@ -226,27 +219,27 @@ impl Type {\n         ty!(llvm::LLVMVectorType(ty.to_ref(), len as c_uint))\n     }\n \n-    pub fn vec(arch: Architecture, ty: &Type) -> Type {\n-        Type::struct_(\n-            [ Type::int(arch), Type::int(arch), Type::array(ty, 0) ],\n+    pub fn vec(ccx: &CrateContext, ty: &Type) -> Type {\n+        Type::struct_(ccx,\n+            [Type::int(ccx), Type::int(ccx), Type::array(ty, 0)],\n         false)\n     }\n \n-    pub fn opaque_vec(arch: Architecture) -> Type {\n-        Type::vec(arch, &Type::i8())\n+    pub fn opaque_vec(ccx: &CrateContext) -> Type {\n+        Type::vec(ccx, &Type::i8(ccx))\n     }\n \n     // The box pointed to by @T.\n-    pub fn at_box(ctx: &CrateContext, ty: Type) -> Type {\n-        Type::struct_([\n-            ctx.int_type, Type::glue_fn(Type::i8p()).ptr_to(),\n-            Type::i8p(), Type::i8p(), ty\n+    pub fn at_box(ccx: &CrateContext, ty: Type) -> Type {\n+        Type::struct_(ccx, [\n+            ccx.int_type, Type::glue_fn(ccx, Type::i8p(ccx)).ptr_to(),\n+            Type::i8p(ccx), Type::i8p(ccx), ty\n         ], false)\n     }\n \n-    pub fn opaque_trait() -> Type {\n-        let vtable = Type::glue_fn(Type::i8p()).ptr_to().ptr_to();\n-        Type::struct_([vtable, Type::i8p()], false)\n+    pub fn opaque_trait(ccx: &CrateContext) -> Type {\n+        let vtable = Type::glue_fn(ccx, Type::i8p(ccx)).ptr_to().ptr_to();\n+        Type::struct_(ccx, [vtable, Type::i8p(ccx)], false)\n     }\n \n     pub fn kind(&self) -> TypeKind {"}, {"sha": "32821f32df5c8b50dc10b5cba363407b71bc0a2b", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 38, "deletions": 41, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb6de3076e17a8a25728f616b833e1060f06088/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=0bb6de3076e17a8a25728f616b833e1060f06088", "patch": "@@ -54,7 +54,7 @@ pub fn type_of_rust_fn(cx: &CrateContext, has_env: bool,\n \n     // Arg 1: Environment\n     if has_env {\n-        atys.push(Type::i8p());\n+        atys.push(Type::i8p(cx));\n     }\n \n     // ... then explicit args.\n@@ -63,7 +63,7 @@ pub fn type_of_rust_fn(cx: &CrateContext, has_env: bool,\n \n     // Use the output as the actual return value if it's immediate.\n     if use_out_pointer || return_type_is_void(cx, output) {\n-        Type::func(atys.as_slice(), &Type::void())\n+        Type::func(atys.as_slice(), &Type::void(cx))\n     } else {\n         Type::func(atys.as_slice(), &lloutputtype)\n     }\n@@ -112,37 +112,36 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n     }\n \n     let llsizingty = match ty::get(t).sty {\n-        ty::ty_nil | ty::ty_bot => Type::nil(),\n-        ty::ty_bool => Type::bool(),\n-        ty::ty_char => Type::char(),\n+        ty::ty_nil | ty::ty_bot => Type::nil(cx),\n+        ty::ty_bool => Type::bool(cx),\n+        ty::ty_char => Type::char(cx),\n         ty::ty_int(t) => Type::int_from_ty(cx, t),\n         ty::ty_uint(t) => Type::uint_from_ty(cx, t),\n-        ty::ty_float(t) => Type::float_from_ty(t),\n+        ty::ty_float(t) => Type::float_from_ty(cx, t),\n \n         ty::ty_str(ty::vstore_uniq) |\n         ty::ty_vec(_, ty::vstore_uniq) |\n         ty::ty_box(..) |\n         ty::ty_uniq(..) |\n         ty::ty_ptr(..) |\n-        ty::ty_rptr(..) => Type::i8p(),\n+        ty::ty_rptr(..) => Type::i8p(cx),\n \n         ty::ty_str(ty::vstore_slice(..)) |\n         ty::ty_vec(_, ty::vstore_slice(..)) => {\n-            Type::struct_([Type::i8p(), Type::i8p()], false)\n+            Type::struct_(cx, [Type::i8p(cx), Type::i8p(cx)], false)\n         }\n \n-        ty::ty_bare_fn(..) => Type::i8p(),\n-        ty::ty_closure(..) => Type::struct_([Type::i8p(), Type::i8p()], false),\n-        ty::ty_trait(..) => Type::opaque_trait(),\n+        ty::ty_bare_fn(..) => Type::i8p(cx),\n+        ty::ty_closure(..) => Type::struct_(cx, [Type::i8p(cx), Type::i8p(cx)], false),\n+        ty::ty_trait(..) => Type::opaque_trait(cx),\n \n-        ty::ty_str(ty::vstore_fixed(size)) => Type::array(&Type::i8(), size as u64),\n+        ty::ty_str(ty::vstore_fixed(size)) => Type::array(&Type::i8(cx), size as u64),\n         ty::ty_vec(mt, ty::vstore_fixed(size)) => {\n             Type::array(&sizing_type_of(cx, mt.ty), size as u64)\n         }\n \n         ty::ty_unboxed_vec(mt) => {\n-            let sz_ty = sizing_type_of(cx, mt.ty);\n-            Type::vec(cx.sess().targ_cfg.arch, &sz_ty)\n+            Type::vec(cx, &sizing_type_of(cx, mt.ty))\n         }\n \n         ty::ty_tup(..) | ty::ty_enum(..) => {\n@@ -151,9 +150,9 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n         }\n \n         ty::ty_struct(..) => {\n-            if ty::type_is_simd(cx.tcx, t) {\n-                let et = ty::simd_type(cx.tcx, t);\n-                let n = ty::simd_size(cx.tcx, t);\n+            if ty::type_is_simd(cx.tcx(), t) {\n+                let et = ty::simd_type(cx.tcx(), t);\n+                let n = ty::simd_size(cx.tcx(), t);\n                 Type::vector(&type_of(cx, et), n as u64)\n             } else {\n                 let repr = adt::represent_type(cx, t);\n@@ -183,21 +182,21 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n         }\n     }\n \n-    debug!(\"type_of {} {:?}\", t.repr(cx.tcx), t);\n+    debug!(\"type_of {} {:?}\", t.repr(cx.tcx()), t);\n \n     // Replace any typedef'd types with their equivalent non-typedef\n     // type. This ensures that all LLVM nominal types that contain\n     // Rust types are defined as the same LLVM types.  If we don't do\n     // this then, e.g. `Option<{myfield: bool}>` would be a different\n     // type than `Option<myrec>`.\n-    let t_norm = ty::normalize_ty(cx.tcx, t);\n+    let t_norm = ty::normalize_ty(cx.tcx(), t);\n \n     if t != t_norm {\n         let llty = type_of(cx, t_norm);\n         debug!(\"--> normalized {} {:?} to {} {:?} llty={}\",\n-                t.repr(cx.tcx),\n+                t.repr(cx.tcx()),\n                 t,\n-                t_norm.repr(cx.tcx),\n+                t_norm.repr(cx.tcx()),\n                 t_norm,\n                 cx.tn.type_to_str(llty));\n         let mut lltypes = cx.lltypes.borrow_mut();\n@@ -206,14 +205,14 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n     }\n \n     let mut llty = match ty::get(t).sty {\n-      ty::ty_nil | ty::ty_bot => Type::nil(),\n-      ty::ty_bool => Type::bool(),\n-      ty::ty_char => Type::char(),\n+      ty::ty_nil | ty::ty_bot => Type::nil(cx),\n+      ty::ty_bool => Type::bool(cx),\n+      ty::ty_char => Type::char(cx),\n       ty::ty_int(t) => Type::int_from_ty(cx, t),\n       ty::ty_uint(t) => Type::uint_from_ty(cx, t),\n-      ty::ty_float(t) => Type::float_from_ty(t),\n+      ty::ty_float(t) => Type::float_from_ty(cx, t),\n       ty::ty_str(ty::vstore_uniq) => {\n-        Type::vec(cx.sess().targ_cfg.arch, &Type::i8()).ptr_to()\n+        Type::vec(cx, &Type::i8(cx)).ptr_to()\n       }\n       ty::ty_enum(did, ref substs) => {\n         // Only create the named struct, but don't fill it in. We\n@@ -231,20 +230,18 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n           type_of(cx, typ).ptr_to()\n       }\n       ty::ty_vec(ref mt, ty::vstore_uniq) => {\n-          let ty = type_of(cx, mt.ty);\n-          Type::vec(cx.sess().targ_cfg.arch, &ty).ptr_to()\n+          Type::vec(cx, &type_of(cx, mt.ty)).ptr_to()\n       }\n       ty::ty_unboxed_vec(ref mt) => {\n-          let ty = type_of(cx, mt.ty);\n-          Type::vec(cx.sess().targ_cfg.arch, &ty)\n+          Type::vec(cx, &type_of(cx, mt.ty))\n       }\n       ty::ty_ptr(ref mt) => type_of(cx, mt.ty).ptr_to(),\n       ty::ty_rptr(_, ref mt) => type_of(cx, mt.ty).ptr_to(),\n \n       ty::ty_vec(ref mt, ty::vstore_slice(_)) => {\n           let p_ty = type_of(cx, mt.ty).ptr_to();\n           let u_ty = Type::uint_from_ty(cx, ast::TyU);\n-          Type::struct_([p_ty, u_ty], false)\n+          Type::struct_(cx, [p_ty, u_ty], false)\n       }\n \n       ty::ty_str(ty::vstore_slice(_)) => {\n@@ -253,7 +250,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n       }\n \n       ty::ty_str(ty::vstore_fixed(n)) => {\n-          Type::array(&Type::i8(), (n + 1u) as u64)\n+          Type::array(&Type::i8(cx), (n + 1u) as u64)\n       }\n \n       ty::ty_vec(ref mt, ty::vstore_fixed(n)) => {\n@@ -265,17 +262,17 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n       }\n       ty::ty_closure(_) => {\n           let fn_ty = type_of_fn_from_ty(cx, t).ptr_to();\n-          Type::struct_([fn_ty, Type::i8p()], false)\n+          Type::struct_(cx, [fn_ty, Type::i8p(cx)], false)\n       }\n-      ty::ty_trait(..) => Type::opaque_trait(),\n+      ty::ty_trait(..) => Type::opaque_trait(cx),\n       ty::ty_tup(..) => {\n           let repr = adt::represent_type(cx, t);\n           adt::type_of(cx, repr)\n       }\n       ty::ty_struct(did, ref substs) => {\n-          if ty::type_is_simd(cx.tcx, t) {\n-              let et = ty::simd_type(cx.tcx, t);\n-              let n = ty::simd_size(cx.tcx, t);\n+          if ty::type_is_simd(cx.tcx(), t) {\n+              let et = ty::simd_type(cx.tcx(), t);\n+              let n = ty::simd_size(cx.tcx(), t);\n               Type::vector(&type_of(cx, et), n as u64)\n           } else {\n               // Only create the named struct, but don't fill it in. We fill it\n@@ -296,7 +293,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n     };\n \n     debug!(\"--> mapped t={} {:?} to llty={}\",\n-            t.repr(cx.tcx),\n+            t.repr(cx.tcx()),\n             t,\n             cx.tn.type_to_str(llty));\n     {\n@@ -306,7 +303,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n \n     // If this was an enum or struct, fill in the type now.\n     match ty::get(t).sty {\n-        ty::ty_enum(..) | ty::ty_struct(..) if !ty::type_is_simd(cx.tcx, t) => {\n+        ty::ty_enum(..) | ty::ty_struct(..) if !ty::type_is_simd(cx.tcx(), t) => {\n             let repr = adt::represent_type(cx, t);\n             adt::finish_type_of(cx, repr, &mut llty);\n         }\n@@ -327,7 +324,7 @@ pub fn llvm_type_name(cx: &CrateContext,\n         a_struct => { \"struct\" }\n         an_enum => { \"enum\" }\n     };\n-    let tstr = ppaux::parameterized(cx.tcx, ty::item_path_str(cx.tcx, did),\n+    let tstr = ppaux::parameterized(cx.tcx(), ty::item_path_str(cx.tcx(), did),\n                                     &ty::NonerasedRegions(opt_vec::Empty),\n                                     tps, did, false);\n     if did.krate == 0 {\n@@ -339,5 +336,5 @@ pub fn llvm_type_name(cx: &CrateContext,\n \n pub fn type_of_dtor(ccx: &CrateContext, self_ty: ty::t) -> Type {\n     let self_ty = type_of(ccx, self_ty).ptr_to();\n-    Type::func([self_ty], &Type::void())\n+    Type::func([self_ty], &Type::void(ccx))\n }"}]}