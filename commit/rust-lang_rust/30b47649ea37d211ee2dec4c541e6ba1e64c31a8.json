{"sha": "30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwYjQ3NjQ5ZWEzN2QyMTFlZTJkZWM0YzU0MWU2YmExZTY0YzMxYTg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-19T12:52:01Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-24T16:52:03Z"}, "message": "new liveness pass to supercede last_use / initedness", "tree": {"sha": "b6b5825a2711f7911bd64bd1e505d44253d4e256", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6b5825a2711f7911bd64bd1e505d44253d4e256"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "html_url": "https://github.com/rust-lang/rust/commit/30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3be0b105436118e187ea52deb89788afaf1edb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3be0b105436118e187ea52deb89788afaf1edb5", "html_url": "https://github.com/rust-lang/rust/commit/a3be0b105436118e187ea52deb89788afaf1edb5"}], "stats": {"total": 2266, "additions": 2104, "deletions": 162}, "files": [{"sha": "3404f277e8d74d08b97718bec05c63344eeb135f", "filename": "src/librustsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Flibrustsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Flibrustsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fast.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -351,7 +351,7 @@ enum expr_ {\n }\n \n #[auto_serialize]\n-type capture_item = {\n+type capture_item = @{\n     id: int,\n     is_move: bool,\n     name: ident, // Currently, can only capture a local var."}, {"sha": "51b26373c367847019fb16d86e0fa1171a8c6cbb", "filename": "src/librustsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fparser.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -434,7 +434,7 @@ class parser {\n         fn parse_capture_item(p:parser, is_move: bool) -> capture_item {\n             let sp = mk_sp(p.span.lo, p.span.hi);\n             let ident = parse_ident(p);\n-            {id: p.get_id(), is_move: is_move, name: ident, span: sp}\n+            @{id: p.get_id(), is_move: is_move, name: ident, span: sp}\n         }\n \n         if eat_keyword(self, \"move\") {\n@@ -1710,7 +1710,7 @@ class parser {\n                     let id = p.get_id();\n                     let sp = mk_sp(p.span.lo, p.span.hi);\n                     let ident = parse_ident(p);\n-                    res += [{id:id, is_move: is_move, name:ident, span:sp}];\n+                    res += [@{id:id, is_move: is_move, name:ident, span:sp}];\n                     if !eat(p, token::COMMA) {\n                         ret res;\n                     }"}, {"sha": "0cb99af21417d19467ad39f1fc54bd8af1689d67", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -192,6 +192,9 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n          bind middle::check_loop::check_crate(ty_cx, crate));\n     time(time_passes, \"alt checking\",\n          bind middle::check_alt::check_crate(ty_cx, crate));\n+    let _last_use_map =\n+        time(time_passes, \"liveness checking\",\n+             bind middle::liveness::check_crate(ty_cx, method_map, crate));\n     time(time_passes, \"typestate checking\",\n          bind middle::tstate::ck::check_crate(ty_cx, crate));\n     let (root_map, mutbl_map) = time("}, {"sha": "8cf6671a3d45c3a6173acf6607e39bda2429bdd5", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -541,6 +541,15 @@ enum assignment_type {\n }\n \n impl methods for assignment_type {\n+    fn checked_by_liveness() -> bool {\n+        // the liveness pass guarantees that immutable local variables\n+        // are only assigned once; but it doesn't consider &mut\n+        alt self {\n+          at_straight_up {true}\n+          at_swap {true}\n+          at_mutbl_ref {false}\n+        }\n+    }\n     fn ing_form(desc: str) -> str {\n         alt self {\n           at_straight_up { \"assigning to \" + desc }\n@@ -717,6 +726,13 @@ impl methods for check_loan_ctxt {\n         }\n     }\n \n+    fn is_local_variable(cmt: cmt) -> bool {\n+        alt cmt.cat {\n+          cat_local(_) {true}\n+          _ {false}\n+        }\n+    }\n+\n     fn is_self_field(cmt: cmt) -> bool {\n         alt cmt.cat {\n           cat_comp(cmt_base, comp_field(_)) {\n@@ -735,9 +751,13 @@ impl methods for check_loan_ctxt {\n         #debug[\"check_assignment(cmt=%s)\",\n                self.bccx.cmt_to_repr(cmt)];\n \n-        // check that the lvalue `ex` is assignable, but be careful\n-        // because assigning to self.foo in a ctor is always allowed.\n-        if !self.in_ctor || !self.is_self_field(cmt) {\n+        if self.in_ctor && self.is_self_field(cmt)\n+            && at.checked_by_liveness() {\n+            // assigning to self.foo in a ctor is always allowed.\n+        } else if self.is_local_variable(cmt) && at.checked_by_liveness() {\n+            // liveness guarantees that immutable local variables\n+            // are only assigned once\n+        } else {\n             alt cmt.mutbl {\n               m_mutbl { /*ok*/ }\n               m_const | m_imm {"}, {"sha": "d6edd2b935d8052fe11da07564dc97f3f3ec854e", "filename": "src/rustc/middle/capture.rs", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Frustc%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Frustc%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcapture.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -1,5 +1,6 @@\n import syntax::{ast, ast_util};\n import driver::session::session;\n+import syntax::codemap::span;\n import std::map;\n import std::map::hashmap;\n \n@@ -14,15 +15,17 @@ export cap_drop;\n export cap_ref;\n \n enum capture_mode {\n-    cap_copy, //< Copy the value into the closure.\n-    cap_move, //< Move the value into the closure.\n-    cap_drop, //< Drop value after creating closure.\n-    cap_ref,  //< Reference directly from parent stack frame (block fn).\n+    cap_copy, // Copy the value into the closure.\n+    cap_move, // Move the value into the closure.\n+    cap_drop, // Drop value after creating closure.\n+    cap_ref,  // Reference directly from parent stack frame (block fn).\n }\n \n type capture_var = {\n-    def: ast::def,     //< The variable being accessed free.\n-    mode: capture_mode //< How is the variable being accessed.\n+    def: ast::def,                       // Variable being accessed free\n+    span: span,                          // Location of access or cap item\n+    cap_item: option<ast::capture_item>, // Capture item, if any\n+    mode: capture_mode                   // How variable is being accessed\n };\n \n type capture_map = map::hashmap<ast::def_id, capture_var>;\n@@ -70,15 +73,24 @@ fn compute_capture_vars(tcx: ty::ctxt,\n             // if we are moving the value in, but it's not actually used,\n             // must drop it.\n             if vec::any(*freevars, {|fv| fv.def == cap_def}) {\n-                cap_map.insert(cap_def_id, { def:cap_def, mode:cap_move });\n+                cap_map.insert(cap_def_id, {def:cap_def,\n+                                            span: cap_item.span,\n+                                            cap_item: some(cap_item),\n+                                            mode:cap_move});\n             } else {\n-                cap_map.insert(cap_def_id, { def:cap_def, mode:cap_drop });\n+                cap_map.insert(cap_def_id, {def:cap_def,\n+                                            span: cap_item.span,\n+                                            cap_item: some(cap_item),\n+                                            mode:cap_drop});\n             }\n         } else {\n             // if we are copying the value in, but it's not actually used,\n             // just ignore it.\n             if vec::any(*freevars, {|fv| fv.def == cap_def}) {\n-                cap_map.insert(cap_def_id, { def:cap_def, mode:cap_copy });\n+                cap_map.insert(cap_def_id, {def:cap_def,\n+                                            span: cap_item.span,\n+                                            cap_item: some(cap_item),\n+                                            mode:cap_copy});\n             }\n         }\n     }\n@@ -96,7 +108,10 @@ fn compute_capture_vars(tcx: ty::ctxt,\n         alt cap_map.find(fvar_def_id) {\n           option::some(_) { /* was explicitly named, do nothing */ }\n           option::none {\n-            cap_map.insert(fvar_def_id, {def:fvar.def, mode:implicit_mode});\n+            cap_map.insert(fvar_def_id, {def:fvar.def,\n+                                         span: fvar.span,\n+                                         cap_item: none,\n+                                         mode:implicit_mode});\n           }\n         }\n     }"}, {"sha": "d95c58c15c8b8cceb541c3fe1e6b6fcd0865255d", "filename": "src/rustc/middle/liveness.rs", "status": "added", "additions": 1502, "deletions": 0, "changes": 1502, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,1502 @@\n+/*\n+\n+A classic liveness analysis based on dataflow over the AST.  Computes,\n+for each local variable in a function, whether that variable is live\n+at a given point.  Program execution points are identified by their\n+id.\n+\n+# Basic idea\n+\n+The basic model is that each local variable is assigned an index.  We\n+represent sets of local variables using a vector indexed by this\n+index.  The value in the vector is either 0, indicating the variable\n+is dead, or the id of an expression that uses the variable.\n+\n+We conceptually walk over the AST in reverse execution order.  If we\n+find a use of a variable, we add it to the set of live variables.  If\n+we find an assignment to a variable, we remove it from the set of live\n+variables.  When we have to merge two flows, we take the union of\n+those two flows---if the variable is live on both paths, we simply\n+pick one id.  In the event of loops, we continue doing this until a\n+fixed point is reached.\n+\n+## Checking initialization\n+\n+At the function entry point, all variables must be dead.  If this is\n+not the case, we can report an error using the id found in the set of\n+live variables, which identifies a use of the variable which is not\n+dominated by an assignment.\n+\n+## Checking moves\n+\n+After each explicit move, the variable must be dead.\n+\n+## Computing last uses\n+\n+Any use of the variable where the variable is dead afterwards is a\n+last use.\n+\n+# Extension to handle constructors\n+\n+Each field is assigned an index just as with local variables.  A use of\n+`self` is considered a use of all fields.  A use of `self.f` is just a use\n+of `f`.\n+\n+*/\n+\n+import dvec::{dvec, extensions};\n+import std::map::{hashmap, int_hash, str_hash};\n+import syntax::{visit, ast_util};\n+import syntax::print::pprust::{expr_to_str};\n+import visit::vt;\n+import syntax::codemap::span;\n+import syntax::ast::*;\n+import driver::session::session;\n+import io::writer_util;\n+import capture::{cap_move, cap_drop, cap_copy, cap_ref};\n+\n+export check_crate;\n+export last_use_map;\n+\n+type last_use_map = hashmap<node_id, @dvec<node_id>>;\n+\n+enum variable = uint;\n+enum live_node = uint;\n+\n+enum live_node_kind {\n+    lnk_freevar(span),\n+    lnk_expr(span),\n+    lnk_vdef(span),\n+    lnk_exit\n+}\n+\n+fn check_crate(tcx: ty::ctxt,\n+               method_map: typeck::method_map,\n+               crate: @crate) -> last_use_map {\n+    let visitor = visit::mk_vt(@{\n+        visit_fn: visit_fn,\n+        visit_local: visit_local,\n+        visit_expr: visit_expr\n+        with *visit::default_visitor()\n+    });\n+\n+    let last_use_map = int_hash();\n+    let initial_maps = @ir_maps(tcx, method_map, last_use_map);\n+    visit::visit_crate(*crate, initial_maps, visitor);\n+    tcx.sess.abort_if_errors();\n+    ret last_use_map;\n+}\n+\n+impl of to_str::to_str for live_node {\n+    fn to_str() -> str { #fmt[\"ln(%u)\", *self] }\n+}\n+\n+impl of to_str::to_str for variable {\n+    fn to_str() -> str { #fmt[\"v(%u)\", *self] }\n+}\n+\n+// ______________________________________________________________________\n+// Creating ir_maps\n+//\n+// This is the first pass and the one that drives the main\n+// computation.  It walks up and down the IR once.  On the way down,\n+// we count for each function the number of variables as well as\n+// liveness nodes.  A liveness node is basically an expression or\n+// capture clause that does something of interest: either it has\n+// interesting control flow or it uses/defines a local variable.\n+//\n+// On the way back up, at each function node we create liveness sets\n+// (we now know precisely how big to make our various vectors and so\n+// forth) and then do the data-flow propagation to compute the set\n+// of live variables at each program point.\n+//\n+// Finally, we run back over the IR one last time and, using the\n+// computed liveness, check various safety conditions.  For example,\n+// there must be no live nodes at the definition site for a variable\n+// unless it has an initializer.  Similarly, each non-mutable local\n+// variable must not be assigned if there is some successor\n+// assignment.  And so forth.\n+\n+impl methods for live_node {\n+    fn is_valid() -> bool { *self != uint::max_value }\n+}\n+\n+fn invalid_node() -> live_node { live_node(uint::max_value) }\n+\n+enum relevant_def { rdef_var(node_id), rdef_self }\n+\n+type capture_info = {ln: live_node, is_move: bool, rv: relevant_def};\n+\n+type var_info = {id: node_id, name: str};\n+\n+fn relevant_def(def: def) -> option<relevant_def> {\n+    alt def {\n+      def_self(_) {some(rdef_self)}\n+      def_arg(nid, _) | def_local(nid, _) {some(rdef_var(nid))}\n+      _ {none}\n+    }\n+}\n+\n+class ir_maps {\n+    let tcx: ty::ctxt;\n+    let method_map: typeck::method_map;\n+    let last_use_map: last_use_map;\n+\n+    let mut num_live_nodes: uint;\n+    let mut num_vars: uint;\n+    let live_node_map: hashmap<node_id, live_node>;\n+    let variable_map: hashmap<node_id, variable>;\n+    let field_map: hashmap<str, variable>;\n+    let capture_map: hashmap<node_id, @[capture_info]>;\n+    let mut var_infos: [var_info];\n+    let mut lnks: [live_node_kind];\n+\n+    new(tcx: ty::ctxt, method_map: typeck::method_map,\n+        last_use_map: hashmap<node_id, @dvec<node_id>>) {\n+        self.tcx = tcx;\n+        self.method_map = method_map;\n+        self.last_use_map = last_use_map;\n+\n+        self.num_live_nodes = 0u;\n+        self.num_vars = 0u;\n+        self.live_node_map = int_hash();\n+        self.variable_map = int_hash();\n+        self.capture_map = int_hash();\n+        self.field_map = str_hash();\n+        self.var_infos = [];\n+        self.lnks = [];\n+    }\n+\n+    fn add_live_node(lnk: live_node_kind) -> live_node {\n+        let ln = live_node(self.num_live_nodes);\n+        self.lnks += [lnk];\n+        self.num_live_nodes += 1u;\n+\n+        #debug[\"%s is of kind %?\", ln.to_str(), lnk];\n+\n+        ln\n+    }\n+\n+    fn add_live_node_for_node(node_id: node_id, lnk: live_node_kind) {\n+        let ln = self.add_live_node(lnk);\n+        self.live_node_map.insert(node_id, ln);\n+\n+        #debug[\"%s is node %d\", ln.to_str(), node_id];\n+    }\n+\n+    fn add_variable(node_id: node_id, name: str) -> variable {\n+        let v = variable(self.num_vars);\n+        self.variable_map.insert(node_id, v);\n+        self.var_infos += [{id:node_id, name:name}];\n+        self.num_vars += 1u;\n+\n+        #debug[\"%s is node %d\", v.to_str(), node_id];\n+\n+        v\n+    }\n+\n+    fn variable(node_id: node_id, span: span) -> variable {\n+        alt self.variable_map.find(node_id) {\n+          some(var) {var}\n+          none {\n+            self.tcx.sess.span_bug(\n+                span, \"No variable registered for this id\");\n+          }\n+        }\n+    }\n+\n+    fn set_captures(node_id: node_id, +cs: [capture_info]) {\n+        self.capture_map.insert(node_id, @cs);\n+    }\n+\n+    fn captures(expr: @expr) -> @[capture_info] {\n+        alt self.capture_map.find(expr.id) {\n+          some(caps) {caps}\n+          none {\n+            self.tcx.sess.span_bug(expr.span, \"no registered caps\");\n+          }\n+        }\n+    }\n+\n+    fn lnk(ln: live_node) -> live_node_kind {\n+        self.lnks[*ln]\n+    }\n+\n+    fn add_last_use(expr_id: node_id, var: variable) {\n+        let v = alt self.last_use_map.find(expr_id) {\n+          some(v) { v }\n+          none {\n+            let v = @dvec();\n+            self.last_use_map.insert(expr_id, v);\n+            v\n+          }\n+        };\n+        let {id, name} = self.var_infos[*var];\n+        #debug[\"Node %d is a last use of variable %d / %s\",\n+               expr_id, id, name];\n+        (*v).push(id);\n+    }\n+}\n+\n+fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n+            sp: span, id: node_id, &&self: @ir_maps, v: vt<@ir_maps>) {\n+    #debug[\"visit_fn: id=%d\", id];\n+    let _i = util::common::indenter();\n+\n+    // swap in a new set of IR maps for this function body:\n+    let fn_maps = @ir_maps(self.tcx, self.method_map,\n+                           self.last_use_map);\n+\n+    #debug[\"creating fn_maps: %x\", ptr::addr_of(*fn_maps) as uint];\n+\n+    for decl.inputs.each { |arg|\n+        #debug[\"adding argument %d\", arg.id];\n+        (*fn_maps).add_variable(arg.id, arg.ident);\n+    }\n+\n+    // gather up the various local variables, significant expressions,\n+    // and so forth:\n+    visit::visit_fn(fk, decl, body, sp, id, fn_maps, v);\n+\n+    alt fk {\n+      visit::fk_ctor(_, _, _, class_did) {\n+        add_class_fields(fn_maps, class_did);\n+      }\n+      _ {}\n+    }\n+\n+    // Special nodes and variables:\n+    // - exit_ln represents the end of the fn, either by ret or fail\n+    // - implicit_ret_var is a pseudo-variable that represents\n+    //   an implicit return\n+    let specials = {\n+        exit_ln: (*fn_maps).add_live_node(lnk_exit),\n+        fallthrough_ln: (*fn_maps).add_live_node(lnk_exit),\n+        no_ret_var: (*fn_maps).add_variable(0, \"<no_ret>\"),\n+        self_var: (*fn_maps).add_variable(0, \"self\")\n+    };\n+\n+    // compute liveness\n+    let lsets = @liveness(fn_maps, specials);\n+    let entry_ln = (*lsets).compute(body);\n+\n+    // check for various error conditions\n+    let check_vt = visit::mk_vt(@{\n+        visit_fn: check_fn,\n+        visit_local: check_local,\n+        visit_expr: check_expr\n+        with *visit::default_visitor()\n+    });\n+    check_vt.visit_block(body, lsets, check_vt);\n+    lsets.check_ret(id, sp, fk, entry_ln);\n+    lsets.check_fields(sp, entry_ln);\n+}\n+\n+fn add_class_fields(self: @ir_maps, did: def_id) {\n+    for ty::lookup_class_fields(self.tcx, did).each { |field_ty|\n+        assert field_ty.id.crate == local_crate;\n+        let var = (*self).add_variable(\n+            field_ty.id.node, #fmt[\"self.%s\", field_ty.ident]);\n+        self.field_map.insert(field_ty.ident, var);\n+    }\n+}\n+\n+fn visit_local(local: @local, &&self: @ir_maps, vt: vt<@ir_maps>) {\n+    let def_map = self.tcx.def_map;\n+    pat_util::pat_bindings(def_map, local.node.pat) { |p_id, sp, path|\n+        #debug[\"adding local variable %d\", p_id];\n+        let name = ast_util::path_to_ident(path);\n+        (*self).add_live_node_for_node(p_id, lnk_vdef(sp));\n+        (*self).add_variable(p_id, name);\n+    }\n+    visit::visit_local(local, self, vt);\n+}\n+\n+fn visit_expr(expr: @expr, &&self: @ir_maps, vt: vt<@ir_maps>) {\n+    alt expr.node {\n+      // live nodes required for uses or definitions of variables:\n+      expr_path(_) {\n+        let def = self.tcx.def_map.get(expr.id);\n+        #debug[\"expr %d: path that leads to %?\", expr.id, def];\n+        if relevant_def(def).is_some() {\n+            (*self).add_live_node_for_node(expr.id, lnk_expr(expr.span));\n+        }\n+        visit::visit_expr(expr, self, vt);\n+      }\n+      expr_fn(_, _, _, cap_clause) |\n+      expr_fn_block(_, _, cap_clause) {\n+        // Make a live_node for each captured variable, with the span\n+        // being the location that the variable is used.  This results\n+        // in better error messages than just pointing at the closure\n+        // construction site.\n+        let proto = ty::ty_fn_proto(ty::expr_ty(self.tcx, expr));\n+        let cvs = capture::compute_capture_vars(self.tcx, expr.id,\n+                                                proto, cap_clause);\n+        let mut call_caps = [];\n+        for cvs.each { |cv|\n+            alt relevant_def(cv.def) {\n+              some(rv) {\n+                let cv_ln = (*self).add_live_node(lnk_freevar(cv.span));\n+                let is_move = alt cv.mode {\n+                  cap_move | cap_drop {true} // var must be dead afterwards\n+                  cap_copy | cap_ref {false} // var can still be used\n+                };\n+                call_caps += [{ln: cv_ln, is_move: is_move, rv: rv}];\n+              }\n+              none {}\n+            }\n+        }\n+        (*self).set_captures(expr.id, call_caps);\n+\n+        visit::visit_expr(expr, self, vt);\n+      }\n+\n+      // live nodes required for interesting control flow:\n+      expr_if_check(*) | expr_if(*) | expr_alt(*) |\n+      expr_while(*) | expr_loop(*) {\n+        (*self).add_live_node_for_node(expr.id, lnk_expr(expr.span));\n+        visit::visit_expr(expr, self, vt);\n+      }\n+      expr_binary(op, _, _) if ast_util::lazy_binop(op) {\n+        (*self).add_live_node_for_node(expr.id, lnk_expr(expr.span));\n+        visit::visit_expr(expr, self, vt);\n+      }\n+\n+      // otherwise, live nodes are not required:\n+      expr_index(*) | expr_field(*) | expr_vstore(*) |\n+      expr_vec(*) | expr_rec(*) | expr_call(*) | expr_tup(*) |\n+      expr_bind(*) | expr_new(*) | expr_log(*) | expr_binary(*) |\n+      expr_assert(*) | expr_check(*) | expr_addr_of(*) | expr_copy(*) |\n+      expr_loop_body(*) | expr_cast(*) | expr_unary(*) | expr_fail(*) |\n+      expr_break | expr_cont | expr_lit(_) | expr_ret(*) |\n+      expr_block(*) | expr_move(*) | expr_assign(*) | expr_swap(*) |\n+      expr_assign_op(*) | expr_mac(*) {\n+          visit::visit_expr(expr, self, vt);\n+      }\n+    }\n+}\n+\n+// ______________________________________________________________________\n+// Computing liveness sets\n+//\n+// Actually we compute just a bit more than just liveness, but we use\n+// the same basic propagation framework in all cases.\n+\n+type users = {\n+    reader: live_node,\n+    writer: live_node\n+};\n+\n+fn invalid_users() -> users {\n+    {reader: invalid_node(), writer: invalid_node()}\n+}\n+\n+type specials = {\n+    exit_ln: live_node,\n+    fallthrough_ln: live_node,\n+    no_ret_var: variable,\n+    self_var: variable\n+};\n+\n+const ACC_READ: uint = 1u;\n+const ACC_WRITE: uint = 2u;\n+\n+class liveness {\n+    let tcx: ty::ctxt;\n+    let ir: @ir_maps;\n+    let s: specials;\n+    let successors: [mut live_node];\n+    let users: [mut users];\n+    let mut break_ln: live_node;\n+    let mut cont_ln: live_node;\n+\n+    new(ir: @ir_maps, specials: specials) {\n+        self.ir = ir;\n+        self.tcx = ir.tcx;\n+        self.s = specials;\n+        self.successors =\n+            vec::to_mut(\n+                vec::from_elem(self.ir.num_live_nodes,\n+                               invalid_node()));\n+        self.users =\n+            vec::to_mut(\n+                vec::from_elem(self.ir.num_live_nodes * self.ir.num_vars,\n+                               invalid_users()));\n+        self.break_ln = invalid_node();\n+        self.cont_ln = invalid_node();\n+    }\n+\n+    // _______________________________________________________________________\n+\n+    fn live_node(node_id: node_id, span: span) -> live_node {\n+        alt self.ir.live_node_map.find(node_id) {\n+          some(ln) {ln}\n+          none {\n+            // This must be a mismatch between the ir_map construction\n+            // above and the propagation code below; the two sets of\n+            // code have to agree about which AST nodes are worth\n+            // creating liveness nodes for.\n+            self.tcx.sess.span_bug(\n+                span, #fmt[\"No live node registered for node %d\",\n+                           node_id]);\n+          }\n+        }\n+    }\n+\n+    fn variable_from_rdef(rv: relevant_def, span: span) -> variable {\n+        alt rv {\n+          rdef_self {self.s.self_var}\n+          rdef_var(nid) {self.variable(nid, span)}\n+        }\n+    }\n+\n+    fn variable(node_id: node_id, span: span) -> variable {\n+        (*self.ir).variable(node_id, span)\n+    }\n+\n+    fn variable_from_def_map(node_id: node_id,\n+                             span: span) -> option<variable> {\n+        alt self.tcx.def_map.find(node_id) {\n+          some(def) {\n+            relevant_def(def).map { |rdef|\n+              self.variable_from_rdef(rdef, span)\n+            }\n+          }\n+          none {\n+            self.tcx.sess.span_bug(\n+                span, \"Not present in def map\")\n+          }\n+        }\n+    }\n+\n+    fn idx(ln: live_node, var: variable) -> uint {\n+        *ln * self.ir.num_vars + *var\n+    }\n+\n+    fn live_on_entry(ln: live_node, var: variable)\n+        -> option<live_node_kind> {\n+\n+        assert ln.is_valid();\n+        let reader = self.users[self.idx(ln, var)].reader;\n+        if reader.is_valid() {some((*self.ir).lnk(reader))} else {none}\n+    }\n+\n+    fn live_on_exit(ln: live_node, var: variable)\n+        -> option<live_node_kind> {\n+\n+        self.live_on_entry(self.successors[*ln], var)\n+    }\n+\n+    fn assigned_on_entry(ln: live_node, var: variable)\n+        -> option<live_node_kind> {\n+\n+        assert ln.is_valid();\n+        let writer = self.users[self.idx(ln, var)].writer;\n+        if writer.is_valid() {some((*self.ir).lnk(writer))} else {none}\n+    }\n+\n+    fn assigned_on_exit(ln: live_node, var: variable)\n+        -> option<live_node_kind> {\n+\n+        self.assigned_on_entry(self.successors[*ln], var)\n+    }\n+\n+    fn indices(ln: live_node, op: fn(uint)) {\n+        let node_base_idx = self.idx(ln, variable(0u));\n+        uint::range(0u, self.ir.num_vars) { |var_idx|\n+            op(node_base_idx + var_idx)\n+        }\n+    }\n+\n+    fn indices2(ln: live_node, succ_ln: live_node,\n+                op: fn(uint, uint)) {\n+        let node_base_idx = self.idx(ln, variable(0u));\n+        let succ_base_idx = self.idx(succ_ln, variable(0u));\n+        uint::range(0u, self.ir.num_vars) { |var_idx|\n+            op(node_base_idx + var_idx, succ_base_idx + var_idx);\n+        }\n+    }\n+\n+    fn write_vars(wr: io::writer,\n+                  ln: live_node,\n+                  test: fn(uint) -> live_node) {\n+        let node_base_idx = self.idx(ln, variable(0u));\n+        uint::range(0u, self.ir.num_vars) { |var_idx|\n+            let idx = node_base_idx + var_idx;\n+            if test(idx).is_valid() {\n+                wr.write_str(\" \");\n+                wr.write_str(variable(var_idx).to_str());\n+            }\n+        }\n+    }\n+\n+    fn ln_str(ln: live_node) -> str {\n+        io::with_str_writer { |wr|\n+            wr.write_str(\"[ln(\");\n+            wr.write_uint(*ln);\n+            wr.write_str(\") of kind \");\n+            wr.write_str(#fmt[\"%?\", self.ir.lnks[*ln]]);\n+            wr.write_str(\" reads\");\n+            self.write_vars(wr, ln, {|idx| self.users[idx].reader});\n+            wr.write_str(\"  writes\");\n+            self.write_vars(wr, ln, {|idx| self.users[idx].writer});\n+            wr.write_str(\" \");\n+            wr.write_str(\" precedes \");\n+            wr.write_str(self.successors[*ln].to_str());\n+            wr.write_str(\"]\");\n+        }\n+    }\n+\n+    fn init_empty(ln: live_node, succ_ln: live_node) {\n+        self.successors[*ln] = succ_ln;\n+\n+        // It is not necessary to initialize the\n+        // values to empty because this is the value\n+        // they have when they are created, and the sets\n+        // only grow during iterations.\n+        //\n+        // self.indices(ln) { |idx|\n+        //     self.users[idx] = invalid_users();\n+        // }\n+    }\n+\n+    fn init_from_succ(ln: live_node, succ_ln: live_node) {\n+        // more efficient version of init_empty() / merge_from_succ()\n+        self.successors[*ln] = succ_ln;\n+        self.indices2(ln, succ_ln) { |idx, succ_idx|\n+            self.users[idx] = self.users[succ_idx];\n+        }\n+        #debug[\"init_from_succ(ln=%s, succ=%s)\",\n+               self.ln_str(ln), self.ln_str(succ_ln)];\n+    }\n+\n+    fn merge_from_succ(ln: live_node, succ_ln: live_node,\n+                       first_merge: bool) -> bool {\n+        if ln == succ_ln { ret false; }\n+\n+        let mut changed = false;\n+        self.indices2(ln, succ_ln) { |idx, succ_idx|\n+            changed |= copy_if_invalid(self.users[succ_idx].reader,\n+                                       self.users[idx].reader);\n+            changed |= copy_if_invalid(self.users[succ_idx].writer,\n+                                       self.users[idx].writer);\n+        }\n+\n+        #debug[\"merge_from_succ(ln=%s, succ=%s, first_merge=%b, changed=%b)\",\n+               ln.to_str(), self.ln_str(succ_ln), first_merge, changed];\n+        ret changed;\n+\n+        fn copy_if_invalid(src: live_node, &dst: live_node) -> bool {\n+            if src.is_valid() {\n+                if !dst.is_valid() {\n+                    dst = src;\n+                    ret true;\n+                }\n+            }\n+            ret false;\n+        }\n+    }\n+\n+    // Indicates that a local variable was *defined*; we know that no\n+    // uses of the variable can precede the definition (resolve checks\n+    // this) so we just clear out all the data.\n+    fn define(writer: live_node, var: variable) {\n+        let idx = self.idx(writer, var);\n+        self.users[idx].reader = invalid_node();\n+        self.users[idx].writer = invalid_node();\n+\n+        #debug[\"%s defines %s (idx=%u): %s\", writer.to_str(), var.to_str(),\n+               idx, self.ln_str(writer)];\n+    }\n+\n+    // Indicates that a new value for the local variable was assigned.\n+    fn write(writer: live_node, var: variable) {\n+        let idx = self.idx(writer, var);\n+        self.users[idx].reader = invalid_node();\n+        self.users[idx].writer = writer;\n+\n+        #debug[\"%s writes %s (idx=%u): %s\", writer.to_str(), var.to_str(),\n+               idx, self.ln_str(writer)];\n+    }\n+\n+    // Indicates that the current value of the local variable was used.\n+    fn read(reader: live_node, var: variable) {\n+        let idx = self.idx(reader, var);\n+        self.users[idx].reader = reader;\n+\n+        #debug[\"%s reads %s (idx=%u): %s\", reader.to_str(), var.to_str(),\n+               idx, self.ln_str(reader)];\n+    }\n+\n+    // Either read, write, or both depending on the acc bitset\n+    fn acc(ln: live_node, var: variable, acc: uint) {\n+        if (acc & ACC_WRITE) != 0u { self.write(ln, var) }\n+\n+        // Important: if we both read/write, must do read second\n+        // or else the write will override.\n+        if (acc & ACC_READ) != 0u { self.read(ln, var) }\n+    }\n+\n+    // _______________________________________________________________________\n+\n+    fn compute(body: blk) -> live_node {\n+        // if there is a `break` or `cont` at the top level, then it's\n+        // effectively a return---this only occurs in `for` loops,\n+        // where the body is really a closure.\n+        let entry_ln: live_node =\n+            self.with_loop_nodes(self.s.exit_ln, self.s.exit_ln) {||\n+                self.propagate_through_fn_block(body)\n+            };\n+\n+        // hack to skip the loop unless #debug is enabled:\n+        #debug[\"^^ liveness computation results for body %d (entry=%s)\",\n+               {\n+                   uint::range(0u, self.ir.num_live_nodes) { |ln_idx|\n+                       #debug[\"%s\", self.ln_str(live_node(ln_idx))];\n+                   }\n+                   body.node.id\n+               },\n+               entry_ln.to_str()];\n+\n+        entry_ln\n+    }\n+\n+    fn propagate_through_fn_block(blk: blk) -> live_node {\n+        if blk.node.expr.is_none() {\n+            self.read(self.s.fallthrough_ln, self.s.no_ret_var)\n+        }\n+\n+        // in a ctor, there is an implicit use of self.f for all fields f:\n+        for self.ir.field_map.each_value { |var|\n+            self.read(self.s.fallthrough_ln, var);\n+        }\n+\n+        self.propagate_through_block(blk, self.s.fallthrough_ln)\n+    }\n+\n+    fn propagate_through_block(blk: blk, succ: live_node) -> live_node {\n+        let succ = self.propagate_through_opt_expr(blk.node.expr, succ);\n+        blk.node.stmts.foldr(succ) { |stmt, succ|\n+            self.propagate_through_stmt(stmt, succ)\n+        }\n+    }\n+\n+    fn propagate_through_stmt(stmt: @stmt, succ: live_node) -> live_node {\n+        alt stmt.node {\n+          stmt_decl(decl, _) {\n+            ret self.propagate_through_decl(decl, succ);\n+          }\n+\n+          stmt_expr(expr, _) | stmt_semi(expr, _) {\n+            ret self.propagate_through_expr(expr, succ);\n+          }\n+        }\n+    }\n+\n+    fn propagate_through_decl(decl: @decl, succ: live_node) -> live_node {\n+        alt decl.node {\n+          decl_local(locals) {\n+            locals.foldr(succ) { |local, succ|\n+                self.propagate_through_local(local, succ)\n+            }\n+          }\n+          decl_item(_) {\n+            succ\n+          }\n+        }\n+    }\n+\n+    fn propagate_through_local(local: @local, succ: live_node) -> live_node {\n+        // Note: we mark the variable as defined regardless of whether\n+        // there is an initializer.  Initially I had thought to only mark\n+        // the live variable as defined if it was initialized, and then we\n+        // could check for uninit variables just by scanning what is live\n+        // at the start of the function. But that doesn't work so well for\n+        // immutable variables defined in a loop:\n+        //     loop { let x; x = 5; }\n+        // because the \"assignment\" loops back around and generates an error.\n+        //\n+        // So now we just check that variables defined w/o an\n+        // initializer are not live at the point of their\n+        // initialization, which is mildly more complex than checking\n+        // once at the func header but otherwise equivalent.\n+\n+        let opt_init = local.node.init.map { |i| i.expr };\n+        let mut succ = self.propagate_through_opt_expr(opt_init, succ);\n+        let def_map = self.tcx.def_map;\n+        pat_util::pat_bindings(def_map, local.node.pat) { |p_id, sp, _n|\n+            let ln = self.live_node(p_id, sp);\n+            let var = self.variable(p_id, sp);\n+            self.init_from_succ(ln, succ);\n+            self.define(ln, var);\n+            succ = ln;\n+        }\n+        succ\n+    }\n+\n+    fn propagate_through_exprs(exprs: [@expr], succ: live_node) -> live_node {\n+        exprs.foldr(succ) { |expr, succ|\n+            self.propagate_through_expr(expr, succ)\n+        }\n+    }\n+\n+    fn propagate_through_opt_expr(opt_expr: option<@expr>,\n+                                  succ: live_node) -> live_node {\n+        opt_expr.foldl(succ) { |succ, expr|\n+            self.propagate_through_expr(expr, succ)\n+        }\n+    }\n+\n+    fn propagate_through_expr(expr: @expr, succ: live_node) -> live_node {\n+        alt expr.node {\n+          // Interesting cases with control flow or which gen/kill\n+\n+          expr_path(_) {\n+            self.access_path(expr, succ, ACC_READ)\n+          }\n+\n+          expr_field(e, nm, _) {\n+            // If this is a reference to `self.f` inside of a ctor,\n+            // then we treat it as a read of that variable.\n+            // Otherwise, we ignore it and just propagate down to\n+            // process `e`.\n+            alt self.as_self_field(e, nm) {\n+              some((ln, var)) {\n+                self.init_from_succ(ln, succ);\n+                self.read(ln, var);\n+                ln\n+              }\n+              none {\n+                self.propagate_through_expr(e, succ)\n+              }\n+            }\n+          }\n+\n+          expr_fn(*) | expr_fn_block(*) {\n+            // the construction of a closure itself is not important,\n+            // but we have to consider the closed over variables.\n+            let caps = (*self.ir).captures(expr);\n+            (*caps).foldr(succ) { |cap, succ|\n+                self.init_from_succ(cap.ln, succ);\n+                let var = self.variable_from_rdef(cap.rv, expr.span);\n+                self.read(cap.ln, var);\n+                cap.ln\n+            }\n+          }\n+\n+          expr_if_check(cond, then, els) |\n+          expr_if(cond, then, els) {\n+            //\n+            //     (cond)\n+            //       |\n+            //       v\n+            //     (expr)\n+            //     /   \\\n+            //    |     |\n+            //    v     v\n+            //  (then)(els)\n+            //    |     |\n+            //    v     v\n+            //   (  succ  )\n+            //\n+            let else_ln = self.propagate_through_opt_expr(els, succ);\n+            let then_ln = self.propagate_through_block(then, succ);\n+            let ln = self.live_node(expr.id, expr.span);\n+            self.init_from_succ(ln, else_ln);\n+            self.merge_from_succ(ln, then_ln, false);\n+            self.propagate_through_expr(cond, ln)\n+          }\n+\n+          expr_while(cond, blk) {\n+            self.propagate_through_loop(expr, some(cond), blk, succ)\n+          }\n+\n+          expr_loop(blk) {\n+            self.propagate_through_loop(expr, none, blk, succ)\n+          }\n+\n+          expr_alt(e, arms, _) {\n+            //\n+            //      (e)\n+            //       |\n+            //       v\n+            //     (expr)\n+            //     / | \\\n+            //    |  |  |\n+            //    v  v  v\n+            //   (..arms..)\n+            //    |  |  |\n+            //    v  v  v\n+            //   (  succ  )\n+            //\n+            //\n+            let ln = self.live_node(expr.id, expr.span);\n+            self.init_empty(ln, succ);\n+            let mut first_merge = true;\n+            for arms.each { |arm|\n+                let arm_succ =\n+                    self.propagate_through_opt_expr(\n+                        arm.guard,\n+                        self.propagate_through_block(arm.body, succ));\n+                self.merge_from_succ(ln, arm_succ, first_merge);\n+                first_merge = false;\n+            };\n+            self.propagate_through_expr(e, ln)\n+          }\n+\n+          expr_ret(o_e) | expr_fail(o_e) { // ignore succ and subst exit_ln:\n+            self.propagate_through_opt_expr(o_e, self.s.exit_ln)\n+          }\n+\n+          expr_break {\n+            if !self.break_ln.is_valid() {\n+                self.tcx.sess.span_bug(\n+                    expr.span, \"break with invalid break_ln\");\n+            }\n+\n+            self.break_ln\n+          }\n+\n+          expr_cont {\n+            if !self.cont_ln.is_valid() {\n+                self.tcx.sess.span_bug(\n+                    expr.span, \"cont with invalid cont_ln\");\n+            }\n+\n+            self.cont_ln\n+          }\n+\n+          expr_move(l, r) | expr_assign(l, r) {\n+            // see comment on lvalues in\n+            // propagate_through_lvalue_components()\n+            let succ = self.write_lvalue(l, succ, ACC_WRITE);\n+            let succ = self.propagate_through_expr(r, succ);\n+            self.propagate_through_lvalue_components(l, succ)\n+          }\n+\n+          expr_swap(l, r) {\n+            // see comment on lvalues in\n+            // propagate_through_lvalue_components()\n+            let succ = self.write_lvalue(r, succ, ACC_WRITE|ACC_READ);\n+            let succ = self.write_lvalue(l, succ, ACC_WRITE|ACC_READ);\n+            let succ = self.propagate_through_lvalue_components(r, succ);\n+            self.propagate_through_lvalue_components(l, succ)\n+          }\n+\n+          expr_assign_op(_, l, r) {\n+            // see comment on lvalues in\n+            // propagate_through_lvalue_components()\n+            let succ = self.write_lvalue(l, succ, ACC_WRITE|ACC_READ);\n+            let succ = self.propagate_through_expr(r, succ);\n+            self.propagate_through_lvalue_components(l, succ)\n+          }\n+\n+          // Uninteresting cases: just propagate in rev exec order\n+\n+          expr_vstore(expr, _) {\n+            self.propagate_through_expr(expr, succ)\n+          }\n+\n+          expr_vec(exprs, _) {\n+            self.propagate_through_exprs(exprs, succ)\n+          }\n+\n+          expr_rec(fields, with_expr) {\n+            let succ = self.propagate_through_opt_expr(with_expr, succ);\n+            fields.foldr(succ) { |field, succ|\n+                self.propagate_through_expr(field.node.expr, succ)\n+            }\n+          }\n+\n+          expr_call(f, args, _) {\n+            // calling a fn with bot return type means that the fn\n+            // will fail, and hence the successors can be ignored\n+            let t_ret = ty::ty_fn_ret(ty::expr_ty(self.tcx, f));\n+            let succ = if ty::type_is_bot(t_ret) {self.s.exit_ln}\n+                       else {succ};\n+            let succ = self.propagate_through_exprs(args, succ);\n+            self.propagate_through_expr(f, succ)\n+          }\n+\n+          expr_tup(exprs) {\n+            self.propagate_through_exprs(exprs, succ)\n+          }\n+\n+          expr_bind(f, args) {\n+            let succ = args.foldr(succ) { |arg, succ|\n+                alt arg {\n+                  none {succ}\n+                  some(e) {self.propagate_through_expr(e, succ)}\n+                }\n+            };\n+            self.propagate_through_expr(f, succ)\n+          }\n+\n+          expr_binary(op, l, r) if ast_util::lazy_binop(op) {\n+            let r_succ = self.propagate_through_expr(r, succ);\n+\n+            let ln = self.live_node(expr.id, expr.span);\n+            self.init_from_succ(ln, succ);\n+            self.merge_from_succ(ln, r_succ, false);\n+\n+            self.propagate_through_expr(l, ln)\n+          }\n+\n+          expr_new(l, _, r) |\n+          expr_log(_, l, r) |\n+          expr_index(l, r) |\n+          expr_binary(_, l, r) {\n+            self.propagate_through_exprs([l, r], succ)\n+          }\n+\n+          expr_assert(e) |\n+          expr_check(_, e) |\n+          expr_addr_of(_, e) |\n+          expr_copy(e) |\n+          expr_loop_body(e) |\n+          expr_cast(e, _) |\n+          expr_unary(_, e) {\n+            self.propagate_through_expr(e, succ)\n+          }\n+\n+          expr_lit(*) {\n+            succ\n+          }\n+\n+          expr_block(blk) {\n+            self.propagate_through_block(blk, succ)\n+          }\n+\n+          expr_mac(*) {\n+            self.tcx.sess.span_bug(expr.span, \"unexpanded macro\");\n+          }\n+        }\n+    }\n+\n+    fn propagate_through_lvalue_components(expr: @expr,\n+                                           succ: live_node) -> live_node {\n+        // # Lvalues\n+        //\n+        // In general, the full flow graph structure for an\n+        // assignment/move/etc can be handled in one of two ways,\n+        // depending on whether what is being assigned is a \"tracked\n+        // value\" or not. A tracked value is basically a local variable\n+        // or argument, or a self-field (`self.f`) in a ctor.\n+        //\n+        // The two kinds of graphs are:\n+        //\n+        //    Tracked lvalue          Untracked lvalue\n+        // ----------------------++-----------------------\n+        //                       ||\n+        //         |             ||           |\n+        //         |             ||           v\n+        //         |             ||   (lvalue components)\n+        //         |             ||           |\n+        //         v             ||           v\n+        //     (rvalue)          ||       (rvalue)\n+        //         |             ||           |\n+        //         v             ||           |\n+        // (write of lvalue)     ||           |\n+        //         |             ||           |\n+        //         v             ||           v\n+        //      (succ)           ||        (succ)\n+        //                       ||\n+        // ----------------------++-----------------------\n+        //\n+        // I will cover the two cases in turn:\n+        //\n+        // # Tracked lvalues\n+        //\n+        // A tracked lvalue is either a local variable/argument `x` or\n+        // else it is a self-field `self.f` in a constructor.  In\n+        // these cases, the link_node where the write occurs is linked\n+        // to node id of `x` or `self`, respectively.  The\n+        // `write_lvalue()` routine generates the contents of this\n+        // node.  There are no subcomponents to consider.\n+        //\n+        // # Non-tracked lvalues\n+        //\n+        // These are lvalues like `x[5]` or `x.f`.  In that case, we\n+        // basically ignore the value which is written to but generate\n+        // reads for the components---`x` in these two examples.  The\n+        // components reads are generated by\n+        // `propagate_through_lvalue_components()` (this fn).\n+        //\n+        // # Illegal lvalues\n+        //\n+        // It is still possible to observe assignments to non-lvalues;\n+        // these errors are detected in the later pass borrowck.  We\n+        // just ignore such cases and treat them as reads.\n+\n+        alt expr.node {\n+          expr_path(_) {\n+            succ\n+          }\n+\n+          expr_field(e, nm, _) {\n+            alt self.as_self_field(e, nm) {\n+              some(_) {succ}\n+              none {self.propagate_through_expr(e, succ)}\n+            }\n+          }\n+\n+          _ {\n+            self.propagate_through_expr(expr, succ)\n+          }\n+        }\n+    }\n+\n+    // see comment on propagate_through_lvalue()\n+    fn write_lvalue(expr: @expr,\n+                    succ: live_node,\n+                    acc: uint) -> live_node {\n+        alt expr.node {\n+          expr_path(_) {\n+            self.access_path(expr, succ, acc)\n+          }\n+\n+          expr_field(e, nm, _) {\n+            alt self.as_self_field(e, nm) {\n+              some((ln, var)) {\n+                self.init_from_succ(ln, succ);\n+                self.acc(ln, var, acc);\n+                ln\n+              }\n+              none {\n+                succ\n+              }\n+            }\n+          }\n+\n+          // We do not track other lvalues, so just propagate through\n+          // to their subcomponents.  Also, it may happen that\n+          // non-lvalues occur here, because those are detected in the\n+          // later pass borrowck.\n+          _ {succ}\n+        }\n+    }\n+\n+    fn access_path(expr: @expr, succ: live_node, acc: uint) -> live_node {\n+        let def = self.tcx.def_map.get(expr.id);\n+        alt relevant_def(def) {\n+          some(rdef_self) {\n+            // Accessing `self` is like accessing every field of\n+            // the current object. This allows something like\n+            // `self = ...;` (it will be considered a write to\n+            // every field, sensibly enough), though the borrowck\n+            // pass will reject it later on.\n+            //\n+            // Also, note that, within a ctor at least, an\n+            // expression like `self.f` is \"shortcircuiting\"\n+            // before it reaches this point by the code for\n+            // expr_field.\n+            let ln = self.live_node(expr.id, expr.span);\n+            if acc != 0u {\n+                self.init_from_succ(ln, succ);\n+                for self.ir.field_map.each_value { |var|\n+                    self.acc(ln, var, acc);\n+                }\n+            }\n+            ln\n+          }\n+          some(rdef_var(nid)) {\n+            let ln = self.live_node(expr.id, expr.span);\n+            if acc != 0u {\n+                self.init_from_succ(ln, succ);\n+                let var = self.variable(nid, expr.span);\n+                self.acc(ln, var, acc);\n+            }\n+            ln\n+          }\n+          none {\n+            succ\n+          }\n+        }\n+    }\n+\n+    fn as_self_field(expr: @expr, fld: str) -> option<(live_node,variable)> {\n+        // If we checking a constructor, then we treat self.f as a\n+        // variable.  we use the live_node id that will be assigned to\n+        // the reference to self but the variable id for `f`.\n+        alt expr.node {\n+          expr_path(_) {\n+            let def = self.tcx.def_map.get(expr.id);\n+            alt def {\n+              def_self(_) {\n+                // Note: the field_map is empty unless we are in a ctor\n+                ret self.ir.field_map.find(fld).map { |var|\n+                    let ln = self.live_node(expr.id, expr.span);\n+                    (ln, var)\n+                };\n+              }\n+              _ { ret none; }\n+            }\n+          }\n+          _ { ret none; }\n+        }\n+    }\n+\n+    fn propagate_through_loop(expr: @expr,\n+                              cond: option<@expr>,\n+                              body: blk,\n+                              succ: live_node) -> live_node {\n+\n+        /*\n+\n+        We model control flow like this:\n+\n+              (cond) <--+\n+                |       |\n+                v       |\n+          +-- (expr)    |\n+          |     |       |\n+          |     v       |\n+          |   (body) ---+\n+          |\n+          |\n+          v\n+        (succ)\n+\n+        */\n+\n+        // first iteration:\n+        let mut first_merge = true;\n+        let ln = self.live_node(expr.id, expr.span);\n+        self.init_empty(ln, succ);\n+        if cond.is_some() {\n+            // if there is a condition, then it's possible we bypass\n+            // the body altogether.  otherwise, the only way is via a\n+            // break in the loop body.\n+            self.merge_from_succ(ln, succ, first_merge);\n+            first_merge = false;\n+        }\n+        let cond_ln = self.propagate_through_opt_expr(cond, ln);\n+        let body_ln = self.with_loop_nodes(succ, ln) {||\n+            self.propagate_through_block(body, cond_ln)\n+        };\n+\n+        // repeat until fixed point is reached:\n+        while self.merge_from_succ(ln, body_ln, first_merge) {\n+            first_merge = false;\n+            assert cond_ln == self.propagate_through_opt_expr(cond, ln);\n+            assert body_ln == self.with_loop_nodes(succ, ln) {||\n+                self.propagate_through_block(body, cond_ln)\n+            };\n+        }\n+\n+        cond_ln\n+    }\n+\n+    fn with_loop_nodes<R>(break_ln: live_node,\n+                          cont_ln: live_node,\n+                          f: fn() -> R) -> R {\n+        let bl = self.break_ln, cl = self.cont_ln;\n+        self.break_ln = break_ln;\n+        self.cont_ln = cont_ln;\n+        let r <- f();\n+        self.break_ln = bl;\n+        self.cont_ln = cl;\n+        ret r;\n+    }\n+}\n+\n+// _______________________________________________________________________\n+// Checking for error conditions\n+\n+fn check_local(local: @local, &&self: @liveness, vt: vt<@liveness>) {\n+    alt local.node.init {\n+      some({op: init_move, expr: expr}) {\n+        // can never be accessed uninitialized, but the move might\n+        // be invalid\n+        #debug[\"check_local() with move initializer\"];\n+        self.check_move_from_expr(expr, vt);\n+      }\n+      some({op: init_op, expr: _}) {\n+        // can never be accessed uninitialized\n+        #debug[\"check_local() with initializer\"];\n+      }\n+      none {\n+        #debug[\"check_local() with no initializer\"];\n+        let def_map = self.tcx.def_map;\n+        pat_util::pat_bindings(def_map, local.node.pat) {|p_id, sp, _n|\n+            let ln = (*self).live_node(p_id, sp);\n+            let var = (*self).variable(p_id, sp);\n+            alt (*self).live_on_exit(ln, var) {\n+              none { /* not live: good */ }\n+              some(lnk) {\n+                self.report_illegal_read(\n+                    local.span, lnk, var, possibly_uninitialized_variable);\n+              }\n+            }\n+        }\n+      }\n+    }\n+\n+    visit::visit_local(local, self, vt);\n+}\n+\n+fn check_expr(expr: @expr, &&self: @liveness, vt: vt<@liveness>) {\n+    alt expr.node {\n+      expr_path(_) {\n+        for (*self).variable_from_def_map(expr.id, expr.span).each { |var|\n+            let ln = (*self).live_node(expr.id, expr.span);\n+            self.consider_last_use(expr, ln, var);\n+        }\n+\n+        visit::visit_expr(expr, self, vt);\n+      }\n+\n+      expr_fn(_, _, _, cap_clause) | expr_fn_block(_, _, cap_clause) {\n+        let caps = (*self.ir).captures(expr);\n+        for (*caps).each { |cap|\n+            let var = (*self).variable_from_rdef(cap.rv, expr.span);\n+            self.consider_last_use(expr, cap.ln, var);\n+            if cap.is_move {\n+                self.check_move_from_var(expr.span, cap.ln, var);\n+            }\n+        }\n+\n+        visit::visit_expr(expr, self, vt);\n+      }\n+\n+      expr_assign(l, r) {\n+        self.check_lvalue(l, vt);\n+        vt.visit_expr(r, self, vt);\n+      }\n+\n+      expr_move(l, r) {\n+        self.check_lvalue(l, vt);\n+        self.check_move_from_expr(r, vt);\n+      }\n+\n+      expr_call(f, args, _) {\n+        let targs = ty::ty_fn_args(ty::expr_ty(self.tcx, f));\n+        vt.visit_expr(f, self, vt);\n+        vec::iter2(args, targs) { |arg_expr, arg_ty|\n+            alt ty::resolved_mode(self.tcx, arg_ty.mode) {\n+              by_val | by_ref | by_mutbl_ref | by_copy {\n+                vt.visit_expr(arg_expr, self, vt);\n+              }\n+              by_move {\n+                self.check_move_from_expr(arg_expr, vt);\n+              }\n+            }\n+        }\n+      }\n+\n+      // no correctness conditions related to liveness\n+      expr_if_check(*) | expr_if(*) | expr_alt(*) |\n+      expr_while(*) | expr_loop(*) |\n+      expr_index(*) | expr_field(*) | expr_vstore(*) |\n+      expr_vec(*) | expr_rec(*) | expr_tup(*) |\n+      expr_bind(*) | expr_new(*) | expr_log(*) | expr_binary(*) |\n+      expr_assert(*) | expr_check(*) | expr_addr_of(*) | expr_copy(*) |\n+      expr_loop_body(*) | expr_cast(*) | expr_unary(*) | expr_fail(*) |\n+      expr_ret(*) | expr_break | expr_cont | expr_lit(_) |\n+      expr_block(*) | expr_swap(*) | expr_assign_op(*) | expr_mac(*) {\n+        visit::visit_expr(expr, self, vt);\n+      }\n+    }\n+}\n+\n+fn check_fn(_fk: visit::fn_kind, _decl: fn_decl,\n+            _body: blk, _sp: span, _id: node_id,\n+            &&_self: @liveness, _v: vt<@liveness>) {\n+    // do not check contents of nested fns\n+}\n+\n+enum read_kind {\n+    possibly_uninitialized_variable,\n+    possibly_uninitialized_field,\n+    moved_variable\n+}\n+\n+impl check_methods for @liveness {\n+    fn check_fields(sp: span, entry_ln: live_node) {\n+        for self.ir.field_map.each { |nm, var|\n+            alt (*self).live_on_entry(entry_ln, var) {\n+              none { /* ok */ }\n+              some(lnk_exit) {\n+                self.tcx.sess.span_err(\n+                    sp, #fmt[\"field `self.%s` is never initialized\", nm]);\n+              }\n+              some(lnk) {\n+                self.report_illegal_read(\n+                    sp, lnk, var, possibly_uninitialized_field);\n+              }\n+            }\n+        }\n+    }\n+\n+    fn check_ret(id: node_id, sp: span, fk: visit::fn_kind,\n+                 entry_ln: live_node) {\n+        if (*self).live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n+            // if no_ret_var is live, then we fall off the end of the\n+            // function without any kind of return expression:\n+\n+            let t_ret = ty::ty_fn_ret(ty::node_id_to_type(self.tcx, id));\n+            if ty::type_is_nil(t_ret) {\n+                // for nil return types, it is ok to not return a value expl.\n+            } else if ty::type_is_bot(t_ret) {\n+                // for bot return types, not ok.  Function should fail.\n+                self.tcx.sess.span_err(\n+                    sp, \"some control paths may return\");\n+            } else {\n+                alt fk {\n+                  visit::fk_ctor(*) {\n+                    // ctors are written as though they are unit.\n+                  }\n+                  _ {\n+                    self.tcx.sess.span_err(\n+                        sp, \"not all control paths return a value\");\n+                  }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_move_from_var(span: span, ln: live_node, var: variable) {\n+        #debug[\"check_move_from_var(%s, %s)\",\n+               ln.to_str(), var.to_str()];\n+\n+        alt (*self).live_on_exit(ln, var) {\n+          none {}\n+          some(lnk) {\n+            self.report_illegal_read(span, lnk, var, moved_variable);\n+            self.tcx.sess.span_note(\n+                span,\n+                \"move of variable occurred here\");\n+          }\n+        }\n+    }\n+\n+    fn consider_last_use(expr: @expr, ln: live_node, var: variable) {\n+        alt (*self).live_on_exit(ln, var) {\n+          some(_) {}\n+          none {\n+            (*self.ir).add_last_use(expr.id, var);\n+          }\n+       }\n+    }\n+\n+    fn check_move_from_expr(expr: @expr, vt: vt<@liveness>) {\n+        #debug[\"check_move_from_expr(node %d: %s)\",\n+               expr.id, expr_to_str(expr)];\n+\n+        if self.ir.method_map.contains_key(expr.id) {\n+            // actually an rvalue, since this calls a method\n+            ret vt.visit_expr(expr, self, vt);\n+        }\n+\n+        alt expr.node {\n+          expr_path(_) {\n+            let def = self.tcx.def_map.get(expr.id);\n+            alt relevant_def(def) {\n+              some(rdef) {\n+                // Moving from a variable is allowed if is is not live.\n+                let ln = (*self).live_node(expr.id, expr.span);\n+                let var = (*self).variable_from_rdef(rdef, expr.span);\n+                self.check_move_from_var(expr.span, ln, var);\n+              }\n+              none {}\n+            }\n+          }\n+\n+          expr_field(base, _, _) {\n+            // Moving from x.y is allowed if x is never used later.\n+            // (Note that the borrowck guarantees that anything\n+            //  being moved from is uniquely tied to the stack frame)\n+            self.check_move_from_expr(base, vt);\n+          }\n+\n+          expr_index(base, idx) {\n+            // Moving from x[y] is allowed if x is never used later.\n+            // (Note that the borrowck guarantees that anything\n+            //  being moved from is uniquely tied to the stack frame)\n+            self.check_move_from_expr(base, vt);\n+            vt.visit_expr(idx, self, vt);\n+          }\n+\n+          _ {\n+            // For other kinds of lvalues, no checks are required,\n+            // and any embedded expressions are actually rvalues\n+            vt.visit_expr(expr, self, vt);\n+          }\n+       }\n+    }\n+\n+    fn check_lvalue(expr: @expr, vt: vt<@liveness>) {\n+        alt expr.node {\n+          expr_path(_) {\n+            alt self.tcx.def_map.get(expr.id) {\n+              def_local(nid, false) {\n+                // Assignment to an immutable variable or argument:\n+                // only legal if there is no later assignment.\n+                let ln = (*self).live_node(expr.id, expr.span);\n+                let var = (*self).variable(nid, expr.span);\n+                alt (*self).assigned_on_exit(ln, var) {\n+                  some(lnk_expr(span)) {\n+                    self.tcx.sess.span_err(\n+                        span,\n+                        \"re-assignment of immutable variable\");\n+\n+                    self.tcx.sess.span_note(\n+                        expr.span,\n+                        \"prior assignment occurs here\");\n+                  }\n+                  some(lnk) {\n+                    self.tcx.sess.span_bug(\n+                        expr.span,\n+                        #fmt[\"illegal writer: %?\", lnk]);\n+                   }\n+                  none {}\n+                }\n+              }\n+              def_arg(*) | def_local(_, true) {\n+                // Assignment to a mutable variable; no conditions\n+                // req'd.  In the case of arguments, the mutability is\n+                // enforced by borrowck.\n+              }\n+              _ {\n+                // Not a variable, don't care\n+              }\n+            }\n+          }\n+\n+          _ {\n+            // For other kinds of lvalues, no checks are required,\n+            // and any embedded expressions are actually rvalues\n+            visit::visit_expr(expr, self, vt);\n+          }\n+       }\n+    }\n+\n+    fn report_illegal_read(chk_span: span,\n+                           lnk: live_node_kind,\n+                           var: variable,\n+                           rk: read_kind) {\n+        let msg = alt rk {\n+          possibly_uninitialized_variable {\"possibly uninitialized variable\"}\n+          possibly_uninitialized_field {\"possibly uninitialized field\"}\n+          moved_variable {\"moved variable\"}\n+        };\n+        let name = self.ir.var_infos[*var].name;\n+        alt lnk {\n+          lnk_freevar(span) {\n+            self.tcx.sess.span_err(\n+                span,\n+                #fmt[\"capture of %s: `%s`\", msg, name]);\n+          }\n+          lnk_expr(span) {\n+            self.tcx.sess.span_err(\n+                span,\n+                #fmt[\"use of %s: `%s`\", msg, name]);\n+          }\n+          lnk_exit | lnk_vdef(_) {\n+            self.tcx.sess.span_bug(\n+                chk_span,\n+                #fmt[\"illegal reader: %?\", lnk]);\n+          }\n+        }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "4ba01859cdd546e5ef02edb0f1444aa421ea364d", "filename": "src/rustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Frustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Frustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rc?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -72,6 +72,7 @@ mod middle {\n     mod borrowck;\n     mod alias;\n     mod last_use;\n+    mod liveness;\n     mod block_use;\n     mod kind;\n     mod freevars;"}, {"sha": "c053180bf438cac9fab851d2eb7de92c3b1aa689", "filename": "src/test/compile-fail/and-init.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Fand-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Fand-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fand-init.rs?ref=a3be0b105436118e187ea52deb89788afaf1edb5", "patch": "@@ -1,8 +0,0 @@\n-// error-pattern:unsatisfied precondition constraint (for example, init(i\n-\n-fn main() {\n-    let i: int;\n-\n-    log(debug, false && { i = 5; true });\n-    log(debug, i);\n-}"}, {"sha": "13ec17e05856bdd56fa1291fa32642775c50a737", "filename": "src/test/compile-fail/assign-imm-local-twice.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fassign-imm-local-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fassign-imm-local-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassign-imm-local-twice.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,9 @@\n+fn test(cond: bool) {\n+    let v: int;\n+    v = 1; //! NOTE prior assignment occurs here\n+    v = 2; //! ERROR re-assignment of immutable variable\n+}\n+\n+fn main() {\n+    test(true);\n+}"}, {"sha": "99b8346166a16f3b65716d5bf4dcaa0ab375cb07", "filename": "src/test/compile-fail/block-uninit.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Fblock-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Fblock-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-uninit.rs?ref=a3be0b105436118e187ea52deb89788afaf1edb5", "patch": "@@ -1,4 +0,0 @@\n-// error-pattern:unsatisfied precondition constraint\n-\n-fn force(f: fn()) { f(); }\n-fn main() { let x: int; force(fn&() { log(error, x); }); }"}, {"sha": "8babc95f0dcc4d1360fda44d9e97638afae1e389", "filename": "src/test/compile-fail/break-uninit.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Fbreak-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Fbreak-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbreak-uninit.rs?ref=a3be0b105436118e187ea52deb89788afaf1edb5", "patch": "@@ -1,14 +0,0 @@\n-// error-pattern:unsatisfied precondition\n-\n-fn foo() -> int {\n-    let x: int;\n-    let i: int;\n-\n-    loop { i = 0; break; x = 0; }\n-\n-    log(debug, x);\n-\n-    ret 17;\n-}\n-\n-fn main() { log(debug, foo()); }"}, {"sha": "1229e0dc0ee8f1cf36fb4add0f589e71755a8ada", "filename": "src/test/compile-fail/break-uninit2.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Fbreak-uninit2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Fbreak-uninit2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbreak-uninit2.rs?ref=a3be0b105436118e187ea52deb89788afaf1edb5", "patch": "@@ -1,14 +0,0 @@\n-// error-pattern:unsatisfied precondition\n-\n-fn foo() -> int {\n-    let x: int;\n-    let i: int;\n-\n-    while 1 != 2  { i = 0; break; x = 0; }\n-\n-    log(debug, x);\n-\n-    ret 17;\n-}\n-\n-fn main() { log(debug, foo()); }"}, {"sha": "ab3f1dd1087e7db37bf236d0c8f08a7e40a8ca46", "filename": "src/test/compile-fail/fn-expr-type-state.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Ffn-expr-type-state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Ffn-expr-type-state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-expr-type-state.rs?ref=a3be0b105436118e187ea52deb89788afaf1edb5", "patch": "@@ -1,7 +0,0 @@\n-// error-pattern:unsatisfied precondition\n-\n-fn main() {\n-    // Typestate should work even in a fn@. we should reject this program.\n-    let f = fn@() -> int { let i: int; ret i; };\n-    log(error, f());\n-}"}, {"sha": "75682c8ddf8fd1a337658fbe59083bb002d4c826", "filename": "src/test/compile-fail/fn-expr-typestate-2.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Ffn-expr-typestate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Ffn-expr-typestate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-expr-typestate-2.rs?ref=a3be0b105436118e187ea52deb89788afaf1edb5", "patch": "@@ -1,6 +0,0 @@\n-// error-pattern:unsatisfied precondition\n-\n-fn main() {\n-    let j = fn@() -> int { let i: int; ret i; }();\n-    log(error, j);\n-}"}, {"sha": "447f6f44dc57011bf914ff75bf3e43bc4a53a209", "filename": "src/test/compile-fail/fru-typestate.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Ffru-typestate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Ffru-typestate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffru-typestate.rs?ref=a3be0b105436118e187ea52deb89788afaf1edb5", "patch": "@@ -1,12 +0,0 @@\n-// -*- rust -*-\n-\n-// error-pattern: precondition\n-\n-type point = {x: int, y: int};\n-\n-fn main() {\n-    let origin: point;\n-\n-    let right: point = {x: 10 with origin};\n-    origin = {x: 0, y: 0};\n-}"}, {"sha": "15b3d6d96c7ed7f157a09cef7afb2c2ed6caa6d0", "filename": "src/test/compile-fail/issue-2163.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Fissue-2163.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Fissue-2163.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2163.rs?ref=a3be0b105436118e187ea52deb89788afaf1edb5", "patch": "@@ -1,5 +0,0 @@\n-fn main(s: [str]) {\n-    let a: [int] = [];\n-    vec::each(a) { |x| //! ERROR in function `anon`, not all control paths\n-    }                  //! ERROR see function return type of `bool`\n-}"}, {"sha": "aea30e3465c6d5a2a172df5790fab02322d37302", "filename": "src/test/compile-fail/liveness-and-init.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-and-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-and-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-and-init.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    let i: int;\n+\n+    log(debug, false && { i = 5; true });\n+    log(debug, i); //! ERROR use of possibly uninitialized variable: `i`\n+}"}, {"sha": "a68528418e6d6d3ceb61ef00782015b90a064a1b", "filename": "src/test/compile-fail/liveness-assign-imm-local-in-loop.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-loop.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,11 @@\n+fn test(cond: bool) {\n+    let v: int;\n+    loop {\n+        v = 1; //! ERROR re-assignment of immutable variable\n+        //!^ NOTE prior assignment occurs here\n+    }\n+}\n+\n+fn main() {\n+    test(true);\n+}"}, {"sha": "2f880e03c74f3325f54a0a7a3038e8c8313796c8", "filename": "src/test/compile-fail/liveness-assign-imm-local-in-op-eq.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-op-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-op-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-op-eq.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,9 @@\n+fn test(cond: bool) {\n+    let v: int;\n+    v = 2;  //! NOTE prior assignment occurs here\n+    v += 1; //! ERROR re-assignment of immutable variable\n+}\n+\n+fn main() {\n+    test(true);\n+}"}, {"sha": "c432d03bed36c9fd661a0c247deb5fd7741c2e40", "filename": "src/test/compile-fail/liveness-assign-imm-local-in-swap.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-swap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-swap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-assign-imm-local-in-swap.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,18 @@\n+fn test1() {\n+    let v: int;\n+    let mut w: int;\n+    v = 1; //! NOTE prior assignment occurs here\n+    w = 2;\n+    v <-> w; //! ERROR re-assignment of immutable variable\n+}\n+\n+fn test2() {\n+    let v: int;\n+    let mut w: int;\n+    v = 1; //! NOTE prior assignment occurs here\n+    w = 2;\n+    w <-> v; //! ERROR re-assignment of immutable variable\n+}\n+\n+fn main() {\n+}"}, {"sha": "8fb6a9e873705df230ffdc1131a7b29862139e2f", "filename": "src/test/compile-fail/liveness-bad-bang-2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-bad-bang-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-bad-bang-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-bad-bang-2.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "previous_filename": "src/test/compile-fail/bad-bang-ann-2.rs"}, {"sha": "698f9f7cf7925c1a22c18f2f7c6032a4405819ff", "filename": "src/test/compile-fail/liveness-block-unint.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-block-unint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-block-unint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-block-unint.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,7 @@\n+fn force(f: fn()) { f(); }\n+fn main() {\n+    let x: int;\n+    force(fn&() {\n+        log(debug, x); //! ERROR capture of possibly uninitialized variable: `x`\n+    });\n+}"}, {"sha": "30038dbe96ebd047bbc20a3c6edc9e6229737ae9", "filename": "src/test/compile-fail/liveness-break-uninit-2.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-break-uninit-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-break-uninit-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-break-uninit-2.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,16 @@\n+fn foo() -> int {\n+    let x: int;\n+    let i: int;\n+\n+    while 1 != 2  {\n+        i = 0;\n+        break;\n+        x = 0; //! WARNING unreachable statement\n+    }\n+\n+    log(debug, x); //! ERROR use of possibly uninitialized variable: `x`\n+\n+    ret 17;\n+}\n+\n+fn main() { log(debug, foo()); }"}, {"sha": "55041daa7fb95877f6ddeaf5618ab9f96d1c2f9b", "filename": "src/test/compile-fail/liveness-break-uninit.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-break-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-break-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-break-uninit.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,16 @@\n+fn foo() -> int {\n+    let x: int;\n+    let i: int;\n+\n+    loop {\n+        i = 0;\n+        break;\n+        x = 0;  //! WARNING unreachable statement\n+    }\n+\n+    log(debug, x); //! ERROR use of possibly uninitialized variable: `x`\n+\n+    ret 17;\n+}\n+\n+fn main() { log(debug, foo()); }"}, {"sha": "6a05ccf0605eeb9c519ff55c600a8cc6a42ec032", "filename": "src/test/compile-fail/liveness-closure-require-ret.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-closure-require-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-closure-require-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-closure-require-ret.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "previous_filename": "src/test/compile-fail/block-require-return.rs"}, {"sha": "9c98229281612090e03be3633516618308f1c024", "filename": "src/test/compile-fail/liveness-ctor-access-self-with-uninit-fields.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-ctor-access-self-with-uninit-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-ctor-access-self-with-uninit-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-ctor-access-self-with-uninit-fields.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,11 @@\n+class cat {\n+  let how_hungry : int;\n+  fn meow() {}\n+  new() {\n+     self.meow();\n+     //!^ ERROR use of possibly uninitialized field: `self.how_hungry`\n+  }\n+}\n+\n+fn main() {\n+}"}, {"sha": "b979bdd9255d8c22629a719f7e6e4d1b656d1de1", "filename": "src/test/compile-fail/liveness-ctor-field-never-init.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-ctor-field-never-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-ctor-field-never-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-ctor-field-never-init.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,7 @@\n+class cat {\n+  let how_hungry : int;\n+  new() {} //! ERROR field `self.how_hungry` is never initialized\n+}\n+\n+fn main() {\n+}"}, {"sha": "080d4678a2f1eaed9d165dea313125356f14a4e0", "filename": "src/test/compile-fail/liveness-ctor-uninit-field.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-ctor-uninit-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-ctor-uninit-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-ctor-uninit-field.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,14 @@\n+class cat {\n+  let mut a: int;\n+  let mut b: int;\n+  let mut c: int;\n+\n+  new() {\n+     self.a = 3;\n+     self.b = self.a;\n+     self.a += self.c; //! ERROR use of possibly uninitialized field: `self.c`\n+  }\n+}\n+\n+fn main() {\n+}"}, {"sha": "3bbccd62ae3e7acba3156280b506a3da19fd8445", "filename": "src/test/compile-fail/liveness-ctor-uninit-var.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-ctor-uninit-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-ctor-uninit-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-ctor-uninit-var.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -1,4 +1,3 @@\n-// error-pattern:unsatisfied precondition\n class cat {\n   priv {\n     let mut meows : uint;\n@@ -13,7 +12,7 @@ class cat {\n   new(in_x : uint, in_y : int) {\n     let foo;\n     self.meows = in_x + (in_y as uint);\n-    self.how_hungry = foo;\n+    self.how_hungry = foo; //! ERROR use of possibly uninitialized variable: `foo`\n   }\n }\n ", "previous_filename": "src/test/compile-fail/ctor-uninit-var.rs"}, {"sha": "4d78b7a7aff91e7036d66545322c99d1565d09c5", "filename": "src/test/compile-fail/liveness-forgot-ret.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-forgot-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-forgot-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-forgot-ret.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "previous_filename": "src/test/compile-fail/forgot-ret.rs"}, {"sha": "5cbd24a6a5b29fa7fe5062070c9df19ba0c5d1f4", "filename": "src/test/compile-fail/liveness-if-no-else.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-if-no-else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-if-no-else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-if-no-else.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,6 @@\n+fn foo(x: int) { log(debug, x); }\n+\n+fn main() {\n+\tlet x: int; if 1 > 2 { x = 10; }\n+\tfoo(x); //! ERROR use of possibly uninitialized variable: `x`\n+}"}, {"sha": "dbb3e6b164546f48b072034aaa0b95948a874d21", "filename": "src/test/compile-fail/liveness-if-with-else.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-if-with-else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-if-with-else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-if-with-else.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -1,5 +1,3 @@\n-// error-pattern:unsatisfied precondition\n-\n fn foo(x: int) { log(debug, x); }\n \n fn main() {\n@@ -9,5 +7,5 @@ fn main() {\n     } else {\n         x = 10;\n     }\n-    foo(x);\n+    foo(x); //! ERROR use of possibly uninitialized variable: `x`\n }", "previous_filename": "src/test/compile-fail/use-uninit-3.rs"}, {"sha": "28351ceeb08cdb47e69d7dcaf4db16581247eb74", "filename": "src/test/compile-fail/liveness-init-in-called-fn-expr.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-init-in-called-fn-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-init-in-called-fn-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-init-in-called-fn-expr.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    let j = fn@() -> int {\n+        let i: int;\n+        ret i; //! ERROR use of possibly uninitialized variable: `i`\n+    };\n+    j();\n+}"}, {"sha": "8c68ba750a8a12d6a58719424e44ebd1b5c873ab", "filename": "src/test/compile-fail/liveness-init-in-fn-expr.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-init-in-fn-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-init-in-fn-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-init-in-fn-expr.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    let f = fn@() -> int {\n+        let i: int;\n+        ret i; //! ERROR use of possibly uninitialized variable: `i`\n+    };\n+    log(error, f());\n+}"}, {"sha": "1c17a2503dcaba8676064a74194aca3226573857", "filename": "src/test/compile-fail/liveness-init-in-fru.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-init-in-fru.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-init-in-fru.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-init-in-fru.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,8 @@\n+// -*- rust -*-\n+\n+type point = {x: int, y: int};\n+\n+fn main() {\n+    let mut origin: point;\n+    origin = {x: 10 with origin}; //! ERROR use of possibly uninitialized variable: `origin`\n+}"}, {"sha": "2f37dc5070f386f5a595046479aa07aabc7f586b", "filename": "src/test/compile-fail/liveness-init-op-equal.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-init-op-equal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-init-op-equal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-init-op-equal.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,8 @@\n+fn test(cond: bool) {\n+    let v: int;\n+    v += 1; //! ERROR use of possibly uninitialized variable: `v`\n+}\n+\n+fn main() {\n+    test(true);\n+}"}, {"sha": "56c5b3b2717c026ccc7aebac4bee1e582fe4aa02", "filename": "src/test/compile-fail/liveness-init-plus-equal.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-init-plus-equal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-init-plus-equal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-init-plus-equal.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,8 @@\n+fn test(cond: bool) {\n+    let mut v: int;\n+    v = v + 1; //! ERROR use of possibly uninitialized variable: `v`\n+}\n+\n+fn main() {\n+    test(true);\n+}"}, {"sha": "dea27e585ef06c3fb9ce49decf4eab424b6f3acf", "filename": "src/test/compile-fail/liveness-issue-2163.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,5 @@\n+fn main(s: [str]) {\n+    let a: [int] = [];\n+    vec::each(a) { |x| //! ERROR not all control paths return a value\n+    }\n+}"}, {"sha": "54d8de63014e20d4807ed72e2e0cc61f60a9dd4c", "filename": "src/test/compile-fail/liveness-missing-ret2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-missing-ret2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-missing-ret2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-missing-ret2.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "previous_filename": "src/test/compile-fail/missing-return2.rs"}, {"sha": "01483f033eb0f0565f2315931c1685e7ccb2b639", "filename": "src/test/compile-fail/liveness-move-from-mode.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-move-from-mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-move-from-mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-move-from-mode.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,10 @@\n+fn take(-x: int) {}\n+\n+fn main() {\n+\n+    let x: int = 25;\n+    loop {\n+        take(x); //! ERROR use of moved variable: `x`\n+        //!^ NOTE move of variable occurred here\n+    }\n+}"}, {"sha": "81467d8a2b4e10419a5fefab27c597ef35241fb9", "filename": "src/test/compile-fail/liveness-move-in-loop.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-loop.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,16 @@\n+fn main() {\n+\n+    let y: int = 42;\n+    let mut x: int;\n+    loop {\n+        log(debug, y);\n+        loop {\n+            loop {\n+                loop {\n+                    x <- y; //! ERROR use of moved variable\n+                    //!^ NOTE move of variable occurred here\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "6acbc5a9f359a8c9f135669785e776772a95eda4", "filename": "src/test/compile-fail/liveness-move-in-while.rs", "status": "renamed", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-while.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -1,10 +1,11 @@\n-// error-pattern:unsatisfied precondition constraint (for example, init(y\n fn main() {\n \n     let y: int = 42;\n-    let x: int;\n+    let mut x: int;\n     loop {\n         log(debug, y);\n         while true { while true { while true { x <- y; } } }\n+        //!^ ERROR use of moved variable: `y`\n+        //!^^ NOTE move of variable occurred here\n     }\n }", "previous_filename": "src/test/compile-fail/while-constraints.rs"}, {"sha": "5912378cf42516362c862f0e77c80dfe4a3548e0", "filename": "src/test/compile-fail/liveness-or-init.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-or-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-or-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-or-init.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    let i: int;\n+\n+    log(debug, false || { i = 5; true });\n+    log(debug, i); //! ERROR use of possibly uninitialized variable: `i`\n+}"}, {"sha": "cee1444ca630ae0d46a986ce35527a8e8598b3a5", "filename": "src/test/compile-fail/liveness-return.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-return.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,6 @@\n+fn f() -> int {\n+\tlet x: int;\n+\tret x; //! ERROR use of possibly uninitialized variable: `x`\n+}\n+\n+fn main() { f(); }"}, {"sha": "53714c1f740c7ae7f7e56a715708704f92beebe7", "filename": "src/test/compile-fail/liveness-swap-uninit.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-swap-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-swap-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-swap-uninit.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+\tlet x = 3;\n+\tlet y;\n+\tx <-> y; //! ERROR use of possibly uninitialized variable: `y`\n+}"}, {"sha": "7c619804c3c9a7ad529cad274e92ad9ea9553eb9", "filename": "src/test/compile-fail/liveness-uninit-after-item.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-uninit-after-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-uninit-after-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-uninit-after-item.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    let bar;\n+    fn baz(x: int) { }\n+    bind baz(bar); //! ERROR use of possibly uninitialized variable: `bar`\n+}\n+"}, {"sha": "1930a2e33526779ea7ef092695bcb18340d7979b", "filename": "src/test/compile-fail/liveness-uninit.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-uninit.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,6 @@\n+fn foo(x: int) { log(debug, x); }\n+\n+fn main() {\n+\tlet x: int;\n+\tfoo(x); //! ERROR use of possibly uninitialized variable: `x`\n+}"}, {"sha": "48d7a9a303e1e927414d93dfe8d577d2105288d3", "filename": "src/test/compile-fail/liveness-use-after-move.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-move.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    let x = @5;\n+    let y <- x; //! NOTE move of variable occurred here\n+    log(debug, *x); //! ERROR use of moved variable: `x`\n+}"}, {"sha": "63e42bee3c9b429310a91da5142befb714c36dba", "filename": "src/test/compile-fail/liveness-use-after-send.rs", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -1,4 +1,3 @@\n-// error-pattern:unsatisfied precondition constraint\n fn send<T: send>(ch: _chan<T>, -data: T) {\n     log(debug, ch);\n     log(debug, data);\n@@ -10,8 +9,8 @@ enum _chan<T> = int;\n // Tests that \"log(debug, message);\" is flagged as using\n // message after the send deinitializes it\n fn test00_start(ch: _chan<int>, message: int, count: int) {\n-    send(ch, message);\n-    log(debug, message);\n+    send(ch, message); //! NOTE move of variable occurred here\n+    log(debug, message); //! ERROR use of moved variable: `message`\n }\n \n fn main() { fail; }", "previous_filename": "src/test/compile-fail/use-after-send.rs"}, {"sha": "50d0662f803775b93e393fb5445292abf724b1d3", "filename": "src/test/compile-fail/liveness-use-in-index-lvalue.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-use-in-index-lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-use-in-index-lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-use-in-index-lvalue.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,6 @@\n+fn test() {\n+    let w: [int];\n+    w[5] = 0; //! ERROR use of possibly uninitialized variable: `w`\n+}\n+\n+fn main() { test(); }"}, {"sha": "755deb31fbafceb6130b55d12472212cee0f939b", "filename": "src/test/compile-fail/liveness-while-break.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-while-break.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-while-break.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-while-break.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,12 @@\n+fn test(cond: bool) {\n+    let v;\n+    while cond {\n+        v = 3;\n+        break;\n+    }\n+    #debug[\"%d\", v]; //! ERROR use of possibly uninitialized variable: `v`\n+}\n+\n+fn main() {\n+    test(true);\n+}"}, {"sha": "a0a90e9550c39f81cd691e17ffb332e9b93fa8ce", "filename": "src/test/compile-fail/liveness-while-cond.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-while-cond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-while-cond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-while-cond.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    let x: bool;\n+    while x { } //! ERROR use of possibly uninitialized variable: `x`\n+}"}, {"sha": "b69012bc3f22a6bf71d1e824ca48693f585ddfb6", "filename": "src/test/compile-fail/liveness-while.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Fliveness-while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-while.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,7 @@\n+fn f() -> int {\n+    let mut x: int;\n+    while 1 == 1 { x = 10; }\n+    ret x; //! ERROR use of possibly uninitialized variable: `x`\n+}\n+\n+fn main() { f(); }"}, {"sha": "512cd44e2065a59c2678ae595d35eb1297020804", "filename": "src/test/compile-fail/move-arg.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Fmove-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Fmove-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-arg.rs?ref=a3be0b105436118e187ea52deb89788afaf1edb5", "patch": "@@ -1,4 +0,0 @@\n-// error-pattern:unsatisfied precondition constraint\n-fn test(-foo: int) { assert (foo == 10); }\n-\n-fn main() { let x = 10; test(x); log(debug, x); }"}, {"sha": "0bc339904ba2b2990f5a20ac65720e7e0d76dd90", "filename": "src/test/compile-fail/or-init.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2For-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2For-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2For-init.rs?ref=a3be0b105436118e187ea52deb89788afaf1edb5", "patch": "@@ -1,8 +0,0 @@\n-// error-pattern:unsatisfied precondition constraint (for example, init(i\n-\n-fn main() {\n-    let i: int;\n-\n-    log(debug, false || { i = 5; true });\n-    log(debug, i);\n-}"}, {"sha": "1978ec5f420be081b006e8f280d8461e3214c309", "filename": "src/test/compile-fail/return-uninit.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Freturn-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Freturn-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Freturn-uninit.rs?ref=a3be0b105436118e187ea52deb89788afaf1edb5", "patch": "@@ -1,5 +0,0 @@\n-// error-pattern: precondition constraint\n-\n-fn f() -> int { let x: int; ret x; }\n-\n-fn main() { f(); }"}, {"sha": "fbf400db08aa6242929a002fc74c1b4b87497e3c", "filename": "src/test/compile-fail/swap-uninit.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Fswap-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Fswap-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fswap-uninit.rs?ref=a3be0b105436118e187ea52deb89788afaf1edb5", "patch": "@@ -1,3 +0,0 @@\n-// error-pattern:unsatisfied precondition\n-\n-fn main() { let x = 3; let y; x <-> y; }"}, {"sha": "7b254fe2e19e1d11619386641a4e296fba0de471", "filename": "src/test/compile-fail/tstate-and-init.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-and-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-and-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-and-init.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,7 @@\n+pure fn is_even(i: int) -> bool { (i%2) == 0 }\n+fn even(i: int) : is_even(i) -> int { i }\n+fn main() {\n+    let i: int = 4;\n+    log(debug, false && { check is_even(i); true });\n+    even(i); //! ERROR unsatisfied precondition\n+}"}, {"sha": "3fbf812a9dcbfabbd34beb22d0e403cd56933920", "filename": "src/test/compile-fail/tstate-block-uninit.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-block-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-block-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-block-uninit.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,11 @@\n+pure fn is_even(i: int) -> bool { (i%2) == 0 }\n+fn even(i: int) : is_even(i) -> int { i }\n+\n+fn force(f: fn()) { f(); }\n+\n+fn main() {\n+    let x: int = 4;\n+    force(fn&() {\n+        even(x); //! ERROR unsatisfied precondition\n+    });\n+}"}, {"sha": "8ea5446c8090ba529531e43ef46ceaa51cedc7e5", "filename": "src/test/compile-fail/tstate-break-uninit-2.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-break-uninit-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-break-uninit-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-break-uninit-2.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,16 @@\n+pure fn is_even(i: int) -> bool { (i%2) == 0 }\n+fn even(i: int) : is_even(i) -> int { i }\n+\n+fn foo() -> int {\n+    let x: int = 4;\n+\n+    while 1 != 2 {\n+        break;\n+        check is_even(x); //! WARNING unreachable statement\n+    }\n+\n+    even(x); //! ERROR unsatisfied precondition\n+    ret 17;\n+}\n+\n+fn main() { log(debug, foo()); }"}, {"sha": "55146447b44842c921d15623ac1b31ecde4b358d", "filename": "src/test/compile-fail/tstate-break-uninit.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-break-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-break-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-break-uninit.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,16 @@\n+pure fn is_even(i: int) -> bool { (i%2) == 0 }\n+fn even(i: int) : is_even(i) -> int { i }\n+\n+fn foo() -> int {\n+    let x: int = 4;\n+\n+    loop {\n+        break;\n+        check is_even(x); //! WARNING unreachable statement\n+    }\n+\n+    even(x); //! ERROR unsatisfied precondition\n+    ret 17;\n+}\n+\n+fn main() { log(debug, foo()); }"}, {"sha": "d249865cd497dc677e6489f28ca2feef27532734", "filename": "src/test/compile-fail/tstate-ctor-unsat.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-ctor-unsat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-ctor-unsat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-ctor-unsat.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,25 @@\n+pure fn is_even(i: int) -> bool { (i%2) == 0 }\n+fn even(i: int) : is_even(i) -> int { i }\n+\n+class cat {\n+  priv {\n+    let mut meows : uint;\n+  }\n+\n+  let how_hungry : int;\n+\n+  fn eat() {\n+    self.how_hungry -= 5;\n+  }\n+\n+  new(in_x : uint, in_y : int) {\n+    let foo = 3;\n+    self.meows = in_x + (in_y as uint);\n+    self.how_hungry = even(foo); //! ERROR unsatisfied precondition\n+  }\n+}\n+\n+fn main() {\n+  let nyan : cat = cat(52u, 99);\n+  nyan.eat();\n+}"}, {"sha": "a4989d86ab4e358bf1fc7534d3a0246190829a18", "filename": "src/test/compile-fail/tstate-fru.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-fru.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-fru.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-fru.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,13 @@\n+// -*- rust -*-\n+\n+type point = {x: int, y: int};\n+\n+pure fn test(_p: point) -> bool { true }\n+fn tested(p: point) : test(p) -> point { p }\n+\n+fn main() {\n+    let origin: point;\n+    origin = {x: 0, y: 0};\n+    let right: point = {x: 10 with tested(origin)};\n+        //!^ ERROR precondition\n+}"}, {"sha": "fbc02bf591a0e58b79d8f36184eb1f56245f020b", "filename": "src/test/compile-fail/tstate-if-no-else.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-if-no-else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-if-no-else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-if-no-else.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,10 @@\n+pure fn is_even(i: int) -> bool { (i%2) == 0 }\n+fn even(i: int) : is_even(i) -> int { i }\n+\n+fn foo(x: int) { log(debug, x); }\n+\n+fn main() {\n+\tlet x: int = 10;\n+        if 1 > 2 { check is_even(x); }\n+        even(x); //! ERROR unsatisfied precondition\n+}"}, {"sha": "74edb4b8d8b720b551cc39a0cab5af5c741d0875", "filename": "src/test/compile-fail/tstate-if-with-else.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-if-with-else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-if-with-else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-if-with-else.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,14 @@\n+pure fn is_even(i: int) -> bool { (i%2) == 0 }\n+fn even(i: int) : is_even(i) -> int { i }\n+\n+fn foo(x: int) { log(debug, x); }\n+\n+fn main() {\n+    let x: int = 10;\n+    if 1 > 2 {\n+        #debug(\"whoops\");\n+    } else {\n+        check is_even(x);\n+    }\n+    even(x); //! ERROR unsatisfied precondition\n+}"}, {"sha": "34ff0753d86ad042cf58ffc67ef220280066d3ce", "filename": "src/test/compile-fail/tstate-loop-constraints.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-loop-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-loop-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-loop-constraints.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,19 @@\n+pure fn is_even(i: int) -> bool { (i%2) == 0 }\n+fn even(i: int) : is_even(i) -> int { i }\n+\n+fn main() {\n+\n+    let mut x: int = 42;\n+    loop {\n+        loop {\n+            loop {\n+                check is_even(x);\n+                even(x); // OK\n+                loop {\n+                    even(x); //! ERROR unsatisfied precondition\n+                    x = 11; \n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "c26925929a6aa0bcd9492e868eafc8030adbbbb2", "filename": "src/test/compile-fail/tstate-or-init.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-or-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-or-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-or-init.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,7 @@\n+pure fn is_even(i: int) -> bool { (i%2) == 0 }\n+fn even(i: int) : is_even(i) -> int { i }\n+fn main() {\n+    let i: int = 4;\n+    log(debug, false || { check is_even(i); true });\n+    even(i); //! ERROR unsatisfied precondition\n+}"}, {"sha": "6d786bacd7be3164a2c031215ccfeac2735a8703", "filename": "src/test/compile-fail/tstate-return.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-return.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,9 @@\n+pure fn is_even(i: int) -> bool { (i%2) == 0 }\n+fn even(i: int) : is_even(i) -> int { i }\n+\n+fn f() -> int {\n+\tlet x: int = 4;\n+\tret even(x); //! ERROR unsatisfied precondition\n+}\n+\n+fn main() { f(); }"}, {"sha": "b82df3a8657b878afa4e9ff1eb0985e5c0bb6338", "filename": "src/test/compile-fail/tstate-unsat-after-item.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-unsat-after-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-unsat-after-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-unsat-after-item.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,9 @@\n+pure fn is_even(i: int) -> bool { (i%2) == 0 }\n+fn even(i: int) : is_even(i) -> int { i }\n+\n+fn main() {\n+    let x = 4;\n+    fn baz(_x: int) { }\n+    bind baz(even(x)); //! ERROR unsatisfied precondition\n+}\n+"}, {"sha": "010ac92f7b02e356d6a7cbed21217ec227d4616e", "filename": "src/test/compile-fail/tstate-unsat-in-called-fn-expr.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-unsat-in-called-fn-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-unsat-in-called-fn-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-unsat-in-called-fn-expr.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,9 @@\n+fn foo(v: [int]) : vec::is_empty(v) { #debug(\"%d\", v[0]); }\n+\n+fn main() {\n+    let f = fn@() {\n+        let v = [1];\n+        foo(v); //! ERROR unsatisfied precondition constraint\n+    }();\n+    log(error, f);\n+}"}, {"sha": "b9cd25825378c12db45f0efc6f87162e69f515ba", "filename": "src/test/compile-fail/tstate-unsat-in-fn-expr.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-unsat-in-fn-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-unsat-in-fn-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-unsat-in-fn-expr.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,9 @@\n+fn foo(v: [int]) : vec::is_empty(v) { #debug(\"%d\", v[0]); }\n+\n+fn main() {\n+    let f = fn@() {\n+        let v = [1];\n+        foo(v); //! ERROR unsatisfied precondition constraint\n+    };\n+    log(error, f());\n+}"}, {"sha": "44a3e88fdee76a27042d0b27799a6bb8aa62b781", "filename": "src/test/compile-fail/tstate-unsat.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-unsat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-unsat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-unsat.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,7 @@\n+pure fn is_even(i: int) -> bool { (i%2) == 0 }\n+fn even(i: int) : is_even(i) -> int { i }\n+\n+fn main() {\n+    let x: int = 4;\n+    even(x); //! ERROR unsatisfied precondition\n+}"}, {"sha": "6a25929a85b3bf668595ae0de634cd8e0657d5a0", "filename": "src/test/compile-fail/tstate-while-break.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-while-break.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-while-break.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-while-break.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,15 @@\n+pure fn is_even(i: int) -> bool { (i%2) == 0 }\n+fn even(i: int) : is_even(i) -> int { i }\n+\n+fn test(cond: bool) {\n+    let v = 4;\n+    while cond {\n+        check is_even(v);\n+        break;\n+    }\n+    even(v); //! ERROR unsatisfied precondition\n+}\n+\n+fn main() {\n+    test(true);\n+}"}, {"sha": "ae5436aa4e8418dbb1e41f9b82eeb41633d1a593", "filename": "src/test/compile-fail/tstate-while-cond.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-while-cond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-while-cond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-while-cond.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,7 @@\n+pure fn is_even(i: int) -> bool { (i%2) == 0 }\n+fn even(i: int) : is_even(i) -> int { i }\n+\n+fn main() {\n+    let x: int = 4;\n+    while even(x) != 0 { } //! ERROR unsatisfied precondition\n+}"}, {"sha": "646d2466c7464b4cc129af7e85d6887938614e4b", "filename": "src/test/compile-fail/tstate-while-loop-unsat-constriants.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-while-loop-unsat-constriants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-while-loop-unsat-constriants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-while-loop-unsat-constriants.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "previous_filename": "src/test/compile-fail/while-loop-pred-constraints.rs"}, {"sha": "6091a0237a25980af3807cf878f5599fb8e21870", "filename": "src/test/compile-fail/tstate-while.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Fcompile-fail%2Ftstate-while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-while.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,10 @@\n+pure fn is_even(i: int) -> bool { (i%2) == 0 }\n+fn even(i: int) : is_even(i) -> int { i }\n+\n+fn f() {\n+    let mut x: int = 10;\n+    while 1 == 1 { x = 10; }\n+    even(x); //! ERROR unsatisfied precondition\n+}\n+\n+fn main() { f(); }"}, {"sha": "560c855a7e66dac7730d16636d8c582a303407fd", "filename": "src/test/compile-fail/uninit-after-item.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Funinit-after-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Funinit-after-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funinit-after-item.rs?ref=a3be0b105436118e187ea52deb89788afaf1edb5", "patch": "@@ -1,7 +0,0 @@\n-// error-pattern:unsatisfied precondition constraint (for example, init(bar\n-fn main() {\n-    let bar;\n-    fn baz(x: int) { }\n-    bind baz(bar);\n-}\n-"}, {"sha": "177ad0010befa849ca269ae50b7366e6a4aaa0d9", "filename": "src/test/compile-fail/use-after-move.rs", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Fuse-after-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Fuse-after-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-move.rs?ref=a3be0b105436118e187ea52deb89788afaf1edb5", "patch": "@@ -1,2 +0,0 @@\n-// error-pattern:unsatisfied precondition constraint (for example, init(x\n-fn main() { let x = @5; let y <- x; log(debug, *x); }"}, {"sha": "82946cf022a5214ac723de169adf4d83864e90e7", "filename": "src/test/compile-fail/use-uninit-2.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Fuse-uninit-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Fuse-uninit-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-uninit-2.rs?ref=a3be0b105436118e187ea52deb89788afaf1edb5", "patch": "@@ -1,5 +0,0 @@\n-// error-pattern:unsatisfied precondition\n-\n-fn foo(x: int) { log(debug, x); }\n-\n-fn main() { let x: int; if 1 > 2 { x = 10; } foo(x); }"}, {"sha": "3ad93fe0a08a849fa5bbb9a30ebc9ce29d8bd6ed", "filename": "src/test/compile-fail/use-uninit.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Fuse-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Fuse-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-uninit.rs?ref=a3be0b105436118e187ea52deb89788afaf1edb5", "patch": "@@ -1,5 +0,0 @@\n-// error-pattern:unsatisfied precondition\n-\n-fn foo(x: int) { log(debug, x); }\n-\n-fn main() { let x: int; foo(x); }"}, {"sha": "231fb299898e635862a2a6ce711514dd7c05335f", "filename": "src/test/compile-fail/while-bypass.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Fwhile-bypass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Fwhile-bypass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhile-bypass.rs?ref=a3be0b105436118e187ea52deb89788afaf1edb5", "patch": "@@ -1,5 +0,0 @@\n-// error-pattern: precondition constraint\n-\n-fn f() -> int { let x: int; while 1 == 1 { x = 10; } ret x; }\n-\n-fn main() { f(); }"}, {"sha": "5ff3adf34c300fdb7f7237ae2c7d96f3042507b6", "filename": "src/test/compile-fail/while-expr.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Fwhile-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Fwhile-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhile-expr.rs?ref=a3be0b105436118e187ea52deb89788afaf1edb5", "patch": "@@ -1,3 +0,0 @@\n-// error-pattern: precondition constraint\n-\n-fn main() { let x: bool; while x { } }"}, {"sha": "38c1d471593ee32934a7a5dbb504333e4d0f7ced", "filename": "src/test/compile-fail/while-loop-constraints.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Fwhile-loop-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Fwhile-loop-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhile-loop-constraints.rs?ref=a3be0b105436118e187ea52deb89788afaf1edb5", "patch": "@@ -1,14 +0,0 @@\n-// error-pattern:unsatisfied precondition constraint (for example, init(y\n-fn main() {\n-\n-    let y: int = 42;\n-    let x: int;\n-    loop {\n-        log(debug, y);\n-        loop {\n-            loop {\n-                loop { x <- y; }\n-            }\n-        }\n-    }\n-}"}, {"sha": "283e925e20782df161dce19861786b1bcae2c6e3", "filename": "src/test/compile-fail/writing-through-uninit-vec.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Fwriting-through-uninit-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3be0b105436118e187ea52deb89788afaf1edb5/src%2Ftest%2Fcompile-fail%2Fwriting-through-uninit-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwriting-through-uninit-vec.rs?ref=a3be0b105436118e187ea52deb89788afaf1edb5", "patch": "@@ -1,5 +0,0 @@\n-// error-pattern:unsatisfied precondition constraint\n-\n-fn test() { let w: [int]; w[5] = 0; }\n-\n-fn main() { test(); }"}, {"sha": "9fbf5fb447f934c2c267407a1607af908673deb4", "filename": "src/test/run-pass/liveness-assign-imm-local-after-loop.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Frun-pass%2Fliveness-assign-imm-local-after-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Frun-pass%2Fliveness-assign-imm-local-after-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fliveness-assign-imm-local-after-loop.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,10 @@\n+fn test(cond: bool) {\n+    let v: int;\n+    v = 1;\n+    loop { } // loop never terminates, so no error is reported\n+    v = 2;\n+}\n+\n+fn main() {\n+\t// note: don't call test()... :)\n+}"}, {"sha": "4b1cc59171310bd85f10b7ea23cffa8236e7f90c", "filename": "src/test/run-pass/liveness-assign-imm-local-after-ret.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Frun-pass%2Fliveness-assign-imm-local-after-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Frun-pass%2Fliveness-assign-imm-local-after-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fliveness-assign-imm-local-after-ret.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,9 @@\n+fn test() {\n+    let _v: int;\n+    _v = 1;\n+    ret;\n+    _v = 2; //! WARNING: unreachable statement\n+}\n+\n+fn main() {\n+}"}, {"sha": "58274555202d5a8aa1281113739e09d968c92e41", "filename": "src/test/run-pass/liveness-loop-break.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Frun-pass%2Fliveness-loop-break.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Frun-pass%2Fliveness-loop-break.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fliveness-loop-break.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,14 @@\n+// xfail-test --- tstate incorrectly fails this\n+\n+fn test() {\n+    let v;\n+    loop {\n+        v = 3;\n+        break;\n+    }\n+    #debug[\"%d\", v];\n+}\n+\n+fn main() {\n+    test();\n+}"}, {"sha": "a7f9547c0596cd49632d92eea723b70dea1d0ecf", "filename": "src/test/run-pass/liveness-move-in-loop.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Frun-pass%2Fliveness-move-in-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Frun-pass%2Fliveness-move-in-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fliveness-move-in-loop.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,15 @@\n+fn take(-x: int) -> int {x}\n+\n+fn the_loop() {\n+    let mut list = [];\n+    loop {\n+        let x = 5;\n+        if x > 3 {\n+            list += [take(x)];\n+        } else {\n+            break;\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "14a276b316a19756117f3995edf17cf704fd4193", "filename": "src/test/run-pass/tstate-loop-break.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Frun-pass%2Ftstate-loop-break.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30b47649ea37d211ee2dec4c541e6ba1e64c31a8/src%2Ftest%2Frun-pass%2Ftstate-loop-break.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftstate-loop-break.rs?ref=30b47649ea37d211ee2dec4c541e6ba1e64c31a8", "patch": "@@ -0,0 +1,17 @@\n+// xfail-test\n+\n+pure fn is_even(i: int) -> bool { (i%2) == 0 }\n+fn even(i: int) : is_even(i) -> int { i }\n+\n+fn test() {\n+    let v = 4;\n+    loop {\n+        check is_even(v);\n+        break;\n+    }\n+    even(v);\n+}\n+\n+fn main() {\n+    test();\n+}"}]}