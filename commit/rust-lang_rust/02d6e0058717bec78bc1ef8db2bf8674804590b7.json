{"sha": "02d6e0058717bec78bc1ef8db2bf8674804590b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyZDZlMDA1ODcxN2JlYzc4YmMxZWY4ZGIyYmY4Njc0ODA0NTkwYjc=", "commit": {"author": {"name": "Stjepan Glavina", "email": "stjepang@gmail.com", "date": "2017-03-19T20:40:02Z"}, "committer": {"name": "Stjepan Glavina", "email": "stjepang@gmail.com", "date": "2017-03-21T19:46:20Z"}, "message": "Use partial insertion sort", "tree": {"sha": "85a105db6d49a37d4e32839f68fd38455caea7c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85a105db6d49a37d4e32839f68fd38455caea7c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02d6e0058717bec78bc1ef8db2bf8674804590b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02d6e0058717bec78bc1ef8db2bf8674804590b7", "html_url": "https://github.com/rust-lang/rust/commit/02d6e0058717bec78bc1ef8db2bf8674804590b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02d6e0058717bec78bc1ef8db2bf8674804590b7/comments", "author": null, "committer": null, "parents": [{"sha": "c4454a5507be95da969712ac0326055635efe778", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4454a5507be95da969712ac0326055635efe778", "html_url": "https://github.com/rust-lang/rust/commit/c4454a5507be95da969712ac0326055635efe778"}], "stats": {"total": 173, "additions": 119, "deletions": 54}, "files": [{"sha": "a015c8fc120e0af57d3bd96065211d4f5b962c0c", "filename": "src/libcore/slice/sort.rs", "status": "modified", "additions": 119, "deletions": 54, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/02d6e0058717bec78bc1ef8db2bf8674804590b7/src%2Flibcore%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02d6e0058717bec78bc1ef8db2bf8674804590b7/src%2Flibcore%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fsort.rs?ref=02d6e0058717bec78bc1ef8db2bf8674804590b7", "patch": "@@ -38,64 +38,125 @@ impl<T> Drop for CopyOnDrop<T> {\n     }\n }\n \n-/// Sorts a slice using insertion sort, which is `O(n^2)` worst-case.\n-fn insertion_sort<T, F>(v: &mut [T], is_less: &mut F)\n+/// Shifts the first element to the right until it encounters a greater or equal element.\n+fn shift_head<T, F>(v: &mut [T], is_less: &mut F)\n     where F: FnMut(&T, &T) -> bool\n {\n     let len = v.len();\n+    unsafe {\n+        // If the first two elements are out-of-order...\n+        if len >= 2 && is_less(v.get_unchecked(1), v.get_unchecked(0)) {\n+            // Read the first element into a stack-allocated variable. If a following comparison\n+            // operation panics, `hole` will get dropped and automatically write the element back\n+            // into the slice.\n+            let mut tmp = NoDrop { value: ptr::read(v.get_unchecked(0)) };\n+            let mut hole = CopyOnDrop {\n+                src: &mut tmp.value,\n+                dest: v.get_unchecked_mut(1),\n+            };\n+            ptr::copy_nonoverlapping(v.get_unchecked(1), v.get_unchecked_mut(0), 1);\n \n-    for i in 1..len {\n-        unsafe {\n-            if is_less(v.get_unchecked(i), v.get_unchecked(i - 1)) {\n-                // There are three ways to implement insertion here:\n-                //\n-                // 1. Swap adjacent elements until the first one gets to its final destination.\n-                //    However, this way we copy data around more than is necessary. If elements are\n-                //    big structures (costly to copy), this method will be slow.\n-                //\n-                // 2. Iterate until the right place for the first element is found. Then shift the\n-                //    elements succeeding it to make room for it and finally place it into the\n-                //    remaining hole. This is a good method.\n-                //\n-                // 3. Copy the first element into a temporary variable. Iterate until the right\n-                //    place for it is found. As we go along, copy every traversed element into the\n-                //    slot preceding it. Finally, copy data from the temporary variable into the\n-                //    remaining hole. This method is very good. Benchmarks demonstrated slightly\n-                //    better performance than with the 2nd method.\n-                //\n-                // All methods were benchmarked, and the 3rd showed best results. So we chose that\n-                // one.\n-                let mut tmp = NoDrop { value: ptr::read(v.get_unchecked(i)) };\n-\n-                // Intermediate state of the insertion process is always tracked by `hole`, which\n-                // serves two purposes:\n-                // 1. Protects integrity of `v` from panics in `is_less`.\n-                // 2. Fills the remaining hole in `v` in the end.\n-                //\n-                // Panic safety:\n-                //\n-                // If `is_less` panics at any point during the process, `hole` will get dropped and\n-                // fill the hole in `v` with `tmp`, thus ensuring that `v` still holds every object\n-                // it initially held exactly once.\n-                let mut hole = CopyOnDrop {\n-                    src: &mut tmp.value,\n-                    dest: v.get_unchecked_mut(i - 1),\n-                };\n-                ptr::copy_nonoverlapping(v.get_unchecked(i - 1), v.get_unchecked_mut(i), 1);\n-\n-                for h in (0..i-1).rev() {\n-                    if !is_less(&tmp.value, v.get_unchecked(h)) {\n-                        break;\n-                    }\n-                    ptr::copy_nonoverlapping(v.get_unchecked(h), v.get_unchecked_mut(h + 1), 1);\n-                    hole.dest = v.get_unchecked_mut(h);\n+            for i in 2..len {\n+                if !is_less(&v[i], &tmp.value) {\n+                    break;\n                 }\n-                // `hole` gets dropped and thus copies `tmp` into the remaining hole in `v`.\n+\n+                // Move `i`-th element one place to the left, thus shifting the hole to the right.\n+                ptr::copy_nonoverlapping(v.get_unchecked(i), v.get_unchecked_mut(i - 1), 1);\n+                hole.dest = v.get_unchecked_mut(i);\n             }\n+            // `hole` gets dropped and thus copies `tmp` into the remaining hole in `v`.\n         }\n     }\n }\n \n+/// Shifts the last element to the left until it encounters a smaller or equal element.\n+fn shift_tail<T, F>(v: &mut [T], is_less: &mut F)\n+    where F: FnMut(&T, &T) -> bool\n+{\n+    let len = v.len();\n+    unsafe {\n+        // If the last two elements are out-of-order...\n+        if len >= 2 && is_less(v.get_unchecked(len - 1), v.get_unchecked(len - 2)) {\n+            // Read the last element into a stack-allocated variable. If a following comparison\n+            // operation panics, `hole` will get dropped and automatically write the element back\n+            // into the slice.\n+            let mut tmp = NoDrop { value: ptr::read(v.get_unchecked(len - 1)) };\n+            let mut hole = CopyOnDrop {\n+                src: &mut tmp.value,\n+                dest: v.get_unchecked_mut(len - 2),\n+            };\n+            ptr::copy_nonoverlapping(v.get_unchecked(len - 2), v.get_unchecked_mut(len - 1), 1);\n+\n+            for i in (0..len-2).rev() {\n+                if !is_less(&tmp.value, v.get_unchecked(i)) {\n+                    break;\n+                }\n+\n+                // Move `i`-th element one place to the right, thus shifting the hole to the left.\n+                ptr::copy_nonoverlapping(v.get_unchecked(i), v.get_unchecked_mut(i + 1), 1);\n+                hole.dest = v.get_unchecked_mut(i);\n+            }\n+            // `hole` gets dropped and thus copies `tmp` into the remaining hole in `v`.\n+        }\n+    }\n+}\n+\n+/// Partially sorts a slice by shifting several out-of-order elements around.\n+///\n+/// Returns true if the slice is sorted at the end. This function is `O(n)` worst-case.\n+#[cold]\n+fn partial_insertion_sort<T, F>(v: &mut [T], is_less: &mut F) -> bool\n+    where F: FnMut(&T, &T) -> bool\n+{\n+    // Maximum number of adjacent out-of-order pairs that will get shifted.\n+    const MAX_STEPS: usize = 5;\n+    // If the slice is shorter than this, don't shift any elements.\n+    const SHORTEST_SHIFTING: usize = 50;\n+\n+    let len = v.len();\n+    let mut i = 1;\n+\n+    for _ in 0..MAX_STEPS {\n+        unsafe {\n+            // Find the next pair of adjacent out-of-order elements.\n+            while i < len && !is_less(v.get_unchecked(i), v.get_unchecked(i - 1)) {\n+                i += 1;\n+            }\n+        }\n+\n+        // Are we done?\n+        if i == len {\n+            return true;\n+        }\n+\n+        // Don't shift elements on short arrays, that has a performance cost.\n+        if len < SHORTEST_SHIFTING {\n+            return false;\n+        }\n+\n+        // Swap the found pair of elements. This puts them in correct order.\n+        v.swap(i - 1, i);\n+\n+        // Shift the smaller element to the left.\n+        shift_tail(&mut v[..i], is_less);\n+        // Shift the greater element to the right.\n+        shift_head(&mut v[i..], is_less);\n+    }\n+\n+    // Didn't manage to sort the slice in the limited number of steps.\n+    false\n+}\n+\n+/// Sorts a slice using insertion sort, which is `O(n^2)` worst-case.\n+fn insertion_sort<T, F>(v: &mut [T], is_less: &mut F)\n+    where F: FnMut(&T, &T) -> bool\n+{\n+    for i in 2..v.len()+1 {\n+        shift_tail(&mut v[..i], is_less);\n+    }\n+}\n+\n /// Sorts `v` using heapsort, which guarantees `O(n log n)` worst-case.\n #[cold]\n fn heapsort<T, F>(v: &mut [T], is_less: &mut F)\n@@ -180,6 +241,9 @@ fn partition_in_blocks<T, F>(v: &mut [T], pivot: &T, is_less: &mut F) -> usize\n     let mut end_r = ptr::null_mut();\n     let mut offsets_r: [u8; BLOCK] = unsafe { mem::uninitialized() };\n \n+    // FIXME: When we get VLAs, try creating one array of length `min(v.len(), 2 * BLOCK)` rather\n+    // than two fixed-size arrays of length `BLOCK`. VLAs might be more cache-efficient.\n+\n     // Returns the number of elements between pointers `l` (inclusive) and `r` (exclusive).\n     fn width<T>(l: *mut T, r: *mut T) -> usize {\n         assert!(mem::size_of::<T>() > 0);\n@@ -470,10 +534,10 @@ fn break_patterns<T>(v: &mut [T]) {\n fn choose_pivot<T, F>(v: &mut [T], is_less: &mut F) -> (usize, bool)\n     where F: FnMut(&T, &T) -> bool\n {\n-    // Minimal length to choose the median-of-medians method.\n+    // Minimum length to choose the median-of-medians method.\n     // Shorter slices use the simple median-of-three method.\n-    const SHORTEST_MEDIAN_OF_MEDIANS: usize = 80;\n-    // Maximal number of swaps that can be performed in this function.\n+    const SHORTEST_MEDIAN_OF_MEDIANS: usize = 50;\n+    // Maximum number of swaps that can be performed in this function.\n     const MAX_SWAPS: usize = 4 * 3;\n \n     let len = v.len();\n@@ -522,7 +586,7 @@ fn choose_pivot<T, F>(v: &mut [T], is_less: &mut F) -> (usize, bool)\n     if swaps < MAX_SWAPS {\n         (b, swaps == 0)\n     } else {\n-        // The maximal number of swaps was performed. Chances are the slice is descending or mostly\n+        // The maximum number of swaps was performed. Chances are the slice is descending or mostly\n         // descending, so reversing will probably help sort it faster.\n         v.reverse();\n         (len - 1 - b, true)\n@@ -575,8 +639,9 @@ fn recurse<'a, T, F>(mut v: &'a mut [T], is_less: &mut F, mut pred: Option<&'a T\n         // If the last partitioning was decently balanced and didn't shuffle elements, and if pivot\n         // selection predicts the slice is likely already sorted...\n         if was_balanced && was_partitioned && likely_sorted {\n-            // Check whether the slice really is sorted. If so, we're done.\n-            if v.windows(2).all(|w| !is_less(&w[1], &w[0])) {\n+            // Try identifying several out-of-order elements and shifting them to correct\n+            // positions. If the slice ends up being completely sorted, we're done.\n+            if partial_insertion_sort(v, is_less) {\n                 return;\n             }\n         }"}]}