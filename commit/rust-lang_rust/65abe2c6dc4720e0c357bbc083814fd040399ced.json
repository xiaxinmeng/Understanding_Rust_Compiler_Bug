{"sha": "65abe2c6dc4720e0c357bbc083814fd040399ced", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1YWJlMmM2ZGM0NzIwZTBjMzU3YmJjMDgzODE0ZmQwNDAzOTljZWQ=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-05-16T22:54:50Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-05-22T22:31:38Z"}, "message": "Using libstd future instead.\n\nTurning off sequential versions for tracing.", "tree": {"sha": "47c39a45b677cd1b0ddd006487bcf4fbbcc2d768", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47c39a45b677cd1b0ddd006487bcf4fbbcc2d768"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65abe2c6dc4720e0c357bbc083814fd040399ced", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65abe2c6dc4720e0c357bbc083814fd040399ced", "html_url": "https://github.com/rust-lang/rust/commit/65abe2c6dc4720e0c357bbc083814fd040399ced", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65abe2c6dc4720e0c357bbc083814fd040399ced/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cba2761cc4b0c1a8600928828f980bfb4466472d", "url": "https://api.github.com/repos/rust-lang/rust/commits/cba2761cc4b0c1a8600928828f980bfb4466472d", "html_url": "https://github.com/rust-lang/rust/commit/cba2761cc4b0c1a8600928828f980bfb4466472d"}], "stats": {"total": 112, "additions": 38, "deletions": 74}, "files": [{"sha": "0f6b82c5d8520e3ac8937d611e834c5ab16d70d1", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 38, "deletions": 74, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/65abe2c6dc4720e0c357bbc083814fd040399ced/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65abe2c6dc4720e0c357bbc083814fd040399ced/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=65abe2c6dc4720e0c357bbc083814fd040399ced", "patch": "@@ -403,9 +403,10 @@ fn validate(edges: [(node_id, node_id)],\n }\n \n fn main() {\n-    let scale = 15u;\n+    let scale = 14u;\n     let num_keys = 16u;\n     let do_validate = false;\n+    let do_sequential = true;\n \n     let start = time::precise_time_s();\n     let edges = make_edges(scale, 16u);\n@@ -431,44 +432,49 @@ fn main() {\n     gen_search_keys(graph, num_keys).map() {|root|\n         io::stdout().write_line(\"\");\n         io::stdout().write_line(#fmt(\"Search key: %?\", root));\n-    \n-        let start = time::precise_time_s();\n-        let bfs_tree = bfs(graph, root);\n-        let stop = time::precise_time_s();\n-\n-        total_seq += stop - start;\n-\n-        io::stdout().write_line(#fmt(\"Sequential BFS completed in %? seconds.\",\n-                                     stop - start));\n \n-        if do_validate {\n+        if do_sequential {\n             let start = time::precise_time_s();\n-            assert(validate(edges, root, bfs_tree));\n+            let bfs_tree = bfs(graph, root);\n             let stop = time::precise_time_s();\n             \n-            io::stdout().write_line(#fmt(\"Validation completed in %? seconds.\",\n-                                         stop - start));\n-        }\n-\n-        let start = time::precise_time_s();\n-        let bfs_tree = bfs2(graph, root);\n-        let stop = time::precise_time_s();\n-\n-        //total_seq += stop - start;\n+            //total_seq += stop - start;\n \n-        io::stdout().write_line(\n-            #fmt(\"Slow Sequential BFS completed in %? seconds.\",\n-                 stop - start));\n-\n-        if do_validate {\n+            io::stdout().write_line(\n+                #fmt(\"Sequential BFS completed in %? seconds.\",\n+                     stop - start));\n+            \n+            if do_validate {\n+                let start = time::precise_time_s();\n+                assert(validate(edges, root, bfs_tree));\n+                let stop = time::precise_time_s();\n+                \n+                io::stdout().write_line(\n+                    #fmt(\"Validation completed in %? seconds.\",\n+                         stop - start));\n+            }\n+            \n             let start = time::precise_time_s();\n-            assert(validate(edges, root, bfs_tree));\n+            let bfs_tree = bfs2(graph, root);\n             let stop = time::precise_time_s();\n             \n-            io::stdout().write_line(#fmt(\"Validation completed in %? seconds.\",\n-                                         stop - start));\n+            total_seq += stop - start;\n+            \n+            io::stdout().write_line(\n+                #fmt(\"Alternate Sequential BFS completed in %? seconds.\",\n+                     stop - start));\n+            \n+            if do_validate {\n+                let start = time::precise_time_s();\n+                assert(validate(edges, root, bfs_tree));\n+                let stop = time::precise_time_s();\n+                \n+                io::stdout().write_line(\n+                    #fmt(\"Validation completed in %? seconds.\",\n+                         stop - start));\n+            }\n         }\n-\n+        \n         let start = time::precise_time_s();\n         let bfs_tree = pbfs(graph, root);\n         let stop = time::precise_time_s();\n@@ -502,49 +508,7 @@ import comm::port;\n import comm::chan;\n import comm::send;\n import comm::recv;\n-import task::spawn;\n-\n-iface future<T: send> {\n-    fn get() -> T;\n-}\n-\n-type future_<T: send> = {\n-    mut slot : option<T>,\n-    port : port<T>,\n-};\n-\n-impl<T: send> of future<T> for future_<T> {\n-    fn get() -> T {\n-        get(self)\n-    }\n-}\n-\n-fn get<T: send>(f: future_<T>) -> T {\n-    alt(f.slot) {\n-      some(x) { x }\n-      none {\n-        let x = recv(f.port);\n-        f.slot = some(x);\n-        x\n-      }\n-    }\n-}\n-\n-\n-#[doc=\"Executes a bit of code asynchronously.\n-\n-Returns a handle that can be used to retrieve the result at your\n-leisure.\"]\n-fn future<T: send>(thunk : fn~() -> T) -> future<T> {\n-    let p = port();\n-    let c = chan(p);\n-\n-    spawn() {||\n-        send(c, thunk());\n-    }\n-\n-    {mut slot: none::<T>, port : p} as future::<T>\n-}\n+import future::future;\n \n #[doc=\"The maximum number of tasks this module will spawn for a single\n  operationg.\"]\n@@ -576,7 +540,7 @@ fn map_slices<A: send, B: send>(xs: [A], f: fn~(uint, [A]) -> B) -> [B] {\n         while base < len {\n             let slice = vec::slice(xs, base,\n                                    uint::min(len, base + items_per_task));\n-            futures += [future() {|copy base|\n+            futures += [future::spawn() {|copy base|\n                 f(base, slice)\n             }];\n             base += items_per_task;"}]}