{"sha": "54b548795f603bb790853ff6dd0190dc3f32b7b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0YjU0ODc5NWY2MDNiYjc5MDg1M2ZmNmRkMDE5MGRjM2YzMmI3Yjk=", "commit": {"author": {"name": "gifnksm", "email": "makoto.nksm+github@gmail.com", "date": "2012-12-22T02:13:28Z"}, "committer": {"name": "gifnksm", "email": "makoto.nksm+github@gmail.com", "date": "2012-12-22T06:14:26Z"}, "message": "Impl Zero, One of BigInt, BigUint", "tree": {"sha": "42e0a774e78c3b8545a7dffc35b04c7e0c0840d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42e0a774e78c3b8545a7dffc35b04c7e0c0840d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54b548795f603bb790853ff6dd0190dc3f32b7b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54b548795f603bb790853ff6dd0190dc3f32b7b9", "html_url": "https://github.com/rust-lang/rust/commit/54b548795f603bb790853ff6dd0190dc3f32b7b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54b548795f603bb790853ff6dd0190dc3f32b7b9/comments", "author": {"login": "gifnksm", "id": 164213, "node_id": "MDQ6VXNlcjE2NDIxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/164213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gifnksm", "html_url": "https://github.com/gifnksm", "followers_url": "https://api.github.com/users/gifnksm/followers", "following_url": "https://api.github.com/users/gifnksm/following{/other_user}", "gists_url": "https://api.github.com/users/gifnksm/gists{/gist_id}", "starred_url": "https://api.github.com/users/gifnksm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gifnksm/subscriptions", "organizations_url": "https://api.github.com/users/gifnksm/orgs", "repos_url": "https://api.github.com/users/gifnksm/repos", "events_url": "https://api.github.com/users/gifnksm/events{/privacy}", "received_events_url": "https://api.github.com/users/gifnksm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gifnksm", "id": 164213, "node_id": "MDQ6VXNlcjE2NDIxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/164213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gifnksm", "html_url": "https://github.com/gifnksm", "followers_url": "https://api.github.com/users/gifnksm/followers", "following_url": "https://api.github.com/users/gifnksm/following{/other_user}", "gists_url": "https://api.github.com/users/gifnksm/gists{/gist_id}", "starred_url": "https://api.github.com/users/gifnksm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gifnksm/subscriptions", "organizations_url": "https://api.github.com/users/gifnksm/orgs", "repos_url": "https://api.github.com/users/gifnksm/repos", "events_url": "https://api.github.com/users/gifnksm/events{/privacy}", "received_events_url": "https://api.github.com/users/gifnksm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e83d70cc1df93e5aadc91feb7c2cf25290e6ef8", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e83d70cc1df93e5aadc91feb7c2cf25290e6ef8", "html_url": "https://github.com/rust-lang/rust/commit/0e83d70cc1df93e5aadc91feb7c2cf25290e6ef8"}], "stats": {"total": 158, "additions": 85, "deletions": 73}, "files": [{"sha": "1e772c0a585a9151a59a48a18c53055da84afba0", "filename": "src/libstd/bigint.rs", "status": "modified", "additions": 85, "deletions": 73, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/54b548795f603bb790853ff6dd0190dc3f32b7b9/src%2Flibstd%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b548795f603bb790853ff6dd0190dc3f32b7b9/src%2Flibstd%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbigint.rs?ref=54b548795f603bb790853ff6dd0190dc3f32b7b9", "patch": "@@ -7,6 +7,7 @@ A BigInt is a combination of BigUint and Sign.\n */\n \n use core::cmp::{Eq, Ord};\n+use core::num::{Num, Zero, One};\n \n /**\n A BigDigit is a BigUint's composing element.\n@@ -99,6 +100,14 @@ impl BigUint : Shr<uint, BigUint> {\n     }\n }\n \n+impl BigUint : Zero {\n+    static pure fn zero() -> BigUint { BigUint::from_at_vec(@[]) }\n+}\n+\n+impl BigUint : One {\n+    static pub pure fn one() -> BigUint { BigUint::from_at_vec(@[1]) }\n+}\n+\n impl BigUint : Num {\n     pure fn add(&self, other: &BigUint) -> BigUint {\n         let new_len = uint::max(self.data.len(), other.data.len());\n@@ -141,7 +150,7 @@ impl BigUint : Num {\n     }\n \n     pure fn mul(&self, other: &BigUint) -> BigUint {\n-        if self.is_zero() || other.is_zero() { return BigUint::zero(); }\n+        if self.is_zero() || other.is_zero() { return Zero::zero(); }\n \n         let s_len = self.data.len(), o_len = other.data.len();\n         if s_len == 1 { return mul_digit(other, self.data[0]);  }\n@@ -167,7 +176,7 @@ impl BigUint : Num {\n         return ll + mm.shl_unit(half_len) + hh.shl_unit(half_len * 2);\n \n         pure fn mul_digit(a: &BigUint, n: BigDigit) -> BigUint {\n-            if n == 0 { return BigUint::zero(); }\n+            if n == 0 { return Zero::zero(); }\n             if n == 1 { return *a; }\n \n             let mut carry = 0;\n@@ -192,7 +201,7 @@ impl BigUint : Num {\n             match a.cmp(&b) {\n                 s if s < 0 => (s, b - a),\n                 s if s > 0 => (s, a - b),\n-                _          => (0, BigUint::zero())\n+                _          => (0, Zero::zero())\n             }\n         }\n     }\n@@ -211,15 +220,15 @@ impl BigUint : Num {\n     }\n \n     static pure fn from_int(n: int) -> BigUint {\n-        if (n < 0) { BigUint::zero() } else { BigUint::from_uint(n as uint) }\n+        if (n < 0) { Zero::zero() } else { BigUint::from_uint(n as uint) }\n     }\n }\n \n pub impl BigUint {\n     /// Creates and initializes an BigUint.\n     static pub pure fn from_uint(n: uint) -> BigUint {\n         match BigDigit::from_uint(n) {\n-            (0,  0)  => BigUint::zero(),\n+            (0,  0)  => Zero::zero(),\n             (0,  n0) => BigUint::from_at_vec(@[n0]),\n             (n1, n0) => BigUint::from_at_vec(@[n0, n1])\n         }\n@@ -257,8 +266,8 @@ pub impl BigUint {\n         let base_num: BigUint = BigUint::from_uint(base);\n \n         let mut end             = buf.len();\n-        let mut n: BigUint      = BigUint::zero();\n-        let mut power: BigUint  = BigUint::one();\n+        let mut n: BigUint      = Zero::zero();\n+        let mut power: BigUint  = One::one();\n         loop {\n             let start = uint::max(end, unit_len) - unit_len;\n             match uint::parse_bytes(vec::view(buf, start, end), radix) {\n@@ -273,8 +282,6 @@ pub impl BigUint {\n         }\n     }\n \n-    static pub pure fn zero() -> BigUint { BigUint::from_at_vec(@[]) }\n-    static pub pure fn one() -> BigUint { BigUint::from_at_vec(@[1]) }\n     pure fn abs(&self) -> BigUint { *self }\n \n     /// Compare two BigUint value.\n@@ -295,12 +302,12 @@ pub impl BigUint {\n \n     pure fn divmod(&self, other: &BigUint) -> (BigUint, BigUint) {\n         if other.is_zero() { fail }\n-        if self.is_zero() { return (BigUint::zero(), BigUint::zero()); }\n-        if *other == BigUint::one() { return (*self, BigUint::zero()); }\n+        if self.is_zero() { return (Zero::zero(), Zero::zero()); }\n+        if *other == One::one() { return (*self, Zero::zero()); }\n \n         match self.cmp(other) {\n-            s if s < 0 => return (BigUint::zero(), *self),\n-            0          => return (BigUint::one(), BigUint::zero()),\n+            s if s < 0 => return (Zero::zero(), *self),\n+            0          => return (One::one(), Zero::zero()),\n             _          => {} // Do nothing\n         }\n \n@@ -317,7 +324,7 @@ pub impl BigUint {\n \n         pure fn divmod_inner(a: BigUint, b: BigUint) -> (BigUint, BigUint) {\n             let mut r = a;\n-            let mut d = BigUint::zero();\n+            let mut d = Zero::zero::<BigUint>();\n             let mut n = 1;\n             while r >= b {\n                 let mut (d0, d_unit, b_unit) = div_estimate(r, b, n);\n@@ -340,7 +347,7 @@ pub impl BigUint {\n         pure fn div_estimate(a: BigUint, b: BigUint, n: uint)\n             -> (BigUint, BigUint, BigUint) {\n             if a.data.len() < n {\n-                return (BigUint::zero(), BigUint::zero(), a);\n+                return (Zero::zero(), Zero::zero(), a);\n             }\n \n             let an = vec::view(a.data, a.data.len() - n, a.data.len());\n@@ -357,7 +364,7 @@ pub impl BigUint {\n \n             let shift = (a.data.len() - an.len()) - (b.data.len() - 1);\n             return (BigUint::from_slice(d).shl_unit(shift),\n-                    BigUint::one().shl_unit(shift),\n+                    One::one::<BigUint>().shl_unit(shift),\n                     b.shl_unit(shift));\n         }\n     }\n@@ -442,7 +449,7 @@ pub impl BigUint {\n \n     priv pure fn shr_unit(&self, n_unit: uint) -> BigUint {\n         if n_unit == 0 { return *self; }\n-        if self.data.len() < n_unit { return BigUint::zero(); }\n+        if self.data.len() < n_unit { return Zero::zero(); }\n         return BigUint::from_slice(\n             vec::view(self.data, n_unit, self.data.len())\n         );\n@@ -560,6 +567,18 @@ impl BigInt : Shr<uint, BigInt> {\n     }\n }\n \n+impl BigInt : Zero {\n+    static pub pure fn zero() -> BigInt {\n+        BigInt::from_biguint(Zero, Zero::zero())\n+    }\n+}\n+\n+impl BigInt : One {\n+    static pub pure fn one() -> BigInt {\n+        BigInt::from_biguint(Plus, One::one())\n+    }\n+}\n+\n impl BigInt : Num {\n     pure fn add(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n@@ -582,7 +601,7 @@ impl BigInt : Num {\n                 s if s > 0 =>\n                     BigInt::from_biguint(Plus, self.data - other.data),\n                 _ =>\n-                    BigInt::zero()\n+                    Zero::zero()\n             },\n             (Plus, Minus) => self + (-*other),\n             (Minus, Plus) => -((-self) + *other),\n@@ -591,7 +610,7 @@ impl BigInt : Num {\n     }\n     pure fn mul(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n-            (Zero, _)     | (_,     Zero)  => BigInt::zero(),\n+            (Zero, _)     | (_,     Zero)  => Zero::zero(),\n             (Plus, Plus)  | (Minus, Minus) => {\n                 BigInt::from_biguint(Plus, self.data * other.data)\n             },\n@@ -628,22 +647,22 @@ impl BigInt : Num {\n                 Minus, BigUint::from_uint(uint::max_value - (n as uint) + 1)\n             );\n         }\n-        return BigInt::zero();\n+        return Zero::zero();\n     }\n }\n \n pub impl BigInt {\n     /// Creates and initializes an BigInt.\n     static pub pure fn from_biguint(sign: Sign, data: BigUint) -> BigInt {\n         if sign == Zero || data.is_zero() {\n-            return BigInt { sign: Zero, data: BigUint::zero() };\n+            return BigInt { sign: Zero, data: Zero::zero() };\n         }\n         return BigInt { sign: sign, data: data };\n     }\n \n     /// Creates and initializes an BigInt.\n     static pub pure fn from_uint(n: uint) -> BigInt {\n-        if n == 0 { return BigInt::zero(); }\n+        if n == 0 { return Zero::zero(); }\n         return BigInt::from_biguint(Plus, BigUint::from_uint(n));\n     }\n \n@@ -678,13 +697,6 @@ pub impl BigInt {\n             .map(|bu| BigInt::from_biguint(sign, *bu));\n     }\n \n-    static pub pure fn zero() -> BigInt {\n-        BigInt::from_biguint(Zero, BigUint::zero())\n-    }\n-    static pub pure fn one() -> BigInt {\n-        BigInt::from_biguint(Plus, BigUint::one())\n-    }\n-\n     pure fn abs(&self) -> BigInt { BigInt::from_biguint(Plus, self.data) }\n \n     pure fn cmp(&self, other: &BigInt) -> int {\n@@ -709,14 +721,14 @@ pub impl BigInt {\n             (_,    Zero)   => fail,\n             (Plus, Plus)  | (Zero, Plus)  => (d, m),\n             (Plus, Minus) | (Zero, Minus) => if m.is_zero() {\n-                (-d, BigInt::zero())\n+                (-d, Zero::zero())\n             } else {\n-                (-d - BigInt::one(), m + *other)\n+                (-d - One::one(), m + *other)\n             },\n             (Minus, Plus) => if m.is_zero() {\n-                (-d, BigInt::zero())\n+                (-d, Zero::zero())\n             } else {\n-                (-d - BigInt::one(), other - m)\n+                (-d - One::one(), other - m)\n             },\n             (Minus, Minus) => (d, -m)\n         }\n@@ -876,11 +888,11 @@ mod biguint_tests {\n     #[test]\n     fn test_convert_int() {\n         fn check_conv(b: BigUint, i: int) {\n-            assert b == num::Num::from_int(i);\n+            assert b == Num::from_int(i);\n             assert b.to_int() == i;\n         }\n \n-        check_conv(BigUint::zero(), 0);\n+        check_conv(Zero::zero(), 0);\n         check_conv(BigUint::from_at_vec(@[1]), 1);\n \n         check_conv(BigUint::from_at_vec(@[-1]),\n@@ -902,7 +914,7 @@ mod biguint_tests {\n             assert b.to_uint() == u;\n         }\n \n-        check_conv(BigUint::zero(), 0);\n+        check_conv(Zero::zero(), 0);\n         check_conv(BigUint::from_at_vec(@[ 1]), 1);\n         check_conv(BigUint::from_at_vec(@[-1]),\n                    uint::max_value >> BigDigit::bits);\n@@ -1022,10 +1034,10 @@ mod biguint_tests {\n             let c = BigUint::from_slice(cVec);\n \n             if a.is_not_zero() {\n-                assert c.divmod(&a) == (b, BigUint::zero());\n+                assert c.divmod(&a) == (b, Zero::zero());\n             }\n             if b.is_not_zero() {\n-                assert c.divmod(&b) == (a, BigUint::zero());\n+                assert c.divmod(&b) == (a, Zero::zero());\n             }\n         }\n \n@@ -1041,7 +1053,7 @@ mod biguint_tests {\n     }\n \n     fn to_str_pairs() -> ~[ (BigUint, ~[(uint, ~str)]) ] {\n-        ~[( BigUint::zero(), ~[\n+        ~[( Zero::zero(), ~[\n             (2, ~\"0\"), (3, ~\"0\")\n         ]), ( BigUint::from_slice([ 0xff ]), ~[\n             (2,  ~\"11111111\"),\n@@ -1108,7 +1120,7 @@ mod biguint_tests {\n     #[test]\n     fn test_factor() {\n         fn factor(n: uint) -> BigUint {\n-            let mut f= BigUint::one();\n+            let mut f= One::one::<BigUint>();\n             for uint::range(2, n + 1) |i| {\n                 f *= BigUint::from_uint(i);\n             }\n@@ -1130,12 +1142,12 @@ mod bigint_tests {\n     fn test_from_biguint() {\n         assert BigInt::from_biguint(Plus, BigUint::from_uint(1)) ==\n             BigInt { sign: Plus, data: BigUint::from_uint(1) };\n-        assert BigInt::from_biguint(Plus, BigUint::zero()) ==\n-            BigInt { sign: Zero, data: BigUint::zero() };\n+        assert BigInt::from_biguint(Plus, Zero::zero()) ==\n+            BigInt { sign: Zero, data: Zero::zero() };\n         assert BigInt::from_biguint(Minus, BigUint::from_uint(1)) ==\n             BigInt { sign: Minus, data: BigUint::from_uint(1) };\n         assert BigInt::from_biguint(Zero, BigUint::from_uint(1)) ==\n-            BigInt { sign: Zero, data: BigUint::zero() };\n+            BigInt { sign: Zero, data: Zero::zero() };\n     }\n \n     #[test]\n@@ -1144,7 +1156,7 @@ mod bigint_tests {\n             .map(|data| BigUint::from_slice(*data));\n         let nums: ~[BigInt]\n             = vec::reversed(uints).map(|bu| BigInt::from_biguint(Minus, *bu))\n-            + [ BigInt::zero() ]\n+            + [ Zero::zero() ]\n             + uints.map(|bu| BigInt::from_biguint(Plus, *bu));\n \n         for nums.eachi |i, ni| {\n@@ -1183,12 +1195,12 @@ mod bigint_tests {\n     #[test]\n     fn test_convert_int() {\n         fn check_conv(b: BigInt, i: int) {\n-            assert b == num::Num::from_int(i);\n+            assert b == Num::from_int(i);\n             assert b.to_int() == i;\n         }\n \n-        check_conv(BigInt::zero(), 0);\n-        check_conv(BigInt::one(), 1);\n+        check_conv(Zero::zero(), 0);\n+        check_conv(One::one(), 1);\n         check_conv(\n             BigInt::from_biguint(\n                 Plus, BigUint::from_uint(int::max_value as uint)),\n@@ -1220,8 +1232,8 @@ mod bigint_tests {\n             assert b.to_uint() == u;\n         }\n \n-        check_conv(BigInt::zero(), 0);\n-        check_conv(BigInt::one(), 1);\n+        check_conv(Zero::zero(), 0);\n+        check_conv(One::one(), 1);\n \n         check_conv(\n             BigInt::from_biguint(Plus, BigUint::from_uint(uint::max_value)),\n@@ -1265,7 +1277,7 @@ mod bigint_tests {\n             assert a + (-c) == (-b);\n             assert b + (-c) == (-a);\n             assert (-a) + (-b) == (-c);\n-            assert a + (-a) == BigInt::zero();\n+            assert a + (-a) == Zero::zero();\n         }\n     }\n \n@@ -1284,7 +1296,7 @@ mod bigint_tests {\n             assert b - (-a) == c;\n             assert a - (-b) == c;\n             assert (-c) - (-a) == (-b);\n-            assert a - a == BigInt::zero();\n+            assert a - a == Zero::zero();\n         }\n     }\n \n@@ -1366,17 +1378,17 @@ mod bigint_tests {\n             check_divmod_sub(-a, -b);\n \n             if d.is_zero() {\n-                assert a.divmod(&b)     == (c, BigInt::zero());\n-                assert (-a).divmod(&b)  == (-c, BigInt::zero());\n-                assert (a).divmod(&-b)  == (-c, BigInt::zero());\n-                assert (-a).divmod(&-b) == (c, BigInt::zero());\n+                assert a.divmod(&b)     == (c, Zero::zero());\n+                assert (-a).divmod(&b)  == (-c, Zero::zero());\n+                assert (a).divmod(&-b)  == (-c, Zero::zero());\n+                assert (-a).divmod(&-b) == (c, Zero::zero());\n             } else {\n                 // a == bc + d\n                 assert a.divmod(&b) == (c, d);\n                 // a == (-b)(-c - 1) + (d - b)\n-                assert a.divmod(&-b) == (-c - BigInt::one(), d - b);\n+                assert a.divmod(&-b) == (-c - One::one(), d - b);\n                 // (-a) == b (-c - 1) + (b - d)\n-                assert (-a).divmod(&b) == (-c - BigInt::one(), b - d);\n+                assert (-a).divmod(&b) == (-c - One::one(), b - d);\n                 // (-a) == (-b)(c) - d\n                 assert (-a).divmod(&-b) == (c, -d);\n             }\n@@ -1387,8 +1399,8 @@ mod bigint_tests {\n             let b = BigInt::from_slice(Plus, bVec);\n             let c = BigInt::from_slice(Plus, cVec);\n \n-            if a.is_not_zero() { check_divmod(c, a, b, BigInt::zero()); }\n-            if b.is_not_zero() { check_divmod(c, b, a, BigInt::zero()); }\n+            if a.is_not_zero() { check_divmod(c, a, b, Zero::zero()); }\n+            if b.is_not_zero() { check_divmod(c, b, a, Zero::zero()); }\n         }\n \n         for divmod_quadruples.each |elm| {\n@@ -1422,10 +1434,10 @@ mod bigint_tests {\n             check_quotrem_sub(-a, -b);\n \n             if d.is_zero() {\n-                assert a.quotrem(&b)     == (c, BigInt::zero());\n-                assert (-a).quotrem(&b)  == (-c, BigInt::zero());\n-                assert (a).quotrem(&-b)  == (-c, BigInt::zero());\n-                assert (-a).quotrem(&-b) == (c, BigInt::zero());\n+                assert a.quotrem(&b)     == (c, Zero::zero());\n+                assert (-a).quotrem(&b)  == (-c, Zero::zero());\n+                assert (a).quotrem(&-b)  == (-c, Zero::zero());\n+                assert (-a).quotrem(&-b) == (c, Zero::zero());\n             } else {\n                 // a == bc + d\n                 assert a.quotrem(&b) == (c, d);\n@@ -1443,8 +1455,8 @@ mod bigint_tests {\n             let b = BigInt::from_slice(Plus, bVec);\n             let c = BigInt::from_slice(Plus, cVec);\n \n-            if a.is_not_zero() { check_quotrem(c, a, b, BigInt::zero()); }\n-            if b.is_not_zero() { check_quotrem(c, b, a, BigInt::zero()); }\n+            if a.is_not_zero() { check_quotrem(c, a, b, Zero::zero()); }\n+            if b.is_not_zero() { check_quotrem(c, b, a, Zero::zero()); }\n         }\n \n         for divmod_quadruples.each |elm| {\n@@ -1464,9 +1476,9 @@ mod bigint_tests {\n     fn test_to_str_radix() {\n         assert BigInt::from_biguint(Plus, BigUint::from_uint(10))\n             .to_str_radix(10) == ~\"10\";\n-        assert BigInt::one().to_str_radix(10) == ~\"1\";\n-        assert BigInt::zero().to_str_radix(10) == ~\"0\";\n-        assert (-BigInt::one()).to_str_radix(10) == ~\"-1\";\n+        assert One::one::<BigInt>().to_str_radix(10) == ~\"1\";\n+        assert Zero::zero::<BigInt>().to_str_radix(10) == ~\"0\";\n+        assert (-One::one::<BigInt>()).to_str_radix(10) == ~\"-1\";\n         assert BigInt::from_biguint(Minus, BigUint::from_uint(10))\n             .to_str_radix(10) == ~\"-10\";\n     }\n@@ -1476,16 +1488,16 @@ mod bigint_tests {\n     fn test_from_str_radix() {\n         assert BigInt::from_biguint(Plus, BigUint::from_uint(10)) ==\n             BigInt::from_str_radix(~\"10\", 10).get();\n-        assert BigInt::one()== BigInt::from_str_radix(~\"1\", 10).get();\n-        assert BigInt::zero() == BigInt::from_str_radix(~\"0\", 10).get();\n-        assert (-BigInt::one()) == BigInt::from_str_radix(~\"-1\", 10).get();\n+        assert One::one::<BigInt>() == BigInt::from_str_radix(~\"1\", 10).get();\n+        assert Zero::zero::<BigInt>() == BigInt::from_str_radix(~\"0\", 10).get();\n+        assert (-One::one::<BigInt>()) == BigInt::from_str_radix(~\"-1\", 10).get();\n         assert BigInt::from_biguint(Minus, BigUint::from_uint(10)) ==\n             BigInt::from_str_radix(~\"-10\", 10).get();\n \n         assert BigInt::from_str_radix(~\"Z\", 10) == None;\n         assert BigInt::from_str_radix(~\"_\", 2) == None;\n         assert BigInt::from_str_radix(~\"-1\", 10) ==\n-            Some(BigInt::from_biguint(Minus, BigUint::one()));\n+            Some(BigInt::from_biguint(Minus, One::one()));\n     }\n \n     #[test]\n@@ -1494,7 +1506,7 @@ mod bigint_tests {\n             BigInt::from_at_vec(Minus, @[1, 1, 1]);\n         assert -BigInt::from_at_vec(Minus, @[1, 1, 1]) ==\n             BigInt::from_at_vec(Plus,  @[1, 1, 1]);\n-        assert -BigInt::zero() == BigInt::zero();\n+        assert -Zero::zero::<BigInt>() == Zero::zero::<BigInt>();\n     }\n }\n "}]}