{"sha": "50ea6f6886f3315ad93b035e918b8a4165325132", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwZWE2ZjY4ODZmMzMxNWFkOTNiMDM1ZTkxOGI4YTQxNjUzMjUxMzI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-03-19T11:16:40Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-03-23T08:52:33Z"}, "message": "Remove incorrect subtyping for `&mut Trait` and introduce coercion\nfor `&mut (Trait+'a)` to `&mut (Trait+'b)` if `'a:'b`.\n\nFixes #14985.", "tree": {"sha": "bebcd1eedfd2b79392e564ebc6b318f0f924fef5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bebcd1eedfd2b79392e564ebc6b318f0f924fef5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50ea6f6886f3315ad93b035e918b8a4165325132", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50ea6f6886f3315ad93b035e918b8a4165325132", "html_url": "https://github.com/rust-lang/rust/commit/50ea6f6886f3315ad93b035e918b8a4165325132", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50ea6f6886f3315ad93b035e918b8a4165325132/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0aad7dd4fad8d7e2e2f877a511a637258949597", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0aad7dd4fad8d7e2e2f877a511a637258949597", "html_url": "https://github.com/rust-lang/rust/commit/b0aad7dd4fad8d7e2e2f877a511a637258949597"}], "stats": {"total": 93, "additions": 71, "deletions": 22}, "files": [{"sha": "930e95d1f939a474590138324dbacc9dd1b5dac7", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/50ea6f6886f3315ad93b035e918b8a4165325132/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ea6f6886f3315ad93b035e918b8a4165325132/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=50ea6f6886f3315ad93b035e918b8a4165325132", "patch": "@@ -557,18 +557,7 @@ pub fn super_tys<'tcx, C>(this: &C,\n \n         (&ty::ty_rptr(a_r, ref a_mt), &ty::ty_rptr(b_r, ref b_mt)) => {\n             let r = try!(this.regions_with_variance(ty::Contravariant, *a_r, *b_r));\n-\n-            // FIXME(14985)  If we have mutable references to trait objects, we\n-            // used to use covariant subtyping. I have preserved this behaviour,\n-            // even though it is probably incorrect. So don't go down the usual\n-            // path which would require invariance.\n-            let mt = match (&a_mt.ty.sty, &b_mt.ty.sty) {\n-                (&ty::ty_trait(..), &ty::ty_trait(..)) if a_mt.mutbl == b_mt.mutbl => {\n-                    let ty = try!(this.tys(a_mt.ty, b_mt.ty));\n-                    ty::mt { ty: ty, mutbl: a_mt.mutbl }\n-                }\n-                _ => try!(this.mts(a_mt, b_mt))\n-            };\n+            let mt = try!(this.mts(a_mt, b_mt));\n             Ok(ty::mk_rptr(tcx, tcx.mk_region(r), mt))\n         }\n "}, {"sha": "f731507ba906dbeb7f0af6bfbc8bf6ea17ac875b", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/50ea6f6886f3315ad93b035e918b8a4165325132/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ea6f6886f3315ad93b035e918b8a4165325132/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=50ea6f6886f3315ad93b035e918b8a4165325132", "patch": "@@ -92,6 +92,12 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         Ok(None) // No coercion required.\n     }\n \n+    fn outlives(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ()> {\n+        let sub = Sub(self.fcx.infcx().combine_fields(false, self.trace.clone()));\n+        try!(sub.regions(b, a));\n+        Ok(())\n+    }\n+\n     fn unpack_actual_value<T, F>(&self, a: Ty<'tcx>, f: F) -> T where\n         F: FnOnce(Ty<'tcx>) -> T,\n     {\n@@ -340,21 +346,40 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                     Some((ty, ty::UnsizeLength(len)))\n                 }\n                 (&ty::ty_trait(ref data_a), &ty::ty_trait(ref data_b)) => {\n-                    // For now, we only support upcasts from\n-                    // `Foo+Send` to `Foo` (really, any time there are\n-                    // fewer builtin bounds then before). These are\n-                    // convenient because they don't require any sort\n-                    // of change to the vtable at runtime.\n-                    if data_a.bounds.builtin_bounds != data_b.bounds.builtin_bounds &&\n-                        data_a.bounds.builtin_bounds.is_superset(&data_b.bounds.builtin_bounds)\n-                    {\n+                    // Upcasts permit two things:\n+                    //\n+                    // 1. Dropping builtin bounds, e.g. `Foo+Send` to `Foo`\n+                    // 2. Tightening the region bound, e.g. `Foo+'a` to `Foo+'b` if `'a : 'b`\n+                    //\n+                    // Note that neither of these changes requires any\n+                    // change at runtime.  Eventually this will be\n+                    // generalized.\n+                    //\n+                    // We always upcast when we can because of reason\n+                    // #2 (region bounds).\n+                    if data_a.bounds.builtin_bounds.is_superset(&data_b.bounds.builtin_bounds) {\n+                        // construct a type `a1` which is a version of\n+                        // `a` using the upcast bounds from `b`\n                         let bounds_a1 = ty::ExistentialBounds {\n-                            region_bound: data_a.bounds.region_bound,\n+                            // From type b\n+                            region_bound: data_b.bounds.region_bound,\n                             builtin_bounds: data_b.bounds.builtin_bounds,\n+\n+                            // From type a\n                             projection_bounds: data_a.bounds.projection_bounds.clone(),\n                         };\n                         let ty_a1 = ty::mk_trait(tcx, data_a.principal.clone(), bounds_a1);\n-                        match self.fcx.infcx().try(|_| self.subtype(ty_a1, ty_b)) {\n+\n+                        // relate `a1` to `b`\n+                        let result = self.fcx.infcx().try(|_| {\n+                            // it's ok to upcast from Foo+'a to Foo+'b so long as 'a : 'b\n+                            try!(self.outlives(data_a.bounds.region_bound,\n+                                               data_b.bounds.region_bound));\n+                            self.subtype(ty_a1, ty_b)\n+                        });\n+\n+                        // if that was successful, we have a coercion\n+                        match result {\n                             Ok(_) => Some((ty_b, ty::UnsizeUpcast(ty_b))),\n                             Err(_) => None,\n                         }"}, {"sha": "8d05cb67e77b10dbc4afe722306bec6138ba0174", "filename": "src/test/compile-fail/regions-trait-object-subtyping.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/50ea6f6886f3315ad93b035e918b8a4165325132/src%2Ftest%2Fcompile-fail%2Fregions-trait-object-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ea6f6886f3315ad93b035e918b8a4165325132/src%2Ftest%2Fcompile-fail%2Fregions-trait-object-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-object-subtyping.rs?ref=50ea6f6886f3315ad93b035e918b8a4165325132", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Dummy { fn dummy(&self); }\n+\n+fn foo1<'a:'b,'b>(x: &'a mut (Dummy+'a)) -> &'b mut (Dummy+'b) {\n+    // Here, we are able to coerce\n+    x\n+}\n+\n+fn foo2<'a:'b,'b>(x: &'b mut (Dummy+'a)) -> &'b mut (Dummy+'b) {\n+    // Here, we are able to coerce\n+    x\n+}\n+\n+fn foo3<'a,'b>(x: &'a mut Dummy) -> &'b mut Dummy {\n+    // Without knowing 'a:'b, we can't coerce\n+    x //~ ERROR mismatched types\n+     //~^ ERROR cannot infer\n+}\n+\n+struct Wrapper<T>(T);\n+fn foo4<'a:'b,'b>(x: Wrapper<&'a mut Dummy>) -> Wrapper<&'b mut Dummy> {\n+    // We can't coerce because it is packed in `Wrapper`\n+    x //~ ERROR mismatched types\n+}\n+\n+fn main() {}"}]}