{"sha": "bb689c09f5ea185e082254c514bae1f8940e04a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiNjg5YzA5ZjVlYTE4NWUwODIyNTRjNTE0YmFlMWY4OTQwZTA0YTQ=", "commit": {"author": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-02-24T22:38:59Z"}, "committer": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-03-07T04:41:57Z"}, "message": "Convert const ADT construction to trans::adt.\n\nAlso converts const cast-from-enum, because it used the same routine to\nget the discriminant as what's renovated to construct the enums.\n\nAlso fixes ICE on struct-like variants as consts, and provides a slightly\nless bad ICE for functional-update-like struct expressions in consts.", "tree": {"sha": "b124c5e25bf33a6c9deba0f865e00e570df9f4c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b124c5e25bf33a6c9deba0f865e00e570df9f4c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb689c09f5ea185e082254c514bae1f8940e04a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb689c09f5ea185e082254c514bae1f8940e04a4", "html_url": "https://github.com/rust-lang/rust/commit/bb689c09f5ea185e082254c514bae1f8940e04a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb689c09f5ea185e082254c514bae1f8940e04a4/comments", "author": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a028c5ab8363d9263d0cda09d6ab884c5b73978", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a028c5ab8363d9263d0cda09d6ab884c5b73978", "html_url": "https://github.com/rust-lang/rust/commit/2a028c5ab8363d9263d0cda09d6ab884c5b73978"}], "stats": {"total": 157, "additions": 44, "deletions": 113}, "files": [{"sha": "d5656b9002be1fdc7d07d5512b8657b3bc484eea", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bb689c09f5ea185e082254c514bae1f8940e04a4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb689c09f5ea185e082254c514bae1f8940e04a4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=bb689c09f5ea185e082254c514bae1f8940e04a4", "patch": "@@ -828,30 +828,6 @@ pub fn trans_external_path(ccx: @CrateContext, did: ast::def_id, t: ty::t)\n     };\n }\n \n-pub fn get_discrim_val(cx: @CrateContext, span: span, enum_did: ast::def_id,\n-                       variant_did: ast::def_id) -> ValueRef {\n-    // Can't use `discrims` from the crate context here because\n-    // those discriminants have an extra level of indirection,\n-    // and there's no LLVM constant load instruction.\n-    let mut lldiscrim_opt = None;\n-    for ty::enum_variants(cx.tcx, enum_did).each |variant_info| {\n-        if variant_info.id == variant_did {\n-            lldiscrim_opt = Some(C_int(cx,\n-                                       variant_info.disr_val));\n-            break;\n-        }\n-    }\n-\n-    match lldiscrim_opt {\n-        None => {\n-            cx.tcx.sess.span_bug(span, ~\"didn't find discriminant?!\");\n-        }\n-        Some(found_lldiscrim) => {\n-            found_lldiscrim\n-        }\n-    }\n-}\n-\n pub fn invoke(bcx: block, llfn: ValueRef, +llargs: ~[ValueRef]) -> block {\n     let _icx = bcx.insn_ctxt(\"invoke_\");\n     if bcx.unreachable { return bcx; }"}, {"sha": "19d5bb4dbf55b40d0ddce915e56404cd9eca2573", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 44, "deletions": 89, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/bb689c09f5ea185e082254c514bae1f8940e04a4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb689c09f5ea185e082254c514bae1f8940e04a4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=bb689c09f5ea185e082254c514bae1f8940e04a4", "patch": "@@ -12,6 +12,7 @@ use core::prelude::*;\n \n use lib::llvm::{llvm, ValueRef, TypeRef, Bool, True, False};\n use middle::const_eval;\n+use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::base::get_insn_ctxt;\n use middle::trans::common::*;\n@@ -328,24 +329,8 @@ fn const_expr_unchecked(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n               }\n               (expr::cast_enum, expr::cast_integral) |\n               (expr::cast_enum, expr::cast_float)  => {\n-                let def = ty::resolve_expr(cx.tcx, base);\n-                let (enum_did, variant_did) = match def {\n-                    ast::def_variant(enum_did, variant_did) => {\n-                        (enum_did, variant_did)\n-                    }\n-                    _ => cx.sess.bug(~\"enum cast source is not enum\")\n-                };\n-                // Note that we know this is a C-like (nullary) enum\n-                // variant or we wouldn't have gotten here\n-                let variants = ty::enum_variants(cx.tcx, enum_did);\n-                let iv = if variants.len() == 1 {\n-                    // Univariants don't have a discriminant field,\n-                    // because there's only one value it could have:\n-                    C_integral(T_i64(),\n-                               variants[0].disr_val as u64, True)\n-                } else {\n-                    base::get_discrim_val(cx, e.span, enum_did, variant_did)\n-                };\n+                let repr = adt::represent_type(cx, basety);\n+                let iv = C_int(cx, adt::const_get_discrim(cx, &repr, v));\n                 let ety_cast = expr::cast_type_kind(ety);\n                 match ety_cast {\n                     expr::cast_integral => {\n@@ -373,28 +358,32 @@ fn const_expr_unchecked(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n             gv\n           }\n           ast::expr_tup(es) => {\n-            C_struct(es.map(|e| const_expr(cx, *e)))\n+              let ety = ty::expr_ty(cx.tcx, e);\n+              let repr = adt::represent_type(cx, ety);\n+              adt::trans_const(cx, &repr, 0, es.map(|e| const_expr(cx, *e)))\n           }\n           ast::expr_rec(ref fs, None) => {\n-              C_struct([C_struct(\n-                  (*fs).map(|f| const_expr(cx, f.node.expr)))])\n+              let ety = ty::expr_ty(cx.tcx, e);\n+              let repr = adt::represent_type(cx, ety);\n+              adt::trans_const(cx, &repr, 0,\n+                               fs.map(|f| const_expr(cx, f.node.expr)))\n           }\n-          ast::expr_struct(_, ref fs, _) => {\n+          ast::expr_struct(_, ref fs, None) => {\n               let ety = ty::expr_ty(cx.tcx, e);\n-              let cs = do expr::with_field_tys(cx.tcx,\n-                                               ety,\n-                                               None) |_hd, field_tys| {\n-                  field_tys.map(|field_ty| {\n+              let repr = adt::represent_type(cx, ety);\n+              do expr::with_field_tys(cx.tcx, ety, Some(e.id))\n+                  |discr, field_tys| {\n+                  let cs = field_tys.map(|field_ty| {\n                       match fs.find(|f| field_ty.ident == f.node.ident) {\n                           Some(ref f) => const_expr(cx, (*f).node.expr),\n                           None => {\n                               cx.tcx.sess.span_bug(\n                                   e.span, ~\"missing struct field\");\n                           }\n                       }\n-                  })\n-              };\n-              C_struct([C_struct(cs)])\n+                  });\n+                  adt::trans_const(cx, &repr, discr, cs)\n+              }\n           }\n           ast::expr_vec(es, ast::m_imm) => {\n             let (v, _, _) = const_vec(cx, e, es);\n@@ -452,78 +441,44 @@ fn const_expr_unchecked(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                     get_const_val(cx, def_id)\n                 }\n                 Some(ast::def_variant(enum_did, variant_did)) => {\n-                    // Note that we know this is a C-like (nullary) enum\n-                    // variant or we wouldn't have gotten here -- the constant\n-                    // checker forbids paths that don't map to C-like enum\n-                    // variants.\n-                    if ty::enum_is_univariant(cx.tcx, enum_did) {\n-                        // Univariants have no discriminant field.\n-                        C_struct(~[])\n-                    } else {\n-                    let lldiscrim = base::get_discrim_val(cx, e.span,\n-                                                          enum_did,\n-                                                          variant_did);\n-                    // However, we still have to pad it out to the\n-                    // size of the full enum; see the expr_call case,\n-                    // below.\n                     let ety = ty::expr_ty(cx.tcx, e);\n-                    let size = machine::static_size_of_enum(cx, ety);\n-                    let padding = C_null(T_array(T_i8(), size));\n-                    C_struct(~[lldiscrim, padding])\n-                }\n+                    let repr = adt::represent_type(cx, ety);\n+                    let vinfo = ty::enum_variant_with_id(cx.tcx,\n+                                                         enum_did,\n+                                                         variant_did);\n+                    adt::trans_const(cx, &repr, vinfo.disr_val, [])\n                 }\n                 Some(ast::def_struct(_)) => {\n                     let ety = ty::expr_ty(cx.tcx, e);\n                     let llty = type_of::type_of(cx, ety);\n                     C_null(llty)\n                 }\n                 _ => {\n-                    cx.sess.span_bug(e.span,\n-                                     ~\"expected a const, fn, or variant def\")\n+                    cx.sess.span_bug(e.span, ~\"expected a const, fn, \\\n+                                               struct, or variant def\")\n                 }\n             }\n           }\n           ast::expr_call(callee, args, _) => {\n-            match cx.tcx.def_map.find(&callee.id) {\n-                Some(ast::def_struct(def_id)) => {\n-                    let llstructbody =\n-                        C_struct(args.map(|a| const_expr(cx, *a)));\n-                    if ty::ty_dtor(cx.tcx, def_id).is_present() {\n-                        C_struct(~[ llstructbody, C_u8(0) ])\n-                    } else {\n-                        C_struct(~[ llstructbody ])\n-                    }\n-                }\n-            Some(ast::def_variant(tid, vid)) => {\n-                let ety = ty::expr_ty(cx.tcx, e);\n-                let univar = ty::enum_is_univariant(cx.tcx, tid);\n-                let size = machine::static_size_of_enum(cx, ety);\n-\n-                let discrim = base::get_discrim_val(cx, e.span, tid, vid);\n-                let c_args = C_struct(args.map(|a| const_expr(cx, *a)));\n-\n-                // FIXME (#1645): enum body alignment is generaly wrong.\n-                if !univar {\n-                    // Pad out the data to the size of its type_of;\n-                    // this is necessary if the enum is contained\n-                    // within an aggregate (tuple, struct, vector) so\n-                    // that the next element is at the right offset.\n-                    let actual_size =\n-                        machine::llsize_of_real(cx, llvm::LLVMTypeOf(c_args));\n-                    let padding =\n-                        C_null(T_array(T_i8(), size - actual_size));\n-                    // A packed_struct has an alignment of 1; thus,\n-                    // wrapping one around c_args will misalign it the\n-                    // same way we normally misalign enum bodies\n-                    // without affecting its internal alignment or\n-                    // changing the alignment of the enum.\n-                    C_struct(~[discrim, C_packed_struct(~[c_args]), padding])\n-                } else {\n-                    C_struct(~[c_args])\n-                }\n-            }\n-                _ => cx.sess.span_bug(e.span, ~\"expected a struct def\")\n-            }\n+              match cx.tcx.def_map.find(&callee.id) {\n+                  Some(ast::def_struct(_)) => {\n+                      let ety = ty::expr_ty(cx.tcx, e);\n+                      let repr = adt::represent_type(cx, ety);\n+                      adt::trans_const(cx, &repr, 0,\n+                                       args.map(|a| const_expr(cx, *a)))\n+                  }\n+                  Some(ast::def_variant(enum_did, variant_did)) => {\n+                      let ety = ty::expr_ty(cx.tcx, e);\n+                      let repr = adt::represent_type(cx, ety);\n+                      let vinfo = ty::enum_variant_with_id(cx.tcx,\n+                                                           enum_did,\n+                                                           variant_did);\n+                      adt::trans_const(cx, &repr, vinfo.disr_val,\n+                                       args.map(|a| const_expr(cx, *a)))\n+                  }\n+                  _ => cx.sess.span_bug(e.span, ~\"expected a struct or \\\n+                                                  variant def\")\n+              }\n           }\n           ast::expr_paren(e) => { return const_expr(cx, e); }\n           _ => cx.sess.span_bug(e.span,"}]}