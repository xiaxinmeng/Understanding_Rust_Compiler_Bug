{"sha": "5bc49807ddad3669836e3bbfe09ab680bc6aad3d", "node_id": "C_kwDOAAsO6NoAKDViYzQ5ODA3ZGRhZDM2Njk4MzZlM2JiZmUwOWFiNjgwYmM2YWFkM2Q", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-01-26T05:15:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-26T05:15:26Z"}, "message": "Rollup merge of #107175 - compiler-errors:bad-types-in-vec-push, r=estebank\n\nFix escaping inference var ICE in `point_at_expr_source_of_inferred_type`\n\nFixes #107158\n\n`point_at_expr_source_of_inferred_type` uses `lookup_probe` to adjust the self type of a method receiver -- but that method returns inference variables from inside a probe. That means that the ty vars are no longer valid, so we can't use any infcx methods on them.\n\nAlso, pass some extra span info to hack a quick solution to bad labels, resulting in this diagnostic improvement:\n\n```rust\nfn example2() {\n    let mut x = vec![1];\n    x.push(\"\");\n}\n```\n\n```diff\n  error[E0308]: mismatched types\n   --> src/main.rs:5:12\n    |\n  5 |     x.push(\"\");\n    |       ---- ^^\n    |       |    |\n    |       |    expected integer, found `&str`\n-   |       |    this is of type `&'static str`, which causes `x` to be inferred as `Vec<{integer}>`\n    |       arguments to this method are incorrect\n```\n(since that \"which causes `x` to be inferred as `Vec<{integer}>` part is wrong)\n\nr? `@estebank`\n\n(we really should make this code better in general, cc #106590, but that's a bit bigger issue that needs some more thinking about)", "tree": {"sha": "10501d27b4b439ca992db6e96f9cc20fdbb0c8ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10501d27b4b439ca992db6e96f9cc20fdbb0c8ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5bc49807ddad3669836e3bbfe09ab680bc6aad3d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj0gxuCRBK7hj4Ov3rIwAAPyEIAK0ASvFX/MHQRsKXBVD60lql\n7rDX2C2OuIjJsmNqmclQzfbb8XR9YtdAaSYWbPibQC7U7PKH0SqLA0tHRLu8Hl9i\n7KAJt2hOAQI8cPS4MG/bc5+yJnAs6yjXYdVQpKX214GFlNmXG2eh1r7bGISa9odf\n7EVpvS9H6htnZxAuQe0ntae+IiE/K2U2VrlqhWg3epDT0S92gQy2H4BSLcwqOGWL\naKGaKj4PukSgcPsCzXrzuL4rKeJiz/09g/rwEjegqkcIN75/Knm4bCqS/18Eu0zD\nnGEPAj5p0KbcFNK5ZXLwrmoVkSOfAYgECBUHctNZBZpWb5GC+M40Vg3UBVLB808=\n=Au1j\n-----END PGP SIGNATURE-----\n", "payload": "tree 10501d27b4b439ca992db6e96f9cc20fdbb0c8ee\nparent 4b51b20d8710f7e543be02ac9ef6f65842c1926a\nparent 9f933b5642c08e4241cbfed0f15270df552ce8e6\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1674710126 +0100\ncommitter GitHub <noreply@github.com> 1674710126 +0100\n\nRollup merge of #107175 - compiler-errors:bad-types-in-vec-push, r=estebank\n\nFix escaping inference var ICE in `point_at_expr_source_of_inferred_type`\n\nFixes #107158\n\n`point_at_expr_source_of_inferred_type` uses `lookup_probe` to adjust the self type of a method receiver -- but that method returns inference variables from inside a probe. That means that the ty vars are no longer valid, so we can't use any infcx methods on them.\n\nAlso, pass some extra span info to hack a quick solution to bad labels, resulting in this diagnostic improvement:\n\n```rust\nfn example2() {\n    let mut x = vec![1];\n    x.push(\"\");\n}\n```\n\n```diff\n  error[E0308]: mismatched types\n   --> src/main.rs:5:12\n    |\n  5 |     x.push(\"\");\n    |       ---- ^^\n    |       |    |\n    |       |    expected integer, found `&str`\n-   |       |    this is of type `&'static str`, which causes `x` to be inferred as `Vec<{integer}>`\n    |       arguments to this method are incorrect\n```\n(since that \"which causes `x` to be inferred as `Vec<{integer}>` part is wrong)\n\nr? `@estebank`\n\n(we really should make this code better in general, cc #106590, but that's a bit bigger issue that needs some more thinking about)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5bc49807ddad3669836e3bbfe09ab680bc6aad3d", "html_url": "https://github.com/rust-lang/rust/commit/5bc49807ddad3669836e3bbfe09ab680bc6aad3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5bc49807ddad3669836e3bbfe09ab680bc6aad3d/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b51b20d8710f7e543be02ac9ef6f65842c1926a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b51b20d8710f7e543be02ac9ef6f65842c1926a", "html_url": "https://github.com/rust-lang/rust/commit/4b51b20d8710f7e543be02ac9ef6f65842c1926a"}, {"sha": "9f933b5642c08e4241cbfed0f15270df552ce8e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f933b5642c08e4241cbfed0f15270df552ce8e6", "html_url": "https://github.com/rust-lang/rust/commit/9f933b5642c08e4241cbfed0f15270df552ce8e6"}], "stats": {"total": 97, "additions": 79, "deletions": 18}, "files": [{"sha": "a7b6a5c0331fc9722e126952c4198d309c27e86c", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5bc49807ddad3669836e3bbfe09ab680bc6aad3d/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc49807ddad3669836e3bbfe09ab680bc6aad3d/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=5bc49807ddad3669836e3bbfe09ab680bc6aad3d", "patch": "@@ -62,7 +62,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             || self.suggest_floating_point_literal(err, expr, expected)\n             || self.note_result_coercion(err, expr, expected, expr_ty);\n         if !suggested {\n-            self.point_at_expr_source_of_inferred_type(err, expr, expr_ty, expected);\n+            self.point_at_expr_source_of_inferred_type(err, expr, expr_ty, expected, expr.span);\n         }\n     }\n \n@@ -222,6 +222,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         found: Ty<'tcx>,\n         expected: Ty<'tcx>,\n+        mismatch_span: Span,\n     ) -> bool {\n         let map = self.tcx.hir();\n \n@@ -270,7 +271,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             lt_op: |_| self.tcx.lifetimes.re_erased,\n             ct_op: |c| c,\n             ty_op: |t| match *t.kind() {\n-                ty::Infer(ty::TyVar(vid)) => self.tcx.mk_ty_infer(ty::TyVar(self.root_var(vid))),\n+                ty::Infer(ty::TyVar(_)) => self.tcx.mk_ty_var(ty::TyVid::from_u32(0)),\n                 ty::Infer(ty::IntVar(_)) => {\n                     self.tcx.mk_ty_infer(ty::IntVar(ty::IntVid { index: 0 }))\n                 }\n@@ -281,7 +282,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             },\n         };\n         let mut prev = eraser.fold_ty(ty);\n-        let mut prev_span = None;\n+        let mut prev_span: Option<Span> = None;\n \n         for binding in expr_finder.uses {\n             // In every expression where the binding is referenced, we will look at that\n@@ -333,13 +334,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             // inferred in this method call.\n                             let arg = &args[i];\n                             let arg_ty = self.node_ty(arg.hir_id);\n-                            err.span_label(\n-                                arg.span,\n-                                &format!(\n-                                    \"this is of type `{arg_ty}`, which causes `{ident}` to be \\\n-                                     inferred as `{ty}`\",\n-                                ),\n-                            );\n+                            if !arg.span.overlaps(mismatch_span) {\n+                                err.span_label(\n+                                    arg.span,\n+                                    &format!(\n+                                        \"this is of type `{arg_ty}`, which causes `{ident}` to be \\\n+                                        inferred as `{ty}`\",\n+                                    ),\n+                                );\n+                            }\n                             param_args.insert(param_ty, (arg, arg_ty));\n                         }\n                     }\n@@ -382,12 +385,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     && self.can_eq(self.param_env, ty, found).is_ok()\n                 {\n                     // We only point at the first place where the found type was inferred.\n+                    if !segment.ident.span.overlaps(mismatch_span) {\n                     err.span_label(\n                         segment.ident.span,\n                         with_forced_trimmed_paths!(format!(\n                             \"here the type of `{ident}` is inferred to be `{ty}`\",\n                         )),\n-                    );\n+                    );}\n                     break;\n                 } else if !param_args.is_empty() {\n                     break;\n@@ -406,12 +410,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // We use the *previous* span because if the type is known *here* it means\n                     // it was *evaluated earlier*. We don't do this for method calls because we\n                     // evaluate the method's self type eagerly, but not in any other case.\n-                    err.span_label(\n-                        span,\n-                        with_forced_trimmed_paths!(format!(\n-                            \"here the type of `{ident}` is inferred to be `{ty}`\",\n-                        )),\n-                    );\n+                    if !span.overlaps(mismatch_span) {\n+                        err.span_label(\n+                            span,\n+                            with_forced_trimmed_paths!(format!(\n+                                \"here the type of `{ident}` is inferred to be `{ty}`\",\n+                            )),\n+                        );\n+                    }\n                     break;\n                 }\n                 prev = ty;"}, {"sha": "e78c76d5dde7031337b15a34272520d5438cebff", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5bc49807ddad3669836e3bbfe09ab680bc6aad3d/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc49807ddad3669836e3bbfe09ab680bc6aad3d/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=5bc49807ddad3669836e3bbfe09ab680bc6aad3d", "patch": "@@ -808,7 +808,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     kind: TypeVariableOriginKind::MiscVariable,\n                     span: full_call_span,\n                 });\n-                self.point_at_expr_source_of_inferred_type(&mut err, rcvr, expected, callee_ty);\n+                self.point_at_expr_source_of_inferred_type(\n+                    &mut err,\n+                    rcvr,\n+                    expected,\n+                    callee_ty,\n+                    provided_arg_span,\n+                );\n             }\n             // Call out where the function is defined\n             self.label_fn_like("}, {"sha": "a807f030cfce46d1de90db77a9efde8b1deca935", "filename": "tests/ui/typeck/bad-type-in-vec-push.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5bc49807ddad3669836e3bbfe09ab680bc6aad3d/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc49807ddad3669836e3bbfe09ab680bc6aad3d/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-push.rs?ref=5bc49807ddad3669836e3bbfe09ab680bc6aad3d", "patch": "@@ -0,0 +1,20 @@\n+// The error message here still is pretty confusing.\n+\n+fn main() {\n+    let mut result = vec![1];\n+    // The type of `result` is constrained to be `Vec<{integer}>` here.\n+    // But the logic we use to find what expression constrains a type\n+    // is not sophisticated enough to know this.\n+\n+    let mut vector = Vec::new();\n+    vector.sort();\n+    result.push(vector);\n+    //~^ ERROR mismatched types\n+    // So it thinks that the type of `result` is constrained here.\n+}\n+\n+fn example2() {\n+    let mut x = vec![1];\n+    x.push(\"\");\n+    //~^ ERROR mismatched types\n+}"}, {"sha": "e4c99ec8e701f99a1f72792c438a9626c947886a", "filename": "tests/ui/typeck/bad-type-in-vec-push.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5bc49807ddad3669836e3bbfe09ab680bc6aad3d/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-push.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5bc49807ddad3669836e3bbfe09ab680bc6aad3d/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-push.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-push.stderr?ref=5bc49807ddad3669836e3bbfe09ab680bc6aad3d", "patch": "@@ -0,0 +1,29 @@\n+error[E0308]: mismatched types\n+  --> $DIR/bad-type-in-vec-push.rs:11:17\n+   |\n+LL |     vector.sort();\n+   |     ------ here the type of `vector` is inferred to be `Vec<_>`\n+LL |     result.push(vector);\n+   |            ---- ^^^^^^ expected integer, found struct `Vec`\n+   |            |\n+   |            arguments to this method are incorrect\n+   |\n+   = note: expected type `{integer}`\n+            found struct `Vec<_>`\n+note: associated function defined here\n+  --> $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n+\n+error[E0308]: mismatched types\n+  --> $DIR/bad-type-in-vec-push.rs:18:12\n+   |\n+LL |     x.push(\"\");\n+   |       ---- ^^ expected integer, found `&str`\n+   |       |\n+   |       arguments to this method are incorrect\n+   |\n+note: associated function defined here\n+  --> $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}]}