{"sha": "ff804778c8d69d7835cf7076886ac5dac9a39659", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmODA0Nzc4YzhkNjlkNzgzNWNmNzA3Njg4NmFjNWRhYzlhMzk2NTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-08T19:03:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-08T19:03:09Z"}, "message": "Auto merge of #24029 - nagisa:print-locking, r=alexcrichton\n\nwrite_fmt calls write for each formatted field. The default implementation of write_fmt is used,\r\nwhich will call write on not-yet-locked stdout (and write locking after), therefore making print!\r\nin multithreaded environment still interleave contents of two separate prints.\r\n\r\nI\u2019m not sure whether we want to do this change, though, because it has the same deadlock hazard which we tried to avoid by not locking inside write_fmt itself (see [this comment](https://github.com/rust-lang/rust/blob/80def6c2447d23a624e611417f24cf0ab2a5a676/src/libstd/io/stdio.rs#L267)).\r\n\r\nSpotted on [reddit].\r\n\r\ncc @alexcrichton \r\n\r\n[reddit]: http://www.reddit.com/r/rust/comments/31comh/println_with_multiple_threads/", "tree": {"sha": "748fbd735552a72c5fe06d5025fbca206d688bc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/748fbd735552a72c5fe06d5025fbca206d688bc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff804778c8d69d7835cf7076886ac5dac9a39659", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff804778c8d69d7835cf7076886ac5dac9a39659", "html_url": "https://github.com/rust-lang/rust/commit/ff804778c8d69d7835cf7076886ac5dac9a39659", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff804778c8d69d7835cf7076886ac5dac9a39659/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/30e7e6e8b0389d407f8b46ab605a9e3475a851d5", "html_url": "https://github.com/rust-lang/rust/commit/30e7e6e8b0389d407f8b46ab605a9e3475a851d5"}, {"sha": "45aa6c8d1bc2f7863c92da6643de4642bb2d83bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/45aa6c8d1bc2f7863c92da6643de4642bb2d83bf", "html_url": "https://github.com/rust-lang/rust/commit/45aa6c8d1bc2f7863c92da6643de4642bb2d83bf"}], "stats": {"total": 480, "additions": 446, "deletions": 34}, "files": [{"sha": "2850d92e34d401152a378af9e60cb409bfacf497", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ff804778c8d69d7835cf7076886ac5dac9a39659/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff804778c8d69d7835cf7076886ac5dac9a39659/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=ff804778c8d69d7835cf7076886ac5dac9a39659", "patch": "@@ -18,6 +18,7 @@ use io::lazy::Lazy;\n use io::{self, BufReader, LineWriter};\n use sync::{Arc, Mutex, MutexGuard};\n use sys::stdio;\n+use sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\n \n /// Stdout used by print! and println! macros\n thread_local! {\n@@ -210,7 +211,7 @@ pub struct Stdout {\n     // FIXME: this should be LineWriter or BufWriter depending on the state of\n     //        stdout (tty or not). Note that if this is not line buffered it\n     //        should also flush-on-panic or some form of flush-on-abort.\n-    inner: Arc<Mutex<LineWriter<StdoutRaw>>>,\n+    inner: Arc<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>>,\n }\n \n /// A locked reference to the a `Stdout` handle.\n@@ -219,7 +220,7 @@ pub struct Stdout {\n /// method on `Stdout`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct StdoutLock<'a> {\n-    inner: MutexGuard<'a, LineWriter<StdoutRaw>>,\n+    inner: ReentrantMutexGuard<'a, RefCell<LineWriter<StdoutRaw>>>,\n }\n \n /// Constructs a new reference to the standard output of the current process.\n@@ -231,13 +232,13 @@ pub struct StdoutLock<'a> {\n /// The returned handle implements the `Write` trait.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stdout() -> Stdout {\n-    static INSTANCE: Lazy<Mutex<LineWriter<StdoutRaw>>> = lazy_init!(stdout_init);\n+    static INSTANCE: Lazy<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>> = lazy_init!(stdout_init);\n     return Stdout {\n         inner: INSTANCE.get().expect(\"cannot access stdout during shutdown\"),\n     };\n \n-    fn stdout_init() -> Arc<Mutex<LineWriter<StdoutRaw>>> {\n-        Arc::new(Mutex::new(LineWriter::new(stdout_raw())))\n+    fn stdout_init() -> Arc<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>> {\n+        Arc::new(ReentrantMutex::new(RefCell::new(LineWriter::new(stdout_raw()))))\n     }\n }\n \n@@ -264,23 +265,26 @@ impl Write for Stdout {\n     fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n         self.lock().write_all(buf)\n     }\n-    // Don't override write_fmt as it's possible to run arbitrary code during a\n-    // write_fmt, allowing the possibility of a recursive lock (aka deadlock)\n+    fn write_fmt(&mut self, args: fmt::Arguments) -> io::Result<()> {\n+        self.lock().write_fmt(args)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Write for StdoutLock<'a> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        self.inner.write(&buf[..cmp::min(buf.len(), OUT_MAX)])\n+        self.inner.borrow_mut().write(&buf[..cmp::min(buf.len(), OUT_MAX)])\n+    }\n+    fn flush(&mut self) -> io::Result<()> {\n+        self.inner.borrow_mut().flush()\n     }\n-    fn flush(&mut self) -> io::Result<()> { self.inner.flush() }\n }\n \n /// A handle to the standard error stream of a process.\n ///\n /// For more information, see `stderr`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Stderr {\n-    inner: Arc<Mutex<StderrRaw>>,\n+    inner: Arc<ReentrantMutex<RefCell<StderrRaw>>>,\n }\n \n /// A locked reference to the a `Stderr` handle.\n@@ -289,7 +293,7 @@ pub struct Stderr {\n /// method on `Stderr`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct StderrLock<'a> {\n-    inner: MutexGuard<'a, StderrRaw>,\n+    inner: ReentrantMutexGuard<'a, RefCell<StderrRaw>>,\n }\n \n /// Constructs a new reference to the standard error stream of a process.\n@@ -300,13 +304,13 @@ pub struct StderrLock<'a> {\n /// The returned handle implements the `Write` trait.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stderr() -> Stderr {\n-    static INSTANCE: Lazy<Mutex<StderrRaw>> = lazy_init!(stderr_init);\n+    static INSTANCE: Lazy<ReentrantMutex<RefCell<StderrRaw>>> = lazy_init!(stderr_init);\n     return Stderr {\n         inner: INSTANCE.get().expect(\"cannot access stderr during shutdown\"),\n     };\n \n-    fn stderr_init() -> Arc<Mutex<StderrRaw>> {\n-        Arc::new(Mutex::new(stderr_raw()))\n+    fn stderr_init() -> Arc<ReentrantMutex<RefCell<StderrRaw>>> {\n+        Arc::new(ReentrantMutex::new(RefCell::new(stderr_raw())))\n     }\n }\n \n@@ -333,14 +337,18 @@ impl Write for Stderr {\n     fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n         self.lock().write_all(buf)\n     }\n-    // Don't override write_fmt for the same reasons as Stdout\n+    fn write_fmt(&mut self, args: fmt::Arguments) -> io::Result<()> {\n+        self.lock().write_fmt(args)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Write for StderrLock<'a> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        self.inner.write(&buf[..cmp::min(buf.len(), OUT_MAX)])\n+        self.inner.borrow_mut().write(&buf[..cmp::min(buf.len(), OUT_MAX)])\n+    }\n+    fn flush(&mut self) -> io::Result<()> {\n+        self.inner.borrow_mut().flush()\n     }\n-    fn flush(&mut self) -> io::Result<()> { self.inner.flush() }\n }\n \n /// Resets the task-local stderr handle to the specified writer"}, {"sha": "654b33f1a579d1f5372093adcd8fb117af0d3881", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff804778c8d69d7835cf7076886ac5dac9a39659/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff804778c8d69d7835cf7076886ac5dac9a39659/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=ff804778c8d69d7835cf7076886ac5dac9a39659", "patch": "@@ -11,12 +11,12 @@\n use prelude::v1::*;\n \n use sync::atomic::{AtomicUsize, Ordering, ATOMIC_USIZE_INIT};\n-use sync::poison::{self, LockResult};\n-use sys::time::SteadyTime;\n+use sync::{mutex, MutexGuard, PoisonError};\n use sys_common::condvar as sys;\n use sys_common::mutex as sys_mutex;\n+use sys_common::poison::{self, LockResult};\n+use sys::time::SteadyTime;\n use time::Duration;\n-use sync::{mutex, MutexGuard, PoisonError};\n \n /// A Condition Variable\n ///"}, {"sha": "91e9714fbef48b896793f53deff438346ca804b7", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ff804778c8d69d7835cf7076886ac5dac9a39659/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff804778c8d69d7835cf7076886ac5dac9a39659/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=ff804778c8d69d7835cf7076886ac5dac9a39659", "patch": "@@ -20,15 +20,15 @@\n pub use alloc::arc::{Arc, Weak};\n pub use core::atomic;\n \n-pub use self::mutex::{Mutex, MutexGuard, StaticMutex};\n-pub use self::mutex::MUTEX_INIT;\n-pub use self::rwlock::{RwLock, StaticRwLock, RW_LOCK_INIT};\n-pub use self::rwlock::{RwLockReadGuard, RwLockWriteGuard};\n+pub use self::barrier::{Barrier, BarrierWaitResult};\n pub use self::condvar::{Condvar, StaticCondvar, CONDVAR_INIT};\n+pub use self::mutex::MUTEX_INIT;\n+pub use self::mutex::{Mutex, MutexGuard, StaticMutex};\n pub use self::once::{Once, ONCE_INIT};\n+pub use sys_common::poison::{PoisonError, TryLockError, TryLockResult, LockResult};\n+pub use self::rwlock::{RwLockReadGuard, RwLockWriteGuard};\n+pub use self::rwlock::{RwLock, StaticRwLock, RW_LOCK_INIT};\n pub use self::semaphore::{Semaphore, SemaphoreGuard};\n-pub use self::barrier::{Barrier, BarrierWaitResult};\n-pub use self::poison::{PoisonError, TryLockError, TryLockResult, LockResult};\n \n pub use self::future::Future;\n \n@@ -39,6 +39,5 @@ mod condvar;\n mod future;\n mod mutex;\n mod once;\n-mod poison;\n mod rwlock;\n mod semaphore;"}, {"sha": "46fb20cd6a2d69356b5f93fe38a9ef50bc7af725", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff804778c8d69d7835cf7076886ac5dac9a39659/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff804778c8d69d7835cf7076886ac5dac9a39659/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=ff804778c8d69d7835cf7076886ac5dac9a39659", "patch": "@@ -11,11 +11,11 @@\n use prelude::v1::*;\n \n use cell::UnsafeCell;\n+use fmt;\n use marker;\n use ops::{Deref, DerefMut};\n-use sync::poison::{self, TryLockError, TryLockResult, LockResult};\n use sys_common::mutex as sys;\n-use fmt;\n+use sys_common::poison::{self, TryLockError, TryLockResult, LockResult};\n \n /// A mutual exclusion primitive useful for protecting shared data\n ///\n@@ -212,7 +212,7 @@ impl<T> Mutex<T> {\n \n     /// Attempts to acquire this lock.\n     ///\n-    /// If the lock could not be acquired at this time, then `None` is returned.\n+    /// If the lock could not be acquired at this time, then `Err` is returned.\n     /// Otherwise, an RAII guard is returned. The lock will be unlocked when the\n     /// guard is dropped.\n     ///"}, {"sha": "eb6d46a5dda7a160e3a4212140def19945804481", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff804778c8d69d7835cf7076886ac5dac9a39659/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff804778c8d69d7835cf7076886ac5dac9a39659/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=ff804778c8d69d7835cf7076886ac5dac9a39659", "patch": "@@ -11,11 +11,11 @@\n use prelude::v1::*;\n \n use cell::UnsafeCell;\n+use fmt;\n use marker;\n use ops::{Deref, DerefMut};\n-use sync::poison::{self, LockResult, TryLockError, TryLockResult};\n+use sys_common::poison::{self, LockResult, TryLockError, TryLockResult};\n use sys_common::rwlock as sys;\n-use fmt;\n \n /// A reader-writer lock\n ///"}, {"sha": "8a01eace889c378abb7a248aa99e7acc6d06c06e", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff804778c8d69d7835cf7076886ac5dac9a39659/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff804778c8d69d7835cf7076886ac5dac9a39659/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=ff804778c8d69d7835cf7076886ac5dac9a39659", "patch": "@@ -29,6 +29,8 @@ pub mod condvar;\n pub mod mutex;\n pub mod net;\n pub mod net2;\n+pub mod poison;\n+pub mod remutex;\n pub mod rwlock;\n pub mod stack;\n pub mod thread;"}, {"sha": "347cd0b464ed95892e74b13adafdb30a3013e532", "filename": "src/libstd/sys/common/poison.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ff804778c8d69d7835cf7076886ac5dac9a39659/src%2Flibstd%2Fsys%2Fcommon%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff804778c8d69d7835cf7076886ac5dac9a39659/src%2Flibstd%2Fsys%2Fcommon%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fpoison.rs?ref=ff804778c8d69d7835cf7076886ac5dac9a39659", "previous_filename": "src/libstd/sync/poison.rs"}, {"sha": "b35063c0e234126757410e5d75e97b79f39ca385", "filename": "src/libstd/sys/common/remutex.rs", "status": "added", "additions": 233, "deletions": 0, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/ff804778c8d69d7835cf7076886ac5dac9a39659/src%2Flibstd%2Fsys%2Fcommon%2Fremutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff804778c8d69d7835cf7076886ac5dac9a39659/src%2Flibstd%2Fsys%2Fcommon%2Fremutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fremutex.rs?ref=ff804778c8d69d7835cf7076886ac5dac9a39659", "patch": "@@ -0,0 +1,233 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![unstable(feature = \"reentrant_mutex\", reason = \"new API\")]\n+\n+use prelude::v1::*;\n+\n+use fmt;\n+use marker;\n+use ops::Deref;\n+use sys_common::poison::{self, TryLockError, TryLockResult, LockResult};\n+use sys::mutex as sys;\n+\n+/// A re-entrant mutual exclusion\n+///\n+/// This mutex will block *other* threads waiting for the lock to become available. The thread\n+/// which has already locked the mutex can lock it multiple times without blocking, preventing a\n+/// common source of deadlocks.\n+pub struct ReentrantMutex<T> {\n+    inner: Box<sys::ReentrantMutex>,\n+    poison: poison::Flag,\n+    data: T,\n+}\n+\n+unsafe impl<T: Send> Send for ReentrantMutex<T> {}\n+unsafe impl<T: Send> Sync for ReentrantMutex<T> {}\n+\n+\n+/// An RAII implementation of a \"scoped lock\" of a mutex. When this structure is\n+/// dropped (falls out of scope), the lock will be unlocked.\n+///\n+/// The data protected by the mutex can be accessed through this guard via its\n+/// Deref and DerefMut implementations\n+#[must_use]\n+pub struct ReentrantMutexGuard<'a, T: 'a> {\n+    // funny underscores due to how Deref/DerefMut currently work (they\n+    // disregard field privacy).\n+    __lock: &'a ReentrantMutex<T>,\n+    __poison: poison::Guard,\n+}\n+\n+impl<'a, T> !marker::Send for ReentrantMutexGuard<'a, T> {}\n+\n+\n+impl<T> ReentrantMutex<T> {\n+    /// Creates a new reentrant mutex in an unlocked state.\n+    pub fn new(t: T) -> ReentrantMutex<T> {\n+        ReentrantMutex {\n+            inner: box unsafe { sys::ReentrantMutex::new() },\n+            poison: poison::FLAG_INIT,\n+            data: t,\n+        }\n+    }\n+\n+    /// Acquires a mutex, blocking the current thread until it is able to do so.\n+    ///\n+    /// This function will block the caller until it is available to acquire the mutex.\n+    /// Upon returning, the thread is the only thread with the mutex held. When the thread\n+    /// calling this method already holds the lock, the call shall succeed without\n+    /// blocking.\n+    ///\n+    /// # Failure\n+    ///\n+    /// If another user of this mutex panicked while holding the mutex, then\n+    /// this call will return failure if the mutex would otherwise be\n+    /// acquired.\n+    pub fn lock(&self) -> LockResult<ReentrantMutexGuard<T>> {\n+        unsafe { self.inner.lock() }\n+        ReentrantMutexGuard::new(&self)\n+    }\n+\n+    /// Attempts to acquire this lock.\n+    ///\n+    /// If the lock could not be acquired at this time, then `Err` is returned.\n+    /// Otherwise, an RAII guard is returned.\n+    ///\n+    /// This function does not block.\n+    ///\n+    /// # Failure\n+    ///\n+    /// If another user of this mutex panicked while holding the mutex, then\n+    /// this call will return failure if the mutex would otherwise be\n+    /// acquired.\n+    pub fn try_lock(&self) -> TryLockResult<ReentrantMutexGuard<T>> {\n+        if unsafe { self.inner.try_lock() } {\n+            Ok(try!(ReentrantMutexGuard::new(&self)))\n+        } else {\n+            Err(TryLockError::WouldBlock)\n+        }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T> Drop for ReentrantMutex<T> {\n+    fn drop(&mut self) {\n+        // This is actually safe b/c we know that there is no further usage of\n+        // this mutex (it's up to the user to arrange for a mutex to get\n+        // dropped, that's not our job)\n+        unsafe { self.inner.destroy() }\n+    }\n+}\n+\n+impl<T: fmt::Debug + 'static> fmt::Debug for ReentrantMutex<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.try_lock() {\n+            Ok(guard) => write!(f, \"ReentrantMutex {{ data: {:?} }}\", &*guard),\n+            Err(TryLockError::Poisoned(err)) => {\n+                write!(f, \"ReentrantMutex {{ data: Poisoned({:?}) }}\", &**err.get_ref())\n+            },\n+            Err(TryLockError::WouldBlock) => write!(f, \"ReentrantMutex {{ <locked> }}\")\n+        }\n+    }\n+}\n+\n+impl<'mutex, T> ReentrantMutexGuard<'mutex, T> {\n+    fn new(lock: &'mutex ReentrantMutex<T>)\n+            -> LockResult<ReentrantMutexGuard<'mutex, T>> {\n+        poison::map_result(lock.poison.borrow(), |guard| {\n+            ReentrantMutexGuard {\n+                __lock: lock,\n+                __poison: guard,\n+            }\n+        })\n+    }\n+}\n+\n+impl<'mutex, T> Deref for ReentrantMutexGuard<'mutex, T> {\n+    type Target = T;\n+\n+    fn deref<'a>(&'a self) -> &'a T {\n+        &self.__lock.data\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<'a, T> Drop for ReentrantMutexGuard<'a, T> {\n+    #[inline]\n+    fn drop(&mut self) {\n+        unsafe {\n+            self.__lock.poison.done(&self.__poison);\n+            self.__lock.inner.unlock();\n+        }\n+    }\n+}\n+\n+\n+#[cfg(test)]\n+mod test {\n+    use prelude::v1::*;\n+    use sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\n+    use cell::RefCell;\n+    use sync::Arc;\n+    use boxed;\n+    use thread;\n+\n+    #[test]\n+    fn smoke() {\n+        let m = ReentrantMutex::new(());\n+        {\n+            let a = m.lock().unwrap();\n+            {\n+                let b = m.lock().unwrap();\n+                {\n+                    let c = m.lock().unwrap();\n+                    assert_eq!(*c, ());\n+                }\n+                assert_eq!(*b, ());\n+            }\n+            assert_eq!(*a, ());\n+        }\n+    }\n+\n+    #[test]\n+    fn is_mutex() {\n+        let m = ReentrantMutex::new(RefCell::new(0));\n+        let lock = m.lock().unwrap();\n+        let handle = thread::scoped(|| {\n+            let lock = m.lock().unwrap();\n+            assert_eq!(*lock.borrow(), 4950);\n+        });\n+        for i in 0..100 {\n+            let mut lock = m.lock().unwrap();\n+            *lock.borrow_mut() += i;\n+        }\n+        drop(lock);\n+        drop(handle);\n+    }\n+\n+    #[test]\n+    fn trylock_works() {\n+        let m = ReentrantMutex::new(());\n+        let lock = m.try_lock().unwrap();\n+        let lock2 = m.try_lock().unwrap();\n+        {\n+            thread::scoped(|| {\n+                let lock = m.try_lock();\n+                assert!(lock.is_err());\n+            });\n+        }\n+        let lock3 = m.try_lock().unwrap();\n+    }\n+\n+    pub struct Answer<'a>(pub ReentrantMutexGuard<'a, RefCell<u32>>);\n+    impl<'a> Drop for Answer<'a> {\n+        fn drop(&mut self) {\n+            *self.0.borrow_mut() = 42;\n+        }\n+    }\n+\n+    #[test]\n+    fn poison_works() {\n+        let m = Arc::new(ReentrantMutex::new(RefCell::new(0)));\n+        let mc = m.clone();\n+        let result = thread::spawn(move ||{\n+            let lock = mc.lock().unwrap();\n+            *lock.borrow_mut() = 1;\n+            let lock2 = mc.lock().unwrap();\n+            *lock.borrow_mut() = 2;\n+            let answer = Answer(lock2);\n+            panic!(\"What the answer to my lifetimes dilemma is?\");\n+            drop(answer);\n+        }).join();\n+        assert!(result.is_err());\n+        let r = m.lock().err().unwrap().into_inner();\n+        assert_eq!(*r.borrow(), 42);\n+    }\n+}"}, {"sha": "af814653c1466c5f1d315bb69de7faaa28fcb3d0", "filename": "src/libstd/sys/unix/mutex.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ff804778c8d69d7835cf7076886ac5dac9a39659/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff804778c8d69d7835cf7076886ac5dac9a39659/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs?ref=ff804778c8d69d7835cf7076886ac5dac9a39659", "patch": "@@ -12,6 +12,7 @@ use prelude::v1::*;\n \n use cell::UnsafeCell;\n use sys::sync as ffi;\n+use mem;\n \n pub struct Mutex { inner: UnsafeCell<ffi::pthread_mutex_t> }\n \n@@ -67,3 +68,50 @@ impl Mutex {\n         debug_assert!(r == 0 || r == libc::EINVAL);\n     }\n }\n+\n+// FIXME: remove the box, because box happens twice now, once at the common layer and once here.\n+// Box is necessary here, because mutex may not change address after it is intialised on some\n+// platforms. Regular Mutex above handles this by offloading intialisation to the OS on first lock.\n+// Sadly, as far as reentrant mutexes go, this scheme is not quite portable and we must initialise\n+// when we create the mutex, in the `new`.\n+pub struct ReentrantMutex { inner: Box<UnsafeCell<ffi::pthread_mutex_t>> }\n+\n+unsafe impl Send for ReentrantMutex {}\n+unsafe impl Sync for ReentrantMutex {}\n+\n+impl ReentrantMutex {\n+    pub unsafe fn new() -> ReentrantMutex {\n+        let mutex = ReentrantMutex { inner: box mem::uninitialized() };\n+        let mut attr: ffi::pthread_mutexattr_t = mem::uninitialized();\n+        let result = ffi::pthread_mutexattr_init(&mut attr as *mut _);\n+        debug_assert_eq!(result, 0);\n+        let result = ffi::pthread_mutexattr_settype(&mut attr as *mut _,\n+                                                    ffi::PTHREAD_MUTEX_RECURSIVE);\n+        debug_assert_eq!(result, 0);\n+        let result = ffi::pthread_mutex_init(mutex.inner.get(), &attr as *const _);\n+        debug_assert_eq!(result, 0);\n+        let result = ffi::pthread_mutexattr_destroy(&mut attr as *mut _);\n+        debug_assert_eq!(result, 0);\n+        mutex\n+    }\n+\n+    pub unsafe fn lock(&self) {\n+        let result = ffi::pthread_mutex_lock(self.inner.get());\n+        debug_assert_eq!(result, 0);\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_lock(&self) -> bool {\n+        ffi::pthread_mutex_trylock(self.inner.get()) == 0\n+    }\n+\n+    pub unsafe fn unlock(&self) {\n+        let result = ffi::pthread_mutex_unlock(self.inner.get());\n+        debug_assert_eq!(result, 0);\n+    }\n+\n+    pub unsafe fn destroy(&self) {\n+        let result = ffi::pthread_mutex_destroy(self.inner.get());\n+        debug_assert_eq!(result, 0);\n+    }\n+}"}, {"sha": "41e1e206a423a7c43a0869c6ec642a5aedf9d1e9", "filename": "src/libstd/sys/unix/sync.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ff804778c8d69d7835cf7076886ac5dac9a39659/src%2Flibstd%2Fsys%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff804778c8d69d7835cf7076886ac5dac9a39659/src%2Flibstd%2Fsys%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fsync.rs?ref=ff804778c8d69d7835cf7076886ac5dac9a39659", "patch": "@@ -12,17 +12,25 @@\n \n use libc;\n \n-pub use self::os::{PTHREAD_MUTEX_INITIALIZER, pthread_mutex_t};\n+pub use self::os::{PTHREAD_MUTEX_INITIALIZER, PTHREAD_MUTEX_RECURSIVE, pthread_mutex_t,\n+                   pthread_mutexattr_t};\n pub use self::os::{PTHREAD_COND_INITIALIZER, pthread_cond_t};\n pub use self::os::{PTHREAD_RWLOCK_INITIALIZER, pthread_rwlock_t};\n \n extern {\n     // mutexes\n+    pub fn pthread_mutex_init(lock: *mut pthread_mutex_t, attr: *const pthread_mutexattr_t)\n+                            -> libc::c_int;\n     pub fn pthread_mutex_destroy(lock: *mut pthread_mutex_t) -> libc::c_int;\n     pub fn pthread_mutex_lock(lock: *mut pthread_mutex_t) -> libc::c_int;\n     pub fn pthread_mutex_trylock(lock: *mut pthread_mutex_t) -> libc::c_int;\n     pub fn pthread_mutex_unlock(lock: *mut pthread_mutex_t) -> libc::c_int;\n \n+    pub fn pthread_mutexattr_init(attr: *mut pthread_mutexattr_t) -> libc::c_int;\n+    pub fn pthread_mutexattr_destroy(attr: *mut pthread_mutexattr_t) -> libc::c_int;\n+    pub fn pthread_mutexattr_settype(attr: *mut pthread_mutexattr_t, _type: libc::c_int)\n+                                    -> libc::c_int;\n+\n     // cvars\n     pub fn pthread_cond_wait(cond: *mut pthread_cond_t,\n                              lock: *mut pthread_mutex_t) -> libc::c_int;\n@@ -52,12 +60,14 @@ mod os {\n     use libc;\n \n     pub type pthread_mutex_t = *mut libc::c_void;\n+    pub type pthread_mutexattr_t = *mut libc::c_void;\n     pub type pthread_cond_t = *mut libc::c_void;\n     pub type pthread_rwlock_t = *mut libc::c_void;\n \n     pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = 0 as *mut _;\n     pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = 0 as *mut _;\n     pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = 0 as *mut _;\n+    pub const PTHREAD_MUTEX_RECURSIVE: libc::c_int = 2;\n }\n \n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n@@ -95,6 +105,12 @@ mod os {\n         __opaque: [u8; __PTHREAD_MUTEX_SIZE__],\n     }\n     #[repr(C)]\n+    pub struct pthread_mutexattr_t {\n+        __sig: libc::c_long,\n+        // note, that this is 16 bytes just to be safe, the actual struct might be smaller.\n+        __opaque: [u8; 16],\n+    }\n+    #[repr(C)]\n     pub struct pthread_cond_t {\n         __sig: libc::c_long,\n         __opaque: [u8; __PTHREAD_COND_SIZE__],\n@@ -117,6 +133,8 @@ mod os {\n         __sig: _PTHREAD_RWLOCK_SIG_INIT,\n         __opaque: [0; __PTHREAD_RWLOCK_SIZE__],\n     };\n+\n+    pub const PTHREAD_MUTEX_RECURSIVE: libc::c_int = 2;\n }\n \n #[cfg(target_os = \"linux\")]\n@@ -161,6 +179,12 @@ mod os {\n         size: [u8; __SIZEOF_PTHREAD_MUTEX_T],\n     }\n     #[repr(C)]\n+    pub struct pthread_mutexattr_t {\n+        __align: libc::c_longlong,\n+        // note, that this is 16 bytes just to be safe, the actual struct might be smaller.\n+        size: [u8; 16],\n+    }\n+    #[repr(C)]\n     pub struct pthread_cond_t {\n         __align: libc::c_longlong,\n         size: [u8; __SIZEOF_PTHREAD_COND_T],\n@@ -183,13 +207,15 @@ mod os {\n         __align: 0,\n         size: [0; __SIZEOF_PTHREAD_RWLOCK_T],\n     };\n+    pub const PTHREAD_MUTEX_RECURSIVE: libc::c_int = 1;\n }\n #[cfg(target_os = \"android\")]\n mod os {\n     use libc;\n \n     #[repr(C)]\n     pub struct pthread_mutex_t { value: libc::c_int }\n+    pub type pthread_mutexattr_t = libc::c_long;\n     #[repr(C)]\n     pub struct pthread_cond_t { value: libc::c_int }\n     #[repr(C)]\n@@ -218,4 +244,5 @@ mod os {\n         pendingWriters: 0,\n         reserved: [0 as *mut _; 4],\n     };\n+    pub const PTHREAD_MUTEX_RECURSIVE: libc::c_int = 1;\n }"}, {"sha": "ca20858bb5bc503936ef09078626454d299e390c", "filename": "src/libstd/sys/windows/mutex.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ff804778c8d69d7835cf7076886ac5dac9a39659/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff804778c8d69d7835cf7076886ac5dac9a39659/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs?ref=ff804778c8d69d7835cf7076886ac5dac9a39659", "patch": "@@ -12,6 +12,7 @@ use prelude::v1::*;\n \n use cell::UnsafeCell;\n use sys::sync as ffi;\n+use mem;\n \n pub struct Mutex { inner: UnsafeCell<ffi::SRWLOCK> }\n \n@@ -57,3 +58,33 @@ impl Mutex {\n         // ...\n     }\n }\n+\n+pub struct ReentrantMutex { inner: Box<UnsafeCell<ffi::CRITICAL_SECTION>> }\n+\n+unsafe impl Send for ReentrantMutex {}\n+unsafe impl Sync for ReentrantMutex {}\n+\n+impl ReentrantMutex {\n+    pub unsafe fn new() -> ReentrantMutex {\n+        let mutex = ReentrantMutex { inner: box mem::uninitialized() };\n+        ffi::InitializeCriticalSection(mutex.inner.get());\n+        mutex\n+    }\n+\n+    pub unsafe fn lock(&self) {\n+        ffi::EnterCriticalSection(self.inner.get());\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_lock(&self) -> bool {\n+        ffi::TryEnterCriticalSection(self.inner.get()) != 0\n+    }\n+\n+    pub unsafe fn unlock(&self) {\n+        ffi::LeaveCriticalSection(self.inner.get());\n+    }\n+\n+    pub unsafe fn destroy(&self) {\n+        ffi::DeleteCriticalSection(self.inner.get());\n+    }\n+}"}, {"sha": "5410259540eaccbf5338c460a0c0c0add8a2a7c1", "filename": "src/libstd/sys/windows/sync.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ff804778c8d69d7835cf7076886ac5dac9a39659/src%2Flibstd%2Fsys%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff804778c8d69d7835cf7076886ac5dac9a39659/src%2Flibstd%2Fsys%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fsync.rs?ref=ff804778c8d69d7835cf7076886ac5dac9a39659", "patch": "@@ -8,17 +8,27 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use libc::{BOOL, DWORD, LPVOID, c_ulong};\n+use libc::{BOOL, DWORD, LPVOID, LONG, HANDLE, c_ulong};\n use libc::types::os::arch::extra::BOOLEAN;\n \n pub type PCONDITION_VARIABLE = *mut CONDITION_VARIABLE;\n pub type PSRWLOCK = *mut SRWLOCK;\n pub type ULONG = c_ulong;\n+pub type ULONG_PTR = c_ulong;\n \n #[repr(C)]\n pub struct CONDITION_VARIABLE { pub ptr: LPVOID }\n #[repr(C)]\n pub struct SRWLOCK { pub ptr: LPVOID }\n+#[repr(C)]\n+pub struct CRITICAL_SECTION {\n+    CriticalSectionDebug: LPVOID,\n+    LockCount: LONG,\n+    RecursionCount: LONG,\n+    OwningThread: HANDLE,\n+    LockSemaphore: HANDLE,\n+    SpinCount: ULONG_PTR\n+}\n \n pub const CONDITION_VARIABLE_INIT: CONDITION_VARIABLE = CONDITION_VARIABLE {\n     ptr: 0 as *mut _,\n@@ -41,4 +51,10 @@ extern \"system\" {\n     pub fn ReleaseSRWLockShared(SRWLock: PSRWLOCK);\n     pub fn TryAcquireSRWLockExclusive(SRWLock: PSRWLOCK) -> BOOLEAN;\n     pub fn TryAcquireSRWLockShared(SRWLock: PSRWLOCK) -> BOOLEAN;\n+\n+    pub fn InitializeCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n+    pub fn EnterCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n+    pub fn TryEnterCriticalSection(CriticalSection: *mut CRITICAL_SECTION) -> BOOLEAN;\n+    pub fn LeaveCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n+    pub fn DeleteCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n }"}, {"sha": "df3b572bce49b22157787fe9c0389fb67e8c5db4", "filename": "src/test/run-pass/atomic-print.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ff804778c8d69d7835cf7076886ac5dac9a39659/src%2Ftest%2Frun-pass%2Fatomic-print.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff804778c8d69d7835cf7076886ac5dac9a39659/src%2Ftest%2Frun-pass%2Fatomic-print.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fatomic-print.rs?ref=ff804778c8d69d7835cf7076886ac5dac9a39659", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::{env, fmt, process, sync, thread};\n+\n+struct SlowFmt(u32);\n+impl fmt::Debug for SlowFmt {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        thread::sleep_ms(3);\n+        self.0.fmt(f)\n+    }\n+}\n+\n+fn do_print(x: u32) {\n+    let x = SlowFmt(x);\n+    println!(\"{:?}{:?}{:?}{:?}{:?}\", x, x, x, x, x);\n+}\n+\n+fn main(){\n+    if env::args().count() == 2 {\n+        let barrier = sync::Arc::new(sync::Barrier::new(2));\n+        let tbarrier = barrier.clone();\n+        let t = thread::scoped(||{\n+            tbarrier.wait();\n+            do_print(1);\n+        });\n+        barrier.wait();\n+        do_print(2);\n+        t.join();\n+    } else {\n+        let this = env::args().next().unwrap();\n+        let output = process::Command::new(this).arg(\"-\").output().unwrap();\n+        for line in String::from_utf8(output.stdout).unwrap().lines() {\n+            match line.chars().next().unwrap() {\n+                '1' => assert_eq!(line, \"11111\"),\n+                '2' => assert_eq!(line, \"22222\"),\n+                _   => panic!(\"Unexpected character\")\n+            }\n+        }\n+    }\n+}"}]}