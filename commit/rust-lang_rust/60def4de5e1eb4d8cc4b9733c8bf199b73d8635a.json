{"sha": "60def4de5e1eb4d8cc4b9733c8bf199b73d8635a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwZGVmNGRlNWUxZWI0ZDhjYzRiOTczM2M4YmYxOTliNzNkODYzNWE=", "commit": {"author": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2021-02-24T20:29:09Z"}, "committer": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2021-03-09T19:12:41Z"}, "message": "[WIP] Eagerly construct bodies of THIR", "tree": {"sha": "3e731b377149117ad9cd73e195b1d67ad3b697cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e731b377149117ad9cd73e195b1d67ad3b697cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a", "html_url": "https://github.com/rust-lang/rust/commit/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a/comments", "author": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a5d45f68cadc8fff4fbb557780f92b403b19c19", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a5d45f68cadc8fff4fbb557780f92b403b19c19", "html_url": "https://github.com/rust-lang/rust/commit/3a5d45f68cadc8fff4fbb557780f92b403b19c19"}], "stats": {"total": 2869, "additions": 1315, "deletions": 1554}, "files": [{"sha": "2d1fd4d09d1a447badca352e22ca50da067a8e4b", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=60def4de5e1eb4d8cc4b9733c8bf199b73d8635a", "patch": "@@ -2,7 +2,6 @@ use crate::build::matches::ArmHasGuard;\n use crate::build::ForGuard::OutsideGuard;\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n use crate::thir::*;\n-use rustc_hir as hir;\n use rustc_middle::mir::*;\n use rustc_session::lint::builtin::UNSAFE_OP_IN_UNSAFE_FN;\n use rustc_session::lint::Level;\n@@ -13,7 +12,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         destination: Place<'tcx>,\n         block: BasicBlock,\n-        ast_block: &'tcx hir::Block<'tcx>,\n+        ast_block: &Block<'tcx>,\n         source_info: SourceInfo,\n     ) -> BlockAnd<()> {\n         let Block {\n@@ -24,22 +23,29 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             expr,\n             targeted_by_break,\n             safety_mode,\n-        } = self.hir.mirror(ast_block);\n+        } = ast_block;\n         self.in_opt_scope(opt_destruction_scope.map(|de| (de, source_info)), move |this| {\n-            this.in_scope((region_scope, source_info), LintLevel::Inherited, move |this| {\n-                if targeted_by_break {\n-                    this.in_breakable_scope(None, destination, span, |this| {\n+            this.in_scope((*region_scope, source_info), LintLevel::Inherited, move |this| {\n+                if *targeted_by_break {\n+                    this.in_breakable_scope(None, destination, *span, |this| {\n                         Some(this.ast_block_stmts(\n                             destination,\n                             block,\n-                            span,\n-                            stmts,\n-                            expr,\n-                            safety_mode,\n+                            *span,\n+                            &stmts,\n+                            expr.as_deref(),\n+                            *safety_mode,\n                         ))\n                     })\n                 } else {\n-                    this.ast_block_stmts(destination, block, span, stmts, expr, safety_mode)\n+                    this.ast_block_stmts(\n+                        destination,\n+                        block,\n+                        *span,\n+                        &stmts,\n+                        expr.as_deref(),\n+                        *safety_mode,\n+                    )\n                 }\n             })\n         })\n@@ -50,8 +56,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         destination: Place<'tcx>,\n         mut block: BasicBlock,\n         span: Span,\n-        stmts: Vec<StmtRef<'tcx>>,\n-        expr: Option<ExprRef<'tcx>>,\n+        stmts: &[Stmt<'tcx>],\n+        expr: Option<&Expr<'tcx>>,\n         safety_mode: BlockSafety,\n     ) -> BlockAnd<()> {\n         let this = self;\n@@ -79,19 +85,17 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         this.update_source_scope_for_safety_mode(span, safety_mode);\n \n         let source_info = this.source_info(span);\n-        for stmt in stmts {\n-            let Stmt { kind, opt_destruction_scope } = this.hir.mirror(stmt);\n+        for Stmt { kind, opt_destruction_scope } in stmts {\n             match kind {\n                 StmtKind::Expr { scope, expr } => {\n                     this.block_context.push(BlockFrame::Statement { ignores_expr_result: true });\n                     unpack!(\n                         block = this.in_opt_scope(\n                             opt_destruction_scope.map(|de| (de, source_info)),\n                             |this| {\n-                                let si = (scope, source_info);\n+                                let si = (*scope, source_info);\n                                 this.in_scope(si, LintLevel::Inherited, |this| {\n-                                    let expr = this.hir.mirror(expr);\n-                                    this.stmt_expr(block, expr, Some(scope))\n+                                    this.stmt_expr(block, &expr, Some(*scope))\n                                 })\n                             }\n                         )\n@@ -102,7 +106,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     this.block_context.push(BlockFrame::Statement { ignores_expr_result });\n \n                     // Enter the remainder scope, i.e., the bindings' destruction scope.\n-                    this.push_scope((remainder_scope, source_info));\n+                    this.push_scope((*remainder_scope, source_info));\n                     let_scope_stack.push(remainder_scope);\n \n                     // Declare the bindings, which may create a source scope.\n@@ -114,29 +118,29 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                     // Evaluate the initializer, if present.\n                     if let Some(init) = initializer {\n-                        let initializer_span = init.span();\n+                        let initializer_span = init.span;\n \n                         unpack!(\n                             block = this.in_opt_scope(\n                                 opt_destruction_scope.map(|de| (de, source_info)),\n                                 |this| {\n-                                    let scope = (init_scope, source_info);\n-                                    this.in_scope(scope, lint_level, |this| {\n+                                    let scope = (*init_scope, source_info);\n+                                    this.in_scope(scope, *lint_level, |this| {\n                                         this.declare_bindings(\n                                             visibility_scope,\n                                             remainder_span,\n                                             &pattern,\n                                             ArmHasGuard(false),\n                                             Some((None, initializer_span)),\n                                         );\n-                                        this.expr_into_pattern(block, pattern, init)\n+                                        this.expr_into_pattern(block, pattern.clone(), &init)\n                                     })\n                                 }\n                             )\n                         );\n                     } else {\n-                        let scope = (init_scope, source_info);\n-                        unpack!(this.in_scope(scope, lint_level, |this| {\n+                        let scope = (*init_scope, source_info);\n+                        unpack!(this.in_scope(scope, *lint_level, |this| {\n                             this.declare_bindings(\n                                 visibility_scope,\n                                 remainder_span,\n@@ -176,13 +180,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         if let Some(expr) = expr {\n             let tail_result_is_ignored =\n                 destination_ty.is_unit() || this.block_context.currently_ignores_tail_results();\n-            let span = match expr {\n-                ExprRef::Thir(expr) => expr.span,\n-                ExprRef::Mirror(ref expr) => expr.span,\n-            };\n-            this.block_context.push(BlockFrame::TailExpr { tail_result_is_ignored, span });\n+            this.block_context\n+                .push(BlockFrame::TailExpr { tail_result_is_ignored, span: expr.span });\n \n-            unpack!(block = this.into(destination, block, expr));\n+            unpack!(block = this.expr_into_dest(destination, block, expr));\n             let popped = this.block_context.pop();\n \n             assert!(popped.map_or(false, |bf| bf.is_tail_expr()));\n@@ -200,7 +201,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // Finally, we pop all the let scopes before exiting out from the scope of block\n         // itself.\n         for scope in let_scope_stack.into_iter().rev() {\n-            unpack!(block = this.pop_scope((scope, source_info), block));\n+            unpack!(block = this.pop_scope((*scope, source_info), block));\n         }\n         // Restore the original source scope.\n         this.source_scope = outer_source_scope;"}, {"sha": "1096d2eedfe218bd6075410ed0477b04ea2b765c", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=60def4de5e1eb4d8cc4b9733c8bf199b73d8635a", "patch": "@@ -8,33 +8,27 @@ use rustc_middle::ty::CanonicalUserTypeAnnotation;\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, yielding a compile-time constant. Assumes that\n     /// `expr` is a valid compile-time constant!\n-    crate fn as_constant<M>(&mut self, expr: M) -> Constant<'tcx>\n-    where\n-        M: Mirror<'tcx, Output = Expr<'tcx>>,\n-    {\n-        let expr = self.hir.mirror(expr);\n-        self.expr_as_constant(expr)\n-    }\n-\n-    fn expr_as_constant(&mut self, expr: Expr<'tcx>) -> Constant<'tcx> {\n+    crate fn as_constant(&mut self, expr: &Expr<'tcx>) -> Constant<'tcx> {\n         let this = self;\n         let Expr { ty, temp_lifetime: _, span, kind } = expr;\n         match kind {\n-            ExprKind::Scope { region_scope: _, lint_level: _, value } => this.as_constant(value),\n+            ExprKind::Scope { region_scope: _, lint_level: _, value } => this.as_constant(&value),\n             ExprKind::Literal { literal, user_ty, const_id: _ } => {\n                 let user_ty = user_ty.map(|user_ty| {\n                     this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n-                        span,\n+                        span: *span,\n                         user_ty,\n                         inferred_ty: ty,\n                     })\n                 });\n-                assert_eq!(literal.ty, ty);\n-                Constant { span, user_ty, literal }\n+                assert_eq!(literal.ty, *ty);\n+                Constant { span: *span, user_ty, literal }\n+            }\n+            ExprKind::StaticRef { literal, .. } => Constant { span: *span, user_ty: None, literal },\n+            ExprKind::ConstBlock { value } => {\n+                Constant { span: *span, user_ty: None, literal: value }\n             }\n-            ExprKind::StaticRef { literal, .. } => Constant { span, user_ty: None, literal },\n-            ExprKind::ConstBlock { value } => Constant { span, user_ty: None, literal: value },\n-            _ => span_bug!(span, \"expression is not a valid constant {:?}\", kind),\n+            _ => span_bug!(*span, \"expression is not a valid constant {:?}\", kind),\n         }\n     }\n }"}, {"sha": "faa8ea759d70970b39695d2c4b412b8412a59ba1", "filename": "compiler/rustc_mir_build/src/build/expr/as_operand.rs", "status": "modified", "additions": 24, "deletions": 53, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs?ref=60def4de5e1eb4d8cc4b9733c8bf199b73d8635a", "patch": "@@ -14,10 +14,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// after the current enclosing `ExprKind::Scope` has ended, so\n     /// please do *not* return it from functions to avoid bad\n     /// miscompiles.\n-    crate fn as_local_operand<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<Operand<'tcx>>\n-    where\n-        M: Mirror<'tcx, Output = Expr<'tcx>>,\n-    {\n+    crate fn as_local_operand(\n+        &mut self,\n+        block: BasicBlock,\n+        expr: &Expr<'tcx>,\n+    ) -> BlockAnd<Operand<'tcx>> {\n         let local_scope = self.local_scope();\n         self.as_operand(block, Some(local_scope), expr)\n     }\n@@ -70,14 +71,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// value to the stack.\n     ///\n     /// See #68034 for more details.\n-    crate fn as_local_call_operand<M>(\n+    crate fn as_local_call_operand(\n         &mut self,\n         block: BasicBlock,\n-        expr: M,\n-    ) -> BlockAnd<Operand<'tcx>>\n-    where\n-        M: Mirror<'tcx, Output = Expr<'tcx>>,\n-    {\n+        expr: &Expr<'tcx>,\n+    ) -> BlockAnd<Operand<'tcx>> {\n         let local_scope = self.local_scope();\n         self.as_call_operand(block, Some(local_scope), expr)\n     }\n@@ -88,52 +86,27 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// this time.\n     ///\n     /// The operand is known to be live until the end of `scope`.\n-    crate fn as_operand<M>(\n-        &mut self,\n-        block: BasicBlock,\n-        scope: Option<region::Scope>,\n-        expr: M,\n-    ) -> BlockAnd<Operand<'tcx>>\n-    where\n-        M: Mirror<'tcx, Output = Expr<'tcx>>,\n-    {\n-        let expr = self.hir.mirror(expr);\n-        self.expr_as_operand(block, scope, expr)\n-    }\n-\n+    ///\n     /// Like `as_local_call_operand`, except that the argument will\n     /// not be valid once `scope` ends.\n-    fn as_call_operand<M>(\n-        &mut self,\n-        block: BasicBlock,\n-        scope: Option<region::Scope>,\n-        expr: M,\n-    ) -> BlockAnd<Operand<'tcx>>\n-    where\n-        M: Mirror<'tcx, Output = Expr<'tcx>>,\n-    {\n-        let expr = self.hir.mirror(expr);\n-        self.expr_as_call_operand(block, scope, expr)\n-    }\n-\n-    fn expr_as_operand(\n+    crate fn as_operand(\n         &mut self,\n         mut block: BasicBlock,\n         scope: Option<region::Scope>,\n-        expr: Expr<'tcx>,\n+        expr: &Expr<'tcx>,\n     ) -> BlockAnd<Operand<'tcx>> {\n-        debug!(\"expr_as_operand(block={:?}, expr={:?})\", block, expr);\n+        debug!(\"as_operand(block={:?}, expr={:?})\", block, expr);\n         let this = self;\n \n-        if let ExprKind::Scope { region_scope, lint_level, value } = expr.kind {\n+        if let ExprKind::Scope { region_scope, lint_level, value } = &expr.kind {\n             let source_info = this.source_info(expr.span);\n-            let region_scope = (region_scope, source_info);\n+            let region_scope = (*region_scope, source_info);\n             return this\n-                .in_scope(region_scope, lint_level, |this| this.as_operand(block, scope, value));\n+                .in_scope(region_scope, *lint_level, |this| this.as_operand(block, scope, &value));\n         }\n \n         let category = Category::of(&expr.kind).unwrap();\n-        debug!(\"expr_as_operand: category={:?} for={:?}\", category, expr.kind);\n+        debug!(\"as_operand: category={:?} for={:?}\", category, expr.kind);\n         match category {\n             Category::Constant => {\n                 let constant = this.as_constant(expr);\n@@ -146,20 +119,20 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    fn expr_as_call_operand(\n+    crate fn as_call_operand(\n         &mut self,\n         mut block: BasicBlock,\n         scope: Option<region::Scope>,\n-        expr: Expr<'tcx>,\n+        expr: &Expr<'tcx>,\n     ) -> BlockAnd<Operand<'tcx>> {\n-        debug!(\"expr_as_call_operand(block={:?}, expr={:?})\", block, expr);\n+        debug!(\"as_call_operand(block={:?}, expr={:?})\", block, expr);\n         let this = self;\n \n-        if let ExprKind::Scope { region_scope, lint_level, value } = expr.kind {\n+        if let ExprKind::Scope { region_scope, lint_level, value } = &expr.kind {\n             let source_info = this.source_info(expr.span);\n-            let region_scope = (region_scope, source_info);\n-            return this.in_scope(region_scope, lint_level, |this| {\n-                this.as_call_operand(block, scope, value)\n+            let region_scope = (*region_scope, source_info);\n+            return this.in_scope(region_scope, *lint_level, |this| {\n+                this.as_call_operand(block, scope, &value)\n             });\n         }\n \n@@ -177,8 +150,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // As described above, detect the case where we are passing a value of unsized\n                 // type, and that value is coming from the deref of a box.\n                 if let ExprKind::Deref { ref arg } = expr.kind {\n-                    let arg = this.hir.mirror(arg.clone());\n-\n                     // Generate let tmp0 = arg0\n                     let operand = unpack!(block = this.as_temp(block, scope, arg, Mutability::Mut));\n \n@@ -193,6 +164,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n         }\n \n-        this.expr_as_operand(block, scope, expr)\n+        this.as_operand(block, scope, expr)\n     }\n }"}, {"sha": "156f8d2e7045c754e45c950b2b82e2b3266f4dce", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 38, "deletions": 53, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=60def4de5e1eb4d8cc4b9733c8bf199b73d8635a", "patch": "@@ -347,25 +347,22 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Extra care is needed if any user code is allowed to run between calling\n     /// this method and using it, as is the case for `match` and index\n     /// expressions.\n-    crate fn as_place<M>(&mut self, mut block: BasicBlock, expr: M) -> BlockAnd<Place<'tcx>>\n-    where\n-        M: Mirror<'tcx, Output = Expr<'tcx>>,\n-    {\n+    crate fn as_place(\n+        &mut self,\n+        mut block: BasicBlock,\n+        expr: &Expr<'tcx>,\n+    ) -> BlockAnd<Place<'tcx>> {\n         let place_builder = unpack!(block = self.as_place_builder(block, expr));\n         block.and(place_builder.into_place(self.hir.tcx(), self.hir.typeck_results()))\n     }\n \n     /// This is used when constructing a compound `Place`, so that we can avoid creating\n     /// intermediate `Place` values until we know the full set of projections.\n-    crate fn as_place_builder<M>(\n+    crate fn as_place_builder(\n         &mut self,\n         block: BasicBlock,\n-        expr: M,\n-    ) -> BlockAnd<PlaceBuilder<'tcx>>\n-    where\n-        M: Mirror<'tcx, Output = Expr<'tcx>>,\n-    {\n-        let expr = self.hir.mirror(expr);\n+        expr: &Expr<'tcx>,\n+    ) -> BlockAnd<PlaceBuilder<'tcx>> {\n         self.expr_as_place(block, expr, Mutability::Mut, None)\n     }\n \n@@ -374,14 +371,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// place. The place itself may or may not be mutable:\n     /// * If this expr is a place expr like a.b, then we will return that place.\n     /// * Otherwise, a temporary is created: in that event, it will be an immutable temporary.\n-    crate fn as_read_only_place<M>(\n+    crate fn as_read_only_place(\n         &mut self,\n         mut block: BasicBlock,\n-        expr: M,\n-    ) -> BlockAnd<Place<'tcx>>\n-    where\n-        M: Mirror<'tcx, Output = Expr<'tcx>>,\n-    {\n+        expr: &Expr<'tcx>,\n+    ) -> BlockAnd<Place<'tcx>> {\n         let place_builder = unpack!(block = self.as_read_only_place_builder(block, expr));\n         block.and(place_builder.into_place(self.hir.tcx(), self.hir.typeck_results()))\n     }\n@@ -392,22 +386,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// place. The place itself may or may not be mutable:\n     /// * If this expr is a place expr like a.b, then we will return that place.\n     /// * Otherwise, a temporary is created: in that event, it will be an immutable temporary.\n-    fn as_read_only_place_builder<M>(\n+    fn as_read_only_place_builder(\n         &mut self,\n         block: BasicBlock,\n-        expr: M,\n-    ) -> BlockAnd<PlaceBuilder<'tcx>>\n-    where\n-        M: Mirror<'tcx, Output = Expr<'tcx>>,\n-    {\n-        let expr = self.hir.mirror(expr);\n+        expr: &Expr<'tcx>,\n+    ) -> BlockAnd<PlaceBuilder<'tcx>> {\n         self.expr_as_place(block, expr, Mutability::Not, None)\n     }\n \n     fn expr_as_place(\n         &mut self,\n         mut block: BasicBlock,\n-        expr: Expr<'tcx>,\n+        expr: &Expr<'tcx>,\n         mutability: Mutability,\n         fake_borrow_temps: Option<&mut Vec<Local>>,\n     ) -> BlockAnd<PlaceBuilder<'tcx>> {\n@@ -416,61 +406,59 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let this = self;\n         let expr_span = expr.span;\n         let source_info = this.source_info(expr_span);\n-        match expr.kind {\n+        match &expr.kind {\n             ExprKind::Scope { region_scope, lint_level, value } => {\n-                this.in_scope((region_scope, source_info), lint_level, |this| {\n-                    let value = this.hir.mirror(value);\n-                    this.expr_as_place(block, value, mutability, fake_borrow_temps)\n+                this.in_scope((*region_scope, source_info), *lint_level, |this| {\n+                    this.expr_as_place(block, &value, mutability, fake_borrow_temps)\n                 })\n             }\n             ExprKind::Field { lhs, name } => {\n-                let lhs = this.hir.mirror(lhs);\n-                let place_builder =\n-                    unpack!(block = this.expr_as_place(block, lhs, mutability, fake_borrow_temps,));\n-                block.and(place_builder.field(name, expr.ty))\n+                let place_builder = unpack!(\n+                    block = this.expr_as_place(block, &lhs, mutability, fake_borrow_temps,)\n+                );\n+                block.and(place_builder.field(*name, expr.ty))\n             }\n             ExprKind::Deref { arg } => {\n-                let arg = this.hir.mirror(arg);\n-                let place_builder =\n-                    unpack!(block = this.expr_as_place(block, arg, mutability, fake_borrow_temps,));\n+                let place_builder = unpack!(\n+                    block = this.expr_as_place(block, &arg, mutability, fake_borrow_temps,)\n+                );\n                 block.and(place_builder.deref())\n             }\n             ExprKind::Index { lhs, index } => this.lower_index_expression(\n                 block,\n-                lhs,\n-                index,\n+                &lhs,\n+                &index,\n                 mutability,\n                 fake_borrow_temps,\n                 expr.temp_lifetime,\n                 expr_span,\n                 source_info,\n             ),\n             ExprKind::UpvarRef { closure_def_id, var_hir_id } => {\n-                let upvar_id = ty::UpvarId::new(var_hir_id, closure_def_id.expect_local());\n+                let upvar_id = ty::UpvarId::new(*var_hir_id, closure_def_id.expect_local());\n                 this.lower_captured_upvar(block, upvar_id)\n             }\n \n             ExprKind::VarRef { id } => {\n-                let place_builder = if this.is_bound_var_in_guard(id) {\n-                    let index = this.var_local_id(id, RefWithinGuard);\n+                let place_builder = if this.is_bound_var_in_guard(*id) {\n+                    let index = this.var_local_id(*id, RefWithinGuard);\n                     PlaceBuilder::from(index).deref()\n                 } else {\n-                    let index = this.var_local_id(id, OutsideGuard);\n+                    let index = this.var_local_id(*id, OutsideGuard);\n                     PlaceBuilder::from(index)\n                 };\n                 block.and(place_builder)\n             }\n \n             ExprKind::PlaceTypeAscription { source, user_ty } => {\n-                let source = this.hir.mirror(source);\n                 let place_builder = unpack!(\n-                    block = this.expr_as_place(block, source, mutability, fake_borrow_temps,)\n+                    block = this.expr_as_place(block, &source, mutability, fake_borrow_temps,)\n                 );\n                 if let Some(user_ty) = user_ty {\n                     let annotation_index =\n                         this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n                             span: source_info.span,\n-                            user_ty,\n+                            user_ty: *user_ty,\n                             inferred_ty: expr.ty,\n                         });\n \n@@ -493,14 +481,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 block.and(place_builder)\n             }\n             ExprKind::ValueTypeAscription { source, user_ty } => {\n-                let source = this.hir.mirror(source);\n                 let temp =\n-                    unpack!(block = this.as_temp(block, source.temp_lifetime, source, mutability));\n+                    unpack!(block = this.as_temp(block, source.temp_lifetime, &source, mutability));\n                 if let Some(user_ty) = user_ty {\n                     let annotation_index =\n                         this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n                             span: source_info.span,\n-                            user_ty,\n+                            user_ty: *user_ty,\n                             inferred_ty: expr.ty,\n                         });\n                     this.cfg.push(\n@@ -599,22 +586,20 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn lower_index_expression(\n         &mut self,\n         mut block: BasicBlock,\n-        base: ExprRef<'tcx>,\n-        index: ExprRef<'tcx>,\n+        base: &Expr<'tcx>,\n+        index: &Expr<'tcx>,\n         mutability: Mutability,\n         fake_borrow_temps: Option<&mut Vec<Local>>,\n         temp_lifetime: Option<region::Scope>,\n         expr_span: Span,\n         source_info: SourceInfo,\n     ) -> BlockAnd<PlaceBuilder<'tcx>> {\n-        let lhs = self.hir.mirror(base);\n-\n         let base_fake_borrow_temps = &mut Vec::new();\n         let is_outermost_index = fake_borrow_temps.is_none();\n         let fake_borrow_temps = fake_borrow_temps.unwrap_or(base_fake_borrow_temps);\n \n         let mut base_place =\n-            unpack!(block = self.expr_as_place(block, lhs, mutability, Some(fake_borrow_temps),));\n+            unpack!(block = self.expr_as_place(block, base, mutability, Some(fake_borrow_temps),));\n \n         // Making this a *fresh* temporary means we do not have to worry about\n         // the index changing later: Nothing will ever change this temporary."}, {"sha": "8082315408c6fc7c8825f970b9e7846bf6c16f27", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 37, "deletions": 46, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=60def4de5e1eb4d8cc4b9733c8bf199b73d8635a", "patch": "@@ -19,59 +19,49 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// The operand returned from this function will *not be valid* after\n     /// an ExprKind::Scope is passed, so please do *not* return it from\n     /// functions to avoid bad miscompiles.\n-    crate fn as_local_rvalue<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<Rvalue<'tcx>>\n-    where\n-        M: Mirror<'tcx, Output = Expr<'tcx>>,\n-    {\n+    crate fn as_local_rvalue(\n+        &mut self,\n+        block: BasicBlock,\n+        expr: &Expr<'tcx>,\n+    ) -> BlockAnd<Rvalue<'tcx>> {\n         let local_scope = self.local_scope();\n         self.as_rvalue(block, Some(local_scope), expr)\n     }\n \n     /// Compile `expr`, yielding an rvalue.\n-    fn as_rvalue<M>(\n-        &mut self,\n-        block: BasicBlock,\n-        scope: Option<region::Scope>,\n-        expr: M,\n-    ) -> BlockAnd<Rvalue<'tcx>>\n-    where\n-        M: Mirror<'tcx, Output = Expr<'tcx>>,\n-    {\n-        let expr = self.hir.mirror(expr);\n-        self.expr_as_rvalue(block, scope, expr)\n-    }\n-\n-    fn expr_as_rvalue(\n+    crate fn as_rvalue(\n         &mut self,\n         mut block: BasicBlock,\n         scope: Option<region::Scope>,\n-        expr: Expr<'tcx>,\n+        expr: &Expr<'tcx>,\n     ) -> BlockAnd<Rvalue<'tcx>> {\n         debug!(\"expr_as_rvalue(block={:?}, scope={:?}, expr={:?})\", block, scope, expr);\n \n         let this = self;\n         let expr_span = expr.span;\n         let source_info = this.source_info(expr_span);\n \n-        match expr.kind {\n-            ExprKind::ThreadLocalRef(did) => block.and(Rvalue::ThreadLocalRef(did)),\n+        match &expr.kind {\n+            ExprKind::ThreadLocalRef(did) => block.and(Rvalue::ThreadLocalRef(*did)),\n             ExprKind::Scope { region_scope, lint_level, value } => {\n-                let region_scope = (region_scope, source_info);\n-                this.in_scope(region_scope, lint_level, |this| this.as_rvalue(block, scope, value))\n+                let region_scope = (*region_scope, source_info);\n+                this.in_scope(region_scope, *lint_level, |this| {\n+                    this.as_rvalue(block, scope, &value)\n+                })\n             }\n             ExprKind::Repeat { value, count } => {\n-                let value_operand = unpack!(block = this.as_operand(block, scope, value));\n+                let value_operand = unpack!(block = this.as_operand(block, scope, &value));\n                 block.and(Rvalue::Repeat(value_operand, count))\n             }\n             ExprKind::Binary { op, lhs, rhs } => {\n-                let lhs = unpack!(block = this.as_operand(block, scope, lhs));\n-                let rhs = unpack!(block = this.as_operand(block, scope, rhs));\n-                this.build_binary_op(block, op, expr_span, expr.ty, lhs, rhs)\n+                let lhs = unpack!(block = this.as_operand(block, scope, &lhs));\n+                let rhs = unpack!(block = this.as_operand(block, scope, &rhs));\n+                this.build_binary_op(block, *op, expr_span, expr.ty, lhs, rhs)\n             }\n             ExprKind::Unary { op, arg } => {\n-                let arg = unpack!(block = this.as_operand(block, scope, arg));\n+                let arg = unpack!(block = this.as_operand(block, scope, &arg));\n                 // Check for -MIN on signed integers\n-                if this.hir.check_overflow() && op == UnOp::Neg && expr.ty.is_signed() {\n+                if this.hir.check_overflow() && *op == UnOp::Neg && expr.ty.is_signed() {\n                     let bool_ty = this.hir.bool_ty();\n \n                     let minval = this.minval_literal(expr_span, expr.ty);\n@@ -92,10 +82,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         expr_span,\n                     );\n                 }\n-                block.and(Rvalue::UnaryOp(op, arg))\n+                block.and(Rvalue::UnaryOp(*op, arg))\n             }\n             ExprKind::Box { value } => {\n-                let value = this.hir.mirror(value);\n                 // The `Box<T>` temporary created here is not a part of the HIR,\n                 // and therefore is not considered during generator auto-trait\n                 // determination. See the comment about `box` at `yield_in_scope`.\n@@ -115,18 +104,21 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                 // initialize the box contents:\n                 unpack!(\n-                    block =\n-                        this.into(this.hir.tcx().mk_place_deref(Place::from(result)), block, value)\n+                    block = this.expr_into_dest(\n+                        this.hir.tcx().mk_place_deref(Place::from(result)),\n+                        block,\n+                        &value\n+                    )\n                 );\n                 block.and(Rvalue::Use(Operand::Move(Place::from(result))))\n             }\n             ExprKind::Cast { source } => {\n-                let source = unpack!(block = this.as_operand(block, scope, source));\n+                let source = unpack!(block = this.as_operand(block, scope, &source));\n                 block.and(Rvalue::Cast(CastKind::Misc, source, expr.ty))\n             }\n             ExprKind::Pointer { cast, source } => {\n-                let source = unpack!(block = this.as_operand(block, scope, source));\n-                block.and(Rvalue::Cast(CastKind::Pointer(cast), source, expr.ty))\n+                let source = unpack!(block = this.as_operand(block, scope, &source));\n+                block.and(Rvalue::Cast(CastKind::Pointer(*cast), source, expr.ty))\n             }\n             ExprKind::Array { fields } => {\n                 // (*) We would (maybe) be closer to codegen if we\n@@ -159,7 +151,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let el_ty = expr.ty.sequence_element_type(this.hir.tcx());\n                 let fields: Vec<_> = fields\n                     .into_iter()\n-                    .map(|f| unpack!(block = this.as_operand(block, scope, f)))\n+                    .map(|f| unpack!(block = this.as_operand(block, scope, &f)))\n                     .collect();\n \n                 block.and(Rvalue::Aggregate(box AggregateKind::Array(el_ty), fields))\n@@ -169,7 +161,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // first process the set of fields\n                 let fields: Vec<_> = fields\n                     .into_iter()\n-                    .map(|f| unpack!(block = this.as_operand(block, scope, f)))\n+                    .map(|f| unpack!(block = this.as_operand(block, scope, &f)))\n                     .collect();\n \n                 block.and(Rvalue::Aggregate(box AggregateKind::Tuple, fields))\n@@ -179,7 +171,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let operands: Vec<_> = upvars\n                     .into_iter()\n                     .map(|upvar| {\n-                        let upvar = this.hir.mirror(upvar);\n                         match Category::of(&upvar.kind) {\n                             // Use as_place to avoid creating a temporary when\n                             // moving a variable into a closure, so that\n@@ -190,25 +181,25 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             // This occurs when capturing by copy/move, while\n                             // by reference captures use as_operand\n                             Some(Category::Place) => {\n-                                let place = unpack!(block = this.as_place(block, upvar));\n+                                let place = unpack!(block = this.as_place(block, &upvar));\n                                 this.consume_by_copy_or_move(place)\n                             }\n                             _ => {\n                                 // Turn mutable borrow captures into unique\n                                 // borrow captures when capturing an immutable\n                                 // variable. This is sound because the mutation\n                                 // that caused the capture will cause an error.\n-                                match upvar.kind {\n+                                match &upvar.kind {\n                                     ExprKind::Borrow {\n                                         borrow_kind:\n                                             BorrowKind::Mut { allow_two_phase_borrow: false },\n                                         arg,\n                                     } => unpack!(\n                                         block = this.limit_capture_mutability(\n-                                            upvar.span, upvar.ty, scope, block, arg,\n+                                            upvar.span, upvar.ty, scope, block, &arg,\n                                         )\n                                     ),\n-                                    _ => unpack!(block = this.as_operand(block, scope, upvar)),\n+                                    _ => unpack!(block = this.as_operand(block, scope, &upvar)),\n                                 }\n                             }\n                         }\n@@ -219,9 +210,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         // We implicitly set the discriminant to 0. See\n                         // librustc_mir/transform/deaggregator.rs for details.\n                         let movability = movability.unwrap();\n-                        box AggregateKind::Generator(closure_id, substs, movability)\n+                        box AggregateKind::Generator(*closure_id, substs, movability)\n                     }\n-                    UpvarSubsts::Closure(substs) => box AggregateKind::Closure(closure_id, substs),\n+                    UpvarSubsts::Closure(substs) => box AggregateKind::Closure(*closure_id, substs),\n                 };\n                 block.and(Rvalue::Aggregate(result, operands))\n             }\n@@ -377,7 +368,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         upvar_ty: Ty<'tcx>,\n         temp_lifetime: Option<region::Scope>,\n         mut block: BasicBlock,\n-        arg: ExprRef<'tcx>,\n+        arg: &Expr<'tcx>,\n     ) -> BlockAnd<Operand<'tcx>> {\n         let this = self;\n "}, {"sha": "0f4d05fc03ab96974739380a5b1a81ecde52579c", "filename": "compiler/rustc_mir_build/src/build/expr/as_temp.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs?ref=60def4de5e1eb4d8cc4b9733c8bf199b73d8635a", "patch": "@@ -4,48 +4,42 @@ use crate::build::scope::DropKind;\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::thir::*;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n-use rustc_hir as hir;\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr` into a fresh temporary. This is used when building\n     /// up rvalues so as to freeze the value that will be consumed.\n-    crate fn as_temp<M>(\n+    crate fn as_temp(\n         &mut self,\n         block: BasicBlock,\n         temp_lifetime: Option<region::Scope>,\n-        expr: M,\n+        expr: &Expr<'tcx>,\n         mutability: Mutability,\n-    ) -> BlockAnd<Local>\n-    where\n-        M: Mirror<'tcx, Output = Expr<'tcx>>,\n-    {\n-        let expr = self.hir.mirror(expr);\n-        //\n+    ) -> BlockAnd<Local> {\n         // this is the only place in mir building that we need to truly need to worry about\n         // infinite recursion. Everything else does recurse, too, but it always gets broken up\n         // at some point by inserting an intermediate temporary\n-        ensure_sufficient_stack(|| self.expr_as_temp(block, temp_lifetime, expr, mutability))\n+        ensure_sufficient_stack(|| self.as_temp_inner(block, temp_lifetime, expr, mutability))\n     }\n \n-    fn expr_as_temp(\n+    fn as_temp_inner(\n         &mut self,\n         mut block: BasicBlock,\n         temp_lifetime: Option<region::Scope>,\n-        expr: Expr<'tcx>,\n+        expr: &Expr<'tcx>,\n         mutability: Mutability,\n     ) -> BlockAnd<Local> {\n         debug!(\n-            \"expr_as_temp(block={:?}, temp_lifetime={:?}, expr={:?}, mutability={:?})\",\n+            \"as_temp(block={:?}, temp_lifetime={:?}, expr={:?}, mutability={:?})\",\n             block, temp_lifetime, expr, mutability\n         );\n         let this = self;\n \n         let expr_span = expr.span;\n         let source_info = this.source_info(expr_span);\n-        if let ExprKind::Scope { region_scope, lint_level, value } = expr.kind {\n-            return this.in_scope((region_scope, source_info), lint_level, |this| {\n+        if let ExprKind::Scope { region_scope, lint_level, value } = &expr.kind {\n+            return this.in_scope((*region_scope, source_info), *lint_level, |this| {\n                 this.as_temp(block, temp_lifetime, value, mutability)\n             });\n         }\n@@ -89,7 +83,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // Don't bother with StorageLive and Dead for these temporaries,\n             // they are never assigned.\n             ExprKind::Break { .. } | ExprKind::Continue { .. } | ExprKind::Return { .. } => (),\n-            ExprKind::Block { body: hir::Block { expr: None, targeted_by_break: false, .. } }\n+            ExprKind::Block { body: Block { expr: None, targeted_by_break: false, .. } }\n                 if expr_ty.is_never() => {}\n             _ => {\n                 this.cfg\n@@ -114,7 +108,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n         }\n \n-        unpack!(block = this.into(temp_place, block, expr));\n+        unpack!(block = this.expr_into_dest(temp_place, block, expr));\n \n         if let Some(temp_lifetime) = temp_lifetime {\n             this.schedule_drop(expr_span, temp_lifetime, temp, DropKind::Value);"}, {"sha": "9c719e36551c41973f2c3b1324672fef415d8eaf", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 54, "deletions": 50, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=60def4de5e1eb4d8cc4b9733c8bf199b73d8635a", "patch": "@@ -13,13 +13,13 @@ use rustc_middle::ty::CanonicalUserTypeAnnotation;\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, storing the result into `destination`, which\n     /// is assumed to be uninitialized.\n-    crate fn into_expr(\n+    crate fn expr_into_dest(\n         &mut self,\n         destination: Place<'tcx>,\n         mut block: BasicBlock,\n-        expr: Expr<'tcx>,\n+        expr: &Expr<'tcx>,\n     ) -> BlockAnd<()> {\n-        debug!(\"into_expr(destination={:?}, block={:?}, expr={:?})\", destination, block, expr);\n+        debug!(\"expr_into_dest(destination={:?}, block={:?}, expr={:?})\", destination, block, expr);\n \n         // since we frequently have to reference `self` from within a\n         // closure, where `self` would be shadowed, it's easier to\n@@ -35,24 +35,24 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             this.block_context.push(BlockFrame::SubExpr);\n         }\n \n-        let block_and = match expr.kind {\n+        let block_and = match &expr.kind {\n             ExprKind::Scope { region_scope, lint_level, value } => {\n-                let region_scope = (region_scope, source_info);\n+                let region_scope = (*region_scope, source_info);\n                 ensure_sufficient_stack(|| {\n-                    this.in_scope(region_scope, lint_level, |this| {\n-                        this.into(destination, block, value)\n+                    this.in_scope(region_scope, *lint_level, |this| {\n+                        this.expr_into_dest(destination, block, &value)\n                     })\n                 })\n             }\n             ExprKind::Block { body: ast_block } => {\n-                this.ast_block(destination, block, ast_block, source_info)\n+                this.ast_block(destination, block, &ast_block, source_info)\n             }\n             ExprKind::Match { scrutinee, arms } => {\n-                this.match_expr(destination, expr_span, block, scrutinee, arms)\n+                this.match_expr(destination, expr_span, block, &scrutinee, &arms)\n             }\n             ExprKind::If { cond, then, else_opt } => {\n                 let place = unpack!(\n-                    block = this.as_temp(block, Some(this.local_scope()), cond, Mutability::Mut)\n+                    block = this.as_temp(block, Some(this.local_scope()), &cond, Mutability::Mut)\n                 );\n                 let operand = Operand::Move(Place::from(place));\n \n@@ -61,9 +61,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let term = TerminatorKind::if_(this.hir.tcx(), operand, then_block, else_block);\n                 this.cfg.terminate(block, source_info, term);\n \n-                unpack!(then_block = this.into(destination, then_block, then));\n+                unpack!(then_block = this.expr_into_dest(destination, then_block, &then));\n                 else_block = if let Some(else_opt) = else_opt {\n-                    unpack!(this.into(destination, else_block, else_opt))\n+                    unpack!(this.expr_into_dest(destination, else_block, &else_opt))\n                 } else {\n                     // Body of the `if` expression without an `else` clause must return `()`, thus\n                     // we implicitly generate a `else {}` if it is not specified.\n@@ -87,14 +87,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 join_block.unit()\n             }\n             ExprKind::NeverToAny { source } => {\n-                let source = this.hir.mirror(source);\n                 let is_call =\n                     matches!(source.kind, ExprKind::Call { .. } | ExprKind::InlineAsm { .. });\n \n                 // (#66975) Source could be a const of type `!`, so has to\n                 // exist in the generated MIR.\n                 unpack!(\n-                    block = this.as_temp(block, Some(this.local_scope()), source, Mutability::Mut,)\n+                    block =\n+                        this.as_temp(block, Some(this.local_scope()), &source, Mutability::Mut,)\n                 );\n \n                 // This is an optimization. If the expression was a call then we already have an\n@@ -127,15 +127,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     this.cfg.start_new_block(),\n                 );\n \n-                let lhs = unpack!(block = this.as_local_operand(block, lhs));\n+                let lhs = unpack!(block = this.as_local_operand(block, &lhs));\n                 let blocks = match op {\n                     LogicalOp::And => (else_block, false_block),\n                     LogicalOp::Or => (true_block, else_block),\n                 };\n                 let term = TerminatorKind::if_(this.hir.tcx(), lhs, blocks.0, blocks.1);\n                 this.cfg.terminate(block, source_info, term);\n \n-                let rhs = unpack!(else_block = this.as_local_operand(else_block, rhs));\n+                let rhs = unpack!(else_block = this.as_local_operand(else_block, &rhs));\n                 let term = TerminatorKind::if_(this.hir.tcx(), rhs, true_block, false_block);\n                 this.cfg.terminate(else_block, source_info, term);\n \n@@ -188,25 +188,25 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     // introduce a unit temporary as the destination for the loop body.\n                     let tmp = this.get_unit_temp();\n                     // Execute the body, branching back to the test.\n-                    let body_block_end = unpack!(this.into(tmp, body_block, body));\n+                    let body_block_end = unpack!(this.expr_into_dest(tmp, body_block, &body));\n                     this.cfg.goto(body_block_end, source_info, loop_block);\n \n                     // Loops are only exited by `break` expressions.\n                     None\n                 })\n             }\n             ExprKind::Call { ty: _, fun, args, from_hir_call, fn_span } => {\n-                let fun = unpack!(block = this.as_local_operand(block, fun));\n+                let fun = unpack!(block = this.as_local_operand(block, &fun));\n                 let args: Vec<_> = args\n                     .into_iter()\n-                    .map(|arg| unpack!(block = this.as_local_call_operand(block, arg)))\n+                    .map(|arg| unpack!(block = this.as_local_call_operand(block, &arg)))\n                     .collect();\n \n                 let success = this.cfg.start_new_block();\n \n                 this.record_operands_moved(&args);\n \n-                debug!(\"into_expr: fn_span={:?}\", fn_span);\n+                debug!(\"expr_into_dest: fn_span={:?}\", fn_span);\n \n                 this.cfg.terminate(\n                     block,\n@@ -223,35 +223,35 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         } else {\n                             Some((destination, success))\n                         },\n-                        from_hir_call,\n-                        fn_span,\n+                        from_hir_call: *from_hir_call,\n+                        fn_span: *fn_span,\n                     },\n                 );\n                 this.diverge_from(block);\n                 success.unit()\n             }\n-            ExprKind::Use { source } => this.into(destination, block, source),\n+            ExprKind::Use { source } => this.expr_into_dest(destination, block, &source),\n             ExprKind::Borrow { arg, borrow_kind } => {\n                 // We don't do this in `as_rvalue` because we use `as_place`\n                 // for borrow expressions, so we cannot create an `RValue` that\n                 // remains valid across user code. `as_rvalue` is usually called\n                 // by this method anyway, so this shouldn't cause too many\n                 // unnecessary temporaries.\n                 let arg_place = match borrow_kind {\n-                    BorrowKind::Shared => unpack!(block = this.as_read_only_place(block, arg)),\n-                    _ => unpack!(block = this.as_place(block, arg)),\n+                    BorrowKind::Shared => unpack!(block = this.as_read_only_place(block, &arg)),\n+                    _ => unpack!(block = this.as_place(block, &arg)),\n                 };\n                 let borrow =\n-                    Rvalue::Ref(this.hir.tcx().lifetimes.re_erased, borrow_kind, arg_place);\n+                    Rvalue::Ref(this.hir.tcx().lifetimes.re_erased, *borrow_kind, arg_place);\n                 this.cfg.push_assign(block, source_info, destination, borrow);\n                 block.unit()\n             }\n             ExprKind::AddressOf { mutability, arg } => {\n                 let place = match mutability {\n-                    hir::Mutability::Not => this.as_read_only_place(block, arg),\n-                    hir::Mutability::Mut => this.as_place(block, arg),\n+                    hir::Mutability::Not => this.as_read_only_place(block, &arg),\n+                    hir::Mutability::Mut => this.as_place(block, &arg),\n                 };\n-                let address_of = Rvalue::AddressOf(mutability, unpack!(block = place));\n+                let address_of = Rvalue::AddressOf(*mutability, unpack!(block = place));\n                 this.cfg.push_assign(block, source_info, destination, address_of);\n                 block.unit()\n             }\n@@ -267,13 +267,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // (evaluating them in order given by user)\n                 let fields_map: FxHashMap<_, _> = fields\n                     .into_iter()\n-                    .map(|f| (f.name, unpack!(block = this.as_operand(block, Some(scope), f.expr))))\n+                    .map(|f| {\n+                        (f.name, unpack!(block = this.as_operand(block, Some(scope), &f.expr)))\n+                    })\n                     .collect();\n \n-                let field_names = this.hir.all_fields(adt_def, variant_index);\n+                let field_names = this.hir.all_fields(adt_def, *variant_index);\n \n                 let fields: Vec<_> = if let Some(FruInfo { base, field_types }) = base {\n-                    let place_builder = unpack!(block = this.as_place_builder(block, base));\n+                    let place_builder = unpack!(block = this.as_place_builder(block, &base));\n \n                     // MIR does not natively support FRU, so for each\n                     // base-supplied field, generate an operand that\n@@ -307,7 +309,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 });\n                 let adt = box AggregateKind::Adt(\n                     adt_def,\n-                    variant_index,\n+                    *variant_index,\n                     substs,\n                     user_ty,\n                     active_field_index,\n@@ -327,44 +329,46 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     .into_iter()\n                     .map(|op| match op {\n                         thir::InlineAsmOperand::In { reg, expr } => mir::InlineAsmOperand::In {\n-                            reg,\n-                            value: unpack!(block = this.as_local_operand(block, expr)),\n+                            reg: *reg,\n+                            value: unpack!(block = this.as_local_operand(block, &expr)),\n                         },\n                         thir::InlineAsmOperand::Out { reg, late, expr } => {\n                             mir::InlineAsmOperand::Out {\n-                                reg,\n-                                late,\n-                                place: expr.map(|expr| unpack!(block = this.as_place(block, expr))),\n+                                reg: *reg,\n+                                late: *late,\n+                                place: expr\n+                                    .as_ref()\n+                                    .map(|expr| unpack!(block = this.as_place(block, expr))),\n                             }\n                         }\n                         thir::InlineAsmOperand::InOut { reg, late, expr } => {\n-                            let place = unpack!(block = this.as_place(block, expr));\n+                            let place = unpack!(block = this.as_place(block, &expr));\n                             mir::InlineAsmOperand::InOut {\n-                                reg,\n-                                late,\n+                                reg: *reg,\n+                                late: *late,\n                                 // This works because asm operands must be Copy\n                                 in_value: Operand::Copy(place),\n                                 out_place: Some(place),\n                             }\n                         }\n                         thir::InlineAsmOperand::SplitInOut { reg, late, in_expr, out_expr } => {\n                             mir::InlineAsmOperand::InOut {\n-                                reg,\n-                                late,\n-                                in_value: unpack!(block = this.as_local_operand(block, in_expr)),\n-                                out_place: out_expr.map(|out_expr| {\n+                                reg: *reg,\n+                                late: *late,\n+                                in_value: unpack!(block = this.as_local_operand(block, &in_expr)),\n+                                out_place: out_expr.as_ref().map(|out_expr| {\n                                     unpack!(block = this.as_place(block, out_expr))\n                                 }),\n                             }\n                         }\n                         thir::InlineAsmOperand::Const { expr } => mir::InlineAsmOperand::Const {\n-                            value: unpack!(block = this.as_local_operand(block, expr)),\n+                            value: unpack!(block = this.as_local_operand(block, &expr)),\n                         },\n                         thir::InlineAsmOperand::SymFn { expr } => {\n-                            mir::InlineAsmOperand::SymFn { value: box this.as_constant(expr) }\n+                            mir::InlineAsmOperand::SymFn { value: box this.as_constant(&expr) }\n                         }\n                         thir::InlineAsmOperand::SymStatic { def_id } => {\n-                            mir::InlineAsmOperand::SymStatic { def_id }\n+                            mir::InlineAsmOperand::SymStatic { def_id: *def_id }\n                         }\n                     })\n                     .collect();\n@@ -377,7 +381,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     TerminatorKind::InlineAsm {\n                         template,\n                         operands,\n-                        options,\n+                        options: *options,\n                         line_spans,\n                         destination: if options.contains(InlineAsmOptions::NORETURN) {\n                             None\n@@ -436,7 +440,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             ExprKind::Yield { value } => {\n                 let scope = this.local_scope();\n-                let value = unpack!(block = this.as_operand(block, Some(scope), value));\n+                let value = unpack!(block = this.as_operand(block, Some(scope), &value));\n                 let resume = this.cfg.start_new_block();\n                 this.cfg.terminate(\n                     block,"}, {"sha": "07338928eb8efa777ae72103a4f640f461d05848", "filename": "compiler/rustc_mir_build/src/build/expr/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fmod.rs?ref=60def4de5e1eb4d8cc4b9733c8bf199b73d8635a", "patch": "@@ -9,7 +9,7 @@\n //! a type that is not `Copy`, then using any of these functions will\n //! \"move\" the value out of its current home (if any).\n //!\n-//! - `into` -- writes the value into a specific location, which\n+//! - `expr_into_dest` -- writes the value into a specific location, which\n //!   should be uninitialized\n //! - `as_operand` -- evaluates the value and yields an `Operand`,\n //!   suitable for use as an argument to an `Rvalue`"}, {"sha": "0d2d99a8b5e87915013b39ecf6e70e16f7185468", "filename": "compiler/rustc_mir_build/src/build/expr/stmt.rs", "status": "modified", "additions": 32, "deletions": 27, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs?ref=60def4de5e1eb4d8cc4b9733c8bf199b73d8635a", "patch": "@@ -13,7 +13,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn stmt_expr(\n         &mut self,\n         mut block: BasicBlock,\n-        expr: Expr<'tcx>,\n+        expr: &Expr<'tcx>,\n         statement_scope: Option<region::Scope>,\n     ) -> BlockAnd<()> {\n         let this = self;\n@@ -22,16 +22,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // Handle a number of expressions that don't need a destination at all. This\n         // avoids needing a mountain of temporary `()` variables.\n         let expr2 = expr.clone();\n-        match expr.kind {\n+        match &expr.kind {\n             ExprKind::Scope { region_scope, lint_level, value } => {\n-                let value = this.hir.mirror(value);\n-                this.in_scope((region_scope, source_info), lint_level, |this| {\n-                    this.stmt_expr(block, value, statement_scope)\n+                this.in_scope((*region_scope, source_info), *lint_level, |this| {\n+                    this.stmt_expr(block, &value, statement_scope)\n                 })\n             }\n             ExprKind::Assign { lhs, rhs } => {\n-                let lhs = this.hir.mirror(lhs);\n-                let rhs = this.hir.mirror(rhs);\n                 let lhs_span = lhs.span;\n \n                 // Note: we evaluate assignments right-to-left. This\n@@ -44,12 +41,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // Generate better code for things that don't need to be\n                 // dropped.\n                 if this.hir.needs_drop(lhs.ty) {\n-                    let rhs = unpack!(block = this.as_local_operand(block, rhs));\n-                    let lhs = unpack!(block = this.as_place(block, lhs));\n+                    let rhs = unpack!(block = this.as_local_operand(block, &rhs));\n+                    let lhs = unpack!(block = this.as_place(block, &lhs));\n                     unpack!(block = this.build_drop_and_replace(block, lhs_span, lhs, rhs));\n                 } else {\n-                    let rhs = unpack!(block = this.as_local_rvalue(block, rhs));\n-                    let lhs = unpack!(block = this.as_place(block, lhs));\n+                    let rhs = unpack!(block = this.as_local_rvalue(block, &rhs));\n+                    let lhs = unpack!(block = this.as_place(block, &lhs));\n                     this.cfg.push_assign(block, source_info, lhs, rhs);\n                 }\n \n@@ -65,49 +62,57 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // only affects weird things like `x += {x += 1; x}`\n                 // -- is that equal to `x + (x + 1)` or `2*(x+1)`?\n \n-                let lhs = this.hir.mirror(lhs);\n                 let lhs_ty = lhs.ty;\n \n                 debug!(\"stmt_expr AssignOp block_context.push(SubExpr) : {:?}\", expr2);\n                 this.block_context.push(BlockFrame::SubExpr);\n \n                 // As above, RTL.\n-                let rhs = unpack!(block = this.as_local_operand(block, rhs));\n-                let lhs = unpack!(block = this.as_place(block, lhs));\n+                let rhs = unpack!(block = this.as_local_operand(block, &rhs));\n+                let lhs = unpack!(block = this.as_place(block, &lhs));\n \n                 // we don't have to drop prior contents or anything\n                 // because AssignOp is only legal for Copy types\n                 // (overloaded ops should be desugared into a call).\n                 let result = unpack!(\n-                    block =\n-                        this.build_binary_op(block, op, expr_span, lhs_ty, Operand::Copy(lhs), rhs)\n+                    block = this.build_binary_op(\n+                        block,\n+                        *op,\n+                        expr_span,\n+                        lhs_ty,\n+                        Operand::Copy(lhs),\n+                        rhs\n+                    )\n                 );\n                 this.cfg.push_assign(block, source_info, lhs, result);\n \n                 this.block_context.pop();\n                 block.unit()\n             }\n             ExprKind::Continue { label } => {\n-                this.break_scope(block, None, BreakableTarget::Continue(label), source_info)\n-            }\n-            ExprKind::Break { label, value } => {\n-                this.break_scope(block, value, BreakableTarget::Break(label), source_info)\n+                this.break_scope(block, None, BreakableTarget::Continue(*label), source_info)\n             }\n+            ExprKind::Break { label, value } => this.break_scope(\n+                block,\n+                value.as_deref(),\n+                BreakableTarget::Break(*label),\n+                source_info,\n+            ),\n             ExprKind::Return { value } => {\n-                this.break_scope(block, value, BreakableTarget::Return, source_info)\n+                this.break_scope(block, value.as_deref(), BreakableTarget::Return, source_info)\n             }\n             ExprKind::LlvmInlineAsm { asm, outputs, inputs } => {\n                 debug!(\"stmt_expr LlvmInlineAsm block_context.push(SubExpr) : {:?}\", expr2);\n                 this.block_context.push(BlockFrame::SubExpr);\n                 let outputs = outputs\n                     .into_iter()\n-                    .map(|output| unpack!(block = this.as_place(block, output)))\n+                    .map(|output| unpack!(block = this.as_place(block, &output)))\n                     .collect::<Vec<_>>()\n                     .into_boxed_slice();\n                 let inputs = inputs\n                     .into_iter()\n                     .map(|input| {\n-                        (input.span(), unpack!(block = this.as_local_operand(block, input)))\n+                        (input.span, unpack!(block = this.as_local_operand(block, &input)))\n                     })\n                     .collect::<Vec<_>>()\n                     .into_boxed_slice();\n@@ -116,7 +121,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     Statement {\n                         source_info,\n                         kind: StatementKind::LlvmInlineAsm(box LlvmInlineAsm {\n-                            asm: asm.clone(),\n+                            asm: (*asm).clone(),\n                             outputs,\n                             inputs,\n                         }),\n@@ -140,10 +145,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // it is usually better to focus on `the_value` rather\n                 // than the entirety of block(s) surrounding it.\n                 let adjusted_span = (|| {\n-                    if let ExprKind::Block { body } = expr.kind {\n+                    if let ExprKind::Block { body } = &expr.kind {\n                         if let Some(tail_expr) = &body.expr {\n-                            let mut expr = tail_expr;\n-                            while let rustc_hir::ExprKind::Block(subblock, _label) = &expr.kind {\n+                            let mut expr = &*tail_expr;\n+                            while let ExprKind::Block { body: subblock } = &expr.kind {\n                                 if let Some(subtail_expr) = &subblock.expr {\n                                     expr = subtail_expr\n                                 } else {"}, {"sha": "7264e495b84fd0dc6026c67f156f4cb25c40a428", "filename": "compiler/rustc_mir_build/src/build/into.rs", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/3a5d45f68cadc8fff4fbb557780f92b403b19c19/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5d45f68cadc8fff4fbb557780f92b403b19c19/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Finto.rs?ref=3a5d45f68cadc8fff4fbb557780f92b403b19c19", "patch": "@@ -1,55 +0,0 @@\n-//! In general, there are a number of things for which it's convenient\n-//! to just call `builder.into` and have it emit its result into a\n-//! given location. This is basically for expressions or things that can be\n-//! wrapped up as expressions (e.g., blocks). To make this ergonomic, we use this\n-//! latter `EvalInto` trait.\n-\n-use crate::build::{BlockAnd, Builder};\n-use crate::thir::*;\n-use rustc_middle::mir::*;\n-\n-pub(in crate::build) trait EvalInto<'tcx> {\n-    fn eval_into(\n-        self,\n-        builder: &mut Builder<'_, 'tcx>,\n-        destination: Place<'tcx>,\n-        block: BasicBlock,\n-    ) -> BlockAnd<()>;\n-}\n-\n-impl<'a, 'tcx> Builder<'a, 'tcx> {\n-    crate fn into<E>(\n-        &mut self,\n-        destination: Place<'tcx>,\n-        block: BasicBlock,\n-        expr: E,\n-    ) -> BlockAnd<()>\n-    where\n-        E: EvalInto<'tcx>,\n-    {\n-        expr.eval_into(self, destination, block)\n-    }\n-}\n-\n-impl<'tcx> EvalInto<'tcx> for ExprRef<'tcx> {\n-    fn eval_into(\n-        self,\n-        builder: &mut Builder<'_, 'tcx>,\n-        destination: Place<'tcx>,\n-        block: BasicBlock,\n-    ) -> BlockAnd<()> {\n-        let expr = builder.hir.mirror(self);\n-        builder.into_expr(destination, block, expr)\n-    }\n-}\n-\n-impl<'tcx> EvalInto<'tcx> for Expr<'tcx> {\n-    fn eval_into(\n-        self,\n-        builder: &mut Builder<'_, 'tcx>,\n-        destination: Place<'tcx>,\n-        block: BasicBlock,\n-    ) -> BlockAnd<()> {\n-        builder.into_expr(destination, block, self)\n-    }\n-}"}, {"sha": "6a828c1864fc9aad7a770681518b97a64dbe13ac", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=60def4de5e1eb4d8cc4b9733c8bf199b73d8635a", "patch": "@@ -89,10 +89,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         destination: Place<'tcx>,\n         span: Span,\n         mut block: BasicBlock,\n-        scrutinee: ExprRef<'tcx>,\n-        arms: Vec<Arm<'tcx>>,\n+        scrutinee: &Expr<'tcx>,\n+        arms: &[Arm<'tcx>],\n     ) -> BlockAnd<()> {\n-        let scrutinee_span = scrutinee.span();\n+        let scrutinee_span = scrutinee.span;\n         let scrutinee_place =\n             unpack!(block = self.lower_scrutinee(block, scrutinee, scrutinee_span,));\n \n@@ -119,7 +119,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn lower_scrutinee(\n         &mut self,\n         mut block: BasicBlock,\n-        scrutinee: ExprRef<'tcx>,\n+        scrutinee: &Expr<'tcx>,\n         scrutinee_span: Span,\n     ) -> BlockAnd<Place<'tcx>> {\n         let scrutinee_place = unpack!(block = self.as_place(block, scrutinee));\n@@ -236,7 +236,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let arm_source_info = self.source_info(arm.span);\n                 let arm_scope = (arm.scope, arm_source_info);\n                 self.in_scope(arm_scope, arm.lint_level, |this| {\n-                    let body = this.hir.mirror(arm.body.clone());\n                     let scope = this.declare_bindings(\n                         None,\n                         arm.span,\n@@ -259,7 +258,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         this.source_scope = source_scope;\n                     }\n \n-                    this.into(destination, arm_block, body)\n+                    this.expr_into_dest(destination, arm_block, &arm.body)\n                 })\n             })\n             .collect();\n@@ -362,14 +361,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         mut block: BasicBlock,\n         irrefutable_pat: Pat<'tcx>,\n-        initializer: ExprRef<'tcx>,\n+        initializer: &Expr<'tcx>,\n     ) -> BlockAnd<()> {\n         match *irrefutable_pat.kind {\n             // Optimize the case of `let x = ...` to write directly into `x`\n             PatKind::Binding { mode: BindingMode::ByValue, var, subpattern: None, .. } => {\n                 let place =\n                     self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard, true);\n-                unpack!(block = self.into(place, block, initializer));\n+                unpack!(block = self.expr_into_dest(place, block, initializer));\n \n                 // Inject a fake read, see comments on `FakeReadCause::ForLet`.\n                 let source_info = self.source_info(irrefutable_pat.span);\n@@ -404,7 +403,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             } => {\n                 let place =\n                     self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard, true);\n-                unpack!(block = self.into(place, block, initializer));\n+                unpack!(block = self.expr_into_dest(place, block, initializer));\n \n                 // Inject a fake read, see comments on `FakeReadCause::ForLet`.\n                 let pattern_source_info = self.source_info(irrefutable_pat.span);\n@@ -1749,15 +1748,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             let (guard_span, (post_guard_block, otherwise_post_guard_block)) = match guard {\n                 Guard::If(e) => {\n-                    let e = self.hir.mirror(e.clone());\n                     let source_info = self.source_info(e.span);\n                     (e.span, self.test_bool(block, e, source_info))\n                 }\n                 Guard::IfLet(pat, scrutinee) => {\n-                    let scrutinee_span = scrutinee.span();\n-                    let scrutinee_place = unpack!(\n-                        block = self.lower_scrutinee(block, scrutinee.clone(), scrutinee_span)\n-                    );\n+                    let scrutinee_span = scrutinee.span;\n+                    let scrutinee_place =\n+                        unpack!(block = self.lower_scrutinee(block, &scrutinee, scrutinee_span));\n                     let mut guard_candidate = Candidate::new(scrutinee_place, &pat, false);\n                     let wildcard = Pat::wildcard_from_ty(pat.ty);\n                     let mut otherwise_candidate = Candidate::new(scrutinee_place, &wildcard, false);\n@@ -1772,14 +1769,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         pat.span.to(arm_span.unwrap()),\n                         pat,\n                         ArmHasGuard(false),\n-                        Some((Some(&scrutinee_place), scrutinee.span())),\n+                        Some((Some(&scrutinee_place), scrutinee.span)),\n                     );\n                     let post_guard_block = self.bind_pattern(\n                         self.source_info(pat.span),\n                         guard_candidate,\n                         None,\n                         &fake_borrow_temps,\n-                        scrutinee.span(),\n+                        scrutinee.span,\n                         None,\n                         None,\n                     );"}, {"sha": "f9bed4454f2ede28c59417a2cb5168fcf8b04d02", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=60def4de5e1eb4d8cc4b9733c8bf199b73d8635a", "patch": "@@ -667,8 +667,8 @@ fn construct_const<'a, 'tcx>(\n \n     let mut block = START_BLOCK;\n     let ast_expr = &tcx.hir().body(body_id).value;\n-    let expr = builder.hir.mirror(ast_expr);\n-    unpack!(block = builder.into_expr(Place::return_place(), block, expr));\n+    let expr = builder.hir.mirror_expr(ast_expr);\n+    unpack!(block = builder.expr_into_dest(Place::return_place(), block, &expr));\n \n     let source_info = builder.source_info(span);\n     builder.cfg.terminate(block, source_info, TerminatorKind::Return);\n@@ -953,8 +953,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             self.source_scope = source_scope;\n         }\n \n-        let body = self.hir.mirror(ast_body);\n-        self.into(Place::return_place(), block, body)\n+        let body = self.hir.mirror_expr(ast_body);\n+        self.expr_into_dest(Place::return_place(), block, &body)\n     }\n \n     fn set_correct_source_scope_for_arg(\n@@ -1001,7 +1001,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n mod block;\n mod cfg;\n mod expr;\n-mod into;\n mod matches;\n mod misc;\n mod scope;"}, {"sha": "fccff023d0872a6e0d11443f69cc4865bdf9b709", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=60def4de5e1eb4d8cc4b9733c8bf199b73d8635a", "patch": "@@ -82,7 +82,7 @@ that contains only loops and breakable blocks. It tracks where a `break`,\n */\n \n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder, CFG};\n-use crate::thir::{Expr, ExprRef, LintLevel};\n+use crate::thir::{Expr, LintLevel};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::vec::IndexVec;\n use rustc_middle::middle::region;\n@@ -575,7 +575,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn break_scope(\n         &mut self,\n         mut block: BasicBlock,\n-        value: Option<ExprRef<'tcx>>,\n+        value: Option<&Expr<'tcx>>,\n         target: BreakableTarget,\n         source_info: SourceInfo,\n     ) -> BlockAnd<()> {\n@@ -612,7 +612,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             if let Some(value) = value {\n                 debug!(\"stmt_expr Break val block_context.push(SubExpr)\");\n                 self.block_context.push(BlockFrame::SubExpr);\n-                unpack!(block = self.into(destination, block, value));\n+                unpack!(block = self.expr_into_dest(destination, block, value));\n                 self.block_context.pop();\n             } else {\n                 self.cfg.push_assign_unit(block, source_info, destination, self.hir.tcx())\n@@ -920,7 +920,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn test_bool(\n         &mut self,\n         mut block: BasicBlock,\n-        condition: Expr<'tcx>,\n+        condition: &Expr<'tcx>,\n         source_info: SourceInfo,\n     ) -> (BasicBlock, BasicBlock) {\n         let cond = unpack!(block = self.as_local_operand(block, condition));"}, {"sha": "9c1440aba4204487a448a92a7bd0ffbc06f8693b", "filename": "compiler/rustc_mir_build/src/thir/cx/block.rs", "status": "modified", "additions": 76, "deletions": 86, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs?ref=60def4de5e1eb4d8cc4b9733c8bf199b73d8635a", "patch": "@@ -1,4 +1,3 @@\n-use crate::thir::cx::to_ref::ToRef;\n use crate::thir::cx::Cx;\n use crate::thir::{self, *};\n \n@@ -8,110 +7,101 @@ use rustc_middle::ty;\n \n use rustc_index::vec::Idx;\n \n-impl<'tcx> Mirror<'tcx> for &'tcx hir::Block<'tcx> {\n-    type Output = Block<'tcx>;\n-\n-    fn make_mirror(self, cx: &mut Cx<'_, 'tcx>) -> Block<'tcx> {\n+impl<'a, 'tcx> Cx<'a, 'tcx> {\n+    crate fn mirror_block(&mut self, block: &'tcx hir::Block<'tcx>) -> Block<'tcx> {\n         // We have to eagerly lower the \"spine\" of the statements\n         // in order to get the lexical scoping correctly.\n-        let stmts = mirror_stmts(cx, self.hir_id.local_id, &*self.stmts);\n+        let stmts = self.mirror_stmts(block.hir_id.local_id, &*block.stmts);\n         let opt_destruction_scope =\n-            cx.region_scope_tree.opt_destruction_scope(self.hir_id.local_id);\n+            self.region_scope_tree.opt_destruction_scope(block.hir_id.local_id);\n         Block {\n-            targeted_by_break: self.targeted_by_break,\n-            region_scope: region::Scope { id: self.hir_id.local_id, data: region::ScopeData::Node },\n+            targeted_by_break: block.targeted_by_break,\n+            region_scope: region::Scope {\n+                id: block.hir_id.local_id,\n+                data: region::ScopeData::Node,\n+            },\n             opt_destruction_scope,\n-            span: self.span,\n+            span: block.span,\n             stmts,\n-            expr: self.expr.to_ref(),\n-            safety_mode: match self.rules {\n+            expr: block.expr.as_ref().map(|expr| self.mirror_expr_boxed(expr)),\n+            safety_mode: match block.rules {\n                 hir::BlockCheckMode::DefaultBlock => BlockSafety::Safe,\n-                hir::BlockCheckMode::UnsafeBlock(..) => BlockSafety::ExplicitUnsafe(self.hir_id),\n+                hir::BlockCheckMode::UnsafeBlock(..) => BlockSafety::ExplicitUnsafe(block.hir_id),\n                 hir::BlockCheckMode::PushUnsafeBlock(..) => BlockSafety::PushUnsafe,\n                 hir::BlockCheckMode::PopUnsafeBlock(..) => BlockSafety::PopUnsafe,\n             },\n         }\n     }\n-}\n \n-fn mirror_stmts<'a, 'tcx>(\n-    cx: &mut Cx<'a, 'tcx>,\n-    block_id: hir::ItemLocalId,\n-    stmts: &'tcx [hir::Stmt<'tcx>],\n-) -> Vec<StmtRef<'tcx>> {\n-    let mut result = vec![];\n-    for (index, stmt) in stmts.iter().enumerate() {\n-        let hir_id = stmt.hir_id;\n-        let opt_dxn_ext = cx.region_scope_tree.opt_destruction_scope(hir_id.local_id);\n-        match stmt.kind {\n-            hir::StmtKind::Expr(ref expr) | hir::StmtKind::Semi(ref expr) => {\n-                result.push(StmtRef::Mirror(Box::new(Stmt {\n-                    kind: StmtKind::Expr {\n-                        scope: region::Scope { id: hir_id.local_id, data: region::ScopeData::Node },\n-                        expr: expr.to_ref(),\n-                    },\n-                    opt_destruction_scope: opt_dxn_ext,\n-                })))\n-            }\n-            hir::StmtKind::Item(..) => {\n-                // ignore for purposes of the MIR\n-            }\n-            hir::StmtKind::Local(ref local) => {\n-                let remainder_scope = region::Scope {\n-                    id: block_id,\n-                    data: region::ScopeData::Remainder(region::FirstStatementIndex::new(index)),\n-                };\n+    fn mirror_stmts(\n+        &mut self,\n+        block_id: hir::ItemLocalId,\n+        stmts: &'tcx [hir::Stmt<'tcx>],\n+    ) -> Vec<Stmt<'tcx>> {\n+        let mut result = vec![];\n+        for (index, stmt) in stmts.iter().enumerate() {\n+            let hir_id = stmt.hir_id;\n+            let opt_dxn_ext = self.region_scope_tree.opt_destruction_scope(hir_id.local_id);\n+            match stmt.kind {\n+                hir::StmtKind::Expr(ref expr) | hir::StmtKind::Semi(ref expr) => {\n+                    result.push(Stmt {\n+                        kind: StmtKind::Expr {\n+                            scope: region::Scope {\n+                                id: hir_id.local_id,\n+                                data: region::ScopeData::Node,\n+                            },\n+                            expr: self.mirror_expr_boxed(expr),\n+                        },\n+                        opt_destruction_scope: opt_dxn_ext,\n+                    })\n+                }\n+                hir::StmtKind::Item(..) => {\n+                    // ignore for purposes of the MIR\n+                }\n+                hir::StmtKind::Local(ref local) => {\n+                    let remainder_scope = region::Scope {\n+                        id: block_id,\n+                        data: region::ScopeData::Remainder(region::FirstStatementIndex::new(index)),\n+                    };\n \n-                let mut pattern = cx.pattern_from_hir(&local.pat);\n+                    let mut pattern = self.pattern_from_hir(&local.pat);\n \n-                if let Some(ty) = &local.ty {\n-                    if let Some(&user_ty) = cx.typeck_results.user_provided_types().get(ty.hir_id) {\n-                        debug!(\"mirror_stmts: user_ty={:?}\", user_ty);\n-                        pattern = Pat {\n-                            ty: pattern.ty,\n-                            span: pattern.span,\n-                            kind: Box::new(PatKind::AscribeUserType {\n-                                ascription: thir::pattern::Ascription {\n-                                    user_ty: PatTyProj::from_user_type(user_ty),\n-                                    user_ty_span: ty.span,\n-                                    variance: ty::Variance::Covariant,\n-                                },\n-                                subpattern: pattern,\n-                            }),\n-                        };\n+                    if let Some(ty) = &local.ty {\n+                        if let Some(&user_ty) =\n+                            self.typeck_results.user_provided_types().get(ty.hir_id)\n+                        {\n+                            debug!(\"mirror_stmts: user_ty={:?}\", user_ty);\n+                            pattern = Pat {\n+                                ty: pattern.ty,\n+                                span: pattern.span,\n+                                kind: Box::new(PatKind::AscribeUserType {\n+                                    ascription: thir::pattern::Ascription {\n+                                        user_ty: PatTyProj::from_user_type(user_ty),\n+                                        user_ty_span: ty.span,\n+                                        variance: ty::Variance::Covariant,\n+                                    },\n+                                    subpattern: pattern,\n+                                }),\n+                            };\n+                        }\n                     }\n-                }\n \n-                result.push(StmtRef::Mirror(Box::new(Stmt {\n-                    kind: StmtKind::Let {\n-                        remainder_scope,\n-                        init_scope: region::Scope {\n-                            id: hir_id.local_id,\n-                            data: region::ScopeData::Node,\n+                    result.push(Stmt {\n+                        kind: StmtKind::Let {\n+                            remainder_scope,\n+                            init_scope: region::Scope {\n+                                id: hir_id.local_id,\n+                                data: region::ScopeData::Node,\n+                            },\n+                            pattern,\n+                            initializer: local.init.map(|init| self.mirror_expr_boxed(init)),\n+                            lint_level: LintLevel::Explicit(local.hir_id),\n                         },\n-                        pattern,\n-                        initializer: local.init.to_ref(),\n-                        lint_level: LintLevel::Explicit(local.hir_id),\n-                    },\n-                    opt_destruction_scope: opt_dxn_ext,\n-                })));\n+                        opt_destruction_scope: opt_dxn_ext,\n+                    });\n+                }\n             }\n         }\n+        result\n     }\n-    result\n-}\n-\n-crate fn to_expr_ref<'a, 'tcx>(\n-    cx: &mut Cx<'a, 'tcx>,\n-    block: &'tcx hir::Block<'tcx>,\n-) -> ExprRef<'tcx> {\n-    let block_ty = cx.typeck_results().node_type(block.hir_id);\n-    let temp_lifetime = cx.region_scope_tree.temporary_scope(block.hir_id.local_id);\n-    let expr = Expr {\n-        ty: block_ty,\n-        temp_lifetime,\n-        span: block.span,\n-        kind: ExprKind::Block { body: block },\n-    };\n-    expr.to_ref()\n }"}, {"sha": "cd5e73a45cd59bb2d2390b0e739e82c5b14fa7cf", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 916, "deletions": 873, "changes": 1789, "blob_url": "https://github.com/rust-lang/rust/blob/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=60def4de5e1eb4d8cc4b9733c8bf199b73d8635a", "patch": "@@ -1,5 +1,3 @@\n-use crate::thir::cx::block;\n-use crate::thir::cx::to_ref::ToRef;\n use crate::thir::cx::Cx;\n use crate::thir::util::UserAnnotatedTyHelpers;\n use crate::thir::*;\n@@ -17,45 +15,45 @@ use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n use rustc_middle::ty::{self, AdtKind, Ty};\n use rustc_span::Span;\n \n-impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr<'tcx> {\n-    type Output = Expr<'tcx>;\n+impl<'a, 'tcx> Cx<'a, 'tcx> {\n+    crate fn mirror_expr(&mut self, hir_expr: &'tcx hir::Expr<'tcx>) -> Expr<'tcx> {\n+        let temp_lifetime = self.region_scope_tree.temporary_scope(hir_expr.hir_id.local_id);\n+        let expr_scope =\n+            region::Scope { id: hir_expr.hir_id.local_id, data: region::ScopeData::Node };\n \n-    fn make_mirror(self, cx: &mut Cx<'_, 'tcx>) -> Expr<'tcx> {\n-        let temp_lifetime = cx.region_scope_tree.temporary_scope(self.hir_id.local_id);\n-        let expr_scope = region::Scope { id: self.hir_id.local_id, data: region::ScopeData::Node };\n+        debug!(\"Expr::make_mirror(): id={}, span={:?}\", hir_expr.hir_id, hir_expr.span);\n \n-        debug!(\"Expr::make_mirror(): id={}, span={:?}\", self.hir_id, self.span);\n-\n-        let mut expr = make_mirror_unadjusted(cx, self);\n+        let mut expr = self.make_mirror_unadjusted(hir_expr);\n \n         // Now apply adjustments, if any.\n-        for adjustment in cx.typeck_results().expr_adjustments(self) {\n+        for adjustment in self.typeck_results().expr_adjustments(hir_expr) {\n             debug!(\"make_mirror: expr={:?} applying adjustment={:?}\", expr, adjustment);\n-            expr = apply_adjustment(cx, self, expr, adjustment);\n+            expr = self.apply_adjustment(hir_expr, expr, adjustment);\n         }\n \n         // Next, wrap this up in the expr's scope.\n         expr = Expr {\n             temp_lifetime,\n             ty: expr.ty,\n-            span: self.span,\n+            span: hir_expr.span,\n             kind: ExprKind::Scope {\n                 region_scope: expr_scope,\n-                value: expr.to_ref(),\n-                lint_level: LintLevel::Explicit(self.hir_id),\n+                value: Box::new(expr),\n+                lint_level: LintLevel::Explicit(hir_expr.hir_id),\n             },\n         };\n \n         // Finally, create a destruction scope, if any.\n-        if let Some(region_scope) = cx.region_scope_tree.opt_destruction_scope(self.hir_id.local_id)\n+        if let Some(region_scope) =\n+            self.region_scope_tree.opt_destruction_scope(hir_expr.hir_id.local_id)\n         {\n             expr = Expr {\n                 temp_lifetime,\n                 ty: expr.ty,\n-                span: self.span,\n+                span: hir_expr.span,\n                 kind: ExprKind::Scope {\n                     region_scope,\n-                    value: expr.to_ref(),\n+                    value: Box::new(expr),\n                     lint_level: LintLevel::Inherited,\n                 },\n             };\n@@ -64,687 +62,997 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr<'tcx> {\n         // OK, all done!\n         expr\n     }\n-}\n-\n-fn apply_adjustment<'a, 'tcx>(\n-    cx: &mut Cx<'a, 'tcx>,\n-    hir_expr: &'tcx hir::Expr<'tcx>,\n-    mut expr: Expr<'tcx>,\n-    adjustment: &Adjustment<'tcx>,\n-) -> Expr<'tcx> {\n-    let Expr { temp_lifetime, mut span, .. } = expr;\n-\n-    // Adjust the span from the block, to the last expression of the\n-    // block. This is a better span when returning a mutable reference\n-    // with too short a lifetime. The error message will use the span\n-    // from the assignment to the return place, which should only point\n-    // at the returned value, not the entire function body.\n-    //\n-    // fn return_short_lived<'a>(x: &'a mut i32) -> &'static mut i32 {\n-    //      x\n-    //   // ^ error message points at this expression.\n-    // }\n-    let mut adjust_span = |expr: &mut Expr<'tcx>| {\n-        if let ExprKind::Block { body } = expr.kind {\n-            if let Some(ref last_expr) = body.expr {\n-                span = last_expr.span;\n-                expr.span = span;\n-            }\n-        }\n-    };\n \n-    let kind = match adjustment.kind {\n-        Adjust::Pointer(PointerCast::Unsize) => {\n-            adjust_span(&mut expr);\n-            ExprKind::Pointer { cast: PointerCast::Unsize, source: expr.to_ref() }\n-        }\n-        Adjust::Pointer(cast) => ExprKind::Pointer { cast, source: expr.to_ref() },\n-        Adjust::NeverToAny => ExprKind::NeverToAny { source: expr.to_ref() },\n-        Adjust::Deref(None) => {\n-            adjust_span(&mut expr);\n-            ExprKind::Deref { arg: expr.to_ref() }\n-        }\n-        Adjust::Deref(Some(deref)) => {\n-            // We don't need to do call adjust_span here since\n-            // deref coercions always start with a built-in deref.\n-            let call = deref.method_call(cx.tcx(), expr.ty);\n-\n-            expr = Expr {\n-                temp_lifetime,\n-                ty: cx.tcx.mk_ref(deref.region, ty::TypeAndMut { ty: expr.ty, mutbl: deref.mutbl }),\n-                span,\n-                kind: ExprKind::Borrow {\n-                    borrow_kind: deref.mutbl.to_borrow_kind(),\n-                    arg: expr.to_ref(),\n-                },\n-            };\n+    crate fn mirror_exprs(&mut self, exprs: &'tcx [hir::Expr<'tcx>]) -> Vec<Expr<'tcx>> {\n+        exprs.iter().map(|expr| self.mirror_expr(expr)).collect()\n+    }\n \n-            overloaded_place(\n-                cx,\n-                hir_expr,\n-                adjustment.target,\n-                Some(call),\n-                vec![expr.to_ref()],\n-                deref.span,\n-            )\n-        }\n-        Adjust::Borrow(AutoBorrow::Ref(_, m)) => {\n-            ExprKind::Borrow { borrow_kind: m.to_borrow_kind(), arg: expr.to_ref() }\n-        }\n-        Adjust::Borrow(AutoBorrow::RawPtr(mutability)) => {\n-            ExprKind::AddressOf { mutability, arg: expr.to_ref() }\n-        }\n-    };\n+    crate fn mirror_expr_boxed(&mut self, expr: &'tcx hir::Expr<'tcx>) -> Box<Expr<'tcx>> {\n+        Box::new(self.mirror_expr(expr))\n+    }\n \n-    Expr { temp_lifetime, ty: adjustment.target, span, kind }\n-}\n+    fn apply_adjustment(\n+        &mut self,\n+        hir_expr: &'tcx hir::Expr<'tcx>,\n+        mut expr: Expr<'tcx>,\n+        adjustment: &Adjustment<'tcx>,\n+    ) -> Expr<'tcx> {\n+        let Expr { temp_lifetime, mut span, .. } = expr;\n+\n+        // Adjust the span from the block, to the last expression of the\n+        // block. This is a better span when returning a mutable reference\n+        // with too short a lifetime. The error message will use the span\n+        // from the assignment to the return place, which should only point\n+        // at the returned value, not the entire function body.\n+        //\n+        // fn return_short_lived<'a>(x: &'a mut i32) -> &'static mut i32 {\n+        //      x\n+        //   // ^ error message points at this expression.\n+        // }\n+        let mut adjust_span = |expr: &mut Expr<'tcx>| {\n+            if let ExprKind::Block { body } = &expr.kind {\n+                if let Some(ref last_expr) = body.expr {\n+                    span = last_expr.span;\n+                    expr.span = span;\n+                }\n+            }\n+        };\n \n-fn make_mirror_unadjusted<'a, 'tcx>(\n-    cx: &mut Cx<'a, 'tcx>,\n-    expr: &'tcx hir::Expr<'tcx>,\n-) -> Expr<'tcx> {\n-    let expr_ty = cx.typeck_results().expr_ty(expr);\n-    let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n-\n-    let kind = match expr.kind {\n-        // Here comes the interesting stuff:\n-        hir::ExprKind::MethodCall(_, method_span, ref args, fn_span) => {\n-            // Rewrite a.b(c) into UFCS form like Trait::b(a, c)\n-            let expr = method_callee(cx, expr, method_span, None);\n-            let args = args.iter().map(|e| e.to_ref()).collect();\n-            ExprKind::Call { ty: expr.ty, fun: expr.to_ref(), args, from_hir_call: true, fn_span }\n-        }\n+        let kind = match adjustment.kind {\n+            Adjust::Pointer(PointerCast::Unsize) => {\n+                adjust_span(&mut expr);\n+                ExprKind::Pointer { cast: PointerCast::Unsize, source: Box::new(expr) }\n+            }\n+            Adjust::Pointer(cast) => ExprKind::Pointer { cast, source: Box::new(expr) },\n+            Adjust::NeverToAny => ExprKind::NeverToAny { source: Box::new(expr) },\n+            Adjust::Deref(None) => {\n+                adjust_span(&mut expr);\n+                ExprKind::Deref { arg: Box::new(expr) }\n+            }\n+            Adjust::Deref(Some(deref)) => {\n+                // We don't need to do call adjust_span here since\n+                // deref coercions always start with a built-in deref.\n+                let call = deref.method_call(self.tcx(), expr.ty);\n \n-        hir::ExprKind::Call(ref fun, ref args) => {\n-            if cx.typeck_results().is_method_call(expr) {\n-                // The callee is something implementing Fn, FnMut, or FnOnce.\n-                // Find the actual method implementation being called and\n-                // build the appropriate UFCS call expression with the\n-                // callee-object as expr parameter.\n+                expr = Expr {\n+                    temp_lifetime,\n+                    ty: self\n+                        .tcx\n+                        .mk_ref(deref.region, ty::TypeAndMut { ty: expr.ty, mutbl: deref.mutbl }),\n+                    span,\n+                    kind: ExprKind::Borrow {\n+                        borrow_kind: deref.mutbl.to_borrow_kind(),\n+                        arg: Box::new(expr),\n+                    },\n+                };\n \n-                // rewrite f(u, v) into FnOnce::call_once(f, (u, v))\n+                self.overloaded_place(\n+                    hir_expr,\n+                    adjustment.target,\n+                    Some(call),\n+                    vec![expr],\n+                    deref.span,\n+                )\n+            }\n+            Adjust::Borrow(AutoBorrow::Ref(_, m)) => {\n+                ExprKind::Borrow { borrow_kind: m.to_borrow_kind(), arg: Box::new(expr) }\n+            }\n+            Adjust::Borrow(AutoBorrow::RawPtr(mutability)) => {\n+                ExprKind::AddressOf { mutability, arg: Box::new(expr) }\n+            }\n+        };\n \n-                let method = method_callee(cx, expr, fun.span, None);\n+        Expr { temp_lifetime, ty: adjustment.target, span, kind }\n+    }\n \n-                let arg_tys = args.iter().map(|e| cx.typeck_results().expr_ty_adjusted(e));\n-                let tupled_args = Expr {\n-                    ty: cx.tcx.mk_tup(arg_tys),\n-                    temp_lifetime,\n-                    span: expr.span,\n-                    kind: ExprKind::Tuple { fields: args.iter().map(ToRef::to_ref).collect() },\n-                };\n+    fn make_mirror_unadjusted(&mut self, expr: &'tcx hir::Expr<'tcx>) -> Expr<'tcx> {\n+        let expr_ty = self.typeck_results().expr_ty(expr);\n+        let temp_lifetime = self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n \n+        let kind = match expr.kind {\n+            // Here comes the interesting stuff:\n+            hir::ExprKind::MethodCall(_, method_span, ref args, fn_span) => {\n+                // Rewrite a.b(c) into UFCS form like Trait::b(a, c)\n+                let expr = self.method_callee(expr, method_span, None);\n+                let args = self.mirror_exprs(args);\n                 ExprKind::Call {\n-                    ty: method.ty,\n-                    fun: method.to_ref(),\n-                    args: vec![fun.to_ref(), tupled_args.to_ref()],\n+                    ty: expr.ty,\n+                    fun: Box::new(expr),\n+                    args,\n                     from_hir_call: true,\n-                    fn_span: expr.span,\n+                    fn_span,\n                 }\n-            } else {\n-                let adt_data =\n-                    if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = fun.kind {\n-                        // Tuple-like ADTs are represented as ExprKind::Call. We convert them here.\n-                        expr_ty.ty_adt_def().and_then(|adt_def| match path.res {\n-                            Res::Def(DefKind::Ctor(_, CtorKind::Fn), ctor_id) => {\n-                                Some((adt_def, adt_def.variant_index_with_ctor_id(ctor_id)))\n-                            }\n-                            Res::SelfCtor(..) => Some((adt_def, VariantIdx::new(0))),\n-                            _ => None,\n-                        })\n-                    } else {\n-                        None\n+            }\n+\n+            hir::ExprKind::Call(ref fun, ref args) => {\n+                if self.typeck_results().is_method_call(expr) {\n+                    // The callee is something implementing Fn, FnMut, or FnOnce.\n+                    // Find the actual method implementation being called and\n+                    // build the appropriate UFCS call expression with the\n+                    // callee-object as expr parameter.\n+\n+                    // rewrite f(u, v) into FnOnce::call_once(f, (u, v))\n+\n+                    let method = self.method_callee(expr, fun.span, None);\n+\n+                    let arg_tys = args.iter().map(|e| self.typeck_results().expr_ty_adjusted(e));\n+                    let tupled_args = Expr {\n+                        ty: self.tcx.mk_tup(arg_tys),\n+                        temp_lifetime,\n+                        span: expr.span,\n+                        kind: ExprKind::Tuple { fields: self.mirror_exprs(args) },\n                     };\n-                if let Some((adt_def, index)) = adt_data {\n-                    let substs = cx.typeck_results().node_substs(fun.hir_id);\n-                    let user_provided_types = cx.typeck_results().user_provided_types();\n-                    let user_ty = user_provided_types.get(fun.hir_id).copied().map(|mut u_ty| {\n-                        if let UserType::TypeOf(ref mut did, _) = &mut u_ty.value {\n-                            *did = adt_def.did;\n-                        }\n-                        u_ty\n-                    });\n-                    debug!(\"make_mirror_unadjusted: (call) user_ty={:?}\", user_ty);\n-\n-                    let field_refs = args\n-                        .iter()\n-                        .enumerate()\n-                        .map(|(idx, e)| FieldExprRef { name: Field::new(idx), expr: e.to_ref() })\n-                        .collect();\n-                    ExprKind::Adt {\n-                        adt_def,\n-                        substs,\n-                        variant_index: index,\n-                        fields: field_refs,\n-                        user_ty,\n-                        base: None,\n-                    }\n-                } else {\n+\n                     ExprKind::Call {\n-                        ty: cx.typeck_results().node_type(fun.hir_id),\n-                        fun: fun.to_ref(),\n-                        args: args.to_ref(),\n+                        ty: method.ty,\n+                        fun: Box::new(method),\n+                        args: vec![self.mirror_expr(fun), tupled_args],\n                         from_hir_call: true,\n                         fn_span: expr.span,\n                     }\n+                } else {\n+                    let adt_data =\n+                        if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = fun.kind {\n+                            // Tuple-like ADTs are represented as ExprKind::Call. We convert them here.\n+                            expr_ty.ty_adt_def().and_then(|adt_def| match path.res {\n+                                Res::Def(DefKind::Ctor(_, CtorKind::Fn), ctor_id) => {\n+                                    Some((adt_def, adt_def.variant_index_with_ctor_id(ctor_id)))\n+                                }\n+                                Res::SelfCtor(..) => Some((adt_def, VariantIdx::new(0))),\n+                                _ => None,\n+                            })\n+                        } else {\n+                            None\n+                        };\n+                    if let Some((adt_def, index)) = adt_data {\n+                        let substs = self.typeck_results().node_substs(fun.hir_id);\n+                        let user_provided_types = self.typeck_results().user_provided_types();\n+                        let user_ty =\n+                            user_provided_types.get(fun.hir_id).copied().map(|mut u_ty| {\n+                                if let UserType::TypeOf(ref mut did, _) = &mut u_ty.value {\n+                                    *did = adt_def.did;\n+                                }\n+                                u_ty\n+                            });\n+                        debug!(\"make_mirror_unadjusted: (call) user_ty={:?}\", user_ty);\n+\n+                        let field_refs = args\n+                            .iter()\n+                            .enumerate()\n+                            .map(|(idx, e)| FieldExpr {\n+                                name: Field::new(idx),\n+                                expr: self.mirror_expr(e),\n+                            })\n+                            .collect();\n+                        ExprKind::Adt {\n+                            adt_def,\n+                            substs,\n+                            variant_index: index,\n+                            fields: field_refs,\n+                            user_ty,\n+                            base: None,\n+                        }\n+                    } else {\n+                        ExprKind::Call {\n+                            ty: self.typeck_results().node_type(fun.hir_id),\n+                            fun: self.mirror_expr_boxed(fun),\n+                            args: self.mirror_exprs(args),\n+                            from_hir_call: true,\n+                            fn_span: expr.span,\n+                        }\n+                    }\n                 }\n             }\n-        }\n \n-        hir::ExprKind::AddrOf(hir::BorrowKind::Ref, mutbl, ref arg) => {\n-            ExprKind::Borrow { borrow_kind: mutbl.to_borrow_kind(), arg: arg.to_ref() }\n-        }\n+            hir::ExprKind::AddrOf(hir::BorrowKind::Ref, mutbl, ref arg) => ExprKind::Borrow {\n+                borrow_kind: mutbl.to_borrow_kind(),\n+                arg: self.mirror_expr_boxed(arg),\n+            },\n \n-        hir::ExprKind::AddrOf(hir::BorrowKind::Raw, mutability, ref arg) => {\n-            ExprKind::AddressOf { mutability, arg: arg.to_ref() }\n-        }\n+            hir::ExprKind::AddrOf(hir::BorrowKind::Raw, mutability, ref arg) => {\n+                ExprKind::AddressOf { mutability, arg: self.mirror_expr_boxed(arg) }\n+            }\n \n-        hir::ExprKind::Block(ref blk, _) => ExprKind::Block { body: &blk },\n+            hir::ExprKind::Block(ref blk, _) => ExprKind::Block { body: self.mirror_block(blk) },\n \n-        hir::ExprKind::Assign(ref lhs, ref rhs, _) => {\n-            ExprKind::Assign { lhs: lhs.to_ref(), rhs: rhs.to_ref() }\n-        }\n+            hir::ExprKind::Assign(ref lhs, ref rhs, _) => ExprKind::Assign {\n+                lhs: self.mirror_expr_boxed(lhs),\n+                rhs: self.mirror_expr_boxed(rhs),\n+            },\n \n-        hir::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n-            if cx.typeck_results().is_method_call(expr) {\n-                overloaded_operator(cx, expr, vec![lhs.to_ref(), rhs.to_ref()])\n-            } else {\n-                ExprKind::AssignOp { op: bin_op(op.node), lhs: lhs.to_ref(), rhs: rhs.to_ref() }\n+            hir::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n+                if self.typeck_results().is_method_call(expr) {\n+                    let lhs = self.mirror_expr(lhs);\n+                    let rhs = self.mirror_expr(rhs);\n+                    self.overloaded_operator(expr, vec![lhs, rhs])\n+                } else {\n+                    ExprKind::AssignOp {\n+                        op: bin_op(op.node),\n+                        lhs: self.mirror_expr_boxed(lhs),\n+                        rhs: self.mirror_expr_boxed(rhs),\n+                    }\n+                }\n             }\n-        }\n \n-        hir::ExprKind::Lit(ref lit) => ExprKind::Literal {\n-            literal: cx.const_eval_literal(&lit.node, expr_ty, lit.span, false),\n-            user_ty: None,\n-            const_id: None,\n-        },\n-\n-        hir::ExprKind::Binary(op, ref lhs, ref rhs) => {\n-            if cx.typeck_results().is_method_call(expr) {\n-                overloaded_operator(cx, expr, vec![lhs.to_ref(), rhs.to_ref()])\n-            } else {\n-                // FIXME overflow\n-                match (op.node, cx.constness) {\n-                    (hir::BinOpKind::And, _) => ExprKind::LogicalOp {\n-                        op: LogicalOp::And,\n-                        lhs: lhs.to_ref(),\n-                        rhs: rhs.to_ref(),\n-                    },\n-                    (hir::BinOpKind::Or, _) => ExprKind::LogicalOp {\n-                        op: LogicalOp::Or,\n-                        lhs: lhs.to_ref(),\n-                        rhs: rhs.to_ref(),\n-                    },\n+            hir::ExprKind::Lit(ref lit) => ExprKind::Literal {\n+                literal: self.const_eval_literal(&lit.node, expr_ty, lit.span, false),\n+                user_ty: None,\n+                const_id: None,\n+            },\n \n-                    _ => {\n-                        let op = bin_op(op.node);\n-                        ExprKind::Binary { op, lhs: lhs.to_ref(), rhs: rhs.to_ref() }\n+            hir::ExprKind::Binary(op, ref lhs, ref rhs) => {\n+                if self.typeck_results().is_method_call(expr) {\n+                    let lhs = self.mirror_expr(lhs);\n+                    let rhs = self.mirror_expr(rhs);\n+                    self.overloaded_operator(expr, vec![lhs, rhs])\n+                } else {\n+                    // FIXME overflow\n+                    match (op.node, self.constness) {\n+                        (hir::BinOpKind::And, _) => ExprKind::LogicalOp {\n+                            op: LogicalOp::And,\n+                            lhs: self.mirror_expr_boxed(lhs),\n+                            rhs: self.mirror_expr_boxed(rhs),\n+                        },\n+                        (hir::BinOpKind::Or, _) => ExprKind::LogicalOp {\n+                            op: LogicalOp::Or,\n+                            lhs: self.mirror_expr_boxed(lhs),\n+                            rhs: self.mirror_expr_boxed(rhs),\n+                        },\n+\n+                        _ => {\n+                            let op = bin_op(op.node);\n+                            ExprKind::Binary {\n+                                op,\n+                                lhs: self.mirror_expr_boxed(lhs),\n+                                rhs: self.mirror_expr_boxed(rhs),\n+                            }\n+                        }\n                     }\n                 }\n             }\n-        }\n \n-        hir::ExprKind::Index(ref lhs, ref index) => {\n-            if cx.typeck_results().is_method_call(expr) {\n-                overloaded_place(\n-                    cx,\n-                    expr,\n-                    expr_ty,\n-                    None,\n-                    vec![lhs.to_ref(), index.to_ref()],\n-                    expr.span,\n-                )\n-            } else {\n-                ExprKind::Index { lhs: lhs.to_ref(), index: index.to_ref() }\n+            hir::ExprKind::Index(ref lhs, ref index) => {\n+                if self.typeck_results().is_method_call(expr) {\n+                    let lhs = self.mirror_expr(lhs);\n+                    let index = self.mirror_expr(index);\n+                    self.overloaded_place(expr, expr_ty, None, vec![lhs, index], expr.span)\n+                } else {\n+                    ExprKind::Index {\n+                        lhs: self.mirror_expr_boxed(lhs),\n+                        index: self.mirror_expr_boxed(index),\n+                    }\n+                }\n             }\n-        }\n \n-        hir::ExprKind::Unary(hir::UnOp::Deref, ref arg) => {\n-            if cx.typeck_results().is_method_call(expr) {\n-                overloaded_place(cx, expr, expr_ty, None, vec![arg.to_ref()], expr.span)\n-            } else {\n-                ExprKind::Deref { arg: arg.to_ref() }\n+            hir::ExprKind::Unary(hir::UnOp::Deref, ref arg) => {\n+                if self.typeck_results().is_method_call(expr) {\n+                    let arg = self.mirror_expr(arg);\n+                    self.overloaded_place(expr, expr_ty, None, vec![arg], expr.span)\n+                } else {\n+                    ExprKind::Deref { arg: self.mirror_expr_boxed(arg) }\n+                }\n             }\n-        }\n \n-        hir::ExprKind::Unary(hir::UnOp::Not, ref arg) => {\n-            if cx.typeck_results().is_method_call(expr) {\n-                overloaded_operator(cx, expr, vec![arg.to_ref()])\n-            } else {\n-                ExprKind::Unary { op: UnOp::Not, arg: arg.to_ref() }\n+            hir::ExprKind::Unary(hir::UnOp::Not, ref arg) => {\n+                if self.typeck_results().is_method_call(expr) {\n+                    let arg = self.mirror_expr(arg);\n+                    self.overloaded_operator(expr, vec![arg])\n+                } else {\n+                    ExprKind::Unary { op: UnOp::Not, arg: self.mirror_expr_boxed(arg) }\n+                }\n             }\n-        }\n \n-        hir::ExprKind::Unary(hir::UnOp::Neg, ref arg) => {\n-            if cx.typeck_results().is_method_call(expr) {\n-                overloaded_operator(cx, expr, vec![arg.to_ref()])\n-            } else if let hir::ExprKind::Lit(ref lit) = arg.kind {\n-                ExprKind::Literal {\n-                    literal: cx.const_eval_literal(&lit.node, expr_ty, lit.span, true),\n-                    user_ty: None,\n-                    const_id: None,\n+            hir::ExprKind::Unary(hir::UnOp::Neg, ref arg) => {\n+                if self.typeck_results().is_method_call(expr) {\n+                    let arg = self.mirror_expr(arg);\n+                    self.overloaded_operator(expr, vec![arg])\n+                } else if let hir::ExprKind::Lit(ref lit) = arg.kind {\n+                    ExprKind::Literal {\n+                        literal: self.const_eval_literal(&lit.node, expr_ty, lit.span, true),\n+                        user_ty: None,\n+                        const_id: None,\n+                    }\n+                } else {\n+                    ExprKind::Unary { op: UnOp::Neg, arg: self.mirror_expr_boxed(arg) }\n                 }\n-            } else {\n-                ExprKind::Unary { op: UnOp::Neg, arg: arg.to_ref() }\n             }\n-        }\n \n-        hir::ExprKind::Struct(ref qpath, ref fields, ref base) => match expr_ty.kind() {\n-            ty::Adt(adt, substs) => match adt.adt_kind() {\n-                AdtKind::Struct | AdtKind::Union => {\n-                    let user_provided_types = cx.typeck_results().user_provided_types();\n-                    let user_ty = user_provided_types.get(expr.hir_id).copied();\n-                    debug!(\"make_mirror_unadjusted: (struct/union) user_ty={:?}\", user_ty);\n-                    ExprKind::Adt {\n-                        adt_def: adt,\n-                        variant_index: VariantIdx::new(0),\n-                        substs,\n-                        user_ty,\n-                        fields: field_refs(cx, fields),\n-                        base: base.as_ref().map(|base| FruInfo {\n-                            base: base.to_ref(),\n-                            field_types: cx.typeck_results().fru_field_types()[expr.hir_id].clone(),\n-                        }),\n+            hir::ExprKind::Struct(ref qpath, ref fields, ref base) => match expr_ty.kind() {\n+                ty::Adt(adt, substs) => match adt.adt_kind() {\n+                    AdtKind::Struct | AdtKind::Union => {\n+                        let user_provided_types = self.typeck_results().user_provided_types();\n+                        let user_ty = user_provided_types.get(expr.hir_id).copied();\n+                        debug!(\"make_mirror_unadjusted: (struct/union) user_ty={:?}\", user_ty);\n+                        ExprKind::Adt {\n+                            adt_def: adt,\n+                            variant_index: VariantIdx::new(0),\n+                            substs,\n+                            user_ty,\n+                            fields: self.field_refs(fields),\n+                            base: base.as_ref().map(|base| FruInfo {\n+                                base: self.mirror_expr_boxed(base),\n+                                field_types: self.typeck_results().fru_field_types()[expr.hir_id]\n+                                    .clone(),\n+                            }),\n+                        }\n                     }\n-                }\n-                AdtKind::Enum => {\n-                    let res = cx.typeck_results().qpath_res(qpath, expr.hir_id);\n-                    match res {\n-                        Res::Def(DefKind::Variant, variant_id) => {\n-                            assert!(base.is_none());\n-\n-                            let index = adt.variant_index_with_id(variant_id);\n-                            let user_provided_types = cx.typeck_results().user_provided_types();\n-                            let user_ty = user_provided_types.get(expr.hir_id).copied();\n-                            debug!(\"make_mirror_unadjusted: (variant) user_ty={:?}\", user_ty);\n-                            ExprKind::Adt {\n-                                adt_def: adt,\n-                                variant_index: index,\n-                                substs,\n-                                user_ty,\n-                                fields: field_refs(cx, fields),\n-                                base: None,\n+                    AdtKind::Enum => {\n+                        let res = self.typeck_results().qpath_res(qpath, expr.hir_id);\n+                        match res {\n+                            Res::Def(DefKind::Variant, variant_id) => {\n+                                assert!(base.is_none());\n+\n+                                let index = adt.variant_index_with_id(variant_id);\n+                                let user_provided_types =\n+                                    self.typeck_results().user_provided_types();\n+                                let user_ty = user_provided_types.get(expr.hir_id).copied();\n+                                debug!(\"make_mirror_unadjusted: (variant) user_ty={:?}\", user_ty);\n+                                ExprKind::Adt {\n+                                    adt_def: adt,\n+                                    variant_index: index,\n+                                    substs,\n+                                    user_ty,\n+                                    fields: self.field_refs(fields),\n+                                    base: None,\n+                                }\n+                            }\n+                            _ => {\n+                                span_bug!(expr.span, \"unexpected res: {:?}\", res);\n                             }\n-                        }\n-                        _ => {\n-                            span_bug!(expr.span, \"unexpected res: {:?}\", res);\n                         }\n                     }\n-                }\n-            },\n-            _ => {\n-                span_bug!(expr.span, \"unexpected type for struct literal: {:?}\", expr_ty);\n-            }\n-        },\n-\n-        hir::ExprKind::Closure(..) => {\n-            let closure_ty = cx.typeck_results().expr_ty(expr);\n-            let (def_id, substs, movability) = match *closure_ty.kind() {\n-                ty::Closure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs), None),\n-                ty::Generator(def_id, substs, movability) => {\n-                    (def_id, UpvarSubsts::Generator(substs), Some(movability))\n-                }\n+                },\n                 _ => {\n-                    span_bug!(expr.span, \"closure expr w/o closure type: {:?}\", closure_ty);\n+                    span_bug!(expr.span, \"unexpected type for struct literal: {:?}\", expr_ty);\n                 }\n-            };\n+            },\n \n-            let upvars = cx\n-                .typeck_results()\n-                .closure_min_captures_flattened(def_id)\n-                .zip(substs.upvar_tys())\n-                .map(|(captured_place, ty)| capture_upvar(cx, expr, captured_place, ty))\n-                .collect();\n-            ExprKind::Closure { closure_id: def_id, substs, upvars, movability }\n-        }\n+            hir::ExprKind::Closure(..) => {\n+                let closure_ty = self.typeck_results().expr_ty(expr);\n+                let (def_id, substs, movability) = match *closure_ty.kind() {\n+                    ty::Closure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs), None),\n+                    ty::Generator(def_id, substs, movability) => {\n+                        (def_id, UpvarSubsts::Generator(substs), Some(movability))\n+                    }\n+                    _ => {\n+                        span_bug!(expr.span, \"closure expr w/o closure type: {:?}\", closure_ty);\n+                    }\n+                };\n \n-        hir::ExprKind::Path(ref qpath) => {\n-            let res = cx.typeck_results().qpath_res(qpath, expr.hir_id);\n-            convert_path_expr(cx, expr, res)\n-        }\n+                let upvars = self\n+                    .typeck_results()\n+                    .closure_min_captures_flattened(def_id)\n+                    .zip(substs.upvar_tys())\n+                    .map(|(captured_place, ty)| self.capture_upvar(expr, captured_place, ty))\n+                    .collect();\n+                ExprKind::Closure { closure_id: def_id, substs, upvars, movability }\n+            }\n \n-        hir::ExprKind::InlineAsm(ref asm) => ExprKind::InlineAsm {\n-            template: asm.template,\n-            operands: asm\n-                .operands\n-                .iter()\n-                .map(|(op, _op_sp)| {\n-                    match *op {\n-                        hir::InlineAsmOperand::In { reg, ref expr } => {\n-                            InlineAsmOperand::In { reg, expr: expr.to_ref() }\n-                        }\n-                        hir::InlineAsmOperand::Out { reg, late, ref expr } => {\n-                            InlineAsmOperand::Out {\n+            hir::ExprKind::Path(ref qpath) => {\n+                let res = self.typeck_results().qpath_res(qpath, expr.hir_id);\n+                self.convert_path_expr(expr, res)\n+            }\n+\n+            hir::ExprKind::InlineAsm(ref asm) => ExprKind::InlineAsm {\n+                template: asm.template,\n+                operands: asm\n+                    .operands\n+                    .iter()\n+                    .map(|(op, _op_sp)| {\n+                        match *op {\n+                            hir::InlineAsmOperand::In { reg, ref expr } => {\n+                                InlineAsmOperand::In { reg, expr: self.mirror_expr(expr) }\n+                            }\n+                            hir::InlineAsmOperand::Out { reg, late, ref expr } => {\n+                                InlineAsmOperand::Out {\n+                                    reg,\n+                                    late,\n+                                    expr: expr.as_ref().map(|expr| self.mirror_expr(expr)),\n+                                }\n+                            }\n+                            hir::InlineAsmOperand::InOut { reg, late, ref expr } => {\n+                                InlineAsmOperand::InOut { reg, late, expr: self.mirror_expr(expr) }\n+                            }\n+                            hir::InlineAsmOperand::SplitInOut {\n                                 reg,\n                                 late,\n-                                expr: expr.as_ref().map(|expr| expr.to_ref()),\n+                                ref in_expr,\n+                                ref out_expr,\n+                            } => InlineAsmOperand::SplitInOut {\n+                                reg,\n+                                late,\n+                                in_expr: self.mirror_expr(in_expr),\n+                                out_expr: out_expr.as_ref().map(|expr| self.mirror_expr(expr)),\n+                            },\n+                            hir::InlineAsmOperand::Const { ref expr } => {\n+                                InlineAsmOperand::Const { expr: self.mirror_expr(expr) }\n                             }\n-                        }\n-                        hir::InlineAsmOperand::InOut { reg, late, ref expr } => {\n-                            InlineAsmOperand::InOut { reg, late, expr: expr.to_ref() }\n-                        }\n-                        hir::InlineAsmOperand::SplitInOut {\n-                            reg,\n-                            late,\n-                            ref in_expr,\n-                            ref out_expr,\n-                        } => InlineAsmOperand::SplitInOut {\n-                            reg,\n-                            late,\n-                            in_expr: in_expr.to_ref(),\n-                            out_expr: out_expr.as_ref().map(|expr| expr.to_ref()),\n-                        },\n-                        hir::InlineAsmOperand::Const { ref expr } => {\n-                            InlineAsmOperand::Const { expr: expr.to_ref() }\n-                        }\n-                        hir::InlineAsmOperand::Sym { ref expr } => {\n-                            let qpath = match expr.kind {\n-                                hir::ExprKind::Path(ref qpath) => qpath,\n-                                _ => span_bug!(\n-                                    expr.span,\n-                                    \"asm `sym` operand should be a path, found {:?}\",\n-                                    expr.kind\n-                                ),\n-                            };\n-                            let temp_lifetime =\n-                                cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n-                            let res = cx.typeck_results().qpath_res(qpath, expr.hir_id);\n-                            let ty;\n-                            match res {\n-                                Res::Def(DefKind::Fn, _) | Res::Def(DefKind::AssocFn, _) => {\n-                                    ty = cx.typeck_results().node_type(expr.hir_id);\n-                                    let user_ty = user_substs_applied_to_res(cx, expr.hir_id, res);\n-                                    InlineAsmOperand::SymFn {\n-                                        expr: Expr {\n-                                            ty,\n-                                            temp_lifetime,\n-                                            span: expr.span,\n-                                            kind: ExprKind::Literal {\n-                                                literal: ty::Const::zero_sized(cx.tcx, ty),\n-                                                user_ty,\n-                                                const_id: None,\n+                            hir::InlineAsmOperand::Sym { ref expr } => {\n+                                let qpath = match expr.kind {\n+                                    hir::ExprKind::Path(ref qpath) => qpath,\n+                                    _ => span_bug!(\n+                                        expr.span,\n+                                        \"asm `sym` operand should be a path, found {:?}\",\n+                                        expr.kind\n+                                    ),\n+                                };\n+                                let temp_lifetime =\n+                                    self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n+                                let res = self.typeck_results().qpath_res(qpath, expr.hir_id);\n+                                let ty;\n+                                match res {\n+                                    Res::Def(DefKind::Fn, _) | Res::Def(DefKind::AssocFn, _) => {\n+                                        ty = self.typeck_results().node_type(expr.hir_id);\n+                                        let user_ty =\n+                                            self.user_substs_applied_to_res(expr.hir_id, res);\n+                                        InlineAsmOperand::SymFn {\n+                                            expr: Expr {\n+                                                ty,\n+                                                temp_lifetime,\n+                                                span: expr.span,\n+                                                kind: ExprKind::Literal {\n+                                                    literal: ty::Const::zero_sized(self.tcx, ty),\n+                                                    user_ty,\n+                                                    const_id: None,\n+                                                },\n                                             },\n                                         }\n-                                        .to_ref(),\n                                     }\n-                                }\n \n-                                Res::Def(DefKind::Static, def_id) => {\n-                                    InlineAsmOperand::SymStatic { def_id }\n-                                }\n+                                    Res::Def(DefKind::Static, def_id) => {\n+                                        InlineAsmOperand::SymStatic { def_id }\n+                                    }\n \n-                                _ => {\n-                                    cx.tcx.sess.span_err(\n-                                        expr.span,\n-                                        \"asm `sym` operand must point to a fn or static\",\n-                                    );\n-\n-                                    // Not a real fn, but we're not reaching codegen anyways...\n-                                    ty = cx.tcx.ty_error();\n-                                    InlineAsmOperand::SymFn {\n-                                        expr: Expr {\n-                                            ty,\n-                                            temp_lifetime,\n-                                            span: expr.span,\n-                                            kind: ExprKind::Literal {\n-                                                literal: ty::Const::zero_sized(cx.tcx, ty),\n-                                                user_ty: None,\n-                                                const_id: None,\n+                                    _ => {\n+                                        self.tcx.sess.span_err(\n+                                            expr.span,\n+                                            \"asm `sym` operand must point to a fn or static\",\n+                                        );\n+\n+                                        // Not a real fn, but we're not reaching codegen anyways...\n+                                        ty = self.tcx.ty_error();\n+                                        InlineAsmOperand::SymFn {\n+                                            expr: Expr {\n+                                                ty,\n+                                                temp_lifetime,\n+                                                span: expr.span,\n+                                                kind: ExprKind::Literal {\n+                                                    literal: ty::Const::zero_sized(self.tcx, ty),\n+                                                    user_ty: None,\n+                                                    const_id: None,\n+                                                },\n                                             },\n                                         }\n-                                        .to_ref(),\n                                     }\n                                 }\n                             }\n                         }\n-                    }\n-                })\n-                .collect(),\n-            options: asm.options,\n-            line_spans: asm.line_spans,\n-        },\n-\n-        hir::ExprKind::LlvmInlineAsm(ref asm) => ExprKind::LlvmInlineAsm {\n-            asm: &asm.inner,\n-            outputs: asm.outputs_exprs.to_ref(),\n-            inputs: asm.inputs_exprs.to_ref(),\n-        },\n-\n-        hir::ExprKind::ConstBlock(ref anon_const) => {\n-            let anon_const_def_id = cx.tcx.hir().local_def_id(anon_const.hir_id);\n-            let value = ty::Const::from_anon_const(cx.tcx, anon_const_def_id);\n-\n-            ExprKind::ConstBlock { value }\n-        }\n-        // Now comes the rote stuff:\n-        hir::ExprKind::Repeat(ref v, ref count) => {\n-            let count_def_id = cx.tcx.hir().local_def_id(count.hir_id);\n-            let count = ty::Const::from_anon_const(cx.tcx, count_def_id);\n+                    })\n+                    .collect(),\n+                options: asm.options,\n+                line_spans: asm.line_spans,\n+            },\n \n-            ExprKind::Repeat { value: v.to_ref(), count }\n-        }\n-        hir::ExprKind::Ret(ref v) => ExprKind::Return { value: v.to_ref() },\n-        hir::ExprKind::Break(dest, ref value) => match dest.target_id {\n-            Ok(target_id) => ExprKind::Break {\n-                label: region::Scope { id: target_id.local_id, data: region::ScopeData::Node },\n-                value: value.to_ref(),\n+            hir::ExprKind::LlvmInlineAsm(ref asm) => ExprKind::LlvmInlineAsm {\n+                asm: &asm.inner,\n+                outputs: self.mirror_exprs(asm.outputs_exprs),\n+                inputs: self.mirror_exprs(asm.inputs_exprs),\n+            },\n+\n+            hir::ExprKind::ConstBlock(ref anon_const) => {\n+                let anon_const_def_id = self.tcx.hir().local_def_id(anon_const.hir_id);\n+                let value = ty::Const::from_anon_const(self.tcx, anon_const_def_id);\n+\n+                ExprKind::ConstBlock { value }\n+            }\n+            // Now comes the rote stuff:\n+            hir::ExprKind::Repeat(ref v, ref count) => {\n+                let count_def_id = self.tcx.hir().local_def_id(count.hir_id);\n+                let count = ty::Const::from_anon_const(self.tcx, count_def_id);\n+\n+                ExprKind::Repeat { value: self.mirror_expr_boxed(v), count }\n+            }\n+            hir::ExprKind::Ret(ref v) => {\n+                ExprKind::Return { value: v.as_ref().map(|v| self.mirror_expr_boxed(v)) }\n+            }\n+            hir::ExprKind::Break(dest, ref value) => match dest.target_id {\n+                Ok(target_id) => ExprKind::Break {\n+                    label: region::Scope { id: target_id.local_id, data: region::ScopeData::Node },\n+                    value: value.as_ref().map(|value| self.mirror_expr_boxed(value)),\n+                },\n+                Err(err) => bug!(\"invalid loop id for break: {}\", err),\n+            },\n+            hir::ExprKind::Continue(dest) => match dest.target_id {\n+                Ok(loop_id) => ExprKind::Continue {\n+                    label: region::Scope { id: loop_id.local_id, data: region::ScopeData::Node },\n+                },\n+                Err(err) => bug!(\"invalid loop id for continue: {}\", err),\n             },\n-            Err(err) => bug!(\"invalid loop id for break: {}\", err),\n-        },\n-        hir::ExprKind::Continue(dest) => match dest.target_id {\n-            Ok(loop_id) => ExprKind::Continue {\n-                label: region::Scope { id: loop_id.local_id, data: region::ScopeData::Node },\n+            hir::ExprKind::If(cond, then, else_opt) => ExprKind::If {\n+                cond: self.mirror_expr_boxed(cond),\n+                then: self.mirror_expr_boxed(then),\n+                else_opt: else_opt.map(|el| self.mirror_expr_boxed(el)),\n             },\n-            Err(err) => bug!(\"invalid loop id for continue: {}\", err),\n-        },\n-        hir::ExprKind::If(cond, then, else_opt) => ExprKind::If {\n-            cond: cond.to_ref(),\n-            then: then.to_ref(),\n-            else_opt: else_opt.map(|el| el.to_ref()),\n-        },\n-        hir::ExprKind::Match(ref discr, ref arms, _) => ExprKind::Match {\n-            scrutinee: discr.to_ref(),\n-            arms: arms.iter().map(|a| convert_arm(cx, a)).collect(),\n-        },\n-        hir::ExprKind::Loop(ref body, ..) => ExprKind::Loop { body: block::to_expr_ref(cx, body) },\n-        hir::ExprKind::Field(ref source, ..) => ExprKind::Field {\n-            lhs: source.to_ref(),\n-            name: Field::new(cx.tcx.field_index(expr.hir_id, cx.typeck_results)),\n-        },\n-        hir::ExprKind::Cast(ref source, ref cast_ty) => {\n-            // Check for a user-given type annotation on this `cast`\n-            let user_provided_types = cx.typeck_results.user_provided_types();\n-            let user_ty = user_provided_types.get(cast_ty.hir_id);\n-\n-            debug!(\n-                \"cast({:?}) has ty w/ hir_id {:?} and user provided ty {:?}\",\n-                expr, cast_ty.hir_id, user_ty,\n-            );\n-\n-            // Check to see if this cast is a \"coercion cast\", where the cast is actually done\n-            // using a coercion (or is a no-op).\n-            let cast = if cx.typeck_results().is_coercion_cast(source.hir_id) {\n-                // Convert the lexpr to a vexpr.\n-                ExprKind::Use { source: source.to_ref() }\n-            } else if cx.typeck_results().expr_ty(source).is_region_ptr() {\n-                // Special cased so that we can type check that the element\n-                // type of the source matches the pointed to type of the\n-                // destination.\n-                ExprKind::Pointer { source: source.to_ref(), cast: PointerCast::ArrayToPointer }\n-            } else {\n-                // check whether this is casting an enum variant discriminant\n-                // to prevent cycles, we refer to the discriminant initializer\n-                // which is always an integer and thus doesn't need to know the\n-                // enum's layout (or its tag type) to compute it during const eval\n-                // Example:\n-                // enum Foo {\n-                //     A,\n-                //     B = A as isize + 4,\n-                // }\n-                // The correct solution would be to add symbolic computations to miri,\n-                // so we wouldn't have to compute and store the actual value\n-                let var = if let hir::ExprKind::Path(ref qpath) = source.kind {\n-                    let res = cx.typeck_results().qpath_res(qpath, source.hir_id);\n-                    cx.typeck_results().node_type(source.hir_id).ty_adt_def().and_then(|adt_def| {\n-                        match res {\n-                            Res::Def(\n-                                DefKind::Ctor(CtorOf::Variant, CtorKind::Const),\n-                                variant_ctor_id,\n-                            ) => {\n-                                let idx = adt_def.variant_index_with_ctor_id(variant_ctor_id);\n-                                let (d, o) = adt_def.discriminant_def_for_variant(idx);\n-                                use rustc_middle::ty::util::IntTypeExt;\n-                                let ty = adt_def.repr.discr_type();\n-                                let ty = ty.to_ty(cx.tcx());\n-                                Some((d, o, ty))\n-                            }\n-                            _ => None,\n-                        }\n-                    })\n+            hir::ExprKind::Match(ref discr, ref arms, _) => ExprKind::Match {\n+                scrutinee: self.mirror_expr_boxed(discr),\n+                arms: arms.iter().map(|a| self.convert_arm(a)).collect(),\n+            },\n+            hir::ExprKind::Loop(ref body, ..) => {\n+                let block_ty = self.typeck_results().node_type(body.hir_id);\n+                let temp_lifetime = self.region_scope_tree.temporary_scope(body.hir_id.local_id);\n+                let block = self.mirror_block(body);\n+                let body = Box::new(Expr {\n+                    ty: block_ty,\n+                    temp_lifetime,\n+                    span: block.span,\n+                    kind: ExprKind::Block { body: block },\n+                });\n+                ExprKind::Loop { body }\n+            }\n+            hir::ExprKind::Field(ref source, ..) => ExprKind::Field {\n+                lhs: self.mirror_expr_boxed(source),\n+                name: Field::new(self.tcx.field_index(expr.hir_id, self.typeck_results)),\n+            },\n+            hir::ExprKind::Cast(ref source, ref cast_ty) => {\n+                // Check for a user-given type annotation on this `cast`\n+                let user_provided_types = self.typeck_results.user_provided_types();\n+                let user_ty = user_provided_types.get(cast_ty.hir_id);\n+\n+                debug!(\n+                    \"cast({:?}) has ty w/ hir_id {:?} and user provided ty {:?}\",\n+                    expr, cast_ty.hir_id, user_ty,\n+                );\n+\n+                // Check to see if this cast is a \"coercion cast\", where the cast is actually done\n+                // using a coercion (or is a no-op).\n+                let cast = if self.typeck_results().is_coercion_cast(source.hir_id) {\n+                    // Convert the lexpr to a vexpr.\n+                    ExprKind::Use { source: self.mirror_expr_boxed(source) }\n+                } else if self.typeck_results().expr_ty(source).is_region_ptr() {\n+                    // Special cased so that we can type check that the element\n+                    // type of the source matches the pointed to type of the\n+                    // destination.\n+                    ExprKind::Pointer {\n+                        source: self.mirror_expr_boxed(source),\n+                        cast: PointerCast::ArrayToPointer,\n+                    }\n                 } else {\n-                    None\n-                };\n+                    // check whether this is casting an enum variant discriminant\n+                    // to prevent cycles, we refer to the discriminant initializer\n+                    // which is always an integer and thus doesn't need to know the\n+                    // enum's layout (or its tag type) to compute it during const eval\n+                    // Example:\n+                    // enum Foo {\n+                    //     A,\n+                    //     B = A as isize + 4,\n+                    // }\n+                    // The correct solution would be to add symbolic computations to miri,\n+                    // so we wouldn't have to compute and store the actual value\n+                    let var = if let hir::ExprKind::Path(ref qpath) = source.kind {\n+                        let res = self.typeck_results().qpath_res(qpath, source.hir_id);\n+                        self.typeck_results().node_type(source.hir_id).ty_adt_def().and_then(\n+                            |adt_def| match res {\n+                                Res::Def(\n+                                    DefKind::Ctor(CtorOf::Variant, CtorKind::Const),\n+                                    variant_ctor_id,\n+                                ) => {\n+                                    let idx = adt_def.variant_index_with_ctor_id(variant_ctor_id);\n+                                    let (d, o) = adt_def.discriminant_def_for_variant(idx);\n+                                    use rustc_middle::ty::util::IntTypeExt;\n+                                    let ty = adt_def.repr.discr_type();\n+                                    let ty = ty.to_ty(self.tcx());\n+                                    Some((d, o, ty))\n+                                }\n+                                _ => None,\n+                            },\n+                        )\n+                    } else {\n+                        None\n+                    };\n \n-                let source = if let Some((did, offset, var_ty)) = var {\n-                    let mk_const = |literal| {\n-                        Expr {\n+                    let source = if let Some((did, offset, var_ty)) = var {\n+                        let mk_const = |literal| Expr {\n                             temp_lifetime,\n                             ty: var_ty,\n                             span: expr.span,\n                             kind: ExprKind::Literal { literal, user_ty: None, const_id: None },\n+                        };\n+                        let offset = mk_const(ty::Const::from_bits(\n+                            self.tcx,\n+                            offset as u128,\n+                            self.param_env.and(var_ty),\n+                        ));\n+                        match did {\n+                            Some(did) => {\n+                                // in case we are offsetting from a computed discriminant\n+                                // and not the beginning of discriminants (which is always `0`)\n+                                let substs = InternalSubsts::identity_for_item(self.tcx(), did);\n+                                let lhs = mk_const(self.tcx().mk_const(ty::Const {\n+                                    val: ty::ConstKind::Unevaluated(\n+                                        ty::WithOptConstParam::unknown(did),\n+                                        substs,\n+                                        None,\n+                                    ),\n+                                    ty: var_ty,\n+                                }));\n+                                let bin = ExprKind::Binary {\n+                                    op: BinOp::Add,\n+                                    lhs: Box::new(lhs),\n+                                    rhs: Box::new(offset),\n+                                };\n+                                Expr { temp_lifetime, ty: var_ty, span: expr.span, kind: bin }\n+                            }\n+                            None => offset,\n                         }\n-                        .to_ref()\n+                    } else {\n+                        self.mirror_expr(source)\n                     };\n-                    let offset = mk_const(ty::Const::from_bits(\n-                        cx.tcx,\n-                        offset as u128,\n-                        cx.param_env.and(var_ty),\n-                    ));\n-                    match did {\n-                        Some(did) => {\n-                            // in case we are offsetting from a computed discriminant\n-                            // and not the beginning of discriminants (which is always `0`)\n-                            let substs = InternalSubsts::identity_for_item(cx.tcx(), did);\n-                            let lhs = mk_const(cx.tcx().mk_const(ty::Const {\n-                                val: ty::ConstKind::Unevaluated(\n-                                    ty::WithOptConstParam::unknown(did),\n-                                    substs,\n-                                    None,\n-                                ),\n-                                ty: var_ty,\n-                            }));\n-                            let bin = ExprKind::Binary { op: BinOp::Add, lhs, rhs: offset };\n-                            Expr { temp_lifetime, ty: var_ty, span: expr.span, kind: bin }.to_ref()\n-                        }\n-                        None => offset,\n-                    }\n-                } else {\n-                    source.to_ref()\n-                };\n \n-                ExprKind::Cast { source }\n-            };\n+                    ExprKind::Cast { source: Box::new(source) }\n+                };\n \n-            if let Some(user_ty) = user_ty {\n-                // NOTE: Creating a new Expr and wrapping a Cast inside of it may be\n-                //       inefficient, revisit this when performance becomes an issue.\n-                let cast_expr = Expr { temp_lifetime, ty: expr_ty, span: expr.span, kind: cast };\n-                debug!(\"make_mirror_unadjusted: (cast) user_ty={:?}\", user_ty);\n+                if let Some(user_ty) = user_ty {\n+                    // NOTE: Creating a new Expr and wrapping a Cast inside of it may be\n+                    //       inefficient, revisit this when performance becomes an issue.\n+                    let cast_expr =\n+                        Box::new(Expr { temp_lifetime, ty: expr_ty, span: expr.span, kind: cast });\n+                    debug!(\"make_mirror_unadjusted: (cast) user_ty={:?}\", user_ty);\n \n-                ExprKind::ValueTypeAscription {\n-                    source: cast_expr.to_ref(),\n-                    user_ty: Some(*user_ty),\n+                    ExprKind::ValueTypeAscription { source: cast_expr, user_ty: Some(*user_ty) }\n+                } else {\n+                    cast\n                 }\n-            } else {\n-                cast\n             }\n-        }\n-        hir::ExprKind::Type(ref source, ref ty) => {\n-            let user_provided_types = cx.typeck_results.user_provided_types();\n-            let user_ty = user_provided_types.get(ty.hir_id).copied();\n-            debug!(\"make_mirror_unadjusted: (type) user_ty={:?}\", user_ty);\n-            if source.is_syntactic_place_expr() {\n-                ExprKind::PlaceTypeAscription { source: source.to_ref(), user_ty }\n-            } else {\n-                ExprKind::ValueTypeAscription { source: source.to_ref(), user_ty }\n+            hir::ExprKind::Type(ref source, ref ty) => {\n+                let user_provided_types = self.typeck_results.user_provided_types();\n+                let user_ty = user_provided_types.get(ty.hir_id).copied();\n+                debug!(\"make_mirror_unadjusted: (type) user_ty={:?}\", user_ty);\n+                let mirrored = self.mirror_expr_boxed(source);\n+                if source.is_syntactic_place_expr() {\n+                    ExprKind::PlaceTypeAscription { source: mirrored, user_ty }\n+                } else {\n+                    ExprKind::ValueTypeAscription { source: mirrored, user_ty }\n+                }\n+            }\n+            hir::ExprKind::DropTemps(ref source) => {\n+                ExprKind::Use { source: self.mirror_expr_boxed(source) }\n+            }\n+            hir::ExprKind::Box(ref value) => ExprKind::Box { value: self.mirror_expr_boxed(value) },\n+            hir::ExprKind::Array(ref fields) => ExprKind::Array {\n+                fields: fields.iter().map(|field| self.mirror_expr(field)).collect(),\n+            },\n+            hir::ExprKind::Tup(ref fields) => ExprKind::Tuple {\n+                fields: fields.iter().map(|field| self.mirror_expr(field)).collect(),\n+            },\n+\n+            hir::ExprKind::Yield(ref v, _) => ExprKind::Yield { value: self.mirror_expr_boxed(v) },\n+            hir::ExprKind::Err => unreachable!(),\n+        };\n+\n+        Expr { temp_lifetime, ty: expr_ty, span: expr.span, kind }\n+    }\n+\n+    fn user_substs_applied_to_res(\n+        &mut self,\n+        hir_id: hir::HirId,\n+        res: Res,\n+    ) -> Option<ty::CanonicalUserType<'tcx>> {\n+        debug!(\"user_substs_applied_to_res: res={:?}\", res);\n+        let user_provided_type = match res {\n+            // A reference to something callable -- e.g., a fn, method, or\n+            // a tuple-struct or tuple-variant. This has the type of a\n+            // `Fn` but with the user-given substitutions.\n+            Res::Def(DefKind::Fn, _)\n+            | Res::Def(DefKind::AssocFn, _)\n+            | Res::Def(DefKind::Ctor(_, CtorKind::Fn), _)\n+            | Res::Def(DefKind::Const, _)\n+            | Res::Def(DefKind::AssocConst, _) => {\n+                self.typeck_results().user_provided_types().get(hir_id).copied()\n+            }\n+\n+            // A unit struct/variant which is used as a value (e.g.,\n+            // `None`). This has the type of the enum/struct that defines\n+            // this variant -- but with the substitutions given by the\n+            // user.\n+            Res::Def(DefKind::Ctor(_, CtorKind::Const), _) => {\n+                self.user_substs_applied_to_ty_of_hir_id(hir_id)\n+            }\n+\n+            // `Self` is used in expression as a tuple struct constructor or an unit struct constructor\n+            Res::SelfCtor(_) => self.user_substs_applied_to_ty_of_hir_id(hir_id),\n+\n+            _ => bug!(\"user_substs_applied_to_res: unexpected res {:?} at {:?}\", res, hir_id),\n+        };\n+        debug!(\"user_substs_applied_to_res: user_provided_type={:?}\", user_provided_type);\n+        user_provided_type\n+    }\n+\n+    fn method_callee(\n+        &mut self,\n+        expr: &hir::Expr<'_>,\n+        span: Span,\n+        overloaded_callee: Option<(DefId, SubstsRef<'tcx>)>,\n+    ) -> Expr<'tcx> {\n+        let temp_lifetime = self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n+        let (def_id, substs, user_ty) = match overloaded_callee {\n+            Some((def_id, substs)) => (def_id, substs, None),\n+            None => {\n+                let (kind, def_id) =\n+                    self.typeck_results().type_dependent_def(expr.hir_id).unwrap_or_else(|| {\n+                        span_bug!(expr.span, \"no type-dependent def for method callee\")\n+                    });\n+                let user_ty = self.user_substs_applied_to_res(expr.hir_id, Res::Def(kind, def_id));\n+                debug!(\"method_callee: user_ty={:?}\", user_ty);\n+                (def_id, self.typeck_results().node_substs(expr.hir_id), user_ty)\n             }\n+        };\n+        let ty = self.tcx().mk_fn_def(def_id, substs);\n+        Expr {\n+            temp_lifetime,\n+            ty,\n+            span,\n+            kind: ExprKind::Literal {\n+                literal: ty::Const::zero_sized(self.tcx(), ty),\n+                user_ty,\n+                const_id: None,\n+            },\n+        }\n+    }\n+\n+    fn convert_arm(&mut self, arm: &'tcx hir::Arm<'tcx>) -> Arm<'tcx> {\n+        Arm {\n+            pattern: self.pattern_from_hir(&arm.pat),\n+            guard: arm.guard.as_ref().map(|g| match g {\n+                hir::Guard::If(ref e) => Guard::If(self.mirror_expr_boxed(e)),\n+                hir::Guard::IfLet(ref pat, ref e) => {\n+                    Guard::IfLet(self.pattern_from_hir(pat), self.mirror_expr_boxed(e))\n+                }\n+            }),\n+            body: self.mirror_expr(arm.body),\n+            lint_level: LintLevel::Explicit(arm.hir_id),\n+            scope: region::Scope { id: arm.hir_id.local_id, data: region::ScopeData::Node },\n+            span: arm.span,\n         }\n-        hir::ExprKind::DropTemps(ref source) => ExprKind::Use { source: source.to_ref() },\n-        hir::ExprKind::Box(ref value) => ExprKind::Box { value: value.to_ref() },\n-        hir::ExprKind::Array(ref fields) => ExprKind::Array { fields: fields.to_ref() },\n-        hir::ExprKind::Tup(ref fields) => ExprKind::Tuple { fields: fields.to_ref() },\n+    }\n \n-        hir::ExprKind::Yield(ref v, _) => ExprKind::Yield { value: v.to_ref() },\n-        hir::ExprKind::Err => unreachable!(),\n-    };\n+    fn convert_path_expr(&mut self, expr: &'tcx hir::Expr<'tcx>, res: Res) -> ExprKind<'tcx> {\n+        let substs = self.typeck_results().node_substs(expr.hir_id);\n+        match res {\n+            // A regular function, constructor function or a constant.\n+            Res::Def(DefKind::Fn, _)\n+            | Res::Def(DefKind::AssocFn, _)\n+            | Res::Def(DefKind::Ctor(_, CtorKind::Fn), _)\n+            | Res::SelfCtor(..) => {\n+                let user_ty = self.user_substs_applied_to_res(expr.hir_id, res);\n+                debug!(\"convert_path_expr: user_ty={:?}\", user_ty);\n+                ExprKind::Literal {\n+                    literal: ty::Const::zero_sized(\n+                        self.tcx,\n+                        self.typeck_results().node_type(expr.hir_id),\n+                    ),\n+                    user_ty,\n+                    const_id: None,\n+                }\n+            }\n \n-    Expr { temp_lifetime, ty: expr_ty, span: expr.span, kind }\n-}\n+            Res::Def(DefKind::ConstParam, def_id) => {\n+                let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n+                let item_id = self.tcx.hir().get_parent_node(hir_id);\n+                let item_def_id = self.tcx.hir().local_def_id(item_id);\n+                let generics = self.tcx.generics_of(item_def_id);\n+                let index = generics.param_def_id_to_index[&def_id];\n+                let name = self.tcx.hir().name(hir_id);\n+                let val = ty::ConstKind::Param(ty::ParamConst::new(index, name));\n+                ExprKind::Literal {\n+                    literal: self.tcx.mk_const(ty::Const {\n+                        val,\n+                        ty: self.typeck_results().node_type(expr.hir_id),\n+                    }),\n+                    user_ty: None,\n+                    const_id: Some(def_id),\n+                }\n+            }\n+\n+            Res::Def(DefKind::Const, def_id) | Res::Def(DefKind::AssocConst, def_id) => {\n+                let user_ty = self.user_substs_applied_to_res(expr.hir_id, res);\n+                debug!(\"convert_path_expr: (const) user_ty={:?}\", user_ty);\n+                ExprKind::Literal {\n+                    literal: self.tcx.mk_const(ty::Const {\n+                        val: ty::ConstKind::Unevaluated(\n+                            ty::WithOptConstParam::unknown(def_id),\n+                            substs,\n+                            None,\n+                        ),\n+                        ty: self.typeck_results().node_type(expr.hir_id),\n+                    }),\n+                    user_ty,\n+                    const_id: Some(def_id),\n+                }\n+            }\n+\n+            Res::Def(DefKind::Ctor(_, CtorKind::Const), def_id) => {\n+                let user_provided_types = self.typeck_results.user_provided_types();\n+                let user_provided_type = user_provided_types.get(expr.hir_id).copied();\n+                debug!(\"convert_path_expr: user_provided_type={:?}\", user_provided_type);\n+                let ty = self.typeck_results().node_type(expr.hir_id);\n+                match ty.kind() {\n+                    // A unit struct/variant which is used as a value.\n+                    // We return a completely different ExprKind here to account for this special case.\n+                    ty::Adt(adt_def, substs) => ExprKind::Adt {\n+                        adt_def,\n+                        variant_index: adt_def.variant_index_with_ctor_id(def_id),\n+                        substs,\n+                        user_ty: user_provided_type,\n+                        fields: vec![],\n+                        base: None,\n+                    },\n+                    _ => bug!(\"unexpected ty: {:?}\", ty),\n+                }\n+            }\n+\n+            // We encode uses of statics as a `*&STATIC` where the `&STATIC` part is\n+            // a constant reference (or constant raw pointer for `static mut`) in MIR\n+            Res::Def(DefKind::Static, id) => {\n+                let ty = self.tcx.static_ptr_ty(id);\n+                let temp_lifetime = self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n+                let kind = if self.tcx.is_thread_local_static(id) {\n+                    ExprKind::ThreadLocalRef(id)\n+                } else {\n+                    let ptr = self.tcx.create_static_alloc(id);\n+                    ExprKind::StaticRef {\n+                        literal: ty::Const::from_scalar(self.tcx, Scalar::Ptr(ptr.into()), ty),\n+                        def_id: id,\n+                    }\n+                };\n+                ExprKind::Deref { arg: Box::new(Expr { ty, temp_lifetime, span: expr.span, kind }) }\n+            }\n+\n+            Res::Local(var_hir_id) => self.convert_var(var_hir_id),\n \n-fn user_substs_applied_to_res<'tcx>(\n-    cx: &mut Cx<'_, 'tcx>,\n-    hir_id: hir::HirId,\n-    res: Res,\n-) -> Option<ty::CanonicalUserType<'tcx>> {\n-    debug!(\"user_substs_applied_to_res: res={:?}\", res);\n-    let user_provided_type = match res {\n-        // A reference to something callable -- e.g., a fn, method, or\n-        // a tuple-struct or tuple-variant. This has the type of a\n-        // `Fn` but with the user-given substitutions.\n-        Res::Def(DefKind::Fn, _)\n-        | Res::Def(DefKind::AssocFn, _)\n-        | Res::Def(DefKind::Ctor(_, CtorKind::Fn), _)\n-        | Res::Def(DefKind::Const, _)\n-        | Res::Def(DefKind::AssocConst, _) => {\n-            cx.typeck_results().user_provided_types().get(hir_id).copied()\n+            _ => span_bug!(expr.span, \"res `{:?}` not yet implemented\", res),\n         }\n+    }\n \n-        // A unit struct/variant which is used as a value (e.g.,\n-        // `None`). This has the type of the enum/struct that defines\n-        // this variant -- but with the substitutions given by the\n-        // user.\n-        Res::Def(DefKind::Ctor(_, CtorKind::Const), _) => {\n-            cx.user_substs_applied_to_ty_of_hir_id(hir_id)\n+    fn convert_var(&mut self, var_hir_id: hir::HirId) -> ExprKind<'tcx> {\n+        // We want upvars here not captures.\n+        // Captures will be handled in MIR.\n+        let is_upvar = self\n+            .tcx\n+            .upvars_mentioned(self.body_owner)\n+            .map_or(false, |upvars| upvars.contains_key(&var_hir_id));\n+\n+        debug!(\n+            \"convert_var({:?}): is_upvar={}, body_owner={:?}\",\n+            var_hir_id, is_upvar, self.body_owner\n+        );\n+\n+        if is_upvar {\n+            ExprKind::UpvarRef { closure_def_id: self.body_owner, var_hir_id }\n+        } else {\n+            ExprKind::VarRef { id: var_hir_id }\n         }\n+    }\n \n-        // `Self` is used in expression as a tuple struct constructor or an unit struct constructor\n-        Res::SelfCtor(_) => cx.user_substs_applied_to_ty_of_hir_id(hir_id),\n+    fn overloaded_operator(\n+        &mut self,\n+        expr: &'tcx hir::Expr<'tcx>,\n+        args: Vec<Expr<'tcx>>,\n+    ) -> ExprKind<'tcx> {\n+        let fun = Box::new(self.method_callee(expr, expr.span, None));\n+        ExprKind::Call { ty: fun.ty, fun, args, from_hir_call: false, fn_span: expr.span }\n+    }\n \n-        _ => bug!(\"user_substs_applied_to_res: unexpected res {:?} at {:?}\", res, hir_id),\n-    };\n-    debug!(\"user_substs_applied_to_res: user_provided_type={:?}\", user_provided_type);\n-    user_provided_type\n-}\n+    fn overloaded_place(\n+        &mut self,\n+        expr: &'tcx hir::Expr<'tcx>,\n+        place_ty: Ty<'tcx>,\n+        overloaded_callee: Option<(DefId, SubstsRef<'tcx>)>,\n+        args: Vec<Expr<'tcx>>,\n+        span: Span,\n+    ) -> ExprKind<'tcx> {\n+        // For an overloaded *x or x[y] expression of type T, the method\n+        // call returns an &T and we must add the deref so that the types\n+        // line up (this is because `*x` and `x[y]` represent places):\n+\n+        // Reconstruct the output assuming it's a reference with the\n+        // same region and mutability as the receiver. This holds for\n+        // `Deref(Mut)::Deref(_mut)` and `Index(Mut)::index(_mut)`.\n+        let (region, mutbl) = match *args[0].ty.kind() {\n+            ty::Ref(region, _, mutbl) => (region, mutbl),\n+            _ => span_bug!(span, \"overloaded_place: receiver is not a reference\"),\n+        };\n+        let ref_ty = self.tcx.mk_ref(region, ty::TypeAndMut { ty: place_ty, mutbl });\n+\n+        // construct the complete expression `foo()` for the overloaded call,\n+        // which will yield the &T type\n+        let temp_lifetime = self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n+        let fun = Box::new(self.method_callee(expr, span, overloaded_callee));\n+        let ref_expr = Box::new(Expr {\n+            temp_lifetime,\n+            ty: ref_ty,\n+            span,\n+            kind: ExprKind::Call { ty: fun.ty, fun, args, from_hir_call: false, fn_span: span },\n+        });\n+\n+        // construct and return a deref wrapper `*foo()`\n+        ExprKind::Deref { arg: ref_expr }\n+    }\n+\n+    fn capture_upvar(\n+        &mut self,\n+        closure_expr: &'tcx hir::Expr<'tcx>,\n+        captured_place: &'a ty::CapturedPlace<'tcx>,\n+        upvar_ty: Ty<'tcx>,\n+    ) -> Expr<'tcx> {\n+        let upvar_capture = captured_place.info.capture_kind;\n+        let temp_lifetime = self.region_scope_tree.temporary_scope(closure_expr.hir_id.local_id);\n+        let var_ty = captured_place.place.base_ty;\n+\n+        // The result of capture analysis in `rustc_typeck/check/upvar.rs`represents a captured path\n+        // as it's seen for use within the closure and not at the time of closure creation.\n+        //\n+        // That is we see expect to see it start from a captured upvar and not something that is local\n+        // to the closure's parent.\n+        let var_hir_id = match captured_place.place.base {\n+            HirPlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n+            base => bug!(\"Expected an upvar, found {:?}\", base),\n+        };\n+\n+        let mut captured_place_expr = Expr {\n+            temp_lifetime,\n+            ty: var_ty,\n+            span: closure_expr.span,\n+            kind: self.convert_var(var_hir_id),\n+        };\n+\n+        for proj in captured_place.place.projections.iter() {\n+            let kind = match proj.kind {\n+                HirProjectionKind::Deref => ExprKind::Deref { arg: Box::new(captured_place_expr) },\n+                HirProjectionKind::Field(field, ..) => {\n+                    // Variant index will always be 0, because for multi-variant\n+                    // enums, we capture the enum entirely.\n+                    ExprKind::Field {\n+                        lhs: Box::new(captured_place_expr),\n+                        name: Field::new(field as usize),\n+                    }\n+                }\n+                HirProjectionKind::Index | HirProjectionKind::Subslice => {\n+                    // We don't capture these projections, so we can ignore them here\n+                    continue;\n+                }\n+            };\n \n-fn method_callee<'a, 'tcx>(\n-    cx: &mut Cx<'a, 'tcx>,\n-    expr: &hir::Expr<'_>,\n-    span: Span,\n-    overloaded_callee: Option<(DefId, SubstsRef<'tcx>)>,\n-) -> Expr<'tcx> {\n-    let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n-    let (def_id, substs, user_ty) = match overloaded_callee {\n-        Some((def_id, substs)) => (def_id, substs, None),\n-        None => {\n-            let (kind, def_id) = cx\n-                .typeck_results()\n-                .type_dependent_def(expr.hir_id)\n-                .unwrap_or_else(|| span_bug!(expr.span, \"no type-dependent def for method callee\"));\n-            let user_ty = user_substs_applied_to_res(cx, expr.hir_id, Res::Def(kind, def_id));\n-            debug!(\"method_callee: user_ty={:?}\", user_ty);\n-            (def_id, cx.typeck_results().node_substs(expr.hir_id), user_ty)\n+            captured_place_expr =\n+                Expr { temp_lifetime, ty: proj.ty, span: closure_expr.span, kind };\n+        }\n+\n+        match upvar_capture {\n+            ty::UpvarCapture::ByValue(_) => captured_place_expr,\n+            ty::UpvarCapture::ByRef(upvar_borrow) => {\n+                let borrow_kind = match upvar_borrow.kind {\n+                    ty::BorrowKind::ImmBorrow => BorrowKind::Shared,\n+                    ty::BorrowKind::UniqueImmBorrow => BorrowKind::Unique,\n+                    ty::BorrowKind::MutBorrow => BorrowKind::Mut { allow_two_phase_borrow: false },\n+                };\n+                Expr {\n+                    temp_lifetime,\n+                    ty: upvar_ty,\n+                    span: closure_expr.span,\n+                    kind: ExprKind::Borrow { borrow_kind, arg: Box::new(captured_place_expr) },\n+                }\n+            }\n         }\n-    };\n-    let ty = cx.tcx().mk_fn_def(def_id, substs);\n-    Expr {\n-        temp_lifetime,\n-        ty,\n-        span,\n-        kind: ExprKind::Literal {\n-            literal: ty::Const::zero_sized(cx.tcx(), ty),\n-            user_ty,\n-            const_id: None,\n-        },\n+    }\n+\n+    /// Converts a list of named fields (i.e., for struct-like struct/enum ADTs) into FieldExpr.\n+    fn field_refs(&mut self, fields: &'tcx [hir::Field<'tcx>]) -> Vec<FieldExpr<'tcx>> {\n+        fields\n+            .iter()\n+            .map(|field| FieldExpr {\n+                name: Field::new(self.tcx.field_index(field.hir_id, self.typeck_results)),\n+                expr: self.mirror_expr(field.expr),\n+            })\n+            .collect()\n     }\n }\n \n@@ -776,135 +1084,6 @@ impl ToBorrowKind for hir::Mutability {\n     }\n }\n \n-fn convert_arm<'tcx>(cx: &mut Cx<'_, 'tcx>, arm: &'tcx hir::Arm<'tcx>) -> Arm<'tcx> {\n-    Arm {\n-        pattern: cx.pattern_from_hir(&arm.pat),\n-        guard: arm.guard.as_ref().map(|g| match g {\n-            hir::Guard::If(ref e) => Guard::If(e.to_ref()),\n-            hir::Guard::IfLet(ref pat, ref e) => Guard::IfLet(cx.pattern_from_hir(pat), e.to_ref()),\n-        }),\n-        body: arm.body.to_ref(),\n-        lint_level: LintLevel::Explicit(arm.hir_id),\n-        scope: region::Scope { id: arm.hir_id.local_id, data: region::ScopeData::Node },\n-        span: arm.span,\n-    }\n-}\n-\n-fn convert_path_expr<'a, 'tcx>(\n-    cx: &mut Cx<'a, 'tcx>,\n-    expr: &'tcx hir::Expr<'tcx>,\n-    res: Res,\n-) -> ExprKind<'tcx> {\n-    let substs = cx.typeck_results().node_substs(expr.hir_id);\n-    match res {\n-        // A regular function, constructor function or a constant.\n-        Res::Def(DefKind::Fn, _)\n-        | Res::Def(DefKind::AssocFn, _)\n-        | Res::Def(DefKind::Ctor(_, CtorKind::Fn), _)\n-        | Res::SelfCtor(..) => {\n-            let user_ty = user_substs_applied_to_res(cx, expr.hir_id, res);\n-            debug!(\"convert_path_expr: user_ty={:?}\", user_ty);\n-            ExprKind::Literal {\n-                literal: ty::Const::zero_sized(cx.tcx, cx.typeck_results().node_type(expr.hir_id)),\n-                user_ty,\n-                const_id: None,\n-            }\n-        }\n-\n-        Res::Def(DefKind::ConstParam, def_id) => {\n-            let hir_id = cx.tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-            let item_id = cx.tcx.hir().get_parent_node(hir_id);\n-            let item_def_id = cx.tcx.hir().local_def_id(item_id);\n-            let generics = cx.tcx.generics_of(item_def_id);\n-            let index = generics.param_def_id_to_index[&def_id];\n-            let name = cx.tcx.hir().name(hir_id);\n-            let val = ty::ConstKind::Param(ty::ParamConst::new(index, name));\n-            ExprKind::Literal {\n-                literal: cx\n-                    .tcx\n-                    .mk_const(ty::Const { val, ty: cx.typeck_results().node_type(expr.hir_id) }),\n-                user_ty: None,\n-                const_id: Some(def_id),\n-            }\n-        }\n-\n-        Res::Def(DefKind::Const, def_id) | Res::Def(DefKind::AssocConst, def_id) => {\n-            let user_ty = user_substs_applied_to_res(cx, expr.hir_id, res);\n-            debug!(\"convert_path_expr: (const) user_ty={:?}\", user_ty);\n-            ExprKind::Literal {\n-                literal: cx.tcx.mk_const(ty::Const {\n-                    val: ty::ConstKind::Unevaluated(\n-                        ty::WithOptConstParam::unknown(def_id),\n-                        substs,\n-                        None,\n-                    ),\n-                    ty: cx.typeck_results().node_type(expr.hir_id),\n-                }),\n-                user_ty,\n-                const_id: Some(def_id),\n-            }\n-        }\n-\n-        Res::Def(DefKind::Ctor(_, CtorKind::Const), def_id) => {\n-            let user_provided_types = cx.typeck_results.user_provided_types();\n-            let user_provided_type = user_provided_types.get(expr.hir_id).copied();\n-            debug!(\"convert_path_expr: user_provided_type={:?}\", user_provided_type);\n-            let ty = cx.typeck_results().node_type(expr.hir_id);\n-            match ty.kind() {\n-                // A unit struct/variant which is used as a value.\n-                // We return a completely different ExprKind here to account for this special case.\n-                ty::Adt(adt_def, substs) => ExprKind::Adt {\n-                    adt_def,\n-                    variant_index: adt_def.variant_index_with_ctor_id(def_id),\n-                    substs,\n-                    user_ty: user_provided_type,\n-                    fields: vec![],\n-                    base: None,\n-                },\n-                _ => bug!(\"unexpected ty: {:?}\", ty),\n-            }\n-        }\n-\n-        // We encode uses of statics as a `*&STATIC` where the `&STATIC` part is\n-        // a constant reference (or constant raw pointer for `static mut`) in MIR\n-        Res::Def(DefKind::Static, id) => {\n-            let ty = cx.tcx.static_ptr_ty(id);\n-            let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n-            let kind = if cx.tcx.is_thread_local_static(id) {\n-                ExprKind::ThreadLocalRef(id)\n-            } else {\n-                let ptr = cx.tcx.create_static_alloc(id);\n-                ExprKind::StaticRef {\n-                    literal: ty::Const::from_scalar(cx.tcx, Scalar::Ptr(ptr.into()), ty),\n-                    def_id: id,\n-                }\n-            };\n-            ExprKind::Deref { arg: Expr { ty, temp_lifetime, span: expr.span, kind }.to_ref() }\n-        }\n-\n-        Res::Local(var_hir_id) => convert_var(cx, var_hir_id),\n-\n-        _ => span_bug!(expr.span, \"res `{:?}` not yet implemented\", res),\n-    }\n-}\n-\n-fn convert_var<'tcx>(cx: &mut Cx<'_, 'tcx>, var_hir_id: hir::HirId) -> ExprKind<'tcx> {\n-    // We want upvars here not captures.\n-    // Captures will be handled in MIR.\n-    let is_upvar = cx\n-        .tcx\n-        .upvars_mentioned(cx.body_owner)\n-        .map_or(false, |upvars| upvars.contains_key(&var_hir_id));\n-\n-    debug!(\"convert_var({:?}): is_upvar={}, body_owner={:?}\", var_hir_id, is_upvar, cx.body_owner);\n-\n-    if is_upvar {\n-        ExprKind::UpvarRef { closure_def_id: cx.body_owner, var_hir_id }\n-    } else {\n-        ExprKind::VarRef { id: var_hir_id }\n-    }\n-}\n-\n fn bin_op(op: hir::BinOpKind) -> BinOp {\n     match op {\n         hir::BinOpKind::Add => BinOp::Add,\n@@ -926,139 +1105,3 @@ fn bin_op(op: hir::BinOpKind) -> BinOp {\n         _ => bug!(\"no equivalent for ast binop {:?}\", op),\n     }\n }\n-\n-fn overloaded_operator<'a, 'tcx>(\n-    cx: &mut Cx<'a, 'tcx>,\n-    expr: &'tcx hir::Expr<'tcx>,\n-    args: Vec<ExprRef<'tcx>>,\n-) -> ExprKind<'tcx> {\n-    let fun = method_callee(cx, expr, expr.span, None);\n-    ExprKind::Call { ty: fun.ty, fun: fun.to_ref(), args, from_hir_call: false, fn_span: expr.span }\n-}\n-\n-fn overloaded_place<'a, 'tcx>(\n-    cx: &mut Cx<'a, 'tcx>,\n-    expr: &'tcx hir::Expr<'tcx>,\n-    place_ty: Ty<'tcx>,\n-    overloaded_callee: Option<(DefId, SubstsRef<'tcx>)>,\n-    args: Vec<ExprRef<'tcx>>,\n-    span: Span,\n-) -> ExprKind<'tcx> {\n-    // For an overloaded *x or x[y] expression of type T, the method\n-    // call returns an &T and we must add the deref so that the types\n-    // line up (this is because `*x` and `x[y]` represent places):\n-\n-    let recv_ty = match args[0] {\n-        ExprRef::Thir(e) => cx.typeck_results().expr_ty_adjusted(e),\n-        ExprRef::Mirror(ref e) => e.ty,\n-    };\n-\n-    // Reconstruct the output assuming it's a reference with the\n-    // same region and mutability as the receiver. This holds for\n-    // `Deref(Mut)::Deref(_mut)` and `Index(Mut)::index(_mut)`.\n-    let (region, mutbl) = match *recv_ty.kind() {\n-        ty::Ref(region, _, mutbl) => (region, mutbl),\n-        _ => span_bug!(span, \"overloaded_place: receiver is not a reference\"),\n-    };\n-    let ref_ty = cx.tcx.mk_ref(region, ty::TypeAndMut { ty: place_ty, mutbl });\n-\n-    // construct the complete expression `foo()` for the overloaded call,\n-    // which will yield the &T type\n-    let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n-    let fun = method_callee(cx, expr, span, overloaded_callee);\n-    let ref_expr = Expr {\n-        temp_lifetime,\n-        ty: ref_ty,\n-        span,\n-        kind: ExprKind::Call {\n-            ty: fun.ty,\n-            fun: fun.to_ref(),\n-            args,\n-            from_hir_call: false,\n-            fn_span: span,\n-        },\n-    };\n-\n-    // construct and return a deref wrapper `*foo()`\n-    ExprKind::Deref { arg: ref_expr.to_ref() }\n-}\n-\n-fn capture_upvar<'a, 'tcx>(\n-    cx: &mut Cx<'_, 'tcx>,\n-    closure_expr: &'tcx hir::Expr<'tcx>,\n-    captured_place: &'a ty::CapturedPlace<'tcx>,\n-    upvar_ty: Ty<'tcx>,\n-) -> ExprRef<'tcx> {\n-    let upvar_capture = captured_place.info.capture_kind;\n-    let temp_lifetime = cx.region_scope_tree.temporary_scope(closure_expr.hir_id.local_id);\n-    let var_ty = captured_place.place.base_ty;\n-\n-    // The result of capture analysis in `rustc_typeck/check/upvar.rs`represents a captured path\n-    // as it's seen for use within the closure and not at the time of closure creation.\n-    //\n-    // That is we see expect to see it start from a captured upvar and not something that is local\n-    // to the closure's parent.\n-    let var_hir_id = match captured_place.place.base {\n-        HirPlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n-        base => bug!(\"Expected an upvar, found {:?}\", base),\n-    };\n-\n-    let mut captured_place_expr = Expr {\n-        temp_lifetime,\n-        ty: var_ty,\n-        span: closure_expr.span,\n-        kind: convert_var(cx, var_hir_id),\n-    };\n-\n-    for proj in captured_place.place.projections.iter() {\n-        let kind = match proj.kind {\n-            HirProjectionKind::Deref => ExprKind::Deref { arg: captured_place_expr.to_ref() },\n-            HirProjectionKind::Field(field, ..) => {\n-                // Variant index will always be 0, because for multi-variant\n-                // enums, we capture the enum entirely.\n-                ExprKind::Field {\n-                    lhs: captured_place_expr.to_ref(),\n-                    name: Field::new(field as usize),\n-                }\n-            }\n-            HirProjectionKind::Index | HirProjectionKind::Subslice => {\n-                // We don't capture these projections, so we can ignore them here\n-                continue;\n-            }\n-        };\n-\n-        captured_place_expr = Expr { temp_lifetime, ty: proj.ty, span: closure_expr.span, kind };\n-    }\n-\n-    match upvar_capture {\n-        ty::UpvarCapture::ByValue(_) => captured_place_expr.to_ref(),\n-        ty::UpvarCapture::ByRef(upvar_borrow) => {\n-            let borrow_kind = match upvar_borrow.kind {\n-                ty::BorrowKind::ImmBorrow => BorrowKind::Shared,\n-                ty::BorrowKind::UniqueImmBorrow => BorrowKind::Unique,\n-                ty::BorrowKind::MutBorrow => BorrowKind::Mut { allow_two_phase_borrow: false },\n-            };\n-            Expr {\n-                temp_lifetime,\n-                ty: upvar_ty,\n-                span: closure_expr.span,\n-                kind: ExprKind::Borrow { borrow_kind, arg: captured_place_expr.to_ref() },\n-            }\n-            .to_ref()\n-        }\n-    }\n-}\n-\n-/// Converts a list of named fields (i.e., for struct-like struct/enum ADTs) into FieldExprRef.\n-fn field_refs<'a, 'tcx>(\n-    cx: &mut Cx<'a, 'tcx>,\n-    fields: &'tcx [hir::Field<'tcx>],\n-) -> Vec<FieldExprRef<'tcx>> {\n-    fields\n-        .iter()\n-        .map(|field| FieldExprRef {\n-            name: Field::new(cx.tcx.field_index(field.hir_id, cx.typeck_results)),\n-            expr: field.expr.to_ref(),\n-        })\n-        .collect()\n-}"}, {"sha": "6b3b3be514c039d1558ae306f8b87af96c0c8c99", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=60def4de5e1eb4d8cc4b9733c8bf199b73d8635a", "patch": "@@ -93,11 +93,6 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Cx<'a, 'tcx> {\n-    /// Normalizes `ast` into the appropriate \"mirror\" type.\n-    crate fn mirror<M: Mirror<'tcx>>(&mut self, ast: M) -> M::Output {\n-        ast.make_mirror(self)\n-    }\n-\n     crate fn usize_ty(&mut self) -> Ty<'tcx> {\n         self.tcx.types.usize\n     }\n@@ -219,4 +214,3 @@ impl<'tcx> UserAnnotatedTyHelpers<'tcx> for Cx<'_, 'tcx> {\n \n mod block;\n mod expr;\n-mod to_ref;"}, {"sha": "53a988ebb79e2aec4fc453028b0513a7352845e2", "filename": "compiler/rustc_mir_build/src/thir/cx/to_ref.rs", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/3a5d45f68cadc8fff4fbb557780f92b403b19c19/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fto_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5d45f68cadc8fff4fbb557780f92b403b19c19/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fto_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fto_ref.rs?ref=3a5d45f68cadc8fff4fbb557780f92b403b19c19", "patch": "@@ -1,65 +0,0 @@\n-use crate::thir::*;\n-\n-use rustc_hir as hir;\n-\n-crate trait ToRef {\n-    type Output;\n-    fn to_ref(self) -> Self::Output;\n-}\n-\n-impl<'tcx> ToRef for &'tcx hir::Expr<'tcx> {\n-    type Output = ExprRef<'tcx>;\n-\n-    fn to_ref(self) -> ExprRef<'tcx> {\n-        ExprRef::Thir(self)\n-    }\n-}\n-\n-impl<'tcx> ToRef for &'tcx &'tcx hir::Expr<'tcx> {\n-    type Output = ExprRef<'tcx>;\n-\n-    fn to_ref(self) -> ExprRef<'tcx> {\n-        ExprRef::Thir(&**self)\n-    }\n-}\n-\n-impl<'tcx> ToRef for Expr<'tcx> {\n-    type Output = ExprRef<'tcx>;\n-\n-    fn to_ref(self) -> ExprRef<'tcx> {\n-        ExprRef::Mirror(Box::new(self))\n-    }\n-}\n-\n-impl<'tcx, T, U> ToRef for &'tcx Option<T>\n-where\n-    &'tcx T: ToRef<Output = U>,\n-{\n-    type Output = Option<U>;\n-\n-    fn to_ref(self) -> Option<U> {\n-        self.as_ref().map(|expr| expr.to_ref())\n-    }\n-}\n-\n-impl<'tcx, T, U> ToRef for &'tcx Vec<T>\n-where\n-    &'tcx T: ToRef<Output = U>,\n-{\n-    type Output = Vec<U>;\n-\n-    fn to_ref(self) -> Vec<U> {\n-        self.iter().map(|expr| expr.to_ref()).collect()\n-    }\n-}\n-\n-impl<'tcx, T, U> ToRef for &'tcx [T]\n-where\n-    &'tcx T: ToRef<Output = U>,\n-{\n-    type Output = Vec<U>;\n-\n-    fn to_ref(self) -> Vec<U> {\n-        self.iter().map(|expr| expr.to_ref()).collect()\n-    }\n-}"}, {"sha": "f934dd32c53812611e7ff2ed242e81a33984e544", "filename": "compiler/rustc_mir_build/src/thir/mod.rs", "status": "modified", "additions": 62, "deletions": 149, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60def4de5e1eb4d8cc4b9733c8bf199b73d8635a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs?ref=60def4de5e1eb4d8cc4b9733c8bf199b73d8635a", "patch": "@@ -4,7 +4,6 @@\n //! unit-tested and separated from the Rust source and compiler data\n //! structures.\n \n-use self::cx::Cx;\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -39,8 +38,8 @@ crate struct Block<'tcx> {\n     crate region_scope: region::Scope,\n     crate opt_destruction_scope: Option<region::Scope>,\n     crate span: Span,\n-    crate stmts: Vec<StmtRef<'tcx>>,\n-    crate expr: Option<ExprRef<'tcx>>,\n+    crate stmts: Vec<Stmt<'tcx>>,\n+    crate expr: Option<Box<Expr<'tcx>>>,\n     crate safety_mode: BlockSafety,\n }\n \n@@ -52,11 +51,6 @@ crate enum BlockSafety {\n     PopUnsafe,\n }\n \n-#[derive(Clone, Debug)]\n-crate enum StmtRef<'tcx> {\n-    Mirror(Box<Stmt<'tcx>>),\n-}\n-\n #[derive(Clone, Debug)]\n crate struct Stmt<'tcx> {\n     crate kind: StmtKind<'tcx>,\n@@ -70,7 +64,7 @@ crate enum StmtKind<'tcx> {\n         scope: region::Scope,\n \n         /// expression being evaluated in this statement\n-        expr: ExprRef<'tcx>,\n+        expr: Box<Expr<'tcx>>,\n     },\n \n     Let {\n@@ -88,7 +82,7 @@ crate enum StmtKind<'tcx> {\n         pattern: Pat<'tcx>,\n \n         /// let pat: ty = <INIT> ...\n-        initializer: Option<ExprRef<'tcx>>,\n+        initializer: Option<Box<Expr<'tcx>>>,\n \n         /// the lint level for this let-statement\n         lint_level: LintLevel,\n@@ -97,12 +91,12 @@ crate enum StmtKind<'tcx> {\n \n // `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Expr<'_>, 168);\n+rustc_data_structures::static_assert_size!(Expr<'_>, 160);\n \n /// The Thir trait implementor lowers their expressions (`&'tcx H::Expr`)\n /// into instances of this `Expr` enum. This lowering can be done\n /// basically as lazily or as eagerly as desired: every recursive\n-/// reference to an expression in this enum is an `ExprRef<'tcx>`, which\n+/// reference to an expression in this enum is an `Box<Expr<'tcx>>`, which\n /// may in turn be another instance of this enum (boxed), or else an\n /// unlowered `&'tcx H::Expr`. Note that instances of `Expr` are very\n /// short-lived. They are created by `Thir::to_expr`, analyzed and\n@@ -134,84 +128,84 @@ crate enum ExprKind<'tcx> {\n     Scope {\n         region_scope: region::Scope,\n         lint_level: LintLevel,\n-        value: ExprRef<'tcx>,\n+        value: Box<Expr<'tcx>>,\n     },\n     Box {\n-        value: ExprRef<'tcx>,\n+        value: Box<Expr<'tcx>>,\n     },\n     If {\n-        cond: ExprRef<'tcx>,\n-        then: ExprRef<'tcx>,\n-        else_opt: Option<ExprRef<'tcx>>,\n+        cond: Box<Expr<'tcx>>,\n+        then: Box<Expr<'tcx>>,\n+        else_opt: Option<Box<Expr<'tcx>>>,\n     },\n     Call {\n         ty: Ty<'tcx>,\n-        fun: ExprRef<'tcx>,\n-        args: Vec<ExprRef<'tcx>>,\n-        // Whether this is from a call in HIR, rather than from an overloaded\n-        // operator. True for overloaded function call.\n+        fun: Box<Expr<'tcx>>,\n+        args: Vec<Expr<'tcx>>,\n+        /// Whether this is from a call in HIR, rather than from an overloaded\n+        /// operator. `true` for overloaded function call.\n         from_hir_call: bool,\n         /// This `Span` is the span of the function, without the dot and receiver\n         /// (e.g. `foo(a, b)` in `x.foo(a, b)`\n         fn_span: Span,\n     },\n     Deref {\n-        arg: ExprRef<'tcx>,\n+        arg: Box<Expr<'tcx>>,\n     }, // NOT overloaded!\n     Binary {\n         op: BinOp,\n-        lhs: ExprRef<'tcx>,\n-        rhs: ExprRef<'tcx>,\n+        lhs: Box<Expr<'tcx>>,\n+        rhs: Box<Expr<'tcx>>,\n     }, // NOT overloaded!\n     LogicalOp {\n         op: LogicalOp,\n-        lhs: ExprRef<'tcx>,\n-        rhs: ExprRef<'tcx>,\n+        lhs: Box<Expr<'tcx>>,\n+        rhs: Box<Expr<'tcx>>,\n     }, // NOT overloaded!\n     // LogicalOp is distinct from BinaryOp because of lazy evaluation of the operands.\n     Unary {\n         op: UnOp,\n-        arg: ExprRef<'tcx>,\n+        arg: Box<Expr<'tcx>>,\n     }, // NOT overloaded!\n     Cast {\n-        source: ExprRef<'tcx>,\n+        source: Box<Expr<'tcx>>,\n     },\n     Use {\n-        source: ExprRef<'tcx>,\n+        source: Box<Expr<'tcx>>,\n     }, // Use a lexpr to get a vexpr.\n     NeverToAny {\n-        source: ExprRef<'tcx>,\n+        source: Box<Expr<'tcx>>,\n     },\n     Pointer {\n         cast: PointerCast,\n-        source: ExprRef<'tcx>,\n+        source: Box<Expr<'tcx>>,\n     },\n     Loop {\n-        body: ExprRef<'tcx>,\n+        body: Box<Expr<'tcx>>,\n     },\n     Match {\n-        scrutinee: ExprRef<'tcx>,\n+        scrutinee: Box<Expr<'tcx>>,\n         arms: Vec<Arm<'tcx>>,\n     },\n     Block {\n-        body: &'tcx hir::Block<'tcx>,\n+        body: Block<'tcx>,\n     },\n     Assign {\n-        lhs: ExprRef<'tcx>,\n-        rhs: ExprRef<'tcx>,\n+        lhs: Box<Expr<'tcx>>,\n+        rhs: Box<Expr<'tcx>>,\n     },\n     AssignOp {\n         op: BinOp,\n-        lhs: ExprRef<'tcx>,\n-        rhs: ExprRef<'tcx>,\n+        lhs: Box<Expr<'tcx>>,\n+        rhs: Box<Expr<'tcx>>,\n     },\n     Field {\n-        lhs: ExprRef<'tcx>,\n+        lhs: Box<Expr<'tcx>>,\n         name: Field,\n     },\n     Index {\n-        lhs: ExprRef<'tcx>,\n-        index: ExprRef<'tcx>,\n+        lhs: Box<Expr<'tcx>>,\n+        index: Box<Expr<'tcx>>,\n     },\n     VarRef {\n         id: hir::HirId,\n@@ -226,35 +220,35 @@ crate enum ExprKind<'tcx> {\n     },\n     Borrow {\n         borrow_kind: BorrowKind,\n-        arg: ExprRef<'tcx>,\n+        arg: Box<Expr<'tcx>>,\n     },\n     /// A `&raw [const|mut] $place_expr` raw borrow resulting in type `*[const|mut] T`.\n     AddressOf {\n         mutability: hir::Mutability,\n-        arg: ExprRef<'tcx>,\n+        arg: Box<Expr<'tcx>>,\n     },\n     Break {\n         label: region::Scope,\n-        value: Option<ExprRef<'tcx>>,\n+        value: Option<Box<Expr<'tcx>>>,\n     },\n     Continue {\n         label: region::Scope,\n     },\n     Return {\n-        value: Option<ExprRef<'tcx>>,\n+        value: Option<Box<Expr<'tcx>>>,\n     },\n     ConstBlock {\n         value: &'tcx Const<'tcx>,\n     },\n     Repeat {\n-        value: ExprRef<'tcx>,\n+        value: Box<Expr<'tcx>>,\n         count: &'tcx Const<'tcx>,\n     },\n     Array {\n-        fields: Vec<ExprRef<'tcx>>,\n+        fields: Vec<Expr<'tcx>>,\n     },\n     Tuple {\n-        fields: Vec<ExprRef<'tcx>>,\n+        fields: Vec<Expr<'tcx>>,\n     },\n     Adt {\n         adt_def: &'tcx AdtDef,\n@@ -265,23 +259,23 @@ crate enum ExprKind<'tcx> {\n         /// Bar::<T> { ... }`.\n         user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n \n-        fields: Vec<FieldExprRef<'tcx>>,\n+        fields: Vec<FieldExpr<'tcx>>,\n         base: Option<FruInfo<'tcx>>,\n     },\n     PlaceTypeAscription {\n-        source: ExprRef<'tcx>,\n+        source: Box<Expr<'tcx>>,\n         /// Type that the user gave to this expression\n         user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n     },\n     ValueTypeAscription {\n-        source: ExprRef<'tcx>,\n+        source: Box<Expr<'tcx>>,\n         /// Type that the user gave to this expression\n         user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n     },\n     Closure {\n         closure_id: DefId,\n         substs: UpvarSubsts<'tcx>,\n-        upvars: Vec<ExprRef<'tcx>>,\n+        upvars: Vec<Expr<'tcx>>,\n         movability: Option<hir::Movability>,\n     },\n     Literal {\n@@ -310,46 +304,40 @@ crate enum ExprKind<'tcx> {\n     ThreadLocalRef(DefId),\n     LlvmInlineAsm {\n         asm: &'tcx hir::LlvmInlineAsmInner,\n-        outputs: Vec<ExprRef<'tcx>>,\n-        inputs: Vec<ExprRef<'tcx>>,\n+        outputs: Vec<Expr<'tcx>>,\n+        inputs: Vec<Expr<'tcx>>,\n     },\n     Yield {\n-        value: ExprRef<'tcx>,\n+        value: Box<Expr<'tcx>>,\n     },\n }\n \n #[derive(Clone, Debug)]\n-crate enum ExprRef<'tcx> {\n-    Thir(&'tcx hir::Expr<'tcx>),\n-    Mirror(Box<Expr<'tcx>>),\n-}\n-\n-#[derive(Clone, Debug)]\n-crate struct FieldExprRef<'tcx> {\n+crate struct FieldExpr<'tcx> {\n     crate name: Field,\n-    crate expr: ExprRef<'tcx>,\n+    crate expr: Expr<'tcx>,\n }\n \n #[derive(Clone, Debug)]\n crate struct FruInfo<'tcx> {\n-    crate base: ExprRef<'tcx>,\n+    crate base: Box<Expr<'tcx>>,\n     crate field_types: Vec<Ty<'tcx>>,\n }\n \n #[derive(Clone, Debug)]\n crate struct Arm<'tcx> {\n     crate pattern: Pat<'tcx>,\n     crate guard: Option<Guard<'tcx>>,\n-    crate body: ExprRef<'tcx>,\n+    crate body: Expr<'tcx>,\n     crate lint_level: LintLevel,\n     crate scope: region::Scope,\n     crate span: Span,\n }\n \n #[derive(Clone, Debug)]\n crate enum Guard<'tcx> {\n-    If(ExprRef<'tcx>),\n-    IfLet(Pat<'tcx>, ExprRef<'tcx>),\n+    If(Box<Expr<'tcx>>),\n+    IfLet(Pat<'tcx>, Box<Expr<'tcx>>),\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -358,110 +346,35 @@ crate enum LogicalOp {\n     Or,\n }\n \n-impl<'tcx> ExprRef<'tcx> {\n-    crate fn span(&self) -> Span {\n-        match self {\n-            ExprRef::Thir(expr) => expr.span,\n-            ExprRef::Mirror(expr) => expr.span,\n-        }\n-    }\n-}\n-\n #[derive(Clone, Debug)]\n crate enum InlineAsmOperand<'tcx> {\n     In {\n         reg: InlineAsmRegOrRegClass,\n-        expr: ExprRef<'tcx>,\n+        expr: Expr<'tcx>,\n     },\n     Out {\n         reg: InlineAsmRegOrRegClass,\n         late: bool,\n-        expr: Option<ExprRef<'tcx>>,\n+        expr: Option<Expr<'tcx>>,\n     },\n     InOut {\n         reg: InlineAsmRegOrRegClass,\n         late: bool,\n-        expr: ExprRef<'tcx>,\n+        expr: Expr<'tcx>,\n     },\n     SplitInOut {\n         reg: InlineAsmRegOrRegClass,\n         late: bool,\n-        in_expr: ExprRef<'tcx>,\n-        out_expr: Option<ExprRef<'tcx>>,\n+        in_expr: Expr<'tcx>,\n+        out_expr: Option<Expr<'tcx>>,\n     },\n     Const {\n-        expr: ExprRef<'tcx>,\n+        expr: Expr<'tcx>,\n     },\n     SymFn {\n-        expr: ExprRef<'tcx>,\n+        expr: Expr<'tcx>,\n     },\n     SymStatic {\n         def_id: DefId,\n     },\n }\n-\n-///////////////////////////////////////////////////////////////////////////\n-// The Mirror trait\n-\n-/// \"Mirroring\" is the process of converting from a HIR type into one\n-/// of the THIR types defined in this file. This is basically a \"on\n-/// the fly\" desugaring step that hides a lot of the messiness in the\n-/// tcx. For example, the mirror of a `&'tcx hir::Expr` is an\n-/// `Expr<'tcx>`.\n-///\n-/// Mirroring is gradual: when you mirror an outer expression like `e1\n-/// + e2`, the references to the inner expressions `e1` and `e2` are\n-/// `ExprRef<'tcx>` instances, and they may or may not be eagerly\n-/// mirrored. This allows a single AST node from the compiler to\n-/// expand into one or more Thir nodes, which lets the Thir nodes be\n-/// simpler.\n-crate trait Mirror<'tcx> {\n-    type Output;\n-\n-    fn make_mirror(self, cx: &mut Cx<'_, 'tcx>) -> Self::Output;\n-}\n-\n-impl<'tcx> Mirror<'tcx> for Expr<'tcx> {\n-    type Output = Expr<'tcx>;\n-\n-    fn make_mirror(self, _: &mut Cx<'_, 'tcx>) -> Expr<'tcx> {\n-        self\n-    }\n-}\n-\n-impl<'tcx> Mirror<'tcx> for ExprRef<'tcx> {\n-    type Output = Expr<'tcx>;\n-\n-    fn make_mirror(self, hir: &mut Cx<'_, 'tcx>) -> Expr<'tcx> {\n-        match self {\n-            ExprRef::Thir(h) => h.make_mirror(hir),\n-            ExprRef::Mirror(m) => *m,\n-        }\n-    }\n-}\n-\n-impl<'tcx> Mirror<'tcx> for Stmt<'tcx> {\n-    type Output = Stmt<'tcx>;\n-\n-    fn make_mirror(self, _: &mut Cx<'_, 'tcx>) -> Stmt<'tcx> {\n-        self\n-    }\n-}\n-\n-impl<'tcx> Mirror<'tcx> for StmtRef<'tcx> {\n-    type Output = Stmt<'tcx>;\n-\n-    fn make_mirror(self, _: &mut Cx<'_, 'tcx>) -> Stmt<'tcx> {\n-        match self {\n-            StmtRef::Mirror(m) => *m,\n-        }\n-    }\n-}\n-\n-impl<'tcx> Mirror<'tcx> for Block<'tcx> {\n-    type Output = Block<'tcx>;\n-\n-    fn make_mirror(self, _: &mut Cx<'_, 'tcx>) -> Block<'tcx> {\n-        self\n-    }\n-}"}]}