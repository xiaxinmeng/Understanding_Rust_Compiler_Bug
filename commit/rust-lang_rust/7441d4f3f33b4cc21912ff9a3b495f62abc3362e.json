{"sha": "7441d4f3f33b4cc21912ff9a3b495f62abc3362e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0NDFkNGYzZjMzYjRjYzIxOTEyZmY5YTNiNDk1ZjYyYWJjMzM2MmU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-15T17:28:00Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-08-25T00:08:14Z"}, "message": "native: TCP close/close_accept for windows\n\nThis commit implements TcpAcceptor::{close, close_accept} for windows via\nWSAEVENT types.", "tree": {"sha": "74e3277e78e3df4e58361785feb03cead18e841e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74e3277e78e3df4e58361785feb03cead18e841e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7441d4f3f33b4cc21912ff9a3b495f62abc3362e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7441d4f3f33b4cc21912ff9a3b495f62abc3362e", "html_url": "https://github.com/rust-lang/rust/commit/7441d4f3f33b4cc21912ff9a3b495f62abc3362e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7441d4f3f33b4cc21912ff9a3b495f62abc3362e/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb8df7a8e3c53f16d22f76da50e6e2e4734bdf62", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb8df7a8e3c53f16d22f76da50e6e2e4734bdf62", "html_url": "https://github.com/rust-lang/rust/commit/cb8df7a8e3c53f16d22f76da50e6e2e4734bdf62"}], "stats": {"total": 306, "additions": 228, "deletions": 78}, "files": [{"sha": "3bd850b5aac7fcc2daeb8d2c8cd01dfcf90ce3f0", "filename": "src/libnative/io/c_windows.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7441d4f3f33b4cc21912ff9a3b495f62abc3362e/src%2Flibnative%2Fio%2Fc_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7441d4f3f33b4cc21912ff9a3b495f62abc3362e/src%2Flibnative%2Fio%2Fc_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_windows.rs?ref=7441d4f3f33b4cc21912ff9a3b495f62abc3362e", "patch": "@@ -26,6 +26,14 @@ pub static ENABLE_INSERT_MODE: libc::DWORD = 0x20;\n pub static ENABLE_LINE_INPUT: libc::DWORD = 0x2;\n pub static ENABLE_PROCESSED_INPUT: libc::DWORD = 0x1;\n pub static ENABLE_QUICK_EDIT_MODE: libc::DWORD = 0x40;\n+pub static WSA_INVALID_EVENT: WSAEVENT = 0 as WSAEVENT;\n+\n+pub static FD_ACCEPT: libc::c_long = 0x08;\n+pub static FD_MAX_EVENTS: uint = 10;\n+pub static WSA_INFINITE: libc::DWORD = libc::INFINITE;\n+pub static WSA_WAIT_TIMEOUT: libc::DWORD = libc::consts::os::extra::WAIT_TIMEOUT;\n+pub static WSA_WAIT_EVENT_0: libc::DWORD = libc::consts::os::extra::WAIT_OBJECT_0;\n+pub static WSA_WAIT_FAILED: libc::DWORD = libc::consts::os::extra::WAIT_FAILED;\n \n #[repr(C)]\n #[cfg(target_arch = \"x86\")]\n@@ -52,6 +60,16 @@ pub struct WSADATA {\n \n pub type LPWSADATA = *mut WSADATA;\n \n+#[repr(C)]\n+pub struct WSANETWORKEVENTS {\n+    pub lNetworkEvents: libc::c_long,\n+    pub iErrorCode: [libc::c_int, ..FD_MAX_EVENTS],\n+}\n+\n+pub type LPWSANETWORKEVENTS = *mut WSANETWORKEVENTS;\n+\n+pub type WSAEVENT = libc::HANDLE;\n+\n #[repr(C)]\n pub struct fd_set {\n     fd_count: libc::c_uint,\n@@ -68,6 +86,21 @@ extern \"system\" {\n     pub fn WSAStartup(wVersionRequested: libc::WORD,\n                       lpWSAData: LPWSADATA) -> libc::c_int;\n     pub fn WSAGetLastError() -> libc::c_int;\n+    pub fn WSACloseEvent(hEvent: WSAEVENT) -> libc::BOOL;\n+    pub fn WSACreateEvent() -> WSAEVENT;\n+    pub fn WSAEventSelect(s: libc::SOCKET,\n+                          hEventObject: WSAEVENT,\n+                          lNetworkEvents: libc::c_long) -> libc::c_int;\n+    pub fn WSASetEvent(hEvent: WSAEVENT) -> libc::BOOL;\n+    pub fn WSAWaitForMultipleEvents(cEvents: libc::DWORD,\n+                                    lphEvents: *const WSAEVENT,\n+                                    fWaitAll: libc::BOOL,\n+                                    dwTimeout: libc::DWORD,\n+                                    fAltertable: libc::BOOL) -> libc::DWORD;\n+    pub fn WSAEnumNetworkEvents(s: libc::SOCKET,\n+                                hEventObject: WSAEVENT,\n+                                lpNetworkEvents: LPWSANETWORKEVENTS)\n+                                -> libc::c_int;\n \n     pub fn ioctlsocket(s: libc::SOCKET, cmd: libc::c_long,\n                        argp: *mut libc::c_ulong) -> libc::c_int;"}, {"sha": "daa1b25e40775d6b85c835b245a2a0ae9a331fe0", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 181, "deletions": 74, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/7441d4f3f33b4cc21912ff9a3b495f62abc3362e/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7441d4f3f33b4cc21912ff9a3b495f62abc3362e/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=7441d4f3f33b4cc21912ff9a3b495f62abc3362e", "patch": "@@ -11,6 +11,7 @@\n use alloc::arc::Arc;\n use libc;\n use std::mem;\n+use std::ptr;\n use std::rt::mutex;\n use std::rt::rtio;\n use std::rt::rtio::{IoResult, IoError};\n@@ -19,16 +20,16 @@ use std::sync::atomics;\n use super::{retry, keep_going};\n use super::c;\n use super::util;\n-use super::file::FileDesc;\n-use super::process;\n+\n+#[cfg(unix)] use super::process;\n+#[cfg(unix)] use super::file::FileDesc;\n+\n+pub use self::os::{init, sock_t, last_error};\n \n ////////////////////////////////////////////////////////////////////////////////\n // sockaddr and misc bindings\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[cfg(windows)] pub type sock_t = libc::SOCKET;\n-#[cfg(unix)]    pub type sock_t = super::file::fd_t;\n-\n pub fn htons(u: u16) -> u16 {\n     u.to_be()\n }\n@@ -100,7 +101,7 @@ fn socket(addr: rtio::SocketAddr, ty: libc::c_int) -> IoResult<sock_t> {\n             rtio::Ipv6Addr(..) => libc::AF_INET6,\n         };\n         match libc::socket(fam, ty, 0) {\n-            -1 => Err(super::last_error()),\n+            -1 => Err(os::last_error()),\n             fd => Ok(fd),\n         }\n     }\n@@ -114,7 +115,7 @@ fn setsockopt<T>(fd: sock_t, opt: libc::c_int, val: libc::c_int,\n                                    payload,\n                                    mem::size_of::<T>() as libc::socklen_t);\n         if ret != 0 {\n-            Err(last_error())\n+            Err(os::last_error())\n         } else {\n             Ok(())\n         }\n@@ -130,33 +131,14 @@ pub fn getsockopt<T: Copy>(fd: sock_t, opt: libc::c_int,\n                                 &mut slot as *mut _ as *mut _,\n                                 &mut len);\n         if ret != 0 {\n-            Err(last_error())\n+            Err(os::last_error())\n         } else {\n             assert!(len as uint == mem::size_of::<T>());\n             Ok(slot)\n         }\n     }\n }\n \n-#[cfg(windows)]\n-pub fn last_error() -> IoError {\n-    use std::os;\n-    let code = unsafe { c::WSAGetLastError() as uint };\n-    IoError {\n-        code: code,\n-        extra: 0,\n-        detail: Some(os::error_string(code)),\n-    }\n-}\n-\n-#[cfg(not(windows))]\n-fn last_error() -> IoError {\n-    super::last_error()\n-}\n-\n-#[cfg(windows)] unsafe fn close(sock: sock_t) { let _ = libc::closesocket(sock); }\n-#[cfg(unix)]    unsafe fn close(sock: sock_t) { let _ = libc::close(sock); }\n-\n fn sockname(fd: sock_t,\n             f: unsafe extern \"system\" fn(sock_t, *mut libc::sockaddr,\n                                          *mut libc::socklen_t) -> libc::c_int)\n@@ -170,7 +152,7 @@ fn sockname(fd: sock_t,\n                     storage as *mut libc::sockaddr,\n                     &mut len as *mut libc::socklen_t);\n         if ret != 0 {\n-            return Err(last_error())\n+            return Err(os::last_error())\n         }\n     }\n     return sockaddr_to_addr(&storage, len as uint);\n@@ -224,28 +206,6 @@ pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n     }\n }\n \n-#[cfg(unix)]\n-pub fn init() {}\n-\n-#[cfg(windows)]\n-pub fn init() {\n-\n-    unsafe {\n-        use std::rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n-        static mut INITIALIZED: bool = false;\n-        static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n-\n-        let _guard = LOCK.lock();\n-        if !INITIALIZED {\n-            let mut data: c::WSADATA = mem::zeroed();\n-            let ret = c::WSAStartup(0x202,      // version 2.2\n-                                    &mut data);\n-            assert_eq!(ret, 0);\n-            INITIALIZED = true;\n-        }\n-    }\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // TCP streams\n ////////////////////////////////////////////////////////////////////////////////\n@@ -292,7 +252,7 @@ impl TcpStream {\n             },\n             None => {\n                 match retry(|| unsafe { libc::connect(fd, addrp, len) }) {\n-                    -1 => Err(last_error()),\n+                    -1 => Err(os::last_error()),\n                     _ => Ok(ret),\n                 }\n             }\n@@ -438,7 +398,7 @@ impl rtio::RtioSocket for TcpStream {\n }\n \n impl Drop for Inner {\n-    fn drop(&mut self) { unsafe { close(self.fd); } }\n+    fn drop(&mut self) { unsafe { os::close(self.fd); } }\n }\n \n #[unsafe_destructor]\n@@ -474,17 +434,16 @@ impl TcpListener {\n         }\n \n         match unsafe { libc::bind(fd, addrp, len) } {\n-            -1 => Err(last_error()),\n+            -1 => Err(os::last_error()),\n             _ => Ok(ret),\n         }\n     }\n \n     pub fn fd(&self) -> sock_t { self.inner.fd }\n \n     pub fn native_listen(self, backlog: int) -> IoResult<TcpAcceptor> {\n-        try!(util::set_nonblocking(self.fd(), true));\n         match unsafe { libc::listen(self.fd(), backlog as libc::c_int) } {\n-            -1 => Err(last_error()),\n+            -1 => Err(os::last_error()),\n \n             #[cfg(unix)]\n             _ => {\n@@ -502,6 +461,26 @@ impl TcpListener {\n                     deadline: 0,\n                 })\n             }\n+\n+            #[cfg(windows)]\n+            _ => {\n+                let accept = try!(os::Event::new());\n+                let ret = unsafe {\n+                    c::WSAEventSelect(self.fd(), accept.handle(), c::FD_ACCEPT)\n+                };\n+                if ret != 0 {\n+                    return Err(os::last_error())\n+                }\n+                Ok(TcpAcceptor {\n+                    inner: Arc::new(AcceptorInner {\n+                        listener: self,\n+                        abort: try!(os::Event::new()),\n+                        accept: accept,\n+                        closed: atomics::AtomicBool::new(false),\n+                    }),\n+                    deadline: 0,\n+                })\n+            }\n         }\n     }\n }\n@@ -534,6 +513,14 @@ struct AcceptorInner {\n     closed: atomics::AtomicBool,\n }\n \n+#[cfg(windows)]\n+struct AcceptorInner {\n+    listener: TcpListener,\n+    abort: os::Event,\n+    accept: os::Event,\n+    closed: atomics::AtomicBool,\n+}\n+\n impl TcpAcceptor {\n     pub fn fd(&self) -> sock_t { self.inner.listener.fd() }\n \n@@ -542,27 +529,63 @@ impl TcpAcceptor {\n         let deadline = if self.deadline == 0 {None} else {Some(self.deadline)};\n \n         while !self.inner.closed.load(atomics::SeqCst) {\n-            unsafe {\n-                let mut storage: libc::sockaddr_storage = mem::zeroed();\n-                let storagep = &mut storage as *mut libc::sockaddr_storage;\n-                let size = mem::size_of::<libc::sockaddr_storage>();\n-                let mut size = size as libc::socklen_t;\n-                match retry(|| {\n-                    libc::accept(self.fd(),\n-                                 storagep as *mut libc::sockaddr,\n-                                 &mut size as *mut libc::socklen_t) as libc::c_int\n-                }) as sock_t {\n-                    -1 if util::wouldblock() => {}\n-                    -1 => return Err(last_error()),\n-                    fd => return Ok(TcpStream::new(Inner::new(fd))),\n-                }\n+            match retry(|| unsafe {\n+                libc::accept(self.fd(), ptr::mut_null(), ptr::mut_null())\n+            }) {\n+                -1 if util::wouldblock() => {}\n+                -1 => return Err(os::last_error()),\n+                fd => return Ok(TcpStream::new(Inner::new(fd as sock_t))),\n             }\n             try!(util::await([self.fd(), self.inner.reader.fd()],\n                              deadline, util::Readable));\n         }\n \n         Err(util::eof())\n     }\n+\n+    #[cfg(windows)]\n+    pub fn native_accept(&mut self) -> IoResult<TcpStream> {\n+        let events = [self.inner.abort.handle(), self.inner.accept.handle()];\n+\n+        while !self.inner.closed.load(atomics::SeqCst) {\n+            let ms = if self.deadline == 0 {\n+                c::WSA_INFINITE as u64\n+            } else {\n+                let now = ::io::timer::now();\n+                if self.deadline < now {0} else {now - self.deadline}\n+            };\n+            let ret = unsafe {\n+                c::WSAWaitForMultipleEvents(2, events.as_ptr(), libc::FALSE,\n+                                            ms as libc::DWORD, libc::FALSE)\n+            };\n+            match ret {\n+                c::WSA_WAIT_TIMEOUT => {\n+                    return Err(util::timeout(\"accept timed out\"))\n+                }\n+                c::WSA_WAIT_FAILED => return Err(os::last_error()),\n+                c::WSA_WAIT_EVENT_0 => break,\n+                n => assert_eq!(n, c::WSA_WAIT_EVENT_0 + 1),\n+            }\n+            println!(\"woke up\");\n+\n+            let mut wsaevents: c::WSANETWORKEVENTS = unsafe { mem::zeroed() };\n+            let ret = unsafe {\n+                c::WSAEnumNetworkEvents(self.fd(), events[1], &mut wsaevents)\n+            };\n+            if ret != 0 { return Err(os::last_error()) }\n+\n+            if wsaevents.lNetworkEvents & c::FD_ACCEPT == 0 { continue }\n+            match unsafe {\n+                libc::accept(self.fd(), ptr::mut_null(), ptr::mut_null())\n+            } {\n+                -1 if util::wouldblock() => {}\n+                -1 => return Err(os::last_error()),\n+                fd => return Ok(TcpStream::new(Inner::new(fd))),\n+            }\n+        }\n+\n+        Err(util::eof())\n+    }\n }\n \n impl rtio::RtioSocket for TcpAcceptor {\n@@ -599,6 +622,17 @@ impl rtio::RtioTcpAcceptor for TcpAcceptor {\n             Err(e) => Err(e),\n         }\n     }\n+\n+    #[cfg(windows)]\n+    fn close_accept(&mut self) -> IoResult<()> {\n+        self.inner.closed.store(true, atomics::SeqCst);\n+        let ret = unsafe { c::WSASetEvent(self.inner.abort.handle()) };\n+        if ret == libc::TRUE {\n+            Ok(())\n+        } else {\n+            Err(os::last_error())\n+        }\n+    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -625,7 +659,7 @@ impl UdpSocket {\n         let addrp = &storage as *const _ as *const libc::sockaddr;\n \n         match unsafe { libc::bind(fd, addrp, len) } {\n-            -1 => Err(last_error()),\n+            -1 => Err(os::last_error()),\n             _ => Ok(ret),\n         }\n     }\n@@ -881,15 +915,15 @@ pub fn read<T>(fd: sock_t,\n             let _guard = lock();\n             match retry(|| read(deadline.is_some())) {\n                 -1 if util::wouldblock() => { assert!(deadline.is_some()); }\n-                -1 => return Err(last_error()),\n+                -1 => return Err(os::last_error()),\n                n => { ret = n; break }\n             }\n         }\n     }\n \n     match ret {\n         0 => Err(util::eof()),\n-        n if n < 0 => Err(last_error()),\n+        n if n < 0 => Err(os::last_error()),\n         n => Ok(n as uint)\n     }\n }\n@@ -940,15 +974,88 @@ pub fn write<T>(fd: sock_t,\n             let len = buf.len() - written;\n             match retry(|| write(deadline.is_some(), ptr, len) as libc::c_int) {\n                 -1 if util::wouldblock() => {}\n-                -1 => return Err(last_error()),\n+                -1 => return Err(os::last_error()),\n                 n => { written += n as uint; }\n             }\n         }\n         ret = 0;\n     }\n     if ret < 0 {\n-        Err(last_error())\n+        Err(os::last_error())\n     } else {\n         Ok(written)\n     }\n }\n+\n+#[cfg(windows)]\n+mod os {\n+    use libc;\n+    use std::mem;\n+    use std::rt::rtio::{IoError, IoResult};\n+\n+    use io::c;\n+\n+    pub type sock_t = libc::SOCKET;\n+    pub struct Event(c::WSAEVENT);\n+\n+    impl Event {\n+        pub fn new() -> IoResult<Event> {\n+            let event = unsafe { c::WSACreateEvent() };\n+            if event == c::WSA_INVALID_EVENT {\n+                Err(last_error())\n+            } else {\n+                Ok(Event(event))\n+            }\n+        }\n+\n+        pub fn handle(&self) -> c::WSAEVENT { let Event(handle) = *self; handle }\n+    }\n+\n+    impl Drop for Event {\n+        fn drop(&mut self) {\n+            unsafe { let _ = c::WSACloseEvent(self.handle()); }\n+        }\n+    }\n+\n+    pub fn init() {\n+        unsafe {\n+            use std::rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+            static mut INITIALIZED: bool = false;\n+            static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+\n+            let _guard = LOCK.lock();\n+            if !INITIALIZED {\n+                let mut data: c::WSADATA = mem::zeroed();\n+                let ret = c::WSAStartup(0x202,      // version 2.2\n+                                        &mut data);\n+                assert_eq!(ret, 0);\n+                INITIALIZED = true;\n+            }\n+        }\n+    }\n+\n+    pub fn last_error() -> IoError {\n+        use std::os;\n+        let code = unsafe { c::WSAGetLastError() as uint };\n+        IoError {\n+            code: code,\n+            extra: 0,\n+            detail: Some(os::error_string(code)),\n+        }\n+    }\n+\n+    pub unsafe fn close(sock: sock_t) { let _ = libc::closesocket(sock); }\n+}\n+\n+#[cfg(unix)]\n+mod os {\n+    use libc;\n+    use std::rt::rtio::IoError;\n+    use io;\n+\n+    pub type sock_t = io::file::fd_t;\n+\n+    pub fn init() {}\n+    pub fn last_error() -> IoError { io::last_error() }\n+    pub unsafe fn close(sock: sock_t) { let _ = libc::close(sock); }\n+}"}, {"sha": "4d01230cbd9771295c5042d37a554a1cece1c395", "filename": "src/libnative/io/pipe_windows.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7441d4f3f33b4cc21912ff9a3b495f62abc3362e/src%2Flibnative%2Fio%2Fpipe_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7441d4f3f33b4cc21912ff9a3b495f62abc3362e/src%2Flibnative%2Fio%2Fpipe_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_windows.rs?ref=7441d4f3f33b4cc21912ff9a3b495f62abc3362e", "patch": "@@ -99,10 +99,10 @@ use super::c;\n use super::util;\n use super::file::to_utf16;\n \n-pub struct Event(libc::HANDLE);\n+struct Event(libc::HANDLE);\n \n impl Event {\n-    pub fn new(manual_reset: bool, initial_state: bool) -> IoResult<Event> {\n+    fn new(manual_reset: bool, initial_state: bool) -> IoResult<Event> {\n         let event = unsafe {\n             libc::CreateEventW(ptr::mut_null(),\n                                manual_reset as libc::BOOL,\n@@ -116,7 +116,7 @@ impl Event {\n         }\n     }\n \n-    pub fn handle(&self) -> libc::HANDLE { let Event(handle) = *self; handle }\n+    fn handle(&self) -> libc::HANDLE { let Event(handle) = *self; handle }\n }\n \n impl Drop for Event {\n@@ -709,5 +709,13 @@ impl rtio::RtioUnixAcceptor for UnixAcceptor {\n     fn set_timeout(&mut self, timeout: Option<u64>) {\n         self.deadline = timeout.map(|i| i + ::io::timer::now()).unwrap_or(0);\n     }\n+\n+    fn clone(&self) -> Box<rtio::RtioUnixAcceptor + Send> {\n+        fail!()\n+    }\n+\n+    fn close_accept(&mut self) -> IoResult<()> {\n+        fail!()\n+    }\n }\n "}, {"sha": "c5b1bbec4f1631988026fa98d25f770906440905", "filename": "src/libnative/io/util.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7441d4f3f33b4cc21912ff9a3b495f62abc3362e/src%2Flibnative%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7441d4f3f33b4cc21912ff9a3b495f62abc3362e/src%2Flibnative%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Futil.rs?ref=7441d4f3f33b4cc21912ff9a3b495f62abc3362e", "patch": "@@ -194,7 +194,9 @@ pub fn await(fds: &[net::sock_t], deadline: Option<u64>,\n                 &mut tv as *mut _\n             }\n         };\n-        let r = unsafe { c::select(max, read, write, ptr::mut_null(), tvp) };\n+        let r = unsafe {\n+            c::select(max as libc::c_int, read, write, ptr::mut_null(), tvp)\n+        };\n         r\n     }) {\n         -1 => Err(last_error()),"}]}