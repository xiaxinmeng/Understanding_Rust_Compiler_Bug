{"sha": "0a998b86e977912dfabd4fddb3c7efe87accf2c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhOTk4Yjg2ZTk3NzkxMmRmYWJkNGZkZGIzYzdlZmU4N2FjY2YyYzI=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-05T20:30:40Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-10T11:19:34Z"}, "message": "Support `#[macro_reexport]`ing custom derives.", "tree": {"sha": "317c4bdf9d17873a49bc449fa7217273c2a6e7b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/317c4bdf9d17873a49bc449fa7217273c2a6e7b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a998b86e977912dfabd4fddb3c7efe87accf2c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a998b86e977912dfabd4fddb3c7efe87accf2c2", "html_url": "https://github.com/rust-lang/rust/commit/0a998b86e977912dfabd4fddb3c7efe87accf2c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a998b86e977912dfabd4fddb3c7efe87accf2c2/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad5345239850a6d9f16ad30e7f2d220ac1c0ae9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad5345239850a6d9f16ad30e7f2d220ac1c0ae9d", "html_url": "https://github.com/rust-lang/rust/commit/ad5345239850a6d9f16ad30e7f2d220ac1c0ae9d"}], "stats": {"total": 340, "additions": 170, "deletions": 170}, "files": [{"sha": "3583ccdb97bad097da77239959c45cf1477d9872", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0a998b86e977912dfabd4fddb3c7efe87accf2c2/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a998b86e977912dfabd4fddb3c7efe87accf2c2/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=0a998b86e977912dfabd4fddb3c7efe87accf2c2", "patch": "@@ -34,6 +34,7 @@ use session::Session;\n use session::search_paths::PathKind;\n use util::nodemap::{NodeSet, DefIdMap};\n use std::path::PathBuf;\n+use std::rc::Rc;\n use syntax::ast;\n use syntax::attr;\n use syntax::ext::base::SyntaxExtension;\n@@ -106,6 +107,11 @@ pub enum InlinedItemRef<'a> {\n     ImplItem(DefId, &'a hir::ImplItem)\n }\n \n+pub enum LoadedMacro {\n+    MacroRules(ast::MacroDef),\n+    ProcMacro(Rc<SyntaxExtension>),\n+}\n+\n #[derive(Copy, Clone, Debug)]\n pub struct ExternCrate {\n     /// def_id of an `extern crate` in the current crate that caused\n@@ -211,7 +217,7 @@ pub trait CrateStore<'tcx> {\n     fn relative_def_path(&self, def: DefId) -> Option<hir_map::DefPath>;\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>;\n     fn item_children(&self, did: DefId) -> Vec<def::Export>;\n-    fn load_macro(&self, did: DefId, sess: &Session) -> ast::MacroDef;\n+    fn load_macro(&self, did: DefId, sess: &Session) -> LoadedMacro;\n \n     // misc. metadata\n     fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n@@ -383,7 +389,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     }\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name> { bug!(\"struct_field_names\") }\n     fn item_children(&self, did: DefId) -> Vec<def::Export> { bug!(\"item_children\") }\n-    fn load_macro(&self, did: DefId, sess: &Session) -> ast::MacroDef { bug!(\"load_macro\") }\n+    fn load_macro(&self, did: DefId, sess: &Session) -> LoadedMacro { bug!(\"load_macro\") }\n \n     // misc. metadata\n     fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n@@ -424,7 +430,6 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n }\n \n pub trait CrateLoader {\n-    fn process_item(&mut self, item: &ast::Item, defs: &Definitions, load_macros: bool)\n-                    -> Vec<(ast::Name, SyntaxExtension)>;\n+    fn process_item(&mut self, item: &ast::Item, defs: &Definitions);\n     fn postprocess(&mut self, krate: &ast::Crate);\n }"}, {"sha": "75944122f5c10ab93b18455c215a8f63f1f52479", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 57, "deletions": 79, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/0a998b86e977912dfabd4fddb3c7efe87accf2c2/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a998b86e977912dfabd4fddb3c7efe87accf2c2/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=0a998b86e977912dfabd4fddb3c7efe87accf2c2", "patch": "@@ -35,7 +35,6 @@ use syntax::ast;\n use syntax::abi::Abi;\n use syntax::attr;\n use syntax::ext::base::SyntaxExtension;\n-use syntax::feature_gate::{self, emit_feature_err};\n use syntax::parse::token::{InternedString, intern};\n use syntax_pos::{Span, DUMMY_SP};\n use log;\n@@ -285,15 +284,13 @@ impl<'a> CrateLoader<'a> {\n \n         let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, span, dep_kind);\n \n-        if crate_root.macro_derive_registrar.is_some() {\n-            self.sess.span_err(span, \"crates of the `proc-macro` crate type \\\n-                                      cannot be linked at runtime\");\n-        }\n-\n         let cmeta = Rc::new(cstore::CrateMetadata {\n             name: name.to_string(),\n             extern_crate: Cell::new(None),\n             key_map: metadata.load_key_map(crate_root.index),\n+            proc_macros: crate_root.macro_derive_registrar.map(|_| {\n+                self.load_derive_macros(&crate_root, dylib.clone().map(|p| p.0), span)\n+            }),\n             root: crate_root,\n             blob: metadata,\n             cnum_map: RefCell::new(cnum_map),\n@@ -317,34 +314,48 @@ impl<'a> CrateLoader<'a> {\n                      hash: Option<&Svh>,\n                      span: Span,\n                      kind: PathKind,\n-                     dep_kind: DepKind)\n+                     mut dep_kind: DepKind)\n                      -> (CrateNum, Rc<cstore::CrateMetadata>) {\n         info!(\"resolving crate `extern crate {} as {}`\", name, ident);\n-        let result = match self.existing_match(name, hash, kind) {\n-            Some(cnum) => LoadResult::Previous(cnum),\n-            None => {\n-                info!(\"falling back to a load\");\n-                let mut locate_ctxt = locator::Context {\n-                    sess: self.sess,\n-                    span: span,\n-                    ident: ident,\n-                    crate_name: name,\n-                    hash: hash.map(|a| &*a),\n-                    filesearch: self.sess.target_filesearch(kind),\n-                    target: &self.sess.target.target,\n-                    triple: &self.sess.opts.target_triple,\n-                    root: root,\n+        let result = if let Some(cnum) = self.existing_match(name, hash, kind) {\n+            LoadResult::Previous(cnum)\n+        } else {\n+            info!(\"falling back to a load\");\n+            let mut locate_ctxt = locator::Context {\n+                sess: self.sess,\n+                span: span,\n+                ident: ident,\n+                crate_name: name,\n+                hash: hash.map(|a| &*a),\n+                filesearch: self.sess.target_filesearch(kind),\n+                target: &self.sess.target.target,\n+                triple: &self.sess.opts.target_triple,\n+                root: root,\n+                rejected_via_hash: vec![],\n+                rejected_via_triple: vec![],\n+                rejected_via_kind: vec![],\n+                rejected_via_version: vec![],\n+                should_match_name: true,\n+                is_proc_macro: Some(false),\n+            };\n+\n+            self.load(&mut locate_ctxt).or_else(|| {\n+                dep_kind = DepKind::MacrosOnly;\n+\n+                let mut proc_macro_locator = locator::Context {\n+                    target: &self.sess.host,\n+                    triple: config::host_triple(),\n+                    filesearch: self.sess.host_filesearch(PathKind::Crate),\n                     rejected_via_hash: vec![],\n                     rejected_via_triple: vec![],\n                     rejected_via_kind: vec![],\n                     rejected_via_version: vec![],\n-                    should_match_name: true,\n+                    is_proc_macro: Some(true),\n+                    ..locate_ctxt\n                 };\n-                match self.load(&mut locate_ctxt) {\n-                    Some(result) => result,\n-                    None => locate_ctxt.report_errs(),\n-                }\n-            }\n+\n+                self.load(&mut proc_macro_locator)\n+            }).unwrap_or_else(|| locate_ctxt.report_errs())\n         };\n \n         match result {\n@@ -431,6 +442,10 @@ impl<'a> CrateLoader<'a> {\n                           dep_kind: DepKind)\n                           -> cstore::CrateNumMap {\n         debug!(\"resolving deps of external crate\");\n+        if crate_root.macro_derive_registrar.is_some() {\n+            return cstore::CrateNumMap::new();\n+        }\n+\n         // The map from crate numbers in the crate we're resolving to local crate\n         // numbers\n         let deps = crate_root.crate_deps.decode(metadata);\n@@ -479,6 +494,7 @@ impl<'a> CrateLoader<'a> {\n             rejected_via_kind: vec![],\n             rejected_via_version: vec![],\n             should_match_name: true,\n+            is_proc_macro: None,\n         };\n         let library = self.load(&mut locate_ctxt).or_else(|| {\n             if !is_cross {\n@@ -525,51 +541,36 @@ impl<'a> CrateLoader<'a> {\n     /// implemented as dynamic libraries, but we have a possible future where\n     /// custom derive (and other macro-1.1 style features) are implemented via\n     /// executables and custom IPC.\n-    fn load_derive_macros(&mut self, item: &ast::Item, ekrate: &ExtensionCrate)\n-                          -> Option<Vec<(ast::Name, SyntaxExtension)>> {\n+    fn load_derive_macros(&mut self, root: &CrateRoot, dylib: Option<PathBuf>, span: Span)\n+                          -> Vec<(ast::Name, Rc<SyntaxExtension>)> {\n         use std::{env, mem};\n         use proc_macro::TokenStream;\n         use proc_macro::__internal::Registry;\n         use rustc_back::dynamic_lib::DynamicLibrary;\n         use syntax_ext::deriving::custom::CustomDerive;\n \n-        let root = ekrate.metadata.get_root();\n-        let index = match root.macro_derive_registrar {\n-            Some(index) => index,\n-            None => return None,\n-        };\n-        if !self.sess.features.borrow().proc_macro {\n-            let issue = feature_gate::GateIssue::Language;\n-            let msg = \"loading custom derive macro crates is experimentally supported\";\n-            emit_feature_err(&self.sess.parse_sess, \"proc_macro\", item.span, issue, msg);\n-        }\n-\n-        if ekrate.target_only {\n-            let msg = format!(\"proc-macro crate is not available for triple `{}` (only found {})\",\n-                               config::host_triple(), self.sess.opts.target_triple);\n-            self.sess.span_fatal(item.span, &msg);\n-        }\n-        let path = match ekrate.dylib.clone() {\n+        let path = match dylib {\n             Some(dylib) => dylib,\n-            None => span_bug!(item.span, \"proc-macro crate not dylib\"),\n+            None => span_bug!(span, \"proc-macro crate not dylib\"),\n         };\n         // Make sure the path contains a / or the linker will search for it.\n         let path = env::current_dir().unwrap().join(path);\n         let lib = match DynamicLibrary::open(Some(&path)) {\n             Ok(lib) => lib,\n-            Err(err) => self.sess.span_fatal(item.span, &err),\n+            Err(err) => self.sess.span_fatal(span, &err),\n         };\n \n-        let sym = self.sess.generate_derive_registrar_symbol(&root.hash, index);\n+        let sym = self.sess.generate_derive_registrar_symbol(&root.hash,\n+                                                             root.macro_derive_registrar.unwrap());\n         let registrar = unsafe {\n             let sym = match lib.symbol(&sym) {\n                 Ok(f) => f,\n-                Err(err) => self.sess.span_fatal(item.span, &err),\n+                Err(err) => self.sess.span_fatal(span, &err),\n             };\n             mem::transmute::<*mut u8, fn(&mut Registry)>(sym)\n         };\n \n-        struct MyRegistrar(Vec<(ast::Name, SyntaxExtension)>);\n+        struct MyRegistrar(Vec<(ast::Name, Rc<SyntaxExtension>)>);\n \n         impl Registry for MyRegistrar {\n             fn register_custom_derive(&mut self,\n@@ -580,7 +581,7 @@ impl<'a> CrateLoader<'a> {\n                 let derive = SyntaxExtension::CustomDerive(\n                     Box::new(CustomDerive::new(expand, attrs))\n                 );\n-                self.0.push((intern(trait_name), derive));\n+                self.0.push((intern(trait_name), Rc::new(derive)));\n             }\n         }\n \n@@ -590,7 +591,7 @@ impl<'a> CrateLoader<'a> {\n         // Intentionally leak the dynamic library. We can't ever unload it\n         // since the library can make things that will live arbitrarily long.\n         mem::forget(lib);\n-        Some(my_registrar.0)\n+        my_registrar.0\n     }\n \n     /// Look for a plugin registrar. Returns library path, crate\n@@ -928,35 +929,14 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n         self.register_statically_included_foreign_items();\n     }\n \n-    fn process_item(&mut self, item: &ast::Item, definitions: &Definitions, load_macros: bool)\n-                    -> Vec<(ast::Name, SyntaxExtension)> {\n+    fn process_item(&mut self, item: &ast::Item, definitions: &Definitions) {\n         match item.node {\n             ast::ItemKind::ExternCrate(_) => {}\n-            ast::ItemKind::ForeignMod(ref fm) => {\n-                self.process_foreign_mod(item, fm);\n-                return Vec::new();\n-            }\n-            _ => return Vec::new(),\n+            ast::ItemKind::ForeignMod(ref fm) => return self.process_foreign_mod(item, fm),\n+            _ => return,\n         }\n \n         let info = self.extract_crate_info(item).unwrap();\n-        if load_macros {\n-            let ekrate = self.read_extension_crate(item.span, &info);\n-\n-            // If this is a proc-macro crate, return here to avoid registering.\n-            if let Some(custom_derives) = self.load_derive_macros(item, &ekrate) {\n-                return custom_derives;\n-            }\n-\n-            // Register crate now to avoid double-reading metadata\n-            if let PMDSource::Owned(lib) = ekrate.metadata {\n-                if ekrate.target_only || config::host_triple() == self.sess.opts.target_triple {\n-                    let ExternCrateInfo { ref ident, ref name, dep_kind, .. } = info;\n-                    self.register_crate(&None, ident, name, item.span, lib, dep_kind);\n-                }\n-            }\n-        }\n-\n         let (cnum, ..) = self.resolve_crate(\n             &None, &info.ident, &info.name, None, item.span, PathKind::Crate, info.dep_kind,\n         );\n@@ -968,7 +948,5 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n             ExternCrate { def_id: def_id, span: item.span, direct: true, path_len: len };\n         self.update_extern_crate(cnum, extern_crate, &mut FxHashSet());\n         self.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n-\n-        Vec::new()\n     }\n }"}, {"sha": "8c95e4aec0a0457d346a80f5dd12c4346fe95bad", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a998b86e977912dfabd4fddb3c7efe87accf2c2/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a998b86e977912dfabd4fddb3c7efe87accf2c2/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=0a998b86e977912dfabd4fddb3c7efe87accf2c2", "patch": "@@ -28,6 +28,7 @@ use std::rc::Rc;\n use std::path::PathBuf;\n use flate::Bytes;\n use syntax::{ast, attr};\n+use syntax::ext::base::SyntaxExtension;\n use syntax_pos;\n \n pub use rustc::middle::cstore::{NativeLibraryKind, LinkagePreference};\n@@ -80,6 +81,8 @@ pub struct CrateMetadata {\n \n     pub dep_kind: Cell<DepKind>,\n     pub source: CrateSource,\n+\n+    pub proc_macros: Option<Vec<(ast::Name, Rc<SyntaxExtension>)>>,\n }\n \n pub struct CachedInlinedItem {"}, {"sha": "83de8acdb60565c3c68af466bd52155d7399b77b", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0a998b86e977912dfabd4fddb3c7efe87accf2c2/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a998b86e977912dfabd4fddb3c7efe87accf2c2/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=0a998b86e977912dfabd4fddb3c7efe87accf2c2", "patch": "@@ -14,7 +14,7 @@ use locator;\n use schema;\n \n use rustc::middle::cstore::{InlinedItem, CrateStore, CrateSource, DepKind, ExternCrate};\n-use rustc::middle::cstore::{NativeLibraryKind, LinkMeta, LinkagePreference};\n+use rustc::middle::cstore::{NativeLibraryKind, LinkMeta, LinkagePreference, LoadedMacro};\n use rustc::hir::def::{self, Def};\n use rustc::middle::lang_items;\n use rustc::session::Session;\n@@ -353,8 +353,13 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         result\n     }\n \n-    fn load_macro(&self, id: DefId, sess: &Session) -> ast::MacroDef {\n-        let (name, def) = self.get_crate_data(id.krate).get_macro(id.index);\n+    fn load_macro(&self, id: DefId, sess: &Session) -> LoadedMacro {\n+        let data = self.get_crate_data(id.krate);\n+        if let Some(ref proc_macros) = data.proc_macros {\n+            return LoadedMacro::ProcMacro(proc_macros[id.index.as_usize()].1.clone());\n+        }\n+\n+        let (name, def) = data.get_macro(id.index);\n         let source_name = format!(\"<{} macros>\", name);\n \n         // NB: Don't use parse_tts_from_source_str because it parses with quote_depth > 0.\n@@ -379,15 +384,15 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         sess.imported_macro_spans.borrow_mut()\n             .insert(local_span, (def.name.as_str().to_string(), def.span));\n \n-        ast::MacroDef {\n+        LoadedMacro::MacroRules(ast::MacroDef {\n             ident: ast::Ident::with_empty_ctxt(def.name),\n             id: ast::DUMMY_NODE_ID,\n             span: local_span,\n             imported_from: None, // FIXME\n             allow_internal_unstable: attr::contains_name(&def.attrs, \"allow_internal_unstable\"),\n             attrs: def.attrs,\n             body: body,\n-        }\n+        })\n     }\n \n     fn maybe_get_item_ast<'a>(&'tcx self,"}, {"sha": "78cde4c2fcb7eb3a3826705b25e5ec036aa21041", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0a998b86e977912dfabd4fddb3c7efe87accf2c2/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a998b86e977912dfabd4fddb3c7efe87accf2c2/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=0a998b86e977912dfabd4fddb3c7efe87accf2c2", "patch": "@@ -691,7 +691,15 @@ impl<'a, 'tcx> CrateMetadata {\n     pub fn each_child_of_item<F>(&self, id: DefIndex, mut callback: F)\n         where F: FnMut(def::Export)\n     {\n-        let macros_only = self.dep_kind.get() == DepKind::MacrosOnly;\n+        if let Some(ref proc_macros) = self.proc_macros {\n+            for (id, &(name, _)) in proc_macros.iter().enumerate() {\n+                callback(def::Export {\n+                    name: name,\n+                    def: Def::Macro(DefId { krate: self.cnum, index: DefIndex::new(id), }),\n+                })\n+            }\n+            return\n+        }\n \n         // Find the item.\n         let item = match self.maybe_entry(id) {\n@@ -700,6 +708,7 @@ impl<'a, 'tcx> CrateMetadata {\n         };\n \n         // Iterate over all children.\n+        let macros_only = self.dep_kind.get() == DepKind::MacrosOnly;\n         for child_index in item.children.decode(self) {\n             if macros_only {\n                 continue"}, {"sha": "b6b347fff5f26fcf5de2f7ad5066c34b90915009", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0a998b86e977912dfabd4fddb3c7efe87accf2c2/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a998b86e977912dfabd4fddb3c7efe87accf2c2/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=0a998b86e977912dfabd4fddb3c7efe87accf2c2", "patch": "@@ -262,6 +262,7 @@ pub struct Context<'a> {\n     pub rejected_via_kind: Vec<CrateMismatch>,\n     pub rejected_via_version: Vec<CrateMismatch>,\n     pub should_match_name: bool,\n+    pub is_proc_macro: Option<bool>,\n }\n \n pub struct ArchiveMetadata {\n@@ -623,6 +624,12 @@ impl<'a> Context<'a> {\n \n     fn crate_matches(&mut self, metadata: &MetadataBlob, libpath: &Path) -> Option<Svh> {\n         let root = metadata.get_root();\n+        if let Some(is_proc_macro) = self.is_proc_macro {\n+            if root.macro_derive_registrar.is_some() != is_proc_macro {\n+                return None;\n+            }\n+        }\n+\n         let rustc_version = rustc_version();\n         if root.rustc_version != rustc_version {\n             info!(\"Rejecting via version: expected {} got {}\","}, {"sha": "99e7a9042c0ceb939c8a49de6b7d62d87a9e4458", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 48, "deletions": 73, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/0a998b86e977912dfabd4fddb3c7efe87accf2c2/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a998b86e977912dfabd4fddb3c7efe87accf2c2/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=0a998b86e977912dfabd4fddb3c7efe87accf2c2", "patch": "@@ -21,9 +21,9 @@ use Namespace::{self, TypeNS, ValueNS, MacroNS};\n use ResolveResult::Success;\n use {resolve_error, resolve_struct_error, ResolutionError};\n \n-use rustc::middle::cstore::DepKind;\n+use rustc::middle::cstore::{DepKind, LoadedMacro};\n use rustc::hir::def::*;\n-use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, DefIndex, BUILTIN_MACROS_CRATE};\n+use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n use rustc::ty;\n \n use std::cell::Cell;\n@@ -62,7 +62,6 @@ struct LegacyMacroImports {\n     import_all: Option<Span>,\n     imports: Vec<(Name, Span)>,\n     reexports: Vec<(Name, Span)>,\n-    no_link: bool,\n }\n \n impl<'b> Resolver<'b> {\n@@ -213,59 +212,26 @@ impl<'b> Resolver<'b> {\n             }\n \n             ItemKind::ExternCrate(_) => {\n-                let legacy_imports = self.legacy_macro_imports(&item.attrs);\n-                // `#[macro_use]` and `#[macro_reexport]` are only allowed at the crate root.\n-                if self.current_module.parent.is_some() && {\n-                    legacy_imports.import_all.is_some() || !legacy_imports.imports.is_empty() ||\n-                    !legacy_imports.reexports.is_empty()\n-                } {\n-                    span_err!(self.session, item.span, E0468,\n-                              \"an `extern crate` loading macros must be at the crate root\");\n-                }\n-\n-                let load_macros = legacy_imports != LegacyMacroImports::default();\n-                let proc_macros =\n-                    self.crate_loader.process_item(item, &self.definitions, load_macros);\n+                self.crate_loader.process_item(item, &self.definitions);\n \n                 // n.b. we don't need to look at the path option here, because cstore already did\n-                let crate_id = self.session.cstore.extern_mod_stmt_cnum(item.id);\n-                let module = if let Some(crate_id) = crate_id {\n-                    let module = self.get_extern_crate_root(crate_id);\n-                    let binding = (module, sp, ty::Visibility::Public).to_name_binding();\n-                    let binding = self.arenas.alloc_name_binding(binding);\n-                    let directive = self.arenas.alloc_import_directive(ImportDirective {\n-                        id: item.id,\n-                        parent: parent,\n-                        imported_module: Cell::new(Some(module)),\n-                        subclass: ImportDirectiveSubclass::ExternCrate,\n-                        span: item.span,\n-                        module_path: Vec::new(),\n-                        vis: Cell::new(vis),\n-                    });\n-                    let imported_binding = self.import(binding, directive);\n-                    self.define(parent, name, TypeNS, imported_binding);\n-                    self.populate_module_if_necessary(module);\n-                    module\n-                } else {\n-                    // Define a module and populate it with proc macros.\n-                    let module_kind =\n-                        ModuleKind::Def(Def::Mod(self.definitions.local_def_id(item.id)), name);\n-                    let module = self.arenas.alloc_module(ModuleS::new(None, module_kind));\n-                    self.define(parent, name, TypeNS, (module, sp, vis));\n-                    for (name, ext) in proc_macros {\n-                        let def_id = DefId {\n-                            krate: BUILTIN_MACROS_CRATE,\n-                            index: DefIndex::new(self.macro_map.len()),\n-                        };\n-                        self.macro_map.insert(def_id, Rc::new(ext));\n-                        let vis = ty::Visibility::Public;\n-                        self.define(module, name, MacroNS, (Def::Macro(def_id), DUMMY_SP, vis));\n-                    }\n-                    module\n-                };\n-\n-                let allow_shadowing = expansion == Mark::root();\n-                self.process_legacy_macro_imports(module, legacy_imports, allow_shadowing);\n+                let crate_id = self.session.cstore.extern_mod_stmt_cnum(item.id).unwrap();\n+                let module = self.get_extern_crate_root(crate_id);\n+                let binding = (module, sp, ty::Visibility::Public).to_name_binding();\n+                let binding = self.arenas.alloc_name_binding(binding);\n+                let directive = self.arenas.alloc_import_directive(ImportDirective {\n+                    id: item.id,\n+                    parent: parent,\n+                    imported_module: Cell::new(Some(module)),\n+                    subclass: ImportDirectiveSubclass::ExternCrate,\n+                    span: item.span,\n+                    module_path: Vec::new(),\n+                    vis: Cell::new(vis),\n+                });\n+                let imported_binding = self.import(binding, directive);\n+                self.define(parent, name, TypeNS, imported_binding);\n+                self.populate_module_if_necessary(module);\n+                self.process_legacy_macro_imports(item, module, expansion);\n             }\n \n             ItemKind::Mod(..) if item.ident == keywords::Invalid.ident() => {} // Crate root\n@@ -286,9 +252,7 @@ impl<'b> Resolver<'b> {\n                 self.current_module = module;\n             }\n \n-            ItemKind::ForeignMod(..) => {\n-                self.crate_loader.process_item(item, &self.definitions, false);\n-            }\n+            ItemKind::ForeignMod(..) => self.crate_loader.process_item(item, &self.definitions),\n \n             // These items live in the value namespace.\n             ItemKind::Static(_, m, _) => {\n@@ -431,10 +395,10 @@ impl<'b> Resolver<'b> {\n         let name = child.name;\n         let def = child.def;\n         let def_id = def.def_id();\n-        let vis = if parent.is_trait() {\n-            ty::Visibility::Public\n-        } else {\n-            self.session.cstore.visibility(def_id)\n+        let vis = match def {\n+            Def::Macro(..) => ty::Visibility::Public,\n+            _ if parent.is_trait() => ty::Visibility::Public,\n+            _ => self.session.cstore.visibility(def_id),\n         };\n \n         match def {\n@@ -524,7 +488,11 @@ impl<'b> Resolver<'b> {\n             return ext.clone();\n         }\n \n-        let mut macro_rules = self.session.cstore.load_macro(def_id, &self.session);\n+        let mut macro_rules = match self.session.cstore.load_macro(def_id, &self.session) {\n+            LoadedMacro::MacroRules(macro_rules) => macro_rules,\n+            LoadedMacro::ProcMacro(ext) => return ext,\n+        };\n+\n         let mark = Mark::fresh();\n         let invocation = self.arenas.alloc_invocation_data(InvocationData {\n             module: Cell::new(self.get_extern_crate_root(def_id.krate)),\n@@ -561,10 +529,23 @@ impl<'b> Resolver<'b> {\n         }\n     }\n \n-    fn process_legacy_macro_imports(&mut self,\n-                                    module: Module<'b>,\n-                                    legacy_imports: LegacyMacroImports,\n-                                    allow_shadowing: bool) {\n+    fn process_legacy_macro_imports(&mut self, item: &Item, module: Module<'b>, expansion: Mark) {\n+        let allow_shadowing = expansion == Mark::root();\n+        let legacy_imports = self.legacy_macro_imports(&item.attrs);\n+        let cnum = module.def_id().unwrap().krate;\n+\n+        // `#[macro_use]` and `#[macro_reexport]` are only allowed at the crate root.\n+        if self.current_module.parent.is_some() && legacy_imports != LegacyMacroImports::default() {\n+            span_err!(self.session, item.span, E0468,\n+                      \"an `extern crate` loading macros must be at the crate root\");\n+        } else if self.session.cstore.dep_kind(cnum) == DepKind::MacrosOnly &&\n+                  legacy_imports == LegacyMacroImports::default() {\n+            let msg = \"custom derive crates and `#[no_link]` crates have no effect without \\\n+                       `#[macro_use]`\";\n+            self.session.span_warn(item.span, msg);\n+            self.used_crates.insert(cnum); // Avoid the normal unused extern crate warning\n+        }\n+\n         if let Some(span) = legacy_imports.import_all {\n             module.for_each_child(|name, ns, binding| if ns == MacroNS {\n                 self.legacy_import_macro(name, binding.def(), span, allow_shadowing);\n@@ -583,11 +564,7 @@ impl<'b> Resolver<'b> {\n             self.used_crates.insert(module.def_id().unwrap().krate);\n             let result = self.resolve_name_in_module(module, name, MacroNS, false, None);\n             if let Success(binding) = result {\n-                let def = binding.def();\n-                if let Def::Macro(DefId { krate: BUILTIN_MACROS_CRATE, .. }) = def {\n-                    self.session.span_err(span, \"`proc-macro` crates cannot be reexported from\");\n-                }\n-                self.macro_exports.push(Export { name: name, def: def });\n+                self.macro_exports.push(Export { name: name, def: binding.def() });\n             } else {\n                 span_err!(self.session, span, E0470, \"reexported macro not found\");\n             }\n@@ -647,8 +624,6 @@ impl<'b> Resolver<'b> {\n                 } else {\n                     bad_macro_reexport(self, attr.span());\n                 }\n-            } else if attr.check_name(\"no_link\") {\n-                imports.no_link = true;\n             }\n         }\n         imports"}, {"sha": "d0407162793ee98a5a75ef9d52e98c71fd91bc34", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a998b86e977912dfabd4fddb3c7efe87accf2c2/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a998b86e977912dfabd4fddb3c7efe87accf2c2/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=0a998b86e977912dfabd4fddb3c7efe87accf2c2", "patch": "@@ -21,6 +21,7 @@ use syntax_pos::Span;\n use rustc::hir::map as hir_map;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::LOCAL_CRATE;\n+use rustc::middle::cstore::LoadedMacro;\n use rustc::middle::privacy::AccessLevel;\n use rustc::util::nodemap::FxHashSet;\n \n@@ -198,7 +199,12 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     if def_id.krate == LOCAL_CRATE {\n                         continue // These are `krate.exported_macros`, handled in `self.visit()`.\n                     }\n-                    let def = self.cx.sess().cstore.load_macro(def_id, self.cx.sess());\n+                    let def = match self.cx.sess().cstore.load_macro(def_id, self.cx.sess()) {\n+                        LoadedMacro::MacroRules(macro_rules) => macro_rules,\n+                        // FIXME(jseyfried): document proc macro reexports\n+                        LoadedMacro::ProcMacro(..) => continue,\n+                    };\n+\n                     // FIXME(jseyfried) merge with `self.visit_macro()`\n                     let matchers = def.body.chunks(4).map(|arm| arm[0].get_span()).collect();\n                     om.macros.push(Macro {"}, {"sha": "b1d473820f774b1914c37cac18277a1843d28dee", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0a998b86e977912dfabd4fddb3c7efe87accf2c2/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a998b86e977912dfabd4fddb3c7efe87accf2c2/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=0a998b86e977912dfabd4fddb3c7efe87accf2c2", "patch": "@@ -12,10 +12,10 @@\n \n use syntax::ast::{self, MetaItem};\n use syntax::attr::HasAttrs;\n+use syntax::codemap;\n use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxExtension};\n use syntax::ext::build::AstBuilder;\n-use syntax::feature_gate;\n-use syntax::codemap;\n+use syntax::feature_gate::{self, emit_feature_err};\n use syntax::parse::token::{intern, intern_and_get_ident};\n use syntax::ptr::P;\n use syntax_pos::Span;\n@@ -220,6 +220,12 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n                                  .filter(|&(_, ref name)| !is_builtin_trait(&name.name().unwrap()))\n                                  .next();\n     if let Some((i, titem)) = macros_11_derive {\n+        if !cx.ecfg.features.unwrap().proc_macro {\n+            let issue = feature_gate::GateIssue::Language;\n+            let msg = \"custom derive macros are experimentally supported\";\n+            emit_feature_err(cx.parse_sess, \"proc_macro\", titem.span, issue, msg);\n+        }\n+\n         let tname = ast::Ident::with_empty_ctxt(intern(&titem.name().unwrap()));\n         let path = ast::Path::from_ident(titem.span, tname);\n         let ext = cx.resolver.resolve_macro(cx.current_expansion.mark, &path, false).unwrap();"}, {"sha": "8d26207273d4288bd1b53c8809be4c6127821155", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/derive-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a998b86e977912dfabd4fddb3c7efe87accf2c2/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a998b86e977912dfabd4fddb3c7efe87accf2c2/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-a.rs?ref=0a998b86e977912dfabd4fddb3c7efe87accf2c2", "patch": "@@ -21,5 +21,5 @@ use proc_macro::TokenStream;\n \n #[proc_macro_derive(A)]\n pub fn derive_a(input: TokenStream) -> TokenStream {\n-    input\n+    \"\".parse().unwrap()\n }"}, {"sha": "6a8fcdf4ab7826657c7ba19e422f752ea2a1a44a", "filename": "src/test/compile-fail-fulldeps/proc-macro/feature-gate-4.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a998b86e977912dfabd4fddb3c7efe87accf2c2/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Ffeature-gate-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a998b86e977912dfabd4fddb3c7efe87accf2c2/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Ffeature-gate-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Ffeature-gate-4.rs?ref=0a998b86e977912dfabd4fddb3c7efe87accf2c2", "patch": "@@ -12,4 +12,6 @@\n \n #[macro_use]\n extern crate derive_a;\n-//~^ ERROR: loading custom derive macro crates is experimentally supported\n+\n+#[derive(A)] //~ ERROR custom derive macros are experimentally supported\n+struct S;"}, {"sha": "f61b8b4073b6f51aa0275e66645290284014744d", "filename": "src/test/compile-fail-fulldeps/proc-macro/no-macro-use-attr.rs", "status": "renamed", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0a998b86e977912dfabd4fddb3c7efe87accf2c2/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fno-macro-use-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a998b86e977912dfabd4fddb3c7efe87accf2c2/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fno-macro-use-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fno-macro-use-attr.rs?ref=0a998b86e977912dfabd4fddb3c7efe87accf2c2", "patch": "@@ -10,7 +10,10 @@\n \n // aux-build:derive-a.rs\n \n+#![feature(rustc_attrs)]\n+\n extern crate derive_a;\n-//~^ ERROR: crates of the `proc-macro` crate type cannot be linked at runtime\n+//~^ WARN custom derive crates and `#[no_link]` crates have no effect without `#[macro_use]`\n \n-fn main() {}\n+#[rustc_error]\n+fn main() {} //~ ERROR compilation successful", "previous_filename": "src/test/compile-fail-fulldeps/proc-macro/cannot-link.rs"}, {"sha": "dc828fbf7d160ef960c64cfa1370935cfcdd9beb", "filename": "src/test/compile-fail-fulldeps/proc-macro/shadow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a998b86e977912dfabd4fddb3c7efe87accf2c2/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a998b86e977912dfabd4fddb3c7efe87accf2c2/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fshadow.rs?ref=0a998b86e977912dfabd4fddb3c7efe87accf2c2", "patch": "@@ -15,6 +15,6 @@\n #[macro_use]\n extern crate derive_a;\n #[macro_use]\n-extern crate derive_a; //~ ERROR `derive_a` has already been defined\n+extern crate derive_a; //~ ERROR `derive_a` has already been imported\n \n fn main() {}"}, {"sha": "c4737a373992d5658c455303ac703780bdf0fe48", "filename": "src/test/compile-fail/no-link.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a998b86e977912dfabd4fddb3c7efe87accf2c2/src%2Ftest%2Fcompile-fail%2Fno-link.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a998b86e977912dfabd4fddb3c7efe87accf2c2/src%2Ftest%2Fcompile-fail%2Fno-link.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-link.rs?ref=0a998b86e977912dfabd4fddb3c7efe87accf2c2", "patch": "@@ -12,6 +12,7 @@\n \n #[no_link]\n extern crate empty_struct;\n+//~^ WARN custom derive crates and `#[no_link]` crates have no effect without `#[macro_use]`\n \n fn main() {\n     empty_struct::XEmpty1; //~ ERROR unresolved name"}]}