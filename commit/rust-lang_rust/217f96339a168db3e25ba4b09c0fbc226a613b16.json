{"sha": "217f96339a168db3e25ba4b09c0fbc226a613b16", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxN2Y5NjMzOWExNjhkYjNlMjViYTRiMDljMGZiYzIyNmE2MTNiMTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-15T05:57:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-15T05:57:37Z"}, "message": "auto merge of #6224 : erickt/rust/rustc-cleanup, r=erickt\n\nJust a couple minor cleanups and renames of librustc", "tree": {"sha": "51e9c3209df80220435ededee66794ced776d5f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51e9c3209df80220435ededee66794ced776d5f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/217f96339a168db3e25ba4b09c0fbc226a613b16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/217f96339a168db3e25ba4b09c0fbc226a613b16", "html_url": "https://github.com/rust-lang/rust/commit/217f96339a168db3e25ba4b09c0fbc226a613b16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/217f96339a168db3e25ba4b09c0fbc226a613b16/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31cedf6927ae4add985995137c394032b599ea1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/31cedf6927ae4add985995137c394032b599ea1e", "html_url": "https://github.com/rust-lang/rust/commit/31cedf6927ae4add985995137c394032b599ea1e"}, {"sha": "729708d1124bc7318b98b69aadca987e7fe80a8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/729708d1124bc7318b98b69aadca987e7fe80a8d", "html_url": "https://github.com/rust-lang/rust/commit/729708d1124bc7318b98b69aadca987e7fe80a8d"}], "stats": {"total": 1193, "additions": 605, "deletions": 588}, "files": [{"sha": "9426cd6041d918ee76e0c0d1b98fba8e8417bba4", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -100,7 +100,7 @@ pub static tag_mod_impl_trait: uint = 0x47u;\n   different tags.\n  */\n pub static tag_item_impl_method: uint = 0x48u;\n-pub static tag_item_trait_method_self_ty: uint = 0x4b;\n+pub static tag_item_trait_method_explicit_self: uint = 0x4b;\n pub static tag_item_trait_method_self_ty_region: uint = 0x4c;\n \n "}, {"sha": "e6b8432854d32d32e5b93fd7b06ffb050799f81c", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -22,7 +22,7 @@ use syntax::ast_map;\n use syntax::diagnostic::expect;\n \n pub struct ProvidedTraitMethodInfo {\n-    ty: ty::method,\n+    ty: ty::Method,\n     def_id: ast::def_id\n }\n \n@@ -129,17 +129,18 @@ pub fn get_impls_for_mod(cstore: @mut cstore::CStore, def: ast::def_id,\n }\n \n pub fn get_method(tcx: ty::ctxt,\n-                  def: ast::def_id) -> ty::method\n+                  def: ast::def_id) -> ty::Method\n {\n     let cdata = cstore::get_crate_data(tcx.cstore, def.crate);\n     decoder::get_method(tcx.cstore.intr, cdata, def.node, tcx)\n }\n \n-pub fn get_method_name_and_self_ty(cstore: @mut cstore::CStore,\n-                                   def: ast::def_id) -> (ast::ident, ast::self_ty_)\n+pub fn get_method_name_and_explicit_self(cstore: @mut cstore::CStore,\n+                                         def: ast::def_id)\n+                                     -> (ast::ident, ast::explicit_self_)\n {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n-    decoder::get_method_name_and_self_ty(cstore.intr, cdata, def.node)\n+    decoder::get_method_name_and_explicit_self(cstore.intr, cdata, def.node)\n }\n \n pub fn get_trait_method_def_ids(cstore: @mut cstore::CStore,"}, {"sha": "48bfe209f1fddecd0b4be504681ebf5cb26159e6", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 36, "deletions": 34, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -653,7 +653,7 @@ pub fn get_enum_variants(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n                                 item, tcx, cdata);\n         let name = item_name(intr, item);\n         let arg_tys = match ty::get(ctor_ty).sty {\n-          ty::ty_bare_fn(ref f) => f.sig.inputs.map(|a| a.ty),\n+          ty::ty_bare_fn(ref f) => copy f.sig.inputs,\n           _ => ~[], // Nullary enum variant.\n         };\n         match variant_disr_val(item) {\n@@ -670,7 +670,7 @@ pub fn get_enum_variants(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n     return infos;\n }\n \n-fn get_self_ty(item: ebml::Doc) -> ast::self_ty_ {\n+fn get_explicit_self(item: ebml::Doc) -> ast::explicit_self_ {\n     fn get_mutability(ch: u8) -> ast::mutability {\n         match ch as char {\n             'i' => { ast::m_imm }\n@@ -682,11 +682,11 @@ fn get_self_ty(item: ebml::Doc) -> ast::self_ty_ {\n         }\n     }\n \n-    let self_type_doc = reader::get_doc(item, tag_item_trait_method_self_ty);\n-    let string = reader::doc_as_str(self_type_doc);\n+    let explicit_self_doc = reader::get_doc(item, tag_item_trait_method_explicit_self);\n+    let string = reader::doc_as_str(explicit_self_doc);\n \n-    let self_ty_kind = string[0];\n-    match self_ty_kind as char {\n+    let explicit_self_kind = string[0];\n+    match explicit_self_kind as char {\n         's' => { return ast::sty_static; }\n         'v' => { return ast::sty_value; }\n         '@' => { return ast::sty_box(get_mutability(string[1])); }\n@@ -696,7 +696,7 @@ fn get_self_ty(item: ebml::Doc) -> ast::self_ty_ {\n             return ast::sty_region(None, get_mutability(string[1]));\n         }\n         _ => {\n-            fail!(\"unknown self type code: `%c`\", self_ty_kind as char);\n+            fail!(\"unknown self type code: `%c`\", explicit_self_kind as char);\n         }\n     }\n }\n@@ -707,12 +707,12 @@ fn item_impl_methods(intr: @ident_interner, cdata: cmd, item: ebml::Doc,\n     for reader::tagged_docs(item, tag_item_impl_method) |doc| {\n         let m_did = reader::with_doc_data(doc, |d| parse_def_id(d));\n         let mth_item = lookup_item(m_did.node, cdata.data);\n-        let self_ty = get_self_ty(mth_item);\n+        let explicit_self = get_explicit_self(mth_item);\n         rslt.push(@resolve::MethodInfo {\n                     did: translate_def_id(cdata, m_did),\n                     n_tps: item_ty_param_count(mth_item) - base_tps,\n                     ident: item_name(intr, mth_item),\n-                    self_type: self_ty});\n+                    explicit_self: explicit_self});\n     }\n     rslt\n }\n@@ -748,19 +748,19 @@ pub fn get_impls_for_mod(intr: @ident_interner,\n     @result\n }\n \n-pub fn get_method_name_and_self_ty(\n+pub fn get_method_name_and_explicit_self(\n     intr: @ident_interner,\n     cdata: cmd,\n-    id: ast::node_id) -> (ast::ident, ast::self_ty_)\n+    id: ast::node_id) -> (ast::ident, ast::explicit_self_)\n {\n     let method_doc = lookup_item(id, cdata.data);\n     let name = item_name(intr, method_doc);\n-    let self_ty = get_self_ty(method_doc);\n-    (name, self_ty)\n+    let explicit_self = get_explicit_self(method_doc);\n+    (name, explicit_self)\n }\n \n pub fn get_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n-                  tcx: ty::ctxt) -> ty::method\n+                  tcx: ty::ctxt) -> ty::Method\n {\n     let method_doc = lookup_item(id, cdata.data);\n     let def_id = item_def_id(method_doc, cdata);\n@@ -770,19 +770,20 @@ pub fn get_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n     let transformed_self_ty = doc_transformed_self_ty(method_doc, tcx, cdata);\n     let fty = doc_method_fty(method_doc, tcx, cdata);\n     let vis = item_visibility(method_doc);\n-    let self_ty = get_self_ty(method_doc);\n-    ty::method {\n-        ident: name,\n-        generics: ty::Generics {\n+    let explicit_self = get_explicit_self(method_doc);\n+\n+    ty::Method::new(\n+        name,\n+        ty::Generics {\n             type_param_defs: type_param_defs,\n             region_param: None\n         },\n-        transformed_self_ty: transformed_self_ty,\n-        fty: fty,\n-        self_ty: self_ty,\n-        vis: vis,\n-        def_id: def_id\n-    }\n+        transformed_self_ty,\n+        fty,\n+        explicit_self,\n+        vis,\n+        def_id\n+    )\n }\n \n pub fn get_trait_method_def_ids(cdata: cmd,\n@@ -823,19 +824,20 @@ pub fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n         };\n \n         let transformed_self_ty = doc_transformed_self_ty(mth, tcx, cdata);\n-        let self_ty = get_self_ty(mth);\n-        let ty_method = ty::method {\n-            ident: name,\n-            generics: ty::Generics {\n+        let explicit_self = get_explicit_self(mth);\n+\n+        let ty_method = ty::Method::new(\n+            name,\n+            ty::Generics {\n                 type_param_defs: type_param_defs,\n                 region_param: None\n             },\n-            transformed_self_ty: transformed_self_ty,\n-            fty: fty,\n-            self_ty: self_ty,\n-            vis: ast::public,\n-            def_id: did\n-        };\n+            transformed_self_ty,\n+            fty,\n+            explicit_self,\n+            ast::public,\n+            did\n+        );\n         let provided_trait_method_info = ProvidedTraitMethodInfo {\n             ty: ty_method,\n             def_id: did"}, {"sha": "d27bfd081bc65708fe2ebcbce6fa7b99efdf12dc", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -366,7 +366,7 @@ fn encode_path(ecx: @EncodeContext,\n fn encode_reexported_static_method(ecx: @EncodeContext,\n                                    ebml_w: &mut writer::Encoder,\n                                    exp: &middle::resolve::Export2,\n-                                   m: @ty::method) {\n+                                   m: @ty::Method) {\n     debug!(\"(encode static trait method) reexport '%s::%s'\",\n             *exp.name, *ecx.tcx.sess.str_of(m.ident));\n     ebml_w.start_tag(tag_items_data_item_reexport);\n@@ -389,7 +389,7 @@ fn encode_reexported_static_methods(ecx: @EncodeContext,\n                 Some(&ast_map::node_item(_, path)) => {\n                     if mod_path != *path {\n                         for methods.each |&m| {\n-                            if m.self_ty  == ast::sty_static {\n+                            if m.explicit_self == ast::sty_static {\n                                 encode_reexported_static_method(ecx,\n                                                                 ebml_w,\n                                                                 exp, m);\n@@ -486,11 +486,11 @@ fn encode_visibility(ebml_w: &mut writer::Encoder, visibility: visibility) {\n     ebml_w.end_tag();\n }\n \n-fn encode_self_type(ebml_w: &mut writer::Encoder, self_type: ast::self_ty_) {\n-    ebml_w.start_tag(tag_item_trait_method_self_ty);\n+fn encode_explicit_self(ebml_w: &mut writer::Encoder, explicit_self: ast::explicit_self_) {\n+    ebml_w.start_tag(tag_item_trait_method_explicit_self);\n \n     // Encode the base self type.\n-    match self_type {\n+    match explicit_self {\n         sty_static => {\n             ebml_w.writer.write(&[ 's' as u8 ]);\n         }\n@@ -625,7 +625,7 @@ fn encode_info_for_struct_ctor(ecx: @EncodeContext,\n \n fn encode_method_ty_fields(ecx: @EncodeContext,\n                            ebml_w: &mut writer::Encoder,\n-                           method_ty: &ty::method) {\n+                           method_ty: &ty::Method) {\n     encode_def_id(ebml_w, method_ty.def_id);\n     encode_name(ecx, ebml_w, method_ty.ident);\n     encode_ty_type_param_defs(ebml_w, ecx,\n@@ -634,7 +634,7 @@ fn encode_method_ty_fields(ecx: @EncodeContext,\n     encode_transformed_self_ty(ecx, ebml_w, method_ty.transformed_self_ty);\n     encode_method_fty(ecx, ebml_w, &method_ty.fty);\n     encode_visibility(ebml_w, method_ty.vis);\n-    encode_self_type(ebml_w, method_ty.self_ty);\n+    encode_explicit_self(ebml_w, method_ty.explicit_self);\n }\n \n fn encode_info_for_method(ecx: @EncodeContext,\n@@ -652,10 +652,10 @@ fn encode_info_for_method(ecx: @EncodeContext,\n     ebml_w.start_tag(tag_items_data_item);\n \n     let method_def_id = local_def(m.id);\n-    let method_ty: @ty::method = ty::method(ecx.tcx, method_def_id);\n+    let method_ty = ty::method(ecx.tcx, method_def_id);\n     encode_method_ty_fields(ecx, ebml_w, method_ty);\n \n-    match m.self_ty.node {\n+    match m.explicit_self.node {\n         ast::sty_static => {\n             encode_family(ebml_w, purity_static_method_family(m.purity));\n         }\n@@ -948,7 +948,7 @@ fn encode_info_for_item(ecx: @EncodeContext,\n         for ty::trait_method_def_ids(tcx, local_def(item.id)).eachi |i, &method_def_id| {\n             assert!(method_def_id.crate == ast::local_crate);\n \n-            let method_ty: @ty::method = ty::method(tcx, method_def_id);\n+            let method_ty = ty::method(tcx, method_def_id);\n \n             index.push(entry {val: method_def_id.node, pos: ebml_w.writer.tell()});\n \n@@ -962,7 +962,7 @@ fn encode_info_for_item(ecx: @EncodeContext,\n             trait_path.push(ast_map::path_name(item.ident));\n             encode_path(ecx, ebml_w, trait_path, ast_map::path_name(method_ty.ident));\n \n-            match method_ty.self_ty {\n+            match method_ty.explicit_self {\n                 sty_static => {\n                     encode_family(ebml_w,\n                                   purity_static_method_family(\n@@ -991,7 +991,7 @@ fn encode_info_for_item(ecx: @EncodeContext,\n                     // This is obviously a bogus assert but I don't think this\n                     // ever worked before anyhow...near as I can tell, before\n                     // we would emit two items.\n-                    if method_ty.self_ty == sty_static {\n+                    if method_ty.explicit_self == sty_static {\n                         tcx.sess.span_unimpl(\n                             item.span,\n                             fmt!(\"Method %s is both provided and static\","}, {"sha": "5c82894c1509341fba066ef4e70c27d2054d257e", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -126,12 +126,6 @@ pub fn parse_trait_ref_data(data: @~[u8], crate_num: int, pos: uint, tcx: ty::ct\n     parse_trait_ref(st, conv)\n }\n \n-pub fn parse_arg_data(data: @~[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n-                      conv: conv_did) -> ty::arg {\n-    let st = parse_state_from_data(data, crate_num, pos, tcx);\n-    parse_arg(st, conv)\n-}\n-\n fn parse_path(st: @mut PState) -> @ast::Path {\n     let mut idents: ~[ast::ident] = ~[];\n     fn is_last(c: char) -> bool { return c == '(' || c == ':'; }\n@@ -471,12 +465,6 @@ fn parse_onceness(c: char) -> ast::Onceness {\n     }\n }\n \n-fn parse_arg(st: @mut PState, conv: conv_did) -> ty::arg {\n-    ty::arg {\n-        ty: parse_ty(st, conv)\n-    }\n-}\n-\n fn parse_closure_ty(st: @mut PState, conv: conv_did) -> ty::ClosureTy {\n     let sigil = parse_sigil(st);\n     let purity = parse_purity(next(st));\n@@ -505,9 +493,9 @@ fn parse_bare_fn_ty(st: @mut PState, conv: conv_did) -> ty::BareFnTy {\n \n fn parse_sig(st: @mut PState, conv: conv_did) -> ty::FnSig {\n     assert!((next(st) == '['));\n-    let mut inputs: ~[ty::arg] = ~[];\n+    let mut inputs = ~[];\n     while peek(st) != ']' {\n-        inputs.push(ty::arg { ty: parse_ty(st, conv) });\n+        inputs.push(parse_ty(st, conv));\n     }\n     st.pos += 1u; // eat the ']'\n     let ret_ty = parse_ty(st, conv);"}, {"sha": "2cb95e1a2fc00b263e385a91f647fb7fb0590975", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -344,10 +344,6 @@ fn enc_sigil(w: @io::Writer, sigil: Sigil) {\n     }\n }\n \n-pub fn enc_arg(w: @io::Writer, cx: @ctxt, arg: ty::arg) {\n-    enc_ty(w, cx, arg.ty);\n-}\n-\n fn enc_purity(w: @io::Writer, p: purity) {\n     match p {\n       pure_fn => w.write_char('p'),\n@@ -389,8 +385,8 @@ fn enc_closure_ty(w: @io::Writer, cx: @ctxt, ft: &ty::ClosureTy) {\n \n fn enc_fn_sig(w: @io::Writer, cx: @ctxt, fsig: &ty::FnSig) {\n     w.write_char('[');\n-    for fsig.inputs.each |arg| {\n-        enc_arg(w, cx, *arg);\n+    for fsig.inputs.each |ty| {\n+        enc_ty(w, cx, *ty);\n     }\n     w.write_char(']');\n     enc_ty(w, cx, fsig.output);"}, {"sha": "2996c4c8476dc8c0596ad7f3d842d379cef16800", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 6, "deletions": 25, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -526,8 +526,8 @@ fn encode_method_map_entry(ecx: @e::EncodeContext,\n                            ebml_w: &mut writer::Encoder,\n                            mme: method_map_entry) {\n     do ebml_w.emit_struct(\"method_map_entry\", 3) |ebml_w| {\n-        do ebml_w.emit_struct_field(\"self_arg\", 0u) |ebml_w| {\n-            ebml_w.emit_arg(ecx, mme.self_arg);\n+        do ebml_w.emit_struct_field(\"self_ty\", 0u) |ebml_w| {\n+            ebml_w.emit_ty(ecx, mme.self_ty);\n         }\n         do ebml_w.emit_struct_field(\"explicit_self\", 2u) |ebml_w| {\n             mme.explicit_self.encode(ebml_w);\n@@ -546,14 +546,14 @@ impl read_method_map_entry_helper for reader::Decoder {\n                              -> method_map_entry {\n         do self.read_struct(\"method_map_entry\", 3) |this| {\n             method_map_entry {\n-                self_arg: this.read_struct_field(\"self_arg\", 0, |this| {\n-                    this.read_arg(xcx)\n+                self_ty: this.read_struct_field(\"self_ty\", 0u, |this| {\n+                    this.read_ty(xcx)\n                 }),\n                 explicit_self: this.read_struct_field(\"explicit_self\",\n                                                       2,\n                                                       |this| {\n-                    let self_type: ast::self_ty_ = Decodable::decode(this);\n-                    self_type\n+                    let explicit_self: ast::explicit_self_ = Decodable::decode(this);\n+                    explicit_self\n                 }),\n                 origin: this.read_struct_field(\"origin\", 1, |this| {\n                     let method_origin: method_origin =\n@@ -712,7 +712,6 @@ impl get_ty_str_ctxt for e::EncodeContext {\n }\n \n trait ebml_writer_helpers {\n-    fn emit_arg(&mut self, ecx: @e::EncodeContext, arg: ty::arg);\n     fn emit_ty(&mut self, ecx: @e::EncodeContext, ty: ty::t);\n     fn emit_vstore(&mut self, ecx: @e::EncodeContext, vstore: ty::vstore);\n     fn emit_tys(&mut self, ecx: @e::EncodeContext, tys: &[ty::t]);\n@@ -737,12 +736,6 @@ impl ebml_writer_helpers for writer::Encoder {\n         }\n     }\n \n-    fn emit_arg(&mut self, ecx: @e::EncodeContext, arg: ty::arg) {\n-        do self.emit_opaque |this| {\n-            tyencode::enc_arg(this.writer, ecx.ty_str_ctxt(), arg);\n-        }\n-    }\n-\n     fn emit_tys(&mut self, ecx: @e::EncodeContext, tys: &[ty::t]) {\n         do self.emit_from_vec(tys) |this, ty| {\n             this.emit_ty(ecx, *ty)\n@@ -943,7 +936,6 @@ impl doc_decoder_helpers for ebml::Doc {\n }\n \n trait ebml_decoder_decoder_helpers {\n-    fn read_arg(&mut self, xcx: @ExtendedDecodeContext) -> ty::arg;\n     fn read_ty(&mut self, xcx: @ExtendedDecodeContext) -> ty::t;\n     fn read_tys(&mut self, xcx: @ExtendedDecodeContext) -> ~[ty::t];\n     fn read_type_param_def(&mut self, xcx: @ExtendedDecodeContext)\n@@ -958,17 +950,6 @@ trait ebml_decoder_decoder_helpers {\n }\n \n impl ebml_decoder_decoder_helpers for reader::Decoder {\n-    fn read_arg(&mut self, xcx: @ExtendedDecodeContext) -> ty::arg {\n-        do self.read_opaque |this, doc| {\n-            tydecode::parse_arg_data(\n-                doc.data,\n-                xcx.dcx.cdata.cnum,\n-                doc.start,\n-                xcx.dcx.tcx,\n-                |s, a| this.convert_def_id(xcx, s, a))\n-        }\n-    }\n-\n     fn read_ty(&mut self, xcx: @ExtendedDecodeContext) -> ty::t {\n         // Note: regions types embed local node ids.  In principle, we\n         // should translate these node ids into the new decode"}, {"sha": "9995de24e8db29d37265a074eadb4d5d7f253719", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -381,7 +381,7 @@ fn visit_fn(fk: &visit::fn_kind,\n     // Add `this`, whether explicit or implicit.\n     match *fk {\n         fk_method(_, _, method) => {\n-            match method.self_ty.node {\n+            match method.explicit_self.node {\n                 sty_value | sty_region(*) | sty_box(_) | sty_uniq(_) => {\n                     fn_maps.add_variable(Arg(method.self_id,\n                                              special_idents::self_));"}, {"sha": "91f565bcae6259d8f93e6e8e3ae2ed2e1d28166b", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -10,7 +10,7 @@\n \n use driver::session::Session;\n use metadata::csearch::{each_path, get_trait_method_def_ids};\n-use metadata::csearch::get_method_name_and_self_ty;\n+use metadata::csearch::get_method_name_and_explicit_self;\n use metadata::csearch::get_static_methods_if_impl;\n use metadata::csearch::get_type_name_if_impl;\n use metadata::cstore::find_extern_mod_stmt_cnum;\n@@ -28,7 +28,7 @@ use syntax::ast::{def_const, def_foreign_mod, def_fn, def_id, def_label};\n use syntax::ast::{def_local, def_mod, def_prim_ty, def_region, def_self};\n use syntax::ast::{def_self_ty, def_static_method, def_struct, def_ty};\n use syntax::ast::{def_ty_param, def_typaram_binder, def_trait};\n-use syntax::ast::{def_upvar, def_use, def_variant, expr, expr_assign_op};\n+use syntax::ast::{def_upvar, def_use, def_variant, explicit_self_, expr, expr_assign_op};\n use syntax::ast::{expr_binary, expr_break, expr_field};\n use syntax::ast::{expr_fn_block, expr_index, expr_method_call, expr_path};\n use syntax::ast::{def_prim_ty, def_region, def_self, def_ty, def_ty_param};\n@@ -45,7 +45,7 @@ use syntax::ast::{local, local_crate, lt, method, mul};\n use syntax::ast::{named_field, ne, neg, node_id, pat, pat_enum, pat_ident};\n use syntax::ast::{Path, pat_lit, pat_range, pat_struct};\n use syntax::ast::{prim_ty, private, provided};\n-use syntax::ast::{public, required, rem, self_ty_, shl, shr, stmt_decl};\n+use syntax::ast::{public, required, rem, shl, shr, stmt_decl};\n use syntax::ast::{struct_field, struct_variant_kind};\n use syntax::ast::{sty_static, subtract, trait_ref, tuple_variant_kind, Ty};\n use syntax::ast::{ty_bool, ty_char, ty_f, ty_f32, ty_f64, ty_float, ty_i};\n@@ -96,7 +96,7 @@ pub struct MethodInfo {\n     did: def_id,\n     n_tps: uint,\n     ident: ident,\n-    self_type: self_ty_\n+    explicit_self: explicit_self_\n }\n \n pub struct Impl {\n@@ -1203,7 +1203,7 @@ pub impl Resolver {\n                 // Bail out early if there are no static methods.\n                 let mut has_static_methods = false;\n                 for methods.each |method| {\n-                    match method.self_ty.node {\n+                    match method.explicit_self.node {\n                         sty_static => has_static_methods = true,\n                         _ => {}\n                     }\n@@ -1236,7 +1236,7 @@ pub impl Resolver {\n \n                         // For each static method...\n                         for methods.each |method| {\n-                            match method.self_ty.node {\n+                            match method.explicit_self.node {\n                                 sty_static => {\n                                     // Add the static method to the\n                                     // module.\n@@ -1274,7 +1274,7 @@ pub impl Resolver {\n                 let mut has_static_methods = false;\n                 for (*methods).each |method| {\n                     let ty_m = trait_method_to_ty_method(method);\n-                    match ty_m.self_ty.node {\n+                    match ty_m.explicit_self.node {\n                         sty_static => {\n                             has_static_methods = true;\n                             break;\n@@ -1306,7 +1306,7 @@ pub impl Resolver {\n                     let ident = ty_m.ident;\n                     // Add it to the trait info if not static,\n                     // add it as a name in the trait module otherwise.\n-                    match ty_m.self_ty.node {\n+                    match ty_m.explicit_self.node {\n                         sty_static => {\n                             let def = def_static_method(\n                                 local_def(ty_m.id),\n@@ -1612,17 +1612,17 @@ pub impl Resolver {\n                                                             def_id);\n               let mut interned_method_names = HashSet::new();\n               for method_def_ids.each |&method_def_id| {\n-                  let (method_name, self_ty) =\n-                      get_method_name_and_self_ty(self.session.cstore,\n-                                                  method_def_id);\n+                  let (method_name, explicit_self) =\n+                      get_method_name_and_explicit_self(self.session.cstore,\n+                                                        method_def_id);\n \n                   debug!(\"(building reduced graph for \\\n                           external crate) ... adding \\\n                           trait method '%s'\",\n                          *self.session.str_of(method_name));\n \n                   // Add it to the trait info if not static.\n-                  if self_ty != sty_static {\n+                  if explicit_self != sty_static {\n                       interned_method_names.insert(method_name);\n                   }\n               }\n@@ -3774,7 +3774,7 @@ pub impl Resolver {\n                               outer_type_parameter_count,\n                               rib_kind);\n         // we only have self ty if it is a non static method\n-        let self_binding = match method.self_ty.node {\n+        let self_binding = match method.explicit_self.node {\n           sty_static => { NoSelfBinding }\n           _ => { HasSelfBinding(method.self_id, false) }\n         };"}, {"sha": "773de1577f703eca9c97ef30eb7a14dd706e801d", "filename": "src/librustc/middle/resolve_stage0.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -11,7 +11,7 @@\n use driver::session;\n use driver::session::Session;\n use metadata::csearch::{each_path, get_trait_method_def_ids};\n-use metadata::csearch::get_method_name_and_self_ty;\n+use metadata::csearch::get_method_name_and_explicit_self;\n use metadata::csearch::get_static_methods_if_impl;\n use metadata::csearch::get_type_name_if_impl;\n use metadata::cstore::find_extern_mod_stmt_cnum;\n@@ -46,7 +46,7 @@ use syntax::ast::{local, local_crate, lt, method, mul};\n use syntax::ast::{named_field, ne, neg, node_id, pat, pat_enum, pat_ident};\n use syntax::ast::{Path, pat_lit, pat_range, pat_struct};\n use syntax::ast::{prim_ty, private, provided};\n-use syntax::ast::{public, required, rem, self_ty_, shl, shr, stmt_decl};\n+use syntax::ast::{public, required, rem, explicit_self_, shl, shr, stmt_decl};\n use syntax::ast::{struct_field, struct_variant_kind};\n use syntax::ast::{sty_static, subtract, trait_ref, tuple_variant_kind, Ty};\n use syntax::ast::{ty_bool, ty_char, ty_f, ty_f32, ty_f64, ty_float, ty_i};\n@@ -97,7 +97,7 @@ pub struct MethodInfo {\n     did: def_id,\n     n_tps: uint,\n     ident: ident,\n-    self_type: self_ty_\n+    explicit_self: explicit_self_\n }\n \n pub struct Impl {\n@@ -1219,7 +1219,7 @@ pub impl Resolver {\n                 // Bail out early if there are no static methods.\n                 let mut has_static_methods = false;\n                 for methods.each |method| {\n-                    match method.self_ty.node {\n+                    match method.explicit_self.node {\n                         sty_static => has_static_methods = true,\n                         _ => {}\n                     }\n@@ -1252,7 +1252,7 @@ pub impl Resolver {\n \n                         // For each static method...\n                         for methods.each |method| {\n-                            match method.self_ty.node {\n+                            match method.explicit_self.node {\n                                 sty_static => {\n                                     // Add the static method to the\n                                     // module.\n@@ -1290,7 +1290,7 @@ pub impl Resolver {\n                 let mut has_static_methods = false;\n                 for (*methods).each |method| {\n                     let ty_m = trait_method_to_ty_method(method);\n-                    match ty_m.self_ty.node {\n+                    match ty_m.explicit_self.node {\n                         sty_static => {\n                             has_static_methods = true;\n                             break;\n@@ -1322,7 +1322,7 @@ pub impl Resolver {\n                     let ident = ty_m.ident;\n                     // Add it to the trait info if not static,\n                     // add it as a name in the trait module otherwise.\n-                    match ty_m.self_ty.node {\n+                    match ty_m.explicit_self.node {\n                         sty_static => {\n                             let def = def_static_method(\n                                 local_def(ty_m.id),\n@@ -1628,17 +1628,17 @@ pub impl Resolver {\n                                                             def_id);\n               let mut interned_method_names = HashSet::new();\n               for method_def_ids.each |&method_def_id| {\n-                  let (method_name, self_ty) =\n-                      get_method_name_and_self_ty(self.session.cstore,\n-                                                  method_def_id);\n+                  let (method_name, explicit_self) =\n+                      get_method_name_and_explicit_self(self.session.cstore,\n+                                                        method_def_id);\n \n                   debug!(\"(building reduced graph for \\\n                           external crate) ... adding \\\n                           trait method '%s'\",\n                          *self.session.str_of(method_name));\n \n                   // Add it to the trait info if not static.\n-                  if self_ty != sty_static {\n+                  if explicit_self != sty_static {\n                       interned_method_names.insert(method_name);\n                   }\n               }\n@@ -3800,7 +3800,7 @@ pub impl Resolver {\n                               outer_type_parameter_count,\n                               rib_kind);\n         // we only have self ty if it is a non static method\n-        let self_binding = match method.self_ty.node {\n+        let self_binding = match method.explicit_self.node {\n           sty_static => { NoSelfBinding }\n           _ => { HasSelfBinding(method.self_id, false) }\n         };"}, {"sha": "9211939cd2af7297f256bfa6296f61c912700c12", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -32,12 +32,9 @@ pub fn trans_inline_asm(bcx: block, ia: &ast::inline_asm) -> block {\n     let outputs = do ia.outputs.map |&(c, out)| {\n         constraints.push(copy *c);\n \n-        let aoutty = ty::arg {\n-            ty: expr_ty(bcx, out)\n-        };\n         aoutputs.push(unpack_result!(bcx, {\n             callee::trans_arg_expr(bcx,\n-                                   aoutty,\n+                                   expr_ty(bcx, out),\n                                    ty::ByCopy,\n                                    out,\n                                    &mut cleanups,\n@@ -50,13 +47,9 @@ pub fn trans_inline_asm(bcx: block, ia: &ast::inline_asm) -> block {\n             _ => fail!(\"Expression must be addr of\")\n         };\n \n-        let outty = ty::arg {\n-            ty: expr_ty(bcx, e)\n-        };\n-\n         unpack_result!(bcx, {\n             callee::trans_arg_expr(bcx,\n-                                   outty,\n+                                   expr_ty(bcx, e),\n                                    ty::ByCopy,\n                                    e,\n                                    &mut cleanups,\n@@ -75,13 +68,9 @@ pub fn trans_inline_asm(bcx: block, ia: &ast::inline_asm) -> block {\n     let inputs = do ia.inputs.map |&(c, in)| {\n         constraints.push(copy *c);\n \n-        let inty = ty::arg {\n-            ty: expr_ty(bcx, in)\n-        };\n-\n         unpack_result!(bcx, {\n             callee::trans_arg_expr(bcx,\n-                                   inty,\n+                                   expr_ty(bcx, in),\n                                    ty::ByCopy,\n                                    in,\n                                    &mut cleanups,"}, {"sha": "e14d6d79ab51d11410ff831605e6ff5bf9b371d2", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -1664,12 +1664,12 @@ pub fn new_fn_ctxt(ccx: @CrateContext,\n // the function's fn_ctxt).  create_llargs_for_fn_args populates the llargs\n // field of the fn_ctxt with\n pub fn create_llargs_for_fn_args(cx: fn_ctxt,\n-                                 ty_self: self_arg,\n+                                 self_arg: self_arg,\n                                  args: &[ast::arg])\n                               -> ~[ValueRef] {\n     let _icx = cx.insn_ctxt(\"create_llargs_for_fn_args\");\n \n-    match ty_self {\n+    match self_arg {\n       impl_self(tt) => {\n         cx.llself = Some(ValSelfData {\n             v: cx.llenv,\n@@ -1701,7 +1701,7 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n                             bcx: block,\n                             args: &[ast::arg],\n                             raw_llargs: &[ValueRef],\n-                            arg_tys: &[ty::arg]) -> block {\n+                            arg_tys: &[ty::t]) -> block {\n     let _icx = fcx.insn_ctxt(\"copy_args_to_allocas\");\n     let mut bcx = bcx;\n \n@@ -1720,7 +1720,7 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n     }\n \n     for uint::range(0, arg_tys.len()) |arg_n| {\n-        let arg_ty = &arg_tys[arg_n];\n+        let arg_ty = arg_tys[arg_n];\n         let raw_llarg = raw_llargs[arg_n];\n         let arg_id = args[arg_n].id;\n \n@@ -1732,15 +1732,15 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n         // This alloca should be optimized away by LLVM's mem-to-reg pass in\n         // the event it's not truly needed.\n         // only by value if immediate:\n-        let llarg = if datum::appropriate_mode(arg_ty.ty).is_by_value() {\n-            let alloc = alloc_ty(bcx, arg_ty.ty);\n+        let llarg = if datum::appropriate_mode(arg_ty).is_by_value() {\n+            let alloc = alloc_ty(bcx, arg_ty);\n             Store(bcx, raw_llarg, alloc);\n             alloc\n         } else {\n             raw_llarg\n         };\n \n-        add_clean(bcx, llarg, arg_ty.ty);\n+        add_clean(bcx, llarg, arg_ty);\n \n         bcx = _match::bind_irrefutable_pat(bcx,\n                                           args[arg_n].pat,\n@@ -1801,7 +1801,7 @@ pub fn trans_closure(ccx: @CrateContext,\n                      decl: &ast::fn_decl,\n                      body: &ast::blk,\n                      llfndecl: ValueRef,\n-                     ty_self: self_arg,\n+                     self_arg: self_arg,\n                      param_substs: Option<@param_substs>,\n                      id: ast::node_id,\n                      impl_id: Option<ast::def_id>,\n@@ -1825,7 +1825,7 @@ pub fn trans_closure(ccx: @CrateContext,\n                                impl_id,\n                                param_substs,\n                                Some(body.span));\n-    let raw_llargs = create_llargs_for_fn_args(fcx, ty_self, decl.inputs);\n+    let raw_llargs = create_llargs_for_fn_args(fcx, self_arg, decl.inputs);\n \n     // Set the fixed stack segment flag if necessary.\n     if attr::attrs_contains_name(attributes, \"fixed_stack_segment\") {\n@@ -1882,16 +1882,16 @@ pub fn trans_fn(ccx: @CrateContext,\n                 decl: &ast::fn_decl,\n                 body: &ast::blk,\n                 llfndecl: ValueRef,\n-                ty_self: self_arg,\n+                self_arg: self_arg,\n                 param_substs: Option<@param_substs>,\n                 id: ast::node_id,\n                 impl_id: Option<ast::def_id>,\n                 attrs: &[ast::attribute]) {\n     let do_time = ccx.sess.trans_stats();\n     let start = if do_time { time::get_time() }\n                 else { time::Timespec::new(0, 0) };\n-    debug!(\"trans_fn(ty_self=%?, param_substs=%s)\",\n-           ty_self,\n+    debug!(\"trans_fn(self_arg=%?, param_substs=%s)\",\n+           self_arg,\n            param_substs.repr(ccx.tcx));\n     let _icx = ccx.insn_ctxt(\"trans_fn\");\n     ccx.stats.n_fns += 1;\n@@ -1902,7 +1902,7 @@ pub fn trans_fn(ccx: @CrateContext,\n                   decl,\n                   body,\n                   llfndecl,\n-                  ty_self,\n+                  self_arg,\n                   param_substs,\n                   id,\n                   impl_id,\n@@ -1987,7 +1987,7 @@ pub fn trans_enum_variant(ccx: @CrateContext,\n             Some(&local_mem(x)) => x,\n             _ => fail!(\"trans_enum_variant: how do we know this works?\"),\n         };\n-        let arg_ty = arg_tys[i].ty;\n+        let arg_ty = arg_tys[i];\n         memcpy_ty(bcx, lldestptr, llarg, arg_ty);\n     }\n     build_return(bcx);\n@@ -2061,7 +2061,7 @@ pub fn trans_tuple_struct(ccx: @CrateContext,\n                                    local_mem\")\n             }\n         };\n-        let arg_ty = arg_tys[i].ty;\n+        let arg_ty = arg_tys[i];\n         memcpy_ty(bcx, lldestptr, llarg, arg_ty);\n     }\n "}, {"sha": "dc81a9805887b1c4d440997458a4b9333db1be4b", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -674,7 +674,7 @@ pub enum AutorefArg {\n // temp_cleanups: cleanups that should run only if failure occurs before the\n // call takes place:\n pub fn trans_arg_expr(bcx: block,\n-                      formal_ty: ty::arg,\n+                      formal_arg_ty: ty::t,\n                       self_mode: ty::SelfMode,\n                       arg_expr: @ast::expr,\n                       temp_cleanups: &mut ~[ValueRef],\n@@ -683,9 +683,9 @@ pub fn trans_arg_expr(bcx: block,\n     let _icx = bcx.insn_ctxt(\"trans_arg_expr\");\n     let ccx = bcx.ccx();\n \n-    debug!(\"trans_arg_expr(formal_ty=(%s), self_mode=%?, arg_expr=%s, \\\n+    debug!(\"trans_arg_expr(formal_arg_ty=(%s), self_mode=%?, arg_expr=%s, \\\n             ret_flag=%?)\",\n-           formal_ty.ty.repr(bcx.tcx()),\n+           formal_arg_ty.repr(bcx.tcx()),\n            self_mode,\n            arg_expr.repr(bcx.tcx()),\n            ret_flag.map(|v| bcx.val_str(*v)));\n@@ -734,9 +734,9 @@ pub fn trans_arg_expr(bcx: block,\n         // \"undef\" value, as such a value should never\n         // be inspected. It's important for the value\n         // to have type lldestty (the callee's expected type).\n-        let llformal_ty = type_of::type_of(ccx, formal_ty.ty);\n+        let llformal_arg_ty = type_of::type_of(ccx, formal_arg_ty);\n         unsafe {\n-            val = llvm::LLVMGetUndef(llformal_ty);\n+            val = llvm::LLVMGetUndef(llformal_arg_ty);\n         }\n     } else {\n         // FIXME(#3548) use the adjustments table\n@@ -784,16 +784,16 @@ pub fn trans_arg_expr(bcx: block,\n             }\n         }\n \n-        if formal_ty.ty != arg_datum.ty {\n+        if formal_arg_ty != arg_datum.ty {\n             // this could happen due to e.g. subtyping\n-            let llformal_ty = type_of::type_of_explicit_arg(ccx, &formal_ty);\n-            let llformal_ty = match self_mode {\n-                ty::ByRef => T_ptr(llformal_ty),\n-                ty::ByCopy => llformal_ty,\n+            let llformal_arg_ty = type_of::type_of_explicit_arg(ccx, &formal_arg_ty);\n+            let llformal_arg_ty = match self_mode {\n+                ty::ByRef => T_ptr(llformal_arg_ty),\n+                ty::ByCopy => llformal_arg_ty,\n             };\n             debug!(\"casting actual type (%s) to match formal (%s)\",\n-                   bcx.val_str(val), bcx.llty_str(llformal_ty));\n-            val = PointerCast(bcx, val, llformal_ty);\n+                   bcx.val_str(val), bcx.llty_str(llformal_arg_ty));\n+            val = PointerCast(bcx, val, llformal_arg_ty);\n         }\n     }\n "}, {"sha": "d8252a449ba0dba12c49e5b696d18be5a8f14c99", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -785,7 +785,7 @@ fn create_ty(cx: @CrateContext, t: ty::t, span: span)\n             cx.sess.span_bug(span, \"debuginfo for rptr NYI\")\n         },\n         ty::ty_bare_fn(ref barefnty) => {\n-            let inputs = do barefnty.sig.inputs.map |a| { a.ty };\n+            let inputs = barefnty.sig.inputs.map(|a| *a);\n             let output = barefnty.sig.output;\n             create_fn_ty(cx, t, inputs, output, span)\n         },"}, {"sha": "e5bbe50007e8176dbd871412a350fbd26c7e3256", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -29,7 +29,7 @@ use middle::trans::machine;\n use middle::trans::type_of::*;\n use middle::trans::type_of;\n use middle::ty;\n-use middle::ty::{FnSig, arg};\n+use middle::ty::FnSig;\n use util::ppaux::ty_to_str;\n \n use syntax::codemap::span;\n@@ -94,7 +94,7 @@ fn foreign_signature(ccx: @CrateContext, fn_sig: &ty::FnSig)\n      * values by pointer like we do.\n      */\n \n-    let llarg_tys = fn_sig.inputs.map(|arg| type_of(ccx, arg.ty));\n+    let llarg_tys = fn_sig.inputs.map(|arg_ty| type_of(ccx, *arg_ty));\n     let llret_ty = type_of::type_of(ccx, fn_sig.output);\n     LlvmSignature {\n         llarg_tys: llarg_tys,\n@@ -820,7 +820,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                 region: ty::re_bound(ty::br_anon(0)),\n                 sig: FnSig {\n                     bound_lifetime_names: opt_vec::Empty,\n-                    inputs: ~[ arg { ty: star_u8 } ],\n+                    inputs: ~[ star_u8 ],\n                     output: ty::mk_nil()\n                 }\n             });"}, {"sha": "10e019b2a376c332e7a2aba8e49cc238cdc6af90", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -99,14 +99,14 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::def_id,\n               let path = vec::append(\n                   ty::item_path(ccx.tcx, impl_did),\n                   ~[path_name(mth.ident)]);\n-              let self_kind = match mth.self_ty.node {\n+              let self_kind = match mth.explicit_self.node {\n                   ast::sty_static => no_self,\n                   _ => {\n                       let self_ty = ty::node_id_to_type(ccx.tcx,\n                                                         mth.self_id);\n                       debug!(\"calling inline trans_fn with self_ty %s\",\n                              ty_to_str(ccx.tcx, self_ty));\n-                      match mth.self_ty.node {\n+                      match mth.explicit_self.node {\n                           ast::sty_value => impl_owned_self(self_ty),\n                           _ => impl_self(self_ty),\n                       }"}, {"sha": "bdbb45bf2755a7be2dc725e0ac2681afc8168fa9", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -25,7 +25,6 @@ use middle::trans::inline;\n use middle::trans::monomorphize;\n use middle::trans::type_of::*;\n use middle::ty;\n-use middle::ty::arg;\n use middle::typeck;\n use util::common::indenter;\n use util::ppaux::Repr;\n@@ -70,7 +69,12 @@ pub fn trans_impl(ccx: @CrateContext, path: path, name: ast::ident,\n                 }\n             }\n \n-            trans_method(ccx, path, *method, param_substs_opt, self_ty, llfn,\n+            trans_method(ccx,\n+                         path,\n+                         *method,\n+                         param_substs_opt,\n+                         self_ty,\n+                         llfn,\n                          ast_util::local_def(id));\n         }\n     }\n@@ -99,18 +103,17 @@ pub fn trans_method(ccx: @CrateContext,\n                     llfn: ValueRef,\n                     impl_id: ast::def_id) {\n     // figure out how self is being passed\n-    let self_arg = match method.self_ty.node {\n+    let self_arg = match method.explicit_self.node {\n       ast::sty_static => {\n         no_self\n       }\n       _ => {\n         // determine the (monomorphized) type that `self` maps to for\n         // this method\n-        let self_ty;\n-        match base_self_ty {\n-            None => self_ty = ty::node_id_to_type(ccx.tcx, method.self_id),\n-            Some(provided_self_ty) => self_ty = provided_self_ty\n-        }\n+        let self_ty = match base_self_ty {\n+            None => ty::node_id_to_type(ccx.tcx, method.self_id),\n+            Some(provided_self_ty) => provided_self_ty,\n+        };\n         let self_ty = match param_substs {\n             None => self_ty,\n             Some(@param_substs {tys: ref tys, _}) => {\n@@ -120,7 +123,7 @@ pub fn trans_method(ccx: @CrateContext,\n         debug!(\"calling trans_fn with base_self_ty %s, self_ty %s\",\n                base_self_ty.repr(ccx.tcx),\n                self_ty.repr(ccx.tcx));\n-        match method.self_ty.node {\n+        match method.explicit_self.node {\n           ast::sty_value => {\n             impl_owned_self(self_ty)\n           }\n@@ -151,12 +154,10 @@ pub fn trans_self_arg(bcx: block,\n     let mut temp_cleanups = ~[];\n \n     // Compute the type of self.\n-    let self_arg = arg {\n-        ty: monomorphize_type(bcx, mentry.self_arg.ty)\n-    };\n+    let self_ty = monomorphize_type(bcx, mentry.self_ty);\n \n     let result = trans_arg_expr(bcx,\n-                                self_arg,\n+                                self_ty,\n                                 mentry.self_mode,\n                                 base,\n                                 &mut temp_cleanups,\n@@ -589,7 +590,7 @@ pub fn trans_trait_callee(bcx: block,\n                           n_method: uint,\n                           self_expr: @ast::expr,\n                           store: ty::TraitStore,\n-                          explicit_self: ast::self_ty_)\n+                          explicit_self: ast::explicit_self_)\n                        -> Callee {\n     //!\n     //\n@@ -626,7 +627,7 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n                                      n_method: uint,\n                                      llpair: ValueRef,\n                                      store: ty::TraitStore,\n-                                     explicit_self: ast::self_ty_)\n+                                     explicit_self: ast::explicit_self_)\n                                   -> Callee {\n     //!\n     //"}, {"sha": "714444af7b2088e11337e9dd0389c371d1666b12", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -35,7 +35,7 @@ use syntax::parse::token::special_idents;\n \n pub struct Reflector {\n     visitor_val: ValueRef,\n-    visitor_methods: @~[@ty::method],\n+    visitor_methods: @~[@ty::Method],\n     final_bcx: block,\n     tydesc_ty: TypeRef,\n     bcx: block\n@@ -284,13 +284,8 @@ pub impl Reflector {\n                 let sym = mangle_internal_name_by_path_and_seq(ccx,\n                                                                sub_path,\n                                                                \"get_disr\");\n-                let args = [\n-                    ty::arg {\n-                        ty: opaqueptrty\n-                    }\n-                ];\n \n-                let llfty = type_of_fn(ccx, args, ty::mk_int());\n+                let llfty = type_of_fn(ccx, [opaqueptrty], ty::mk_int());\n                 let llfdecl = decl_internal_cdecl_fn(ccx.llmod, sym, llfty);\n                 let arg = unsafe {\n                     llvm::LLVMGetParam(llfdecl, first_real_arg as c_uint)\n@@ -357,7 +352,7 @@ pub impl Reflector {\n             let modeval = 5u;   // \"by copy\"\n             let extra = ~[self.c_uint(i),\n                          self.c_uint(modeval),\n-                         self.c_tydesc(arg.ty)];\n+                         self.c_tydesc(*arg)];\n             self.visit(~\"fn_input\", extra);\n         }\n         let extra = ~[self.c_uint(retval),"}, {"sha": "dfbebd90c298b5746e2660baf18bd3d3218c0b08", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -19,21 +19,21 @@ use util::ppaux;\n \n use syntax::ast;\n \n-pub fn arg_is_indirect(_: @CrateContext, arg: &ty::arg) -> bool {\n-    !ty::type_is_immediate(arg.ty)\n+pub fn arg_is_indirect(_: @CrateContext, arg_ty: &ty::t) -> bool {\n+    !ty::type_is_immediate(*arg_ty)\n }\n \n-pub fn type_of_explicit_arg(ccx: @CrateContext, arg: &ty::arg) -> TypeRef {\n-    let llty = type_of(ccx, arg.ty);\n-    if arg_is_indirect(ccx, arg) {T_ptr(llty)} else {llty}\n+pub fn type_of_explicit_arg(ccx: @CrateContext, arg_ty: &ty::t) -> TypeRef {\n+    let llty = type_of(ccx, *arg_ty);\n+    if arg_is_indirect(ccx, arg_ty) {T_ptr(llty)} else {llty}\n }\n \n pub fn type_of_explicit_args(ccx: @CrateContext,\n-                             inputs: &[ty::arg]) -> ~[TypeRef] {\n-    inputs.map(|arg| type_of_explicit_arg(ccx, arg))\n+                             inputs: &[ty::t]) -> ~[TypeRef] {\n+    inputs.map(|arg_ty| type_of_explicit_arg(ccx, arg_ty))\n }\n \n-pub fn type_of_fn(cx: @CrateContext, inputs: &[ty::arg], output: ty::t)\n+pub fn type_of_fn(cx: @CrateContext, inputs: &[ty::t], output: ty::t)\n                -> TypeRef {\n     unsafe {\n         let mut atys: ~[TypeRef] = ~[];"}, {"sha": "4a8adfba11c3177b0b521370b8fbec7c8d0d862e", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -78,7 +78,7 @@ pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n         ty::ty_bare_fn(ty::BareFnTy {sig: ref sig, _}) |\n         ty::ty_closure(ty::ClosureTy {sig: ref sig, _}) => {\n             for sig.inputs.each |arg| {\n-                type_needs(cx, use_repr, arg.ty);\n+                type_needs(cx, use_repr, *arg);\n             }\n         }\n         _ => ()\n@@ -331,18 +331,16 @@ pub fn mark_for_expr(cx: Context, e: @expr) {\n         node_type_needs(cx, use_tydesc, val.id);\n       }\n       expr_call(f, _, _) => {\n-          for vec::each(ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx,\n-                                                           f.id))) |a| {\n-              type_needs(cx, use_repr, a.ty);\n+          for ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx, f.id)).each |a| {\n+              type_needs(cx, use_repr, *a);\n           }\n       }\n       expr_method_call(rcvr, _, _, _, _) => {\n         let base_ty = ty::node_id_to_type(cx.ccx.tcx, rcvr.id);\n         type_needs(cx, use_repr, ty::type_autoderef(cx.ccx.tcx, base_ty));\n \n-        for ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx,\n-                                               e.callee_id)).each |a| {\n-            type_needs(cx, use_repr, a.ty);\n+        for ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx, e.callee_id)).each |a| {\n+            type_needs(cx, use_repr, *a);\n         }\n         mark_for_method_call(cx, e.id, e.callee_id);\n       }"}, {"sha": "f10ec1d7ac7f3c995da57868f34f4e5a324973e2", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 45, "deletions": 27, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -47,27 +47,49 @@ use syntax;\n \n // Data types\n \n-#[deriving(Eq, IterBytes)]\n-pub struct arg {\n-    ty: t\n-}\n-\n #[deriving(Eq)]\n pub struct field {\n     ident: ast::ident,\n     mt: mt\n }\n \n-pub struct method {\n+pub struct Method {\n     ident: ast::ident,\n     generics: ty::Generics,\n     transformed_self_ty: Option<ty::t>,\n     fty: BareFnTy,\n-    self_ty: ast::self_ty_,\n+    explicit_self: ast::explicit_self_,\n     vis: ast::visibility,\n     def_id: ast::def_id\n }\n \n+pub impl Method {\n+    fn new(ident: ast::ident,\n+           generics: ty::Generics,\n+           transformed_self_ty: Option<ty::t>,\n+           fty: BareFnTy,\n+           explicit_self: ast::explicit_self_,\n+           vis: ast::visibility,\n+           def_id: ast::def_id) -> Method {\n+        // Check the invariants.\n+        if explicit_self == ast::sty_static {\n+            assert!(transformed_self_ty.is_none());\n+        } else {\n+            assert!(transformed_self_ty.is_some());\n+        }\n+\n+       Method {\n+            ident: ident,\n+            generics: generics,\n+            transformed_self_ty: transformed_self_ty,\n+            fty: fty,\n+            explicit_self: explicit_self,\n+            vis: vis,\n+            def_id: def_id\n+        }\n+    }\n+}\n+\n #[deriving(Eq)]\n pub struct mt {\n     ty: t,\n@@ -259,13 +281,13 @@ struct ctxt_ {\n     node_type_substs: @mut HashMap<node_id, ~[t]>,\n \n     // Maps from a method to the method \"descriptor\"\n-    methods: @mut HashMap<def_id, @method>,\n+    methods: @mut HashMap<def_id, @Method>,\n \n     // Maps from a trait def-id to a list of the def-ids of its methods\n     trait_method_def_ids: @mut HashMap<def_id, @~[def_id]>,\n \n     // A cache for the trait_methods() routine\n-    trait_methods_cache: @mut HashMap<def_id, @~[@method]>,\n+    trait_methods_cache: @mut HashMap<def_id, @~[@Method]>,\n \n     trait_refs: @mut HashMap<node_id, @TraitRef>,\n     trait_defs: @mut HashMap<def_id, @TraitDef>,\n@@ -392,7 +414,7 @@ pub struct ClosureTy {\n #[deriving(Eq)]\n pub struct FnSig {\n     bound_lifetime_names: OptVec<ast::ident>,\n-    inputs: ~[arg],\n+    inputs: ~[t],\n     output: t\n }\n \n@@ -1107,14 +1129,14 @@ fn mk_t(cx: ctxt, st: sty) -> t {\n       }\n       &ty_tup(ref ts) => for ts.each |tt| { flags |= get(*tt).flags; },\n       &ty_bare_fn(ref f) => {\n-        for f.sig.inputs.each |a| { flags |= get(a.ty).flags; }\n+        for f.sig.inputs.each |a| { flags |= get(*a).flags; }\n          flags |= get(f.sig.output).flags;\n          // T -> _|_ is *not* _|_ !\n          flags &= !(has_ty_bot as uint);\n       }\n       &ty_closure(ref f) => {\n         flags |= rflags(f.region);\n-        for f.sig.inputs.each |a| { flags |= get(a.ty).flags; }\n+        for f.sig.inputs.each |a| { flags |= get(*a).flags; }\n         flags |= get(f.sig.output).flags;\n         // T -> _|_ is *not* _|_ !\n         flags &= !(has_ty_bot as uint);\n@@ -1298,7 +1320,7 @@ pub fn mk_bare_fn(cx: ctxt, fty: BareFnTy) -> t {\n }\n \n pub fn mk_ctor_fn(cx: ctxt, input_tys: &[ty::t], output: ty::t) -> t {\n-    let input_args = input_tys.map(|t| arg { ty: *t });\n+    let input_args = input_tys.map(|t| *t);\n     mk_bare_fn(cx,\n                BareFnTy {\n                    purity: ast::pure_fn,\n@@ -1372,11 +1394,11 @@ pub fn maybe_walk_ty(ty: t, f: &fn(t) -> bool) {\n       }\n       ty_tup(ref ts) => { for ts.each |tt| { maybe_walk_ty(*tt, f); } }\n       ty_bare_fn(ref ft) => {\n-        for ft.sig.inputs.each |a| { maybe_walk_ty(a.ty, f); }\n+        for ft.sig.inputs.each |a| { maybe_walk_ty(*a, f); }\n         maybe_walk_ty(ft.sig.output, f);\n       }\n       ty_closure(ref ft) => {\n-        for ft.sig.inputs.each |a| { maybe_walk_ty(a.ty, f); }\n+        for ft.sig.inputs.each |a| { maybe_walk_ty(*a, f); }\n         maybe_walk_ty(ft.sig.output, f);\n       }\n     }\n@@ -1387,11 +1409,7 @@ pub fn fold_sty_to_ty(tcx: ty::ctxt, sty: &sty, foldop: &fn(t) -> t) -> t {\n }\n \n pub fn fold_sig(sig: &FnSig, fldop: &fn(t) -> t) -> FnSig {\n-    let args = do sig.inputs.map |arg| {\n-        arg {\n-            ty: fldop(arg.ty)\n-        }\n-    };\n+    let args = sig.inputs.map(|arg| fldop(*arg));\n \n     FnSig {\n         bound_lifetime_names: copy sig.bound_lifetime_names,\n@@ -2999,7 +3017,7 @@ pub fn ty_fn_sig(fty: t) -> FnSig {\n }\n \n // Type accessors for substructures of types\n-pub fn ty_fn_args(fty: t) -> ~[arg] {\n+pub fn ty_fn_args(fty: t) -> ~[t] {\n     match get(fty).sty {\n         ty_bare_fn(ref f) => copy f.sig.inputs,\n         ty_closure(ref f) => copy f.sig.inputs,\n@@ -3103,7 +3121,7 @@ pub fn replace_closure_return_type(tcx: ctxt, fn_type: t, ret_type: t) -> t {\n \n // Returns a vec of all the input and output types of fty.\n pub fn tys_in_fn_sig(sig: &FnSig) -> ~[t] {\n-    vec::append_one(sig.inputs.map(|a| a.ty), sig.output)\n+    vec::append_one(sig.inputs.map(|a| *a), sig.output)\n }\n \n // Type accessors for AST nodes\n@@ -3507,7 +3525,7 @@ pub fn field_idx_strict(tcx: ty::ctxt, id: ast::ident, fields: &[field])\n         fields.map(|f| tcx.sess.str_of(f.ident))));\n }\n \n-pub fn method_idx(id: ast::ident, meths: &[@method]) -> Option<uint> {\n+pub fn method_idx(id: ast::ident, meths: &[@Method]) -> Option<uint> {\n     vec::position(meths, |m| m.ident == id)\n }\n \n@@ -3831,12 +3849,12 @@ fn lookup_locally_or_in_crate_store<V:Copy>(\n     return v;\n }\n \n-pub fn trait_method(cx: ctxt, trait_did: ast::def_id, idx: uint) -> @method {\n+pub fn trait_method(cx: ctxt, trait_did: ast::def_id, idx: uint) -> @Method {\n     let method_def_id = ty::trait_method_def_ids(cx, trait_did)[idx];\n     ty::method(cx, method_def_id)\n }\n \n-pub fn trait_methods(cx: ctxt, trait_did: ast::def_id) -> @~[@method] {\n+pub fn trait_methods(cx: ctxt, trait_did: ast::def_id) -> @~[@Method] {\n     match cx.trait_methods_cache.find(&trait_did) {\n         Some(&methods) => methods,\n         None => {\n@@ -3848,7 +3866,7 @@ pub fn trait_methods(cx: ctxt, trait_did: ast::def_id) -> @~[@method] {\n     }\n }\n \n-pub fn method(cx: ctxt, id: ast::def_id) -> @method {\n+pub fn method(cx: ctxt, id: ast::def_id) -> @Method {\n     lookup_locally_or_in_crate_store(\n         \"methods\", id, cx.methods,\n         || @csearch::get_method(cx, id))\n@@ -4061,7 +4079,7 @@ pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[VariantInfo] {\n                         let ctor_ty = node_id_to_type(cx, variant.node.id);\n                         let arg_tys = {\n                             if args.len() > 0u {\n-                                ty_fn_args(ctor_ty).map(|a| a.ty)\n+                                ty_fn_args(ctor_ty).map(|a| *a)\n                             } else {\n                                 ~[]\n                             }"}, {"sha": "de6064b0a313bb016bf56aedf28aac1dc319fecd", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -53,7 +53,7 @@\n  */\n \n use middle::const_eval;\n-use middle::ty::{arg, substs};\n+use middle::ty::{substs};\n use middle::ty::{ty_param_substs_and_ty};\n use middle::ty;\n use middle::typeck::rscope::in_binding_rscope;\n@@ -501,16 +501,12 @@ pub fn ty_of_arg<AC:AstConv,\n                  this: &AC,\n                  rscope: &RS,\n                  a: ast::arg,\n-                 expected_ty: Option<ty::arg>)\n-                 -> ty::arg {\n-    let ty = match a.ty.node {\n-        ast::ty_infer if expected_ty.is_some() => expected_ty.get().ty,\n+                 expected_ty: Option<ty::t>)\n+                 -> ty::t {\n+    match a.ty.node {\n+        ast::ty_infer if expected_ty.is_some() => expected_ty.get(),\n         ast::ty_infer => this.ty_infer(a.ty.span),\n         _ => ast_ty_to_ty(this, rscope, a.ty),\n-    };\n-\n-    arg {\n-        ty: ty\n     }\n }\n \n@@ -546,7 +542,7 @@ pub fn bound_lifetimes<AC:AstConv>(\n \n struct SelfInfo {\n     untransformed_self_ty: ty::t,\n-    self_transform: ast::self_ty\n+    explicit_self: ast::explicit_self\n }\n \n pub fn ty_of_method<AC:AstConv,RS:region_scope + Copy + 'static>(\n@@ -555,12 +551,12 @@ pub fn ty_of_method<AC:AstConv,RS:region_scope + Copy + 'static>(\n     purity: ast::purity,\n     lifetimes: &OptVec<ast::Lifetime>,\n     untransformed_self_ty: ty::t,\n-    self_transform: ast::self_ty,\n+    explicit_self: ast::explicit_self,\n     decl: &ast::fn_decl) -> (Option<ty::t>, ty::BareFnTy)\n {\n     let self_info = SelfInfo {\n         untransformed_self_ty: untransformed_self_ty,\n-        self_transform: self_transform\n+        explicit_self: explicit_self\n     };\n     let (a, b) = ty_of_method_or_bare_fn(\n         this, rscope, purity, AbiSet::Rust(), lifetimes, Some(&self_info), decl);\n@@ -621,15 +617,15 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:region_scope + Copy + 'static>(\n         rscope: &RS,\n         self_info: &SelfInfo) -> Option<ty::t>\n     {\n-        match self_info.self_transform.node {\n+        match self_info.explicit_self.node {\n             ast::sty_static => None,\n             ast::sty_value => {\n                 Some(self_info.untransformed_self_ty)\n             }\n             ast::sty_region(lifetime, mutability) => {\n                 let region =\n                     ast_region_to_region(this, rscope,\n-                                         self_info.self_transform.span,\n+                                         self_info.explicit_self.span,\n                                          lifetime);\n                 Some(ty::mk_rptr(this.tcx(), region,\n                                  ty::mt {ty: self_info.untransformed_self_ty,"}, {"sha": "9e8103f4527f6fabf46a76919280f63bd6910ccc", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -170,7 +170,7 @@ pub struct LookupContext<'self> {\n pub struct Candidate {\n     rcvr_ty: ty::t,\n     rcvr_substs: ty::substs,\n-    method_ty: @ty::method,\n+    method_ty: @ty::Method,\n     origin: method_origin,\n }\n \n@@ -381,7 +381,7 @@ pub impl<'self> LookupContext<'self> {\n             let trait_methods = ty::trait_methods(tcx, bound_trait_ref.def_id);\n             let pos = {\n                 match trait_methods.position(|m| {\n-                    m.self_ty != ast::sty_static &&\n+                    m.explicit_self != ast::sty_static &&\n                         m.ident == self.m_name })\n                 {\n                     Some(pos) => pos,\n@@ -469,7 +469,7 @@ pub impl<'self> LookupContext<'self> {\n                                           did: def_id,\n                                           substs: &ty::substs) {\n         struct MethodInfo {\n-            method_ty: @ty::method,\n+            method_ty: @ty::Method,\n             trait_def_id: ast::def_id,\n             index: uint\n         }\n@@ -830,26 +830,26 @@ pub impl<'self> LookupContext<'self> {\n     }\n \n     fn search_for_method(&self,\n-                         self_ty: ty::t)\n+                         rcvr_ty: ty::t)\n         -> Option<method_map_entry>\n     {\n-        debug!(\"search_for_method(self_ty=%s)\", self.ty_to_str(self_ty));\n+        debug!(\"search_for_method(rcvr_ty=%s)\", self.ty_to_str(rcvr_ty));\n         let _indenter = indenter();\n \n         // I am not sure that inherent methods should have higher\n         // priority, but it is necessary ATM to handle some of the\n         // existing code.\n \n         debug!(\"searching inherent candidates\");\n-        match self.consider_candidates(self_ty, self.inherent_candidates) {\n+        match self.consider_candidates(rcvr_ty, self.inherent_candidates) {\n             None => {}\n             Some(mme) => {\n                 return Some(mme);\n             }\n         }\n \n         debug!(\"searching extension candidates\");\n-        match self.consider_candidates(self_ty, self.extension_candidates) {\n+        match self.consider_candidates(rcvr_ty, self.extension_candidates) {\n             None => {\n                 return None;\n             }\n@@ -860,12 +860,12 @@ pub impl<'self> LookupContext<'self> {\n     }\n \n     fn consider_candidates(&self,\n-                           self_ty: ty::t,\n+                           rcvr_ty: ty::t,\n                            candidates: &mut ~[Candidate])\n         -> Option<method_map_entry>\n     {\n         let relevant_candidates =\n-            candidates.filter_to_vec(|c| self.is_relevant(self_ty, c));\n+            candidates.filter_to_vec(|c| self.is_relevant(rcvr_ty, c));\n \n         let relevant_candidates = self.merge_candidates(relevant_candidates);\n \n@@ -882,7 +882,7 @@ pub impl<'self> LookupContext<'self> {\n             }\n         }\n \n-        Some(self.confirm_candidate(self_ty, &relevant_candidates[0]))\n+        Some(self.confirm_candidate(rcvr_ty, &relevant_candidates[0]))\n     }\n \n     fn merge_candidates(&self, candidates: &[Candidate]) -> ~[Candidate] {\n@@ -932,7 +932,7 @@ pub impl<'self> LookupContext<'self> {\n     }\n \n     fn confirm_candidate(&self,\n-                         self_ty: ty::t,\n+                         rcvr_ty: ty::t,\n                          candidate: &Candidate)\n         -> method_map_entry\n     {\n@@ -948,11 +948,11 @@ pub impl<'self> LookupContext<'self> {\n         self.enforce_drop_trait_limitations(candidate);\n \n         // static methods should never have gotten this far:\n-        assert!(candidate.method_ty.self_ty != sty_static);\n+        assert!(candidate.method_ty.explicit_self != sty_static);\n \n         let transformed_self_ty = match candidate.origin {\n             method_trait(*) => {\n-                match candidate.method_ty.self_ty {\n+                match candidate.method_ty.explicit_self {\n                     sty_region(*) => {\n                         // FIXME(#5762) again, preserving existing\n                         // behavior here which (for &self) desires\n@@ -1033,31 +1033,29 @@ pub impl<'self> LookupContext<'self> {\n         let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {sig: fn_sig, ..bare_fn_ty});\n         debug!(\"after replacing bound regions, fty=%s\", self.ty_to_str(fty));\n \n-        let self_mode = get_mode_from_self_type(candidate.method_ty.self_ty);\n+        let self_mode = get_mode_from_explicit_self(candidate.method_ty.explicit_self);\n \n         // before we only checked whether self_ty could be a subtype\n         // of rcvr_ty; now we actually make it so (this may cause\n         // variables to unify etc).  Since we checked beforehand, and\n         // nothing has changed in the meantime, this unification\n         // should never fail.\n         match self.fcx.mk_subty(false, self.self_expr.span,\n-                                self_ty, transformed_self_ty) {\n+                                rcvr_ty, transformed_self_ty) {\n             result::Ok(_) => (),\n             result::Err(_) => {\n                 self.bug(fmt!(\"%s was a subtype of %s but now is not?\",\n-                              self.ty_to_str(self_ty),\n+                              self.ty_to_str(rcvr_ty),\n                               self.ty_to_str(transformed_self_ty)));\n             }\n         }\n \n         self.fcx.write_ty(self.callee_id, fty);\n         self.fcx.write_substs(self.callee_id, all_substs);\n         method_map_entry {\n-            self_arg: arg {\n-                ty: candidate.rcvr_ty,\n-            },\n+            self_ty: candidate.rcvr_ty,\n             self_mode: self_mode,\n-            explicit_self: candidate.method_ty.self_ty,\n+            explicit_self: candidate.method_ty.explicit_self,\n             origin: candidate.origin,\n         }\n     }\n@@ -1116,17 +1114,19 @@ pub impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    fn is_relevant(&self, self_ty: ty::t, candidate: &Candidate) -> bool {\n-        debug!(\"is_relevant(self_ty=%s, candidate=%s)\",\n-               self.ty_to_str(self_ty), self.cand_to_str(candidate));\n+    // `rcvr_ty` is the type of the expression. It may be a subtype of a\n+    // candidate method's `self_ty`.\n+    fn is_relevant(&self, rcvr_ty: ty::t, candidate: &Candidate) -> bool {\n+        debug!(\"is_relevant(rcvr_ty=%s, candidate=%s)\",\n+               self.ty_to_str(rcvr_ty), self.cand_to_str(candidate));\n \n         // Check for calls to object methods.  We resolve these differently.\n         //\n         // FIXME(#5762)---we don't check that an @self method is only called\n         // on an @Trait object here and so forth\n         match candidate.origin {\n             method_trait(*) => {\n-                match candidate.method_ty.self_ty {\n+                match candidate.method_ty.explicit_self {\n                     sty_static | sty_value => {\n                         return false;\n                     }\n@@ -1136,25 +1136,25 @@ pub impl<'self> LookupContext<'self> {\n                         // an &@Trait receiver (wacky)\n                     }\n                     sty_box(*) | sty_uniq(*) => {\n-                        return self.fcx.can_mk_subty(self_ty,\n+                        return self.fcx.can_mk_subty(rcvr_ty,\n                                                      candidate.rcvr_ty).is_ok();\n                     }\n                 };\n             }\n             _ => {}\n         }\n \n-        return match candidate.method_ty.self_ty {\n+        return match candidate.method_ty.explicit_self {\n             sty_static => {\n                 false\n             }\n \n             sty_value => {\n-                self.fcx.can_mk_subty(self_ty, candidate.rcvr_ty).is_ok()\n+                self.fcx.can_mk_subty(rcvr_ty, candidate.rcvr_ty).is_ok()\n             }\n \n             sty_region(_, m) => {\n-                match ty::get(self_ty).sty {\n+                match ty::get(rcvr_ty).sty {\n                     ty::ty_rptr(_, mt) => {\n                         mutability_matches(mt.mutbl, m) &&\n                         self.fcx.can_mk_subty(mt.ty, candidate.rcvr_ty).is_ok()\n@@ -1165,7 +1165,7 @@ pub impl<'self> LookupContext<'self> {\n             }\n \n             sty_box(m) => {\n-                match ty::get(self_ty).sty {\n+                match ty::get(rcvr_ty).sty {\n                     ty::ty_box(mt) => {\n                         mutability_matches(mt.mutbl, m) &&\n                         self.fcx.can_mk_subty(mt.ty, candidate.rcvr_ty).is_ok()\n@@ -1176,7 +1176,7 @@ pub impl<'self> LookupContext<'self> {\n             }\n \n             sty_uniq(m) => {\n-                match ty::get(self_ty).sty {\n+                match ty::get(rcvr_ty).sty {\n                     ty::ty_uniq(mt) => {\n                         mutability_matches(mt.mutbl, m) &&\n                         self.fcx.can_mk_subty(mt.ty, candidate.rcvr_ty).is_ok()\n@@ -1301,8 +1301,8 @@ pub impl<'self> LookupContext<'self> {\n     }\n }\n \n-pub fn get_mode_from_self_type(self_type: ast::self_ty_) -> SelfMode {\n-    match self_type {\n+pub fn get_mode_from_explicit_self(explicit_self: ast::explicit_self_) -> SelfMode {\n+    match explicit_self {\n         sty_value => ty::ByCopy,\n         _ => ty::ByRef,\n     }"}, {"sha": "942f73b4555880a8a16c4d11686949215200dc10", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 91, "deletions": 113, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -81,7 +81,7 @@ use middle::pat_util::pat_id_map;\n use middle::pat_util;\n use middle::ty::{FnSig, VariantInfo_};\n use middle::ty::{ty_param_bounds_and_ty, ty_param_substs_and_ty};\n-use middle::ty::{substs, arg, param_ty};\n+use middle::ty::{substs, param_ty};\n use middle::ty;\n use middle::typeck::astconv::AstConv;\n use middle::typeck::astconv::{ast_region_to_region, ast_ty_to_ty};\n@@ -352,7 +352,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n \n     relate_free_regions(tcx, opt_self_info.map(|s| s.self_ty), &fn_sig);\n \n-    let arg_tys = fn_sig.inputs.map(|a| a.ty);\n+    let arg_tys = fn_sig.inputs.map(|a| *a);\n     let ret_ty = fn_sig.output;\n \n     debug!(\"check_fn(arg_tys=%?, ret_ty=%?, opt_self_ty=%?)\",\n@@ -527,7 +527,7 @@ pub fn check_method(ccx: @mut CrateCtxt,\n     let opt_self_info = method_ty.transformed_self_ty.map(|&ty| {\n         SelfInfo {self_ty: ty,\n                   self_id: method.self_id,\n-                  span: method.self_ty.span}\n+                  span: method.explicit_self.span}\n     });\n \n     check_bare_fn(\n@@ -1192,7 +1192,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     fn check_argument_types(\n         fcx: @mut FnCtxt,\n         sp: span,\n-        fn_inputs: &[ty::arg],\n+        fn_inputs: &[ty::t],\n         callee_expr: @ast::expr,\n         args: &[@ast::expr],\n         sugar: ast::CallSugar,\n@@ -1211,7 +1211,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let supplied_arg_count = args.len();\n         let expected_arg_count = fn_inputs.len();\n         let formal_tys = if expected_arg_count == supplied_arg_count {\n-            fn_inputs.map(|a| a.ty)\n+            fn_inputs.map(|a| *a)\n         } else {\n             let suffix = match sugar {\n                 ast::NoSugar => \"\",\n@@ -1287,8 +1287,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         }\n     }\n \n-    fn err_args(len: uint) -> ~[ty::arg] {\n-        vec::from_fn(len, |_| ty::arg { ty: ty::mk_err() })\n+    fn err_args(len: uint) -> ~[ty::t] {\n+        vec::from_fn(len, |_| ty::mk_err())\n     }\n \n     // A generic function for checking assignment expressions\n@@ -1701,11 +1701,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let fty = if error_happened {\n             fty_sig = FnSig {\n                 bound_lifetime_names: opt_vec::Empty,\n-                inputs: fn_ty.sig.inputs.map(|_| {\n-                    arg {\n-                        ty: ty::mk_err()\n-                    }\n-                }),\n+                inputs: fn_ty.sig.inputs.map(|_| ty::mk_err()),\n                 output: ty::mk_err()\n             };\n             ty::mk_err()\n@@ -3132,24 +3128,23 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n             }\n             disr_vals.push(*disr_val);\n             let ctor_ty = ty::node_id_to_type(ccx.tcx, v.node.id);\n-            let arg_tys;\n \n             let this_disr_val = *disr_val;\n             *disr_val += 1;\n \n-            match v.node.kind {\n+            let arg_tys = match v.node.kind {\n                 ast::tuple_variant_kind(ref args) if args.len() > 0u => {\n-                    arg_tys = Some(ty::ty_fn_args(ctor_ty).map(|a| a.ty));\n+                    Some(ty::ty_fn_args(ctor_ty).map(|a| *a))\n                 }\n                 ast::tuple_variant_kind(_) => {\n-                    arg_tys = Some(~[]);\n+                    Some(~[])\n                 }\n                 ast::struct_variant_kind(_) => {\n-                    arg_tys = Some(ty::lookup_struct_fields(\n+                    Some(ty::lookup_struct_fields(\n                         ccx.tcx, local_def(v.node.id)).map(|cf|\n-                            ty::node_id_to_type(ccx.tcx, cf.id.node)));\n+                            ty::node_id_to_type(ccx.tcx, cf.id.node)))\n                 }\n-            }\n+            };\n \n             match arg_tys {\n                 None => {}\n@@ -3454,27 +3449,20 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n     fn param(ccx: @mut CrateCtxt, n: uint) -> ty::t {\n         ty::mk_param(ccx.tcx, n, local_def(0))\n     }\n-    fn arg(ty: ty::t) -> ty::arg {\n-        arg {\n-            ty: ty\n-        }\n-    }\n \n     let tcx = ccx.tcx;\n     let (n_tps, inputs, output) = match *ccx.tcx.sess.str_of(it.ident) {\n       ~\"size_of\" |\n       ~\"pref_align_of\" | ~\"min_align_of\" => (1u, ~[], ty::mk_uint()),\n       ~\"init\" => (1u, ~[], param(ccx, 0u)),\n       ~\"uninit\" => (1u, ~[], param(ccx, 0u)),\n-      ~\"forget\" => (1u, ~[arg(param(ccx, 0u))], ty::mk_nil()),\n-      ~\"transmute\" => (2, ~[ arg(param(ccx, 0)) ], param(ccx, 1)),\n+      ~\"forget\" => (1u, ~[ param(ccx, 0) ], ty::mk_nil()),\n+      ~\"transmute\" => (2, ~[ param(ccx, 0) ], param(ccx, 1)),\n       ~\"move_val\" | ~\"move_val_init\" => {\n           (1u,\n            ~[\n-            arg(ty::mk_mut_rptr(tcx,\n-                                ty::re_bound(ty::br_anon(0)),\n-                                param(ccx, 0))),\n-               arg(param(ccx, 0u))\n+              ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)), param(ccx, 0)),\n+              param(ccx, 0u)\n             ],\n          ty::mk_nil())\n       }\n@@ -3483,30 +3471,26 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n       ~\"atomic_cxchg\"    | ~\"atomic_cxchg_acq\"| ~\"atomic_cxchg_rel\" => {\n         (0,\n          ~[\n-            arg(ty::mk_mut_rptr(tcx,\n-                                ty::re_bound(ty::br_anon(0)),\n-                                ty::mk_int())),\n-               arg(ty::mk_int()),\n-               arg(ty::mk_int())\n+            ty::mk_mut_rptr(tcx,\n+                            ty::re_bound(ty::br_anon(0)),\n+                            ty::mk_int()),\n+            ty::mk_int(),\n+            ty::mk_int()\n          ],\n          ty::mk_int())\n       }\n       ~\"atomic_load\"     | ~\"atomic_load_acq\" => {\n         (0,\n          ~[\n-            arg(ty::mk_imm_rptr(tcx,\n-                            ty::re_bound(ty::br_anon(0)),\n-                            ty::mk_int()))\n+            ty::mk_imm_rptr(tcx, ty::re_bound(ty::br_anon(0)), ty::mk_int())\n          ],\n         ty::mk_int())\n       }\n       ~\"atomic_store\"    | ~\"atomic_store_rel\" => {\n         (0,\n          ~[\n-            arg(ty::mk_mut_rptr(tcx,\n-                                ty::re_bound(ty::br_anon(0)),\n-                                ty::mk_int())),\n-            arg(ty::mk_int())\n+            ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)), ty::mk_int()),\n+            ty::mk_int()\n          ],\n          ty::mk_nil())\n       }\n@@ -3515,10 +3499,8 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n       ~\"atomic_xchg_rel\" | ~\"atomic_xadd_rel\" | ~\"atomic_xsub_rel\" => {\n         (0,\n          ~[\n-            arg(ty::mk_mut_rptr(tcx,\n-                                ty::re_bound(ty::br_anon(0)),\n-                                ty::mk_int())),\n-            arg(ty::mk_int())\n+            ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)), ty::mk_int()),\n+            ty::mk_int()\n          ],\n          ty::mk_int())\n       }\n@@ -3536,7 +3518,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n             ty: tydesc_ty,\n             mutbl: ast::m_imm\n         });\n-        (0, ~[ arg(td_ptr), arg(visitor_object_ty) ], ty::mk_nil())\n+        (0, ~[ td_ptr, visitor_object_ty ], ty::mk_nil())\n       }\n       ~\"frame_address\" => {\n         let fty = ty::mk_closure(ccx.tcx, ty::ClosureTy {\n@@ -3546,118 +3528,114 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n             region: ty::re_bound(ty::br_anon(0)),\n             sig: ty::FnSig {\n                 bound_lifetime_names: opt_vec::Empty,\n-                inputs: ~[\n-                    arg {\n-                        ty: ty::mk_imm_ptr(ccx.tcx,\n-                                           ty::mk_mach_uint(ast::ty_u8))\n-                    }\n-                ],\n+                inputs: ~[ty::mk_imm_ptr(ccx.tcx, ty::mk_mach_uint(ast::ty_u8))],\n                 output: ty::mk_nil()\n             }\n         });\n-        (0u, ~[ arg(fty) ], ty::mk_nil())\n+        (0u, ~[fty], ty::mk_nil())\n       }\n       ~\"morestack_addr\" => {\n         (0u, ~[], ty::mk_nil_ptr(ccx.tcx))\n       }\n       ~\"memmove32\" => {\n         (0,\n          ~[\n-            arg(ty::mk_ptr(tcx, ty::mt {\n+            ty::mk_ptr(tcx, ty::mt {\n                 ty: ty::mk_u8(),\n                 mutbl: ast::m_mutbl\n-            })),\n-            arg(ty::mk_ptr(tcx, ty::mt {\n+            }),\n+            ty::mk_ptr(tcx, ty::mt {\n                 ty: ty::mk_u8(),\n                 mutbl: ast::m_imm\n-            })),\n-            arg(ty::mk_u32())\n+            }),\n+            ty::mk_u32()\n          ],\n          ty::mk_nil())\n       }\n       ~\"memmove64\" => {\n         (0,\n-         ~[arg(ty::mk_ptr(tcx, ty::mt {\n-            ty: ty::mk_u8(),\n-            mutbl: ast::m_mutbl\n-           })),\n-           arg(ty::mk_ptr(tcx, ty::mt {\n-            ty: ty::mk_u8(),\n-            mutbl: ast::m_imm\n-           })),\n-           arg(ty::mk_u64())\n+         ~[\n+            ty::mk_ptr(tcx, ty::mt {\n+                ty: ty::mk_u8(),\n+                mutbl: ast::m_mutbl\n+            }),\n+            ty::mk_ptr(tcx, ty::mt {\n+                ty: ty::mk_u8(),\n+                mutbl: ast::m_imm\n+            }),\n+            ty::mk_u64()\n          ],\n          ty::mk_nil())\n       }\n-        ~\"sqrtf32\" => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n-        ~\"sqrtf64\" => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n+        ~\"sqrtf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+        ~\"sqrtf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n         ~\"powif32\" => {\n            (0,\n-            ~[ arg(ty::mk_f32()), arg(ty::mk_i32()) ],\n+            ~[ ty::mk_f32(), ty::mk_i32() ],\n             ty::mk_f32())\n         }\n         ~\"powif64\" => {\n            (0,\n-            ~[ arg(ty::mk_f64()), arg(ty::mk_i32()) ],\n+            ~[ ty::mk_f64(), ty::mk_i32() ],\n             ty::mk_f64())\n         }\n-        ~\"sinf32\" => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n-        ~\"sinf64\" => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n-        ~\"cosf32\" => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n-        ~\"cosf64\" => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n+        ~\"sinf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+        ~\"sinf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+        ~\"cosf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+        ~\"cosf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n         ~\"powf32\" => {\n            (0,\n-            ~[ arg(ty::mk_f32()), arg(ty::mk_f32()) ],\n+            ~[ ty::mk_f32(), ty::mk_f32() ],\n             ty::mk_f32())\n         }\n         ~\"powf64\" => {\n            (0,\n-            ~[ arg(ty::mk_f64()), arg(ty::mk_f64()) ],\n+            ~[ ty::mk_f64(), ty::mk_f64() ],\n             ty::mk_f64())\n         }\n-        ~\"expf32\"   => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n-        ~\"expf64\"   => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n-        ~\"exp2f32\"  => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n-        ~\"exp2f64\"  => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n-        ~\"logf32\"   => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n-        ~\"logf64\"   => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n-        ~\"log10f32\" => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n-        ~\"log10f64\" => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n-        ~\"log2f32\"  => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n-        ~\"log2f64\"  => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n+        ~\"expf32\"   => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+        ~\"expf64\"   => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+        ~\"exp2f32\"  => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+        ~\"exp2f64\"  => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+        ~\"logf32\"   => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+        ~\"logf64\"   => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+        ~\"log10f32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+        ~\"log10f64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+        ~\"log2f32\"  => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+        ~\"log2f64\"  => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n         ~\"fmaf32\" => {\n             (0,\n-             ~[ arg(ty::mk_f32()), arg(ty::mk_f32()), arg(ty::mk_f32()) ],\n+             ~[ ty::mk_f32(), ty::mk_f32(), ty::mk_f32() ],\n              ty::mk_f32())\n         }\n         ~\"fmaf64\" => {\n             (0,\n-             ~[ arg(ty::mk_f64()), arg(ty::mk_f64()), arg(ty::mk_f64()) ],\n+             ~[ ty::mk_f64(), ty::mk_f64(), ty::mk_f64() ],\n              ty::mk_f64())\n         }\n-        ~\"fabsf32\"  => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n-        ~\"fabsf64\"  => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n-        ~\"floorf32\" => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n-        ~\"floorf64\" => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n-        ~\"ceilf32\"  => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n-        ~\"ceilf64\"  => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n-        ~\"truncf32\" => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n-        ~\"truncf64\" => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n-        ~\"ctpop8\"   => (0, ~[ arg(ty::mk_i8())  ], ty::mk_i8()),\n-        ~\"ctpop16\"  => (0, ~[ arg(ty::mk_i16()) ], ty::mk_i16()),\n-        ~\"ctpop32\"  => (0, ~[ arg(ty::mk_i32()) ], ty::mk_i32()),\n-        ~\"ctpop64\"  => (0, ~[ arg(ty::mk_i64()) ], ty::mk_i64()),\n-        ~\"ctlz8\"    => (0, ~[ arg(ty::mk_i8())  ], ty::mk_i8()),\n-        ~\"ctlz16\"   => (0, ~[ arg(ty::mk_i16()) ], ty::mk_i16()),\n-        ~\"ctlz32\"   => (0, ~[ arg(ty::mk_i32()) ], ty::mk_i32()),\n-        ~\"ctlz64\"   => (0, ~[ arg(ty::mk_i64()) ], ty::mk_i64()),\n-        ~\"cttz8\"    => (0, ~[ arg(ty::mk_i8())  ], ty::mk_i8()),\n-        ~\"cttz16\"   => (0, ~[ arg(ty::mk_i16()) ], ty::mk_i16()),\n-        ~\"cttz32\"   => (0, ~[ arg(ty::mk_i32()) ], ty::mk_i32()),\n-        ~\"cttz64\"   => (0, ~[ arg(ty::mk_i64()) ], ty::mk_i64()),\n-        ~\"bswap16\"  => (0, ~[ arg(ty::mk_i16()) ], ty::mk_i16()),\n-        ~\"bswap32\"  => (0, ~[ arg(ty::mk_i32()) ], ty::mk_i32()),\n-        ~\"bswap64\"  => (0, ~[ arg(ty::mk_i64()) ], ty::mk_i64()),\n+        ~\"fabsf32\"  => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+        ~\"fabsf64\"  => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+        ~\"floorf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+        ~\"floorf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+        ~\"ceilf32\"  => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+        ~\"ceilf64\"  => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+        ~\"truncf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+        ~\"truncf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+        ~\"ctpop8\"   => (0, ~[ ty::mk_i8()  ], ty::mk_i8()),\n+        ~\"ctpop16\"  => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n+        ~\"ctpop32\"  => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n+        ~\"ctpop64\"  => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n+        ~\"ctlz8\"    => (0, ~[ ty::mk_i8()  ], ty::mk_i8()),\n+        ~\"ctlz16\"   => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n+        ~\"ctlz32\"   => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n+        ~\"ctlz64\"   => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n+        ~\"cttz8\"    => (0, ~[ ty::mk_i8()  ], ty::mk_i8()),\n+        ~\"cttz16\"   => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n+        ~\"cttz32\"   => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n+        ~\"cttz64\"   => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n+        ~\"bswap16\"  => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n+        ~\"bswap32\"  => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n+        ~\"bswap64\"  => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n         ref other => {\n             tcx.sess.span_err(it.span,\n                               ~\"unrecognized intrinsic function: `\" +"}, {"sha": "87b105e3c7d4d94e1d399a13b55dc9c29025eb75", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -258,7 +258,7 @@ pub fn relate_free_regions(\n \n     let mut all_tys = ~[];\n     for fn_sig.inputs.each |arg| {\n-        all_tys.push(arg.ty);\n+        all_tys.push(*arg);\n     }\n     for self_ty.each |&t| {\n         all_tys.push(t);"}, {"sha": "394d00bef2d44c08909f4d1e88d3ce274dd0877a", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -13,7 +13,6 @@\n // substitutions.\n \n use middle::pat_util;\n-use middle::ty::arg;\n use middle::ty;\n use middle::typeck::check::{FnCtxt, SelfInfo};\n use middle::typeck::infer::{force_all, resolve_all, resolve_region};\n@@ -63,14 +62,9 @@ fn resolve_method_map_entry(fcx: @mut FnCtxt, sp: span, id: ast::node_id) {\n     match fcx.inh.method_map.find(&id) {\n         None => {}\n         Some(mme) => {\n-            for resolve_type_vars_in_type(fcx, sp, mme.self_arg.ty).each |t| {\n+            for resolve_type_vars_in_type(fcx, sp, mme.self_ty).each |t| {\n                 let method_map = fcx.ccx.method_map;\n-                let new_entry = method_map_entry {\n-                    self_arg: arg {\n-                        ty: *t\n-                    },\n-                    ..*mme\n-                };\n+                let new_entry = method_map_entry { self_ty: *t, ..*mme };\n                 debug!(\"writeback::resolve_method_map_entry(id=%?, \\\n                         new_entry=%?)\",\n                        id, new_entry);"}, {"sha": "c64a0235eb1f0db6a25b4f23c72987bab65d28c5", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -156,7 +156,7 @@ pub fn method_to_MethodInfo(ast_method: @method) -> @MethodInfo {\n         did: local_def(ast_method.id),\n         n_tps: ast_method.generics.ty_params.len(),\n         ident: ast_method.ident,\n-        self_type: ast_method.self_ty.node\n+        explicit_self: ast_method.explicit_self.node\n     }\n }\n \n@@ -383,7 +383,7 @@ pub impl CoherenceChecker {\n                         did: new_did,\n                         n_tps: trait_method.generics.type_param_defs.len(),\n                         ident: trait_method.ident,\n-                        self_type: trait_method.self_ty\n+                        explicit_self: trait_method.explicit_self\n                     },\n                     trait_method_def_id: trait_method.def_id\n                 };\n@@ -527,7 +527,7 @@ pub impl CoherenceChecker {\n     #[cfg(stage0)]\n     fn each_provided_trait_method(&self,\n             trait_did: ast::def_id,\n-            f: &fn(x: @ty::method) -> bool) {\n+            f: &fn(@ty::Method) -> bool) {\n         // Make a list of all the names of the provided methods.\n         // XXX: This is horrible.\n         let mut provided_method_idents = HashSet::new();\n@@ -547,7 +547,7 @@ pub impl CoherenceChecker {\n     #[cfg(not(stage0))]\n     fn each_provided_trait_method(&self,\n             trait_did: ast::def_id,\n-            f: &fn(x: @ty::method) -> bool) -> bool {\n+            f: &fn(x: @ty::Method) -> bool) -> bool {\n         // Make a list of all the names of the provided methods.\n         // XXX: This is horrible.\n         let mut provided_method_idents = HashSet::new();\n@@ -975,7 +975,7 @@ pub impl CoherenceChecker {\n                         did: new_did,\n                         n_tps: trait_method_info.ty.generics.type_param_defs.len(),\n                         ident: trait_method_info.ty.ident,\n-                        self_type: trait_method_info.ty.self_ty\n+                        explicit_self: trait_method_info.ty.explicit_self\n                     },\n                     trait_method_def_id: trait_method_info.def_id\n                 };\n@@ -1073,7 +1073,7 @@ fn subst_receiver_types_in_method_ty(\n     impl_id: ast::node_id,\n     trait_ref: &ty::TraitRef,\n     new_def_id: ast::def_id,\n-    method: &ty::method) -> ty::method\n+    method: &ty::Method) -> ty::Method\n {\n     /*!\n      * Substitutes the values for the receiver's type parameters\n@@ -1117,19 +1117,22 @@ fn subst_receiver_types_in_method_ty(\n         tps: combined_tps\n     };\n \n-    ty::method {\n-        ident: method.ident,\n+    ty::Method::new(\n+        method.ident,\n+\n+        // method types *can* appear in the generic bounds\n+        method.generics.subst(tcx, &combined_substs),\n \n         // method tps cannot appear in the self_ty, so use `substs` from trait ref\n-        transformed_self_ty: method.transformed_self_ty.subst(tcx, &trait_ref.substs),\n-\n-        // method types *can* appear in the generic bounds or the fty\n-        generics: method.generics.subst(tcx, &combined_substs),\n-        fty: method.fty.subst(tcx, &combined_substs),\n-        self_ty: method.self_ty,\n-        vis: method.vis,\n-        def_id: new_def_id\n-    }\n+        method.transformed_self_ty.subst(tcx, &trait_ref.substs),\n+\n+        // method types *can* appear in the fty\n+        method.fty.subst(tcx, &combined_substs),\n+\n+        method.explicit_self,\n+        method.vis,\n+        new_def_id\n+    )\n }\n \n pub fn check_coherence(crate_context: @mut CrateCtxt, crate: @crate) {"}, {"sha": "39305dc62b18ba81c3cff148476e8cadaac3d027", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 38, "deletions": 42, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -52,7 +52,7 @@ use syntax::ast_map;\n use syntax::ast_util::{local_def, split_trait_methods};\n use syntax::codemap::span;\n use syntax::codemap;\n-use syntax::print::pprust::{path_to_str, self_ty_to_str};\n+use syntax::print::pprust::{path_to_str, explicit_self_to_str};\n use syntax::visit;\n use syntax::opt_vec::OptVec;\n use syntax::opt_vec;\n@@ -227,26 +227,26 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n         }, _) => {\n             let trait_ty_generics = ty_generics(ccx, region_paramd, generics, 0);\n \n-            // For each method, construct a suitable ty::method and\n+            // For each method, construct a suitable ty::Method and\n             // store it into the `tcx.methods` table:\n             for ms.each |m| {\n                 let ty_method = @match m {\n                     &ast::required(ref m) => {\n                         ty_method_of_trait_method(\n                             ccx, trait_id, region_paramd, generics,\n-                            &m.id, &m.ident, &m.self_ty,\n+                            &m.id, &m.ident, &m.explicit_self,\n                             &m.generics, &m.purity, &m.decl)\n                     }\n \n                     &ast::provided(ref m) => {\n                         ty_method_of_trait_method(\n                             ccx, trait_id, region_paramd, generics,\n-                            &m.id, &m.ident, &m.self_ty,\n+                            &m.id, &m.ident, &m.explicit_self,\n                             &m.generics, &m.purity, &m.decl)\n                     }\n                 };\n \n-                if ty_method.self_ty == ast::sty_static {\n+                if ty_method.explicit_self == ast::sty_static {\n                     make_static_method_ty(ccx, trait_id, ty_method,\n                                           &trait_ty_generics);\n                 }\n@@ -270,7 +270,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n \n     fn make_static_method_ty(ccx: &CrateCtxt,\n                              trait_id: ast::node_id,\n-                             m: &ty::method,\n+                             m: &ty::Method,\n                              trait_ty_generics: &ty::Generics) {\n         // If declaration is\n         //\n@@ -376,27 +376,27 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                                  trait_generics: &ast::Generics,\n                                  m_id: &ast::node_id,\n                                  m_ident: &ast::ident,\n-                                 m_self_ty: &ast::self_ty,\n+                                 m_explicit_self: &ast::explicit_self,\n                                  m_generics: &ast::Generics,\n                                  m_purity: &ast::purity,\n-                                 m_decl: &ast::fn_decl) -> ty::method\n+                                 m_decl: &ast::fn_decl) -> ty::Method\n     {\n         let trait_self_ty = ty::mk_self(this.tcx, local_def(trait_id));\n-        let rscope = MethodRscope::new(m_self_ty.node, trait_rp, trait_generics);\n+        let rscope = MethodRscope::new(m_explicit_self.node, trait_rp, trait_generics);\n         let (transformed_self_ty, fty) =\n             astconv::ty_of_method(this, &rscope, *m_purity, &m_generics.lifetimes,\n-                                  trait_self_ty, *m_self_ty, m_decl);\n+                                  trait_self_ty, *m_explicit_self, m_decl);\n         let num_trait_type_params = trait_generics.ty_params.len();\n-        ty::method {\n-            ident: *m_ident,\n-            generics: ty_generics(this, None, m_generics, num_trait_type_params),\n-            transformed_self_ty: transformed_self_ty,\n-            fty: fty,\n-            self_ty: m_self_ty.node,\n+        ty::Method::new(\n+            *m_ident,\n+            ty_generics(this, None, m_generics, num_trait_type_params),\n+            transformed_self_ty,\n+            fty,\n+            m_explicit_self.node,\n             // assume public, because this is only invoked on trait methods\n-            vis: ast::public,\n-            def_id: local_def(*m_id)\n-        }\n+            ast::public,\n+            local_def(*m_id)\n+        )\n     }\n }\n \n@@ -444,7 +444,7 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n pub fn compare_impl_method(tcx: ty::ctxt,\n                            impl_tps: uint,\n                            cm: &ConvertedMethod,\n-                           trait_m: &ty::method,\n+                           trait_m: &ty::Method,\n                            trait_substs: &ty::substs,\n                            self_ty: ty::t) {\n     debug!(\"compare_impl_method()\");\n@@ -459,15 +459,15 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n     // that the error messages you get out of this code are a bit more\n     // inscrutable, particularly for cases where one method has no\n     // self.\n-    match (&trait_m.self_ty, &impl_m.self_ty) {\n+    match (&trait_m.explicit_self, &impl_m.explicit_self) {\n         (&ast::sty_static, &ast::sty_static) => {}\n         (&ast::sty_static, _) => {\n             tcx.sess.span_err(\n                 cm.span,\n                 fmt!(\"method `%s` has a `%s` declaration in the impl, \\\n                       but not in the trait\",\n                      *tcx.sess.str_of(trait_m.ident),\n-                     self_ty_to_str(impl_m.self_ty, tcx.sess.intr())));\n+                     explicit_self_to_str(impl_m.explicit_self, tcx.sess.intr())));\n             return;\n         }\n         (_, &ast::sty_static) => {\n@@ -476,7 +476,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n                 fmt!(\"method `%s` has a `%s` declaration in the trait, \\\n                       but not in the impl\",\n                      *tcx.sess.str_of(trait_m.ident),\n-                     self_ty_to_str(trait_m.self_ty, tcx.sess.intr())));\n+                     explicit_self_to_str(trait_m.explicit_self, tcx.sess.intr())));\n             return;\n         }\n         _ => {\n@@ -576,14 +576,10 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n     // represent the self argument (unless this is a static method).\n     // This argument will have the *transformed* self type.\n     for trait_m.transformed_self_ty.each |&t| {\n-        trait_fn_args.push(ty::arg {\n-            ty: t\n-        });\n+        trait_fn_args.push(t);\n     }\n     for impl_m.transformed_self_ty.each |&t| {\n-        impl_fn_args.push(ty::arg {\n-            ty: t\n-        });\n+        impl_fn_args.push(t);\n     }\n \n     // Add in the normal arguments.\n@@ -727,7 +723,7 @@ pub fn convert_field(ccx: &CrateCtxt,\n }\n \n pub struct ConvertedMethod {\n-    mty: @ty::method,\n+    mty: @ty::Method,\n     id: ast::node_id,\n     span: span,\n     body_id: ast::node_id\n@@ -780,16 +776,16 @@ pub fn convert_methods(ccx: &CrateCtxt,\n                     untransformed_rcvr_ty: ty::t,\n                     rcvr_generics: &ast::Generics,\n                     rcvr_visibility: ast::visibility,\n-                    method_generics: &ast::Generics) -> ty::method\n+                    method_generics: &ast::Generics) -> ty::Method\n     {\n-        let rscope = MethodRscope::new(m.self_ty.node,\n+        let rscope = MethodRscope::new(m.explicit_self.node,\n                                        rp,\n                                        rcvr_generics);\n         let (transformed_self_ty, fty) =\n             astconv::ty_of_method(ccx, &rscope, m.purity,\n                                   &method_generics.lifetimes,\n                                   untransformed_rcvr_ty,\n-                                  m.self_ty, &m.decl);\n+                                  m.explicit_self, &m.decl);\n \n         // if the method specifies a visibility, use that, otherwise\n         // inherit the visibility from the impl (so `foo` in `pub impl\n@@ -798,15 +794,15 @@ pub fn convert_methods(ccx: &CrateCtxt,\n         let method_vis = m.vis.inherit_from(rcvr_visibility);\n \n         let num_rcvr_type_params = rcvr_generics.ty_params.len();\n-        ty::method {\n-            ident: m.ident,\n-            generics: ty_generics(ccx, None, &m.generics, num_rcvr_type_params),\n-            transformed_self_ty: transformed_self_ty,\n-            fty: fty,\n-            self_ty: m.self_ty.node,\n-            vis: method_vis,\n-            def_id: local_def(m.id)\n-        }\n+        ty::Method::new(\n+            m.ident,\n+            ty_generics(ccx, None, &m.generics, num_rcvr_type_params),\n+            transformed_self_ty,\n+            fty,\n+            m.explicit_self.node,\n+            method_vis,\n+            local_def(m.id)\n+        )\n     }\n }\n "}, {"sha": "fcd2c6ffe592ef97f59f143238770ab6c39383f1", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -55,7 +55,7 @@\n // now.\n \n use middle::ty::{FloatVar, FnSig, IntVar, TyVar};\n-use middle::ty::{IntType, UintType, arg, substs};\n+use middle::ty::{IntType, UintType, substs};\n use middle::ty;\n use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::lub::Lub;\n@@ -95,7 +95,7 @@ pub trait Combine {\n                    b: &ty::ClosureTy) -> cres<ty::ClosureTy>;\n     fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig>;\n     fn flds(&self, a: ty::field, b: ty::field) -> cres<ty::field>;\n-    fn args(&self, a: ty::arg, b: ty::arg) -> cres<ty::arg>;\n+    fn args(&self, a: ty::t, b: ty::t) -> cres<ty::t>;\n     fn sigils(&self, p1: ast::Sigil, p2: ast::Sigil) -> cres<ast::Sigil>;\n     fn purities(&self, a: purity, b: purity) -> cres<purity>;\n     fn abis(&self, a: AbiSet, b: AbiSet) -> cres<AbiSet>;\n@@ -311,12 +311,9 @@ pub fn super_flds<C:Combine>(\n     }\n }\n \n-pub fn super_args<C:Combine>(this: &C, a: ty::arg, b: ty::arg)\n-                             -> cres<ty::arg> {\n-    do this.contratys(a.ty, b.ty).chain |t| {\n-        Ok(arg {\n-            ty: t\n-        })\n+pub fn super_args<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n+    do this.contratys(a, b).chain |t| {\n+        Ok(t)\n     }\n }\n \n@@ -407,10 +404,7 @@ pub fn super_bare_fn_tys<C:Combine>(\n pub fn super_fn_sigs<C:Combine>(\n     this: &C, a_f: &ty::FnSig, b_f: &ty::FnSig) -> cres<ty::FnSig>\n {\n-    fn argvecs<C:Combine>(this: &C,\n-                          a_args: &[ty::arg],\n-                          b_args: &[ty::arg]) -> cres<~[ty::arg]>\n-    {\n+    fn argvecs<C:Combine>(this: &C, a_args: &[ty::t], b_args: &[ty::t]) -> cres<~[ty::t]> {\n         if vec::same_length(a_args, b_args) {\n             map_vec2(a_args, b_args, |a, b| this.args(*a, *b))\n         } else {"}, {"sha": "42e42ddb1e7635867285858d9520738ecabcf158", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -153,7 +153,7 @@ impl Combine for Glb {\n         super_trait_stores(self, vk, a, b)\n     }\n \n-    fn args(&self, a: ty::arg, b: ty::arg) -> cres<ty::arg> {\n+    fn args(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n         super_args(self, a, b)\n     }\n "}, {"sha": "20a051f053185d5b13e339aae1fe055c3de29b81", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -236,7 +236,7 @@ impl Combine for Lub {\n         super_trait_stores(self, vk, a, b)\n     }\n \n-    fn args(&self, a: ty::arg, b: ty::arg) -> cres<ty::arg> {\n+    fn args(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n         super_args(self, a, b)\n     }\n "}, {"sha": "ca083bc2d86d9f75c984c2db3dddeacbc924e401", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -245,7 +245,7 @@ impl Combine for Sub {\n         super_trait_stores(self, vk, a, b)\n     }\n \n-    fn args(&self, a: ty::arg, b: ty::arg) -> cres<ty::arg> {\n+    fn args(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n         super_args(self, a, b)\n     }\n "}, {"sha": "d9088c064939b432ca0adfc8031c4f4ad08896c8", "filename": "src/librustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -31,7 +31,7 @@ impl InferStr for ty::t {\n impl InferStr for FnSig {\n     fn inf_str(&self, cx: &InferCtxt) -> ~str {\n         fmt!(\"(%s) -> %s\",\n-             str::connect(self.inputs.map(|a| a.ty.inf_str(cx)), \", \"),\n+             str::connect(self.inputs.map(|a| a.inf_str(cx)), \", \"),\n              self.output.inf_str(cx))\n     }\n }"}, {"sha": "95c8f242b49e148a57104b70384bd835be75d094", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -118,13 +118,13 @@ pub struct method_param {\n pub struct method_map_entry {\n     // the type of the self parameter, which is not reflected in the fn type\n     // (FIXME #3446)\n-    self_arg: ty::arg,\n+    self_ty: ty::t,\n \n     // the mode of `self`\n     self_mode: ty::SelfMode,\n \n     // the type of explicit self on the method\n-    explicit_self: ast::self_ty_,\n+    explicit_self: ast::explicit_self_,\n \n     // method details being invoked\n     origin: method_origin,\n@@ -351,22 +351,15 @@ fn check_start_fn_ty(ccx: @mut CrateCtxt,\n                 _ => ()\n             }\n \n-            fn arg(ty: ty::t) -> ty::arg {\n-                ty::arg {\n-                    ty: ty\n-                }\n-            }\n-\n             let se_ty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n                 purity: ast::impure_fn,\n                 abis: abi::AbiSet::Rust(),\n                 sig: ty::FnSig {\n                     bound_lifetime_names: opt_vec::Empty,\n                     inputs: ~[\n-                        arg(ty::mk_int()),\n-                        arg(ty::mk_imm_ptr(tcx,\n-                                           ty::mk_imm_ptr(tcx, ty::mk_u8()))),\n-                        arg(ty::mk_imm_ptr(tcx, ty::mk_u8()))\n+                        ty::mk_int(),\n+                        ty::mk_imm_ptr(tcx, ty::mk_imm_ptr(tcx, ty::mk_u8())),\n+                        ty::mk_imm_ptr(tcx, ty::mk_u8())\n                     ],\n                     output: ty::mk_int()\n                 }"}, {"sha": "7c37784b09db9ff7922192f2b9e57a13bd4e447d", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -142,22 +142,22 @@ impl RegionParameterization {\n }\n \n pub struct MethodRscope {\n-    self_ty: ast::self_ty_,\n+    explicit_self: ast::explicit_self_,\n     variance: Option<ty::region_variance>,\n     region_param_names: RegionParamNames,\n }\n \n impl MethodRscope {\n     // `generics` here refers to the generics of the outer item (impl or\n     // trait).\n-    pub fn new(self_ty: ast::self_ty_,\n+    pub fn new(explicit_self: ast::explicit_self_,\n                variance: Option<ty::region_variance>,\n                rcvr_generics: &ast::Generics)\n             -> MethodRscope {\n         let region_param_names =\n             RegionParamNames::from_generics(rcvr_generics);\n         MethodRscope {\n-            self_ty: self_ty,\n+            explicit_self: explicit_self,\n             variance: variance,\n             region_param_names: region_param_names\n         }"}, {"sha": "62b5eed1435f083feb905d17d3fa11eda49937a2", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -11,7 +11,7 @@\n use metadata::encoder;\n use middle::ty::{ReSkolemized, ReVar};\n use middle::ty::{bound_region, br_anon, br_named, br_self, br_cap_avoid};\n-use middle::ty::{br_fresh, ctxt, field, method};\n+use middle::ty::{br_fresh, ctxt, field};\n use middle::ty::{mt, t, param_ty};\n use middle::ty::{re_bound, re_free, re_scope, re_infer, re_static, Region,\n                  re_empty};\n@@ -281,7 +281,7 @@ pub fn tys_to_str(cx: ctxt, ts: &[t]) -> ~str {\n \n pub fn fn_sig_to_str(cx: ctxt, typ: &ty::FnSig) -> ~str {\n     fmt!(\"fn%s -> %s\",\n-         tys_to_str(cx, typ.inputs.map(|a| a.ty)),\n+         tys_to_str(cx, typ.inputs.map(|a| *a)),\n          ty_to_str(cx, typ.output))\n }\n \n@@ -290,8 +290,8 @@ pub fn trait_ref_to_str(cx: ctxt, trait_ref: &ty::TraitRef) -> ~str {\n }\n \n pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n-    fn fn_input_to_str(cx: ctxt, input: ty::arg) -> ~str {\n-        ty_to_str(cx, input.ty)\n+    fn fn_input_to_str(cx: ctxt, input: ty::t) -> ~str {\n+        ty_to_str(cx, input)\n     }\n     fn bare_fn_to_str(cx: ctxt,\n                       purity: ast::purity,\n@@ -375,7 +375,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n             }\n         }\n     }\n-    fn method_to_str(cx: ctxt, m: method) -> ~str {\n+    fn method_to_str(cx: ctxt, m: ty::Method) -> ~str {\n         bare_fn_to_str(cx,\n                        m.fty.purity,\n                        m.fty.abis,\n@@ -633,15 +633,15 @@ impl Repr for ty::Generics {\n     }\n }\n \n-impl Repr for ty::method {\n+impl Repr for ty::Method {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         fmt!(\"method {ident: %s, generics: %s, transformed_self_ty: %s, \\\n-              fty: %s, self_ty: %s, vis: %s, def_id: %s}\",\n+              fty: %s, explicit_self: %s, vis: %s, def_id: %s}\",\n              self.ident.repr(tcx),\n              self.generics.repr(tcx),\n              self.transformed_self_ty.repr(tcx),\n              self.fty.repr(tcx),\n-             self.self_ty.repr(tcx),\n+             self.explicit_self.repr(tcx),\n              self.vis.repr(tcx),\n              self.def_id.repr(tcx))\n     }\n@@ -653,7 +653,7 @@ impl Repr for ast::ident {\n     }\n }\n \n-impl Repr for ast::self_ty_ {\n+impl Repr for ast::explicit_self_ {\n     fn repr(&self, _tcx: ctxt) -> ~str {\n         fmt!(\"%?\", *self)\n     }\n@@ -685,18 +685,12 @@ impl Repr for typeck::method_map_entry {\n         fmt!(\"method_map_entry {self_arg: %s, \\\n               explicit_self: %s, \\\n               origin: %s}\",\n-             self.self_arg.repr(tcx),\n+             self.self_ty.repr(tcx),\n              self.explicit_self.repr(tcx),\n              self.origin.repr(tcx))\n     }\n }\n \n-impl Repr for ty::arg {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n-        fmt!(\"(%s)\", self.ty.repr(tcx))\n-    }\n-}\n-\n impl Repr for typeck::method_origin {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         match self {"}, {"sha": "18fdf958aa962938a069713b95cfa22c1d5a5c56", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -187,7 +187,7 @@ fn get_method_sig(\n                                     &ty_m.decl,\n                                     ty_m.purity,\n                                     ty_m.ident,\n-                                    Some(ty_m.self_ty.node),\n+                                    Some(ty_m.explicit_self.node),\n                                     &ty_m.generics,\n                                     extract::interner()\n                                 ))\n@@ -197,7 +197,7 @@ fn get_method_sig(\n                                     &m.decl,\n                                     m.purity,\n                                     m.ident,\n-                                    Some(m.self_ty.node),\n+                                    Some(m.explicit_self.node),\n                                     &m.generics,\n                                     extract::interner()\n                                 ))\n@@ -218,7 +218,7 @@ fn get_method_sig(\n                             &method.decl,\n                             method.purity,\n                             method.ident,\n-                            Some(method.self_ty.node),\n+                            Some(method.explicit_self.node),\n                             &method.generics,\n                             extract::interner()\n                         ))"}, {"sha": "f77d00ce9b1961912e244cfd77d44b7c302b6229", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 45, "deletions": 4, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -17,6 +17,7 @@ use opt_vec::OptVec;\n use core::cast;\n use core::option::{None, Option, Some};\n use core::to_bytes;\n+use core::to_bytes::IterBytes;\n use core::to_str::ToStr;\n use std::serialize::{Encodable, Decodable, Encoder, Decoder};\n \n@@ -123,6 +124,20 @@ pub struct Lifetime {\n     ident: ident\n }\n \n+#[cfg(stage0)]\n+impl to_bytes::IterBytes for Lifetime {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n+        to_bytes::iter_bytes_3(&self.id, &self.span, &self.ident, lsb0, f)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for Lifetime {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        to_bytes::iter_bytes_3(&self.id, &self.span, &self.ident, lsb0, f)\n+    }\n+}\n+\n // a \"Path\" is essentially Rust's notion of a name;\n // for instance: core::cmp::Eq  .  It's represented\n // as a sequence of identifiers, along with a bunch\n@@ -754,7 +769,7 @@ pub struct ty_method {\n     purity: purity,\n     decl: fn_decl,\n     generics: Generics,\n-    self_ty: self_ty,\n+    explicit_self: explicit_self,\n     id: node_id,\n     span: span,\n }\n@@ -1051,15 +1066,41 @@ impl to_bytes::IterBytes for ret_style {\n #[auto_encode]\n #[auto_decode]\n #[deriving(Eq)]\n-pub enum self_ty_ {\n+pub enum explicit_self_ {\n     sty_static,                                // no self\n     sty_value,                                 // `self`\n     sty_region(Option<@Lifetime>, mutability), // `&'lt self`\n     sty_box(mutability),                       // `@self`\n     sty_uniq(mutability)                       // `~self`\n }\n \n-pub type self_ty = spanned<self_ty_>;\n+#[cfg(stage0)]\n+impl to_bytes::IterBytes for explicit_self_ {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n+        match *self {\n+            sty_static => 0u8.iter_bytes(lsb0, f),\n+            sty_value => 1u8.iter_bytes(lsb0, f),\n+            sty_region(ref lft, ref mutbl) => to_bytes::iter_bytes_3(&2u8, &lft, mutbl, lsb0, f),\n+            sty_box(ref mutbl) => to_bytes::iter_bytes_2(&3u8, mutbl, lsb0, f),\n+            sty_uniq(ref mutbl) => to_bytes::iter_bytes_2(&4u8, mutbl, lsb0, f),\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for explicit_self_ {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        match *self {\n+            sty_static => 0u8.iter_bytes(lsb0, f),\n+            sty_value => 1u8.iter_bytes(lsb0, f),\n+            sty_region(ref lft, ref mutbl) => to_bytes::iter_bytes_3(&2u8, &lft, mutbl, lsb0, f),\n+            sty_box(ref mutbl) => to_bytes::iter_bytes_2(&3u8, mutbl, lsb0, f),\n+            sty_uniq(ref mutbl) => to_bytes::iter_bytes_2(&4u8, mutbl, lsb0, f),\n+        }\n+    }\n+}\n+\n+pub type explicit_self = spanned<explicit_self_>;\n \n #[auto_encode]\n #[auto_decode]\n@@ -1068,7 +1109,7 @@ pub struct method {\n     ident: ident,\n     attrs: ~[attribute],\n     generics: Generics,\n-    self_ty: self_ty,\n+    explicit_self: explicit_self,\n     purity: purity,\n     decl: fn_decl,\n     body: blk,"}, {"sha": "a98e3002dcfbbe5e476c81dbed16e614afabd4ad", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -272,7 +272,7 @@ pub fn trait_method_to_ty_method(method: &trait_method) -> ty_method {\n                 purity: m.purity,\n                 decl: copy m.decl,\n                 generics: copy m.generics,\n-                self_ty: m.self_ty,\n+                explicit_self: m.explicit_self,\n                 id: m.id,\n                 span: m.span,\n             }"}, {"sha": "cd0b29f2a1e3f12024a055812eea467873a0d8f6", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -152,6 +152,20 @@ impl<D:Decoder> Decodable<D> for span {\n     }\n }\n \n+#[cfg(stage0)]\n+impl to_bytes::IterBytes for span {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n+        to_bytes::iter_bytes_3(&self.lo, &self.hi, &self.expn_info, lsb0, f);\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for span {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        to_bytes::iter_bytes_3(&self.lo, &self.hi, &self.expn_info, lsb0, f)\n+    }\n+}\n+\n pub fn spanned<T>(lo: BytePos, hi: BytePos, t: T) -> spanned<T> {\n     respan(mk_sp(lo, hi), t)\n }\n@@ -199,16 +213,62 @@ pub struct FileMapAndLine {fm: @FileMap, line: uint}\n pub struct FileMapAndBytePos {fm: @FileMap, pos: BytePos}\n pub struct NameAndSpan {name: ~str, span: Option<span>}\n \n+#[cfg(stage0)]\n+impl to_bytes::IterBytes for NameAndSpan {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n+        to_bytes::iter_bytes_2(&self.name, &self.span, lsb0, f)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for NameAndSpan {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        to_bytes::iter_bytes_2(&self.name, &self.span, lsb0, f)\n+    }\n+}\n+\n pub struct CallInfo {\n     call_site: span,\n     callee: NameAndSpan\n }\n \n+#[cfg(stage0)]\n+impl to_bytes::IterBytes for CallInfo {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n+        to_bytes::iter_bytes_2(&self.call_site, &self.callee, lsb0, f)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for CallInfo {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        to_bytes::iter_bytes_2(&self.call_site, &self.callee, lsb0, f)\n+    }\n+}\n+\n /// Extra information for tracking macro expansion of spans\n pub enum ExpnInfo {\n     ExpandedFrom(CallInfo)\n }\n \n+#[cfg(stage0)]\n+impl to_bytes::IterBytes for ExpnInfo {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n+        match *self {\n+            ExpandedFrom(ref call_info) => to_bytes::iter_bytes_2(&0u8, call_info, lsb0, f)\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for ExpnInfo {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        match *self {\n+            ExpandedFrom(ref call_info) => to_bytes::iter_bytes_2(&0u8, call_info, lsb0, f)\n+        }\n+    }\n+}\n+\n pub type FileName = ~str;\n \n pub struct FileLines"}, {"sha": "fa9d69c6e99108394823fbb0dd93e335cef59a50", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -713,7 +713,7 @@ fn mk_ser_method(\n         ident: cx.ident_of(\"encode\"),\n         attrs: ~[],\n         generics: ast_util::empty_generics(),\n-        self_ty: codemap::spanned {\n+        explicit_self: codemap::spanned {\n             node: ast::sty_region(None, ast::m_imm),\n             span: span\n         },\n@@ -772,7 +772,7 @@ fn mk_deser_method(\n         ident: cx.ident_of(\"decode\"),\n         attrs: ~[],\n         generics: ast_util::empty_generics(),\n-        self_ty: codemap::spanned { node: ast::sty_static, span: span },\n+        explicit_self: codemap::spanned { node: ast::sty_static, span: span },\n         purity: ast::impure_fn,\n         decl: deser_decl,\n         body: deser_body,"}, {"sha": "1a45107c267387b503ad270f93f98141af8e333a", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -28,7 +28,7 @@ pub fn expand_deriving_clone(cx: @ext_ctxt,\n             MethodDef {\n                 name: ~\"clone\",\n                 generics: LifetimeBounds::empty(),\n-                self_ty: borrowed_explicit_self(),\n+                explicit_self: borrowed_explicit_self(),\n                 args: ~[],\n                 ret_ty: Self,\n                 const_nonmatching: false,"}, {"sha": "7fc2fdc7963587a8af6b49744cd43e347780bd65", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -34,7 +34,7 @@ pub fn expand_deriving_eq(cx: @ext_ctxt,\n             MethodDef {\n                 name: $name,\n                 generics: LifetimeBounds::empty(),\n-                self_ty: borrowed_explicit_self(),\n+                explicit_self: borrowed_explicit_self(),\n                 args: ~[borrowed_self()],\n                 ret_ty: Literal(Path::new(~[~\"bool\"])),\n                 const_nonmatching: true,"}, {"sha": "5445aef4491be2954e1bd3b9213811fd7335f5db", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -24,7 +24,7 @@ pub fn expand_deriving_ord(cx: @ext_ctxt,\n             MethodDef {\n                 name: $name,\n                 generics: LifetimeBounds::empty(),\n-                self_ty: borrowed_explicit_self(),\n+                explicit_self: borrowed_explicit_self(),\n                 args: ~[borrowed_self()],\n                 ret_ty: Literal(Path::new(~[~\"bool\"])),\n                 const_nonmatching: false,"}, {"sha": "4541569b829ac10995d5a952d7ea3b8b22482db6", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -33,7 +33,7 @@ pub fn expand_deriving_totaleq(cx: @ext_ctxt,\n             MethodDef {\n                 name: ~\"equals\",\n                 generics: LifetimeBounds::empty(),\n-                self_ty: borrowed_explicit_self(),\n+                explicit_self: borrowed_explicit_self(),\n                 args: ~[borrowed_self()],\n                 ret_ty: Literal(Path::new(~[~\"bool\"])),\n                 const_nonmatching: true,"}, {"sha": "8f156e6a9e315afe11ae547022eb614d3715853f", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -27,7 +27,7 @@ pub fn expand_deriving_totalord(cx: @ext_ctxt,\n             MethodDef {\n                 name: ~\"cmp\",\n                 generics: LifetimeBounds::empty(),\n-                self_ty: borrowed_explicit_self(),\n+                explicit_self: borrowed_explicit_self(),\n                 args: ~[borrowed_self()],\n                 ret_ty: Literal(Path::new(~[~\"core\", ~\"cmp\", ~\"Ordering\"])),\n                 const_nonmatching: false,"}, {"sha": "3be65ecd8db9cc53f88cf70f063f66d8e391dcbe", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -119,13 +119,13 @@ fn create_decode_method(\n     let body_block = build::mk_simple_block(cx, span, expr);\n \n     // Create the method.\n-    let self_ty = spanned { node: sty_static, span: span };\n+    let explicit_self = spanned { node: sty_static, span: span };\n     let method_ident = cx.ident_of(\"decode\");\n     @ast::method {\n         ident: method_ident,\n         attrs: ~[],\n         generics: ast_util::empty_generics(),\n-        self_ty: self_ty,\n+        explicit_self: explicit_self,\n         purity: impure_fn,\n         decl: fn_decl,\n         body: body_block,"}, {"sha": "2078ec9d45cf483ba3a5b7ebc72c64c8f891d444", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -111,13 +111,13 @@ fn create_encode_method(\n     let body_block = build::mk_block_(cx, span, statements);\n \n     // Create the method.\n-    let self_ty = spanned { node: sty_region(None, m_imm), span: span };\n+    let explicit_self = spanned { node: sty_region(None, m_imm), span: span };\n     let method_ident = cx.ident_of(\"encode\");\n     @ast::method {\n         ident: method_ident,\n         attrs: ~[],\n         generics: ast_util::empty_generics(),\n-        self_ty: self_ty,\n+        explicit_self: explicit_self,\n         purity: impure_fn,\n         decl: fn_decl,\n         body: body_block,"}, {"sha": "fc14e3c3f732b83d5ef1f03405a00877b2038a95", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -216,7 +216,7 @@ pub struct MethodDef<'self> {\n     /// Whether there is a self argument (outer Option) i.e. whether\n     /// this is a static function, and whether it is a pointer (inner\n     /// Option)\n-    self_ty: Option<Option<PtrTy>>,\n+    explicit_self: Option<Option<PtrTy>>,\n \n     /// Arguments other than the self argument\n     args: ~[Ty],\n@@ -321,7 +321,7 @@ impl<'self> TraitDef<'self> {\n                          type_ident: ident,\n                          generics: &Generics) -> @ast::item {\n         let methods = do self.methods.map |method_def| {\n-            let (self_ty, self_args, nonself_args, tys) =\n+            let (explicit_self, self_args, nonself_args, tys) =\n                 method_def.split_self_nonself_args(cx, span, type_ident, generics);\n \n             let body = if method_def.is_static() {\n@@ -339,7 +339,7 @@ impl<'self> TraitDef<'self> {\n \n             method_def.create_method(cx, span,\n                                      type_ident, generics,\n-                                     self_ty, tys,\n+                                     explicit_self, tys,\n                                      body)\n         };\n \n@@ -352,7 +352,7 @@ impl<'self> TraitDef<'self> {\n                        type_ident: ident,\n                        generics: &Generics) -> @ast::item {\n         let methods = do self.methods.map |method_def| {\n-            let (self_ty, self_args, nonself_args, tys) =\n+            let (explicit_self, self_args, nonself_args, tys) =\n                 method_def.split_self_nonself_args(cx, span, type_ident, generics);\n \n             let body = if method_def.is_static() {\n@@ -370,7 +370,7 @@ impl<'self> TraitDef<'self> {\n \n             method_def.create_method(cx, span,\n                                      type_ident, generics,\n-                                     self_ty, tys,\n+                                     explicit_self, tys,\n                                      body)\n         };\n \n@@ -404,28 +404,27 @@ impl<'self> MethodDef<'self> {\n     }\n \n     fn is_static(&self) -> bool {\n-        self.self_ty.is_none()\n+        self.explicit_self.is_none()\n     }\n \n     fn split_self_nonself_args(&self, cx: @ext_ctxt, span: span,\n                              type_ident: ident, generics: &Generics)\n-        -> (ast::self_ty, ~[@expr], ~[@expr], ~[(ident, @ast::Ty)]) {\n+        -> (ast::explicit_self, ~[@expr], ~[@expr], ~[(ident, @ast::Ty)]) {\n \n         let mut self_args = ~[], nonself_args = ~[], arg_tys = ~[];\n-        let mut ast_self_ty = respan(span, ast::sty_static);\n         let mut nonstatic = false;\n \n-        match self.self_ty {\n+        let ast_explicit_self = match self.explicit_self {\n             Some(ref self_ptr) => {\n-                let (self_expr, self_ty) = ty::get_explicit_self(cx, span,\n-                                                                 self_ptr);\n+                let (self_expr, explicit_self) = ty::get_explicit_self(cx, span, self_ptr);\n \n-                ast_self_ty = self_ty;\n                 self_args.push(self_expr);\n                 nonstatic = true;\n+\n+                explicit_self\n             }\n-            _ => {}\n-        }\n+            None => respan(span, ast::sty_static),\n+        };\n \n         for self.args.eachi |i, ty| {\n             let ast_ty = ty.to_ty(cx, span, type_ident, generics);\n@@ -449,13 +448,13 @@ impl<'self> MethodDef<'self> {\n             }\n         }\n \n-        (ast_self_ty, self_args, nonself_args, arg_tys)\n+        (ast_explicit_self, self_args, nonself_args, arg_tys)\n     }\n \n     fn create_method(&self, cx: @ext_ctxt, span: span,\n                      type_ident: ident,\n                      generics: &Generics,\n-                     self_ty: ast::self_ty,\n+                     explicit_self: ast::explicit_self,\n                      arg_types: ~[(ident, @ast::Ty)],\n                      body: @expr) -> @ast::method {\n         // create the generics that aren't for Self\n@@ -477,7 +476,7 @@ impl<'self> MethodDef<'self> {\n             ident: method_ident,\n             attrs: ~[],\n             generics: fn_generics,\n-            self_ty: self_ty,\n+            explicit_self: explicit_self,\n             purity: ast::impure_fn,\n             decl: fn_decl,\n             body: body_block,"}, {"sha": "27e3a54add540c65bca27e3b3319046d3ae9873c", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -26,7 +26,7 @@ pub fn expand_deriving_iter_bytes(cx: @ext_ctxt,\n             MethodDef {\n                 name: ~\"iter_bytes\",\n                 generics: LifetimeBounds::empty(),\n-                self_ty: borrowed_explicit_self(),\n+                explicit_self: borrowed_explicit_self(),\n                 args: ~[\n                     Literal(Path::new(~[~\"bool\"])),\n                     Literal(Path::new(~[~\"core\", ~\"to_bytes\", ~\"Cb\"]))"}, {"sha": "2d91fcd346ae5090bf3b72c0573f387f6c85f44b", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -32,7 +32,7 @@ pub fn expand_deriving_rand(cx: @ext_ctxt,\n                     bounds: ~[(~\"R\",\n                                ~[ Path::new(~[~\"core\", ~\"rand\", ~\"Rng\"]) ])]\n                 },\n-                self_ty: None,\n+                explicit_self: None,\n                 args: ~[\n                     Ptr(~Literal(Path::new_local(~\"R\")),\n                         Borrowed(None, ast::m_mutbl))"}, {"sha": "13cb09e970df6046580e970d9ae1b74288ed6fa7", "filename": "src/libsyntax/ext/deriving/to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -27,7 +27,7 @@ pub fn expand_deriving_to_str(cx: @ext_ctxt,\n             MethodDef {\n                 name: ~\"to_str\",\n                 generics: LifetimeBounds::empty(),\n-                self_ty: borrowed_explicit_self(),\n+                explicit_self: borrowed_explicit_self(),\n                 args: ~[],\n                 ret_ty: Ptr(~Literal(Path::new_local(~\"str\")), Owned),\n                 const_nonmatching: false,"}, {"sha": "8fd372e47928633f5fd230fd31d3fde32cc3e23e", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -217,7 +217,7 @@ pub impl LifetimeBounds {\n \n \n pub fn get_explicit_self(cx: @ext_ctxt, span: span, self_ptr: &Option<PtrTy>)\n-    -> (@expr, ast::self_ty) {\n+    -> (@expr, ast::explicit_self) {\n     let self_path = build::make_self(cx, span);\n     match *self_ptr {\n         None => {"}, {"sha": "f6dbbbf420d8e676d1f60ef3dca50cf36d8e51f9", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -323,7 +323,7 @@ fn noop_fold_method(m: @method, fld: @ast_fold) -> @method {\n         ident: fld.fold_ident(m.ident),\n         attrs: /* FIXME (#2543) */ copy m.attrs,\n         generics: fold_generics(&m.generics, fld),\n-        self_ty: m.self_ty,\n+        explicit_self: m.explicit_self,\n         purity: m.purity,\n         decl: fold_fn_decl(&m.decl, fld),\n         body: fld.fold_block(&m.body),"}, {"sha": "b1fa47f69178f23db8bec361bb799a82d9e4b64e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -19,7 +19,7 @@ use ast::{_mod, add, arg, arm, attribute, bind_by_ref, bind_infer};\n use ast::{bind_by_copy, bitand, bitor, bitxor, blk};\n use ast::{blk_check_mode, box};\n use ast::{crate, crate_cfg, decl, decl_item};\n-use ast::{decl_local, default_blk, deref, div, enum_def};\n+use ast::{decl_local, default_blk, deref, div, enum_def, explicit_self};\n use ast::{expr, expr_, expr_addr_of, expr_match, expr_again};\n use ast::{expr_assign, expr_assign_op, expr_binary, expr_block};\n use ast::{expr_break, expr_call, expr_cast, expr_copy, expr_do_body};\n@@ -43,7 +43,7 @@ use ast::{named_field, neg, node_id, noreturn, not, pat, pat_box, pat_enum};\n use ast::{pat_ident, pat_lit, pat_range, pat_region, pat_struct};\n use ast::{pat_tup, pat_uniq, pat_wild, private};\n use ast::{rem, required};\n-use ast::{ret_style, return_val, self_ty, shl, shr, stmt, stmt_decl};\n+use ast::{ret_style, return_val, shl, shr, stmt, stmt_decl};\n use ast::{stmt_expr, stmt_semi, stmt_mac, struct_def, struct_field};\n use ast::{struct_variant_kind, subtract};\n use ast::{sty_box, sty_region, sty_static, sty_uniq, sty_value};\n@@ -504,7 +504,7 @@ pub impl Parser {\n \n             let generics = p.parse_generics();\n \n-            let (self_ty, d) = do self.parse_fn_decl_with_self() |p| {\n+            let (explicit_self, d) = do self.parse_fn_decl_with_self() |p| {\n                 // This is somewhat dubious; We don't want to allow argument\n                 // names to be left off if there is a definition...\n                 either::Left(p.parse_arg_general(false))\n@@ -526,7 +526,7 @@ pub impl Parser {\n                     purity: pur,\n                     decl: d,\n                     generics: generics,\n-                    self_ty: self_ty,\n+                    explicit_self: explicit_self,\n                     id: p.get_id(),\n                     span: mk_sp(lo, hi)\n                 })\n@@ -540,7 +540,7 @@ pub impl Parser {\n                     ident: ident,\n                     attrs: attrs,\n                     generics: generics,\n-                    self_ty: self_ty,\n+                    explicit_self: explicit_self,\n                     purity: pur,\n                     decl: d,\n                     body: body,\n@@ -3002,11 +3002,11 @@ pub impl Parser {\n         &self,\n         parse_arg_fn:\n         &fn(&Parser) -> arg_or_capture_item\n-    ) -> (self_ty, fn_decl) {\n-        fn maybe_parse_self_ty(\n-            cnstr: &fn(v: mutability) -> ast::self_ty_,\n+    ) -> (explicit_self, fn_decl) {\n+        fn maybe_parse_explicit_self(\n+            cnstr: &fn(v: mutability) -> ast::explicit_self_,\n             p: &Parser\n-        ) -> ast::self_ty_ {\n+        ) -> ast::explicit_self_ {\n             // We need to make sure it isn't a mode or a type\n             if p.token_is_keyword(&~\"self\", &p.look_ahead(1)) ||\n                 ((p.token_is_keyword(&~\"const\", &p.look_ahead(1)) ||\n@@ -3022,7 +3022,7 @@ pub impl Parser {\n             }\n         }\n \n-        fn maybe_parse_borrowed_self_ty(this: &Parser) -> ast::self_ty_ {\n+        fn maybe_parse_borrowed_explicit_self(this: &Parser) -> ast::explicit_self_ {\n             // The following things are possible to see here:\n             //\n             //     fn(&self)\n@@ -3066,15 +3066,15 @@ pub impl Parser {\n         // A bit of complexity and lookahead is needed here in order to to be\n         // backwards compatible.\n         let lo = self.span.lo;\n-        let self_ty = match *self.token {\n+        let explicit_self = match *self.token {\n           token::BINOP(token::AND) => {\n-            maybe_parse_borrowed_self_ty(self)\n+            maybe_parse_borrowed_explicit_self(self)\n           }\n           token::AT => {\n-            maybe_parse_self_ty(sty_box, self)\n+            maybe_parse_explicit_self(sty_box, self)\n           }\n           token::TILDE => {\n-            maybe_parse_self_ty(sty_uniq, self)\n+            maybe_parse_explicit_self(sty_uniq, self)\n           }\n           token::IDENT(*) if self.is_self_ident() => {\n             self.bump();\n@@ -3087,7 +3087,7 @@ pub impl Parser {\n \n         // If we parsed a self type, expect a comma before the argument list.\n         let args_or_capture_items;\n-        if self_ty != sty_static {\n+        if explicit_self != sty_static {\n             match *self.token {\n                 token::COMMA => {\n                     self.bump();\n@@ -3132,7 +3132,7 @@ pub impl Parser {\n             cf: ret_style\n         };\n \n-        (spanned(lo, hi, self_ty), fn_decl)\n+        (spanned(lo, hi, explicit_self), fn_decl)\n     }\n \n     // parse the |arg, arg| header on a lambda\n@@ -3199,7 +3199,7 @@ pub impl Parser {\n         let pur = self.parse_fn_purity();\n         let ident = self.parse_ident();\n         let generics = self.parse_generics();\n-        let (self_ty, decl) = do self.parse_fn_decl_with_self() |p| {\n+        let (explicit_self, decl) = do self.parse_fn_decl_with_self() |p| {\n             p.parse_arg()\n         };\n \n@@ -3210,7 +3210,7 @@ pub impl Parser {\n             ident: ident,\n             attrs: attrs,\n             generics: generics,\n-            self_ty: self_ty,\n+            explicit_self: explicit_self,\n             purity: pur,\n             decl: decl,\n             body: body,"}, {"sha": "49a30d153dc1f9f8db17ff8534eb7257808604ba", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/217f96339a168db3e25ba4b09c0fbc226a613b16/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=217f96339a168db3e25ba4b09c0fbc226a613b16", "patch": "@@ -181,12 +181,12 @@ pub fn path_to_str(p: @ast::Path, intr: @ident_interner) -> ~str {\n }\n \n pub fn fun_to_str(decl: &ast::fn_decl, purity: ast::purity, name: ast::ident,\n-                  opt_self_ty: Option<ast::self_ty_>,\n+                  opt_explicit_self: Option<ast::explicit_self_>,\n                   generics: &ast::Generics, intr: @ident_interner) -> ~str {\n     do io::with_str_writer |wr| {\n         let s = rust_printer(wr, intr);\n         print_fn(s, decl, Some(purity), AbiSet::Rust(),\n-                 name, generics, opt_self_ty, ast::inherited);\n+                 name, generics, opt_explicit_self, ast::inherited);\n         end(s); // Close the head box\n         end(s); // Close the outer box\n         eof(s.s);\n@@ -797,7 +797,7 @@ pub fn print_ty_method(s: @ps, m: &ast::ty_method) {\n     print_outer_attributes(s, m.attrs);\n     print_ty_fn(s, None, None, None, m.purity, ast::Many,\n                 &m.decl, Some(m.ident), Some(&m.generics),\n-                Some(/*bad*/ copy m.self_ty.node));\n+                Some(/*bad*/ copy m.explicit_self.node));\n     word(s.s, ~\";\");\n }\n \n@@ -813,7 +813,7 @@ pub fn print_method(s: @ps, meth: @ast::method) {\n     maybe_print_comment(s, meth.span.lo);\n     print_outer_attributes(s, meth.attrs);\n     print_fn(s, &meth.decl, Some(meth.purity), AbiSet::Rust(),\n-             meth.ident, &meth.generics, Some(meth.self_ty.node),\n+             meth.ident, &meth.generics, Some(meth.explicit_self.node),\n              meth.vis);\n     word(s.s, ~\" \");\n     print_block_with_attrs(s, &meth.body, meth.attrs);\n@@ -1626,13 +1626,13 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n     (s.ann.post)(ann_node);\n }\n \n-pub fn self_ty_to_str(self_ty: ast::self_ty_, intr: @ident_interner) -> ~str {\n-    to_str(self_ty, |a, b| { print_self_ty(a, b); () }, intr)\n+pub fn explicit_self_to_str(explicit_self: ast::explicit_self_, intr: @ident_interner) -> ~str {\n+    to_str(explicit_self, |a, b| { print_explicit_self(a, b); () }, intr)\n }\n \n // Returns whether it printed anything\n-pub fn print_self_ty(s: @ps, self_ty: ast::self_ty_) -> bool {\n-    match self_ty {\n+pub fn print_explicit_self(s: @ps, explicit_self: ast::explicit_self_) -> bool {\n+    match explicit_self {\n         ast::sty_static => { return false; }\n         ast::sty_value => { word(s.s, ~\"self\"); }\n         ast::sty_region(lt, m) => {\n@@ -1657,24 +1657,24 @@ pub fn print_fn(s: @ps,\n                 abis: AbiSet,\n                 name: ast::ident,\n                 generics: &ast::Generics,\n-                opt_self_ty: Option<ast::self_ty_>,\n+                opt_explicit_self: Option<ast::explicit_self_>,\n                 vis: ast::visibility) {\n     head(s, ~\"\");\n-    print_fn_header_info(s, opt_self_ty, purity, abis, ast::Many, None, vis);\n+    print_fn_header_info(s, opt_explicit_self, purity, abis, ast::Many, None, vis);\n     nbsp(s);\n     print_ident(s, name);\n     print_generics(s, generics);\n-    print_fn_args_and_ret(s, decl, opt_self_ty);\n+    print_fn_args_and_ret(s, decl, opt_explicit_self);\n }\n \n pub fn print_fn_args(s: @ps, decl: &ast::fn_decl,\n-                 opt_self_ty: Option<ast::self_ty_>) {\n+                 opt_explicit_self: Option<ast::explicit_self_>) {\n     // It is unfortunate to duplicate the commasep logic, but we we want the\n     // self type and the args all in the same box.\n     box(s, 0u, inconsistent);\n     let mut first = true;\n-    for opt_self_ty.each |self_ty| {\n-        first = !print_self_ty(s, *self_ty);\n+    for opt_explicit_self.each |explicit_self| {\n+        first = !print_explicit_self(s, *explicit_self);\n     }\n \n     for decl.inputs.each |arg| {\n@@ -1686,9 +1686,9 @@ pub fn print_fn_args(s: @ps, decl: &ast::fn_decl,\n }\n \n pub fn print_fn_args_and_ret(s: @ps, decl: &ast::fn_decl,\n-                             opt_self_ty: Option<ast::self_ty_>) {\n+                             opt_explicit_self: Option<ast::explicit_self_>) {\n     popen(s);\n-    print_fn_args(s, decl, opt_self_ty);\n+    print_fn_args(s, decl, opt_explicit_self);\n     pclose(s);\n \n     maybe_print_comment(s, decl.output.span.lo);\n@@ -1900,7 +1900,7 @@ pub fn print_ty_fn(s: @ps,\n                    decl: &ast::fn_decl,\n                    id: Option<ast::ident>,\n                    generics: Option<&ast::Generics>,\n-                   opt_self_ty: Option<ast::self_ty_>) {\n+                   opt_explicit_self: Option<ast::explicit_self_>) {\n     ibox(s, indent_unit);\n \n     // Duplicates the logic in `print_fn_header_info()`.  This is because that\n@@ -1920,8 +1920,8 @@ pub fn print_ty_fn(s: @ps,\n     // self type and the args all in the same box.\n     box(s, 0u, inconsistent);\n     let mut first = true;\n-    for opt_self_ty.each |self_ty| {\n-        first = !print_self_ty(s, *self_ty);\n+    for opt_explicit_self.each |explicit_self| {\n+        first = !print_explicit_self(s, *explicit_self);\n     }\n     for decl.inputs.each |arg| {\n         if first { first = false; } else { word_space(s, ~\",\"); }\n@@ -2163,7 +2163,7 @@ pub fn print_opt_sigil(s: @ps, opt_sigil: Option<ast::Sigil>) {\n }\n \n pub fn print_fn_header_info(s: @ps,\n-                            _opt_sty: Option<ast::self_ty_>,\n+                            _opt_explicit_self: Option<ast::explicit_self_>,\n                             opt_purity: Option<ast::purity>,\n                             abis: AbiSet,\n                             onceness: ast::Onceness,"}]}