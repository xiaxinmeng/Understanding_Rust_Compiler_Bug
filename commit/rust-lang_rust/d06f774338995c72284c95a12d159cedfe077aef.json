{"sha": "d06f774338995c72284c95a12d159cedfe077aef", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwNmY3NzQzMzg5OTVjNzIyODRjOTVhMTJkMTU5Y2VkZmUwNzdhZWY=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-01-24T18:32:37Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-06-04T17:24:12Z"}, "message": "Support forwarding caller location through trait object method call\n\nSince PR #69251, the `#[track_caller]` attribute has been supported on\ntraits. However, it only has an effect on direct (monomorphized) method\ncalls. Calling a `#[track_caller]` method on a trait object will *not*\npropagate caller location information - instead, `Location::caller()` will\nreturn the location of the method definition.\n\nThis PR forwards caller location information when `#[track_caller]` is\npresent on the method definition in the trait. This is possible because\n`#[track_caller]` in this position is 'inherited' by any impls of that\ntrait, so all implementations will have the same ABI.\n\nThis PR does *not* change the behavior in the case where\n`#[track_caller]` is present only on the impl of a trait.\nWhile all implementations of the method might have an explicit\n`#[track_caller]`, we cannot know this at codegen time, since other\ncrates may have impls of the trait. Therefore, we keep the current\nbehavior of not forwarding the caller location, ensuring that all\nimplementations of the trait will have the correct ABI.\n\nSee the modified test for examples of how this works", "tree": {"sha": "d6ca64e826994ba8d0d24851bf37897061ccb012", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6ca64e826994ba8d0d24851bf37897061ccb012"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d06f774338995c72284c95a12d159cedfe077aef", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAmC6Yb0ACgkQtAh+UQ6Y\nsWQuIg/8CPitPCBsRIxXy7GZQsfU+fNPij4g50RpxZ1bEdtwVA6ezZKdJUscz4yL\nDRmwVdHWohOPpxdt8SOhMnyqi1LVkRFun590s9ZLZYWMmR3UwF8ZiuvumH6vXNuP\nB4VHIUe2Q9jD1scJk+Uxycw3yEb7iSUtyOrLwUGpL5IA+4JHBSDS8n8BLfCXoP0k\nD5zqkgYjMFSaNJrid9xaDLsT2uTBk7mkIzGEvcvJNlYblGg8VBTWPZzEeEnJ4QAZ\nOz4ICoJqFq3joSk6l8dj+Q2nLlJH63arm8RfLOXOeTszS5R2aQBDuWJOIdEowKkg\n4LoOe4F/rvX15fFdgcjWgXVejMCuBD2su7rsqg6V29Bur+Vqh+dVcgqNUuODo5zg\no8d4w6A0+NLK4tsR/nAqhMGbQQ7e2Az57FCsnsKxo3yXcW2UXFy2E1P5NlrO2MCG\nqs41WO+lTC26V5fBbQMSsY6Ino6zex82RqpdbDw6Qf38sRoBw1W0Vw6ZJt+/czGK\n2GYp3m+OiF+vJNNHo0xsQWps6k4AADhZ0CpQcKQ7BQ9dtCWxF5wRkXLtYE6B/mzW\n4zCZcQCCn0VbBnjBk5uR5PAMzo+3dKhDy5Di5Kejz7qXoRU5QXpX6HznlllQIonT\nB3QkcguUwpy12u0Qqdqeq09vkW9/YtAGIAaByuV2dsLjnlKIroU=\n=oH2w\n-----END PGP SIGNATURE-----", "payload": "tree d6ca64e826994ba8d0d24851bf37897061ccb012\nparent 595088d602049d821bf9a217f2d79aea40715208\nauthor Aaron Hill <aa1ronham@gmail.com> 1611513157 -0500\ncommitter Aaron Hill <aa1ronham@gmail.com> 1622827452 -0500\n\nSupport forwarding caller location through trait object method call\n\nSince PR #69251, the `#[track_caller]` attribute has been supported on\ntraits. However, it only has an effect on direct (monomorphized) method\ncalls. Calling a `#[track_caller]` method on a trait object will *not*\npropagate caller location information - instead, `Location::caller()` will\nreturn the location of the method definition.\n\nThis PR forwards caller location information when `#[track_caller]` is\npresent on the method definition in the trait. This is possible because\n`#[track_caller]` in this position is 'inherited' by any impls of that\ntrait, so all implementations will have the same ABI.\n\nThis PR does *not* change the behavior in the case where\n`#[track_caller]` is present only on the impl of a trait.\nWhile all implementations of the method might have an explicit\n`#[track_caller]`, we cannot know this at codegen time, since other\ncrates may have impls of the trait. Therefore, we keep the current\nbehavior of not forwarding the caller location, ensuring that all\nimplementations of the trait will have the correct ABI.\n\nSee the modified test for examples of how this works\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d06f774338995c72284c95a12d159cedfe077aef", "html_url": "https://github.com/rust-lang/rust/commit/d06f774338995c72284c95a12d159cedfe077aef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d06f774338995c72284c95a12d159cedfe077aef/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "595088d602049d821bf9a217f2d79aea40715208", "url": "https://api.github.com/repos/rust-lang/rust/commits/595088d602049d821bf9a217f2d79aea40715208", "html_url": "https://github.com/rust-lang/rust/commit/595088d602049d821bf9a217f2d79aea40715208"}], "stats": {"total": 112, "additions": 98, "deletions": 14}, "files": [{"sha": "54adbb35e8708e93d7c939e2b2902275086f6315", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d06f774338995c72284c95a12d159cedfe077aef/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d06f774338995c72284c95a12d159cedfe077aef/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=d06f774338995c72284c95a12d159cedfe077aef", "patch": "@@ -920,6 +920,10 @@ rustc_queries! {\n         desc { |tcx| \"looking up const stability of `{}`\", tcx.def_path_str(def_id) }\n     }\n \n+    query should_inherit_track_caller(def_id: DefId) -> bool {\n+        desc { |tcx| \"computing should_inherit_track_caller of `{}`\", tcx.def_path_str(def_id) }\n+    }\n+\n     query lookup_deprecation_entry(def_id: DefId) -> Option<DeprecationEntry> {\n         desc { |tcx| \"checking whether `{}` is deprecated\", tcx.def_path_str(def_id) }\n     }"}, {"sha": "261a19f862e02958b226f4e386f04c6ce17793b6", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 48, "deletions": 4, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d06f774338995c72284c95a12d159cedfe077aef/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d06f774338995c72284c95a12d159cedfe077aef/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=d06f774338995c72284c95a12d159cedfe077aef", "patch": "@@ -227,8 +227,9 @@ impl<'tcx> InstanceDef<'tcx> {\n \n     pub fn requires_caller_location(&self, tcx: TyCtxt<'_>) -> bool {\n         match *self {\n-            InstanceDef::Item(def) => {\n-                tcx.codegen_fn_attrs(def.did).flags.contains(CodegenFnAttrFlags::TRACK_CALLER)\n+            InstanceDef::Item(ty::WithOptConstParam { did: def_id, .. })\n+            | InstanceDef::Virtual(def_id, _) => {\n+                tcx.codegen_fn_attrs(def_id).flags.contains(CodegenFnAttrFlags::TRACK_CALLER)\n             }\n             _ => false,\n         }\n@@ -403,7 +404,7 @@ impl<'tcx> Instance<'tcx> {\n         def_id: DefId,\n         substs: SubstsRef<'tcx>,\n     ) -> Option<Instance<'tcx>> {\n-        debug!(\"resolve(def_id={:?}, substs={:?})\", def_id, substs);\n+        debug!(\"resolve_for_vtable(def_id={:?}, substs={:?})\", def_id, substs);\n         let fn_sig = tcx.fn_sig(def_id);\n         let is_vtable_shim = !fn_sig.inputs().skip_binder().is_empty()\n             && fn_sig.input(0).skip_binder().is_param(0)\n@@ -412,7 +413,50 @@ impl<'tcx> Instance<'tcx> {\n             debug!(\" => associated item with unsizeable self: Self\");\n             Some(Instance { def: InstanceDef::VtableShim(def_id), substs })\n         } else {\n-            Instance::resolve_for_fn_ptr(tcx, param_env, def_id, substs)\n+            Instance::resolve(tcx, param_env, def_id, substs).ok().flatten().map(|mut resolved| {\n+                match resolved.def {\n+                    InstanceDef::Item(def) => {\n+                        // We need to generate a shim when we cannot guarantee that\n+                        // the caller of a trait object method will be aware of\n+                        // `#[track_caller]` - this ensures that the caller\n+                        // and callee ABI will always match.\n+                        //\n+                        // The shim is generated when all of these conditions are met:\n+                        //\n+                        // 1) The underlying method expects a caller location parameter\n+                        // in the ABI\n+                        if resolved.def.requires_caller_location(tcx)\n+                            // 2) The caller location parameter comes from having `#[track_caller]`\n+                            // on the implementation, and *not* on the trait method.\n+                            && !tcx.should_inherit_track_caller(def.did)\n+                            // If the method implementation comes from the trait definition itself\n+                            // (e.g. `trait Foo { #[track_caller] my_fn() { /* impl */ } }`),\n+                            // then we don't need to generate a shim. This check is needed because\n+                            // `should_inherit_track_caller` returns `false` if our method\n+                            // implementation comes from the trait block, and not an impl block\n+                            && !matches!(\n+                                tcx.opt_associated_item(def.did),\n+                                Some(ty::AssocItem {\n+                                    container: ty::AssocItemContainer::TraitContainer(_),\n+                                    ..\n+                                })\n+                            )\n+                        {\n+                            debug!(\n+                                \" => vtable fn pointer created for function with #[track_caller]\"\n+                            );\n+                            resolved.def = InstanceDef::ReifyShim(def.did);\n+                        }\n+                    }\n+                    InstanceDef::Virtual(def_id, _) => {\n+                        debug!(\" => vtable fn pointer created for virtual call\");\n+                        resolved.def = InstanceDef::ReifyShim(def_id);\n+                    }\n+                    _ => {}\n+                }\n+\n+                resolved\n+            })\n         }\n     }\n "}, {"sha": "6edb1f145b48e762488a3c0214d0552e297eb1d3", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d06f774338995c72284c95a12d159cedfe077aef/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d06f774338995c72284c95a12d159cedfe077aef/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=d06f774338995c72284c95a12d159cedfe077aef", "patch": "@@ -93,6 +93,7 @@ pub fn provide(providers: &mut Providers) {\n         generator_kind,\n         codegen_fn_attrs,\n         collect_mod_item_types,\n+        should_inherit_track_caller,\n         ..*providers\n     };\n }\n@@ -2652,7 +2653,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n     let attrs = tcx.get_attrs(id);\n \n     let mut codegen_fn_attrs = CodegenFnAttrs::new();\n-    if should_inherit_track_caller(tcx, id) {\n+    if tcx.should_inherit_track_caller(id) {\n         codegen_fn_attrs.flags |= CodegenFnAttrFlags::TRACK_CALLER;\n     }\n "}, {"sha": "22622e228f547717dbc4f8f05f410dcf7d19c32c", "filename": "src/test/ui/rfc-2091-track-caller/tracked-trait-obj.rs", "status": "modified", "additions": 44, "deletions": 9, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/d06f774338995c72284c95a12d159cedfe077aef/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftracked-trait-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d06f774338995c72284c95a12d159cedfe077aef/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftracked-trait-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftracked-trait-obj.rs?ref=d06f774338995c72284c95a12d159cedfe077aef", "patch": "@@ -2,22 +2,57 @@\n \n trait Tracked {\n     #[track_caller]\n-    fn handle(&self) {\n+    fn track_caller_trait_method(&self, line: u32, col: u32) {\n         let location = std::panic::Location::caller();\n         assert_eq!(location.file(), file!());\n-        // we only call this via trait object, so the def site should *always* be returned\n-        assert_eq!(location.line(), line!() - 4);\n-        assert_eq!(location.column(), 5);\n+        // The trait method definition is annotated with `#[track_caller]`,\n+        // so caller location information will work through a method\n+        // call on a trait object\n+        assert_eq!(location.line(), line, \"Bad line\");\n+        assert_eq!(location.column(), col, \"Bad col\");\n     }\n+\n+    fn track_caller_not_on_trait_method(&self);\n+\n+    #[track_caller]\n+    fn track_caller_through_self(self: Box<Self>, line: u32, col: u32);\n }\n \n-impl Tracked for () {}\n-impl Tracked for u8 {}\n+impl Tracked for () {\n+    // We have `#[track_caller]` on the implementation of the method,\n+    // but not on the definition of the method in the trait. Therefore,\n+    // caller location information will *not* work through a method call\n+    // on a trait object. Instead, we will get the location of this method\n+    #[track_caller]\n+    fn track_caller_not_on_trait_method(&self) {\n+        let location = std::panic::Location::caller();\n+        assert_eq!(location.file(), file!());\n+        assert_eq!(location.line(), line!() - 3);\n+        assert_eq!(location.column(), 5);\n+    }\n+\n+    // We don't have a `#[track_caller]` attribute, but\n+    // `#[track_caller]` is present on the trait definition,\n+    // so we'll still get location information\n+    fn track_caller_through_self(self: Box<Self>, line: u32, col: u32) {\n+        let location = std::panic::Location::caller();\n+        assert_eq!(location.file(), file!());\n+        // The trait method definition is annotated with `#[track_caller]`,\n+        // so caller location information will work through a method\n+        // call on a trait object\n+        assert_eq!(location.line(), line, \"Bad line\");\n+        assert_eq!(location.column(), col, \"Bad col\");\n+    }\n+}\n \n fn main() {\n-    let tracked: &dyn Tracked = &5u8;\n-    tracked.handle();\n+    let tracked: &dyn Tracked = &();\n+    tracked.track_caller_trait_method(line!(), 13); // The column is the start of 'track_caller_trait_method'\n \n     const TRACKED: &dyn Tracked = &();\n-    TRACKED.handle();\n+    TRACKED.track_caller_trait_method(line!(), 13); // The column is the start of 'track_caller_trait_method'\n+    TRACKED.track_caller_not_on_trait_method();\n+\n+    let boxed: Box<dyn Tracked> = Box::new(());\n+    boxed.track_caller_through_self(line!(), 11); // The column is the start of `track_caller_through_self`\n }"}]}