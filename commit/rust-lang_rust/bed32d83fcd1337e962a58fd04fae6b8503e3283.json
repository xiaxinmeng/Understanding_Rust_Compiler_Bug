{"sha": "bed32d83fcd1337e962a58fd04fae6b8503e3283", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlZDMyZDgzZmNkMTMzN2U5NjJhNThmZDA0ZmFlNmI4NTAzZTMyODM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-12T11:17:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-12T11:17:36Z"}, "message": "Auto merge of #32804 - alexcrichton:stabilize-1.9, r=brson\n\nstd: Stabilize APIs for the 1.9 release\n\nThis commit applies all stabilizations, renamings, and deprecations that the\nlibrary team has decided on for the upcoming 1.9 release. All tracking issues\nhave gone through a cycle-long \"final comment period\" and the specific APIs\nstabilized/deprecated are:\n\nStable\n\n* `std::panic`\n* `std::panic::catch_unwind` (renamed from `recover`)\n* `std::panic::resume_unwind` (renamed from `propagate`)\n* `std::panic::AssertUnwindSafe` (renamed from `AssertRecoverSafe`)\n* `std::panic::UnwindSafe` (renamed from `RecoverSafe`)\n* `str::is_char_boundary`\n* `<*const T>::as_ref`\n* `<*mut T>::as_ref`\n* `<*mut T>::as_mut`\n* `AsciiExt::make_ascii_uppercase`\n* `AsciiExt::make_ascii_lowercase`\n* `char::decode_utf16`\n* `char::DecodeUtf16`\n* `char::DecodeUtf16Error`\n* `char::DecodeUtf16Error::unpaired_surrogate`\n* `BTreeSet::take`\n* `BTreeSet::replace`\n* `BTreeSet::get`\n* `HashSet::take`\n* `HashSet::replace`\n* `HashSet::get`\n* `OsString::with_capacity`\n* `OsString::clear`\n* `OsString::capacity`\n* `OsString::reserve`\n* `OsString::reserve_exact`\n* `OsStr::is_empty`\n* `OsStr::len`\n* `std::os::unix::thread`\n* `RawPthread`\n* `JoinHandleExt`\n* `JoinHandleExt::as_pthread_t`\n* `JoinHandleExt::into_pthread_t`\n* `HashSet::hasher`\n* `HashMap::hasher`\n* `CommandExt::exec`\n* `File::try_clone`\n* `SocketAddr::set_ip`\n* `SocketAddr::set_port`\n* `SocketAddrV4::set_ip`\n* `SocketAddrV4::set_port`\n* `SocketAddrV6::set_ip`\n* `SocketAddrV6::set_port`\n* `SocketAddrV6::set_flowinfo`\n* `SocketAddrV6::set_scope_id`\n* `<[T]>::copy_from_slice`\n* `ptr::read_volatile`\n* `ptr::write_volatile`\n* The `#[deprecated]` attribute\n* `OpenOptions::create_new`\n\nDeprecated\n\n* `std::raw::Slice` - use raw parts of `slice` module instead\n* `std::raw::Repr` - use raw parts of `slice` module instead\n* `str::char_range_at` - use slicing plus `chars()` plus `len_utf8`\n* `str::char_range_at_reverse` - use slicing plus `chars().rev()` plus `len_utf8`\n* `str::char_at` - use slicing plus `chars()`\n* `str::char_at_reverse` - use slicing plus `chars().rev()`\n* `str::slice_shift_char` - use `chars()` plus `Chars::as_str`\n* `CommandExt::session_leader` - use `before_exec` instead.\n\nCloses #27719\ncc #27751 (deprecating the `Slice` bits)\nCloses #27754\nCloses #27780\nCloses #27809\nCloses #27811\nCloses #27830\nCloses #28050\nCloses #29453\nCloses #29791\nCloses #29935\nCloses #30014\nCloses #30752\nCloses #31262\ncc #31398 (still need to deal with `before_exec`)\nCloses #31405\nCloses #31572\nCloses #31755\nCloses #31756", "tree": {"sha": "1602a9ea8b4221ba0b27018b8685f52f5d1dbbd0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1602a9ea8b4221ba0b27018b8685f52f5d1dbbd0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bed32d83fcd1337e962a58fd04fae6b8503e3283", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bed32d83fcd1337e962a58fd04fae6b8503e3283", "html_url": "https://github.com/rust-lang/rust/commit/bed32d83fcd1337e962a58fd04fae6b8503e3283", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bed32d83fcd1337e962a58fd04fae6b8503e3283/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28c9fdafc06a259c25c1b889044fd49b4dfc69e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/28c9fdafc06a259c25c1b889044fd49b4dfc69e2", "html_url": "https://github.com/rust-lang/rust/commit/28c9fdafc06a259c25c1b889044fd49b4dfc69e2"}, {"sha": "552eda70d33cead1398adfecce1a75e7a61e3daf", "url": "https://api.github.com/repos/rust-lang/rust/commits/552eda70d33cead1398adfecce1a75e7a61e3daf", "html_url": "https://github.com/rust-lang/rust/commit/552eda70d33cead1398adfecce1a75e7a61e3daf"}], "stats": {"total": 836, "additions": 508, "deletions": 328}, "files": [{"sha": "8d2558e4344e631fd1fde74c4eaea9660f50ed66", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -13,7 +13,6 @@\n #![feature(box_syntax)]\n #![feature(libc)]\n #![feature(rustc_private)]\n-#![feature(str_char)]\n #![feature(test)]\n #![feature(question_mark)]\n \n@@ -412,16 +411,26 @@ fn extract_gdb_version(full_version_line: Option<String>) -> Option<String> {\n \n             // used to be a regex \"(^|[^0-9])([0-9]\\.[0-9]+)\"\n             for (pos, c) in full_version_line.char_indices() {\n-                if !c.is_digit(10) { continue }\n-                if pos + 2 >= full_version_line.len() { continue }\n-                if full_version_line.char_at(pos + 1) != '.' { continue }\n-                if !full_version_line.char_at(pos + 2).is_digit(10) { continue }\n-                if pos > 0 && full_version_line.char_at_reverse(pos).is_digit(10) {\n+                if !c.is_digit(10) {\n+                    continue\n+                }\n+                if pos + 2 >= full_version_line.len() {\n+                    continue\n+                }\n+                if full_version_line[pos + 1..].chars().next().unwrap() != '.' {\n+                    continue\n+                }\n+                if !full_version_line[pos + 2..].chars().next().unwrap().is_digit(10) {\n+                    continue\n+                }\n+                if pos > 0 && full_version_line[..pos].chars().next_back()\n+                                                      .unwrap().is_digit(10) {\n                     continue\n                 }\n                 let mut end = pos + 3;\n                 while end < full_version_line.len() &&\n-                      full_version_line.char_at(end).is_digit(10) {\n+                      full_version_line[end..].chars().next()\n+                                              .unwrap().is_digit(10) {\n                     end += 1;\n                 }\n                 return Some(full_version_line[pos..end].to_owned());\n@@ -453,13 +462,13 @@ fn extract_lldb_version(full_version_line: Option<String>) -> Option<String> {\n             for (pos, l) in full_version_line.char_indices() {\n                 if l != 'l' && l != 'L' { continue }\n                 if pos + 5 >= full_version_line.len() { continue }\n-                let l = full_version_line.char_at(pos + 1);\n+                let l = full_version_line[pos + 1..].chars().next().unwrap();\n                 if l != 'l' && l != 'L' { continue }\n-                let d = full_version_line.char_at(pos + 2);\n+                let d = full_version_line[pos + 2..].chars().next().unwrap();\n                 if d != 'd' && d != 'D' { continue }\n-                let b = full_version_line.char_at(pos + 3);\n+                let b = full_version_line[pos + 3..].chars().next().unwrap();\n                 if b != 'b' && b != 'B' { continue }\n-                let dash = full_version_line.char_at(pos + 4);\n+                let dash = full_version_line[pos + 4..].chars().next().unwrap();\n                 if dash != '-' { continue }\n \n                 let vers = full_version_line[pos + 5..].chars().take_while(|c| {"}, {"sha": "418a0bc7121cbd624be4797e47fd78b5226b59be", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -115,7 +115,7 @@ fn parse_expected(last_nonfollow_error: Option<usize>,\n                   tag: &str)\n                   -> Option<(WhichLine, ExpectedError)> {\n     let start = match line.find(tag) { Some(i) => i, None => return None };\n-    let (follow, adjusts) = if line.char_at(start + tag.len()) == '|' {\n+    let (follow, adjusts) = if line[start + tag.len()..].chars().next().unwrap() == '|' {\n         (true, 0)\n     } else {\n         (false, line[start + tag.len()..].chars().take_while(|c| *c == '^').count())"}, {"sha": "6773c34c7d76da8cadaafb314c9e2f3bbfdc3364", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -1177,7 +1177,7 @@ fn scan_char(haystack: &str, needle: char, idx: &mut usize) -> bool {\n     if *idx >= haystack.len() {\n         return false;\n     }\n-    let ch = haystack.char_at(*idx);\n+    let ch = haystack[*idx..].chars().next().unwrap();\n     if ch != needle {\n         return false;\n     }\n@@ -1188,7 +1188,7 @@ fn scan_char(haystack: &str, needle: char, idx: &mut usize) -> bool {\n fn scan_integer(haystack: &str, idx: &mut usize) -> bool {\n     let mut i = *idx;\n     while i < haystack.len() {\n-        let ch = haystack.char_at(i);\n+        let ch = haystack[i..].chars().next().unwrap();\n         if ch < '0' || '9' < ch {\n             break;\n         }\n@@ -1208,7 +1208,7 @@ fn scan_string(haystack: &str, needle: &str, idx: &mut usize) -> bool {\n         if haystack_i >= haystack.len() {\n             return false;\n         }\n-        let ch = haystack.char_at(haystack_i);\n+        let ch = haystack[haystack_i..].chars().next().unwrap();\n         haystack_i += ch.len_utf8();\n         if !scan_char(needle, ch, &mut needle_i) {\n             return false;"}, {"sha": "e679381f223f8a97624c21efefbc1f49b9d28c90", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -379,7 +379,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// The value may be any borrowed form of the set's value type,\n     /// but the ordering on the borrowed form *must* match the\n     /// ordering on the value type.\n-    #[unstable(feature = \"set_recovery\", issue = \"28050\")]\n+    #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n     pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T>\n         where T: Borrow<Q>,\n               Q: Ord\n@@ -502,7 +502,7 @@ impl<T: Ord> BTreeSet<T> {\n \n     /// Adds a value to the set, replacing the existing value, if any, that is equal to the given\n     /// one. Returns the replaced value.\n-    #[unstable(feature = \"set_recovery\", issue = \"28050\")]\n+    #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n     pub fn replace(&mut self, value: T) -> Option<T> {\n         Recover::replace(&mut self.map, value)\n     }\n@@ -538,7 +538,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// The value may be any borrowed form of the set's value type,\n     /// but the ordering on the borrowed form *must* match the\n     /// ordering on the value type.\n-    #[unstable(feature = \"set_recovery\", issue = \"28050\")]\n+    #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n     pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T>\n         where T: Borrow<Q>,\n               Q: Ord"}, {"sha": "7540c51e236d226b18343352e9bce5649d6d6d1b", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -27,15 +27,13 @@\n        test(no_crate_inject, attr(allow(unused_variables), deny(warnings))))]\n \n #![cfg_attr(test, allow(deprecated))] // rand\n-#![cfg_attr(not(test), feature(copy_from_slice))] // impl [T]\n #![cfg_attr(not(stage0), deny(warnings))]\n \n #![feature(alloc)]\n #![feature(allow_internal_unstable)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(core_intrinsics)]\n-#![feature(decode_utf16)]\n #![feature(dropck_parametricity)]\n #![feature(fmt_internals)]\n #![feature(heap_api)]"}, {"sha": "db91d911c7355d0a68b07bb2b70ac073a406953c", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -845,14 +845,13 @@ impl<T> [T] {\n     /// # Example\n     ///\n     /// ```rust\n-    /// #![feature(copy_from_slice)]\n     /// let mut dst = [0, 0, 0];\n     /// let src = [1, 2, 3];\n     ///\n     /// dst.copy_from_slice(&src);\n     /// assert_eq!(src, dst);\n     /// ```\n-    #[unstable(feature = \"copy_from_slice\", issue = \"31755\")]\n+    #[stable(feature = \"copy_from_slice\", since = \"1.9.0\")]\n     pub fn copy_from_slice(&mut self, src: &[T]) where T: Copy {\n         core_slice::SliceExt::copy_from_slice(self, src)\n     }"}, {"sha": "b2b1e019a1b899f1887c2e436ac87993b177154d", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -228,8 +228,6 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(str_char)]\n-    ///\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     /// assert!(s.is_char_boundary(0));\n     /// // start of `\u8001`\n@@ -242,12 +240,7 @@ impl str {\n     /// // third byte of `\u8001`\n     /// assert!(!s.is_char_boundary(8));\n     /// ```\n-    #[unstable(feature = \"str_char\",\n-               reason = \"it is unclear whether this method pulls its weight \\\n-                         with the existence of the char_indices iterator or \\\n-                         this method may want to be replaced with checked \\\n-                         slicing\",\n-               issue = \"27754\")]\n+    #[stable(feature = \"is_char_boundary\", since = \"1.9.0\")]\n     #[inline]\n     pub fn is_char_boundary(&self, index: usize) -> bool {\n         core_str::StrExt::is_char_boundary(self, index)\n@@ -374,6 +367,7 @@ impl str {\n     ///\n     /// ```\n     /// #![feature(str_char)]\n+    /// #![allow(deprecated)]\n     ///\n     /// use std::str::CharRange;\n     ///\n@@ -408,6 +402,9 @@ impl str {\n                          removed altogether\",\n                issue = \"27754\")]\n     #[inline]\n+    #[rustc_deprecated(reason = \"use slicing plus chars() plus len_utf8\",\n+                       since = \"1.9.0\")]\n+    #[allow(deprecated)]\n     pub fn char_range_at(&self, start: usize) -> CharRange {\n         core_str::StrExt::char_range_at(self, start)\n     }\n@@ -432,6 +429,7 @@ impl str {\n     ///\n     /// ```\n     /// #![feature(str_char)]\n+    /// #![allow(deprecated)]\n     ///\n     /// use std::str::CharRange;\n     ///\n@@ -466,6 +464,9 @@ impl str {\n                          eventually removed altogether\",\n                issue = \"27754\")]\n     #[inline]\n+    #[rustc_deprecated(reason = \"use slicing plus chars().rev() plus len_utf8\",\n+                       since = \"1.9.0\")]\n+    #[allow(deprecated)]\n     pub fn char_range_at_reverse(&self, start: usize) -> CharRange {\n         core_str::StrExt::char_range_at_reverse(self, start)\n     }\n@@ -481,6 +482,7 @@ impl str {\n     ///\n     /// ```\n     /// #![feature(str_char)]\n+    /// #![allow(deprecated)]\n     ///\n     /// let s = \"ab\u03c0c\";\n     /// assert_eq!(s.char_at(1), 'b');\n@@ -495,6 +497,9 @@ impl str {\n                          subslice\",\n                issue = \"27754\")]\n     #[inline]\n+    #[allow(deprecated)]\n+    #[rustc_deprecated(reason = \"use slicing plus chars()\",\n+                       since = \"1.9.0\")]\n     pub fn char_at(&self, i: usize) -> char {\n         core_str::StrExt::char_at(self, i)\n     }\n@@ -511,6 +516,7 @@ impl str {\n     ///\n     /// ```\n     /// #![feature(str_char)]\n+    /// #![allow(deprecated)]\n     ///\n     /// let s = \"ab\u03c0c\";\n     /// assert_eq!(s.char_at_reverse(1), 'a');\n@@ -523,6 +529,9 @@ impl str {\n                          cases generate panics\",\n                issue = \"27754\")]\n     #[inline]\n+    #[rustc_deprecated(reason = \"use slicing plus chars().rev()\",\n+                       since = \"1.9.0\")]\n+    #[allow(deprecated)]\n     pub fn char_at_reverse(&self, i: usize) -> char {\n         core_str::StrExt::char_at_reverse(self, i)\n     }\n@@ -541,6 +550,7 @@ impl str {\n     ///\n     /// ```\n     /// #![feature(str_char)]\n+    /// #![allow(deprecated)]\n     ///\n     /// let s = \"\u0141o\u0301dz\u0301\"; // \\u{141}o\\u{301}dz\\u{301}\n     /// let (c, s1) = s.slice_shift_char().unwrap();\n@@ -559,6 +569,9 @@ impl str {\n                          and/or char_indices iterators\",\n                issue = \"27754\")]\n     #[inline]\n+    #[rustc_deprecated(reason = \"use chars() plus Chars::as_str\",\n+                       since = \"1.9.0\")]\n+    #[allow(deprecated)]\n     pub fn slice_shift_char(&self) -> Option<(char, &str)> {\n         core_str::StrExt::slice_shift_char(self)\n     }"}, {"sha": "2226116585fcb072550d4fa6ce90faf43d8a5180", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -1037,14 +1037,13 @@ impl String {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop(&mut self) -> Option<char> {\n-        let len = self.len();\n-        if len == 0 {\n-            return None;\n-        }\n-\n-        let ch = self.char_at_reverse(len);\n+        let ch = match self.chars().rev().next() {\n+            Some(ch) => ch,\n+            None => return None,\n+        };\n+        let newlen = self.len() - ch.len_utf8();\n         unsafe {\n-            self.vec.set_len(len - ch.len_utf8());\n+            self.vec.set_len(newlen);\n         }\n         Some(ch)\n     }\n@@ -1075,11 +1074,13 @@ impl String {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(&mut self, idx: usize) -> char {\n-        let len = self.len();\n-        assert!(idx < len);\n+        let ch = match self[idx..].chars().next() {\n+            Some(ch) => ch,\n+            None => panic!(\"cannot remove a char from the end of a string\"),\n+        };\n \n-        let ch = self.char_at(idx);\n         let next = idx + ch.len_utf8();\n+        let len = self.len();\n         unsafe {\n             ptr::copy(self.vec.as_ptr().offset(next as isize),\n                       self.vec.as_mut_ptr().offset(idx as isize),"}, {"sha": "211942f2294ecd165246ecb95e43dd7782cdbaca", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -10,13 +10,11 @@\n \n #![deny(warnings)]\n \n-#![feature(ascii)]\n #![feature(binary_heap_extras)]\n #![feature(box_syntax)]\n #![feature(btree_range)]\n #![feature(collections)]\n #![feature(collections_bound)]\n-#![feature(copy_from_slice)]\n #![feature(const_fn)]\n #![feature(fn_traits)]\n #![feature(enumset)]\n@@ -25,7 +23,6 @@\n #![feature(map_values_mut)]\n #![feature(pattern)]\n #![feature(rand)]\n-#![feature(set_recovery)]\n #![feature(step_by)]\n #![feature(str_char)]\n #![feature(str_escape)]"}, {"sha": "929ac7a52ab2786a3a0945a7237c37db9c7767d5", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -464,12 +464,14 @@ fn test_is_whitespace() {\n }\n \n #[test]\n+#[allow(deprecated)]\n fn test_slice_shift_char() {\n     let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\";\n     assert_eq!(data.slice_shift_char(), Some(('\u0e1b', \"\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\")));\n }\n \n #[test]\n+#[allow(deprecated)]\n fn test_slice_shift_char_2() {\n     let empty = \"\";\n     assert_eq!(empty.slice_shift_char(), None);\n@@ -657,6 +659,7 @@ fn test_contains_char() {\n }\n \n #[test]\n+#[allow(deprecated)]\n fn test_char_at() {\n     let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n     let v = vec!['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n@@ -668,6 +671,7 @@ fn test_char_at() {\n }\n \n #[test]\n+#[allow(deprecated)]\n fn test_char_at_reverse() {\n     let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n     let v = vec!['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n@@ -745,6 +749,7 @@ fn test_total_ord() {\n }\n \n #[test]\n+#[allow(deprecated)]\n fn test_char_range_at() {\n     let data = \"b\u00a2\u20ac\ud852\udf62\ud852\udf62\u20ac\u00a2b\";\n     assert_eq!('b', data.char_range_at(0).ch);\n@@ -758,6 +763,7 @@ fn test_char_range_at() {\n }\n \n #[test]\n+#[allow(deprecated)]\n fn test_char_range_at_reverse_underflow() {\n     assert_eq!(\"abc\".char_range_at_reverse(0).next, 0);\n }"}, {"sha": "a6b5355d947860be655fd50118510c222b1b4ed8", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 37, "deletions": 27, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -166,9 +166,16 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n ///\n /// Volatile operations are intended to act on I/O memory, and are guaranteed\n /// to not be elided or reordered by the compiler across other volatile\n-/// operations. See the LLVM documentation on [[volatile]].\n+/// operations.\n ///\n-/// [volatile]: http://llvm.org/docs/LangRef.html#volatile-memory-accesses\n+/// # Notes\n+///\n+/// Rust does not currently have a rigorously and formally defined memory model,\n+/// so the precise semantics of what \"volatile\" means here is subject to change\n+/// over time. That being said, the semantics will almost always end up pretty\n+/// similar to [C11's definition of volatile][c11].\n+///\n+/// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n ///\n /// # Safety\n ///\n@@ -179,7 +186,7 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n /// `zero_memory`, or `copy_memory`). Note that `*src = foo` counts as a use\n /// because it will attempt to drop the value previously at `*src`.\n #[inline]\n-#[unstable(feature = \"volatile\", reason = \"recently added\", issue = \"31756\")]\n+#[stable(feature = \"volatile\", since = \"1.9.0\")]\n pub unsafe fn read_volatile<T>(src: *const T) -> T {\n     intrinsics::volatile_load(src)\n }\n@@ -189,9 +196,16 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n ///\n /// Volatile operations are intended to act on I/O memory, and are guaranteed\n /// to not be elided or reordered by the compiler across other volatile\n-/// operations. See the LLVM documentation on [[volatile]].\n+/// operations.\n+///\n+/// # Notes\n ///\n-/// [volatile]: http://llvm.org/docs/LangRef.html#volatile-memory-accesses\n+/// Rust does not currently have a rigorously and formally defined memory model,\n+/// so the precise semantics of what \"volatile\" means here is subject to change\n+/// over time. That being said, the semantics will almost always end up pretty\n+/// similar to [C11's definition of volatile][c11].\n+///\n+/// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n ///\n /// # Safety\n ///\n@@ -204,7 +218,7 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n /// This is appropriate for initializing uninitialized memory, or overwriting\n /// memory that has previously been `read` from.\n #[inline]\n-#[unstable(feature = \"volatile\", reason = \"recently added\", issue = \"31756\")]\n+#[stable(feature = \"volatile\", since = \"1.9.0\")]\n pub unsafe fn write_volatile<T>(dst: *mut T, src: T) {\n     intrinsics::volatile_store(dst, src);\n }\n@@ -238,6 +252,9 @@ impl<T: ?Sized> *const T {\n     /// operation because the returned value could be pointing to invalid\n     /// memory.\n     ///\n+    /// Additionally, the lifetime `'a` returned is arbitrarily chosen and does\n+    /// not necessarily reflect the actual lifetime of the data.\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -251,17 +268,13 @@ impl<T: ?Sized> *const T {\n     ///     }\n     /// }\n     /// ```\n-    #[unstable(feature = \"ptr_as_ref\",\n-               reason = \"Option is not clearly the right return type, and we \\\n-                         may want to tie the return lifetime to a borrow of \\\n-                         the raw pointer\",\n-               issue = \"27780\")]\n+    #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n     #[inline]\n-    pub unsafe fn as_ref<'a>(&self) -> Option<&'a T> where T: Sized {\n+    pub unsafe fn as_ref<'a>(self) -> Option<&'a T> where T: Sized {\n         if self.is_null() {\n             None\n         } else {\n-            Some(&**self)\n+            Some(&*self)\n         }\n     }\n \n@@ -324,6 +337,9 @@ impl<T: ?Sized> *mut T {\n     /// operation because the returned value could be pointing to invalid\n     /// memory.\n     ///\n+    /// Additionally, the lifetime `'a` returned is arbitrarily chosen and does\n+    /// not necessarily reflect the actual lifetime of the data.\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -337,17 +353,13 @@ impl<T: ?Sized> *mut T {\n     ///     }\n     /// }\n     /// ```\n-    #[unstable(feature = \"ptr_as_ref\",\n-               reason = \"Option is not clearly the right return type, and we \\\n-                         may want to tie the return lifetime to a borrow of \\\n-                         the raw pointer\",\n-               issue = \"27780\")]\n+    #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n     #[inline]\n-    pub unsafe fn as_ref<'a>(&self) -> Option<&'a T> where T: Sized {\n+    pub unsafe fn as_ref<'a>(self) -> Option<&'a T> where T: Sized {\n         if self.is_null() {\n             None\n         } else {\n-            Some(&**self)\n+            Some(&*self)\n         }\n     }\n \n@@ -385,7 +397,8 @@ impl<T: ?Sized> *mut T {\n     /// # Safety\n     ///\n     /// As with `as_ref`, this is unsafe because it cannot verify the validity\n-    /// of the returned pointer.\n+    /// of the returned pointer, nor can it ensure that the lifetime `'a`\n+    /// returned is indeed a valid lifetime for the contained data.\n     ///\n     /// # Examples\n     ///\n@@ -395,16 +408,13 @@ impl<T: ?Sized> *mut T {\n     /// let mut s = [1, 2, 3];\n     /// let ptr: *mut u32 = s.as_mut_ptr();\n     /// ```\n-    #[unstable(feature = \"ptr_as_ref\",\n-               reason = \"return value does not necessarily convey all possible \\\n-                         information\",\n-               issue = \"27780\")]\n+    #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n     #[inline]\n-    pub unsafe fn as_mut<'a>(&self) -> Option<&'a mut T> where T: Sized {\n+    pub unsafe fn as_mut<'a>(self) -> Option<&'a mut T> where T: Sized {\n         if self.is_null() {\n             None\n         } else {\n-            Some(&mut **self)\n+            Some(&mut *self)\n         }\n     }\n }"}, {"sha": "19226d81f16882000966fcd514a046d1f16abe86", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -60,12 +60,17 @@ use mem;\n /// ```\n #[repr(C)]\n #[allow(missing_debug_implementations)]\n+#[rustc_deprecated(reason = \"use raw accessors/constructors in `slice` module\",\n+                   since = \"1.9.0\")]\n+#[unstable(feature = \"raw\", issue = \"27751\")]\n pub struct Slice<T> {\n     pub data: *const T,\n     pub len: usize,\n }\n \n+#[allow(deprecated)]\n impl<T> Copy for Slice<T> {}\n+#[allow(deprecated)]\n impl<T> Clone for Slice<T> {\n     fn clone(&self) -> Slice<T> { *self }\n }\n@@ -152,6 +157,9 @@ pub struct TraitObject {\n \n /// This trait is meant to map equivalences between raw structs and their\n /// corresponding rust values.\n+#[rustc_deprecated(reason = \"use raw accessors/constructors in `slice` module\",\n+                   since = \"1.9.0\")]\n+#[unstable(feature = \"raw\", issue = \"27751\")]\n pub unsafe trait Repr<T> {\n     /// This function \"unwraps\" a rust value (without consuming it) into its raw\n     /// struct representation. This can be used to read/write different values\n@@ -161,5 +169,7 @@ pub unsafe trait Repr<T> {\n     fn repr(&self) -> T { unsafe { mem::transmute_copy(&self) } }\n }\n \n+#[allow(deprecated)]\n unsafe impl<T> Repr<Slice<T>> for [T] {}\n+#[allow(deprecated)]\n unsafe impl Repr<Slice<u8>> for str {}"}, {"sha": "2e91238bff3cc1966b54b88728511a9b13885725", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -50,10 +50,12 @@ use result::Result::{Ok, Err};\n use ptr;\n use mem;\n use marker::{Copy, Send, Sync, self};\n-use raw::Repr;\n-// Avoid conflicts with *both* the Slice trait (buggy) and the `slice::raw` module.\n-use raw::Slice as RawSlice;\n \n+#[repr(C)]\n+struct Repr<T> {\n+    pub data: *const T,\n+    pub len: usize,\n+}\n \n //\n // Extension traits\n@@ -152,8 +154,8 @@ pub trait SliceExt {\n     fn ends_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n \n     #[stable(feature = \"clone_from_slice\", since = \"1.7.0\")]\n-    fn clone_from_slice(&mut self, &[Self::Item]) where Self::Item: Clone;\n-    #[unstable(feature = \"copy_from_slice\", issue = \"31755\")]\n+    fn clone_from_slice(&mut self, src: &[Self::Item]) where Self::Item: Clone;\n+    #[stable(feature = \"copy_from_slice\", since = \"1.9.0\")]\n     fn copy_from_slice(&mut self, src: &[Self::Item]) where Self::Item: Copy;\n }\n \n@@ -317,7 +319,11 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn len(&self) -> usize { self.repr().len }\n+    fn len(&self) -> usize {\n+        unsafe {\n+            mem::transmute::<&[T], Repr<T>>(self).len\n+        }\n+    }\n \n     #[inline]\n     fn get_mut(&mut self, index: usize) -> Option<&mut T> {\n@@ -1695,7 +1701,7 @@ impl<'a, T> ExactSizeIterator for ChunksMut<'a, T> {}\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn from_raw_parts<'a, T>(p: *const T, len: usize) -> &'a [T] {\n-    mem::transmute(RawSlice { data: p, len: len })\n+    mem::transmute(Repr { data: p, len: len })\n }\n \n /// Performs the same functionality as `from_raw_parts`, except that a mutable\n@@ -1707,7 +1713,7 @@ pub unsafe fn from_raw_parts<'a, T>(p: *const T, len: usize) -> &'a [T] {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn from_raw_parts_mut<'a, T>(p: *mut T, len: usize) -> &'a mut [T] {\n-    mem::transmute(RawSlice { data: p, len: len })\n+    mem::transmute(Repr { data: p, len: len })\n }\n \n //"}, {"sha": "f3c31d59fc4671717be8f1628c52b2d74bbbf08c", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -29,7 +29,6 @@ use marker::Sized;\n use mem;\n use ops::{Fn, FnMut, FnOnce};\n use option::Option::{self, None, Some};\n-use raw::{Repr, Slice};\n use result::Result::{self, Ok, Err};\n use slice::{self, SliceExt};\n \n@@ -1664,24 +1663,23 @@ pub trait StrExt {\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n         where P::Searcher: ReverseSearcher<'a>;\n-    #[unstable(feature = \"str_char\",\n-               reason = \"it is unclear whether this method pulls its weight \\\n-                         with the existence of the char_indices iterator or \\\n-                         this method may want to be replaced with checked \\\n-                         slicing\",\n-               issue = \"27754\")]\n+    #[stable(feature = \"is_char_boundary\", since = \"1.9.0\")]\n     fn is_char_boundary(&self, index: usize) -> bool;\n     #[unstable(feature = \"str_char\",\n                reason = \"often replaced by char_indices, this method may \\\n                          be removed in favor of just char_at() or eventually \\\n                          removed altogether\",\n                issue = \"27754\")]\n+    #[rustc_deprecated(reason = \"use slicing plus chars() plus len_utf8\",\n+                       since = \"1.9.0\")]\n     fn char_range_at(&self, start: usize) -> CharRange;\n     #[unstable(feature = \"str_char\",\n                reason = \"often replaced by char_indices, this method may \\\n                          be removed in favor of just char_at_reverse() or \\\n                          eventually removed altogether\",\n                issue = \"27754\")]\n+    #[rustc_deprecated(reason = \"use slicing plus chars().rev() plus len_utf8\",\n+                       since = \"1.9.0\")]\n     fn char_range_at_reverse(&self, start: usize) -> CharRange;\n     #[unstable(feature = \"str_char\",\n                reason = \"frequently replaced by the chars() iterator, this \\\n@@ -1690,12 +1688,16 @@ pub trait StrExt {\n                          iterators or by getting the first char from a \\\n                          subslice\",\n                issue = \"27754\")]\n+    #[rustc_deprecated(reason = \"use slicing plus chars()\",\n+                       since = \"1.9.0\")]\n     fn char_at(&self, i: usize) -> char;\n     #[unstable(feature = \"str_char\",\n                reason = \"see char_at for more details, but reverse semantics \\\n                          are also somewhat unclear, especially with which \\\n                          cases generate panics\",\n                issue = \"27754\")]\n+    #[rustc_deprecated(reason = \"use slicing plus chars().rev()\",\n+                       since = \"1.9.0\")]\n     fn char_at_reverse(&self, i: usize) -> char;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn as_bytes(&self) -> &[u8];\n@@ -1714,6 +1716,8 @@ pub trait StrExt {\n                          may not be warranted with the existence of the chars \\\n                          and/or char_indices iterators\",\n                issue = \"27754\")]\n+    #[rustc_deprecated(reason = \"use chars() plus Chars::as_str\",\n+                       since = \"1.9.0\")]\n     fn slice_shift_char(&self) -> Option<(char, &str)>;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn as_ptr(&self) -> *const u8;\n@@ -1857,18 +1861,16 @@ impl StrExt for str {\n \n     #[inline]\n     unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n-        mem::transmute(Slice {\n-            data: self.as_ptr().offset(begin as isize),\n-            len: end - begin,\n-        })\n+        let ptr = self.as_ptr().offset(begin as isize);\n+        let len = end - begin;\n+        from_utf8_unchecked(slice::from_raw_parts(ptr, len))\n     }\n \n     #[inline]\n     unsafe fn slice_mut_unchecked(&mut self, begin: usize, end: usize) -> &mut str {\n-        mem::transmute(Slice {\n-            data: self.as_ptr().offset(begin as isize),\n-            len: end - begin,\n-        })\n+        let ptr = self.as_ptr().offset(begin as isize);\n+        let len = end - begin;\n+        mem::transmute(slice::from_raw_parts_mut(ptr as *mut u8, len))\n     }\n \n     #[inline]\n@@ -1983,11 +1985,13 @@ impl StrExt for str {\n     }\n \n     #[inline]\n+    #[allow(deprecated)]\n     fn char_at(&self, i: usize) -> char {\n         self.char_range_at(i).ch\n     }\n \n     #[inline]\n+    #[allow(deprecated)]\n     fn char_at_reverse(&self, i: usize) -> char {\n         self.char_range_at_reverse(i).ch\n     }\n@@ -2039,6 +2043,7 @@ impl StrExt for str {\n     }\n \n     #[inline]\n+    #[allow(deprecated)]\n     fn slice_shift_char(&self) -> Option<(char, &str)> {\n         if self.is_empty() {\n             None\n@@ -2055,7 +2060,9 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn len(&self) -> usize { self.repr().len }\n+    fn len(&self) -> usize {\n+        self.as_bytes().len()\n+    }\n \n     #[inline]\n     fn is_empty(&self) -> bool { self.len() == 0 }"}, {"sha": "41fd742c9e011f48094edd8b250b1857ebc3ed33", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::char;\n+\n #[test]\n fn test_is_lowercase() {\n     assert!('a'.is_lowercase());\n@@ -213,7 +215,10 @@ fn test_len_utf16() {\n #[test]\n fn test_decode_utf16() {\n     fn check(s: &[u16], expected: &[Result<char, u16>]) {\n-        assert_eq!(::std::char::decode_utf16(s.iter().cloned()).collect::<Vec<_>>(), expected);\n+        let v = char::decode_utf16(s.iter().cloned())\n+                     .map(|r| r.map_err(|e| e.unpaired_surrogate()))\n+                     .collect::<Vec<_>>();\n+        assert_eq!(v, expected);\n     }\n     check(&[0xD800, 0x41, 0x42], &[Err(0xD800), Ok('A'), Ok('B')]);\n     check(&[0xD800, 0], &[Err(0xD800), Ok('\\0')]);"}, {"sha": "aa7ab4b4e3f85c82eee639a02bae62b213baf687", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -15,20 +15,17 @@\n #![feature(box_syntax)]\n #![feature(cell_extras)]\n #![feature(const_fn)]\n-#![feature(copy_from_slice)]\n #![feature(core_float)]\n #![feature(core_private_bignum)]\n #![feature(core_private_diy_float)]\n #![feature(dec2flt)]\n-#![feature(decode_utf16)]\n #![feature(fixed_size_array)]\n #![feature(float_extras)]\n #![feature(flt2dec)]\n #![feature(iter_arith)]\n #![feature(libc)]\n #![feature(nonzero)]\n #![feature(peekable_is_empty)]\n-#![feature(ptr_as_ref)]\n #![feature(rand)]\n #![feature(raw)]\n #![feature(slice_patterns)]"}, {"sha": "eda20699755a18e89d9749627074c66a50547def", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -91,7 +91,6 @@\n \n #![deny(missing_docs)]\n #![feature(staged_api)]\n-#![feature(str_char)]\n \n use self::Name::*;\n use self::HasArg::*;\n@@ -223,7 +222,7 @@ pub type Result = result::Result<Matches, Fail>;\n impl Name {\n     fn from_str(nm: &str) -> Name {\n         if nm.len() == 1 {\n-            Short(nm.char_at(0))\n+            Short(nm.chars().next().unwrap())\n         } else {\n             Long(nm.to_owned())\n         }\n@@ -261,7 +260,7 @@ impl OptGroup {\n             }\n             (1, 0) => {\n                 Opt {\n-                    name: Short(short_name.char_at(0)),\n+                    name: Short(short_name.chars().next().unwrap()),\n                     hasarg: hasarg,\n                     occur: occur,\n                     aliases: Vec::new(),\n@@ -273,7 +272,7 @@ impl OptGroup {\n                     hasarg: hasarg,\n                     occur: occur,\n                     aliases: vec![Opt {\n-                                      name: Short(short_name.char_at(0)),\n+                                      name: Short(short_name.chars().next().unwrap()),\n                                       hasarg: hasarg,\n                                       occur: occur,\n                                       aliases: Vec::new(),\n@@ -599,7 +598,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                 let mut j = 1;\n                 names = Vec::new();\n                 while j < curlen {\n-                    let ch = cur.char_at(j);\n+                    let ch = cur[j..].chars().next().unwrap();\n                     let opt = Short(ch);\n \n                     // In a series of potential options (eg. -aheJ), if we"}, {"sha": "4edbeab5dfb11049cbedf1255d30608c16abcc6f", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -122,7 +122,6 @@\n        test(attr(deny(warnings))))]\n #![cfg_attr(not(stage0), deny(warnings))]\n \n-#![feature(copy_from_slice)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(question_mark)]"}, {"sha": "e9ed0ed574eaffb9c2f7aa69e099af529644e9ad", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -1494,11 +1494,14 @@ impl<'a> State<'a> {\n \n                 let mut out_idx = 0;\n                 self.commasep(Inconsistent, &a.outputs, |s, out| {\n-                    match out.constraint.slice_shift_char() {\n-                        Some(('=', operand)) if out.is_rw => {\n-                            s.print_string(&format!(\"+{}\", operand), ast::StrStyle::Cooked)?\n+                    let mut ch = out.constraint.chars();\n+                    match ch.next() {\n+                        Some('=') if out.is_rw => {\n+                            s.print_string(&format!(\"+{}\", ch.as_str()),\n+                                           ast::StrStyle::Cooked)?\n                         }\n-                        _ => s.print_string(&out.constraint, ast::StrStyle::Cooked)?,\n+                        _ => s.print_string(&out.constraint,\n+                                            ast::StrStyle::Cooked)?,\n                     }\n                     s.popen()?;\n                     s.print_expr(&outputs[out_idx])?;"}, {"sha": "d1bbbf08ac230f5a261a619c7a74aaf433bb563f", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -28,7 +28,6 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(const_fn)]\n-#![feature(copy_from_slice)]\n #![feature(enumset)]\n #![feature(iter_arith)]\n #![feature(libc)]\n@@ -39,7 +38,6 @@\n #![feature(slice_patterns)]\n #![feature(staged_api)]\n #![feature(step_by)]\n-#![feature(str_char)]\n #![feature(question_mark)]\n #![cfg_attr(test, feature(test))]\n "}, {"sha": "815e60a8e0342a1a25960cfdf426a1e50b808504", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -351,11 +351,11 @@ fn split_msg_into_multilines(msg: &str) -> Option<String> {\n             return None\n     }\n     let first = msg.match_indices(\"expected\").filter(|s| {\n-        s.0 > 0 && (msg.char_at_reverse(s.0) == ' ' ||\n-                    msg.char_at_reverse(s.0) == '(')\n+        let last = msg[..s.0].chars().rev().next();\n+        last == Some(' ') || last == Some('(')\n     }).map(|(a, b)| (a - 1, a + b.len()));\n     let second = msg.match_indices(\"found\").filter(|s| {\n-        msg.char_at_reverse(s.0) == ' '\n+        msg[..s.0].chars().rev().next() == Some(' ')\n     }).map(|(a, b)| (a - 1, a + b.len()));\n \n     let mut new_msg = String::new();"}, {"sha": "67b11a930d6f7fbbef6da55e3ef4bf84752d6b0f", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -32,7 +32,6 @@\n \n #![feature(box_syntax)]\n #![feature(const_fn)]\n-#![feature(copy_from_slice)]\n #![feature(libc)]\n #![feature(rand)]\n #![feature(rustc_private)]"}, {"sha": "f4fb226d3525f7aaf598530dcf940cdd3a04018e", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -63,7 +63,9 @@ impl NonCamelCaseTypes {\n \n             // start with a non-lowercase letter rather than non-uppercase\n             // ones (some scripts don't have a concept of upper/lowercase)\n-            !name.is_empty() && !name.char_at(0).is_lowercase() && !name.contains('_')\n+            !name.is_empty() &&\n+                !name.chars().next().unwrap().is_lowercase() &&\n+                !name.contains('_')\n         }\n \n         fn to_camel_case(s: &str) -> String {"}, {"sha": "e7c9097a56a58ea27bf26a1548c9a3db6edb0705", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -36,7 +36,6 @@\n #![feature(rustc_private)]\n #![feature(slice_patterns)]\n #![feature(staged_api)]\n-#![feature(str_char)]\n \n #[macro_use]\n extern crate syntax;"}, {"sha": "863cada5b88090f09a9eb434c37b93add48ca19d", "filename": "src/librustc_unicode/char.rs", "status": "modified", "additions": 38, "deletions": 17, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibrustc_unicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibrustc_unicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Fchar.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -29,8 +29,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::char::CharExt as C;\n-use core::option::Option::{self, Some, None};\n-use core::iter::Iterator;\n+use core::fmt;\n use tables::{derived_property, property, general_category, conversions};\n \n // stable reexports\n@@ -739,7 +738,7 @@ impl char {\n }\n \n /// An iterator that decodes UTF-16 encoded code points from an iterator of `u16`s.\n-#[unstable(feature = \"decode_utf16\", reason = \"recently exposed\", issue = \"27830\")]\n+#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n #[derive(Clone)]\n pub struct DecodeUtf16<I>\n     where I: Iterator<Item = u16>\n@@ -748,6 +747,13 @@ pub struct DecodeUtf16<I>\n     buf: Option<u16>,\n }\n \n+/// An iterator that decodes UTF-16 encoded code points from an iterator of `u16`s.\n+#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct DecodeUtf16Error {\n+    code: u16,\n+}\n+\n /// Create an iterator over the UTF-16 encoded code points in `iter`,\n /// returning unpaired surrogates as `Err`s.\n ///\n@@ -756,8 +762,6 @@ pub struct DecodeUtf16<I>\n /// Basic usage:\n ///\n /// ```\n-/// #![feature(decode_utf16)]\n-///\n /// use std::char::decode_utf16;\n ///\n /// fn main() {\n@@ -766,7 +770,9 @@ pub struct DecodeUtf16<I>\n ///              0x0073, 0xDD1E, 0x0069, 0x0063,\n ///              0xD834];\n ///\n-///     assert_eq!(decode_utf16(v.iter().cloned()).collect::<Vec<_>>(),\n+///     assert_eq!(decode_utf16(v.iter().cloned())\n+///                            .map(|r| r.map_err(|e| e.unpaired_surrogate()))\n+///                            .collect::<Vec<_>>(),\n ///                vec![Ok('\ud834\udd1e'),\n ///                     Ok('m'), Ok('u'), Ok('s'),\n ///                     Err(0xDD1E),\n@@ -778,8 +784,6 @@ pub struct DecodeUtf16<I>\n /// A lossy decoder can be obtained by replacing `Err` results with the replacement character:\n ///\n /// ```\n-/// #![feature(decode_utf16)]\n-///\n /// use std::char::{decode_utf16, REPLACEMENT_CHARACTER};\n ///\n /// fn main() {\n@@ -794,7 +798,7 @@ pub struct DecodeUtf16<I>\n ///                \"\ud834\udd1emus\ufffdic\ufffd\");\n /// }\n /// ```\n-#[unstable(feature = \"decode_utf16\", reason = \"recently exposed\", issue = \"27830\")]\n+#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n #[inline]\n pub fn decode_utf16<I: IntoIterator<Item = u16>>(iter: I) -> DecodeUtf16<I::IntoIter> {\n     DecodeUtf16 {\n@@ -803,11 +807,11 @@ pub fn decode_utf16<I: IntoIterator<Item = u16>>(iter: I) -> DecodeUtf16<I::Into\n     }\n }\n \n-#[unstable(feature = \"decode_utf16\", reason = \"recently exposed\", issue = \"27830\")]\n+#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n impl<I: Iterator<Item=u16>> Iterator for DecodeUtf16<I> {\n-    type Item = Result<char, u16>;\n+    type Item = Result<char, DecodeUtf16Error>;\n \n-    fn next(&mut self) -> Option<Result<char, u16>> {\n+    fn next(&mut self) -> Option<Result<char, DecodeUtf16Error>> {\n         let u = match self.buf.take() {\n             Some(buf) => buf,\n             None => match self.iter.next() {\n@@ -821,18 +825,18 @@ impl<I: Iterator<Item=u16>> Iterator for DecodeUtf16<I> {\n             Some(Ok(unsafe { from_u32_unchecked(u as u32) }))\n         } else if u >= 0xDC00 {\n             // a trailing surrogate\n-            Some(Err(u))\n+            Some(Err(DecodeUtf16Error { code: u }))\n         } else {\n             let u2 = match self.iter.next() {\n                 Some(u2) => u2,\n                 // eof\n-                None => return Some(Err(u)),\n+                None => return Some(Err(DecodeUtf16Error { code: u })),\n             };\n             if u2 < 0xDC00 || u2 > 0xDFFF {\n                 // not a trailing surrogate so we're not a valid\n                 // surrogate pair, so rewind to redecode u2 next time.\n                 self.buf = Some(u2);\n-                return Some(Err(u));\n+                return Some(Err(DecodeUtf16Error { code: u }));\n             }\n \n             // all ok, so lets decode it.\n@@ -850,8 +854,25 @@ impl<I: Iterator<Item=u16>> Iterator for DecodeUtf16<I> {\n     }\n }\n \n-/// `U+FFFD REPLACEMENT CHARACTER` (\ufffd) is used in Unicode to represent a decoding error.\n+impl DecodeUtf16Error {\n+    /// Returns the unpaired surrogate which caused this error.\n+    #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n+    pub fn unpaired_surrogate(&self) -> u16 {\n+        self.code\n+    }\n+}\n+\n+#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n+impl fmt::Display for DecodeUtf16Error {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"unpaired surrogate found: {:x}\", self.code)\n+    }\n+}\n+\n+/// `U+FFFD REPLACEMENT CHARACTER` (\ufffd) is used in Unicode to represent a\n+/// decoding error.\n+///\n /// It can occur, for example, when giving ill-formed UTF-8 bytes to\n /// [`String::from_utf8_lossy`](../../std/string/struct.String.html#method.from_utf8_lossy).\n-#[unstable(feature = \"decode_utf16\", reason = \"recently added\", issue = \"27830\")]\n+#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n pub const REPLACEMENT_CHARACTER: char = '\\u{FFFD}';"}, {"sha": "bc7c7c5e0caf06d80ce8e6d6bd8e175b5cb6bdb0", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -21,12 +21,10 @@\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(libc)]\n-#![feature(recover)]\n #![feature(rustc_private)]\n #![feature(set_stdio)]\n #![feature(slice_patterns)]\n #![feature(staged_api)]\n-#![feature(std_panic)]\n #![feature(test)]\n #![feature(unicode)]\n #![feature(question_mark)]"}, {"sha": "982f477fc4ae1c0c5429551048c989711e9da4ec", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -15,7 +15,7 @@ use std::ffi::OsString;\n use std::io::prelude::*;\n use std::io;\n use std::path::PathBuf;\n-use std::panic::{self, AssertRecoverSafe};\n+use std::panic::{self, AssertUnwindSafe};\n use std::process::Command;\n use std::rc::Rc;\n use std::str;\n@@ -256,18 +256,13 @@ fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n         control.after_analysis.stop = Compilation::Stop;\n     }\n \n-    match {\n-        let b_sess = AssertRecoverSafe(&sess);\n-        let b_cstore = AssertRecoverSafe(&cstore);\n-        let b_cfg = AssertRecoverSafe(cfg.clone());\n-        let b_control = AssertRecoverSafe(&control);\n-\n-        panic::recover(|| {\n-            driver::compile_input(&b_sess, &b_cstore, (*b_cfg).clone(),\n-                                  &input, &out,\n-                                  &None, None, &b_control)\n-        })\n-    } {\n+    let res = panic::catch_unwind(AssertUnwindSafe(|| {\n+        driver::compile_input(&sess, &cstore, cfg.clone(),\n+                              &input, &out,\n+                              &None, None, &control)\n+    }));\n+\n+    match res {\n         Ok(r) => {\n             match r {\n                 Err(count) if count > 0 && compile_fail == false => {"}, {"sha": "31b71dbc80b62c2bd3ce75f5e78778d6b0567590", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -132,7 +132,10 @@ impl FromHex for str {\n                     buf >>= 4;\n                     continue\n                 }\n-                _ => return Err(InvalidHexCharacter(self.char_at(idx), idx)),\n+                _ => {\n+                    let ch = self[idx..].chars().next().unwrap();\n+                    return Err(InvalidHexCharacter(ch, idx))\n+                }\n             }\n \n             modulus += 1;"}, {"sha": "80cd47c85ccdfd64e5b5764a12b9d4aaa11f3e04", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -32,7 +32,6 @@ Core encoding and decoding interfaces.\n #![feature(enumset)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n-#![feature(str_char)]\n #![feature(unicode)]\n #![feature(question_mark)]\n #![cfg_attr(test, feature(test))]"}, {"sha": "0db91034eb5ac8eed231b5d28b9c3f4f9bc06347", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -128,8 +128,6 @@ pub trait AsciiExt {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(ascii)]\n-    ///\n     /// use std::ascii::AsciiExt;\n     ///\n     /// let mut ascii = 'a';\n@@ -138,7 +136,7 @@ pub trait AsciiExt {\n     ///\n     /// assert_eq!('A', ascii);\n     /// ```\n-    #[unstable(feature = \"ascii\", issue = \"27809\")]\n+    #[stable(feature = \"ascii\", since = \"1.9.0\")]\n     fn make_ascii_uppercase(&mut self);\n \n     /// Converts this type to its ASCII lower case equivalent in-place.\n@@ -148,8 +146,6 @@ pub trait AsciiExt {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(ascii)]\n-    ///\n     /// use std::ascii::AsciiExt;\n     ///\n     /// let mut ascii = 'A';\n@@ -158,7 +154,7 @@ pub trait AsciiExt {\n     ///\n     /// assert_eq!('a', ascii);\n     /// ```\n-    #[unstable(feature = \"ascii\", issue = \"27809\")]\n+    #[stable(feature = \"ascii\", since = \"1.9.0\")]\n     fn make_ascii_lowercase(&mut self);\n }\n "}, {"sha": "c20270e830665d4ee0eb36d3bef5b9352f62166d", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -620,8 +620,7 @@ impl<K, V, S> HashMap<K, V, S>\n     }\n \n     /// Returns a reference to the map's hasher.\n-    #[unstable(feature = \"hashmap_public_hasher\", reason = \"don't want to make insta-stable\",\n-               issue = \"31262\")]\n+    #[stable(feature = \"hashmap_public_hasher\", since = \"1.9.0\")]\n     pub fn hasher(&self) -> &S {\n         &self.hash_builder\n     }"}, {"sha": "b353a4c1ba120ca6521e0bf8cf6133336c911af1", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -194,8 +194,7 @@ impl<T, S> HashSet<T, S>\n     }\n \n     /// Returns a reference to the set's hasher.\n-    #[unstable(feature = \"hashmap_public_hasher\", reason = \"don't want to make insta-stable\",\n-               issue = \"31262\")]\n+    #[stable(feature = \"hashmap_public_hasher\", since = \"1.9.0\")]\n     pub fn hasher(&self) -> &S {\n         self.map.hasher()\n     }\n@@ -459,7 +458,7 @@ impl<T, S> HashSet<T, S>\n     /// The value may be any borrowed form of the set's value type, but\n     /// `Hash` and `Eq` on the borrowed form *must* match those for\n     /// the value type.\n-    #[unstable(feature = \"set_recovery\", issue = \"28050\")]\n+    #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n     pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T>\n         where T: Borrow<Q>, Q: Hash + Eq\n     {\n@@ -556,7 +555,7 @@ impl<T, S> HashSet<T, S>\n \n     /// Adds a value to the set, replacing the existing value, if any, that is equal to the given\n     /// one. Returns the replaced value.\n-    #[unstable(feature = \"set_recovery\", issue = \"28050\")]\n+    #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n     pub fn replace(&mut self, value: T) -> Option<T> {\n         Recover::replace(&mut self.map, value)\n     }\n@@ -591,7 +590,7 @@ impl<T, S> HashSet<T, S>\n     /// The value may be any borrowed form of the set's value type, but\n     /// `Hash` and `Eq` on the borrowed form *must* match those for\n     /// the value type.\n-    #[unstable(feature = \"set_recovery\", issue = \"28050\")]\n+    #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n     pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T>\n         where T: Borrow<Q>, Q: Hash + Eq\n     {"}, {"sha": "35cd4a5ec5292076fef8fc29d4d8dd2f5883199f", "filename": "src/libstd/error.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -49,13 +49,11 @@\n \n use any::TypeId;\n use boxed::Box;\n-use convert::From;\n+use char;\n use fmt::{self, Debug, Display};\n use marker::{Send, Sync, Reflect};\n use mem::transmute;\n use num;\n-use option::Option::{self, Some, None};\n-use result::Result::{self, Ok, Err};\n use raw::TraitObject;\n use str;\n use string::{self, String};\n@@ -189,6 +187,13 @@ impl Error for string::ParseError {\n     }\n }\n \n+#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n+impl Error for char::DecodeUtf16Error {\n+    fn description(&self) -> &str {\n+        \"unpaired surrogate found\"\n+    }\n+}\n+\n #[stable(feature = \"box_error\", since = \"1.7.0\")]\n impl<T: Error> Error for Box<T> {\n     fn description(&self) -> &str {"}, {"sha": "0d29e62485abb8035fa3c7a404174790cc6d61c9", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -86,54 +86,51 @@ impl OsString {\n         self.inner.push_slice(&s.as_ref().inner)\n     }\n \n-    /// Creates a new `OsString` with the given capacity. The string will be\n-    /// able to hold exactly `capacity` bytes without reallocating. If\n-    /// `capacity` is 0, the string will not allocate.\n+    /// Creates a new `OsString` with the given capacity.\n+    ///\n+    /// The string will be able to hold exactly `capacity` lenth units of other\n+    /// OS strings without reallocating. If `capacity` is 0, the string will not\n+    /// allocate.\n     ///\n     /// See main `OsString` documentation information about encoding.\n-    #[unstable(feature = \"osstring_simple_functions\",\n-               reason = \"recently added\", issue = \"29453\")]\n+    #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n     pub fn with_capacity(capacity: usize) -> OsString {\n         OsString {\n             inner: Buf::with_capacity(capacity)\n         }\n     }\n \n     /// Truncates the `OsString` to zero length.\n-    #[unstable(feature = \"osstring_simple_functions\",\n-               reason = \"recently added\", issue = \"29453\")]\n+    #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n     pub fn clear(&mut self) {\n         self.inner.clear()\n     }\n \n-    /// Returns the number of bytes this `OsString` can hold without\n-    /// reallocating.\n+    /// Returns the capacity this `OsString` can hold without reallocating.\n     ///\n     /// See `OsString` introduction for information about encoding.\n-    #[unstable(feature = \"osstring_simple_functions\",\n-               reason = \"recently added\", issue = \"29453\")]\n+    #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n     pub fn capacity(&self) -> usize {\n         self.inner.capacity()\n     }\n \n-    /// Reserves capacity for at least `additional` more bytes to be inserted\n-    /// in the given `OsString`. The collection may reserve more space to avoid\n-    /// frequent reallocations.\n-    #[unstable(feature = \"osstring_simple_functions\",\n-               reason = \"recently added\", issue = \"29453\")]\n+    /// Reserves capacity for at least `additional` more capacity to be inserted\n+    /// in the given `OsString`.\n+    ///\n+    /// The collection may reserve more space to avoid frequent reallocations.\n+    #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n     pub fn reserve(&mut self, additional: usize) {\n         self.inner.reserve(additional)\n     }\n \n-    /// Reserves the minimum capacity for exactly `additional` more bytes to be\n-    /// inserted in the given `OsString`. Does nothing if the capacity is\n+    /// Reserves the minimum capacity for exactly `additional` more capacity to\n+    /// be inserted in the given `OsString`. Does nothing if the capacity is\n     /// already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it\n     /// requests. Therefore capacity can not be relied upon to be precisely\n     /// minimal. Prefer reserve if future insertions are expected.\n-    #[unstable(feature = \"osstring_simple_functions\",\n-               reason = \"recently added\", issue = \"29453\")]\n+    #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n     pub fn reserve_exact(&mut self, additional: usize) {\n         self.inner.reserve_exact(additional)\n     }\n@@ -286,17 +283,20 @@ impl OsStr {\n     }\n \n     /// Checks whether the `OsStr` is empty.\n-    #[unstable(feature = \"osstring_simple_functions\",\n-               reason = \"recently added\", issue = \"29453\")]\n+    #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n     pub fn is_empty(&self) -> bool {\n         self.inner.inner.is_empty()\n     }\n \n-    /// Returns the number of bytes in this `OsStr`.\n+    /// Returns the length of this `OsStr`.\n+    ///\n+    /// Note that this does **not** return the number of bytes in this string\n+    /// as, for example, OS strings on Windows are encoded as a list of `u16`\n+    /// rather than a list of bytes. This number is simply useful for passing to\n+    /// other methods like `OsString::with_capacity` to avoid reallocations.\n     ///\n-    /// See `OsStr` introduction for information about encoding.\n-    #[unstable(feature = \"osstring_simple_functions\",\n-               reason = \"recently added\", issue = \"29453\")]\n+    /// See `OsStr` introduction for more information about encoding.\n+    #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n     pub fn len(&self) -> usize {\n         self.inner.inner.len()\n     }"}, {"sha": "f5a51e974272754541ac5813ed6c0ecec3cad521", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -302,7 +302,7 @@ impl File {\n     /// The returned `File` is a reference to the same state that this object\n     /// references. Both handles will read and write with the same cursor\n     /// position.\n-    #[unstable(feature = \"file_try_clone\", reason = \"newly added\", issue = \"31405\")]\n+    #[stable(feature = \"file_try_clone\", since = \"1.9.0\")]\n     pub fn try_clone(&self) -> io::Result<File> {\n         Ok(File {\n             inner: self.inner.duplicate()?\n@@ -523,16 +523,13 @@ impl OpenOptions {\n     /// # Examples\n     ///\n     /// ```no_run\n-    /// #![feature(expand_open_options)]\n     /// use std::fs::OpenOptions;\n     ///\n     /// let file = OpenOptions::new().write(true)\n     ///                              .create_new(true)\n     ///                              .open(\"foo.txt\");\n     /// ```\n-    #[unstable(feature = \"expand_open_options\",\n-               reason = \"recently added\",\n-               issue = \"30014\")]\n+    #[stable(feature = \"expand_open_options2\", since = \"1.9.0\")]\n     pub fn create_new(&mut self, create_new: bool) -> &mut OpenOptions {\n         self.0.create_new(create_new); self\n     }"}, {"sha": "6dd7273c17fe7b614cebcc67cc4cac7c68e0468f", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -1596,7 +1596,7 @@ impl<R: Read> Iterator for Chars<R> {\n             }\n         }\n         Some(match str::from_utf8(&buf[..width]).ok() {\n-            Some(s) => Ok(s.char_at(0)),\n+            Some(s) => Ok(s.chars().next().unwrap()),\n             None => Err(CharsError::NotUtf8),\n         })\n     }"}, {"sha": "e14a31453d381601f4ccf4e860f8fc4c95bcadef", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -222,10 +222,8 @@\n #![feature(collections)]\n #![feature(collections_bound)]\n #![feature(const_fn)]\n-#![feature(copy_from_slice)]\n #![feature(core_float)]\n #![feature(core_intrinsics)]\n-#![feature(decode_utf16)]\n #![feature(dropck_parametricity)]\n #![feature(float_extras)]\n #![feature(float_from_str_radix)]"}, {"sha": "d510339f1c5b492d29941a9cbfe10bc7e4e926d5", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -68,7 +68,7 @@ impl SocketAddr {\n     }\n \n     /// Change the IP address associated with this socket address.\n-    #[unstable(feature = \"sockaddr_setters\", reason = \"recent addition\", issue = \"31572\")]\n+    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n     pub fn set_ip(&mut self, new_ip: IpAddr) {\n         // `match (*self, new_ip)` would have us mutate a copy of self only to throw it away.\n         match (self, new_ip) {\n@@ -88,7 +88,7 @@ impl SocketAddr {\n     }\n \n     /// Change the port number associated with this socket address.\n-    #[unstable(feature = \"sockaddr_setters\", reason = \"recent addition\", issue = \"31572\")]\n+    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n     pub fn set_port(&mut self, new_port: u16) {\n         match *self {\n             SocketAddr::V4(ref mut a) => a.set_port(new_port),\n@@ -120,16 +120,22 @@ impl SocketAddrV4 {\n     }\n \n     /// Change the IP address associated with this socket address.\n-    #[unstable(feature = \"sockaddr_setters\", reason = \"recent addition\", issue = \"31572\")]\n-    pub fn set_ip(&mut self, new_ip: Ipv4Addr) { self.inner.sin_addr = *new_ip.as_inner() }\n+    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n+    pub fn set_ip(&mut self, new_ip: Ipv4Addr) {\n+        self.inner.sin_addr = *new_ip.as_inner()\n+    }\n \n     /// Returns the port number associated with this socket address.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn port(&self) -> u16 { ntoh(self.inner.sin_port) }\n+    pub fn port(&self) -> u16 {\n+        ntoh(self.inner.sin_port)\n+    }\n \n     /// Change the port number associated with this socket address.\n-    #[unstable(feature = \"sockaddr_setters\", reason = \"recent addition\", issue = \"31572\")]\n-    pub fn set_port(&mut self, new_port: u16) { self.inner.sin_port = hton(new_port) }\n+    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n+    pub fn set_port(&mut self, new_port: u16) {\n+        self.inner.sin_port = hton(new_port);\n+    }\n }\n \n impl SocketAddrV6 {\n@@ -159,35 +165,45 @@ impl SocketAddrV6 {\n     }\n \n     /// Change the IP address associated with this socket address.\n-    #[unstable(feature = \"sockaddr_setters\", reason = \"recent addition\", issue = \"31572\")]\n-    pub fn set_ip(&mut self, new_ip: Ipv6Addr) { self.inner.sin6_addr = *new_ip.as_inner() }\n+    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n+    pub fn set_ip(&mut self, new_ip: Ipv6Addr) {\n+        self.inner.sin6_addr = *new_ip.as_inner()\n+    }\n \n     /// Returns the port number associated with this socket address.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn port(&self) -> u16 { ntoh(self.inner.sin6_port) }\n+    pub fn port(&self) -> u16 {\n+        ntoh(self.inner.sin6_port)\n+    }\n \n     /// Change the port number associated with this socket address.\n-    #[unstable(feature = \"sockaddr_setters\", reason = \"recent addition\", issue = \"31572\")]\n-    pub fn set_port(&mut self, new_port: u16) { self.inner.sin6_port = hton(new_port) }\n+    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n+    pub fn set_port(&mut self, new_port: u16) {\n+        self.inner.sin6_port = hton(new_port);\n+    }\n \n     /// Returns the flow information associated with this address,\n     /// corresponding to the `sin6_flowinfo` field in C.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn flowinfo(&self) -> u32 { self.inner.sin6_flowinfo }\n+    pub fn flowinfo(&self) -> u32 {\n+        self.inner.sin6_flowinfo\n+    }\n \n     /// Change the flow information associated with this socket address.\n-    #[unstable(feature = \"sockaddr_setters\", reason = \"recent addition\", issue = \"31572\")]\n+    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n     pub fn set_flowinfo(&mut self, new_flowinfo: u32) {\n         self.inner.sin6_flowinfo = new_flowinfo;\n     }\n \n     /// Returns the scope ID associated with this address,\n     /// corresponding to the `sin6_scope_id` field in C.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn scope_id(&self) -> u32 { self.inner.sin6_scope_id }\n+    pub fn scope_id(&self) -> u32 {\n+        self.inner.sin6_scope_id\n+    }\n \n     /// Change the scope ID associated with this socket address.\n-    #[unstable(feature = \"sockaddr_setters\", reason = \"recent addition\", issue = \"31572\")]\n+    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n     pub fn set_scope_id(&mut self, new_scope_id: u32) {\n         self.inner.sin6_scope_id = new_scope_id;\n     }"}, {"sha": "16401c4527f160b15dab692c8872aeff10018ccf", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 156, "deletions": 66, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -10,8 +10,7 @@\n \n //! Panic support in the standard library\n \n-#![unstable(feature = \"std_panic\", reason = \"awaiting feedback\",\n-            issue = \"27719\")]\n+#![stable(feature = \"std_panic\", since = \"1.9.0\")]\n \n use any::Any;\n use boxed::Box;\n@@ -23,6 +22,7 @@ use sync::{Arc, Mutex, RwLock};\n use sys_common::unwind;\n use thread::Result;\n \n+#[unstable(feature = \"panic_handler\", issue = \"30449\")]\n pub use panicking::{take_hook, set_hook, PanicInfo, Location};\n \n ///\n@@ -92,7 +92,7 @@ pub fn take_handler() -> Box<Fn(&PanicInfo) + 'static + Sync + Send> {\n /// \"speed bump\" to alert users of `recover` that broken invariants may be\n /// witnessed and may need to be accounted for.\n ///\n-/// ## Who implements `RecoverSafe`?\n+/// ## Who implements `UnwindSafe`?\n ///\n /// Types such as `&mut T` and `&RefCell<T>` are examples which are **not**\n /// recover safe. The general idea is that any mutable state which can be shared\n@@ -104,18 +104,26 @@ pub fn take_handler() -> Box<Fn(&PanicInfo) + 'static + Sync + Send> {\n /// poisoning by default. They still allow witnessing a broken invariant, but\n /// they already provide their own \"speed bumps\" to do so.\n ///\n-/// ## When should `RecoverSafe` be used?\n+/// ## When should `UnwindSafe` be used?\n ///\n /// Is not intended that most types or functions need to worry about this trait.\n /// It is only used as a bound on the `recover` function and as mentioned above,\n /// the lack of `unsafe` means it is mostly an advisory. The `AssertRecoverSafe`\n /// wrapper struct in this module can be used to force this trait to be\n /// implemented for any closed over variables passed to the `recover` function\n /// (more on this below).\n-#[unstable(feature = \"recover\", reason = \"awaiting feedback\", issue = \"27719\")]\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n #[rustc_on_unimplemented = \"the type {Self} may not be safely transferred \\\n                             across a recover boundary\"]\n+pub trait UnwindSafe {}\n+\n+/// Deprecated, renamed to UnwindSafe\n+#[unstable(feature = \"recover\", reason = \"awaiting feedback\", issue = \"27719\")]\n+#[rustc_deprecated(reason = \"renamed to `UnwindSafe`\", since = \"1.9.0\")]\n pub trait RecoverSafe {}\n+#[unstable(feature = \"recover\", reason = \"awaiting feedback\", issue = \"27719\")]\n+#[allow(deprecated)]\n+impl<T: UnwindSafe> RecoverSafe for T {}\n \n /// A marker trait representing types where a shared reference is considered\n /// recover safe.\n@@ -124,12 +132,12 @@ pub trait RecoverSafe {}\n /// interior mutability.\n ///\n /// This is a \"helper marker trait\" used to provide impl blocks for the\n-/// `RecoverSafe` trait, for more information see that documentation.\n-#[unstable(feature = \"recover\", reason = \"awaiting feedback\", issue = \"27719\")]\n+/// `UnwindSafe` trait, for more information see that documentation.\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n #[rustc_on_unimplemented = \"the type {Self} contains interior mutability \\\n                             and a reference may not be safely transferrable \\\n                             across a recover boundary\"]\n-pub trait RefRecoverSafe {}\n+pub trait RefUnwindSafe {}\n \n /// A simple wrapper around a type to assert that it is panic safe.\n ///\n@@ -143,90 +151,141 @@ pub trait RefRecoverSafe {}\n ///\n /// # Examples\n ///\n-/// One way to use `AssertRecoverSafe` is to assert that the entire closure\n+/// One way to use `AssertUnwindSafe` is to assert that the entire closure\n /// itself is recover safe, bypassing all checks for all variables:\n ///\n /// ```\n-/// #![feature(recover, std_panic)]\n-///\n-/// use std::panic::{self, AssertRecoverSafe};\n+/// use std::panic::{self, AssertUnwindSafe};\n ///\n /// let mut variable = 4;\n ///\n /// // This code will not compile because the closure captures `&mut variable`\n /// // which is not considered panic safe by default.\n ///\n-/// // panic::recover(|| {\n+/// // panic::catch_unwind(|| {\n /// //     variable += 3;\n /// // });\n ///\n-/// // This, however, will compile due to the `AssertRecoverSafe` wrapper\n-/// let result = panic::recover(AssertRecoverSafe(|| {\n+/// // This, however, will compile due to the `AssertUnwindSafe` wrapper\n+/// let result = panic::catch_unwind(AssertUnwindSafe(|| {\n ///     variable += 3;\n /// }));\n /// // ...\n /// ```\n ///\n /// Wrapping the entire closure amounts to a blanket assertion that all captured\n-/// variables are recover safe. This has the downside that if new captures are\n-/// added in the future, they will also be considered recover safe. Therefore,\n+/// variables are unwind safe. This has the downside that if new captures are\n+/// added in the future, they will also be considered unwind safe. Therefore,\n /// you may prefer to just wrap individual captures, as shown below. This is\n /// more annotation, but it ensures that if a new capture is added which is not\n-/// recover safe, you will get a compilation error at that time, which will\n+/// unwind safe, you will get a compilation error at that time, which will\n /// allow you to consider whether that new capture in fact represent a bug or\n /// not.\n ///\n /// ```\n-/// #![feature(recover, std_panic)]\n-///\n-/// use std::panic::{self, AssertRecoverSafe};\n+/// use std::panic::{self, AssertUnwindSafe};\n ///\n /// let mut variable = 4;\n /// let other_capture = 3;\n ///\n /// let result = {\n-///     let mut wrapper = AssertRecoverSafe(&mut variable);\n-///     panic::recover(move || {\n+///     let mut wrapper = AssertUnwindSafe(&mut variable);\n+///     panic::catch_unwind(move || {\n ///         **wrapper += other_capture;\n ///     })\n /// };\n /// // ...\n /// ```\n-#[unstable(feature = \"recover\", reason = \"awaiting feedback\", issue = \"27719\")]\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+pub struct AssertUnwindSafe<T>(\n+    #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+    pub T\n+);\n+\n+/// Deprecated, renamed to `AssertUnwindSafe`\n+#[unstable(feature = \"recover\", issue = \"27719\")]\n+#[rustc_deprecated(reason = \"renamed to `AssertUnwindSafe`\", since = \"1.9.0\")]\n pub struct AssertRecoverSafe<T>(pub T);\n \n-// Implementations of the `RecoverSafe` trait:\n+// Implementations of the `UnwindSafe` trait:\n //\n-// * By default everything is recover safe\n-// * pointers T contains mutability of some form are not recover safe\n+// * By default everything is unwind safe\n+// * pointers T contains mutability of some form are not unwind safe\n // * Unique, an owning pointer, lifts an implementation\n-// * Types like Mutex/RwLock which are explicilty poisoned are recover safe\n-// * Our custom AssertRecoverSafe wrapper is indeed recover safe\n-impl RecoverSafe for .. {}\n-impl<'a, T: ?Sized> !RecoverSafe for &'a mut T {}\n-impl<'a, T: RefRecoverSafe + ?Sized> RecoverSafe for &'a T {}\n-impl<T: RefRecoverSafe + ?Sized> RecoverSafe for *const T {}\n-impl<T: RefRecoverSafe + ?Sized> RecoverSafe for *mut T {}\n-impl<T: RecoverSafe> RecoverSafe for Unique<T> {}\n-impl<T: RefRecoverSafe + ?Sized> RecoverSafe for Shared<T> {}\n-impl<T: ?Sized> RecoverSafe for Mutex<T> {}\n-impl<T: ?Sized> RecoverSafe for RwLock<T> {}\n-impl<T> RecoverSafe for AssertRecoverSafe<T> {}\n+// * Types like Mutex/RwLock which are explicilty poisoned are unwind safe\n+// * Our custom AssertUnwindSafe wrapper is indeed unwind safe\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl UnwindSafe for .. {}\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<'a, T: ?Sized> !UnwindSafe for &'a mut T {}\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<'a, T: RefUnwindSafe + ?Sized> UnwindSafe for &'a T {}\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T: RefUnwindSafe + ?Sized> UnwindSafe for *const T {}\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T: RefUnwindSafe + ?Sized> UnwindSafe for *mut T {}\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T: UnwindSafe> UnwindSafe for Unique<T> {}\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T: RefUnwindSafe + ?Sized> UnwindSafe for Shared<T> {}\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T: ?Sized> UnwindSafe for Mutex<T> {}\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T: ?Sized> UnwindSafe for RwLock<T> {}\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T> UnwindSafe for AssertUnwindSafe<T> {}\n+#[unstable(feature = \"recover\", issue = \"27719\")]\n+#[allow(deprecated)]\n+impl<T> UnwindSafe for AssertRecoverSafe<T> {}\n \n // not covered via the Shared impl above b/c the inner contents use\n // Cell/AtomicUsize, but the usage here is recover safe so we can lift the\n // impl up one level to Arc/Rc itself\n-impl<T: RefRecoverSafe + ?Sized> RecoverSafe for Rc<T> {}\n-impl<T: RefRecoverSafe + ?Sized> RecoverSafe for Arc<T> {}\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T: RefUnwindSafe + ?Sized> UnwindSafe for Rc<T> {}\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T: RefUnwindSafe + ?Sized> UnwindSafe for Arc<T> {}\n \n // Pretty simple implementations for the `RefRecoverSafe` marker trait,\n // basically just saying that this is a marker trait and `UnsafeCell` is the\n // only thing which doesn't implement it (which then transitively applies to\n // everything else).\n-impl RefRecoverSafe for .. {}\n-impl<T: ?Sized> !RefRecoverSafe for UnsafeCell<T> {}\n-impl<T> RefRecoverSafe for AssertRecoverSafe<T> {}\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl RefUnwindSafe for .. {}\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T: ?Sized> !RefUnwindSafe for UnsafeCell<T> {}\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T> RefUnwindSafe for AssertUnwindSafe<T> {}\n+#[unstable(feature = \"recover\", issue = \"27719\")]\n+#[allow(deprecated)]\n+impl<T> RefUnwindSafe for AssertRecoverSafe<T> {}\n+\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T> Deref for AssertUnwindSafe<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        &self.0\n+    }\n+}\n+\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T> DerefMut for AssertUnwindSafe<T> {\n+    fn deref_mut(&mut self) -> &mut T {\n+        &mut self.0\n+    }\n+}\n \n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<R, F: FnOnce() -> R> FnOnce<()> for AssertUnwindSafe<F> {\n+    type Output = R;\n+\n+    extern \"rust-call\" fn call_once(self, _args: ()) -> R {\n+        (self.0)()\n+    }\n+}\n+\n+#[allow(deprecated)]\n impl<T> AssertRecoverSafe<T> {\n     /// Creates a new `AssertRecoverSafe` wrapper around the provided type.\n     #[unstable(feature = \"recover\", reason = \"awaiting feedback\", issue = \"27719\")]\n@@ -245,6 +304,8 @@ impl<T> AssertRecoverSafe<T> {\n     }\n }\n \n+#[unstable(feature = \"recover\", issue = \"27719\")]\n+#[allow(deprecated)]\n impl<T> Deref for AssertRecoverSafe<T> {\n     type Target = T;\n \n@@ -253,12 +314,16 @@ impl<T> Deref for AssertRecoverSafe<T> {\n     }\n }\n \n+#[unstable(feature = \"recover\", issue = \"27719\")]\n+#[allow(deprecated)]\n impl<T> DerefMut for AssertRecoverSafe<T> {\n     fn deref_mut(&mut self) -> &mut T {\n         &mut self.0\n     }\n }\n \n+#[unstable(feature = \"recover\", issue = \"27719\")]\n+#[allow(deprecated)]\n impl<R, F: FnOnce() -> R> FnOnce<()> for AssertRecoverSafe<F> {\n     type Output = R;\n \n@@ -267,7 +332,7 @@ impl<R, F: FnOnce() -> R> FnOnce<()> for AssertRecoverSafe<F> {\n     }\n }\n \n-/// Invokes a closure, capturing the cause of panic if one occurs.\n+/// Invokes a closure, capturing the cause of an unwinding panic if one occurs.\n ///\n /// This function will return `Ok` with the closure's result if the closure\n /// does not panic, and will return `Err(cause)` if the closure panics. The\n@@ -280,38 +345,44 @@ impl<R, F: FnOnce() -> R> FnOnce<()> for AssertRecoverSafe<F> {\n ///\n /// It is **not** recommended to use this function for a general try/catch\n /// mechanism. The `Result` type is more appropriate to use for functions that\n-/// can fail on a regular basis.\n-///\n-/// The closure provided is required to adhere to the `RecoverSafe` to ensure\n-/// that all captured variables are safe to cross this recover boundary. The\n-/// purpose of this bound is to encode the concept of [exception safety][rfc] in\n-/// the type system. Most usage of this function should not need to worry about\n-/// this bound as programs are naturally panic safe without `unsafe` code. If it\n-/// becomes a problem the associated `AssertRecoverSafe` wrapper type in this\n+/// can fail on a regular basis. Additionally, this function is not guaranteed\n+/// to catch all panics, see the \"Notes\" sectino below.\n+///\n+/// The closure provided is required to adhere to the `UnwindSafe` to ensure\n+/// that all captured variables are safe to cross this boundary. The purpose of\n+/// this bound is to encode the concept of [exception safety][rfc] in the type\n+/// system. Most usage of this function should not need to worry about this\n+/// bound as programs are naturally panic safe without `unsafe` code. If it\n+/// becomes a problem the associated `AssertUnwindSafe` wrapper type in this\n /// module can be used to quickly assert that the usage here is indeed exception\n /// safe.\n ///\n /// [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md\n ///\n+/// # Notes\n+///\n+/// Note that this function **may not catch all panics** in Rust. A panic in\n+/// Rust is not always implemented via unwinding, but can be implemented by\n+/// aborting the process as well. This function *only* catches unwinding panics,\n+/// not those that abort the process.\n+///\n /// # Examples\n ///\n /// ```\n-/// #![feature(recover, std_panic)]\n-///\n /// use std::panic;\n ///\n-/// let result = panic::recover(|| {\n+/// let result = panic::catch_unwind(|| {\n ///     println!(\"hello!\");\n /// });\n /// assert!(result.is_ok());\n ///\n-/// let result = panic::recover(|| {\n+/// let result = panic::catch_unwind(|| {\n ///     panic!(\"oh no!\");\n /// });\n /// assert!(result.is_err());\n /// ```\n-#[unstable(feature = \"recover\", reason = \"awaiting feedback\", issue = \"27719\")]\n-pub fn recover<F: FnOnce() -> R + RecoverSafe, R>(f: F) -> Result<R> {\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n     let mut result = None;\n     unsafe {\n         let result = &mut result;\n@@ -320,27 +391,46 @@ pub fn recover<F: FnOnce() -> R + RecoverSafe, R>(f: F) -> Result<R> {\n     Ok(result.unwrap())\n }\n \n+/// Deprecated, renamed to `catch_unwind`\n+#[unstable(feature = \"recover\", reason = \"awaiting feedback\", issue = \"27719\")]\n+#[rustc_deprecated(reason = \"renamed to `catch_unwind`\", since = \"1.9.0\")]\n+pub fn recover<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n+    catch_unwind(f)\n+}\n+\n /// Triggers a panic without invoking the panic handler.\n ///\n-/// This is designed to be used in conjunction with `recover` to, for example,\n-/// carry a panic across a layer of C code.\n+/// This is designed to be used in conjunction with `catch_unwind` to, for\n+/// example, carry a panic across a layer of C code.\n+///\n+/// # Notes\n+///\n+/// Note that panics in Rust are not always implemented via unwinding, but they\n+/// may be implemented by aborting the process. If this function is called when\n+/// panics are implemented this way then this function will abort the process,\n+/// not trigger an unwind.\n ///\n /// # Examples\n ///\n /// ```should_panic\n-/// #![feature(std_panic, recover, panic_propagate)]\n-///\n /// use std::panic;\n ///\n-/// let result = panic::recover(|| {\n+/// let result = panic::catch_unwind(|| {\n ///     panic!(\"oh no!\");\n /// });\n ///\n /// if let Err(err) = result {\n-///     panic::propagate(err);\n+///     panic::resume_unwind(err);\n /// }\n /// ```\n+#[stable(feature = \"resume_unwind\", since = \"1.9.0\")]\n+pub fn resume_unwind(payload: Box<Any + Send>) -> ! {\n+    unwind::rust_panic(payload)\n+}\n+\n+/// Deprecated, use resume_unwind instead\n #[unstable(feature = \"panic_propagate\", reason = \"awaiting feedback\", issue = \"30752\")]\n+#[rustc_deprecated(reason = \"renamed to `resume_unwind`\", since = \"1.9.0\")]\n pub fn propagate(payload: Box<Any + Send>) -> ! {\n-    unwind::rust_panic(payload)\n+    resume_unwind(payload)\n }"}, {"sha": "83091c72c0d6bea2a2c4a0a990679effac0fd93e", "filename": "src/libstd/rt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -60,7 +60,7 @@ fn lang_start(main: *const u8, argc: isize, argv: *const *const u8) -> isize {\n         sys_common::args::init(argc, argv);\n \n         // Let's run some code!\n-        let res = panic::recover(mem::transmute::<_, fn()>(main));\n+        let res = panic::catch_unwind(mem::transmute::<_, fn()>(main));\n         sys_common::cleanup();\n         res.is_err()\n     };"}, {"sha": "e228d236a3ca716317dd709ecd79471c508dc971", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -425,13 +425,13 @@ mod tests {\n         static O: Once = Once::new();\n \n         // poison the once\n-        let t = panic::recover(|| {\n+        let t = panic::catch_unwind(|| {\n             O.call_once(|| panic!());\n         });\n         assert!(t.is_err());\n \n         // poisoning propagates\n-        let t = panic::recover(|| {\n+        let t = panic::catch_unwind(|| {\n             O.call_once(|| {});\n         });\n         assert!(t.is_err());\n@@ -453,7 +453,7 @@ mod tests {\n         static O: Once = Once::new();\n \n         // poison the once\n-        let t = panic::recover(|| {\n+        let t = panic::catch_unwind(|| {\n             O.call_once(|| panic!());\n         });\n         assert!(t.is_err());"}, {"sha": "6f185437e50af47b3d4b7966210fbaa636284e78", "filename": "src/libstd/sys/common/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -131,7 +131,7 @@ pub fn demangle(writer: &mut Write, s: &str) -> io::Result<()> {\n                 first = false;\n             }\n             let mut rest = inner;\n-            while rest.char_at(0).is_numeric() {\n+            while rest.chars().next().unwrap().is_numeric() {\n                 rest = &rest[1..];\n             }\n             let i: usize = inner[.. (inner.len() - rest.len())].parse().unwrap();"}, {"sha": "55e485e5811acc687dce80d57e2f43571489f3d3", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -191,8 +191,11 @@ impl Wtf8Buf {\n             match item {\n                 Ok(ch) => string.push_char(ch),\n                 Err(surrogate) => {\n+                    let surrogate = surrogate.unpaired_surrogate();\n                     // Surrogates are known to be in the code point range.\n-                    let code_point = unsafe { CodePoint::from_u32_unchecked(surrogate as u32) };\n+                    let code_point = unsafe {\n+                        CodePoint::from_u32_unchecked(surrogate as u32)\n+                    };\n                     // Skip the WTF-8 concatenation check,\n                     // surrogate pairs are already decoded by decode_utf16\n                     string.push_code_point_unchecked(code_point)"}, {"sha": "1be3d75d866dd7123c663604a142fb9f8ffcfeed", "filename": "src/libstd/sys/unix/ext/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Fsys%2Funix%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Fsys%2Funix%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fmod.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -49,7 +49,9 @@ pub mod prelude {\n     #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub use super::fs::{PermissionsExt, OpenOptionsExt, MetadataExt, FileTypeExt};\n     #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::fs::{DirEntryExt};\n+    pub use super::fs::DirEntryExt;\n+    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use super::thread::JoinHandleExt;\n     #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub use super::process::{CommandExt, ExitStatusExt};\n }"}, {"sha": "7f31cf9f3bf80690b7f01506e9bdf317b3b07b78", "filename": "src/libstd/sys/unix/ext/process.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -45,6 +45,8 @@ pub trait CommandExt {\n     /// (the daemon) in the same session.\n     #[unstable(feature = \"process_session_leader\", reason = \"recently added\",\n                issue = \"27811\")]\n+    #[rustc_deprecated(reason = \"use `before_exec` instead\",\n+                       since = \"1.9.0\")]\n     fn session_leader(&mut self, on: bool) -> &mut process::Command;\n \n     /// Schedules a closure to be run just before the `exec` function is\n@@ -94,7 +96,7 @@ pub trait CommandExt {\n     /// file descriptors may have changed. If a \"transactional spawn\" is\n     /// required to gracefully handle errors it is recommended to use the\n     /// cross-platform `spawn` instead.\n-    #[unstable(feature = \"process_exec\", issue = \"31398\")]\n+    #[stable(feature = \"process_exec2\", since = \"1.9.0\")]\n     fn exec(&mut self) -> io::Error;\n }\n "}, {"sha": "fe2a48764dc3a99799373cf3f0878a8b61d6dca7", "filename": "src/libstd/sys/unix/ext/thread.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Fsys%2Funix%2Fext%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Fsys%2Funix%2Fext%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fthread.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -8,37 +8,41 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Unix-specific extensions to primitives in the `std::process` module.\n+//! Unix-specific extensions to primitives in the `std::thread` module.\n \n-#![unstable(feature = \"thread_extensions\", issue = \"29791\")]\n+#![stable(feature = \"thread_extensions\", since = \"1.9.0\")]\n \n #[allow(deprecated)]\n use os::unix::raw::pthread_t;\n use sys_common::{AsInner, IntoInner};\n use thread::JoinHandle;\n \n-#[unstable(feature = \"thread_extensions\", issue = \"29791\")]\n+#[stable(feature = \"thread_extensions\", since = \"1.9.0\")]\n #[allow(deprecated)]\n pub type RawPthread = pthread_t;\n \n /// Unix-specific extensions to `std::thread::JoinHandle`\n-#[unstable(feature = \"thread_extensions\", issue = \"29791\")]\n+#[stable(feature = \"thread_extensions\", since = \"1.9.0\")]\n pub trait JoinHandleExt {\n     /// Extracts the raw pthread_t without taking ownership\n+    #[stable(feature = \"thread_extensions\", since = \"1.9.0\")]\n     fn as_pthread_t(&self) -> RawPthread;\n+\n     /// Consumes the thread, returning the raw pthread_t\n     ///\n     /// This function **transfers ownership** of the underlying pthread_t to\n     /// the caller. Callers are then the unique owners of the pthread_t and\n     /// must either detach or join the pthread_t once it's no longer needed.\n+    #[stable(feature = \"thread_extensions\", since = \"1.9.0\")]\n     fn into_pthread_t(self) -> RawPthread;\n }\n \n-#[unstable(feature = \"thread_extensions\", issue = \"29791\")]\n+#[stable(feature = \"thread_extensions\", since = \"1.9.0\")]\n impl<T> JoinHandleExt for JoinHandle<T> {\n     fn as_pthread_t(&self) -> RawPthread {\n         self.as_inner().id() as RawPthread\n     }\n+\n     fn into_pthread_t(self) -> RawPthread {\n         self.into_inner().into_id() as RawPthread\n     }"}, {"sha": "36b3a3d4bdec8570f839bf1a580276f1c16973b7", "filename": "src/libstd/sys/windows/ext/thread.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fthread.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -10,18 +10,20 @@\n \n //! Extensions to `std::thread` for Windows.\n \n-#![unstable(feature = \"thread_extensions\", issue = \"29791\")]\n+#![stable(feature = \"thread_extensions\", since = \"1.9.0\")]\n \n use os::windows::io::{RawHandle, AsRawHandle, IntoRawHandle};\n use thread;\n use sys_common::{AsInner, IntoInner};\n \n+#[stable(feature = \"thread_extensions\", since = \"1.9.0\")]\n impl<T> AsRawHandle for thread::JoinHandle<T> {\n     fn as_raw_handle(&self) -> RawHandle {\n         self.as_inner().handle().raw() as *mut _\n     }\n }\n \n+#[stable(feature = \"thread_extensions\", since = \"1.9.0\")]\n impl<T> IntoRawHandle for thread::JoinHandle<T>  {\n     fn into_raw_handle(self) -> RawHandle {\n         self.into_inner().into_handle().into_raw() as *mut _"}, {"sha": "fc18ef407ab2f9e138f5bb435a793959bf959c47", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -237,7 +237,7 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Option<u32>, Status\n     (\"stmt_expr_attributes\", \"1.6.0\", Some(15701), Active),\n \n     // Allows `#[deprecated]` attribute\n-    (\"deprecated\", \"1.6.0\", Some(29935), Active),\n+    (\"deprecated\", \"1.9.0\", Some(29935), Accepted),\n \n     // allow using type ascription in expressions\n     (\"type_ascription\", \"1.6.0\", Some(23416), Active),\n@@ -435,7 +435,7 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n     (\"must_use\", Whitelisted, Ungated),\n     (\"stable\", Whitelisted, Ungated),\n     (\"unstable\", Whitelisted, Ungated),\n-    (\"deprecated\", Normal, Gated(\"deprecated\", \"`#[deprecated]` attribute is unstable\")),\n+    (\"deprecated\", Normal, Ungated),\n \n     (\"rustc_paren_sugar\", Normal, Gated(\"unboxed_closures\",\n                                         \"unboxed_closures are still evolving\")),"}, {"sha": "ca7e5729c0b7a176dd83ac415e85e2acf08dd07a", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -29,7 +29,6 @@\n #![feature(libc)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n-#![feature(str_char)]\n #![feature(str_escape)]\n #![feature(unicode)]\n #![feature(question_mark)]"}, {"sha": "fcd83b4104130294b1f0a471e487287572031e25", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -2209,12 +2209,14 @@ impl<'a> State<'a> {\n \n                 self.commasep(Inconsistent, &a.outputs,\n                                    |s, out| {\n-                    match out.constraint.slice_shift_char() {\n-                        Some(('=', operand)) if out.is_rw => {\n-                            s.print_string(&format!(\"+{}\", operand),\n+                    let mut ch = out.constraint.chars();\n+                    match ch.next() {\n+                        Some('=') if out.is_rw => {\n+                            s.print_string(&format!(\"+{}\", ch.as_str()),\n                                            ast::StrStyle::Cooked)?\n                         }\n-                        _ => s.print_string(&out.constraint, ast::StrStyle::Cooked)?\n+                        _ => s.print_string(&out.constraint,\n+                                            ast::StrStyle::Cooked)?\n                     }\n                     s.popen()?;\n                     s.print_expr(&out.expr)?;"}, {"sha": "50d2b9d31fe010b396ad1dff085d8307387bf455", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -131,11 +131,12 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                     // It's the opposite of '=&' which means that the memory\n                     // cannot be shared with any other operand (usually when\n                     // a register is clobbered early.)\n-                    let output = match constraint.slice_shift_char() {\n-                        Some(('=', _)) => None,\n-                        Some(('+', operand)) => {\n+                    let mut ch = constraint.chars();\n+                    let output = match ch.next() {\n+                        Some('=') => None,\n+                        Some('+') => {\n                             Some(token::intern_and_get_ident(&format!(\n-                                        \"={}\", operand)))\n+                                        \"={}\", ch.as_str())))\n                         }\n                         _ => {\n                             cx.span_err(span, \"output operand constraint lacks '=' or '+'\");\n@@ -146,7 +147,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                     let is_rw = output.is_some();\n                     let is_indirect = constraint.contains(\"*\");\n                     outputs.push(ast::InlineAsmOutput {\n-                        constraint: output.unwrap_or(constraint),\n+                        constraint: output.unwrap_or(constraint.clone()),\n                         expr: out,\n                         is_rw: is_rw,\n                         is_indirect: is_indirect,"}, {"sha": "8f5362b4d2895c270ca10440b0459d76b9793089", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -21,7 +21,6 @@\n \n #![feature(rustc_private)]\n #![feature(staged_api)]\n-#![feature(str_char)]\n \n extern crate fmt_macros;\n #[macro_use] extern crate log;"}, {"sha": "8170c9fd8f161db0ebf4bceafd079d94576c804c", "filename": "src/test/compile-fail/deprecation-in-staged-api.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Ftest%2Fcompile-fail%2Fdeprecation-in-staged-api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Ftest%2Fcompile-fail%2Fdeprecation-in-staged-api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdeprecation-in-staged-api.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -10,7 +10,7 @@\n \n // #[deprecated] can't be used in staged api\n \n-#![feature(deprecated, staged_api)]\n+#![feature(staged_api)]\n \n #![stable(feature = \"test_feature\", since = \"1.0.0\")]\n "}, {"sha": "5fc8f684a66fe01f678fdc4cb3bde67a7f15a6f3", "filename": "src/test/compile-fail/deprecation-lint.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Ftest%2Fcompile-fail%2Fdeprecation-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Ftest%2Fcompile-fail%2Fdeprecation-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdeprecation-lint.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -10,8 +10,6 @@\n \n // aux-build:deprecation-lint.rs\n \n-#![feature(deprecated)]\n-\n #![deny(deprecated)]\n #![allow(warnings)]\n "}, {"sha": "af2ac79ea80721808bcc49e694f9ba8e6c9f52a0", "filename": "src/test/compile-fail/deprecation-sanity.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Ftest%2Fcompile-fail%2Fdeprecation-sanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Ftest%2Fcompile-fail%2Fdeprecation-sanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdeprecation-sanity.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -10,8 +10,6 @@\n \n // Various checks that deprecation attributes are used correctly\n \n-#![feature(deprecated)]\n-\n mod bogus_attribute_types_1 {\n     #[deprecated(since = \"a\", note = \"a\", reason)] //~ ERROR unknown meta item 'reason'\n     fn f1() { }"}, {"sha": "ece8fa7dc47bb12da8a4ffdbdad81c48a9a513e7", "filename": "src/test/compile-fail/not-panic-safe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -11,10 +11,10 @@\n #![allow(dead_code)]\n #![feature(recover)]\n \n-use std::panic::RecoverSafe;\n+use std::panic::UnwindSafe;\n \n-fn assert<T: RecoverSafe + ?Sized>() {}\n+fn assert<T: UnwindSafe + ?Sized>() {}\n \n fn main() {\n-    assert::<&mut i32>(); //~ ERROR: RecoverSafe` is not satisfied\n+    assert::<&mut i32>(); //~ ERROR: UnwindSafe` is not satisfied\n }"}, {"sha": "cc73cbe15fe5f9f16dfe8aa62b98fc895ac3b2e8", "filename": "src/test/compile-fail/placement-expr-unstable.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Ftest%2Fcompile-fail%2Fplacement-expr-unstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Ftest%2Fcompile-fail%2Fplacement-expr-unstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fplacement-expr-unstable.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -18,9 +18,6 @@ fn main() {\n     use std::boxed::HEAP; //~ ERROR use of unstable library feature\n \n     let _ = HEAP <- { //~ ERROR use of unstable library feature\n-        ::core::raw::Slice { //~ ERROR use of unstable library feature\n-            data: &42, //~ ERROR use of unstable library feature\n-            len: 1 //~ ERROR use of unstable library feature\n-        }\n+        HEAP //~ ERROR use of unstable library feature\n     };\n }"}, {"sha": "b918f79f2d5d6fc71f147d68a8459dc14a393f1b", "filename": "src/test/run-pass/panic-safe.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Ftest%2Frun-pass%2Fpanic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bed32d83fcd1337e962a58fd04fae6b8503e3283/src%2Ftest%2Frun-pass%2Fpanic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpanic-safe.rs?ref=bed32d83fcd1337e962a58fd04fae6b8503e3283", "patch": "@@ -11,14 +11,14 @@\n #![allow(dead_code)]\n #![feature(recover)]\n \n-use std::panic::{RecoverSafe, AssertRecoverSafe};\n+use std::panic::{UnwindSafe, AssertUnwindSafe};\n use std::cell::RefCell;\n use std::sync::{Mutex, RwLock, Arc};\n use std::rc::Rc;\n \n struct Foo { a: i32 }\n \n-fn assert<T: RecoverSafe + ?Sized>() {}\n+fn assert<T: UnwindSafe + ?Sized>() {}\n \n fn main() {\n     assert::<i32>();\n@@ -43,13 +43,13 @@ fn main() {\n         assert::<Mutex<T>>();\n         assert::<RwLock<T>>();\n     }\n-    fn baz<T: RecoverSafe>() {\n+    fn baz<T: UnwindSafe>() {\n         assert::<Box<T>>();\n         assert::<Vec<T>>();\n         assert::<RefCell<T>>();\n-        assert::<AssertRecoverSafe<T>>();\n-        assert::<&AssertRecoverSafe<T>>();\n-        assert::<Rc<AssertRecoverSafe<T>>>();\n-        assert::<Arc<AssertRecoverSafe<T>>>();\n+        assert::<AssertUnwindSafe<T>>();\n+        assert::<&AssertUnwindSafe<T>>();\n+        assert::<Rc<AssertUnwindSafe<T>>>();\n+        assert::<Arc<AssertUnwindSafe<T>>>();\n     }\n }"}]}