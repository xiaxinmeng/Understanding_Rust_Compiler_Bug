{"sha": "5e3f1b148db5bfa27fee52464ae1f5d34c49d77b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlM2YxYjE0OGRiNWJmYTI3ZmVlNTI0NjRhZTFmNWQzNGM0OWQ3N2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-13T19:26:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-13T19:26:35Z"}, "message": "Auto merge of #75382 - JulianKnodt:match_branches, r=oli-obk\n\nFirst iteration of simplify match branches\n\nThis is a simple MIR pass that attempts to convert\n```\n   bb0: {\n        StorageLive(_2);\n        _3 = discriminant(_1);\n        switchInt(move _3) -> [0isize: bb2, otherwise: bb1];\n    }\n\n    bb1: {\n        _2 = const false;\n        goto -> bb3;\n    }\n\n    bb2: {\n        _2 = const true;\n        goto -> bb3;\n    }\n```\ninto\n```\n    bb0: {\n        StorageLive(_2);\n        _3 = discriminant(_1);\n        _2 = _3 == 0;\n        goto -> bb3;\n    }\n```\nThere are still missing components(like checking if the assignments are bools).\nWas hoping that this could get some review though.\n\nHandles #75141\n\nr? @oli-obk", "tree": {"sha": "14f760bd76b3ed28ad68f4b34adf8a2f2ee7398c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14f760bd76b3ed28ad68f4b34adf8a2f2ee7398c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e3f1b148db5bfa27fee52464ae1f5d34c49d77b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e3f1b148db5bfa27fee52464ae1f5d34c49d77b", "html_url": "https://github.com/rust-lang/rust/commit/5e3f1b148db5bfa27fee52464ae1f5d34c49d77b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e3f1b148db5bfa27fee52464ae1f5d34c49d77b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6396b75e782954acb085447fb836c4e0ff5281d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6396b75e782954acb085447fb836c4e0ff5281d", "html_url": "https://github.com/rust-lang/rust/commit/b6396b75e782954acb085447fb836c4e0ff5281d"}, {"sha": "46e5699af97301fc89dadfa5633d6db814df3cc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/46e5699af97301fc89dadfa5633d6db814df3cc6", "html_url": "https://github.com/rust-lang/rust/commit/46e5699af97301fc89dadfa5633d6db814df3cc6"}], "stats": {"total": 240, "additions": 240, "deletions": 0}, "files": [{"sha": "74da6d5e629b3c0971c83dcf78320fc70a8c9c60", "filename": "src/librustc_mir/transform/match_branches.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/5e3f1b148db5bfa27fee52464ae1f5d34c49d77b/src%2Flibrustc_mir%2Ftransform%2Fmatch_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3f1b148db5bfa27fee52464ae1f5d34c49d77b/src%2Flibrustc_mir%2Ftransform%2Fmatch_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmatch_branches.rs?ref=5e3f1b148db5bfa27fee52464ae1f5d34c49d77b", "patch": "@@ -0,0 +1,93 @@\n+use crate::transform::{MirPass, MirSource};\n+use rustc_middle::mir::*;\n+use rustc_middle::ty::TyCtxt;\n+\n+pub struct MatchBranchSimplification;\n+\n+// What's the intent of this pass?\n+// If one block is found that switches between blocks which both go to the same place\n+// AND both of these blocks set a similar const in their ->\n+// condense into 1 block based on discriminant AND goto the destination afterwards\n+\n+impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+        let param_env = tcx.param_env(src.def_id());\n+        let bbs = body.basic_blocks_mut();\n+        'outer: for bb_idx in bbs.indices() {\n+            let (discr, val, switch_ty, first, second) = match bbs[bb_idx].terminator().kind {\n+                TerminatorKind::SwitchInt {\n+                    discr: Operand::Move(ref place),\n+                    switch_ty,\n+                    ref targets,\n+                    ref values,\n+                    ..\n+                } if targets.len() == 2 && values.len() == 1 => {\n+                    (place, values[0], switch_ty, targets[0], targets[1])\n+                }\n+                // Only optimize switch int statements\n+                _ => continue,\n+            };\n+\n+            // Check that destinations are identical, and if not, then don't optimize this block\n+            if &bbs[first].terminator().kind != &bbs[second].terminator().kind {\n+                continue;\n+            }\n+\n+            // Check that blocks are assignments of consts to the same place or same statement,\n+            // and match up 1-1, if not don't optimize this block.\n+            let first_stmts = &bbs[first].statements;\n+            let scnd_stmts = &bbs[second].statements;\n+            if first_stmts.len() != scnd_stmts.len() {\n+                continue;\n+            }\n+            for (f, s) in first_stmts.iter().zip(scnd_stmts.iter()) {\n+                match (&f.kind, &s.kind) {\n+                    // If two statements are exactly the same just ignore them.\n+                    (f_s, s_s) if f_s == s_s => (),\n+\n+                    (\n+                        StatementKind::Assign(box (lhs_f, Rvalue::Use(Operand::Constant(f_c)))),\n+                        StatementKind::Assign(box (lhs_s, Rvalue::Use(Operand::Constant(s_c)))),\n+                    ) if lhs_f == lhs_s => {\n+                        if let Some(f_c) = f_c.literal.try_eval_bool(tcx, param_env) {\n+                            // This should also be a bool because it's writing to the same place\n+                            let s_c = s_c.literal.try_eval_bool(tcx, param_env).unwrap();\n+                            if f_c != s_c {\n+                                // have to check this here because f_c & s_c might have\n+                                // different spans.\n+                                continue;\n+                            }\n+                        }\n+                        continue 'outer;\n+                    }\n+                    // If there are not exclusively assignments, then ignore this\n+                    _ => continue 'outer,\n+                }\n+            }\n+            // Take owenership of items now that we know we can optimize.\n+            let discr = discr.clone();\n+            let (from, first) = bbs.pick2_mut(bb_idx, first);\n+\n+            let new_stmts = first.statements.iter().cloned().map(|mut s| {\n+                if let StatementKind::Assign(box (_, ref mut rhs)) = s.kind {\n+                    if let Rvalue::Use(Operand::Constant(c)) = rhs {\n+                        let size = tcx.layout_of(param_env.and(switch_ty)).unwrap().size;\n+                        let const_cmp = Operand::const_from_scalar(\n+                            tcx,\n+                            switch_ty,\n+                            crate::interpret::Scalar::from_uint(val, size),\n+                            rustc_span::DUMMY_SP,\n+                        );\n+                        if let Some(c) = c.literal.try_eval_bool(tcx, param_env) {\n+                            let op = if c { BinOp::Eq } else { BinOp::Ne };\n+                            *rhs = Rvalue::BinaryOp(op, Operand::Move(discr), const_cmp);\n+                        }\n+                    }\n+                }\n+                s\n+            });\n+            from.statements.extend(new_stmts);\n+            from.terminator_mut().kind = first.terminator().kind.clone();\n+        }\n+    }\n+}"}, {"sha": "4f26f3bb45973b178c36fc8821c9bc24025221b8", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e3f1b148db5bfa27fee52464ae1f5d34c49d77b/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3f1b148db5bfa27fee52464ae1f5d34c49d77b/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=5e3f1b148db5bfa27fee52464ae1f5d34c49d77b", "patch": "@@ -29,6 +29,7 @@ pub mod generator;\n pub mod inline;\n pub mod instcombine;\n pub mod instrument_coverage;\n+pub mod match_branches;\n pub mod no_landing_pads;\n pub mod nrvo;\n pub mod promote_consts;\n@@ -440,6 +441,7 @@ fn run_optimization_passes<'tcx>(\n         // with async primitives.\n         &generator::StateTransform,\n         &instcombine::InstCombine,\n+        &match_branches::MatchBranchSimplification,\n         &const_prop::ConstProp,\n         &simplify_branches::SimplifyBranches::new(\"after-const-prop\"),\n         &simplify_try::SimplifyArmIdentity,"}, {"sha": "df94c897e92f870b526f2a1f434dcde6546ce68d", "filename": "src/test/mir-opt/matches_reduce_branches.foo.MatchBranchSimplification.diff.32bit", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/5e3f1b148db5bfa27fee52464ae1f5d34c49d77b/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.foo.MatchBranchSimplification.diff.32bit", "raw_url": "https://github.com/rust-lang/rust/raw/5e3f1b148db5bfa27fee52464ae1f5d34c49d77b/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.foo.MatchBranchSimplification.diff.32bit", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.foo.MatchBranchSimplification.diff.32bit?ref=5e3f1b148db5bfa27fee52464ae1f5d34c49d77b", "patch": "@@ -0,0 +1,66 @@\n+- // MIR for `foo` before MatchBranchSimplification\n++ // MIR for `foo` after MatchBranchSimplification\n+  \n+  fn foo(_1: std::option::Option<()>) -> () {\n+      debug bar => _1;                     // in scope 0 at $DIR/matches_reduce_branches.rs:4:8: 4:11\n+      let mut _0: ();                      // return place in scope 0 at $DIR/matches_reduce_branches.rs:4:25: 4:25\n+      let mut _2: bool;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _3: isize;                   // in scope 0 at $DIR/matches_reduce_branches.rs:5:22: 5:26\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _3 = discriminant(_1);           // scope 0 at $DIR/matches_reduce_branches.rs:5:22: 5:26\n+-         switchInt(move _3) -> [0_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/matches_reduce_branches.rs:5:22: 5:26\n++         _2 = Eq(move _3, const 0_isize); // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n++                                          // ty::Const\n++                                          // + ty: isize\n++                                          // + val: Value(Scalar(0x00000000))\n++                                          // mir::Constant\n++                                          // + span: $DIR/matches_reduce_branches.rs:1:1: 1:1\n++                                          // + literal: Const { ty: isize, val: Value(Scalar(0x00000000)) }\n++         goto -> bb3;                     // scope 0 at $DIR/matches_reduce_branches.rs:5:22: 5:26\n+      }\n+  \n+      bb1: {\n+          _2 = const false;                // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                                           // ty::Const\n+                                           // + ty: bool\n+                                           // + val: Value(Scalar(0x00))\n+                                           // mir::Constant\n+                                           // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                                           // + literal: Const { ty: bool, val: Value(Scalar(0x00)) }\n+          goto -> bb3;                     // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      }\n+  \n+      bb2: {\n+          _2 = const true;                 // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                                           // ty::Const\n+                                           // + ty: bool\n+                                           // + val: Value(Scalar(0x01))\n+                                           // mir::Constant\n+                                           // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                                           // + literal: Const { ty: bool, val: Value(Scalar(0x01)) }\n+          goto -> bb3;                     // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      }\n+  \n+      bb3: {\n+          switchInt(_2) -> [false: bb4, otherwise: bb5]; // scope 0 at $DIR/matches_reduce_branches.rs:5:5: 7:6\n+      }\n+  \n+      bb4: {\n+          _0 = const ();                   // scope 0 at $DIR/matches_reduce_branches.rs:5:5: 7:6\n+                                           // ty::Const\n+                                           // + ty: ()\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/matches_reduce_branches.rs:5:5: 7:6\n+                                           // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n+          goto -> bb5;                     // scope 0 at $DIR/matches_reduce_branches.rs:5:5: 7:6\n+      }\n+  \n+      bb5: {\n+          StorageDead(_2);                 // scope 0 at $DIR/matches_reduce_branches.rs:8:1: 8:2\n+          return;                          // scope 0 at $DIR/matches_reduce_branches.rs:8:2: 8:2\n+      }\n+  }\n+  "}, {"sha": "06849b4a5d98347be2f15c2f1c50481ce38b5be6", "filename": "src/test/mir-opt/matches_reduce_branches.foo.MatchBranchSimplification.diff.64bit", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/5e3f1b148db5bfa27fee52464ae1f5d34c49d77b/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.foo.MatchBranchSimplification.diff.64bit", "raw_url": "https://github.com/rust-lang/rust/raw/5e3f1b148db5bfa27fee52464ae1f5d34c49d77b/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.foo.MatchBranchSimplification.diff.64bit", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.foo.MatchBranchSimplification.diff.64bit?ref=5e3f1b148db5bfa27fee52464ae1f5d34c49d77b", "patch": "@@ -0,0 +1,66 @@\n+- // MIR for `foo` before MatchBranchSimplification\n++ // MIR for `foo` after MatchBranchSimplification\n+  \n+  fn foo(_1: std::option::Option<()>) -> () {\n+      debug bar => _1;                     // in scope 0 at $DIR/matches_reduce_branches.rs:4:8: 4:11\n+      let mut _0: ();                      // return place in scope 0 at $DIR/matches_reduce_branches.rs:4:25: 4:25\n+      let mut _2: bool;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _3: isize;                   // in scope 0 at $DIR/matches_reduce_branches.rs:5:22: 5:26\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _3 = discriminant(_1);           // scope 0 at $DIR/matches_reduce_branches.rs:5:22: 5:26\n+-         switchInt(move _3) -> [0_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/matches_reduce_branches.rs:5:22: 5:26\n++         _2 = Eq(move _3, const 0_isize); // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n++                                          // ty::Const\n++                                          // + ty: isize\n++                                          // + val: Value(Scalar(0x0000000000000000))\n++                                          // mir::Constant\n++                                          // + span: $DIR/matches_reduce_branches.rs:1:1: 1:1\n++                                          // + literal: Const { ty: isize, val: Value(Scalar(0x0000000000000000)) }\n++         goto -> bb3;                     // scope 0 at $DIR/matches_reduce_branches.rs:5:22: 5:26\n+      }\n+  \n+      bb1: {\n+          _2 = const false;                // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                                           // ty::Const\n+                                           // + ty: bool\n+                                           // + val: Value(Scalar(0x00))\n+                                           // mir::Constant\n+                                           // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                                           // + literal: Const { ty: bool, val: Value(Scalar(0x00)) }\n+          goto -> bb3;                     // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      }\n+  \n+      bb2: {\n+          _2 = const true;                 // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                                           // ty::Const\n+                                           // + ty: bool\n+                                           // + val: Value(Scalar(0x01))\n+                                           // mir::Constant\n+                                           // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                                           // + literal: Const { ty: bool, val: Value(Scalar(0x01)) }\n+          goto -> bb3;                     // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      }\n+  \n+      bb3: {\n+          switchInt(_2) -> [false: bb4, otherwise: bb5]; // scope 0 at $DIR/matches_reduce_branches.rs:5:5: 7:6\n+      }\n+  \n+      bb4: {\n+          _0 = const ();                   // scope 0 at $DIR/matches_reduce_branches.rs:5:5: 7:6\n+                                           // ty::Const\n+                                           // + ty: ()\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/matches_reduce_branches.rs:5:5: 7:6\n+                                           // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n+          goto -> bb5;                     // scope 0 at $DIR/matches_reduce_branches.rs:5:5: 7:6\n+      }\n+  \n+      bb5: {\n+          StorageDead(_2);                 // scope 0 at $DIR/matches_reduce_branches.rs:8:1: 8:2\n+          return;                          // scope 0 at $DIR/matches_reduce_branches.rs:8:2: 8:2\n+      }\n+  }\n+  "}, {"sha": "91b6bfc836bd49dafc88c03708df7a070e14675e", "filename": "src/test/mir-opt/matches_reduce_branches.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5e3f1b148db5bfa27fee52464ae1f5d34c49d77b/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3f1b148db5bfa27fee52464ae1f5d34c49d77b/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.rs?ref=5e3f1b148db5bfa27fee52464ae1f5d34c49d77b", "patch": "@@ -0,0 +1,13 @@\n+// EMIT_MIR_FOR_EACH_BIT_WIDTH\n+// EMIT_MIR matches_reduce_branches.foo.MatchBranchSimplification.diff\n+\n+fn foo(bar: Option<()>) {\n+    if matches!(bar, None) {\n+      ()\n+    }\n+}\n+\n+fn main() {\n+  let _ = foo(None);\n+  let _ = foo(Some(()));\n+}"}]}