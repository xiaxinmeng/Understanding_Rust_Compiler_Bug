{"sha": "68a09fc5398a54538559bd46c38a5372d0ed6091", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4YTA5ZmM1Mzk4YTU0NTM4NTU5YmQ0NmMzOGE1MzcyZDBlZDYwOTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-28T17:59:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-28T17:59:25Z"}, "message": "Auto merge of #50164 - nox:rval-range-metadata, r=eddyb\n\nEmit range metadata on calls returning scalars (fixes #50157)", "tree": {"sha": "4a214af9d938caff61511f5386650175aceb36d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a214af9d938caff61511f5386650175aceb36d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68a09fc5398a54538559bd46c38a5372d0ed6091", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68a09fc5398a54538559bd46c38a5372d0ed6091", "html_url": "https://github.com/rust-lang/rust/commit/68a09fc5398a54538559bd46c38a5372d0ed6091", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68a09fc5398a54538559bd46c38a5372d0ed6091/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e01e22509df395fb42885235d694909b4309398", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e01e22509df395fb42885235d694909b4309398", "html_url": "https://github.com/rust-lang/rust/commit/1e01e22509df395fb42885235d694909b4309398"}, {"sha": "90656441a9dfbc42b6f5f1f25abeead66012bb00", "url": "https://api.github.com/repos/rust-lang/rust/commits/90656441a9dfbc42b6f5f1f25abeead66012bb00", "html_url": "https://github.com/rust-lang/rust/commit/90656441a9dfbc42b6f5f1f25abeead66012bb00"}], "stats": {"total": 99, "additions": 78, "deletions": 21}, "files": [{"sha": "346e5667a7babbd3613d320c51e5009c62cbb77f", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/68a09fc5398a54538559bd46c38a5372d0ed6091/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a09fc5398a54538559bd46c38a5372d0ed6091/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=68a09fc5398a54538559bd46c38a5372d0ed6091", "patch": "@@ -14,7 +14,7 @@ pub use self::Primitive::*;\n use spec::Target;\n \n use std::cmp;\n-use std::ops::{Add, Deref, Sub, Mul, AddAssign, RangeInclusive};\n+use std::ops::{Add, Deref, Sub, Mul, AddAssign, Range, RangeInclusive};\n \n pub mod call;\n \n@@ -544,6 +544,23 @@ impl Scalar {\n             false\n         }\n     }\n+\n+    /// Returns the valid range as a `x..y` range.\n+    ///\n+    /// If `x` and `y` are equal, the range is full, not empty.\n+    pub fn valid_range_exclusive<C: HasDataLayout>(&self, cx: C) -> Range<u128> {\n+        // For a (max) value of -1, max will be `-1 as usize`, which overflows.\n+        // However, that is fine here (it would still represent the full range),\n+        // i.e., if the range is everything.\n+        let bits = self.value.size(cx).bits();\n+        assert!(bits <= 128);\n+        let mask = !0u128 >> (128 - bits);\n+        let start = self.valid_range.start;\n+        let end = self.valid_range.end;\n+        assert_eq!(start, start & mask);\n+        assert_eq!(end, end & mask);\n+        start..(end.wrapping_add(1) & mask)\n+    }\n }\n \n /// Describes how the fields of a type are located in memory."}, {"sha": "927d5c7e15a20c5f30684311fbd24450411977a2", "filename": "src/librustc_target/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/68a09fc5398a54538559bd46c38a5372d0ed6091/src%2Flibrustc_target%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a09fc5398a54538559bd46c38a5372d0ed6091/src%2Flibrustc_target%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Flib.rs?ref=68a09fc5398a54538559bd46c38a5372d0ed6091", "patch": "@@ -29,6 +29,7 @@\n #![feature(const_fn)]\n #![feature(fs_read_write)]\n #![feature(inclusive_range)]\n+#![feature(inclusive_range_fields)]\n #![feature(slice_patterns)]\n \n #[macro_use]"}, {"sha": "1d0d7ec601f1f96a9ad9fc12db4f2c14f6b7d481", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/68a09fc5398a54538559bd46c38a5372d0ed6091/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a09fc5398a54538559bd46c38a5372d0ed6091/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=68a09fc5398a54538559bd46c38a5372d0ed6091", "patch": "@@ -265,7 +265,7 @@ pub trait FnTypeExt<'a, 'tcx> {\n     fn llvm_type(&self, cx: &CodegenCx<'a, 'tcx>) -> Type;\n     fn llvm_cconv(&self) -> llvm::CallConv;\n     fn apply_attrs_llfn(&self, llfn: ValueRef);\n-    fn apply_attrs_callsite(&self, callsite: ValueRef);\n+    fn apply_attrs_callsite(&self, bx: &Builder<'a, 'tcx>, callsite: ValueRef);\n }\n \n impl<'a, 'tcx> FnTypeExt<'a, 'tcx> for FnType<'tcx, Ty<'tcx>> {\n@@ -640,7 +640,7 @@ impl<'a, 'tcx> FnTypeExt<'a, 'tcx> for FnType<'tcx, Ty<'tcx>> {\n         }\n     }\n \n-    fn apply_attrs_callsite(&self, callsite: ValueRef) {\n+    fn apply_attrs_callsite(&self, bx: &Builder<'a, 'tcx>, callsite: ValueRef) {\n         let mut i = 0;\n         let mut apply = |attrs: &ArgAttributes| {\n             attrs.apply_callsite(llvm::AttributePlace::Argument(i), callsite);\n@@ -653,6 +653,24 @@ impl<'a, 'tcx> FnTypeExt<'a, 'tcx> for FnType<'tcx, Ty<'tcx>> {\n             PassMode::Indirect(ref attrs) => apply(attrs),\n             _ => {}\n         }\n+        if let layout::Abi::Scalar(ref scalar) = self.ret.layout.abi {\n+            // If the value is a boolean, the range is 0..2 and that ultimately\n+            // become 0..0 when the type becomes i1, which would be rejected\n+            // by the LLVM verifier.\n+            match scalar.value {\n+                layout::Int(..) if !scalar.is_bool() => {\n+                    let range = scalar.valid_range_exclusive(bx.cx);\n+                    if range.start != range.end {\n+                        // FIXME(nox): This causes very weird type errors about\n+                        // SHL operators in constants in stage 2 with LLVM 3.9.\n+                        if unsafe { llvm::LLVMRustVersionMajor() >= 4 } {\n+                            bx.range_metadata(callsite, range);\n+                        }\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n         for arg in &self.args {\n             if arg.pad.is_some() {\n                 apply(&ArgAttributes::new());"}, {"sha": "96a10e8b99d32272c48fa189fa0bc207becc2f8f", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/68a09fc5398a54538559bd46c38a5372d0ed6091/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a09fc5398a54538559bd46c38a5372d0ed6091/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=68a09fc5398a54538559bd46c38a5372d0ed6091", "patch": "@@ -25,6 +25,7 @@\n #![allow(unused_attributes)]\n #![feature(libc)]\n #![feature(quote)]\n+#![feature(range_contains)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_sort_by_cached_key)]\n #![feature(optin_builtin_traits)]"}, {"sha": "e5fdc26eeaf0d335ae8bb860b9b587ae2cf76001", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68a09fc5398a54538559bd46c38a5372d0ed6091/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a09fc5398a54538559bd46c38a5372d0ed6091/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=68a09fc5398a54538559bd46c38a5372d0ed6091", "patch": "@@ -127,7 +127,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                                            ret_bx,\n                                            llblock(this, cleanup),\n                                            cleanup_bundle);\n-                fn_ty.apply_attrs_callsite(invokeret);\n+                fn_ty.apply_attrs_callsite(&bx, invokeret);\n \n                 if let Some((ret_dest, target)) = destination {\n                     let ret_bx = this.build_block(target);\n@@ -136,7 +136,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                 }\n             } else {\n                 let llret = bx.call(fn_ptr, &llargs, cleanup_bundle);\n-                fn_ty.apply_attrs_callsite(llret);\n+                fn_ty.apply_attrs_callsite(&bx, llret);\n                 if this.mir[bb].is_cleanup {\n                     // Cleanup is always the cold path. Don't inline\n                     // drop glue. Also, when there is a deeply-nested"}, {"sha": "8532c0b149dedcb67fdf4745d527161821b54547", "filename": "src/librustc_trans/mir/place.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/68a09fc5398a54538559bd46c38a5372d0ed6091/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a09fc5398a54538559bd46c38a5372d0ed6091/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fplace.rs?ref=68a09fc5398a54538559bd46c38a5372d0ed6091", "patch": "@@ -91,24 +91,15 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n         }\n \n         let scalar_load_metadata = |load, scalar: &layout::Scalar| {\n-            let (min, max) = (scalar.valid_range.start, scalar.valid_range.end);\n-            let max_next = max.wrapping_add(1);\n-            let bits = scalar.value.size(bx.cx).bits();\n-            assert!(bits <= 128);\n-            let mask = !0u128 >> (128 - bits);\n-            // For a (max) value of -1, max will be `-1 as usize`, which overflows.\n-            // However, that is fine here (it would still represent the full range),\n-            // i.e., if the range is everything.  The lo==hi case would be\n-            // rejected by the LLVM verifier (it would mean either an\n-            // empty set, which is impossible, or the entire range of the\n-            // type, which is pointless).\n+            let vr = scalar.valid_range.clone();\n             match scalar.value {\n-                layout::Int(..) if max_next & mask != min & mask => {\n-                    // llvm::ConstantRange can deal with ranges that wrap around,\n-                    // so an overflow on (max + 1) is fine.\n-                    bx.range_metadata(load, min..max_next);\n+                layout::Int(..) => {\n+                    let range = scalar.valid_range_exclusive(bx.cx);\n+                    if range.start != range.end {\n+                        bx.range_metadata(load, range);\n+                    }\n                 }\n-                layout::Pointer if 0 < min && min < max => {\n+                layout::Pointer if vr.start < vr.end && !vr.contains(&0) => {\n                     bx.nonnull_metadata(load);\n                 }\n                 _ => {}"}, {"sha": "20d42ed852dfed745d79c177eb629e07d49e5649", "filename": "src/test/codegen/call-metadata.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/68a09fc5398a54538559bd46c38a5372d0ed6091/src%2Ftest%2Fcodegen%2Fcall-metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a09fc5398a54538559bd46c38a5372d0ed6091/src%2Ftest%2Fcodegen%2Fcall-metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcall-metadata.rs?ref=68a09fc5398a54538559bd46c38a5372d0ed6091", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Checks that range metadata gets emitted on calls to functions returning a\n+// scalar value.\n+\n+// compile-flags: -C no-prepopulate-passes\n+// min-llvm-version 4.0\n+\n+\n+#![crate_type = \"lib\"]\n+\n+pub fn test() {\n+    // CHECK: call i8 @some_true(), !range [[R0:![0-9]+]]\n+    // CHECK: [[R0]] = !{i8 0, i8 3}\n+    some_true();\n+}\n+\n+#[no_mangle]\n+fn some_true() -> Option<bool> {\n+    Some(true)\n+}"}]}