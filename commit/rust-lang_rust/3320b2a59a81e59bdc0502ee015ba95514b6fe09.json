{"sha": "3320b2a59a81e59bdc0502ee015ba95514b6fe09", "node_id": "C_kwDOAAsO6NoAKDMzMjBiMmE1OWE4MWU1OWJkYzA1MDJlZTAxNWJhOTU1MTRiNmZlMDk", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-04-19T04:35:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-04-19T04:35:34Z"}, "message": "Rollup merge of #110432 - compiler-errors:unsatisfied-index-impl, r=cjgillot\n\nReport more detailed reason why `Index` impl is not satisfied\n\nFixes #110373", "tree": {"sha": "102bda7043632bf29b16070c58de4641350e76b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/102bda7043632bf29b16070c58de4641350e76b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3320b2a59a81e59bdc0502ee015ba95514b6fe09", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkP2+WCRBK7hj4Ov3rIwAAWxAIAB3eCTuDAZOVaOcSq49KqbpM\n9sAl8j9dXSe5wl5SK4Oho9enz6n/ljGUpa18ZWimvzuMAWhUk4weIZEeUKqv31Fe\ne/4UtCxvl6h9PJLVqHOxNCdiSBFzyOaiSfwsc97v3C6PhviRQFBJSo4YOgdcSOH2\nifQKlONWxZsgiXhqw8Cx1B5yWkfXJjXlYO2dCxrlQd4euT9NNTbz1HTBRzijLxh5\nH7HGEz6QFAP2x0hVXQ2sLc8a659H6q+6K8UcZc471yZkGl2ppaVld9y3wU4G7EG6\nBZ+N9uJfHXzsA7+OhH4g3uVKpA/cAboR0Hw6X6CWj68q6GsSzqaCDVCHENcZ8yY=\n=LLb1\n-----END PGP SIGNATURE-----\n", "payload": "tree 102bda7043632bf29b16070c58de4641350e76b8\nparent da481403e7e3c91878ef8fe3099c04dbb862a145\nparent 8d75a8f699c921724b1e01ce932de77d08533957\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1681878934 +0200\ncommitter GitHub <noreply@github.com> 1681878934 +0200\n\nRollup merge of #110432 - compiler-errors:unsatisfied-index-impl, r=cjgillot\n\nReport more detailed reason why `Index` impl is not satisfied\n\nFixes #110373\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3320b2a59a81e59bdc0502ee015ba95514b6fe09", "html_url": "https://github.com/rust-lang/rust/commit/3320b2a59a81e59bdc0502ee015ba95514b6fe09", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3320b2a59a81e59bdc0502ee015ba95514b6fe09/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da481403e7e3c91878ef8fe3099c04dbb862a145", "url": "https://api.github.com/repos/rust-lang/rust/commits/da481403e7e3c91878ef8fe3099c04dbb862a145", "html_url": "https://github.com/rust-lang/rust/commit/da481403e7e3c91878ef8fe3099c04dbb862a145"}, {"sha": "8d75a8f699c921724b1e01ce932de77d08533957", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d75a8f699c921724b1e01ce932de77d08533957", "html_url": "https://github.com/rust-lang/rust/commit/8d75a8f699c921724b1e01ce932de77d08533957"}], "stats": {"total": 183, "additions": 183, "deletions": 0}, "files": [{"sha": "0c0a7515d9c3bfb0a20bf076356b0dd409a33262", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/3320b2a59a81e59bdc0502ee015ba95514b6fe09/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3320b2a59a81e59bdc0502ee015ba95514b6fe09/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=3320b2a59a81e59bdc0502ee015ba95514b6fe09", "patch": "@@ -38,6 +38,7 @@ use rustc_infer::infer;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::DefineOpaqueTypes;\n use rustc_infer::infer::InferOk;\n+use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::ObligationCause;\n use rustc_middle::middle::stability;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase};\n@@ -53,6 +54,8 @@ use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_target::abi::FieldIdx;\n use rustc_target::spec::abi::Abi::RustIntrinsic;\n use rustc_trait_selection::infer::InferCtxtExt;\n+use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n+use rustc_trait_selection::traits::ObligationCtxt;\n use rustc_trait_selection::traits::{self, ObligationCauseCode};\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -2800,6 +2803,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     element_ty\n                 }\n                 None => {\n+                    // Attempt to *shallowly* search for an impl which matches,\n+                    // but has nested obligations which are unsatisfied.\n+                    for (base_t, _) in self.autoderef(base.span, base_t).silence_errors() {\n+                        if let Some((_, index_ty, element_ty)) =\n+                            self.find_and_report_unsatisfied_index_impl(expr.hir_id, base, base_t)\n+                        {\n+                            self.demand_coerce(idx, idx_t, index_ty, None, AllowTwoPhase::No);\n+                            return element_ty;\n+                        }\n+                    }\n+\n                     let mut err = type_error_struct!(\n                         self.tcx.sess,\n                         expr.span,\n@@ -2843,6 +2857,82 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    /// Try to match an implementation of `Index` against a self type, and report\n+    /// the unsatisfied predicates that result from confirming this impl.\n+    ///\n+    /// Given an index expression, sometimes the `Self` type shallowly but does not\n+    /// deeply satisfy an impl predicate. Instead of simply saying that the type\n+    /// does not support being indexed, we want to point out exactly what nested\n+    /// predicates cause this to be, so that the user can add them to fix their code.\n+    fn find_and_report_unsatisfied_index_impl(\n+        &self,\n+        index_expr_hir_id: HirId,\n+        base_expr: &hir::Expr<'_>,\n+        base_ty: Ty<'tcx>,\n+    ) -> Option<(ErrorGuaranteed, Ty<'tcx>, Ty<'tcx>)> {\n+        let index_trait_def_id = self.tcx.lang_items().index_trait()?;\n+        let index_trait_output_def_id = self.tcx.get_diagnostic_item(sym::IndexOutput)?;\n+\n+        let mut relevant_impls = vec![];\n+        self.tcx.for_each_relevant_impl(index_trait_def_id, base_ty, |impl_def_id| {\n+            relevant_impls.push(impl_def_id);\n+        });\n+        let [impl_def_id] = relevant_impls[..] else {\n+            // Only report unsatisfied impl predicates if there's one impl\n+            return None;\n+        };\n+\n+        self.commit_if_ok(|_| {\n+            let ocx = ObligationCtxt::new_in_snapshot(self);\n+            let impl_substs = self.fresh_substs_for_item(base_expr.span, impl_def_id);\n+            let impl_trait_ref =\n+                self.tcx.impl_trait_ref(impl_def_id).unwrap().subst(self.tcx, impl_substs);\n+            let cause = self.misc(base_expr.span);\n+\n+            // Match the impl self type against the base ty. If this fails,\n+            // we just skip this impl, since it's not particularly useful.\n+            let impl_trait_ref = ocx.normalize(&cause, self.param_env, impl_trait_ref);\n+            ocx.eq(&cause, self.param_env, impl_trait_ref.self_ty(), base_ty)?;\n+\n+            // Register the impl's predicates. One of these predicates\n+            // must be unsatisfied, or else we wouldn't have gotten here\n+            // in the first place.\n+            ocx.register_obligations(traits::predicates_for_generics(\n+                |idx, span| {\n+                    traits::ObligationCause::new(\n+                        base_expr.span,\n+                        self.body_id,\n+                        if span.is_dummy() {\n+                            traits::ExprItemObligation(impl_def_id, index_expr_hir_id, idx)\n+                        } else {\n+                            traits::ExprBindingObligation(impl_def_id, span, index_expr_hir_id, idx)\n+                        },\n+                    )\n+                },\n+                self.param_env,\n+                self.tcx.predicates_of(impl_def_id).instantiate(self.tcx, impl_substs),\n+            ));\n+\n+            // Normalize the output type, which we can use later on as the\n+            // return type of the index expression...\n+            let element_ty = ocx.normalize(\n+                &cause,\n+                self.param_env,\n+                self.tcx.mk_projection(index_trait_output_def_id, impl_trait_ref.substs),\n+            );\n+\n+            let errors = ocx.select_where_possible();\n+            // There should be at least one error reported. If not, we\n+            // will still delay a span bug in `report_fulfillment_errors`.\n+            Ok::<_, NoSolution>((\n+                self.err_ctxt().report_fulfillment_errors(&errors),\n+                impl_trait_ref.substs.type_at(1),\n+                element_ty,\n+            ))\n+        })\n+        .ok()\n+    }\n+\n     fn point_at_index_if_possible(\n         &self,\n         errors: &mut Vec<traits::FulfillmentError<'tcx>>,"}, {"sha": "d6ee7ac34aaca594650508f57f810e63ff6725bc", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3320b2a59a81e59bdc0502ee015ba95514b6fe09/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3320b2a59a81e59bdc0502ee015ba95514b6fe09/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=3320b2a59a81e59bdc0502ee015ba95514b6fe09", "patch": "@@ -204,6 +204,7 @@ symbols! {\n         HashSet,\n         Hasher,\n         Implied,\n+        IndexOutput,\n         Input,\n         Into,\n         IntoDiagnostic,"}, {"sha": "f3754484f6a0609e53a6aedad5a0351e40e38ec9", "filename": "library/core/src/ops/index.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3320b2a59a81e59bdc0502ee015ba95514b6fe09/library%2Fcore%2Fsrc%2Fops%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3320b2a59a81e59bdc0502ee015ba95514b6fe09/library%2Fcore%2Fsrc%2Fops%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Findex.rs?ref=3320b2a59a81e59bdc0502ee015ba95514b6fe09", "patch": "@@ -59,6 +59,7 @@\n pub trait Index<Idx: ?Sized> {\n     /// The returned type after indexing.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_diagnostic_item = \"IndexOutput\"]\n     type Output: ?Sized;\n \n     /// Performs the indexing (`container[index]`) operation."}, {"sha": "2564b530004e5f61e3b6b0fad4c5641c2d94e600", "filename": "tests/ui/typeck/bad-index-due-to-nested.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3320b2a59a81e59bdc0502ee015ba95514b6fe09/tests%2Fui%2Ftypeck%2Fbad-index-due-to-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3320b2a59a81e59bdc0502ee015ba95514b6fe09/tests%2Fui%2Ftypeck%2Fbad-index-due-to-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fbad-index-due-to-nested.rs?ref=3320b2a59a81e59bdc0502ee015ba95514b6fe09", "patch": "@@ -0,0 +1,27 @@\n+use std::hash::Hash;\n+use std::marker::PhantomData;\n+use std::ops::Index;\n+\n+struct HashMap<K, V>(PhantomData<(K, V)>);\n+\n+impl<K, V> Index<&K> for HashMap<K, V>\n+where\n+    K: Hash,\n+    V: Copy,\n+{\n+    type Output = V;\n+\n+    fn index(&self, k: &K) -> &V {\n+        todo!()\n+    }\n+}\n+\n+fn index<'a, K, V>(map: &'a HashMap<K, V>, k: K) -> &'a V {\n+    map[k]\n+    //~^ ERROR the trait bound `K: Hash` is not satisfied\n+    //~| ERROR the trait bound `V: Copy` is not satisfied\n+    //~| ERROR mismatched types\n+    //~| ERROR mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "e03b06b336eefc0d989275b87816796ffede031c", "filename": "tests/ui/typeck/bad-index-due-to-nested.stderr", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/3320b2a59a81e59bdc0502ee015ba95514b6fe09/tests%2Fui%2Ftypeck%2Fbad-index-due-to-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3320b2a59a81e59bdc0502ee015ba95514b6fe09/tests%2Fui%2Ftypeck%2Fbad-index-due-to-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fbad-index-due-to-nested.stderr?ref=3320b2a59a81e59bdc0502ee015ba95514b6fe09", "patch": "@@ -0,0 +1,64 @@\n+error[E0277]: the trait bound `K: Hash` is not satisfied\n+  --> $DIR/bad-index-due-to-nested.rs:20:5\n+   |\n+LL |     map[k]\n+   |     ^^^ the trait `Hash` is not implemented for `K`\n+   |\n+note: required by a bound in `<HashMap<K, V> as Index<&K>>`\n+  --> $DIR/bad-index-due-to-nested.rs:9:8\n+   |\n+LL |     K: Hash,\n+   |        ^^^^ required by this bound in `<HashMap<K, V> as Index<&K>>`\n+help: consider restricting type parameter `K`\n+   |\n+LL | fn index<'a, K: std::hash::Hash, V>(map: &'a HashMap<K, V>, k: K) -> &'a V {\n+   |               +++++++++++++++++\n+\n+error[E0277]: the trait bound `V: Copy` is not satisfied\n+  --> $DIR/bad-index-due-to-nested.rs:20:5\n+   |\n+LL |     map[k]\n+   |     ^^^ the trait `Copy` is not implemented for `V`\n+   |\n+note: required by a bound in `<HashMap<K, V> as Index<&K>>`\n+  --> $DIR/bad-index-due-to-nested.rs:10:8\n+   |\n+LL |     V: Copy,\n+   |        ^^^^ required by this bound in `<HashMap<K, V> as Index<&K>>`\n+help: consider restricting type parameter `V`\n+   |\n+LL | fn index<'a, K, V: std::marker::Copy>(map: &'a HashMap<K, V>, k: K) -> &'a V {\n+   |                  +++++++++++++++++++\n+\n+error[E0308]: mismatched types\n+  --> $DIR/bad-index-due-to-nested.rs:20:9\n+   |\n+LL | fn index<'a, K, V>(map: &'a HashMap<K, V>, k: K) -> &'a V {\n+   |              - this type parameter\n+LL |     map[k]\n+   |         ^\n+   |         |\n+   |         expected `&K`, found type parameter `K`\n+   |         help: consider borrowing here: `&k`\n+   |\n+   = note:   expected reference `&K`\n+           found type parameter `K`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/bad-index-due-to-nested.rs:20:5\n+   |\n+LL | fn index<'a, K, V>(map: &'a HashMap<K, V>, k: K) -> &'a V {\n+   |                 - this type parameter               ----- expected `&'a V` because of return type\n+LL |     map[k]\n+   |     ^^^^^^\n+   |     |\n+   |     expected `&V`, found type parameter `V`\n+   |     help: consider borrowing here: `&map[k]`\n+   |\n+   = note:   expected reference `&'a V`\n+           found type parameter `V`\n+\n+error: aborting due to 4 previous errors\n+\n+Some errors have detailed explanations: E0277, E0308.\n+For more information about an error, try `rustc --explain E0277`."}]}