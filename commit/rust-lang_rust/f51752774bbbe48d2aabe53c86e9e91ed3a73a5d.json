{"sha": "f51752774bbbe48d2aabe53c86e9e91ed3a73a5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1MTc1Mjc3NGJiYmU0OGQyYWFiZTUzYzg2ZTllOTFlZDNhNzNhNWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-13T14:28:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-13T14:28:48Z"}, "message": "Auto merge of #54951 - alexcrichton:more-wasm-threads, r=sfackler\n\nstd: Implement TLS for wasm32-unknown-unknown\n\nThis adds an implementation of thread local storage for the\n`wasm32-unknown-unknown` target when the `atomics` feature is\nimplemented. This, however, comes with a notable caveat of that it\nrequires a new feature of the standard library, `wasm-bindgen-threads`,\nto be enabled.\n\nThread local storage for wasm (when `atomics` are enabled and there's\nactually more than one thread) is powered by the assumption that an\nexternal entity can fill in some information for us. It's not currently\nclear who will fill in this information nor whose responsibility it\nshould be long-term. In the meantime there's a strategy being gamed out\nin the `wasm-bindgen` project specifically, and the hope is that we can\ncontinue to test and iterate on the standard library without committing\nto a particular strategy yet.\n\nAs to the details of `wasm-bindgen`'s strategy, LLVM doesn't currently\nhave the ability to emit custom `global` values (thread locals in a\n`WebAssembly.Module`) so we leverage the `wasm-bindgen` CLI tool to do\nit for us. To that end we have a few intrinsics, assuming two global values:\n\n* `__wbindgen_current_id` - gets the current thread id as a 32-bit\n  integer. It's `wasm-bindgen`'s responsibility to initialize this\n  per-thread and then inform libstd of the id. Currently `wasm-bindgen`\n  performs this initialization as part of the `start` function.\n* `__wbindgen_tcb_{get,set}` - in addition to a thread id it's assumed\n  that there's a global available for simply storing a pointer's worth\n  of information (a thread control block, which currently only contains\n  thread local storage). This would ideally be a native `global`\n  injected by LLVM, but we don't have a great way to support that right\n  now.\n\nTo reiterate, this is all intended to be unstable and purely intended\nfor testing out Rust on the web with threads. The story is very likely\nto change in the future and we want to make sure that we're able to do\nthat!", "tree": {"sha": "2186eef6fcb94391c98c6c36efed30682fbba8fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2186eef6fcb94391c98c6c36efed30682fbba8fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f51752774bbbe48d2aabe53c86e9e91ed3a73a5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f51752774bbbe48d2aabe53c86e9e91ed3a73a5d", "html_url": "https://github.com/rust-lang/rust/commit/f51752774bbbe48d2aabe53c86e9e91ed3a73a5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f51752774bbbe48d2aabe53c86e9e91ed3a73a5d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24faa975895b548a2868491b1268076cc599151d", "url": "https://api.github.com/repos/rust-lang/rust/commits/24faa975895b548a2868491b1268076cc599151d", "html_url": "https://github.com/rust-lang/rust/commit/24faa975895b548a2868491b1268076cc599151d"}, {"sha": "cbe9f33b8bb94b262f91bc8c6f61a7f6518164b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbe9f33b8bb94b262f91bc8c6f61a7f6518164b4", "html_url": "https://github.com/rust-lang/rust/commit/cbe9f33b8bb94b262f91bc8c6f61a7f6518164b4"}], "stats": {"total": 147, "additions": 122, "deletions": 25}, "files": [{"sha": "cd1e3438fc372f1d6726344e3510bbdb1ede821f", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f51752774bbbe48d2aabe53c86e9e91ed3a73a5d/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f51752774bbbe48d2aabe53c86e9e91ed3a73a5d/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=f51752774bbbe48d2aabe53c86e9e91ed3a73a5d", "patch": "@@ -48,4 +48,13 @@ jemalloc = [\"alloc_jemalloc\"]\n force_alloc_system = []\n panic-unwind = [\"panic_unwind\"]\n profiler = [\"profiler_builtins\"]\n+\n+# An off-by-default feature which enables a linux-syscall-like ABI for libstd to\n+# interoperate with the host environment. Currently not well documented and\n+# requires rebuilding the standard library to use it.\n wasm_syscall = []\n+\n+# An off-by-default features to enable libstd to assume that wasm-bindgen is in\n+# the environment for hooking up some thread-related information like the\n+# current thread id and accessing/getting the current thread's TCB\n+wasm-bindgen-threads = []"}, {"sha": "762e807096fde5f2a310b06568f22e4361e8b6d0", "filename": "src/libstd/sys/wasm/mutex_atomics.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f51752774bbbe48d2aabe53c86e9e91ed3a73a5d/src%2Flibstd%2Fsys%2Fwasm%2Fmutex_atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f51752774bbbe48d2aabe53c86e9e91ed3a73a5d/src%2Flibstd%2Fsys%2Fwasm%2Fmutex_atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fmutex_atomics.rs?ref=f51752774bbbe48d2aabe53c86e9e91ed3a73a5d", "patch": "@@ -11,7 +11,8 @@\n use arch::wasm32::atomic;\n use cell::UnsafeCell;\n use mem;\n-use sync::atomic::{AtomicUsize, AtomicU64, Ordering::SeqCst};\n+use sync::atomic::{AtomicUsize, AtomicU32, Ordering::SeqCst};\n+use sys::thread;\n \n pub struct Mutex {\n     locked: AtomicUsize,\n@@ -70,7 +71,7 @@ impl Mutex {\n }\n \n pub struct ReentrantMutex {\n-    owner: AtomicU64,\n+    owner: AtomicU32,\n     recursions: UnsafeCell<u32>,\n }\n \n@@ -91,7 +92,7 @@ unsafe impl Sync for ReentrantMutex {}\n impl ReentrantMutex {\n     pub unsafe fn uninitialized() -> ReentrantMutex {\n         ReentrantMutex {\n-            owner: AtomicU64::new(0),\n+            owner: AtomicU32::new(0),\n             recursions: UnsafeCell::new(0),\n         }\n     }\n@@ -101,20 +102,20 @@ impl ReentrantMutex {\n     }\n \n     pub unsafe fn lock(&self) {\n-        let me = thread_id();\n+        let me = thread::my_id();\n         while let Err(owner) = self._try_lock(me) {\n-            let val = atomic::wait_i64(self.ptr(), owner as i64, -1);\n+            let val = atomic::wait_i32(self.ptr(), owner as i32, -1);\n             debug_assert!(val == 0 || val == 1);\n         }\n     }\n \n     #[inline]\n     pub unsafe fn try_lock(&self) -> bool {\n-        self._try_lock(thread_id()).is_ok()\n+        self._try_lock(thread::my_id()).is_ok()\n     }\n \n     #[inline]\n-    unsafe fn _try_lock(&self, id: u64) -> Result<(), u64> {\n+    unsafe fn _try_lock(&self, id: u32) -> Result<(), u32> {\n         let id = id.checked_add(1).unwrap(); // make sure `id` isn't 0\n         match self.owner.compare_exchange(0, id, SeqCst, SeqCst) {\n             // we transitioned from unlocked to locked\n@@ -153,11 +154,7 @@ impl ReentrantMutex {\n     }\n \n     #[inline]\n-    fn ptr(&self) -> *mut i64 {\n-        &self.owner as *const AtomicU64 as *mut i64\n+    fn ptr(&self) -> *mut i32 {\n+        &self.owner as *const AtomicU32 as *mut i32\n     }\n }\n-\n-fn thread_id() -> u64 {\n-    panic!(\"thread ids not implemented on wasm with atomics yet\")\n-}"}, {"sha": "4ad89c42b92dca0bfa921c1caabd5d2aeb3d5730", "filename": "src/libstd/sys/wasm/thread.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f51752774bbbe48d2aabe53c86e9e91ed3a73a5d/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f51752774bbbe48d2aabe53c86e9e91ed3a73a5d/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs?ref=f51752774bbbe48d2aabe53c86e9e91ed3a73a5d", "patch": "@@ -69,3 +69,49 @@ pub mod guard {\n     pub unsafe fn init() -> Option<Guard> { None }\n     pub unsafe fn deinit() {}\n }\n+\n+cfg_if! {\n+    if #[cfg(all(target_feature = \"atomics\", feature = \"wasm-bindgen-threads\"))] {\n+        #[link(wasm_import_module = \"__wbindgen_thread_xform__\")]\n+        extern {\n+            fn __wbindgen_current_id() -> u32;\n+            fn __wbindgen_tcb_get() -> u32;\n+            fn __wbindgen_tcb_set(ptr: u32);\n+        }\n+        pub fn my_id() -> u32 {\n+            unsafe { __wbindgen_current_id() }\n+        }\n+\n+        // These are currently only ever used in `thread_local_atomics.rs`, if\n+        // you'd like to use them be sure to update that and make sure everyone\n+        // agrees what's what.\n+        pub fn tcb_get() -> *mut u8 {\n+            use mem;\n+            assert_eq!(mem::size_of::<*mut u8>(), mem::size_of::<u32>());\n+            unsafe { __wbindgen_tcb_get() as *mut u8 }\n+        }\n+\n+        pub fn tcb_set(ptr: *mut u8) {\n+            unsafe { __wbindgen_tcb_set(ptr as u32); }\n+        }\n+\n+        // FIXME: still need something for hooking exiting a thread to free\n+        // data...\n+\n+    } else if #[cfg(target_feature = \"atomics\")] {\n+        pub fn my_id() -> u32 {\n+            panic!(\"thread ids not implemented on wasm with atomics yet\")\n+        }\n+\n+        pub fn tcb_get() -> *mut u8 {\n+            panic!(\"thread local data not implemented on wasm with atomics yet\")\n+        }\n+\n+        pub fn tcb_set(ptr: *mut u8) {\n+            panic!(\"thread local data not implemented on wasm with atomics yet\")\n+        }\n+    } else {\n+        // stubbed out because no functions actually access these intrinsics\n+        // unless atomics are enabled\n+    }\n+}"}, {"sha": "acfe60719f2f75206067f02bccc4972b5e341e13", "filename": "src/libstd/sys/wasm/thread_local_atomics.rs", "status": "modified", "additions": 46, "deletions": 7, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f51752774bbbe48d2aabe53c86e9e91ed3a73a5d/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local_atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f51752774bbbe48d2aabe53c86e9e91ed3a73a5d/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local_atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local_atomics.rs?ref=f51752774bbbe48d2aabe53c86e9e91ed3a73a5d", "patch": "@@ -8,22 +8,61 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use sys::thread;\n+use sync::atomic::{AtomicUsize, Ordering::SeqCst};\n+\n+const MAX_KEYS: usize = 128;\n+static NEXT_KEY: AtomicUsize = AtomicUsize::new(0);\n+\n+struct ThreadControlBlock {\n+    keys: [*mut u8; MAX_KEYS],\n+}\n+\n+impl ThreadControlBlock {\n+    fn new() -> ThreadControlBlock {\n+        ThreadControlBlock {\n+            keys: [0 as *mut u8; MAX_KEYS],\n+        }\n+    }\n+\n+    fn get() -> *mut ThreadControlBlock {\n+        let ptr = thread::tcb_get();\n+        if !ptr.is_null() {\n+            return ptr as *mut ThreadControlBlock\n+        }\n+        let tcb = Box::into_raw(Box::new(ThreadControlBlock::new()));\n+        thread::tcb_set(tcb as *mut u8);\n+        tcb\n+    }\n+}\n+\n pub type Key = usize;\n \n-pub unsafe fn create(_dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n-    panic!(\"TLS on wasm with atomics not implemented yet\");\n+pub unsafe fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n+    drop(dtor); // FIXME: need to figure out how to hook thread exit to run this\n+    let key = NEXT_KEY.fetch_add(1, SeqCst);\n+    if key >= MAX_KEYS {\n+        NEXT_KEY.store(MAX_KEYS, SeqCst);\n+        panic!(\"cannot allocate space for more TLS keys\");\n+    }\n+    // offset by 1 so we never hand out 0. This is currently required by\n+    // `sys_common/thread_local.rs` where it can't cope with keys of value 0\n+    // because it messes up the atomic management.\n+    return key + 1\n }\n \n-pub unsafe fn set(_key: Key, _value: *mut u8) {\n-    panic!(\"TLS on wasm with atomics not implemented yet\");\n+pub unsafe fn set(key: Key, value: *mut u8) {\n+    (*ThreadControlBlock::get()).keys[key - 1] = value;\n }\n \n-pub unsafe fn get(_key: Key) -> *mut u8 {\n-    panic!(\"TLS on wasm with atomics not implemented yet\");\n+pub unsafe fn get(key: Key) -> *mut u8 {\n+    (*ThreadControlBlock::get()).keys[key - 1]\n }\n \n pub unsafe fn destroy(_key: Key) {\n-    panic!(\"TLS on wasm with atomics not implemented yet\");\n+    // FIXME: should implement this somehow, this isn't typically called but it\n+    // can be called if two threads race to initialize a TLS slot and one ends\n+    // up not being needed.\n }\n \n #[inline]"}, {"sha": "59f100fad1bb9a1eda0aa41d72fa42c6b7c506d6", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f51752774bbbe48d2aabe53c86e9e91ed3a73a5d/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f51752774bbbe48d2aabe53c86e9e91ed3a73a5d/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=f51752774bbbe48d2aabe53c86e9e91ed3a73a5d", "patch": "@@ -172,16 +172,22 @@ macro_rules! __thread_local_inner {\n                 &'static $crate::cell::UnsafeCell<\n                     $crate::option::Option<$t>>>\n             {\n-                #[cfg(target_arch = \"wasm32\")]\n+                #[cfg(all(target_arch = \"wasm32\", not(target_feature = \"atomics\")))]\n                 static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =\n                     $crate::thread::__StaticLocalKeyInner::new();\n \n                 #[thread_local]\n-                #[cfg(all(target_thread_local, not(target_arch = \"wasm32\")))]\n+                #[cfg(all(\n+                    target_thread_local,\n+                    not(all(target_arch = \"wasm32\", not(target_feature = \"atomics\"))),\n+                ))]\n                 static __KEY: $crate::thread::__FastLocalKeyInner<$t> =\n                     $crate::thread::__FastLocalKeyInner::new();\n \n-                #[cfg(all(not(target_thread_local), not(target_arch = \"wasm32\")))]\n+                #[cfg(all(\n+                    not(target_thread_local),\n+                    not(all(target_arch = \"wasm32\", not(target_feature = \"atomics\"))),\n+                ))]\n                 static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n                     $crate::thread::__OsLocalKeyInner::new();\n \n@@ -302,7 +308,7 @@ impl<T: 'static> LocalKey<T> {\n /// On some platforms like wasm32 there's no threads, so no need to generate\n /// thread locals and we can instead just use plain statics!\n #[doc(hidden)]\n-#[cfg(target_arch = \"wasm32\")]\n+#[cfg(all(target_arch = \"wasm32\", not(target_feature = \"atomics\")))]\n pub mod statik {\n     use cell::UnsafeCell;\n     use fmt;"}, {"sha": "796b2bd3eed8709715ee96a99b319d4e56fa0d8a", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f51752774bbbe48d2aabe53c86e9e91ed3a73a5d/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f51752774bbbe48d2aabe53c86e9e91ed3a73a5d/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=f51752774bbbe48d2aabe53c86e9e91ed3a73a5d", "patch": "@@ -203,7 +203,7 @@ pub use self::local::{LocalKey, AccessError};\n // where available, but both are needed.\n \n #[unstable(feature = \"libstd_thread_internals\", issue = \"0\")]\n-#[cfg(target_arch = \"wasm32\")]\n+#[cfg(all(target_arch = \"wasm32\", not(target_feature = \"atomics\")))]\n #[doc(hidden)] pub use self::local::statik::Key as __StaticLocalKeyInner;\n #[unstable(feature = \"libstd_thread_internals\", issue = \"0\")]\n #[cfg(target_thread_local)]"}]}