{"sha": "3ed23a4bd0f6ab5db47f0ff41a457d09241228b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlZDIzYTRiZDBmNmFiNWRiNDdmMGZmNDFhNDU3ZDA5MjQxMjI4YjU=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2018-05-18T14:06:20Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2018-05-22T14:54:07Z"}, "message": "Use SortedMap instead of BTreeMap for relocations in MIRI.", "tree": {"sha": "4bdd9612e4f94109ad1e36711bd428b907636c25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bdd9612e4f94109ad1e36711bd428b907636c25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ed23a4bd0f6ab5db47f0ff41a457d09241228b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ed23a4bd0f6ab5db47f0ff41a457d09241228b5", "html_url": "https://github.com/rust-lang/rust/commit/3ed23a4bd0f6ab5db47f0ff41a457d09241228b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ed23a4bd0f6ab5db47f0ff41a457d09241228b5/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "879eb972adc681cb02b84505760ccebedd7465cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/879eb972adc681cb02b84505760ccebedd7465cd", "html_url": "https://github.com/rust-lang/rust/commit/879eb972adc681cb02b84505760ccebedd7465cd"}], "stats": {"total": 82, "additions": 56, "deletions": 26}, "files": [{"sha": "9827ee51ba29d739f0bb49392268b6dbb8930483", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3ed23a4bd0f6ab5db47f0ff41a457d09241228b5/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed23a4bd0f6ab5db47f0ff41a457d09241228b5/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=3ed23a4bd0f6ab5db47f0ff41a457d09241228b5", "patch": "@@ -12,7 +12,6 @@ pub use self::error::{EvalError, EvalResult, EvalErrorKind, AssertMessage};\n \n pub use self::value::{PrimVal, PrimValKind, Value, Pointer, ConstValue};\n \n-use std::collections::BTreeMap;\n use std::fmt;\n use mir;\n use hir::def_id::DefId;\n@@ -21,9 +20,11 @@ use ty::layout::{self, Align, HasDataLayout, Size};\n use middle::region;\n use std::iter;\n use std::io;\n+use std::ops::{Deref, DerefMut};\n use std::hash::Hash;\n use syntax::ast::Mutability;\n use rustc_serialize::{Encoder, Decoder, Decodable, Encodable};\n+use rustc_data_structures::sorted_map::SortedMap;\n use rustc_data_structures::fx::FxHashMap;\n use byteorder::{WriteBytesExt, ReadBytesExt, LittleEndian, BigEndian};\n \n@@ -341,7 +342,7 @@ pub struct Allocation {\n     pub bytes: Vec<u8>,\n     /// Maps from byte addresses to allocations.\n     /// Only the first byte of a pointer is inserted into the map.\n-    pub relocations: BTreeMap<Size, AllocId>,\n+    pub relocations: Relocations,\n     /// Denotes undefined memory. Reading from undefined memory is forbidden in miri\n     pub undef_mask: UndefMask,\n     /// The alignment of the allocation to detect unaligned reads.\n@@ -358,7 +359,7 @@ impl Allocation {\n         undef_mask.grow(Size::from_bytes(slice.len() as u64), true);\n         Self {\n             bytes: slice.to_owned(),\n-            relocations: BTreeMap::new(),\n+            relocations: Relocations::new(),\n             undef_mask,\n             align,\n             runtime_mutability: Mutability::Immutable,\n@@ -373,7 +374,7 @@ impl Allocation {\n         assert_eq!(size.bytes() as usize as u64, size.bytes());\n         Allocation {\n             bytes: vec![0; size.bytes() as usize],\n-            relocations: BTreeMap::new(),\n+            relocations: Relocations::new(),\n             undef_mask: UndefMask::new(size),\n             align,\n             runtime_mutability: Mutability::Immutable,\n@@ -383,6 +384,35 @@ impl Allocation {\n \n impl<'tcx> ::serialize::UseSpecializedDecodable for &'tcx Allocation {}\n \n+#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+pub struct Relocations(SortedMap<Size, AllocId>);\n+\n+impl Relocations {\n+    pub fn new() -> Relocations {\n+        Relocations(SortedMap::new())\n+    }\n+\n+    // The caller must guarantee that the given relocations are already sorted\n+    // by address and contain no duplicates.\n+    pub fn from_presorted(r: Vec<(Size, AllocId)>) -> Relocations {\n+        Relocations(SortedMap::from_presorted_elements(r))\n+    }\n+}\n+\n+impl Deref for Relocations {\n+    type Target = SortedMap<Size, AllocId>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+impl DerefMut for Relocations {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.0\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Methods to access integers in the target endianness\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "a4fe85135de7a36e64e68dc784b889082b5411aa", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ed23a4bd0f6ab5db47f0ff41a457d09241228b5/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed23a4bd0f6ab5db47f0ff41a457d09241228b5/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=3ed23a4bd0f6ab5db47f0ff41a457d09241228b5", "patch": "@@ -83,7 +83,7 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx, alloc: &Allocation) -> ValueRef {\n     let pointer_size = layout.pointer_size.bytes() as usize;\n \n     let mut next_offset = 0;\n-    for (&offset, &alloc_id) in &alloc.relocations {\n+    for &(offset, alloc_id) in alloc.relocations.iter() {\n         let offset = offset.bytes();\n         assert_eq!(offset as usize as u64, offset);\n         let offset = offset as usize;"}, {"sha": "3f7ecf9dfb282603c09bc2352a2acc4c322cc2af", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3ed23a4bd0f6ab5db47f0ff41a457d09241228b5/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed23a4bd0f6ab5db47f0ff41a457d09241228b5/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=3ed23a4bd0f6ab5db47f0ff41a457d09241228b5", "patch": "@@ -1,4 +1,4 @@\n-use std::collections::{btree_map, VecDeque};\n+use std::collections::VecDeque;\n use std::ptr;\n \n use rustc::hir::def_id::DefId;\n@@ -519,7 +519,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     fn get_bytes(&self, ptr: MemoryPointer, size: Size, align: Align) -> EvalResult<'tcx, &[u8]> {\n         assert_ne!(size.bytes(), 0);\n-        if self.relocations(ptr, size)?.count() != 0 {\n+        if self.relocations(ptr, size)?.len() != 0 {\n             return err!(ReadPointerAsBytes);\n         }\n         self.check_defined(ptr, size)?;\n@@ -614,9 +614,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         // first copy the relocations to a temporary buffer, because\n         // `get_bytes_mut` will clear the relocations, which is correct,\n         // since we don't want to keep any relocations at the target.\n-\n         let relocations: Vec<_> = self.relocations(src, size)?\n-            .map(|(&offset, &alloc_id)| {\n+            .iter()\n+            .map(|&(offset, alloc_id)| {\n                 // Update relocation offsets for the new positions in the destination allocation.\n                 (offset + dest.offset - src.offset, alloc_id)\n             })\n@@ -648,7 +648,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n         self.copy_undef_mask(src, dest, size)?;\n         // copy back the relocations\n-        self.get_mut(dest.alloc_id)?.relocations.extend(relocations);\n+        self.get_mut(dest.alloc_id)?.relocations.insert_presorted(relocations);\n \n         Ok(())\n     }\n@@ -660,7 +660,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         match alloc.bytes[offset..].iter().position(|&c| c == 0) {\n             Some(size) => {\n                 let p1 = Size::from_bytes((size + 1) as u64);\n-                if self.relocations(ptr, p1)?.count() != 0 {\n+                if self.relocations(ptr, p1)?.len() != 0 {\n                     return err!(ReadPointerAsBytes);\n                 }\n                 self.check_defined(ptr, p1)?;\n@@ -720,7 +720,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         let bytes = read_target_uint(endianness, bytes).unwrap();\n         // See if we got a pointer\n         if size != self.pointer_size() {\n-            if self.relocations(ptr, size)?.count() != 0 {\n+            if self.relocations(ptr, size)?.len() != 0 {\n                 return err!(ReadPointerAsBytes);\n             }\n         } else {\n@@ -808,24 +808,26 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         &self,\n         ptr: MemoryPointer,\n         size: Size,\n-    ) -> EvalResult<'tcx, btree_map::Range<Size, AllocId>> {\n+    ) -> EvalResult<'tcx, &[(Size, AllocId)]> {\n         let start = ptr.offset.bytes().saturating_sub(self.pointer_size().bytes() - 1);\n         let end = ptr.offset + size;\n         Ok(self.get(ptr.alloc_id)?.relocations.range(Size::from_bytes(start)..end))\n     }\n \n     fn clear_relocations(&mut self, ptr: MemoryPointer, size: Size) -> EvalResult<'tcx> {\n-        // Find all relocations overlapping the given range.\n-        let keys: Vec<_> = self.relocations(ptr, size)?.map(|(&k, _)| k).collect();\n-        if keys.is_empty() {\n-            return Ok(());\n-        }\n-\n         // Find the start and end of the given range and its outermost relocations.\n+        let (first, last) = {\n+            // Find all relocations overlapping the given range.\n+            let relocations = self.relocations(ptr, size)?;\n+            if relocations.is_empty() {\n+                return Ok(());\n+            }\n+\n+            (relocations.first().unwrap().0,\n+             relocations.last().unwrap().0 + self.pointer_size())\n+        };\n         let start = ptr.offset;\n         let end = start + size;\n-        let first = *keys.first().unwrap();\n-        let last = *keys.last().unwrap() + self.pointer_size();\n \n         let alloc = self.get_mut(ptr.alloc_id)?;\n \n@@ -839,16 +841,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n \n         // Forget all the relocations.\n-        for k in keys {\n-            alloc.relocations.remove(&k);\n-        }\n+        alloc.relocations.remove_range(first ..= last);\n \n         Ok(())\n     }\n \n     fn check_relocation_edges(&self, ptr: MemoryPointer, size: Size) -> EvalResult<'tcx> {\n-        let overlapping_start = self.relocations(ptr, Size::from_bytes(0))?.count();\n-        let overlapping_end = self.relocations(ptr.offset(size, self)?, Size::from_bytes(0))?.count();\n+        let overlapping_start = self.relocations(ptr, Size::from_bytes(0))?.len();\n+        let overlapping_end = self.relocations(ptr.offset(size, self)?, Size::from_bytes(0))?.len();\n         if overlapping_start + overlapping_end != 0 {\n             return err!(ReadPointerAsBytes);\n         }"}]}