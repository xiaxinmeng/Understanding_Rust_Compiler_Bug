{"sha": "0b1c434d5321addbdecd5c908ad82bb626cc7cbb", "node_id": "C_kwDOAAsO6NoAKDBiMWM0MzRkNTMyMWFkZGJkZWNkNWM5MDhhZDgyYmI2MjZjYzdjYmI", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-12-21T16:14:57Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-12-21T17:27:54Z"}, "message": "Deduplicate lower ctx hygiene field", "tree": {"sha": "894626e83eac060881e0aab8936237df6b15accc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/894626e83eac060881e0aab8936237df6b15accc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b1c434d5321addbdecd5c908ad82bb626cc7cbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b1c434d5321addbdecd5c908ad82bb626cc7cbb", "html_url": "https://github.com/rust-lang/rust/commit/0b1c434d5321addbdecd5c908ad82bb626cc7cbb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b1c434d5321addbdecd5c908ad82bb626cc7cbb/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "929cae74b160a9a3567962d9f880bd60e0dc4e34", "url": "https://api.github.com/repos/rust-lang/rust/commits/929cae74b160a9a3567962d9f880bd60e0dc4e34", "html_url": "https://github.com/rust-lang/rust/commit/929cae74b160a9a3567962d9f880bd60e0dc4e34"}], "stats": {"total": 45, "additions": 24, "deletions": 21}, "files": [{"sha": "45b374f338b9c09150c8a29f5212e7fc7a995ec1", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0b1c434d5321addbdecd5c908ad82bb626cc7cbb/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1c434d5321addbdecd5c908ad82bb626cc7cbb/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=0b1c434d5321addbdecd5c908ad82bb626cc7cbb", "patch": "@@ -56,6 +56,7 @@ use la_arena::{Arena, Idx, IdxRange, RawIdx};\n use profile::Count;\n use rustc_hash::FxHashMap;\n use smallvec::SmallVec;\n+use stdx::never;\n use syntax::{ast, match_ast, SyntaxKind};\n \n use crate::{\n@@ -109,18 +110,17 @@ impl ItemTree {\n             Some(node) => node,\n             None => return Default::default(),\n         };\n-        if syntax.kind() == SyntaxKind::ERROR {\n+        if never!(syntax.kind() == SyntaxKind::ERROR) {\n             // FIXME: not 100% sure why these crop up, but return an empty tree to avoid a panic\n             return Default::default();\n         }\n \n-        let hygiene = Hygiene::new(db.upcast(), file_id);\n-        let ctx = lower::Ctx::new(db, hygiene.clone(), file_id);\n+        let ctx = lower::Ctx::new(db, file_id);\n         let mut top_attrs = None;\n         let mut item_tree = match_ast! {\n             match syntax {\n                 ast::SourceFile(file) => {\n-                    top_attrs = Some(RawAttrs::new(db, &file, &hygiene));\n+                    top_attrs = Some(RawAttrs::new(db, &file, ctx.hygiene()));\n                     ctx.lower_module_items(&file)\n                 },\n                 ast::MacroItems(items) => {\n@@ -147,8 +147,7 @@ impl ItemTree {\n     fn block_item_tree(db: &dyn DefDatabase, block: BlockId) -> Arc<ItemTree> {\n         let loc = db.lookup_intern_block(block);\n         let block = loc.ast_id.to_node(db.upcast());\n-        let hygiene = Hygiene::new(db.upcast(), loc.ast_id.file_id);\n-        let ctx = lower::Ctx::new(db, hygiene, loc.ast_id.file_id);\n+        let ctx = lower::Ctx::new(db, loc.ast_id.file_id);\n         Arc::new(ctx.lower_block(&block))\n     }\n "}, {"sha": "f31fcf0d97b8db786a04025f6b5357255bca591e", "filename": "crates/hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0b1c434d5321addbdecd5c908ad82bb626cc7cbb/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1c434d5321addbdecd5c908ad82bb626cc7cbb/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=0b1c434d5321addbdecd5c908ad82bb626cc7cbb", "patch": "@@ -19,24 +19,26 @@ fn id<N: ItemTreeNode>(index: Idx<N>) -> FileItemTreeId<N> {\n pub(super) struct Ctx<'a> {\n     db: &'a dyn DefDatabase,\n     tree: ItemTree,\n-    hygiene: Hygiene,\n     source_ast_id_map: Arc<AstIdMap>,\n     body_ctx: crate::body::LowerCtx<'a>,\n     forced_visibility: Option<RawVisibilityId>,\n }\n \n impl<'a> Ctx<'a> {\n-    pub(super) fn new(db: &'a dyn DefDatabase, hygiene: Hygiene, file: HirFileId) -> Self {\n+    pub(super) fn new(db: &'a dyn DefDatabase, file: HirFileId) -> Self {\n         Self {\n             db,\n             tree: ItemTree::default(),\n-            hygiene,\n             source_ast_id_map: db.ast_id_map(file),\n             body_ctx: crate::body::LowerCtx::new(db, file),\n             forced_visibility: None,\n         }\n     }\n \n+    pub(super) fn hygiene(&self) -> &Hygiene {\n+        self.body_ctx.hygiene()\n+    }\n+\n     pub(super) fn lower_module_items(mut self, item_owner: &dyn HasModuleItem) -> ItemTree {\n         self.tree.top_level =\n             item_owner.items().flat_map(|item| self.lower_mod_item(&item)).collect();\n@@ -88,7 +90,7 @@ impl<'a> Ctx<'a> {\n     }\n \n     fn lower_mod_item(&mut self, item: &ast::Item) -> Option<ModItem> {\n-        let attrs = RawAttrs::new(self.db, item, &self.hygiene);\n+        let attrs = RawAttrs::new(self.db, item, self.hygiene());\n         let item: ModItem = match item {\n             ast::Item::Struct(ast) => self.lower_struct(ast)?.into(),\n             ast::Item::Union(ast) => self.lower_union(ast)?.into(),\n@@ -162,7 +164,7 @@ impl<'a> Ctx<'a> {\n         for field in fields.fields() {\n             if let Some(data) = self.lower_record_field(&field) {\n                 let idx = self.data().fields.alloc(data);\n-                self.add_attrs(idx.into(), RawAttrs::new(self.db, &field, &self.hygiene));\n+                self.add_attrs(idx.into(), RawAttrs::new(self.db, &field, self.hygiene()));\n             }\n         }\n         let end = self.next_field_idx();\n@@ -182,7 +184,7 @@ impl<'a> Ctx<'a> {\n         for (i, field) in fields.fields().enumerate() {\n             let data = self.lower_tuple_field(i, &field);\n             let idx = self.data().fields.alloc(data);\n-            self.add_attrs(idx.into(), RawAttrs::new(self.db, &field, &self.hygiene));\n+            self.add_attrs(idx.into(), RawAttrs::new(self.db, &field, self.hygiene()));\n         }\n         let end = self.next_field_idx();\n         IdxRange::new(start..end)\n@@ -227,7 +229,7 @@ impl<'a> Ctx<'a> {\n         for variant in variants.variants() {\n             if let Some(data) = self.lower_variant(&variant) {\n                 let idx = self.data().variants.alloc(data);\n-                self.add_attrs(idx.into(), RawAttrs::new(self.db, &variant, &self.hygiene));\n+                self.add_attrs(idx.into(), RawAttrs::new(self.db, &variant, self.hygiene()));\n             }\n         }\n         let end = self.next_variant_idx();\n@@ -270,7 +272,7 @@ impl<'a> Ctx<'a> {\n                 };\n                 let ty = Interned::new(self_type);\n                 let idx = self.data().params.alloc(Param::Normal(None, ty));\n-                self.add_attrs(idx.into(), RawAttrs::new(self.db, &self_param, &self.hygiene));\n+                self.add_attrs(idx.into(), RawAttrs::new(self.db, &self_param, self.hygiene()));\n                 has_self_param = true;\n             }\n             for param in param_list.params() {\n@@ -294,7 +296,7 @@ impl<'a> Ctx<'a> {\n                         self.data().params.alloc(Param::Normal(name, ty))\n                     }\n                 };\n-                self.add_attrs(idx.into(), RawAttrs::new(self.db, &param, &self.hygiene));\n+                self.add_attrs(idx.into(), RawAttrs::new(self.db, &param, self.hygiene()));\n             }\n         }\n         let end_param = self.next_param_idx();\n@@ -427,7 +429,7 @@ impl<'a> Ctx<'a> {\n             self.with_inherited_visibility(visibility, |this| {\n                 list.assoc_items()\n                     .filter_map(|item| {\n-                        let attrs = RawAttrs::new(db, &item, &this.hygiene);\n+                        let attrs = RawAttrs::new(db, &item, this.hygiene());\n                         this.lower_assoc_item(&item).map(|item| {\n                             this.add_attrs(ModItem::from(item).into(), attrs);\n                             item\n@@ -465,7 +467,7 @@ impl<'a> Ctx<'a> {\n             .flat_map(|it| it.assoc_items())\n             .filter_map(|item| {\n                 let assoc = self.lower_assoc_item(&item)?;\n-                let attrs = RawAttrs::new(self.db, &item, &self.hygiene);\n+                let attrs = RawAttrs::new(self.db, &item, self.hygiene());\n                 self.add_attrs(ModItem::from(assoc).into(), attrs);\n                 Some(assoc)\n             })\n@@ -478,7 +480,7 @@ impl<'a> Ctx<'a> {\n     fn lower_use(&mut self, use_item: &ast::Use) -> Option<FileItemTreeId<Import>> {\n         let visibility = self.lower_visibility(use_item);\n         let ast_id = self.source_ast_id_map.ast_id(use_item);\n-        let (use_tree, _) = lower_use_tree(self.db, &self.hygiene, use_item.use_tree()?)?;\n+        let (use_tree, _) = lower_use_tree(self.db, self.hygiene(), use_item.use_tree()?)?;\n \n         let res = Import { visibility, ast_id, use_tree };\n         Some(id(self.data().imports.alloc(res)))\n@@ -500,7 +502,7 @@ impl<'a> Ctx<'a> {\n     }\n \n     fn lower_macro_call(&mut self, m: &ast::MacroCall) -> Option<FileItemTreeId<MacroCall>> {\n-        let path = Interned::new(ModPath::from_src(self.db, m.path()?, &self.hygiene)?);\n+        let path = Interned::new(ModPath::from_src(self.db, m.path()?, self.hygiene())?);\n         let ast_id = self.source_ast_id_map.ast_id(m);\n         let expand_to = hir_expand::ExpandTo::from_call_site(m);\n         let res = MacroCall { path, ast_id, expand_to };\n@@ -535,7 +537,7 @@ impl<'a> Ctx<'a> {\n                     // (in other words, the knowledge that they're in an extern block must not be used).\n                     // This is because an extern block can contain macros whose ItemTree's top-level items\n                     // should be considered to be in an extern block too.\n-                    let attrs = RawAttrs::new(self.db, &item, &self.hygiene);\n+                    let attrs = RawAttrs::new(self.db, &item, self.hygiene());\n                     let id: ModItem = match item {\n                         ast::ExternItem::Fn(ast) => {\n                             let func_id = self.lower_function(&ast)?;\n@@ -616,7 +618,9 @@ impl<'a> Ctx<'a> {\n     fn lower_visibility(&mut self, item: &dyn ast::HasVisibility) -> RawVisibilityId {\n         let vis = match self.forced_visibility {\n             Some(vis) => return vis,\n-            None => RawVisibility::from_ast_with_hygiene(self.db, item.visibility(), &self.hygiene),\n+            None => {\n+                RawVisibility::from_ast_with_hygiene(self.db, item.visibility(), self.hygiene())\n+            }\n         };\n \n         self.data().vis.alloc(vis)"}]}