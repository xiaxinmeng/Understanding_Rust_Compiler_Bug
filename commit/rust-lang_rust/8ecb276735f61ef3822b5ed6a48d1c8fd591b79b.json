{"sha": "8ecb276735f61ef3822b5ed6a48d1c8fd591b79b", "node_id": "C_kwDOAAsO6NoAKDhlY2IyNzY3MzVmNjFlZjM4MjJiNWVkNmE0OGQxYzhmZDU5MWI3OWI", "commit": {"author": {"name": "Jannis Christopher K\u00f6hl", "email": "mail@koehl.dev", "date": "2022-11-10T18:12:10Z"}, "committer": {"name": "Jannis Christopher K\u00f6hl", "email": "mail@koehl.dev", "date": "2022-11-10T18:12:10Z"}, "message": "Simplify creation of map", "tree": {"sha": "1a6d3756fa871ea40f4983d714e5517af49bf045", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a6d3756fa871ea40f4983d714e5517af49bf045"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ecb276735f61ef3822b5ed6a48d1c8fd591b79b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ecb276735f61ef3822b5ed6a48d1c8fd591b79b", "html_url": "https://github.com/rust-lang/rust/commit/8ecb276735f61ef3822b5ed6a48d1c8fd591b79b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ecb276735f61ef3822b5ed6a48d1c8fd591b79b/comments", "author": {"login": "jachris", "id": 30163784, "node_id": "MDQ6VXNlcjMwMTYzNzg0", "avatar_url": "https://avatars.githubusercontent.com/u/30163784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jachris", "html_url": "https://github.com/jachris", "followers_url": "https://api.github.com/users/jachris/followers", "following_url": "https://api.github.com/users/jachris/following{/other_user}", "gists_url": "https://api.github.com/users/jachris/gists{/gist_id}", "starred_url": "https://api.github.com/users/jachris/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jachris/subscriptions", "organizations_url": "https://api.github.com/users/jachris/orgs", "repos_url": "https://api.github.com/users/jachris/repos", "events_url": "https://api.github.com/users/jachris/events{/privacy}", "received_events_url": "https://api.github.com/users/jachris/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jachris", "id": 30163784, "node_id": "MDQ6VXNlcjMwMTYzNzg0", "avatar_url": "https://avatars.githubusercontent.com/u/30163784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jachris", "html_url": "https://github.com/jachris", "followers_url": "https://api.github.com/users/jachris/followers", "following_url": "https://api.github.com/users/jachris/following{/other_user}", "gists_url": "https://api.github.com/users/jachris/gists{/gist_id}", "starred_url": "https://api.github.com/users/jachris/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jachris/subscriptions", "organizations_url": "https://api.github.com/users/jachris/orgs", "repos_url": "https://api.github.com/users/jachris/repos", "events_url": "https://api.github.com/users/jachris/events{/privacy}", "received_events_url": "https://api.github.com/users/jachris/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9766ee0b2040d93c7ff4af237c3c839d54adf8ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/9766ee0b2040d93c7ff4af237c3c839d54adf8ea", "html_url": "https://github.com/rust-lang/rust/commit/9766ee0b2040d93c7ff4af237c3c839d54adf8ea"}], "stats": {"total": 79, "additions": 26, "deletions": 53}, "files": [{"sha": "13072a30282c4c2bc176f73732dbc44a79c78520", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "modified", "additions": 25, "deletions": 52, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/8ecb276735f61ef3822b5ed6a48d1c8fd591b79b/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ecb276735f61ef3822b5ed6a48d1c8fd591b79b/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=8ecb276735f61ef3822b5ed6a48d1c8fd591b79b", "patch": "@@ -36,7 +36,6 @@ use std::fmt::{Debug, Formatter};\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_index::vec::IndexVec;\n-use rustc_middle::mir::tcx::PlaceTy;\n use rustc_middle::mir::visit::{MutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -552,9 +551,10 @@ impl<V: JoinSemiLattice + Clone> JoinSemiLattice for State<V> {\n     }\n }\n \n-/// A partial mapping from `Place` to `PlaceIndex`, where some place indices have value indices.\n+/// Partial mapping from [`Place`] to [`PlaceIndex`], where some places also have a [`ValueIndex`].\n ///\n-/// Some additional bookkeeping is done to speed up traversal:\n+/// This data structure essentially maintains a tree of places and their projections. Some\n+/// additional bookkeeping is done, to speed up traversal over this tree:\n /// - For iteration, every [`PlaceInfo`] contains an intrusive linked list of its children.\n /// - To directly get the child for a specific projection, there is a `projections` map.\n #[derive(Debug)]\n@@ -578,7 +578,8 @@ impl Map {\n     /// Returns a map that only tracks places whose type passes the filter.\n     ///\n     /// This is currently the only way to create a [`Map`]. The way in which the tracked places are\n-    /// chosen is an implementation detail and may not be relied upon.\n+    /// chosen is an implementation detail and may not be relied upon (other than that their type\n+    /// passes the filter).\n     #[instrument(skip_all, level = \"debug\")]\n     pub fn from_filter<'tcx>(\n         tcx: TyCtxt<'tcx>,\n@@ -599,6 +600,7 @@ impl Map {\n         mut filter: impl FnMut(Ty<'tcx>) -> bool,\n         exclude: &FxHashSet<Place<'tcx>>,\n     ) {\n+        // We use this vector as stack, pushing and popping projections.\n         let mut projection = Vec::new();\n         for (local, decl) in body.local_decls.iter_enumerated() {\n             self.register_with_filter_rec(\n@@ -612,6 +614,9 @@ impl Map {\n         }\n     }\n \n+    /// Register fields of the given (local, projection) place.\n+    ///\n+    /// Invariant: The projection must only contain fields.\n     fn register_with_filter_rec<'tcx>(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n@@ -626,10 +631,19 @@ impl Map {\n             return;\n         }\n \n-        if filter(ty) {\n-            // This might fail if `ty` is not scalar.\n-            let _ = self.register_with_ty(local, projection, ty);\n+        // Note: The framework supports only scalars for now.\n+        if filter(ty) && ty.is_scalar() {\n+            // We know that the projection only contains trackable elements.\n+            let place = self.make_place(local, projection).unwrap();\n+\n+            // Allocate a value slot if it doesn't have one.\n+            if self.places[place].value_index.is_none() {\n+                self.places[place].value_index = Some(self.value_count.into());\n+                self.value_count += 1;\n+            }\n         }\n+\n+        // Recurse with all fields of this place.\n         iter_fields(ty, tcx, |variant, field, ty| {\n             if variant.is_some() {\n                 // Downcasts are currently not supported.\n@@ -668,59 +682,17 @@ impl Map {\n         Ok(index)\n     }\n \n-    #[allow(unused)]\n-    fn register<'tcx>(\n-        &mut self,\n-        local: Local,\n-        projection: &[PlaceElem<'tcx>],\n-        decls: &impl HasLocalDecls<'tcx>,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> Result<(), ()> {\n-        projection\n-            .iter()\n-            .fold(PlaceTy::from_ty(decls.local_decls()[local].ty), |place_ty, &elem| {\n-                place_ty.projection_ty(tcx, elem)\n-            });\n-\n-        let place_ty = Place::ty_from(local, projection, decls, tcx);\n-        if place_ty.variant_index.is_some() {\n-            return Err(());\n-        }\n-        self.register_with_ty(local, projection, place_ty.ty)\n-    }\n-\n-    /// Tries to track the given place. Fails if type is non-scalar or projection is not trackable.\n-    fn register_with_ty<'tcx>(\n-        &mut self,\n-        local: Local,\n-        projection: &[PlaceElem<'tcx>],\n-        ty: Ty<'tcx>,\n-    ) -> Result<(), ()> {\n-        if !ty.is_scalar() {\n-            // Currently, only scalar types are allowed, because they are atomic\n-            // and therefore do not require invalidation of parent places.\n-            return Err(());\n-        }\n-\n-        let place = self.make_place(local, projection)?;\n-\n-        // Allocate a value slot if it doesn't have one.\n-        if self.places[place].value_index.is_none() {\n-            self.places[place].value_index = Some(self.value_count.into());\n-            self.value_count += 1;\n-        }\n-\n-        Ok(())\n-    }\n-\n+    /// Returns the number of tracked places, i.e., those for which a value can be stored.\n     pub fn tracked_places(&self) -> usize {\n         self.value_count\n     }\n \n+    /// Applies a single projection element, yielding the corresponding child.\n     pub fn apply(&self, place: PlaceIndex, elem: TrackElem) -> Option<PlaceIndex> {\n         self.projections.get(&(place, elem)).copied()\n     }\n \n+    /// Locates the given place, if it exists in the tree.\n     pub fn find(&self, place: PlaceRef<'_>) -> Option<PlaceIndex> {\n         let mut index = *self.locals.get(place.local)?.as_ref()?;\n \n@@ -736,6 +708,7 @@ impl Map {\n         Children::new(self, parent)\n     }\n \n+    /// Invoke a function on the given place and all descendants.\n     pub fn preorder_invoke(&self, root: PlaceIndex, f: &mut impl FnMut(PlaceIndex)) {\n         f(root);\n         for child in self.children(root) {"}, {"sha": "2ed8a6f161f7ff77ca4fab5878ef944e8b408840", "filename": "compiler/rustc_mir_transform/src/dataflow_const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ecb276735f61ef3822b5ed6a48d1c8fd591b79b/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ecb276735f61ef3822b5ed6a48d1c8fd591b79b/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs?ref=8ecb276735f61ef3822b5ed6a48d1c8fd591b79b", "patch": "@@ -105,7 +105,7 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'tcx> {\n                             FlatSet::Top => FlatSet::Top,\n                             FlatSet::Elem(overflow) => {\n                                 if overflow {\n-                                    // Overflow cannot be reliable propagated. See: https://github.com/rust-lang/rust/pull/101168#issuecomment-1288091446\n+                                    // Overflow cannot be reliably propagated. See: https://github.com/rust-lang/rust/pull/101168#issuecomment-1288091446\n                                     FlatSet::Top\n                                 } else {\n                                     self.wrap_scalar(Scalar::from_bool(false), self.tcx.types.bool)"}]}