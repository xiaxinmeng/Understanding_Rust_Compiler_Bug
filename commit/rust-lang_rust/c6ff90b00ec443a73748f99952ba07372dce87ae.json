{"sha": "c6ff90b00ec443a73748f99952ba07372dce87ae", "node_id": "C_kwDOAAsO6NoAKGM2ZmY5MGIwMGVjNDQzYTczNzQ4Zjk5OTUyYmEwNzM3MmRjZTg3YWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-10T16:45:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-10T16:45:17Z"}, "message": "Auto merge of #98785 - compiler-errors:no-check-expr-in-check-compatible, r=estebank\n\nDo not call `check_expr` in `check_compatible`, since it has side-effects\n\nFixes a weird suggestion in #98784\n\nfound later:\nFixes #98894\nFixes #98897", "tree": {"sha": "1de04833ba163b9559cf4a6473c92121667fe4b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1de04833ba163b9559cf4a6473c92121667fe4b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6ff90b00ec443a73748f99952ba07372dce87ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6ff90b00ec443a73748f99952ba07372dce87ae", "html_url": "https://github.com/rust-lang/rust/commit/c6ff90b00ec443a73748f99952ba07372dce87ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6ff90b00ec443a73748f99952ba07372dce87ae/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29554c0a120f6c1eb0c60f2a88c06faeb3d0f3c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/29554c0a120f6c1eb0c60f2a88c06faeb3d0f3c9", "html_url": "https://github.com/rust-lang/rust/commit/29554c0a120f6c1eb0c60f2a88c06faeb3d0f3c9"}, {"sha": "6858fbc1012c2313dc538ba9fca6fa42c1deb198", "url": "https://api.github.com/repos/rust-lang/rust/commits/6858fbc1012c2313dc538ba9fca6fa42c1deb198", "html_url": "https://github.com/rust-lang/rust/commit/6858fbc1012c2313dc538ba9fca6fa42c1deb198"}], "stats": {"total": 69, "additions": 24, "deletions": 45}, "files": [{"sha": "58c01a34cad51de2350de72d53dbb49ce054ff39", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6ff90b00ec443a73748f99952ba07372dce87ae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6ff90b00ec443a73748f99952ba07372dce87ae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=c6ff90b00ec443a73748f99952ba07372dce87ae", "patch": "@@ -271,7 +271,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     #[instrument(skip(self, expr), level = \"debug\")]\n-    pub(super) fn check_expr_kind(\n+    fn check_expr_kind(\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,"}, {"sha": "a7c7089234aa959701c9cd6b7f43aa0aafae00d2", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 18, "deletions": 26, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c6ff90b00ec443a73748f99952ba07372dce87ae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6ff90b00ec443a73748f99952ba07372dce87ae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=c6ff90b00ec443a73748f99952ba07372dce87ae", "patch": "@@ -483,6 +483,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.set_tainted_by_errors();\n         let tcx = self.tcx;\n \n+        // Precompute the provided types and spans, since that's all we typically need for below\n+        let provided_arg_tys: IndexVec<ProvidedIdx, (Ty<'tcx>, Span)> = provided_args\n+            .iter()\n+            .map(|expr| {\n+                let ty = self\n+                    .typeck_results\n+                    .borrow()\n+                    .expr_ty_adjusted_opt(*expr)\n+                    .unwrap_or_else(|| tcx.ty_error());\n+                (self.resolve_vars_if_possible(ty), expr.span)\n+            })\n+            .collect();\n+\n         // A \"softer\" version of the `demand_compatible`, which checks types without persisting them,\n         // and treats error types differently\n         // This will allow us to \"probe\" for other argument orders that would likely have been correct\n@@ -499,31 +512,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 return Compatibility::Incompatible(None);\n             }\n \n-            let provided_arg: &hir::Expr<'tcx> = &provided_args[provided_idx];\n-            let expectation = Expectation::rvalue_hint(self, expected_input_ty);\n-            // FIXME: check that this is safe; I don't believe this commits any of the obligations, but I can't be sure.\n-            //\n-            //   I had another method of \"soft\" type checking before,\n-            //   but it was failing to find the type of some expressions (like \"\")\n-            //   so I prodded this method and made it pub(super) so I could call it, and it seems to work well.\n-            let checked_ty = self.check_expr_kind(provided_arg, expectation);\n+            let (arg_ty, arg_span) = provided_arg_tys[provided_idx];\n \n+            let expectation = Expectation::rvalue_hint(self, expected_input_ty);\n             let coerced_ty = expectation.only_has_type(self).unwrap_or(formal_input_ty);\n-            let can_coerce = self.can_coerce(checked_ty, coerced_ty);\n+            let can_coerce = self.can_coerce(arg_ty, coerced_ty);\n             if !can_coerce {\n                 return Compatibility::Incompatible(None);\n             }\n \n             // Using probe here, since we don't want this subtyping to affect inference.\n             let subtyping_error = self.probe(|_| {\n-                self.at(&self.misc(provided_arg.span), self.param_env)\n-                    .sup(formal_input_ty, coerced_ty)\n-                    .err()\n+                self.at(&self.misc(arg_span), self.param_env).sup(formal_input_ty, coerced_ty).err()\n             });\n \n             // Same as above: if either the coerce type or the checked type is an error type,\n             // consider them *not* compatible.\n-            let references_error = (coerced_ty, checked_ty).references_error();\n+            let references_error = (coerced_ty, arg_ty).references_error();\n             match (references_error, subtyping_error) {\n                 (false, None) => Compatibility::Compatible,\n                 (_, subtyping_error) => Compatibility::Incompatible(subtyping_error),\n@@ -542,19 +547,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ArgMatrix::new(provided_args.len(), formal_and_expected_inputs.len(), check_compatible)\n                 .find_errors();\n \n-        // Precompute the provided types and spans, since that's all we typically need for below\n-        let provided_arg_tys: IndexVec<ProvidedIdx, (Ty<'tcx>, Span)> = provided_args\n-            .iter()\n-            .map(|expr| {\n-                let ty = self\n-                    .typeck_results\n-                    .borrow()\n-                    .expr_ty_adjusted_opt(*expr)\n-                    .unwrap_or_else(|| tcx.ty_error());\n-                (self.resolve_vars_if_possible(ty), expr.span)\n-            })\n-            .collect();\n-\n         // First, check if we just need to wrap some arguments in a tuple.\n         if let Some((mismatch_idx, terr)) =\n             compatibility_diagonal.iter().enumerate().find_map(|(i, c)| {"}, {"sha": "7c626a01b1298dfdb64655d763eb2d31ba2721a4", "filename": "src/test/ui/issues/issue-3044.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6ff90b00ec443a73748f99952ba07372dce87ae/src%2Ftest%2Fui%2Fissues%2Fissue-3044.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6ff90b00ec443a73748f99952ba07372dce87ae/src%2Ftest%2Fui%2Fissues%2Fissue-3044.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3044.rs?ref=c6ff90b00ec443a73748f99952ba07372dce87ae", "patch": "@@ -1,7 +1,6 @@\n fn main() {\n     let needlesArr: Vec<char> = vec!['a', 'f'];\n     needlesArr.iter().fold(|x, y| {\n+        //~^ ERROR this function takes 2 arguments but 1 argument was supplied\n     });\n-    //~^^ ERROR mismatched types\n-    //~| ERROR this function takes 2 arguments but 1 argument was supplied\n }"}, {"sha": "a4c455ca1927e3fc225c5b09bf56dd344b46511c", "filename": "src/test/ui/issues/issue-3044.stderr", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c6ff90b00ec443a73748f99952ba07372dce87ae/src%2Ftest%2Fui%2Fissues%2Fissue-3044.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6ff90b00ec443a73748f99952ba07372dce87ae/src%2Ftest%2Fui%2Fissues%2Fissue-3044.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3044.stderr?ref=c6ff90b00ec443a73748f99952ba07372dce87ae", "patch": "@@ -1,21 +1,9 @@\n-error[E0308]: mismatched types\n-  --> $DIR/issue-3044.rs:3:35\n-   |\n-LL |       needlesArr.iter().fold(|x, y| {\n-   |  ____________________________------_^\n-   | |                            |\n-   | |                            the expected closure\n-LL | |     });\n-   | |_____^ expected closure, found `()`\n-   |\n-   = note: expected closure `[closure@$DIR/issue-3044.rs:3:28: 3:34]`\n-            found unit type `()`\n-\n error[E0061]: this function takes 2 arguments but 1 argument was supplied\n   --> $DIR/issue-3044.rs:3:23\n    |\n LL |       needlesArr.iter().fold(|x, y| {\n    |  _______________________^^^^-\n+LL | |\n LL | |     });\n    | |______- an argument is missing\n    |\n@@ -27,10 +15,10 @@ LL |     fn fold<B, F>(mut self, init: B, mut f: F) -> B\n help: provide the argument\n    |\n LL ~     needlesArr.iter().fold(|x, y| {\n+LL +\n LL ~     }, /* value */);\n    |\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0061, E0308.\n-For more information about an error, try `rustc --explain E0061`.\n+For more information about this error, try `rustc --explain E0061`."}]}