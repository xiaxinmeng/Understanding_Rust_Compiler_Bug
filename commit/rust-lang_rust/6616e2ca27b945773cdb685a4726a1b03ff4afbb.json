{"sha": "6616e2ca27b945773cdb685a4726a1b03ff4afbb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2MTZlMmNhMjdiOTQ1NzczY2RiNjg1YTQ3MjZhMWIwM2ZmNGFmYmI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-02T10:08:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-02T10:08:10Z"}, "message": "Rollup merge of #71738 - RalfJung:pointer-no-alloc-id, r=oli-obk\n\nremove AllocId generalization of Pointer\n\nThis was only needed for the \"snapshot\" machinery, which is gone.\n\nr? @oli-obk", "tree": {"sha": "6b4b624ddf312c23b61849510ca204617b0ade1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b4b624ddf312c23b61849510ca204617b0ade1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6616e2ca27b945773cdb685a4726a1b03ff4afbb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJerUaKCRBK7hj4Ov3rIwAAdHIIABP47fiV0hpZLVof7v6fXlbi\nqlDekiNz7GxSmGkY8RZ2mCsFnM3+NGstELO3czYzaA71OI3+/4zEuk7zTK+V/4rZ\nIH5W7zJ3IiAVEcefak6KJQh9IAifCajPH9kNSc5DfsMtVjhNtnTzr/KbKRx+lwua\npMbFi9G9xz3qWI4nvWwq4eUUHCiJdsmAMdj560OQFeKdT1eDn3GZdtjBp/4zfw8t\nPVrAD3iMzJGQFUwZns1MNPV+cxuN+Hyb7AeBANGoO+BVxnAJas9QRIVeicaZhi3M\n/ulJICaHbH7mph6BqG/ba41v9Ww6jbyaNr2fjvJ1Qsu09WesIwse0kj3LDRpixg=\n=Ta6y\n-----END PGP SIGNATURE-----\n", "payload": "tree 6b4b624ddf312c23b61849510ca204617b0ade1e\nparent 72b8a31cae896c6ba145a09172ebc994b79d0bf5\nparent 62ee0ea0b6b1fe60044c623066d3ea4169fed814\nauthor Ralf Jung <post@ralfj.de> 1588414090 +0200\ncommitter GitHub <noreply@github.com> 1588414090 +0200\n\nRollup merge of #71738 - RalfJung:pointer-no-alloc-id, r=oli-obk\n\nremove AllocId generalization of Pointer\n\nThis was only needed for the \"snapshot\" machinery, which is gone.\n\nr? @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6616e2ca27b945773cdb685a4726a1b03ff4afbb", "html_url": "https://github.com/rust-lang/rust/commit/6616e2ca27b945773cdb685a4726a1b03ff4afbb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6616e2ca27b945773cdb685a4726a1b03ff4afbb/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72b8a31cae896c6ba145a09172ebc994b79d0bf5", "url": "https://api.github.com/repos/rust-lang/rust/commits/72b8a31cae896c6ba145a09172ebc994b79d0bf5", "html_url": "https://github.com/rust-lang/rust/commit/72b8a31cae896c6ba145a09172ebc994b79d0bf5"}, {"sha": "62ee0ea0b6b1fe60044c623066d3ea4169fed814", "url": "https://api.github.com/repos/rust-lang/rust/commits/62ee0ea0b6b1fe60044c623066d3ea4169fed814", "html_url": "https://github.com/rust-lang/rust/commit/62ee0ea0b6b1fe60044c623066d3ea4169fed814"}], "stats": {"total": 74, "additions": 34, "deletions": 40}, "files": [{"sha": "0b06005649979c9f3a04bd4fdadce852c1032c39", "filename": "src/librustc_middle/mir/interpret/pointer.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6616e2ca27b945773cdb685a4726a1b03ff4afbb/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6616e2ca27b945773cdb685a4726a1b03ff4afbb/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fpointer.rs?ref=6616e2ca27b945773cdb685a4726a1b03ff4afbb", "patch": "@@ -75,18 +75,14 @@ pub trait PointerArithmetic: HasDataLayout {\n \n impl<T: HasDataLayout> PointerArithmetic for T {}\n \n-/// `Pointer` is generic over the type that represents a reference to `Allocation`s,\n-/// thus making it possible for the most convenient representation to be used in\n-/// each context.\n+/// Represents a pointer in the Miri engine.\n ///\n-/// Defaults to the index based and loosely coupled `AllocId`.\n-///\n-/// `Pointer` is also generic over the `Tag` associated with each pointer,\n+/// `Pointer` is generic over the `Tag` associated with each pointer,\n /// which is used to do provenance tracking during execution.\n #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n #[derive(HashStable)]\n-pub struct Pointer<Tag = (), Id = AllocId> {\n-    pub alloc_id: Id,\n+pub struct Pointer<Tag = ()> {\n+    pub alloc_id: AllocId,\n     pub offset: Size,\n     pub tag: Tag,\n }\n@@ -97,7 +93,7 @@ static_assert_size!(Pointer, 16);\n // all the Miri types.\n // We have to use `Debug` output for the tag, because `()` does not implement\n // `Display` so we cannot specialize that.\n-impl<Tag: fmt::Debug, Id: fmt::Debug> fmt::Debug for Pointer<Tag, Id> {\n+impl<Tag: fmt::Debug> fmt::Debug for Pointer<Tag> {\n     default fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         if f.alternate() {\n             write!(f, \"{:#?}+0x{:x}[{:?}]\", self.alloc_id, self.offset.bytes(), self.tag)\n@@ -107,7 +103,7 @@ impl<Tag: fmt::Debug, Id: fmt::Debug> fmt::Debug for Pointer<Tag, Id> {\n     }\n }\n // Specialization for no tag\n-impl<Id: fmt::Debug> fmt::Debug for Pointer<(), Id> {\n+impl fmt::Debug for Pointer<()> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         if f.alternate() {\n             write!(f, \"{:#?}+0x{:x}\", self.alloc_id, self.offset.bytes())"}, {"sha": "ed779d52fb50c96a69c3ccda663ae91fa31ea904", "filename": "src/librustc_middle/mir/interpret/value.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6616e2ca27b945773cdb685a4726a1b03ff4afbb/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6616e2ca27b945773cdb685a4726a1b03ff4afbb/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs?ref=6616e2ca27b945773cdb685a4726a1b03ff4afbb", "patch": "@@ -89,7 +89,7 @@ impl<'tcx> ConstValue<'tcx> {\n /// of a simple value or a pointer into another `Allocation`\n #[derive(Clone, Copy, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n #[derive(HashStable)]\n-pub enum Scalar<Tag = (), Id = AllocId> {\n+pub enum Scalar<Tag = ()> {\n     /// The raw bytes of a simple value.\n     Raw {\n         /// The first `size` bytes of `data` are the value.\n@@ -101,15 +101,15 @@ pub enum Scalar<Tag = (), Id = AllocId> {\n     /// A pointer into an `Allocation`. An `Allocation` in the `memory` module has a list of\n     /// relocations, but a `Scalar` is only large enough to contain one, so we just represent the\n     /// relocation and its associated offset together as a `Pointer` here.\n-    Ptr(Pointer<Tag, Id>),\n+    Ptr(Pointer<Tag>),\n }\n \n #[cfg(target_arch = \"x86_64\")]\n static_assert_size!(Scalar, 24);\n \n // We want the `Debug` output to be readable as it is used by `derive(Debug)` for\n // all the Miri types.\n-impl<Tag: fmt::Debug, Id: fmt::Debug> fmt::Debug for Scalar<Tag, Id> {\n+impl<Tag: fmt::Debug> fmt::Debug for Scalar<Tag> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             Scalar::Ptr(ptr) => write!(f, \"{:?}\", ptr),\n@@ -542,8 +542,8 @@ impl<Tag> From<Pointer<Tag>> for Scalar<Tag> {\n }\n \n #[derive(Clone, Copy, Eq, PartialEq, RustcEncodable, RustcDecodable, HashStable, Hash)]\n-pub enum ScalarMaybeUndef<Tag = (), Id = AllocId> {\n-    Scalar(Scalar<Tag, Id>),\n+pub enum ScalarMaybeUndef<Tag = ()> {\n+    Scalar(Scalar<Tag>),\n     Undef,\n }\n \n@@ -563,7 +563,7 @@ impl<Tag> From<Pointer<Tag>> for ScalarMaybeUndef<Tag> {\n \n // We want the `Debug` output to be readable as it is used by `derive(Debug)` for\n // all the Miri types.\n-impl<Tag: fmt::Debug, Id: fmt::Debug> fmt::Debug for ScalarMaybeUndef<Tag, Id> {\n+impl<Tag: fmt::Debug> fmt::Debug for ScalarMaybeUndef<Tag> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             ScalarMaybeUndef::Undef => write!(f, \"<uninitialized>\"),"}, {"sha": "f668bafe0803f02a939b8217f444ffd737afef56", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6616e2ca27b945773cdb685a4726a1b03ff4afbb/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6616e2ca27b945773cdb685a4726a1b03ff4afbb/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=6616e2ca27b945773cdb685a4726a1b03ff4afbb", "patch": "@@ -11,7 +11,7 @@ use rustc_macros::HashStable;\n use rustc_middle::ich::StableHashingContext;\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::{\n-    sign_extend, truncate, AllocId, FrameInfo, GlobalId, InterpResult, Pointer, Scalar,\n+    sign_extend, truncate, FrameInfo, GlobalId, InterpResult, Pointer, Scalar,\n };\n use rustc_middle::ty::layout::{self, TyAndLayout};\n use rustc_middle::ty::{\n@@ -103,16 +103,16 @@ pub enum StackPopCleanup {\n \n /// State of a local variable including a memoized layout\n #[derive(Clone, PartialEq, Eq, HashStable)]\n-pub struct LocalState<'tcx, Tag = (), Id = AllocId> {\n-    pub value: LocalValue<Tag, Id>,\n+pub struct LocalState<'tcx, Tag = ()> {\n+    pub value: LocalValue<Tag>,\n     /// Don't modify if `Some`, this is only used to prevent computing the layout twice\n     #[stable_hasher(ignore)]\n     pub layout: Cell<Option<TyAndLayout<'tcx>>>,\n }\n \n /// Current value of a local variable\n #[derive(Copy, Clone, PartialEq, Eq, Debug, HashStable)] // Miri debug-prints these\n-pub enum LocalValue<Tag = (), Id = AllocId> {\n+pub enum LocalValue<Tag = ()> {\n     /// This local is not currently alive, and cannot be used at all.\n     Dead,\n     /// This local is alive but not yet initialized. It can be written to\n@@ -125,7 +125,7 @@ pub enum LocalValue<Tag = (), Id = AllocId> {\n     /// This is an optimization over just always having a pointer here;\n     /// we can thus avoid doing an allocation when the local just stores\n     /// immediate values *and* never has its address taken.\n-    Live(Operand<Tag, Id>),\n+    Live(Operand<Tag>),\n }\n \n impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {"}, {"sha": "e2fb9de486f098fd2d440aec7cc6d7674eccf4f5", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6616e2ca27b945773cdb685a4726a1b03ff4afbb/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6616e2ca27b945773cdb685a4726a1b03ff4afbb/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=6616e2ca27b945773cdb685a4726a1b03ff4afbb", "patch": "@@ -15,8 +15,8 @@ use rustc_target::abi::{Abi, DiscriminantKind, HasDataLayout, Integer, LayoutOf,\n use rustc_target::abi::{VariantIdx, Variants};\n \n use super::{\n-    from_known_layout, sign_extend, truncate, AllocId, ConstValue, GlobalId, InterpCx,\n-    InterpResult, MPlaceTy, Machine, MemPlace, Place, PlaceTy, Pointer, Scalar, ScalarMaybeUndef,\n+    from_known_layout, sign_extend, truncate, ConstValue, GlobalId, InterpCx, InterpResult,\n+    MPlaceTy, Machine, MemPlace, Place, PlaceTy, Pointer, Scalar, ScalarMaybeUndef,\n };\n \n /// An `Immediate` represents a single immediate self-contained Rust value.\n@@ -27,9 +27,9 @@ use super::{\n /// In particular, thanks to `ScalarPair`, arithmetic operations and casts can be entirely\n /// defined on `Immediate`, and do not have to work with a `Place`.\n #[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable, Hash)]\n-pub enum Immediate<Tag = (), Id = AllocId> {\n-    Scalar(ScalarMaybeUndef<Tag, Id>),\n-    ScalarPair(ScalarMaybeUndef<Tag, Id>, ScalarMaybeUndef<Tag, Id>),\n+pub enum Immediate<Tag = ()> {\n+    Scalar(ScalarMaybeUndef<Tag>),\n+    ScalarPair(ScalarMaybeUndef<Tag>, ScalarMaybeUndef<Tag>),\n }\n \n impl<Tag> From<ScalarMaybeUndef<Tag>> for Immediate<Tag> {\n@@ -145,9 +145,9 @@ impl<'tcx, Tag> ::std::ops::Deref for ImmTy<'tcx, Tag> {\n /// or still in memory. The latter is an optimization, to delay reading that chunk of\n /// memory and to avoid having to store arbitrary-sized data here.\n #[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable, Hash)]\n-pub enum Operand<Tag = (), Id = AllocId> {\n-    Immediate(Immediate<Tag, Id>),\n-    Indirect(MemPlace<Tag, Id>),\n+pub enum Operand<Tag = ()> {\n+    Immediate(Immediate<Tag>),\n+    Indirect(MemPlace<Tag>),\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]"}, {"sha": "fee9ca0c02e39d3170f4b0eaa1f33fc97c908900", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6616e2ca27b945773cdb685a4726a1b03ff4afbb/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6616e2ca27b945773cdb685a4726a1b03ff4afbb/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=6616e2ca27b945773cdb685a4726a1b03ff4afbb", "patch": "@@ -20,9 +20,9 @@ use super::{\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable)]\n /// Information required for the sound usage of a `MemPlace`.\n-pub enum MemPlaceMeta<Tag = (), Id = AllocId> {\n+pub enum MemPlaceMeta<Tag = ()> {\n     /// The unsized payload (e.g. length for slices or vtable pointer for trait objects).\n-    Meta(Scalar<Tag, Id>),\n+    Meta(Scalar<Tag>),\n     /// `Sized` types or unsized `extern type`\n     None,\n     /// The address of this place may not be taken. This protects the `MemPlace` from coming from\n@@ -32,8 +32,8 @@ pub enum MemPlaceMeta<Tag = (), Id = AllocId> {\n     Poison,\n }\n \n-impl<Tag, Id> MemPlaceMeta<Tag, Id> {\n-    pub fn unwrap_meta(self) -> Scalar<Tag, Id> {\n+impl<Tag> MemPlaceMeta<Tag> {\n+    pub fn unwrap_meta(self) -> Scalar<Tag> {\n         match self {\n             Self::Meta(s) => s,\n             Self::None | Self::Poison => {\n@@ -47,9 +47,7 @@ impl<Tag, Id> MemPlaceMeta<Tag, Id> {\n             Self::None | Self::Poison => false,\n         }\n     }\n-}\n \n-impl<Tag> MemPlaceMeta<Tag> {\n     pub fn erase_tag(self) -> MemPlaceMeta<()> {\n         match self {\n             Self::Meta(s) => MemPlaceMeta::Meta(s.erase_tag()),\n@@ -60,22 +58,22 @@ impl<Tag> MemPlaceMeta<Tag> {\n }\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable)]\n-pub struct MemPlace<Tag = (), Id = AllocId> {\n+pub struct MemPlace<Tag = ()> {\n     /// A place may have an integral pointer for ZSTs, and since it might\n     /// be turned back into a reference before ever being dereferenced.\n     /// However, it may never be undef.\n-    pub ptr: Scalar<Tag, Id>,\n+    pub ptr: Scalar<Tag>,\n     pub align: Align,\n     /// Metadata for unsized places. Interpretation is up to the type.\n     /// Must not be present for sized types, but can be missing for unsized types\n     /// (e.g., `extern type`).\n-    pub meta: MemPlaceMeta<Tag, Id>,\n+    pub meta: MemPlaceMeta<Tag>,\n }\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable)]\n-pub enum Place<Tag = (), Id = AllocId> {\n+pub enum Place<Tag = ()> {\n     /// A place referring to a value allocated in the `Memory` system.\n-    Ptr(MemPlace<Tag, Id>),\n+    Ptr(MemPlace<Tag>),\n \n     /// To support alloc-free locals, we are able to write directly to a local.\n     /// (Without that optimization, we'd just always be a `MemPlace`.)"}]}