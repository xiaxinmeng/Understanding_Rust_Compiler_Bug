{"sha": "582a369bc336b1eb3aab0cfaabf4fb4359b68492", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4MmEzNjliYzMzNmIxZWIzYWFiMGNmYWFiZjRmYjQzNTliNjg0OTI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-17T20:57:41Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-26T13:38:26Z"}, "message": "encapsulate `infcx` too into the delegate", "tree": {"sha": "45b61649115cd5a0573798c7dca7c3c20ec5cf5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45b61649115cd5a0573798c7dca7c3c20ec5cf5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/582a369bc336b1eb3aab0cfaabf4fb4359b68492", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/582a369bc336b1eb3aab0cfaabf4fb4359b68492", "html_url": "https://github.com/rust-lang/rust/commit/582a369bc336b1eb3aab0cfaabf4fb4359b68492", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/582a369bc336b1eb3aab0cfaabf4fb4359b68492/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6f4513804c022150f24fd2c65747e807d430e19", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6f4513804c022150f24fd2c65747e807d430e19", "html_url": "https://github.com/rust-lang/rust/commit/c6f4513804c022150f24fd2c65747e807d430e19"}], "stats": {"total": 118, "additions": 84, "deletions": 34}, "files": [{"sha": "39e3403136360353f306502992623af90215b6d7", "filename": "src/librustc_mir/borrow_check/nll/type_check/relate_tys.rs", "status": "modified", "additions": 84, "deletions": 34, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/582a369bc336b1eb3aab0cfaabf4fb4359b68492/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582a369bc336b1eb3aab0cfaabf4fb4359b68492/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs?ref=582a369bc336b1eb3aab0cfaabf4fb4359b68492", "patch": "@@ -31,8 +31,8 @@ pub(super) fn sub_types<'tcx>(\n ) -> Fallible<()> {\n     debug!(\"sub_types(a={:?}, b={:?}, locations={:?})\", a, b, locations);\n     TypeRelating::new(\n-        infcx,\n-        NllTypeRelatingDelegate::new(borrowck_context, locations, category),\n+        infcx.tcx,\n+        NllTypeRelatingDelegate::new(infcx, borrowck_context, locations, category),\n         ty::Variance::Covariant,\n         ty::List::empty(),\n     ).relate(&a, &b)?;\n@@ -50,8 +50,8 @@ pub(super) fn eq_types<'tcx>(\n ) -> Fallible<()> {\n     debug!(\"eq_types(a={:?}, b={:?}, locations={:?})\", a, b, locations);\n     TypeRelating::new(\n-        infcx,\n-        NllTypeRelatingDelegate::new(borrowck_context, locations, category),\n+        infcx.tcx,\n+        NllTypeRelatingDelegate::new(infcx, borrowck_context, locations, category),\n         ty::Variance::Invariant,\n         ty::List::empty(),\n     ).relate(&a, &b)?;\n@@ -85,8 +85,8 @@ pub(super) fn relate_type_and_user_type<'tcx>(\n     let v1 = ty::Contravariant.xform(v);\n \n     TypeRelating::new(\n-        infcx,\n-        NllTypeRelatingDelegate::new(borrowck_context, locations, category),\n+        infcx.tcx,\n+        NllTypeRelatingDelegate::new(infcx, borrowck_context, locations, category),\n         v1,\n         b_variables,\n     ).relate(&b_value, &a)?;\n@@ -97,7 +97,7 @@ struct TypeRelating<'me, 'gcx: 'tcx, 'tcx: 'me, D>\n where\n     D: TypeRelatingDelegate<'tcx>,\n {\n-    infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'me, 'gcx, 'tcx>,\n \n     /// Callback to use when we deduce an outlives relationship\n     delegate: D,\n@@ -140,10 +140,37 @@ where\n }\n \n trait TypeRelatingDelegate<'tcx> {\n+    /// Push a constraint `sup: sub` -- this constraint must be\n+    /// satisfied for the two types to be related. `sub` and `sup` may\n+    /// be regions from the type or new variables created through the\n+    /// delegate.\n     fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>);\n+\n+    /// Creates a new region variable representing an instantiated\n+    /// higher-ranked region; this will be either existential or\n+    /// universal depending on the context.  So e.g. if you have\n+    /// `for<'a> fn(..) <: for<'b> fn(..)`, then we will first\n+    /// instantiate `'b` with a universally quantitifed region and\n+    /// then `'a` with an existentially quantified region (the order\n+    /// is important so that the existential region `'a` can see the\n+    /// universal one).\n+    fn next_region_var(\n+        &mut self,\n+        universally_quantified: UniversallyQuantified,\n+    ) -> ty::Region<'tcx>;\n+\n+    /// Creates a new existential region in the given universe. This\n+    /// is used when handling subtyping and type variables -- if we\n+    /// have that `?X <: Foo<'a>`, for example, we would instantiate\n+    /// `?X` with a type like `Foo<'?0>` where `'?0` is a fresh\n+    /// existential variable created by this function. We would then\n+    /// relate `Foo<'?0>` with `Foo<'a>` (and probably add an outlives\n+    /// relation stating that `'?0: 'a`).\n+    fn generalize_existential(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx>;\n }\n \n-struct NllTypeRelatingDelegate<'me, 'bccx: 'me, 'tcx: 'bccx> {\n+struct NllTypeRelatingDelegate<'me, 'bccx: 'me, 'gcx: 'tcx, 'tcx: 'bccx> {\n+    infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n     borrowck_context: Option<&'me mut BorrowCheckContext<'bccx, 'tcx>>,\n \n     /// Where (and why) is this relation taking place?\n@@ -153,21 +180,40 @@ struct NllTypeRelatingDelegate<'me, 'bccx: 'me, 'tcx: 'bccx> {\n     category: ConstraintCategory,\n }\n \n-impl NllTypeRelatingDelegate<'me, 'bccx, 'tcx> {\n+impl NllTypeRelatingDelegate<'me, 'bccx, 'gcx, 'tcx> {\n     fn new(\n+        infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n         borrowck_context: Option<&'me mut BorrowCheckContext<'bccx, 'tcx>>,\n         locations: Locations,\n         category: ConstraintCategory,\n     ) -> Self {\n         Self {\n+            infcx,\n             borrowck_context,\n             locations,\n             category,\n         }\n     }\n }\n \n-impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx> {\n+impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, '_, 'tcx> {\n+    fn next_region_var(\n+        &mut self,\n+        universally_quantified: UniversallyQuantified,\n+    ) -> ty::Region<'tcx> {\n+        let origin = if universally_quantified.0 {\n+            NLLRegionVariableOrigin::BoundRegion(self.infcx.create_subuniverse())\n+        } else {\n+            NLLRegionVariableOrigin::Existential\n+        };\n+        self.infcx.next_nll_region_var(origin)\n+    }\n+\n+    fn generalize_existential(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx> {\n+        self.infcx\n+            .next_nll_region_var_in_universe(NLLRegionVariableOrigin::Existential, universe)\n+    }\n+\n     fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>) {\n         if let Some(borrowck_context) = &mut self.borrowck_context {\n             let sub = borrowck_context.universal_regions.to_region_vid(sub);\n@@ -206,14 +252,14 @@ where\n     D: TypeRelatingDelegate<'tcx>,\n {\n     fn new(\n-        infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'me, 'gcx, 'tcx>,\n         delegate: D,\n         ambient_variance: ty::Variance,\n         canonical_var_infos: CanonicalVarInfos<'tcx>,\n     ) -> Self {\n         let canonical_var_values = IndexVec::from_elem_n(None, canonical_var_infos.len());\n         Self {\n-            infcx,\n+            tcx,\n             delegate,\n             ambient_variance,\n             canonical_var_values,\n@@ -243,7 +289,7 @@ where\n     ) -> BoundRegionScope<'tcx> {\n         let mut scope = BoundRegionScope::default();\n         value.skip_binder().visit_with(&mut ScopeInstantiator {\n-            infcx: self.infcx,\n+            delegate: &mut self.delegate,\n             target_index: ty::INNERMOST,\n             universally_quantified,\n             bound_region_scope: &mut scope,\n@@ -335,9 +381,10 @@ where\n         return result;\n     }\n \n-    fn generalize_value(&self, kind: Kind<'tcx>) -> Kind<'tcx> {\n+    fn generalize_value(&mut self, kind: Kind<'tcx>) -> Kind<'tcx> {\n         TypeGeneralizer {\n-            type_rel: self,\n+            tcx: self.tcx,\n+            delegate: &mut self.delegate,\n             first_free_index: ty::INNERMOST,\n             ambient_variance: self.ambient_variance,\n \n@@ -354,7 +401,7 @@ where\n     D: TypeRelatingDelegate<'tcx>,\n {\n     fn tcx(&self) -> TyCtxt<'me, 'gcx, 'tcx> {\n-        self.infcx.tcx\n+        self.tcx\n     }\n \n     fn tag(&self) -> &'static str {\n@@ -559,15 +606,21 @@ where\n /// binder depth, and finds late-bound regions targeting the\n /// `for<..`>.  For each of those, it creates an entry in\n /// `bound_region_scope`.\n-struct ScopeInstantiator<'me, 'gcx: 'tcx, 'tcx: 'me> {\n-    infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n+struct ScopeInstantiator<'me, 'tcx: 'me, D>\n+where\n+    D: TypeRelatingDelegate<'tcx> + 'me,\n+{\n+    delegate: &'me mut D,\n     // The debruijn index of the scope we are instantiating.\n     target_index: ty::DebruijnIndex,\n     universally_quantified: UniversallyQuantified,\n     bound_region_scope: &'me mut BoundRegionScope<'tcx>,\n }\n \n-impl<'me, 'gcx, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'me, 'gcx, 'tcx> {\n+impl<'me, 'tcx, D> TypeVisitor<'tcx> for ScopeInstantiator<'me, 'tcx, D>\n+where\n+    D: TypeRelatingDelegate<'tcx>,\n+{\n     fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> bool {\n         self.target_index.shift_in(1);\n         t.super_visit_with(self);\n@@ -578,21 +631,18 @@ impl<'me, 'gcx, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'me, 'gcx, 'tcx> {\n \n     fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n         let ScopeInstantiator {\n-            infcx,\n             universally_quantified,\n+            bound_region_scope,\n+            delegate,\n             ..\n-        } = *self;\n+        } = self;\n \n         match r {\n             ty::ReLateBound(debruijn, br) if *debruijn == self.target_index => {\n-                self.bound_region_scope.map.entry(*br).or_insert_with(|| {\n-                    let origin = if universally_quantified.0 {\n-                        NLLRegionVariableOrigin::BoundRegion(infcx.create_subuniverse())\n-                    } else {\n-                        NLLRegionVariableOrigin::Existential\n-                    };\n-                    infcx.next_nll_region_var(origin)\n-                });\n+                bound_region_scope\n+                    .map\n+                    .entry(*br)\n+                    .or_insert_with(|| delegate.next_region_var(*universally_quantified));\n             }\n \n             _ => {}\n@@ -625,7 +675,9 @@ struct TypeGeneralizer<'me, 'gcx: 'tcx, 'tcx: 'me, D>\n where\n     D: TypeRelatingDelegate<'tcx> + 'me,\n {\n-    type_rel: &'me TypeRelating<'me, 'gcx, 'tcx, D>,\n+    tcx: TyCtxt<'me, 'gcx, 'tcx>,\n+\n+    delegate: &'me mut D,\n \n     /// After we generalize this type, we are going to relative it to\n     /// some other type. What will be the variance at this point?\n@@ -641,7 +693,7 @@ where\n     D: TypeRelatingDelegate<'tcx>,\n {\n     fn tcx(&self) -> TyCtxt<'me, 'gcx, 'tcx> {\n-        self.type_rel.infcx.tcx\n+        self.tcx\n     }\n \n     fn tag(&self) -> &'static str {\n@@ -724,9 +776,7 @@ where\n         // though, we may however need to check well-formedness or\n         // risk a problem like #41677 again.\n \n-        let replacement_region_vid = self.type_rel\n-            .infcx\n-            .next_nll_region_var_in_universe(NLLRegionVariableOrigin::Existential, self.universe);\n+        let replacement_region_vid = self.delegate.generalize_existential(self.universe);\n \n         Ok(replacement_region_vid)\n     }"}]}