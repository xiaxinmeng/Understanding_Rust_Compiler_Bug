{"sha": "bc87ecf11086704744f554a6d4b1ba323a89a7a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjODdlY2YxMTA4NjcwNDc0NGY1NTRhNmQ0YjFiYTMyM2E4OWE3YTA=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-19T23:06:23Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-19T23:07:12Z"}, "message": "rustc: Unify variables using a single type instead of keeping a list and doing it all at the end. This will give us better error messages.", "tree": {"sha": "f11cb2eb8cd4d9dac845131a27ac3eb4ba82a9df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f11cb2eb8cd4d9dac845131a27ac3eb4ba82a9df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc87ecf11086704744f554a6d4b1ba323a89a7a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc87ecf11086704744f554a6d4b1ba323a89a7a0", "html_url": "https://github.com/rust-lang/rust/commit/bc87ecf11086704744f554a6d4b1ba323a89a7a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc87ecf11086704744f554a6d4b1ba323a89a7a0/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b95584df5c878f716743eb9c60ad5df77af8b18", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b95584df5c878f716743eb9c60ad5df77af8b18", "html_url": "https://github.com/rust-lang/rust/commit/6b95584df5c878f716743eb9c60ad5df77af8b18"}], "stats": {"total": 150, "additions": 106, "deletions": 44}, "files": [{"sha": "6b0d7f64909cd9fae8839dbfe7ec49f06ebecdac", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 105, "deletions": 42, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/bc87ecf11086704744f554a6d4b1ba323a89a7a0/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87ecf11086704744f554a6d4b1ba323a89a7a0/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=bc87ecf11086704744f554a6d4b1ba323a89a7a0", "patch": "@@ -1,3 +1,4 @@\n+import std::int;\n import std::str;\n import std::uint;\n import std::vec;\n@@ -1878,18 +1879,48 @@ mod unify {\n         ures_err(type_err, t, t);\n     }\n \n+    tag set_result {\n+        usr_ok(vec[t]);\n+        usr_err(type_err, t, t);\n+    }\n+\n     type bindings[T] = rec(ufind::ufind sets,\n                            hashmap[T,uint] ids,\n-                           mutable vec[mutable vec[t]] types);\n+                           mutable vec[mutable option::t[t]] types);\n \n     fn mk_bindings[T](map::hashfn[T] hasher, map::eqfn[T] eqer)\n             -> @bindings[T] {\n-        let vec[mutable vec[t]] types = [mutable];\n+        let vec[mutable option::t[t]] types = [mutable];\n         ret @rec(sets=ufind::make(),\n                  ids=map::mk_hashmap[T,uint](hasher, eqer),\n                  mutable types=types);\n     }\n \n+    fn record_binding[T](&@ctxt cx, &@bindings[T] bindings, &T key, t typ)\n+            -> result {\n+        auto n = get_or_create_set[T](bindings, key);\n+\n+        auto result_type = typ;\n+        if (n < vec::len[option::t[t]](bindings.types)) {\n+            alt (bindings.types.(n)) {\n+                case (some[t](?old_type)) {\n+                    alt (unify_step(cx, old_type, typ)) {\n+                        case (ures_ok(?unified_type)) {\n+                            result_type = unified_type;\n+                        }\n+                        case (?res) { ret res; }\n+                    }\n+                }\n+                case (none[t]) { /* fall through */ }\n+            }\n+        }\n+\n+        vec::grow_set[option::t[t]](bindings.types, n, none[t],\n+                                    some[t](result_type));\n+\n+        ret ures_ok(typ);\n+    }\n+\n     type ctxt = rec(@bindings[int] bindings,\n                     unify_handler handler,\n                     ty_ctxt tcx);\n@@ -2091,12 +2122,12 @@ mod unify {\n       ret ures_ok(t);\n     }\n \n-    fn get_or_create_set(&@ctxt cx, int id) -> uint {\n+    fn get_or_create_set[T](&@bindings[T] bindings, &T key) -> uint {\n         auto set_num;\n-        alt (cx.bindings.ids.find(id)) {\n+        alt (bindings.ids.find(key)) {\n             case (none[uint]) {\n-                set_num = ufind::make_set(cx.bindings.sets);\n-                cx.bindings.ids.insert(id, set_num);\n+                set_num = ufind::make_set(bindings.sets);\n+                bindings.ids.insert(key, set_num);\n             }\n             case (some[uint](?n)) { set_num = n; }\n         }\n@@ -2117,21 +2148,21 @@ mod unify {\n             // If the RHS is a variable type, then just do the appropriate\n             // binding.\n             case (ty::ty_var(?actual_id)) {\n-                auto actual_n = get_or_create_set(cx, actual_id);\n+                auto actual_n = get_or_create_set[int](cx.bindings,\n+                                                       actual_id);\n                 alt (struct(cx.tcx, expected)) {\n                     case (ty::ty_var(?expected_id)) {\n-                        auto expected_n = get_or_create_set(cx, expected_id);\n+                        auto expected_n = get_or_create_set[int](cx.bindings,\n+                                                                 expected_id);\n                         ufind::union(cx.bindings.sets, expected_n, actual_n);\n                     }\n \n                     case (_) {\n                         // Just bind the type variable to the expected type.\n-                        auto vlen = vec::len[vec[t]](cx.bindings.types);\n-                        if (actual_n < vlen) {\n-                            cx.bindings.types.(actual_n) += [expected];\n-                        } else {\n-                            assert (actual_n == vlen);\n-                            cx.bindings.types += [mutable [expected]];\n+                        alt (record_binding[int](cx, cx.bindings, actual_id,\n+                                                 expected)) {\n+                            case (ures_ok(_)) { /* fall through */ }\n+                            case (?res) { ret res; }\n                         }\n                     }\n                 }\n@@ -2493,14 +2524,11 @@ mod unify {\n             }\n \n             case (ty::ty_var(?expected_id)) {\n-                // Add a binding.\n-                auto expected_n = get_or_create_set(cx, expected_id);\n-                auto vlen = vec::len[vec[t]](cx.bindings.types);\n-                if (expected_n < vlen) {\n-                    cx.bindings.types.(expected_n) += [actual];\n-                } else {\n-                    assert (expected_n == vlen);\n-                    cx.bindings.types += [mutable [actual]];\n+                // Add a binding. (`actual` can't actually be a var here.)\n+                alt (record_binding[int](cx, cx.bindings, expected_id,\n+                                         actual)) {\n+                    case (ures_ok(_)) { /* fall through */ }\n+                    case (?res) { ret res; }\n                 }\n                 ret ures_ok(expected);\n             }\n@@ -2562,32 +2590,63 @@ mod unify {\n         ret fold_ty(tcx, f, typ);\n     }\n \n-    fn unify_sets[T](&@bindings[T] bindings) -> vec[t] {\n-        let vec[mutable vec[t]] set_types = [mutable];\n-\n-        for (ufind::node node in bindings.sets.nodes) {\n-            let vec[t] v = [];\n-            set_types += [mutable v];\n+    fn unify_sets[T](&ty_ctxt tcx, &@bindings[T] bindings) -> set_result {\n+        obj handler() {\n+            fn resolve_local(ast::def_id id) -> option::t[t] {\n+                log_err \"resolve_local in unify_sets\";\n+                fail;\n+            }\n+            fn record_local(ast::def_id id, t ty) {\n+                log_err \"record_local in unify_sets\";\n+                fail;\n+            }\n+            fn record_param(uint index, t binding) -> unify::result {\n+                log_err \"record_param in unify_sets\";\n+                fail;\n+            }\n         }\n \n+        auto node_count = vec::len[option::t[t]](bindings.types);\n+\n+        let vec[option::t[t]] results =\n+            vec::init_elt[option::t[t]](none[t], node_count);\n+\n         auto i = 0u;\n-        while (i < vec::len[vec[t]](set_types)) {\n+        while (i < node_count) {\n             auto root = ufind::find(bindings.sets, i);\n-            set_types.(root) += bindings.types.(i);\n+            alt (bindings.types.(i)) {\n+                case (none[t]) { /* nothing to do */ }\n+                case (some[t](?actual)) {\n+                    alt (results.(root)) {\n+                        case (none[t]) { results.(root) = some[t](actual); }\n+                        case (some[t](?expected)) {\n+                            // FIXME: Is this right?\n+                            auto bindings = mk_bindings[int](int::hash,\n+                                                             int::eq_alias);\n+                            alt (unify(expected, actual, handler(), bindings,\n+                                    tcx)) {\n+                                case (ures_ok(?result_ty)) {\n+                                    results.(i) = some[t](result_ty);\n+                                }\n+                                case (ures_err(?e, ?t_a, ?t_b)) {\n+                                    ret usr_err(e, t_a, t_b);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n             i += 1u;\n         }\n \n-        let vec[t] result = [];\n-        for (vec[t] types in set_types) {\n-            if (vec::len[t](types) > 1u) {\n-                log_err \"unification of > 1 types in a type set is \" +\n-                    \"unimplemented\";\n-                fail;\n-            }\n-            result += [types.(0)];\n+        // FIXME: This is equivalent to map(option::get, results) but it\n+        // causes an assertion in typeck at the moment.\n+        let vec[t] real_results = [];\n+        for (option::t[t] typ in results) {\n+            real_results += [option::get[t](typ)];\n         }\n \n-        ret result;\n+        ret usr_ok(real_results);\n     }\n \n     fn unify(&t expected,\n@@ -2599,9 +2658,13 @@ mod unify {\n         ret unify_step(cx, expected, actual);\n     }\n \n-    fn fixup(&ty_ctxt tcx, &@bindings[int] bindings, t typ) -> t {\n-        auto set_types = unify_sets[int](bindings);\n-        ret substitute(tcx, bindings, set_types, typ);\n+    fn fixup(&ty_ctxt tcx, &@bindings[int] bindings, t typ) -> result {\n+        alt (unify_sets[int](tcx, bindings)) {\n+            case (usr_ok(?set_types)) {\n+                ret ures_ok(substitute(tcx, bindings, set_types, typ));\n+            }\n+            case (usr_err(?terr, ?t0, ?t1)) { ret ures_err(terr, t0, t1); }\n+        }\n     }\n }\n "}, {"sha": "343a9190b3538c3a97faf26e4238223c6ae0c26a", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc87ecf11086704744f554a6d4b1ba323a89a7a0/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc87ecf11086704744f554a6d4b1ba323a89a7a0/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=bc87ecf11086704744f554a6d4b1ba323a89a7a0", "patch": "@@ -953,8 +953,7 @@ mod unify {\n         alt (result) {\n             case (ures_ok(?rty)) {\n                 if (ty::type_contains_vars(scx.fcx.ccx.tcx, rty)) {\n-                    result = ures_ok(ty::unify::fixup(scx.fcx.ccx.tcx,\n-                                                      bindings, rty));\n+                    result = ty::unify::fixup(scx.fcx.ccx.tcx, bindings, rty);\n                 }\n             }\n             case (_) { /* nothing */ }"}]}