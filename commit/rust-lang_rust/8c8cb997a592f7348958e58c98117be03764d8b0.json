{"sha": "8c8cb997a592f7348958e58c98117be03764d8b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjOGNiOTk3YTU5MmY3MzQ4OTU4ZTU4Yzk4MTE3YmUwMzc2NGQ4YjA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-26T11:36:52Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-22T15:07:06Z"}, "message": "Introduce a tcx() helper method to cleanup this mess.", "tree": {"sha": "f9394d39a6ca85f454566b15d2579a1f76816e79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9394d39a6ca85f454566b15d2579a1f76816e79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c8cb997a592f7348958e58c98117be03764d8b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c8cb997a592f7348958e58c98117be03764d8b0", "html_url": "https://github.com/rust-lang/rust/commit/8c8cb997a592f7348958e58c98117be03764d8b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c8cb997a592f7348958e58c98117be03764d8b0/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34d680009205de2302b902d8f9f5f7ae7a042f1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/34d680009205de2302b902d8f9f5f7ae7a042f1a", "html_url": "https://github.com/rust-lang/rust/commit/34d680009205de2302b902d8f9f5f7ae7a042f1a"}], "stats": {"total": 56, "additions": 29, "deletions": 27}, "files": [{"sha": "ca9ac10341c2a98c33b4fcac01cffe94159a8794", "filename": "src/librustc/middle/infer/coercion.rs", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8c8cb997a592f7348958e58c98117be03764d8b0/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8cb997a592f7348958e58c98117be03764d8b0/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs?ref=8c8cb997a592f7348958e58c98117be03764d8b0", "patch": "@@ -84,10 +84,14 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         let Coerce(ref v) = *self; v\n     }\n \n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n+        self.get_ref().infcx.tcx\n+    }\n+\n     pub fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n         debug!(\"Coerce.tys({} => {})\",\n-               a.repr(self.get_ref().infcx.tcx),\n-               b.repr(self.get_ref().infcx.tcx));\n+               a.repr(self.tcx()),\n+               b.repr(self.tcx()));\n \n         // Consider coercing the subtype to a DST\n         let unsize = self.unpack_actual_value(a, |a| {\n@@ -170,13 +174,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         self.unpack_actual_value(a, |a| {\n             match a.sty {\n-                ty::ty_bare_fn(ref a_f) => {\n-                    // Bare functions are coercible to any closure type.\n-                    //\n-                    // FIXME(#3320) this should go away and be\n-                    // replaced with proper inference, got a patch\n-                    // underway - ndm\n-                    self.coerce_from_bare_fn(a, a_f, b)\n+                ty::ty_bare_fn(Some(a_def_id), ref a_f) => {\n+                    // Function items are coercible to any closure\n+                    // type; function pointers are not (that would\n+                    // require double indirection).\n+                    self.coerce_from_fn_item(a, a_def_id, a_f, b)\n                 }\n                 _ => {\n                     // Otherwise, just use subtyping rules.\n@@ -206,8 +208,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                    mutbl_b: ast::Mutability)\n                                    -> CoerceResult<'tcx> {\n         debug!(\"coerce_borrowed_pointer(a={}, b={})\",\n-               a.repr(self.get_ref().infcx.tcx),\n-               b.repr(self.get_ref().infcx.tcx));\n+               a.repr(self.tcx()),\n+               b.repr(self.tcx()));\n \n         // If we have a parameter of type `&M T_a` and the value\n         // provided is `expr`, we will be adding an implicit borrow,\n@@ -227,7 +229,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             }\n         };\n \n-        let a_borrowed = ty::mk_rptr(self.get_ref().infcx.tcx,\n+        let a_borrowed = ty::mk_rptr(self.tcx(),\n                                      r_borrow,\n                                      mt {ty: inner_ty, mutbl: mutbl_b});\n         try!(sub.tys(a_borrowed, b));\n@@ -247,8 +249,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                       b: Ty<'tcx>)\n                       -> CoerceResult<'tcx> {\n         debug!(\"coerce_unsized(a={}, b={})\",\n-               a.repr(self.get_ref().infcx.tcx),\n-               b.repr(self.get_ref().infcx.tcx));\n+               a.repr(self.tcx()),\n+               b.repr(self.tcx()));\n \n         // Note, we want to avoid unnecessary unsizing. We don't want to coerce to\n         // a DST unless we have to. This currently comes out in the wash since\n@@ -268,7 +270,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n                             let coercion = Coercion(self.get_ref().trace.clone());\n                             let r_borrow = self.get_ref().infcx.next_region_var(coercion);\n-                            let ty = ty::mk_rptr(self.get_ref().infcx.tcx,\n+                            let ty = ty::mk_rptr(self.tcx(),\n                                                  r_borrow,\n                                                  ty::mt{ty: ty, mutbl: mt_b.mutbl});\n                             try!(self.get_ref().infcx.try(|_| sub.tys(ty, b)));\n@@ -292,7 +294,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                 return Err(ty::terr_mutability);\n                             }\n \n-                            let ty = ty::mk_ptr(self.get_ref().infcx.tcx,\n+                            let ty = ty::mk_ptr(self.tcx(),\n                                                  ty::mt{ty: ty, mutbl: mt_b.mutbl});\n                             try!(self.get_ref().infcx.try(|_| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n@@ -311,7 +313,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 self.unpack_actual_value(t_a, |a| {\n                     match self.unsize_ty(t_a, a, t_b) {\n                         Some((ty, kind)) => {\n-                            let ty = ty::mk_uniq(self.get_ref().infcx.tcx, ty);\n+                            let ty = ty::mk_uniq(self.tcx(), ty);\n                             try!(self.get_ref().infcx.try(|_| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                     AutoUnsizeUniq({}))\", kind);\n@@ -336,9 +338,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                  a: Ty<'tcx>,\n                  ty_b: Ty<'tcx>)\n                  -> Option<(Ty<'tcx>, ty::UnsizeKind<'tcx>)> {\n-        debug!(\"unsize_ty(a={}, ty_b={})\", a, ty_b.repr(self.get_ref().infcx.tcx));\n+        debug!(\"unsize_ty(a={}, ty_b={})\", a, ty_b.repr(self.tcx()));\n \n-        let tcx = self.get_ref().infcx.tcx;\n+        let tcx = self.tcx();\n \n         self.unpack_actual_value(ty_b, |b|\n             match (&a.sty, &b.sty) {\n@@ -412,7 +414,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                               b: Ty<'tcx>,\n                               b_mutbl: ast::Mutability) -> CoerceResult<'tcx>\n     {\n-        let tcx = self.get_ref().infcx.tcx;\n+        let tcx = self.tcx();\n \n         debug!(\"coerce_borrowed_object(a={}, b={}, b_mutbl={})\",\n                a.repr(tcx),\n@@ -431,7 +433,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                             b: Ty<'tcx>,\n                             b_mutbl: ast::Mutability) -> CoerceResult<'tcx>\n     {\n-        let tcx = self.get_ref().infcx.tcx;\n+        let tcx = self.tcx();\n \n         debug!(\"coerce_unsafe_object(a={}, b={}, b_mutbl={})\",\n                a.repr(tcx),\n@@ -451,7 +453,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         F: FnOnce(Ty<'tcx>) -> Ty<'tcx>,\n         G: FnOnce() -> ty::AutoRef<'tcx>,\n     {\n-        let tcx = self.get_ref().infcx.tcx;\n+        let tcx = self.tcx();\n \n         match a.sty {\n             ty::ty_rptr(_, ty::mt{ty, mutbl}) => match ty.sty {\n@@ -480,8 +482,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                               b: Ty<'tcx>)\n                               -> CoerceResult<'tcx> {\n         debug!(\"coerce_borrowed_fn(a={}, b={})\",\n-               a.repr(self.get_ref().infcx.tcx),\n-               b.repr(self.get_ref().infcx.tcx));\n+               a.repr(self.tcx()),\n+               b.repr(self.tcx()));\n \n         match a.sty {\n             ty::ty_bare_fn(ref f) => {\n@@ -528,8 +530,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                              mutbl_b: ast::Mutability)\n                              -> CoerceResult<'tcx> {\n         debug!(\"coerce_unsafe_ptr(a={}, b={})\",\n-               a.repr(self.get_ref().infcx.tcx),\n-               b.repr(self.get_ref().infcx.tcx));\n+               a.repr(self.tcx()),\n+               b.repr(self.tcx()));\n \n         let mt_a = match a.sty {\n             ty::ty_rptr(_, mt) | ty::ty_ptr(mt) => mt,\n@@ -539,7 +541,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         };\n \n         // Check that the types which they point at are compatible.\n-        let a_unsafe = ty::mk_ptr(self.get_ref().infcx.tcx, ty::mt{ mutbl: mutbl_b, ty: mt_a.ty });\n+        let a_unsafe = ty::mk_ptr(self.tcx(), ty::mt{ mutbl: mutbl_b, ty: mt_a.ty });\n         try!(self.subtype(a_unsafe, b));\n         if !can_coerce_mutbls(mt_a.mutbl, mutbl_b) {\n             return Err(ty::terr_mutability);"}]}