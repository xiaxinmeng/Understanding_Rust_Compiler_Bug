{"sha": "c0b7112ba246d96f253ba845d91f36c0b7398e42", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwYjcxMTJiYTI0NmQ5NmYyNTNiYTg0NWQ5MWYzNmMwYjczOThlNDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-02T20:10:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-02T20:10:40Z"}, "message": "Auto merge of #40216 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 7 pull requests\n\n- Successful merges: #39832, #40104, #40110, #40117, #40129, #40139, #40166\n- Failed merges:", "tree": {"sha": "2eb615b585a9039247b1c1f8589dd0941c75d1dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2eb615b585a9039247b1c1f8589dd0941c75d1dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0b7112ba246d96f253ba845d91f36c0b7398e42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0b7112ba246d96f253ba845d91f36c0b7398e42", "html_url": "https://github.com/rust-lang/rust/commit/c0b7112ba246d96f253ba845d91f36c0b7398e42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0b7112ba246d96f253ba845d91f36c0b7398e42/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5907ed63d329daefcd1680813d57e5ca00cd2fc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/5907ed63d329daefcd1680813d57e5ca00cd2fc2", "html_url": "https://github.com/rust-lang/rust/commit/5907ed63d329daefcd1680813d57e5ca00cd2fc2"}, {"sha": "ba39e5d905dc5a32c1156db780635612deeb2bd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba39e5d905dc5a32c1156db780635612deeb2bd0", "html_url": "https://github.com/rust-lang/rust/commit/ba39e5d905dc5a32c1156db780635612deeb2bd0"}], "stats": {"total": 555, "additions": 411, "deletions": 144}, "files": [{"sha": "dfd292176d2f9c9bd67445291b3c68d7dad9a23e", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -524,6 +524,7 @@ use string;\n pub fn format(args: Arguments) -> string::String {\n     let capacity = args.estimated_capacity();\n     let mut output = string::String::with_capacity(capacity);\n-    let _ = output.write_fmt(args);\n+    output.write_fmt(args)\n+          .expect(\"a formatting trait implementation returned an error\");\n     output\n }"}, {"sha": "396a917dfde261f87ba8823e17c533f2d0f8f660", "filename": "src/libcollections/macros.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibcollections%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibcollections%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fmacros.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -72,6 +72,12 @@ macro_rules! vec {\n ///\n /// [fmt]: ../std/fmt/index.html\n ///\n+/// # Panics\n+///\n+/// `format!` panics if a formatting trait implementation returns an error.\n+/// This indicates an incorrect implementation\n+/// since `fmt::Write for String` never returns an error itself.\n+///\n /// # Examples\n ///\n /// ```"}, {"sha": "f2e4be49684a91af99a761ee4305bc7f9d4a2fd5", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -1900,13 +1900,20 @@ pub trait ToString {\n     fn to_string(&self) -> String;\n }\n \n+/// # Panics\n+///\n+/// In this implementation, the `to_string` method panics\n+/// if the `Display` implementation returns an error.\n+/// This indicates an incorrect `Display` implementation\n+/// since `fmt::Write for String` never returns an error itself.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Display + ?Sized> ToString for T {\n     #[inline]\n     default fn to_string(&self) -> String {\n         use core::fmt::Write;\n         let mut buf = String::new();\n-        let _ = buf.write_fmt(format_args!(\"{}\", self));\n+        buf.write_fmt(format_args!(\"{}\", self))\n+           .expect(\"a Display implementation return an error unexpectedly\");\n         buf.shrink_to_fit();\n         buf\n     }"}, {"sha": "0516e111be3b38002bd924e6a7ada7c107082e4b", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -125,6 +125,10 @@ pub mod __internal {\n         fn register_attr_proc_macro(&mut self,\n                                     name: &str,\n                                     expand: fn(TokenStream, TokenStream) -> TokenStream);\n+\n+        fn register_bang_proc_macro(&mut self,\n+                                    name: &str,\n+                                    expand: fn(TokenStream) -> TokenStream);\n     }\n \n     // Emulate scoped_thread_local!() here essentially"}, {"sha": "10761a03bec0cabd1d05f7dfd669458479d85272", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -983,7 +983,7 @@ pub enum Rvalue<'tcx> {\n     Use(Operand<'tcx>),\n \n     /// [x; 32]\n-    Repeat(Operand<'tcx>, TypedConstVal<'tcx>),\n+    Repeat(Operand<'tcx>, ConstUsize),\n \n     /// &x or &mut x\n     Ref(&'tcx Region, BorrowKind, Lvalue<'tcx>),\n@@ -1038,7 +1038,8 @@ pub enum CastKind {\n \n #[derive(Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum AggregateKind<'tcx> {\n-    Array,\n+    /// The type is of the element\n+    Array(Ty<'tcx>),\n     Tuple,\n     /// The second field is variant number (discriminant), it's equal to 0\n     /// for struct and union expressions. The fourth field is active field\n@@ -1135,7 +1136,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                 }\n \n                 match *kind {\n-                    AggregateKind::Array => write!(fmt, \"{:?}\", lvs),\n+                    AggregateKind::Array(_) => write!(fmt, \"{:?}\", lvs),\n \n                     AggregateKind::Tuple => {\n                         match lvs.len() {\n@@ -1202,19 +1203,6 @@ pub struct Constant<'tcx> {\n     pub literal: Literal<'tcx>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n-pub struct TypedConstVal<'tcx> {\n-    pub ty: Ty<'tcx>,\n-    pub span: Span,\n-    pub value: ConstUsize,\n-}\n-\n-impl<'tcx> Debug for TypedConstVal<'tcx> {\n-    fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n-        write!(fmt, \"const {}\", ConstInt::Usize(self.value))\n-    }\n-}\n-\n newtype_index!(Promoted, \"promoted\");\n \n #[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]"}, {"sha": "14d3876a66e5522a1c4e07a7e659045077369163", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 19, "deletions": 25, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -134,76 +134,70 @@ impl<'tcx> Lvalue<'tcx> {\n }\n \n impl<'tcx> Rvalue<'tcx> {\n-    pub fn ty<'a, 'gcx>(&self, mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Ty<'tcx>>\n+    pub fn ty<'a, 'gcx>(&self, mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx>\n     {\n         match *self {\n-            Rvalue::Use(ref operand) => Some(operand.ty(mir, tcx)),\n+            Rvalue::Use(ref operand) => operand.ty(mir, tcx),\n             Rvalue::Repeat(ref operand, ref count) => {\n                 let op_ty = operand.ty(mir, tcx);\n-                let count = count.value.as_u64(tcx.sess.target.uint_type);\n+                let count = count.as_u64(tcx.sess.target.uint_type);\n                 assert_eq!(count as usize as u64, count);\n-                Some(tcx.mk_array(op_ty, count as usize))\n+                tcx.mk_array(op_ty, count as usize)\n             }\n             Rvalue::Ref(reg, bk, ref lv) => {\n                 let lv_ty = lv.ty(mir, tcx).to_ty(tcx);\n-                Some(tcx.mk_ref(reg,\n+                tcx.mk_ref(reg,\n                     ty::TypeAndMut {\n                         ty: lv_ty,\n                         mutbl: bk.to_mutbl_lossy()\n                     }\n-                ))\n+                )\n             }\n-            Rvalue::Len(..) => Some(tcx.types.usize),\n-            Rvalue::Cast(.., ty) => Some(ty),\n+            Rvalue::Len(..) => tcx.types.usize,\n+            Rvalue::Cast(.., ty) => ty,\n             Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n                 let lhs_ty = lhs.ty(mir, tcx);\n                 let rhs_ty = rhs.ty(mir, tcx);\n-                Some(op.ty(tcx, lhs_ty, rhs_ty))\n+                op.ty(tcx, lhs_ty, rhs_ty)\n             }\n             Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) => {\n                 let lhs_ty = lhs.ty(mir, tcx);\n                 let rhs_ty = rhs.ty(mir, tcx);\n                 let ty = op.ty(tcx, lhs_ty, rhs_ty);\n-                let ty = tcx.intern_tup(&[ty, tcx.types.bool], false);\n-                Some(ty)\n+                tcx.intern_tup(&[ty, tcx.types.bool], false)\n             }\n             Rvalue::UnaryOp(_, ref operand) => {\n-                Some(operand.ty(mir, tcx))\n+                operand.ty(mir, tcx)\n             }\n             Rvalue::Discriminant(ref lval) => {\n                 let ty = lval.ty(mir, tcx).to_ty(tcx);\n                 if let ty::TyAdt(adt_def, _) = ty.sty {\n-                    Some(adt_def.repr.discr_type().to_ty(tcx))\n+                    adt_def.repr.discr_type().to_ty(tcx)\n                 } else {\n                     // Undefined behaviour, bug for now; may want to return something for\n                     // the `discriminant` intrinsic later.\n                     bug!(\"Rvalue::Discriminant on Lvalue of type {:?}\", ty);\n                 }\n             }\n             Rvalue::Box(t) => {\n-                Some(tcx.mk_box(t))\n+                tcx.mk_box(t)\n             }\n             Rvalue::Aggregate(ref ak, ref ops) => {\n                 match *ak {\n-                    AggregateKind::Array => {\n-                        if let Some(operand) = ops.get(0) {\n-                            let ty = operand.ty(mir, tcx);\n-                            Some(tcx.mk_array(ty, ops.len()))\n-                        } else {\n-                            None\n-                        }\n+                    AggregateKind::Array(ty) => {\n+                        tcx.mk_array(ty, ops.len())\n                     }\n                     AggregateKind::Tuple => {\n-                        Some(tcx.mk_tup(\n+                        tcx.mk_tup(\n                             ops.iter().map(|op| op.ty(mir, tcx)),\n                             false\n-                        ))\n+                        )\n                     }\n                     AggregateKind::Adt(def, _, substs, _) => {\n-                        Some(tcx.item_type(def.did).subst(tcx, substs))\n+                        tcx.item_type(def.did).subst(tcx, substs)\n                     }\n                     AggregateKind::Closure(did, substs) => {\n-                        Some(tcx.mk_closure_from_closure_substs(did, substs))\n+                        tcx.mk_closure_from_closure_substs(did, substs)\n                     }\n                 }\n             }"}, {"sha": "980d1806e78f8b34d60f94bc3816044b835cf128", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 4, "deletions": 23, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -235,12 +235,6 @@ macro_rules! make_mir_visitor {\n                 self.super_const_usize(const_usize);\n             }\n \n-            fn visit_typed_const_val(&mut self,\n-                                     val: & $($mutability)* TypedConstVal<'tcx>,\n-                                     location: Location) {\n-                self.super_typed_const_val(val, location);\n-            }\n-\n             fn visit_local_decl(&mut self,\n                                 local_decl: & $($mutability)* LocalDecl<'tcx>) {\n                 self.super_local_decl(local_decl);\n@@ -467,9 +461,9 @@ macro_rules! make_mir_visitor {\n                     }\n \n                     Rvalue::Repeat(ref $($mutability)* value,\n-                                   ref $($mutability)* typed_const_val) => {\n+                                   ref $($mutability)* length) => {\n                         self.visit_operand(value, location);\n-                        self.visit_typed_const_val(typed_const_val, location);\n+                        self.visit_const_usize(length, location);\n                     }\n \n                     Rvalue::Ref(r, bk, ref $($mutability)* path) => {\n@@ -515,7 +509,8 @@ macro_rules! make_mir_visitor {\n                     Rvalue::Aggregate(ref $($mutability)* kind,\n                                       ref $($mutability)* operands) => {\n                         match *kind {\n-                            AggregateKind::Array => {\n+                            AggregateKind::Array(ref $($mutability)* ty) => {\n+                                self.visit_ty(ty);\n                             }\n                             AggregateKind::Tuple => {\n                             }\n@@ -647,20 +642,6 @@ macro_rules! make_mir_visitor {\n                 self.visit_literal(literal, location);\n             }\n \n-            fn super_typed_const_val(&mut self,\n-                                     constant: & $($mutability)* TypedConstVal<'tcx>,\n-                                     location: Location) {\n-                let TypedConstVal {\n-                    ref $($mutability)* span,\n-                    ref $($mutability)* ty,\n-                    ref $($mutability)* value,\n-                } = *constant;\n-\n-                self.visit_span(span);\n-                self.visit_ty(ty);\n-                self.visit_const_usize(value, location);\n-            }\n-\n             fn super_literal(&mut self,\n                              literal: & $($mutability)* Literal<'tcx>,\n                              location: Location) {"}, {"sha": "26c7a9166e68e9280ed8a683cc421944d530de60", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -53,6 +53,7 @@ pub enum CallConv {\n     X86_64_SysV = 78,\n     X86_64_Win64 = 79,\n     X86_VectorCall = 80,\n+    X86_Intr = 83,\n }\n \n /// LLVMRustLinkage"}, {"sha": "49dcffb4830a1da67eb69f88b486a2c68091bdc9", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -586,7 +586,7 @@ impl<'a> CrateLoader<'a> {\n         use proc_macro::__internal::Registry;\n         use rustc_back::dynamic_lib::DynamicLibrary;\n         use syntax_ext::deriving::custom::ProcMacroDerive;\n-        use syntax_ext::proc_macro_impl::AttrProcMacro;\n+        use syntax_ext::proc_macro_impl::{AttrProcMacro, BangProcMacro};\n \n         let path = match dylib {\n             Some(dylib) => dylib,\n@@ -630,6 +630,15 @@ impl<'a> CrateLoader<'a> {\n                 );\n                 self.0.push((Symbol::intern(name), Rc::new(expand)));\n             }\n+\n+            fn register_bang_proc_macro(&mut self,\n+                                        name: &str,\n+                                        expand: fn(TokenStream) -> TokenStream) {\n+                let expand = SyntaxExtension::ProcMacro(\n+                    Box::new(BangProcMacro { inner: expand })\n+                );\n+                self.0.push((Symbol::intern(name), Rc::new(expand)));\n+            }\n         }\n \n         let mut my_registrar = MyRegistrar(Vec::new());"}, {"sha": "7c3807a5edca5cb53cd88f4e138a268d36fe6f35", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -148,12 +148,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 //     to the same MIR as `let x = ();`.\n \n                 // first process the set of fields\n+                let el_ty = expr.ty.sequence_element_type(this.hir.tcx());\n                 let fields: Vec<_> =\n                     fields.into_iter()\n                           .map(|f| unpack!(block = this.as_operand(block, f)))\n                           .collect();\n \n-                block.and(Rvalue::Aggregate(AggregateKind::Array, fields))\n+                block.and(Rvalue::Aggregate(AggregateKind::Array(el_ty), fields))\n             }\n             ExprKind::Tuple { fields } => { // see (*) above\n                 // first process the set of fields"}, {"sha": "c67bb8ec6c585346fc7d646addcecfaeda46df6f", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -602,11 +602,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n             ExprKind::Repeat {\n                 value: v.to_ref(),\n-                count: TypedConstVal {\n-                    ty: cx.tcx.types.usize,\n-                    span: c.span,\n-                    value: count\n-                }\n+                count: count,\n             }\n         }\n         hir::ExprRet(ref v) => ExprKind::Return { value: v.to_ref() },"}, {"sha": "2ee375dee08ac7a9a04eeaaddeb436bbcca8effb", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -14,7 +14,8 @@\n //! unit-tested and separated from the Rust source and compiler data\n //! structures.\n \n-use rustc::mir::{BinOp, BorrowKind, Field, Literal, UnOp, TypedConstVal};\n+use rustc_const_math::ConstUsize;\n+use rustc::mir::{BinOp, BorrowKind, Field, Literal, UnOp};\n use rustc::hir::def_id::DefId;\n use rustc::middle::region::CodeExtent;\n use rustc::ty::subst::Substs;\n@@ -219,7 +220,7 @@ pub enum ExprKind<'tcx> {\n     },\n     Repeat {\n         value: ExprRef<'tcx>,\n-        count: TypedConstVal<'tcx>,\n+        count: ConstUsize,\n     },\n     Array {\n         fields: Vec<ExprRef<'tcx>>,"}, {"sha": "e998665e035365056fafe6065ce5b694b4371980", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -752,7 +752,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     }\n \n                     if Some(def.did) == self.tcx.lang_items.unsafe_cell_type() {\n-                        let ty = rvalue.ty(self.mir, self.tcx).unwrap();\n+                        let ty = rvalue.ty(self.mir, self.tcx);\n                         self.add_type(ty);\n                         assert!(self.qualif.intersects(Qualif::MUTABLE_INTERIOR));\n                         // Even if the value inside may not need dropping,"}, {"sha": "c99c4323bb8a1c4c9d4b752a375736e4c8ba199e", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -83,9 +83,8 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n \n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         self.super_rvalue(rvalue, location);\n-        if let Some(ty) = rvalue.ty(self.mir, self.tcx()) {\n-            self.sanitize_type(rvalue, ty);\n-        }\n+        let rval_ty = rvalue.ty(self.mir, self.tcx());\n+        self.sanitize_type(rvalue, rval_ty);\n     }\n \n     fn visit_mir(&mut self, mir: &Mir<'tcx>) {\n@@ -356,14 +355,10 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             StatementKind::Assign(ref lv, ref rv) => {\n                 let lv_ty = lv.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = rv.ty(mir, tcx);\n-                if let Some(rv_ty) = rv_ty {\n-                    if let Err(terr) = self.sub_types(rv_ty, lv_ty) {\n-                        span_mirbug!(self, stmt, \"bad assignment ({:?} = {:?}): {:?}\",\n-                                     lv_ty, rv_ty, terr);\n-                    }\n+                if let Err(terr) = self.sub_types(rv_ty, lv_ty) {\n+                    span_mirbug!(self, stmt, \"bad assignment ({:?} = {:?}): {:?}\",\n+                                 lv_ty, rv_ty, terr);\n                 }\n-                // FIXME: rvalue with undeterminable type - e.g. AggregateKind::Array branch that\n-                // returns `None`.\n             }\n             StatementKind::SetDiscriminant{ ref lvalue, variant_index } => {\n                 let lvalue_type = lvalue.ty(mir, tcx).to_ty(tcx);"}, {"sha": "ce02cb0e8364374e06c9a7105aad2050f6018d86", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -19,7 +19,7 @@ use rustc::mir::{Constant, Literal, Location, LocalDecl};\n use rustc::mir::{Lvalue, LvalueElem, LvalueProjection};\n use rustc::mir::{Mir, Operand, ProjectionElem};\n use rustc::mir::{Rvalue, SourceInfo, Statement, StatementKind};\n-use rustc::mir::{Terminator, TerminatorKind, TypedConstVal, VisibilityScope, VisibilityScopeData};\n+use rustc::mir::{Terminator, TerminatorKind, VisibilityScope, VisibilityScopeData};\n use rustc::mir::visit as mir_visit;\n use rustc::mir::visit::Visitor;\n use rustc::ty::{ClosureSubsts, TyCtxt};\n@@ -191,7 +191,7 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n                 // AggregateKind is not distinguished by visit API, so\n                 // record it. (`super_rvalue` handles `_operands`.)\n                 self.record(match *kind {\n-                    AggregateKind::Array => \"AggregateKind::Array\",\n+                    AggregateKind::Array(_) => \"AggregateKind::Array\",\n                     AggregateKind::Tuple => \"AggregateKind::Tuple\",\n                     AggregateKind::Adt(..) => \"AggregateKind::Adt\",\n                     AggregateKind::Closure(..) => \"AggregateKind::Closure\",\n@@ -297,13 +297,6 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n         self.super_const_usize(const_usize);\n     }\n \n-    fn visit_typed_const_val(&mut self,\n-                             val: &TypedConstVal<'tcx>,\n-                             location: Location) {\n-        self.record(\"TypedConstVal\", val);\n-        self.super_typed_const_val(val, location);\n-    }\n-\n     fn visit_local_decl(&mut self,\n                         local_decl: &LocalDecl<'tcx>) {\n         self.record(\"LocalDecl\", local_decl);"}, {"sha": "0bbe981f2f72c816bd50b38695693d25101450fb", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -355,6 +355,7 @@ impl FnType {\n             Aapcs => llvm::ArmAapcsCallConv,\n             PtxKernel => llvm::PtxKernel,\n             Msp430Interrupt => llvm::Msp430Intr,\n+            X86Interrupt => llvm::X86_Intr,\n \n             // These API constants ought to be more specific...\n             Cdecl => llvm::CCallConv,"}, {"sha": "c524d8351e003c2d47fceee185aa9d5501f3929a", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -529,7 +529,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n             mir::Rvalue::Repeat(ref elem, ref count) => {\n                 let elem = self.const_operand(elem, span)?;\n-                let size = count.value.as_u64(tcx.sess.target.uint_type);\n+                let size = count.as_u64(tcx.sess.target.uint_type);\n                 let fields = vec![elem.llval; size as usize];\n                 self.const_array(dest_ty, &fields)\n             }\n@@ -548,7 +548,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 failure?;\n \n                 match *kind {\n-                    mir::AggregateKind::Array => {\n+                    mir::AggregateKind::Array(_) => {\n                         self.const_array(dest_ty, &fields)\n                     }\n                     mir::AggregateKind::Adt(..) |"}, {"sha": "b6af4e52e820b9062fe1641fdcb1ea4aa5220f3e", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -95,7 +95,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n             mir::Rvalue::Repeat(ref elem, ref count) => {\n                 let tr_elem = self.trans_operand(&bcx, elem);\n-                let size = count.value.as_u64(bcx.tcx().sess.target.uint_type);\n+                let size = count.as_u64(bcx.tcx().sess.target.uint_type);\n                 let size = C_uint(bcx.ccx, size);\n                 let base = base::get_dataptr(&bcx, dest.llval);\n                 tvec::slice_for_each(&bcx, base, tr_elem.ty, size, |bcx, llslot| {\n@@ -435,7 +435,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::Rvalue::Discriminant(ref lvalue) => {\n                 let discr_lvalue = self.trans_lvalue(&bcx, lvalue);\n                 let enum_ty = discr_lvalue.ty.to_ty(bcx.tcx());\n-                let discr_ty = rvalue.ty(&*self.mir, bcx.tcx()).unwrap();\n+                let discr_ty = rvalue.ty(&*self.mir, bcx.tcx());\n                 let discr_type = type_of::immediate_type_of(bcx.ccx, discr_ty);\n                 let discr = adt::trans_get_discr(&bcx, enum_ty, discr_lvalue.llval,\n                                                   discr_lvalue.alignment, Some(discr_type), true);"}, {"sha": "d21bb68d4c827d9204306e18c936cb5b149f21d0", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -3895,7 +3895,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                   let base_t = self.structurally_resolved_type(expr.span, base_t);\n                   match self.lookup_indexing(expr, base, base_t, idx_t, lvalue_pref) {\n                       Some((index_ty, element_ty)) => {\n-                          self.demand_eqtype(expr.span, index_ty, idx_t);\n+                          self.demand_coerce(idx, idx_t, index_ty);\n                           element_ty\n                       }\n                       None => {"}, {"sha": "07f29784df607eb5ff56e14b3e32c5d26b32c2ba", "filename": "src/libstd/sys/unix/process/magenta.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fmagenta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fmagenta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fmagenta.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -156,18 +156,18 @@ extern {\n     pub fn launchpad_create(job: mx_handle_t, name: *const c_char,\n                             lp: *mut *mut launchpad_t) -> mx_status_t;\n \n-    pub fn launchpad_start(lp: *mut launchpad_t) -> mx_status_t;\n+    pub fn launchpad_go(lp: *mut launchpad_t,\n+                        proc_handle: *mut mx_handle_t,\n+                        err_msg: *mut *const c_char) -> mx_status_t;\n \n     pub fn launchpad_destroy(lp: *mut launchpad_t);\n \n-    pub fn launchpad_arguments(lp: *mut launchpad_t, argc: c_int,\n+    pub fn launchpad_set_args(lp: *mut launchpad_t, argc: c_int,\n                                argv: *const *const c_char) -> mx_status_t;\n \n-    pub fn launchpad_environ(lp: *mut launchpad_t, envp: *const *const c_char) -> mx_status_t;\n+    pub fn launchpad_set_environ(lp: *mut launchpad_t, envp: *const *const c_char) -> mx_status_t;\n \n-    pub fn launchpad_clone_mxio_root(lp: *mut launchpad_t) -> mx_status_t;\n-\n-    pub fn launchpad_clone_mxio_cwd(lp: *mut launchpad_t) -> mx_status_t;\n+    pub fn launchpad_clone(lp: *mut launchpad_t, what: u32) -> mx_status_t;\n \n     pub fn launchpad_clone_fd(lp: *mut launchpad_t, fd: c_int, target_fd: c_int) -> mx_status_t;\n \n@@ -182,6 +182,16 @@ extern {\n     pub fn launchpad_vmo_from_file(filename: *const c_char) -> mx_handle_t;\n }\n \n+// Launchpad clone constants\n+\n+pub const LP_CLONE_MXIO_ROOT: u32 = 0x0001;\n+pub const LP_CLONE_MXIO_CWD: u32 = 0x0002;\n+// LP_CLONE_MXIO_STDIO = 0x0004\n+// LP_CLONE_MXIO_ALL = 0x00FF\n+// LP_CLONE_ENVIRON = 0x0100\n+// LP_CLONE_DEFAULT_JOB = 0x0200\n+// LP_CLONE_ALL = 0xFFFF\n+\n // Errors\n \n #[allow(unused)] pub const ERR_INTERNAL: mx_status_t = -1;"}, {"sha": "7d583cb3dfce31f016d65f06d5e55efbecda459a", "filename": "src/libstd/sys/unix/process/process_fuchsia.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -13,7 +13,7 @@ use libc;\n use mem;\n use ptr;\n \n-use sys::process::magenta::{Handle, launchpad_t, mx_handle_t};\n+use sys::process::magenta::{Handle, mx_handle_t};\n use sys::process::process_common::*;\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -30,9 +30,9 @@ impl Command {\n \n         let (ours, theirs) = self.setup_io(default, needs_stdin)?;\n \n-        let (launchpad, process_handle) = unsafe { self.do_exec(theirs)? };\n+        let process_handle = unsafe { self.do_exec(theirs)? };\n \n-        Ok((Process { launchpad: launchpad, handle: Handle::new(process_handle) }, ours))\n+        Ok((Process { handle: Handle::new(process_handle) }, ours))\n     }\n \n     pub fn exec(&mut self, default: Stdio) -> io::Error {\n@@ -51,7 +51,7 @@ impl Command {\n     }\n \n     unsafe fn do_exec(&mut self, stdio: ChildPipes)\n-                      -> io::Result<(*mut launchpad_t, mx_handle_t)> {\n+                      -> io::Result<mx_handle_t> {\n         use sys::process::magenta::*;\n \n         let job_handle = mx_job_default();\n@@ -75,16 +75,15 @@ impl Command {\n         let launchpad_destructor = LaunchpadDestructor(launchpad);\n \n         // Set the process argv\n-        mx_cvt(launchpad_arguments(launchpad, self.get_argv().len() as i32 - 1,\n-                                   self.get_argv().as_ptr()))?;\n+        mx_cvt(launchpad_set_args(launchpad, self.get_argv().len() as i32 - 1,\n+                                  self.get_argv().as_ptr()))?;\n         // Setup the environment vars\n-        mx_cvt(launchpad_environ(launchpad, envp))?;\n+        mx_cvt(launchpad_set_environ(launchpad, envp))?;\n         mx_cvt(launchpad_add_vdso_vmo(launchpad))?;\n-        mx_cvt(launchpad_clone_mxio_root(launchpad))?;\n         // Load the executable\n         mx_cvt(launchpad_elf_load(launchpad, launchpad_vmo_from_file(self.get_argv()[0])))?;\n         mx_cvt(launchpad_load_vdso(launchpad, MX_HANDLE_INVALID))?;\n-        mx_cvt(launchpad_clone_mxio_cwd(launchpad))?;\n+        mx_cvt(launchpad_clone(launchpad, LP_CLONE_MXIO_ROOT | LP_CLONE_MXIO_CWD))?;\n \n         // Clone stdin, stdout, and stderr\n         if let Some(fd) = stdio.stdin.fd() {\n@@ -111,12 +110,15 @@ impl Command {\n             callback()?;\n         }\n \n-        let process_handle = mx_cvt(launchpad_start(launchpad))?;\n-\n-        // Successfully started the launchpad\n+        // `launchpad_go` destroys the launchpad, so we must not\n         mem::forget(launchpad_destructor);\n \n-        Ok((launchpad, process_handle))\n+        let mut process_handle: mx_handle_t = 0;\n+        let mut err_msg: *const libc::c_char = ptr::null();\n+        mx_cvt(launchpad_go(launchpad, &mut process_handle, &mut err_msg))?;\n+        // FIXME: See if we want to do something with that err_msg\n+\n+        Ok(process_handle)\n     }\n }\n \n@@ -125,7 +127,6 @@ impl Command {\n ////////////////////////////////////////////////////////////////////////////////\n \n pub struct Process {\n-    launchpad: *mut launchpad_t,\n     handle: Handle,\n }\n \n@@ -195,10 +196,3 @@ impl Process {\n         Ok(Some(ExitStatus::new(proc_info.rec.return_code)))\n     }\n }\n-\n-impl Drop for Process {\n-    fn drop(&mut self) {\n-        use sys::process::magenta::launchpad_destroy;\n-        unsafe { launchpad_destroy(self.launchpad); }\n-    }\n-}"}, {"sha": "30641515a41dd0ca3e3400ba7911bbd2cce70a15", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -25,6 +25,7 @@ pub enum Abi {\n     SysV64,\n     PtxKernel,\n     Msp430Interrupt,\n+    X86Interrupt,\n \n     // Multiplatform / generic ABIs\n     Rust,\n@@ -59,6 +60,7 @@ const AbiDatas: &'static [AbiData] = &[\n     AbiData {abi: Abi::SysV64, name: \"sysv64\", generic: false },\n     AbiData {abi: Abi::PtxKernel, name: \"ptx-kernel\", generic: false },\n     AbiData {abi: Abi::Msp430Interrupt, name: \"msp430-interrupt\", generic: false },\n+    AbiData {abi: Abi::X86Interrupt, name: \"x86-interrupt\", generic: false },\n \n     // Cross-platform ABIs\n     AbiData {abi: Abi::Rust, name: \"Rust\", generic: true },"}, {"sha": "6eb7d449f269287afe915646535552840b0ec16d", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -77,12 +77,19 @@ macro_rules! declare_features {\n     };\n \n     ($((removed, $feature: ident, $ver: expr, $issue: expr),)+) => {\n-        /// Represents features which has since been removed (it was once Active)\n+        /// Represents unstable features which have since been removed (it was once Active)\n         const REMOVED_FEATURES: &'static [(&'static str, &'static str, Option<u32>)] = &[\n             $((stringify!($feature), $ver, $issue)),+\n         ];\n     };\n \n+    ($((stable_removed, $feature: ident, $ver: expr, $issue: expr),)+) => {\n+        /// Represents stable features which have since been removed (it was once Accepted)\n+        const STABLE_REMOVED_FEATURES: &'static [(&'static str, &'static str, Option<u32>)] = &[\n+            $((stringify!($feature), $ver, $issue)),+\n+        ];\n+    };\n+\n     ($((accepted, $feature: ident, $ver: expr, $issue: expr),)+) => {\n         /// Those language feature has since been Accepted (it was once Active)\n         const ACCEPTED_FEATURES: &'static [(&'static str, &'static str, Option<u32>)] = &[\n@@ -330,6 +337,9 @@ declare_features! (\n     // Used to identify crates that contain sanitizer runtimes\n     // rustc internal\n     (active, sanitizer_runtime, \"1.17.0\", None),\n+\n+    // `extern \"x86-interrupt\" fn()`\n+    (active, abi_x86_interrupt, \"1.17.0\", Some(40180)),\n );\n \n declare_features! (\n@@ -351,6 +361,10 @@ declare_features! (\n     (removed, pushpop_unsafe, \"1.2.0\", None),\n );\n \n+declare_features! (\n+    (stable_removed, no_stack_check, \"1.0.0\", None),\n+);\n+\n declare_features! (\n     (accepted, associated_types, \"1.0.0\", None),\n     // allow overloading augmented assignment operations like `a += b`\n@@ -505,9 +519,6 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                              not yet settled\",\n                                             cfg_fn!(structural_match))),\n \n-    // Not used any more, but we can't feature gate it\n-    (\"no_stack_check\", Normal, Ungated),\n-\n     (\"plugin\", CrateLevel, Gated(Stability::Unstable,\n                                  \"plugin\",\n                                  \"compiler plugins are experimental \\\n@@ -763,6 +774,11 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                            \"attribute proc macros are currently unstable\",\n                                            cfg_fn!(proc_macro))),\n \n+    (\"proc_macro\", Normal, Gated(Stability::Unstable,\n+                                 \"proc_macro\",\n+                                 \"function-like proc macros are currently unstable\",\n+                                 cfg_fn!(proc_macro))),\n+\n     (\"rustc_derive_registrar\", Normal, Gated(Stability::Unstable,\n                                              \"rustc_derive_registrar\",\n                                              \"used internally by rustc\",\n@@ -909,8 +925,10 @@ fn find_lang_feature_issue(feature: &str) -> Option<u32> {\n         // assert!(issue.is_some())\n         issue\n     } else {\n-        // search in Accepted or Removed features\n-        match ACCEPTED_FEATURES.iter().chain(REMOVED_FEATURES).find(|t| t.0 == feature) {\n+        // search in Accepted, Removed, or Stable Removed features\n+        let found = ACCEPTED_FEATURES.iter().chain(REMOVED_FEATURES).chain(STABLE_REMOVED_FEATURES)\n+            .find(|t| t.0 == feature);\n+        match found {\n             Some(&(_, _, issue)) => issue,\n             None => panic!(\"Feature `{}` is not declared anywhere\", feature),\n         }\n@@ -1036,6 +1054,10 @@ impl<'a> PostExpansionVisitor<'a> {\n                 gate_feature_post!(&self, abi_msp430_interrupt, span,\n                                    \"msp430-interrupt ABI is experimental and subject to change\");\n             },\n+            Abi::X86Interrupt => {\n+                gate_feature_post!(&self, abi_x86_interrupt, span,\n+                                   \"x86-interrupt ABI is experimental and subject to change\");\n+            },\n             // Stable\n             Abi::Cdecl |\n             Abi::Stdcall |\n@@ -1444,7 +1466,9 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute]) -> F\n                         feature_checker.collect(&features, mi.span);\n                     }\n                     else if let Some(&(_, _, _)) = REMOVED_FEATURES.iter()\n-                        .find(|& &(n, _, _)| name == n) {\n+                            .find(|& &(n, _, _)| name == n)\n+                        .or_else(|| STABLE_REMOVED_FEATURES.iter()\n+                            .find(|& &(n, _, _)| name == n)) {\n                         span_err!(span_handler, mi.span, E0557, \"feature has been removed\");\n                     }\n                     else if let Some(&(_, _, _)) = ACCEPTED_FEATURES.iter()"}, {"sha": "f60e5824db9627cc67e203060a8409ab58afee7f", "filename": "src/libsyntax_ext/proc_macro_impl.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibsyntax_ext%2Fproc_macro_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibsyntax_ext%2Fproc_macro_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_impl.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -56,3 +56,38 @@ impl base::AttrProcMacro for AttrProcMacro {\n         }\n     }\n }\n+\n+pub struct BangProcMacro {\n+    pub inner: fn(TsShim) -> TsShim,\n+}\n+\n+impl base::ProcMacro for BangProcMacro {\n+    fn expand<'cx>(&self,\n+                   ecx: &'cx mut ExtCtxt,\n+                   span: Span,\n+                   input: TokenStream)\n+                   -> TokenStream {\n+        let input = __internal::token_stream_wrap(input);\n+\n+        let res = __internal::set_parse_sess(&ecx.parse_sess, || {\n+            panic::catch_unwind(panic::AssertUnwindSafe(|| (self.inner)(input)))\n+        });\n+\n+        match res {\n+            Ok(stream) => __internal::token_stream_inner(stream),\n+            Err(e) => {\n+                let msg = \"proc macro panicked\";\n+                let mut err = ecx.struct_span_fatal(span, msg);\n+                if let Some(s) = e.downcast_ref::<String>() {\n+                    err.help(&format!(\"message: {}\", s));\n+                }\n+                if let Some(s) = e.downcast_ref::<&'static str>() {\n+                    err.help(&format!(\"message: {}\", s));\n+                }\n+\n+                err.emit();\n+                panic!(FatalError);\n+            }\n+        }\n+    }\n+}"}, {"sha": "9c96ad547e1ae33254dc8034826b68748db50bc9", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 57, "deletions": 9, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -27,21 +27,25 @@ use syntax_pos::{Span, DUMMY_SP};\n \n use deriving;\n \n+const PROC_MACRO_KINDS: [&'static str; 3] =\n+    [\"proc_macro_derive\", \"proc_macro_attribute\", \"proc_macro\"];\n+\n struct ProcMacroDerive {\n     trait_name: ast::Name,\n     function_name: Ident,\n     span: Span,\n     attrs: Vec<ast::Name>,\n }\n \n-struct AttrProcMacro {\n+struct ProcMacroDef {\n     function_name: Ident,\n     span: Span,\n }\n \n struct CollectProcMacros<'a> {\n     derives: Vec<ProcMacroDerive>,\n-    attr_macros: Vec<AttrProcMacro>,\n+    attr_macros: Vec<ProcMacroDef>,\n+    bang_macros: Vec<ProcMacroDef>,\n     in_root: bool,\n     handler: &'a errors::Handler,\n     is_proc_macro_crate: bool,\n@@ -58,17 +62,18 @@ pub fn modify(sess: &ParseSess,\n     let ecfg = ExpansionConfig::default(\"proc_macro\".to_string());\n     let mut cx = ExtCtxt::new(sess, ecfg, resolver);\n \n-    let (derives, attr_macros) = {\n+    let (derives, attr_macros, bang_macros) = {\n         let mut collect = CollectProcMacros {\n             derives: Vec::new(),\n             attr_macros: Vec::new(),\n+            bang_macros: Vec::new(),\n             in_root: true,\n             handler: handler,\n             is_proc_macro_crate: is_proc_macro_crate,\n             is_test_crate: is_test_crate,\n         };\n         visit::walk_crate(&mut collect, &krate);\n-        (collect.derives, collect.attr_macros)\n+        (collect.derives, collect.attr_macros, collect.bang_macros)\n     };\n \n     if !is_proc_macro_crate {\n@@ -83,7 +88,7 @@ pub fn modify(sess: &ParseSess,\n         return krate;\n     }\n \n-    krate.module.items.push(mk_registrar(&mut cx, &derives, &attr_macros));\n+    krate.module.items.push(mk_registrar(&mut cx, &derives, &attr_macros, &bang_macros));\n \n     if krate.exported_macros.len() > 0 {\n         handler.err(\"cannot export macro_rules! macros from a `proc-macro` \\\n@@ -93,6 +98,10 @@ pub fn modify(sess: &ParseSess,\n     return krate\n }\n \n+fn is_proc_macro_attr(attr: &ast::Attribute) -> bool {\n+    PROC_MACRO_KINDS.iter().any(|kind| attr.check_name(kind))\n+}\n+\n impl<'a> CollectProcMacros<'a> {\n     fn check_not_pub_in_root(&self, vis: &ast::Visibility, sp: Span) {\n         if self.is_proc_macro_crate &&\n@@ -196,12 +205,12 @@ impl<'a> CollectProcMacros<'a> {\n     fn collect_attr_proc_macro(&mut self, item: &'a ast::Item, attr: &'a ast::Attribute) {\n         if let Some(_) = attr.meta_item_list() {\n             self.handler.span_err(attr.span, \"`#[proc_macro_attribute]` attribute\n-                cannot contain any meta items\");\n+                does not take any arguments\");\n             return;\n         }\n \n         if self.in_root && item.vis == ast::Visibility::Public {\n-            self.attr_macros.push(AttrProcMacro {\n+            self.attr_macros.push(ProcMacroDef {\n                 span: item.span,\n                 function_name: item.ident,\n             });\n@@ -215,6 +224,29 @@ impl<'a> CollectProcMacros<'a> {\n             self.handler.span_err(item.span, msg);\n         }\n     }\n+\n+    fn collect_bang_proc_macro(&mut self, item: &'a ast::Item, attr: &'a ast::Attribute) {\n+        if let Some(_) = attr.meta_item_list() {\n+            self.handler.span_err(attr.span, \"`#[proc_macro]` attribute\n+                does not take any arguments\");\n+            return;\n+        }\n+\n+        if self.in_root && item.vis == ast::Visibility::Public {\n+            self.bang_macros.push(ProcMacroDef {\n+                span: item.span,\n+                function_name: item.ident,\n+            });\n+        } else {\n+            let msg = if !self.in_root {\n+                \"functions tagged with `#[proc_macro]` must \\\n+                 currently reside in the root of the crate\"\n+            } else {\n+                \"functions tagged with `#[proc_macro]` must be `pub`\"\n+            };\n+            self.handler.span_err(item.span, msg);\n+        }\n+    }\n }\n \n impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n@@ -232,7 +264,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n         let mut found_attr: Option<&'a ast::Attribute> = None;\n \n         for attr in &item.attrs {\n-            if attr.check_name(\"proc_macro_derive\") || attr.check_name(\"proc_macro_attribute\") {\n+            if is_proc_macro_attr(&attr) {\n                 if let Some(prev_attr) = found_attr {\n                     let msg = if attr.name() == prev_attr.name() {\n                         format!(\"Only one `#[{}]` attribute is allowed on any given function\",\n@@ -285,6 +317,8 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n             self.collect_custom_derive(item, attr);\n         } else if attr.check_name(\"proc_macro_attribute\") {\n             self.collect_attr_proc_macro(item, attr);\n+        } else if attr.check_name(\"proc_macro\") {\n+            self.collect_bang_proc_macro(item, attr);\n         };\n \n         visit::walk_item(self, item);\n@@ -320,7 +354,8 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n //      }\n fn mk_registrar(cx: &mut ExtCtxt,\n                 custom_derives: &[ProcMacroDerive],\n-                custom_attrs: &[AttrProcMacro]) -> P<ast::Item> {\n+                custom_attrs: &[ProcMacroDef],\n+                custom_macros: &[ProcMacroDef]) -> P<ast::Item> {\n     let eid = cx.codemap().record_expansion(ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: NameAndSpan {\n@@ -342,6 +377,7 @@ fn mk_registrar(cx: &mut ExtCtxt,\n     let registrar = Ident::from_str(\"registrar\");\n     let register_custom_derive = Ident::from_str(\"register_custom_derive\");\n     let register_attr_proc_macro = Ident::from_str(\"register_attr_proc_macro\");\n+    let register_bang_proc_macro = Ident::from_str(\"register_bang_proc_macro\");\n \n     let mut stmts = custom_derives.iter().map(|cd| {\n         let path = cx.path_global(cd.span, vec![cd.function_name]);\n@@ -371,6 +407,18 @@ fn mk_registrar(cx: &mut ExtCtxt,\n                                   vec![registrar, name, cx.expr_path(path)]))\n     }));\n \n+    stmts.extend(custom_macros.iter().map(|cm| {\n+        let name = cx.expr_str(cm.span, cm.function_name.name);\n+        let path = cx.path_global(cm.span, vec![cm.function_name]);\n+        let registrar = cx.expr_ident(cm.span, registrar);\n+\n+        let ufcs_path = cx.path(span,\n+                                vec![proc_macro, __internal, registry, register_bang_proc_macro]);\n+\n+        cx.stmt_expr(cx.expr_call(span, cx.expr_path(ufcs_path),\n+                                  vec![registrar, name, cx.expr_path(path)]))\n+    }));\n+\n     let path = cx.path(span, vec![proc_macro, __internal, registry]);\n     let registrar_path = cx.ty_path(path);\n     let arg_ty = cx.ty_rptr(span, registrar_path, None, ast::Mutability::Mutable);"}, {"sha": "838cd4bf6d745625c3320c01b1ae593f7416c916", "filename": "src/test/codegen/abi-x86-interrupt.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Ftest%2Fcodegen%2Fabi-x86-interrupt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Ftest%2Fcodegen%2Fabi-x86-interrupt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fabi-x86-interrupt.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Checks if the correct annotation for the x86-interrupt ABI is passed to\n+// llvm. Also checks that the abi_x86_interrupt feature gate allows usage\n+// of the x86-interrupt abi.\n+\n+// ignore-arm\n+// ignore-aarch64\n+// min-llvm-version 3.8\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+#![feature(abi_x86_interrupt)]\n+\n+// CHECK: define x86_intrcc i64 @has_x86_interrupt_abi\n+#[no_mangle]\n+pub extern \"x86-interrupt\" fn has_x86_interrupt_abi(a: i64) -> i64 {\n+    a * 2\n+}"}, {"sha": "89ac11b309d751bc13d46f10996895ff8abe75da", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/bang_proc_macro.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fbang_proc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fbang_proc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fbang_proc_macro.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+// no-prefer-dynamic\n+#![feature(proc_macro)]\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro]\n+pub fn bang_proc_macro(input: TokenStream) -> TokenStream {\n+    input\n+}"}, {"sha": "7ecc685357ee675b0e4235f51756790b25a1c6e3", "filename": "src/test/compile-fail-fulldeps/proc-macro/macro-use-bang.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fmacro-use-bang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fmacro-use-bang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fmacro-use-bang.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:bang_proc_macro.rs\n+\n+#![feature(proc_macro)]\n+\n+#[macro_use]\n+extern crate bang_proc_macro;\n+\n+fn main() {\n+    bang_proc_macro!(println!(\"Hello, world!\"));\n+    //~^ ERROR: procedural macros cannot be imported with `#[macro_use]`\n+}"}, {"sha": "e0066dd43be89f13cb3d8ec3a8abf80d302ce5a6", "filename": "src/test/compile-fail-fulldeps/proc-macro/resolve-error.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fresolve-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fresolve-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fresolve-error.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -11,6 +11,7 @@\n // aux-build:derive-foo.rs\n // aux-build:derive-clona.rs\n // aux-build:attr_proc_macro.rs\n+// aux-build:bang_proc_macro.rs\n \n #![feature(proc_macro)]\n \n@@ -19,13 +20,19 @@ extern crate derive_foo;\n #[macro_use]\n extern crate derive_clona;\n extern crate attr_proc_macro;\n+extern crate bang_proc_macro;\n \n use attr_proc_macro::attr_proc_macro;\n+use bang_proc_macro::bang_proc_macro;\n \n macro_rules! FooWithLongNam {\n     () => {}\n }\n \n+macro_rules! attr_proc_mac {\n+    () => {}\n+}\n+\n #[derive(FooWithLongNan)]\n //~^ ERROR cannot find derive macro `FooWithLongNan` in this scope\n //~^^ HELP did you mean `FooWithLongName`?\n@@ -61,7 +68,12 @@ fn main() {\n \n     attr_proc_macra!();\n     //~^ ERROR cannot find macro `attr_proc_macra!` in this scope\n+    //~^^ HELP did you mean `attr_proc_mac!`?\n \n     Dlona!();\n     //~^ ERROR cannot find macro `Dlona!` in this scope\n+\n+    bang_proc_macrp!();\n+    //~^ ERROR cannot find macro `bang_proc_macrp!` in this scope\n+    //~^^ HELP did you mean `bang_proc_macro!`?\n }"}, {"sha": "38aaefd52b342ba83564b86c8ea517de84e80e3d", "filename": "src/test/compile-fail/deprecated_no_stack_check.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Ftest%2Fcompile-fail%2Fdeprecated_no_stack_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Ftest%2Fcompile-fail%2Fdeprecated_no_stack_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdeprecated_no_stack_check.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(warnings)]\n+#![feature(no_stack_check)]\n+//~^ ERROR: 12:12: 12:26: feature has been removed [E0557]\n+fn main() {\n+\n+}"}, {"sha": "b77c9fab7169f6add4cedb9cecc13ee304495b8d", "filename": "src/test/compile-fail/feature-gate-abi.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Ftest%2Fcompile-fail%2Ffeature-gate-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Ftest%2Fcompile-fail%2Ffeature-gate-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-abi.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -12,6 +12,7 @@\n // gate-test-platform_intrinsics\n // gate-test-abi_vectorcall\n // gate-test-abi_ptx\n+// gate-test-abi_x86_interrupt\n \n // Functions\n extern \"rust-intrinsic\" fn f1() {} //~ ERROR intrinsics are subject to change\n@@ -20,6 +21,7 @@ extern \"vectorcall\" fn f3() {} //~ ERROR vectorcall is experimental and subject\n extern \"rust-call\" fn f4() {} //~ ERROR rust-call ABI is subject to change\n extern \"msp430-interrupt\" fn f5() {} //~ ERROR msp430-interrupt ABI is experimental\n extern \"ptx-kernel\" fn f6() {} //~ ERROR PTX ABIs are experimental and subject to change\n+extern \"x86-interrupt\" fn f7() {} //~ ERROR x86-interrupt ABI is experimental\n \n // Methods in trait definition\n trait Tr {\n@@ -29,13 +31,15 @@ trait Tr {\n     extern \"rust-call\" fn m4(); //~ ERROR rust-call ABI is subject to change\n     extern \"msp430-interrupt\" fn m5(); //~ ERROR msp430-interrupt ABI is experimental\n     extern \"ptx-kernel\" fn m6(); //~ ERROR PTX ABIs are experimental and subject to change\n+    extern \"x86-interrupt\" fn m7(); //~ ERROR x86-interrupt ABI is experimental\n \n     extern \"rust-intrinsic\" fn dm1() {} //~ ERROR intrinsics are subject to change\n     extern \"platform-intrinsic\" fn dm2() {} //~ ERROR platform intrinsics are experimental\n     extern \"vectorcall\" fn dm3() {} //~ ERROR vectorcall is experimental and subject to change\n     extern \"rust-call\" fn dm4() {} //~ ERROR rust-call ABI is subject to change\n     extern \"msp430-interrupt\" fn dm5() {} //~ ERROR msp430-interrupt ABI is experimental\n     extern \"ptx-kernel\" fn dm6() {} //~ ERROR PTX ABIs are experimental and subject to change\n+    extern \"x86-interrupt\" fn dm7() {} //~ ERROR x86-interrupt ABI is experimental\n }\n \n struct S;\n@@ -48,6 +52,7 @@ impl Tr for S {\n     extern \"rust-call\" fn m4() {} //~ ERROR rust-call ABI is subject to change\n     extern \"msp430-interrupt\" fn m5() {} //~ ERROR msp430-interrupt ABI is experimental\n     extern \"ptx-kernel\" fn m6() {} //~ ERROR PTX ABIs are experimental and subject to change\n+    extern \"x86-interrupt\" fn m7() {} //~ ERROR x86-interrupt ABI is experimental\n }\n \n // Methods in inherent impl\n@@ -58,6 +63,7 @@ impl S {\n     extern \"rust-call\" fn im4() {} //~ ERROR rust-call ABI is subject to change\n     extern \"msp430-interrupt\" fn im5() {} //~ ERROR msp430-interrupt ABI is experimental\n     extern \"ptx-kernel\" fn im6() {} //~ ERROR PTX ABIs are experimental and subject to change\n+    extern \"x86-interrupt\" fn im7() {} //~ ERROR x86-interrupt ABI is experimental\n }\n \n // Function pointer types\n@@ -67,6 +73,7 @@ type A3 = extern \"vectorcall\" fn(); //~ ERROR vectorcall is experimental and sub\n type A4 = extern \"rust-call\" fn(); //~ ERROR rust-call ABI is subject to change\n type A5 = extern \"msp430-interrupt\" fn(); //~ ERROR msp430-interrupt ABI is experimental\n type A6 = extern \"ptx-kernel\" fn (); //~ ERROR PTX ABIs are experimental and subject to change\n+type A7 = extern \"x86-interrupt\" fn(); //~ ERROR x86-interrupt ABI is experimental\n \n // Foreign modules\n extern \"rust-intrinsic\" {} //~ ERROR intrinsics are subject to change\n@@ -75,5 +82,6 @@ extern \"vectorcall\" {} //~ ERROR vectorcall is experimental and subject to chang\n extern \"rust-call\" {} //~ ERROR rust-call ABI is subject to change\n extern \"msp430-interrupt\" {} //~ ERROR msp430-interrupt ABI is experimental\n extern \"ptx-kernel\" {} //~ ERROR PTX ABIs are experimental and subject to change\n+extern \"x86-interrupt\" {} //~ ERROR x86-interrupt ABI is experimental\n \n fn main() {}"}, {"sha": "122a47aff7198d5f512605ce09d1e0422c5eec9d", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/bang-macro.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fbang-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fbang-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fbang-macro.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+#![feature(proc_macro)]\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro]\n+pub fn rewrite(input: TokenStream) -> TokenStream {\n+    let input = input.to_string();\n+\n+    assert_eq!(input, r#\"\"Hello, world!\"\"#);\n+\n+    r#\"\"NOT Hello, world!\"\"#.parse().unwrap()\n+}"}, {"sha": "531bd0dd3569d9b0a191c3330950d60599a8173d", "filename": "src/test/run-pass-fulldeps/proc-macro/bang-macro.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fbang-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fbang-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fbang-macro.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:bang-macro.rs\n+\n+#![feature(proc_macro)]\n+\n+extern crate bang_macro;\n+use bang_macro::rewrite;\n+\n+fn main() {\n+    assert_eq!(rewrite!(\"Hello, world!\"), \"NOT Hello, world!\");\n+}"}, {"sha": "b6d02908a0f78a55d264a2a1e91ca7e1ce7f7e9d", "filename": "src/test/run-pass/issue-40085.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Ftest%2Frun-pass%2Fissue-40085.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Ftest%2Frun-pass%2Fissue-40085.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-40085.rs?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ops::Index;\n+fn bar() {}\n+static UNIT: () = ();\n+struct S;\n+impl Index<fn()> for S {\n+    type Output = ();\n+    fn index(&self, _: fn()) -> &() { &UNIT }\n+}\n+fn main() {\n+    S.index(bar);\n+    S[bar];\n+}"}, {"sha": "eef8793511529fab5d904d6b766ce8b8a263d96b", "filename": "src/test/ui/codemap_tests/unicode.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7112ba246d96f253ba845d91f36c0b7398e42/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.stderr?ref=c0b7112ba246d96f253ba845d91f36c0b7398e42", "patch": "@@ -1,4 +1,4 @@\n-error: invalid ABI: expected one of [cdecl, stdcall, fastcall, vectorcall, aapcs, win64, sysv64, ptx-kernel, msp430-interrupt, Rust, C, system, rust-intrinsic, rust-call, platform-intrinsic, unadjusted], found `\u8def\u6feb\u72fc\u00e1\u0301\u0301`\n+error: invalid ABI: expected one of [cdecl, stdcall, fastcall, vectorcall, aapcs, win64, sysv64, ptx-kernel, msp430-interrupt, x86-interrupt, Rust, C, system, rust-intrinsic, rust-call, platform-intrinsic, unadjusted], found `\u8def\u6feb\u72fc\u00e1\u0301\u0301`\n   --> $DIR/unicode.rs:11:8\n    |\n 11 | extern \"\u8def\u6feb\u72fc\u00e1\u0301\u0301\" fn foo() {}"}]}