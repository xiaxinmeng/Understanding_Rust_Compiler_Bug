{"sha": "2d754b49daa897656f6df5aa24b7560dbc35205e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkNzU0YjQ5ZGFhODk3NjU2ZjZkZjVhYTI0Yjc1NjBkYmMzNTIwNWU=", "commit": {"author": {"name": "Laurent Bonnans", "email": "bonnans.l@gmail.com", "date": "2014-02-26T18:16:53Z"}, "committer": {"name": "Laurent Bonnans", "email": "bonnans.l@gmail.com", "date": "2014-03-10T18:27:59Z"}, "message": "fs: use an iterative algorithm for 'rmdir_recursive'\n\nFor now, the windows version uses stat, just as before.\nWe should switch back to lstat as soon as #12795 is closed.", "tree": {"sha": "3159bcec9c44c897a53326cf1bee41170503f664", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3159bcec9c44c897a53326cf1bee41170503f664"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d754b49daa897656f6df5aa24b7560dbc35205e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d754b49daa897656f6df5aa24b7560dbc35205e", "html_url": "https://github.com/rust-lang/rust/commit/2d754b49daa897656f6df5aa24b7560dbc35205e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d754b49daa897656f6df5aa24b7560dbc35205e/comments", "author": {"login": "lbonn", "id": 2680312, "node_id": "MDQ6VXNlcjI2ODAzMTI=", "avatar_url": "https://avatars.githubusercontent.com/u/2680312?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lbonn", "html_url": "https://github.com/lbonn", "followers_url": "https://api.github.com/users/lbonn/followers", "following_url": "https://api.github.com/users/lbonn/following{/other_user}", "gists_url": "https://api.github.com/users/lbonn/gists{/gist_id}", "starred_url": "https://api.github.com/users/lbonn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lbonn/subscriptions", "organizations_url": "https://api.github.com/users/lbonn/orgs", "repos_url": "https://api.github.com/users/lbonn/repos", "events_url": "https://api.github.com/users/lbonn/events{/privacy}", "received_events_url": "https://api.github.com/users/lbonn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lbonn", "id": 2680312, "node_id": "MDQ6VXNlcjI2ODAzMTI=", "avatar_url": "https://avatars.githubusercontent.com/u/2680312?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lbonn", "html_url": "https://github.com/lbonn", "followers_url": "https://api.github.com/users/lbonn/followers", "following_url": "https://api.github.com/users/lbonn/following{/other_user}", "gists_url": "https://api.github.com/users/lbonn/gists{/gist_id}", "starred_url": "https://api.github.com/users/lbonn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lbonn/subscriptions", "organizations_url": "https://api.github.com/users/lbonn/orgs", "repos_url": "https://api.github.com/users/lbonn/repos", "events_url": "https://api.github.com/users/lbonn/events{/privacy}", "received_events_url": "https://api.github.com/users/lbonn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0fcd5d54552ec758f9e6c6f70071247fb13e117f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fcd5d54552ec758f9e6c6f70071247fb13e117f", "html_url": "https://github.com/rust-lang/rust/commit/0fcd5d54552ec758f9e6c6f70071247fb13e117f"}], "stats": {"total": 49, "additions": 41, "deletions": 8}, "files": [{"sha": "330f09ed47a47c3aa654622d13f7bc366b0e13ec", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 41, "deletions": 8, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/2d754b49daa897656f6df5aa24b7560dbc35205e/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d754b49daa897656f6df5aa24b7560dbc35205e/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=2d754b49daa897656f6df5aa24b7560dbc35205e", "patch": "@@ -51,6 +51,7 @@ fs::unlink(&path);\n \n use c_str::ToCStr;\n use clone::Clone;\n+use container::Container;\n use iter::Iterator;\n use super::{Reader, Writer, Seek};\n use super::{SeekStyle, Read, Write, Open, IoError, Truncate,\n@@ -62,6 +63,7 @@ use result::{Ok, Err};\n use path;\n use path::{Path, GenericPath};\n use vec::{OwnedVector, ImmutableVector};\n+use vec_ng::Vec;\n \n /// Unconstrained file access type that exposes read and write operations\n ///\n@@ -557,16 +559,47 @@ pub fn mkdir_recursive(path: &Path, mode: FilePermission) -> IoResult<()> {\n /// This function will return an `Err` value if an error happens. See\n /// `file::unlink` and `fs::readdir` for possible error conditions.\n pub fn rmdir_recursive(path: &Path) -> IoResult<()> {\n-    let children = try!(readdir(path));\n-    for child in children.iter() {\n-        if child.is_dir() {\n-            try!(rmdir_recursive(child));\n-        } else {\n-            try!(unlink(child));\n+    let mut rm_stack = Vec::new();\n+    rm_stack.push(path.clone());\n+\n+    while !rm_stack.is_empty() {\n+        let children = try!(readdir(rm_stack.last().unwrap()));\n+        let mut has_child_dir = false;\n+\n+        // delete all regular files in the way and push subdirs\n+        // on the stack\n+        for child in children.move_iter() {\n+            // FIXME(#12795) we should use lstat in all cases\n+            let child_type = match cfg!(windows) {\n+                true => try!(stat(&child)).kind,\n+                false => try!(lstat(&child)).kind\n+            };\n+\n+            if child_type == io::TypeDirectory {\n+                rm_stack.push(child);\n+                has_child_dir = true;\n+            } else {\n+                // we can carry on safely if the file is already gone\n+                // (eg: deleted by someone else since readdir)\n+                match unlink(&child) {\n+                    Ok(()) => (),\n+                    Err(ref e) if e.kind == io::FileNotFound => (),\n+                    Err(e) => return Err(e)\n+                }\n+            }\n+        }\n+\n+        // if no subdir was found, let's pop and delete\n+        if !has_child_dir {\n+            match rmdir(&rm_stack.pop().unwrap()) {\n+                Ok(()) => (),\n+                Err(ref e) if e.kind == io::FileNotFound => (),\n+                Err(e) => return Err(e)\n+            }\n         }\n     }\n-    // Directory should now be empty\n-    rmdir(path)\n+\n+    Ok(())\n }\n \n /// Changes the timestamps for a file's last modification and access time."}]}