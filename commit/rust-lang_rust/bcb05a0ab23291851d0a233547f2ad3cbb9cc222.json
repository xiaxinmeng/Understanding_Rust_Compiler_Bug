{"sha": "bcb05a0ab23291851d0a233547f2ad3cbb9cc222", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjYjA1YTBhYjIzMjkxODUxZDBhMjMzNTQ3ZjJhZDNjYmI5Y2MyMjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-28T21:34:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-28T21:34:12Z"}, "message": "Auto merge of #55043 - oliver-giersch:unchecked_thread_spawning, r=alexcrichton\n\nUnchecked thread spawning\n\n# Summary\n\nAdd an unsafe interface for spawning lifetime-unrestricted threads for\nlibrary authors to build less-contrived, less-hacky safe abstractions\non.\n\n# Motivation\n\nSo a few years back scoped threads were entirely removed from the Rust\nstdlib, the reason being that it was possible to leak the scoped thread's\njoin guards without resorting to unsafe code, which meant the concept\nwas not completely safe, either.\nOnly a maximally-restrictive safe API for thread spawning was kept in the\nstdlib, that requires `'static` lifetime bounds on both the thread closure\nand its return type.\nA number of 3rd party libraries sprung up to offer their implementations\nfor safe scoped threads implementations.\nThese work by essentially hiding the join guards from the user, thus\nforcing them to join at the end of an (internal) function scope.\n\nHowever, since these libraries have to use the maximally restrictive\nthread spawning API, they have to resort to some very contrived manipulations\nand subversions of Rust's type system to basically achieve what this commit does\nwith some minimal restructuring of the current code and exposing a new unsafe\nfunction signature for spawning threads without lifetime restrictions.\nObviously this is unsafe, but its main use would be to allow library authors\nto write safe abstractions with and around it.\nTo further illustrate my point, here's a quick summary of the hoops that,\nfor instance `crossbeam`, has to jump through to spawn a lifetime unrestricted\nthread, all of which would not be necessary if an unsafe API existed as part\nof the stdlib:\n\n1. Allocate an `Arc<Option<T>>` on the heap where the result with type\n`T: 'a` will go (in practice requires `Mutex` or `UnsafeCell` as well).\n\n2. Wrap the desired thread closure with lifetime bound `'a` into another\nclosure (also `..: 'a`) that returns `()`, executes the inner closure and\nwrites its result into the pre-allocated `Option<T>`.\n\n3. Box the wrapping closure, cast it to a trait object (`FnBox`) and\n(unsafely) transmute its lifetime bound from `'a` to `'static`.\n\nSo while this new `spawn_unchecked` function is certainly not very relevant\nfor general use, since scoped threads are so common I think it makes sense\nto expose an interface for libraries implementing these to build on.\nThe changes implemented are also very minimal: The current `spawn` function\n(which internally contains unsafe code) is moved into an unsafe `spawn_unchecked`\nfunction, which the safe function then wraps around.\n\n# Issues\n\n- ~~so far, no documentation for the new function (yet)~~\n- the name of the function might be controversial, as `*_unchecked` more commonly\nindicates that some sort of runtime check is omitted (`unrestricted` may be\nmore fitting)\n- if accepted, it might make sense to add a freestanding `thread::spawn_unchecked`\nfunction similar to the current `thread::spawn` for convenience.", "tree": {"sha": "739fb10b7ed7370aa58dc07eca7a2baf5c259e31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/739fb10b7ed7370aa58dc07eca7a2baf5c259e31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bcb05a0ab23291851d0a233547f2ad3cbb9cc222", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bcb05a0ab23291851d0a233547f2ad3cbb9cc222", "html_url": "https://github.com/rust-lang/rust/commit/bcb05a0ab23291851d0a233547f2ad3cbb9cc222", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bcb05a0ab23291851d0a233547f2ad3cbb9cc222/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96064eb61dc703c289fae61bdf90593d3e7b2449", "url": "https://api.github.com/repos/rust-lang/rust/commits/96064eb61dc703c289fae61bdf90593d3e7b2449", "html_url": "https://github.com/rust-lang/rust/commit/96064eb61dc703c289fae61bdf90593d3e7b2449"}, {"sha": "7849aeddb9de12cd7dadc3953cb581695717130b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7849aeddb9de12cd7dadc3953cb581695717130b", "html_url": "https://github.com/rust-lang/rust/commit/7849aeddb9de12cd7dadc3953cb581695717130b"}], "stats": {"total": 91, "additions": 78, "deletions": 13}, "files": [{"sha": "3702c91966fdacbddc3fa554ed3d5285aaf8f413", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 78, "deletions": 13, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/bcb05a0ab23291851d0a233547f2ad3cbb9cc222/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcb05a0ab23291851d0a233547f2ad3cbb9cc222/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=bcb05a0ab23291851d0a233547f2ad3cbb9cc222", "patch": "@@ -386,6 +386,74 @@ impl Builder {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn spawn<F, T>(self, f: F) -> io::Result<JoinHandle<T>> where\n         F: FnOnce() -> T, F: Send + 'static, T: Send + 'static\n+    {\n+        unsafe { self.spawn_unchecked(f) }\n+    }\n+\n+    /// Spawns a new thread without any lifetime restrictions by taking ownership\n+    /// of the `Builder`, and returns an [`io::Result`] to its [`JoinHandle`].\n+    ///\n+    /// The spawned thread may outlive the caller (unless the caller thread\n+    /// is the main thread; the whole process is terminated when the main\n+    /// thread finishes). The join handle can be used to block on\n+    /// termination of the child thread, including recovering its panics.\n+    ///\n+    /// This method is identical to [`thread::Builder::spawn`][`Builder::spawn`],\n+    /// except for the relaxed lifetime bounds, which render it unsafe.\n+    /// For a more complete documentation see [`thread::spawn`][`spawn`].\n+    ///\n+    /// # Errors\n+    ///\n+    /// Unlike the [`spawn`] free function, this method yields an\n+    /// [`io::Result`] to capture any failure to create the thread at\n+    /// the OS level.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if a thread name was set and it contained null bytes.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller has to ensure that no references in the supplied thread closure\n+    /// or its return type can outlive the spawned thread's lifetime. This can be\n+    /// guaranteed in two ways:\n+    ///\n+    /// - ensure that [`join`][`JoinHandle::join`] is called before any referenced\n+    /// data is dropped\n+    /// - use only types with `'static` lifetime bounds, i.e. those with no or only\n+    /// `'static` references (both [`thread::Builder::spawn`][`Builder::spawn`]\n+    /// and [`thread::spawn`][`spawn`] enforce this property statically)\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(thread_spawn_unchecked)]\n+    /// use std::thread;\n+    ///\n+    /// let builder = thread::Builder::new();\n+    ///\n+    /// let x = 1;\n+    /// let thread_x = &x;\n+    ///\n+    /// let handler = unsafe {\n+    ///     builder.spawn_unchecked(move || {\n+    ///         println!(\"x = {}\", *thread_x);\n+    ///     }).unwrap()\n+    /// };\n+    ///\n+    /// // caller has to ensure `join()` is called, otherwise\n+    /// // it is possible to access freed memory if `x` gets\n+    /// // dropped before the thread closure is executed!\n+    /// handler.join().unwrap();\n+    /// ```\n+    ///\n+    /// [`spawn`]: ../../std/thread/fn.spawn.html\n+    /// [`Builder::spawn`]: ../../std/thread/struct.Builder.html#method.spawn\n+    /// [`io::Result`]: ../../std/io/type.Result.html\n+    /// [`JoinHandle`]: ../../std/thread/struct.JoinHandle.html\n+    #[unstable(feature = \"thread_spawn_unchecked\", issue = \"55132\")]\n+    pub unsafe fn spawn_unchecked<F, T>(self, f: F) -> io::Result<JoinHandle<T>> where\n+        F: FnOnce() -> T, F: Send, T: Send\n     {\n         let Builder { name, stack_size } = self;\n \n@@ -402,22 +470,19 @@ impl Builder {\n             if let Some(name) = their_thread.cname() {\n                 imp::Thread::set_name(name);\n             }\n-            unsafe {\n-                thread_info::set(imp::guard::current(), their_thread);\n-                #[cfg(feature = \"backtrace\")]\n-                let try_result = panic::catch_unwind(panic::AssertUnwindSafe(|| {\n-                    ::sys_common::backtrace::__rust_begin_short_backtrace(f)\n-                }));\n-                #[cfg(not(feature = \"backtrace\"))]\n-                let try_result = panic::catch_unwind(panic::AssertUnwindSafe(f));\n-                *their_packet.get() = Some(try_result);\n-            }\n+\n+            thread_info::set(imp::guard::current(), their_thread);\n+            #[cfg(feature = \"backtrace\")]\n+            let try_result = panic::catch_unwind(panic::AssertUnwindSafe(|| {\n+                ::sys_common::backtrace::__rust_begin_short_backtrace(f)\n+            }));\n+            #[cfg(not(feature = \"backtrace\"))]\n+            let try_result = panic::catch_unwind(panic::AssertUnwindSafe(f));\n+            *their_packet.get() = Some(try_result);\n         };\n \n         Ok(JoinHandle(JoinInner {\n-            native: unsafe {\n-                Some(imp::Thread::new(stack_size, Box::new(main))?)\n-            },\n+            native: Some(imp::Thread::new(stack_size, Box::new(main))?),\n             thread: my_thread,\n             packet: Packet(my_packet),\n         }))"}]}