{"sha": "b536d2bb763d478dbf96c035dbd5b68b5ff639b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1MzZkMmJiNzYzZDQ3OGRiZjk2YzAzNWRiZDViNjhiNWZmNjM5Yjk=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-04-24T00:09:58Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-04-24T17:34:13Z"}, "message": "fix O(n^2) perf bug for std::io::fs::walk_dir\n\nThe `walk_dir` iterator was simulating a queue using a vector (in particular, using `shift`),\nleading to O(n^2) performance. Since the order was not well-specified (see issue #13411),\nthe simplest fix is to use the vector as a stack (and thus yield a depth-first traversal).\nThis patch does exactly that.  It leaves the order as originally specified -- \"some top-down\norder\" -- and adds a test to ensure a top-down traversal.\n\nNote that the underlying `readdir` function does not specify any particular order, nor\ndoes the system call it uses.\n\nCloses #13411.", "tree": {"sha": "2819a98060d80a93b68fc455bcb40c824f98d7ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2819a98060d80a93b68fc455bcb40c824f98d7ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b536d2bb763d478dbf96c035dbd5b68b5ff639b9", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b536d2bb763d478dbf96c035dbd5b68b5ff639b9", "html_url": "https://github.com/rust-lang/rust/commit/b536d2bb763d478dbf96c035dbd5b68b5ff639b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b536d2bb763d478dbf96c035dbd5b68b5ff639b9/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3157c3e95b3f8d217e4a1e1e7f93939866e74472", "url": "https://api.github.com/repos/rust-lang/rust/commits/3157c3e95b3f8d217e4a1e1e7f93939866e74472", "html_url": "https://github.com/rust-lang/rust/commit/3157c3e95b3f8d217e4a1e1e7f93939866e74472"}], "stats": {"total": 31, "additions": 29, "deletions": 2}, "files": [{"sha": "a9c493c284dd344787de21971bf0bcb47c60833e", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b536d2bb763d478dbf96c035dbd5b68b5ff639b9/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b536d2bb763d478dbf96c035dbd5b68b5ff639b9/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=b536d2bb763d478dbf96c035dbd5b68b5ff639b9", "patch": "@@ -491,7 +491,8 @@ pub fn readdir(path: &Path) -> IoResult<Vec<Path>> {\n \n /// Returns an iterator which will recursively walk the directory structure\n /// rooted at `path`. The path given will not be iterated over, and this will\n-/// perform iteration in a top-down order.\n+/// perform iteration in some top-down order.  The contents of unreadable\n+/// subdirectories are ignored.\n pub fn walk_dir(path: &Path) -> IoResult<Directories> {\n     Ok(Directories { stack: try!(readdir(path)) })\n }\n@@ -503,7 +504,7 @@ pub struct Directories {\n \n impl Iterator<Path> for Directories {\n     fn next(&mut self) -> Option<Path> {\n-        match self.stack.shift() {\n+        match self.stack.pop() {\n             Some(path) => {\n                 if path.is_dir() {\n                     match readdir(&path) {\n@@ -970,6 +971,32 @@ mod test {\n         check!(rmdir(dir));\n     })\n \n+    iotest!(fn file_test_walk_dir() {\n+        let tmpdir = tmpdir();\n+        let dir = &tmpdir.join(\"walk_dir\");\n+        check!(mkdir(dir, io::UserRWX));\n+\n+        let dir1 = &dir.join(\"01/02/03\");\n+        check!(mkdir_recursive(dir1, io::UserRWX));\n+        check!(File::create(&dir1.join(\"04\")));\n+\n+        let dir2 = &dir.join(\"11/12/13\");\n+        check!(mkdir_recursive(dir2, io::UserRWX));\n+        check!(File::create(&dir2.join(\"14\")));\n+\n+        let mut files = check!(walk_dir(dir));\n+        let mut cur = [0u8, .. 2];\n+        for f in files {\n+            let stem = f.filestem_str().unwrap();\n+            let root = stem[0] - ('0' as u8);\n+            let name = stem[1] - ('0' as u8);\n+            assert!(cur[root as uint] < name);\n+            cur[root as uint] = name;\n+        }\n+\n+        check!(rmdir_recursive(dir));\n+    })\n+\n     iotest!(fn recursive_mkdir() {\n         let tmpdir = tmpdir();\n         let dir = tmpdir.join(\"d1/d2\");"}]}