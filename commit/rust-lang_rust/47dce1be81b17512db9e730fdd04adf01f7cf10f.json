{"sha": "47dce1be81b17512db9e730fdd04adf01f7cf10f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3ZGNlMWJlODFiMTc1MTJkYjllNzMwZmRkMDRhZGYwMWY3Y2YxMGY=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-11-13T00:12:15Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-01-15T00:13:21Z"}, "message": "Add test for `ResultsCursor`\n\nThis is a unit test that ensures the `seek` functions work correctly.", "tree": {"sha": "49c1ca4bf4cf2da1fff7470aff7ab88b55bfe759", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49c1ca4bf4cf2da1fff7470aff7ab88b55bfe759"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47dce1be81b17512db9e730fdd04adf01f7cf10f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47dce1be81b17512db9e730fdd04adf01f7cf10f", "html_url": "https://github.com/rust-lang/rust/commit/47dce1be81b17512db9e730fdd04adf01f7cf10f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47dce1be81b17512db9e730fdd04adf01f7cf10f/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "355cfcdf433c47bfb2365752d33f2a24dfc6e78f", "url": "https://api.github.com/repos/rust-lang/rust/commits/355cfcdf433c47bfb2365752d33f2a24dfc6e78f", "html_url": "https://github.com/rust-lang/rust/commit/355cfcdf433c47bfb2365752d33f2a24dfc6e78f"}], "stats": {"total": 356, "additions": 356, "deletions": 0}, "files": [{"sha": "3a7c650c4618c1df20a0b7e8645ab8254bf6d5c4", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/47dce1be81b17512db9e730fdd04adf01f7cf10f/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47dce1be81b17512db9e730fdd04adf01f7cf10f/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=47dce1be81b17512db9e730fdd04adf01f7cf10f", "patch": "@@ -215,6 +215,31 @@ impl<'tcx> Body<'tcx> {\n         }\n     }\n \n+    /// Returns a partially initialized MIR body containing only a list of basic blocks.\n+    ///\n+    /// The returned MIR contains no `LocalDecl`s (even for the return place) or source scopes. It\n+    /// is only useful for testing but cannot be `#[cfg(test)]` because it is used in a different\n+    /// crate.\n+    pub fn new_cfg_only(basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>) -> Self {\n+        Body {\n+            phase: MirPhase::Build,\n+            basic_blocks,\n+            source_scopes: IndexVec::new(),\n+            yield_ty: None,\n+            generator_drop: None,\n+            generator_layout: None,\n+            local_decls: IndexVec::new(),\n+            user_type_annotations: IndexVec::new(),\n+            arg_count: 0,\n+            spread_arg: None,\n+            span: DUMMY_SP,\n+            control_flow_destroyed: Vec::new(),\n+            generator_kind: None,\n+            var_debug_info: Vec::new(),\n+            ignore_interior_mut_in_const_validation: false,\n+        }\n+    }\n+\n     #[inline]\n     pub fn basic_blocks(&self) -> &IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n         &self.basic_blocks"}, {"sha": "a80e7375482ed48b43b1cbaeb7ffb2406f6342fa", "filename": "src/librustc_mir/dataflow/generic/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/47dce1be81b17512db9e730fdd04adf01f7cf10f/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47dce1be81b17512db9e730fdd04adf01f7cf10f/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fmod.rs?ref=47dce1be81b17512db9e730fdd04adf01f7cf10f", "patch": "@@ -307,3 +307,6 @@ impl<T: Idx> GenKill<T> for BitSet<T> {\n         self.remove(elem);\n     }\n }\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "add9bfd03a8182b72a0ea399c8e750922a0b3bdb", "filename": "src/librustc_mir/dataflow/generic/tests.rs", "status": "added", "additions": 328, "deletions": 0, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/47dce1be81b17512db9e730fdd04adf01f7cf10f/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47dce1be81b17512db9e730fdd04adf01f7cf10f/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Ftests.rs?ref=47dce1be81b17512db9e730fdd04adf01f7cf10f", "patch": "@@ -0,0 +1,328 @@\n+//! A test for the logic that updates the state in a `ResultsCursor` during seek.\n+\n+use rustc::mir::{self, BasicBlock, Location};\n+use rustc::ty;\n+use rustc_index::bit_set::BitSet;\n+use rustc_index::vec::IndexVec;\n+\n+use super::*;\n+use crate::dataflow::BottomValue;\n+\n+/// Returns `true` if the given location points to a `Call` terminator that can return\n+/// successfully.\n+fn is_call_terminator_non_diverging(body: &mir::Body<'_>, loc: Location) -> bool {\n+    loc == body.terminator_loc(loc.block)\n+        && matches!(\n+            body[loc.block].terminator().kind,\n+            mir::TerminatorKind::Call { destination: Some(_), ..  }\n+        )\n+}\n+\n+/// Creates a `mir::Body` with a few disconnected basic blocks.\n+///\n+/// This is the `Body` that will be used by the `MockAnalysis` below. The shape of its CFG is not\n+/// important.\n+fn mock_body() -> mir::Body<'static> {\n+    let span = syntax_pos::DUMMY_SP;\n+    let source_info = mir::SourceInfo { scope: mir::OUTERMOST_SOURCE_SCOPE, span };\n+\n+    let mut blocks = IndexVec::new();\n+    let mut block = |n, kind| {\n+        let nop = mir::Statement { source_info, kind: mir::StatementKind::Nop };\n+\n+        blocks.push(mir::BasicBlockData {\n+            statements: std::iter::repeat(&nop).cloned().take(n).collect(),\n+            terminator: Some(mir::Terminator { source_info, kind }),\n+            is_cleanup: false,\n+        })\n+    };\n+\n+    let dummy_place = mir::Place { local: mir::RETURN_PLACE, projection: ty::List::empty() };\n+\n+    block(4, mir::TerminatorKind::Return);\n+    block(1, mir::TerminatorKind::Return);\n+    block(\n+        2,\n+        mir::TerminatorKind::Call {\n+            func: mir::Operand::Copy(dummy_place.clone()),\n+            args: vec![],\n+            destination: Some((dummy_place.clone(), mir::START_BLOCK)),\n+            cleanup: None,\n+            from_hir_call: false,\n+        },\n+    );\n+    block(3, mir::TerminatorKind::Return);\n+    block(0, mir::TerminatorKind::Return);\n+    block(\n+        4,\n+        mir::TerminatorKind::Call {\n+            func: mir::Operand::Copy(dummy_place.clone()),\n+            args: vec![],\n+            destination: Some((dummy_place.clone(), mir::START_BLOCK)),\n+            cleanup: None,\n+            from_hir_call: false,\n+        },\n+    );\n+\n+    mir::Body::new_cfg_only(blocks)\n+}\n+\n+/// A dataflow analysis whose state is unique at every possible `SeekTarget`.\n+///\n+/// Uniqueness is achieved by having a *locally* unique effect before and after each statement and\n+/// terminator (see `effect_at_target`) while ensuring that the entry set for each block is\n+/// *globally* unique (see `mock_entry_set`).\n+///\n+/// For example, a `BasicBlock` with ID `2` and a `Call` terminator has the following state at each\n+/// location (\"+x\" indicates that \"x\" is added to the state).\n+///\n+/// | Location               | Before            | After  |\n+/// |------------------------|-------------------|--------|\n+/// | (on_entry)             | {102}                     ||\n+/// | Statement 0            | +0                | +1     |\n+/// | statement 1            | +2                | +3     |\n+/// | `Call` terminator      | +4                | +5     |\n+/// | (on unwind)            | {102,0,1,2,3,4,5}         ||\n+/// | (on successful return) | +6                        ||\n+///\n+/// The `102` in the block's entry set is derived from the basic block index and ensures that the\n+/// expected state is unique across all basic blocks. Remember, it is generated by\n+/// `mock_entry_sets`, not from actually running `MockAnalysis` to fixpoint.\n+struct MockAnalysis<'tcx> {\n+    body: &'tcx mir::Body<'tcx>,\n+}\n+\n+impl MockAnalysis<'tcx> {\n+    const BASIC_BLOCK_OFFSET: usize = 100;\n+\n+    /// The entry set for each `BasicBlock` is the ID of that block offset by a fixed amount to\n+    /// avoid colliding with the statement/terminator effects.\n+    fn mock_entry_set(self, bb: BasicBlock) -> BitSet<usize> {\n+        let mut ret = BitSet::new_empty(self.bits_per_block(body));\n+        ret.insert(Self::BASIC_BLOCK_OFFSET + bb.index());\n+        ret\n+    }\n+\n+    fn mock_entry_sets(&self) -> IndexVec<BasicBlock, BitSet<usize>> {\n+        let empty = BitSet::new_empty(self.bits_per_block(body));\n+        let mut ret = IndexVec::from_elem(empty, &self.body.basic_blocks());\n+\n+        for (bb, _) in self.body.basic_blocks().iter_enumerated() {\n+            ret[bb] = self.mock_entry_set(bb);\n+        }\n+\n+        ret\n+    }\n+\n+    /// Returns the index that should be added to the dataflow state at the given target.\n+    ///\n+    /// This index is only unique within a given basic block. `SeekAfter` and\n+    /// `SeekAfterAssumeCallReturns` have the same effect unless `target` is a `Call` terminator.\n+    fn effect_at_target(&self, target: SeekTarget) -> Option<usize> {\n+        use SeekTarget::*;\n+\n+        let idx = match target {\n+            BlockStart(_) => return None,\n+\n+            AfterAssumeCallReturns(loc) if is_call_terminator_non_diverging(self.body, loc) => {\n+                loc.statement_index * 2 + 2\n+            }\n+\n+            Before(loc) => loc.statement_index * 2,\n+            After(loc) | AfterAssumeCallReturns(loc) => loc.statement_index * 2 + 1,\n+        };\n+\n+        assert!(idx < Self::BASIC_BLOCK_OFFSET, \"Too many statements in basic block\");\n+        Some(idx)\n+    }\n+\n+    /// Returns the expected state at the given `SeekTarget`.\n+    ///\n+    /// This is the union of index of the target basic block, the index assigned to the\n+    /// target statement or terminator, and the indices of all preceding statements in the target\n+    /// basic block.\n+    ///\n+    /// For example, the expected state when calling\n+    /// `seek_before(Location { block: 2, statement_index: 2 })` would be `[102, 0, 1, 2, 3, 4]`.\n+    fn expected_state_at_target(&self, target: SeekTarget) -> BitSet<usize> {\n+        let mut ret = BitSet::new_empty(self.bits_per_block(self.body));\n+        ret.insert(Self::BASIC_BLOCK_OFFSET + target.block().index());\n+\n+        if let Some(target_effect) = self.effect_at_target(target) {\n+            for i in 0..=target_effect {\n+                ret.insert(i);\n+            }\n+        }\n+\n+        ret\n+    }\n+}\n+\n+impl BottomValue for MockAnalysis<'tcx> {\n+    const BOTTOM_VALUE: bool = false;\n+}\n+\n+impl AnalysisDomain<'tcx> for MockAnalysis<'tcx> {\n+    type Idx = usize;\n+\n+    const NAME: &'static str = \"mock\";\n+\n+    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize {\n+        Self::BASIC_BLOCK_OFFSET + body.basic_blocks().len()\n+    }\n+\n+    fn initialize_start_block(&self, _: &mir::Body<'tcx>, _: &mut BitSet<Self::Idx>) {\n+        unimplemented!(\"This is never called since `MockAnalysis` is never iterated to fixpoint\");\n+    }\n+}\n+\n+impl Analysis<'tcx> for MockAnalysis<'tcx> {\n+    fn apply_statement_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        _statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    ) {\n+        let idx = SeekTarget::After(location).effect(self.body).unwrap();\n+        assert!(state.insert(idx));\n+    }\n+\n+    fn apply_before_statement_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        _statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    ) {\n+        let idx = SeekTarget::Before(location).effect(self.body).unwrap();\n+        assert!(state.insert(idx));\n+    }\n+\n+    fn apply_terminator_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        _terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    ) {\n+        let idx = SeekTarget::After(location).effect(self.body).unwrap();\n+        assert!(state.insert(idx));\n+    }\n+\n+    fn apply_before_terminator_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        _terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    ) {\n+        let idx = SeekTarget::Before(location).effect(self.body).unwrap();\n+        assert!(state.insert(idx));\n+    }\n+\n+    fn apply_call_return_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        block: BasicBlock,\n+        _func: &mir::Operand<'tcx>,\n+        _args: &[mir::Operand<'tcx>],\n+        _return_place: &mir::Place<'tcx>,\n+    ) {\n+        let location = self.body.terminator_loc(block);\n+        let idx = SeekTarget::AfterAssumeCallReturns(location).effect(self.body).unwrap();\n+        assert!(state.insert(idx));\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+enum SeekTarget {\n+    BlockStart(BasicBlock),\n+    Before(Location),\n+    After(Location),\n+    AfterAssumeCallReturns(Location),\n+}\n+\n+impl SeekTarget {\n+    fn block(&self) -> BasicBlock {\n+        use SeekTarget::*;\n+\n+        match *self {\n+            BlockStart(block) => block,\n+            Before(loc) | After(loc) | AfterAssumeCallReturns(loc) => loc.block,\n+        }\n+    }\n+\n+    /// An iterator over all possible `SeekTarget`s in a given block in order, starting with\n+    /// `BlockStart`.\n+    ///\n+    /// This includes both `After` and `AfterAssumeCallReturns` for every `Location`.\n+    fn iter_in_block(body: &mir::Body<'_>, block: BasicBlock) -> impl Iterator<Item = Self> {\n+        let statements_and_terminator = (0..=body[block].statements.len())\n+            .flat_map(|i| (0..3).map(move |j| (i, j)))\n+            .map(move |(i, kind)| {\n+                let loc = Location { block, statement_index: i };\n+                match kind {\n+                    0 => SeekTarget::Before(loc),\n+                    1 => SeekTarget::After(loc),\n+                    2 => SeekTarget::AfterAssumeCallReturns(loc),\n+                    _ => unreachable!(),\n+                }\n+            });\n+\n+        std::iter::once(SeekTarget::BlockStart(block)).chain(statements_and_terminator)\n+    }\n+}\n+\n+#[test]\n+fn cursor_seek() {\n+    let body = mock_body();\n+    let body = &body;\n+    let analysis = MockAnalysis { body };\n+\n+    let mut cursor = Results { entry_sets: analysis.mock_entry_sets(), analysis }.into_cursor(body);\n+\n+    // Sanity check: the mock call return effect is unique and actually being applied.\n+    let call_terminator_loc = Location { block: BasicBlock::from_usize(2), statement_index: 2 };\n+    assert!(is_call_terminator_non_diverging(body, call_terminator_loc));\n+\n+    let call_return_effect = cursor\n+        .analysis()\n+        .effect_at_target(SeekTarget::AfterAssumeCallReturns(call_terminator_loc))\n+        .unwrap();\n+    assert_ne!(call_return_effect, SeekTarget::After(call_terminator_loc).effect(body).unwrap());\n+\n+    cursor.seek_after(call_terminator_loc);\n+    assert!(!cursor.get().contains(call_return_effect));\n+    cursor.seek_after_assume_call_returns(call_terminator_loc);\n+    assert!(cursor.get().contains(call_return_effect));\n+\n+    let every_target = || {\n+        body.basic_blocks()\n+            .iter_enumerated()\n+            .flat_map(|(bb, _)| SeekTarget::iter_in_block(body, bb))\n+    };\n+\n+    let mut seek_to_target = |targ| {\n+        use SeekTarget::*;\n+\n+        match targ {\n+            BlockStart(block) => cursor.seek_to_block_start(block),\n+            Before(loc) => cursor.seek_before(loc),\n+            After(loc) => cursor.seek_after(loc),\n+            AfterAssumeCallReturns(loc) => cursor.seek_after_assume_call_returns(loc),\n+        }\n+\n+        assert_eq!(cursor.get(), &cursor.analysis().expected_state_at_target(targ));\n+    };\n+\n+    // Seek *to* every possible `SeekTarget` *from* every possible `SeekTarget`.\n+    //\n+    // By resetting the cursor to `from` each time it changes, we end up checking some edges twice.\n+    // What we really want is an Eulerian cycle for the complete digraph over all possible\n+    // `SeekTarget`s, but it's not worth spending the time to compute it.\n+    for from in every_target() {\n+        seek_to_target(from);\n+\n+        for to in every_target() {\n+            seek_to_target(to);\n+            seek_to_target(from);\n+        }\n+    }\n+}"}]}