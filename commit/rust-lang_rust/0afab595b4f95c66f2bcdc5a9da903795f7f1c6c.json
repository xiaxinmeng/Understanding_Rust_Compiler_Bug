{"sha": "0afab595b4f95c66f2bcdc5a9da903795f7f1c6c", "node_id": "C_kwDOAAsO6NoAKDBhZmFiNTk1YjRmOTVjNjZmMmJjZGM1YTlkYTkwMzc5NWY3ZjFjNmM", "commit": {"author": {"name": "Neven Villani", "email": "vanille@crans.org", "date": "2023-03-16T13:44:30Z"}, "committer": {"name": "Neven Villani", "email": "vanille@crans.org", "date": "2023-03-16T13:52:46Z"}, "message": "TB: Reborrow policy and connection to the main machine", "tree": {"sha": "1c72e886246547472db71a097a8887b46e38eb38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c72e886246547472db71a097a8887b46e38eb38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0afab595b4f95c66f2bcdc5a9da903795f7f1c6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0afab595b4f95c66f2bcdc5a9da903795f7f1c6c", "html_url": "https://github.com/rust-lang/rust/commit/0afab595b4f95c66f2bcdc5a9da903795f7f1c6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0afab595b4f95c66f2bcdc5a9da903795f7f1c6c/comments", "author": {"login": "Vanille-N", "id": 58042063, "node_id": "MDQ6VXNlcjU4MDQyMDYz", "avatar_url": "https://avatars.githubusercontent.com/u/58042063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Vanille-N", "html_url": "https://github.com/Vanille-N", "followers_url": "https://api.github.com/users/Vanille-N/followers", "following_url": "https://api.github.com/users/Vanille-N/following{/other_user}", "gists_url": "https://api.github.com/users/Vanille-N/gists{/gist_id}", "starred_url": "https://api.github.com/users/Vanille-N/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Vanille-N/subscriptions", "organizations_url": "https://api.github.com/users/Vanille-N/orgs", "repos_url": "https://api.github.com/users/Vanille-N/repos", "events_url": "https://api.github.com/users/Vanille-N/events{/privacy}", "received_events_url": "https://api.github.com/users/Vanille-N/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Vanille-N", "id": 58042063, "node_id": "MDQ6VXNlcjU4MDQyMDYz", "avatar_url": "https://avatars.githubusercontent.com/u/58042063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Vanille-N", "html_url": "https://github.com/Vanille-N", "followers_url": "https://api.github.com/users/Vanille-N/followers", "following_url": "https://api.github.com/users/Vanille-N/following{/other_user}", "gists_url": "https://api.github.com/users/Vanille-N/gists{/gist_id}", "starred_url": "https://api.github.com/users/Vanille-N/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Vanille-N/subscriptions", "organizations_url": "https://api.github.com/users/Vanille-N/orgs", "repos_url": "https://api.github.com/users/Vanille-N/repos", "events_url": "https://api.github.com/users/Vanille-N/events{/privacy}", "received_events_url": "https://api.github.com/users/Vanille-N/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d4e8b9bc069c66eddf791421647bcb495bdeac4", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d4e8b9bc069c66eddf791421647bcb495bdeac4", "html_url": "https://github.com/rust-lang/rust/commit/7d4e8b9bc069c66eddf791421647bcb495bdeac4"}], "stats": {"total": 609, "additions": 608, "deletions": 1}, "files": [{"sha": "ed958329f9514f19dc3793759910ff91a6fada1c", "filename": "src/tools/miri/src/borrow_tracker/mod.rs", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0afab595b4f95c66f2bcdc5a9da903795f7f1c6c/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0afab595b4f95c66f2bcdc5a9da903795f7f1c6c/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs?ref=0afab595b4f95c66f2bcdc5a9da903795f7f1c6c", "patch": "@@ -11,6 +11,7 @@ use rustc_target::abi::Size;\n \n use crate::*;\n pub mod stacked_borrows;\n+pub mod tree_borrows;\n \n pub type CallId = NonZeroU64;\n \n@@ -230,8 +231,10 @@ impl GlobalStateInner {\n /// Which borrow tracking method to use\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n pub enum BorrowTrackerMethod {\n-    /// Stacked Borrows, as implemented in borrow_tracker/stacked\n+    /// Stacked Borrows, as implemented in borrow_tracker/stacked_borrows\n     StackedBorrows,\n+    /// Tree borrows, as implemented in borrow_tracker/tree_borrows\n+    TreeBorrows,\n }\n \n impl BorrowTrackerMethod {\n@@ -258,6 +261,10 @@ impl GlobalStateInner {\n                 AllocState::StackedBorrows(Box::new(RefCell::new(Stacks::new_allocation(\n                     id, alloc_size, self, kind, machine,\n                 )))),\n+            BorrowTrackerMethod::TreeBorrows =>\n+                AllocState::TreeBorrows(Box::new(RefCell::new(Tree::new_allocation(\n+                    id, alloc_size, self, kind, machine,\n+                )))),\n         }\n     }\n }\n@@ -273,6 +280,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let method = this.machine.borrow_tracker.as_ref().unwrap().borrow().borrow_tracker_method;\n         match method {\n             BorrowTrackerMethod::StackedBorrows => this.sb_retag_ptr_value(kind, val),\n+            BorrowTrackerMethod::TreeBorrows => this.tb_retag_ptr_value(kind, val),\n         }\n     }\n \n@@ -285,6 +293,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let method = this.machine.borrow_tracker.as_ref().unwrap().borrow().borrow_tracker_method;\n         match method {\n             BorrowTrackerMethod::StackedBorrows => this.sb_retag_place_contents(kind, place),\n+            BorrowTrackerMethod::TreeBorrows => this.tb_retag_place_contents(kind, place),\n         }\n     }\n \n@@ -293,6 +302,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let method = this.machine.borrow_tracker.as_ref().unwrap().borrow().borrow_tracker_method;\n         match method {\n             BorrowTrackerMethod::StackedBorrows => this.sb_retag_return_place(),\n+            BorrowTrackerMethod::TreeBorrows => this.tb_retag_return_place(),\n         }\n     }\n \n@@ -301,6 +311,34 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let method = this.machine.borrow_tracker.as_ref().unwrap().borrow().borrow_tracker_method;\n         match method {\n             BorrowTrackerMethod::StackedBorrows => this.sb_expose_tag(alloc_id, tag),\n+            BorrowTrackerMethod::TreeBorrows => this.tb_expose_tag(alloc_id, tag),\n+        }\n+    }\n+\n+    fn give_pointer_debug_name(\n+        &mut self,\n+        ptr: Pointer<Option<Provenance>>,\n+        nth_parent: u8,\n+        name: &str,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let method = this.machine.borrow_tracker.as_ref().unwrap().borrow().borrow_tracker_method;\n+        match method {\n+            BorrowTrackerMethod::StackedBorrows => {\n+                this.tcx.tcx.sess.warn(\"Stacked Borrows does not support named pointers; `miri_pointer_name` is a no-op\");\n+                Ok(())\n+            }\n+            BorrowTrackerMethod::TreeBorrows =>\n+                this.tb_give_pointer_debug_name(ptr, nth_parent, name),\n+        }\n+    }\n+\n+    fn print_borrow_state(&mut self, alloc_id: AllocId, show_unnamed: bool) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let method = this.machine.borrow_tracker.as_ref().unwrap().borrow().borrow_tracker_method;\n+        match method {\n+            BorrowTrackerMethod::StackedBorrows => this.print_stacks(alloc_id),\n+            BorrowTrackerMethod::TreeBorrows => this.print_tree(alloc_id, show_unnamed),\n         }\n     }\n }\n@@ -310,6 +348,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n pub enum AllocState {\n     /// Data corresponding to Stacked Borrows\n     StackedBorrows(Box<RefCell<stacked_borrows::AllocState>>),\n+    /// Data corresponding to Tree Borrows\n+    TreeBorrows(Box<RefCell<tree_borrows::AllocState>>),\n }\n \n impl machine::AllocExtra {\n@@ -328,6 +368,14 @@ impl machine::AllocExtra {\n             _ => panic!(\"expected Stacked Borrows borrow tracking, got something else\"),\n         }\n     }\n+\n+    #[track_caller]\n+    pub fn borrow_tracker_tb(&self) -> &RefCell<tree_borrows::AllocState> {\n+        match self.borrow_tracker {\n+            Some(AllocState::TreeBorrows(ref tb)) => tb,\n+            _ => panic!(\"expected Tree Borrows borrow tracking, got something else\"),\n+        }\n+    }\n }\n \n impl AllocState {\n@@ -341,6 +389,14 @@ impl AllocState {\n         match self {\n             AllocState::StackedBorrows(sb) =>\n                 sb.borrow_mut().before_memory_read(alloc_id, prov_extra, range, machine),\n+            AllocState::TreeBorrows(tb) =>\n+                tb.borrow_mut().before_memory_access(\n+                    AccessKind::Read,\n+                    alloc_id,\n+                    prov_extra,\n+                    range,\n+                    machine,\n+                ),\n         }\n     }\n \n@@ -354,6 +410,14 @@ impl AllocState {\n         match self {\n             AllocState::StackedBorrows(sb) =>\n                 sb.get_mut().before_memory_write(alloc_id, prov_extra, range, machine),\n+            AllocState::TreeBorrows(tb) =>\n+                tb.get_mut().before_memory_access(\n+                    AccessKind::Write,\n+                    alloc_id,\n+                    prov_extra,\n+                    range,\n+                    machine,\n+                ),\n         }\n     }\n \n@@ -367,12 +431,15 @@ impl AllocState {\n         match self {\n             AllocState::StackedBorrows(sb) =>\n                 sb.get_mut().before_memory_deallocation(alloc_id, prov_extra, range, machine),\n+            AllocState::TreeBorrows(tb) =>\n+                tb.get_mut().before_memory_deallocation(alloc_id, prov_extra, range, machine),\n         }\n     }\n \n     pub fn remove_unreachable_tags(&self, tags: &FxHashSet<BorTag>) {\n         match self {\n             AllocState::StackedBorrows(sb) => sb.borrow_mut().remove_unreachable_tags(tags),\n+            AllocState::TreeBorrows(tb) => tb.borrow_mut().remove_unreachable_tags(tags),\n         }\n     }\n }\n@@ -381,6 +448,7 @@ impl VisitTags for AllocState {\n     fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         match self {\n             AllocState::StackedBorrows(sb) => sb.visit_tags(visit),\n+            AllocState::TreeBorrows(tb) => tb.visit_tags(visit),\n         }\n     }\n }"}, {"sha": "2297ceb125912b98093c37f639967041df09aad9", "filename": "src/tools/miri/src/borrow_tracker/tree_borrows/mod.rs", "status": "added", "additions": 539, "deletions": 0, "changes": 539, "blob_url": "https://github.com/rust-lang/rust/blob/0afab595b4f95c66f2bcdc5a9da903795f7f1c6c/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0afab595b4f95c66f2bcdc5a9da903795f7f1c6c/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fmod.rs?ref=0afab595b4f95c66f2bcdc5a9da903795f7f1c6c", "patch": "@@ -0,0 +1,539 @@\n+use log::trace;\n+\n+use rustc_target::abi::{Abi, Size};\n+\n+use crate::borrow_tracker::{AccessKind, GlobalStateInner, ProtectorKind, RetagFields};\n+use rustc_middle::{\n+    mir::{Mutability, RetagKind},\n+    ty::{\n+        self,\n+        layout::{HasParamEnv, LayoutOf},\n+        Ty,\n+    },\n+};\n+\n+use crate::*;\n+\n+mod diagnostics;\n+mod perms;\n+mod tree;\n+mod unimap;\n+use perms::Permission;\n+pub use tree::Tree;\n+\n+pub type AllocState = Tree;\n+\n+pub fn err_tb_ub<'tcx>(msg: String) -> InterpError<'tcx> {\n+    err_machine_stop!(TerminationInfo::TreeBorrowsUb { msg })\n+}\n+\n+impl<'tcx> Tree {\n+    /// Create a new allocation, i.e. a new tree\n+    pub fn new_allocation(\n+        id: AllocId,\n+        size: Size,\n+        state: &mut GlobalStateInner,\n+        _kind: MemoryKind<machine::MiriMemoryKind>,\n+        machine: &MiriMachine<'_, 'tcx>,\n+    ) -> Self {\n+        let tag = state.base_ptr_tag(id, machine); // Fresh tag for the root\n+        Tree::new(tag, size)\n+    }\n+\n+    /// Check that an access on the entire range is permitted, and update\n+    /// the tree.\n+    pub fn before_memory_access(\n+        &mut self,\n+        access_kind: AccessKind,\n+        alloc_id: AllocId,\n+        prov: ProvenanceExtra,\n+        range: AllocRange,\n+        machine: &MiriMachine<'_, 'tcx>,\n+    ) -> InterpResult<'tcx> {\n+        trace!(\n+            \"{} with tag {:?}: {:?}, size {}\",\n+            access_kind,\n+            prov,\n+            Pointer::new(alloc_id, range.start),\n+            range.size.bytes(),\n+        );\n+        // TODO: for now we bail out on wildcard pointers. Eventually we should\n+        // handle them as much as we can.\n+        let tag = match prov {\n+            ProvenanceExtra::Concrete(tag) => tag,\n+            ProvenanceExtra::Wildcard => return Ok(()),\n+        };\n+        let global = machine.borrow_tracker.as_ref().unwrap();\n+        self.perform_access(access_kind, tag, range, global)\n+    }\n+\n+    /// Check that this pointer has permission to deallocate this range.\n+    pub fn before_memory_deallocation(\n+        &mut self,\n+        _alloc_id: AllocId,\n+        prov: ProvenanceExtra,\n+        range: AllocRange,\n+        machine: &MiriMachine<'_, 'tcx>,\n+    ) -> InterpResult<'tcx> {\n+        // TODO: for now we bail out on wildcard pointers. Eventually we should\n+        // handle them as much as we can.\n+        let tag = match prov {\n+            ProvenanceExtra::Concrete(tag) => tag,\n+            ProvenanceExtra::Wildcard => return Ok(()),\n+        };\n+        let global = machine.borrow_tracker.as_ref().unwrap();\n+        self.dealloc(tag, range, global)\n+    }\n+\n+    pub fn expose_tag(&mut self, _tag: BorTag) {\n+        // TODO\n+    }\n+}\n+\n+/// Policy for a new borrow.\n+#[derive(Debug, Clone, Copy)]\n+struct NewPermission {\n+    /// Whether this borrow requires a read access on its parent.\n+    /// `perform_read_access` is `true` for all pointers marked `dereferenceable`.\n+    perform_read_access: bool,\n+    /// Which permission should the pointer start with.\n+    initial_state: Permission,\n+    /// Whether this pointer is part of the arguments of a function call.\n+    /// `protector` is `Some(_)` for all pointers marked `noalias`.\n+    protector: Option<ProtectorKind>,\n+}\n+\n+impl<'tcx> NewPermission {\n+    /// Determine NewPermission of the reference from the type of the pointee.\n+    fn from_ref_ty(\n+        pointee: Ty<'tcx>,\n+        mutability: Mutability,\n+        kind: RetagKind,\n+        cx: &crate::MiriInterpCx<'_, 'tcx>,\n+    ) -> Option<Self> {\n+        let ty_is_freeze = pointee.is_freeze(*cx.tcx, cx.param_env());\n+        let ty_is_unpin = pointee.is_unpin(*cx.tcx, cx.param_env());\n+        let initial_state = match mutability {\n+            Mutability::Mut if ty_is_unpin => Permission::new_unique_2phase(ty_is_freeze),\n+            Mutability::Not if ty_is_freeze => Permission::new_frozen(),\n+            // Raw pointers never enter this function so they are not handled.\n+            // However raw pointers are not the only pointers that take the parent\n+            // tag, this also happens for `!Unpin` `&mut`s and interior mutable\n+            // `&`s, which are excluded above.\n+            _ => return None,\n+        };\n+        // This field happens to be redundant since right now we always do a read,\n+        // but it could be useful in the future.\n+        let perform_read_access = true;\n+\n+        let protector = (kind == RetagKind::FnEntry).then_some(ProtectorKind::StrongProtector);\n+        Some(Self { perform_read_access, initial_state, protector })\n+    }\n+\n+    // Boxes are not handled by `from_ref_ty`, they need special behavior\n+    // implemented here.\n+    fn from_box_ty(\n+        ty: Ty<'tcx>,\n+        kind: RetagKind,\n+        cx: &crate::MiriInterpCx<'_, 'tcx>,\n+    ) -> Option<Self> {\n+        let pointee = ty.builtin_deref(true).unwrap().ty;\n+        pointee.is_unpin(*cx.tcx, cx.param_env()).then_some(()).map(|()| {\n+            // Regular `Unpin` box, give it `noalias` but only a weak protector\n+            // because it is valid to deallocate it within the function.\n+            let ty_is_freeze = ty.is_freeze(*cx.tcx, cx.param_env());\n+            Self {\n+                perform_read_access: true,\n+                initial_state: Permission::new_unique_2phase(ty_is_freeze),\n+                protector: (kind == RetagKind::FnEntry).then_some(ProtectorKind::WeakProtector),\n+            }\n+        })\n+    }\n+}\n+\n+/// Retagging/reborrowing.\n+/// Policy on which permission to grant to each pointer should be left to\n+/// the implementation of NewPermission.\n+impl<'mir: 'ecx, 'tcx: 'mir, 'ecx> EvalContextPrivExt<'mir, 'tcx, 'ecx>\n+    for crate::MiriInterpCx<'mir, 'tcx>\n+{\n+}\n+trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    /// Returns the `AllocId` the reborrow was done in, if there is some actual\n+    /// memory associated with this pointer. Returns `None` if there is no actual\n+    /// memory allocated. Also checks that the reborrow of size `ptr_size` is\n+    /// within bounds of the allocation.\n+    ///\n+    /// Also returns the tag that the pointer should get, which is essentially\n+    /// `if new_perm.is_some() { new_tag } else { parent_tag }` along with\n+    /// some logging (always) and fake reads (if `new_perm` is\n+    /// `Some(NewPermission { perform_read_access: true }`).\n+    fn tb_reborrow(\n+        &mut self,\n+        place: &MPlaceTy<'tcx, Provenance>, // parent tag extracted from here\n+        ptr_size: Size,\n+        new_perm: Option<NewPermission>,\n+        new_tag: BorTag,\n+    ) -> InterpResult<'tcx, Option<(AllocId, BorTag)>> {\n+        let this = self.eval_context_mut();\n+\n+        // It is crucial that this gets called on all code paths, to ensure we track tag creation.\n+        let log_creation = |this: &MiriInterpCx<'mir, 'tcx>,\n+                            loc: Option<(AllocId, Size, ProvenanceExtra)>| // alloc_id, base_offset, orig_tag\n+         -> InterpResult<'tcx> {\n+            let global = this.machine.borrow_tracker.as_ref().unwrap().borrow();\n+            let ty = place.layout.ty;\n+            if global.tracked_pointer_tags.contains(&new_tag) {\n+                let kind_str = format!(\"{new_perm:?} (pointee type {ty})\");\n+                this.emit_diagnostic(NonHaltingDiagnostic::CreatedPointerTag(\n+                    new_tag.inner(),\n+                    Some(kind_str),\n+                    loc.map(|(alloc_id, base_offset, orig_tag)| (alloc_id, alloc_range(base_offset, ptr_size), orig_tag)),\n+                ));\n+            }\n+            drop(global); // don't hold that reference any longer than we have to\n+            Ok(())\n+        };\n+\n+        let (alloc_id, base_offset, parent_prov) = if ptr_size > Size::ZERO {\n+            this.ptr_get_alloc_id(place.ptr)?\n+        } else {\n+            match this.ptr_try_get_alloc_id(place.ptr) {\n+                Ok(data) => data,\n+                Err(_) => {\n+                    // This pointer doesn't come with an AllocId, so there's no\n+                    // memory to do retagging in.\n+                    trace!(\n+                        \"reborrow of size 0: reference {:?} derived from {:?} (pointee {})\",\n+                        new_tag,\n+                        place.ptr,\n+                        place.layout.ty,\n+                    );\n+                    log_creation(this, None)?;\n+                    return Ok(None);\n+                }\n+            }\n+        };\n+        let orig_tag = match parent_prov {\n+            ProvenanceExtra::Wildcard => return Ok(None), // TODO: handle wildcard pointers\n+            ProvenanceExtra::Concrete(tag) => tag,\n+        };\n+\n+        // Protection against trying to get a reference to a vtable:\n+        // vtables do not have an alloc_extra so the call to\n+        // `get_alloc_extra` that follows fails.\n+        let (alloc_size, _align, alloc_kind) = this.get_alloc_info(alloc_id);\n+        if ptr_size == Size::ZERO && !matches!(alloc_kind, AllocKind::LiveData) {\n+            return Ok(Some((alloc_id, orig_tag)));\n+        }\n+\n+        log_creation(this, Some((alloc_id, base_offset, parent_prov)))?;\n+\n+        // Ensure we bail out if the pointer goes out-of-bounds (see miri#1050).\n+        if base_offset + ptr_size > alloc_size {\n+            throw_ub!(PointerOutOfBounds {\n+                alloc_id,\n+                alloc_size,\n+                ptr_offset: this.target_usize_to_isize(base_offset.bytes()),\n+                ptr_size,\n+                msg: CheckInAllocMsg::InboundsTest\n+            });\n+        }\n+\n+        trace!(\n+            \"reborrow: reference {:?} derived from {:?} (pointee {}): {:?}, size {}\",\n+            new_tag,\n+            orig_tag,\n+            place.layout.ty,\n+            Pointer::new(alloc_id, base_offset),\n+            ptr_size.bytes()\n+        );\n+\n+        let Some(new_perm) = new_perm else { return Ok(Some((alloc_id, orig_tag))); };\n+\n+        if let Some(protect) = new_perm.protector {\n+            // We register the protection in two different places.\n+            // This makes creating a protector slower, but checking whether a tag\n+            // is protected faster.\n+            this.frame_mut().extra.borrow_tracker.as_mut().unwrap().protected_tags.push(new_tag);\n+            this.machine\n+                .borrow_tracker\n+                .as_mut()\n+                .expect(\"We should have borrow tracking data\")\n+                .get_mut()\n+                .protected_tags\n+                .insert(new_tag, protect);\n+        }\n+\n+        let alloc_extra = this.get_alloc_extra(alloc_id)?;\n+        let range = alloc_range(base_offset, ptr_size);\n+        let mut tree_borrows = alloc_extra.borrow_tracker_tb().borrow_mut();\n+\n+        if new_perm.perform_read_access {\n+            // Count this reborrow as a read access\n+            let global = &this.machine.borrow_tracker.as_ref().unwrap();\n+            tree_borrows.perform_access(AccessKind::Read, orig_tag, range, global)?;\n+            if let Some(data_race) = alloc_extra.data_race.as_ref() {\n+                data_race.read(alloc_id, range, &this.machine)?;\n+            }\n+        }\n+\n+        // Record the parent-child pair in the tree.\n+        tree_borrows.new_child(orig_tag, new_tag, new_perm.initial_state, range)?;\n+        Ok(Some((alloc_id, new_tag)))\n+    }\n+\n+    /// Retags an indidual pointer, returning the retagged version.\n+    fn tb_retag_reference(\n+        &mut self,\n+        val: &ImmTy<'tcx, Provenance>,\n+        new_perm: Option<NewPermission>,\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, Provenance>> {\n+        let this = self.eval_context_mut();\n+        // We want a place for where the ptr *points to*, so we get one.\n+        let place = this.ref_to_mplace(val)?;\n+\n+        // Get a lower bound of the size of this place.\n+        // (When `extern type` are involved, use the size of the known prefix.)\n+        let size = this\n+            .size_and_align_of_mplace(&place)?\n+            .map(|(size, _)| size)\n+            .unwrap_or(place.layout.size);\n+\n+        // This new tag is not guaranteed to actually be used.\n+        //\n+        // If you run out of tags, consider the following optimization: adjust `tb_reborrow`\n+        // so that rather than taking as input a fresh tag and deciding whether it uses this\n+        // one or the parent it instead just returns whether a new tag should be created.\n+        // This will avoid creating tags than end up never being used.\n+        let new_tag = this.machine.borrow_tracker.as_mut().unwrap().get_mut().new_ptr();\n+\n+        // Compute the actual reborrow.\n+        let reborrowed = this.tb_reborrow(&place, size, new_perm, new_tag)?;\n+\n+        // Adjust pointer.\n+        let new_place = place.map_provenance(|p| {\n+            p.map(|prov| {\n+                match reborrowed {\n+                    Some((alloc_id, actual_tag)) => {\n+                        // If `reborrow` could figure out the AllocId of this ptr, hard-code it into the new one.\n+                        // Even if we started out with a wildcard, this newly retagged pointer is tied to that allocation.\n+                        Provenance::Concrete { alloc_id, tag: actual_tag }\n+                    }\n+                    None => {\n+                        // Looks like this has to stay a wildcard pointer.\n+                        assert!(matches!(prov, Provenance::Wildcard));\n+                        Provenance::Wildcard\n+                    }\n+                }\n+            })\n+        });\n+\n+        // Return new pointer.\n+        Ok(ImmTy::from_immediate(new_place.to_ref(this), val.layout))\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    /// Retag a pointer. References are passed to `from_ref_ty` and\n+    /// raw pointers are never reborrowed.\n+    fn tb_retag_ptr_value(\n+        &mut self,\n+        kind: RetagKind,\n+        val: &ImmTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, Provenance>> {\n+        let this = self.eval_context_mut();\n+        let new_perm = if let &ty::Ref(_, pointee, mutability) = val.layout.ty.kind() {\n+            NewPermission::from_ref_ty(pointee, mutability, kind, this)\n+        } else {\n+            None\n+        };\n+        this.tb_retag_reference(val, new_perm)\n+    }\n+\n+    /// Retag all pointers that are stored in this place.\n+    fn tb_retag_place_contents(\n+        &mut self,\n+        kind: RetagKind,\n+        place: &PlaceTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let retag_fields = this.machine.borrow_tracker.as_mut().unwrap().get_mut().retag_fields;\n+        let mut visitor = RetagVisitor { ecx: this, kind, retag_fields };\n+        return visitor.visit_value(place);\n+\n+        // The actual visitor.\n+        struct RetagVisitor<'ecx, 'mir, 'tcx> {\n+            ecx: &'ecx mut MiriInterpCx<'mir, 'tcx>,\n+            kind: RetagKind,\n+            retag_fields: RetagFields,\n+        }\n+        impl<'ecx, 'mir, 'tcx> RetagVisitor<'ecx, 'mir, 'tcx> {\n+            #[inline(always)] // yes this helps in our benchmarks\n+            fn retag_ptr_inplace(\n+                &mut self,\n+                place: &PlaceTy<'tcx, Provenance>,\n+                new_perm: Option<NewPermission>,\n+            ) -> InterpResult<'tcx> {\n+                let val = self.ecx.read_immediate(&self.ecx.place_to_op(place)?)?;\n+                let val = self.ecx.tb_retag_reference(&val, new_perm)?;\n+                self.ecx.write_immediate(*val, place)?;\n+                Ok(())\n+            }\n+        }\n+        impl<'ecx, 'mir, 'tcx> MutValueVisitor<'mir, 'tcx, MiriMachine<'mir, 'tcx>>\n+            for RetagVisitor<'ecx, 'mir, 'tcx>\n+        {\n+            type V = PlaceTy<'tcx, Provenance>;\n+\n+            #[inline(always)]\n+            fn ecx(&mut self) -> &mut MiriInterpCx<'mir, 'tcx> {\n+                self.ecx\n+            }\n+\n+            fn visit_box(&mut self, place: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n+                let new_perm = NewPermission::from_box_ty(place.layout.ty, self.kind, self.ecx);\n+                self.retag_ptr_inplace(place, new_perm)\n+            }\n+\n+            fn visit_value(&mut self, place: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n+                // If this place is smaller than a pointer, we know that it can't contain any\n+                // pointers we need to retag, so we can stop recursion early.\n+                // This optimization is crucial for ZSTs, because they can contain way more fields\n+                // than we can ever visit.\n+                if place.layout.is_sized() && place.layout.size < self.ecx.pointer_size() {\n+                    return Ok(());\n+                }\n+\n+                // Check the type of this value to see what to do with it (retag, or recurse).\n+                match place.layout.ty.kind() {\n+                    &ty::Ref(_, pointee, mutability) => {\n+                        let new_perm =\n+                            NewPermission::from_ref_ty(pointee, mutability, self.kind, self.ecx);\n+                        self.retag_ptr_inplace(place, new_perm)?;\n+                    }\n+                    ty::RawPtr(_) => {\n+                        // We definitely do *not* want to recurse into raw pointers -- wide raw\n+                        // pointers have fields, and for dyn Trait pointees those can have reference\n+                        // type!\n+                        // We also do not want to reborrow them.\n+                    }\n+                    ty::Adt(adt, _) if adt.is_box() => {\n+                        // Recurse for boxes, they require some tricky handling and will end up in `visit_box` above.\n+                        // (Yes this means we technically also recursively retag the allocator itself\n+                        // even if field retagging is not enabled. *shrug*)\n+                        self.walk_value(place)?;\n+                    }\n+                    _ => {\n+                        // Not a reference/pointer/box. Only recurse if configured appropriately.\n+                        let recurse = match self.retag_fields {\n+                            RetagFields::No => false,\n+                            RetagFields::Yes => true,\n+                            RetagFields::OnlyScalar => {\n+                                // Matching `ArgAbi::new` at the time of writing, only fields of\n+                                // `Scalar` and `ScalarPair` ABI are considered.\n+                                matches!(place.layout.abi, Abi::Scalar(..) | Abi::ScalarPair(..))\n+                            }\n+                        };\n+                        if recurse {\n+                            self.walk_value(place)?;\n+                        }\n+                    }\n+                }\n+\n+                Ok(())\n+            }\n+        }\n+    }\n+\n+    /// After a stack frame got pushed, retag the return place so that we are sure\n+    /// it does not alias with anything.\n+    ///\n+    /// This is a HACK because there is nothing in MIR that would make the retag\n+    /// explicit. Also see <https://github.com/rust-lang/rust/issues/71117>.\n+    fn tb_retag_return_place(&mut self) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        //this.debug_hint_location();\n+        let return_place = &this.frame().return_place;\n+        if return_place.layout.is_zst() {\n+            // There may not be any memory here, nothing to do.\n+            return Ok(());\n+        }\n+        // We need this to be in-memory to use tagged pointers.\n+        let return_place = this.force_allocation(&return_place.clone())?;\n+\n+        // We have to turn the place into a pointer to use the existing code.\n+        // (The pointer type does not matter, so we use a raw pointer.)\n+        let ptr_layout = this.layout_of(this.tcx.mk_mut_ptr(return_place.layout.ty))?;\n+        let val = ImmTy::from_immediate(return_place.to_ref(this), ptr_layout);\n+        // Reborrow it. With protection! That is part of the point.\n+        // FIXME: do we truly want a 2phase borrow here?\n+        let new_perm = Some(NewPermission {\n+            initial_state: Permission::new_unique_2phase(/*freeze*/ false),\n+            perform_read_access: true,\n+            protector: Some(ProtectorKind::StrongProtector),\n+        });\n+        let val = this.tb_retag_reference(&val, new_perm)?;\n+        // And use reborrowed pointer for return place.\n+        let return_place = this.ref_to_mplace(&val)?;\n+        this.frame_mut().return_place = return_place.into();\n+\n+        Ok(())\n+    }\n+\n+    /// Mark the given tag as exposed. It was found on a pointer with the given AllocId.\n+    fn tb_expose_tag(&mut self, alloc_id: AllocId, tag: BorTag) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        // Function pointers and dead objects don't have an alloc_extra so we ignore them.\n+        // This is okay because accessing them is UB anyway, no need for any Tree Borrows checks.\n+        // NOT using `get_alloc_extra_mut` since this might be a read-only allocation!\n+        let (_size, _align, kind) = this.get_alloc_info(alloc_id);\n+        match kind {\n+            AllocKind::LiveData => {\n+                // This should have alloc_extra data, but `get_alloc_extra` can still fail\n+                // if converting this alloc_id from a global to a local one\n+                // uncovers a non-supported `extern static`.\n+                let alloc_extra = this.get_alloc_extra(alloc_id)?;\n+                trace!(\"Stacked Borrows tag {tag:?} exposed in {alloc_id:?}\");\n+                alloc_extra.borrow_tracker_tb().borrow_mut().expose_tag(tag);\n+            }\n+            AllocKind::Function | AllocKind::VTable | AllocKind::Dead => {\n+                // No tree borrows on these allocations.\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    /// Display the tree.\n+    fn print_tree(&mut self, alloc_id: AllocId, show_unnamed: bool) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let alloc_extra = this.get_alloc_extra(alloc_id)?;\n+        let tree_borrows = alloc_extra.borrow_tracker_tb().borrow();\n+        let borrow_tracker = &this.machine.borrow_tracker.as_ref().unwrap().borrow();\n+        tree_borrows.print_tree(&borrow_tracker.protected_tags, show_unnamed)\n+    }\n+\n+    /// Give a name to the pointer, usually the name it has in the source code (for debugging).\n+    /// The name given is `name` and the pointer that receives it is the `nth_parent`\n+    /// of `ptr` (with 0 representing `ptr` itself)\n+    fn tb_give_pointer_debug_name(\n+        &mut self,\n+        ptr: Pointer<Option<Provenance>>,\n+        nth_parent: u8,\n+        name: &str,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let (tag, alloc_id) = match ptr.provenance {\n+            Some(Provenance::Concrete { tag, alloc_id }) => (tag, alloc_id),\n+            _ => {\n+                eprintln!(\"Can't give the name {name} to Wildcard pointer\");\n+                return Ok(());\n+            }\n+        };\n+        let alloc_extra = this.get_alloc_extra(alloc_id)?;\n+        let mut tree_borrows = alloc_extra.borrow_tracker_tb().borrow_mut();\n+        tree_borrows.give_pointer_debug_name(tag, nth_parent, name)\n+    }\n+}"}]}