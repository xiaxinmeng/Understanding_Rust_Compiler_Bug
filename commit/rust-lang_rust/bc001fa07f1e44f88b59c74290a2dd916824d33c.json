{"sha": "bc001fa07f1e44f88b59c74290a2dd916824d33c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjMDAxZmEwN2YxZTQ0Zjg4YjU5Yzc0MjkwYTJkZDkxNjgyNGQzM2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-15T03:54:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-15T03:54:15Z"}, "message": "Auto merge of #49881 - varkor:partialord-opt, r=Manishearth\n\nFix derive(PartialOrd) and optimise final field operation\n\n```rust\n// Before (`lt` on 2-field struct)\nself.f1 < other.f1 || (!(other.f1 < self.f1) &&\n(self.f2 < other.f2 || (!(other.f2 < self.f2) &&\n(false)\n))\n)\n\n// After\nself.f1 < other.f1 || (!(other.f1 < self.f1) &&\nself.f2 < other.f2\n)\n\n// Before (`le` on 2-field struct)\nself.f1 < other.f1 || (!(other.f1 < self.f1) &&\n(self.f2 < other.f2 || (!(other.f2 < self.f2) &&\n(true)\n))\n)\n\n// After\nself.f1 < other.f1 || (self.f1 == other.f1 &&\nself.f2 <= other.f2\n)\n```\n\n(The big diff is mainly because of a past faulty rustfmt application that I corrected \ud83d\ude12)\n\nFixes #49650 and fixes #49505.", "tree": {"sha": "a55b1eb61a3bf7d791bbe40f2833015679abf36e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a55b1eb61a3bf7d791bbe40f2833015679abf36e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc001fa07f1e44f88b59c74290a2dd916824d33c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc001fa07f1e44f88b59c74290a2dd916824d33c", "html_url": "https://github.com/rust-lang/rust/commit/bc001fa07f1e44f88b59c74290a2dd916824d33c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc001fa07f1e44f88b59c74290a2dd916824d33c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4d43e248340b6acaf02f4439713c160fd77a846", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4d43e248340b6acaf02f4439713c160fd77a846", "html_url": "https://github.com/rust-lang/rust/commit/d4d43e248340b6acaf02f4439713c160fd77a846"}, {"sha": "105c5180941f4034fd0d576a1d4c1bb71dd8e077", "url": "https://api.github.com/repos/rust-lang/rust/commits/105c5180941f4034fd0d576a1d4c1bb71dd8e077", "html_url": "https://github.com/rust-lang/rust/commit/105c5180941f4034fd0d576a1d4c1bb71dd8e077"}], "stats": {"total": 341, "additions": 245, "deletions": 96}, "files": [{"sha": "edb9389c00c58e0b3410bcb74d1e125581b3629b", "filename": "src/etc/generate-deriving-span-tests.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc001fa07f1e44f88b59c74290a2dd916824d33c/src%2Fetc%2Fgenerate-deriving-span-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/bc001fa07f1e44f88b59c74290a2dd916824d33c/src%2Fetc%2Fgenerate-deriving-span-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgenerate-deriving-span-tests.py?ref=bc001fa07f1e44f88b59c74290a2dd916824d33c", "patch": "@@ -122,7 +122,7 @@ def write_file(name, string):\n \n for (trait, supers, errs) in [('Clone', [], 1),\n                               ('PartialEq', [], 2),\n-                              ('PartialOrd', ['PartialEq'], 3),\n+                              ('PartialOrd', ['PartialEq'], 5),\n                               ('Eq', ['PartialEq'], 1),\n                               ('Ord', ['Eq', 'PartialOrd', 'PartialEq'], 1),\n                               ('Debug', [], 1),"}, {"sha": "81ca7e732283d07b3997627013904f7b15315d57", "filename": "src/libsyntax_ext/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 34, "deletions": 27, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/bc001fa07f1e44f88b59c74290a2dd916824d33c/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc001fa07f1e44f88b59c74290a2dd916824d33c/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=bc001fa07f1e44f88b59c74290a2dd916824d33c", "patch": "@@ -26,41 +26,48 @@ pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt,\n                                   push: &mut FnMut(Annotatable)) {\n     // structures are equal if all fields are equal, and non equal, if\n     // any fields are not equal or if the enum variants are different\n-    fn cs_eq(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n-        cs_fold(true, // use foldl\n-                |cx, span, subexpr, self_f, other_fs| {\n+    fn cs_op(cx: &mut ExtCtxt,\n+             span: Span,\n+             substr: &Substructure,\n+             op: BinOpKind,\n+             combiner: BinOpKind,\n+             base: bool)\n+             -> P<Expr>\n+    {\n+        let op = |cx: &mut ExtCtxt, span: Span, self_f: P<Expr>, other_fs: &[P<Expr>]| {\n             let other_f = match (other_fs.len(), other_fs.get(0)) {\n                 (1, Some(o_f)) => o_f,\n                 _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\"),\n             };\n \n-            let eq = cx.expr_binary(span, BinOpKind::Eq, self_f, other_f.clone());\n+            cx.expr_binary(span, op, self_f, other_f.clone())\n+        };\n \n-            cx.expr_binary(span, BinOpKind::And, subexpr, eq)\n-        },\n-                cx.expr_bool(span, true),\n-                Box::new(|cx, span, _, _| cx.expr_bool(span, false)),\n-                cx,\n-                span,\n-                substr)\n+        cs_fold1(true, // use foldl\n+            |cx, span, subexpr, self_f, other_fs| {\n+                let eq = op(cx, span, self_f, other_fs);\n+                cx.expr_binary(span, combiner, subexpr, eq)\n+            },\n+            |cx, args| {\n+                match args {\n+                    Some((span, self_f, other_fs)) => {\n+                        // Special-case the base case to generate cleaner code.\n+                        op(cx, span, self_f, other_fs)\n+                    }\n+                    None => cx.expr_bool(span, base),\n+                }\n+            },\n+            Box::new(|cx, span, _, _| cx.expr_bool(span, !base)),\n+            cx,\n+            span,\n+            substr)\n     }\n-    fn cs_ne(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n-        cs_fold(true, // use foldl\n-                |cx, span, subexpr, self_f, other_fs| {\n-            let other_f = match (other_fs.len(), other_fs.get(0)) {\n-                (1, Some(o_f)) => o_f,\n-                _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\"),\n-            };\n-\n-            let eq = cx.expr_binary(span, BinOpKind::Ne, self_f, other_f.clone());\n \n-            cx.expr_binary(span, BinOpKind::Or, subexpr, eq)\n-        },\n-                cx.expr_bool(span, false),\n-                Box::new(|cx, span, _, _| cx.expr_bool(span, true)),\n-                cx,\n-                span,\n-                substr)\n+    fn cs_eq(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n+        cs_op(cx, span, substr, BinOpKind::Eq, BinOpKind::And, true)\n+    }\n+    fn cs_ne(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n+        cs_op(cx, span, substr, BinOpKind::Ne, BinOpKind::Or, false)\n     }\n \n     macro_rules! md {"}, {"sha": "9560fd0570af7b681153f91e25e10d438f12513f", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 79, "deletions": 47, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/bc001fa07f1e44f88b59c74290a2dd916824d33c/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc001fa07f1e44f88b59c74290a2dd916824d33c/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=bc001fa07f1e44f88b59c74290a2dd916824d33c", "patch": "@@ -190,54 +190,86 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<\n \n /// Strict inequality.\n fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n-    let op = if less { BinOpKind::Lt } else { BinOpKind::Gt };\n-    cs_fold(false, // need foldr,\n-            |cx, span, subexpr, self_f, other_fs| {\n-        // build up a series of chain ||'s and &&'s from the inside\n-        // out (hence foldr) to get lexical ordering, i.e. for op ==\n-        // `ast::lt`\n-        //\n-        // ```\n-        // self.f1 < other.f1 || (!(other.f1 < self.f1) &&\n-        // (self.f2 < other.f2 || (!(other.f2 < self.f2) &&\n-        // (false)\n-        // ))\n-        // )\n-        // ```\n-        //\n-        // The optimiser should remove the redundancy. We explicitly\n-        // get use the binops to avoid auto-deref dereferencing too many\n-        // layers of pointers, if the type includes pointers.\n-        //\n-        let other_f = match (other_fs.len(), other_fs.get(0)) {\n-            (1, Some(o_f)) => o_f,\n-            _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n-        };\n-\n-        let cmp = cx.expr_binary(span, op, self_f.clone(), other_f.clone());\n+    let strict_op = if less { BinOpKind::Lt } else { BinOpKind::Gt };\n+    cs_fold1(false, // need foldr,\n+        |cx, span, subexpr, self_f, other_fs| {\n+            // build up a series of chain ||'s and &&'s from the inside\n+            // out (hence foldr) to get lexical ordering, i.e. for op ==\n+            // `ast::lt`\n+            //\n+            // ```\n+            // self.f1 < other.f1 || (!(other.f1 < self.f1) &&\n+            // self.f2 < other.f2\n+            // )\n+            // ```\n+            //\n+            // and for op ==\n+            // `ast::le`\n+            //\n+            // ```\n+            // self.f1 < other.f1 || (self.f1 == other.f1 &&\n+            // self.f2 <= other.f2\n+            // )\n+            // ```\n+            //\n+            // The optimiser should remove the redundancy. We explicitly\n+            // get use the binops to avoid auto-deref dereferencing too many\n+            // layers of pointers, if the type includes pointers.\n+            //\n+            let other_f = match (other_fs.len(), other_fs.get(0)) {\n+                (1, Some(o_f)) => o_f,\n+                _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n+            };\n \n-        let not_cmp = cx.expr_unary(span,\n-                                    ast::UnOp::Not,\n-                                    cx.expr_binary(span, op, other_f.clone(), self_f));\n+            let strict_ineq = cx.expr_binary(span, strict_op, self_f.clone(), other_f.clone());\n \n-        let and = cx.expr_binary(span, BinOpKind::And, not_cmp, subexpr);\n-        cx.expr_binary(span, BinOpKind::Or, cmp, and)\n-    },\n-            cx.expr_bool(span, equal),\n-            Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n-        if self_args.len() != 2 {\n-            cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n-        } else {\n-            let op = match (less, equal) {\n-                (true, true) => LeOp,\n-                (true, false) => LtOp,\n-                (false, true) => GeOp,\n-                (false, false) => GtOp,\n+            let deleg_cmp = if !equal {\n+                cx.expr_unary(span,\n+                            ast::UnOp::Not,\n+                            cx.expr_binary(span, strict_op, other_f.clone(), self_f))\n+            } else {\n+                cx.expr_binary(span, BinOpKind::Eq, self_f, other_f.clone())\n             };\n-            some_ordering_collapsed(cx, span, op, tag_tuple)\n-        }\n-    }),\n-            cx,\n-            span,\n-            substr)\n+\n+            let and = cx.expr_binary(span, BinOpKind::And, deleg_cmp, subexpr);\n+            cx.expr_binary(span, BinOpKind::Or, strict_ineq, and)\n+        },\n+        |cx, args| {\n+            match args {\n+                Some((span, self_f, other_fs)) => {\n+                    // Special-case the base case to generate cleaner code with\n+                    // fewer operations (e.g. `<=` instead of `<` and `==`).\n+                    let other_f = match (other_fs.len(), other_fs.get(0)) {\n+                        (1, Some(o_f)) => o_f,\n+                        _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n+                    };\n+\n+                    let op = match (less, equal) {\n+                        (false, false) => BinOpKind::Gt,\n+                        (false, true) => BinOpKind::Ge,\n+                        (true, false) => BinOpKind::Lt,\n+                        (true, true) => BinOpKind::Le,\n+                    };\n+\n+                    cx.expr_binary(span, op, self_f, other_f.clone())\n+                }\n+                None => cx.expr_bool(span, equal)\n+            }\n+        },\n+        Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n+            if self_args.len() != 2 {\n+                cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n+            } else {\n+                let op = match (less, equal) {\n+                    (false, false) => GtOp,\n+                    (false, true) => GeOp,\n+                    (true, false) => LtOp,\n+                    (true, true) => LeOp,\n+                };\n+                some_ordering_collapsed(cx, span, op, tag_tuple)\n+            }\n+        }),\n+        cx,\n+        span,\n+        substr)\n }"}, {"sha": "1f80385cfbd24051b7acf05733918f02ba699a54", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 99, "deletions": 17, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/bc001fa07f1e44f88b59c74290a2dd916824d33c/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc001fa07f1e44f88b59c74290a2dd916824d33c/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=bc001fa07f1e44f88b59c74290a2dd916824d33c", "patch": "@@ -1680,12 +1680,55 @@ impl<'a> TraitDef<'a> {\n \n // helpful premade recipes\n \n+pub fn cs_fold_fields<'a, F>(use_foldl: bool,\n+                             mut f: F,\n+                             base: P<Expr>,\n+                             cx: &mut ExtCtxt,\n+                             all_fields: &[FieldInfo<'a>])\n+                             -> P<Expr>\n+    where F: FnMut(&mut ExtCtxt, Span, P<Expr>, P<Expr>, &[P<Expr>]) -> P<Expr>\n+{\n+    if use_foldl {\n+        all_fields.iter().fold(base, |old, field| {\n+            f(cx, field.span, old, field.self_.clone(), &field.other)\n+        })\n+    } else {\n+        all_fields.iter().rev().fold(base, |old, field| {\n+            f(cx, field.span, old, field.self_.clone(), &field.other)\n+        })\n+    }\n+}\n+\n+pub fn cs_fold_enumnonmatch(mut enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n+                            cx: &mut ExtCtxt,\n+                            trait_span: Span,\n+                            substructure: &Substructure)\n+                            -> P<Expr>\n+{\n+    match *substructure.fields {\n+        EnumNonMatchingCollapsed(ref all_args, _, tuple) => {\n+            enum_nonmatch_f(cx,\n+                            trait_span,\n+                            (&all_args[..], tuple),\n+                            substructure.nonself_args)\n+        }\n+        _ => cx.span_bug(trait_span, \"cs_fold_enumnonmatch expected an EnumNonMatchingCollapsed\")\n+    }\n+}\n+\n+pub fn cs_fold_static(cx: &mut ExtCtxt,\n+                      trait_span: Span)\n+                      -> P<Expr>\n+{\n+    cx.span_bug(trait_span, \"static function in `derive`\")\n+}\n+\n /// Fold the fields. `use_foldl` controls whether this is done\n /// left-to-right (`true`) or right-to-left (`false`).\n pub fn cs_fold<F>(use_foldl: bool,\n-                  mut f: F,\n+                  f: F,\n                   base: P<Expr>,\n-                  mut enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n+                  enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n                   cx: &mut ExtCtxt,\n                   trait_span: Span,\n                   substructure: &Substructure)\n@@ -1695,26 +1738,65 @@ pub fn cs_fold<F>(use_foldl: bool,\n     match *substructure.fields {\n         EnumMatching(.., ref all_fields) |\n         Struct(_, ref all_fields) => {\n-            if use_foldl {\n-                all_fields.iter().fold(base, |old, field| {\n-                    f(cx, field.span, old, field.self_.clone(), &field.other)\n-                })\n-            } else {\n-                all_fields.iter().rev().fold(base, |old, field| {\n-                    f(cx, field.span, old, field.self_.clone(), &field.other)\n-                })\n-            }\n+            cs_fold_fields(use_foldl, f, base, cx, all_fields)\n         }\n-        EnumNonMatchingCollapsed(ref all_args, _, tuple) => {\n-            enum_nonmatch_f(cx,\n-                            trait_span,\n-                            (&all_args[..], tuple),\n-                            substructure.nonself_args)\n+        EnumNonMatchingCollapsed(..) => {\n+            cs_fold_enumnonmatch(enum_nonmatch_f, cx, trait_span, substructure)\n+        }\n+        StaticEnum(..) | StaticStruct(..) => {\n+            cs_fold_static(cx, trait_span)\n         }\n-        StaticEnum(..) | StaticStruct(..) => cx.span_bug(trait_span, \"static function in `derive`\"),\n     }\n }\n \n+/// Function to fold over fields, with three cases, to generate more efficient and concise code.\n+/// When the `substructure` has grouped fields, there are two cases:\n+/// Zero fields: call the base case function with None (like the usual base case of `cs_fold`).\n+/// One or more fields: call the base case function on the first value (which depends on\n+/// `use_fold`), and use that as the base case. Then perform `cs_fold` on the remainder of the\n+/// fields.\n+/// When the `substructure` is a `EnumNonMatchingCollapsed`, the result of `enum_nonmatch_f`\n+/// is returned. Statics may not be folded over.\n+/// See `cs_op` in `partial_ord.rs` for a model example.\n+pub fn cs_fold1<F, B>(use_foldl: bool,\n+                      f: F,\n+                      mut b: B,\n+                      enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n+                      cx: &mut ExtCtxt,\n+                      trait_span: Span,\n+                      substructure: &Substructure)\n+                      -> P<Expr>\n+    where F: FnMut(&mut ExtCtxt, Span, P<Expr>, P<Expr>, &[P<Expr>]) -> P<Expr>,\n+          B: FnMut(&mut ExtCtxt, Option<(Span, P<Expr>, &[P<Expr>])>) -> P<Expr>\n+{\n+    match *substructure.fields {\n+        EnumMatching(.., ref all_fields) |\n+        Struct(_, ref all_fields) => {\n+            let (base, all_fields) = match (all_fields.is_empty(), use_foldl) {\n+                (false, true) => {\n+                    let field = &all_fields[0];\n+                    let args = (field.span, field.self_.clone(), &field.other[..]);\n+                    (b(cx, Some(args)), &all_fields[1..])\n+                }\n+                (false, false) => {\n+                    let idx = all_fields.len() - 1;\n+                    let field = &all_fields[idx];\n+                    let args = (field.span, field.self_.clone(), &field.other[..]);\n+                    (b(cx, Some(args)), &all_fields[..idx])\n+                }\n+                (true, _) => (b(cx, None), &all_fields[..])\n+            };\n+\n+            cs_fold_fields(use_foldl, f, base, cx, all_fields)\n+        }\n+        EnumNonMatchingCollapsed(..) => {\n+            cs_fold_enumnonmatch(enum_nonmatch_f, cx, trait_span, substructure)\n+        }\n+        StaticEnum(..) | StaticStruct(..) => {\n+            cs_fold_static(cx, trait_span)\n+        }\n+    }\n+}\n \n /// Call the method that is being derived on all the fields, and then\n /// process the collected results. i.e."}, {"sha": "dcf02f308307d0b97c5d93c3161938a690664c0f", "filename": "src/test/compile-fail/derives-span-PartialOrd-enum-struct-variant.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc001fa07f1e44f88b59c74290a2dd916824d33c/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc001fa07f1e44f88b59c74290a2dd916824d33c/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-enum-struct-variant.rs?ref=bc001fa07f1e44f88b59c74290a2dd916824d33c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -19,6 +19,8 @@ enum Enum {\n      x: Error //~ ERROR\n //~^ ERROR\n //~^^ ERROR\n+//~^^^ ERROR\n+//~^^^^ ERROR\n    }\n }\n "}, {"sha": "7eb44c7e19e84a7d88a1bf874ffcc42394af2343", "filename": "src/test/compile-fail/derives-span-PartialOrd-enum.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc001fa07f1e44f88b59c74290a2dd916824d33c/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc001fa07f1e44f88b59c74290a2dd916824d33c/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-enum.rs?ref=bc001fa07f1e44f88b59c74290a2dd916824d33c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -19,6 +19,8 @@ enum Enum {\n      Error //~ ERROR\n //~^ ERROR\n //~^^ ERROR\n+//~^^^ ERROR\n+//~^^^^ ERROR\n      )\n }\n "}, {"sha": "36dae0124ce9bf410f872bc12823240e778ab9f7", "filename": "src/test/compile-fail/derives-span-PartialOrd-struct.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc001fa07f1e44f88b59c74290a2dd916824d33c/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc001fa07f1e44f88b59c74290a2dd916824d33c/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-struct.rs?ref=bc001fa07f1e44f88b59c74290a2dd916824d33c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -18,6 +18,8 @@ struct Struct {\n     x: Error //~ ERROR\n //~^ ERROR\n //~^^ ERROR\n+//~^^^ ERROR\n+//~^^^^ ERROR\n }\n \n fn main() {}"}, {"sha": "fd2df0967545b9eb23b9a0be7e52787b84376cb0", "filename": "src/test/compile-fail/derives-span-PartialOrd-tuple-struct.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc001fa07f1e44f88b59c74290a2dd916824d33c/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc001fa07f1e44f88b59c74290a2dd916824d33c/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderives-span-PartialOrd-tuple-struct.rs?ref=bc001fa07f1e44f88b59c74290a2dd916824d33c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -18,6 +18,8 @@ struct Struct(\n     Error //~ ERROR\n //~^ ERROR\n //~^^ ERROR\n+//~^^^ ERROR\n+//~^^^^ ERROR\n );\n \n fn main() {}"}, {"sha": "df766e361d5bdb553c8f62f2ca218495d80d1856", "filename": "src/test/compile-fail/range_traits-1.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc001fa07f1e44f88b59c74290a2dd916824d33c/src%2Ftest%2Fcompile-fail%2Frange_traits-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc001fa07f1e44f88b59c74290a2dd916824d33c/src%2Ftest%2Fcompile-fail%2Frange_traits-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange_traits-1.rs?ref=bc001fa07f1e44f88b59c74290a2dd916824d33c", "patch": "@@ -42,6 +42,8 @@ struct AllTheRanges {\n     //~^^ ERROR Ord\n     //~^^^ ERROR binary operation `<` cannot be applied to type\n     //~^^^^ ERROR binary operation `>` cannot be applied to type\n+    //~^^^^^ ERROR binary operation `<=` cannot be applied to type\n+    //~^^^^^^ ERROR binary operation `>=` cannot be applied to type\n }\n \n fn main() {}"}, {"sha": "bc9e9a700875ebe5f9b8a858c952dec9f021b5e8", "filename": "src/test/run-pass/derive-partialord-correctness.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bc001fa07f1e44f88b59c74290a2dd916824d33c/src%2Ftest%2Frun-pass%2Fderive-partialord-correctness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc001fa07f1e44f88b59c74290a2dd916824d33c/src%2Ftest%2Frun-pass%2Fderive-partialord-correctness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderive-partialord-correctness.rs?ref=bc001fa07f1e44f88b59c74290a2dd916824d33c", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Original issue: #49650\n+\n+#[derive(PartialOrd, PartialEq)]\n+struct FloatWrapper(f64);\n+\n+fn main() {\n+    assert!((0.0 / 0.0 >= 0.0) == (FloatWrapper(0.0 / 0.0) >= FloatWrapper(0.0)))\n+}"}]}