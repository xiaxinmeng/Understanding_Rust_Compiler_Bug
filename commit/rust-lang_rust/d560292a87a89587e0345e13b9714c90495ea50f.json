{"sha": "d560292a87a89587e0345e13b9714c90495ea50f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1NjAyOTJhODdhODk1ODdlMDM0NWUxM2I5NzE0YzkwNDk1ZWE1MGY=", "commit": {"author": {"name": "Cl\u00e9ment Renault", "email": "renault.cle@gmail.com", "date": "2018-09-16T21:32:16Z"}, "committer": {"name": "Cl\u00e9ment Renault", "email": "renault.cle@gmail.com", "date": "2018-09-23T07:10:18Z"}, "message": "Make the `Vec::dedup` method use `slice::partition_dedup` internally", "tree": {"sha": "692cc0e59911e34216a61ffde239e67523b96427", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/692cc0e59911e34216a61ffde239e67523b96427"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d560292a87a89587e0345e13b9714c90495ea50f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d560292a87a89587e0345e13b9714c90495ea50f", "html_url": "https://github.com/rust-lang/rust/commit/d560292a87a89587e0345e13b9714c90495ea50f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d560292a87a89587e0345e13b9714c90495ea50f/comments", "author": {"login": "Kerollmops", "id": 3610253, "node_id": "MDQ6VXNlcjM2MTAyNTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3610253?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kerollmops", "html_url": "https://github.com/Kerollmops", "followers_url": "https://api.github.com/users/Kerollmops/followers", "following_url": "https://api.github.com/users/Kerollmops/following{/other_user}", "gists_url": "https://api.github.com/users/Kerollmops/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kerollmops/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kerollmops/subscriptions", "organizations_url": "https://api.github.com/users/Kerollmops/orgs", "repos_url": "https://api.github.com/users/Kerollmops/repos", "events_url": "https://api.github.com/users/Kerollmops/events{/privacy}", "received_events_url": "https://api.github.com/users/Kerollmops/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kerollmops", "id": 3610253, "node_id": "MDQ6VXNlcjM2MTAyNTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3610253?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kerollmops", "html_url": "https://github.com/Kerollmops", "followers_url": "https://api.github.com/users/Kerollmops/followers", "following_url": "https://api.github.com/users/Kerollmops/following{/other_user}", "gists_url": "https://api.github.com/users/Kerollmops/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kerollmops/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kerollmops/subscriptions", "organizations_url": "https://api.github.com/users/Kerollmops/orgs", "repos_url": "https://api.github.com/users/Kerollmops/repos", "events_url": "https://api.github.com/users/Kerollmops/events{/privacy}", "received_events_url": "https://api.github.com/users/Kerollmops/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78bccb3540ae8082d34e45be5abb19ed720e9a32", "url": "https://api.github.com/repos/rust-lang/rust/commits/78bccb3540ae8082d34e45be5abb19ed720e9a32", "html_url": "https://github.com/rust-lang/rust/commit/78bccb3540ae8082d34e45be5abb19ed720e9a32"}], "stats": {"total": 91, "additions": 7, "deletions": 84}, "files": [{"sha": "6ce24b65990622b848b63912a4d94bd28f636c9a", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d560292a87a89587e0345e13b9714c90495ea50f/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d560292a87a89587e0345e13b9714c90495ea50f/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=d560292a87a89587e0345e13b9714c90495ea50f", "patch": "@@ -119,6 +119,7 @@\n #![feature(exact_chunks)]\n #![feature(rustc_const_unstable)]\n #![feature(const_vec_new)]\n+#![feature(slice_partition_dedup)]\n #![feature(maybe_uninit)]\n \n // Allow testing this library"}, {"sha": "e845438c0a836972d56a39c72cd7f897e6a1e626", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 6, "deletions": 84, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/d560292a87a89587e0345e13b9714c90495ea50f/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d560292a87a89587e0345e13b9714c90495ea50f/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=d560292a87a89587e0345e13b9714c90495ea50f", "patch": "@@ -963,90 +963,12 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec, [\"foo\", \"bar\", \"baz\", \"bar\"]);\n     /// ```\n     #[stable(feature = \"dedup_by\", since = \"1.16.0\")]\n-    pub fn dedup_by<F>(&mut self, mut same_bucket: F) where F: FnMut(&mut T, &mut T) -> bool {\n-        unsafe {\n-            // Although we have a mutable reference to `self`, we cannot make\n-            // *arbitrary* changes. The `same_bucket` calls could panic, so we\n-            // must ensure that the vector is in a valid state at all time.\n-            //\n-            // The way that we handle this is by using swaps; we iterate\n-            // over all the elements, swapping as we go so that at the end\n-            // the elements we wish to keep are in the front, and those we\n-            // wish to reject are at the back. We can then truncate the\n-            // vector. This operation is still O(n).\n-            //\n-            // Example: We start in this state, where `r` represents \"next\n-            // read\" and `w` represents \"next_write`.\n-            //\n-            //           r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //           w\n-            //\n-            // Comparing self[r] against self[w-1], this is not a duplicate, so\n-            // we swap self[r] and self[w] (no effect as r==w) and then increment both\n-            // r and w, leaving us with:\n-            //\n-            //               r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //               w\n-            //\n-            // Comparing self[r] against self[w-1], this value is a duplicate,\n-            // so we increment `r` but leave everything else unchanged:\n-            //\n-            //                   r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //               w\n-            //\n-            // Comparing self[r] against self[w-1], this is not a duplicate,\n-            // so swap self[r] and self[w] and advance r and w:\n-            //\n-            //                       r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 2 | 1 | 3 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //                   w\n-            //\n-            // Not a duplicate, repeat:\n-            //\n-            //                           r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 2 | 3 | 1 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //                       w\n-            //\n-            // Duplicate, advance r. End of vec. Truncate to w.\n-\n-            let ln = self.len();\n-            if ln <= 1 {\n-                return;\n-            }\n-\n-            // Avoid bounds checks by using raw pointers.\n-            let p = self.as_mut_ptr();\n-            let mut r: usize = 1;\n-            let mut w: usize = 1;\n-\n-            while r < ln {\n-                let p_r = p.add(r);\n-                let p_wm1 = p.add(w - 1);\n-                if !same_bucket(&mut *p_r, &mut *p_wm1) {\n-                    if r != w {\n-                        let p_w = p_wm1.offset(1);\n-                        mem::swap(&mut *p_r, &mut *p_w);\n-                    }\n-                    w += 1;\n-                }\n-                r += 1;\n-            }\n-\n-            self.truncate(w);\n-        }\n+    pub fn dedup_by<F>(&mut self, same_bucket: F) where F: FnMut(&mut T, &mut T) -> bool {\n+        let len = {\n+            let (dedup, _) = self.as_mut_slice().partition_dedup_by(same_bucket);\n+            dedup.len()\n+        };\n+        self.truncate(len);\n     }\n \n     /// Appends an element to the back of a collection."}]}