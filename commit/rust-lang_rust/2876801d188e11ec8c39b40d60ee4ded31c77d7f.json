{"sha": "2876801d188e11ec8c39b40d60ee4ded31c77d7f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4NzY4MDFkMTg4ZTExZWM4YzM5YjQwZDYwZWU0ZGVkMzFjNzdkN2Y=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-01-25T00:37:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-01-25T00:37:00Z"}, "message": "Rollup merge of #57652 - mark-i-m:remove-old, r=nikomatsakis\n\nUpdate/remove some old readmes\n\nr? @nikomatsakis\n\ncc #48478\n\nThere are a bunch of READMEs with content that I would like to see a final decision made on:\n- https://github.com/rust-lang/rust/tree/master/src/librustc/ty/query\n- https://github.com/rust-lang/rust/tree/master/src/librustc/dep_graph\n- https://github.com/rust-lang/rust/blob/master/src/librustc/infer/region_constraints\n- https://github.com/rust-lang/rust/tree/master/src/librustc/infer/higher_ranked\n- https://github.com/rust-lang/rust/tree/master/src/librustc/infer/lexical_region_resolve\n- https://github.com/rust-lang/rust/blob/master/src/librustc_borrowck/borrowck\n\nIt's not clear how useful or obsolete any of these are. I would really appreciate if the appropriate domain experts for each of these could respond with one of (a) delete it, (b) wait for system to be remove, or (c) move it to rustc-guide. @nikomatsakis do you know who to ping for any of these (sorry, I suspect many of them are you)?", "tree": {"sha": "5582d7629b67191bab66d39d78a00100608df9c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5582d7629b67191bab66d39d78a00100608df9c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2876801d188e11ec8c39b40d60ee4ded31c77d7f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcSlosCRBK7hj4Ov3rIwAAdHIIAGPQhEcuxWh6Yz1LPUjnmnUd\ncrl0rukWSxRoHzf1PxLIX6zn3ejY1seNwBvnwCnlPM05kAPdIKYhjfCHd//xKIY9\n9t3muh1XEBNlMZ5oEM/xi2UWd/kSvDQoPrWaJ1Em2o4zVX2HWAys5uiDRfO5MY/u\ncVZCTSF7IC7rMSJaF/QsG5KG9G/0UZPvvXJxzNFghRmCx4CSwFep8BmLSCnUHzXy\nzx9EPuUs1M51+zta41GGu4HGxMY/9AjDVW4TBIRJKqRLa4BXsxPiYDpyCot9SRE8\naLCR6DAAHYgRCsWvB5h96zJwrhrXty1hjacT6HLxy6xp7B1W+NJ1RbyhyvHDL/4=\n=rgMo\n-----END PGP SIGNATURE-----\n", "payload": "tree 5582d7629b67191bab66d39d78a00100608df9c1\nparent f20c6c8581f5fb5c7cb679736d7a0dcbefa7b038\nparent dcd56d11da6e1d7cb8874d27d1fbb4f6a94a71de\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1548376620 +0100\ncommitter GitHub <noreply@github.com> 1548376620 +0100\n\nRollup merge of #57652 - mark-i-m:remove-old, r=nikomatsakis\n\nUpdate/remove some old readmes\n\nr? @nikomatsakis\n\ncc #48478\n\nThere are a bunch of READMEs with content that I would like to see a final decision made on:\n- https://github.com/rust-lang/rust/tree/master/src/librustc/ty/query\n- https://github.com/rust-lang/rust/tree/master/src/librustc/dep_graph\n- https://github.com/rust-lang/rust/blob/master/src/librustc/infer/region_constraints\n- https://github.com/rust-lang/rust/tree/master/src/librustc/infer/higher_ranked\n- https://github.com/rust-lang/rust/tree/master/src/librustc/infer/lexical_region_resolve\n- https://github.com/rust-lang/rust/blob/master/src/librustc_borrowck/borrowck\n\nIt's not clear how useful or obsolete any of these are. I would really appreciate if the appropriate domain experts for each of these could respond with one of (a) delete it, (b) wait for system to be remove, or (c) move it to rustc-guide. @nikomatsakis do you know who to ping for any of these (sorry, I suspect many of them are you)?\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2876801d188e11ec8c39b40d60ee4ded31c77d7f", "html_url": "https://github.com/rust-lang/rust/commit/2876801d188e11ec8c39b40d60ee4ded31c77d7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2876801d188e11ec8c39b40d60ee4ded31c77d7f/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f20c6c8581f5fb5c7cb679736d7a0dcbefa7b038", "url": "https://api.github.com/repos/rust-lang/rust/commits/f20c6c8581f5fb5c7cb679736d7a0dcbefa7b038", "html_url": "https://github.com/rust-lang/rust/commit/f20c6c8581f5fb5c7cb679736d7a0dcbefa7b038"}, {"sha": "dcd56d11da6e1d7cb8874d27d1fbb4f6a94a71de", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcd56d11da6e1d7cb8874d27d1fbb4f6a94a71de", "html_url": "https://github.com/rust-lang/rust/commit/dcd56d11da6e1d7cb8874d27d1fbb4f6a94a71de"}], "stats": {"total": 957, "additions": 93, "deletions": 864}, "files": [{"sha": "14e773286bc6a21ccf06c6d281f641f787675630", "filename": "src/README.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2876801d188e11ec8c39b40d60ee4ded31c77d7f/src%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/2876801d188e11ec8c39b40d60ee4ded31c77d7f/src%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FREADME.md?ref=2876801d188e11ec8c39b40d60ee4ded31c77d7f", "patch": "@@ -8,7 +8,6 @@ For more information on how various parts of the compiler work, see the [rustc g\n There is also useful content in the following READMEs, which are gradually being moved over to the guide:\n - https://github.com/rust-lang/rust/tree/master/src/librustc/ty/query\n - https://github.com/rust-lang/rust/tree/master/src/librustc/dep_graph\n-- https://github.com/rust-lang/rust/blob/master/src/librustc/infer/region_constraints\n - https://github.com/rust-lang/rust/tree/master/src/librustc/infer/higher_ranked\n - https://github.com/rust-lang/rust/tree/master/src/librustc/infer/lexical_region_resolve\n "}, {"sha": "e7afaa5beb0a75adcc35dca489ddbfe834cc0419", "filename": "src/librustc/infer/higher_ranked/README.md", "status": "modified", "additions": 6, "deletions": 401, "changes": 407, "blob_url": "https://github.com/rust-lang/rust/blob/2876801d188e11ec8c39b40d60ee4ded31c77d7f/src%2Flibrustc%2Finfer%2Fhigher_ranked%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/2876801d188e11ec8c39b40d60ee4ded31c77d7f/src%2Flibrustc%2Finfer%2Fhigher_ranked%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2FREADME.md?ref=2876801d188e11ec8c39b40d60ee4ded31c77d7f", "patch": "@@ -1,403 +1,8 @@\n-# Skolemization and functions\n+To learn more about how Higher-ranked trait bounds work in the _old_ trait\n+solver, see [this chapter][oldhrtb] of the rustc-guide.\n \n-One of the trickiest and most subtle aspects of regions is dealing\n-with higher-ranked things which include bound region variables, such\n-as function types. I strongly suggest that if you want to understand\n-the situation, you read this paper (which is, admittedly, very long,\n-but you don't have to read the whole thing):\n+To learn more about how they work in the _new_ trait solver, see [this\n+chapter][newhrtb].\n \n-http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/\n-\n-Although my explanation will never compete with SPJ's (for one thing,\n-his is approximately 100 pages), I will attempt to explain the basic\n-problem and also how we solve it. Note that the paper only discusses\n-subtyping, not the computation of LUB/GLB.\n-\n-The problem we are addressing is that there is a kind of subtyping\n-between functions with bound region parameters. Consider, for\n-example, whether the following relation holds:\n-\n-    for<'a> fn(&'a isize) <: for<'b> fn(&'b isize)? (Yes, a => b)\n-\n-The answer is that of course it does. These two types are basically\n-the same, except that in one we used the name `a` and one we used\n-the name `b`.\n-\n-In the examples that follow, it becomes very important to know whether\n-a lifetime is bound in a function type (that is, is a lifetime\n-parameter) or appears free (is defined in some outer scope).\n-Therefore, from now on I will always write the bindings explicitly,\n-using the Rust syntax `for<'a> fn(&'a isize)` to indicate that `a` is a\n-lifetime parameter.\n-\n-Now let's consider two more function types. Here, we assume that the\n-`'b` lifetime is defined somewhere outside and hence is not a lifetime\n-parameter bound by the function type (it \"appears free\"):\n-\n-    for<'a> fn(&'a isize) <: fn(&'b isize)? (Yes, a => b)\n-\n-This subtyping relation does in fact hold. To see why, you have to\n-consider what subtyping means. One way to look at `T1 <: T2` is to\n-say that it means that it is always ok to treat an instance of `T1` as\n-if it had the type `T2`. So, with our functions, it is always ok to\n-treat a function that can take pointers with any lifetime as if it\n-were a function that can only take a pointer with the specific\n-lifetime `'b`. After all, `'b` is a lifetime, after all, and\n-the function can take values of any lifetime.\n-\n-You can also look at subtyping as the *is a* relationship. This amounts\n-to the same thing: a function that accepts pointers with any lifetime\n-*is a* function that accepts pointers with some specific lifetime.\n-\n-So, what if we reverse the order of the two function types, like this:\n-\n-    fn(&'b isize) <: for<'a> fn(&'a isize)? (No)\n-\n-Does the subtyping relationship still hold?  The answer of course is\n-no. In this case, the function accepts *only the lifetime `'b`*,\n-so it is not reasonable to treat it as if it were a function that\n-accepted any lifetime.\n-\n-What about these two examples:\n-\n-    for<'a,'b> fn(&'a isize, &'b isize) <: for<'a>    fn(&'a isize, &'a isize)? (Yes)\n-    for<'a>    fn(&'a isize, &'a isize) <: for<'a,'b> fn(&'a isize, &'b isize)? (No)\n-\n-Here, it is true that functions which take two pointers with any two\n-lifetimes can be treated as if they only accepted two pointers with\n-the same lifetime, but not the reverse.\n-\n-## The algorithm\n-\n-Here is the algorithm we use to perform the subtyping check:\n-\n-1. Replace all bound regions in the subtype with new variables\n-2. Replace all bound regions in the supertype with placeholder\n-   equivalents. A \"placeholder\" region is just a new fresh region\n-   name.\n-3. Check that the parameter and return types match as normal\n-4. Ensure that no placeholder regions 'leak' into region variables\n-   visible from \"the outside\"\n-\n-Let's walk through some examples and see how this algorithm plays out.\n-\n-#### First example\n-\n-We'll start with the first example, which was:\n-\n-    1. for<'a> fn(&'a T) <: for<'b> fn(&'b T)?        Yes: a -> b\n-\n-After steps 1 and 2 of the algorithm we will have replaced the types\n-like so:\n-\n-    1. fn(&'A T) <: fn(&'x T)?\n-\n-Here the upper case `&A` indicates a *region variable*, that is, a\n-region whose value is being inferred by the system. I also replaced\n-`&b` with `&x`---I'll use letters late in the alphabet (`x`, `y`, `z`)\n-to indicate placeholder region names. We can assume they don't appear\n-elsewhere. Note that neither the sub- nor the supertype bind any\n-region names anymore (as indicated by the absence of `<` and `>`).\n-\n-The next step is to check that the parameter types match. Because\n-parameters are contravariant, this means that we check whether:\n-\n-    &'x T <: &'A T\n-\n-Region pointers are contravariant so this implies that\n-\n-    &A <= &x\n-\n-must hold, where `<=` is the subregion relationship. Processing\n-*this* constrain simply adds a constraint into our graph that `&A <=\n-&x` and is considered successful (it can, for example, be satisfied by\n-choosing the value `&x` for `&A`).\n-\n-So far we have encountered no error, so the subtype check succeeds.\n-\n-#### The third example\n-\n-Now let's look first at the third example, which was:\n-\n-    3. fn(&'a T)    <: for<'b> fn(&'b T)?        No!\n-\n-After steps 1 and 2 of the algorithm we will have replaced the types\n-like so:\n-\n-    3. fn(&'a T) <: fn(&'x T)?\n-\n-This looks pretty much the same as before, except that on the LHS\n-`'a` was not bound, and hence was left as-is and not replaced with\n-a variable. The next step is again to check that the parameter types\n-match. This will ultimately require (as before) that `'a` <= `&x`\n-must hold: but this does not hold. `self` and `x` are both distinct\n-free regions. So the subtype check fails.\n-\n-#### Checking for placeholder leaks\n-\n-You may be wondering about that mysterious last step in the algorithm.\n-So far it has not been relevant. The purpose of that last step is to\n-catch something like *this*:\n-\n-    for<'a> fn() -> fn(&'a T) <: fn() -> for<'b> fn(&'b T)?   No.\n-\n-Here the function types are the same but for where the binding occurs.\n-The subtype returns a function that expects a value in precisely one\n-region. The supertype returns a function that expects a value in any\n-region. If we allow an instance of the subtype to be used where the\n-supertype is expected, then, someone could call the fn and think that\n-the return value has type `fn<b>(&'b T)` when it really has type\n-`fn(&'a T)` (this is case #3, above). Bad.\n-\n-So let's step through what happens when we perform this subtype check.\n-We first replace the bound regions in the subtype (the supertype has\n-no bound regions). This gives us:\n-\n-    fn() -> fn(&'A T) <: fn() -> for<'b> fn(&'b T)?\n-\n-Now we compare the return types, which are covariant, and hence we have:\n-\n-    fn(&'A T) <: for<'b> fn(&'b T)?\n-\n-Here we replace the bound region in the supertype with a placeholder to yield:\n-\n-    fn(&'A T) <: fn(&'x T)?\n-\n-And then proceed to compare the argument types:\n-\n-    &'x T <: &'A T\n-    'A <= 'x\n-\n-Finally, this is where it gets interesting!  This is where an error\n-*should* be reported. But in fact this will not happen. The reason why\n-is that `A` is a variable: we will infer that its value is the fresh\n-region `x` and think that everything is happy. In fact, this behavior\n-is *necessary*, it was key to the first example we walked through.\n-\n-The difference between this example and the first one is that the variable\n-`A` already existed at the point where the placeholders were added. In\n-the first example, you had two functions:\n-\n-    for<'a> fn(&'a T) <: for<'b> fn(&'b T)\n-\n-and hence `&A` and `&x` were created \"together\". In general, the\n-intention of the placeholder names is that they are supposed to be\n-fresh names that could never be equal to anything from the outside.\n-But when inference comes into play, we might not be respecting this\n-rule.\n-\n-So the way we solve this is to add a fourth step that examines the\n-constraints that refer to placeholder names. Basically, consider a\n-non-directed version of the constraint graph. Let `Tainted(x)` be the\n-set of all things reachable from a placeholder variable `x`.\n-`Tainted(x)` should not contain any regions that existed before the\n-step at which the placeholders were created. So this case here\n-would fail because `&x` was created alone, but is relatable to `&A`.\n-\n-## Computing the LUB and GLB\n-\n-The paper I pointed you at is written for Haskell. It does not\n-therefore considering subtyping and in particular does not consider\n-LUB or GLB computation. We have to consider this. Here is the\n-algorithm I implemented.\n-\n-First though, let's discuss what we are trying to compute in more\n-detail. The LUB is basically the \"common supertype\" and the GLB is\n-\"common subtype\"; one catch is that the LUB should be the\n-*most-specific* common supertype and the GLB should be *most general*\n-common subtype (as opposed to any common supertype or any common\n-subtype).\n-\n-Anyway, to help clarify, here is a table containing some function\n-pairs and their LUB/GLB (for conciseness, in this table, I'm just\n-including the lifetimes here, not the rest of the types, and I'm\n-writing `fn<>` instead of `for<> fn`):\n-\n-```\n-Type 1                Type 2                LUB                    GLB\n-fn<'a>('a)            fn('X)                fn('X)                 fn<'a>('a)\n-fn('a)                fn('X)                --                     fn<'a>('a)\n-fn<'a,'b>('a, 'b)     fn<'x>('x, 'x)        fn<'a>('a, 'a)         fn<'a,'b>('a, 'b)\n-fn<'a,'b>('a, 'b, 'a) fn<'x,'y>('x, 'y, 'y) fn<'a>('a, 'a, 'a)     fn<'a,'b,'c>('a,'b,'c)\n-```\n-\n-### Conventions\n-\n-I use lower-case letters (e.g., `&a`) for bound regions and upper-case\n-letters for free regions (`&A`).  Region variables written with a\n-dollar-sign (e.g., `$a`).  I will try to remember to enumerate the\n-bound-regions on the fn type as well (e.g., `for<'a> fn(&a)`).\n-\n-### High-level summary\n-\n-Both the LUB and the GLB algorithms work in a similar fashion.  They\n-begin by replacing all bound regions (on both sides) with fresh region\n-inference variables.  Therefore, both functions are converted to types\n-that contain only free regions.  We can then compute the LUB/GLB in a\n-straightforward way, as described in `combine.rs`.  This results in an\n-interim type T.  The algorithms then examine the regions that appear\n-in T and try to, in some cases, replace them with bound regions to\n-yield the final result.\n-\n-To decide whether to replace a region `R` that appears in `T` with\n-a bound region, the algorithms make use of two bits of\n-information.  First is a set `V` that contains all region\n-variables created as part of the LUB/GLB computation (roughly; see\n-`region_vars_confined_to_snapshot()` for full details). `V` will\n-contain the region variables created to replace the bound regions\n-in the input types, but it also contains 'intermediate' variables\n-created to represent the LUB/GLB of individual regions.\n-Basically, when asked to compute the LUB/GLB of a region variable\n-with another region, the inferencer cannot oblige immediately\n-since the values of that variables are not known.  Therefore, it\n-creates a new variable that is related to the two regions.  For\n-example, the LUB of two variables `$x` and `$y` is a fresh\n-variable `$z` that is constrained such that `$x <= $z` and `$y <=\n-$z`.  So `V` will contain these intermediate variables as well.\n-\n-The other important factor in deciding how to replace a region in T is\n-the function `Tainted($r)` which, for a region variable, identifies\n-all regions that the region variable is related to in some way\n-(`Tainted()` made an appearance in the subtype computation as well).\n-\n-### LUB\n-\n-The LUB algorithm proceeds in three steps:\n-\n-1. Replace all bound regions (on both sides) with fresh region\n-   inference variables.\n-2. Compute the LUB \"as normal\", meaning compute the GLB of each\n-   pair of argument types and the LUB of the return types and\n-   so forth.  Combine those to a new function type `F`.\n-3. Replace each region `R` that appears in `F` as follows:\n-   - Let `V` be the set of variables created during the LUB\n-     computational steps 1 and 2, as described in the previous section.\n-   - If `R` is not in `V`, replace `R` with itself.\n-   - If `Tainted(R)` contains a region that is not in `V`,\n-     replace `R` with itself.\n-   - Otherwise, select the earliest variable in `Tainted(R)` that originates\n-     from the left-hand side and replace `R` with the bound region that\n-     this variable was a replacement for.\n-\n-So, let's work through the simplest example: `fn(&A)` and `for<'a> fn(&a)`.\n-In this case, `&a` will be replaced with `$a` and the interim LUB type\n-`fn($b)` will be computed, where `$b=GLB(&A,$a)`.  Therefore, `V =\n-{$a, $b}` and `Tainted($b) = { $b, $a, &A }`.  When we go to replace\n-`$b`, we find that since `&A \\in Tainted($b)` is not a member of `V`,\n-we leave `$b` as is.  When region inference happens, `$b` will be\n-resolved to `&A`, as we wanted.\n-\n-Let's look at a more complex one: `fn(&a, &b)` and `fn(&x, &x)`.  In\n-this case, we'll end up with a (pre-replacement) LUB type of `fn(&g,\n-&h)` and a graph that looks like:\n-\n-```\n-     $a        $b     *--$x\n-       \\        \\    /  /\n-        \\        $h-*  /\n-         $g-----------*\n-```\n-\n-Here `$g` and `$h` are fresh variables that are created to represent\n-the LUB/GLB of things requiring inference.  This means that `V` and\n-`Tainted` will look like:\n-\n-```\n-V = {$a, $b, $g, $h, $x}\n-Tainted($g) = Tainted($h) = { $a, $b, $h, $g, $x }\n-```\n-\n-Therefore we replace both `$g` and `$h` with `$a`, and end up\n-with the type `fn(&a, &a)`.\n-\n-### GLB\n-\n-The procedure for computing the GLB is similar.  The difference lies\n-in computing the replacements for the various variables. For each\n-region `R` that appears in the type `F`, we again compute `Tainted(R)`\n-and examine the results:\n-\n-1. If `R` is not in `V`, it is not replaced.\n-2. Else, if `Tainted(R)` contains only variables in `V`, and it\n-   contains exactly one variable from the LHS and one variable from\n-   the RHS, then `R` can be mapped to the bound version of the\n-   variable from the LHS.\n-3. Else, if `Tainted(R)` contains no variable from the LHS and no\n-   variable from the RHS, then `R` can be mapped to itself.\n-4. Else, `R` is mapped to a fresh bound variable.\n-\n-These rules are pretty complex.  Let's look at some examples to see\n-how they play out.\n-\n-Out first example was `fn(&a)` and `fn(&X)`.  In this case, `&a` will\n-be replaced with `$a` and we will ultimately compute a\n-(pre-replacement) GLB type of `fn($g)` where `$g=LUB($a,&X)`.\n-Therefore, `V={$a,$g}` and `Tainted($g)={$g,$a,&X}.  To find the\n-replacement for `$g` we consult the rules above:\n-- Rule (1) does not apply because `$g \\in V`\n-- Rule (2) does not apply because `&X \\in Tainted($g)`\n-- Rule (3) does not apply because `$a \\in Tainted($g)`\n-- Hence, by rule (4), we replace `$g` with a fresh bound variable `&z`.\n-So our final result is `fn(&z)`, which is correct.\n-\n-The next example is `fn(&A)` and `fn(&Z)`. In this case, we will again\n-have a (pre-replacement) GLB of `fn(&g)`, where `$g = LUB(&A,&Z)`.\n-Therefore, `V={$g}` and `Tainted($g) = {$g, &A, &Z}`.  In this case,\n-by rule (3), `$g` is mapped to itself, and hence the result is\n-`fn($g)`.  This result is correct (in this case, at least), but it is\n-indicative of a case that *can* lead us into concluding that there is\n-no GLB when in fact a GLB does exist.  See the section \"Questionable\n-Results\" below for more details.\n-\n-The next example is `fn(&a, &b)` and `fn(&c, &c)`. In this case, as\n-before, we'll end up with `F=fn($g, $h)` where `Tainted($g) =\n-Tainted($h) = {$g, $h, $a, $b, $c}`.  Only rule (4) applies and hence\n-we'll select fresh bound variables `y` and `z` and wind up with\n-`fn(&y, &z)`.\n-\n-For the last example, let's consider what may seem trivial, but is\n-not: `fn(&a, &a)` and `fn(&b, &b)`.  In this case, we'll get `F=fn($g,\n-$h)` where `Tainted($g) = {$g, $a, $x}` and `Tainted($h) = {$h, $a,\n-$x}`.  Both of these sets contain exactly one bound variable from each\n-side, so we'll map them both to `&a`, resulting in `fn(&a, &a)`, which\n-is the desired result.\n-\n-### Shortcomings and correctness\n-\n-You may be wondering whether this algorithm is correct.  The answer is\n-\"sort of\".  There are definitely cases where they fail to compute a\n-result even though a correct result exists.  I believe, though, that\n-if they succeed, then the result is valid, and I will attempt to\n-convince you.  The basic argument is that the \"pre-replacement\" step\n-computes a set of constraints.  The replacements, then, attempt to\n-satisfy those constraints, using bound identifiers where needed.\n-\n-For now I will briefly go over the cases for LUB/GLB and identify\n-their intent:\n-\n-- LUB:\n-  - The region variables that are substituted in place of bound regions\n-    are intended to collect constraints on those bound regions.\n-  - If Tainted(R) contains only values in V, then this region is unconstrained\n-    and can therefore be generalized, otherwise it cannot.\n-- GLB:\n-  - The region variables that are substituted in place of bound regions\n-    are intended to collect constraints on those bound regions.\n-  - If Tainted(R) contains exactly one variable from each side, and\n-    only variables in V, that indicates that those two bound regions\n-    must be equated.\n-  - Otherwise, if Tainted(R) references any variables from left or right\n-    side, then it is trying to combine a bound region with a free one or\n-    multiple bound regions, so we need to select fresh bound regions.\n-\n-Sorry this is more of a shorthand to myself.  I will try to write up something\n-more convincing in the future.\n-\n-#### Where are the algorithms wrong?\n-\n-- The pre-replacement computation can fail even though using a\n-  bound-region would have succeeded.\n-- We will compute GLB(fn(fn($a)), fn(fn($b))) as fn($c) where $c is the\n-  GLB of $a and $b.  But if inference finds that $a and $b must be mapped\n-  to regions without a GLB, then this is effectively a failure to compute\n-  the GLB.  However, the result `fn<$c>(fn($c))` is a valid GLB.\n+[oldhrtb]: https://rust-lang.github.io/rustc-guide/traits/hrtb.html\n+[newhrtb]: https://rust-lang.github.io/rustc-guide/borrow_check/region_inference.html#placeholders-and-universes"}, {"sha": "56320636a67431a88e7616cfb7c9189936977ec3", "filename": "src/librustc/infer/lexical_region_resolve/README.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2876801d188e11ec8c39b40d60ee4ded31c77d7f/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/2876801d188e11ec8c39b40d60ee4ded31c77d7f/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2FREADME.md?ref=2876801d188e11ec8c39b40d60ee4ded31c77d7f", "patch": "@@ -2,8 +2,12 @@\n \n > WARNING: This README is obsolete and will be removed soon! For\n > more info on how the current borrowck works, see the [rustc guide].\n+>\n+> As of edition 2018, region inference is done using Non-lexical lifetimes,\n+> which is described in the guide and [this RFC].\n \n [rustc guide]: https://rust-lang.github.io/rustc-guide/mir/borrowck.html\n+[this RFC]: https://github.com/rust-lang/rfcs/blob/master/text/2094-nll.md\n \n ## Terminology\n "}, {"sha": "ea7fffe9dc1c6fdc25b673ff7b248cc1bcea9203", "filename": "src/librustc/infer/region_constraints/README.md", "status": "modified", "additions": 1, "deletions": 75, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/2876801d188e11ec8c39b40d60ee4ded31c77d7f/src%2Flibrustc%2Finfer%2Fregion_constraints%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/2876801d188e11ec8c39b40d60ee4ded31c77d7f/src%2Flibrustc%2Finfer%2Fregion_constraints%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2FREADME.md?ref=2876801d188e11ec8c39b40d60ee4ded31c77d7f", "patch": "@@ -1,77 +1,3 @@\n-# Region constraint collection\n-\n-> WARNING: This README is obsolete and will be removed soon! For\n-> more info on how the current borrowck works, see the [rustc guide].\n+For info on how the current borrowck works, see the [rustc guide].\n \n [rustc guide]: https://rust-lang.github.io/rustc-guide/mir/borrowck.html\n-\n-## Terminology\n-\n-Note that we use the terms region and lifetime interchangeably.\n-\n-## Introduction\n-\n-As described in the rustc guide [chapter on type inference][ti], and unlike\n-normal type inference, which is similar in spirit to H-M and thus\n-works progressively, the region type inference works by accumulating\n-constraints over the course of a function.  Finally, at the end of\n-processing a function, we process and solve the constraints all at\n-once.\n-\n-[ti]: https://rust-lang.github.io/rustc-guide/type-inference.html\n-\n-The constraints are always of one of three possible forms:\n-\n-- `ConstrainVarSubVar(Ri, Rj)` states that region variable Ri must be\n-  a subregion of Rj\n-- `ConstrainRegSubVar(R, Ri)` states that the concrete region R (which\n-  must not be a variable) must be a subregion of the variable Ri\n-- `ConstrainVarSubReg(Ri, R)` states the variable Ri should be less\n-  than the concrete region R. This is kind of deprecated and ought to\n-  be replaced with a verify (they essentially play the same role).\n-\n-In addition to constraints, we also gather up a set of \"verifys\"\n-(what, you don't think Verify is a noun? Get used to it my\n-friend!). These represent relations that must hold but which don't\n-influence inference proper. These take the form of:\n-\n-- `VerifyRegSubReg(Ri, Rj)` indicates that Ri <= Rj must hold,\n-  where Rj is not an inference variable (and Ri may or may not contain\n-  one). This doesn't influence inference because we will already have\n-  inferred Ri to be as small as possible, so then we just test whether\n-  that result was less than Rj or not.\n-- `VerifyGenericBound(R, Vb)` is a more complex expression which tests\n-  that the region R must satisfy the bound `Vb`. The bounds themselves\n-  may have structure like \"must outlive one of the following regions\"\n-  or \"must outlive ALL of the following regions. These bounds arise\n-  from constraints like `T: 'a` -- if we know that `T: 'b` and `T: 'c`\n-  (say, from where clauses), then we can conclude that `T: 'a` if `'b:\n-  'a` *or* `'c: 'a`.\n-\n-## Building up the constraints\n-\n-Variables and constraints are created using the following methods:\n-\n-- `new_region_var()` creates a new, unconstrained region variable;\n-- `make_subregion(Ri, Rj)` states that Ri is a subregion of Rj\n-- `lub_regions(Ri, Rj) -> Rk` returns a region Rk which is\n-  the smallest region that is greater than both Ri and Rj\n-- `glb_regions(Ri, Rj) -> Rk` returns a region Rk which is\n-  the greatest region that is smaller than both Ri and Rj\n-\n-The actual region resolution algorithm is not entirely\n-obvious, though it is also not overly complex.\n-\n-## Snapshotting\n-\n-It is also permitted to try (and rollback) changes to the graph.  This\n-is done by invoking `start_snapshot()`, which returns a value.  Then\n-later you can call `rollback_to()` which undoes the work.\n-Alternatively, you can call `commit()` which ends all snapshots.\n-Snapshots can be recursive---so you can start a snapshot when another\n-is in progress, but only the root snapshot can \"commit\".\n-\n-## Skolemization\n-\n-For a discussion on skolemization and higher-ranked subtyping, please\n-see the module `middle::infer::higher_ranked::doc`."}, {"sha": "4b5e08cecd99c0719783fd538fe5e8044c293b3f", "filename": "src/librustc/ty/query/README.md", "status": "modified", "additions": 2, "deletions": 301, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/2876801d188e11ec8c39b40d60ee4ded31c77d7f/src%2Flibrustc%2Fty%2Fquery%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/2876801d188e11ec8c39b40d60ee4ded31c77d7f/src%2Flibrustc%2Fty%2Fquery%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2FREADME.md?ref=2876801d188e11ec8c39b40d60ee4ded31c77d7f", "patch": "@@ -1,302 +1,3 @@\n-# The Rust Compiler Query System\n-\n-The Compiler Query System is the key to our new demand-driven\n-organization.  The idea is pretty simple. You have various queries\n-that compute things about the input -- for example, there is a query\n-called `type_of(def_id)` that, given the def-id of some item, will\n-compute the type of that item and return it to you.\n-\n-Query execution is **memoized** -- so the first time you invoke a\n-query, it will go do the computation, but the next time, the result is\n-returned from a hashtable. Moreover, query execution fits nicely into\n-**incremental computation**; the idea is roughly that, when you do a\n-query, the result **may** be returned to you by loading stored data\n-from disk (but that's a separate topic we won't discuss further here).\n-\n-The overall vision is that, eventually, the entire compiler\n-control-flow will be query driven. There will effectively be one\n-top-level query (\"compile\") that will run compilation on a crate; this\n-will in turn demand information about that crate, starting from the\n-*end*.  For example:\n-\n-- This \"compile\" query might demand to get a list of codegen-units\n-  (i.e., modules that need to be compiled by LLVM).\n-- But computing the list of codegen-units would invoke some subquery\n-  that returns the list of all modules defined in the Rust source.\n-- That query in turn would invoke something asking for the HIR.\n-- This keeps going further and further back until we wind up doing the\n-  actual parsing.\n-\n-However, that vision is not fully realized. Still, big chunks of the\n-compiler (for example, generating MIR) work exactly like this.\n-\n-### Invoking queries\n-\n-To invoke a query is simple. The tcx (\"type context\") offers a method\n-for each defined query. So, for example, to invoke the `type_of`\n-query, you would just do this:\n-\n-```rust\n-let ty = tcx.type_of(some_def_id);\n-```\n-\n-### Cycles between queries\n-\n-Currently, cycles during query execution should always result in a\n-compilation error. Typically, they arise because of illegal programs\n-that contain cyclic references they shouldn't (though sometimes they\n-arise because of compiler bugs, in which case we need to factor our\n-queries in a more fine-grained fashion to avoid them).\n-\n-However, it is nonetheless often useful to *recover* from a cycle\n-(after reporting an error, say) and try to soldier on, so as to give a\n-better user experience. In order to recover from a cycle, you don't\n-get to use the nice method-call-style syntax. Instead, you invoke\n-using the `try_get` method, which looks roughly like this:\n-\n-```rust\n-use ty::query::queries;\n-...\n-match queries::type_of::try_get(tcx, DUMMY_SP, self.did) {\n-  Ok(result) => {\n-    // no cycle occurred! You can use `result`\n-  }\n-  Err(err) => {\n-    // A cycle occurred! The error value `err` is a `DiagnosticBuilder`,\n-    // meaning essentially an \"in-progress\", not-yet-reported error message.\n-    // See below for more details on what to do here.\n-  }\n-}\n-```\n-\n-So, if you get back an `Err` from `try_get`, then a cycle *did* occur. This means that\n-you must ensure that a compiler error message is reported. You can do that in two ways:\n-\n-The simplest is to invoke `err.emit()`. This will emit the cycle error to the user.\n-\n-However, often cycles happen because of an illegal program, and you\n-know at that point that an error either already has been reported or\n-will be reported due to this cycle by some other bit of code. In that\n-case, you can invoke `err.cancel()` to not emit any error. It is\n-traditional to then invoke:\n-\n-```\n-tcx.sess.delay_span_bug(some_span, \"some message\")\n-```\n-\n-`delay_span_bug()` is a helper that says: we expect a compilation\n-error to have happened or to happen in the future; so, if compilation\n-ultimately succeeds, make an ICE with the message `\"some\n-message\"`. This is basically just a precaution in case you are wrong.\n-\n-### How the compiler executes a query\n-\n-So you may be wondering what happens when you invoke a query\n-method. The answer is that, for each query, the compiler maintains a\n-cache -- if your query has already been executed, then, the answer is\n-simple: we clone the return value out of the cache and return it\n-(therefore, you should try to ensure that the return types of queries\n-are cheaply cloneable; insert a `Rc` if necessary).\n-\n-#### Providers\n-\n-If, however, the query is *not* in the cache, then the compiler will\n-try to find a suitable **provider**. A provider is a function that has\n-been defined and linked into the compiler somewhere that contains the\n-code to compute the result of the query.\n-\n-**Providers are defined per-crate.** The compiler maintains,\n-internally, a table of providers for every crate, at least\n-conceptually. Right now, there are really two sets: the providers for\n-queries about the **local crate** (that is, the one being compiled)\n-and providers for queries about **external crates** (that is,\n-dependencies of the local crate). Note that what determines the crate\n-that a query is targeting is not the *kind* of query, but the *key*.\n-For example, when you invoke `tcx.type_of(def_id)`, that could be a\n-local query or an external query, depending on what crate the `def_id`\n-is referring to (see the `self::keys::Key` trait for more information\n-on how that works).\n-\n-Providers always have the same signature:\n-\n-```rust\n-fn provider<'cx, 'tcx>(tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n-                       key: QUERY_KEY)\n-                       -> QUERY_RESULT\n-{\n-    ...\n-}\n-```\n-\n-Providers take two arguments: the `tcx` and the query key. Note also\n-that they take the *global* tcx (i.e., they use the `'tcx` lifetime\n-twice), rather than taking a tcx with some active inference context.\n-They return the result of the query.\n-\n-####  How providers are setup\n-\n-When the tcx is created, it is given the providers by its creator using\n-the `Providers` struct. This struct is generate by the macros here, but it\n-is basically a big list of function pointers:\n-\n-```rust\n-struct Providers {\n-    type_of: for<'cx, 'tcx> fn(TyCtxt<'cx, 'tcx, 'tcx>, DefId) -> Ty<'tcx>,\n-    ...\n-}\n-```\n-\n-At present, we have one copy of the struct for local crates, and one\n-for external crates, though the plan is that we may eventually have\n-one per crate.\n-\n-These `Provider` structs are ultimately created and populated by\n-`librustc_driver`, but it does this by distributing the work\n-throughout the other `rustc_*` crates. This is done by invoking\n-various `provide` functions. These functions tend to look something\n-like this:\n-\n-```rust\n-pub fn provide(providers: &mut Providers) {\n-    *providers = Providers {\n-        type_of,\n-        ..*providers\n-    };\n-}\n-```\n-\n-That is, they take an `&mut Providers` and mutate it in place. Usually\n-we use the formulation above just because it looks nice, but you could\n-as well do `providers.type_of = type_of`, which would be equivalent.\n-(Here, `type_of` would be a top-level function, defined as we saw\n-before.) So, if we want to add a provider for some other query,\n-let's call it `fubar`, into the crate above, we might modify the `provide()`\n-function like so:\n-\n-```rust\n-pub fn provide(providers: &mut Providers) {\n-    *providers = Providers {\n-        type_of,\n-        fubar,\n-        ..*providers\n-    };\n-}\n-\n-fn fubar<'cx, 'tcx>(tcx: TyCtxt<'cx, 'tcx>, key: DefId) -> Fubar<'tcx> { .. }\n-```\n-\n-NB. Most of the `rustc_*` crates only provide **local\n-providers**. Almost all **extern providers** wind up going through the\n-`rustc_metadata` crate, which loads the information from the crate\n-metadata.  But in some cases there are crates that provide queries for\n-*both* local and external crates, in which case they define both a\n-`provide` and a `provide_extern` function that `rustc_driver` can\n-invoke.\n-\n-### Adding a new kind of query\n-\n-So suppose you want to add a new kind of query, how do you do so?\n-Well, defining a query takes place in two steps:\n-\n-1. first, you have to specify the query name and arguments; and then,\n-2. you have to supply query providers where needed.\n-\n-To specify the query name and arguments, you simply add an entry\n-to the big macro invocation in `mod.rs`. This will probably have changed\n-by the time you read this README, but at present it looks something\n-like:\n-\n-```\n-define_queries! { <'tcx>\n-    /// Records the type of every item.\n-    [] fn type_of: TypeOfItem(DefId) -> Ty<'tcx>,\n-\n-    ...\n-}\n-```\n-\n-Each line of the macro defines one query. The name is broken up like this:\n-\n-```\n-[] fn type_of: TypeOfItem(DefId) -> Ty<'tcx>,\n-^^    ^^^^^^^  ^^^^^^^^^^ ^^^^^     ^^^^^^^^\n-|     |        |          |         |\n-|     |        |          |         result type of query\n-|     |        |          query key type\n-|     |        dep-node constructor\n-|     name of query\n-query flags\n-```\n-\n-Let's go over them one by one:\n-\n-- **Query flags:** these are largely unused right now, but the intention\n-  is that we'll be able to customize various aspects of how the query is\n-  processed.\n-- **Name of query:** the name of the query method\n-  (`tcx.type_of(..)`). Also used as the name of a struct\n-  (`ty::query::queries::type_of`) that will be generated to represent\n-  this query.\n-- **Dep-node constructor:** indicates the constructor function that\n-  connects this query to incremental compilation. Typically, this is a\n-  `DepNode` variant, which can be added by modifying the\n-  `define_dep_nodes!` macro invocation in\n-  `librustc/dep_graph/dep_node.rs`.\n-  - However, sometimes we use a custom function, in which case the\n-    name will be in snake case and the function will be defined at the\n-    bottom of the file. This is typically used when the query key is\n-    not a def-id, or just not the type that the dep-node expects.\n-- **Query key type:** the type of the argument to this query.\n-  This type must implement the `ty::query::keys::Key` trait, which\n-  defines (for example) how to map it to a crate, and so forth.\n-- **Result type of query:** the type produced by this query. This type\n-  should (a) not use `RefCell` or other interior mutability and (b) be\n-  cheaply cloneable. Interning or using `Rc` or `Arc` is recommended for\n-  non-trivial data types.\n-  - The one exception to those rules is the `ty::steal::Steal` type,\n-    which is used to cheaply modify MIR in place. See the definition\n-    of `Steal` for more details. New uses of `Steal` should **not** be\n-    added without alerting `@rust-lang/compiler`.\n-\n-So, to add a query:\n-\n-- Add an entry to `define_queries!` using the format above.\n-- Possibly add a corresponding entry to the dep-node macro.\n-- Link the provider by modifying the appropriate `provide` method;\n-  or add a new one if needed and ensure that `rustc_driver` is invoking it.\n-\n-#### Query structs and descriptions\n-\n-For each kind, the `define_queries` macro will generate a \"query struct\"\n-named after the query. This struct is a kind of a place-holder\n-describing the query. Each such struct implements the\n-`self::config::QueryConfig` trait, which has associated types for the\n-key/value of that particular query. Basically the code generated looks something\n-like this:\n-\n-```rust\n-// Dummy struct representing a particular kind of query:\n-pub struct type_of<'tcx> { phantom: PhantomData<&'tcx ()> }\n-\n-impl<'tcx> QueryConfig for type_of<'tcx> {\n-  type Key = DefId;\n-  type Value = Ty<'tcx>;\n-}\n-```\n-\n-There is an additional trait that you may wish to implement called\n-`self::config::QueryDescription`. This trait is used during cycle\n-errors to give a \"human readable\" name for the query, so that we can\n-summarize what was happening when the cycle occurred. Implementing\n-this trait is optional if the query key is `DefId`, but if you *don't*\n-implement it, you get a pretty generic error (\"processing `foo`...\").\n-You can put new impls into the `config` module. They look something like this:\n-\n-```rust\n-impl<'tcx> QueryDescription for queries::type_of<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, key: DefId) -> String {\n-        format!(\"computing the type of `{}`\", tcx.item_path_str(key))\n-    }\n-}\n-```\n+For more information about how the query system works, see the [rustc guide].\n \n+[rustc guide]: https://rust-lang.github.io/rustc-guide/query.html"}, {"sha": "982a2bacce1648459cffea4dc3cde3e83d0fb5b2", "filename": "src/librustc_data_structures/obligation_forest/README.md", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/f20c6c8581f5fb5c7cb679736d7a0dcbefa7b038/src%2Flibrustc_data_structures%2Fobligation_forest%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/f20c6c8581f5fb5c7cb679736d7a0dcbefa7b038/src%2Flibrustc_data_structures%2Fobligation_forest%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2FREADME.md?ref=f20c6c8581f5fb5c7cb679736d7a0dcbefa7b038", "patch": "@@ -1,81 +0,0 @@\n-The `ObligationForest` is a utility data structure used in trait\n-matching to track the set of outstanding obligations (those not yet\n-resolved to success or error). It also tracks the \"backtrace\" of each\n-pending obligation (why we are trying to figure this out in the first\n-place).\n-\n-### External view\n-\n-`ObligationForest` supports two main public operations (there are a\n-few others not discussed here):\n-\n-1. Add a new root obligations (`push_tree`).\n-2. Process the pending obligations (`process_obligations`).\n-\n-When a new obligation `N` is added, it becomes the root of an\n-obligation tree. This tree can also carry some per-tree state `T`,\n-which is given at the same time. This tree is a singleton to start, so\n-`N` is both the root and the only leaf. Each time the\n-`process_obligations` method is called, it will invoke its callback\n-with every pending obligation (so that will include `N`, the first\n-time). The callback also receives a (mutable) reference to the\n-per-tree state `T`. The callback should process the obligation `O`\n-that it is given and return one of three results:\n-\n-- `Ok(None)` -> ambiguous result. Obligation was neither a success\n-  nor a failure. It is assumed that further attempts to process the\n-  obligation will yield the same result unless something in the\n-  surrounding environment changes.\n-- `Ok(Some(C))` - the obligation was *shallowly successful*. The\n-  vector `C` is a list of subobligations. The meaning of this is that\n-  `O` was successful on the assumption that all the obligations in `C`\n-  are also successful. Therefore, `O` is only considered a \"true\"\n-  success if `C` is empty. Otherwise, `O` is put into a suspended\n-  state and the obligations in `C` become the new pending\n-  obligations. They will be processed the next time you call\n-  `process_obligations`.\n-- `Err(E)` -> obligation failed with error `E`. We will collect this\n-  error and return it from `process_obligations`, along with the\n-  \"backtrace\" of obligations (that is, the list of obligations up to\n-  and including the root of the failed obligation). No further\n-  obligations from that same tree will be processed, since the tree is\n-  now considered to be in error.\n-\n-When the call to `process_obligations` completes, you get back an `Outcome`,\n-which includes three bits of information:\n-\n-- `completed`: a list of obligations where processing was fully\n-  completed without error (meaning that all transitive subobligations\n-  have also been completed). So, for example, if the callback from\n-  `process_obligations` returns `Ok(Some(C))` for some obligation `O`,\n-  then `O` will be considered completed right away if `C` is the\n-  empty vector. Otherwise it will only be considered completed once\n-  all the obligations in `C` have been found completed.\n-- `errors`: a list of errors that occurred and associated backtraces\n-  at the time of error, which can be used to give context to the user.\n-- `stalled`: if true, then none of the existing obligations were\n-  *shallowly successful* (that is, no callback returned `Ok(Some(_))`).\n-  This implies that all obligations were either errors or returned an\n-  ambiguous result, which means that any further calls to\n-  `process_obligations` would simply yield back further ambiguous\n-  results. This is used by the `FulfillmentContext` to decide when it\n-  has reached a steady state.\n-\n-#### Snapshots\n-\n-The `ObligationForest` supports a limited form of snapshots; see\n-`start_snapshot`; `commit_snapshot`; and `rollback_snapshot`. In\n-particular, you can use a snapshot to roll back new root\n-obligations. However, it is an error to attempt to\n-`process_obligations` during a snapshot.\n-\n-### Implementation details\n-\n-For the most part, comments specific to the implementation are in the\n-code.  This file only contains a very high-level overview. Basically,\n-the forest is stored in a vector. Each element of the vector is a node\n-in some tree. Each node in the vector has the index of an (optional)\n-parent and (for convenience) its root (which may be itself). It also\n-has a current state, described by `NodeState`. After each\n-processing step, we compress the vector to remove completed and error\n-nodes, which aren't needed anymore."}, {"sha": "9dd7d204f0373d5ccea71f87c629a3d33b5f6176", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 80, "deletions": 5, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/2876801d188e11ec8c39b40d60ee4ded31c77d7f/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2876801d188e11ec8c39b40d60ee4ded31c77d7f/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=2876801d188e11ec8c39b40d60ee4ded31c77d7f", "patch": "@@ -1,9 +1,84 @@\n //! The `ObligationForest` is a utility data structure used in trait\n-//! matching to track the set of outstanding obligations (those not\n-//! yet resolved to success or error). It also tracks the \"backtrace\"\n-//! of each pending obligation (why we are trying to figure this out\n-//! in the first place). See README.md for a general overview of how\n-//! to use this class.\n+//! matching to track the set of outstanding obligations (those not yet\n+//! resolved to success or error). It also tracks the \"backtrace\" of each\n+//! pending obligation (why we are trying to figure this out in the first\n+//! place).\n+//!\n+//! ### External view\n+//!\n+//! `ObligationForest` supports two main public operations (there are a\n+//! few others not discussed here):\n+//!\n+//! 1. Add a new root obligations (`push_tree`).\n+//! 2. Process the pending obligations (`process_obligations`).\n+//!\n+//! When a new obligation `N` is added, it becomes the root of an\n+//! obligation tree. This tree can also carry some per-tree state `T`,\n+//! which is given at the same time. This tree is a singleton to start, so\n+//! `N` is both the root and the only leaf. Each time the\n+//! `process_obligations` method is called, it will invoke its callback\n+//! with every pending obligation (so that will include `N`, the first\n+//! time). The callback also receives a (mutable) reference to the\n+//! per-tree state `T`. The callback should process the obligation `O`\n+//! that it is given and return one of three results:\n+//!\n+//! - `Ok(None)` -> ambiguous result. Obligation was neither a success\n+//!   nor a failure. It is assumed that further attempts to process the\n+//!   obligation will yield the same result unless something in the\n+//!   surrounding environment changes.\n+//! - `Ok(Some(C))` - the obligation was *shallowly successful*. The\n+//!   vector `C` is a list of subobligations. The meaning of this is that\n+//!   `O` was successful on the assumption that all the obligations in `C`\n+//!   are also successful. Therefore, `O` is only considered a \"true\"\n+//!   success if `C` is empty. Otherwise, `O` is put into a suspended\n+//!   state and the obligations in `C` become the new pending\n+//!   obligations. They will be processed the next time you call\n+//!   `process_obligations`.\n+//! - `Err(E)` -> obligation failed with error `E`. We will collect this\n+//!   error and return it from `process_obligations`, along with the\n+//!   \"backtrace\" of obligations (that is, the list of obligations up to\n+//!   and including the root of the failed obligation). No further\n+//!   obligations from that same tree will be processed, since the tree is\n+//!   now considered to be in error.\n+//!\n+//! When the call to `process_obligations` completes, you get back an `Outcome`,\n+//! which includes three bits of information:\n+//!\n+//! - `completed`: a list of obligations where processing was fully\n+//!   completed without error (meaning that all transitive subobligations\n+//!   have also been completed). So, for example, if the callback from\n+//!   `process_obligations` returns `Ok(Some(C))` for some obligation `O`,\n+//!   then `O` will be considered completed right away if `C` is the\n+//!   empty vector. Otherwise it will only be considered completed once\n+//!   all the obligations in `C` have been found completed.\n+//! - `errors`: a list of errors that occurred and associated backtraces\n+//!   at the time of error, which can be used to give context to the user.\n+//! - `stalled`: if true, then none of the existing obligations were\n+//!   *shallowly successful* (that is, no callback returned `Ok(Some(_))`).\n+//!   This implies that all obligations were either errors or returned an\n+//!   ambiguous result, which means that any further calls to\n+//!   `process_obligations` would simply yield back further ambiguous\n+//!   results. This is used by the `FulfillmentContext` to decide when it\n+//!   has reached a steady state.\n+//!\n+//! #### Snapshots\n+//!\n+//! The `ObligationForest` supports a limited form of snapshots; see\n+//! `start_snapshot`; `commit_snapshot`; and `rollback_snapshot`. In\n+//! particular, you can use a snapshot to roll back new root\n+//! obligations. However, it is an error to attempt to\n+//! `process_obligations` during a snapshot.\n+//!\n+//! ### Implementation details\n+//!\n+//! For the most part, comments specific to the implementation are in the\n+//! code.  This file only contains a very high-level overview. Basically,\n+//! the forest is stored in a vector. Each element of the vector is a node\n+//! in some tree. Each node in the vector has the index of an (optional)\n+//! parent and (for convenience) its root (which may be itself). It also\n+//! has a current state, described by `NodeState`. After each\n+//! processing step, we compress the vector to remove completed and error\n+//! nodes, which aren't needed anymore.\n \n use fx::{FxHashMap, FxHashSet};\n "}]}