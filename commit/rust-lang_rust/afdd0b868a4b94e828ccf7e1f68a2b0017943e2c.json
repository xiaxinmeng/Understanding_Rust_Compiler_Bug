{"sha": "afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmZGQwYjg2OGE0Yjk0ZTgyOGNjZjdlMWY2OGEyYjAwMTc5NDNlMmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-02T16:30:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-02T16:30:41Z"}, "message": "auto merge of #5143 : erickt/rust/incoming, r=pcwalton\n\nGood morning,\r\n\r\nIt's taken a long time, but I finally am almost done freeing libsyntax of `vecs_implicitly_copyable` in this pull request, but I'm running into some issues. I've confirmed that all but the last commit (which only disables `vecs_implicitly_copyable` pass the `check` tests. The last commit errors with this message, which makes no sense to me:\r\n\r\n```\r\n/Users/erickt/rust/rust/src/libcore/num/f32.rs:35:37: 35:43 error: expected `,` but found `=`\r\n/Users/erickt/rust/rust/src/libcore/num/f32.rs:35         pub pure fn $name($( $arg : $arg_ty ),*) -> $rv {\r\n                                                                                       ^~~~~~\r\n```\r\n\r\nand this stack trace:\r\n\r\n```\r\n#1  0x00000001000b059b in sys::begin_unwind_::_a923ca4ae164c::_06 ()\r\n#2  0x00000001000b0542 in sys::begin_unwind::anon::anon::expr_fn_13876 ()\r\n#3  0x00000001000048a1 in sys::begin_unwind::_8ec273289fc0adc0::_06 ()\r\n#4  0x00000001005df999 in diagnostic::__extensions__::meth_7941::span_fatal::_efdf2d14612d79ec::_06 ()\r\n#5  0x0000000100682d48 in parse::parser::__extensions__::meth_16938::fatal::_8aa3239426747a3::_06 ()\r\n#6  0x00000001006850b8 in parse::common::__extensions__::meth_17005::expect::_d3604ec6c7698d5f::_06 ()\r\n#7  0x00000001006b59f1 in parse::common::__extensions__::parse_seq_to_before_end_17860::_48c79835f9eb1011::_06 ()\r\n#8  0x00000001006a50f7 in parse::parser::__extensions__::meth_17606::parse_fn_decl::_14f3785fe78967d::_06 ()\r\n#9  0x00000001006b6f59 in parse::parser::__extensions__::meth_17987::parse_item_fn::_8a6be529cf7b2ca5::_06 ()\r\n#10 0x00000001006ac839 in parse::parser::__extensions__::meth_17761::parse_item_or_view_item::_bfead947d6dd7d25::_06 ()\r\n#11 0x00000001006c8b8f in parse::parser::__extensions__::meth_18364::parse_item::_96b54e33f65abe76::_06 ()\r\n#12 0x000000010076179f in ext::tt::macro_rules::add_new_extension::generic_extension::anon::anon::expr_fn_23365 ()\r\n#13 0x000000010072e793 in ext::expand::expand_item_mac::_a4f486c4465cfb1b::_06 ()\r\n#14 0x00000001007b5ad3 in __morestack ()\r\n```\r\n\r\nThere also a bunch of new warnings that I haven't cleaned up yet: https://gist.github.com/erickt/5048251.\r\n\r\n@nikomatsakis thought there might be some scary bug in the parser caused by moving a vector in the parser instead of copying it, which is why I'm filing this pull request before it's ready. Thanks for any help!", "tree": {"sha": "4e3d85a43f684fd9d3b2e80a6a9178f90e63d7ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e3d85a43f684fd9d3b2e80a6a9178f90e63d7ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "html_url": "https://github.com/rust-lang/rust/commit/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2304fe6208404ce952aaa37e7634db570ff71f6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2304fe6208404ce952aaa37e7634db570ff71f6c", "html_url": "https://github.com/rust-lang/rust/commit/2304fe6208404ce952aaa37e7634db570ff71f6c"}, {"sha": "5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "url": "https://api.github.com/repos/rust-lang/rust/commits/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece", "html_url": "https://github.com/rust-lang/rust/commit/5515fd5c8cf65a8eebd43ddb0de6ff920a509ece"}], "stats": {"total": 5125, "additions": 2868, "deletions": 2257}, "files": [{"sha": "c16a7cf8d3ebed4ad6bcbf7f39ba4cf5c77f5ac4", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -134,7 +134,7 @@ pub pure fn safe_to_use_expr(e: ast::expr, tm: test_mode) -> bool {\n \n pub fn safe_to_steal_ty(t: @ast::Ty, tm: test_mode) -> bool {\n     // Restrictions happen to be the same.\n-    safe_to_replace_ty(t.node, tm)\n+    safe_to_replace_ty(&t.node, tm)\n }\n \n // Not type-parameterized: https://github.com/mozilla/rust/issues/898 (FIXED)\n@@ -175,8 +175,8 @@ pub fn steal(crate: ast::crate, tm: test_mode) -> StolenStuff {\n }\n \n \n-pub fn safe_to_replace_expr(e: ast::expr_, _tm: test_mode) -> bool {\n-    match e {\n+pub fn safe_to_replace_expr(e: &ast::expr_, _tm: test_mode) -> bool {\n+    match *e {\n       // https://github.com/mozilla/rust/issues/652\n       ast::expr_if(*) => { false }\n       ast::expr_block(_) => { false }\n@@ -188,8 +188,8 @@ pub fn safe_to_replace_expr(e: ast::expr_, _tm: test_mode) -> bool {\n     }\n }\n \n-pub fn safe_to_replace_ty(t: ast::ty_, _tm: test_mode) -> bool {\n-    match t {\n+pub fn safe_to_replace_ty(t: &ast::ty_, _tm: test_mode) -> bool {\n+    match *t {\n       ast::ty_infer => { false } // always implicit, always top level\n       ast::ty_bot => { false }   // in source, can only appear\n                               // as the out type of a function\n@@ -204,7 +204,7 @@ pub fn replace_expr_in_crate(crate: ast::crate, i: uint,\n    ast::crate {\n     let j: @mut uint = @mut 0u;\n     fn fold_expr_rep(j_: @mut uint, i_: uint, newexpr_: ast::expr_,\n-                     original: ast::expr_, fld: fold::ast_fold,\n+                     original: &ast::expr_, fld: fold::ast_fold,\n                      tm_: test_mode) ->\n        ast::expr_ {\n         *j_ += 1u;\n@@ -221,7 +221,7 @@ pub fn replace_expr_in_crate(crate: ast::crate, i: uint,\n         .. *fold::default_ast_fold()\n     };\n     let af = fold::make_fold(afp);\n-    let crate2: @ast::crate = @af.fold_crate(crate);\n+    let crate2: @ast::crate = @af.fold_crate(&crate);\n     *crate2\n }\n \n@@ -231,7 +231,7 @@ pub fn replace_ty_in_crate(crate: ast::crate, i: uint, newty: ast::Ty,\n                            tm: test_mode) -> ast::crate {\n     let j: @mut uint = @mut 0u;\n     fn fold_ty_rep(j_: @mut uint, i_: uint, newty_: ast::ty_,\n-                   original: ast::ty_, fld: fold::ast_fold,\n+                   original: &ast::ty_, fld: fold::ast_fold,\n                    tm_: test_mode) ->\n        ast::ty_ {\n         *j_ += 1u;\n@@ -244,7 +244,7 @@ pub fn replace_ty_in_crate(crate: ast::crate, i: uint, newty: ast::Ty,\n         .. *fold::default_ast_fold()\n     };\n     let af = fold::make_fold(afp);\n-    let crate2: @ast::crate = @af.fold_crate(crate);\n+    let crate2: @ast::crate = @af.fold_crate(&crate);\n     *crate2\n }\n "}, {"sha": "61bb03dd7f902f37d74b0f3390ad79a068278f9f", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -396,7 +396,7 @@ pub fn pretty_print_input(sess: Session, +cfg: ast::crate_cfg, input: input,\n           pprust::node_block(s, ref blk) => {\n             pp::space(s.s);\n             pprust::synth_comment(\n-                s, ~\"block \" + int::to_str((*blk).node.id));\n+                s, ~\"block \" + int::to_str(blk.node.id));\n           }\n           pprust::node_expr(s, expr) => {\n             pp::space(s.s);"}, {"sha": "94dbfb51eb8226d97c57643348c7c32634244825", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -358,7 +358,7 @@ pub mod test {\n     pub fn make_crate_type_attr(+t: ~str) -> ast::attribute {\n         codemap::respan(codemap::dummy_sp(), ast::attribute_ {\n             style: ast::attr_outer,\n-            value: codemap::respan(codemap::dummy_sp(),\n+            value: @codemap::respan(codemap::dummy_sp(),\n                 ast::meta_name_value(\n                     @~\"crate_type\",\n                     codemap::respan(codemap::dummy_sp(),"}, {"sha": "faa1ad9854af7cd3a2ce793dd18621faf1bf406d", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -45,7 +45,7 @@ pub fn strip_items(crate: @ast::crate, in_cfg: in_cfg_pred)\n           .. *fold::default_ast_fold()};\n \n     let fold = fold::make_fold(precursor);\n-    let res = @fold.fold_crate(*crate);\n+    let res = @fold.fold_crate(&*crate);\n     return res;\n }\n \n@@ -63,7 +63,7 @@ fn filter_view_item(cx: @Context, &&view_item: @ast::view_item\n     }\n }\n \n-fn fold_mod(cx: @Context, m: ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n+fn fold_mod(cx: @Context, m: &ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n     let filtered_items =\n         m.items.filter_mapped(|a| filter_item(cx, *a));\n     let filtered_view_items =\n@@ -83,7 +83,7 @@ fn filter_foreign_item(cx: @Context, &&item: @ast::foreign_item) ->\n \n fn fold_foreign_mod(\n     cx: @Context,\n-    nm: ast::foreign_mod,\n+    nm: &ast::foreign_mod,\n     fld: fold::ast_fold\n ) -> ast::foreign_mod {\n     let filtered_items =\n@@ -98,21 +98,21 @@ fn fold_foreign_mod(\n     }\n }\n \n-fn fold_item_underscore(cx: @Context, +item: ast::item_,\n+fn fold_item_underscore(cx: @Context, item: &ast::item_,\n                         fld: fold::ast_fold) -> ast::item_ {\n-    let item = match item {\n-        ast::item_impl(a, b, c, methods) => {\n+    let item = match *item {\n+        ast::item_impl(ref a, b, c, ref methods) => {\n             let methods = methods.filtered(|m| method_in_cfg(cx, *m) );\n-            ast::item_impl(a, b, c, methods)\n+            ast::item_impl(/*bad*/ copy *a, b, c, methods)\n         }\n         ast::item_trait(ref a, ref b, ref methods) => {\n             let methods = methods.filtered(|m| trait_method_in_cfg(cx, m) );\n             ast::item_trait(/*bad*/copy *a, /*bad*/copy *b, methods)\n         }\n-        item => item\n+        ref item => /*bad*/ copy *item\n     };\n \n-    fold::noop_fold_item_underscore(item, fld)\n+    fold::noop_fold_item_underscore(&item, fld)\n }\n \n fn filter_stmt(cx: @Context, &&stmt: @ast::stmt) ->\n@@ -134,7 +134,7 @@ fn filter_stmt(cx: @Context, &&stmt: @ast::stmt) ->\n \n fn fold_block(\n     cx: @Context,\n-    b: ast::blk_,\n+    b: &ast::blk_,\n     fld: fold::ast_fold\n ) -> ast::blk_ {\n     let filtered_stmts ="}, {"sha": "b7df99795924b2953d6518ef479d3afdfb090055", "filename": "src/librustc/front/core_inject.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fcore_inject.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -50,7 +50,7 @@ fn inject_libcore_ref(sess: Session,\n                 attrs: ~[\n                     spanned(ast::attribute_ {\n                         style: ast::attr_inner,\n-                        value: spanned(ast::meta_name_value(\n+                        value: @spanned(ast::meta_name_value(\n                             @~\"vers\",\n                             spanned(ast::lit_str(@CORE_VERSION.to_str()))\n                         )),\n@@ -66,10 +66,13 @@ fn inject_libcore_ref(sess: Session,\n                 view_items: vis,\n                 ../*bad*/copy crate.module\n             };\n-            new_module = fld.fold_mod(new_module);\n+            new_module = fld.fold_mod(&new_module);\n \n             // FIXME #2543: Bad copy.\n-            let new_crate = ast::crate_ { module: new_module, ..copy crate };\n+            let new_crate = ast::crate_ {\n+                module: new_module,\n+                ..copy *crate\n+            };\n             (new_crate, span)\n         },\n         fold_mod: |module, fld| {\n@@ -95,12 +98,15 @@ fn inject_libcore_ref(sess: Session,\n             let vis = vec::append(~[vi2], module.view_items);\n \n             // FIXME #2543: Bad copy.\n-            let new_module = ast::_mod { view_items: vis, ..copy module };\n-            fold::noop_fold_mod(new_module, fld)\n+            let new_module = ast::_mod {\n+                view_items: vis,\n+                ..copy *module\n+            };\n+            fold::noop_fold_mod(&new_module, fld)\n         },\n         ..*fold::default_ast_fold()\n     };\n \n     let fold = fold::make_fold(precursor);\n-    @fold.fold_crate(*crate)\n+    @fold.fold_crate(crate)\n }"}, {"sha": "94b49e9d266e4e1ee71932f2b01f3103f13d082a", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -91,7 +91,7 @@ fn generate_test_harness(sess: session::Session,\n         fold_mod: |a,b| fold_mod(cx, a, b),.. *fold::default_ast_fold()};\n \n     let fold = fold::make_fold(precursor);\n-    let res = @fold.fold_crate(*crate);\n+    let res = @fold.fold_crate(&*crate);\n     cx.ext_cx.bt_pop();\n     return res;\n }\n@@ -106,7 +106,7 @@ fn strip_test_functions(crate: @ast::crate) -> @ast::crate {\n }\n \n fn fold_mod(cx: @mut TestCtxt,\n-            m: ast::_mod,\n+            m: &ast::_mod,\n             fld: fold::ast_fold)\n          -> ast::_mod {\n     // Remove any #[main] from the AST so it doesn't clash with\n@@ -125,19 +125,21 @@ fn fold_mod(cx: @mut TestCtxt,\n         items: vec::map(m.items, |i| nomain(cx, *i)),\n     };\n \n-    fold::noop_fold_mod(mod_nomain, fld)\n+    fold::noop_fold_mod(&mod_nomain, fld)\n }\n \n fn fold_crate(cx: @mut TestCtxt,\n-              c: ast::crate_,\n+              c: &ast::crate_,\n               fld: fold::ast_fold)\n            -> ast::crate_ {\n     let folded = fold::noop_fold_crate(c, fld);\n \n     // Add a special __test module to the crate that will contain code\n     // generated for the test harness\n-    ast::crate_ { module: add_test_module(cx, /*bad*/copy folded.module),\n-                  .. folded }\n+    ast::crate_ {\n+        module: add_test_module(cx, &folded.module),\n+        .. folded\n+    }\n }\n \n \n@@ -238,11 +240,11 @@ fn should_fail(i: @ast::item) -> bool {\n     vec::len(attr::find_attrs_by_name(i.attrs, ~\"should_fail\")) > 0u\n }\n \n-fn add_test_module(cx: &TestCtxt, +m: ast::_mod) -> ast::_mod {\n+fn add_test_module(cx: &TestCtxt, m: &ast::_mod) -> ast::_mod {\n     let testmod = mk_test_module(cx);\n     ast::_mod {\n         items: vec::append_one(/*bad*/copy m.items, testmod),\n-        .. m\n+        .. /*bad*/ copy *m\n     }\n }\n "}, {"sha": "cbe2217c9fc9b8d2b556e195a5334ca4ac21bcf6", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -1009,7 +1009,7 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::attribute] {\n                 codemap::spanned {\n                     node: ast::attribute_ {\n                         style: ast::attr_outer,\n-                        value: /*bad*/copy *meta_item,\n+                        value: meta_item,\n                         is_sugared_doc: false,\n                     },\n                     span: codemap::dummy_sp()"}, {"sha": "7d2423c7c5d3ba0658a35a3cc47067a15997b484", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -326,7 +326,7 @@ fn encode_path(ecx: @EncodeContext, ebml_w: writer::Encoder,\n }\n \n fn encode_info_for_mod(ecx: @EncodeContext, ebml_w: writer::Encoder,\n-                       md: _mod, id: node_id, path: &[ast_map::path_elt],\n+                       md: &_mod, id: node_id, path: &[ast_map::path_elt],\n                        name: ident) {\n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(id));\n@@ -659,7 +659,7 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n         }\n         ebml_w.end_tag();\n       }\n-      item_mod(m) => {\n+      item_mod(ref m) => {\n         add_to_index();\n         encode_info_for_mod(ecx, ebml_w, m, item.id, path, item.ident);\n       }\n@@ -912,8 +912,8 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n         // method info, we output static methods with type signatures as\n         // written. Here, we output the *real* type signatures. I feel like\n         // maybe we should only ever handle the real type signatures.\n-        for vec::each((*ms)) |m| {\n-            let ty_m = ast_util::trait_method_to_ty_method(*m);\n+        for ms.each |m| {\n+            let ty_m = ast_util::trait_method_to_ty_method(m);\n             if ty_m.self_ty.node != ast::sty_static { loop; }\n \n             index.push(entry { val: ty_m.id, pos: ebml_w.writer.tell() });\n@@ -995,7 +995,7 @@ fn encode_info_for_items(ecx: @EncodeContext, ebml_w: writer::Encoder,\n     let index = @mut ~[];\n     ebml_w.start_tag(tag_items_data);\n     index.push(entry { val: crate_node_id, pos: ebml_w.writer.tell() });\n-    encode_info_for_mod(ecx, ebml_w, crate.node.module,\n+    encode_info_for_mod(ecx, ebml_w, &crate.node.module,\n                         crate_node_id, ~[],\n                         syntax::parse::token::special_idents::invalid);\n     visit::visit_crate(*crate, (), visit::mk_vt(@visit::Visitor {\n@@ -1088,7 +1088,7 @@ fn write_int(writer: io::Writer, &&n: int) {\n     writer.write_be_u32(n as u32);\n }\n \n-fn encode_meta_item(ebml_w: writer::Encoder, mi: meta_item) {\n+fn encode_meta_item(ebml_w: writer::Encoder, mi: @meta_item) {\n     match mi.node {\n       meta_word(name) => {\n         ebml_w.start_tag(tag_meta_item_word);\n@@ -1118,7 +1118,7 @@ fn encode_meta_item(ebml_w: writer::Encoder, mi: meta_item) {\n         ebml_w.writer.write(str::to_bytes(*name));\n         ebml_w.end_tag();\n         for items.each |inner_item| {\n-            encode_meta_item(ebml_w, **inner_item);\n+            encode_meta_item(ebml_w, *inner_item);\n         }\n         ebml_w.end_tag();\n       }"}, {"sha": "d5cb2f8726d1786a2d81d7014d75781940280a98", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -298,7 +298,7 @@ fn encode_ast(ebml_w: writer::Encoder, item: ast::inlined_item) {\n // nested items, as otherwise it would get confused when translating\n // inlined items.\n fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n-    fn drop_nested_items(blk: ast::blk_, fld: fold::ast_fold) -> ast::blk_ {\n+    fn drop_nested_items(blk: &ast::blk_, fld: fold::ast_fold) -> ast::blk_ {\n         let stmts_sans_items = do blk.stmts.filtered |stmt| {\n             match stmt.node {\n               ast::stmt_expr(_, _) | ast::stmt_semi(_, _) |\n@@ -317,7 +317,7 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n             id: blk.id,\n             rules: blk.rules\n         };\n-        fold::noop_fold_block(blk_sans_items, fld)\n+        fold::noop_fold_block(&blk_sans_items, fld)\n     }\n \n     let fld = fold::make_fold(@fold::AstFoldFns {\n@@ -336,7 +336,7 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n         ast::ii_foreign(fld.fold_foreign_item(i))\n       }\n       ast::ii_dtor(ref dtor, nm, ref tps, parent_id) => {\n-        let dtor_body = fld.fold_block((*dtor).node.body);\n+        let dtor_body = fld.fold_block(&dtor.node.body);\n         ast::ii_dtor(\n             codemap::spanned {\n                 node: ast::struct_dtor_ { body: dtor_body,\n@@ -372,8 +372,8 @@ fn renumber_ast(xcx: @ExtendedDecodeContext, ii: ast::inlined_item)\n         ast::ii_foreign(fld.fold_foreign_item(i))\n       }\n       ast::ii_dtor(ref dtor, nm, ref generics, parent_id) => {\n-        let dtor_body = fld.fold_block((*dtor).node.body);\n-        let dtor_attrs = fld.fold_attributes(copy dtor.node.attrs);\n+        let dtor_body = fld.fold_block(&dtor.node.body);\n+        let dtor_attrs = fld.fold_attributes(/*bad*/copy (*dtor).node.attrs);\n         let new_generics = fold::fold_generics(generics, fld);\n         let dtor_id = fld.new_id((*dtor).node.id);\n         let new_parent = xcx.tr_def_id(parent_id);"}, {"sha": "c3555e54519a33e9627a4a597f37b22739004a0f", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -579,9 +579,9 @@ pub impl CheckLoanCtxt {\n     }\n }\n \n-fn check_loans_in_fn(fk: visit::fn_kind,\n-                     decl: ast::fn_decl,\n-                     body: ast::blk,\n+fn check_loans_in_fn(fk: &visit::fn_kind,\n+                     decl: &ast::fn_decl,\n+                     body: &ast::blk,\n                      sp: span,\n                      id: ast::node_id,\n                      &&self: @mut CheckLoanCtxt,\n@@ -590,7 +590,7 @@ fn check_loans_in_fn(fk: visit::fn_kind,\n     let fty = ty::node_id_to_type(self.tcx(), id);\n \n     let declared_purity;\n-    match fk {\n+    match *fk {\n         visit::fk_item_fn(*) | visit::fk_method(*) |\n         visit::fk_dtor(*) => {\n             declared_purity = ty::ty_fn_purity(fty);\n@@ -611,7 +611,7 @@ fn check_loans_in_fn(fk: visit::fn_kind,\n         do save_and_restore_managed(self.fn_args) {\n             *self.declared_purity = declared_purity;\n \n-            match fk {\n+            match *fk {\n                 visit::fk_anon(*) |\n                 visit::fk_fn_block(*) if is_stack_closure => {\n                     // inherits the fn_args from enclosing ctxt\n@@ -753,7 +753,7 @@ fn check_loans_in_expr(expr: @ast::expr,\n     visit::visit_expr(expr, self, vt);\n }\n \n-fn check_loans_in_block(blk: ast::blk,\n+fn check_loans_in_block(blk: &ast::blk,\n                         &&self: @mut CheckLoanCtxt,\n                         vt: visit::vt<@mut CheckLoanCtxt>) {\n     do save_and_restore_managed(self.declared_purity) {"}, {"sha": "ab343456ef463efc4d04c457eb95622099bdeb3e", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -95,9 +95,9 @@ pub fn gather_loans(bccx: @BorrowckCtxt, crate: @ast::crate) -> ReqMaps {\n     return glcx.req_maps;\n }\n \n-fn req_loans_in_fn(fk: visit::fn_kind,\n-                   decl: ast::fn_decl,\n-                   body: ast::blk,\n+fn req_loans_in_fn(fk: &visit::fn_kind,\n+                   decl: &ast::fn_decl,\n+                   body: &ast::blk,\n                    sp: span,\n                    id: ast::node_id,\n                    &&self: @mut GatherLoanCtxt,\n@@ -107,7 +107,7 @@ fn req_loans_in_fn(fk: visit::fn_kind,\n     let old_root_ub = self.root_ub;\n     self.root_ub = body.node.id;\n \n-    match fk {\n+    match *fk {\n         visit::fk_anon(*) | visit::fk_fn_block(*) => {}\n         visit::fk_item_fn(*) | visit::fk_method(*) |\n         visit::fk_dtor(*) => {\n@@ -269,13 +269,13 @@ fn req_loans_in_expr(ex: @ast::expr,\n         (vt.visit_expr)(cond, self, vt);\n \n         // during body, can only root for the body\n-        self.root_ub = (*body).node.id;\n-        (vt.visit_block)((*body), self, vt);\n+        self.root_ub = body.node.id;\n+        (vt.visit_block)(body, self, vt);\n       }\n \n       // see explanation attached to the `root_ub` field:\n       ast::expr_loop(ref body, _) => {\n-        self.root_ub = (*body).node.id;\n+        self.root_ub = body.node.id;\n         visit::visit_expr(ex, self, vt);\n       }\n "}, {"sha": "15f64b0fa2f0c0b8892ef4191b09615111751c1f", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -33,10 +33,10 @@ pub fn check_crate(tcx: ty::ctxt, crate: @crate) {\n             match e.node {\n               expr_while(e, ref b) => {\n                 (v.visit_expr)(e, cx, v);\n-                (v.visit_block)((*b), Context { in_loop: true,.. cx }, v);\n+                (v.visit_block)(b, Context { in_loop: true,.. cx }, v);\n               }\n               expr_loop(ref b, _) => {\n-                (v.visit_block)((*b), Context { in_loop: true,.. cx }, v);\n+                (v.visit_block)(b, Context { in_loop: true,.. cx }, v);\n               }\n               expr_fn(*) => {\n                 visit::visit_expr(e, Context {\n@@ -45,18 +45,18 @@ pub fn check_crate(tcx: ty::ctxt, crate: @crate) {\n                                      }, v);\n               }\n               expr_fn_block(_, ref b) => {\n-                (v.visit_block)((*b), Context {\n+                (v.visit_block)(b, Context {\n                                          in_loop: false,\n                                          can_ret: false\n                                       }, v);\n               }\n               expr_loop_body(@expr {node: expr_fn_block(_, ref b), _}) => {\n                 let sigil = ty::ty_closure_sigil(ty::expr_ty(tcx, e));\n                 let blk = (sigil == BorrowedSigil);\n-                (v.visit_block)((*b), Context {\n+                (v.visit_block)(b, Context {\n                                          in_loop: true,\n                                          can_ret: blk\n-                                      }, v);\n+                                     }, v);\n               }\n               expr_break(_) => {\n                 if !cx.in_loop {"}, {"sha": "f736c403cfccdb687777cdcffb50a46e932fc433", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -673,9 +673,9 @@ pub fn check_local(cx: @MatchCheckCtxt,\n }\n \n pub fn check_fn(cx: @MatchCheckCtxt,\n-                kind: visit::fn_kind,\n-                decl: fn_decl,\n-                body: blk,\n+                kind: &visit::fn_kind,\n+                decl: &fn_decl,\n+                body: &blk,\n                 sp: span,\n                 id: node_id,\n                 &&s: (),"}, {"sha": "7d2ab1700ddb1ff57d48bf77c692c59a4b7b2608", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -39,7 +39,7 @@ pub type freevar_map = HashMap<ast::node_id, freevar_info>;\n // Since we want to be able to collect upvars in some arbitrary piece\n // of the AST, we take a walker function that we invoke with a visitor\n // in order to start the search.\n-fn collect_freevars(def_map: resolve::DefMap, blk: ast::blk)\n+fn collect_freevars(def_map: resolve::DefMap, blk: &ast::blk)\n     -> freevar_info {\n     let seen = HashMap();\n     let refs = @mut ~[];\n@@ -100,8 +100,8 @@ pub fn annotate_freevars(def_map: resolve::DefMap, crate: @ast::crate) ->\n    freevar_map {\n     let freevars = HashMap();\n \n-    let walk_fn = fn@(_fk: visit::fn_kind, _decl: ast::fn_decl,\n-                      blk: ast::blk, _sp: span, nid: ast::node_id) {\n+    let walk_fn = fn@(_fk: &visit::fn_kind, _decl: &ast::fn_decl,\n+                      blk: &ast::blk, _sp: span, nid: ast::node_id) {\n         let vars = collect_freevars(def_map, blk);\n         freevars.insert(nid, vars);\n     };"}, {"sha": "1b1e9afa924d5dcf1b2b4a655dc04f9bcaa0d81b", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -153,8 +153,14 @@ fn with_appropriate_checker(cx: Context, id: node_id, b: fn(check_fn)) {\n \n // Check that the free variables used in a shared/sendable closure conform\n // to the copy/move kind bounds. Then recursively check the function body.\n-fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n-            fn_id: node_id, cx: Context, v: visit::vt<Context>) {\n+fn check_fn(\n+    fk: &visit::fn_kind,\n+    decl: &fn_decl,\n+    body: &blk,\n+    sp: span,\n+    fn_id: node_id,\n+    cx: Context,\n+    v: visit::vt<Context>) {\n \n     // Check kinds on free variables:\n     do with_appropriate_checker(cx, fn_id) |chk| {\n@@ -166,7 +172,7 @@ fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n     visit::visit_fn(fk, decl, body, sp, fn_id, cx, v);\n }\n \n-fn check_arm(a: arm, cx: Context, v: visit::vt<Context>) {\n+fn check_arm(a: &arm, cx: Context, v: visit::vt<Context>) {\n     for vec::each(a.pats) |p| {\n         do pat_util::pat_bindings(cx.tcx.def_map, *p) |mode, id, span, _pth| {\n             if mode == bind_by_copy {"}, {"sha": "d399f0e6886e6f8c2015cabbdb7da1efd05a1c73", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -324,7 +324,7 @@ struct LanguageItemCollector {\n \n pub impl LanguageItemCollector {\n     fn match_and_collect_meta_item(&self, item_def_id: def_id,\n-                                   meta_item: meta_item) {\n+                                   meta_item: @meta_item) {\n         match meta_item.node {\n             meta_name_value(key, literal) => {\n                 match literal.node {\n@@ -376,10 +376,10 @@ pub impl LanguageItemCollector {\n             visit_item: |item| {\n                 for item.attrs.each |attribute| {\n                     unsafe {\n-                        (*this).match_and_collect_meta_item(local_def(item\n-                                                                      .id),\n-                                                            attribute.node\n-                                                                     .value);\n+                        (*this).match_and_collect_meta_item(\n+                            local_def(item.id),\n+                            attribute.node.value\n+                        );\n                     }\n                 }\n             },"}, {"sha": "8bcc573ac36cb760334f187f6eb51778d75c07bb", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -753,7 +753,7 @@ fn check_item_structural_records(cx: ty::ctxt, it: @ast::item) {\n fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n \n     fn check_foreign_fn(cx: ty::ctxt, fn_id: ast::node_id,\n-                        decl: ast::fn_decl) {\n+                        decl: &ast::fn_decl) {\n         let tys = vec::map(decl.inputs, |a| a.ty );\n         for vec::each(vec::append_one(tys, decl.output)) |ty| {\n             match ty.node {\n@@ -786,9 +786,9 @@ fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n       if attr::foreign_abi(it.attrs) !=\n             either::Right(ast::foreign_abi_rust_intrinsic) => {\n         for nmod.items.each |ni| {\n-            match ni.node {\n+            match /*bad*/copy ni.node {\n               ast::foreign_item_fn(ref decl, _, _) => {\n-                check_foreign_fn(cx, it.id, *decl);\n+                check_foreign_fn(cx, it.id, decl);\n               }\n               // FIXME #4622: Not implemented.\n               ast::foreign_item_const(*) => {}\n@@ -950,13 +950,13 @@ fn check_item_non_camel_case_types(cx: ty::ctxt, it: @ast::item) {\n     }\n }\n \n-fn check_fn(tcx: ty::ctxt, fk: visit::fn_kind, decl: ast::fn_decl,\n-            _body: ast::blk, span: span, id: ast::node_id) {\n+fn check_fn(tcx: ty::ctxt, fk: &visit::fn_kind, decl: &ast::fn_decl,\n+            _body: &ast::blk, span: span, id: ast::node_id) {\n     debug!(\"lint check_fn fk=%? id=%?\", fk, id);\n \n     // don't complain about blocks, since they tend to get their modes\n     // specified from the outside\n-    match fk {\n+    match *fk {\n       visit::fk_fn_block(*) => { return; }\n       _ => {}\n     }\n@@ -965,7 +965,7 @@ fn check_fn(tcx: ty::ctxt, fk: visit::fn_kind, decl: ast::fn_decl,\n     check_fn_deprecated_modes(tcx, fn_ty, decl, span, id);\n }\n \n-fn check_fn_deprecated_modes(tcx: ty::ctxt, fn_ty: ty::t, decl: ast::fn_decl,\n+fn check_fn_deprecated_modes(tcx: ty::ctxt, fn_ty: ty::t, decl: &ast::fn_decl,\n                              span: span, id: ast::node_id) {\n     match ty::get(fn_ty).sty {\n         ty::ty_closure(ty::ClosureTy {sig: ref sig, _}) |\n@@ -1017,7 +1017,7 @@ fn check_fn_deprecated_modes(tcx: ty::ctxt, fn_ty: ty::t, decl: ast::fn_decl,\n                             ast::ty_closure(@ast::TyClosure{decl: ref d, _}) |\n                             ast::ty_bare_fn(@ast::TyBareFn{decl: ref d, _})=>{\n                                 check_fn_deprecated_modes(tcx, arg_ty.ty,\n-                                                          *d, span, id);\n+                                                          d, span, id);\n                             }\n                             ast::ty_path(*) => {\n                                 // This is probably a typedef, so we can't\n@@ -1053,7 +1053,7 @@ fn check_item_deprecated_modes(tcx: ty::ctxt, it: @ast::item) {\n                 ast::ty_bare_fn(@ast::TyBareFn {decl: ref decl, _}) => {\n                     let fn_ty = ty::node_id_to_type(tcx, it.id);\n                     check_fn_deprecated_modes(\n-                        tcx, fn_ty, *decl, ty.span, it.id)\n+                        tcx, fn_ty, decl, ty.span, it.id)\n                 }\n                 _ => ()\n             }"}, {"sha": "5286fa1025a769ee90a4d8791ab363b22d12d39b", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -435,9 +435,9 @@ pub impl IrMaps {\n     }\n }\n \n-fn visit_fn(fk: visit::fn_kind,\n-            decl: fn_decl,\n-            body: blk,\n+fn visit_fn(fk: &visit::fn_kind,\n+            decl: &fn_decl,\n+            body: &blk,\n             sp: span,\n             id: node_id,\n             &&self: @mut IrMaps,\n@@ -465,7 +465,7 @@ fn visit_fn(fk: visit::fn_kind,\n     };\n \n     // Add `self`, whether explicit or implicit.\n-    match fk {\n+    match *fk {\n         fk_method(_, _, method) => {\n             match method.self_ty.node {\n                 sty_by_ref => {\n@@ -540,7 +540,7 @@ fn visit_local(local: @local, &&self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n     visit::visit_local(local, self, vt);\n }\n \n-fn visit_arm(arm: arm, &&self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n+fn visit_arm(arm: &arm, &&self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n     let def_map = self.tcx.def_map;\n     for arm.pats.each |pat| {\n         do pat_util::pat_bindings(def_map, *pat) |bm, p_id, sp, path| {\n@@ -976,7 +976,7 @@ pub impl Liveness {\n \n     // _______________________________________________________________________\n \n-    fn compute(&self, decl: fn_decl, body: blk) -> LiveNode {\n+    fn compute(&self, decl: &fn_decl, body: &blk) -> LiveNode {\n         // if there is a `break` or `again` at the top level, then it's\n         // effectively a return---this only occurs in `for` loops,\n         // where the body is really a closure.\n@@ -1001,7 +1001,7 @@ pub impl Liveness {\n         entry_ln\n     }\n \n-    fn propagate_through_fn_block(&self, decl: fn_decl, blk: blk)\n+    fn propagate_through_fn_block(&self, decl: &fn_decl, blk: &blk)\n                                  -> LiveNode {\n         // inputs passed by & mode should be considered live on exit:\n         for decl.inputs.each |arg| {\n@@ -1035,7 +1035,7 @@ pub impl Liveness {\n         self.propagate_through_block(blk, self.s.fallthrough_ln)\n     }\n \n-    fn propagate_through_block(&self, blk: blk, succ: LiveNode) -> LiveNode {\n+    fn propagate_through_block(&self, blk: &blk, succ: LiveNode) -> LiveNode {\n         let succ = self.propagate_through_opt_expr(blk.node.expr, succ);\n         do blk.node.stmts.foldr(succ) |stmt, succ| {\n             self.propagate_through_stmt(*stmt, succ)\n@@ -1131,7 +1131,7 @@ pub impl Liveness {\n               The next-node for a break is the successor of the entire\n               loop. The next-node for a continue is the top of this loop.\n               */\n-              self.with_loop_nodes((*blk).node.id, succ,\n+              self.with_loop_nodes(blk.node.id, succ,\n                   self.live_node(expr.id, expr.span), || {\n \n                  // the construction of a closure itself is not important,\n@@ -1161,21 +1161,21 @@ pub impl Liveness {\n             //   (  succ  )\n             //\n             let else_ln = self.propagate_through_opt_expr(els, succ);\n-            let then_ln = self.propagate_through_block((*then), succ);\n+            let then_ln = self.propagate_through_block(then, succ);\n             let ln = self.live_node(expr.id, expr.span);\n             self.init_from_succ(ln, else_ln);\n             self.merge_from_succ(ln, then_ln, false);\n             self.propagate_through_expr(cond, ln)\n           }\n \n           expr_while(cond, ref blk) => {\n-            self.propagate_through_loop(expr, Some(cond), (*blk), succ)\n+            self.propagate_through_loop(expr, Some(cond), blk, succ)\n           }\n \n           // Note that labels have been resolved, so we don't need to look\n           // at the label ident\n           expr_loop(ref blk, _) => {\n-            self.propagate_through_loop(expr, None, (*blk), succ)\n+            self.propagate_through_loop(expr, None, blk, succ)\n           }\n \n           expr_match(e, ref arms) => {\n@@ -1196,9 +1196,9 @@ pub impl Liveness {\n             let ln = self.live_node(expr.id, expr.span);\n             self.init_empty(ln, succ);\n             let mut first_merge = true;\n-            for (*arms).each |arm| {\n+            for arms.each |arm| {\n                 let body_succ =\n-                    self.propagate_through_block(arm.body, succ);\n+                    self.propagate_through_block(&arm.body, succ);\n                 let guard_succ =\n                     self.propagate_through_opt_expr(arm.guard, body_succ);\n                 let arm_succ =\n@@ -1359,7 +1359,7 @@ pub impl Liveness {\n           }\n \n           expr_block(ref blk) => {\n-            self.propagate_through_block((*blk), succ)\n+            self.propagate_through_block(blk, succ)\n           }\n \n           expr_mac(*) => {\n@@ -1460,7 +1460,7 @@ pub impl Liveness {\n \n     fn propagate_through_loop(&self, expr: @expr,\n                               cond: Option<@expr>,\n-                              body: blk,\n+                              body: &blk,\n                               succ: LiveNode) -> LiveNode {\n \n         /*\n@@ -1565,7 +1565,7 @@ fn check_local(local: @local, &&self: @Liveness, vt: vt<@Liveness>) {\n     visit::visit_local(local, self, vt);\n }\n \n-fn check_arm(arm: arm, &&self: @Liveness, vt: vt<@Liveness>) {\n+fn check_arm(arm: &arm, &&self: @Liveness, vt: vt<@Liveness>) {\n     do self.arm_pats_bindings(arm.pats) |ln, var, sp| {\n         self.warn_about_unused(sp, ln, var);\n     }\n@@ -1636,8 +1636,8 @@ fn check_expr(expr: @expr, &&self: @Liveness, vt: vt<@Liveness>) {\n     }\n }\n \n-fn check_fn(_fk: visit::fn_kind, _decl: fn_decl,\n-            _body: blk, _sp: span, _id: node_id,\n+fn check_fn(_fk: &visit::fn_kind, _decl: &fn_decl,\n+            _body: &blk, _sp: span, _id: node_id,\n             &&_self: @Liveness, _v: vt<@Liveness>) {\n     // do not check contents of nested fns\n }\n@@ -1650,7 +1650,7 @@ enum ReadKind {\n }\n \n pub impl @Liveness {\n-    fn check_ret(&self, id: node_id, sp: span, _fk: visit::fn_kind,\n+    fn check_ret(&self, id: node_id, sp: span, _fk: &visit::fn_kind,\n                  entry_ln: LiveNode) {\n         if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n             // if no_ret_var is live, then we fall off the end of the\n@@ -1882,7 +1882,7 @@ pub impl @Liveness {\n         if name[0] == ('_' as u8) { None } else { Some(name) }\n     }\n \n-    fn warn_about_unused_args(&self, decl: fn_decl, entry_ln: LiveNode) {\n+    fn warn_about_unused_args(&self, decl: &fn_decl, entry_ln: LiveNode) {\n         for decl.inputs.each |arg| {\n             do pat_util::pat_bindings(self.tcx.def_map, arg.pat)\n                     |_bm, p_id, sp, _n| {"}, {"sha": "95764050898cdfede6062a01f3f3916965c897a8", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -221,7 +221,7 @@ pub fn record_parent(cx: ctxt, child_id: ast::node_id) {\n     }\n }\n \n-pub fn resolve_block(blk: ast::blk, cx: ctxt, visitor: visit::vt<ctxt>) {\n+pub fn resolve_block(blk: &ast::blk, cx: ctxt, visitor: visit::vt<ctxt>) {\n     // Record the parent of this block.\n     record_parent(cx, blk.node.id);\n \n@@ -230,7 +230,7 @@ pub fn resolve_block(blk: ast::blk, cx: ctxt, visitor: visit::vt<ctxt>) {\n     visit::visit_block(blk, new_cx, visitor);\n }\n \n-pub fn resolve_arm(arm: ast::arm, cx: ctxt, visitor: visit::vt<ctxt>) {\n+pub fn resolve_arm(arm: &ast::arm, cx: ctxt, visitor: visit::vt<ctxt>) {\n     visit::visit_arm(arm, cx, visitor);\n }\n \n@@ -316,14 +316,14 @@ pub fn resolve_item(item: @ast::item, cx: ctxt, visitor: visit::vt<ctxt>) {\n     visit::visit_item(item, new_cx, visitor);\n }\n \n-pub fn resolve_fn(fk: visit::fn_kind,\n-                  decl: ast::fn_decl,\n-                  body: ast::blk,\n+pub fn resolve_fn(fk: &visit::fn_kind,\n+                  decl: &ast::fn_decl,\n+                  body: &ast::blk,\n                   sp: span,\n                   id: ast::node_id,\n                   cx: ctxt,\n                   visitor: visit::vt<ctxt>) {\n-    let fn_cx = match fk {\n+    let fn_cx = match *fk {\n         visit::fk_item_fn(*) | visit::fk_method(*) |\n         visit::fk_dtor(*) => {\n             // Top-level functions are a root scope.\n@@ -337,7 +337,7 @@ pub fn resolve_fn(fk: visit::fn_kind,\n     };\n \n     // Record the ID of `self`.\n-    match fk {\n+    match *fk {\n         visit::fk_method(_, _, method) => {\n             cx.region_map.insert(method.self_id, body.node.id);\n         }\n@@ -607,9 +607,9 @@ pub fn determine_rp_in_item(item: @ast::item,\n     }\n }\n \n-pub fn determine_rp_in_fn(fk: visit::fn_kind,\n-                          decl: ast::fn_decl,\n-                          body: ast::blk,\n+pub fn determine_rp_in_fn(fk: &visit::fn_kind,\n+                          decl: &ast::fn_decl,\n+                          body: &ast::blk,\n                           _: span,\n                           _: ast::node_id,\n                           &&cx: @mut DetermineRpCtxt,\n@@ -627,7 +627,7 @@ pub fn determine_rp_in_fn(fk: visit::fn_kind,\n     }\n }\n \n-pub fn determine_rp_in_ty_method(ty_m: ast::ty_method,\n+pub fn determine_rp_in_ty_method(ty_m: &ast::ty_method,\n                                  &&cx: @mut DetermineRpCtxt,\n                                  visitor: visit::vt<@mut DetermineRpCtxt>) {\n     do cx.with(cx.item_id, false) {"}, {"sha": "1c4928fd374542617cc7fa42c0e3c8aa73ab1d45", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -1029,7 +1029,7 @@ pub impl Resolver {\n         }\n     }\n \n-    fn block_needs_anonymous_module(@mut self, block: blk) -> bool {\n+    fn block_needs_anonymous_module(@mut self, block: &blk) -> bool {\n         // If the block has view items, we need an anonymous module.\n         if block.node.view_items.len() > 0 {\n             return true;\n@@ -1081,7 +1081,7 @@ pub impl Resolver {\n         let privacy = visibility_to_privacy(item.vis);\n \n         match /*bad*/copy item.node {\n-            item_mod(module_) => {\n+            item_mod(ref module_) => {\n                 let (name_bindings, new_parent) =\n                     self.add_child(ident, parent, ForbidDuplicateModules, sp);\n \n@@ -1278,7 +1278,7 @@ pub impl Resolver {\n                 // methods, so check that first.\n                 let mut has_static_methods = false;\n                 for (*methods).each |method| {\n-                    let ty_m = trait_method_to_ty_method(*method);\n+                    let ty_m = trait_method_to_ty_method(method);\n                     match ty_m.self_ty.node {\n                         sty_static => {\n                             has_static_methods = true;\n@@ -1306,7 +1306,7 @@ pub impl Resolver {\n                 // Add the names of all the methods to the trait info.\n                 let method_names = @HashMap();\n                 for (*methods).each |method| {\n-                    let ty_m = trait_method_to_ty_method(*method);\n+                    let ty_m = trait_method_to_ty_method(method);\n \n                     let ident = ty_m.ident;\n                     // Add it to the trait info if not static,\n@@ -1537,7 +1537,7 @@ pub impl Resolver {\n     }\n \n     fn build_reduced_graph_for_block(@mut self,\n-                                     block: blk,\n+                                     block: &blk,\n                                      parent: ReducedGraphParent,\n                                      &&visitor: vt<ReducedGraphParent>) {\n         let mut new_parent;\n@@ -3729,7 +3729,7 @@ pub impl Resolver {\n                                     visitor);\n             }\n \n-            item_mod(module_) => {\n+            item_mod(ref module_) => {\n                 do self.with_scope(Some(item.ident)) {\n                     self.resolve_module(module_, item.span, item.ident,\n                                         item.id, visitor);\n@@ -3788,7 +3788,7 @@ pub impl Resolver {\n                                          item.id,\n                                          0,\n                                          OpaqueFunctionRibKind),\n-                                      (*block),\n+                                      block,\n                                       NoSelfBinding,\n                                       visitor);\n             }\n@@ -3866,7 +3866,7 @@ pub impl Resolver {\n                         rib_kind: RibKind,\n                         optional_declaration: Option<@fn_decl>,\n                         type_parameters: TypeParameters,\n-                        block: blk,\n+                        block: &blk,\n                         self_binding: SelfBinding,\n                         visitor: ResolveVisitor) {\n         // Create a value rib for the function.\n@@ -3980,7 +3980,7 @@ pub impl Resolver {\n                     self.resolve_function(NormalRibKind,\n                                           None,\n                                           NoTypeParameters,\n-                                          (*destructor).node.body,\n+                                          &destructor.node.body,\n                                           HasSelfBinding\n                                             ((*destructor).node.self_id,\n                                              true),\n@@ -4013,7 +4013,7 @@ pub impl Resolver {\n         self.resolve_function(rib_kind,\n                               Some(@/*bad*/copy method.decl),\n                               type_parameters,\n-                              method.body,\n+                              &method.body,\n                               self_binding,\n                               visitor);\n     }\n@@ -4095,7 +4095,7 @@ pub impl Resolver {\n     }\n \n     fn resolve_module(@mut self,\n-                      module_: _mod,\n+                      module_: &_mod,\n                       span: span,\n                       _name: ident,\n                       id: node_id,\n@@ -4137,7 +4137,7 @@ pub impl Resolver {\n         return result;\n     }\n \n-    fn check_consistent_bindings(@mut self, arm: arm) {\n+    fn check_consistent_bindings(@mut self, arm: &arm) {\n         if arm.pats.len() == 0 { return; }\n         let map_0 = self.binding_mode_map(arm.pats[0]);\n         for arm.pats.eachi() |i, p| {\n@@ -4176,7 +4176,7 @@ pub impl Resolver {\n         }\n     }\n \n-    fn resolve_arm(@mut self, arm: arm, visitor: ResolveVisitor) {\n+    fn resolve_arm(@mut self, arm: &arm, visitor: ResolveVisitor) {\n         (*self.value_ribs).push(@Rib(NormalRibKind));\n \n         let bindings_list = HashMap();\n@@ -4190,12 +4190,12 @@ pub impl Resolver {\n         self.check_consistent_bindings(arm);\n \n         visit_expr_opt(arm.guard, (), visitor);\n-        self.resolve_block(arm.body, visitor);\n+        self.resolve_block(&arm.body, visitor);\n \n         (*self.value_ribs).pop();\n     }\n \n-    fn resolve_block(@mut self, block: blk, visitor: ResolveVisitor) {\n+    fn resolve_block(@mut self, block: &blk, visitor: ResolveVisitor) {\n         debug!(\"(resolving block) entering block\");\n         (*self.value_ribs).push(@Rib(NormalRibKind));\n \n@@ -4954,7 +4954,7 @@ pub impl Resolver {\n                 self.resolve_function(FunctionRibKind(expr.id, block.node.id),\n                                       Some(@/*bad*/copy *fn_decl),\n                                       NoTypeParameters,\n-                                      (*block),\n+                                      block,\n                                       NoSelfBinding,\n                                       visitor);\n             }"}, {"sha": "d1472f63ae746b59a9d1162aadec7e4cc7438470", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -2100,7 +2100,7 @@ pub fn trans_item(ccx: @CrateContext, item: ast::item) {\n                      vec::append(/*bad*/copy *path, ~[path_name(item.ident)]),\n                      decl, body, llfndecl, no_self, None, item.id, None);\n         } else {\n-            for vec::each((*body).node.stmts) |stmt| {\n+            for body.node.stmts.each |stmt| {\n                 match stmt.node {\n                   ast::stmt_decl(@codemap::spanned { node: ast::decl_item(i),\n                                                  _ }, _) => {\n@@ -2115,7 +2115,7 @@ pub fn trans_item(ccx: @CrateContext, item: ast::item) {\n         meth::trans_impl(ccx, /*bad*/copy *path, item.ident, *ms,\n                          generics, None, item.id);\n       }\n-      ast::item_mod(m) => {\n+      ast::item_mod(ref m) => {\n         trans_mod(ccx, m);\n       }\n       ast::item_enum(ref enum_definition, ref tps) => {\n@@ -2128,11 +2128,10 @@ pub fn trans_item(ccx: @CrateContext, item: ast::item) {\n         }\n       }\n       ast::item_const(_, expr) => consts::trans_const(ccx, expr, item.id),\n-      ast::item_foreign_mod(foreign_mod) => {\n+      ast::item_foreign_mod(ref foreign_mod) => {\n         let abi = match attr::foreign_abi(item.attrs) {\n-          either::Right(abi_) => abi_,\n-          either::Left(ref msg) => ccx.sess.span_fatal(item.span,\n-                                                       /*bad*/copy *msg)\n+            Right(abi_) => abi_,\n+            Left(ref msg) => ccx.sess.span_fatal(item.span, /*bad*/copy *msg)\n         };\n         foreign::trans_foreign_mod(ccx, foreign_mod, abi);\n       }\n@@ -2172,9 +2171,9 @@ pub fn trans_struct_def(ccx: @CrateContext, struct_def: @ast::struct_def,\n // separate modules in the compiled program.  That's because modules exist\n // only as a convenience for humans working with the code, to organize names\n // and control visibility.\n-pub fn trans_mod(ccx: @CrateContext, m: ast::_mod) {\n+pub fn trans_mod(ccx: @CrateContext, m: &ast::_mod) {\n     let _icx = ccx.insn_ctxt(\"trans_mod\");\n-    for vec::each(m.items) |item| {\n+    for m.items.each |item| {\n         trans_item(ccx, **item);\n     }\n }\n@@ -3027,8 +3026,12 @@ pub fn trans_crate(sess: session::Session,\n     let symbol_hasher = @hash::default_state();\n     let link_meta =\n         link::build_link_meta(sess, crate, output, symbol_hasher);\n-    let reachable = reachable::find_reachable(crate.node.module, emap2, tcx,\n-                                              maps.method_map);\n+    let reachable = reachable::find_reachable(\n+        &crate.node.module,\n+        emap2,\n+        tcx,\n+        maps.method_map\n+    );\n \n     // Append \".rc\" to crate name as LLVM module identifier.\n     //\n@@ -3145,7 +3148,7 @@ pub fn trans_crate(sess: session::Session,\n \n         {\n             let _icx = ccx.insn_ctxt(\"text\");\n-            trans_mod(ccx, crate.node.module);\n+            trans_mod(ccx, &crate.node.module);\n         }\n \n         decl_gc_metadata(ccx, llmod_id);"}, {"sha": "12864f12abd99d71a2db5bd0be0bdad7f819f559", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -417,7 +417,7 @@ pub fn trans_lang_call_with_type_params(bcx: block,\n         ArgVals(args), dest, DontAutorefArg);\n }\n \n-pub fn body_contains_ret(body: ast::blk) -> bool {\n+pub fn body_contains_ret(body: &ast::blk) -> bool {\n     let cx = @mut false;\n     visit::visit_block(body, cx, visit::mk_vt(@visit::Visitor {\n         visit_item: |_i, _cx, _v| { },\n@@ -451,7 +451,7 @@ pub fn trans_call_inner(\n               ast::expr_loop_body(@ast::expr {\n                 node: ast::expr_fn_block(_, ref body),\n                 _\n-              }) =>  body_contains_ret((*body)),\n+              }) =>  body_contains_ret(body),\n               _ => false\n             }\n           }"}, {"sha": "6c0c73dd016f268c6f786d8a9846cb51db2c054d", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -207,7 +207,7 @@ fn build_wrap_fn_(ccx: @CrateContext,\n // function itself is unnecessary). We used to do this, in fact, and will\n // perhaps do so in the future.\n pub fn trans_foreign_mod(ccx: @CrateContext,\n-                         foreign_mod: ast::foreign_mod,\n+                         foreign_mod: &ast::foreign_mod,\n                          abi: ast::foreign_abi) {\n \n     let _icx = ccx.insn_ctxt(\"foreign::trans_foreign_mod\");"}, {"sha": "d2bf034165dd90f0fa1df5bdffed1d995cdb6f3d", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -307,7 +307,7 @@ pub fn trans_static_method_callee(bcx: block,\n     let mname = if method_id.crate == ast::local_crate {\n         match bcx.tcx().items.get(&method_id.node) {\n             ast_map::node_trait_method(trait_method, _, _) => {\n-                ast_util::trait_method_to_ty_method(*trait_method).ident\n+                ast_util::trait_method_to_ty_method(trait_method).ident\n             }\n             _ => fail!(~\"callee is not a trait method\")\n         }"}, {"sha": "17abebad600dc0e15a8b6929df2d53d6d2e5e67d", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -40,7 +40,7 @@ struct ctx {\n     rmap: map\n }\n \n-pub fn find_reachable(crate_mod: _mod, exp_map2: resolve::ExportMap2,\n+pub fn find_reachable(crate_mod: &_mod, exp_map2: resolve::ExportMap2,\n                       tcx: ty::ctxt, method_map: typeck::method_map) -> map {\n     let rmap = HashMap();\n     let cx = ctx {\n@@ -87,10 +87,10 @@ fn traverse_def_id(cx: ctx, did: def_id) {\n     }\n }\n \n-fn traverse_public_mod(cx: ctx, mod_id: node_id, m: _mod) {\n+fn traverse_public_mod(cx: ctx, mod_id: node_id, m: &_mod) {\n     if !traverse_exports(cx, mod_id) {\n         // No exports, so every local item is exported\n-        for vec::each(m.items) |item| {\n+        for m.items.each |item| {\n             traverse_public_item(cx, *item);\n         }\n     }\n@@ -99,19 +99,19 @@ fn traverse_public_mod(cx: ctx, mod_id: node_id, m: _mod) {\n fn traverse_public_item(cx: ctx, item: @item) {\n     if cx.rmap.contains_key(&item.id) { return; }\n     cx.rmap.insert(item.id, ());\n-    match item.node {\n-      item_mod(ref m) => traverse_public_mod(cx, item.id, *m),\n+    match /*bad*/copy item.node {\n+      item_mod(ref m) => traverse_public_mod(cx, item.id, m),\n       item_foreign_mod(ref nm) => {\n           if !traverse_exports(cx, item.id) {\n-              for vec::each(nm.items) |item| {\n+              for nm.items.each |item| {\n                   cx.rmap.insert(item.id, ());\n               }\n           }\n       }\n       item_fn(_, _, ref generics, ref blk) => {\n         if generics.ty_params.len() > 0u ||\n            attr::find_inline_attr(item.attrs) != attr::ia_none {\n-            traverse_inline_body(cx, (*blk));\n+            traverse_inline_body(cx, blk);\n         }\n       }\n       item_impl(ref generics, _, _, ref ms) => {\n@@ -121,20 +121,20 @@ fn traverse_public_item(cx: ctx, item: @item) {\n                 attr::find_inline_attr(m.attrs) != attr::ia_none\n             {\n                 cx.rmap.insert(m.id, ());\n-                traverse_inline_body(cx, m.body);\n+                traverse_inline_body(cx, &m.body);\n             }\n         }\n       }\n       item_struct(ref struct_def, ref generics) => {\n         for struct_def.ctor_id.each |&ctor_id| {\n             cx.rmap.insert(ctor_id, ());\n         }\n-        do option::iter(&struct_def.dtor) |dtor| {\n+        do struct_def.dtor.iter |dtor| {\n             cx.rmap.insert(dtor.node.id, ());\n             if generics.ty_params.len() > 0u ||\n                 attr::find_inline_attr(dtor.node.attrs) != attr::ia_none\n             {\n-                traverse_inline_body(cx, dtor.node.body);\n+                traverse_inline_body(cx, &dtor.node.body);\n             }\n         }\n       }\n@@ -173,7 +173,7 @@ fn traverse_ty(ty: @Ty, cx: ctx, v: visit::vt<ctx>) {\n     }\n }\n \n-fn traverse_inline_body(cx: ctx, body: blk) {\n+fn traverse_inline_body(cx: ctx, body: &blk) {\n     fn traverse_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n         match e.node {\n           expr_path(_) => {\n@@ -222,16 +222,19 @@ fn traverse_inline_body(cx: ctx, body: blk) {\n     fn traverse_item(i: @item, cx: ctx, _v: visit::vt<ctx>) {\n       traverse_public_item(cx, i);\n     }\n-     visit::visit_block(body, cx, visit::mk_vt(@visit::Visitor {\n+    visit::visit_block(body, cx, visit::mk_vt(@visit::Visitor {\n         visit_expr: traverse_expr,\n         visit_item: traverse_item,\n          ..*visit::default_visitor()\n     }));\n }\n \n-fn traverse_all_resources_and_impls(cx: ctx, crate_mod: _mod) {\n+fn traverse_all_resources_and_impls(cx: ctx, crate_mod: &_mod) {\n     visit::visit_mod(\n-        crate_mod, codemap::dummy_sp(), 0, cx,\n+        crate_mod,\n+        codemap::dummy_sp(),\n+        0,\n+        cx,\n         visit::mk_vt(@visit::Visitor {\n             visit_expr: |_e, _cx, _v| { },\n             visit_item: |i, cx, v| {"}, {"sha": "ff92f265cc06abd9cac96ef8ffefef1991c42a0f", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -107,7 +107,7 @@ pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n       ast_map::node_item(@ast::item { node: item_fn(_, _, _, ref body),\n                                       _ }, _) |\n       ast_map::node_method(@ast::method {body: ref body, _}, _, _) => {\n-        handle_body(cx, (*body));\n+        handle_body(cx, body);\n       }\n       ast_map::node_trait_method(*) => {\n         // This will be a static trait method. For now, we just assume\n@@ -163,8 +163,8 @@ pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n             for uint::range(0u, n_tps) |n| { cx.uses[n] |= flags;}\n         }\n       }\n-      ast_map::node_dtor(_, dtor, _, _) => {\n-        handle_body(cx, dtor.node.body);\n+      ast_map::node_dtor(_, ref dtor, _, _) => {\n+        handle_body(cx, &dtor.node.body);\n       }\n       ast_map::node_struct_ctor(*) => {\n         // Similarly to node_variant, this monomorphized function just uses\n@@ -363,7 +363,7 @@ pub fn mark_for_expr(cx: Context, e: @expr) {\n     }\n }\n \n-pub fn handle_body(cx: Context, body: blk) {\n+pub fn handle_body(cx: Context, body: &blk) {\n     let v = visit::mk_vt(@visit::Visitor {\n         visit_expr: |e, cx, v| {\n             visit::visit_expr(e, cx, v);"}, {"sha": "cabda54eeea0027cd30f2f59c87ffdfe4cf21812", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -3811,7 +3811,7 @@ pub fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n                             ast_map::path_name(method.ident))\n           }\n           ast_map::node_trait_method(trait_method, _, path) => {\n-            let method = ast_util::trait_method_to_ty_method(*trait_method);\n+            let method = ast_util::trait_method_to_ty_method(&*trait_method);\n             vec::append_one(/*bad*/copy *path,\n                             ast_map::path_name(method.ident))\n           }"}, {"sha": "5c05723bb3f0471df766fb0ff7e47079676b7b30", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -333,14 +333,14 @@ pub fn ast_ty_to_ty<AC:AstConv,RS:region_scope + Copy + Durable>(\n         };\n         ty::mk_rec(tcx, flds)\n       }\n-      ast::ty_bare_fn(bf) => {\n+      ast::ty_bare_fn(ref bf) => {\n           ty::mk_bare_fn(tcx, ty_of_bare_fn(self, rscope, bf.purity,\n-                                            bf.abi, bf.decl))\n+                                            bf.abi, &bf.decl))\n       }\n-      ast::ty_closure(f) => {\n+      ast::ty_closure(ref f) => {\n           let fn_decl = ty_of_closure(self, rscope, f.sigil,\n                                       f.purity, f.onceness,\n-                                      f.region, f.decl, None,\n+                                      f.region, &f.decl, None,\n                                       ast_ty.span);\n           ty::mk_closure(tcx, fn_decl)\n       }\n@@ -474,7 +474,7 @@ pub fn ty_of_bare_fn<AC:AstConv,RS:region_scope + Copy + Durable>(\n         rscope: RS,\n         purity: ast::purity,\n         abi: ast::Abi,\n-        decl: ast::fn_decl)\n+        decl: &ast::fn_decl)\n      -> ty::BareFnTy {\n     debug!(\"ty_of_fn_decl\");\n \n@@ -502,7 +502,7 @@ pub fn ty_of_closure<AC:AstConv,RS:region_scope + Copy + Durable>(\n         purity: ast::purity,\n         onceness: ast::Onceness,\n         opt_region: Option<@ast::region>,\n-        decl: ast::fn_decl,\n+        decl: &ast::fn_decl,\n         expected_tys: Option<ty::FnSig>,\n         span: span)\n      -> ty::ClosureTy {"}, {"sha": "39b2a2efdd817da634b73fdf9ec87794ac427432", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -58,7 +58,7 @@ pub fn check_match(fcx: @mut FnCtxt,\n           Some(e) => { check_expr_has_type(fcx, e, ty::mk_bool(tcx)); },\n           None => ()\n         }\n-        if !check_block(fcx, arm.body) { arm_non_bot = true; }\n+        if !check_block(fcx, &arm.body) { arm_non_bot = true; }\n         let bty = fcx.node_ty(arm.body.node.id);\n         demand::suptype(fcx, arm.body.span, result_ty, bty);\n     }"}, {"sha": "9ca8268171b0b59515c117627cee3d284da74ca3", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 38, "deletions": 28, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -246,7 +246,7 @@ pub fn check_item_types(ccx: @mut CrateCtxt, crate: @ast::crate) {\n \n pub fn check_bare_fn(ccx: @mut CrateCtxt,\n                      decl: &ast::fn_decl,\n-                     body: ast::blk,\n+                     body: &ast::blk,\n                      id: ast::node_id,\n                      self_info: Option<SelfInfo>) {\n     let fty = ty::node_id_to_type(ccx.tcx, id);\n@@ -266,7 +266,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n                 sigil: Option<ast::Sigil>,\n                 fn_sig: &ty::FnSig,\n                 decl: &ast::fn_decl,\n-                body: ast::blk,\n+                body: &ast::blk,\n                 fn_kind: FnKind,\n                 old_fcx: Option<@mut FnCtxt>) {\n     let tcx = ccx.tcx;\n@@ -384,7 +384,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n \n     fn gather_locals(fcx: @mut FnCtxt,\n                      decl: &ast::fn_decl,\n-                     body: ast::blk,\n+                     body: &ast::blk,\n                      arg_tys: &[ty::t],\n                      self_info: Option<SelfInfo>) {\n         let tcx = fcx.ccx.tcx;\n@@ -462,7 +462,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n             visit::visit_pat(p, e, v);\n         };\n \n-        let visit_block = fn@(b: ast::blk, &&e: (), v: visit::vt<()>) {\n+        let visit_block = fn@(b: &ast::blk, &&e: (), v: visit::vt<()>) {\n             // non-obvious: the `blk` variable maps to region lb, so\n             // we have to keep this up-to-date.  This\n             // is... unfortunate.  It'd be nice to not need this.\n@@ -472,8 +472,8 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         };\n \n         // Don't descend into fns and items\n-        fn visit_fn(_fk: visit::fn_kind, _decl: ast::fn_decl,\n-                    _body: ast::blk, _sp: span,\n+        fn visit_fn(_fk: &visit::fn_kind, _decl: &ast::fn_decl,\n+                    _body: &ast::blk, _sp: span,\n                     _id: ast::node_id, &&_t: (), _v: visit::vt<()>) {\n         }\n         fn visit_item(_i: @ast::item, &&_e: (), _v: visit::vt<()>) { }\n@@ -500,7 +500,13 @@ pub fn check_method(ccx: @mut CrateCtxt,\n         def_id: self_impl_def_id,\n         explicit_self: method.self_ty\n     };\n-    check_bare_fn(ccx, &method.decl, method.body, method.id, Some(self_info));\n+    check_bare_fn(\n+        ccx,\n+        &method.decl,\n+        &method.body,\n+        method.id,\n+        Some(self_info)\n+    );\n }\n \n pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n@@ -544,9 +550,13 @@ pub fn check_struct(ccx: @mut CrateCtxt,\n         };\n         // typecheck the dtor\n         let dtor_dec = ast_util::dtor_dec();\n-        check_bare_fn(ccx, &dtor_dec,\n-                      dtor.node.body, dtor.node.id,\n-                      Some(class_t));\n+        check_bare_fn(\n+            ccx,\n+            &dtor_dec,\n+            &dtor.node.body,\n+            dtor.node.id,\n+            Some(class_t)\n+        );\n     };\n \n     // Check that the class is instantiable\n@@ -568,7 +578,7 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n                             it.id);\n       }\n       ast::item_fn(ref decl, _, _, ref body) => {\n-        check_bare_fn(ccx, decl, (*body), it.id, None);\n+        check_bare_fn(ccx, decl, body, it.id, None);\n       }\n       ast::item_impl(_, _, ty, ms) => {\n         let rp = ccx.tcx.region_paramd_items.find(&it.id);\n@@ -1404,7 +1414,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     fn check_for(fcx: @mut FnCtxt,\n                  local: @ast::local,\n                  element_ty: ty::t,\n-                 body: ast::blk,\n+                 body: &ast::blk,\n                  node_id: ast::node_id)\n               -> bool {\n         let local_ty = fcx.local_ty(local.span, local.node.id);\n@@ -1418,7 +1428,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     // A generic function for checking the then and else in an if\n     // or if-check\n     fn check_then_else(fcx: @mut FnCtxt,\n-                       thn: ast::blk,\n+                       thn: &ast::blk,\n                        elsopt: Option<@ast::expr>,\n                        id: ast::node_id,\n                        _sp: span)\n@@ -1616,7 +1626,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                      expr: @ast::expr,\n                      ast_sigil_opt: Option<ast::Sigil>,\n                      decl: &ast::fn_decl,\n-                     body: ast::blk,\n+                     body: &ast::blk,\n                      fn_kind: FnKind,\n                      expected: Option<ty::t>) {\n         let tcx = fcx.ccx.tcx;\n@@ -1660,7 +1670,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let mut fn_ty = astconv::ty_of_closure(\n             fcx, fcx,\n             sigil, purity, expected_onceness,\n-            None, *decl, expected_tys, expr.span);\n+            None, decl, expected_tys, expr.span);\n \n         let fty = ty::mk_closure(tcx, copy fn_ty);\n \n@@ -2101,7 +2111,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 // message because of the indirect_ret_ty.\n                 let fn_kind = if err_happened {Vanilla} else {ForLoop};\n                 check_expr_fn(fcx, loop_body, None,\n-                              decl, *body, fn_kind, Some(inner_ty));\n+                              decl, body, fn_kind, Some(inner_ty));\n                 demand::suptype(fcx, loop_body.span,\n                                 inner_ty, fcx.expr_ty(loop_body));\n             }\n@@ -2348,28 +2358,28 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n       }\n       ast::expr_if(cond, ref thn, elsopt) => {\n         bot = check_expr_has_type(fcx, cond, ty::mk_bool(tcx));\n-        bot |= check_then_else(fcx, *thn, elsopt, id, expr.span);\n+        bot |= check_then_else(fcx, thn, elsopt, id, expr.span);\n       }\n       ast::expr_while(cond, ref body) => {\n         bot = check_expr_has_type(fcx, cond, ty::mk_bool(tcx));\n-        check_block_no_value(fcx, (*body));\n+        check_block_no_value(fcx, body);\n         fcx.write_ty(id, ty::mk_nil(tcx));\n       }\n       ast::expr_loop(ref body, _) => {\n-        check_block_no_value(fcx, (*body));\n+        check_block_no_value(fcx, body);\n         fcx.write_ty(id, ty::mk_nil(tcx));\n-        bot = !may_break(tcx, expr.id, (*body));\n+        bot = !may_break(tcx, expr.id, body);\n       }\n       ast::expr_match(discrim, ref arms) => {\n         bot = _match::check_match(fcx, expr, discrim, (/*bad*/copy *arms));\n       }\n       ast::expr_fn(sigil, ref decl, ref body, _) => {\n         check_expr_fn(fcx, expr, Some(sigil),\n-                      decl, (*body), Vanilla, expected);\n+                      decl, body, Vanilla, expected);\n       }\n       ast::expr_fn_block(ref decl, ref body) => {\n         check_expr_fn(fcx, expr, None,\n-                      decl, (*body), Vanilla, expected);\n+                      decl, body, Vanilla, expected);\n       }\n       ast::expr_loop_body(loop_body) => {\n           check_loop_body(fcx, expr, expected, loop_body);\n@@ -2399,7 +2409,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         match b.node {\n           ast::expr_fn_block(ref decl, ref body) => {\n             check_expr_fn(fcx, b, None,\n-                          decl, *body, DoBlock, Some(inner_ty));\n+                          decl, body, DoBlock, Some(inner_ty));\n             demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n           }\n           // argh\n@@ -2409,7 +2419,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n       }\n       ast::expr_block(ref b) => {\n         // If this is an unchecked block, turn off purity-checking\n-        bot = check_block_with_expected(fcx, *b, expected);\n+        bot = check_block_with_expected(fcx, b, expected);\n         let typ =\n             match b.node.expr {\n               Some(expr) => fcx.expr_ty(expr),\n@@ -2699,7 +2709,7 @@ pub fn check_stmt(fcx: @mut FnCtxt, stmt: @ast::stmt) -> bool {\n     return bot;\n }\n \n-pub fn check_block_no_value(fcx: @mut FnCtxt, blk: ast::blk) -> bool {\n+pub fn check_block_no_value(fcx: @mut FnCtxt, blk: &ast::blk) -> bool {\n     let bot = check_block(fcx, blk);\n     if !bot {\n         let blkty = fcx.node_ty(blk.node.id);\n@@ -2709,12 +2719,12 @@ pub fn check_block_no_value(fcx: @mut FnCtxt, blk: ast::blk) -> bool {\n     return bot;\n }\n \n-pub fn check_block(fcx0: @mut FnCtxt, blk: ast::blk) -> bool {\n+pub fn check_block(fcx0: @mut FnCtxt, blk: &ast::blk) -> bool {\n     check_block_with_expected(fcx0, blk, None)\n }\n \n pub fn check_block_with_expected(fcx0: @mut FnCtxt,\n-                                 blk: ast::blk,\n+                                 blk: &ast::blk,\n                                  expected: Option<ty::t>)\n                               -> bool {\n     let fcx = match blk.node.rules {\n@@ -3109,7 +3119,7 @@ pub fn ast_expr_vstore_to_vstore(fcx: @mut FnCtxt,\n }\n \n // Returns true if b contains a break that can exit from b\n-pub fn may_break(cx: ty::ctxt, id: ast::node_id, b: ast::blk) -> bool {\n+pub fn may_break(cx: ty::ctxt, id: ast::node_id, b: &ast::blk) -> bool {\n     // First: is there an unlabeled break immediately\n     // inside the loop?\n     (loop_query(b, |e| {"}, {"sha": "1f2dfe7192fb525e6c0895b0f2c1c8ebabaa2b18", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -125,7 +125,7 @@ pub fn regionck_expr(fcx: @mut FnCtxt, e: @ast::expr) {\n     fcx.infcx().resolve_regions();\n }\n \n-pub fn regionck_fn(fcx: @mut FnCtxt, blk: ast::blk) {\n+pub fn regionck_fn(fcx: @mut FnCtxt, blk: &ast::blk) {\n     let rcx = @mut Rcx { fcx: fcx, errors_reported: 0 };\n     let v = regionck_visitor();\n     (v.visit_block)(blk, rcx, v);\n@@ -176,7 +176,7 @@ pub fn visit_local(l: @ast::local, &&rcx: @mut Rcx, v: rvt) {\n     }\n }\n \n-pub fn visit_block(b: ast::blk, &&rcx: @mut Rcx, v: rvt) {\n+pub fn visit_block(b: &ast::blk, &&rcx: @mut Rcx, v: rvt) {\n     visit::visit_block(b, rcx, v);\n }\n "}, {"sha": "2dbf74e1666b4714b6f1f525f89ff0d33294752e", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -695,7 +695,7 @@ pub fn resolve_expr(ex: @ast::expr,\n \n // Detect points where a trait-bounded type parameter is\n // instantiated, resolve the impls for the parameters.\n-pub fn resolve_in_block(fcx: @mut FnCtxt, bl: ast::blk) {\n+pub fn resolve_in_block(fcx: @mut FnCtxt, bl: &ast::blk) {\n     visit::visit_block(bl, fcx, visit::mk_vt(@visit::Visitor {\n         visit_expr: resolve_expr,\n         visit_item: |_,_,_| {},"}, {"sha": "e5aca315dd1c9ad2c9e1351d10b7b12d8c1bfe76", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -218,7 +218,7 @@ fn visit_expr(e: @ast::expr, &&wbcx: @mut WbCtxt, v: wb_vt) {\n     }\n     visit::visit_expr(e, wbcx, v);\n }\n-fn visit_block(b: ast::blk, &&wbcx: @mut WbCtxt, v: wb_vt) {\n+fn visit_block(b: &ast::blk, &&wbcx: @mut WbCtxt, v: wb_vt) {\n     if !wbcx.success { return; }\n     resolve_type_vars_for_node(wbcx, b.span, b.node.id);\n     visit::visit_block(b, wbcx, v);\n@@ -278,7 +278,7 @@ pub fn resolve_type_vars_in_expr(fcx: @mut FnCtxt, e: @ast::expr) -> bool {\n \n pub fn resolve_type_vars_in_fn(fcx: @mut FnCtxt,\n                                decl: &ast::fn_decl,\n-                               blk: ast::blk,\n+                               blk: &ast::blk,\n                                self_info: Option<SelfInfo>) -> bool {\n     let wbcx = @mut WbCtxt { fcx: fcx, success: true };\n     let visit = mk_visitor();"}, {"sha": "f8fcef7580b1d272bdbcb04b327dc0ecec1f8a58", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -628,7 +628,7 @@ pub impl CoherenceChecker {\n         visit_crate(*crate, (), mk_vt(@Visitor {\n             visit_item: |item, _context, visitor| {\n                 match /*bad*/copy item.node {\n-                    item_mod(module_) => {\n+                    item_mod(ref module_) => {\n                         // Then visit the module items.\n                         visit_mod(module_, item.span, item.id, (), visitor);\n                     }"}, {"sha": "67dca7ea81196c0bdb44810bfb2a033669558b59", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 32, "deletions": 23, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -230,7 +230,7 @@ pub fn ensure_trait_methods(ccx: @mut CrateCtxt,\n     }\n \n     fn make_static_method_ty(ccx: @mut CrateCtxt,\n-                             am: ast::ty_method,\n+                             am: &ast::ty_method,\n                              rp: Option<ty::region_variance>,\n                              m: ty::method,\n                              // Take this as an argument b/c we may check\n@@ -291,10 +291,15 @@ pub fn ensure_trait_methods(ccx: @mut CrateCtxt,\n             }\n \n             let trait_bounds = ty_param_bounds(ccx, generics);\n-            let ty_m = trait_method_to_ty_method(*m);\n-            let method_ty = ty_of_ty_method(ccx, ty_m, region_paramd, def_id);\n+            let ty_m = trait_method_to_ty_method(m);\n+            let method_ty = ty_of_ty_method(\n+                ccx,\n+                &ty_m,\n+                region_paramd,\n+                def_id\n+            );\n             if ty_m.self_ty.node == ast::sty_static {\n-                make_static_method_ty(ccx, ty_m, region_paramd,\n+                make_static_method_ty(ccx, &ty_m, region_paramd,\n                                       method_ty, trait_ty,\n                                       trait_bounds);\n             }\n@@ -692,7 +697,7 @@ pub fn convert_struct(ccx: @mut CrateCtxt,\n             astconv::ty_of_bare_fn(\n                 ccx, type_rscope(rp),\n                 ast::impure_fn, ast::RustAbi,\n-                ast_util::dtor_dec()));\n+                &ast_util::dtor_dec()));\n         write_ty_to_tcx(tcx, dtor.node.id, t_dtor);\n         tcx.tcache.insert(local_def(dtor.node.id),\n                           ty_param_bounds_and_ty {\n@@ -751,22 +756,22 @@ pub fn ty_of_method(ccx: @mut CrateCtxt,\n         ident: m.ident,\n         tps: ty_param_bounds(ccx, &m.generics),\n         fty: astconv::ty_of_bare_fn(ccx, type_rscope(rp), m.purity,\n-                                    ast::RustAbi, m.decl),\n+                                    ast::RustAbi, &m.decl),\n         self_ty: m.self_ty.node,\n         vis: m.vis,\n         def_id: local_def(m.id)\n     }\n }\n \n pub fn ty_of_ty_method(self: @mut CrateCtxt,\n-                       m: ast::ty_method,\n+                       m: &ast::ty_method,\n                        rp: Option<ty::region_variance>,\n                        id: ast::def_id) -> ty::method {\n     ty::method {\n         ident: m.ident,\n         tps: ty_param_bounds(self, &m.generics),\n         fty: astconv::ty_of_bare_fn(self, type_rscope(rp), m.purity,\n-                                    ast::RustAbi, m.decl),\n+                                    ast::RustAbi, &m.decl),\n         // assume public, because this is only invoked on trait methods\n         self_ty: m.self_ty.node,\n         vis: ast::public,\n@@ -822,7 +827,7 @@ pub fn ty_of_item(ccx: @mut CrateCtxt, it: @ast::item)\n       ast::item_fn(ref decl, purity, ref generics, _) => {\n         let bounds = ty_param_bounds(ccx, generics);\n         let tofd = astconv::ty_of_bare_fn(ccx, empty_rscope, purity,\n-                                          ast::RustAbi, *decl);\n+                                          ast::RustAbi, decl);\n         let tpt = ty_param_bounds_and_ty {\n             bounds: bounds,\n             region_param: None,\n@@ -905,19 +910,23 @@ pub fn ty_of_item(ccx: @mut CrateCtxt, it: @ast::item)\n \n pub fn ty_of_foreign_item(ccx: @mut CrateCtxt, it: @ast::foreign_item)\n     -> ty::ty_param_bounds_and_ty {\n-    match it.node {\n-      ast::foreign_item_fn(ref fn_decl, _, ref generics) => {\n-        return ty_of_foreign_fn_decl(ccx, *fn_decl, local_def(it.id),\n-                                     generics);\n-      }\n-      ast::foreign_item_const(t) => {\n-        let rb = in_binding_rscope(empty_rscope);\n-        return ty::ty_param_bounds_and_ty {\n-            bounds: @~[],\n-            region_param: None,\n-            ty: ast_ty_to_ty(ccx, rb, t)\n-        };\n-      }\n+    match /*bad*/copy it.node {\n+        ast::foreign_item_fn(ref fn_decl, _, ref generics) => {\n+            ty_of_foreign_fn_decl(\n+                ccx,\n+                fn_decl,\n+                local_def(it.id),\n+                generics\n+            )\n+        }\n+        ast::foreign_item_const(t) => {\n+            let rb = in_binding_rscope(empty_rscope);\n+            ty::ty_param_bounds_and_ty {\n+                bounds: @~[],\n+                region_param: None,\n+                ty: ast_ty_to_ty(ccx, rb, t)\n+            }\n+        }\n     }\n }\n \n@@ -977,7 +986,7 @@ pub fn ty_param_bounds(ccx: @mut CrateCtxt,\n }\n \n pub fn ty_of_foreign_fn_decl(ccx: @mut CrateCtxt,\n-                             decl: ast::fn_decl,\n+                             decl: &ast::fn_decl,\n                              def_id: ast::def_id,\n                              generics: &ast::Generics)\n                           -> ty::ty_param_bounds_and_ty {"}, {"sha": "6357198fdf2cb14dec30cb234cb3ffe25cf78aeb", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -59,7 +59,7 @@ pub fn field_exprs(fields: ~[ast::field]) -> ~[@ast::expr] {\n \n // Takes a predicate p, returns true iff p is true for any subexpressions\n // of b -- skipping any inner loops (loop, while, loop_body)\n-pub fn loop_query(b: ast::blk, p: fn@(ast::expr_) -> bool) -> bool {\n+pub fn loop_query(b: &ast::blk, p: fn@(ast::expr_) -> bool) -> bool {\n     let rs = @mut false;\n     let visit_expr: @fn(@ast::expr,\n                         &&flag: @mut bool,\n@@ -82,7 +82,7 @@ pub fn loop_query(b: ast::blk, p: fn@(ast::expr_) -> bool) -> bool {\n \n // Takes a predicate p, returns true iff p is true for any subexpressions\n // of b -- skipping any inner loops (loop, while, loop_body)\n-pub fn block_query(b: ast::blk, p: fn@(@ast::expr) -> bool) -> bool {\n+pub fn block_query(b: &ast::blk, p: fn@(@ast::expr) -> bool) -> bool {\n     let rs = @mut false;\n     let visit_expr: @fn(@ast::expr,\n                         &&flag: @mut bool,"}, {"sha": "995fdba35cbd75aa4830529746da648fe75fb517", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -70,7 +70,7 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n       re_scope(node_id) => {\n         match cx.items.find(&node_id) {\n           Some(ast_map::node_block(ref blk)) => {\n-            explain_span(cx, \"block\", (*blk).span)\n+            explain_span(cx, \"block\", blk.span)\n           }\n           Some(ast_map::node_expr(expr)) => {\n             match expr.node {\n@@ -108,7 +108,7 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n \n         match cx.items.find(&id) {\n           Some(ast_map::node_block(ref blk)) => {\n-            let (msg, opt_span) = explain_span(cx, \"block\", (*blk).span);\n+            let (msg, opt_span) = explain_span(cx, \"block\", blk.span);\n             (fmt!(\"%s %s\", prefix, msg), opt_span)\n           }\n           Some(_) | None => {\n@@ -159,7 +159,7 @@ pub fn re_scope_id_to_str(cx: ctxt, node_id: ast::node_id) -> ~str {\n     match cx.items.find(&node_id) {\n       Some(ast_map::node_block(ref blk)) => {\n         fmt!(\"<block at %s>\",\n-             cx.sess.codemap.span_to_str((*blk).span))\n+             cx.sess.codemap.span_to_str(blk.span))\n       }\n       Some(ast_map::node_expr(expr)) => {\n         match expr.node {"}, {"sha": "afd3ca0ef6af309b7102a11ef0c4222f5760c458", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -77,7 +77,7 @@ fn get_fn_sig(srv: astsrv::Srv, fn_id: doc::AstId) -> Option<~str> {\n             ident: ident,\n             node: ast::foreign_item_fn(ref decl, _, ref tys), _\n           }, _, _) => {\n-            Some(pprust::fun_to_str(*decl, ident, tys,\n+            Some(pprust::fun_to_str(decl, ident, tys,\n                                     extract::interner()))\n           }\n           _ => fail!(~\"get_fn_sig: fn_id not bound to a fn item\")\n@@ -213,15 +213,15 @@ fn get_method_sig(\n                   match method {\n                     ast::required(ty_m) => {\n                       Some(pprust::fun_to_str(\n-                          ty_m.decl,\n+                          &ty_m.decl,\n                           ty_m.ident,\n                           &ty_m.generics,\n                           extract::interner()\n                       ))\n                     }\n                     ast::provided(m) => {\n                       Some(pprust::fun_to_str(\n-                          m.decl,\n+                          &m.decl,\n                           m.ident,\n                           &m.generics,\n                           extract::interner()\n@@ -240,7 +240,7 @@ fn get_method_sig(\n             }) {\n                 Some(method) => {\n                     Some(pprust::fun_to_str(\n-                        method.decl,\n+                        &method.decl,\n                         method.ident,\n                         &method.generics,\n                         extract::interner()"}, {"sha": "fdabe86359a6b01d6e11ffb0445c9bf9b87790e7", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -76,7 +76,7 @@ struct ReadyCtx {\n     fns: ~[ListenerFn]\n }\n \n-fn fold_mod(_ctx: @mut ReadyCtx, m: ast::_mod,\n+fn fold_mod(_ctx: @mut ReadyCtx, m: &ast::_mod,\n             fold: fold::ast_fold) -> ast::_mod {\n     fn strip_main(item: @ast::item) -> @ast::item {\n         @ast::item {\n@@ -87,11 +87,11 @@ fn fold_mod(_ctx: @mut ReadyCtx, m: ast::_mod,\n         }\n     }\n \n-    fold::noop_fold_mod(ast::_mod {\n-        items: do vec::map(m.items) |item| {\n+    fold::noop_fold_mod(&ast::_mod {\n+        items: do m.items.map |item| {\n             strip_main(*item)\n         },\n-        .. m\n+        .. copy *m\n     }, fold)\n }\n \n@@ -199,7 +199,7 @@ pub fn ready_crate(sess: session::Session,\n \n     let fold = fold::make_fold(precursor);\n \n-    @fold.fold_crate(*crate)\n+    @fold.fold_crate(crate)\n }\n \n pub fn parse_vers(vers: ~str) -> result::Result<semver::Version, ~str> {"}, {"sha": "1053473a3a58996a741597a6bbc189b7d86771bf", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -1190,7 +1190,7 @@ pub enum attr_style { attr_outer, attr_inner, }\n #[deriving_eq]\n pub struct attribute_ {\n     style: attr_style,\n-    value: meta_item,\n+    value: @meta_item,\n     is_sugared_doc: bool,\n }\n "}, {"sha": "0627e063d976cb44f9c11496419d76ad69c9c34a", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 105, "deletions": 80, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -61,8 +61,8 @@ pub fn path_to_str_with_sep(p: &[path_elt], sep: ~str, itr: @ident_interner)\n                          -> ~str {\n     let strs = do p.map |e| {\n         match *e {\n-          path_mod(s) => *itr.get(s),\n-          path_name(s) => *itr.get(s)\n+          path_mod(s) => copy *itr.get(s),\n+          path_name(s) => copy *itr.get(s)\n         }\n     };\n     str::connect(strs, sep)\n@@ -71,7 +71,7 @@ pub fn path_to_str_with_sep(p: &[path_elt], sep: ~str, itr: @ident_interner)\n pub fn path_ident_to_str(p: path, i: ident, itr: @ident_interner) -> ~str {\n     if vec::is_empty(p) {\n         //FIXME /* FIXME (#2543) */ copy *i\n-        *itr.get(i)\n+        copy *itr.get(i)\n     } else {\n         fmt!(\"%s::%s\", path_to_str(p, itr), *itr.get(i))\n     }\n@@ -83,8 +83,8 @@ pub fn path_to_str(p: &[path_elt], itr: @ident_interner) -> ~str {\n \n pub fn path_elt_to_str(pe: path_elt, itr: @ident_interner) -> ~str {\n     match pe {\n-        path_mod(s) => *itr.get(s),\n-        path_name(s) => *itr.get(s)\n+        path_mod(s) => copy *itr.get(s),\n+        path_name(s) => copy *itr.get(s)\n     }\n }\n \n@@ -119,7 +119,7 @@ pub struct Ctx {\n pub type vt = visit::vt<@mut Ctx>;\n \n pub fn extend(cx: @mut Ctx, +elt: ident) -> @path {\n-    @(vec::append(cx.path, ~[path_name(elt)]))\n+    @(vec::append(copy cx.path, ~[path_name(elt)]))\n }\n \n pub fn mk_ast_map_visitor() -> vt {\n@@ -161,7 +161,7 @@ pub fn map_decoded_item(diag: span_handler,\n     // variables that are simultaneously in scope).\n     let cx = @mut Ctx {\n         map: @map,\n-        path: path,\n+        path: copy path,\n         local_id: 0,\n         diag: diag,\n     };\n@@ -174,47 +174,57 @@ pub fn map_decoded_item(diag: span_handler,\n       ii_item(*) | ii_dtor(*) => { /* fallthrough */ }\n       ii_foreign(i) => {\n         cx.map.insert(i.id, node_foreign_item(i, foreign_abi_rust_intrinsic,\n-                                             @path));\n+                                              @/*bad*/ copy path));\n       }\n       ii_method(impl_did, m) => {\n-        map_method(impl_did, @path, m, cx);\n+        map_method(impl_did, @/*bad*/ copy path, m, cx);\n       }\n     }\n \n     // visit the item / method contents and add those to the map:\n     ii.accept(cx, v);\n }\n \n-pub fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n-              sp: codemap::span, id: node_id, &&cx: @mut Ctx, v: vt) {\n+pub fn map_fn(\n+    fk: &visit::fn_kind,\n+    decl: &fn_decl,\n+    body: &blk,\n+    sp: codemap::span,\n+    id: node_id,\n+    &&cx: @mut Ctx,\n+    v: visit::vt<@mut Ctx>\n+) {\n     for decl.inputs.each |a| {\n         cx.map.insert(a.id,\n-                      node_arg(/* FIXME (#2543) */\n-                          copy *a, cx.local_id));\n+                      node_arg(/* FIXME (#2543) */ copy *a, cx.local_id));\n         cx.local_id += 1u;\n     }\n-    match fk {\n-        visit::fk_dtor(ref tps, ref attrs, self_id, parent_id) => {\n+    match *fk {\n+        visit::fk_dtor(generics, ref attrs, self_id, parent_id) => {\n             let dt = @spanned {\n                 node: ast::struct_dtor_ {\n                     id: id,\n-                    attrs: (*attrs),\n+                    attrs: /* FIXME (#2543) */ vec::from_slice(*attrs),\n                     self_id: self_id,\n-                    body: /* FIXME (#2543) */ copy body,\n+                    body: /* FIXME (#2543) */ copy *body,\n                 },\n                 span: sp,\n             };\n-            cx.map.insert(id, node_dtor(/* FIXME (#2543) */ copy *tps, dt,\n-                                        parent_id,\n-                                        @/* FIXME (#2543) */ copy cx.path));\n+            cx.map.insert(\n+                id,\n+                node_dtor(\n+                    /* FIXME (#2543) */ copy *generics,\n+                    dt,\n+                    parent_id,\n+                    @/* FIXME (#2543) */ copy cx.path));\n       }\n       _ => ()\n     }\n     visit::visit_fn(fk, decl, body, sp, id, cx, v);\n }\n \n-pub fn map_block(b: blk, &&cx: @mut Ctx, v: vt) {\n-    cx.map.insert(b.node.id, node_block(/* FIXME (#2543) */ copy b));\n+pub fn map_block(b: &blk, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n+    cx.map.insert(b.node.id, node_block(/* FIXME (#2543) */ copy *b));\n     visit::visit_block(b, cx, v);\n }\n \n@@ -230,12 +240,12 @@ pub fn number_pat(cx: @mut Ctx, pat: @pat) {\n     };\n }\n \n-pub fn map_local(loc: @local, &&cx: @mut Ctx, v: vt) {\n+pub fn map_local(loc: @local, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n     number_pat(cx, loc.node.pat);\n     visit::visit_local(loc, cx, v);\n }\n \n-pub fn map_arm(arm: arm, &&cx: @mut Ctx, v: vt) {\n+pub fn map_arm(arm: &arm, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n     number_pat(cx, arm.pats[0]);\n     visit::visit_arm(arm, cx, v);\n }\n@@ -247,70 +257,85 @@ pub fn map_method(impl_did: def_id, impl_path: @path,\n     cx.local_id += 1u;\n }\n \n-pub fn map_item(i: @item, &&cx: @mut Ctx, v: vt) {\n+pub fn map_item(i: @item, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n     let item_path = @/* FIXME (#2543) */ copy cx.path;\n     cx.map.insert(i.id, node_item(i, item_path));\n     match i.node {\n-      item_impl(_, _, _, ms) => {\n-        let impl_did = ast_util::local_def(i.id);\n-        for ms.each |m| {\n-            map_method(impl_did, extend(cx, i.ident), *m, cx);\n+        item_impl(_, _, _, ref ms) => {\n+            let impl_did = ast_util::local_def(i.id);\n+            for ms.each |m| {\n+                map_method(impl_did, extend(cx, i.ident), *m, cx);\n+            }\n         }\n-      }\n-      item_enum(ref enum_definition, _) => {\n-        for (*enum_definition).variants.each |v| {\n-            cx.map.insert(v.node.id, node_variant(\n-                /* FIXME (#2543) */ copy *v, i,\n-                extend(cx, i.ident)));\n+        item_enum(ref enum_definition, _) => {\n+            for (*enum_definition).variants.each |v| {\n+                cx.map.insert(v.node.id, node_variant(\n+                    /* FIXME (#2543) */ copy *v, i,\n+                    extend(cx, i.ident)));\n+            }\n         }\n-      }\n-      item_foreign_mod(nm) => {\n-        let abi = match attr::foreign_abi(i.attrs) {\n-          either::Left(ref msg) => cx.diag.span_fatal(i.span, (*msg)),\n-          either::Right(abi) => abi\n-        };\n-        for nm.items.each |nitem| {\n-            cx.map.insert(nitem.id,\n-                          node_foreign_item(*nitem, abi,\n-                                           /* FIXME (#2543) */\n-                                            if nm.sort == ast::named {\n-                                                extend(cx, i.ident)\n-                                            }\n-                                            else {\n-                                                /* Anonymous extern mods go\n-                                                in the parent scope */\n-                                                @copy cx.path\n-                                            }));\n+        item_foreign_mod(ref nm) => {\n+            let abi = match attr::foreign_abi(i.attrs) {\n+                Left(ref msg) => cx.diag.span_fatal(i.span, (*msg)),\n+                Right(abi) => abi\n+            };\n+            for nm.items.each |nitem| {\n+                cx.map.insert(nitem.id,\n+                    node_foreign_item(\n+                        *nitem,\n+                        abi,\n+                        // FIXME (#2543)\n+                        if nm.sort == ast::named {\n+                            extend(cx, i.ident)\n+                        } else {\n+                            // Anonymous extern mods go in the parent scope\n+                            @copy cx.path\n+                        }\n+                    )\n+                );\n+            }\n         }\n-      }\n-      item_struct(struct_def, _) => {\n-        map_struct_def(struct_def, node_item(i, item_path), i.ident, cx,\n-                       v);\n-      }\n-      item_trait(_, ref traits, ref methods) => {\n-        for traits.each |p| {\n-            cx.map.insert(p.ref_id, node_item(i, item_path));\n+        item_struct(struct_def, _) => {\n+            map_struct_def(\n+                struct_def,\n+                node_item(i, item_path),\n+                i.ident,\n+                cx,\n+                v\n+            );\n         }\n-        for (*methods).each |tm| {\n-            let id = ast_util::trait_method_to_ty_method(*tm).id;\n-            let d_id = ast_util::local_def(i.id);\n-            cx.map.insert(id, node_trait_method(@*tm, d_id, item_path));\n+        item_trait(_, ref traits, ref methods) => {\n+            for traits.each |p| {\n+                cx.map.insert(p.ref_id, node_item(i, item_path));\n+            }\n+            for methods.each |tm| {\n+                let id = ast_util::trait_method_to_ty_method(tm).id;\n+                let d_id = ast_util::local_def(i.id);\n+                cx.map.insert(\n+                    id,\n+                    node_trait_method(@copy *tm, d_id, item_path)\n+                );\n+            }\n         }\n-      }\n-      _ => ()\n+        _ => ()\n     }\n     match i.node {\n-      item_mod(_) | item_foreign_mod(_) => {\n-        cx.path.push(path_mod(i.ident));\n-      }\n-      _ => cx.path.push(path_name(i.ident))\n+        item_mod(_) | item_foreign_mod(_) => {\n+            cx.path.push(path_mod(i.ident));\n+        }\n+        _ => cx.path.push(path_name(i.ident))\n     }\n     visit::visit_item(i, cx, v);\n     cx.path.pop();\n }\n \n-pub fn map_struct_def(struct_def: @ast::struct_def, parent_node: ast_node,\n-                      ident: ast::ident, cx: @mut Ctx, _v: vt) {\n+pub fn map_struct_def(\n+    struct_def: @ast::struct_def,\n+    parent_node: ast_node,\n+    ident: ast::ident,\n+    cx: @mut Ctx,\n+    _v: visit::vt<@mut Ctx>\n+) {\n     let p = extend(cx, ident);\n     // If this is a tuple-like struct, register the constructor.\n     match struct_def.ctor_id {\n@@ -327,12 +352,12 @@ pub fn map_struct_def(struct_def: @ast::struct_def, parent_node: ast_node,\n     }\n }\n \n-pub fn map_expr(ex: @expr, &&cx: @mut Ctx, v: vt) {\n+pub fn map_expr(ex: @expr, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n     cx.map.insert(ex.id, node_expr(ex));\n     visit::visit_expr(ex, cx, v);\n }\n \n-pub fn map_stmt(stmt: @stmt, &&cx: @mut Ctx, v: vt) {\n+pub fn map_stmt(stmt: @stmt, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n     cx.map.insert(stmt_id(*stmt), node_stmt(stmt));\n     visit::visit_stmt(stmt, cx, v);\n }\n@@ -366,14 +391,14 @@ pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n         fmt!(\"method %s in %s (id=%?)\",\n              *itr.get(m.ident), path_to_str(*path, itr), id)\n       }\n-      Some(node_trait_method(tm, _, path)) => {\n-        let m = ast_util::trait_method_to_ty_method(*tm);\n+      Some(node_trait_method(ref tm, _, path)) => {\n+        let m = ast_util::trait_method_to_ty_method(&**tm);\n         fmt!(\"method %s in %s (id=%?)\",\n              *itr.get(m.ident), path_to_str(*path, itr), id)\n       }\n       Some(node_variant(ref variant, _, path)) => {\n         fmt!(\"variant %s in %s (id=%?)\",\n-             *itr.get((*variant).node.name), path_to_str(*path, itr), id)\n+             *itr.get(variant.node.name), path_to_str(*path, itr), id)\n       }\n       Some(node_expr(expr)) => {\n         fmt!(\"expr %s (id=%?)\", pprust::expr_to_str(expr, itr), id)\n@@ -401,8 +426,8 @@ pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n }\n \n pub fn node_item_query<Result>(items: map, id: node_id,\n-                           query: fn(@item) -> Result,\n-                           error_msg: ~str) -> Result {\n+                               query: fn(@item) -> Result,\n+                               +error_msg: ~str) -> Result {\n     match items.find(&id) {\n         Some(node_item(it, _)) => query(it),\n         _ => fail!(error_msg)"}, {"sha": "7e0cd2640b2c43f7dd9a2c4b20acf8fece50e0fd", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -28,7 +28,7 @@ use core::vec;\n pub pure fn path_name_i(idents: &[ident], intr: @token::ident_interner)\n                      -> ~str {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n-    str::connect(idents.map(|i| *intr.get(*i)), ~\"::\")\n+    str::connect(idents.map(|i| copy *intr.get(*i)), ~\"::\")\n }\n \n \n@@ -261,15 +261,15 @@ pub fn public_methods(ms: ~[@method]) -> ~[@method] {\n \n // extract a ty_method from a trait_method. if the trait_method is\n // a default, pull out the useful fields to make a ty_method\n-pub fn trait_method_to_ty_method(method: trait_method) -> ty_method {\n-    match method {\n-        required(ref m) => (*m),\n+pub fn trait_method_to_ty_method(method: &trait_method) -> ty_method {\n+    match *method {\n+        required(ref m) => copy *m,\n         provided(ref m) => {\n             ty_method {\n                 ident: m.ident,\n-                attrs: m.attrs,\n+                attrs: copy m.attrs,\n                 purity: m.purity,\n-                decl: m.decl,\n+                decl: copy m.decl,\n                 generics: copy m.generics,\n                 self_ty: m.self_ty,\n                 id: m.id,\n@@ -279,12 +279,12 @@ pub fn trait_method_to_ty_method(method: trait_method) -> ty_method {\n     }\n }\n \n-pub fn split_trait_methods(trait_methods: ~[trait_method])\n+pub fn split_trait_methods(trait_methods: &[trait_method])\n     -> (~[ty_method], ~[@method]) {\n     let mut reqd = ~[], provd = ~[];\n     for trait_methods.each |trt_method| {\n         match *trt_method {\n-          required(ref tm) => reqd.push((*tm)),\n+          required(ref tm) => reqd.push(copy *tm),\n           provided(m) => provd.push(m)\n         }\n     };\n@@ -411,8 +411,8 @@ pub fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n         visit_view_item: fn@(vi: @view_item) {\n             match vi.node {\n               view_item_extern_mod(_, _, id) => vfn(id),\n-              view_item_use(vps) => {\n-                  for vec::each(vps) |vp| {\n+              view_item_use(ref vps) => {\n+                  for vps.each |vp| {\n                       match vp.node {\n                           view_path_simple(_, _, _, id) => vfn(id),\n                           view_path_glob(_, id) => vfn(id),\n@@ -440,15 +440,15 @@ pub fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n             vfn(l.node.id);\n         },\n \n-        visit_block: fn@(b: blk) {\n+        visit_block: fn@(b: &blk) {\n             vfn(b.node.id);\n         },\n \n         visit_stmt: fn@(s: @stmt) {\n             vfn(ast_util::stmt_id(*s));\n         },\n \n-        visit_arm: fn@(_a: arm) { },\n+        visit_arm: fn@(_a: &arm) { },\n \n         visit_pat: fn@(p: @pat) {\n             vfn(p.id)\n@@ -474,21 +474,21 @@ pub fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n \n         visit_generics: visit_generics,\n \n-        visit_fn: fn@(fk: visit::fn_kind, d: ast::fn_decl,\n-                      _b: ast::blk, _sp: span, id: ast::node_id) {\n+        visit_fn: fn@(fk: &visit::fn_kind, d: &ast::fn_decl,\n+                      _b: &ast::blk, _sp: span, id: ast::node_id) {\n             vfn(id);\n \n-            match fk {\n-                visit::fk_dtor(ref generics, _, self_id, parent_id) => {\n+            match *fk {\n+                visit::fk_dtor(generics, _, self_id, parent_id) => {\n                     visit_generics(generics);\n                     vfn(id);\n                     vfn(self_id);\n                     vfn(parent_id.node);\n                 }\n-                visit::fk_item_fn(_, ref generics, _) => {\n+                visit::fk_item_fn(_, generics, _) => {\n                     visit_generics(generics);\n                 }\n-                visit::fk_method(_, ref generics, m) => {\n+                visit::fk_method(_, generics, m) => {\n                     vfn(m.self_id);\n                     visit_generics(generics);\n                 }\n@@ -502,10 +502,10 @@ pub fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n             }\n         },\n \n-        visit_ty_method: fn@(_ty_m: ty_method) {\n+        visit_ty_method: fn@(_ty_m: &ty_method) {\n         },\n \n-        visit_trait_method: fn@(_ty_m: trait_method) {\n+        visit_trait_method: fn@(_ty_m: &trait_method) {\n         },\n \n         visit_struct_def: fn@(_sd: @struct_def,\n@@ -552,30 +552,29 @@ pub fn walk_pat(pat: @pat, it: fn(@pat)) {\n     it(pat);\n     match pat.node {\n         pat_ident(_, _, Some(p)) => walk_pat(p, it),\n-        pat_rec(fields, _) | pat_struct(_, fields, _) => {\n+        pat_rec(ref fields, _) | pat_struct(_, ref fields, _) => {\n             for fields.each |f| {\n                 walk_pat(f.pat, it)\n             }\n         }\n-        pat_enum(_, Some(s)) | pat_tup(s) => {\n+        pat_enum(_, Some(ref s)) | pat_tup(ref s) => {\n             for s.each |p| {\n                 walk_pat(*p, it)\n             }\n         }\n         pat_box(s) | pat_uniq(s) | pat_region(s) => {\n             walk_pat(s, it)\n         }\n-        pat_vec(elts, tail) => {\n+        pat_vec(ref elts, ref tail) => {\n             for elts.each |p| {\n                 walk_pat(*p, it)\n             }\n-            do option::iter(&tail) |tail| {\n+            do tail.iter |tail| {\n                 walk_pat(*tail, it)\n             }\n         }\n         pat_wild | pat_lit(_) | pat_range(_, _) | pat_ident(_, _, _) |\n-        pat_enum(_, _) => {\n-        }\n+        pat_enum(_, _) => { }\n     }\n }\n "}, {"sha": "e744d19b96544bc8868123c90760afd23e5451fb", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 37, "deletions": 35, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -51,16 +51,17 @@ pub fn mk_word_item(name: @~str) -> @ast::meta_item {\n \n pub fn mk_attr(item: @ast::meta_item) -> ast::attribute {\n     dummy_spanned(ast::attribute_ { style: ast::attr_inner,\n-                                    value: *item,\n+                                    value: item,\n                                     is_sugared_doc: false })\n }\n \n-pub fn mk_sugared_doc_attr(text: ~str,\n+pub fn mk_sugared_doc_attr(+text: ~str,\n                            +lo: BytePos, +hi: BytePos) -> ast::attribute {\n+    let style = doc_comment_style(text);\n     let lit = spanned(lo, hi, ast::lit_str(@text));\n     let attr = ast::attribute_ {\n-        style: doc_comment_style(text),\n-        value: spanned(lo, hi, ast::meta_name_value(@~\"doc\", lit)),\n+        style: style,\n+        value: @spanned(lo, hi, ast::meta_name_value(@~\"doc\", lit)),\n         is_sugared_doc: true\n     };\n     spanned(lo, hi, attr)\n@@ -69,7 +70,7 @@ pub fn mk_sugared_doc_attr(text: ~str,\n /* Conversion */\n \n pub fn attr_meta(attr: ast::attribute) -> @ast::meta_item {\n-    @attr.node.value\n+    attr.node.value\n }\n \n // Get the meta_items from inside a vector of attributes\n@@ -79,7 +80,7 @@ pub fn attr_metas(attrs: ~[ast::attribute]) -> ~[@ast::meta_item] {\n \n pub fn desugar_doc_attr(attr: &ast::attribute) -> ast::attribute {\n     if attr.node.is_sugared_doc {\n-        let comment = get_meta_item_value_str(@attr.node.value).get();\n+        let comment = get_meta_item_value_str(attr.node.value).get();\n         let meta = mk_name_value_item_str(@~\"doc\",\n                                      @strip_doc_comment_decoration(*comment));\n         mk_attr(meta)\n@@ -91,7 +92,7 @@ pub fn desugar_doc_attr(attr: &ast::attribute) -> ast::attribute {\n /* Accessors */\n \n pub pure fn get_attr_name(attr: &ast::attribute) -> @~str {\n-    get_meta_item_name(@attr.node.value)\n+    get_meta_item_name(attr.node.value)\n }\n \n pub pure fn get_meta_item_name(meta: @ast::meta_item) -> @~str {\n@@ -122,8 +123,8 @@ pub fn get_meta_item_value_str(meta: @ast::meta_item) -> Option<@~str> {\n pub fn get_meta_item_list(meta: @ast::meta_item)\n                        -> Option<~[@ast::meta_item]> {\n     match meta.node {\n-      ast::meta_list(_, l) => option::Some(/* FIXME (#2543) */ copy l),\n-      _ => option::None\n+        ast::meta_list(_, ref l) => Some(/* FIXME (#2543) */ copy *l),\n+        _ => None\n     }\n }\n \n@@ -182,33 +183,33 @@ pub fn contains(haystack: &[@ast::meta_item],\n }\n \n fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n-    return match a.node {\n-          ast::meta_word(ref na) => match b.node {\n+    match a.node {\n+        ast::meta_word(ref na) => match b.node {\n             ast::meta_word(ref nb) => (*na) == (*nb),\n             _ => false\n-          },\n-          ast::meta_name_value(ref na, va) => match b.node {\n+        },\n+        ast::meta_name_value(ref na, va) => match b.node {\n             ast::meta_name_value(ref nb, vb) => {\n                 (*na) == (*nb) && va.node == vb.node\n             }\n             _ => false\n-          },\n-          ast::meta_list(ref na, misa) => match b.node {\n-            ast::meta_list(ref nb, misb) => {\n+        },\n+        ast::meta_list(ref na, ref misa) => match b.node {\n+            ast::meta_list(ref nb, ref misb) => {\n                 if na != nb { return false; }\n-                for misa.each |&mi| {\n-                    if !contains(misb, mi) { return false; }\n+                for misa.each |mi| {\n+                    if !misb.contains(mi) { return false; }\n                 }\n                 true\n             }\n             _ => false\n-          }\n         }\n+    }\n }\n \n pub fn contains_name(metas: &[@ast::meta_item], name: &str) -> bool {\n     let matches = find_meta_items_by_name(metas, name);\n-    return vec::len(matches) > 0u;\n+    matches.len() > 0u\n }\n \n pub fn attrs_contains_name(attrs: &[ast::attribute], name: &str) -> bool {\n@@ -226,14 +227,14 @@ pub fn first_attr_value_str_by_name(attrs: ~[ast::attribute], name: &str)\n     }\n }\n \n-fn last_meta_item_by_name(items: ~[@ast::meta_item], name: &str)\n+fn last_meta_item_by_name(items: &[@ast::meta_item], name: &str)\n     -> Option<@ast::meta_item> {\n \n     let items = attr::find_meta_items_by_name(items, name);\n     vec::last_opt(items)\n }\n \n-pub fn last_meta_item_value_str_by_name(items: ~[@ast::meta_item], name: &str)\n+pub fn last_meta_item_value_str_by_name(items: &[@ast::meta_item], name: &str)\n                                      -> Option<@~str> {\n \n     match last_meta_item_by_name(items, name) {\n@@ -259,21 +260,23 @@ pub fn last_meta_item_list_by_name(items: ~[@ast::meta_item], name: &str)\n \n /* Higher-level applications */\n \n-pub fn sort_meta_items(+items: ~[@ast::meta_item]) -> ~[@ast::meta_item] {\n+pub fn sort_meta_items(items: &[@ast::meta_item]) -> ~[@ast::meta_item] {\n     // This is sort of stupid here, converting to a vec of mutables and back\n-    let mut v = items;\n+    let mut v = vec::from_slice(items);\n     do std::sort::quick_sort(v) |ma, mb| {\n         get_meta_item_name(*ma) <= get_meta_item_name(*mb)\n     }\n \n     // There doesn't seem to be a more optimal way to do this\n-    do v.map |&m| {\n+    do v.map |m| {\n         match m.node {\n-          ast::meta_list(n, mis) => @spanned {\n-              node: ast::meta_list(n, sort_meta_items(mis)),\n-              .. *m\n-          },\n-          _ => m\n+            ast::meta_list(n, ref mis) => {\n+                @spanned {\n+                    node: ast::meta_list(n, sort_meta_items(*mis)),\n+                    .. /*bad*/ copy **m\n+                }\n+            }\n+            _ => /*bad*/ copy *m\n         }\n     }\n }\n@@ -297,7 +300,7 @@ pub fn remove_meta_items_by_name(items: ~[@ast::meta_item], name: &str) ->\n pub fn find_linkage_metas(attrs: &[ast::attribute]) -> ~[@ast::meta_item] {\n     do find_attrs_by_name(attrs, ~\"link\").flat_map |attr| {\n         match attr.node.value.node {\n-            ast::meta_list(_, items) => /* FIXME (#2543) */ copy items,\n+            ast::meta_list(_, ref items) => /* FIXME (#2543) */ copy *items,\n             _ => ~[]\n         }\n     }\n@@ -344,11 +347,10 @@ pub fn find_inline_attr(attrs: &[ast::attribute]) -> inline_attr {\n     do vec::foldl(ia_none, attrs) |ia,attr| {\n         match attr.node.value.node {\n           ast::meta_word(@~\"inline\") => ia_hint,\n-          ast::meta_list(@~\"inline\", items) => {\n-            if !vec::is_empty(find_meta_items_by_name(items, ~\"always\")) {\n+          ast::meta_list(@~\"inline\", ref items) => {\n+            if !find_meta_items_by_name(*items, ~\"always\").is_empty() {\n                 ia_always\n-            } else if !vec::is_empty(\n-                find_meta_items_by_name(items, ~\"never\")) {\n+            } else if !find_meta_items_by_name(*items, ~\"never\").is_empty() {\n                 ia_never\n             } else {\n                 ia_hint"}, {"sha": "0e2f3c2c8562fa32bfce5adb933b261acce766a2", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 49, "deletions": 34, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -114,7 +114,7 @@ mod syntax {\n pub fn expand_auto_encode(\n     cx: ext_ctxt,\n     span: span,\n-    _mitem: ast::meta_item,\n+    _mitem: @ast::meta_item,\n     in_items: ~[@ast::item]\n ) -> ~[@ast::item] {\n     fn is_auto_encode(a: &ast::attribute) -> bool {\n@@ -124,7 +124,7 @@ pub fn expand_auto_encode(\n     fn filter_attrs(item: @ast::item) -> @ast::item {\n         @ast::item {\n             attrs: item.attrs.filtered(|a| !is_auto_encode(a)),\n-            .. *item\n+            .. copy *item\n         }\n     }\n \n@@ -147,7 +147,7 @@ pub fn expand_auto_encode(\n                         cx,\n                         item.span,\n                         item.ident,\n-                        *enum_def,\n+                        copy *enum_def,\n                         generics\n                     );\n \n@@ -169,7 +169,7 @@ pub fn expand_auto_encode(\n pub fn expand_auto_decode(\n     cx: ext_ctxt,\n     span: span,\n-    _mitem: ast::meta_item,\n+    _mitem: @ast::meta_item,\n     in_items: ~[@ast::item]\n ) -> ~[@ast::item] {\n     fn is_auto_decode(a: &ast::attribute) -> bool {\n@@ -179,7 +179,7 @@ pub fn expand_auto_decode(\n     fn filter_attrs(item: @ast::item) -> @ast::item {\n         @ast::item {\n             attrs: item.attrs.filtered(|a| !is_auto_decode(a)),\n-            .. *item\n+            .. copy *item\n         }\n     }\n \n@@ -202,7 +202,7 @@ pub fn expand_auto_decode(\n                         cx,\n                         item.span,\n                         item.ident,\n-                        *enum_def,\n+                        copy *enum_def,\n                         generics\n                     );\n \n@@ -241,7 +241,7 @@ priv impl ext_ctxt {\n         }\n     }\n \n-    fn expr(span: span, node: ast::expr_) -> @ast::expr {\n+    fn expr(span: span, +node: ast::expr_) -> @ast::expr {\n         @ast::expr {\n             id: self.next_id(),\n             callee_id: self.next_id(),\n@@ -250,7 +250,7 @@ priv impl ext_ctxt {\n         }\n     }\n \n-    fn path(span: span, strs: ~[ast::ident]) -> @ast::path {\n+    fn path(span: span, +strs: ~[ast::ident]) -> @ast::path {\n         @ast::path {\n             span: span,\n             global: false,\n@@ -260,7 +260,7 @@ priv impl ext_ctxt {\n         }\n     }\n \n-    fn path_global(span: span, strs: ~[ast::ident]) -> @ast::path {\n+    fn path_global(span: span, +strs: ~[ast::ident]) -> @ast::path {\n         @ast::path {\n             span: span,\n             global: true,\n@@ -270,8 +270,11 @@ priv impl ext_ctxt {\n         }\n     }\n \n-    fn path_tps(span: span, strs: ~[ast::ident],\n-                tps: ~[@ast::Ty]) -> @ast::path {\n+    fn path_tps(\n+        span: span,\n+        +strs: ~[ast::ident],\n+        +tps: ~[@ast::Ty]\n+    ) -> @ast::path {\n         @ast::path {\n             span: span,\n             global: false,\n@@ -281,8 +284,11 @@ priv impl ext_ctxt {\n         }\n     }\n \n-    fn path_tps_global(span: span, strs: ~[ast::ident],\n-                       tps: ~[@ast::Ty]) -> @ast::path {\n+    fn path_tps_global(\n+        span: span,\n+        +strs: ~[ast::ident],\n+        +tps: ~[@ast::Ty]\n+    ) -> @ast::path {\n         @ast::path {\n             span: span,\n             global: true,\n@@ -292,8 +298,11 @@ priv impl ext_ctxt {\n         }\n     }\n \n-    fn ty_path(span: span, strs: ~[ast::ident],\n-               tps: ~[@ast::Ty]) -> @ast::Ty {\n+    fn ty_path(\n+        span: span,\n+        +strs: ~[ast::ident],\n+        +tps: ~[@ast::Ty]\n+    ) -> @ast::Ty {\n         @ast::Ty {\n             id: self.next_id(),\n             node: ast::ty_path(\n@@ -339,13 +348,13 @@ priv impl ext_ctxt {\n                                 span: span}))\n     }\n \n-    fn lambda(blk: ast::blk) -> @ast::expr {\n+    fn lambda(+blk: ast::blk) -> @ast::expr {\n         let ext_cx = self;\n-        let blk_e = self.expr(blk.span, ast::expr_block(blk));\n+        let blk_e = self.expr(copy blk.span, ast::expr_block(copy blk));\n         quote_expr!( || $blk_e )\n     }\n \n-    fn blk(span: span, stmts: ~[@ast::stmt]) -> ast::blk {\n+    fn blk(span: span, +stmts: ~[@ast::stmt]) -> ast::blk {\n         codemap::spanned {\n             node: ast::blk_ {\n                 view_items: ~[],\n@@ -371,15 +380,15 @@ priv impl ext_ctxt {\n         }\n     }\n \n-    fn expr_path(span: span, strs: ~[ast::ident]) -> @ast::expr {\n+    fn expr_path(span: span, +strs: ~[ast::ident]) -> @ast::expr {\n         self.expr(span, ast::expr_path(self.path(span, strs)))\n     }\n \n-    fn expr_path_global(span: span, strs: ~[ast::ident]) -> @ast::expr {\n+    fn expr_path_global(span: span, +strs: ~[ast::ident]) -> @ast::expr {\n         self.expr(span, ast::expr_path(self.path_global(span, strs)))\n     }\n \n-    fn expr_var(span: span, var: ~str) -> @ast::expr {\n+    fn expr_var(span: span, +var: ~str) -> @ast::expr {\n         self.expr_path(span, ~[self.ident_of(var)])\n     }\n \n@@ -394,7 +403,7 @@ priv impl ext_ctxt {\n     fn expr_call(\n         span: span,\n         expr: @ast::expr,\n-        args: ~[@ast::expr]\n+        +args: ~[@ast::expr]\n     ) -> @ast::expr {\n         self.expr(span, ast::expr_call(expr, args, ast::NoSugar))\n     }\n@@ -403,7 +412,7 @@ priv impl ext_ctxt {\n         self.lambda(self.expr_blk(expr))\n     }\n \n-    fn lambda_stmts(span: span, stmts: ~[@ast::stmt]) -> @ast::expr {\n+    fn lambda_stmts(span: span, +stmts: ~[@ast::stmt]) -> @ast::expr {\n         self.lambda(self.blk(span, stmts))\n     }\n }\n@@ -572,7 +581,7 @@ fn mk_deser_impl(\n fn mk_ser_method(\n     cx: ext_ctxt,\n     span: span,\n-    ser_body: ast::blk\n+    +ser_body: ast::blk\n ) -> @ast::method {\n     let ty_s = @ast::Ty {\n         id: cx.next_id(),\n@@ -636,7 +645,7 @@ fn mk_deser_method(\n     cx: ext_ctxt,\n     span: span,\n     ty: @ast::Ty,\n-    deser_body: ast::blk\n+    +deser_body: ast::blk\n ) -> @ast::method {\n     let ty_d = @ast::Ty {\n         id: cx.next_id(),\n@@ -858,14 +867,14 @@ fn mk_enum_ser_impl(\n     cx: ext_ctxt,\n     span: span,\n     ident: ast::ident,\n-    enum_def: ast::enum_def,\n+    +enum_def: ast::enum_def,\n     generics: &ast::Generics\n ) -> @ast::item {\n     let body = mk_enum_ser_body(\n         cx,\n         span,\n         ident,\n-        enum_def.variants\n+        copy enum_def.variants\n     );\n \n     mk_ser_impl(cx, span, ident, generics, body)\n@@ -875,7 +884,7 @@ fn mk_enum_deser_impl(\n     cx: ext_ctxt,\n     span: span,\n     ident: ast::ident,\n-    enum_def: ast::enum_def,\n+    +enum_def: ast::enum_def,\n     generics: &ast::Generics\n ) -> @ast::item {\n     let body = mk_enum_deser_body(\n@@ -974,12 +983,18 @@ fn mk_enum_ser_body(\n     cx: ext_ctxt,\n     span: span,\n     name: ast::ident,\n-    variants: ~[ast::variant]\n+    +variants: ~[ast::variant]\n ) -> @ast::expr {\n     let arms = do variants.mapi |v_idx, variant| {\n         match variant.node.kind {\n-            ast::tuple_variant_kind(args) =>\n-                ser_variant(cx, span, variant.node.name, v_idx, args),\n+            ast::tuple_variant_kind(ref args) =>\n+                ser_variant(\n+                    cx,\n+                    span,\n+                    variant.node.name,\n+                    v_idx,\n+                    /*bad*/ copy *args\n+                ),\n             ast::struct_variant_kind(*) =>\n                 fail!(~\"struct variants unimplemented\"),\n             ast::enum_variant_kind(*) =>\n@@ -1059,7 +1074,7 @@ fn mk_enum_deser_body(\n ) -> @ast::expr {\n     let mut arms = do variants.mapi |v_idx, variant| {\n         let body = match variant.node.kind {\n-            ast::tuple_variant_kind(args) => {\n+            ast::tuple_variant_kind(ref args) => {\n                 if args.is_empty() {\n                     // for a nullary variant v, do \"v\"\n                     ext_cx.expr_path(span, ~[variant.node.name])\n@@ -1069,7 +1084,7 @@ fn mk_enum_deser_body(\n                         ext_cx,\n                         span,\n                         variant.node.name,\n-                        args\n+                        copy *args\n                     )\n                 }\n             },\n@@ -1092,7 +1107,7 @@ fn mk_enum_deser_body(\n         }\n     };\n \n-    let quoted_expr = quote_expr!(\n+    let quoted_expr = copy quote_expr!(\n       ::core::sys::begin_unwind(~\"explicit failure\", ~\"empty\", 1);\n     ).node;\n "}, {"sha": "7d3c7cafa9525b622815834bcd3e7decc2cca16d", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -38,15 +38,15 @@ pub struct MacroDef {\n }\n \n pub type ItemDecorator =\n-    fn@(ext_ctxt, span, ast::meta_item, ~[@ast::item]) -> ~[@ast::item];\n+    fn@(ext_ctxt, span, @ast::meta_item, ~[@ast::item]) -> ~[@ast::item];\n \n pub struct SyntaxExpanderTT {\n     expander: SyntaxExpanderTTFun,\n     span: Option<span>\n }\n \n pub type SyntaxExpanderTTFun\n-    = fn@(ext_ctxt, span, ~[ast::token_tree]) -> MacResult;\n+    = fn@(ext_ctxt, span, &[ast::token_tree]) -> MacResult;\n \n pub struct SyntaxExpanderTTItem {\n     expander: SyntaxExpanderTTItemFun,\n@@ -222,7 +222,7 @@ pub trait ext_ctxt {\n }\n \n pub fn mk_ctxt(parse_sess: @mut parse::ParseSess,\n-               cfg: ast::crate_cfg) -> ext_ctxt {\n+               +cfg: ast::crate_cfg) -> ext_ctxt {\n     struct CtxtRepr {\n         parse_sess: @mut parse::ParseSess,\n         cfg: ast::crate_cfg,\n@@ -233,7 +233,7 @@ pub fn mk_ctxt(parse_sess: @mut parse::ParseSess,\n     impl ext_ctxt for CtxtRepr {\n         fn codemap(@mut self) -> @CodeMap { self.parse_sess.cm }\n         fn parse_sess(@mut self) -> @mut parse::ParseSess { self.parse_sess }\n-        fn cfg(@mut self) -> ast::crate_cfg { self.cfg }\n+        fn cfg(@mut self) -> ast::crate_cfg { copy self.cfg }\n         fn call_site(@mut self) -> span {\n             match *self.backtrace {\n                 Some(@ExpandedFrom(CallInfo {call_site: cs, _})) => cs,\n@@ -244,15 +244,15 @@ pub fn mk_ctxt(parse_sess: @mut parse::ParseSess,\n         fn backtrace(@mut self) -> Option<@ExpnInfo> { *self.backtrace }\n         fn mod_push(@mut self, i: ast::ident) { self.mod_path.push(i); }\n         fn mod_pop(@mut self) { self.mod_path.pop(); }\n-        fn mod_path(@mut self) -> ~[ast::ident] { return self.mod_path; }\n+        fn mod_path(@mut self) -> ~[ast::ident] { copy self.mod_path }\n         fn bt_push(@mut self, ei: codemap::ExpnInfo) {\n             match ei {\n               ExpandedFrom(CallInfo {call_site: cs, callee: ref callee}) => {\n                 *self.backtrace =\n                     Some(@ExpandedFrom(CallInfo {\n                         call_site: span {lo: cs.lo, hi: cs.hi,\n                                          expn_info: *self.backtrace},\n-                        callee: (*callee)}));\n+                        callee: copy *callee}));\n               }\n             }\n         }\n@@ -299,12 +299,11 @@ pub fn mk_ctxt(parse_sess: @mut parse::ParseSess,\n         fn set_trace_macros(@mut self, x: bool) {\n             self.trace_mac = x\n         }\n-\n         fn str_of(@mut self, id: ast::ident) -> ~str {\n-            *self.parse_sess.interner.get(id)\n+            copy *self.parse_sess.interner.get(id)\n         }\n         fn ident_of(@mut self, st: ~str) -> ast::ident {\n-            self.parse_sess.interner.intern(@st)\n+            self.parse_sess.interner.intern(@/*bad*/ copy st)\n         }\n     }\n     let imp: @mut CtxtRepr = @mut CtxtRepr {\n@@ -320,7 +319,7 @@ pub fn mk_ctxt(parse_sess: @mut parse::ParseSess,\n pub fn expr_to_str(cx: ext_ctxt, expr: @ast::expr, err_msg: ~str) -> ~str {\n     match expr.node {\n       ast::expr_lit(l) => match l.node {\n-        ast::lit_str(s) => return *s,\n+        ast::lit_str(s) => copy *s,\n         _ => cx.span_fatal(l.span, err_msg)\n       },\n       _ => cx.span_fatal(expr.span, err_msg)\n@@ -363,15 +362,15 @@ pub fn get_single_str_from_tts(cx: ext_ctxt,\n     }\n }\n \n-pub fn get_exprs_from_tts(cx: ext_ctxt, tts: ~[ast::token_tree])\n+pub fn get_exprs_from_tts(cx: ext_ctxt, tts: &[ast::token_tree])\n                        -> ~[@ast::expr] {\n     let p = parse::new_parser_from_tts(cx.parse_sess(),\n                                        cx.cfg(),\n-                                       tts);\n+                                       vec::from_slice(tts));\n     let mut es = ~[];\n     while *p.token != token::EOF {\n         if es.len() != 0 {\n-            p.eat(token::COMMA);\n+            p.eat(&token::COMMA);\n         }\n         es.push(p.parse_expr());\n     }"}, {"sha": "c6e6e677348a10f0cfcc5caca1d1d0e5ddd85906", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 38, "deletions": 30, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -29,7 +29,7 @@ pub struct Field {\n \n pub fn mk_expr(cx: ext_ctxt,\n                sp: codemap::span,\n-               expr: ast::expr_)\n+               +expr: ast::expr_)\n             -> @ast::expr {\n     @ast::expr {\n         id: cx.next_id(),\n@@ -65,7 +65,7 @@ pub fn mk_unary(cx: ext_ctxt, sp: span, op: ast::unop, e: @ast::expr)\n     cx.next_id(); // see ast_util::op_expr_callee_id\n     mk_expr(cx, sp, ast::expr_unary(op, e))\n }\n-pub fn mk_raw_path(sp: span, idents: ~[ast::ident]) -> @ast::path {\n+pub fn mk_raw_path(sp: span, +idents: ~[ast::ident]) -> @ast::path {\n     let p = @ast::path { span: sp,\n                          global: false,\n                          idents: idents,\n@@ -74,7 +74,7 @@ pub fn mk_raw_path(sp: span, idents: ~[ast::ident]) -> @ast::path {\n     return p;\n }\n pub fn mk_raw_path_(sp: span,\n-                    idents: ~[ast::ident],\n+                    +idents: ~[ast::ident],\n                     +types: ~[@ast::Ty])\n                  -> @ast::path {\n     @ast::path { span: sp,\n@@ -83,25 +83,25 @@ pub fn mk_raw_path_(sp: span,\n                  rp: None,\n                  types: types }\n }\n-pub fn mk_raw_path_global(sp: span, idents: ~[ast::ident]) -> @ast::path {\n+pub fn mk_raw_path_global(sp: span, +idents: ~[ast::ident]) -> @ast::path {\n     @ast::path { span: sp,\n                  global: true,\n                  idents: idents,\n                  rp: None,\n                  types: ~[] }\n }\n-pub fn mk_path(cx: ext_ctxt, sp: span, idents: ~[ast::ident]) -> @ast::expr {\n+pub fn mk_path(cx: ext_ctxt, sp: span, +idents: ~[ast::ident]) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_path(mk_raw_path(sp, idents)))\n }\n-pub fn mk_path_global(cx: ext_ctxt, sp: span, idents: ~[ast::ident])\n+pub fn mk_path_global(cx: ext_ctxt, sp: span, +idents: ~[ast::ident])\n                    -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_path(mk_raw_path_global(sp, idents)))\n }\n pub fn mk_access_(cx: ext_ctxt, sp: span, p: @ast::expr, m: ast::ident)\n                -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_field(p, m, ~[]))\n }\n-pub fn mk_access(cx: ext_ctxt, sp: span, p: ~[ast::ident], m: ast::ident)\n+pub fn mk_access(cx: ext_ctxt, sp: span, +p: ~[ast::ident], m: ast::ident)\n               -> @ast::expr {\n     let pathexpr = mk_path(cx, sp, p);\n     return mk_access_(cx, sp, pathexpr, m);\n@@ -110,21 +110,21 @@ pub fn mk_addr_of(cx: ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n     return mk_expr(cx, sp, ast::expr_addr_of(ast::m_imm, e));\n }\n pub fn mk_call_(cx: ext_ctxt, sp: span, fn_expr: @ast::expr,\n-                args: ~[@ast::expr]) -> @ast::expr {\n+                +args: ~[@ast::expr]) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_call(fn_expr, args, ast::NoSugar))\n }\n-pub fn mk_call(cx: ext_ctxt, sp: span, fn_path: ~[ast::ident],\n-               args: ~[@ast::expr]) -> @ast::expr {\n+pub fn mk_call(cx: ext_ctxt, sp: span, +fn_path: ~[ast::ident],\n+               +args: ~[@ast::expr]) -> @ast::expr {\n     let pathexpr = mk_path(cx, sp, fn_path);\n     return mk_call_(cx, sp, pathexpr, args);\n }\n-pub fn mk_call_global(cx: ext_ctxt, sp: span, fn_path: ~[ast::ident],\n-                      args: ~[@ast::expr]) -> @ast::expr {\n+pub fn mk_call_global(cx: ext_ctxt, sp: span, +fn_path: ~[ast::ident],\n+                      +args: ~[@ast::expr]) -> @ast::expr {\n     let pathexpr = mk_path_global(cx, sp, fn_path);\n     return mk_call_(cx, sp, pathexpr, args);\n }\n // e = expr, t = type\n-pub fn mk_base_vec_e(cx: ext_ctxt, sp: span, exprs: ~[@ast::expr])\n+pub fn mk_base_vec_e(cx: ext_ctxt, sp: span, +exprs: ~[@ast::expr])\n                   -> @ast::expr {\n     let vecexpr = ast::expr_vec(exprs, ast::m_imm);\n     mk_expr(cx, sp, vecexpr)\n@@ -134,25 +134,25 @@ pub fn mk_vstore_e(cx: ext_ctxt, sp: span, expr: @ast::expr,\n    @ast::expr {\n     mk_expr(cx, sp, ast::expr_vstore(expr, vst))\n }\n-pub fn mk_uniq_vec_e(cx: ext_ctxt, sp: span, exprs: ~[@ast::expr])\n+pub fn mk_uniq_vec_e(cx: ext_ctxt, sp: span, +exprs: ~[@ast::expr])\n                   -> @ast::expr {\n     mk_vstore_e(cx, sp, mk_base_vec_e(cx, sp, exprs), ast::expr_vstore_uniq)\n }\n-pub fn mk_slice_vec_e(cx: ext_ctxt, sp: span, exprs: ~[@ast::expr])\n+pub fn mk_slice_vec_e(cx: ext_ctxt, sp: span, +exprs: ~[@ast::expr])\n                    -> @ast::expr {\n     mk_vstore_e(cx, sp, mk_base_vec_e(cx, sp, exprs),\n                 ast::expr_vstore_slice)\n }\n-pub fn mk_fixed_vec_e(cx: ext_ctxt, sp: span, exprs: ~[@ast::expr])\n+pub fn mk_fixed_vec_e(cx: ext_ctxt, sp: span, +exprs: ~[@ast::expr])\n                    -> @ast::expr {\n     mk_vstore_e(cx, sp, mk_base_vec_e(cx, sp, exprs),\n                 ast::expr_vstore_fixed(None))\n }\n-pub fn mk_base_str(cx: ext_ctxt, sp: span, s: ~str) -> @ast::expr {\n+pub fn mk_base_str(cx: ext_ctxt, sp: span, +s: ~str) -> @ast::expr {\n     let lit = ast::lit_str(@s);\n     return mk_lit(cx, sp, lit);\n }\n-pub fn mk_uniq_str(cx: ext_ctxt, sp: span, s: ~str) -> @ast::expr {\n+pub fn mk_uniq_str(cx: ext_ctxt, sp: span, +s: ~str) -> @ast::expr {\n     mk_vstore_e(cx, sp, mk_base_str(cx, sp, s), ast::expr_vstore_uniq)\n }\n pub fn mk_field(sp: span, f: &Field) -> ast::field {\n@@ -164,28 +164,36 @@ pub fn mk_field(sp: span, f: &Field) -> ast::field {\n pub fn mk_fields(sp: span, fields: ~[Field]) -> ~[ast::field] {\n     fields.map(|f| mk_field(sp, f))\n }\n-pub fn mk_rec_e(cx: ext_ctxt, sp: span, fields: ~[Field]) -> @ast::expr {\n+pub fn mk_rec_e(cx: ext_ctxt,\n+                sp: span,\n+                +fields: ~[Field])\n+             -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_rec(mk_fields(sp, fields),\n                                   option::None::<@ast::expr>))\n }\n-pub fn mk_struct_e(cx: ext_ctxt, sp: span, ctor_path: ~[ast::ident],\n-                   fields: ~[Field]) -> @ast::expr {\n+pub fn mk_struct_e(cx: ext_ctxt,\n+                   sp: span,\n+                   +ctor_path: ~[ast::ident],\n+                   +fields: ~[Field])\n+                -> @ast::expr {\n     mk_expr(cx, sp,\n             ast::expr_struct(mk_raw_path(sp, ctor_path),\n                              mk_fields(sp, fields),\n                                     option::None::<@ast::expr>))\n }\n-pub fn mk_global_struct_e(cx: ext_ctxt, sp: span,\n-                          ctor_path: ~[ast::ident],\n-                          fields: ~[Field])\n+pub fn mk_global_struct_e(cx: ext_ctxt,\n+                          sp: span,\n+                          +ctor_path: ~[ast::ident],\n+                          +fields: ~[Field])\n                        -> @ast::expr {\n     mk_expr(cx, sp,\n             ast::expr_struct(mk_raw_path_global(sp, ctor_path),\n                              mk_fields(sp, fields),\n                                     option::None::<@ast::expr>))\n }\n-pub fn mk_glob_use(cx: ext_ctxt, sp: span, path: ~[ast::ident])\n-            -> @ast::view_item {\n+pub fn mk_glob_use(cx: ext_ctxt,\n+                   sp: span,\n+                   +path: ~[ast::ident]) -> @ast::view_item {\n     let glob = @codemap::spanned {\n         node: ast::view_path_glob(mk_raw_path(sp, path), cx.next_id()),\n         span: sp,\n@@ -221,8 +229,8 @@ pub fn mk_local(cx: ext_ctxt, sp: span, mutbl: bool,\n     @codemap::spanned { node: ast::stmt_decl(@decl, cx.next_id()), span: sp }\n }\n pub fn mk_block(cx: ext_ctxt, span: span,\n-                view_items: ~[@ast::view_item],\n-                stmts: ~[@ast::stmt],\n+                +view_items: ~[@ast::view_item],\n+                +stmts: ~[@ast::stmt],\n                 expr: Option<@ast::expr>) -> @ast::expr {\n     let blk = codemap::spanned {\n         node: ast::blk_ {\n@@ -316,7 +324,7 @@ pub fn mk_stmt(cx: ext_ctxt, span: span, expr: @ast::expr) -> @ast::stmt {\n }\n pub fn mk_ty_path(cx: ext_ctxt,\n                   span: span,\n-                  idents: ~[ ast::ident ])\n+                  +idents: ~[ ast::ident ])\n                -> @ast::Ty {\n     let ty = build::mk_raw_path(span, idents);\n     let ty = ast::ty_path(ty, cx.next_id());\n@@ -325,7 +333,7 @@ pub fn mk_ty_path(cx: ext_ctxt,\n }\n pub fn mk_ty_path_global(cx: ext_ctxt,\n                          span: span,\n-                         idents: ~[ ast::ident ])\n+                         +idents: ~[ ast::ident ])\n                       -> @ast::Ty {\n     let ty = build::mk_raw_path_global(span, idents);\n     let ty = ast::ty_path(ty, cx.next_id());"}, {"sha": "4f53bf62efbab671b19f158c3a789f7a4b71ce3f", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -16,7 +16,7 @@ use ext::base::*;\n use ext::base;\n use parse::token;\n \n-pub fn expand_syntax_ext(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+pub fn expand_syntax_ext(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let mut res_str = ~\"\";\n     for tts.eachi |i, e| {"}, {"sha": "50047d2ce4166fee9eba81760b54ada9369d7d95", "filename": "src/libsyntax/ext/deriving.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -62,7 +62,7 @@ type ExpandDerivingEnumDefFn = &fn(ext_ctxt,\n \n pub fn expand_deriving_eq(cx: ext_ctxt,\n                           span: span,\n-                          _mitem: meta_item,\n+                          _mitem: @meta_item,\n                           in_items: ~[@item])\n                        -> ~[@item] {\n     expand_deriving(cx,\n@@ -74,7 +74,7 @@ pub fn expand_deriving_eq(cx: ext_ctxt,\n \n pub fn expand_deriving_iter_bytes(cx: ext_ctxt,\n                                   span: span,\n-                                  _mitem: meta_item,\n+                                  _mitem: @meta_item,\n                                   in_items: ~[@item])\n                                -> ~[@item] {\n     expand_deriving(cx,\n@@ -490,8 +490,8 @@ fn call_substructure_iter_bytes_method(cx: ext_ctxt,\n \n fn variant_arg_count(cx: ext_ctxt, span: span, variant: &variant) -> uint {\n     match variant.node.kind {\n-        tuple_variant_kind(args) => args.len(),\n-        struct_variant_kind(struct_def) => struct_def.fields.len(),\n+        tuple_variant_kind(ref args) => args.len(),\n+        struct_variant_kind(ref struct_def) => struct_def.fields.len(),\n         enum_variant_kind(*) => {\n             cx.span_bug(span, ~\"variant_arg_count: enum variants deprecated\")\n         }\n@@ -856,7 +856,7 @@ fn expand_deriving_eq_struct_tuple_method(cx: ext_ctxt,\n     let self_str = ~\"self\";\n     let other_str = ~\"__other\";\n     let type_path = build::mk_raw_path(span, ~[type_ident]);\n-    let fields = struct_def.fields;\n+    let fields = copy struct_def.fields;\n \n     // Create comparison expression, comparing each of the fields\n     let mut match_body = None;"}, {"sha": "91a9de9c051e899cf7bd39a699956571372b88b3", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -15,16 +15,15 @@\n  * interface.\n  */\n \n+use prelude::*;\n+\n use ast;\n use codemap::span;\n use ext::base::*;\n use ext::base;\n use ext::build::mk_uniq_str;\n \n-use core::option;\n-use core::os;\n-\n-pub fn expand_syntax_ext(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+pub fn expand_syntax_ext(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n \n     let var = get_single_str_from_tts(cx, sp, tts, \"env!\");\n@@ -33,8 +32,8 @@ pub fn expand_syntax_ext(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n     // Option<str> rather than just an maybe-empty string.\n \n     let e = match os::getenv(var) {\n-      option::None => mk_uniq_str(cx, sp, ~\"\"),\n-      option::Some(ref s) => mk_uniq_str(cx, sp, (*s))\n+      None => mk_uniq_str(cx, sp, ~\"\"),\n+      Some(ref s) => mk_uniq_str(cx, sp, copy *s)\n     };\n     MRExpr(e)\n }"}, {"sha": "e3408a47c9a40752865bbb0111c4bb1b6966feec", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 111, "deletions": 90, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -27,64 +27,73 @@ use core::vec;\n use core::hashmap::LinearMap;\n \n pub fn expand_expr(extsbox: @mut SyntaxEnv, cx: ext_ctxt,\n-                   e: expr_, s: span, fld: ast_fold,\n-                   orig: fn@(expr_, span, ast_fold) -> (expr_, span))\n+                   e: &expr_, s: span, fld: ast_fold,\n+                   orig: fn@(&expr_, span, ast_fold) -> (expr_, span))\n                 -> (expr_, span) {\n-    return match e {\n-      // expr_mac should really be expr_ext or something; it's the\n-      // entry-point for all syntax extensions.\n-          expr_mac(ref mac) => {\n-\n+    match *e {\n+        // expr_mac should really be expr_ext or something; it's the\n+        // entry-point for all syntax extensions.\n+        expr_mac(ref mac) => {\n             match (*mac).node {\n-\n-              // Token-tree macros, these will be the only case when we're\n-              // finished transitioning.\n-              mac_invoc_tt(pth, ref tts) => {\n-                assert (vec::len(pth.idents) == 1u);\n-                /* using idents and token::special_idents would make the\n-                the macro names be hygienic */\n-                let extname = cx.parse_sess().interner.get(pth.idents[0]);\n-                // leaving explicit deref here to highlight unbox op:\n-                match (*extsbox).find(&extname) {\n-                  None => {\n-                    cx.span_fatal(pth.span,\n-                                  fmt!(\"macro undefined: '%s'\", *extname))\n-                  }\n-                  Some(@SE(NormalTT(SyntaxExpanderTT{expander: exp,\n-                                                 span: exp_sp}))) => {\n-                    cx.bt_push(ExpandedFrom(CallInfo{\n-                        call_site: s,\n-                        callee: NameAndSpan {\n-                            name: *extname, span: exp_sp\n+                // Token-tree macros, these will be the only case when we're\n+                // finished transitioning.\n+                mac_invoc_tt(pth, ref tts) => {\n+                    assert (vec::len(pth.idents) == 1u);\n+                    /* using idents and token::special_idents would make the\n+                    the macro names be hygienic */\n+                    let extname = cx.parse_sess().interner.get(pth.idents[0]);\n+                    // leaving explicit deref here to highlight unbox op:\n+                    match (*extsbox).find(&extname) {\n+                        None => {\n+                            cx.span_fatal(\n+                                pth.span,\n+                                fmt!(\"macro undefined: '%s'\", *extname))\n                         }\n-                    }));\n-\n-                    let expanded = match exp(cx, (*mac).span, (*tts)) {\n-                      MRExpr(e) => e,\n-                      MRAny(expr_maker,_,_) => expr_maker(),\n-                      _ => cx.span_fatal(\n-                          pth.span, fmt!(\"non-expr macro in expr pos: %s\",\n-                                         *extname))\n-                    };\n-\n-                    //keep going, outside-in\n-                    let fully_expanded = fld.fold_expr(expanded).node;\n-                    cx.bt_pop();\n-\n-                    (fully_expanded, s)\n-                  }\n-                  _ => {\n-                    cx.span_fatal(pth.span,\n-                                  fmt!(\"'%s' is not a tt-style macro\",\n-                                       *extname))\n-                  }\n-\n+                        Some(@SE(NormalTT(SyntaxExpanderTT{\n+                            expander: exp,\n+                            span: exp_sp\n+                        }))) => {\n+                            cx.bt_push(ExpandedFrom(CallInfo {\n+                                call_site: s,\n+                                callee: NameAndSpan {\n+                                    name: copy *extname,\n+                                    span: exp_sp,\n+                                },\n+                            }));\n+\n+                            let expanded = match exp(cx, mac.span, *tts) {\n+                                MRExpr(e) => e,\n+                                MRAny(expr_maker,_,_) => expr_maker(),\n+                                _ => {\n+                                    cx.span_fatal(\n+                                        pth.span,\n+                                        fmt!(\n+                                            \"non-expr macro in expr pos: %s\",\n+                                            *extname\n+                                        )\n+                                    )\n+                                }\n+                            };\n+\n+                            //keep going, outside-in\n+                            let fully_expanded =\n+                                copy fld.fold_expr(expanded).node;\n+                            cx.bt_pop();\n+\n+                            (fully_expanded, s)\n+                        }\n+                        _ => {\n+                            cx.span_fatal(\n+                                pth.span,\n+                                fmt!(\"'%s' is not a tt-style macro\", *extname)\n+                            )\n+                        }\n+                    }\n                 }\n-              }\n             }\n-          }\n-          _ => orig(e, s, fld)\n-        };\n+        }\n+        _ => orig(e, s, fld)\n+    }\n }\n \n // This is a secondary mechanism for invoking syntax extensions on items:\n@@ -97,8 +106,8 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv, cx: ext_ctxt,\n // NB: there is some redundancy between this and expand_item, below, and\n // they might benefit from some amount of semantic and language-UI merger.\n pub fn expand_mod_items(extsbox: @mut SyntaxEnv, cx: ext_ctxt,\n-                        module_: ast::_mod, fld: ast_fold,\n-                        orig: fn@(ast::_mod, ast_fold) -> ast::_mod)\n+                        module_: &ast::_mod, fld: ast_fold,\n+                        orig: fn@(&ast::_mod, ast_fold) -> ast::_mod)\n                      -> ast::_mod {\n     // Fold the contents first:\n     let module_ = orig(module_, fld);\n@@ -146,8 +155,8 @@ macro_rules! with_exts_frame (\n \n // When we enter a module, record it, for the sake of `module!`\n pub fn expand_item(extsbox: @mut SyntaxEnv,\n-                   cx: ext_ctxt, &&it: @ast::item, fld: ast_fold,\n-                   orig: fn@(&&v: @ast::item, ast_fold) -> Option<@ast::item>)\n+                   cx: ext_ctxt, it: @ast::item, fld: ast_fold,\n+                   orig: fn@(@ast::item, ast_fold) -> Option<@ast::item>)\n                 -> Option<@ast::item> {\n     // need to do expansion first... it might turn out to be a module.\n     let maybe_it = match it.node {\n@@ -225,7 +234,7 @@ pub fn expand_item_mac(+extsbox: @mut SyntaxEnv,\n \n     let (pth, tts) = match it.node {\n         item_mac(codemap::spanned { node: mac_invoc_tt(pth, ref tts), _}) => {\n-            (pth, (*tts))\n+            (pth, copy *tts)\n         }\n         _ => cx.span_bug(it.span, ~\"invalid item macro invocation\")\n     };\n@@ -245,8 +254,8 @@ pub fn expand_item_mac(+extsbox: @mut SyntaxEnv,\n             cx.bt_push(ExpandedFrom(CallInfo {\n                 call_site: it.span,\n                 callee: NameAndSpan {\n-                    name: *extname,\n-                    span: (*expand).span\n+                    name: copy *extname,\n+                    span: expand.span\n                 }\n             }));\n             ((*expand).expander)(cx, it.span, tts)\n@@ -260,8 +269,8 @@ pub fn expand_item_mac(+extsbox: @mut SyntaxEnv,\n             cx.bt_push(ExpandedFrom(CallInfo {\n                 call_site: it.span,\n                 callee: NameAndSpan {\n-                    name: *extname,\n-                    span: (*expand).span\n+                    name: copy *extname,\n+                    span: expand.span\n                 }\n             }));\n             ((*expand).expander)(cx, it.span, it.ident, tts)\n@@ -288,14 +297,16 @@ pub fn expand_item_mac(+extsbox: @mut SyntaxEnv,\n \n // expand a stmt\n pub fn expand_stmt(extsbox: @mut SyntaxEnv, cx: ext_ctxt,\n-                   && s: stmt_, sp: span, fld: ast_fold,\n-                   orig: fn@(&&s: stmt_, span, ast_fold) -> (stmt_, span))\n+                   s: &stmt_, sp: span, fld: ast_fold,\n+                   orig: fn@(s: &stmt_, span, ast_fold) -> (stmt_, span))\n                 -> (stmt_, span) {\n \n-    let (mac, pth, tts, semi) = match s {\n+    let (mac, pth, tts, semi) = match *s {\n         stmt_mac(ref mac, semi) => {\n-            match (*mac).node {\n-                mac_invoc_tt(pth, ref tts) => ((*mac), pth, (*tts), semi)\n+            match mac.node {\n+                mac_invoc_tt(pth, ref tts) => {\n+                    (copy *mac, pth, copy *tts, semi)\n+                }\n             }\n         }\n         _ => return orig(s, sp, fld)\n@@ -311,7 +322,7 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv, cx: ext_ctxt,\n             SyntaxExpanderTT{expander: exp, span: exp_sp}))) => {\n             cx.bt_push(ExpandedFrom(CallInfo {\n                 call_site: sp,\n-                callee: NameAndSpan { name: *extname, span: exp_sp }\n+                callee: NameAndSpan { name: copy *extname, span: exp_sp }\n             }));\n             let expanded = match exp(cx, mac.span, tts) {\n                 MRExpr(e) =>\n@@ -324,7 +335,7 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv, cx: ext_ctxt,\n             };\n \n             //keep going, outside-in\n-            let fully_expanded = fld.fold_stmt(expanded).node;\n+            let fully_expanded = copy fld.fold_stmt(expanded).node;\n             cx.bt_pop();\n \n             (fully_expanded, sp)\n@@ -346,8 +357,8 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv, cx: ext_ctxt,\n \n \n pub fn expand_block(extsbox: @mut SyntaxEnv, cx: ext_ctxt,\n-                    && blk: blk_, sp: span, fld: ast_fold,\n-                    orig: fn@(&&s: blk_, span, ast_fold) -> (blk_, span))\n+                    blk: &blk_, sp: span, fld: ast_fold,\n+                    orig: fn@(&blk_, span, ast_fold) -> (blk_, span))\n     -> (blk_, span) {\n     match (*extsbox).find(&@~\" block\") {\n         // no scope limit on macros in this block, no need\n@@ -433,7 +444,7 @@ pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n     // every method/element of AstFoldFns in fold.rs.\n     let extsbox = @mut syntax_expander_table();\n     let afp = default_ast_fold();\n-    let cx: ext_ctxt = mk_ctxt(parse_sess, cfg);\n+    let cx: ext_ctxt = mk_ctxt(parse_sess, copy cfg);\n     let f_pre = @AstFoldFns {\n         fold_expr: |expr,span,recur|\n             expand_expr(extsbox, cx, expr, span, recur, afp.fold_expr),\n@@ -444,23 +455,30 @@ pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n         fold_stmt: |stmt,span,recur|\n             expand_stmt(extsbox, cx, stmt, span, recur, afp.fold_stmt),\n         fold_block: |blk,span,recur|\n-            expand_block (extsbox, cx, blk, span, recur, afp.fold_block),\n+            expand_block(extsbox, cx, blk, span, recur, afp.fold_block),\n         new_span: |a| new_span(cx, a),\n         .. *afp};\n     let f = make_fold(f_pre);\n     // add a bunch of macros as though they were placed at the\n     // head of the program (ick).\n-    let attrs = ~[spanned {span:codemap::dummy_sp(),\n-                           node: attribute_\n-                               {style:attr_outer,\n-                                value:spanned\n-                                    {node:meta_word(@~\"macro_escape\"),\n-                                     span:codemap::dummy_sp()},\n-                                is_sugared_doc:false}}];\n+    let attrs = ~[\n+        spanned {\n+            span: codemap::dummy_sp(),\n+            node: attribute_ {\n+                style: attr_outer,\n+                value: @spanned {\n+                    node: meta_word(@~\"macro_escape\"),\n+                    span: codemap::dummy_sp(),\n+                },\n+                is_sugared_doc: false,\n+            }\n+        }\n+    ];\n \n     let cm = match parse_item_from_source_str(~\"<core-macros>\",\n                                               @core_macros(),\n-                                              cfg,attrs,\n+                                              copy cfg,\n+                                              attrs,\n                                               parse_sess) {\n         Some(item) => item,\n         None => cx.bug(~\"expected core macros to parse correctly\")\n@@ -469,8 +487,7 @@ pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n     // as it registers all the core macros as expanders.\n     f.fold_item(cm);\n \n-    let res = @f.fold_crate(*c);\n-    return res;\n+    @f.fold_crate(&*c)\n }\n \n #[cfg(test)]\n@@ -575,13 +592,17 @@ mod test {\n \n     // make a \"meta_word\" outer attribute with the given name\n     fn make_dummy_attr(s: @~str) -> ast::attribute {\n-        spanned {span:codemap::dummy_sp(),\n-                 node: attribute_\n-                     {style:attr_outer,\n-                      value:spanned\n-                          {node:meta_word(s),\n-                           span:codemap::dummy_sp()},\n-                      is_sugared_doc:false}}\n+        spanned {\n+            span:codemap::dummy_sp(),\n+            node: attribute_ {\n+                style: attr_outer,\n+                value: @spanned {\n+                    node: meta_word(s),\n+                    span: codemap::dummy_sp(),\n+                },\n+                is_sugared_doc: false,\n+            }\n+        }\n     }\n \n }"}, {"sha": "e06e43f6287cecb903c778954c4862f18ec04b61", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -26,9 +26,9 @@ use ext::build;\n use ext::build::*;\n use unstable::extfmt::ct::*;\n \n-pub fn expand_syntax_ext(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+pub fn expand_syntax_ext(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n-    let args = get_exprs_from_tts(cx, copy tts);\n+    let args = get_exprs_from_tts(cx, tts);\n     if args.len() == 0 {\n         cx.span_fatal(sp, \"fmt! takes at least 1 argument.\");\n     }\n@@ -277,19 +277,24 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n     for pieces.each |pc| {\n         match *pc {\n           PieceString(ref s) => {\n-            piece_exprs.push(mk_uniq_str(cx, fmt_sp, (*s)))\n+            piece_exprs.push(mk_uniq_str(cx, fmt_sp, copy *s))\n           }\n-          PieceConv(conv) => {\n+          PieceConv(ref conv) => {\n             n += 1u;\n             if n >= nargs {\n                 cx.span_fatal(sp,\n                               ~\"not enough arguments to fmt! \" +\n                                   ~\"for the given format string\");\n             }\n             debug!(\"Building conversion:\");\n-            log_conv(conv);\n+            log_conv(/*bad*/ copy *conv);\n             let arg_expr = args[n];\n-            let c_expr = make_new_conv(cx, fmt_sp, conv, arg_expr);\n+            let c_expr = make_new_conv(\n+                cx,\n+                fmt_sp,\n+                /*bad*/ copy *conv,\n+                arg_expr\n+            );\n             piece_exprs.push(c_expr);\n           }\n         }"}, {"sha": "368520acd2d14a6333c5e8ee855ff8084e4a3bfa", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -8,24 +8,25 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use prelude::*;\n+use core::io::WriterUtil;\n+\n use ast;\n use codemap;\n use ext::base::*;\n use ext::base;\n use print;\n \n-use core::io;\n-use core::io::WriterUtil;\n-use core::option;\n-\n pub fn expand_syntax_ext(cx: ext_ctxt,\n                          sp: codemap::span,\n-                         tt: ~[ast::token_tree])\n+                         tt: &[ast::token_tree])\n                       -> base::MacResult {\n \n     cx.print_backtrace();\n     io::stdout().write_line(\n-        print::pprust::tt_to_str(ast::tt_delim(tt),cx.parse_sess().interner));\n+        print::pprust::tt_to_str(\n+            ast::tt_delim(vec::from_slice(tt)),\n+            cx.parse_sess().interner));\n \n     //trivial expression\n     MRExpr(@ast::expr {"}, {"sha": "3b885b7a7b976faa4ee55b2158e8e2432f7453af", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 79, "deletions": 39, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -35,15 +35,15 @@ mod syntax {\n     pub use parse;\n }\n \n-pub fn path(ids: ~[ident], span: span) -> @ast::path {\n+pub fn path(+ids: ~[ident], span: span) -> @ast::path {\n     @ast::path { span: span,\n                  global: false,\n                  idents: ids,\n                  rp: None,\n                  types: ~[] }\n }\n \n-pub fn path_global(ids: ~[ident], span: span) -> @ast::path {\n+pub fn path_global(+ids: ~[ident], span: span) -> @ast::path {\n     @ast::path { span: span,\n                  global: true,\n                  idents: ids,\n@@ -52,19 +52,23 @@ pub fn path_global(ids: ~[ident], span: span) -> @ast::path {\n }\n \n pub trait append_types {\n-    fn add_ty(ty: @ast::Ty) -> @ast::path;\n-    fn add_tys(+tys: ~[@ast::Ty]) -> @ast::path;\n+    fn add_ty(&self, ty: @ast::Ty) -> @ast::path;\n+    fn add_tys(&self, +tys: ~[@ast::Ty]) -> @ast::path;\n }\n \n impl append_types for @ast::path {\n-    fn add_ty(ty: @ast::Ty) -> @ast::path {\n-        @ast::path { types: vec::append_one(self.types, ty),\n-                     .. *self}\n+    fn add_ty(&self, ty: @ast::Ty) -> @ast::path {\n+        @ast::path {\n+            types: vec::append_one(copy self.types, ty),\n+            .. copy **self\n+        }\n     }\n \n-    fn add_tys(+tys: ~[@ast::Ty]) -> @ast::path {\n-        @ast::path { types: vec::append(self.types, tys),\n-                     .. *self}\n+    fn add_tys(&self, +tys: ~[@ast::Ty]) -> @ast::path {\n+        @ast::path {\n+            types: vec::append(copy self.types, tys),\n+            .. copy **self\n+        }\n     }\n }\n \n@@ -75,34 +79,49 @@ pub trait ext_ctxt_ast_builder {\n     fn expr_block(&self, e: @ast::expr) -> ast::blk;\n     fn fn_decl(&self, +inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl;\n     fn item(&self, name: ident, span: span, +node: ast::item_) -> @ast::item;\n-    fn item_fn_poly(&self, name: ident,\n+    fn item_fn_poly(&self,\n+                    ame: ident,\n                     +inputs: ~[ast::arg],\n                     output: @ast::Ty,\n                     +generics: Generics,\n                     +body: ast::blk) -> @ast::item;\n-    fn item_fn(&self, name: ident,\n+    fn item_fn(&self,\n+               name: ident,\n                +inputs: ~[ast::arg],\n                output: @ast::Ty,\n                +body: ast::blk) -> @ast::item;\n-    fn item_enum_poly(&self, name: ident,\n+    fn item_enum_poly(&self,\n+                      name: ident,\n                       span: span,\n                       +enum_definition: ast::enum_def,\n                       +generics: Generics) -> @ast::item;\n-    fn item_enum(&self, name: ident, span: span,\n+    fn item_enum(&self,\n+                 name: ident,\n+                 span: span,\n                  +enum_definition: ast::enum_def) -> @ast::item;\n-    fn item_struct_poly(&self, name: ident, span: span,\n-                        struct_def: ast::struct_def,\n+    fn item_struct_poly(&self,\n+                        name: ident,\n+                        span: span,\n+                        +struct_def: ast::struct_def,\n                         +generics: Generics) -> @ast::item;\n-    fn item_struct(&self, name: ident, span: span,\n-                   struct_def: ast::struct_def) -> @ast::item;\n-    fn struct_expr(&self, path: @ast::path,\n-                   fields: ~[ast::field]) -> @ast::expr;\n-    fn variant(&self, name: ident, span: span,\n+    fn item_struct(&self,\n+                   name: ident,\n+                   span: span,\n+                   +struct_def: ast::struct_def) -> @ast::item;\n+    fn struct_expr(&self,\n+                   path: @ast::path,\n+                   +fields: ~[ast::field]) -> @ast::expr;\n+    fn variant(&self,\n+               name: ident,\n+               span: span,\n                +tys: ~[@ast::Ty]) -> ast::variant;\n-    fn item_mod(&self, name: ident, span: span,\n+    fn item_mod(&self,\n+                name: ident,\n+                span: span,\n                 +items: ~[@ast::item]) -> @ast::item;\n     fn ty_path_ast_builder(&self, path: @ast::path) -> @ast::Ty;\n-    fn item_ty_poly(&self, name: ident,\n+    fn item_ty_poly(&self,\n+                    name: ident,\n                     span: span,\n                     ty: @ast::Ty,\n                     +generics: Generics) -> @ast::item;\n@@ -114,7 +133,7 @@ pub trait ext_ctxt_ast_builder {\n     fn block(&self, +stmts: ~[@ast::stmt], e: @ast::expr) -> ast::blk;\n     fn stmt_let(&self, ident: ident, e: @ast::expr) -> @ast::stmt;\n     fn stmt_expr(&self, e: @ast::expr) -> @ast::stmt;\n-    fn block_expr(&self, b: ast::blk) -> @ast::expr;\n+    fn block_expr(&self, +b: ast::blk) -> @ast::expr;\n     fn ty_option(&self, ty: @ast::Ty) -> @ast::Ty;\n     fn ty_infer(&self) -> @ast::Ty;\n     fn ty_nil_ast_builder(&self) -> @ast::Ty;\n@@ -130,7 +149,7 @@ impl ext_ctxt_ast_builder for ext_ctxt {\n         ], dummy_sp()).add_ty(ty))\n     }\n \n-    fn block_expr(&self, b: ast::blk) -> @ast::expr {\n+    fn block_expr(&self, +b: ast::blk) -> @ast::expr {\n         @expr {\n             id: self.next_id(),\n             callee_id: self.next_id(),\n@@ -229,7 +248,7 @@ impl ext_ctxt_ast_builder for ext_ctxt {\n         // Rust coding conventions\n         let non_camel_case_attribute = respan(dummy_sp(), ast::attribute_ {\n             style: ast::attr_outer,\n-            value: respan(dummy_sp(),\n+            value: @respan(dummy_sp(),\n                           ast::meta_list(@~\"allow\", ~[\n                               @respan(dummy_sp(),\n                                       ast::meta_word(\n@@ -259,12 +278,19 @@ impl ext_ctxt_ast_builder for ext_ctxt {\n                                body))\n     }\n \n-    fn item_fn(&self, name: ident,\n+    fn item_fn(&self,\n+               name: ident,\n                +inputs: ~[ast::arg],\n                output: @ast::Ty,\n-               +body: ast::blk) -> @ast::item {\n-        self.item_fn_poly(name, inputs, output,\n-                          ast_util::empty_generics(), body)\n+               +body: ast::blk\n+    ) -> @ast::item {\n+        self.item_fn_poly(\n+            name,\n+            inputs,\n+            output,\n+            ast_util::empty_generics(),\n+            body\n+        )\n     }\n \n     fn item_enum_poly(&self, name: ident, span: span,\n@@ -279,20 +305,31 @@ impl ext_ctxt_ast_builder for ext_ctxt {\n                             ast_util::empty_generics())\n     }\n \n-    fn item_struct(&self, name: ident, span: span,\n-                   struct_def: ast::struct_def) -> @ast::item {\n-        self.item_struct_poly(name, span, struct_def,\n-                              ast_util::empty_generics())\n+    fn item_struct(\n+        &self, name: ident,\n+        span: span,\n+        +struct_def: ast::struct_def\n+    ) -> @ast::item {\n+        self.item_struct_poly(\n+            name,\n+            span,\n+            struct_def,\n+            ast_util::empty_generics()\n+        )\n     }\n \n-    fn item_struct_poly(&self, name: ident, span: span,\n-                        struct_def: ast::struct_def,\n-                        +generics: Generics) -> @ast::item {\n+    fn item_struct_poly(\n+        &self,\n+        name: ident,\n+        span: span,\n+        +struct_def: ast::struct_def,\n+        +generics: Generics\n+    ) -> @ast::item {\n         self.item(name, span, ast::item_struct(@struct_def, generics))\n     }\n \n     fn struct_expr(&self, path: @ast::path,\n-                   fields: ~[ast::field]) -> @ast::expr {\n+                   +fields: ~[ast::field]) -> @ast::expr {\n         @ast::expr {\n             id: self.next_id(),\n             callee_id: self.next_id(),\n@@ -381,7 +418,10 @@ impl ext_ctxt_ast_builder for ext_ctxt {\n         let new_params = do generics.ty_params.map |ty_param| {\n             ast::TyParam { bounds: no_bounds, ..copy *ty_param }\n         };\n-        Generics { ty_params: new_params, ..*generics }\n+        Generics {\n+            ty_params: new_params,\n+            .. copy *generics\n+        }\n     }\n \n     fn item_ty_poly(&self, name: ident, span: span, ty: @ast::Ty,"}, {"sha": "c5bed32a24f2a13ca8d50dca9c37757561be9e32", "filename": "src/libsyntax/ext/pipes/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -88,7 +88,7 @@ pub fn analyze(proto: protocol, _cx: ext_ctxt) {\n     }\n \n     if self_live.len() > 0 {\n-        let states = str::connect(self_live.map(|s| s.name), ~\" \");\n+        let states = str::connect(self_live.map(|s| copy s.name), ~\" \");\n \n         debug!(\"protocol %s is unbounded due to loops involving: %s\",\n                proto.name, states);"}, {"sha": "c26bfd178b024a017cdb2be380a38c51398f55ab", "filename": "src/libsyntax/ext/pipes/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -65,11 +65,11 @@ pub mod liveness;\n \n \n pub fn expand_proto(cx: ext_ctxt, _sp: span, id: ast::ident,\n-                tt: ~[ast::token_tree]) -> base::MacResult {\n+                    tt: ~[ast::token_tree]) -> base::MacResult {\n     let sess = cx.parse_sess();\n     let cfg = cx.cfg();\n     let tt_rdr = new_tt_reader(copy cx.parse_sess().span_diagnostic,\n-                               cx.parse_sess().interner, None, tt);\n+                               cx.parse_sess().interner, None, copy tt);\n     let rdr = tt_rdr as reader;\n     let rust_parser = Parser(sess, cfg, rdr.dup());\n "}, {"sha": "a5ca24c67378c4b4f763f93c2517f3304d02dd43", "filename": "src/libsyntax/ext/pipes/parse_proto.rs", "status": "modified", "additions": 43, "deletions": 27, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -20,31 +20,35 @@ use parse::token;\n use core::prelude::*;\n \n pub trait proto_parser {\n-    fn parse_proto(&self, id: ~str) -> protocol;\n+    fn parse_proto(&self, +id: ~str) -> protocol;\n     fn parse_state(&self, proto: protocol);\n     fn parse_message(&self, state: state);\n }\n \n impl proto_parser for parser::Parser {\n-    fn parse_proto(&self, id: ~str) -> protocol {\n+    fn parse_proto(&self, +id: ~str) -> protocol {\n         let proto = protocol(id, *self.span);\n \n-        self.parse_seq_to_before_end(token::EOF, SeqSep {\n-                                        sep: None,\n-                                        trailing_sep_allowed: false\n-                                     }, |self| self.parse_state(proto));\n+        self.parse_seq_to_before_end(\n+            &token::EOF,\n+            SeqSep {\n+                sep: None,\n+                trailing_sep_allowed: false,\n+            },\n+            |self| self.parse_state(proto)\n+        );\n \n         return proto;\n     }\n \n     fn parse_state(&self, proto: protocol) {\n         let id = self.parse_ident();\n-        let name = *self.interner.get(id);\n+        let name = copy *self.interner.get(id);\n \n-        self.expect(token::COLON);\n-        let dir = match *self.token {\n-          token::IDENT(n, _) => self.interner.get(n),\n-          _ => fail!()\n+        self.expect(&token::COLON);\n+        let dir = match copy *self.token {\n+            token::IDENT(n, _) => self.interner.get(n),\n+            _ => fail!()\n         };\n         self.bump();\n         let dir = match dir {\n@@ -63,35 +67,47 @@ impl proto_parser for parser::Parser {\n \n         // parse the messages\n         self.parse_unspanned_seq(\n-            token::LBRACE, token::RBRACE, SeqSep {\n+            &token::LBRACE,\n+            &token::RBRACE,\n+            SeqSep {\n                 sep: Some(token::COMMA),\n-                trailing_sep_allowed: true\n-            }, |self| self.parse_message(state));\n+                trailing_sep_allowed: true,\n+            },\n+            |self| self.parse_message(state)\n+        );\n     }\n \n     fn parse_message(&self, state: state) {\n-        let mname = *self.interner.get(self.parse_ident());\n+        let mname = copy *self.interner.get(self.parse_ident());\n \n         let args = if *self.token == token::LPAREN {\n-            self.parse_unspanned_seq(token::LPAREN,\n-                                     token::RPAREN, SeqSep {\n-                                        sep: Some(token::COMMA),\n-                                        trailing_sep_allowed: true\n-                                     }, |p| p.parse_ty(false))\n+            self.parse_unspanned_seq(\n+                &token::LPAREN,\n+                &token::RPAREN,\n+                SeqSep {\n+                    sep: Some(token::COMMA),\n+                    trailing_sep_allowed: true,\n+                },\n+                |p| p.parse_ty(false)\n+            )\n         }\n         else { ~[] };\n \n-        self.expect(token::RARROW);\n+        self.expect(&token::RARROW);\n \n         let next = match *self.token {\n           token::IDENT(_, _) => {\n-            let name = *self.interner.get(self.parse_ident());\n+            let name = copy *self.interner.get(self.parse_ident());\n             let ntys = if *self.token == token::LT {\n-                self.parse_unspanned_seq(token::LT,\n-                                         token::GT, SeqSep {\n-                                            sep: Some(token::COMMA),\n-                                            trailing_sep_allowed: true\n-                                         }, |p| p.parse_ty(false))\n+                self.parse_unspanned_seq(\n+                    &token::LT,\n+                    &token::GT,\n+                    SeqSep {\n+                        sep: Some(token::COMMA),\n+                        trailing_sep_allowed: true,\n+                    },\n+                    |p| p.parse_ty(false)\n+                )\n             }\n             else { ~[] };\n             Some(next_state {state: name, tys: ntys})"}, {"sha": "968a0e5f77eb4d51da8a8b28005911b11f003d3b", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -60,8 +60,7 @@ impl gen_send for message {\n             let next = this.proto.get_state(next_state.state);\n             assert next_state.tys.len() == next.generics.ty_params.len();\n             let arg_names = tys.mapi(|i, _ty| cx.ident_of(~\"x_\"+i.to_str()));\n-\n-            let args_ast = (arg_names, *tys).map(|n, t| cx.arg(*n, *t));\n+            let args_ast = vec::map2(arg_names, *tys, |n, t| cx.arg(*n, *t));\n \n             let pipe_ty = cx.ty_path_ast_builder(\n                 path(~[this.data_name()], span)\n@@ -121,7 +120,7 @@ impl gen_send for message {\n \n             let mut rty = cx.ty_path_ast_builder(path(~[next.data_name()],\n                                                       span)\n-                                                 .add_tys(next_state.tys));\n+                                               .add_tys(copy next_state.tys));\n             if try {\n                 rty = cx.ty_option(rty);\n             }\n@@ -139,7 +138,7 @@ impl gen_send for message {\n                 debug!(\"pipec: no next state\");\n                 let arg_names = tys.mapi(|i, _ty| (~\"x_\" + i.to_str()));\n \n-                let args_ast = do (arg_names, *tys).map |n, t| {\n+                let args_ast = do vec::map2(arg_names, *tys) |n, t| {\n                     cx.arg(cx.ident_of(*n), *t)\n                 };\n \n@@ -155,7 +154,7 @@ impl gen_send for message {\n                     ~\"\"\n                 }\n                 else {\n-                    ~\"(\" + str::connect(arg_names.map(|x| *x),\n+                    ~\"(\" + str::connect(arg_names.map(|x| copy *x),\n                                         ~\", \") + ~\")\"\n                 };\n \n@@ -212,7 +211,7 @@ impl to_type_decls for state {\n         let mut items_msg = ~[];\n \n         for self.messages.each |m| {\n-            let message(name, span, tys, this, next) = *m;\n+            let message(name, span, tys, this, next) = copy *m;\n \n             let tys = match next {\n               Some(ref next_state) => {\n@@ -228,7 +227,7 @@ impl to_type_decls for state {\n                                 cx.ty_path_ast_builder(\n                                     path(~[cx.ident_of(dir),\n                                            cx.ident_of(next_name)], span)\n-                                    .add_tys(next_state.tys)))\n+                                    .add_tys(copy next_state.tys)))\n               }\n               None => tys\n             };"}, {"sha": "db5c6541e264ddca603f0fc1dbd658f35a99ad74", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -50,7 +50,7 @@ pub struct message(~str, span, ~[@ast::Ty], state, Option<next_state>);\n pub impl message {\n     fn name(&mut self) -> ~str {\n         match *self {\n-          message(ref id, _, _, _, _) => (*id)\n+          message(ref id, _, _, _, _) => copy *id\n         }\n     }\n \n@@ -63,7 +63,7 @@ pub impl message {\n     /// Return the type parameters actually used by this message\n     fn get_generics(&self) -> ast::Generics {\n         match *self {\n-          message(_, _, _, this, _) => this.generics\n+          message(_, _, _, this, _) => copy this.generics\n         }\n     }\n }\n@@ -82,8 +82,8 @@ pub struct state_ {\n }\n \n pub impl state_ {\n-    fn add_message(@self, name: ~str, span: span,\n-                   +data: ~[@ast::Ty], next: Option<next_state>) {\n+    fn add_message(@self, +name: ~str, span: span,\n+                   +data: ~[@ast::Ty], +next: Option<next_state>) {\n         self.messages.push(message(name, span, data, self,\n                                    next));\n     }\n@@ -120,11 +120,11 @@ pub impl state_ {\n \n pub type protocol = @mut protocol_;\n \n-pub fn protocol(name: ~str, +span: span) -> protocol {\n+pub fn protocol(+name: ~str, +span: span) -> protocol {\n     @mut protocol_(name, span)\n }\n \n-pub fn protocol_(name: ~str, span: span) -> protocol_ {\n+pub fn protocol_(+name: ~str, span: span) -> protocol_ {\n     protocol_ {\n         name: name,\n         span: span,\n@@ -174,7 +174,7 @@ pub impl protocol_ {\n }\n \n pub impl protocol {\n-    fn add_state_poly(&self, name: ~str, ident: ast::ident, dir: direction,\n+    fn add_state_poly(&self, +name: ~str, ident: ast::ident, dir: direction,\n                       +generics: ast::Generics) -> state {\n         let messages = @mut ~[];\n "}, {"sha": "4349ffaea4301976f72d0e6dd538c7fd5e3d4c1c", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -221,53 +221,53 @@ pub mod rt {\n \n pub fn expand_quote_tokens(cx: ext_ctxt,\n                            sp: span,\n-                           tts: ~[ast::token_tree]) -> base::MacResult {\n+                           tts: &[ast::token_tree]) -> base::MacResult {\n     base::MRExpr(expand_tts(cx, sp, tts))\n }\n \n pub fn expand_quote_expr(cx: ext_ctxt,\n                          sp: span,\n-                         tts: ~[ast::token_tree]) -> base::MacResult {\n+                         tts: &[ast::token_tree]) -> base::MacResult {\n     base::MRExpr(expand_parse_call(cx, sp, ~\"parse_expr\", ~[], tts))\n }\n \n pub fn expand_quote_item(cx: ext_ctxt,\n                          sp: span,\n-                         tts: ~[ast::token_tree]) -> base::MacResult {\n+                         tts: &[ast::token_tree]) -> base::MacResult {\n     let e_attrs = build::mk_uniq_vec_e(cx, sp, ~[]);\n     base::MRExpr(expand_parse_call(cx, sp, ~\"parse_item\",\n                                     ~[e_attrs], tts))\n }\n \n pub fn expand_quote_pat(cx: ext_ctxt,\n                         sp: span,\n-                        tts: ~[ast::token_tree]) -> base::MacResult {\n+                        tts: &[ast::token_tree]) -> base::MacResult {\n     let e_refutable = build::mk_lit(cx, sp, ast::lit_bool(true));\n     base::MRExpr(expand_parse_call(cx, sp, ~\"parse_pat\",\n                                     ~[e_refutable], tts))\n }\n \n pub fn expand_quote_ty(cx: ext_ctxt,\n                        sp: span,\n-                       tts: ~[ast::token_tree]) -> base::MacResult {\n+                       tts: &[ast::token_tree]) -> base::MacResult {\n     let e_param_colons = build::mk_lit(cx, sp, ast::lit_bool(false));\n     base::MRExpr(expand_parse_call(cx, sp, ~\"parse_ty\",\n                                     ~[e_param_colons], tts))\n }\n \n pub fn expand_quote_stmt(cx: ext_ctxt,\n                          sp: span,\n-                         tts: ~[ast::token_tree]) -> base::MacResult {\n+                         tts: &[ast::token_tree]) -> base::MacResult {\n     let e_attrs = build::mk_uniq_vec_e(cx, sp, ~[]);\n     base::MRExpr(expand_parse_call(cx, sp, ~\"parse_stmt\",\n                                     ~[e_attrs], tts))\n }\n \n fn ids_ext(cx: ext_ctxt, strs: ~[~str]) -> ~[ast::ident] {\n-    strs.map(|str| cx.parse_sess().interner.intern(@*str))\n+    strs.map(|str| cx.parse_sess().interner.intern(@copy *str))\n }\n \n-fn id_ext(cx: ext_ctxt, str: ~str) -> ast::ident {\n+fn id_ext(cx: ext_ctxt, +str: ~str) -> ast::ident {\n     cx.parse_sess().interner.intern(@str)\n }\n \n@@ -508,15 +508,19 @@ fn mk_tts(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n \n fn expand_tts(cx: ext_ctxt,\n               sp: span,\n-              tts: ~[ast::token_tree]) -> @ast::expr {\n+              tts: &[ast::token_tree]) -> @ast::expr {\n \n     // NB: It appears that the main parser loses its mind if we consider\n     // $foo as a tt_nonterminal during the main parse, so we have to re-parse\n     // under quote_depth > 0. This is silly and should go away; the _guess_ is\n     // it has to do with transition away from supporting old-style macros, so\n     // try removing it when enough of them are gone.\n \n-    let p = parse::new_parser_from_tts(cx.parse_sess(), cx.cfg(), tts);\n+    let p = parse::new_parser_from_tts(\n+        cx.parse_sess(),\n+        cx.cfg(),\n+        vec::from_slice(tts)\n+    );\n     *p.quote_depth += 1u;\n     let tts = p.parse_all_token_trees();\n     p.abort_if_errors();\n@@ -578,9 +582,9 @@ fn expand_tts(cx: ext_ctxt,\n \n fn expand_parse_call(cx: ext_ctxt,\n                      sp: span,\n-                     parse_method: ~str,\n-                     arg_exprs: ~[@ast::expr],\n-                     tts: ~[ast::token_tree]) -> @ast::expr {\n+                     +parse_method: ~str,\n+                     +arg_exprs: ~[@ast::expr],\n+                     tts: &[ast::token_tree]) -> @ast::expr {\n     let tts_expr = expand_tts(cx, sp, tts);\n \n     let cfg_call = || build::mk_call_("}, {"sha": "296305bb62e17c042d7bee19275f180fb3b1c9d6", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -29,7 +29,7 @@ use core::vec;\n // a given file into the current one.\n \n /* line!(): expands to the current line number */\n-pub fn expand_line(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+pub fn expand_line(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"line!\");\n \n@@ -40,7 +40,7 @@ pub fn expand_line(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n }\n \n /* col!(): expands to the current column number */\n-pub fn expand_col(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+pub fn expand_col(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"col!\");\n \n@@ -52,7 +52,7 @@ pub fn expand_col(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n /* file!(): expands to the current filename */\n /* The filemap (`loc.file`) contains a bunch more information we could spit\n  * out if we wanted. */\n-pub fn expand_file(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+pub fn expand_file(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"file!\");\n \n@@ -62,13 +62,13 @@ pub fn expand_file(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n     base::MRExpr(mk_base_str(cx, topmost.call_site, filename))\n }\n \n-pub fn expand_stringify(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+pub fn expand_stringify(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let s = pprust::tts_to_str(tts, cx.parse_sess().interner);\n     base::MRExpr(mk_base_str(cx, sp, s))\n }\n \n-pub fn expand_mod(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+pub fn expand_mod(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n     base::MRExpr(mk_base_str(cx, sp,\n@@ -79,7 +79,7 @@ pub fn expand_mod(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n // include! : parse the given file as an expr\n // This is generally a bad idea because it's going to behave\n // unhygienically.\n-pub fn expand_include(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+pub fn expand_include(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include!\");\n     let p = parse::new_sub_parser_from_file(\n@@ -89,7 +89,7 @@ pub fn expand_include(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n }\n \n // include_str! : read the given file, insert it as a literal string expr\n-pub fn expand_include_str(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+pub fn expand_include_str(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include_str!\");\n     let res = io::read_whole_file_str(&res_rel_file(cx, sp, &Path(file)));\n@@ -103,7 +103,7 @@ pub fn expand_include_str(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n     base::MRExpr(mk_base_str(cx, sp, result::unwrap(res)))\n }\n \n-pub fn expand_include_bin(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+pub fn expand_include_bin(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include_bin!\");\n     match io::read_whole_file(&res_rel_file(cx, sp, &Path(file))) {\n@@ -121,19 +121,27 @@ pub fn expand_include_bin(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n \n // recur along an ExpnInfo chain to find the original expression\n fn topmost_expn_info(expn_info: @codemap::ExpnInfo) -> @codemap::ExpnInfo {\n-    let ExpandedFrom(CallInfo { call_site, _ }) = *expn_info;\n-    match call_site.expn_info {\n-        Some(next_expn_info) => {\n-            let ExpandedFrom(CallInfo {\n-                callee: NameAndSpan {name, _},\n-                _\n-            }) = *next_expn_info;\n-            // Don't recurse into file using \"include!\"\n-            if name == ~\"include\" { return expn_info; }\n-\n-            topmost_expn_info(next_expn_info)\n-        },\n-        None => expn_info\n+    match *expn_info {\n+        ExpandedFrom(CallInfo { call_site: ref call_site, _ }) => {\n+            match call_site.expn_info {\n+                Some(next_expn_info) => {\n+                    match *next_expn_info {\n+                        ExpandedFrom(CallInfo {\n+                            callee: NameAndSpan { name: ref name, _ },\n+                            _\n+                        }) => {\n+                            // Don't recurse into file using \"include!\"\n+                            if *name == ~\"include\" {\n+                                expn_info\n+                            } else {\n+                                topmost_expn_info(next_expn_info)\n+                            }\n+                        }\n+                    }\n+                },\n+                None => expn_info\n+            }\n+        }\n     }\n }\n "}, {"sha": "bb6d656d5cc12f9e940498a0dc2547529992199a", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use prelude::*;\n+\n use ast::tt_delim;\n use ast;\n use codemap::span;\n@@ -16,20 +18,26 @@ use ext::base;\n use parse::lexer::{new_tt_reader, reader};\n use parse::parser::Parser;\n \n-use core::option::None;\n-\n pub fn expand_trace_macros(cx: ext_ctxt, sp: span,\n-                           tt: ~[ast::token_tree]) -> base::MacResult {\n+                           tt: &[ast::token_tree]) -> base::MacResult {\n     let sess = cx.parse_sess();\n     let cfg = cx.cfg();\n-    let tt_rdr = new_tt_reader(copy cx.parse_sess().span_diagnostic,\n-                               cx.parse_sess().interner, None, tt);\n+    let tt_rdr = new_tt_reader(\n+        copy cx.parse_sess().span_diagnostic,\n+        cx.parse_sess().interner,\n+        None,\n+        vec::from_slice(tt)\n+    );\n     let rdr = tt_rdr as reader;\n-    let rust_parser = Parser(sess, cfg, rdr.dup());\n+    let rust_parser = Parser(\n+        sess,\n+        copy cfg,\n+        rdr.dup()\n+    );\n \n-    if rust_parser.is_keyword(~\"true\") {\n+    if rust_parser.is_keyword(&~\"true\") {\n         cx.set_trace_macros(true);\n-    } else if rust_parser.is_keyword(~\"false\") {\n+    } else if rust_parser.is_keyword(&~\"false\") {\n         cx.set_trace_macros(false);\n     } else {\n         cx.span_fatal(sp, ~\"trace_macros! only accepts `true` or `false`\")"}, {"sha": "fae9e1651d3426bc34881e37f9e5ee8591603903", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -140,10 +140,10 @@ pub fn count_names(ms: &[matcher]) -> uint {\n }\n \n #[allow(non_implicitly_copyable_typarams)]\n-pub fn initial_matcher_pos(ms: ~[matcher], sep: Option<Token>, lo: BytePos)\n+pub fn initial_matcher_pos(+ms: ~[matcher], sep: Option<Token>, lo: BytePos)\n                         -> ~MatcherPos {\n     let mut match_idx_hi = 0u;\n-    for ms.each() |elt| {\n+    for ms.each |elt| {\n         match elt.node {\n           match_tok(_) => (),\n           match_seq(_,_,_,_,hi) => {\n@@ -154,12 +154,13 @@ pub fn initial_matcher_pos(ms: ~[matcher], sep: Option<Token>, lo: BytePos)\n           }\n         }\n     }\n+    let matches = vec::from_fn(count_names(ms), |_i| dvec::DVec());\n     ~MatcherPos {\n         elts: ms,\n         sep: sep,\n         idx: 0u,\n         up: matcher_pos_up(None),\n-        matches: copy vec::from_fn(count_names(ms), |_i| dvec::DVec()),\n+        matches: matches,\n         match_lo: 0u,\n         match_hi: match_idx_hi,\n         sp_lo: lo\n@@ -225,22 +226,27 @@ pub enum parse_result {\n     error(codemap::span, ~str)\n }\n \n-pub fn parse_or_else(sess: @mut ParseSess, cfg: ast::crate_cfg, rdr: reader,\n-                     ms: ~[matcher]) -> HashMap<ident, @named_match> {\n+pub fn parse_or_else(\n+    sess: @mut ParseSess,\n+    +cfg: ast::crate_cfg,\n+    rdr: reader,\n+    ms: ~[matcher]\n+) -> HashMap<ident, @named_match> {\n     match parse(sess, cfg, rdr, ms) {\n       success(m) => m,\n       failure(sp, ref str) => sess.span_diagnostic.span_fatal(sp, (*str)),\n       error(sp, ref str) => sess.span_diagnostic.span_fatal(sp, (*str))\n     }\n }\n \n-pub fn parse(sess: @mut ParseSess,\n-             cfg: ast::crate_cfg,\n-             rdr: reader,\n-             ms: ~[matcher])\n-          -> parse_result {\n+pub fn parse(\n+    sess: @mut ParseSess,\n+    cfg: ast::crate_cfg,\n+    rdr: reader,\n+    ms: ~[matcher]\n+) -> parse_result {\n     let mut cur_eis = ~[];\n-    cur_eis.push(initial_matcher_pos(ms, None, rdr.peek().sp.lo));\n+    cur_eis.push(initial_matcher_pos(copy ms, None, rdr.peek().sp.lo));\n \n     loop {\n         let mut bb_eis = ~[]; // black-box parsed by parser.rs\n@@ -331,8 +337,8 @@ pub fn parse(sess: @mut ParseSess,\n                                            |_m| DVec::<@named_match>());\n                     let ei_t = ei;\n                     cur_eis.push(~MatcherPos {\n-                        elts: (*matchers),\n-                        sep: (*sep),\n+                        elts: copy *matchers,\n+                        sep: copy *sep,\n                         idx: 0u,\n                         up: matcher_pos_up(Some(ei_t)),\n                         matches: matches,\n@@ -380,15 +386,15 @@ pub fn parse(sess: @mut ParseSess,\n                     nts, next_eis.len()));\n             } else if (bb_eis.len() == 0u && next_eis.len() == 0u) {\n                 return failure(sp, ~\"No rules expected the token: \"\n-                            + to_str(rdr.interner(), tok));\n+                            + to_str(rdr.interner(), &tok));\n             } else if (next_eis.len() > 0u) {\n                 /* Now process the next token */\n                 while(next_eis.len() > 0u) {\n                     cur_eis.push(next_eis.pop());\n                 }\n                 rdr.next_token();\n             } else /* bb_eis.len() == 1 */ {\n-                let rust_parser = Parser(sess, cfg, rdr.dup());\n+                let rust_parser = Parser(sess, copy cfg, rdr.dup());\n \n                 let mut ei = bb_eis.pop();\n                 match ei.elts[ei.idx].node {\n@@ -426,7 +432,7 @@ pub fn parse_nt(p: Parser, name: ~str) -> nonterminal {\n       ~\"ident\" => match *p.token {\n         token::IDENT(sn,b) => { p.bump(); token::nt_ident(sn,b) }\n         _ => p.fatal(~\"expected ident, found \"\n-                     + token::to_str(p.reader.interner(), *p.token))\n+                     + token::to_str(p.reader.interner(), &copy *p.token))\n       },\n       ~\"path\" => token::nt_path(p.parse_path_with_tps(false)),\n       ~\"tt\" => {"}, {"sha": "5c20abc385d3e6ddc3dd1d7f18e2f83c88708abd", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -54,7 +54,7 @@ pub fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n \n     // Parse the macro_rules! invocation (`none` is for no interpolations):\n     let arg_reader = new_tt_reader(copy cx.parse_sess().span_diagnostic,\n-                                   cx.parse_sess().interner, None, arg);\n+                                   cx.parse_sess().interner, None, copy arg);\n     let argument_map = parse_or_else(cx.parse_sess(), cx.cfg(),\n                                      arg_reader as reader, argument_gram);\n \n@@ -71,15 +71,15 @@ pub fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n \n     // Given `lhses` and `rhses`, this is the new macro we create\n     fn generic_extension(cx: ext_ctxt, sp: span, name: ident,\n-                         arg: ~[ast::token_tree],\n+                         arg: &[ast::token_tree],\n                          lhses: ~[@named_match], rhses: ~[@named_match])\n     -> MacResult {\n \n         if cx.trace_macros() {\n             io::println(fmt!(\"%s! { %s }\",\n                              cx.str_of(name),\n                              print::pprust::tt_to_str(\n-                                 ast::tt_delim(arg),\n+                                 ast::tt_delim(vec::from_slice(arg)),\n                                  cx.parse_sess().interner)));\n         }\n \n@@ -94,7 +94,12 @@ pub fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n             match *lhs {\n               @matched_nonterminal(nt_matchers(ref mtcs)) => {\n                 // `none` is because we're not interpolating\n-                let arg_rdr = new_tt_reader(s_d, itr, None, arg) as reader;\n+                let arg_rdr = new_tt_reader(\n+                    s_d,\n+                    itr,\n+                    None,\n+                    vec::from_slice(arg)\n+                ) as reader;\n                 match parse(cx.parse_sess(), cx.cfg(), arg_rdr, (*mtcs)) {\n                   success(named_matches) => {\n                     let rhs = match rhses[i] {\n@@ -125,7 +130,7 @@ pub fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n                   }\n                   failure(sp, ref msg) => if sp.lo >= best_fail_spot.lo {\n                     best_fail_spot = sp;\n-                    best_fail_msg = (*msg);\n+                    best_fail_msg = copy *msg;\n                   },\n                   error(sp, ref msg) => cx.span_fatal(sp, (*msg))\n                 }\n@@ -136,11 +141,11 @@ pub fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n         cx.span_fatal(best_fail_spot, best_fail_msg);\n     }\n \n-    let exp: @fn(ext_ctxt, span, ~[ast::token_tree]) -> MacResult =\n+    let exp: @fn(ext_ctxt, span, &[ast::token_tree]) -> MacResult =\n         |cx, sp, arg| generic_extension(cx, sp, name, arg, lhses, rhses);\n \n     return MRDef(MacroDef{\n-        name: *cx.parse_sess().interner.get(name),\n+        name: copy *cx.parse_sess().interner.get(name),\n         ext: NormalTT(base::SyntaxExpanderTT{expander: exp, span: Some(sp)})\n     });\n }"}, {"sha": "99afd7958e99844c2c3e90d523b173d18147eb64", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -54,7 +54,7 @@ pub struct TtReader {\n pub fn new_tt_reader(sp_diag: span_handler,\n                      itr: @ident_interner,\n                      interp: Option<std::oldmap::HashMap<ident,@named_match>>,\n-                     src: ~[ast::token_tree])\n+                     +src: ~[ast::token_tree])\n                   -> @mut TtReader {\n     let r = @mut TtReader {\n         sp_diag: sp_diag,\n@@ -101,7 +101,7 @@ pub pure fn dup_tt_reader(r: @mut TtReader) -> @mut TtReader {\n         interpolations: r.interpolations,\n         repeat_idx: copy r.repeat_idx,\n         repeat_len: copy r.repeat_len,\n-        cur_tok: r.cur_tok,\n+        cur_tok: copy r.cur_tok,\n         cur_span: r.cur_span\n     }\n }\n@@ -115,7 +115,7 @@ pure fn lookup_cur_matched_by_matched(r: @mut TtReader,\n             // end of the line; duplicate henceforth\n             ad\n           }\n-          matched_seq(ads, _) => ads[*idx]\n+          matched_seq(ref ads, _) => ads[*idx]\n         }\n     }\n     vec::foldl(start, r.repeat_idx, red)\n@@ -131,15 +131,15 @@ enum lis {\n fn lockstep_iter_size(t: token_tree, r: @mut TtReader) -> lis {\n     fn lis_merge(lhs: lis, rhs: lis, r: @mut TtReader) -> lis {\n         match lhs {\n-          lis_unconstrained => rhs,\n-          lis_contradiction(_) => lhs,\n+          lis_unconstrained => copy rhs,\n+          lis_contradiction(_) => copy lhs,\n           lis_constraint(l_len, l_id) => match rhs {\n-            lis_unconstrained => lhs,\n-            lis_contradiction(_) => rhs,\n-            lis_constraint(r_len, _) if l_len == r_len => lhs,\n+            lis_unconstrained => copy lhs,\n+            lis_contradiction(_) => copy rhs,\n+            lis_constraint(r_len, _) if l_len == r_len => copy lhs,\n             lis_constraint(r_len, r_id) => {\n-                let l_n = *r.interner.get(l_id);\n-                let r_n = *r.interner.get(r_id);\n+                let l_n = copy *r.interner.get(l_id);\n+                let r_n = copy *r.interner.get(r_id);\n                 lis_contradiction(fmt!(\"Inconsistent lockstep iteration: \\\n                                        '%s' has %u items, but '%s' has %u\",\n                                         l_n, l_len, r_n, r_len))\n@@ -155,14 +155,17 @@ fn lockstep_iter_size(t: token_tree, r: @mut TtReader) -> lis {\n       tt_tok(*) => lis_unconstrained,\n       tt_nonterminal(_, name) => match *lookup_cur_matched(r, name) {\n         matched_nonterminal(_) => lis_unconstrained,\n-        matched_seq(ads, _) => lis_constraint(ads.len(), name)\n+        matched_seq(ref ads, _) => lis_constraint(ads.len(), name)\n       }\n     }\n }\n \n \n pub fn tt_next_token(r: @mut TtReader) -> TokenAndSpan {\n-    let ret_val = TokenAndSpan { tok: r.cur_tok, sp: r.cur_span };\n+    let ret_val = TokenAndSpan {\n+        tok: copy r.cur_tok,\n+        sp: r.cur_span,\n+    };\n     while r.cur.idx >= r.cur.readme.len() {\n         /* done with this set; pop or repeat? */\n         if ! r.cur.dotdotdoted\n@@ -199,9 +202,9 @@ pub fn tt_next_token(r: @mut TtReader) -> TokenAndSpan {\n     loop { /* because it's easiest, this handles `tt_delim` not starting\n     with a `tt_tok`, even though it won't happen */\n         match r.cur.readme[r.cur.idx] {\n-          tt_delim(tts) => {\n+          tt_delim(copy tts) => {\n             r.cur = @mut TtFrame {\n-                readme: @mut copy tts,\n+                readme: @mut tts,\n                 idx: 0u,\n                 dotdotdoted: false,\n                 sep: None,\n@@ -210,12 +213,13 @@ pub fn tt_next_token(r: @mut TtReader) -> TokenAndSpan {\n             // if this could be 0-length, we'd need to potentially recur here\n           }\n           tt_tok(sp, copy tok) => {\n-            r.cur_span = sp; r.cur_tok = tok;\n+            r.cur_span = sp;\n+            r.cur_tok = tok;\n             r.cur.idx += 1u;\n             return ret_val;\n           }\n           tt_seq(sp, copy tts, copy sep, zerok) => {\n-            match lockstep_iter_size(tt_seq(sp, tts, sep, zerok), r) {\n+            match lockstep_iter_size(tt_seq(sp, copy tts, sep, zerok), r) {\n               lis_unconstrained => {\n                 r.sp_diag.span_fatal(\n                     sp, /* blame macro writer */\n@@ -264,7 +268,8 @@ pub fn tt_next_token(r: @mut TtReader) -> TokenAndSpan {\n                 return ret_val;\n               }\n               matched_nonterminal(ref other_whole_nt) => {\n-                r.cur_span = sp; r.cur_tok = INTERPOLATED((*other_whole_nt));\n+                r.cur_span = sp;\n+                r.cur_tok = INTERPOLATED(copy *other_whole_nt);\n                 r.cur.idx += 1u;\n                 return ret_val;\n               }"}, {"sha": "f820669ab1c6d5a1be5b1f7502e06466bcdc3471", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 468, "deletions": 391, "changes": 859, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -19,27 +19,27 @@ use core::option;\n use core::vec;\n \n pub trait ast_fold {\n-    fn fold_crate(@self, crate) -> crate;\n-    fn fold_view_item(@self, &&v: @view_item) -> @view_item;\n-    fn fold_foreign_item(@self, &&v: @foreign_item) -> @foreign_item;\n-    fn fold_item(@self, &&v: @item) -> Option<@item>;\n-    fn fold_struct_field(@self, &&v: @struct_field) -> @struct_field;\n-    fn fold_item_underscore(@self, item_) -> item_;\n-    fn fold_method(@self, &&v: @method) -> @method;\n-    fn fold_block(@self, blk) -> blk;\n-    fn fold_stmt(@self, &&v: @stmt) -> @stmt;\n-    fn fold_arm(@self, arm) -> arm;\n-    fn fold_pat(@self, &&v: @pat) -> @pat;\n-    fn fold_decl(@self, &&v: @decl) -> @decl;\n-    fn fold_expr(@self, &&v: @expr) -> @expr;\n-    fn fold_ty(@self, &&v: @Ty) -> @Ty;\n-    fn fold_mod(@self, _mod) -> _mod;\n-    fn fold_foreign_mod(@self, foreign_mod) -> foreign_mod;\n-    fn fold_variant(@self, variant) -> variant;\n-    fn fold_ident(@self, &&v: ident) -> ident;\n-    fn fold_path(@self, &&v: @path) -> @path;\n-    fn fold_local(@self, &&v: @local) -> @local;\n-    fn map_exprs(@self, fn@(&&v: @expr) -> @expr, ~[@expr]) -> ~[@expr];\n+    fn fold_crate(@self, &crate) -> crate;\n+    fn fold_view_item(@self, @view_item) -> @view_item;\n+    fn fold_foreign_item(@self, @foreign_item) -> @foreign_item;\n+    fn fold_item(@self, @item) -> Option<@item>;\n+    fn fold_struct_field(@self, @struct_field) -> @struct_field;\n+    fn fold_item_underscore(@self, &item_) -> item_;\n+    fn fold_method(@self, @method) -> @method;\n+    fn fold_block(@self, &blk) -> blk;\n+    fn fold_stmt(@self, &stmt) -> @stmt;\n+    fn fold_arm(@self, &arm) -> arm;\n+    fn fold_pat(@self, @pat) -> @pat;\n+    fn fold_decl(@self, @decl) -> @decl;\n+    fn fold_expr(@self, @expr) -> @expr;\n+    fn fold_ty(@self, @Ty) -> @Ty;\n+    fn fold_mod(@self, &_mod) -> _mod;\n+    fn fold_foreign_mod(@self, &foreign_mod) -> foreign_mod;\n+    fn fold_variant(@self, &variant) -> variant;\n+    fn fold_ident(@self, ident) -> ident;\n+    fn fold_path(@self, @path) -> @path;\n+    fn fold_local(@self, @local) -> @local;\n+    fn map_exprs(@self, fn@(@expr) -> @expr, &[@expr]) -> ~[@expr];\n     fn new_id(@self, node_id) -> node_id;\n     fn new_span(@self, span) -> span;\n }\n@@ -48,27 +48,27 @@ pub trait ast_fold {\n \n pub struct AstFoldFns {\n     //unlike the others, item_ is non-trivial\n-    fold_crate: fn@(crate_, span, ast_fold) -> (crate_, span),\n+    fold_crate: fn@(&crate_, span, ast_fold) -> (crate_, span),\n     fold_view_item: fn@(view_item_, ast_fold) -> view_item_,\n-    fold_foreign_item: fn@(&&v: @foreign_item, ast_fold) -> @foreign_item,\n-    fold_item: fn@(&&v: @item, ast_fold) -> Option<@item>,\n-    fold_struct_field: fn@(&&v: @struct_field, ast_fold) -> @struct_field,\n-    fold_item_underscore: fn@(item_, ast_fold) -> item_,\n-    fold_method: fn@(&&v: @method, ast_fold) -> @method,\n-    fold_block: fn@(blk_, span, ast_fold) -> (blk_, span),\n-    fold_stmt: fn@(stmt_, span, ast_fold) -> (stmt_, span),\n-    fold_arm: fn@(arm, ast_fold) -> arm,\n-    fold_pat: fn@(pat_, span, ast_fold) -> (pat_, span),\n-    fold_decl: fn@(decl_, span, ast_fold) -> (decl_, span),\n-    fold_expr: fn@(expr_, span, ast_fold) -> (expr_, span),\n-    fold_ty: fn@(ty_, span, ast_fold) -> (ty_, span),\n-    fold_mod: fn@(_mod, ast_fold) -> _mod,\n-    fold_foreign_mod: fn@(foreign_mod, ast_fold) -> foreign_mod,\n-    fold_variant: fn@(variant_, span, ast_fold) -> (variant_, span),\n-    fold_ident: fn@(&&v: ident, ast_fold) -> ident,\n-    fold_path: fn@(path, ast_fold) -> path,\n-    fold_local: fn@(local_, span, ast_fold) -> (local_, span),\n-    map_exprs: fn@(fn@(&&v: @expr) -> @expr, ~[@expr]) -> ~[@expr],\n+    fold_foreign_item: fn@(@foreign_item, ast_fold) -> @foreign_item,\n+    fold_item: fn@(@item, ast_fold) -> Option<@item>,\n+    fold_struct_field: fn@(@struct_field, ast_fold) -> @struct_field,\n+    fold_item_underscore: fn@(&item_, ast_fold) -> item_,\n+    fold_method: fn@(@method, ast_fold) -> @method,\n+    fold_block: fn@(&blk_, span, ast_fold) -> (blk_, span),\n+    fold_stmt: fn@(&stmt_, span, ast_fold) -> (stmt_, span),\n+    fold_arm: fn@(&arm, ast_fold) -> arm,\n+    fold_pat: fn@(&pat_, span, ast_fold) -> (pat_, span),\n+    fold_decl: fn@(&decl_, span, ast_fold) -> (decl_, span),\n+    fold_expr: fn@(&expr_, span, ast_fold) -> (expr_, span),\n+    fold_ty: fn@(&ty_, span, ast_fold) -> (ty_, span),\n+    fold_mod: fn@(&_mod, ast_fold) -> _mod,\n+    fold_foreign_mod: fn@(&foreign_mod, ast_fold) -> foreign_mod,\n+    fold_variant: fn@(&variant_, span, ast_fold) -> (variant_, span),\n+    fold_ident: fn@(ident, ast_fold) -> ident,\n+    fold_path: fn@(@path, ast_fold) -> path,\n+    fold_local: fn@(&local_, span, ast_fold) -> (local_, span),\n+    map_exprs: fn@(fn@(@expr) -> @expr, &[@expr]) -> ~[@expr],\n     new_id: fn@(node_id) -> node_id,\n     new_span: fn@(span) -> span\n }\n@@ -78,18 +78,20 @@ pub type ast_fold_fns = @AstFoldFns;\n /* some little folds that probably aren't useful to have in ast_fold itself*/\n \n //used in noop_fold_item and noop_fold_crate and noop_fold_crate_directive\n-fn fold_meta_item_(&&mi: @meta_item, fld: @ast_fold) -> @meta_item {\n+fn fold_meta_item_(mi: @meta_item, fld: @ast_fold) -> @meta_item {\n     @spanned {\n         node:\n             match mi.node {\n-                meta_word(ref id) => meta_word((*id)),\n-                meta_list(ref id, ref mis) => {\n+                meta_word(id) => meta_word(id),\n+                meta_list(id, ref mis) => {\n                     let fold_meta_item = |x| fold_meta_item_(x, fld);\n-                    meta_list(/* FIXME: (#2543) */ copy *id,\n-                              mis.map(|e| fold_meta_item(*e)))\n+                    meta_list(\n+                        id,\n+                        mis.map(|e| fold_meta_item(*e))\n+                    )\n                 }\n-                meta_name_value(ref id, s) => {\n-                    meta_name_value((*id), /* FIXME (#2543) */ copy s)\n+                meta_name_value(id, s) => {\n+                    meta_name_value(id, /* FIXME (#2543) */ copy s)\n                 }\n             },\n         span: fld.new_span(mi.span) }\n@@ -99,7 +101,7 @@ fn fold_attribute_(at: attribute, fld: @ast_fold) -> attribute {\n     spanned {\n         node: ast::attribute_ {\n             style: at.node.style,\n-            value: *fold_meta_item_(@at.node.value, fld),\n+            value: fold_meta_item_(at.node.value, fld),\n             is_sugared_doc: at.node.is_sugared_doc,\n         },\n         span: fld.new_span(at.span),\n@@ -117,23 +119,22 @@ fn fold_arg_(a: arg, fld: @ast_fold) -> arg {\n }\n //used in noop_fold_expr, and possibly elsewhere in the future\n fn fold_mac_(m: mac, fld: @ast_fold) -> mac {\n-    spanned { node: match m.node {\n-                        mac_invoc_tt(*) => m.node,\n-                    },\n-              span: fld.new_span(m.span) }\n+    spanned {\n+        node: match m.node { mac_invoc_tt(*) => copy m.node },\n+        span: fld.new_span(m.span),\n+    }\n }\n \n-pub fn fold_fn_decl(decl: ast::fn_decl, fld: @ast_fold) -> ast::fn_decl {\n+pub fn fold_fn_decl(decl: &ast::fn_decl, fld: @ast_fold) -> ast::fn_decl {\n     ast::fn_decl {\n         inputs: decl.inputs.map(|x| fold_arg_(*x, fld)),\n         output: fld.fold_ty(decl.output),\n         cf: decl.cf,\n     }\n }\n \n-fn fold_ty_param_bound(tpb: TyParamBound,\n-                       fld: @ast_fold) -> TyParamBound {\n-    match tpb {\n+fn fold_ty_param_bound(tpb: &TyParamBound, fld: @ast_fold) -> TyParamBound {\n+    match *tpb {\n         TraitTyParamBound(ty) => TraitTyParamBound(fld.fold_ty(ty)),\n         RegionTyParamBound => RegionTyParamBound\n     }\n@@ -143,7 +144,7 @@ pub fn fold_ty_param(tp: TyParam,\n                      fld: @ast_fold) -> TyParam {\n     TyParam {ident: tp.ident,\n              id: fld.new_id(tp.id),\n-             bounds: @tp.bounds.map(|x| fold_ty_param_bound(*x, fld))}\n+             bounds: @tp.bounds.map(|x| fold_ty_param_bound(x, fld))}\n }\n \n pub fn fold_ty_params(tps: &OptVec<TyParam>,\n@@ -168,12 +169,12 @@ pub fn fold_generics(generics: &Generics, fld: @ast_fold) -> Generics {\n               lifetimes: fold_lifetimes(&generics.lifetimes, fld)}\n }\n \n-pub fn noop_fold_crate(c: crate_, fld: @ast_fold) -> crate_ {\n+pub fn noop_fold_crate(c: &crate_, fld: @ast_fold) -> crate_ {\n     let fold_meta_item = |x| fold_meta_item_(x, fld);\n     let fold_attribute = |x| fold_attribute_(x, fld);\n \n     crate_ {\n-        module: fld.fold_mod(c.module),\n+        module: fld.fold_mod(&c.module),\n         attrs: c.attrs.map(|x| fold_attribute(*x)),\n         config: c.config.map(|x| fold_meta_item(*x)),\n     }\n@@ -184,17 +185,17 @@ fn noop_fold_view_item(vi: view_item_, _fld: @ast_fold) -> view_item_ {\n }\n \n \n-fn noop_fold_foreign_item(&&ni: @foreign_item, fld: @ast_fold)\n+fn noop_fold_foreign_item(ni: @foreign_item, fld: @ast_fold)\n     -> @foreign_item {\n     let fold_arg = |x| fold_arg_(x, fld);\n     let fold_attribute = |x| fold_attribute_(x, fld);\n \n     @ast::foreign_item {\n         ident: fld.fold_ident(ni.ident),\n-        attrs: vec::map(ni.attrs, |x| fold_attribute(*x)),\n+        attrs: ni.attrs.map(|x| fold_attribute(*x)),\n         node:\n             match ni.node {\n-                foreign_item_fn(fdec, purity, ref generics) => {\n+                foreign_item_fn(ref fdec, purity, ref generics) => {\n                     foreign_item_fn(\n                         ast::fn_decl {\n                             inputs: fdec.inputs.map(|a| fold_arg(*a)),\n@@ -214,85 +215,102 @@ fn noop_fold_foreign_item(&&ni: @foreign_item, fld: @ast_fold)\n     }\n }\n \n-pub fn noop_fold_item(&&i: @item, fld: @ast_fold) -> Option<@item> {\n+pub fn noop_fold_item(i: @item, fld: @ast_fold) -> Option<@item> {\n     let fold_attribute = |x| fold_attribute_(x, fld);\n \n     Some(@ast::item { ident: fld.fold_ident(i.ident),\n                       attrs: i.attrs.map(|e| fold_attribute(*e)),\n                       id: fld.new_id(i.id),\n-                      node: fld.fold_item_underscore(i.node),\n+                      node: fld.fold_item_underscore(&i.node),\n                       vis: i.vis,\n                       span: fld.new_span(i.span) })\n }\n \n-fn noop_fold_struct_field(&&sf: @struct_field, fld: @ast_fold)\n+fn noop_fold_struct_field(sf: @struct_field, fld: @ast_fold)\n                        -> @struct_field {\n     @spanned { node: ast::struct_field_ { kind: copy sf.node.kind,\n                                           id: sf.node.id,\n                                           ty: fld.fold_ty(sf.node.ty) },\n                span: sf.span }\n }\n \n-pub fn noop_fold_item_underscore(i: item_, fld: @ast_fold) -> item_ {\n-    match i {\n+pub fn noop_fold_item_underscore(i: &item_, fld: @ast_fold) -> item_ {\n+    match *i {\n         item_const(t, e) => item_const(fld.fold_ty(t), fld.fold_expr(e)),\n-        item_fn(ref decl, purity, ref typms, ref body) => {\n-            item_fn(fold_fn_decl(/* FIXME (#2543) */ copy *decl, fld),\n-                    purity,\n-                    fold_generics(typms, fld),\n-                    fld.fold_block(*body))\n-        }\n-        item_mod(m) => item_mod(fld.fold_mod(m)),\n-        item_foreign_mod(nm) => item_foreign_mod(fld.fold_foreign_mod(nm)),\n-        item_ty(t, ref typms) => item_ty(fld.fold_ty(t),\n-                                     fold_generics(typms, fld)),\n-        item_enum(ref enum_definition, ref typms) => {\n-            item_enum(ast::enum_def(ast::enum_def_ {\n-                variants: enum_definition.variants.map(\n-                    |x| fld.fold_variant(*x)),\n-                common: enum_definition.common.map(\n-                    |x| fold_struct_def(*x, fld)),\n-            }), fold_generics(typms, fld))\n-        }\n-        item_struct(ref struct_def, ref typms) => {\n-            let struct_def = fold_struct_def(\n-                /* FIXME (#2543) */ copy *struct_def,\n-                fld);\n-            item_struct(struct_def, /* FIXME (#2543) */ copy *typms)\n-        }\n-        item_impl(ref tps, ifce, ty, ref methods) => {\n-            item_impl(fold_generics(tps, fld),\n-                      ifce.map(|p| fold_trait_ref(*p, fld)),\n-                      fld.fold_ty(ty),\n-                      methods.map(|x| fld.fold_method(*x)))\n-        }\n-        item_trait(ref tps, ref traits, ref methods) => {\n+        item_fn(ref decl, purity, ref generics, ref body) => {\n+            item_fn(\n+                fold_fn_decl(decl, fld),\n+                purity,\n+                fold_generics(generics, fld),\n+                fld.fold_block(body)\n+            )\n+        }\n+        item_mod(ref m) => item_mod(fld.fold_mod(m)),\n+        item_foreign_mod(ref nm) => {\n+            item_foreign_mod(fld.fold_foreign_mod(nm))\n+        }\n+        item_ty(t, ref generics) => {\n+            item_ty(fld.fold_ty(t), fold_generics(generics, fld))\n+        }\n+        item_enum(ref enum_definition, ref generics) => {\n+            item_enum(\n+                ast::enum_def(\n+                    ast::enum_def_ {\n+                        variants: do enum_definition.variants.map |x| {\n+                            fld.fold_variant(x)\n+                        },\n+                        common: do enum_definition.common.map |x| {\n+                            fold_struct_def(*x, fld)\n+                        }\n+                    }\n+                ),\n+                fold_generics(generics, fld))\n+        }\n+        item_struct(ref struct_def, ref generics) => {\n+            let struct_def = fold_struct_def(*struct_def, fld);\n+            item_struct(struct_def, /* FIXME (#2543) */ copy *generics)\n+        }\n+        item_impl(ref generics, ifce, ty, ref methods) => {\n+            item_impl(\n+                fold_generics(generics, fld),\n+                ifce.map(|p| fold_trait_ref(*p, fld)),\n+                fld.fold_ty(ty),\n+                methods.map(|x| fld.fold_method(*x))\n+            )\n+        }\n+        item_trait(ref generics, ref traits, ref methods) => {\n             let methods = do methods.map |method| {\n                 match *method {\n                     required(*) => copy *method,\n                     provided(method) => provided(fld.fold_method(method))\n                 }\n             };\n-            item_trait(fold_generics(tps, fld),\n-                       traits.map(|p| fold_trait_ref(*p, fld)),\n-                       methods)\n+            item_trait(\n+                fold_generics(generics, fld),\n+                traits.map(|p| fold_trait_ref(*p, fld)),\n+                methods\n+            )\n         }\n         item_mac(ref m) => {\n             // FIXME #2888: we might actually want to do something here.\n-            item_mac((*m))\n+            item_mac(copy *m)\n         }\n     }\n }\n \n fn fold_struct_def(struct_def: @ast::struct_def, fld: @ast_fold)\n                 -> @ast::struct_def {\n     let dtor = do option::map(&struct_def.dtor) |dtor| {\n-        let dtor_body = fld.fold_block(dtor.node.body);\n+        let dtor_body = fld.fold_block(&dtor.node.body);\n         let dtor_id   = fld.new_id(dtor.node.id);\n-        spanned { node: ast::struct_dtor_ { body: dtor_body,\n-                                            id: dtor_id,\n-                                            .. dtor.node},\n-                  span: dtor.span }\n+        spanned {\n+            node: ast::struct_dtor_ {\n+                body: dtor_body,\n+                id: dtor_id,\n+                .. copy dtor.node\n+            },\n+            span: copy dtor.span\n+        }\n     };\n     @ast::struct_def {\n         fields: struct_def.fields.map(|f| fold_struct_field(*f, fld)),\n@@ -301,29 +319,33 @@ fn fold_struct_def(struct_def: @ast::struct_def, fld: @ast_fold)\n     }\n }\n \n-fn fold_trait_ref(&&p: @trait_ref, fld: @ast_fold) -> @trait_ref {\n+fn fold_trait_ref(p: @trait_ref, fld: @ast_fold) -> @trait_ref {\n     @ast::trait_ref {\n         path: fld.fold_path(p.path),\n         ref_id: fld.new_id(p.ref_id),\n     }\n }\n \n-fn fold_struct_field(&&f: @struct_field, fld: @ast_fold) -> @struct_field {\n-    @spanned { node: ast::struct_field_ { kind: copy f.node.kind,\n-                                          id: fld.new_id(f.node.id),\n-                                          ty: fld.fold_ty(f.node.ty) },\n-               span: fld.new_span(f.span) }\n+fn fold_struct_field(f: @struct_field, fld: @ast_fold) -> @struct_field {\n+    @spanned {\n+        node: ast::struct_field_ {\n+            kind: copy f.node.kind,\n+            id: fld.new_id(f.node.id),\n+            ty: fld.fold_ty(f.node.ty),\n+        },\n+        span: fld.new_span(f.span),\n+    }\n }\n \n-fn noop_fold_method(&&m: @method, fld: @ast_fold) -> @method {\n+fn noop_fold_method(m: @method, fld: @ast_fold) -> @method {\n     @ast::method {\n         ident: fld.fold_ident(m.ident),\n         attrs: /* FIXME (#2543) */ copy m.attrs,\n         generics: fold_generics(&m.generics, fld),\n         self_ty: m.self_ty,\n         purity: m.purity,\n-        decl: fold_fn_decl(m.decl, fld),\n-        body: fld.fold_block(m.body),\n+        decl: fold_fn_decl(&m.decl, fld),\n+        body: fld.fold_block(&m.body),\n         id: fld.new_id(m.id),\n         span: fld.new_span(m.span),\n         self_id: fld.new_id(m.self_id),\n@@ -332,7 +354,7 @@ fn noop_fold_method(&&m: @method, fld: @ast_fold) -> @method {\n }\n \n \n-pub fn noop_fold_block(b: blk_, fld: @ast_fold) -> blk_ {\n+pub fn noop_fold_block(b: &blk_, fld: @ast_fold) -> blk_ {\n     ast::blk_ {\n         view_items: b.view_items.map(|x| fld.fold_view_item(*x)),\n         stmts: b.stmts.map(|x| fld.fold_stmt(*x)),\n@@ -342,47 +364,51 @@ pub fn noop_fold_block(b: blk_, fld: @ast_fold) -> blk_ {\n     }\n }\n \n-fn noop_fold_stmt(s: stmt_, fld: @ast_fold) -> stmt_ {\n+fn noop_fold_stmt(s: &stmt_, fld: @ast_fold) -> stmt_ {\n     let fold_mac = |x| fold_mac_(x, fld);\n-    return match s {\n-      stmt_decl(d, nid) => stmt_decl(fld.fold_decl(d), fld.new_id(nid)),\n-      stmt_expr(e, nid) => stmt_expr(fld.fold_expr(e), fld.new_id(nid)),\n-      stmt_semi(e, nid) => stmt_semi(fld.fold_expr(e), fld.new_id(nid)),\n-      stmt_mac(ref mac, semi) => stmt_mac(fold_mac((*mac)), semi)\n-    };\n+    match *s {\n+        stmt_decl(d, nid) => stmt_decl(fld.fold_decl(d), fld.new_id(nid)),\n+        stmt_expr(e, nid) => stmt_expr(fld.fold_expr(e), fld.new_id(nid)),\n+        stmt_semi(e, nid) => stmt_semi(fld.fold_expr(e), fld.new_id(nid)),\n+        stmt_mac(ref mac, semi) => stmt_mac(fold_mac((*mac)), semi)\n+    }\n }\n \n-fn noop_fold_arm(a: arm, fld: @ast_fold) -> arm {\n+fn noop_fold_arm(a: &arm, fld: @ast_fold) -> arm {\n     arm {\n-        pats: vec::map(a.pats, |x| fld.fold_pat(*x)),\n-        guard: option::map(&a.guard, |x| fld.fold_expr(*x)),\n-        body: fld.fold_block(a.body),\n-    }\n-}\n-\n-pub fn noop_fold_pat(p: pat_, fld: @ast_fold) -> pat_ {\n-    return match p {\n-          pat_wild => pat_wild,\n-          pat_ident(binding_mode, pth, sub) => {\n-            pat_ident(binding_mode,\n-                      fld.fold_path(pth),\n-                      option::map(&sub, |x| fld.fold_pat(*x)))\n-          }\n-          pat_lit(e) => pat_lit(fld.fold_expr(e)),\n-          pat_enum(pth, pats) => {\n-              pat_enum(fld.fold_path(pth), option::map(&pats,\n-                       |pats| vec::map(*pats, |x| fld.fold_pat(*x))))\n-          }\n-          pat_rec(fields, etc) => {\n+        pats: a.pats.map(|x| fld.fold_pat(*x)),\n+        guard: a.guard.map(|x| fld.fold_expr(*x)),\n+        body: fld.fold_block(&a.body),\n+    }\n+}\n+\n+pub fn noop_fold_pat(p: &pat_, fld: @ast_fold) -> pat_ {\n+    match *p {\n+        pat_wild => pat_wild,\n+        pat_ident(binding_mode, pth, ref sub) => {\n+            pat_ident(\n+                binding_mode,\n+                fld.fold_path(pth),\n+                sub.map(|x| fld.fold_pat(*x))\n+            )\n+        }\n+        pat_lit(e) => pat_lit(fld.fold_expr(e)),\n+        pat_enum(pth, ref pats) => {\n+            pat_enum(\n+                fld.fold_path(pth),\n+                pats.map(|pats| pats.map(|x| fld.fold_pat(*x)))\n+            )\n+        }\n+        pat_rec(ref fields, etc) => {\n             let fs = do fields.map |f| {\n                 ast::field_pat {\n                     ident: /* FIXME (#2543) */ copy f.ident,\n                     pat: fld.fold_pat(f.pat),\n                 }\n             };\n             pat_rec(fs, etc)\n-          }\n-          pat_struct(pth, fields, etc) => {\n+        }\n+        pat_struct(pth, ref fields, etc) => {\n             let pth_ = fld.fold_path(pth);\n             let fs = do fields.map |f| {\n                 ast::field_pat {\n@@ -391,40 +417,44 @@ pub fn noop_fold_pat(p: pat_, fld: @ast_fold) -> pat_ {\n                 }\n             };\n             pat_struct(pth_, fs, etc)\n-          }\n-          pat_tup(elts) => pat_tup(vec::map(elts, |x| fld.fold_pat(*x))),\n-          pat_box(inner) => pat_box(fld.fold_pat(inner)),\n-          pat_uniq(inner) => pat_uniq(fld.fold_pat(inner)),\n-          pat_region(inner) => pat_region(fld.fold_pat(inner)),\n-          pat_range(e1, e2) => {\n+        }\n+        pat_tup(ref elts) => pat_tup(elts.map(|x| fld.fold_pat(*x))),\n+        pat_box(inner) => pat_box(fld.fold_pat(inner)),\n+        pat_uniq(inner) => pat_uniq(fld.fold_pat(inner)),\n+        pat_region(inner) => pat_region(fld.fold_pat(inner)),\n+        pat_range(e1, e2) => {\n             pat_range(fld.fold_expr(e1), fld.fold_expr(e2))\n-          },\n-          pat_vec(elts, tail) => pat_vec(\n-            vec::map(elts, |x| fld.fold_pat(*x)),\n-            option::map(&tail, |tail| fld.fold_pat(*tail))\n-          )\n-        };\n+        },\n+        pat_vec(ref elts, ref tail) => {\n+            pat_vec(\n+                elts.map(|x| fld.fold_pat(*x)),\n+                tail.map(|tail| fld.fold_pat(*tail))\n+            )\n+        }\n+    }\n }\n \n-fn noop_fold_decl(d: decl_, fld: @ast_fold) -> decl_ {\n-    match d {\n-      decl_local(ls) => decl_local(vec::map(ls, |x| fld.fold_local(*x))),\n-      decl_item(it) => match fld.fold_item(it) {\n-        Some(it_folded) => decl_item(it_folded),\n-        None => decl_local(~[])\n-      }\n+fn noop_fold_decl(d: &decl_, fld: @ast_fold) -> decl_ {\n+    match *d {\n+        decl_local(ref ls) => decl_local(ls.map(|x| fld.fold_local(*x))),\n+        decl_item(it) => {\n+            match fld.fold_item(it) {\n+                Some(it_folded) => decl_item(it_folded),\n+                None => decl_local(~[]),\n+            }\n+        }\n     }\n }\n \n-pub fn wrap<T>(f: fn@(T, ast_fold) -> T)\n-    -> fn@(T, span, ast_fold) -> (T, span)\n+pub fn wrap<T>(f: fn@(&T, ast_fold) -> T)\n+    -> fn@(&T, span, ast_fold) -> (T, span)\n {\n-    return fn@(x: T, s: span, fld: @ast_fold) -> (T, span) {\n+    fn@(x: &T, s: span, fld: @ast_fold) -> (T, span) {\n         (f(x, fld), s)\n     }\n }\n \n-pub fn noop_fold_expr(e: expr_, fld: @ast_fold) -> expr_ {\n+pub fn noop_fold_expr(e: &expr_, fld: @ast_fold) -> expr_ {\n     fn fold_field_(field: field, fld: @ast_fold) -> field {\n         spanned {\n             node: ast::field_ {\n@@ -439,157 +469,196 @@ pub fn noop_fold_expr(e: expr_, fld: @ast_fold) -> expr_ {\n \n     let fold_mac = |x| fold_mac_(x, fld);\n \n-    return match e {\n-          expr_vstore(e, v) => {\n+    match *e {\n+        expr_vstore(e, v) => {\n             expr_vstore(fld.fold_expr(e), v)\n-          }\n-          expr_vec(exprs, mutt) => {\n-            expr_vec(fld.map_exprs(|x| fld.fold_expr(x), exprs), mutt)\n-          }\n-          expr_repeat(expr, count, mutt) =>\n-            expr_repeat(fld.fold_expr(expr), fld.fold_expr(count), mutt),\n-          expr_rec(ref fields, maybe_expr) => {\n-            expr_rec(vec::map((*fields), |x| fold_field(*x)),\n-                     option::map(&maybe_expr, |x| fld.fold_expr(*x)))\n-          }\n-          expr_tup(elts) => expr_tup(vec::map(elts, |x| fld.fold_expr(*x))),\n-          expr_call(f, args, blk) => {\n-            expr_call(fld.fold_expr(f),\n-                      fld.map_exprs(|x| fld.fold_expr(x), args),\n-                      blk)\n-          }\n-          expr_method_call(f, i, tps, args, blk) => {\n-            expr_method_call(fld.fold_expr(f),\n-                             fld.fold_ident(i),\n-                             vec::map(tps, |x| fld.fold_ty(*x)),\n-                             fld.map_exprs(|x| fld.fold_expr(x), args),\n-                             blk)\n-          }\n-          expr_binary(binop, lhs, rhs) => {\n+        }\n+        expr_vec(ref exprs, mutt) => {\n+            expr_vec(fld.map_exprs(|x| fld.fold_expr(x), *exprs), mutt)\n+        }\n+        expr_repeat(expr, count, mutt) => {\n+            expr_repeat(fld.fold_expr(expr), fld.fold_expr(count), mutt)\n+        }\n+        expr_rec(ref fields, maybe_expr) => {\n+            expr_rec(\n+                fields.map(|x| fold_field(*x)),\n+                maybe_expr.map(|x| fld.fold_expr(*x))\n+            )\n+        }\n+        expr_tup(ref elts) => expr_tup(elts.map(|x| fld.fold_expr(*x))),\n+        expr_call(f, ref args, blk) => {\n+            expr_call(\n+                fld.fold_expr(f),\n+                fld.map_exprs(|x| fld.fold_expr(x), *args),\n+                blk\n+            )\n+        }\n+        expr_method_call(f, i, ref tps, ref args, blk) => {\n+            expr_method_call(\n+                fld.fold_expr(f),\n+                fld.fold_ident(i),\n+                tps.map(|x| fld.fold_ty(*x)),\n+                fld.map_exprs(|x| fld.fold_expr(x), *args),\n+                blk\n+            )\n+        }\n+        expr_binary(binop, lhs, rhs) => {\n             expr_binary(binop, fld.fold_expr(lhs), fld.fold_expr(rhs))\n-          }\n-          expr_unary(binop, ohs) => expr_unary(binop, fld.fold_expr(ohs)),\n-          expr_loop_body(f) => expr_loop_body(fld.fold_expr(f)),\n-          expr_do_body(f) => expr_do_body(fld.fold_expr(f)),\n-          expr_lit(_) => copy e,\n-          expr_cast(expr, ty) => expr_cast(fld.fold_expr(expr), ty),\n-          expr_addr_of(m, ohs) => expr_addr_of(m, fld.fold_expr(ohs)),\n-          expr_if(cond, ref tr, fl) => {\n-            expr_if(fld.fold_expr(cond), fld.fold_block((*tr)),\n-                    option::map(&fl, |x| fld.fold_expr(*x)))\n-          }\n-          expr_while(cond, ref body) => {\n-            expr_while(fld.fold_expr(cond), fld.fold_block((*body)))\n-          }\n-          expr_loop(ref body, opt_ident) => {\n-              expr_loop(fld.fold_block((*body)),\n-                        option::map(&opt_ident, |x| fld.fold_ident(*x)))\n-          }\n-          expr_match(expr, ref arms) => {\n-            expr_match(fld.fold_expr(expr),\n-                     vec::map((*arms), |x| fld.fold_arm(*x)))\n-          }\n-          expr_fn(proto, ref decl, ref body, _) => {\n-            expr_fn(proto,\n-                    fold_fn_decl(/* FIXME (#2543) */ copy *decl, fld),\n-                    fld.fold_block(*body),\n-                    @())\n-          }\n-          expr_fn_block(ref decl, ref body) => {\n-            expr_fn_block(fold_fn_decl(/* FIXME (#2543) */ copy *decl, fld),\n-                          fld.fold_block(*body))\n-          }\n-          expr_block(ref blk) => expr_block(fld.fold_block((*blk))),\n-          expr_copy(e) => expr_copy(fld.fold_expr(e)),\n-          expr_assign(el, er) => {\n+        }\n+        expr_unary(binop, ohs) => expr_unary(binop, fld.fold_expr(ohs)),\n+        expr_loop_body(f) => expr_loop_body(fld.fold_expr(f)),\n+        expr_do_body(f) => expr_do_body(fld.fold_expr(f)),\n+        expr_lit(_) => copy *e,\n+        expr_cast(expr, ty) => expr_cast(fld.fold_expr(expr), ty),\n+        expr_addr_of(m, ohs) => expr_addr_of(m, fld.fold_expr(ohs)),\n+        expr_if(cond, ref tr, fl) => {\n+            expr_if(\n+                fld.fold_expr(cond),\n+                fld.fold_block(tr),\n+                fl.map(|x| fld.fold_expr(*x))\n+            )\n+        }\n+        expr_while(cond, ref body) => {\n+            expr_while(fld.fold_expr(cond), fld.fold_block(body))\n+        }\n+        expr_loop(ref body, opt_ident) => {\n+            expr_loop(\n+                fld.fold_block(body),\n+                opt_ident.map(|x| fld.fold_ident(*x))\n+            )\n+        }\n+        expr_match(expr, ref arms) => {\n+            expr_match(\n+                fld.fold_expr(expr),\n+                arms.map(|x| fld.fold_arm(x))\n+            )\n+        }\n+        expr_fn(proto, ref decl, ref body, _) => {\n+            expr_fn(\n+                proto,\n+                fold_fn_decl(decl, fld),\n+                fld.fold_block(body),\n+                @()\n+            )\n+        }\n+        expr_fn_block(ref decl, ref body) => {\n+            expr_fn_block(\n+                fold_fn_decl(decl, fld),\n+                fld.fold_block(body)\n+            )\n+        }\n+        expr_block(ref blk) => expr_block(fld.fold_block(blk)),\n+        expr_copy(e) => expr_copy(fld.fold_expr(e)),\n+        expr_assign(el, er) => {\n             expr_assign(fld.fold_expr(el), fld.fold_expr(er))\n-          }\n-          expr_swap(el, er) => {\n+        }\n+        expr_swap(el, er) => {\n             expr_swap(fld.fold_expr(el), fld.fold_expr(er))\n-          }\n-          expr_assign_op(op, el, er) => {\n+        }\n+        expr_assign_op(op, el, er) => {\n             expr_assign_op(op, fld.fold_expr(el), fld.fold_expr(er))\n-          }\n-          expr_field(el, id, tys) => {\n-            expr_field(fld.fold_expr(el), fld.fold_ident(id),\n-                       vec::map(tys, |x| fld.fold_ty(*x)))\n-          }\n-          expr_index(el, er) => {\n+        }\n+        expr_field(el, id, ref tys) => {\n+            expr_field(\n+                fld.fold_expr(el), fld.fold_ident(id),\n+                tys.map(|x| fld.fold_ty(*x))\n+            )\n+        }\n+        expr_index(el, er) => {\n             expr_index(fld.fold_expr(el), fld.fold_expr(er))\n-          }\n-          expr_path(pth) => expr_path(fld.fold_path(pth)),\n-          expr_break(opt_ident) =>\n-            expr_break(option::map(&opt_ident, |x| fld.fold_ident(*x))),\n-          expr_again(opt_ident) =>\n-            expr_again(option::map(&opt_ident, |x| fld.fold_ident(*x))),\n-          expr_ret(e) => expr_ret(option::map(&e, |x| fld.fold_expr(*x))),\n-          expr_log(i, lv, e) => expr_log(i, fld.fold_expr(lv),\n-                                         fld.fold_expr(e)),\n-          expr_assert(e) => expr_assert(fld.fold_expr(e)),\n-          expr_mac(ref mac) => expr_mac(fold_mac((*mac))),\n-          expr_struct(path, ref fields, maybe_expr) => {\n-            expr_struct(fld.fold_path(path),\n-                        vec::map((*fields), |x| fold_field(*x)),\n-                        option::map(&maybe_expr, |x| fld.fold_expr(*x)))\n-          },\n-          expr_paren(ex) => expr_paren(fld.fold_expr(ex))\n-        }\n-}\n-\n-pub fn noop_fold_ty(t: ty_, fld: @ast_fold) -> ty_ {\n+        }\n+        expr_path(pth) => expr_path(fld.fold_path(pth)),\n+        expr_break(ref opt_ident) => {\n+            expr_break(opt_ident.map(|x| fld.fold_ident(*x)))\n+        }\n+        expr_again(ref opt_ident) => {\n+            expr_again(opt_ident.map(|x| fld.fold_ident(*x)))\n+        }\n+        expr_ret(ref e) => {\n+            expr_ret(e.map(|x| fld.fold_expr(*x)))\n+        }\n+        expr_log(i, lv, e) => {\n+            expr_log(\n+                i,\n+                fld.fold_expr(lv),\n+                fld.fold_expr(e)\n+            )\n+        }\n+        expr_assert(e) => expr_assert(fld.fold_expr(e)),\n+        expr_mac(ref mac) => expr_mac(fold_mac((*mac))),\n+        expr_struct(path, ref fields, maybe_expr) => {\n+            expr_struct(\n+                fld.fold_path(path),\n+                fields.map(|x| fold_field(*x)),\n+                maybe_expr.map(|x| fld.fold_expr(*x))\n+            )\n+        },\n+        expr_paren(ex) => expr_paren(fld.fold_expr(ex))\n+    }\n+}\n+\n+pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n     let fold_mac = |x| fold_mac_(x, fld);\n-    fn fold_mt(mt: mt, fld: @ast_fold) -> mt {\n-        mt { ty: fld.fold_ty(mt.ty), mutbl: mt.mutbl }\n+    fn fold_mt(mt: &mt, fld: @ast_fold) -> mt {\n+        mt {\n+            ty: fld.fold_ty(mt.ty),\n+            mutbl: mt.mutbl,\n+        }\n     }\n     fn fold_field(f: ty_field, fld: @ast_fold) -> ty_field {\n         spanned {\n             node: ast::ty_field_ {\n                 ident: fld.fold_ident(f.node.ident),\n-                mt: fold_mt(f.node.mt, fld),\n+                mt: fold_mt(&f.node.mt, fld),\n             },\n             span: fld.new_span(f.span),\n         }\n     }\n-    match t {\n-      ty_nil | ty_bot | ty_infer => copy t,\n-      ty_box(mt) => ty_box(fold_mt(mt, fld)),\n-      ty_uniq(mt) => ty_uniq(fold_mt(mt, fld)),\n-      ty_vec(mt) => ty_vec(fold_mt(mt, fld)),\n-      ty_ptr(mt) => ty_ptr(fold_mt(mt, fld)),\n-      ty_rptr(region, mt) => ty_rptr(region, fold_mt(mt, fld)),\n-      ty_rec(ref fields) =>\n-        ty_rec(vec::map((*fields), |f| fold_field(*f, fld))),\n-      ty_closure(f) =>\n-        ty_closure(@TyClosure {\n-            sigil: f.sigil,\n-            purity: f.purity,\n-            region: f.region,\n-            onceness: f.onceness,\n-            decl: fold_fn_decl(f.decl, fld)\n-        }),\n-      ty_bare_fn(f) =>\n-        ty_bare_fn(@TyBareFn {\n-            purity: f.purity,\n-            abi: f.abi,\n-            decl: fold_fn_decl(f.decl, fld)\n-        }),\n-      ty_tup(tys) => ty_tup(vec::map(tys, |ty| fld.fold_ty(*ty))),\n-      ty_path(path, id) => ty_path(fld.fold_path(path), fld.new_id(id)),\n-      ty_fixed_length_vec(mt, vs) =>\n-        ty_fixed_length_vec(fold_mt(mt, fld), vs),\n-      ty_mac(ref mac) => ty_mac(fold_mac((*mac)))\n+    match *t {\n+        ty_nil | ty_bot | ty_infer => copy *t,\n+        ty_box(ref mt) => ty_box(fold_mt(mt, fld)),\n+        ty_uniq(ref mt) => ty_uniq(fold_mt(mt, fld)),\n+        ty_vec(ref mt) => ty_vec(fold_mt(mt, fld)),\n+        ty_ptr(ref mt) => ty_ptr(fold_mt(mt, fld)),\n+        ty_rptr(region, ref mt) => ty_rptr(region, fold_mt(mt, fld)),\n+        ty_rec(ref fields) => ty_rec(fields.map(|f| fold_field(*f, fld))),\n+        ty_closure(ref f) => {\n+            ty_closure(@TyClosure {\n+                sigil: f.sigil,\n+                purity: f.purity,\n+                region: f.region,\n+                onceness: f.onceness,\n+                decl: fold_fn_decl(&f.decl, fld)\n+            })\n+        }\n+        ty_bare_fn(ref f) => {\n+            ty_bare_fn(@TyBareFn {\n+                purity: f.purity,\n+                abi: f.abi,\n+                decl: fold_fn_decl(&f.decl, fld)\n+            })\n+        }\n+        ty_tup(ref tys) => ty_tup(tys.map(|ty| fld.fold_ty(*ty))),\n+        ty_path(path, id) => ty_path(fld.fold_path(path), fld.new_id(id)),\n+        ty_fixed_length_vec(ref mt, vs) => {\n+            ty_fixed_length_vec(\n+                fold_mt(mt, fld),\n+                vs\n+            )\n+        }\n+        ty_mac(ref mac) => ty_mac(fold_mac(*mac))\n     }\n }\n \n // ...nor do modules\n-pub fn noop_fold_mod(m: _mod, fld: @ast_fold) -> _mod {\n+pub fn noop_fold_mod(m: &_mod, fld: @ast_fold) -> _mod {\n     ast::_mod {\n         view_items: vec::map(m.view_items, |x| fld.fold_view_item(*x)),\n         items: vec::filter_mapped(m.items, |x| fld.fold_item(*x)),\n     }\n }\n \n-fn noop_fold_foreign_mod(nm: foreign_mod, fld: @ast_fold) -> foreign_mod {\n+fn noop_fold_foreign_mod(nm: &foreign_mod, fld: @ast_fold) -> foreign_mod {\n     ast::foreign_mod {\n         sort: nm.sort,\n         abi: nm.abi,\n@@ -598,25 +667,31 @@ fn noop_fold_foreign_mod(nm: foreign_mod, fld: @ast_fold) -> foreign_mod {\n     }\n }\n \n-fn noop_fold_variant(v: variant_, fld: @ast_fold) -> variant_ {\n+fn noop_fold_variant(v: &variant_, fld: @ast_fold) -> variant_ {\n     fn fold_variant_arg_(va: variant_arg, fld: @ast_fold) -> variant_arg {\n         ast::variant_arg { ty: fld.fold_ty(va.ty), id: fld.new_id(va.id) }\n     }\n     let fold_variant_arg = |x| fold_variant_arg_(x, fld);\n \n     let kind;\n     match v.kind {\n-        tuple_variant_kind(variant_args) =>\n-            kind = tuple_variant_kind(vec::map(variant_args,\n-                                               |x| fold_variant_arg(*x))),\n+        tuple_variant_kind(ref variant_args) => {\n+            kind = tuple_variant_kind(do variant_args.map |x| {\n+                fold_variant_arg(*x)\n+            })\n+        }\n         struct_variant_kind(struct_def) => {\n             let dtor = do option::map(&struct_def.dtor) |dtor| {\n-                let dtor_body = fld.fold_block(dtor.node.body);\n+                let dtor_body = fld.fold_block(&dtor.node.body);\n                 let dtor_id   = fld.new_id(dtor.node.id);\n-                spanned { node: ast::struct_dtor_ { body: dtor_body,\n-                                                    id: dtor_id,\n-                                                    .. dtor.node},\n-                          .. *dtor }\n+                spanned {\n+                    node: ast::struct_dtor_ {\n+                        body: dtor_body,\n+                        id: dtor_id,\n+                        .. copy dtor.node\n+                    },\n+                    .. copy *dtor\n+                }\n             };\n             kind = struct_variant_kind(@ast::struct_def {\n                 fields: vec::map(struct_def.fields,\n@@ -625,12 +700,13 @@ fn noop_fold_variant(v: variant_, fld: @ast_fold) -> variant_ {\n                 ctor_id: option::map(&struct_def.ctor_id, |c| fld.new_id(*c))\n             })\n         }\n-\n         enum_variant_kind(ref enum_definition) => {\n-            let variants = vec::map((*enum_definition).variants,\n-                                    |x| fld.fold_variant(*x));\n-            let common = option::map(&(*enum_definition).common,\n-                                     |x| fold_struct_def(*x, fld));\n+            let variants = do (*enum_definition).variants.map |x| {\n+                fld.fold_variant(x)\n+            };\n+            let common = do (*enum_definition).common.map |x| {\n+                fold_struct_def(*x, fld)\n+            };\n             kind = enum_variant_kind(\n                 ast::enum_def(ast::enum_def_ {\n                     variants: variants,\n@@ -641,7 +717,7 @@ fn noop_fold_variant(v: variant_, fld: @ast_fold) -> variant_ {\n     }\n \n     let fold_attribute = |x| fold_attribute_(x, fld);\n-    let attrs = vec::map(v.attrs, |x| fold_attribute(*x));\n+    let attrs = v.attrs.map(|x| fold_attribute(*x));\n \n     let de = match v.disr_expr {\n       Some(e) => Some(fld.fold_expr(e)),\n@@ -657,19 +733,21 @@ fn noop_fold_variant(v: variant_, fld: @ast_fold) -> variant_ {\n     }\n }\n \n-fn noop_fold_ident(&&i: ident, _fld: @ast_fold) -> ident {\n-    return /* FIXME (#2543) */ copy i;\n+fn noop_fold_ident(i: ident, _fld: @ast_fold) -> ident {\n+    /* FIXME (#2543) */ copy i\n }\n \n-fn noop_fold_path(&&p: path, fld: @ast_fold) -> path {\n-    ast::path { span: fld.new_span(p.span),\n-                global: p.global,\n-                idents: p.idents.map(|x| fld.fold_ident(*x)),\n-                rp: p.rp,\n-                types: p.types.map(|x| fld.fold_ty(*x)) }\n+fn noop_fold_path(p: @path, fld: @ast_fold) -> path {\n+    ast::path {\n+        span: fld.new_span(p.span),\n+        global: p.global,\n+        idents: p.idents.map(|x| fld.fold_ident(*x)),\n+        rp: p.rp,\n+        types: p.types.map(|x| fld.fold_ty(*x)),\n+    }\n }\n \n-fn noop_fold_local(l: local_, fld: @ast_fold) -> local_ {\n+fn noop_fold_local(l: &local_, fld: @ast_fold) -> local_ {\n     local_ {\n         is_mutbl: l.is_mutbl,\n         ty: fld.fold_ty(l.ty),\n@@ -681,47 +759,49 @@ fn noop_fold_local(l: local_, fld: @ast_fold) -> local_ {\n \n /* temporarily eta-expand because of a compiler bug with using `fn<T>` as a\n    value */\n-fn noop_map_exprs(f: fn@(&&v: @expr) -> @expr, es: ~[@expr]) -> ~[@expr] {\n-    return vec::map(es, |x| f(*x));\n+fn noop_map_exprs(f: fn@(@expr) -> @expr, es: &[@expr]) -> ~[@expr] {\n+    es.map(|x| f(*x))\n }\n \n fn noop_id(i: node_id) -> node_id { return i; }\n \n fn noop_span(sp: span) -> span { return sp; }\n \n pub fn default_ast_fold() -> ast_fold_fns {\n-    return @AstFoldFns {fold_crate: wrap(noop_fold_crate),\n-          fold_view_item: noop_fold_view_item,\n-          fold_foreign_item: noop_fold_foreign_item,\n-          fold_item: noop_fold_item,\n-          fold_struct_field: noop_fold_struct_field,\n-          fold_item_underscore: noop_fold_item_underscore,\n-          fold_method: noop_fold_method,\n-          fold_block: wrap(noop_fold_block),\n-          fold_stmt: wrap(noop_fold_stmt),\n-          fold_arm: noop_fold_arm,\n-          fold_pat: wrap(noop_fold_pat),\n-          fold_decl: wrap(noop_fold_decl),\n-          fold_expr: wrap(noop_fold_expr),\n-          fold_ty: wrap(noop_fold_ty),\n-          fold_mod: noop_fold_mod,\n-          fold_foreign_mod: noop_fold_foreign_mod,\n-          fold_variant: wrap(noop_fold_variant),\n-          fold_ident: noop_fold_ident,\n-          fold_path: noop_fold_path,\n-          fold_local: wrap(noop_fold_local),\n-          map_exprs: noop_map_exprs,\n-          new_id: noop_id,\n-          new_span: noop_span};\n+    @AstFoldFns {\n+        fold_crate: wrap(noop_fold_crate),\n+        fold_view_item: noop_fold_view_item,\n+        fold_foreign_item: noop_fold_foreign_item,\n+        fold_item: noop_fold_item,\n+        fold_struct_field: noop_fold_struct_field,\n+        fold_item_underscore: noop_fold_item_underscore,\n+        fold_method: noop_fold_method,\n+        fold_block: wrap(noop_fold_block),\n+        fold_stmt: wrap(noop_fold_stmt),\n+        fold_arm: noop_fold_arm,\n+        fold_pat: wrap(noop_fold_pat),\n+        fold_decl: wrap(noop_fold_decl),\n+        fold_expr: wrap(noop_fold_expr),\n+        fold_ty: wrap(noop_fold_ty),\n+        fold_mod: noop_fold_mod,\n+        fold_foreign_mod: noop_fold_foreign_mod,\n+        fold_variant: wrap(noop_fold_variant),\n+        fold_ident: noop_fold_ident,\n+        fold_path: noop_fold_path,\n+        fold_local: wrap(noop_fold_local),\n+        map_exprs: noop_map_exprs,\n+        new_id: noop_id,\n+        new_span: noop_span,\n+    }\n }\n \n impl ast_fold for AstFoldFns {\n     /* naturally, a macro to write these would be nice */\n-    fn fold_crate(@self, c: crate) -> crate {\n-        let (n, s) = (self.fold_crate)(c.node, c.span, self as @ast_fold);\n+    fn fold_crate(@self, c: &crate) -> crate {\n+        let (n, s) = (self.fold_crate)(&c.node, c.span, self as @ast_fold);\n         spanned { node: n, span: (self.new_span)(s) }\n     }\n-    fn fold_view_item(@self, &&x: @view_item) ->\n+    fn fold_view_item(@self, x: @view_item) ->\n        @view_item {\n         @ast::view_item {\n             node: (self.fold_view_item)(x.node, self as @ast_fold),\n@@ -731,14 +811,13 @@ impl ast_fold for AstFoldFns {\n             span: (self.new_span)(x.span),\n         }\n     }\n-    fn fold_foreign_item(@self, &&x: @foreign_item)\n-        -> @foreign_item {\n-        return (self.fold_foreign_item)(x, self as @ast_fold);\n+    fn fold_foreign_item(@self, x: @foreign_item) -> @foreign_item {\n+        (self.fold_foreign_item)(x, self as @ast_fold)\n     }\n-    fn fold_item(@self, &&i: @item) -> Option<@item> {\n-        return (self.fold_item)(i, self as @ast_fold);\n+    fn fold_item(@self, i: @item) -> Option<@item> {\n+        (self.fold_item)(i, self as @ast_fold)\n     }\n-    fn fold_struct_field(@self, &&sf: @struct_field) -> @struct_field {\n+    fn fold_struct_field(@self, sf: @struct_field) -> @struct_field {\n         @spanned {\n             node: ast::struct_field_ {\n                 kind: copy sf.node.kind,\n@@ -748,79 +827,77 @@ impl ast_fold for AstFoldFns {\n             span: (self.new_span)(sf.span),\n         }\n     }\n-    fn fold_item_underscore(@self, i: item_) ->\n-       item_ {\n-        return (self.fold_item_underscore)(i, self as @ast_fold);\n+    fn fold_item_underscore(@self, i: &item_) -> item_ {\n+        (self.fold_item_underscore)(i, self as @ast_fold)\n     }\n-    fn fold_method(@self, &&x: @method)\n-        -> @method {\n-        return (self.fold_method)(x, self as @ast_fold);\n+    fn fold_method(@self, x: @method) -> @method {\n+        (self.fold_method)(x, self as @ast_fold)\n     }\n-    fn fold_block(@self, x: blk) -> blk {\n-        let (n, s) = (self.fold_block)(x.node, x.span, self as @ast_fold);\n+    fn fold_block(@self, x: &blk) -> blk {\n+        let (n, s) = (self.fold_block)(&x.node, x.span, self as @ast_fold);\n         spanned { node: n, span: (self.new_span)(s) }\n     }\n-    fn fold_stmt(@self, &&x: @stmt) -> @stmt {\n-        let (n, s) = (self.fold_stmt)(x.node, x.span, self as @ast_fold);\n+    fn fold_stmt(@self, x: &stmt) -> @stmt {\n+        let (n, s) = (self.fold_stmt)(&x.node, x.span, self as @ast_fold);\n         @spanned { node: n, span: (self.new_span)(s) }\n     }\n-    fn fold_arm(@self, x: arm) -> arm {\n-        return (self.fold_arm)(x, self as @ast_fold);\n+    fn fold_arm(@self, x: &arm) -> arm {\n+        (self.fold_arm)(x, self as @ast_fold)\n     }\n-    fn fold_pat(@self, &&x: @pat) -> @pat {\n-        let (n, s) =  (self.fold_pat)(x.node, x.span, self as @ast_fold);\n+    fn fold_pat(@self, x: @pat) -> @pat {\n+        let (n, s) =  (self.fold_pat)(&x.node, x.span, self as @ast_fold);\n         @pat {\n             id: (self.new_id)(x.id),\n             node: n,\n             span: (self.new_span)(s),\n         }\n     }\n-    fn fold_decl(@self, &&x: @decl) -> @decl {\n-        let (n, s) = (self.fold_decl)(x.node, x.span, self as @ast_fold);\n+    fn fold_decl(@self, x: @decl) -> @decl {\n+        let (n, s) = (self.fold_decl)(&x.node, x.span, self as @ast_fold);\n         @spanned { node: n, span: (self.new_span)(s) }\n     }\n-    fn fold_expr(@self, &&x: @expr) -> @expr {\n-        let (n, s) = (self.fold_expr)(x.node, x.span, self as @ast_fold);\n+    fn fold_expr(@self, x: @expr) -> @expr {\n+        let (n, s) = (self.fold_expr)(&x.node, x.span, self as @ast_fold);\n         @expr {\n             id: (self.new_id)(x.id),\n             callee_id: (self.new_id)(x.callee_id),\n             node: n,\n             span: (self.new_span)(s),\n         }\n     }\n-    fn fold_ty(@self, &&x: @Ty) -> @Ty {\n-        let (n, s) = (self.fold_ty)(x.node, x.span, self as @ast_fold);\n+    fn fold_ty(@self, x: @Ty) -> @Ty {\n+        let (n, s) = (self.fold_ty)(&x.node, x.span, self as @ast_fold);\n         @Ty {\n             id: (self.new_id)(x.id),\n             node: n,\n             span: (self.new_span)(s),\n         }\n     }\n-    fn fold_mod(@self, x: _mod) -> _mod {\n-        return (self.fold_mod)(x, self as @ast_fold);\n+    fn fold_mod(@self, x: &_mod) -> _mod {\n+        (self.fold_mod)(x, self as @ast_fold)\n     }\n-    fn fold_foreign_mod(@self, x: foreign_mod) ->\n-       foreign_mod {\n-        return (self.fold_foreign_mod)(x, self as @ast_fold);\n+    fn fold_foreign_mod(@self, x: &foreign_mod) -> foreign_mod {\n+        (self.fold_foreign_mod)(x, self as @ast_fold)\n     }\n-    fn fold_variant(@self, x: variant) ->\n-       variant {\n-        let (n, s) = (self.fold_variant)(x.node, x.span, self as @ast_fold);\n+    fn fold_variant(@self, x: &variant) -> variant {\n+        let (n, s) = (self.fold_variant)(&x.node, x.span, self as @ast_fold);\n         spanned { node: n, span: (self.new_span)(s) }\n     }\n-    fn fold_ident(@self, &&x: ident) -> ident {\n-        return (self.fold_ident)(x, self as @ast_fold);\n+    fn fold_ident(@self, x: ident) -> ident {\n+        (self.fold_ident)(x, self as @ast_fold)\n     }\n-    fn fold_path(@self, &&x: @path) -> @path {\n-        @(self.fold_path)(*x, self as @ast_fold)\n+    fn fold_path(@self, x: @path) -> @path {\n+        @(self.fold_path)(x, self as @ast_fold)\n     }\n-    fn fold_local(@self, &&x: @local) -> @local {\n-        let (n, s) = (self.fold_local)(x.node, x.span, self as @ast_fold);\n+    fn fold_local(@self, x: @local) -> @local {\n+        let (n, s) = (self.fold_local)(&x.node, x.span, self as @ast_fold);\n         @spanned { node: n, span: (self.new_span)(s) }\n     }\n-    fn map_exprs(@self,\n-                 f: fn@(&&v: @expr) -> @expr,\n-                 e: ~[@expr]) -> ~[@expr] {\n+    fn map_exprs(\n+        @self,\n+        f: fn@(@expr) -> @expr,\n+        e: &[@expr]\n+    ) -> ~[@expr] {\n         (self.map_exprs)(f, e)\n     }\n     fn new_id(@self, node_id: ast::node_id) -> node_id {"}, {"sha": "16db384bb062c52255bb232dcef57de681d9a0e9", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -92,7 +92,7 @@ impl<T:Copy> OptVec<T> {\n         let mut v0 = ~[t];\n         match *self {\n             Empty => {}\n-            Vec(v1) => { v0.push_all(v1); }\n+            Vec(ref v1) => { v0.push_all(*v1); }\n         }\n         return Vec(v0);\n     }"}, {"sha": "28f84613740fb73e952f3b61dc7efbfaf3e8d96c", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -47,7 +47,10 @@ impl parser_attr for Parser {\n               }\n               token::DOC_COMMENT(s) => {\n                 let attr = ::attr::mk_sugared_doc_attr(\n-                        *self.id_to_str(s), self.span.lo, self.span.hi);\n+                    copy *self.id_to_str(s),\n+                    self.span.lo,\n+                    self.span.hi\n+                );\n                 if attr.node.style != ast::attr_outer {\n                   self.fatal(~\"expected outer comment\");\n                 }\n@@ -62,18 +65,18 @@ impl parser_attr for Parser {\n \n     fn parse_attribute(style: ast::attr_style) -> ast::attribute {\n         let lo = self.span.lo;\n-        self.expect(token::POUND);\n+        self.expect(&token::POUND);\n         return self.parse_attribute_naked(style, lo);\n     }\n \n     fn parse_attribute_naked(style: ast::attr_style, lo: BytePos) ->\n         ast::attribute {\n-        self.expect(token::LBRACKET);\n+        self.expect(&token::LBRACKET);\n         let meta_item = self.parse_meta_item();\n-        self.expect(token::RBRACKET);\n+        self.expect(&token::RBRACKET);\n         let mut hi = self.span.hi;\n         return spanned(lo, hi, ast::attribute_ { style: style,\n-                                                 value: *meta_item,\n+                                                 value: meta_item,\n                                                  is_sugared_doc: false });\n     }\n \n@@ -114,7 +117,10 @@ impl parser_attr for Parser {\n               }\n               token::DOC_COMMENT(s) => {\n                 let attr = ::attr::mk_sugared_doc_attr(\n-                        *self.id_to_str(s), self.span.lo, self.span.hi);\n+                    copy *self.id_to_str(s),\n+                    self.span.lo,\n+                    self.span.hi\n+                );\n                 self.bump();\n                 if attr.node.style == ast::attr_inner {\n                   inner_attrs += ~[attr];\n@@ -152,15 +158,18 @@ impl parser_attr for Parser {\n     }\n \n     fn parse_meta_seq() -> ~[@ast::meta_item] {\n-        return self.parse_seq(token::LPAREN, token::RPAREN,\n-                           seq_sep_trailing_disallowed(token::COMMA),\n-                           |p| p.parse_meta_item()).node;\n+        copy self.parse_seq(\n+            &token::LPAREN,\n+            &token::RPAREN,\n+            seq_sep_trailing_disallowed(token::COMMA),\n+            |p| p.parse_meta_item()\n+        ).node\n     }\n \n     fn parse_optional_meta() -> ~[@ast::meta_item] {\n         match *self.token {\n-          token::LPAREN => return self.parse_meta_seq(),\n-          _ => return ~[]\n+            token::LPAREN => self.parse_meta_seq(),\n+            _ => ~[]\n         }\n     }\n }"}, {"sha": "714ae9a0fd520065db98e00f0b1e08658c0e2d29", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -221,7 +221,7 @@ fn trim_whitespace_prefix_and_push_line(lines: &mut ~[~str],\n         if col < len {\n             s1 = str::slice(s, col, len);\n         } else { s1 = ~\"\"; }\n-    } else { s1 = s; }\n+    } else { s1 = /*bad*/ copy s; }\n     log(debug, ~\"pushing line: \" + s1);\n     lines.push(s1);\n }\n@@ -321,7 +321,7 @@ pub struct lit {\n }\n \n pub fn gather_comments_and_literals(span_diagnostic: diagnostic::span_handler,\n-                                    path: ~str,\n+                                    +path: ~str,\n                                     srdr: io::Reader) -> (~[cmnt], ~[lit]) {\n     let src = @str::from_bytes(srdr.read_whole_stream());\n     let itr = parse::token::mk_fake_ident_interner();\n@@ -354,12 +354,12 @@ pub fn gather_comments_and_literals(span_diagnostic: diagnostic::span_handler,\n         rdr.next_token();\n         //discard, and look ahead; we're working with internal state\n         let TokenAndSpan {tok: tok, sp: sp} = rdr.peek();\n-        if token::is_lit(tok) {\n+        if token::is_lit(&tok) {\n             let s = get_str_from(rdr, bstart);\n-            literals.push(lit {lit: s, pos: sp.lo});\n-            log(debug, ~\"tok lit: \" + s);\n+            literals.push(lit {lit: /*bad*/ copy s, pos: sp.lo});\n+            debug!(\"tok lit: %s\", s);\n         } else {\n-            log(debug, ~\"tok: \" + token::to_str(rdr.interner, tok));\n+            debug!(\"tok: %s\", token::to_str(rdr.interner, &tok));\n         }\n         first_read = false;\n     }"}, {"sha": "f538ed8030c13504a02c04653f7039c70f7caf65", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 138, "deletions": 95, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -30,65 +30,86 @@ pub struct SeqSep {\n     trailing_sep_allowed: bool\n }\n \n-pub fn seq_sep_trailing_disallowed(t: token::Token) -> SeqSep {\n+pub fn seq_sep_trailing_disallowed(+t: token::Token) -> SeqSep {\n     SeqSep {\n-        sep: option::Some(t),\n-        trailing_sep_allowed: false\n+        sep: Some(t),\n+        trailing_sep_allowed: false,\n     }\n }\n-pub fn seq_sep_trailing_allowed(t: token::Token) -> SeqSep {\n+pub fn seq_sep_trailing_allowed(+t: token::Token) -> SeqSep {\n     SeqSep {\n-        sep: option::Some(t),\n-        trailing_sep_allowed: true\n+        sep: Some(t),\n+        trailing_sep_allowed: true,\n     }\n }\n pub fn seq_sep_none() -> SeqSep {\n     SeqSep {\n-        sep: option::None,\n-        trailing_sep_allowed: false\n+        sep: None,\n+        trailing_sep_allowed: false,\n     }\n }\n \n-pub fn token_to_str(reader: reader, ++token: token::Token) -> ~str {\n+pub fn token_to_str(reader: reader, token: &token::Token) -> ~str {\n     token::to_str(reader.interner(), token)\n }\n \n pub impl Parser {\n-    fn unexpected_last(t: token::Token) -> ! {\n+    fn unexpected_last(t: &token::Token) -> ! {\n         self.span_fatal(\n             *self.last_span,\n-            ~\"unexpected token: `\" + token_to_str(self.reader, t) + ~\"`\");\n+            fmt!(\n+                \"unexpected token: `%s`\",\n+                token_to_str(self.reader, t)\n+            )\n+        );\n     }\n \n     fn unexpected() -> ! {\n-        self.fatal(~\"unexpected token: `\"\n-                   + token_to_str(self.reader, *self.token) + ~\"`\");\n+        self.fatal(\n+            fmt!(\n+                \"unexpected token: `%s`\",\n+                token_to_str(self.reader, &copy *self.token)\n+            )\n+        );\n     }\n \n     // expect and consume the token t. Signal an error if\n     // the next token is not t.\n-    fn expect(t: token::Token) {\n-        if *self.token == t {\n+    fn expect(t: &token::Token) {\n+        if *self.token == *t {\n             self.bump();\n         } else {\n-            let mut s: ~str = ~\"expected `\";\n-            s += token_to_str(self.reader, t);\n-            s += ~\"` but found `\";\n-            s += token_to_str(self.reader, *self.token);\n-            self.fatal(s + ~\"`\");\n+            self.fatal(\n+                fmt!(\n+                    \"expected `%s` but found `%s`\",\n+                    token_to_str(self.reader, t),\n+                    token_to_str(self.reader, &copy *self.token)\n+                )\n+            )\n         }\n     }\n \n     fn parse_ident() -> ast::ident {\n         self.check_strict_keywords();\n         self.check_reserved_keywords();\n         match *self.token {\n-          token::IDENT(i, _) => { self.bump(); return i; }\n-          token::INTERPOLATED(token::nt_ident(*)) => { self.bug(\n-              ~\"ident interpolation not converted to real token\"); }\n-          _ => { self.fatal(~\"expected ident, found `\"\n-                         + token_to_str(self.reader, *self.token)\n-                         + ~\"`\"); }\n+            token::IDENT(i, _) => {\n+                self.bump();\n+                i\n+            }\n+            token::INTERPOLATED(token::nt_ident(*)) => {\n+                self.bug(\n+                    ~\"ident interpolation not converted to real token\"\n+                );\n+            }\n+            _ => {\n+                self.fatal(\n+                    fmt!(\n+                        \"expected ident, found `%s`\",\n+                        token_to_str(self.reader, &copy *self.token)\n+                    )\n+                );\n+            }\n         }\n     }\n \n@@ -106,100 +127,104 @@ pub impl Parser {\n \n     // consume token 'tok' if it exists. Returns true if the given\n     // token was present, false otherwise.\n-    fn eat(tok: token::Token) -> bool {\n-        return if *self.token == tok { self.bump(); true } else { false };\n+    fn eat(tok: &token::Token) -> bool {\n+        return if *self.token == *tok { self.bump(); true } else { false };\n     }\n \n     // Storing keywords as interned idents instead of strings would be nifty.\n \n     // A sanity check that the word we are asking for is a known keyword\n-    fn require_keyword(word: ~str) {\n-        if !self.keywords.contains_key(&word) {\n-            self.bug(fmt!(\"unknown keyword: %s\", word));\n+    fn require_keyword(word: &~str) {\n+        if !self.keywords.contains_key(word) {\n+            self.bug(fmt!(\"unknown keyword: %s\", *word));\n         }\n     }\n \n-    fn token_is_word(word: ~str, ++tok: token::Token) -> bool {\n-        match tok {\n-          token::IDENT(sid, false) => { *self.id_to_str(sid) == word }\n-          _ => { false }\n+    pure fn token_is_word(word: &~str, tok: &token::Token) -> bool {\n+        match *tok {\n+            token::IDENT(sid, false) => { *self.id_to_str(sid) == *word }\n+             _ => { false }\n         }\n     }\n \n-    fn token_is_keyword(word: ~str, ++tok: token::Token) -> bool {\n+    fn token_is_keyword(word: &~str, tok: &token::Token) -> bool {\n         self.require_keyword(word);\n         self.token_is_word(word, tok)\n     }\n \n-    fn is_keyword(word: ~str) -> bool {\n-        self.token_is_keyword(word, *self.token)\n+    fn is_keyword(word: &~str) -> bool {\n+        self.token_is_keyword(word, &copy *self.token)\n     }\n \n-    fn is_any_keyword(tok: token::Token) -> bool {\n-        match tok {\n+    fn is_any_keyword(tok: &token::Token) -> bool {\n+        match *tok {\n           token::IDENT(sid, false) => {\n             self.keywords.contains_key(self.id_to_str(sid))\n           }\n           _ => false\n         }\n     }\n \n-    fn eat_keyword(word: ~str) -> bool {\n+    fn eat_keyword(word: &~str) -> bool {\n         self.require_keyword(word);\n         let is_kw = match *self.token {\n-          token::IDENT(sid, false) => (word == *self.id_to_str(sid)),\n-          _ => false\n+            token::IDENT(sid, false) => *word == *self.id_to_str(sid),\n+            _ => false\n         };\n         if is_kw { self.bump() }\n         is_kw\n     }\n \n-    fn expect_keyword(word: ~str) {\n+    fn expect_keyword(word: &~str) {\n         self.require_keyword(word);\n         if !self.eat_keyword(word) {\n-            self.fatal(~\"expected `\" + word + ~\"`, found `\" +\n-                       token_to_str(self.reader, *self.token) +\n-                       ~\"`\");\n+            self.fatal(\n+                fmt!(\n+                    \"expected `%s`, found `%s`\",\n+                    *word,\n+                    token_to_str(self.reader, &copy *self.token)\n+                )\n+            );\n         }\n     }\n \n-    fn is_strict_keyword(word: ~str) -> bool {\n-        self.strict_keywords.contains_key(&word)\n+    fn is_strict_keyword(word: &~str) -> bool {\n+        self.strict_keywords.contains_key(word)\n     }\n \n     fn check_strict_keywords() {\n         match *self.token {\n-          token::IDENT(_, false) => {\n-            let w = token_to_str(self.reader, *self.token);\n-            self.check_strict_keywords_(w);\n-          }\n-          _ => ()\n+            token::IDENT(_, false) => {\n+                let w = token_to_str(self.reader, &copy *self.token);\n+                self.check_strict_keywords_(&w);\n+            }\n+            _ => ()\n         }\n     }\n \n-    fn check_strict_keywords_(w: ~str) {\n+    fn check_strict_keywords_(w: &~str) {\n         if self.is_strict_keyword(w) {\n-            self.fatal(~\"found `\" + w + ~\"` in ident position\");\n+            self.fatal(fmt!(\"found `%s` in ident position\", *w));\n         }\n     }\n \n-    fn is_reserved_keyword(word: ~str) -> bool {\n-        self.reserved_keywords.contains_key(&word)\n+    fn is_reserved_keyword(word: &~str) -> bool {\n+        self.reserved_keywords.contains_key(word)\n     }\n \n     fn check_reserved_keywords() {\n         match *self.token {\n-          token::IDENT(_, false) => {\n-            let w = token_to_str(self.reader, *self.token);\n-            self.check_reserved_keywords_(w);\n-          }\n-          _ => ()\n+            token::IDENT(_, false) => {\n+                let w = token_to_str(self.reader, &copy *self.token);\n+                self.check_reserved_keywords_(&w);\n+            }\n+            _ => ()\n         }\n     }\n \n-    fn check_reserved_keywords_(w: ~str) {\n+    fn check_reserved_keywords_(w: &~str) {\n         if self.is_reserved_keyword(w) {\n-            self.fatal(~\"`\" + w + ~\"` is a reserved keyword\");\n+            self.fatal(fmt!(\"`%s` is a reserved keyword\", *w));\n         }\n     }\n \n@@ -209,41 +234,47 @@ pub impl Parser {\n         if *self.token == token::GT {\n             self.bump();\n         } else if *self.token == token::BINOP(token::SHR) {\n-            self.replace_token(token::GT,\n-                               self.span.lo + BytePos(1u),\n-                               self.span.hi);\n+            self.replace_token(\n+                token::GT,\n+                self.span.lo + BytePos(1u),\n+                self.span.hi\n+            );\n         } else {\n             let mut s: ~str = ~\"expected `\";\n-            s += token_to_str(self.reader, token::GT);\n+            s += token_to_str(self.reader, &token::GT);\n             s += ~\"`, found `\";\n-            s += token_to_str(self.reader, *self.token);\n+            s += token_to_str(self.reader, &copy *self.token);\n             s += ~\"`\";\n             self.fatal(s);\n         }\n     }\n \n     // parse a sequence bracketed by '<' and '>', stopping\n     // before the '>'.\n-    fn parse_seq_to_before_gt<T: Copy>(sep: Option<token::Token>,\n-                                       f: fn(Parser) -> T) -> OptVec<T> {\n+    fn parse_seq_to_before_gt<T: Copy>(\n+        sep: Option<token::Token>,\n+        f: fn(&Parser) -> T\n+    ) -> OptVec<T> {\n         let mut first = true;\n         let mut v = opt_vec::Empty;\n         while *self.token != token::GT\n             && *self.token != token::BINOP(token::SHR) {\n             match sep {\n               Some(ref t) => {\n                 if first { first = false; }\n-                else { self.expect(*t); }\n+                else { self.expect(t); }\n               }\n               _ => ()\n             }\n-            v.push(f(self));\n+            v.push(f(&self));\n         }\n         return v;\n     }\n \n-    fn parse_seq_to_gt<T: Copy>(sep: Option<token::Token>,\n-                                f: fn(Parser) -> T) -> OptVec<T> {\n+    fn parse_seq_to_gt<T: Copy>(\n+        sep: Option<token::Token>,\n+        f: fn(&Parser) -> T\n+    ) -> OptVec<T> {\n         let v = self.parse_seq_to_before_gt(sep, f);\n         self.expect_gt();\n         return v;\n@@ -252,56 +283,68 @@ pub impl Parser {\n     // parse a sequence, including the closing delimiter. The function\n     // f must consume tokens until reaching the next separator or\n     // closing bracket.\n-    fn parse_seq_to_end<T:Copy>(ket: token::Token, sep: SeqSep,\n-                                 f: fn(Parser) -> T) -> ~[T] {\n+    fn parse_seq_to_end<T: Copy>(\n+        ket: &token::Token,\n+        sep: SeqSep,\n+        f: fn(&Parser) -> T\n+    ) -> ~[T] {\n         let val = self.parse_seq_to_before_end(ket, sep, f);\n         self.bump();\n-        return val;\n+        val\n     }\n \n     // parse a sequence, not including the closing delimiter. The function\n     // f must consume tokens until reaching the next separator or\n     // closing bracket.\n-    fn parse_seq_to_before_end<T:Copy>(ket: token::Token, sep: SeqSep,\n-                                        f: fn(Parser) -> T) -> ~[T] {\n+    fn parse_seq_to_before_end<T: Copy>(\n+        ket: &token::Token,\n+        sep: SeqSep,\n+        f: fn(&Parser) -> T\n+    ) -> ~[T] {\n         let mut first: bool = true;\n         let mut v: ~[T] = ~[];\n-        while *self.token != ket {\n+        while *self.token != *ket {\n             match sep.sep {\n               Some(ref t) => {\n                 if first { first = false; }\n-                else { self.expect(*t); }\n+                else { self.expect(t); }\n               }\n               _ => ()\n             }\n-            if sep.trailing_sep_allowed && *self.token == ket { break; }\n-            v.push(f(self));\n+            if sep.trailing_sep_allowed && *self.token == *ket { break; }\n+            v.push(f(&self));\n         }\n         return v;\n     }\n \n     // parse a sequence, including the closing delimiter. The function\n     // f must consume tokens until reaching the next separator or\n     // closing bracket.\n-    fn parse_unspanned_seq<T:Copy>(+bra: token::Token,\n-                                   +ket: token::Token,\n-                                    sep: SeqSep,\n-                                    f: fn(Parser) -> T) -> ~[T] {\n+    fn parse_unspanned_seq<T: Copy>(\n+        bra: &token::Token,\n+        ket: &token::Token,\n+        sep: SeqSep,\n+        f: fn(&Parser) -> T\n+    ) -> ~[T] {\n         self.expect(bra);\n-        let result = self.parse_seq_to_before_end::<T>(ket, sep, f);\n+        let result = self.parse_seq_to_before_end(ket, sep, f);\n         self.bump();\n-        return result;\n+        result\n     }\n \n     // NB: Do not use this function unless you actually plan to place the\n     // spanned list in the AST.\n-    fn parse_seq<T:Copy>(bra: token::Token, ket: token::Token, sep: SeqSep,\n-                          f: fn(Parser) -> T) -> spanned<~[T]> {\n+    fn parse_seq<T: Copy>(\n+        bra: &token::Token,\n+        ket: &token::Token,\n+        sep: SeqSep,\n+        f: fn(&Parser) -> T\n+    ) -> spanned<~[T]> {\n         let lo = self.span.lo;\n         self.expect(bra);\n-        let result = self.parse_seq_to_before_end::<T>(ket, sep, f);\n+        let result = self.parse_seq_to_before_end(ket, sep, f);\n         let hi = self.span.hi;\n         self.bump();\n-        return spanned(lo, hi, result);\n+        spanned(lo, hi, result)\n     }\n }"}, {"sha": "ed71fa411c69fd7e740eba1990bee26f22a04bde", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -103,26 +103,32 @@ fn dup_string_reader(r: @mut StringReader) -> @mut StringReader {\n         curr: r.curr,\n         filemap: r.filemap,\n         interner: r.interner,\n-        peek_tok: r.peek_tok,\n-        peek_span: r.peek_span\n+        peek_tok: copy r.peek_tok,\n+        peek_span: copy r.peek_span\n     }\n }\n \n impl reader for StringReader {\n     fn is_eof(@mut self) -> bool { is_eof(self) }\n     // return the next token. EFFECT: advances the string_reader.\n     fn next_token(@mut self) -> TokenAndSpan {\n-        let ret_val = TokenAndSpan {tok: self.peek_tok, sp: self.peek_span};\n+        let ret_val = TokenAndSpan {\n+            tok: copy self.peek_tok,\n+            sp: copy self.peek_span,\n+        };\n         string_advance_token(self);\n-        return ret_val;\n+        ret_val\n     }\n     fn fatal(@mut self, m: ~str) -> ! {\n         self.span_diagnostic.span_fatal(copy self.peek_span, m)\n     }\n     fn span_diag(@mut self) -> span_handler { self.span_diagnostic }\n     pure fn interner(@mut self) -> @token::ident_interner { self.interner }\n     fn peek(@mut self) -> TokenAndSpan {\n-        TokenAndSpan {tok: self.peek_tok, sp: self.peek_span}\n+        TokenAndSpan {\n+            tok: copy self.peek_tok,\n+            sp: copy self.peek_span,\n+        }\n     }\n     fn dup(@mut self) -> reader { dup_string_reader(self) as reader }\n }\n@@ -136,7 +142,10 @@ impl reader for TtReader {\n     fn span_diag(@mut self) -> span_handler { self.sp_diag }\n     pure fn interner(@mut self) -> @token::ident_interner { self.interner }\n     fn peek(@mut self) -> TokenAndSpan {\n-        TokenAndSpan { tok: self.cur_tok, sp: self.cur_span }\n+        TokenAndSpan {\n+            tok: copy self.cur_tok,\n+            sp: copy self.cur_span,\n+        }\n     }\n     fn dup(@mut self) -> reader { dup_tt_reader(self) as reader }\n }\n@@ -145,8 +154,8 @@ impl reader for TtReader {\n fn string_advance_token(r: @mut StringReader) {\n     match (consume_whitespace_and_comments(r)) {\n         Some(comment) => {\n-            r.peek_tok = comment.tok;\n-            r.peek_span = comment.sp;\n+            r.peek_tok = copy comment.tok;\n+            r.peek_span = copy comment.sp;\n         },\n         None => {\n             if is_eof(r) {"}, {"sha": "887f064018f37823230d983fa8bcdc6eb1a2f006", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 140, "deletions": 75, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -81,70 +81,113 @@ pub fn new_parse_sess_special_handler(sh: span_handler, cm: @codemap::CodeMap)\n \n // this appears to be the main entry point for rust parsing by\n // rustc and crate:\n-pub fn parse_crate_from_file(input: &Path, cfg: ast::crate_cfg,\n-                         sess: @mut ParseSess) -> @ast::crate {\n-    let p = new_parser_from_file(sess, cfg, input);\n-    p.parse_crate_mod(cfg)\n+pub fn parse_crate_from_file(\n+    input: &Path,\n+    cfg: ast::crate_cfg,\n+    sess: @mut ParseSess\n+) -> @ast::crate {\n+    let p = new_parser_from_file(sess, /*bad*/ copy cfg, input);\n+    p.parse_crate_mod(/*bad*/ copy cfg)\n     // why is there no p.abort_if_errors here?\n }\n \n-pub fn parse_crate_from_source_str(name: ~str,\n-                                   source: @~str,\n-                                   cfg: ast::crate_cfg,\n-                                   sess: @mut ParseSess) -> @ast::crate {\n-    let p = new_parser_from_source_str(sess, cfg, name,\n-                                       codemap::FssNone, source);\n-    maybe_aborted(p.parse_crate_mod(cfg),p)\n+pub fn parse_crate_from_source_str(\n+    name: ~str,\n+    source: @~str,\n+    cfg: ast::crate_cfg,\n+    sess: @mut ParseSess\n+) -> @ast::crate {\n+    let p = new_parser_from_source_str(\n+        sess,\n+        /*bad*/ copy cfg,\n+        /*bad*/ copy name,\n+        codemap::FssNone,\n+        source\n+    );\n+    maybe_aborted(p.parse_crate_mod(/*bad*/ copy cfg),p)\n }\n \n-pub fn parse_expr_from_source_str(name: ~str,\n-                                  source: @~str,\n-                                  cfg: ast::crate_cfg,\n-                                  sess: @mut ParseSess) -> @ast::expr {\n-    let p = new_parser_from_source_str(sess, cfg, name,\n-                                       codemap::FssNone, source);\n+pub fn parse_expr_from_source_str(\n+    name: ~str,\n+    source: @~str,\n+    +cfg: ast::crate_cfg,\n+    sess: @mut ParseSess\n+) -> @ast::expr {\n+    let p = new_parser_from_source_str(\n+        sess,\n+        cfg,\n+        /*bad*/ copy name,\n+        codemap::FssNone,\n+        source\n+    );\n     maybe_aborted(p.parse_expr(), p)\n }\n \n-pub fn parse_item_from_source_str(name: ~str,\n-                                  source: @~str,\n-                                  cfg: ast::crate_cfg,\n-                                  +attrs: ~[ast::attribute],\n-                                  sess: @mut ParseSess)\n-                               -> Option<@ast::item> {\n-    let p = new_parser_from_source_str(sess, cfg, name,\n-                                       codemap::FssNone, source);\n+pub fn parse_item_from_source_str(\n+    name: ~str,\n+    source: @~str,\n+    +cfg: ast::crate_cfg,\n+    +attrs: ~[ast::attribute],\n+    sess: @mut ParseSess\n+) -> Option<@ast::item> {\n+    let p = new_parser_from_source_str(\n+        sess,\n+        cfg,\n+        /*bad*/ copy name,\n+        codemap::FssNone,\n+        source\n+    );\n     maybe_aborted(p.parse_item(attrs),p)\n }\n \n-pub fn parse_stmt_from_source_str(name: ~str,\n-                                  source: @~str,\n-                                  cfg: ast::crate_cfg,\n-                                  +attrs: ~[ast::attribute],\n-                                  sess: @mut ParseSess) -> @ast::stmt {\n-    let p = new_parser_from_source_str(sess, cfg, name,\n-                                       codemap::FssNone, source);\n+pub fn parse_stmt_from_source_str(\n+    name: ~str,\n+    source: @~str,\n+    +cfg: ast::crate_cfg,\n+    +attrs: ~[ast::attribute],\n+    sess: @mut ParseSess\n+) -> @ast::stmt {\n+    let p = new_parser_from_source_str(\n+        sess,\n+        cfg,\n+        /*bad*/ copy name,\n+        codemap::FssNone,\n+        source\n+    );\n     maybe_aborted(p.parse_stmt(attrs),p)\n }\n \n-pub fn parse_tts_from_source_str(name: ~str,\n-                                 source: @~str,\n-                                 cfg: ast::crate_cfg,\n-                                 sess: @mut ParseSess) -> ~[ast::token_tree] {\n-    let p = new_parser_from_source_str(sess, cfg, name,\n-                                       codemap::FssNone, source);\n+pub fn parse_tts_from_source_str(\n+    name: ~str,\n+    source: @~str,\n+    +cfg: ast::crate_cfg,\n+    sess: @mut ParseSess\n+) -> ~[ast::token_tree] {\n+    let p = new_parser_from_source_str(\n+        sess,\n+        cfg,\n+        /*bad*/ copy name,\n+        codemap::FssNone,\n+        source\n+    );\n     *p.quote_depth += 1u;\n     maybe_aborted(p.parse_all_token_trees(),p)\n }\n \n-pub fn parse_from_source_str<T>(f: fn (p: Parser) -> T,\n-                            name: ~str, ss: codemap::FileSubstr,\n-                            source: @~str, cfg: ast::crate_cfg,\n-                            sess: @mut ParseSess)\n-    -> T\n-{\n-    let p = new_parser_from_source_str(sess, cfg, name, ss,\n-                                       source);\n+pub fn parse_from_source_str<T>(\n+    f: fn (Parser) -> T,\n+    name: ~str, ss: codemap::FileSubstr,\n+    source: @~str,\n+    +cfg: ast::crate_cfg,\n+    sess: @mut ParseSess\n+) -> T {\n+    let p = new_parser_from_source_str(\n+        sess,\n+        cfg,\n+        /*bad*/ copy name,\n+        /*bad*/ copy ss,\n+        source\n+    );\n     let r = f(p);\n     if !p.reader.is_eof() {\n         p.reader.fatal(~\"expected end-of-string\");\n@@ -160,40 +203,51 @@ pub fn next_node_id(sess: @mut ParseSess) -> node_id {\n     return rv;\n }\n \n-pub fn new_parser_from_source_str(sess: @mut ParseSess, cfg: ast::crate_cfg,\n-                              +name: ~str, +ss: codemap::FileSubstr,\n-                              source: @~str) -> Parser {\n+pub fn new_parser_from_source_str(\n+    sess: @mut ParseSess,\n+    +cfg: ast::crate_cfg,\n+    +name: ~str,\n+    +ss: codemap::FileSubstr,\n+    source: @~str\n+) -> Parser {\n     let filemap = sess.cm.new_filemap_w_substr(name, ss, source);\n-    let srdr = lexer::new_string_reader(copy sess.span_diagnostic,\n-                                        filemap,\n-                                        sess.interner);\n-    return Parser(sess, cfg, srdr as reader);\n+    let srdr = lexer::new_string_reader(\n+        copy sess.span_diagnostic,\n+        filemap,\n+        sess.interner\n+    );\n+    Parser(sess, cfg, srdr as reader)\n }\n \n /// Read the entire source file, return a parser\n /// that draws from that string\n-pub fn new_parser_result_from_file(sess: @mut ParseSess,\n-                            cfg: ast::crate_cfg,\n-                            path: &Path)\n-                         -> Result<Parser, ~str> {\n+pub fn new_parser_result_from_file(\n+    sess: @mut ParseSess,\n+    +cfg: ast::crate_cfg,\n+    path: &Path\n+) -> Result<Parser, ~str> {\n     match io::read_whole_file_str(path) {\n-      result::Ok(src) => {\n+        Ok(src) => {\n+            let filemap = sess.cm.new_filemap(path.to_str(), @src);\n+            let srdr = lexer::new_string_reader(\n+                copy sess.span_diagnostic,\n+                filemap,\n+                sess.interner\n+            );\n+            Ok(Parser(sess, cfg, srdr as reader))\n \n-          let filemap = sess.cm.new_filemap(path.to_str(), @src);\n-          let srdr = lexer::new_string_reader(copy sess.span_diagnostic,\n-                                              filemap,\n-                                              sess.interner);\n-          Ok(Parser(sess, cfg, srdr as reader))\n-\n-      }\n-      result::Err(e) => Err(e)\n+        }\n+        Err(e) => Err(e)\n     }\n }\n \n /// Create a new parser, handling errors as appropriate\n /// if the file doesn't exist\n-pub fn new_parser_from_file(sess: @mut ParseSess, cfg: ast::crate_cfg,\n-                              path: &Path) -> Parser {\n+pub fn new_parser_from_file(\n+    sess: @mut ParseSess,\n+    +cfg: ast::crate_cfg,\n+    path: &Path\n+) -> Parser {\n     match new_parser_result_from_file(sess, cfg, path) {\n         Ok(parser) => parser,\n         Err(e) => {\n@@ -204,8 +258,12 @@ pub fn new_parser_from_file(sess: @mut ParseSess, cfg: ast::crate_cfg,\n \n /// Create a new parser based on a span from an existing parser. Handles\n /// error messages correctly when the file does not exist.\n-pub fn new_sub_parser_from_file(sess: @mut ParseSess, cfg: ast::crate_cfg,\n-                            path: &Path, sp: span) -> Parser {\n+pub fn new_sub_parser_from_file(\n+    sess: @mut ParseSess,\n+    +cfg: ast::crate_cfg,\n+    path: &Path,\n+    sp: span\n+) -> Parser {\n     match new_parser_result_from_file(sess, cfg, path) {\n         Ok(parser) => parser,\n         Err(e) => {\n@@ -214,11 +272,18 @@ pub fn new_sub_parser_from_file(sess: @mut ParseSess, cfg: ast::crate_cfg,\n     }\n }\n \n-pub fn new_parser_from_tts(sess: @mut ParseSess, cfg: ast::crate_cfg,\n-                       tts: ~[ast::token_tree]) -> Parser {\n-    let trdr = lexer::new_tt_reader(copy sess.span_diagnostic, sess.interner,\n-                                    None, tts);\n-    return Parser(sess, cfg, trdr as reader)\n+pub fn new_parser_from_tts(\n+    sess: @mut ParseSess,\n+    +cfg: ast::crate_cfg,\n+    +tts: ~[ast::token_tree]\n+) -> Parser {\n+    let trdr = lexer::new_tt_reader(\n+        copy sess.span_diagnostic,\n+        sess.interner,\n+        None,\n+        tts\n+    );\n+    Parser(sess, cfg, trdr as reader)\n }\n \n // abort if necessary"}, {"sha": "2b2f1f48034a295b7fa340a8e9c413a32f96aec4", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -218,9 +218,9 @@ pub impl Parser {\n     }\n \n     fn try_parse_obsolete_priv_section() -> bool {\n-        if self.is_keyword(~\"priv\") && self.look_ahead(1) == token::LBRACE {\n-            self.obsolete(*self.span, ObsoletePrivSection);\n-            self.eat_keyword(~\"priv\");\n+        if self.is_keyword(&~\"priv\") && self.look_ahead(1) == token::LBRACE {\n+            self.obsolete(copy *self.span, ObsoletePrivSection);\n+            self.eat_keyword(&~\"priv\");\n             self.bump();\n             while *self.token != token::RBRACE {\n                 self.parse_single_class_item(ast::private);"}, {"sha": "4c48b49b5d61eab3e8a800d0f5d7687854b0a874", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 621, "deletions": 488, "changes": 1109, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c"}, {"sha": "6d0ca2c6657016827409b12b80265602a27662b3", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -117,7 +117,7 @@ pub enum nonterminal {\n     nt_matchers(~[ast::matcher])\n }\n \n-pub fn binop_to_str(o: binop) -> ~str {\n+pub pure fn binop_to_str(o: binop) -> ~str {\n     match o {\n       PLUS => ~\"+\",\n       MINUS => ~\"-\",\n@@ -132,8 +132,8 @@ pub fn binop_to_str(o: binop) -> ~str {\n     }\n }\n \n-pub fn to_str(in: @ident_interner, t: Token) -> ~str {\n-    match t {\n+pub fn to_str(in: @ident_interner, t: &Token) -> ~str {\n+    match *t {\n       EQ => ~\"=\",\n       LT => ~\"<\",\n       LE => ~\"<=\",\n@@ -181,14 +181,14 @@ pub fn to_str(in: @ident_interner, t: Token) -> ~str {\n       }\n       LIT_INT_UNSUFFIXED(i) => { i.to_str() }\n       LIT_FLOAT(s, t) => {\n-        let mut body = *in.get(s);\n+        let mut body = copy *in.get(s);\n         if body.ends_with(~\".\") {\n             body = body + ~\"0\";  // `10.f` is not a float literal\n         }\n         body + ast_util::float_ty_to_str(t)\n       }\n       LIT_FLOAT_UNSUFFIXED(s) => {\n-        let mut body = *in.get(s);\n+        let mut body = copy *in.get(s);\n         if body.ends_with(~\".\") {\n             body = body + ~\"0\";  // `10.f` is not a float literal\n         }\n@@ -197,12 +197,12 @@ pub fn to_str(in: @ident_interner, t: Token) -> ~str {\n       LIT_STR(s) => { ~\"\\\"\" + str::escape_default(*in.get(s)) + ~\"\\\"\" }\n \n       /* Name components */\n-      IDENT(s, _) => *in.get(s),\n+      IDENT(s, _) => copy *in.get(s),\n       LIFETIME(s) => fmt!(\"'%s\", *in.get(s)),\n       UNDERSCORE => ~\"_\",\n \n       /* Other */\n-      DOC_COMMENT(s) => *in.get(s),\n+      DOC_COMMENT(s) => copy *in.get(s),\n       EOF => ~\"<eof>\",\n       INTERPOLATED(ref nt) => {\n         match nt {\n@@ -227,8 +227,8 @@ pub fn to_str(in: @ident_interner, t: Token) -> ~str {\n     }\n }\n \n-pub pure fn can_begin_expr(t: Token) -> bool {\n-    match t {\n+pub pure fn can_begin_expr(t: &Token) -> bool {\n+    match *t {\n       LPAREN => true,\n       LBRACE => true,\n       LBRACKET => true,\n@@ -259,22 +259,22 @@ pub pure fn can_begin_expr(t: Token) -> bool {\n }\n \n /// what's the opposite delimiter?\n-pub fn flip_delimiter(t: token::Token) -> token::Token {\n-    match t {\n-      token::LPAREN => token::RPAREN,\n-      token::LBRACE => token::RBRACE,\n-      token::LBRACKET => token::RBRACKET,\n-      token::RPAREN => token::LPAREN,\n-      token::RBRACE => token::LBRACE,\n-      token::RBRACKET => token::LBRACKET,\n+pub fn flip_delimiter(t: &token::Token) -> token::Token {\n+    match *t {\n+      LPAREN => RPAREN,\n+      LBRACE => RBRACE,\n+      LBRACKET => RBRACKET,\n+      RPAREN => LPAREN,\n+      RBRACE => LBRACE,\n+      RBRACKET => LBRACKET,\n       _ => fail!()\n     }\n }\n \n \n \n-pub fn is_lit(t: Token) -> bool {\n-    match t {\n+pub fn is_lit(t: &Token) -> bool {\n+    match *t {\n       LIT_INT(_, _) => true,\n       LIT_UINT(_, _) => true,\n       LIT_INT_UNSUFFIXED(_) => true,\n@@ -285,23 +285,23 @@ pub fn is_lit(t: Token) -> bool {\n     }\n }\n \n-pub pure fn is_ident(t: Token) -> bool {\n-    match t { IDENT(_, _) => true, _ => false }\n+pub pure fn is_ident(t: &Token) -> bool {\n+    match *t { IDENT(_, _) => true, _ => false }\n }\n \n-pub pure fn is_ident_or_path(t: Token) -> bool {\n-    match t {\n+pub pure fn is_ident_or_path(t: &Token) -> bool {\n+    match *t {\n       IDENT(_, _) | INTERPOLATED(nt_path(*)) => true,\n       _ => false\n     }\n }\n \n-pub pure fn is_plain_ident(t: Token) -> bool {\n-    match t { IDENT(_, false) => true, _ => false }\n+pub pure fn is_plain_ident(t: &Token) -> bool {\n+    match *t { IDENT(_, false) => true, _ => false }\n }\n \n-pub pure fn is_bar(t: Token) -> bool {\n-    match t { BINOP(OR) | OROR => true, _ => false }\n+pub pure fn is_bar(t: &Token) -> bool {\n+    match *t { BINOP(OR) | OROR => true, _ => false }\n }\n \n \n@@ -478,7 +478,7 @@ pub fn temporary_keyword_table() -> HashMap<~str, ()> {\n         ~\"self\", ~\"static\",\n     ];\n     for keys.each |word| {\n-        words.insert(*word, ());\n+        words.insert(copy *word, ());\n     }\n     words\n }\n@@ -505,7 +505,7 @@ pub fn strict_keyword_table() -> HashMap<~str, ()> {\n         ~\"while\"\n     ];\n     for keys.each |word| {\n-        words.insert(*word, ());\n+        words.insert(copy *word, ());\n     }\n     words\n }\n@@ -516,7 +516,7 @@ pub fn reserved_keyword_table() -> HashMap<~str, ()> {\n         ~\"be\"\n     ];\n     for keys.each |word| {\n-        words.insert(*word, ());\n+        words.insert(copy *word, ());\n     }\n     words\n }"}, {"sha": "1dc45b1a4bd9a9573aa8164fbe2b2f0d1cd498a3", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -568,15 +568,15 @@ pub fn end(p: @mut Printer) { p.pretty_print(END); }\n pub fn eof(p: @mut Printer) { p.pretty_print(EOF); }\n \n pub fn word(p: @mut Printer, wrd: ~str) {\n-    p.pretty_print(STRING(@wrd, str::len(wrd) as int));\n+    p.pretty_print(STRING(@/*bad*/ copy wrd, wrd.len() as int));\n }\n \n pub fn huge_word(p: @mut Printer, wrd: ~str) {\n-    p.pretty_print(STRING(@wrd, size_infinity));\n+    p.pretty_print(STRING(@/*bad*/ copy wrd, size_infinity));\n }\n \n pub fn zero_word(p: @mut Printer, wrd: ~str) {\n-    p.pretty_print(STRING(@wrd, 0));\n+    p.pretty_print(STRING(@/*bad*/ copy wrd, 0));\n }\n \n pub fn spaces(p: @mut Printer, n: uint) { break_offset(p, n, 0); }"}, {"sha": "282980f0faaea132f9f6adb49463cdad85f39be0", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 76, "deletions": 75, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -40,8 +40,8 @@ use core::u64;\n use core::vec;\n \n // The @ps is stored here to prevent recursive type.\n-pub enum ann_node {\n-    node_block(@ps, ast::blk),\n+pub enum ann_node/& {\n+    node_block(@ps, &ast::blk),\n     node_item(@ps, @ast::item),\n     node_expr(@ps, @ast::expr),\n     node_pat(@ps, @ast::pat),\n@@ -110,18 +110,20 @@ pub fn print_crate(cm: @CodeMap, intr: @ident_interner,\n                    span_diagnostic: diagnostic::span_handler,\n                    crate: @ast::crate, filename: ~str, in: io::Reader,\n                    out: io::Writer, ann: pp_ann, is_expanded: bool) {\n-    let (cmnts, lits) =\n-        comments::gather_comments_and_literals(span_diagnostic,\n-                                               filename, in);\n+    let (cmnts, lits) = comments::gather_comments_and_literals(\n+        span_diagnostic,\n+        copy filename,\n+        in\n+    );\n     let s = @ps {\n         s: pp::mk_printer(out, default_columns),\n         cm: Some(cm),\n         intr: intr,\n-        comments: Some(cmnts),\n+        comments: Some(copy cmnts),\n         // If the code is post expansion, don't use the table of\n         // literals, since it doesn't correspond with the literals\n         // in the AST anymore.\n-        literals: if is_expanded { None } else { Some(lits) },\n+        literals: if is_expanded { None } else { Some(copy lits) },\n         cur_cmnt_and_lit: @mut CurrentCommentAndLiteral {\n             cur_cmnt: 0,\n             cur_lit: 0\n@@ -175,7 +177,7 @@ pub fn path_to_str(&&p: @ast::path, intr: @ident_interner) -> ~str {\n     to_str(p, |a,b| print_path(a, b, false), intr)\n }\n \n-pub fn fun_to_str(decl: ast::fn_decl, name: ast::ident,\n+pub fn fun_to_str(decl: &ast::fn_decl, name: ast::ident,\n                   generics: &ast::Generics, intr: @ident_interner) -> ~str {\n     do io::with_str_writer |wr| {\n         let s = rust_printer(wr, intr);\n@@ -186,7 +188,7 @@ pub fn fun_to_str(decl: ast::fn_decl, name: ast::ident,\n     }\n }\n \n-pub fn block_to_str(blk: ast::blk, intr: @ident_interner) -> ~str {\n+pub fn block_to_str(blk: &ast::blk, intr: @ident_interner) -> ~str {\n     do io::with_str_writer |wr| {\n         let s = rust_printer(wr, intr);\n         // containing cbox, will be closed by print-block at }\n@@ -381,7 +383,7 @@ pub fn print_type(s: @ps, &&ty: @ast::Ty) {\n pub fn print_type_ex(s: @ps, &&ty: @ast::Ty, print_colons: bool) {\n     maybe_print_comment(s, ty.span.lo);\n     ibox(s, 0u);\n-    match ty.node {\n+    match /*bad*/ copy ty.node {\n       ast::ty_nil => word(s.s, ~\"()\"),\n       ast::ty_bot => word(s.s, ~\"!\"),\n       ast::ty_box(mt) => { word(s.s, ~\"@\"); print_mt(s, mt); }\n@@ -425,12 +427,12 @@ pub fn print_type_ex(s: @ps, &&ty: @ast::Ty, print_colons: bool) {\n       }\n       ast::ty_bare_fn(f) => {\n           print_ty_fn(s, Some(f.abi), None, None,\n-                      f.purity, ast::Many, f.decl, None,\n+                      f.purity, ast::Many, &f.decl, None,\n                       None, None);\n       }\n       ast::ty_closure(f) => {\n           print_ty_fn(s, None, Some(f.sigil), f.region,\n-                      f.purity, f.onceness, f.decl, None,\n+                      f.purity, f.onceness, &f.decl, None,\n                       None, None);\n       }\n       ast::ty_path(path, _) => print_path(s, path, print_colons),\n@@ -461,8 +463,8 @@ pub fn print_foreign_item(s: @ps, item: @ast::foreign_item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n-    match item.node {\n-      ast::foreign_item_fn(decl, purity, ref generics) => {\n+    match /*bad*/ copy item.node {\n+      ast::foreign_item_fn(ref decl, purity, ref generics) => {\n         print_fn(s, decl, Some(purity), item.ident, generics, None,\n                  ast::inherited);\n         end(s); // end head-ibox\n@@ -487,7 +489,7 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n     print_outer_attributes(s, item.attrs);\n     let ann_node = node_item(s, item);\n     (s.ann.pre)(ann_node);\n-    match item.node {\n+    match /*bad*/ copy item.node {\n       ast::item_const(ty, expr) => {\n         head(s, visibility_qualified(item.vis, ~\"const\"));\n         print_ident(s, item.ident);\n@@ -505,15 +507,15 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n       ast::item_fn(ref decl, purity, ref typarams, ref body) => {\n         print_fn(\n             s,\n-            /* FIXME (#2543) */ copy *decl,\n+            decl,\n             Some(purity),\n             item.ident,\n             typarams,\n             None,\n             item.vis\n         );\n         word(s.s, ~\" \");\n-        print_block_with_attrs(s, (*body), item.attrs);\n+        print_block_with_attrs(s, body, item.attrs);\n       }\n       ast::item_mod(_mod) => {\n         head(s, visibility_qualified(item.vis, ~\"mod\"));\n@@ -568,7 +570,7 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n           print_struct(s, struct_def, generics, item.ident, item.span);\n       }\n \n-      ast::item_impl(ref generics, opt_trait, ty, methods) => {\n+      ast::item_impl(ref generics, opt_trait, ty, ref methods) => {\n         head(s, visibility_qualified(item.vis, ~\"impl\"));\n         if !generics.is_empty() {\n             print_generics(s, generics);\n@@ -610,8 +612,8 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n         }\n         word(s.s, ~\" \");\n         bopen(s);\n-        for (*methods).each |meth| {\n-            print_trait_method(s, *meth);\n+        for methods.each |meth| {\n+            print_trait_method(s, meth);\n         }\n         bclose(s, item.span);\n       }\n@@ -655,7 +657,7 @@ pub fn print_enum_def(s: @ps, enum_definition: ast::enum_def,\n     space(s.s);\n     if newtype {\n         word_space(s, ~\"=\");\n-        match enum_definition.variants[0].node.kind {\n+        match /*bad*/ copy enum_definition.variants[0].node.kind {\n             ast::tuple_variant_kind(args) => print_type(s, args[0].ty),\n             _ => fail!(~\"newtype syntax with struct?\")\n         }\n@@ -693,9 +695,8 @@ pub fn visibility_to_str(vis: ast::visibility) -> ~str {\n \n pub fn visibility_qualified(vis: ast::visibility, s: ~str) -> ~str {\n     match vis {\n-        ast::private | ast::public =>\n-        visibility_to_str(vis) + \" \" + s,\n-        ast::inherited => s\n+        ast::private | ast::public => visibility_to_str(vis) + \" \" + s,\n+        ast::inherited => copy s\n     }\n }\n \n@@ -740,7 +741,7 @@ pub fn print_struct(s: @ps,\n           maybe_print_comment(s, dtor.span.lo);\n           print_outer_attributes(s, dtor.node.attrs);\n           head(s, ~\"drop\");\n-          print_block(s, dtor.node.body);\n+          print_block(s, &dtor.node.body);\n         }\n \n         for struct_def.fields.each |field| {\n@@ -776,14 +777,14 @@ pub fn print_tt(s: @ps, tt: ast::token_tree) {\n     match tt {\n       ast::tt_delim(ref tts) => print_tts(s, *tts),\n       ast::tt_tok(_, ref tk) => {\n-          word(s.s, parse::token::to_str(s.intr, (*tk)));\n+          word(s.s, parse::token::to_str(s.intr, tk));\n       }\n       ast::tt_seq(_, ref tts, ref sep, zerok) => {\n         word(s.s, ~\"$(\");\n         for (*tts).each() |tt_elt| { print_tt(s, *tt_elt); }\n         word(s.s, ~\")\");\n         match (*sep) {\n-          Some(ref tk) => word(s.s, parse::token::to_str(s.intr, (*tk))),\n+          Some(ref tk) => word(s.s, parse::token::to_str(s.intr, tk)),\n           None => ()\n         }\n         word(s.s, if zerok { ~\"*\" } else { ~\"+\" });\n@@ -808,7 +809,7 @@ pub fn print_tts(s: @ps, &&tts: &[ast::token_tree]) {\n \n pub fn print_variant(s: @ps, v: ast::variant) {\n     print_visibility(s, v.node.vis);\n-    match v.node.kind {\n+    match /*bad*/ copy v.node.kind {\n         ast::tuple_variant_kind(args) => {\n             print_ident(s, v.node.name);\n             if !args.is_empty() {\n@@ -839,32 +840,32 @@ pub fn print_variant(s: @ps, v: ast::variant) {\n     }\n }\n \n-pub fn print_ty_method(s: @ps, m: ast::ty_method) {\n+pub fn print_ty_method(s: @ps, m: &ast::ty_method) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, m.span.lo);\n     print_outer_attributes(s, m.attrs);\n     print_ty_fn(s, None, None, None, m.purity, ast::Many,\n-                m.decl, Some(m.ident), Some(&m.generics),\n-                Some(m.self_ty.node));\n+                &m.decl, Some(m.ident), Some(&m.generics),\n+                Some(/*bad*/ copy m.self_ty.node));\n     word(s.s, ~\";\");\n }\n \n-pub fn print_trait_method(s: @ps, m: ast::trait_method) {\n-    match m {\n-      required(ref ty_m) => print_ty_method(s, (*ty_m)),\n-      provided(m)    => print_method(s, m)\n+pub fn print_trait_method(s: @ps, m: &ast::trait_method) {\n+    match *m {\n+        required(ref ty_m) => print_ty_method(s, ty_m),\n+        provided(m) => print_method(s, m)\n     }\n }\n \n pub fn print_method(s: @ps, meth: @ast::method) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, meth.span.lo);\n     print_outer_attributes(s, meth.attrs);\n-    print_fn(s, meth.decl, Some(meth.purity),\n+    print_fn(s, &meth.decl, Some(meth.purity),\n              meth.ident, &meth.generics, Some(meth.self_ty.node),\n              meth.vis);\n     word(s.s, ~\" \");\n-    print_block_with_attrs(s, meth.body, meth.attrs);\n+    print_block_with_attrs(s, &meth.body, meth.attrs);\n }\n \n pub fn print_outer_attributes(s: @ps, attrs: ~[ast::attribute]) {\n@@ -904,7 +905,7 @@ pub fn print_attribute(s: @ps, attr: ast::attribute) {\n         word(s.s, *comment);\n     } else {\n         word(s.s, ~\"#[\");\n-        print_meta_item(s, @attr.node.value);\n+        print_meta_item(s, attr.node.value);\n         word(s.s, ~\"]\");\n     }\n }\n@@ -935,22 +936,22 @@ pub fn print_stmt(s: @ps, st: ast::stmt) {\n     maybe_print_trailing_comment(s, st.span, None);\n }\n \n-pub fn print_block(s: @ps, blk: ast::blk) {\n+pub fn print_block(s: @ps, blk: &ast::blk) {\n     print_possibly_embedded_block(s, blk, block_normal, indent_unit);\n }\n \n-pub fn print_block_unclosed(s: @ps, blk: ast::blk) {\n+pub fn print_block_unclosed(s: @ps, blk: &ast::blk) {\n     print_possibly_embedded_block_(s, blk, block_normal, indent_unit, ~[],\n                                  false);\n }\n \n-pub fn print_block_unclosed_indent(s: @ps, blk: ast::blk, indented: uint) {\n+pub fn print_block_unclosed_indent(s: @ps, blk: &ast::blk, indented: uint) {\n     print_possibly_embedded_block_(s, blk, block_normal, indented, ~[],\n                                    false);\n }\n \n pub fn print_block_with_attrs(s: @ps,\n-                              blk: ast::blk,\n+                              blk: &ast::blk,\n                               attrs: ~[ast::attribute]) {\n     print_possibly_embedded_block_(s, blk, block_normal, indent_unit, attrs,\n                                   true);\n@@ -959,15 +960,15 @@ pub fn print_block_with_attrs(s: @ps,\n pub enum embed_type { block_block_fn, block_normal, }\n \n pub fn print_possibly_embedded_block(s: @ps,\n-                                     blk: ast::blk,\n+                                     blk: &ast::blk,\n                                      embedded: embed_type,\n                                      indented: uint) {\n     print_possibly_embedded_block_(\n         s, blk, embedded, indented, ~[], true);\n }\n \n pub fn print_possibly_embedded_block_(s: @ps,\n-                                      blk: ast::blk,\n+                                      blk: &ast::blk,\n                                       embedded: embed_type,\n                                       indented: uint,\n                                       attrs: ~[ast::attribute],\n@@ -1002,7 +1003,7 @@ pub fn print_possibly_embedded_block_(s: @ps,\n     (s.ann.post)(ann_node);\n }\n \n-pub fn print_if(s: @ps, test: @ast::expr, blk: ast::blk,\n+pub fn print_if(s: @ps, test: @ast::expr, blk: &ast::blk,\n                 elseopt: Option<@ast::expr>, chk: bool) {\n     head(s, ~\"if\");\n     if chk { word_nbsp(s, ~\"check\"); }\n@@ -1020,15 +1021,15 @@ pub fn print_if(s: @ps, test: @ast::expr, blk: ast::blk,\n                 word(s.s, ~\" else if \");\n                 print_expr(s, i);\n                 space(s.s);\n-                print_block(s, (*t));\n+                print_block(s, t);\n                 do_else(s, e);\n               }\n               // \"final else\"\n               ast::expr_block(ref b) => {\n                 cbox(s, indent_unit - 1u);\n                 ibox(s, 0u);\n                 word(s.s, ~\" else \");\n-                print_block(s, (*b));\n+                print_block(s, b);\n               }\n               // BLEAH, constraints would be great here\n               _ => {\n@@ -1141,7 +1142,7 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n     ibox(s, indent_unit);\n     let ann_node = node_expr(s, expr);\n     (s.ann.pre)(ann_node);\n-    match expr.node {\n+    match /*bad*/ copy expr.node {\n         ast::expr_vstore(e, v) => match v {\n             ast::expr_vstore_fixed(_) => {\n                 print_expr(s, e);\n@@ -1263,13 +1264,13 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n         print_type_ex(s, ty, true);\n       }\n       ast::expr_if(test, ref blk, elseopt) => {\n-        print_if(s, test, (*blk), elseopt, false);\n+        print_if(s, test, blk, elseopt, false);\n       }\n       ast::expr_while(test, ref blk) => {\n         head(s, ~\"while\");\n         print_expr(s, test);\n         space(s.s);\n-        print_block(s, (*blk));\n+        print_block(s, blk);\n       }\n       ast::expr_loop(ref blk, opt_ident) => {\n         head(s, ~\"loop\");\n@@ -1278,7 +1279,7 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n             print_ident(s, *ident);\n             word_space(s, ~\":\");\n         });\n-        print_block(s, (*blk));\n+        print_block(s, blk);\n       }\n       ast::expr_match(expr, ref arms) => {\n         cbox(s, match_indent_unit);\n@@ -1323,7 +1324,7 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n                             ast::expr_block(ref blk) => {\n                                 // the block will close the pattern's ibox\n                                 print_block_unclosed_indent(\n-                                    s, (*blk), match_indent_unit);\n+                                    s, blk, match_indent_unit);\n                             }\n                             _ => {\n                                 end(s); // close the ibox for the pattern\n@@ -1340,7 +1341,7 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n                 }\n             } else {\n                 // the block will close the pattern's ibox\n-                print_block_unclosed_indent(s, arm.body, match_indent_unit);\n+                print_block_unclosed_indent(s, &arm.body, match_indent_unit);\n             }\n         }\n         bclose_(s, expr.span, match_indent_unit);\n@@ -1352,29 +1353,29 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n         ibox(s, 0u);\n         print_fn_header_info(s, None, None, ast::Many,\n                              Some(sigil), ast::inherited);\n-        print_fn_args_and_ret(s, /* FIXME (#2543) */ copy *decl, None);\n+        print_fn_args_and_ret(s, decl, None);\n         space(s.s);\n-        print_block(s, (*body));\n+        print_block(s, body);\n       }\n       ast::expr_fn_block(ref decl, ref body) => {\n         // in do/for blocks we don't want to show an empty\n         // argument list, but at this point we don't know which\n         // we are inside.\n         //\n         // if !decl.inputs.is_empty() {\n-        print_fn_block_args(s, /* FIXME (#2543) */ copy *decl);\n+        print_fn_block_args(s, decl);\n         space(s.s);\n         // }\n-        assert (*body).node.stmts.is_empty();\n-        assert (*body).node.expr.is_some();\n+        assert body.node.stmts.is_empty();\n+        assert body.node.expr.is_some();\n         // we extract the block, so as not to create another set of boxes\n-        match (*body).node.expr.get().node {\n+        match body.node.expr.get().node {\n             ast::expr_block(ref blk) => {\n-                print_block_unclosed(s, (*blk));\n+                print_block_unclosed(s, blk);\n             }\n             _ => {\n                 // this is a bare expression\n-                print_expr(s, (*body).node.expr.get());\n+                print_expr(s, body.node.expr.get());\n                 end(s); // need to close a box\n             }\n         }\n@@ -1394,7 +1395,7 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n         cbox(s, indent_unit);\n         // head-box, will be closed by print-block after {\n         ibox(s, 0u);\n-        print_block(s, (*blk));\n+        print_block(s, blk);\n       }\n       ast::expr_copy(e) => { word_space(s, ~\"copy\"); print_expr(s, e); }\n       ast::expr_assign(lhs, rhs) => {\n@@ -1490,7 +1491,7 @@ pub fn print_local_decl(s: @ps, loc: @ast::local) {\n \n pub fn print_decl(s: @ps, decl: @ast::decl) {\n     maybe_print_comment(s, decl.span.lo);\n-    match decl.node {\n+    match /*bad*/ copy decl.node {\n       ast::decl_local(locs) => {\n         space_if_not_bol(s);\n         ibox(s, indent_unit);\n@@ -1574,7 +1575,7 @@ pub fn print_pat(s: @ps, &&pat: @ast::pat, refutable: bool) {\n     (s.ann.pre)(ann_node);\n     /* Pat isn't normalized, but the beauty of it\n      is that it doesn't matter */\n-    match pat.node {\n+    match /*bad*/ copy pat.node {\n       ast::pat_wild => word(s.s, ~\"_\"),\n       ast::pat_ident(binding_mode, path, sub) => {\n           if refutable {\n@@ -1711,7 +1712,7 @@ pub fn print_self_ty(s: @ps, self_ty: ast::self_ty_) -> bool {\n }\n \n pub fn print_fn(s: @ps,\n-                decl: ast::fn_decl,\n+                decl: &ast::fn_decl,\n                 purity: Option<ast::purity>,\n                 name: ast::ident,\n                 generics: &ast::Generics,\n@@ -1725,7 +1726,7 @@ pub fn print_fn(s: @ps,\n     print_fn_args_and_ret(s, decl, opt_self_ty);\n }\n \n-pub fn print_fn_args(s: @ps, decl: ast::fn_decl,\n+pub fn print_fn_args(s: @ps, decl: &ast::fn_decl,\n                  opt_self_ty: Option<ast::self_ty_>) {\n     // It is unfortunate to duplicate the commasep logic, but we we want the\n     // self type and the args all in the same box.\n@@ -1743,7 +1744,7 @@ pub fn print_fn_args(s: @ps, decl: ast::fn_decl,\n     end(s);\n }\n \n-pub fn print_fn_args_and_ret(s: @ps, decl: ast::fn_decl,\n+pub fn print_fn_args_and_ret(s: @ps, decl: &ast::fn_decl,\n                              opt_self_ty: Option<ast::self_ty_>) {\n     popen(s);\n     print_fn_args(s, decl, opt_self_ty);\n@@ -1760,7 +1761,7 @@ pub fn print_fn_args_and_ret(s: @ps, decl: ast::fn_decl,\n     }\n }\n \n-pub fn print_fn_block_args(s: @ps, decl: ast::fn_decl) {\n+pub fn print_fn_block_args(s: @ps, decl: &ast::fn_decl) {\n     word(s.s, ~\"|\");\n     print_fn_args(s, decl, None);\n     word(s.s, ~\"|\");\n@@ -1905,7 +1906,7 @@ pub fn print_view_item(s: @ps, item: @ast::view_item) {\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n     print_visibility(s, item.vis);\n-    match item.node {\n+    match /*bad*/ copy item.node {\n         ast::view_item_extern_mod(id, mta, _) => {\n             head(s, ~\"extern mod\");\n             print_ident(s, id);\n@@ -1972,7 +1973,7 @@ pub fn print_ty_fn(s: @ps,\n                    opt_region: Option<@ast::region>,\n                    purity: ast::purity,\n                    onceness: ast::Onceness,\n-                   decl: ast::fn_decl, id: Option<ast::ident>,\n+                   decl: &ast::fn_decl, id: Option<ast::ident>,\n                    generics: Option<&ast::Generics>,\n                    opt_self_ty: Option<ast::self_ty_>) {\n     ibox(s, indent_unit);\n@@ -1987,7 +1988,7 @@ pub fn print_ty_fn(s: @ps,\n     print_onceness(s, onceness);\n     word(s.s, ~\"fn\");\n     match id { Some(id) => { word(s.s, ~\" \"); print_ident(s, id); } _ => () }\n-    match generics { Some(g) => print_generics(s, g), _ => () }\n+    match /*bad*/ copy generics { Some(g) => print_generics(s, g), _ => () }\n     zerobreak(s.s);\n \n     popen(s);\n@@ -2114,7 +2115,7 @@ pub fn next_lit(s: @ps, pos: BytePos) -> Option<comments::lit> {\n     match s.literals {\n       Some(ref lits) => {\n         while s.cur_cmnt_and_lit.cur_lit < vec::len((*lits)) {\n-            let ltrl = (*lits)[s.cur_cmnt_and_lit.cur_lit];\n+            let ltrl = /*bad*/ copy (*lits)[s.cur_cmnt_and_lit.cur_lit];\n             if ltrl.pos > pos { return None; }\n             s.cur_cmnt_and_lit.cur_lit += 1u;\n             if ltrl.pos == pos { return Some(ltrl); }\n@@ -2201,7 +2202,7 @@ pub fn next_comment(s: @ps) -> Option<comments::cmnt> {\n     match s.comments {\n       Some(ref cmnts) => {\n         if s.cur_cmnt_and_lit.cur_cmnt < vec::len((*cmnts)) {\n-            return Some((*cmnts)[s.cur_cmnt_and_lit.cur_cmnt]);\n+            return Some(copy cmnts[s.cur_cmnt_and_lit.cur_cmnt]);\n         } else { return None::<comments::cmnt>; }\n       }\n       _ => return None::<comments::cmnt>\n@@ -2316,15 +2317,15 @@ pub mod test {\n         let mock_interner = parse::token::mk_fake_ident_interner();\n         let abba_ident = mock_interner.intern(@~\"abba\");\n \n-        let decl: ast::fn_decl = ast::fn_decl {\n+        let decl = ast::fn_decl {\n             inputs: ~[],\n             output: @ast::Ty {id: 0,\n                               node: ast::ty_nil,\n                               span: codemap::dummy_sp()},\n             cf: ast::return_val\n         };\n         let generics = ast_util::empty_generics();\n-        check_equal (&fun_to_str(decl, abba_ident, &generics, mock_interner),\n+        check_equal (&fun_to_str(&decl, abba_ident, &generics, mock_interner),\n                      &~\"fn abba()\");\n     }\n "}, {"sha": "5919271664e30e4bb557083e3045428cacfd3ed8", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 394, "deletions": 324, "changes": 718, "blob_url": "https://github.com/rust-lang/rust/blob/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "patch": "@@ -32,17 +32,20 @@ use core::vec;\n pub enum vt<E> { mk_vt(visitor<E>), }\n \n pub enum fn_kind {\n-    fk_item_fn(ident, Generics, purity), // fn foo()\n-    fk_method(ident, Generics, @method), // fn foo(&self)\n+    fk_item_fn(ident, &Generics, purity),   // fn foo()\n+    fk_method(ident, &Generics, &method),   // fn foo(&self)\n     fk_anon(ast::Sigil),                    // fn@(x, y) { ... }\n     fk_fn_block,                            // |x, y| ...\n-    fk_dtor(Generics, ~[attribute], node_id /* self id */,\n-            def_id /* parent class id */) // class destructor\n-\n+    fk_dtor( // class destructor\n+        &Generics,\n+        &[attribute],\n+        node_id /* self id */,\n+        def_id /* parent class id */\n+    )\n }\n \n-pub fn name_of_fn(fk: fn_kind) -> ident {\n-    match fk {\n+pub fn name_of_fn(fk: &fn_kind) -> ident {\n+    match *fk {\n       fk_item_fn(name, _, _) | fk_method(name, _, _) => {\n           /* FIXME (#2543) */ copy name\n       }\n@@ -51,38 +54,40 @@ pub fn name_of_fn(fk: fn_kind) -> ident {\n     }\n }\n \n-pub fn generics_of_fn(fk: fn_kind) -> Generics {\n-    match fk {\n-        fk_item_fn(_, tps, _) |\n-        fk_method(_, tps, _) |\n-        fk_dtor(tps, _, _, _) => {\n-            copy tps\n+pub fn generics_of_fn(fk: &fn_kind) -> Generics {\n+    match *fk {\n+        fk_item_fn(_, generics, _) |\n+        fk_method(_, generics, _) |\n+        fk_dtor(generics, _, _, _) => {\n+            copy *generics\n         }\n         fk_anon(*) | fk_fn_block(*) => {\n-            Generics {lifetimes: opt_vec::Empty,\n-                      ty_params: opt_vec::Empty}\n+            Generics {\n+                lifetimes: opt_vec::Empty,\n+                ty_params: opt_vec::Empty,\n+            }\n         }\n     }\n }\n \n pub struct Visitor<E> {\n-    visit_mod: fn@(_mod, span, node_id, E, vt<E>),\n+    visit_mod: fn@(&_mod, span, node_id, E, vt<E>),\n     visit_view_item: fn@(@view_item, E, vt<E>),\n     visit_foreign_item: fn@(@foreign_item, E, vt<E>),\n     visit_item: fn@(@item, E, vt<E>),\n     visit_local: fn@(@local, E, vt<E>),\n-    visit_block: fn@(ast::blk, E, vt<E>),\n+    visit_block: fn@(&blk, E, vt<E>),\n     visit_stmt: fn@(@stmt, E, vt<E>),\n-    visit_arm: fn@(arm, E, vt<E>),\n+    visit_arm: fn@(&arm, E, vt<E>),\n     visit_pat: fn@(@pat, E, vt<E>),\n     visit_decl: fn@(@decl, E, vt<E>),\n     visit_expr: fn@(@expr, E, vt<E>),\n     visit_expr_post: fn@(@expr, E, vt<E>),\n     visit_ty: fn@(@Ty, E, vt<E>),\n     visit_generics: fn@(&Generics, E, vt<E>),\n-    visit_fn: fn@(fn_kind, fn_decl, blk, span, node_id, E, vt<E>),\n-    visit_ty_method: fn@(ty_method, E, vt<E>),\n-    visit_trait_method: fn@(trait_method, E, vt<E>),\n+    visit_fn: fn@(&fn_kind, &fn_decl, &blk, span, node_id, E, vt<E>),\n+    visit_ty_method: fn@(&ty_method, E, vt<E>),\n+    visit_trait_method: fn@(&trait_method, E, vt<E>),\n     visit_struct_def: fn@(@struct_def, ident, &Generics, node_id, E,\n                           vt<E>),\n     visit_struct_field: fn@(@struct_field, E, vt<E>),\n@@ -118,10 +123,10 @@ pub fn default_visitor<E>() -> visitor<E> {\n }\n \n pub fn visit_crate<E>(c: crate, e: E, v: vt<E>) {\n-    (v.visit_mod)(c.node.module, c.span, crate_node_id, e, v);\n+    (v.visit_mod)(&c.node.module, c.span, crate_node_id, e, v);\n }\n \n-pub fn visit_mod<E>(m: _mod, _sp: span, _id: node_id, e: E, v: vt<E>) {\n+pub fn visit_mod<E>(m: &_mod, _sp: span, _id: node_id, e: E, v: vt<E>) {\n     for m.view_items.each |vi| { (v.visit_view_item)(*vi, e, v); }\n     for m.items.each |i| { (v.visit_item)(*i, e, v); }\n }\n@@ -139,65 +144,65 @@ pub fn visit_local<E>(loc: @local, e: E, v: vt<E>) {\n \n pub fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n     match i.node {\n-      item_const(t, ex) => {\n-        (v.visit_ty)(t, e, v);\n-        (v.visit_expr)(ex, e, v);\n-      }\n-      item_fn(ref decl, purity, ref tp, ref body) => {\n-        (v.visit_fn)(\n-            fk_item_fn(\n-                /* FIXME (#2543) */ copy i.ident,\n-                /* FIXME (#2543) */ copy *tp,\n-                purity\n-            ),\n-            /* FIXME (#2543) */ copy *decl,\n-            (*body),\n-            i.span,\n-            i.id,\n-            e,\n-            v\n-        );\n-      }\n-      item_mod(m) => (v.visit_mod)(m, i.span, i.id, e, v),\n-      item_foreign_mod(nm) => {\n-        for nm.view_items.each |vi| { (v.visit_view_item)(*vi, e, v); }\n-        for nm.items.each |ni| { (v.visit_foreign_item)(*ni, e, v); }\n-      }\n-      item_ty(t, ref tps) => {\n-        (v.visit_ty)(t, e, v);\n-        (v.visit_generics)(tps, e, v);\n-      }\n-      item_enum(ref enum_definition, ref tps) => {\n-        (v.visit_generics)(tps, e, v);\n-        visit_enum_def(\n-            *enum_definition,\n-            tps,\n-            e,\n-            v\n-        );\n-      }\n-      item_impl(ref tps, traits, ty, methods) => {\n-        (v.visit_generics)(tps, e, v);\n-        for traits.each |p| {\n-            visit_path(p.path, e, v);\n+        item_const(t, ex) => {\n+            (v.visit_ty)(t, e, v);\n+            (v.visit_expr)(ex, e, v);\n         }\n-        (v.visit_ty)(ty, e, v);\n-        for methods.each |m| {\n-            visit_method_helper(*m, e, v)\n+        item_fn(ref decl, purity, ref generics, ref body) => {\n+            (v.visit_fn)(\n+                &fk_item_fn(\n+                    /* FIXME (#2543) */ copy i.ident,\n+                    generics,\n+                    purity\n+                ),\n+                decl,\n+                body,\n+                i.span,\n+                i.id,\n+                e,\n+                v\n+            );\n         }\n-      }\n-      item_struct(struct_def, ref tps) => {\n-        (v.visit_generics)(tps, e, v);\n-        (v.visit_struct_def)(struct_def, i.ident, tps, i.id, e, v);\n-      }\n-      item_trait(ref tps, ref traits, ref methods) => {\n-        (v.visit_generics)(tps, e, v);\n-        for traits.each |p| { visit_path(p.path, e, v); }\n-        for (*methods).each |m| {\n-            (v.visit_trait_method)(*m, e, v);\n+        item_mod(ref m) => (v.visit_mod)(m, i.span, i.id, e, v),\n+        item_foreign_mod(ref nm) => {\n+            for nm.view_items.each |vi| { (v.visit_view_item)(*vi, e, v); }\n+            for nm.items.each |ni| { (v.visit_foreign_item)(*ni, e, v); }\n         }\n-      }\n-      item_mac(ref m) => visit_mac((*m), e, v)\n+        item_ty(t, ref tps) => {\n+            (v.visit_ty)(t, e, v);\n+            (v.visit_generics)(tps, e, v);\n+        }\n+        item_enum(ref enum_definition, ref tps) => {\n+            (v.visit_generics)(tps, e, v);\n+            visit_enum_def(\n+                *enum_definition,\n+                tps,\n+                e,\n+                v\n+            );\n+        }\n+        item_impl(ref tps, ref traits, ty, ref methods) => {\n+            (v.visit_generics)(tps, e, v);\n+            for traits.each |p| {\n+                visit_path(p.path, e, v);\n+        }\n+            (v.visit_ty)(ty, e, v);\n+            for methods.each |m| {\n+                visit_method_helper(*m, e, v)\n+            }\n+        }\n+        item_struct(struct_def, ref generics) => {\n+            (v.visit_generics)(generics, e, v);\n+            (v.visit_struct_def)(struct_def, i.ident, generics, i.id, e, v);\n+        }\n+        item_trait(ref generics, ref traits, ref methods) => {\n+            (v.visit_generics)(generics, e, v);\n+            for traits.each |p| { visit_path(p.path, e, v); }\n+            for methods.each |m| {\n+                (v.visit_trait_method)(m, e, v);\n+            }\n+        }\n+        item_mac(ref m) => visit_mac((*m), e, v)\n     }\n }\n \n@@ -207,7 +212,7 @@ pub fn visit_enum_def<E>(enum_definition: ast::enum_def,\n                          v: vt<E>) {\n     for enum_definition.variants.each |vr| {\n         match vr.node.kind {\n-            tuple_variant_kind(variant_args) => {\n+            tuple_variant_kind(ref variant_args) => {\n                 for variant_args.each |va| { (v.visit_ty)(va.ty, e, v); }\n             }\n             struct_variant_kind(struct_def) => {\n@@ -227,30 +232,31 @@ pub fn skip_ty<E>(_t: @Ty, _e: E, _v: vt<E>) {}\n \n pub fn visit_ty<E>(t: @Ty, e: E, v: vt<E>) {\n     match t.node {\n-      ty_box(mt) | ty_uniq(mt) |\n-      ty_vec(mt) | ty_ptr(mt) | ty_rptr(_, mt) => {\n-        (v.visit_ty)(mt.ty, e, v);\n-      }\n-      ty_rec(ref flds) => for (*flds).each |f| {\n-        (v.visit_ty)(f.node.mt.ty, e, v);\n-      },\n-      ty_tup(ts) => for ts.each |tt| {\n-        (v.visit_ty)(*tt, e, v);\n-      },\n-      ty_closure(f) => {\n-        for f.decl.inputs.each |a| { (v.visit_ty)(a.ty, e, v); }\n-        (v.visit_ty)(f.decl.output, e, v);\n-      }\n-      ty_bare_fn(f) => {\n-        for f.decl.inputs.each |a| { (v.visit_ty)(a.ty, e, v); }\n-        (v.visit_ty)(f.decl.output, e, v);\n-      }\n-      ty_path(p, _) => visit_path(p, e, v),\n-      ty_fixed_length_vec(mt, _) => (v.visit_ty)(mt.ty, e, v),\n-      ty_nil |\n-      ty_bot |\n-      ty_mac(_) |\n-      ty_infer => ()\n+        ty_box(mt) | ty_uniq(mt) |\n+        ty_vec(mt) | ty_ptr(mt) | ty_rptr(_, mt) => {\n+            (v.visit_ty)(mt.ty, e, v);\n+        },\n+        ty_rec(ref flds) => {\n+            for flds.each |f| {\n+                (v.visit_ty)(f.node.mt.ty, e, v);\n+            }\n+        },\n+        ty_tup(ref ts) => {\n+            for ts.each |tt| {\n+                (v.visit_ty)(*tt, e, v);\n+            }\n+        },\n+        ty_closure(ref f) => {\n+            for f.decl.inputs.each |a| { (v.visit_ty)(a.ty, e, v); }\n+            (v.visit_ty)(f.decl.output, e, v);\n+        },\n+        ty_bare_fn(ref f) => {\n+            for f.decl.inputs.each |a| { (v.visit_ty)(a.ty, e, v); }\n+            (v.visit_ty)(f.decl.output, e, v);\n+        },\n+        ty_path(p, _) => visit_path(p, e, v),\n+        ty_fixed_length_vec(ref mt, _) => (v.visit_ty)(mt.ty, e, v),\n+        ty_nil | ty_bot | ty_mac(_) | ty_infer => ()\n     }\n }\n \n@@ -260,55 +266,61 @@ pub fn visit_path<E>(p: @path, e: E, v: vt<E>) {\n \n pub fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n     match p.node {\n-      pat_enum(path, children) => {\n-        visit_path(path, e, v);\n-        do option::iter(&children) |children| {\n-            for children.each |child| { (v.visit_pat)(*child, e, v); }}\n-      }\n-      pat_rec(fields, _) => for fields.each |f| {\n-        (v.visit_pat)(f.pat, e, v)\n-      },\n-      pat_struct(path, fields, _) => {\n-        visit_path(path, e, v);\n-        for fields.each |f| {\n-            (v.visit_pat)(f.pat, e, v);\n+        pat_enum(path, ref children) => {\n+            visit_path(path, e, v);\n+            do children.iter |children| {\n+                for children.each |child| { (v.visit_pat)(*child, e, v); }\n+            }\n         }\n-      }\n-      pat_tup(elts) => for elts.each |elt| {\n-        (v.visit_pat)(*elt, e, v)\n-      },\n-      pat_box(inner) | pat_uniq(inner) | pat_region(inner) =>\n-          (v.visit_pat)(inner, e, v),\n-      pat_ident(_, path, inner) => {\n-          visit_path(path, e, v);\n-          do option::iter(&inner) |subpat| { (v.visit_pat)(*subpat, e, v)};\n-      }\n-      pat_lit(ex) => (v.visit_expr)(ex, e, v),\n-      pat_range(e1, e2) => {\n-        (v.visit_expr)(e1, e, v);\n-        (v.visit_expr)(e2, e, v);\n-      }\n-      pat_wild => (),\n-      pat_vec(elts, tail) => {\n-        for elts.each |elt| {\n-          (v.visit_pat)(*elt, e, v);\n+        pat_rec(ref fields, _) => {\n+            for fields.each |f| {\n+                (v.visit_pat)(f.pat, e, v)\n+            }\n+        },\n+        pat_struct(path, ref fields, _) => {\n+            visit_path(path, e, v);\n+            for fields.each |f| {\n+                (v.visit_pat)(f.pat, e, v);\n+            }\n         }\n-        do option::iter(&tail) |tail| {\n-          (v.visit_pat)(*tail, e, v);\n+        pat_tup(ref elts) => {\n+            for elts.each |elt| {\n+                (v.visit_pat)(*elt, e, v)\n+            }\n+        },\n+        pat_box(inner) | pat_uniq(inner) | pat_region(inner) => {\n+            (v.visit_pat)(inner, e, v)\n+        },\n+        pat_ident(_, path, ref inner) => {\n+            visit_path(path, e, v);\n+            do inner.iter |subpat| { (v.visit_pat)(*subpat, e, v) }\n+        }\n+        pat_lit(ex) => (v.visit_expr)(ex, e, v),\n+        pat_range(e1, e2) => {\n+            (v.visit_expr)(e1, e, v);\n+            (v.visit_expr)(e2, e, v);\n+        }\n+        pat_wild => (),\n+        pat_vec(ref elts, ref tail) => {\n+            for elts.each |elt| {\n+                (v.visit_pat)(*elt, e, v);\n+            }\n+            do tail.iter |tail| {\n+                (v.visit_pat)(*tail, e, v);\n+            }\n         }\n-      }\n     }\n }\n \n pub fn visit_foreign_item<E>(ni: @foreign_item, e: E, v: vt<E>) {\n     match ni.node {\n-      foreign_item_fn(fd, _, ref generics) => {\n-        visit_fn_decl(fd, e, v);\n-        (v.visit_generics)(generics, e, v);\n-      }\n-      foreign_item_const(t) => {\n-        (v.visit_ty)(t, e, v);\n-      }\n+        foreign_item_fn(ref fd, _, ref generics) => {\n+            visit_fn_decl(fd, e, v);\n+            (v.visit_generics)(generics, e, v);\n+        }\n+        foreign_item_const(t) => {\n+            (v.visit_ty)(t, e, v);\n+        }\n     }\n }\n \n@@ -328,7 +340,7 @@ pub fn visit_generics<E>(generics: &Generics, e: E, v: vt<E>) {\n     }\n }\n \n-pub fn visit_fn_decl<E>(fd: fn_decl, e: E, v: vt<E>) {\n+pub fn visit_fn_decl<E>(fd: &fn_decl, e: E, v: vt<E>) {\n     for fd.inputs.each |a| {\n         (v.visit_pat)(a.pat, e, v);\n         (v.visit_ty)(a.ty, e, v);\n@@ -340,54 +352,81 @@ pub fn visit_fn_decl<E>(fd: fn_decl, e: E, v: vt<E>) {\n // visit_fn() and check for fk_method().  I named this visit_method_helper()\n // because it is not a default impl of any method, though I doubt that really\n // clarifies anything. - Niko\n-pub fn visit_method_helper<E>(m: @method, e: E, v: vt<E>) {\n-    (v.visit_fn)(fk_method(m.ident, /* FIXME (#2543) */ copy m.generics, m),\n-                 m.decl, m.body, m.span, m.id, e, v);\n+pub fn visit_method_helper<E>(m: &method, e: E, v: vt<E>) {\n+    (v.visit_fn)(\n+        &fk_method(\n+            /* FIXME (#2543) */ copy m.ident,\n+            &m.generics,\n+            m\n+        ),\n+        &m.decl,\n+        &m.body,\n+        m.span,\n+        m.id,\n+        e,\n+        v\n+    );\n }\n \n pub fn visit_struct_dtor_helper<E>(dtor: struct_dtor, generics: &Generics,\n                                    parent_id: def_id, e: E, v: vt<E>) {\n-    (v.visit_fn)(fk_dtor(copy *generics, dtor.node.attrs,\n-                         dtor.node.self_id, parent_id),\n-                 ast_util::dtor_dec(),\n-                 dtor.node.body,\n-                 dtor.span,\n-                 dtor.node.id,\n-                 e, v)\n-\n-}\n-\n-pub fn visit_fn<E>(fk: fn_kind, decl: fn_decl, body: blk, _sp: span,\n+    (v.visit_fn)(\n+        &fk_dtor(\n+            generics,\n+            dtor.node.attrs,\n+            dtor.node.self_id,\n+            parent_id\n+        ),\n+        &ast_util::dtor_dec(),\n+        &dtor.node.body,\n+        dtor.span,\n+        dtor.node.id,\n+        e,\n+        v\n+    )\n+\n+}\n+\n+pub fn visit_fn<E>(fk: &fn_kind, decl: &fn_decl, body: &blk, _sp: span,\n                    _id: node_id, e: E, v: vt<E>) {\n     visit_fn_decl(decl, e, v);\n     let generics = generics_of_fn(fk);\n     (v.visit_generics)(&generics, e, v);\n     (v.visit_block)(body, e, v);\n }\n \n-pub fn visit_ty_method<E>(m: ty_method, e: E, v: vt<E>) {\n+pub fn visit_ty_method<E>(m: &ty_method, e: E, v: vt<E>) {\n     for m.decl.inputs.each |a| { (v.visit_ty)(a.ty, e, v); }\n     (v.visit_generics)(&m.generics, e, v);\n     (v.visit_ty)(m.decl.output, e, v);\n }\n \n-pub fn visit_trait_method<E>(m: trait_method, e: E, v: vt<E>) {\n-    match m {\n-      required(ref ty_m) => (v.visit_ty_method)((*ty_m), e, v),\n+pub fn visit_trait_method<E>(m: &trait_method, e: E, v: vt<E>) {\n+    match *m {\n+      required(ref ty_m) => (v.visit_ty_method)(ty_m, e, v),\n       provided(m) => visit_method_helper(m, e, v)\n     }\n }\n \n-pub fn visit_struct_def<E>(sd: @struct_def,\n-                           _nm: ast::ident,\n-                           generics: &Generics,\n-                           id: node_id,\n-                           e: E, v: vt<E>) {\n+pub fn visit_struct_def<E>(\n+    sd: @struct_def,\n+    _nm: ast::ident,\n+    generics: &Generics,\n+    id: node_id,\n+    e: E,\n+    v: vt<E>\n+) {\n     for sd.fields.each |f| {\n         (v.visit_struct_field)(*f, e, v);\n     }\n-    do option::iter(&sd.dtor) |dtor| {\n-      visit_struct_dtor_helper(*dtor, generics, ast_util::local_def(id), e, v)\n+    do sd.dtor.iter |dtor| {\n+        visit_struct_dtor_helper(\n+            *dtor,\n+            generics,\n+            ast_util::local_def(id),\n+            e,\n+            v\n+        )\n     };\n }\n \n@@ -399,7 +438,7 @@ pub fn visit_struct_method<E>(m: @method, e: E, v: vt<E>) {\n     visit_method_helper(m, e, v);\n }\n \n-pub fn visit_block<E>(b: ast::blk, e: E, v: vt<E>) {\n+pub fn visit_block<E>(b: &blk, e: E, v: vt<E>) {\n     for b.node.view_items.each |vi| {\n         (v.visit_view_item)(*vi, e, v);\n     }\n@@ -420,18 +459,20 @@ pub fn visit_stmt<E>(s: @stmt, e: E, v: vt<E>) {\n \n pub fn visit_decl<E>(d: @decl, e: E, v: vt<E>) {\n     match d.node {\n-      decl_local(locs) => for locs.each |loc| {\n-        (v.visit_local)(*loc, e, v)\n-      },\n-      decl_item(it) => (v.visit_item)(it, e, v)\n+        decl_local(ref locs) => {\n+            for locs.each |loc| {\n+                (v.visit_local)(*loc, e, v)\n+            }\n+        },\n+        decl_item(it) => (v.visit_item)(it, e, v)\n     }\n }\n \n pub fn visit_expr_opt<E>(eo: Option<@expr>, e: E, v: vt<E>) {\n     match eo { None => (), Some(ex) => (v.visit_expr)(ex, e, v) }\n }\n \n-pub fn visit_exprs<E>(exprs: ~[@expr], e: E, v: vt<E>) {\n+pub fn visit_exprs<E>(exprs: &[@expr], e: E, v: vt<E>) {\n     for exprs.each |ex| { (v.visit_expr)(*ex, e, v); }\n }\n \n@@ -441,135 +482,144 @@ pub fn visit_mac<E>(_m: mac, _e: E, _v: vt<E>) {\n \n pub fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n     match ex.node {\n-      expr_vstore(x, _) => (v.visit_expr)(x, e, v),\n-      expr_vec(es, _) => visit_exprs(es, e, v),\n-      expr_repeat(element, count, _) => {\n-        (v.visit_expr)(element, e, v);\n-        (v.visit_expr)(count, e, v);\n-      }\n-      expr_rec(ref flds, base) => {\n-        for (*flds).each |f| { (v.visit_expr)(f.node.expr, e, v); }\n-        visit_expr_opt(base, e, v);\n-      }\n-      expr_struct(p, ref flds, base) => {\n-        visit_path(p, e, v);\n-        for (*flds).each |f| { (v.visit_expr)(f.node.expr, e, v); }\n-        visit_expr_opt(base, e, v);\n-      }\n-      expr_tup(elts) => for elts.each |el| { (v.visit_expr)(*el, e, v); },\n-      expr_call(callee, args, _) => {\n-        visit_exprs(args, e, v);\n-        (v.visit_expr)(callee, e, v);\n-      }\n-      expr_method_call(callee, _, tys, args, _) => {\n-        visit_exprs(args, e, v);\n-        for tys.each |tp| { (v.visit_ty)(*tp, e, v); }\n-        (v.visit_expr)(callee, e, v);\n-      }\n-      expr_binary(_, a, b) => {\n-        (v.visit_expr)(a, e, v); (v.visit_expr)(b, e, v);\n-      }\n-      expr_addr_of(_, x) | expr_unary(_, x) |\n-      expr_loop_body(x) | expr_do_body(x) |\n-      expr_assert(x) => (v.visit_expr)(x, e, v),\n-      expr_lit(_) => (),\n-      expr_cast(x, t) => { (v.visit_expr)(x, e, v); (v.visit_ty)(t, e, v); }\n-      expr_if(x, ref b, eo) => {\n-        (v.visit_expr)(x, e, v);\n-        (v.visit_block)((*b), e, v);\n-        visit_expr_opt(eo, e, v);\n-      }\n-      expr_while(x, ref b) => {\n-        (v.visit_expr)(x, e, v);\n-        (v.visit_block)((*b), e, v);\n-      }\n-      expr_loop(ref b, _) => (v.visit_block)((*b), e, v),\n-      expr_match(x, ref arms) => {\n-        (v.visit_expr)(x, e, v);\n-        for (*arms).each |a| { (v.visit_arm)(*a, e, v); }\n-      }\n-      expr_fn(proto, ref decl, ref body, _) => {\n-        (v.visit_fn)(\n-            fk_anon(proto),\n-            /* FIXME (#2543) */ copy *decl,\n-            *body,\n-            ex.span,\n-            ex.id,\n-            e,\n-            v\n-        );\n-      }\n-      expr_fn_block(ref decl, ref body) => {\n-        (v.visit_fn)(\n-            fk_fn_block,\n-            /* FIXME (#2543) */ copy *decl,\n-            *body,\n-            ex.span,\n-            ex.id,\n-            e,\n-            v\n-        );\n-      }\n-      expr_block(ref b) => (v.visit_block)((*b), e, v),\n-      expr_assign(a, b) => {\n-        (v.visit_expr)(b, e, v);\n-        (v.visit_expr)(a, e, v);\n-      }\n-      expr_copy(a) => (v.visit_expr)(a, e, v),\n-      expr_swap(a, b) => { (v.visit_expr)(a, e, v); (v.visit_expr)(b, e, v); }\n-      expr_assign_op(_, a, b) => {\n-        (v.visit_expr)(b, e, v);\n-        (v.visit_expr)(a, e, v);\n-      }\n-      expr_field(x, _, tys) => {\n-        (v.visit_expr)(x, e, v);\n-        for tys.each |tp| { (v.visit_ty)(*tp, e, v); }\n-      }\n-      expr_index(a, b) => {\n-        (v.visit_expr)(a, e, v);\n-        (v.visit_expr)(b, e, v);\n-      }\n-      expr_path(p) => visit_path(p, e, v),\n-      expr_break(_) => (),\n-      expr_again(_) => (),\n-      expr_ret(eo) => visit_expr_opt(eo, e, v),\n-      expr_log(_, lv, x) => {\n-        (v.visit_expr)(lv, e, v);\n-        (v.visit_expr)(x, e, v);\n-      }\n-      expr_mac(ref mac) => visit_mac((*mac), e, v),\n-      expr_paren(x) => (v.visit_expr)(x, e, v),\n+        expr_vstore(x, _) => (v.visit_expr)(x, e, v),\n+        expr_vec(ref es, _) => visit_exprs(*es, e, v),\n+        expr_repeat(element, count, _) => {\n+            (v.visit_expr)(element, e, v);\n+            (v.visit_expr)(count, e, v);\n+        }\n+        expr_rec(ref flds, base) => {\n+            for flds.each |f| { (v.visit_expr)(f.node.expr, e, v); }\n+            visit_expr_opt(base, e, v);\n+        }\n+        expr_struct(p, ref flds, base) => {\n+            visit_path(p, e, v);\n+            for flds.each |f| { (v.visit_expr)(f.node.expr, e, v); }\n+            visit_expr_opt(base, e, v);\n+        }\n+        expr_tup(ref elts) => {\n+            for elts.each |el| { (v.visit_expr)(*el, e, v) }\n+        }\n+        expr_call(callee, ref args, _) => {\n+            visit_exprs(*args, e, v);\n+            (v.visit_expr)(callee, e, v);\n+        }\n+        expr_method_call(callee, _, ref tys, ref args, _) => {\n+            visit_exprs(*args, e, v);\n+            for tys.each |tp| { (v.visit_ty)(*tp, e, v); }\n+            (v.visit_expr)(callee, e, v);\n+        }\n+        expr_binary(_, a, b) => {\n+            (v.visit_expr)(a, e, v);\n+            (v.visit_expr)(b, e, v);\n+        }\n+        expr_addr_of(_, x) | expr_unary(_, x) |\n+        expr_loop_body(x) | expr_do_body(x) |\n+        expr_assert(x) => (v.visit_expr)(x, e, v),\n+        expr_lit(_) => (),\n+        expr_cast(x, t) => {\n+            (v.visit_expr)(x, e, v);\n+            (v.visit_ty)(t, e, v);\n+        }\n+        expr_if(x, ref b, eo) => {\n+            (v.visit_expr)(x, e, v);\n+            (v.visit_block)(b, e, v);\n+            visit_expr_opt(eo, e, v);\n+        }\n+        expr_while(x, ref b) => {\n+            (v.visit_expr)(x, e, v);\n+            (v.visit_block)(b, e, v);\n+        }\n+        expr_loop(ref b, _) => (v.visit_block)(b, e, v),\n+        expr_match(x, ref arms) => {\n+            (v.visit_expr)(x, e, v);\n+            for arms.each |a| { (v.visit_arm)(a, e, v); }\n+        }\n+        expr_fn(proto, ref decl, ref body, _) => {\n+            (v.visit_fn)(\n+                &fk_anon(proto),\n+                decl,\n+                body,\n+                ex.span,\n+                ex.id,\n+                e,\n+                v\n+            );\n+        }\n+        expr_fn_block(ref decl, ref body) => {\n+            (v.visit_fn)(\n+                &fk_fn_block,\n+                decl,\n+                body,\n+                ex.span,\n+                ex.id,\n+                e,\n+                v\n+            );\n+        }\n+        expr_block(ref b) => (v.visit_block)(b, e, v),\n+        expr_assign(a, b) => {\n+            (v.visit_expr)(b, e, v);\n+            (v.visit_expr)(a, e, v);\n+        }\n+        expr_copy(a) => (v.visit_expr)(a, e, v),\n+        expr_swap(a, b) => {\n+            (v.visit_expr)(a, e, v);\n+            (v.visit_expr)(b, e, v);\n+        }\n+        expr_assign_op(_, a, b) => {\n+            (v.visit_expr)(b, e, v);\n+            (v.visit_expr)(a, e, v);\n+        }\n+        expr_field(x, _, ref tys) => {\n+            (v.visit_expr)(x, e, v);\n+            for tys.each |tp| { (v.visit_ty)(*tp, e, v); }\n+        }\n+        expr_index(a, b) => {\n+            (v.visit_expr)(a, e, v);\n+            (v.visit_expr)(b, e, v);\n+        }\n+        expr_path(p) => visit_path(p, e, v),\n+        expr_break(_) => (),\n+        expr_again(_) => (),\n+        expr_ret(eo) => visit_expr_opt(eo, e, v),\n+        expr_log(_, lv, x) => {\n+            (v.visit_expr)(lv, e, v);\n+            (v.visit_expr)(x, e, v);\n+        }\n+        expr_mac(ref mac) => visit_mac((*mac), e, v),\n+        expr_paren(x) => (v.visit_expr)(x, e, v),\n     }\n     (v.visit_expr_post)(ex, e, v);\n }\n \n-pub fn visit_arm<E>(a: arm, e: E, v: vt<E>) {\n+pub fn visit_arm<E>(a: &arm, e: E, v: vt<E>) {\n     for a.pats.each |p| { (v.visit_pat)(*p, e, v); }\n     visit_expr_opt(a.guard, e, v);\n-    (v.visit_block)(a.body, e, v);\n+    (v.visit_block)(&a.body, e, v);\n }\n \n // Simpler, non-context passing interface. Always walks the whole tree, simply\n // calls the given functions on the nodes.\n \n pub struct SimpleVisitor {\n-    visit_mod: fn@(_mod, span, node_id),\n+    visit_mod: fn@(&_mod, span, node_id),\n     visit_view_item: fn@(@view_item),\n     visit_foreign_item: fn@(@foreign_item),\n     visit_item: fn@(@item),\n     visit_local: fn@(@local),\n-    visit_block: fn@(ast::blk),\n+    visit_block: fn@(&blk),\n     visit_stmt: fn@(@stmt),\n-    visit_arm: fn@(arm),\n+    visit_arm: fn@(&arm),\n     visit_pat: fn@(@pat),\n     visit_decl: fn@(@decl),\n     visit_expr: fn@(@expr),\n     visit_expr_post: fn@(@expr),\n     visit_ty: fn@(@Ty),\n     visit_generics: fn@(&Generics),\n-    visit_fn: fn@(fn_kind, fn_decl, blk, span, node_id),\n-    visit_ty_method: fn@(ty_method),\n-    visit_trait_method: fn@(trait_method),\n+    visit_fn: fn@(&fn_kind, &fn_decl, &blk, span, node_id),\n+    visit_ty_method: fn@(&ty_method),\n+    visit_trait_method: fn@(&trait_method),\n     visit_struct_def: fn@(@struct_def, ident, &Generics, node_id),\n     visit_struct_field: fn@(@struct_field),\n     visit_struct_method: fn@(@method)\n@@ -580,34 +630,41 @@ pub type simple_visitor = @SimpleVisitor;\n pub fn simple_ignore_ty(_t: @Ty) {}\n \n pub fn default_simple_visitor() -> @SimpleVisitor {\n-    return @SimpleVisitor {visit_mod: |_m: _mod, _sp: span, _id: node_id| { },\n-          visit_view_item: |_vi: @view_item| { },\n-          visit_foreign_item: |_ni: @foreign_item| { },\n-          visit_item: |_i: @item| { },\n-          visit_local: |_l: @local| { },\n-          visit_block: |_b: ast::blk| { },\n-          visit_stmt: |_s: @stmt| { },\n-          visit_arm: |_a: arm| { },\n-          visit_pat: |_p: @pat| { },\n-          visit_decl: |_d: @decl| { },\n-          visit_expr: |_e: @expr| { },\n-          visit_expr_post: |_e: @expr| { },\n-          visit_ty: simple_ignore_ty,\n-          visit_generics: fn@(_ps: &Generics) {},\n-          visit_fn: fn@(_fk: fn_kind, _d: fn_decl, _b: blk, _sp: span,\n-                        _id: node_id) { },\n-          visit_ty_method: fn@(_m: ty_method) { },\n-          visit_trait_method: fn@(_m: trait_method) { },\n-          visit_struct_def: fn@(_sd: @struct_def, _nm: ident,\n-                                _generics: &Generics, _id: node_id) { },\n-          visit_struct_field: fn@(_f: @struct_field) { },\n-          visit_struct_method: fn@(_m: @method) { }\n-         };\n+    @SimpleVisitor {\n+        visit_mod: |_m, _sp, _id| { },\n+        visit_view_item: |_vi| { },\n+        visit_foreign_item: |_ni| { },\n+        visit_item: |_i| { },\n+        visit_local: |_l| { },\n+        visit_block: |_b| { },\n+        visit_stmt: |_s| { },\n+        visit_arm: |_a| { },\n+        visit_pat: |_p| { },\n+        visit_decl: |_d| { },\n+        visit_expr: |_e| { },\n+        visit_expr_post: |_e| { },\n+        visit_ty: simple_ignore_ty,\n+        visit_generics: fn@(_ps: &Generics) { },\n+        visit_fn: fn@(_fk: &fn_kind, _d: &fn_decl, _b: &blk, _sp: span,\n+                      _id: node_id) { },\n+        visit_ty_method: fn@(_m: &ty_method) { },\n+        visit_trait_method: fn@(_m: &trait_method) { },\n+        visit_struct_def: fn@(_sd: @struct_def, _nm: ident,\n+                              _generics: &Generics, _id: node_id) { },\n+        visit_struct_field: fn@(_f: @struct_field) { },\n+        visit_struct_method: fn@(_m: @method) { }\n+    }\n }\n \n pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n-    fn v_mod(f: fn@(_mod, span, node_id), m: _mod, sp: span, id: node_id,\n-             &&e: (), v: vt<()>) {\n+    fn v_mod(\n+        f: fn@(&_mod, span, node_id),\n+        m: &_mod,\n+        sp: span,\n+        id: node_id,\n+        &&e: (),\n+        v: vt<()>\n+    ) {\n         f(m, sp, id);\n         visit_mod(m, sp, id, e, v);\n     }\n@@ -628,15 +685,15 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         f(l);\n         visit_local(l, e, v);\n     }\n-    fn v_block(f: fn@(ast::blk), bl: ast::blk, &&e: (), v: vt<()>) {\n+    fn v_block(f: fn@(&blk), bl: &blk, &&e: (), v: vt<()>) {\n         f(bl);\n         visit_block(bl, e, v);\n     }\n     fn v_stmt(f: fn@(@stmt), st: @stmt, &&e: (), v: vt<()>) {\n         f(st);\n         visit_stmt(st, e, v);\n     }\n-    fn v_arm(f: fn@(arm), a: arm, &&e: (), v: vt<()>) {\n+    fn v_arm(f: fn@(&arm), a: &arm, &&e: (), v: vt<()>) {\n         f(a);\n         visit_arm(a, e, v);\n     }\n@@ -659,33 +716,46 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         f(ty);\n         visit_ty(ty, e, v);\n     }\n-    fn v_ty_method(f: fn@(ty_method), ty: ty_method, &&e: (), v: vt<()>) {\n+    fn v_ty_method(f: fn@(&ty_method), ty: &ty_method, &&e: (), v: vt<()>) {\n         f(ty);\n         visit_ty_method(ty, e, v);\n     }\n-    fn v_trait_method(f: fn@(trait_method), m: trait_method, &&e: (),\n+    fn v_trait_method(f: fn@(&trait_method), m: &trait_method, &&e: (),\n                       v: vt<()>) {\n         f(m);\n         visit_trait_method(m, e, v);\n     }\n-    fn v_struct_def(f: fn@(@struct_def, ident, &Generics, node_id),\n-                    sd: @struct_def,\n-                    nm: ident,\n-                    generics: &Generics,\n-                    id: node_id,\n-                    &&e: (), v: vt<()>) {\n+    fn v_struct_def(\n+        f: fn@(@struct_def, ident, &Generics, node_id),\n+        sd: @struct_def,\n+        nm: ident,\n+        generics: &Generics,\n+        id: node_id,\n+        &&e: (),\n+        v: vt<()>\n+    ) {\n         f(sd, nm, generics, id);\n         visit_struct_def(sd, nm, generics, id, e, v);\n     }\n-    fn v_generics(f: fn@(&Generics),\n-                  ps: &Generics,\n-                  &&e: (), v: vt<()>) {\n+    fn v_generics(\n+        f: fn@(&Generics),\n+        ps: &Generics,\n+        &&e: (),\n+        v: vt<()>\n+    ) {\n         f(ps);\n         visit_generics(ps, e, v);\n     }\n-    fn v_fn(f: fn@(fn_kind, fn_decl, blk, span, node_id),\n-            fk: fn_kind, decl: fn_decl, body: blk, sp: span,\n-            id: node_id, &&e: (), v: vt<()>) {\n+    fn v_fn(\n+        f: fn@(&fn_kind, &fn_decl, &blk, span, node_id),\n+        fk: &fn_kind,\n+        decl: &fn_decl,\n+        body: &blk,\n+        sp: span,\n+        id: node_id,\n+        &&e: (),\n+        v: vt<()>\n+    ) {\n         f(fk, decl, body, sp, id);\n         visit_fn(fk, decl, body, sp, id, e, v);\n     }"}]}