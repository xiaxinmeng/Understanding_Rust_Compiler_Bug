{"sha": "266b14d4b5b44d1491e50c7aa2ed4b85020796e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2NmIxNGQ0YjViNDRkMTQ5MWU1MGM3YWEyZWQ0Yjg1MDIwNzk2ZTE=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-12-29T18:35:21Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-12-29T18:51:06Z"}, "message": "Refactor mbe parsing code", "tree": {"sha": "e5a76f841673e063538eb2a590d4233d5a5e5d11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5a76f841673e063538eb2a590d4233d5a5e5d11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/266b14d4b5b44d1491e50c7aa2ed4b85020796e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/266b14d4b5b44d1491e50c7aa2ed4b85020796e1", "html_url": "https://github.com/rust-lang/rust/commit/266b14d4b5b44d1491e50c7aa2ed4b85020796e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/266b14d4b5b44d1491e50c7aa2ed4b85020796e1/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77ad203a719be074e81485af7a4fb02fac6cbf61", "url": "https://api.github.com/repos/rust-lang/rust/commits/77ad203a719be074e81485af7a4fb02fac6cbf61", "html_url": "https://github.com/rust-lang/rust/commit/77ad203a719be074e81485af7a4fb02fac6cbf61"}], "stats": {"total": 175, "additions": 99, "deletions": 76}, "files": [{"sha": "7878faaa4c665d47187ad031902e674c542dee94", "filename": "crates/mbe/src/lib.rs", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/266b14d4b5b44d1491e50c7aa2ed4b85020796e1/crates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266b14d4b5b44d1491e50c7aa2ed4b85020796e1/crates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Flib.rs?ref=266b14d4b5b44d1491e50c7aa2ed4b85020796e1", "patch": "@@ -14,10 +14,10 @@ mod tests;\n \n use std::fmt;\n \n-pub use tt::{Delimiter, Punct};\n+pub use tt::{Delimiter, DelimiterKind, Punct};\n \n use crate::{\n-    parser::{parse_pattern, Op},\n+    parser::{parse_pattern, parse_template, Op},\n     tt_iter::TtIter,\n };\n \n@@ -78,8 +78,24 @@ pub struct MacroRules {\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n struct Rule {\n-    lhs: tt::Subtree,\n-    rhs: tt::Subtree,\n+    lhs: MetaTemplate,\n+    rhs: MetaTemplate,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+struct MetaTemplate {\n+    delimiter: Option<Delimiter>,\n+    tokens: Vec<Result<Op, ExpandError>>,\n+}\n+\n+impl<'a> MetaTemplate {\n+    fn iter(&self) -> impl Iterator<Item = &Result<Op, ExpandError>> {\n+        self.tokens.iter()\n+    }\n+\n+    fn delimiter_kind(&self) -> Option<DelimiterKind> {\n+        self.delimiter.map(|it| it.kind)\n+    }\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n@@ -167,7 +183,7 @@ impl MacroRules {\n             rules.push(rule);\n             if let Err(()) = src.expect_char(';') {\n                 if src.len() > 0 {\n-                    return Err(ParseError::Expected(\"expected `:`\".to_string()));\n+                    return Err(ParseError::Expected(\"expected `;`\".to_string()));\n                 }\n                 break;\n             }\n@@ -213,34 +229,38 @@ impl Rule {\n             .map_err(|()| ParseError::Expected(\"expected subtree\".to_string()))?\n             .clone();\n         rhs.delimiter = None;\n+\n+        let lhs = MetaTemplate { tokens: parse_pattern(&lhs), delimiter: None };\n+        let rhs = MetaTemplate { tokens: parse_template(&rhs), delimiter: None };\n+\n         Ok(crate::Rule { lhs, rhs })\n     }\n }\n \n-fn to_parse_error(e: ExpandError) -> ParseError {\n+fn to_parse_error(e: &ExpandError) -> ParseError {\n     let msg = match e {\n         ExpandError::InvalidRepeat => \"invalid repeat\".to_string(),\n         _ => \"invalid macro definition\".to_string(),\n     };\n     ParseError::Expected(msg)\n }\n \n-fn validate(pattern: &tt::Subtree) -> Result<(), ParseError> {\n-    for op in parse_pattern(pattern) {\n-        let op = op.map_err(to_parse_error)?;\n+fn validate(pattern: &MetaTemplate) -> Result<(), ParseError> {\n+    for op in pattern.iter() {\n+        let op = op.as_ref().map_err(|e| to_parse_error(&e))?;\n \n         match op {\n-            Op::TokenTree(tt::TokenTree::Subtree(subtree)) => validate(subtree)?,\n+            Op::Subtree(subtree) => validate(&subtree)?,\n             Op::Repeat { subtree, separator, .. } => {\n                 // Checks that no repetition which could match an empty token\n                 // https://github.com/rust-lang/rust/blob/a58b1ed44f5e06976de2bdc4d7dc81c36a96934f/src/librustc_expand/mbe/macro_rules.rs#L558\n \n                 if separator.is_none() {\n-                    if parse_pattern(subtree).all(|child_op| {\n-                        match child_op.map_err(to_parse_error) {\n+                    if subtree.iter().all(|child_op| {\n+                        match child_op.as_ref().map_err(to_parse_error) {\n                             Ok(Op::Var { kind, .. }) => {\n                                 // vis is optional\n-                                if kind.map_or(false, |it| it == \"vis\") {\n+                                if kind.as_ref().map_or(false, |it| it == \"vis\") {\n                                     return true;\n                                 }\n                             }"}, {"sha": "ab5f87c487ce6b910fdff0eb7ac6012340a7803f", "filename": "crates/mbe/src/mbe_expander/matcher.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/266b14d4b5b44d1491e50c7aa2ed4b85020796e1/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266b14d4b5b44d1491e50c7aa2ed4b85020796e1/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs?ref=266b14d4b5b44d1491e50c7aa2ed4b85020796e1", "patch": "@@ -2,10 +2,10 @@\n \n use crate::{\n     mbe_expander::{Binding, Bindings, Fragment},\n-    parser::{parse_pattern, Op, RepeatKind, Separator},\n+    parser::{Op, RepeatKind, Separator},\n     subtree_source::SubtreeTokenSource,\n     tt_iter::TtIter,\n-    ExpandError,\n+    ExpandError, MetaTemplate,\n };\n \n use super::ExpandResult;\n@@ -83,7 +83,7 @@ impl Match {\n // sense to try using it. Matching errors are added to the `Match`. It might\n // make sense to make pattern parsing a separate step?\n \n-pub(super) fn match_(pattern: &tt::Subtree, src: &tt::Subtree) -> Result<Match, ExpandError> {\n+pub(super) fn match_(pattern: &MetaTemplate, src: &tt::Subtree) -> Result<Match, ExpandError> {\n     assert!(pattern.delimiter == None);\n \n     let mut res = Match::default();\n@@ -101,12 +101,12 @@ pub(super) fn match_(pattern: &tt::Subtree, src: &tt::Subtree) -> Result<Match,\n \n fn match_subtree(\n     res: &mut Match,\n-    pattern: &tt::Subtree,\n+    pattern: &MetaTemplate,\n     src: &mut TtIter,\n ) -> Result<(), ExpandError> {\n-    for op in parse_pattern(pattern) {\n-        match op? {\n-            Op::TokenTree(tt::TokenTree::Leaf(lhs)) => {\n+    for op in pattern.iter() {\n+        match op.as_ref().map_err(|err| err.clone())? {\n+            Op::Leaf(lhs) => {\n                 let rhs = match src.expect_leaf() {\n                     Ok(l) => l,\n                     Err(()) => {\n@@ -132,7 +132,7 @@ fn match_subtree(\n                     }\n                 }\n             }\n-            Op::TokenTree(tt::TokenTree::Subtree(lhs)) => {\n+            Op::Subtree(lhs) => {\n                 let rhs = match src.expect_subtree() {\n                     Ok(s) => s,\n                     Err(()) => {\n@@ -172,7 +172,7 @@ fn match_subtree(\n                 }\n             }\n             Op::Repeat { subtree, kind, separator } => {\n-                match_repeat(res, subtree, kind, separator, src)?;\n+                match_repeat(res, subtree, *kind, separator, src)?;\n             }\n         }\n     }\n@@ -372,9 +372,9 @@ impl<'a> TtIter<'a> {\n \n pub(super) fn match_repeat(\n     res: &mut Match,\n-    pattern: &tt::Subtree,\n+    pattern: &MetaTemplate,\n     kind: RepeatKind,\n-    separator: Option<Separator>,\n+    separator: &Option<Separator>,\n     src: &mut TtIter,\n ) -> Result<(), ExpandError> {\n     // Dirty hack to make macro-expansion terminate.\n@@ -489,12 +489,12 @@ fn match_meta_var(kind: &str, input: &mut TtIter) -> ExpandResult<Option<Fragmen\n     result.map(|tt| if kind == \"expr\" { tt.map(Fragment::Ast) } else { tt.map(Fragment::Tokens) })\n }\n \n-fn collect_vars(buf: &mut Vec<SmolStr>, pattern: &tt::Subtree) -> Result<(), ExpandError> {\n-    for op in parse_pattern(pattern) {\n-        match op? {\n+fn collect_vars(buf: &mut Vec<SmolStr>, pattern: &MetaTemplate) -> Result<(), ExpandError> {\n+    for op in pattern.iter() {\n+        match op.as_ref().map_err(|e| e.clone())? {\n             Op::Var { name, .. } => buf.push(name.clone()),\n-            Op::TokenTree(tt::TokenTree::Leaf(_)) => (),\n-            Op::TokenTree(tt::TokenTree::Subtree(subtree)) => collect_vars(buf, subtree)?,\n+            Op::Leaf(_) => (),\n+            Op::Subtree(subtree) => collect_vars(buf, subtree)?,\n             Op::Repeat { subtree, .. } => collect_vars(buf, subtree)?,\n         }\n     }"}, {"sha": "7205312371d16686392dac48c7921e0d75b52258", "filename": "crates/mbe/src/mbe_expander/transcriber.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/266b14d4b5b44d1491e50c7aa2ed4b85020796e1/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266b14d4b5b44d1491e50c7aa2ed4b85020796e1/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs?ref=266b14d4b5b44d1491e50c7aa2ed4b85020796e1", "patch": "@@ -6,8 +6,8 @@ use syntax::SmolStr;\n use super::ExpandResult;\n use crate::{\n     mbe_expander::{Binding, Bindings, Fragment},\n-    parser::{parse_template, Op, RepeatKind, Separator},\n-    ExpandError,\n+    parser::{Op, RepeatKind, Separator},\n+    ExpandError, MetaTemplate,\n };\n \n impl Bindings {\n@@ -50,7 +50,10 @@ impl Bindings {\n     }\n }\n \n-pub(super) fn transcribe(template: &tt::Subtree, bindings: &Bindings) -> ExpandResult<tt::Subtree> {\n+pub(super) fn transcribe(\n+    template: &MetaTemplate,\n+    bindings: &Bindings,\n+) -> ExpandResult<tt::Subtree> {\n     assert!(template.delimiter == None);\n     let mut ctx = ExpandCtx { bindings: &bindings, nesting: Vec::new() };\n     let mut arena: Vec<tt::TokenTree> = Vec::new();\n@@ -76,35 +79,35 @@ struct ExpandCtx<'a> {\n \n fn expand_subtree(\n     ctx: &mut ExpandCtx,\n-    template: &tt::Subtree,\n+    template: &MetaTemplate,\n     arena: &mut Vec<tt::TokenTree>,\n ) -> ExpandResult<tt::Subtree> {\n     // remember how many elements are in the arena now - when returning, we want to drain exactly how many elements we added. This way, the recursive uses of the arena get their own \"view\" of the arena, but will reuse the allocation\n     let start_elements = arena.len();\n     let mut err = None;\n-    for op in parse_template(template) {\n+    for op in template.iter() {\n         let op = match op {\n             Ok(op) => op,\n             Err(e) => {\n-                err = Some(e);\n+                err = Some(e.clone());\n                 break;\n             }\n         };\n         match op {\n-            Op::TokenTree(tt @ tt::TokenTree::Leaf(..)) => arena.push(tt.clone()),\n-            Op::TokenTree(tt::TokenTree::Subtree(tt)) => {\n-                let ExpandResult { value: tt, err: e } = expand_subtree(ctx, tt, arena);\n+            Op::Leaf(tt) => arena.push(tt.clone().into()),\n+            Op::Subtree(tt) => {\n+                let ExpandResult { value: tt, err: e } = expand_subtree(ctx, &tt, arena);\n                 err = err.or(e);\n                 arena.push(tt.into());\n             }\n             Op::Var { name, .. } => {\n-                let ExpandResult { value: fragment, err: e } = expand_var(ctx, name);\n+                let ExpandResult { value: fragment, err: e } = expand_var(ctx, &name);\n                 err = err.or(e);\n                 push_fragment(arena, fragment);\n             }\n             Op::Repeat { subtree, kind, separator } => {\n                 let ExpandResult { value: fragment, err: e } =\n-                    expand_repeat(ctx, subtree, kind, separator, arena);\n+                    expand_repeat(ctx, subtree, *kind, separator, arena);\n                 err = err.or(e);\n                 push_fragment(arena, fragment)\n             }\n@@ -161,9 +164,9 @@ fn expand_var(ctx: &mut ExpandCtx, v: &SmolStr) -> ExpandResult<Fragment> {\n \n fn expand_repeat(\n     ctx: &mut ExpandCtx,\n-    template: &tt::Subtree,\n+    template: &MetaTemplate,\n     kind: RepeatKind,\n-    separator: Option<Separator>,\n+    separator: &Option<Separator>,\n     arena: &mut Vec<tt::TokenTree>,\n ) -> ExpandResult<Fragment> {\n     let mut buf: Vec<tt::TokenTree> = Vec::new();"}, {"sha": "2f3ebc831397675f95741762ac11eaa3280acb50", "filename": "crates/mbe/src/parser.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/266b14d4b5b44d1491e50c7aa2ed4b85020796e1/crates%2Fmbe%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266b14d4b5b44d1491e50c7aa2ed4b85020796e1/crates%2Fmbe%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fparser.rs?ref=266b14d4b5b44d1491e50c7aa2ed4b85020796e1", "patch": "@@ -4,16 +4,17 @@\n use smallvec::SmallVec;\n use syntax::SmolStr;\n \n-use crate::{tt_iter::TtIter, ExpandError};\n+use crate::{tt_iter::TtIter, ExpandError, MetaTemplate};\n \n-#[derive(Debug)]\n-pub(crate) enum Op<'a> {\n-    Var { name: &'a SmolStr, kind: Option<&'a SmolStr> },\n-    Repeat { subtree: &'a tt::Subtree, kind: RepeatKind, separator: Option<Separator> },\n-    TokenTree(&'a tt::TokenTree),\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub(crate) enum Op {\n+    Var { name: SmolStr, kind: Option<SmolStr> },\n+    Repeat { subtree: MetaTemplate, kind: RepeatKind, separator: Option<Separator> },\n+    Leaf(tt::Leaf),\n+    Subtree(MetaTemplate),\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub(crate) enum RepeatKind {\n     ZeroOrMore,\n     OneOrMore,\n@@ -45,16 +46,12 @@ impl PartialEq for Separator {\n     }\n }\n \n-pub(crate) fn parse_template(\n-    template: &tt::Subtree,\n-) -> impl Iterator<Item = Result<Op<'_>, ExpandError>> {\n-    parse_inner(template, Mode::Template)\n+pub(crate) fn parse_template(template: &tt::Subtree) -> Vec<Result<Op, ExpandError>> {\n+    parse_inner(&template, Mode::Template)\n }\n \n-pub(crate) fn parse_pattern(\n-    pattern: &tt::Subtree,\n-) -> impl Iterator<Item = Result<Op<'_>, ExpandError>> {\n-    parse_inner(pattern, Mode::Pattern)\n+pub(crate) fn parse_pattern(pattern: &tt::Subtree) -> Vec<Result<Op, ExpandError>> {\n+    parse_inner(&pattern, Mode::Pattern)\n }\n \n #[derive(Clone, Copy)]\n@@ -63,12 +60,13 @@ enum Mode {\n     Template,\n }\n \n-fn parse_inner(src: &tt::Subtree, mode: Mode) -> impl Iterator<Item = Result<Op<'_>, ExpandError>> {\n-    let mut src = TtIter::new(src);\n+fn parse_inner(tt: &tt::Subtree, mode: Mode) -> Vec<Result<Op, ExpandError>> {\n+    let mut src = TtIter::new(&tt);\n     std::iter::from_fn(move || {\n         let first = src.next()?;\n         Some(next_op(first, &mut src, mode))\n     })\n+    .collect()\n }\n \n macro_rules! err {\n@@ -83,21 +81,20 @@ macro_rules! bail {\n     };\n }\n \n-fn next_op<'a>(\n-    first: &'a tt::TokenTree,\n-    src: &mut TtIter<'a>,\n-    mode: Mode,\n-) -> Result<Op<'a>, ExpandError> {\n+fn next_op<'a>(first: &tt::TokenTree, src: &mut TtIter<'a>, mode: Mode) -> Result<Op, ExpandError> {\n     let res = match first {\n-        tt::TokenTree::Leaf(tt::Leaf::Punct(tt::Punct { char: '$', .. })) => {\n+        tt::TokenTree::Leaf(leaf @ tt::Leaf::Punct(tt::Punct { char: '$', .. })) => {\n             // Note that the '$' itself is a valid token inside macro_rules.\n             let second = match src.next() {\n-                None => return Ok(Op::TokenTree(first)),\n+                None => return Ok(Op::Leaf(leaf.clone())),\n                 Some(it) => it,\n             };\n             match second {\n                 tt::TokenTree::Subtree(subtree) => {\n                     let (separator, kind) = parse_repeat(src)?;\n+                    let delimiter = subtree.delimiter;\n+                    let tokens = parse_inner(&subtree, mode);\n+                    let subtree = MetaTemplate { tokens, delimiter };\n                     Op::Repeat { subtree, separator, kind }\n                 }\n                 tt::TokenTree::Leaf(leaf) => match leaf {\n@@ -107,18 +104,18 @@ fn next_op<'a>(\n                         if punct.char != '_' {\n                             return Err(ExpandError::UnexpectedToken);\n                         }\n-                        let name = &UNDERSCORE;\n+                        let name = UNDERSCORE.clone();\n                         let kind = eat_fragment_kind(src, mode)?;\n                         Op::Var { name, kind }\n                     }\n                     tt::Leaf::Ident(ident) => {\n-                        let name = &ident.text;\n+                        let name = ident.text.clone();\n                         let kind = eat_fragment_kind(src, mode)?;\n                         Op::Var { name, kind }\n                     }\n                     tt::Leaf::Literal(lit) => {\n-                        if is_boolean_literal(lit) {\n-                            let name = &lit.text;\n+                        if is_boolean_literal(&lit) {\n+                            let name = lit.text.clone();\n                             let kind = eat_fragment_kind(src, mode)?;\n                             Op::Var { name, kind }\n                         } else {\n@@ -128,19 +125,22 @@ fn next_op<'a>(\n                 },\n             }\n         }\n-        tt => Op::TokenTree(tt),\n+        tt::TokenTree::Leaf(tt) => Op::Leaf(tt.clone()),\n+        tt::TokenTree::Subtree(subtree) => {\n+            let delimiter = subtree.delimiter;\n+            let tokens = parse_inner(&subtree, mode);\n+            let subtree = MetaTemplate { tokens, delimiter };\n+            Op::Subtree(subtree)\n+        }\n     };\n     Ok(res)\n }\n \n-fn eat_fragment_kind<'a>(\n-    src: &mut TtIter<'a>,\n-    mode: Mode,\n-) -> Result<Option<&'a SmolStr>, ExpandError> {\n+fn eat_fragment_kind<'a>(src: &mut TtIter<'a>, mode: Mode) -> Result<Option<SmolStr>, ExpandError> {\n     if let Mode::Pattern = mode {\n         src.expect_char(':').map_err(|()| err!(\"bad fragment specifier 1\"))?;\n         let ident = src.expect_ident().map_err(|()| err!(\"bad fragment specifier 1\"))?;\n-        return Ok(Some(&ident.text));\n+        return Ok(Some(ident.text.clone()));\n     };\n     Ok(None)\n }"}]}