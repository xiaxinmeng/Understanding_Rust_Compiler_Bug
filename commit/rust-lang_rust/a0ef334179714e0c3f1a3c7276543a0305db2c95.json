{"sha": "a0ef334179714e0c3f1a3c7276543a0305db2c95", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwZWYzMzQxNzk3MTRlMGMzZjFhM2M3Mjc2NTQzYTAzMDVkYjJjOTU=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "etryzelaar@iqt.org", "date": "2012-12-19T02:55:19Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-12-19T04:54:13Z"}, "message": "core: use movable self to clean up option/result.", "tree": {"sha": "36f12b1ed6b54ec9a7c3e4a2c39e21fd7d0a5b16", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36f12b1ed6b54ec9a7c3e4a2c39e21fd7d0a5b16"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0ef334179714e0c3f1a3c7276543a0305db2c95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0ef334179714e0c3f1a3c7276543a0305db2c95", "html_url": "https://github.com/rust-lang/rust/commit/a0ef334179714e0c3f1a3c7276543a0305db2c95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0ef334179714e0c3f1a3c7276543a0305db2c95/comments", "author": null, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "938058b0040e3c482e10b78eeef7afb941b2b64e", "url": "https://api.github.com/repos/rust-lang/rust/commits/938058b0040e3c482e10b78eeef7afb941b2b64e", "html_url": "https://github.com/rust-lang/rust/commit/938058b0040e3c482e10b78eeef7afb941b2b64e"}], "stats": {"total": 189, "additions": 103, "deletions": 86}, "files": [{"sha": "a4f385ea12cd8221c2ee4e028a7fc1c7972494d0", "filename": "src/libcore/option.rs", "status": "modified", "additions": 58, "deletions": 40, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/a0ef334179714e0c3f1a3c7276543a0305db2c95/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0ef334179714e0c3f1a3c7276543a0305db2c95/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=a0ef334179714e0c3f1a3c7276543a0305db2c95", "patch": "@@ -96,19 +96,6 @@ pub pure fn get_ref<T>(opt: &r/Option<T>) -> &r/T {\n     }\n }\n \n-pub pure fn expect<T>(opt: Option<T>, reason: ~str) -> T {\n-    /*!\n-     * Gets the value out of an option without copying, printing a\n-     * specified message on failure.\n-     *\n-     * # Failure\n-     *\n-     * Fails if the value equals `none`\n-     */\n-    if opt.is_some() { move option::unwrap(move opt) }\n-    else { fail reason }\n-}\n-\n pub pure fn map<T, U>(opt: &Option<T>, f: fn(x: &T) -> U) -> Option<U> {\n     //! Maps a `some` value by reference from one type to another\n \n@@ -235,35 +222,46 @@ pub fn swap_unwrap<T>(opt: &mut Option<T>) -> T {\n     unwrap(util::replace(opt, None))\n }\n \n-pub pure fn unwrap_expect<T>(opt: Option<T>, reason: &str) -> T {\n+pub pure fn expect<T>(opt: Option<T>, reason: &str) -> T {\n     //! As unwrap, but with a specified failure message.\n-    if opt.is_none() { fail reason.to_owned(); }\n-    unwrap(move opt)\n+    match move opt {\n+        Some(move val) => val,\n+        None => fail reason.to_owned(),\n+    }\n }\n \n-// Some of these should change to be &Option<T>, some should not. See below.\n impl<T> Option<T> {\n     /// Returns true if the option equals `none`\n-    pure fn is_none() -> bool { is_none(&self) }\n+    #[inline(always)]\n+    pure fn is_none(&self) -> bool { is_none(self) }\n+\n     /// Returns true if the option contains some value\n-    pure fn is_some() -> bool { is_some(&self) }\n-}\n+    #[inline(always)]\n+    pure fn is_some(&self) -> bool { is_some(self) }\n \n-impl<T> &Option<T> {\n     /**\n      * Update an optional value by optionally running its content by reference\n      * through a function that returns an option.\n      */\n-    pure fn chain_ref<U>(f: fn(x: &T) -> Option<U>) -> Option<U> {\n+    #[inline(always)]\n+    pure fn chain_ref<U>(&self, f: fn(x: &T) -> Option<U>) -> Option<U> {\n         chain_ref(self, f)\n     }\n+\n+    /// Maps a `some` value from one type to another by reference\n+    #[inline(always)]\n+    pure fn map<U>(&self, f: fn(x: &T) -> U) -> Option<U> { map(self, f) }\n+\n     /// Applies a function to the contained value or returns a default\n-    pure fn map_default<U>(def: U, f: fn(x: &T) -> U) -> U\n-        { map_default(self, move def, f) }\n+    #[inline(always)]\n+    pure fn map_default<U>(&self, def: U, f: fn(x: &T) -> U) -> U {\n+        map_default(self, move def, f)\n+    }\n+\n     /// Performs an operation on the contained value by reference\n-    pure fn iter(f: fn(x: &T)) { iter(self, f) }\n-    /// Maps a `some` value from one type to another by reference\n-    pure fn map<U>(f: fn(x: &T) -> U) -> Option<U> { map(self, f) }\n+    #[inline(always)]\n+    pure fn iter(&self, f: fn(x: &T)) { iter(self, f) }\n+\n     /**\n     Gets an immutable reference to the value inside an option.\n \n@@ -278,7 +276,29 @@ impl<T> &Option<T> {\n     Instead, prefer to use pattern matching and handle the `None`\n     case explicitly.\n      */\n-    pure fn get_ref() -> &self/T { get_ref(self) }\n+    #[inline(always)]\n+    pure fn get_ref(&self) -> &self/T { get_ref(self) }\n+\n+    /**\n+     * Gets the value out of an option without copying.\n+     *\n+     * # Failure\n+     *\n+     * Fails if the value equals `none`\n+     */\n+    #[inline(always)]\n+    pure fn unwrap(self) -> T { unwrap(self) }\n+\n+    /**\n+     * Gets the value out of an option, printing a specified message on\n+     * failure\n+     *\n+     * # Failure\n+     *\n+     * Fails if the value equals `none`\n+     */\n+    #[inline(always)]\n+    pure fn expect(self, reason: &str) -> T { expect(self, reason) }\n }\n \n impl<T: Copy> Option<T> {\n@@ -296,19 +316,17 @@ impl<T: Copy> Option<T> {\n     Instead, prefer to use pattern matching and handle the `None`\n     case explicitly.\n     */\n-    pure fn get() -> T { get(self) }\n-    pure fn get_default(def: T) -> T { get_default(self, def) }\n-    /**\n-     * Gets the value out of an option, printing a specified message on\n-     * failure\n-     *\n-     * # Failure\n-     *\n-     * Fails if the value equals `none`\n-     */\n-    pure fn expect(reason: ~str) -> T { expect(self, move reason) }\n+    #[inline(always)]\n+    pure fn get(self) -> T { get(self) }\n+\n+    #[inline(always)]\n+    pure fn get_default(self, def: T) -> T { get_default(self, def) }\n+\n     /// Applies a function zero or more times until the result is none.\n-    pure fn while_some(blk: fn(v: T) -> Option<T>) { while_some(self, blk) }\n+    #[inline(always)]\n+    pure fn while_some(self, blk: fn(v: T) -> Option<T>) {\n+        while_some(self, blk)\n+    }\n }\n \n #[test]"}, {"sha": "59d59d335189632a60e1d955aadbc83c48f273a5", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0ef334179714e0c3f1a3c7276543a0305db2c95/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0ef334179714e0c3f1a3c7276543a0305db2c95/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=a0ef334179714e0c3f1a3c7276543a0305db2c95", "patch": "@@ -412,7 +412,7 @@ Fails if the sender closes the connection.\n */\n pub fn recv<T: Owned, Tbuffer: Owned>(\n     p: RecvPacketBuffered<T, Tbuffer>) -> T {\n-    option::unwrap_expect(try_recv(move p), \"connection closed\")\n+    try_recv(move p).expect(\"connection closed\")\n }\n \n /** Attempts to receive a message from a pipe.\n@@ -1102,7 +1102,7 @@ impl<T: Owned> PortSet<T> : GenericPort<T> {\n     }\n \n     fn recv() -> T {\n-        option::unwrap_expect(self.try_recv(), \"port_set: endpoints closed\")\n+        self.try_recv().expect(\"port_set: endpoints closed\")\n     }\n \n }"}, {"sha": "26064345b59f2bc2ba35b36a048cfa54a39535f8", "filename": "src/libcore/result.rs", "status": "modified", "additions": 43, "deletions": 44, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/a0ef334179714e0c3f1a3c7276543a0305db2c95/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0ef334179714e0c3f1a3c7276543a0305db2c95/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=a0ef334179714e0c3f1a3c7276543a0305db2c95", "patch": "@@ -114,7 +114,7 @@ pub pure fn to_either<T: Copy, U: Copy>(res: &Result<U, T>)\n  *         ok(parse_bytes(buf))\n  *     }\n  */\n-pub fn chain<T, U, V>(res: Result<T, V>, op: fn(t: T)\n+pub pure fn chain<T, U, V>(res: Result<T, V>, op: fn(T)\n     -> Result<U, V>) -> Result<U, V> {\n     match move res {\n         Ok(move t) => op(move t),\n@@ -130,7 +130,7 @@ pub fn chain<T, U, V>(res: Result<T, V>, op: fn(t: T)\n  * immediately returned.  This function can be used to pass through a\n  * successful result while handling an error.\n  */\n-pub fn chain_err<T, U, V>(\n+pub pure fn chain_err<T, U, V>(\n     res: Result<T, V>,\n     op: fn(t: V) -> Result<T, U>)\n     -> Result<T, U> {\n@@ -154,7 +154,7 @@ pub fn chain_err<T, U, V>(\n  *         print_buf(buf)\n  *     }\n  */\n-pub fn iter<T, E>(res: &Result<T, E>, f: fn(&T)) {\n+pub pure fn iter<T, E>(res: &Result<T, E>, f: fn(&T)) {\n     match *res {\n       Ok(ref t) => f(t),\n       Err(_) => ()\n@@ -169,7 +169,7 @@ pub fn iter<T, E>(res: &Result<T, E>, f: fn(&T)) {\n  * This function can be used to pass through a successful result while\n  * handling an error.\n  */\n-pub fn iter_err<T, E>(res: &Result<T, E>, f: fn(&E)) {\n+pub pure fn iter_err<T, E>(res: &Result<T, E>, f: fn(&E)) {\n     match *res {\n       Ok(_) => (),\n       Err(ref e) => f(e)\n@@ -190,7 +190,7 @@ pub fn iter_err<T, E>(res: &Result<T, E>, f: fn(&E)) {\n  *         parse_bytes(buf)\n  *     }\n  */\n-pub fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: fn(&T) -> U)\n+pub pure fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: fn(&T) -> U)\n   -> Result<U, E> {\n     match *res {\n       Ok(ref t) => Ok(op(t)),\n@@ -206,7 +206,7 @@ pub fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: fn(&T) -> U)\n  * is immediately returned.  This function can be used to pass through a\n  * successful result while handling an error.\n  */\n-pub fn map_err<T: Copy, E, F: Copy>(res: &Result<T, E>, op: fn(&E) -> F)\n+pub pure fn map_err<T: Copy, E, F: Copy>(res: &Result<T, E>, op: fn(&E) -> F)\n   -> Result<T, F> {\n     match *res {\n       Ok(copy t) => Ok(t),\n@@ -215,58 +215,55 @@ pub fn map_err<T: Copy, E, F: Copy>(res: &Result<T, E>, op: fn(&E) -> F)\n }\n \n impl<T, E> Result<T, E> {\n+    #[inline(always)]\n     pure fn get_ref(&self) -> &self/T { get_ref(self) }\n \n-    pure fn is_ok() -> bool { is_ok(&self) }\n+    #[inline(always)]\n+    pure fn is_ok(&self) -> bool { is_ok(self) }\n \n-    pure fn is_err() -> bool { is_err(&self) }\n+    #[inline(always)]\n+    pure fn is_err(&self) -> bool { is_err(self) }\n \n-    pure fn iter(f: fn(&T)) {\n-        match self {\n-          Ok(ref t) => f(t),\n-          Err(_) => ()\n-        }\n+    #[inline(always)]\n+    pure fn iter(&self, f: fn(&T)) { iter(self, f) }\n+\n+    #[inline(always)]\n+    pure fn iter_err(&self, f: fn(&E)) { iter_err(self, f) }\n+\n+    #[inline(always)]\n+    pure fn unwrap(self) -> T { unwrap(self) }\n+\n+    #[inline(always)]\n+    pure fn unwrap_err(self) -> T { unwrap(self) }\n+\n+    #[inline(always)]\n+    pure fn chain<U>(self, op: fn(T) -> Result<U,E>) -> Result<U,E> {\n+        chain(self, op)\n     }\n \n-    fn iter_err(f: fn(&E)) {\n-        match self {\n-          Ok(_) => (),\n-          Err(ref e) => f(e)\n-        }\n+    #[inline(always)]\n+    pure fn chain_err<F>(self, op: fn(E) -> Result<T,F>) -> Result<T,F> {\n+        chain_err(self, op)\n     }\n }\n \n impl<T: Copy, E> Result<T, E> {\n-    pure fn get() -> T { get(&self) }\n+    #[inline(always)]\n+    pure fn get(&self) -> T { get(self) }\n \n-    fn map_err<F:Copy>(op: fn(&E) -> F) -> Result<T,F> {\n-        match self {\n-          Ok(copy t) => Ok(t),\n-          Err(ref e) => Err(op(e))\n-        }\n+    #[inline(always)]\n+    pure fn map_err<F:Copy>(&self, op: fn(&E) -> F) -> Result<T,F> {\n+        map_err(self, op)\n     }\n }\n \n impl<T, E: Copy> Result<T, E> {\n-    pure fn get_err() -> E { get_err(&self) }\n-\n-    fn map<U:Copy>(op: fn(&T) -> U) -> Result<U,E> {\n-        match self {\n-          Ok(ref t) => Ok(op(t)),\n-          Err(copy e) => Err(e)\n-        }\n-    }\n-}\n-\n-impl<T: Copy, E: Copy> Result<T, E> {\n-    fn chain<U:Copy>(op: fn(t: T) -> Result<U,E>) -> Result<U,E> {\n-        // XXX: Bad copy\n-        chain(copy self, op)\n-    }\n+    #[inline(always)]\n+    pure fn get_err(&self) -> E { get_err(self) }\n \n-    fn chain_err<F:Copy>(op: fn(t: E) -> Result<T,F>) -> Result<T,F> {\n-        // XXX: Bad copy\n-        chain_err(copy self, op)\n+    #[inline(always)]\n+    pure fn map<U:Copy>(&self, op: fn(&T) -> U) -> Result<U,E> {\n+        map(self, op)\n     }\n }\n \n@@ -360,15 +357,17 @@ pub fn iter_vec2<S,T,U:Copy>(ss: &[S], ts: &[T],\n }\n \n /// Unwraps a result, assuming it is an `ok(T)`\n-pub fn unwrap<T, U>(res: Result<T, U>) -> T {\n+#[inline(always)]\n+pub pure fn unwrap<T, U>(res: Result<T, U>) -> T {\n     match move res {\n       Ok(move t) => move t,\n       Err(_) => fail ~\"unwrap called on an err result\"\n     }\n }\n \n /// Unwraps a result, assuming it is an `err(U)`\n-pub fn unwrap_err<T, U>(res: Result<T, U>) -> U {\n+#[inline(always)]\n+pub pure fn unwrap_err<T, U>(res: Result<T, U>) -> U {\n     match move res {\n       Err(move u) => move u,\n       Ok(_) => fail ~\"unwrap called on an ok result\""}]}