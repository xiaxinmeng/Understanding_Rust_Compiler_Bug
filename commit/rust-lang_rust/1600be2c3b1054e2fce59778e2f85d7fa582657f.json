{"sha": "1600be2c3b1054e2fce59778e2f85d7fa582657f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2MDBiZTJjM2IxMDU0ZTJmY2U1OTc3OGUyZjg1ZDdmYTU4MjY1N2Y=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-14T21:18:53Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-14T21:19:33Z"}, "message": "fix auto_serialize for enums with type parameters", "tree": {"sha": "a3b8b7d281fbc5b4925278149952fce67c30dceb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3b8b7d281fbc5b4925278149952fce67c30dceb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1600be2c3b1054e2fce59778e2f85d7fa582657f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1600be2c3b1054e2fce59778e2f85d7fa582657f", "html_url": "https://github.com/rust-lang/rust/commit/1600be2c3b1054e2fce59778e2f85d7fa582657f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1600be2c3b1054e2fce59778e2f85d7fa582657f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "715d1995d7fdb28caeaa5401e1dbdbb3751bee60", "url": "https://api.github.com/repos/rust-lang/rust/commits/715d1995d7fdb28caeaa5401e1dbdbb3751bee60", "html_url": "https://github.com/rust-lang/rust/commit/715d1995d7fdb28caeaa5401e1dbdbb3751bee60"}], "stats": {"total": 389, "additions": 355, "deletions": 34}, "files": [{"sha": "3734b8db2c0350cfd9b50ab7719159a91c92476a", "filename": "src/libstd/serialization.rs", "status": "modified", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/1600be2c3b1054e2fce59778e2f85d7fa582657f/src%2Flibstd%2Fserialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1600be2c3b1054e2fce59778e2f85d7fa582657f/src%2Flibstd%2Fserialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization.rs?ref=1600be2c3b1054e2fce59778e2f85d7fa582657f", "patch": "@@ -120,3 +120,151 @@ fn serialize_uint<S: serializer>(s: S, v: uint) {\n fn deserialize_uint<D: deserializer>(d: D) -> uint {\n     d.read_uint()\n }\n+\n+fn serialize_u8<S: serializer>(s: S, v: u8) {\n+    s.emit_u8(v);\n+}\n+\n+fn deserialize_u8<D: deserializer>(d: D) -> u8 {\n+    d.read_u8()\n+}\n+\n+fn serialize_u16<S: serializer>(s: S, v: u16) {\n+    s.emit_u16(v);\n+}\n+\n+fn deserialize_u16<D: deserializer>(d: D) -> u16 {\n+    d.read_u16()\n+}\n+\n+fn serialize_u32<S: serializer>(s: S, v: u32) {\n+    s.emit_u32(v);\n+}\n+\n+fn deserialize_u32<D: deserializer>(d: D) -> u32 {\n+    d.read_u32()\n+}\n+\n+fn serialize_u64<S: serializer>(s: S, v: u64) {\n+    s.emit_u64(v);\n+}\n+\n+fn deserialize_u64<D: deserializer>(d: D) -> u64 {\n+    d.read_u64()\n+}\n+\n+fn serialize_int<S: serializer>(s: S, v: int) {\n+    s.emit_int(v);\n+}\n+\n+fn deserialize_int<D: deserializer>(d: D) -> int {\n+    d.read_int()\n+}\n+\n+fn serialize_i8<S: serializer>(s: S, v: i8) {\n+    s.emit_i8(v);\n+}\n+\n+fn deserialize_i8<D: deserializer>(d: D) -> i8 {\n+    d.read_i8()\n+}\n+\n+fn serialize_i16<S: serializer>(s: S, v: i16) {\n+    s.emit_i16(v);\n+}\n+\n+fn deserialize_i16<D: deserializer>(d: D) -> i16 {\n+    d.read_i16()\n+}\n+\n+fn serialize_i32<S: serializer>(s: S, v: i32) {\n+    s.emit_i32(v);\n+}\n+\n+fn deserialize_i32<D: deserializer>(d: D) -> i32 {\n+    d.read_i32()\n+}\n+\n+fn serialize_i64<S: serializer>(s: S, v: i64) {\n+    s.emit_i64(v);\n+}\n+\n+fn deserialize_i64<D: deserializer>(d: D) -> i64 {\n+    d.read_i64()\n+}\n+\n+fn serialize_str<S: serializer>(s: S, v: str) {\n+    s.emit_str(v);\n+}\n+\n+fn deserialize_str<D: deserializer>(d: D) -> str {\n+    d.read_str()\n+}\n+\n+fn serialize_float<S: serializer>(s: S, v: float) {\n+    s.emit_float(v);\n+}\n+\n+fn deserialize_float<D: deserializer>(d: D) -> float {\n+    d.read_float()\n+}\n+\n+fn serialize_f32<S: serializer>(s: S, v: f32) {\n+    s.emit_f32(v);\n+}\n+\n+fn deserialize_f32<D: deserializer>(d: D) -> f32 {\n+    d.read_f32()\n+}\n+\n+fn serialize_f64<S: serializer>(s: S, v: f64) {\n+    s.emit_f64(v);\n+}\n+\n+fn deserialize_f64<D: deserializer>(d: D) -> f64 {\n+    d.read_f64()\n+}\n+\n+fn serialize_bool<S: serializer>(s: S, v: bool) {\n+    s.emit_bool(v);\n+}\n+\n+fn deserialize_bool<D: deserializer>(d: D) -> bool {\n+    d.read_bool()\n+}\n+\n+fn serialize_option<S: serializer,T>(s: S, v: option<T>, st: fn(T)) {\n+    s.emit_enum(\"option\") {||\n+        alt v {\n+          none {\n+            s.emit_enum_variant(\"none\", 0u, 0u) {||\n+            }\n+          }\n+\n+          some(v) {\n+            s.emit_enum_variant(\"some\", 1u, 1u) {||\n+                s.emit_enum_variant_arg(0u) {||\n+                    st(v)\n+                }\n+            }\n+          }\n+        }\n+    }\n+}\n+\n+fn deserialize_option<D: deserializer,T>(d: D, st: fn() -> T) -> option<T> {\n+    d.read_enum(\"option\") {||\n+        d.read_enum_variant {|i|\n+            alt check i {\n+              0u { // none\n+                none\n+              }\n+              1u { // some(v)\n+                some(d.read_enum_variant_arg(0u) {||\n+                    st()\n+                })\n+              }\n+            }\n+        }\n+    }\n+}"}, {"sha": "a925514b8fb0de5f83ab62ffd9379002f9955873", "filename": "src/rustc/syntax/ast.rs", "status": "modified", "additions": 146, "deletions": 2, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/1600be2c3b1054e2fce59778e2f85d7fa582657f/src%2Frustc%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1600be2c3b1054e2fce59778e2f85d7fa582657f/src%2Frustc%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fast.rs?ref=1600be2c3b1054e2fce59778e2f85d7fa582657f", "patch": "@@ -1,33 +1,70 @@\n // The Rust abstract syntax tree.\n \n import codemap::{span, filename};\n+import std::serialization::{serializer,\n+                            deserializer,\n+                            serialize_option,\n+                            deserialize_option,\n+                            serialize_uint,\n+                            deserialize_uint,\n+                            serialize_int,\n+                            deserialize_int,\n+                            serialize_i64,\n+                            deserialize_i64,\n+                            serialize_u64,\n+                            deserialize_u64,\n+                            serialize_str,\n+                            deserialize_str,\n+                            serialize_bool,\n+                            deserialize_bool};\n+\n+fn serialize_span<S>(_s: S, _v: span) {\n+    // FIXME-- serialize some span info\n+}\n+\n+fn deserialize_span<D>(_d: D) -> span {\n+    ast_util::dummy_sp()\n+}\n \n+/*#[auto_serialize]*/\n type spanned<T> = {node: T, span: span};\n \n+/*#[auto_serialize]*/\n type ident = str;\n \n // Functions may or may not have names.\n+/*#[auto_serialize]*/\n type fn_ident = option<ident>;\n \n+/*#[auto_serialize]*/\n type path_ = {global: bool, idents: [ident], types: [@ty]};\n \n+/*#[auto_serialize]*/\n type path = spanned<path_>;\n \n+/*#[auto_serialize]*/\n type crate_num = int;\n+\n+/*#[auto_serialize]*/\n type node_id = int;\n+\n+/*#[auto_serialize]*/\n type def_id = {crate: crate_num, node: node_id};\n \n const local_crate: crate_num = 0;\n const crate_node_id: node_id = 0;\n \n+/*#[auto_serialize]*/\n enum ty_param_bound {\n     bound_copy,\n     bound_send,\n     bound_iface(@ty),\n }\n \n+/*#[auto_serialize]*/\n type ty_param = {ident: ident, id: node_id, bounds: @[ty_param_bound]};\n \n+/*#[auto_serialize]*/\n enum def {\n     def_fn(def_id, purity),\n     def_self(node_id),\n@@ -82,23 +119,30 @@ enum crate_directive_ {\n \n type crate_directive = spanned<crate_directive_>;\n \n+/*#[auto_serialize]*/\n type meta_item = spanned<meta_item_>;\n \n+/*#[auto_serialize]*/\n enum meta_item_ {\n     meta_word(ident),\n     meta_list(ident, [@meta_item]),\n     meta_name_value(ident, lit),\n }\n \n+/*#[auto_serialize]*/\n type blk = spanned<blk_>;\n \n+/*#[auto_serialize]*/\n type blk_ = {view_items: [@view_item], stmts: [@stmt], expr: option<@expr>,\n              id: node_id, rules: blk_check_mode};\n \n+/*#[auto_serialize]*/\n type pat = {id: node_id, node: pat_, span: span};\n \n+/*#[auto_serialize]*/\n type field_pat = {ident: ident, pat: @pat};\n \n+/*#[auto_serialize]*/\n enum pat_ {\n     pat_wild,\n     // A pat_ident may either be a new bound variable,\n@@ -118,8 +162,10 @@ enum pat_ {\n     pat_range(@expr, @expr),\n }\n \n+/*#[auto_serialize]*/\n enum mutability { m_mutbl, m_imm, m_const, }\n \n+/*#[auto_serialize]*/\n enum proto {\n     proto_bare,    // native fn\n     proto_any,     // fn\n@@ -135,6 +181,7 @@ pure fn is_blockish(p: ast::proto) -> bool {\n     }\n }\n \n+/*#[auto_serialize]*/\n enum binop {\n     add,\n     subtract,\n@@ -157,6 +204,7 @@ enum binop {\n     gt,\n }\n \n+/*#[auto_serialize]*/\n enum unop {\n     box(mutability),\n     uniq(mutability),\n@@ -165,18 +213,23 @@ enum unop {\n \n // Generally, after typeck you can get the inferred value\n // using ty::resolved_T(...).\n+/*#[auto_serialize]*/\n enum inferable<T> {\n     expl(T), infer(node_id)\n }\n \n // \"resolved\" mode: the real modes.\n+/*#[auto_serialize]*/\n enum rmode { by_ref, by_val, by_mutbl_ref, by_move, by_copy }\n \n // inferable mode.\n+/*#[auto_serialize]*/\n type mode = inferable<rmode>;\n \n+/*#[auto_serialize]*/\n type stmt = spanned<stmt_>;\n \n+/*#[auto_serialize]*/\n enum stmt_ {\n     stmt_decl(@decl, node_id),\n \n@@ -187,34 +240,48 @@ enum stmt_ {\n     stmt_semi(@expr, node_id),\n }\n \n+/*#[auto_serialize]*/\n enum init_op { init_assign, init_move, }\n \n+/*#[auto_serialize]*/\n type initializer = {op: init_op, expr: @expr};\n \n+/*#[auto_serialize]*/\n type local_ =  // FIXME: should really be a refinement on pat\n     {is_mutbl: bool, ty: @ty, pat: @pat,\n      init: option<initializer>, id: node_id};\n \n+/*#[auto_serialize]*/\n type local = spanned<local_>;\n \n+/*#[auto_serialize]*/\n type decl = spanned<decl_>;\n \n+/*#[auto_serialize]*/\n enum decl_ { decl_local([@local]), decl_item(@item), }\n \n+/*#[auto_serialize]*/\n type arm = {pats: [@pat], guard: option<@expr>, body: blk};\n \n+/*#[auto_serialize]*/\n type field_ = {mutbl: mutability, ident: ident, expr: @expr};\n \n+/*#[auto_serialize]*/\n type field = spanned<field_>;\n \n+/*#[auto_serialize]*/\n enum blk_check_mode { default_blk, unchecked_blk, unsafe_blk, }\n \n+/*#[auto_serialize]*/\n enum expr_check_mode { claimed_expr, checked_expr, }\n \n+/*#[auto_serialize]*/\n type expr = {id: node_id, node: expr_, span: span};\n \n+/*#[auto_serialize]*/\n enum alt_mode { alt_check, alt_exhaustive, }\n \n+/*#[auto_serialize]*/\n enum expr_ {\n     expr_vec([@expr], mutability),\n     expr_rec([field], option<@expr>),\n@@ -270,11 +337,14 @@ enum expr_ {\n     expr_mac(mac),\n }\n \n+/*#[auto_serialize]*/\n type capture_item = {\n     id: int,\n     name: ident, // Currently, can only capture a local var.\n     span: span\n };\n+\n+/*#[auto_serialize]*/\n type capture_clause = {\n     copies: [@capture_item],\n     moves: [@capture_item]\n@@ -289,13 +359,19 @@ enum blk_sort {\n }\n */\n \n+/*#[auto_serialize]*/\n type mac = spanned<mac_>;\n \n+/*#[auto_serialize]*/\n type mac_arg = option<@expr>;\n \n+/*#[auto_serialize]*/\n type mac_body_ = {span: span};\n+\n+/*#[auto_serialize]*/\n type mac_body = option<mac_body_>;\n \n+/*#[auto_serialize]*/\n enum mac_ {\n     mac_invoc(@path, mac_arg, mac_body),\n     mac_embed_type(@ty),\n@@ -306,8 +382,10 @@ enum mac_ {\n     mac_var(uint)\n }\n \n+/*#[auto_serialize]*/\n type lit = spanned<lit_>;\n \n+/*#[auto_serialize]*/\n enum lit_ {\n     lit_str(str),\n     lit_int(i64, int_ty),\n@@ -319,24 +397,33 @@ enum lit_ {\n \n // NB: If you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n+/*#[auto_serialize]*/\n type mt = {ty: @ty, mutbl: mutability};\n \n+/*#[auto_serialize]*/\n type ty_field_ = {ident: ident, mt: mt};\n \n+/*#[auto_serialize]*/\n type ty_field = spanned<ty_field_>;\n \n+/*#[auto_serialize]*/\n type ty_method = {ident: ident, attrs: [attribute],\n                   decl: fn_decl, tps: [ty_param], span: span};\n \n+/*#[auto_serialize]*/\n enum int_ty { ty_i, ty_char, ty_i8, ty_i16, ty_i32, ty_i64, }\n \n+/*#[auto_serialize]*/\n enum uint_ty { ty_u, ty_u8, ty_u16, ty_u32, ty_u64, }\n \n+/*#[auto_serialize]*/\n enum float_ty { ty_f, ty_f32, ty_f64, }\n \n+/*#[auto_serialize]*/\n type ty = {id: node_id, node: ty_, span: span};\n \n // Not represented directly in the AST, referred to by name through a ty_path.\n+/*#[auto_serialize]*/\n enum prim_ty {\n     ty_int(int_ty),\n     ty_uint(uint_ty),\n@@ -345,14 +432,17 @@ enum prim_ty {\n     ty_bool,\n }\n \n+/*#[auto_serialize]*/\n type region = {id: node_id, node: region_};\n \n+/*#[auto_serialize]*/\n enum region_ {\n     re_inferred,\n     re_named(ident),\n     re_self\n }\n \n+/*#[auto_serialize]*/\n enum ty_ {\n     ty_nil,\n     ty_bot, /* bottom type */\n@@ -382,86 +472,121 @@ so that the typestate pass doesn't have to map a function name onto its decl.\n So, the constr_arg type is parameterized: it's instantiated with uint for\n declarations, and ident for uses.\n */\n+/*#[auto_serialize]*/\n enum constr_arg_general_<T> { carg_base, carg_ident(T), carg_lit(@lit), }\n \n+/*#[auto_serialize]*/\n type fn_constr_arg = constr_arg_general_<uint>;\n+\n+/*#[auto_serialize]*/\n type sp_constr_arg<T> = spanned<constr_arg_general_<T>>;\n+\n+/*#[auto_serialize]*/\n type ty_constr_arg = sp_constr_arg<@path>;\n+\n+/*#[auto_serialize]*/\n type constr_arg = spanned<fn_constr_arg>;\n \n // Constrained types' args are parameterized by paths, since\n // we refer to paths directly and not by indices.\n // The implicit root of such path, in the constraint-list for a\n // constrained type, is * (referring to the base record)\n \n+/*#[auto_serialize]*/\n type constr_general_<ARG, ID> =\n     {path: @path, args: [@spanned<constr_arg_general_<ARG>>], id: ID};\n \n // In the front end, constraints have a node ID attached.\n // Typeck turns this to a def_id, using the output of resolve.\n+/*#[auto_serialize]*/\n type constr_general<ARG> = spanned<constr_general_<ARG, node_id>>;\n+\n+/*#[auto_serialize]*/\n type constr_ = constr_general_<uint, node_id>;\n+\n+/*#[auto_serialize]*/\n type constr = spanned<constr_general_<uint, node_id>>;\n+\n+/*#[auto_serialize]*/\n type ty_constr_ = constr_general_<@path, node_id>;\n+\n+/*#[auto_serialize]*/\n type ty_constr = spanned<ty_constr_>;\n \n /* The parser generates ast::constrs; resolve generates\n  a mapping from each function to a list of ty::constr_defs,\n  corresponding to these. */\n+/*#[auto_serialize]*/\n type arg = {mode: mode, ty: @ty, ident: ident, id: node_id};\n \n+/*#[auto_serialize]*/\n type fn_decl =\n     {inputs: [arg],\n      output: @ty,\n      purity: purity,\n      cf: ret_style,\n      constraints: [@constr]};\n \n+/*#[auto_serialize]*/\n enum purity {\n     pure_fn, // declared with \"pure fn\"\n     unsafe_fn, // declared with \"unsafe fn\"\n     impure_fn, // declared with \"fn\"\n     crust_fn, // declared with \"crust fn\"\n }\n \n+/*#[auto_serialize]*/\n enum ret_style {\n     noreturn, // functions with return type _|_ that always\n               // raise an error or exit (i.e. never return to the caller)\n     return_val, // everything else\n }\n \n+/*#[auto_serialize]*/\n type method = {ident: ident, attrs: [attribute],\n                tps: [ty_param], decl: fn_decl, body: blk,\n                id: node_id, span: span, self_id: node_id};\n \n+/*#[auto_serialize]*/\n type _mod = {view_items: [@view_item], items: [@item]};\n \n+/*#[auto_serialize]*/\n enum native_abi {\n     native_abi_rust_intrinsic,\n     native_abi_cdecl,\n     native_abi_stdcall,\n }\n \n+/*#[auto_serialize]*/\n type native_mod =\n     {view_items: [@view_item],\n      items: [@native_item]};\n \n+/*#[auto_serialize]*/\n type variant_arg = {ty: @ty, id: node_id};\n \n+/*#[auto_serialize]*/\n type variant_ = {name: ident, attrs: [attribute], args: [variant_arg],\n                  id: node_id, disr_expr: option<@expr>};\n \n+/*#[auto_serialize]*/\n type variant = spanned<variant_>;\n \n-\n // FIXME: May want to just use path here, which would allow things like\n // 'import ::foo'\n+/*#[auto_serialize]*/\n type simple_path = [ident];\n \n+/*#[auto_serialize]*/\n type path_list_ident_ = {name: ident, id: node_id};\n+\n+/*#[auto_serialize]*/\n type path_list_ident = spanned<path_list_ident_>;\n \n+/*#[auto_serialize]*/\n type view_path = spanned<view_path_>;\n+\n+/*#[auto_serialize]*/\n enum view_path_ {\n \n     // quux = foo::bar::baz\n@@ -478,27 +603,34 @@ enum view_path_ {\n     view_path_list(@simple_path, [path_list_ident], node_id)\n }\n \n+/*#[auto_serialize]*/\n type view_item = spanned<view_item_>;\n+\n+/*#[auto_serialize]*/\n enum view_item_ {\n     view_item_use(ident, [@meta_item], node_id),\n     view_item_import([@view_path]),\n     view_item_export([@view_path])\n }\n \n // Meta-data associated with an item\n+/*#[auto_serialize]*/\n type attribute = spanned<attribute_>;\n \n-\n // Distinguishes between attributes that decorate items and attributes that\n // are contained as statements within items. These two cases need to be\n // distinguished for pretty-printing.\n+/*#[auto_serialize]*/\n enum attr_style { attr_outer, attr_inner, }\n \n+/*#[auto_serialize]*/\n type attribute_ = {style: attr_style, value: meta_item};\n \n+/*#[auto_serialize]*/\n type item = {ident: ident, attrs: [attribute],\n              id: node_id, node: item_, span: span};\n \n+/*#[auto_serialize]*/\n enum item_ {\n     item_const(@ty, @expr),\n     item_fn(fn_decl, [ty_param], blk),\n@@ -518,9 +650,13 @@ enum item_ {\n               @ty /* self */, [@method]),\n }\n \n+/*#[auto_serialize]*/\n type class_item_ = {privacy: privacy, decl: class_member};\n+\n+/*#[auto_serialize]*/\n type class_item = spanned<class_item_>;\n \n+/*#[auto_serialize]*/\n enum class_member {\n     instance_var(ident, @ty, class_mutability, node_id),\n     class_method(@item) // FIXME: methods aren't allowed to be\n@@ -529,29 +665,37 @@ enum class_member {\n     // item to separate out things with type params?\n }\n \n+/*#[auto_serialize]*/\n enum class_mutability { class_mutable, class_immutable }\n \n+/*#[auto_serialize]*/\n enum privacy { priv, pub }\n \n+/*#[auto_serialize]*/\n type class_ctor = spanned<class_ctor_>;\n+\n+/*#[auto_serialize]*/\n type class_ctor_ = {id: node_id,\n                     dec: fn_decl,\n                     body: blk};\n \n+/*#[auto_serialize]*/\n type native_item =\n     {ident: ident,\n      attrs: [attribute],\n      node: native_item_,\n      id: node_id,\n      span: span};\n \n+/*#[auto_serialize]*/\n enum native_item_ {\n     native_item_fn(fn_decl, [ty_param]),\n }\n \n // The data we save and restore about an inlined item or method.  This is not\n // part of the AST that we parse from a file, but it becomes part of the tree\n // that we trans.\n+/*#[auto_serialize]*/\n enum inlined_item {\n     ii_item(@item),\n     ii_method(def_id /* impl id */, @method)"}, {"sha": "44db1b1e1018f22c7df938d693ba5e0be0f8a738", "filename": "src/rustc/syntax/ext/auto_serialize.rs", "status": "modified", "additions": 40, "deletions": 32, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/1600be2c3b1054e2fce59778e2f85d7fa582657f/src%2Frustc%2Fsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1600be2c3b1054e2fce59778e2f85d7fa582657f/src%2Frustc%2Fsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fext%2Fauto_serialize.rs?ref=1600be2c3b1054e2fce59778e2f85d7fa582657f", "patch": "@@ -130,9 +130,14 @@ impl helpers for ext_ctxt {\n           span: span}\n     }\n \n-    fn ty_path(span: span, strs: [str]) -> @ast::ty {\n+    fn path_tps(span: span, strs: [str], tps: [@ast::ty]) -> @ast::path {\n+        @{node: {global: false, idents: strs, types: tps},\n+          span: span}\n+    }\n+\n+    fn ty_path(span: span, strs: [str], tps: [@ast::ty]) -> @ast::ty {\n         @{id: self.next_id(),\n-          node: ast::ty_path(self.path(span, strs), self.next_id()),\n+          node: ast::ty_path(self.path_tps(span, strs, tps), self.next_id()),\n           span: span}\n     }\n \n@@ -469,27 +474,30 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n     }\n }\n \n-fn mk_ser_fn(cx: ext_ctxt, span: span, name: str,\n-             -v_ty: @ast::ty, tps: [ast::ty_param],\n-             f: fn(ext_ctxt, ser_tps_map, @ast::ty,\n+fn mk_ser_fn(cx: ext_ctxt, span: span, name: str, tps: [ast::ty_param],\n+             f: fn(ext_ctxt, ser_tps_map,\n                    -@ast::expr, -@ast::expr) -> [@ast::stmt])\n     -> @ast::item {\n     let ext_cx = cx; // required for #ast\n \n+    let tp_types = vec::map(tps, {|tp| cx.ty_path(span, [tp.ident], [])});\n+    let v_ty = cx.ty_path(span, [name], tp_types);\n+\n     let tp_inputs =\n         vec::map(tps, {|tp|\n             {mode: ast::expl(ast::by_ref),\n              ty: cx.ty_fn(span,\n-                          [cx.ty_path(span, [tp.ident])],\n+                          [cx.ty_path(span, [tp.ident], [])],\n                           cx.ty_nil(span)),\n              ident: \"__s\" + tp.ident,\n              id: cx.next_id()}});\n \n     #debug[\"tp_inputs = %?\", tp_inputs];\n \n+\n     let ser_inputs: [ast::arg] =\n         [{mode: ast::expl(ast::by_ref),\n-          ty: cx.ty_path(span, [\"__S\"]),\n+          ty: cx.ty_path(span, [\"__S\"], []),\n           ident: \"__s\",\n           id: cx.next_id()},\n          {mode: ast::expl(ast::by_ref),\n@@ -510,10 +518,10 @@ fn mk_ser_fn(cx: ext_ctxt, span: span, name: str,\n             });\n     }\n \n-    let ser_bnds = @[ast::bound_iface(cx.ty_path(span,\n-                                                 [\"std\",\n-                                                  \"serialization\",\n-                                                  \"serializer\"]))];\n+    let ser_bnds = @[\n+        ast::bound_iface(cx.ty_path(span,\n+                                    [\"std\", \"serialization\", \"serializer\"],\n+                                    []))];\n \n     let ser_tps: [ast::ty_param] =\n         [{ident: \"__S\",\n@@ -526,7 +534,7 @@ fn mk_ser_fn(cx: ext_ctxt, span: span, name: str,\n                                  span: span};\n \n     let ser_blk = cx.blk(span,\n-                         f(cx, tps_map, v_ty, #ast{ __s }, #ast{ __v }));\n+                         f(cx, tps_map, #ast{ __s }, #ast{ __v }));\n \n     @{ident: \"serialize_\" + name,\n       attrs: [],\n@@ -670,27 +678,28 @@ fn deser_ty(cx: ext_ctxt, tps: deser_tps_map,\n     }\n }\n \n-fn mk_deser_fn(cx: ext_ctxt, span: span, name: str,\n-               -v_ty: @ast::ty, tps: [ast::ty_param],\n-               f: fn(ext_ctxt, deser_tps_map,\n-                     @ast::ty, -@ast::expr) -> @ast::expr)\n+fn mk_deser_fn(cx: ext_ctxt, span: span, name: str, tps: [ast::ty_param],\n+               f: fn(ext_ctxt, deser_tps_map, -@ast::expr) -> @ast::expr)\n     -> @ast::item {\n     let ext_cx = cx; // required for #ast\n \n+    let tp_types = vec::map(tps, {|tp| cx.ty_path(span, [tp.ident], [])});\n+    let v_ty = cx.ty_path(span, [name], tp_types);\n+\n     let tp_inputs =\n         vec::map(tps, {|tp|\n             {mode: ast::expl(ast::by_ref),\n              ty: cx.ty_fn(span,\n                           [],\n-                          cx.ty_path(span, [tp.ident])),\n+                          cx.ty_path(span, [tp.ident], [])),\n              ident: \"__d\" + tp.ident,\n              id: cx.next_id()}});\n \n     #debug[\"tp_inputs = %?\", tp_inputs];\n \n     let deser_inputs: [ast::arg] =\n         [{mode: ast::expl(ast::by_ref),\n-          ty: cx.ty_path(span, [\"__D\"]),\n+          ty: cx.ty_path(span, [\"__D\"], []),\n           ident: \"__d\",\n           id: cx.next_id()}]\n         + tp_inputs;\n@@ -706,18 +715,18 @@ fn mk_deser_fn(cx: ext_ctxt, span: span, name: str,\n             });\n     }\n \n-    let deser_bnds = @[ast::bound_iface(cx.ty_path(span,\n-                                                   [\"std\",\n-                                                    \"serialization\",\n-                                                    \"deserializer\"]))];\n+    let deser_bnds = @[\n+        ast::bound_iface(cx.ty_path(span,\n+                                    [\"std\", \"serialization\", \"deserializer\"],\n+                                    []))];\n \n     let deser_tps: [ast::ty_param] =\n         [{ident: \"__D\",\n           id: cx.next_id(),\n           bounds: deser_bnds}] +\n         vec::map(tps) {|tp| cx.clone_ty_param(tp) };\n \n-    let deser_blk = cx.expr_blk(f(cx, tps_map, v_ty, #ast(expr){__d}));\n+    let deser_blk = cx.expr_blk(f(cx, tps_map, #ast(expr){__d}));\n \n     @{ident: \"deserialize_\" + name,\n       attrs: [],\n@@ -737,14 +746,14 @@ fn ty_fns(cx: ext_ctxt, name: str, ty: @ast::ty, tps: [ast::ty_param])\n \n     let span = ty.span;\n     [\n-        mk_ser_fn(cx, span, name, cx.clone_ty(ty), tps, ser_ty),\n-        mk_deser_fn(cx, span, name, cx.clone_ty(ty), tps, deser_ty)\n+        mk_ser_fn(cx, span, name, tps, ser_ty(_, _, ty, _, _)),\n+        mk_deser_fn(cx, span, name, tps, deser_ty(_, _, ty, _))\n     ]\n }\n \n fn ser_enum(cx: ext_ctxt, tps: ser_tps_map, e_name: str,\n             e_span: span, variants: [ast::variant],\n-            _ty: @ast::ty, -s: @ast::expr, -v: @ast::expr) -> [@ast::stmt] {\n+            -s: @ast::expr, -v: @ast::expr) -> [@ast::stmt] {\n     let ext_cx = cx;\n     let arms = vec::from_fn(vec::len(variants)) {|vidx|\n         let variant = variants[vidx];\n@@ -793,7 +802,7 @@ fn ser_enum(cx: ext_ctxt, tps: ser_tps_map, e_name: str,\n \n fn deser_enum(cx: ext_ctxt, tps: deser_tps_map, e_name: str,\n               e_span: span, variants: [ast::variant],\n-              _ty: @ast::ty, -d: @ast::expr) -> @ast::expr {\n+              -d: @ast::expr) -> @ast::expr {\n     let ext_cx = cx;\n     let arms: [ast::arm] = vec::from_fn(vec::len(variants)) {|vidx|\n         let variant = variants[vidx];\n@@ -831,11 +840,10 @@ fn deser_enum(cx: ext_ctxt, tps: deser_tps_map, e_name: str,\n fn enum_fns(cx: ext_ctxt, e_name: str, e_span: span,\n                variants: [ast::variant], tps: [ast::ty_param])\n     -> [@ast::item] {\n-    let ty = cx.ty_path(e_span, [e_name]);\n     [\n-        mk_ser_fn(cx, e_span, e_name, cx.clone_ty(ty), tps,\n-                  ser_enum(_, _, e_name, e_span, variants, _, _, _)),\n-        mk_deser_fn(cx, e_span, e_name, ty, tps,\n-                    deser_enum(_, _, e_name, e_span, variants, _, _))\n+        mk_ser_fn(cx, e_span, e_name, tps,\n+                  ser_enum(_, _, e_name, e_span, variants, _, _)),\n+        mk_deser_fn(cx, e_span, e_name, tps,\n+                    deser_enum(_, _, e_name, e_span, variants, _))\n     ]\n }"}, {"sha": "eabe25697d940ccb305bd7bdcc81c4bb7e9078a3", "filename": "src/test/run-pass/auto_serialize.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1600be2c3b1054e2fce59778e2f85d7fa582657f/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1600be2c3b1054e2fce59778e2f85d7fa582657f/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize.rs?ref=1600be2c3b1054e2fce59778e2f85d7fa582657f", "patch": "@@ -63,6 +63,15 @@ type uint_vec = [uint];\n #[auto_serialize]\n type point = {x: uint, y: uint};\n \n+#[auto_serialize]\n+enum quark<T> {\n+    top(T),\n+    bottom(T)\n+}\n+\n+#[auto_serialize]\n+type uint_quark = quark<uint>;\n+\n fn main() {\n \n     test_ser_and_deser(plus(@minus(@val(3u), @val(10u)),\n@@ -96,4 +105,16 @@ fn main() {\n                        serialize_uint_vec(_, _),\n                        deserialize_uint_vec(_),\n                        serialize_uint_vec(_, _));\n+\n+    test_ser_and_deser(top(22u),\n+                       \"top(22u)\",\n+                       serialize_uint_quark(_, _),\n+                       deserialize_uint_quark(_),\n+                       serialize_uint_quark(_, _));\n+\n+    test_ser_and_deser(bottom(222u),\n+                       \"bottom(222u)\",\n+                       serialize_uint_quark(_, _),\n+                       deserialize_uint_quark(_),\n+                       serialize_uint_quark(_, _));\n }\n\\ No newline at end of file"}]}