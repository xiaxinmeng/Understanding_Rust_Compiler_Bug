{"sha": "68c4844a1bc35f25d7398e87069a3848d0633798", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4YzQ4NDRhMWJjMzVmMjVkNzM5OGU4NzA2OWEzODQ4ZDA2MzM3OTg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-10-26T13:48:20Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-10-31T16:41:39Z"}, "message": "make nll separately invokable", "tree": {"sha": "68b6f1ba44b8a9b78ba1033eea76956df91a6e15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68b6f1ba44b8a9b78ba1033eea76956df91a6e15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68c4844a1bc35f25d7398e87069a3848d0633798", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68c4844a1bc35f25d7398e87069a3848d0633798", "html_url": "https://github.com/rust-lang/rust/commit/68c4844a1bc35f25d7398e87069a3848d0633798", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68c4844a1bc35f25d7398e87069a3848d0633798/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dde61f38557335870a2d53bfa4099466fb71bd60", "url": "https://api.github.com/repos/rust-lang/rust/commits/dde61f38557335870a2d53bfa4099466fb71bd60", "html_url": "https://github.com/rust-lang/rust/commit/dde61f38557335870a2d53bfa4099466fb71bd60"}], "stats": {"total": 42, "additions": 13, "deletions": 29}, "files": [{"sha": "7df217c62e35a97fc2d74d7b50c3afe38d592287", "filename": "src/librustc_mir/transform/nll/mod.rs", "status": "modified", "additions": 13, "deletions": 29, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/68c4844a1bc35f25d7398e87069a3848d0633798/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c4844a1bc35f25d7398e87069a3848d0633798/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs?ref=68c4844a1bc35f25d7398e87069a3848d0633798", "patch": "@@ -24,7 +24,7 @@ use self::mir_util::PassWhere;\n mod constraint_generation;\n mod subtype;\n \n-mod region_infer;\n+pub(crate) mod region_infer;\n use self::region_infer::RegionInferenceContext;\n \n mod renumber;\n@@ -43,33 +43,23 @@ impl MirPass for NLL {\n             return;\n         }\n \n-        tcx.infer_ctxt()\n-            .enter(|ref infcx| drop(compute_regions(infcx, source, input_mir)));\n+        tcx.infer_ctxt().enter(|ref infcx| {\n+            let mut mir = input_mir.clone();\n+            let _ = compute_regions(infcx, source, &mut mir);\n+        });\n     }\n }\n \n-pub struct RegionComputation<'tcx> {\n-    /// A rewritten version of the input MIR where all the regions are\n-    /// rewritten to refer to inference variables.\n-    pub mir: Mir<'tcx>,\n-\n-    /// The definitions (along with their final values) for all regions.\n-    pub regioncx: RegionInferenceContext,\n-}\n-\n /// Computes the (non-lexical) regions from the input MIR.\n ///\n /// This may result in errors being reported.\n pub fn compute_regions<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     source: MirSource,\n-    input_mir: &Mir<'tcx>,\n-) -> RegionComputation<'tcx> {\n-    // Clone mir so we can mutate it without disturbing the rest of the compiler\n-    let mut mir = input_mir.clone();\n-\n+    mir: &mut Mir<'tcx>,\n+) -> RegionInferenceContext {\n     // Replace all regions with fresh inference variables.\n-    let num_region_variables = renumber::renumber_mir(infcx, &mut mir);\n+    let num_region_variables = renumber::renumber_mir(infcx, mir);\n \n     // Compute what is live where.\n     let liveness = &LivenessResults {\n@@ -98,13 +88,11 @@ pub fn compute_regions<'a, 'gcx, 'tcx>(\n \n     assert!(errors.is_empty(), \"FIXME: report region inference failures\");\n \n-    let computation = RegionComputation { mir, regioncx };\n-\n     // Dump MIR results into a file, if that is enabled. This let us\n     // write unit-tests.\n-    dump_mir_results(infcx, liveness, source, &computation);\n+    dump_mir_results(infcx, liveness, source, &mir, &regioncx);\n \n-    computation\n+    regioncx\n }\n \n struct LivenessResults {\n@@ -116,17 +104,13 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     liveness: &LivenessResults,\n     source: MirSource,\n-    computation: &RegionComputation<'tcx>,\n+    mir: &Mir<'tcx>,\n+    regioncx: &RegionInferenceContext,\n ) {\n     if !mir_util::dump_enabled(infcx.tcx, \"nll\", source) {\n         return;\n     }\n \n-    let RegionComputation {\n-        ref mir,\n-        ref regioncx,\n-    } = *computation;\n-\n     let regular_liveness_per_location: FxHashMap<_, _> = mir.basic_blocks()\n         .indices()\n         .flat_map(|bb| {\n@@ -216,7 +200,7 @@ newtype_index!(RegionIndex {\n /// assert that the region is a `ReVar` and convert the internal index\n /// into a `RegionIndex`. This is reasonable because in our MIR we\n /// replace all free regions with inference variables.\n-trait ToRegionIndex {\n+pub trait ToRegionIndex {\n     fn to_region_index(&self) -> RegionIndex;\n }\n "}]}