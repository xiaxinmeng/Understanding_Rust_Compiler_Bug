{"sha": "59b0077565bc056283dad048a237dbc183000c76", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5YjAwNzc1NjViYzA1NjI4M2RhZDA0OGEyMzdkYmMxODMwMDBjNzY=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-no-reply-9879165716479413131@oli-obk.de", "date": "2016-12-01T21:31:56Z"}, "committer": {"name": "Oliver Schneider", "email": "git-no-reply-9879165716479413131@oli-obk.de", "date": "2016-12-01T21:31:56Z"}, "message": "WIP compiles and doesn't crash (much) but tests are failing", "tree": {"sha": "cd84c2f219e0a01c07103fabc6768bc3a042ccd5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd84c2f219e0a01c07103fabc6768bc3a042ccd5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59b0077565bc056283dad048a237dbc183000c76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59b0077565bc056283dad048a237dbc183000c76", "html_url": "https://github.com/rust-lang/rust/commit/59b0077565bc056283dad048a237dbc183000c76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59b0077565bc056283dad048a237dbc183000c76/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9fe50da1ed24fc02da84d526d8d2b9ba91682cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9fe50da1ed24fc02da84d526d8d2b9ba91682cb", "html_url": "https://github.com/rust-lang/rust/commit/f9fe50da1ed24fc02da84d526d8d2b9ba91682cb"}], "stats": {"total": 734, "additions": 387, "deletions": 347}, "files": [{"sha": "9f798c31af18c7de60136308e65e0904be62587c", "filename": "CHANGELOG.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -1,6 +1,9 @@\n # Change Log\n All notable changes to this project will be documented in this file.\n \n+## 0.0.104 \u2014 2016-12-01\n+* Update to *rustc 1.15.0-nightly (1c448574b 2016-11-28)*\n+\n ## 0.0.103 \u2014 2016-11-25\n * Update to *rustc 1.15.0-nightly (d5814b03e 2016-11-23)*\n "}, {"sha": "0d5e5a4cde6b880dfb27f1586326e8166fbe530b", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -105,15 +105,15 @@ impl LateLintPass for AttrPass {\n         }\n         match item.node {\n             ItemExternCrate(_) |\n-            ItemUse(_) => {\n+            ItemUse(_, _) => {\n                 for attr in &item.attrs {\n                     if let MetaItemKind::List(ref lint_list) = attr.value.node {\n                         match &*attr.name().as_str() {\n                             \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n                                 // whitelist `unused_imports`\n                                 for lint in lint_list {\n                                     if is_word(lint, \"unused_imports\") {\n-                                        if let ItemUse(_) = item.node {\n+                                        if let ItemUse(_, _) = item.node {\n                                             return;\n                                         }\n                                     }\n@@ -193,8 +193,8 @@ fn is_relevant_expr(cx: &LateContext, expr: &Expr) -> bool {\n         ExprRet(Some(ref e)) => is_relevant_expr(cx, e),\n         ExprRet(None) | ExprBreak(_, None) => false,\n         ExprCall(ref path_expr, _) => {\n-            if let ExprPath(..) = path_expr.node {\n-                let fun_id = resolve_node(cx, path_expr.id).expect(\"function should be resolved\").def_id();\n+            if let ExprPath(ref qpath) = path_expr.node {\n+                let fun_id = resolve_node(cx, qpath, path_expr.id).def_id();\n                 !match_def_path(cx, fun_id, &paths::BEGIN_PANIC)\n             } else {\n                 true"}, {"sha": "8a4664d62b72bf4065a738bf2fe88620759a4275", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -1,5 +1,5 @@\n use rustc::hir::*;\n-use rustc::hir::def::{Def, PathResolution};\n+use rustc::hir::def::Def;\n use rustc::lint::*;\n use rustc_const_eval::lookup_const_by_id;\n use syntax::ast::LitKind;\n@@ -245,18 +245,13 @@ fn fetch_int_literal(cx: &LateContext, lit: &Expr) -> Option<u64> {\n                 None\n             }\n         }\n-        ExprPath(_, _) => {\n-            {\n-                // Important to let the borrow expire before the const lookup to avoid double\n-                // borrowing.\n-                let def_map = cx.tcx.def_map.borrow();\n-                match def_map.get(&lit.id) {\n-                    Some(&PathResolution { base_def: Def::Const(def_id), .. }) => Some(def_id),\n-                    _ => None,\n-                }\n+        ExprPath(ref qpath) => {\n+            let def = cx.tcx.tables().qpath_def(qpath, lit.id);\n+            if let Def::Const(def_id) = def {\n+                lookup_const_by_id(cx.tcx, def_id, None).and_then(|(l, _ty)| fetch_int_literal(cx, l))\n+            } else {\n+                None\n             }\n-            .and_then(|def_id| lookup_const_by_id(cx.tcx, def_id, None))\n-            .and_then(|(l, _ty)| fetch_int_literal(cx, l))\n         }\n         _ => None,\n     }"}, {"sha": "ce7adda092cdf0458995d7c7a84b1bf712451bea", "filename": "clippy_lints/src/blacklisted_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblacklisted_name.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -39,7 +39,7 @@ impl LintPass for BlackListedName {\n \n impl LateLintPass for BlackListedName {\n     fn check_pat(&mut self, cx: &LateContext, pat: &Pat) {\n-        if let PatKind::Binding(_, ref ident, _) = pat.node {\n+        if let PatKind::Binding(_, _, ref ident, _) = pat.node {\n             if self.blacklist.iter().any(|s| s == &*ident.node.as_str()) {\n                 span_lint(cx,\n                           BLACKLISTED_NAME,"}, {"sha": "afbf9666b10a49b09b388c26d3642b1a173b4698", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -1,7 +1,7 @@\n #![allow(cast_possible_truncation)]\n \n use rustc::lint::LateContext;\n-use rustc::hir::def::{Def, PathResolution};\n+use rustc::hir::def::Def;\n use rustc_const_eval::lookup_const_by_id;\n use rustc_const_math::{ConstInt, ConstUsize, ConstIsize};\n use rustc::hir::*;\n@@ -10,7 +10,7 @@ use std::cmp::PartialOrd;\n use std::hash::{Hash, Hasher};\n use std::mem;\n use std::rc::Rc;\n-use syntax::ast::{FloatTy, LitIntType, LitKind, StrStyle, UintTy, IntTy};\n+use syntax::ast::{FloatTy, LitIntType, LitKind, StrStyle, UintTy, IntTy, NodeId};\n use syntax::ptr::P;\n \n #[derive(Debug, Copy, Clone)]\n@@ -252,7 +252,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n     /// simple constant folding: Insert an expression, get a constant or none.\n     fn expr(&mut self, e: &Expr) -> Option<Constant> {\n         match e.node {\n-            ExprPath(_, _) => self.fetch_path(e),\n+            ExprPath(ref qpath) => self.fetch_path(qpath, e.id),\n             ExprBlock(ref block) => self.block(block),\n             ExprIf(ref cond, ref then, ref otherwise) => self.ifthenelse(cond, then, otherwise),\n             ExprLit(ref lit) => Some(lit_to_constant(&lit.node)),\n@@ -285,21 +285,22 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n     }\n \n     /// lookup a possibly constant expression from a ExprPath\n-    fn fetch_path(&mut self, e: &Expr) -> Option<Constant> {\n+    fn fetch_path(&mut self, qpath: &QPath, id: NodeId) -> Option<Constant> {\n         if let Some(lcx) = self.lcx {\n-            let mut maybe_id = None;\n-            if let Some(&PathResolution { base_def: Def::Const(id), .. }) = lcx.tcx.def_map.borrow().get(&e.id) {\n-                maybe_id = Some(id);\n-            }\n-            // separate if lets to avoid double borrowing the def_map\n-            if let Some(id) = maybe_id {\n-                if let Some((const_expr, _ty)) = lookup_const_by_id(lcx.tcx, id, None) {\n-                    let ret = self.expr(const_expr);\n-                    if ret.is_some() {\n-                        self.needed_resolution = true;\n+            let def = lcx.tcx.tables().qpath_def(qpath, id);\n+            match def {\n+                Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n+                    let substs = Some(lcx.tcx.tables().node_id_item_substs(id)\n+                        .unwrap_or_else(|| lcx.tcx.intern_substs(&[])));\n+                    if let Some((const_expr, _ty)) = lookup_const_by_id(lcx.tcx, def_id, substs) {\n+                        let ret = self.expr(const_expr);\n+                        if ret.is_some() {\n+                            self.needed_resolution = true;\n+                        }\n+                        return ret;\n                     }\n-                    return ret;\n-                }\n+                },\n+                _ => {},\n             }\n         }\n         None"}, {"sha": "726b8f214fa811e80032b651a32feae104205a3d", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -254,7 +254,7 @@ fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> HashMap<Interned\n                     bindings_impl(cx, pat, map);\n                 }\n             }\n-            PatKind::Binding(_, ref ident, ref as_pat) => {\n+            PatKind::Binding(_, _, ref ident, ref as_pat) => {\n                 if let Entry::Vacant(v) = map.entry(ident.node.as_str()) {\n                     v.insert(cx.tcx.tables().pat_ty(pat));\n                 }"}, {"sha": "35ea620c128350bc215bffa7b757bbebd4d6613d", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -5,7 +5,7 @@ use rustc::ty;\n use rustc::hir::*;\n use syntax::codemap::Span;\n use utils::paths;\n-use utils::{is_automatically_derived, match_path, span_lint_and_then};\n+use utils::{is_automatically_derived, span_lint_and_then, match_path_old};\n \n /// **What it does:** Checks for deriving `Hash` but implementing `PartialEq`\n /// explicitly.\n@@ -89,7 +89,7 @@ impl LateLintPass for Derive {\n fn check_hash_peq<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, span: Span, trait_ref: &TraitRef, ty: ty::Ty<'tcx>,\n                                 hash_is_automatically_derived: bool) {\n     if_let_chain! {[\n-        match_path(&trait_ref.path, &paths::HASH),\n+        match_path_old(&trait_ref.path, &paths::HASH),\n         let Some(peq_trait_def_id) = cx.tcx.lang_items.eq_trait()\n     ], {\n         let peq_trait_def = cx.tcx.lookup_trait_def(peq_trait_def_id);\n@@ -131,7 +131,7 @@ fn check_hash_peq<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, span: Span, trait_re\n \n /// Implementation of the `EXPL_IMPL_CLONE_ON_COPY` lint.\n fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, item: &Item, trait_ref: &TraitRef, ty: ty::Ty<'tcx>) {\n-    if match_path(&trait_ref.path, &paths::CLONE_TRAIT) {\n+    if match_path_old(&trait_ref.path, &paths::CLONE_TRAIT) {\n         let parameter_environment = ty::ParameterEnvironment::for_item(cx.tcx, item.id);\n         let subst_ty = ty.subst(cx.tcx, parameter_environment.free_substs);\n "}, {"sha": "dc240a0df7d5f6e0c0ca4f3e2fdffc1c67cb7376", "filename": "clippy_lints/src/drop_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fdrop_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fdrop_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_ref.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -38,8 +38,8 @@ impl LintPass for Pass {\n impl LateLintPass for Pass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprCall(ref path, ref args) = expr.node {\n-            if let ExprPath(None, _) = path.node {\n-                let def_id = cx.tcx.expect_def(path.id).def_id();\n+            if let ExprPath(ref qpath) = path.node {\n+                let def_id = cx.tcx.tables().qpath_def(qpath, path.id).def_id();\n                 if match_def_path(cx, def_id, &paths::DROP) {\n                     if args.len() != 1 {\n                         return;"}, {"sha": "f4f8d6f378b711a158e7c34e4fb5a655aaa8744f", "filename": "clippy_lints/src/enum_glob_use.rs", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_glob_use.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -2,8 +2,7 @@\n \n use rustc::hir::*;\n use rustc::hir::def::Def;\n-use rustc::hir::map::Node::NodeItem;\n-use rustc::lint::{LateLintPass, LintPass, LateContext, LintArray, LintContext};\n+use rustc::lint::{LateLintPass, LintPass, LateContext, LintArray};\n use syntax::ast::NodeId;\n use syntax::codemap::Span;\n use utils::span_lint;\n@@ -48,24 +47,9 @@ impl EnumGlobUse {\n         if item.vis == Visibility::Public {\n             return; // re-exports are fine\n         }\n-        if let ItemUse(ref item_use) = item.node {\n-            if let ViewPath_::ViewPathGlob(_) = item_use.node {\n-                if let Some(def) = cx.tcx.def_map.borrow().get(&item.id) {\n-                    if let Some(node_id) = cx.tcx.map.as_local_node_id(def.full_def().def_id()) {\n-                        if let Some(NodeItem(it)) = cx.tcx.map.find(node_id) {\n-                            if let ItemEnum(..) = it.node {\n-                                span_lint(cx, ENUM_GLOB_USE, item.span, \"don't use glob imports for enum variants\");\n-                            }\n-                        }\n-                    } else {\n-                        let child = cx.sess().cstore.item_children(def.full_def().def_id());\n-                        if let Some(child) = child.first() {\n-                            if let Def::Variant(..) = child.def {\n-                                span_lint(cx, ENUM_GLOB_USE, item.span, \"don't use glob imports for enum variants\");\n-                            }\n-                        }\n-                    }\n-                }\n+        if let ItemUse(ref path, UseKind::Glob) = item.node {\n+            if let Def::Enum(_) = path.def {\n+                span_lint(cx, ENUM_GLOB_USE, item.span, \"don't use glob imports for enum variants\");\n             }\n         }\n     }"}, {"sha": "d915755fbd121a396a31271e4e06c47666f71030", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -72,9 +72,9 @@ fn check_closure(cx: &LateContext, expr: &Expr) {\n                 _ => (),\n             }\n             for (a1, a2) in decl.inputs.iter().zip(args) {\n-                if let PatKind::Binding(_, ident, _) = a1.pat.node {\n+                if let PatKind::Binding(_, _, ident, _) = a1.pat.node {\n                     // XXXManishearth Should I be checking the binding mode here?\n-                    if let ExprPath(None, ref p) = a2.node {\n+                    if let ExprPath(QPath::Resolved(None, ref p)) = a2.node {\n                         if p.segments.len() != 1 {\n                             // If it's a proper path, it can't be a local variable\n                             return;"}, {"sha": "5998f41512970b88c8e5879886c6b60f9cee28b6", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -61,16 +61,18 @@ impl LateLintPass for EvalOrderDependence {\n         // Find a write to a local variable.\n         match expr.node {\n             ExprAssign(ref lhs, _) | ExprAssignOp(_, ref lhs, _) => {\n-                if let ExprPath(None, ref path) = lhs.node {\n-                    if path.segments.len() == 1 {\n-                        let var = cx.tcx.expect_def(lhs.id).def_id();\n-                        let mut visitor = ReadVisitor {\n-                            cx: cx,\n-                            var: var,\n-                            write_expr: expr,\n-                            last_expr: expr,\n-                        };\n-                        check_for_unsequenced_reads(&mut visitor);\n+                if let ExprPath(ref qpath) = lhs.node {\n+                    if let QPath::Resolved(_, ref path) = *qpath {\n+                        if path.segments.len() == 1 {\n+                            let var = cx.tcx.tables().qpath_def(qpath, lhs.id).def_id();\n+                            let mut visitor = ReadVisitor {\n+                                cx: cx,\n+                                var: var,\n+                                write_expr: expr,\n+                                last_expr: expr,\n+                            };\n+                            check_for_unsequenced_reads(&mut visitor);\n+                        }\n                     }\n                 }\n             }\n@@ -293,19 +295,21 @@ impl<'v, 't> Visitor<'v> for ReadVisitor<'v, 't> {\n         }\n \n         match expr.node {\n-            ExprPath(None, ref path) => {\n-                if path.segments.len() == 1 && self.cx.tcx.expect_def(expr.id).def_id() == self.var {\n-                    if is_in_assignment_position(self.cx, expr) {\n-                        // This is a write, not a read.\n-                    } else {\n-                        span_note_and_lint(\n-                            self.cx,\n-                            EVAL_ORDER_DEPENDENCE,\n-                            expr.span,\n-                            \"unsequenced read of a variable\",\n-                            self.write_expr.span,\n-                            \"whether read occurs before this write depends on evaluation order\"\n-                        );\n+            ExprPath(ref qpath) => {\n+                if let QPath::Resolved(None, ref path) = *qpath {\n+                    if path.segments.len() == 1 && self.cx.tcx.tables().qpath_def(qpath, expr.id).def_id() == self.var {\n+                        if is_in_assignment_position(self.cx, expr) {\n+                            // This is a write, not a read.\n+                        } else {\n+                            span_note_and_lint(\n+                                self.cx,\n+                                EVAL_ORDER_DEPENDENCE,\n+                                expr.span,\n+                                \"unsequenced read of a variable\",\n+                                self.write_expr.span,\n+                                \"whether read occurs before this write depends on evaluation order\"\n+                            );\n+                        }\n                     }\n                 }\n             }"}, {"sha": "92970bc5e01b269a2b3f218b7aff2f50adfc82d0", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -45,10 +45,9 @@ impl LateLintPass for Pass {\n                 // `format!(\"{}\", foo)` expansion\n                 ExprCall(ref fun, ref args) => {\n                     if_let_chain!{[\n-                        let ExprPath(..) = fun.node,\n+                        let ExprPath(ref qpath) = fun.node,\n                         args.len() == 2,\n-                        let Some(fun) = resolve_node(cx, fun.id),\n-                        match_def_path(cx, fun.def_id(), &paths::FMT_ARGUMENTS_NEWV1),\n+                        match_def_path(cx, resolve_node(cx, qpath, fun.id).def_id(), &paths::FMT_ARGUMENTS_NEWV1),\n                         // ensure the format string is `\"{..}\"` with only one argument and no text\n                         check_static_str(cx, &args[0]),\n                         // ensure the format argument is `{}` ie. Display with no fancy option\n@@ -129,9 +128,8 @@ fn check_arg_is_display(cx: &LateContext, expr: &Expr) -> bool {\n         exprs.len() == 1,\n         let ExprCall(_, ref args) = exprs[0].node,\n         args.len() == 2,\n-        let ExprPath(None, _) = args[1].node,\n-        let Some(fun) = resolve_node(cx, args[1].id),\n-        match_def_path(cx, fun.def_id(), &paths::DISPLAY_FMT_METHOD),\n+        let ExprPath(ref qpath) = args[1].node,\n+        match_def_path(cx, resolve_node(cx, qpath, args[1].id).def_id(), &paths::DISPLAY_FMT_METHOD),\n     ], {\n         let ty = walk_ptrs_ty(cx.tcx.tables().pat_ty(&pat[0]));\n "}, {"sha": "82f210f3d507512c7af0a4f8ac479823938daef2", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -138,9 +138,9 @@ impl Functions {\n     }\n }\n \n-fn raw_ptr_arg(cx: &LateContext, arg: &hir::Arg) -> Option<hir::def_id::DefId> {\n-    if let (&hir::PatKind::Binding(_, _, _), &hir::TyPtr(_)) = (&arg.pat.node, &arg.ty.node) {\n-        cx.tcx.def_map.borrow().get(&arg.pat.id).map(|pr| pr.full_def().def_id())\n+fn raw_ptr_arg(_cx: &LateContext, arg: &hir::Arg) -> Option<hir::def_id::DefId> {\n+    if let (&hir::PatKind::Binding(_, def_id, _, _), &hir::TyPtr(_)) = (&arg.pat.node, &arg.ty.node) {\n+        Some(def_id)\n     } else {\n         None\n     }\n@@ -183,8 +183,9 @@ impl<'a, 'tcx, 'v> hir::intravisit::Visitor<'v> for DerefVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx: 'a> DerefVisitor<'a, 'tcx> {\n     fn check_arg(&self, ptr: &hir::Expr) {\n-        if let Some(def) = self.cx.tcx.def_map.borrow().get(&ptr.id) {\n-            if self.ptrs.contains(&def.full_def().def_id()) {\n+        if let hir::ExprPath(ref qpath) = ptr.node {\n+            let def = self.cx.tcx.tables().qpath_def(qpath, ptr.id);\n+            if self.ptrs.contains(&def.def_id()) {\n                 span_lint(self.cx,\n                           NOT_UNSAFE_PTR_ARG_DEREF,\n                           ptr.span,"}, {"sha": "878a1b7313b259a491986086cf83de67a403787c", "filename": "clippy_lints/src/if_let_redundant_pattern_matching.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -63,7 +63,7 @@ impl LateLintPass for Pass {\n                         }\n                     }\n \n-                    PatKind::Path(_, ref path) if match_path(path, &paths::OPTION_NONE) => {\n+                    PatKind::Path(ref path) if match_path(path, &paths::OPTION_NONE) => {\n                         \"is_none()\"\n                     }\n "}, {"sha": "e1f20eb1859f33eb5dd2b02ab5638a53f288d176", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -65,19 +65,18 @@ impl LateLintPass for LetIfSeq {\n                 let Some(expr) = it.peek(),\n                 let hir::StmtDecl(ref decl, _) = stmt.node,\n                 let hir::DeclLocal(ref decl) = decl.node,\n-                let hir::PatKind::Binding(mode, ref name, None) = decl.pat.node,\n-                let Some(def) = cx.tcx.def_map.borrow().get(&decl.pat.id),\n+                let hir::PatKind::Binding(mode, def_id, ref name, None) = decl.pat.node,\n                 let hir::StmtExpr(ref if_, _) = expr.node,\n                 let hir::ExprIf(ref cond, ref then, ref else_) = if_.node,\n-                !used_in_expr(cx, def.full_def().def_id(), cond),\n-                let Some(value) = check_assign(cx, def.full_def().def_id(), then),\n-                !used_in_expr(cx, def.full_def().def_id(), value),\n+                !used_in_expr(cx, def_id, cond),\n+                let Some(value) = check_assign(cx, def_id, then),\n+                !used_in_expr(cx, def_id, value),\n             ], {\n                 let span = codemap::mk_sp(stmt.span.lo, if_.span.hi);\n \n                 let (default_multi_stmts, default) = if let Some(ref else_) = *else_ {\n                     if let hir::ExprBlock(ref else_) = else_.node {\n-                        if let Some(default) = check_assign(cx, def.full_def().def_id(), else_) {\n+                        if let Some(default) = check_assign(cx, def_id, else_) {\n                             (else_.stmts.len() > 1, default)\n                         } else if let Some(ref default) = decl.init {\n                             (true, &**default)\n@@ -137,9 +136,8 @@ struct UsedVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx, 'v> hir::intravisit::Visitor<'v> for UsedVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'v hir::Expr) {\n         if_let_chain! {[\n-            let hir::ExprPath(None, _) = expr.node,\n-            let Some(def) = self.cx.tcx.def_map.borrow().get(&expr.id),\n-            self.id == def.full_def().def_id(),\n+            let hir::ExprPath(ref qpath) = expr.node,\n+            self.id == self.cx.tcx.tables().qpath_def(qpath, expr.id).def_id(),\n         ], {\n             self.used = true;\n             return;\n@@ -154,9 +152,8 @@ fn check_assign<'e>(cx: &LateContext, decl: hir::def_id::DefId, block: &'e hir::\n         let Some(expr) = block.stmts.iter().last(),\n         let hir::StmtSemi(ref expr, _) = expr.node,\n         let hir::ExprAssign(ref var, ref value) = expr.node,\n-        let hir::ExprPath(None, _) = var.node,\n-        let Some(def) = cx.tcx.def_map.borrow().get(&var.id),\n-        decl == def.full_def().def_id(),\n+        let hir::ExprPath(ref qpath) = var.node,\n+        decl == cx.tcx.tables().qpath_def(qpath, var.id).def_id(),\n     ], {\n         let mut v = UsedVisitor {\n             cx: cx,"}, {"sha": "7e2b85df572e5a1c817f9084cde778a0d60a9e69", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -256,7 +256,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box functions::Functions::new(conf.too_many_arguments_threshold));\n     reg.register_early_lint_pass(box doc::Doc::new(conf.doc_valid_idents));\n     reg.register_late_lint_pass(box neg_multiply::NegMultiply);\n-    reg.register_late_lint_pass(box unsafe_removed_from_name::UnsafeNameRemoval);\n+    reg.register_early_lint_pass(box unsafe_removed_from_name::UnsafeNameRemoval);\n     reg.register_late_lint_pass(box mem_forget::MemForget);\n     reg.register_late_lint_pass(box arithmetic::Arithmetic::default());\n     reg.register_late_lint_pass(box assign_ops::AssignOps);"}, {"sha": "236919bfc25341c016a5963b19458e00415d1293", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -239,12 +239,12 @@ impl<'v, 't> RefVisitor<'v, 't> {\n         self.lts\n     }\n \n-    fn collect_anonymous_lifetimes(&mut self, path: &Path, ty: &Ty) {\n-        let last_path_segment = path.segments.last().map(|s| &s.parameters);\n-        if let Some(&AngleBracketedParameters(ref params)) = last_path_segment {\n-            if params.lifetimes.is_empty() {\n-                if let Some(def) = self.cx.tcx.def_map.borrow().get(&ty.id).map(|r| r.full_def()) {\n-                    match def {\n+    fn collect_anonymous_lifetimes(&mut self, qpath: &QPath, ty: &Ty) {\n+        if let QPath::Resolved(_, ref path) = *qpath {\n+            let last_path_segment = path.segments.last().map(|s| &s.parameters);\n+            if let Some(&AngleBracketedParameters(ref params)) = last_path_segment {\n+                if params.lifetimes.is_empty() {\n+                    match self.cx.tcx.tables().qpath_def(qpath, ty.id) {\n                         Def::TyAlias(def_id) |\n                         Def::Struct(def_id) => {\n                             let generics = self.cx.tcx.item_generics(def_id);\n@@ -277,7 +277,7 @@ impl<'v, 't> Visitor<'v> for RefVisitor<'v, 't> {\n             TyRptr(None, _) => {\n                 self.record(&None);\n             }\n-            TyPath(_, ref path) => {\n+            TyPath(ref path) => {\n                 self.collect_anonymous_lifetimes(path, ty);\n             }\n             _ => (),"}, {"sha": "d752e78cddf823ebdae7cbe2ec33ce5696854261", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 48, "deletions": 44, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -366,26 +366,28 @@ impl LateLintPass for Pass {\n         }\n         if let ExprMatch(ref match_expr, ref arms, MatchSource::WhileLetDesugar) = expr.node {\n             let pat = &arms[0].pats[0].node;\n-            if let (&PatKind::TupleStruct(ref path, ref pat_args, _),\n+            if let (&PatKind::TupleStruct(ref qpath, ref pat_args, _),\n                     &ExprMethodCall(method_name, _, ref method_args)) = (pat, &match_expr.node) {\n                 let iter_expr = &method_args[0];\n-                if let Some(lhs_constructor) = path.segments.last() {\n-                    if &*method_name.node.as_str() == \"next\" &&\n-                       match_trait_method(cx, match_expr, &paths::ITERATOR) &&\n-                       &*lhs_constructor.name.as_str() == \"Some\" &&\n-                       !is_refutable(cx, &pat_args[0]) &&\n-                       !is_iterator_used_after_while_let(cx, iter_expr) {\n-                        let iterator = snippet(cx, method_args[0].span, \"_\");\n-                        let loop_var = snippet(cx, pat_args[0].span, \"_\");\n-                        span_lint_and_then(cx,\n-                                           WHILE_LET_ON_ITERATOR,\n-                                           expr.span,\n-                                           \"this loop could be written as a `for` loop\",\n-                                           |db| {\n-                        db.span_suggestion(expr.span,\n-                                           \"try\",\n-                                           format!(\"for {} in {} {{ .. }}\", loop_var, iterator));\n-                        });\n+                if let QPath::Resolved(_, ref path) = *qpath {\n+                    if let Some(lhs_constructor) = path.segments.last() {\n+                        if &*method_name.node.as_str() == \"next\" &&\n+                           match_trait_method(cx, match_expr, &paths::ITERATOR) &&\n+                           &*lhs_constructor.name.as_str() == \"Some\" &&\n+                           !is_refutable(cx, &pat_args[0]) &&\n+                           !is_iterator_used_after_while_let(cx, iter_expr) {\n+                            let iterator = snippet(cx, method_args[0].span, \"_\");\n+                            let loop_var = snippet(cx, pat_args[0].span, \"_\");\n+                            span_lint_and_then(cx,\n+                                               WHILE_LET_ON_ITERATOR,\n+                                               expr.span,\n+                                               \"this loop could be written as a `for` loop\",\n+                                               |db| {\n+                            db.span_suggestion(expr.span,\n+                                               \"try\",\n+                                               format!(\"for {} in {} {{ .. }}\", loop_var, iterator));\n+                            });\n+                        }\n                     }\n                 }\n             }\n@@ -421,10 +423,10 @@ fn check_for_loop(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &E\n fn check_for_loop_range(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &Expr) {\n     if let Some(higher::Range { start: Some(start), ref end, limits }) = higher::range(arg) {\n         // the var must be a single name\n-        if let PatKind::Binding(_, ref ident, _) = pat.node {\n+        if let PatKind::Binding(_, def_id, ref ident, _) = pat.node {\n             let mut visitor = VarVisitor {\n                 cx: cx,\n-                var: cx.tcx.expect_def(pat.id).def_id(),\n+                var: def_id,\n                 indexed: HashMap::new(),\n                 nonindex: false,\n             };\n@@ -510,7 +512,7 @@ fn is_len_call(expr: &Expr, var: &Name) -> bool {\n         let ExprMethodCall(method, _, ref len_args) = expr.node,\n         len_args.len() == 1,\n         &*method.node.as_str() == \"len\",\n-        let ExprPath(_, ref path) = len_args[0].node,\n+        let ExprPath(QPath::Resolved(_, ref path)) = len_args[0].node,\n         path.segments.len() == 1,\n         &path.segments[0].name == var\n     ], {\n@@ -732,7 +734,7 @@ fn check_for_loop_over_map_kv(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Ex\n fn pat_is_wild(pat: &PatKind, body: &Expr) -> bool {\n     match *pat {\n         PatKind::Wild => true,\n-        PatKind::Binding(_, ident, None) if ident.node.as_str().starts_with('_') => {\n+        PatKind::Binding(_, _, ident, None) if ident.node.as_str().starts_with('_') => {\n             let mut visitor = UsedVisitor {\n                 var: ident.node,\n                 used: false,\n@@ -751,7 +753,7 @@ struct UsedVisitor {\n \n impl<'a> Visitor<'a> for UsedVisitor {\n     fn visit_expr(&mut self, expr: &Expr) {\n-        if let ExprPath(None, ref path) = expr.node {\n+        if let ExprPath(QPath::Resolved(None, ref path)) = expr.node {\n             if path.segments.len() == 1 && path.segments[0].name == self.var {\n                 self.used = true;\n                 return;\n@@ -771,20 +773,21 @@ struct VarVisitor<'v, 't: 'v> {\n \n impl<'v, 't> Visitor<'v> for VarVisitor<'v, 't> {\n     fn visit_expr(&mut self, expr: &'v Expr) {\n-        if let ExprPath(None, ref path) = expr.node {\n-            if path.segments.len() == 1 && self.cx.tcx.expect_def(expr.id).def_id() == self.var {\n-                // we are referencing our variable! now check if it's as an index\n-                if_let_chain! {[\n-                    let Some(parexpr) = get_parent_expr(self.cx, expr),\n-                    let ExprIndex(ref seqexpr, _) = parexpr.node,\n-                    let ExprPath(None, ref seqvar) = seqexpr.node,\n-                    seqvar.segments.len() == 1\n-                ], {\n-                    let def_map = self.cx.tcx.def_map.borrow();\n-                    if let Some(def) = def_map.get(&seqexpr.id) {\n-                        match def.base_def {\n+        if let ExprPath(ref qpath) = expr.node {\n+            if let QPath::Resolved(None, ref path) = *qpath {\n+                if path.segments.len() == 1 && self.cx.tcx.tables().qpath_def(qpath, expr.id).def_id() == self.var {\n+                    // we are referencing our variable! now check if it's as an index\n+                    if_let_chain! {[\n+                        let Some(parexpr) = get_parent_expr(self.cx, expr),\n+                        let ExprIndex(ref seqexpr, _) = parexpr.node,\n+                        let ExprPath(ref seqpath) = seqexpr.node,\n+                        let QPath::Resolved(None, ref seqvar) = *seqpath,\n+                        seqvar.segments.len() == 1\n+                    ], {\n+                        let def = self.cx.tcx.tables().qpath_def(seqpath, seqexpr.id);\n+                        match def {\n                             Def::Local(..) | Def::Upvar(..) => {\n-                                let def_id = def.base_def.def_id();\n+                                let def_id = def.def_id();\n                                 let node_id = self.cx.tcx.map.as_local_node_id(def_id).unwrap();\n \n                                 let extent = self.cx.tcx.region_maps.var_scope(node_id);\n@@ -797,11 +800,11 @@ impl<'v, 't> Visitor<'v> for VarVisitor<'v, 't> {\n                             }\n                             _ => (),\n                         }\n-                    }\n-                }}\n-                // we are not indexing anything, record that\n-                self.nonindex = true;\n-                return;\n+                    }}\n+                    // we are not indexing anything, record that\n+                    self.nonindex = true;\n+                    return;\n+                }\n             }\n         }\n         walk_expr(self, expr);\n@@ -1002,7 +1005,7 @@ impl<'v, 't> Visitor<'v> for InitializeVisitor<'v, 't> {\n         // Look for declarations of the variable\n         if let DeclLocal(ref local) = decl.node {\n             if local.pat.id == self.var_id {\n-                if let PatKind::Binding(_, ref ident, _) = local.pat.node {\n+                if let PatKind::Binding(_, _, ref ident, _) = local.pat.node {\n                     self.name = Some(ident.node);\n \n                     self.state = if let Some(ref init) = local.init {\n@@ -1071,8 +1074,9 @@ impl<'v, 't> Visitor<'v> for InitializeVisitor<'v, 't> {\n }\n \n fn var_def_id(cx: &LateContext, expr: &Expr) -> Option<NodeId> {\n-    if let Some(path_res) = cx.tcx.def_map.borrow().get(&expr.id) {\n-        if let Def::Local(def_id) = path_res.base_def {\n+    if let ExprPath(ref qpath) = expr.node {\n+        let path_res = cx.tcx.tables().qpath_def(qpath, expr.id);\n+        if let Def::Local(def_id) = path_res {\n             let node_id = cx.tcx.map.as_local_node_id(def_id).expect(\"That DefId should be valid\");\n             return Some(node_id);\n         }"}, {"sha": "9d9b0a6e35bb23b9dfe46c6cc1c09191c88c558f", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -64,7 +64,7 @@ impl LateLintPass for Pass {\n                             }\n                         }}\n                     }\n-                    ExprPath(_, ref path) => {\n+                    ExprPath(ref path) => {\n                         if match_path(path, &paths::CLONE) {\n                             let type_name = get_type_name(cx, expr, &args[0]).unwrap_or(\"_\");\n                             span_help_and_lint(cx,\n@@ -85,7 +85,7 @@ impl LateLintPass for Pass {\n \n fn expr_eq_name(expr: &Expr, id: ast::Name) -> bool {\n     match expr.node {\n-        ExprPath(None, ref path) => {\n+        ExprPath(QPath::Resolved(None, ref path)) => {\n             let arg_segment = [PathSegment {\n                                    name: id,\n                                    parameters: PathParameters::none(),\n@@ -108,7 +108,7 @@ fn get_type_name(cx: &LateContext, expr: &Expr, arg: &Expr) -> Option<&'static s\n \n fn get_arg_name(pat: &Pat) -> Option<ast::Name> {\n     match pat.node {\n-        PatKind::Binding(_, name, None) => Some(name.node),\n+        PatKind::Binding(_, _, name, None) => Some(name.node),\n         PatKind::Ref(ref subpat, _) => get_arg_name(subpat),\n         _ => None,\n     }"}, {"sha": "828e7eda02633988ad5d3f213689191a30fe465c", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -210,8 +210,8 @@ fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr:\n             }\n             path.to_string()\n         }\n-        PatKind::Binding(BindByValue(MutImmutable), ident, None) => ident.node.to_string(),\n-        PatKind::Path(None, ref path) => path.to_string(),\n+        PatKind::Binding(BindByValue(MutImmutable), _, ident, None) => ident.node.to_string(),\n+        PatKind::Path(ref path) => path.to_string(),\n         _ => return,\n     };\n "}, {"sha": "288c238474fea4157fb4d5af39be27ad66023a80", "filename": "clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_forget.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -30,8 +30,8 @@ impl LintPass for MemForget {\n impl LateLintPass for MemForget {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n         if let ExprCall(ref path_expr, ref args) = e.node {\n-            if let ExprPath(None, _) = path_expr.node {\n-                let def_id = cx.tcx.expect_def(path_expr.id).def_id();\n+            if let ExprPath(ref qpath) = path_expr.node {\n+                let def_id = cx.tcx.tables().qpath_def(qpath, path_expr.id).def_id();\n                 if match_def_path(cx, def_id, &paths::MEM_FORGET) {\n                     let forgot_ty = cx.tcx.tables().expr_ty(&args[0]);\n "}, {"sha": "1a824e467c491a4ac2b3158dbe55493b62a9eeff", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -701,7 +701,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n         }\n \n         if name == \"unwrap_or\" {\n-            if let hir::ExprPath(_, ref path) = fun.node {\n+            if let hir::ExprPath(hir::QPath::Resolved(_, ref path)) = fun.node {\n                 let path: &str = &path.segments\n                                       .last()\n                                       .expect(\"A path must have at least one segment\")\n@@ -877,7 +877,7 @@ fn lint_cstring_as_ptr(cx: &LateContext, expr: &hir::Expr, new: &hir::Expr, unwr\n     if_let_chain!{[\n         let hir::ExprCall(ref fun, ref args) = new.node,\n         args.len() == 1,\n-        let hir::ExprPath(None, ref path) = fun.node,\n+        let hir::ExprPath(ref path) = fun.node,\n         match_path(path, &paths::CSTRING_NEW),\n     ], {\n         span_lint_and_then(cx, TEMPORARY_CSTRING_AS_PTR, expr.span,\n@@ -1188,7 +1188,7 @@ fn lint_chars_next(cx: &LateContext, expr: &hir::Expr, chain: &hir::Expr, other:\n         let Some(args) = method_chain_args(chain, &[\"chars\", \"next\"]),\n         let hir::ExprCall(ref fun, ref arg_char) = other.node,\n         arg_char.len() == 1,\n-        let hir::ExprPath(None, ref path) = fun.node,\n+        let hir::ExprPath(hir::QPath::Resolved(None, ref path)) = fun.node,\n         path.segments.len() == 1 && &*path.segments[0].name.as_str() == \"Some\"\n     ], {\n         let self_ty = walk_ptrs_ty(cx.tcx.tables().expr_ty_adjusted(&args[0][0]));\n@@ -1408,7 +1408,7 @@ impl OutType {\n }\n \n fn is_bool(ty: &hir::Ty) -> bool {\n-    if let hir::TyPath(None, ref p) = ty.node {\n+    if let hir::TyPath(ref p) = ty.node {\n         match_path(p, &[\"bool\"])\n     } else {\n         false"}, {"sha": "2b453f1c8806d30581487d4e240fa7d3fbefe50e", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -61,8 +61,8 @@ enum MinMax {\n \n fn min_max<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(MinMax, Constant, &'a Expr)> {\n     if let ExprCall(ref path, ref args) = expr.node {\n-        if let ExprPath(None, _) = path.node {\n-            let def_id = cx.tcx.expect_def(path.id).def_id();\n+        if let ExprPath(ref qpath) = path.node {\n+            let def_id = cx.tcx.tables().qpath_def(qpath, path.id).def_id();\n \n             if match_def_path(cx, def_id, &paths::CMP_MIN) {\n                 fetch_const(args, MinMax::Min)"}, {"sha": "854a8d144d688abaf10c2a6fb98716686def926c", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -173,7 +173,7 @@ impl LateLintPass for Pass {\n             return;\n         }\n         for arg in &decl.inputs {\n-            if let PatKind::Binding(BindByRef(_), _, _) = arg.pat.node {\n+            if let PatKind::Binding(BindByRef(_), _, _, _) = arg.pat.node {\n                 span_lint(cx,\n                           TOPLEVEL_REF_ARG,\n                           arg.pat.span,\n@@ -186,7 +186,7 @@ impl LateLintPass for Pass {\n         if_let_chain! {[\n             let StmtDecl(ref d, _) = s.node,\n             let DeclLocal(ref l) = d.node,\n-            let PatKind::Binding(BindByRef(mt), i, None) = l.pat.node,\n+            let PatKind::Binding(BindByRef(mt), _, i, None) = l.pat.node,\n             let Some(ref init) = l.init\n         ], {\n             let init = Sugg::hir(cx, init, \"..\");\n@@ -220,10 +220,10 @@ impl LateLintPass for Pass {\n         if let ExprBinary(ref cmp, ref left, ref right) = expr.node {\n             let op = cmp.node;\n             if op.is_comparison() {\n-                if let ExprPath(_, ref path) = left.node {\n+                if let ExprPath(QPath::Resolved(_, ref path)) = left.node {\n                     check_nan(cx, path, expr.span);\n                 }\n-                if let ExprPath(_, ref path) = right.node {\n+                if let ExprPath(QPath::Resolved(_, ref path)) = right.node {\n                     check_nan(cx, path, expr.span);\n                 }\n                 check_to_owned(cx, left, right, true, cmp.span);\n@@ -262,19 +262,23 @@ impl LateLintPass for Pass {\n             return;\n         }\n         let binding = match expr.node {\n-            ExprPath(_, ref path) => {\n-                let binding = path.segments\n-                    .last()\n-                    .expect(\"path should always have at least one segment\")\n-                    .name\n-                    .as_str();\n-                if binding.starts_with('_') &&\n-                    !binding.starts_with(\"__\") &&\n-                    &*binding != \"_result\" && // FIXME: #944\n-                    is_used(cx, expr) &&\n-                    // don't lint if the declaration is in a macro\n-                    non_macro_local(cx, &cx.tcx.expect_def(expr.id)) {\n-                    Some(binding)\n+            ExprPath(ref qpath) => {\n+                if let QPath::Resolved(_, ref path) = *qpath {\n+                    let binding = path.segments\n+                        .last()\n+                        .expect(\"path should always have at least one segment\")\n+                        .name\n+                        .as_str();\n+                    if binding.starts_with('_') &&\n+                        !binding.starts_with(\"__\") &&\n+                        &*binding != \"_result\" && // FIXME: #944\n+                        is_used(cx, expr) &&\n+                        // don't lint if the declaration is in a macro\n+                        non_macro_local(cx, &cx.tcx.tables().qpath_def(qpath, expr.id)) {\n+                        Some(binding)\n+                    } else {\n+                        None\n+                    }\n                 } else {\n                     None\n                 }\n@@ -299,7 +303,7 @@ impl LateLintPass for Pass {\n     }\n \n     fn check_pat(&mut self, cx: &LateContext, pat: &Pat) {\n-        if let PatKind::Binding(_, ref ident, Some(ref right)) = pat.node {\n+        if let PatKind::Binding(_, _, ref ident, Some(ref right)) = pat.node {\n             if right.node == PatKind::Wild {\n                 span_lint(cx,\n                           REDUNDANT_PATTERN,\n@@ -366,7 +370,7 @@ fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr, left: bool, op: S\n             }\n         }\n         ExprCall(ref path, ref v) if v.len() == 1 => {\n-            if let ExprPath(None, ref path) = path.node {\n+            if let ExprPath(ref path) = path.node {\n                 if match_path(path, &[\"String\", \"from_str\"]) || match_path(path, &[\"String\", \"from\"]) {\n                     (cx.tcx.tables().expr_ty(&v[0]), snippet(cx, v[0].span, \"..\"))\n                 } else {"}, {"sha": "eadf0d8ce89c338c2480f803935a17b989016cb3", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -42,7 +42,7 @@ impl LateLintPass for UnnecessaryMutPassed {\n                                                   .expect(\"A function with an unknown type is called. \\\n                                                            If this happened, the compiler would have \\\n                                                            aborted the compilation long ago\");\n-                if let ExprPath(_, ref path) = fn_expr.node {\n+                if let ExprPath(ref path) = fn_expr.node {\n                     check_arguments(cx, arguments, function_type, &path.to_string());\n                 }\n             }"}, {"sha": "459b4faec5dd91e37d0c866fd0ca6b93c5d98f13", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -57,7 +57,7 @@ impl LateLintPass for NeedlessBorrow {\n         if in_macro(cx, pat.span) {\n             return;\n         }\n-        if let PatKind::Binding(BindingMode::BindByRef(MutImmutable), _, _) = pat.node {\n+        if let PatKind::Binding(BindingMode::BindByRef(MutImmutable), _, _, _) = pat.node {\n             if let ty::TyRef(_, ref tam) = cx.tcx.tables().pat_ty(pat).sty {\n                 if tam.mutbl == MutImmutable {\n                     if let ty::TyRef(..) = tam.ty.sty {"}, {"sha": "825aafb4be558cc5ea1c6875e2315fca18995ca4", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -1,5 +1,5 @@\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use rustc::hir::def::{Def, PathResolution};\n+use rustc::hir::def::Def;\n use rustc::hir::{Expr, Expr_, Stmt, StmtSemi, BlockCheckMode, UnsafeSource};\n use utils::{in_macro, span_lint, snippet_opt, span_lint_and_then};\n use std::ops::Deref;\n@@ -68,13 +68,17 @@ fn has_no_effect(cx: &LateContext, expr: &Expr) -> bool {\n             }\n         }\n         Expr_::ExprCall(ref callee, ref args) => {\n-            let def = cx.tcx.def_map.borrow().get(&callee.id).map(|d| d.full_def());\n-            match def {\n-                Some(Def::Struct(..)) |\n-                Some(Def::Variant(..)) |\n-                Some(Def::StructCtor(..)) |\n-                Some(Def::VariantCtor(..)) => args.iter().all(|arg| has_no_effect(cx, arg)),\n-                _ => false,\n+            if let Expr_::ExprPath(ref qpath) = callee.node {\n+                let def = cx.tcx.tables().qpath_def(qpath, callee.id);\n+                match def {\n+                    Def::Struct(..) |\n+                    Def::Variant(..) |\n+                    Def::StructCtor(..) |\n+                    Def::VariantCtor(..) => args.iter().all(|arg| has_no_effect(cx, arg)),\n+                    _ => false,\n+                }\n+            } else {\n+                false\n             }\n         }\n         Expr_::ExprBlock(ref block) => {\n@@ -146,12 +150,17 @@ fn reduce_expression<'a>(cx: &LateContext, expr: &'a Expr) -> Option<Vec<&'a Exp\n             Some(fields.iter().map(|f| &f.expr).chain(base).map(Deref::deref).collect())\n         }\n         Expr_::ExprCall(ref callee, ref args) => {\n-            match cx.tcx.def_map.borrow().get(&callee.id).map(PathResolution::full_def) {\n-                Some(Def::Struct(..)) |\n-                Some(Def::Variant(..)) |\n-                Some(Def::StructCtor(..)) |\n-                Some(Def::VariantCtor(..)) => Some(args.iter().collect()),\n-                _ => None,\n+            if let Expr_::ExprPath(ref qpath) = callee.node {\n+                let def = cx.tcx.tables().qpath_def(qpath, callee.id);\n+                match def {\n+                    Def::Struct(..) |\n+                    Def::Variant(..) |\n+                    Def::StructCtor(..) |\n+                    Def::VariantCtor(..) => Some(args.iter().collect()),\n+                    _ => None,\n+                }\n+            } else {\n+                None\n             }\n         }\n         Expr_::ExprBlock(ref block) => {"}, {"sha": "b7e7c70e41a5cd708965ced0317ca40c353b514c", "filename": "clippy_lints/src/ok_if_let.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fok_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fok_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fok_if_let.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -46,7 +46,7 @@ impl LateLintPass for Pass {\n             let ExprMatch(ref op, ref body, ref source) = expr.node, //test if expr is a match\n             let MatchSource::IfLetDesugar { .. } = *source, //test if it is an If Let\n             let ExprMethodCall(_, _, ref result_types) = op.node, //check is expr.ok() has type Result<T,E>.ok()\n-            let PatKind::TupleStruct(ref x, ref y, _)  = body[0].pats[0].node, //get operation\n+            let PatKind::TupleStruct(QPath::Resolved(_, ref x), ref y, _)  = body[0].pats[0].node, //get operation\n             method_chain_args(op, &[\"ok\"]).is_some() //test to see if using ok() methoduse std::marker::Sized;\n \n         ], {"}, {"sha": "06a1937e1927094b41c7c25c527b2e95b567b8ae", "filename": "clippy_lints/src/overflow_check_conditional.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -35,9 +35,9 @@ impl LateLintPass for OverflowCheckConditional {\n         if_let_chain! {[\n             let Expr_::ExprBinary(ref op, ref first, ref second) = expr.node,\n             let Expr_::ExprBinary(ref op2, ref ident1, ref ident2) = first.node,\n-            let Expr_::ExprPath(_,ref path1) = ident1.node,\n-            let Expr_::ExprPath(_, ref path2) = ident2.node,\n-            let Expr_::ExprPath(_, ref path3) = second.node,\n+            let Expr_::ExprPath(QPath::Resolved(_, ref path1)) = ident1.node,\n+            let Expr_::ExprPath(QPath::Resolved(_, ref path2)) = ident2.node,\n+            let Expr_::ExprPath(QPath::Resolved(_, ref path3)) = second.node,\n             &path1.segments[0] == &path3.segments[0] || &path2.segments[0] == &path3.segments[0],\n             cx.tcx.tables().expr_ty(ident1).is_integral(),\n             cx.tcx.tables().expr_ty(ident2).is_integral()\n@@ -57,9 +57,9 @@ impl LateLintPass for OverflowCheckConditional {\n         if_let_chain! {[\n             let Expr_::ExprBinary(ref op, ref first, ref second) = expr.node,\n             let Expr_::ExprBinary(ref op2, ref ident1, ref ident2) = second.node,\n-            let Expr_::ExprPath(_,ref path1) = ident1.node,\n-            let Expr_::ExprPath(_, ref path2) = ident2.node,\n-            let Expr_::ExprPath(_, ref path3) = first.node,\n+            let Expr_::ExprPath(QPath::Resolved(_, ref path1)) = ident1.node,\n+            let Expr_::ExprPath(QPath::Resolved(_, ref path2)) = ident2.node,\n+            let Expr_::ExprPath(QPath::Resolved(_, ref path3)) = first.node,\n             &path1.segments[0] == &path3.segments[0] || &path2.segments[0] == &path3.segments[0],\n             cx.tcx.tables().expr_ty(ident1).is_integral(),\n             cx.tcx.tables().expr_ty(ident2).is_integral()"}, {"sha": "1d89c5ce507da84b0de076e2f39d57493c617318", "filename": "clippy_lints/src/panic.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -39,9 +39,8 @@ impl LateLintPass for Pass {\n             let Some(ref ex) = block.expr,\n             let ExprCall(ref fun, ref params) = ex.node,\n             params.len() == 2,\n-            let ExprPath(None, _) = fun.node,\n-            let Some(fun) = resolve_node(cx, fun.id),\n-            match_def_path(cx, fun.def_id(), &paths::BEGIN_PANIC),\n+            let ExprPath(ref qpath) = fun.node,\n+            match_def_path(cx, resolve_node(cx, qpath, fun.id).def_id(), &paths::BEGIN_PANIC),\n             let ExprLit(ref lit) = params[0].node,\n             is_direct_expn_of(cx, params[0].span, \"panic\").is_some(),\n             let LitKind::Str(ref string, _) = lit.node,"}, {"sha": "8f25650bf5853c83052e5785c98ad126acdb3dd6", "filename": "clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -40,7 +40,7 @@ impl LateLintPass for Pass {\n         if_let_chain! {[\n             let ItemImpl(_, _, _, Some(ref trait_ref), _, ref impl_items) = item.node,\n             !is_automatically_derived(&*item.attrs),\n-            cx.tcx.expect_def(trait_ref.ref_id).def_id() == cx.tcx.lang_items.eq_trait().unwrap(),\n+            trait_ref.path.def.def_id() == cx.tcx.lang_items.eq_trait().unwrap(),\n         ], {\n             for impl_item in impl_items {\n                 if &*impl_item.name.as_str() == \"ne\" {"}, {"sha": "719d18bffebd0df479f953c4e79b7dbbe4a7b15e", "filename": "clippy_lints/src/print.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprint.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -2,7 +2,7 @@ use rustc::hir::*;\n use rustc::hir::map::Node::{NodeItem, NodeImplItem};\n use rustc::lint::*;\n use utils::paths;\n-use utils::{is_expn_of, match_path, match_def_path, resolve_node, span_lint};\n+use utils::{is_expn_of, match_def_path, resolve_node, span_lint, match_path_old};\n use format::get_argument_fmtstr_parts;\n \n /// **What it does:** This lint warns when you using `print!()` with a format string that\n@@ -69,9 +69,9 @@ impl LateLintPass for Pass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if_let_chain! {[\n             let ExprCall(ref fun, ref args) = expr.node,\n-            let ExprPath(..) = fun.node,\n-            let Some(fun) = resolve_node(cx, fun.id),\n+            let ExprPath(ref qpath) = fun.node,\n         ], {\n+            let fun = resolve_node(cx, qpath, fun.id);\n             let fun_id = fun.def_id();\n \n             // Search for `std::io::_print(..)` which is unique in a\n@@ -93,9 +93,8 @@ impl LateLintPass for Pass {\n                         // ensure we're calling Arguments::new_v1\n                         args.len() == 1,\n                         let ExprCall(ref args_fun, ref args_args) = args[0].node,\n-                        let ExprPath(..) = args_fun.node,\n-                        let Some(def) = resolve_node(cx, args_fun.id),\n-                        match_def_path(cx, def.def_id(), &paths::FMT_ARGUMENTS_NEWV1),\n+                        let ExprPath(ref qpath) = args_fun.node,\n+                        match_def_path(cx, resolve_node(cx, qpath, args_fun.id).def_id(), &paths::FMT_ARGUMENTS_NEWV1),\n                         args_args.len() == 2,\n                         let ExprAddrOf(_, ref match_expr) = args_args[1].node,\n                         let ExprMatch(ref args, _, _) = match_expr.node,\n@@ -121,8 +120,8 @@ impl LateLintPass for Pass {\n             // Search for something like\n             // `::std::fmt::ArgumentV1::new(__arg0, ::std::fmt::Debug::fmt)`\n             else if args.len() == 2 && match_def_path(cx, fun_id, &paths::FMT_ARGUMENTV1_NEW) {\n-                if let ExprPath(None, _) = args[1].node {\n-                    let def_id = resolve_node(cx, args[1].id).unwrap().def_id();\n+                if let ExprPath(ref qpath) = args[1].node {\n+                    let def_id = cx.tcx.tables().qpath_def(qpath, args[1].id).def_id();\n                     if match_def_path(cx, def_id, &paths::DEBUG_FMT_METHOD) && !is_in_debug_impl(cx, expr) &&\n                        is_expn_of(cx, expr.span, \"panic\").is_none() {\n                         span_lint(cx, USE_DEBUG, args[0].span, \"use of `Debug`-based formatting\");\n@@ -141,7 +140,7 @@ fn is_in_debug_impl(cx: &LateContext, expr: &Expr) -> bool {\n         // `Debug` impl\n         if let Some(NodeItem(item)) = map.find(map.get_parent(item.id)) {\n             if let ItemImpl(_, _, _, Some(ref tr), _, _) = item.node {\n-                return match_path(&tr.path, &[\"Debug\"]);\n+                return match_path_old(&tr.path, &[\"Debug\"]);\n             }\n         }\n     }"}, {"sha": "f210ec4dbc05bded1e584d10c2679b3183f47375", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -77,7 +77,7 @@ impl LateLintPass for PointerPass {\n             check_fn(cx, &sig.decl, item.id);\n         }\n     }\n-    \n+\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprBinary(ref op, ref l, ref r) = expr.node {\n             if (op.node == BiEq || op.node == BiNe) && (is_null_path(l) || is_null_path(r)) {\n@@ -116,7 +116,7 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId) {\n fn is_null_path(expr: &Expr) -> bool {\n     if let ExprCall(ref pathexp, ref args) = expr.node {\n         if args.is_empty() {\n-            if let ExprPath(_, ref path) = pathexp.node {\n+            if let ExprPath(ref path) = pathexp.node {\n                 return match_path(path, &paths::PTR_NULL) || match_path(path, &paths::PTR_NULL_MUT)\n             }\n         }"}, {"sha": "791843ee567b35b0266ca5b26361c85c637a1439", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -73,15 +73,19 @@ impl LateLintPass for StepByZero {\n                     let ExprMethodCall(Spanned { node: ref len_name, .. }, _, ref len_args) = end.node,\n                     &*len_name.as_str() == \"len\" && len_args.len() == 1,\n                     // .iter() and .len() called on same Path\n-                    let ExprPath(_, Path { segments: ref iter_path, .. }) = iter_args[0].node,\n-                    let ExprPath(_, Path { segments: ref len_path, .. }) = len_args[0].node,\n+                    let ExprPath(QPath::Resolved(_, ref iter_path)) = iter_args[0].node,\n+                    let ExprPath(QPath::Resolved(_, ref len_path)) = len_args[0].node,\n                     iter_path == len_path\n                  ], {\n-                    span_lint(cx,\n-                              RANGE_ZIP_WITH_LEN,\n-                              expr.span,\n-                              &format!(\"It is more idiomatic to use {}.iter().enumerate()\",\n-                                       snippet(cx, iter_args[0].span, \"_\")));\n+                     let Path { segments: ref iter_path, .. } = **iter_path;\n+                     let Path { segments: ref len_path, .. } = **len_path;\n+                     if iter_path == len_path {\n+                         span_lint(cx,\n+                                   RANGE_ZIP_WITH_LEN,\n+                                   expr.span,\n+                                   &format!(\"It is more idiomatic to use {}.iter().enumerate()\",\n+                                            snippet(cx, iter_args[0].span, \"_\")));\n+                     }\n                 }}\n             }\n         }"}, {"sha": "11eaac0bbb911ac1e4d0d76c7045ff74e1427bdc", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -115,10 +115,10 @@ impl LateLintPass for Pass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if_let_chain!{[\n             let ExprCall(ref fun, ref args) = expr.node,\n+            let ExprPath(ref qpath) = fun.node,\n             args.len() == 1,\n-            let Some(def) = cx.tcx.def_map.borrow().get(&fun.id),\n         ], {\n-            let def_id = def.full_def().def_id();\n+            let def_id = cx.tcx.tables().qpath_def(qpath, fun.id).def_id();\n             if match_def_path(cx, def_id, &paths::REGEX_NEW) ||\n                match_def_path(cx, def_id, &paths::REGEX_BUILDER_NEW) {\n                 check_regex(cx, &args[0], true);"}, {"sha": "c5a232275552222478da463077f12796ac88762f", "filename": "clippy_lints/src/serde.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fserde.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fserde.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fserde.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -29,7 +29,7 @@ impl LintPass for Serde {\n impl LateLintPass for Serde {\n     fn check_item(&mut self, cx: &LateContext, item: &Item) {\n         if let ItemImpl(_, _, _, Some(ref trait_ref), _, ref items) = item.node {\n-            let did = cx.tcx.expect_def(trait_ref.ref_id).def_id();\n+            let did = trait_ref.path.def.def_id();\n             if let Some(visit_did) = get_trait_def_id(cx, &paths::SERDE_DE_VISITOR) {\n                 if did == visit_did {\n                     let mut seen_str = None;"}, {"sha": "c994d47d7599af27ca853325e9a892bd7ef7d050", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -1,8 +1,8 @@\n use reexport::*;\n use rustc::lint::*;\n-use rustc::hir::def::Def;\n use rustc::hir::*;\n use rustc::hir::intravisit::{Visitor, FnKind};\n+use rustc::ty;\n use std::ops::Deref;\n use syntax::codemap::Span;\n use utils::{higher, in_external_macro, snippet, span_lint_and_then};\n@@ -92,7 +92,7 @@ impl LateLintPass for Pass {\n fn check_fn(cx: &LateContext, decl: &FnDecl, expr: &Expr) {\n     let mut bindings = Vec::new();\n     for arg in &decl.inputs {\n-        if let PatKind::Binding(_, ident, _) = arg.pat.node {\n+        if let PatKind::Binding(_, _, ident, _) = arg.pat.node {\n             bindings.push((ident.node, ident.span))\n         }\n     }\n@@ -135,20 +135,20 @@ fn check_decl(cx: &LateContext, decl: &Decl, bindings: &mut Vec<(Name, Span)>) {\n     }\n }\n \n-fn is_binding(cx: &LateContext, pat: &Pat) -> bool {\n-    match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n-        Some(Def::Variant(..)) |\n-        Some(Def::Struct(..)) => false,\n+fn is_binding(cx: &LateContext, pat_id: NodeId) -> bool {\n+    let var_ty = cx.tcx.tables().node_id_to_type(pat_id);\n+    match var_ty.sty {\n+        ty::TyAdt(..) => false,\n         _ => true,\n     }\n }\n \n fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span, bindings: &mut Vec<(Name, Span)>) {\n     // TODO: match more stuff / destructuring\n     match pat.node {\n-        PatKind::Binding(_, ref ident, ref inner) => {\n+        PatKind::Binding(_, _, ref ident, ref inner) => {\n             let name = ident.node;\n-            if is_binding(cx, pat) {\n+            if is_binding(cx, pat.id) {\n                 let mut new_binding = true;\n                 for tup in bindings.iter_mut() {\n                     if tup.0 == name {\n@@ -344,7 +344,7 @@ fn is_self_shadow(name: Name, expr: &Expr) -> bool {\n             block.stmts.is_empty() && block.expr.as_ref().map_or(false, |e| is_self_shadow(name, e))\n         }\n         ExprUnary(op, ref inner) => (UnDeref == op) && is_self_shadow(name, inner),\n-        ExprPath(_, ref path) => path_eq_name(name, path),\n+        ExprPath(QPath::Resolved(_, ref path)) => path_eq_name(name, path),\n         _ => false,\n     }\n }"}, {"sha": "bef66dd402e07ce593f912f58ee48189f7c30849", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -65,7 +65,7 @@ fn check_manual_swap(cx: &LateContext, block: &Block) {\n             let StmtDecl(ref tmp, _) = w[0].node,\n             let DeclLocal(ref tmp) = tmp.node,\n             let Some(ref tmp_init) = tmp.init,\n-            let PatKind::Binding(_, ref tmp_name, None) = tmp.pat.node,\n+            let PatKind::Binding(_, _, ref tmp_name, None) = tmp.pat.node,\n \n             // foo() = bar();\n             let StmtSemi(ref first, _) = w[1].node,\n@@ -74,7 +74,7 @@ fn check_manual_swap(cx: &LateContext, block: &Block) {\n             // bar() = t;\n             let StmtSemi(ref second, _) = w[2].node,\n             let ExprAssign(ref lhs2, ref rhs2) = second.node,\n-            let ExprPath(None, ref rhs2) = rhs2.node,\n+            let ExprPath(QPath::Resolved(None, ref rhs2)) = rhs2.node,\n             rhs2.segments.len() == 1,\n \n             tmp_name.node.as_str() == rhs2.segments[0].name.as_str(),"}, {"sha": "3a8680b1cf7751852dd88efdf78f9e1100b0fe1f", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -87,8 +87,8 @@ impl LintPass for Transmute {\n impl LateLintPass for Transmute {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n         if let ExprCall(ref path_expr, ref args) = e.node {\n-            if let ExprPath(None, ref path) = path_expr.node {\n-                let def_id = cx.tcx.expect_def(path_expr.id).def_id();\n+            if let ExprPath(ref qpath) = path_expr.node {\n+                let def_id = cx.tcx.tables().qpath_def(qpath, path_expr.id).def_id();\n \n                 if match_def_path(cx, def_id, &paths::TRANSMUTE) {\n                     let from_ty = cx.tcx.tables().expr_ty(&args[0]);\n@@ -173,7 +173,7 @@ impl LateLintPass for Transmute {\n                                 let arg = if from_pty.ty == to_rty.ty {\n                                     arg\n                                 } else {\n-                                    arg.as_ty(&format!(\"{} {}\", cast, get_type_snippet(cx, path, to_rty.ty)))\n+                                    arg.as_ty(&format!(\"{} {}\", cast, get_type_snippet(cx, qpath, to_rty.ty)))\n                                 };\n \n                                 db.span_suggestion(e.span, \"try\", sugg::make_unop(deref, arg).to_string());\n@@ -190,8 +190,9 @@ impl LateLintPass for Transmute {\n /// Get the snippet of `Bar` in `\u2026::transmute<Foo, &Bar>`. If that snippet is not available , use\n /// the type's `ToString` implementation. In weird cases it could lead to types with invalid `'_`\n /// lifetime, but it should be rare.\n-fn get_type_snippet(cx: &LateContext, path: &Path, to_rty: ty::Ty) -> String {\n+fn get_type_snippet(cx: &LateContext, path: &QPath, to_rty: ty::Ty) -> String {\n     if_let_chain!{[\n+        let QPath::Resolved(_, ref path) = *path,\n         let Some(seg) = path.segments.last(),\n         let PathParameters::AngleBracketedParameters(ref ang) = seg.parameters,\n         let Some(to_ty) = ang.types.get(1),"}, {"sha": "008a1fbc6ce41e6b2c92ddf9986c84239854cb76", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -7,7 +7,7 @@ use std::cmp::Ordering;\n use syntax::ast::{IntTy, UintTy, FloatTy};\n use syntax::codemap::Span;\n use utils::{comparisons, higher, in_external_macro, in_macro, match_def_path, snippet,\n-            span_help_and_lint, span_lint};\n+            span_help_and_lint, span_lint, opt_def_id};\n use utils::paths;\n \n /// Handles all the linting of funky types\n@@ -74,30 +74,32 @@ impl LateLintPass for TypePass {\n         if in_macro(cx, ast_ty.span) {\n             return;\n         }\n-        if let Some(did) = cx.tcx.def_map.borrow().get(&ast_ty.id) {\n-            if let def::Def::Struct(..) = did.full_def() {\n-                if Some(did.full_def().def_id()) == cx.tcx.lang_items.owned_box() {\n+        if let TyPath(ref qpath) = ast_ty.node {\n+            let def = cx.tcx.tables().qpath_def(qpath, ast_ty.id);\n+            if let Some(def_id) = opt_def_id(def) {\n+                if def_id == cx.tcx.lang_items.owned_box().unwrap() {\n                     if_let_chain! {[\n-                        let TyPath(_, ref path) = ast_ty.node,\n+                        let QPath::Resolved(_, ref path) = *qpath,\n                         let Some(ref last) = path.segments.last(),\n                         let PathParameters::AngleBracketedParameters(ref ag) = last.parameters,\n                         let Some(ref vec) = ag.types.get(0),\n-                        let Some(did) = cx.tcx.def_map.borrow().get(&vec.id),\n-                        let def::Def::Struct(..) = did.full_def(),\n-                        match_def_path(cx, did.full_def().def_id(), &paths::VEC),\n+                        let TyPath(ref qpath) = vec.node,\n+                        let def::Def::Struct(..) = cx.tcx.tables().qpath_def(qpath, vec.id),\n+                        let Some(did) = opt_def_id(cx.tcx.tables().qpath_def(qpath, vec.id)),\n+                        match_def_path(cx, did, &paths::VEC),\n                     ], {\n                         span_help_and_lint(cx,\n                                            BOX_VEC,\n                                            ast_ty.span,\n                                            \"you seem to be trying to use `Box<Vec<T>>`. Consider using just `Vec<T>`\",\n                                            \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation.\");\n                     }}\n-                } else if match_def_path(cx, did.full_def().def_id(), &paths::LINKED_LIST) {\n+                } else if match_def_path(cx, def_id, &paths::LINKED_LIST) {\n                     span_help_and_lint(cx,\n-                                       LINKEDLIST,\n-                                       ast_ty.span,\n-                                       \"I see you're using a LinkedList! Perhaps you meant some other data structure?\",\n-                                       \"a VecDeque might work\");\n+                                        LINKEDLIST,\n+                                        ast_ty.span,\n+                                        \"I see you're using a LinkedList! Perhaps you meant some other data structure?\",\n+                                        \"a VecDeque might work\");\n                 }\n             }\n         }"}, {"sha": "341848a868cd6fb344d3661452e0ab7706c1882a", "filename": "clippy_lints/src/unsafe_removed_from_name.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -1,6 +1,5 @@\n-use rustc::hir::*;\n use rustc::lint::*;\n-use syntax::ast::Name;\n+use syntax::ast::*;\n use syntax::codemap::Span;\n use syntax::symbol::InternedString;\n use utils::span_lint;\n@@ -34,16 +33,16 @@ impl LintPass for UnsafeNameRemoval {\n     }\n }\n \n-impl LateLintPass for UnsafeNameRemoval {\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n-        if let ItemUse(ref item_use) = item.node {\n+impl EarlyLintPass for UnsafeNameRemoval {\n+    fn check_item(&mut self, cx: &EarlyContext, item: &Item) {\n+        if let ItemKind::Use(ref item_use) = item.node {\n             match item_use.node {\n                 ViewPath_::ViewPathSimple(ref name, ref path) => {\n                     unsafe_to_safe_check(\n                         path.segments\n                             .last()\n                             .expect(\"use paths cannot be empty\")\n-                            .name,\n+                            .identifier,\n                         *name,\n                         cx, &item.span\n                         );\n@@ -62,9 +61,9 @@ impl LateLintPass for UnsafeNameRemoval {\n     }\n }\n \n-fn unsafe_to_safe_check(old_name: Name, new_name: Name, cx: &LateContext, span: &Span) {\n-    let old_str = old_name.as_str();\n-    let new_str = new_name.as_str();\n+fn unsafe_to_safe_check(old_name: Ident, new_name: Ident, cx: &EarlyContext, span: &Span) {\n+    let old_str = old_name.name.as_str();\n+    let new_str = new_name.name.as_str();\n     if contains_unsafe(&old_str) && !contains_unsafe(&new_str) {\n         span_lint(cx,\n                   UNSAFE_REMOVED_FROM_NAME,"}, {"sha": "73c87f36bba8ef224a0e6f2f7873911a2161b906", "filename": "clippy_lints/src/unused_label.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Funused_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Funused_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_label.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -66,7 +66,7 @@ impl<'v> Visitor<'v> for UnusedLabelVisitor {\n         match expr.node {\n             hir::ExprBreak(Some(label), _) |\n             hir::ExprAgain(Some(label)) => {\n-                self.labels.remove(&label.node.as_str());\n+                self.labels.remove(&label.name.as_str());\n             }\n             hir::ExprLoop(_, Some(label), _) |\n             hir::ExprWhile(_, _, Some(label)) => {"}, {"sha": "a2e8bc891b4cf7f25f0883fff1c7f8d0b7777cad", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -44,34 +44,21 @@ pub struct Range<'a> {\n \n /// Higher a `hir` range to something similar to `ast::ExprKind::Range`.\n pub fn range(expr: &hir::Expr) -> Option<Range> {\n-    /// Skip unstable blocks. To be removed when ranges get stable.\n-    fn unwrap_unstable(expr: &hir::Expr) -> &hir::Expr {\n-        if let hir::ExprBlock(ref block) = expr.node {\n-            if block.rules == hir::BlockCheckMode::PushUnstableBlock || block.rules == hir::BlockCheckMode::PopUnstableBlock {\n-                if let Some(ref expr) = block.expr {\n-                    return expr;\n-                }\n-            }\n-        }\n-\n-        expr\n-    }\n-\n     /// Find the field named `name` in the field. Always return `Some` for convenience.\n     fn get_field<'a>(name: &str, fields: &'a [hir::Field]) -> Option<&'a hir::Expr> {\n         let expr = &fields.iter()\n                           .find(|field| field.name.node == name)\n                           .unwrap_or_else(|| panic!(\"missing {} field for range\", name))\n                           .expr;\n \n-        Some(unwrap_unstable(expr))\n+        Some(expr)\n     }\n \n     // The range syntax is expanded to literal paths starting with `core` or `std` depending on\n     // `#[no_std]`. Testing both instead of resolving the paths.\n \n-    match unwrap_unstable(expr).node {\n-        hir::ExprPath(None, ref path) => {\n+    match expr.node {\n+        hir::ExprPath(ref path) => {\n             if match_path(path, &paths::RANGE_FULL_STD) || match_path(path, &paths::RANGE_FULL) {\n                 Some(Range {\n                     start: None,\n@@ -168,10 +155,10 @@ pub enum VecArgs<'a> {\n pub fn vec_macro<'e>(cx: &LateContext, expr: &'e hir::Expr) -> Option<VecArgs<'e>> {\n     if_let_chain!{[\n         let hir::ExprCall(ref fun, ref args) = expr.node,\n-        let hir::ExprPath(_, ref path) = fun.node,\n-        let Some(fun_def) = resolve_node(cx, fun.id),\n+        let hir::ExprPath(ref path) = fun.node,\n         is_expn_of(cx, fun.span, \"vec\").is_some(),\n     ], {\n+        let fun_def = resolve_node(cx, path, fun.id);\n         return if match_def_path(cx, fun_def.def_id(), &paths::VEC_FROM_ELEM) && args.len() == 2 {\n             // `vec![elem; size]` case\n             Some(VecArgs::Repeat(&args[0], &args[1]))"}, {"sha": "5c1f4014bee8a17984706155d2373629b4e64515", "filename": "clippy_lints/src/utils/hir.rs", "status": "modified", "additions": 44, "deletions": 25, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n \n         match (&left.node, &right.node) {\n             (&ExprAddrOf(l_mut, ref le), &ExprAddrOf(r_mut, ref re)) => l_mut == r_mut && self.eq_expr(le, re),\n-            (&ExprAgain(li), &ExprAgain(ri)) => both(&li, &ri, |l, r| l.node.as_str() == r.node.as_str()),\n+            (&ExprAgain(li), &ExprAgain(ri)) => both(&li, &ri, |l, r| l.name.as_str() == r.name.as_str()),\n             (&ExprAssign(ref ll, ref lr), &ExprAssign(ref rl, ref rr)) => self.eq_expr(ll, rl) && self.eq_expr(lr, rr),\n             (&ExprAssignOp(ref lo, ref ll, ref lr), &ExprAssignOp(ref ro, ref rl, ref rr)) => {\n                 lo.node == ro.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n@@ -82,7 +82,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n                 })\n             }\n             (&ExprBreak(li, ref le), &ExprBreak(ri, ref re)) =>\n-                both(&li, &ri, |l, r| l.node.as_str() == r.node.as_str())\n+                both(&li, &ri, |l, r| l.name.as_str() == r.name.as_str())\n                 && both(le, re, |l, r| self.eq_expr(l, r)),\n             (&ExprBox(ref l), &ExprBox(ref r)) => self.eq_expr(l, r),\n             (&ExprCall(ref l_fun, ref l_args), &ExprCall(ref r_fun, ref r_args)) => {\n@@ -118,11 +118,9 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             }\n             (&ExprRepeat(ref le, ref ll), &ExprRepeat(ref re, ref rl)) => self.eq_expr(le, re) && self.eq_expr(ll, rl),\n             (&ExprRet(ref l), &ExprRet(ref r)) => both(l, r, |l, r| self.eq_expr(l, r)),\n-            (&ExprPath(ref l_qself, ref l_subpath), &ExprPath(ref r_qself, ref r_subpath)) => {\n-                both(l_qself, r_qself, |l, r| self.eq_qself(l, r)) && self.eq_path(l_subpath, r_subpath)\n-            }\n+            (&ExprPath(ref l), &ExprPath(ref r)) => self.eq_qpath(l, r),\n             (&ExprStruct(ref l_path, ref lf, ref lo), &ExprStruct(ref r_path, ref rf, ref ro)) => {\n-                self.eq_path(l_path, r_path) && both(lo, ro, |l, r| self.eq_expr(l, r)) &&\n+                self.eq_qpath(l_path, r_path) && both(lo, ro, |l, r| self.eq_expr(l, r)) &&\n                 over(lf, rf, |l, r| self.eq_field(l, r))\n             }\n             (&ExprTup(ref l_tup), &ExprTup(ref r_tup)) => self.eq_exprs(l_tup, r_tup),\n@@ -153,14 +151,12 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         match (&left.node, &right.node) {\n             (&PatKind::Box(ref l), &PatKind::Box(ref r)) => self.eq_pat(l, r),\n             (&PatKind::TupleStruct(ref lp, ref la, ls), &PatKind::TupleStruct(ref rp, ref ra, rs)) => {\n-                self.eq_path(lp, rp) && over(la, ra, |l, r| self.eq_pat(l, r)) && ls == rs\n-            }\n-            (&PatKind::Binding(ref lb, ref li, ref lp), &PatKind::Binding(ref rb, ref ri, ref rp)) => {\n-                lb == rb && li.node.as_str() == ri.node.as_str() && both(lp, rp, |l, r| self.eq_pat(l, r))\n+                self.eq_qpath(lp, rp) && over(la, ra, |l, r| self.eq_pat(l, r)) && ls == rs\n             }\n-            (&PatKind::Path(ref ql, ref l), &PatKind::Path(ref qr, ref r)) => {\n-                both(ql, qr, |ql, qr| self.eq_qself(ql, qr)) && self.eq_path(l, r)\n+            (&PatKind::Binding(ref lb, ref ld, ref li, ref lp), &PatKind::Binding(ref rb, ref rd, ref ri, ref rp)) => {\n+                lb == rb && ld == rd && li.node.as_str() == ri.node.as_str() && both(lp, rp, |l, r| self.eq_pat(l, r))\n             }\n+            (&PatKind::Path(ref l), &PatKind::Path(ref r)) => self.eq_qpath(l, r),\n             (&PatKind::Lit(ref l), &PatKind::Lit(ref r)) => self.eq_expr(l, r),\n             (&PatKind::Tuple(ref l, ls), &PatKind::Tuple(ref r, rs)) => {\n                 ls == rs && over(l, r, |l, r| self.eq_pat(l, r))\n@@ -178,6 +174,18 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n     }\n \n+    fn eq_qpath(&self, left: &QPath, right: &QPath) -> bool {\n+        match (left, right) {\n+            (&QPath::Resolved(ref lty, ref lpath), &QPath::Resolved(ref rty, ref rpath)) => {\n+                both(lty, rty, |l, r| self.eq_ty(l, r)) && self.eq_path(lpath, rpath)\n+            },\n+            (&QPath::TypeRelative(ref lty, ref lseg), &QPath::TypeRelative(ref rty, ref rseg)) => {\n+                self.eq_ty(lty, rty) && self.eq_path_segment(lseg, rseg)\n+            },\n+            _ => false,\n+        }\n+    }\n+\n     fn eq_path(&self, left: &Path, right: &Path) -> bool {\n         left.global == right.global &&\n         over(&left.segments, &right.segments, |l, r| self.eq_path_segment(l, r))\n@@ -208,10 +216,6 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         self.eq_path_parameters(&left.parameters, &right.parameters)\n     }\n \n-    fn eq_qself(&self, left: &QSelf, right: &QSelf) -> bool {\n-        left.ty.node == right.ty.node && left.position == right.position\n-    }\n-\n     fn eq_ty(&self, left: &Ty, right: &Ty) -> bool {\n         match (&left.node, &right.node) {\n             (&TySlice(ref l_vec), &TySlice(ref r_vec)) => self.eq_ty(l_vec, r_vec),\n@@ -222,9 +226,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             (&TyRptr(_, ref l_rmut), &TyRptr(_, ref r_rmut)) => {\n                 l_rmut.mutbl == r_rmut.mutbl && self.eq_ty(&*l_rmut.ty, &*r_rmut.ty)\n             }\n-            (&TyPath(ref lq, ref l_path), &TyPath(ref rq, ref r_path)) => {\n-                both(lq, rq, |l, r| self.eq_qself(l, r)) && self.eq_path(l_path, r_path)\n-            }\n+            (&TyPath(ref l), &TyPath(ref r)) => self.eq_qpath(l, r),\n             (&TyTup(ref l), &TyTup(ref r)) => over(l, r, |l, r| self.eq_ty(l, r)),\n             (&TyInfer, &TyInfer) => true,\n             _ => false,\n@@ -318,7 +320,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 let c: fn(_) -> _ = ExprAgain;\n                 c.hash(&mut self.s);\n                 if let Some(i) = i {\n-                    self.hash_name(&i.node);\n+                    self.hash_name(&i.name);\n                 }\n             }\n             ExprAssign(ref l, ref r) => {\n@@ -350,7 +352,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 let c: fn(_, _) -> _ = ExprBreak;\n                 c.hash(&mut self.s);\n                 if let Some(i) = i {\n-                    self.hash_name(&i.node);\n+                    self.hash_name(&i.name);\n                 }\n                 if let Some(ref j) = *j {\n                     self.hash_expr(&*j);\n@@ -452,16 +454,16 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                     self.hash_expr(e);\n                 }\n             }\n-            ExprPath(ref _qself, ref subpath) => {\n-                let c: fn(_, _) -> _ = ExprPath;\n+            ExprPath(ref qpath) => {\n+                let c: fn(_) -> _ = ExprPath;\n                 c.hash(&mut self.s);\n-                self.hash_path(subpath);\n+                self.hash_qpath(qpath);\n             }\n             ExprStruct(ref path, ref fields, ref expr) => {\n                 let c: fn(_, _, _) -> _ = ExprStruct;\n                 c.hash(&mut self.s);\n \n-                self.hash_path(path);\n+                self.hash_qpath(path);\n \n                 for f in fields {\n                     self.hash_name(&f.name.node);\n@@ -526,6 +528,23 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n         n.as_str().hash(&mut self.s);\n     }\n \n+    pub fn hash_qpath(&mut self, p: &QPath) {\n+        match *p {\n+            QPath::Resolved(ref _ty, ref path) => {\n+                let c: fn(_, _) -> _ = QPath::Resolved;\n+                c.hash(&mut self.s);\n+                // self.hash_ty(ty); FIXME\n+                self.hash_path(path);\n+            },\n+            QPath::TypeRelative(ref _ty, ref seg) => {\n+                let c: fn(_, _) -> _ = QPath::TypeRelative;\n+                c.hash(&mut self.s);\n+                // self.hash_ty(ty); FIXME\n+                self.hash_name(&seg.name);\n+            },\n+        }\n+    }\n+\n     pub fn hash_path(&mut self, p: &Path) {\n         p.global.hash(&mut self.s);\n         for p in &p.segments {"}, {"sha": "b297aec7c07224d5cbae7924e6476e1e0d83d55b", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -275,11 +275,14 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n             println!(\"{}index expr:\", ind);\n             print_expr(cx, idx, indent + 1);\n         },\n-        hir::ExprPath(ref sel, ref path) => {\n-            println!(\"{}Path, {}\", ind, ty);\n-            println!(\"{}self: {:?}\", ind, sel);\n+        hir::ExprPath(hir::QPath::Resolved(ref ty, ref path)) => {\n+            println!(\"{}Resolved Path, {:?}\", ind, ty);\n             println!(\"{}path: {:?}\", ind, path);\n         },\n+        hir::ExprPath(hir::QPath::TypeRelative(ref ty, ref seg)) => {\n+            println!(\"{}Relative Path, {:?}\", ind, ty);\n+            println!(\"{}seg: {:?}\", ind, seg);\n+        }\n         hir::ExprAddrOf(ref muta, ref e) => {\n             println!(\"{}AddrOf, {}\", ind, ty);\n             println!(\"mutability: {:?}\", muta);\n@@ -354,7 +357,7 @@ fn print_item(cx: &LateContext, item: &hir::Item) {\n                 println!(\"weird extern crate without a crate id\");\n             }\n         }\n-        hir::ItemUse(ref path) => println!(\"{:?}\", path.node),\n+        hir::ItemUse(ref path, ref kind) => println!(\"{:?}, {:?}\", path, kind),\n         hir::ItemStatic(..) => println!(\"static item of type {:#?}\", cx.tcx.item_type(did)),\n         hir::ItemConst(..) => println!(\"const item of type {:#?}\", cx.tcx.item_type(did)),\n         hir::ItemFn(..) => {\n@@ -383,13 +386,11 @@ fn print_item(cx: &LateContext, item: &hir::Item) {\n                 println!(\"trait has no default impl\");\n             }\n         },\n-        hir::ItemDefaultImpl(_, ref trait_ref) => {\n-            let trait_did = cx.tcx.expect_def(trait_ref.ref_id).def_id();\n-            println!(\"default impl for `{}`\", cx.tcx.item_path_str(trait_did));\n+        hir::ItemDefaultImpl(_, ref _trait_ref) => {\n+            println!(\"default impl\");\n         },\n-        hir::ItemImpl(_, _, _, Some(ref trait_ref), _, _) => {\n-            let trait_did = cx.tcx.expect_def(trait_ref.ref_id).def_id();\n-            println!(\"impl of trait `{}`\", cx.tcx.item_path_str(trait_did));\n+        hir::ItemImpl(_, _, _, Some(ref _trait_ref), _, _) => {\n+            println!(\"trait impl\");\n         },\n         hir::ItemImpl(_, _, _, None, _, _) => {\n             println!(\"impl\");\n@@ -402,7 +403,7 @@ fn print_pat(cx: &LateContext, pat: &hir::Pat, indent: usize) {\n     println!(\"{}+\", ind);\n     match pat.node {\n         hir::PatKind::Wild => println!(\"{}Wild\", ind),\n-        hir::PatKind::Binding(ref mode, ref name, ref inner) => {\n+        hir::PatKind::Binding(ref mode, _, ref name, ref inner) => {\n             println!(\"{}Binding\", ind);\n             println!(\"{}mode: {:?}\", ind, mode);\n             println!(\"{}name: {}\", ind, name.node);\n@@ -434,11 +435,14 @@ fn print_pat(cx: &LateContext, pat: &hir::Pat, indent: usize) {\n                 print_pat(cx, field, indent + 1);\n             }\n         },\n-        hir::PatKind::Path(ref sel, ref path) => {\n-            println!(\"{}Path\", ind);\n-            println!(\"{}self: {:?}\", ind, sel);\n+        hir::PatKind::Path(hir::QPath::Resolved(ref ty, ref path)) => {\n+            println!(\"{}Resolved Path, {:?}\", ind, ty);\n             println!(\"{}path: {:?}\", ind, path);\n         },\n+        hir::PatKind::Path(hir::QPath::TypeRelative(ref ty, ref seg)) => {\n+            println!(\"{}Relative Path, {:?}\", ind, ty);\n+            println!(\"{}seg: {:?}\", ind, seg);\n+        },\n         hir::PatKind::Tuple(ref pats, opt_dots_position) => {\n             println!(\"{}Tuple\", ind);\n             if let Some(dot_position) = opt_dots_position {"}, {"sha": "a510adefb717f20086441ad1896a92ae5adb9bfd", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -140,7 +140,7 @@ impl LateLintPass for LintWithoutLintPass {\n \n fn is_lint_ref_type(ty: &Ty) -> bool {\n     if let TyRptr(Some(_), MutTy { ty: ref inner, mutbl: MutImmutable }) = ty.node {\n-        if let TyPath(None, ref path) = inner.node {\n+        if let TyPath(ref path) = inner.node {\n             return match_path(path, &paths::LINT);\n         }\n     }\n@@ -149,7 +149,7 @@ fn is_lint_ref_type(ty: &Ty) -> bool {\n \n \n fn is_lint_array_type(ty: &Ty) -> bool {\n-    if let TyPath(None, ref path) = ty.node {\n+    if let TyPath(ref path) = ty.node {\n         match_path(path, &paths::LINT_ARRAY)\n     } else {\n         false"}, {"sha": "68d91301b2ca90b0762ec1669513b0a6744d3bd4", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 36, "deletions": 10, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b0077565bc056283dad048a237dbc183000c76/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=59b0077565bc056283dad048a237dbc183000c76", "patch": "@@ -1,6 +1,7 @@\n use reexport::*;\n use rustc::hir::*;\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n+use rustc::hir::def::Def;\n use rustc::hir::map::Node;\n use rustc::lint::{LintContext, LateContext, Level, Lint};\n use rustc::session::Session;\n@@ -202,7 +203,15 @@ pub fn match_trait_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool\n /// ```\n /// match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])\n /// ```\n-pub fn match_path(path: &Path, segments: &[&str]) -> bool {\n+pub fn match_path(path: &QPath, segments: &[&str]) -> bool {\n+    if let QPath::Resolved(_, ref path) = *path {\n+        match_path_old(path, segments)\n+    } else {\n+        false\n+    }\n+}\n+\n+pub fn match_path_old(path: &Path, segments: &[&str]) -> bool {\n     path.segments.iter().rev().zip(segments.iter().rev()).all(|(a, b)| a.name == *b)\n }\n \n@@ -283,8 +292,8 @@ pub fn implements_trait<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>,\n }\n \n /// Resolve the definition of a node from its `NodeId`.\n-pub fn resolve_node(cx: &LateContext, id: NodeId) -> Option<def::Def> {\n-    cx.tcx.def_map.borrow().get(&id).map(|d| d.full_def())\n+pub fn resolve_node(cx: &LateContext, qpath: &QPath, id: NodeId) -> def::Def {\n+    cx.tcx.tables().qpath_def(qpath, id)\n }\n \n /// Match an `Expr` against a chain of methods, and return the matched `Expr`s.\n@@ -736,8 +745,8 @@ pub fn is_copy<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>, env: Node\n \n /// Return whether a pattern is refutable.\n pub fn is_refutable(cx: &LateContext, pat: &Pat) -> bool {\n-    fn is_enum_variant(cx: &LateContext, did: NodeId) -> bool {\n-        matches!(cx.tcx.def_map.borrow().get(&did).map(|d| d.full_def()), Some(def::Def::Variant(..)) | Some(def::Def::VariantCtor(..)))\n+    fn is_enum_variant(cx: &LateContext, qpath: &QPath, did: NodeId) -> bool {\n+        matches!(cx.tcx.tables().qpath_def(qpath, did), def::Def::Variant(..) | def::Def::VariantCtor(..))\n     }\n \n     fn are_refutable<'a, I: Iterator<Item=&'a Pat>>(cx: &LateContext, mut i: I) -> bool {\n@@ -748,17 +757,17 @@ pub fn is_refutable(cx: &LateContext, pat: &Pat) -> bool {\n         PatKind::Binding(..) | PatKind::Wild => false,\n         PatKind::Box(ref pat) | PatKind::Ref(ref pat, _) => is_refutable(cx, pat),\n         PatKind::Lit(..) | PatKind::Range(..) => true,\n-        PatKind::Path(..) => is_enum_variant(cx, pat.id),\n+        PatKind::Path(ref qpath) => is_enum_variant(cx, qpath, pat.id),\n         PatKind::Tuple(ref pats, _) => are_refutable(cx, pats.iter().map(|pat| &**pat)),\n-        PatKind::Struct(_, ref fields, _) => {\n-            if is_enum_variant(cx, pat.id) {\n+        PatKind::Struct(ref qpath, ref fields, _) => {\n+            if is_enum_variant(cx, qpath, pat.id) {\n                 true\n             } else {\n                 are_refutable(cx, fields.iter().map(|field| &*field.node.pat))\n             }\n         }\n-        PatKind::TupleStruct(_, ref pats, _) => {\n-            if is_enum_variant(cx, pat.id) {\n+        PatKind::TupleStruct(ref qpath, ref pats, _) => {\n+            if is_enum_variant(cx, qpath, pat.id) {\n                 true\n             } else {\n                 are_refutable(cx, pats.iter().map(|pat| &**pat))\n@@ -793,3 +802,20 @@ pub fn remove_blocks(expr: &Expr) -> &Expr {\n         expr\n     }\n }\n+\n+pub fn opt_def_id(def: Def) -> Option<DefId> {\n+    match def {\n+        Def::Fn(id) | Def::Mod(id) | Def::Static(id, _) |\n+        Def::Variant(id) | Def::VariantCtor(id, ..) | Def::Enum(id) | Def::TyAlias(id) |\n+        Def::AssociatedTy(id) | Def::TyParam(id) | Def::Struct(id) | Def::StructCtor(id, ..) |\n+        Def::Union(id) | Def::Trait(id) | Def::Method(id) | Def::Const(id) |\n+        Def::AssociatedConst(id) | Def::Local(id) | Def::Upvar(id, ..) | Def::Macro(id) => {\n+            Some(id)\n+        }\n+\n+        Def::Label(..)  |\n+        Def::PrimTy(..) |\n+        Def::SelfTy(..) |\n+        Def::Err => None,\n+    }\n+}"}]}