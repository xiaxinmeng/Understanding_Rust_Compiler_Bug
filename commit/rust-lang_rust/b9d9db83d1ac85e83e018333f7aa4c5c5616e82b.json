{"sha": "b9d9db83d1ac85e83e018333f7aa4c5c5616e82b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5ZDlkYjgzZDFhYzg1ZTgzZTAxODMzM2Y3YWE0YzVjNTYxNmU4MmI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-09-10T18:28:27Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-09-10T18:28:27Z"}, "message": "cleanup dollar handling in expressions", "tree": {"sha": "d486002e8f5a4866716d7640b26562e340b7a347", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d486002e8f5a4866716d7640b26562e340b7a347"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9d9db83d1ac85e83e018333f7aa4c5c5616e82b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9d9db83d1ac85e83e018333f7aa4c5c5616e82b", "html_url": "https://github.com/rust-lang/rust/commit/b9d9db83d1ac85e83e018333f7aa4c5c5616e82b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9d9db83d1ac85e83e018333f7aa4c5c5616e82b/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1140a83c1b393cdcd18e42d5d816fd8be348b059", "url": "https://api.github.com/repos/rust-lang/rust/commits/1140a83c1b393cdcd18e42d5d816fd8be348b059", "html_url": "https://github.com/rust-lang/rust/commit/1140a83c1b393cdcd18e42d5d816fd8be348b059"}], "stats": {"total": 147, "additions": 51, "deletions": 96}, "files": [{"sha": "1dd9a586c7fbc64a4c62f7ea6d978472c1107f46", "filename": "crates/ra_parser/src/grammar/expressions.rs", "status": "modified", "additions": 9, "deletions": 40, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9db83d1ac85e83e018333f7aa4c5c5616e82b/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9db83d1ac85e83e018333f7aa4c5c5616e82b/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=b9d9db83d1ac85e83e018333f7aa4c5c5616e82b", "patch": "@@ -14,20 +14,17 @@ const EXPR_FIRST: TokenSet = LHS_FIRST;\n \n pub(super) fn expr(p: &mut Parser) -> BlockLike {\n     let r = Restrictions { forbid_structs: false, prefer_stmt: false };\n-    let mut dollar_lvl = 0;\n-    expr_bp(p, r, 1, &mut dollar_lvl).1\n+    expr_bp(p, r, 1).1\n }\n \n pub(super) fn expr_stmt(p: &mut Parser) -> (Option<CompletedMarker>, BlockLike) {\n     let r = Restrictions { forbid_structs: false, prefer_stmt: true };\n-    let mut dollar_lvl = 0;\n-    expr_bp(p, r, 1, &mut dollar_lvl)\n+    expr_bp(p, r, 1)\n }\n \n fn expr_no_struct(p: &mut Parser) {\n     let r = Restrictions { forbid_structs: true, prefer_stmt: false };\n-    let mut dollar_lvl = 0;\n-    expr_bp(p, r, 1, &mut dollar_lvl);\n+    expr_bp(p, r, 1);\n }\n \n // test block\n@@ -257,23 +254,8 @@ fn current_op(p: &Parser) -> (u8, SyntaxKind) {\n }\n \n // Parses expression with binding power of at least bp.\n-fn expr_bp(\n-    p: &mut Parser,\n-    r: Restrictions,\n-    mut bp: u8,\n-    dollar_lvl: &mut usize,\n-) -> (Option<CompletedMarker>, BlockLike) {\n-    // `newly_dollar_open` is a flag indicated that dollar is just closed after lhs, e.g.\n-    // `$1$ + a`\n-    // We use this flag to skip handling it.\n-    let mut newly_dollar_open = if p.at_l_dollar() {\n-        *dollar_lvl += p.eat_l_dollars();\n-        true\n-    } else {\n-        false\n-    };\n-\n-    let mut lhs = match lhs(p, r, dollar_lvl) {\n+fn expr_bp(p: &mut Parser, r: Restrictions, bp: u8) -> (Option<CompletedMarker>, BlockLike) {\n+    let mut lhs = match lhs(p, r) {\n         Some((lhs, blocklike)) => {\n             // test stmt_bin_expr_ambiguity\n             // fn foo() {\n@@ -289,15 +271,6 @@ fn expr_bp(\n     };\n \n     loop {\n-        if *dollar_lvl > 0 && p.at_r_dollar() {\n-            *dollar_lvl -= p.eat_r_dollars(*dollar_lvl);\n-            if !newly_dollar_open {\n-                // We \"pump\" bp for make it highest priority\n-                bp = 255;\n-            }\n-            newly_dollar_open = false;\n-        }\n-\n         let is_range = p.at(T![..]) || p.at(T![..=]);\n         let (op_bp, op) = current_op(p);\n         if op_bp < bp {\n@@ -306,19 +279,15 @@ fn expr_bp(\n         let m = lhs.precede(p);\n         p.bump(op);\n \n-        expr_bp(p, r, op_bp + 1, dollar_lvl);\n+        expr_bp(p, r, op_bp + 1);\n         lhs = m.complete(p, if is_range { RANGE_EXPR } else { BIN_EXPR });\n     }\n     (Some(lhs), BlockLike::NotBlock)\n }\n \n const LHS_FIRST: TokenSet = atom::ATOM_EXPR_FIRST.union(token_set![AMP, STAR, EXCL, DOT, MINUS]);\n \n-fn lhs(\n-    p: &mut Parser,\n-    r: Restrictions,\n-    dollar_lvl: &mut usize,\n-) -> Option<(CompletedMarker, BlockLike)> {\n+fn lhs(p: &mut Parser, r: Restrictions) -> Option<(CompletedMarker, BlockLike)> {\n     let m;\n     let kind = match p.current() {\n         // test ref_expr\n@@ -351,7 +320,7 @@ fn lhs(\n                     m = p.start();\n                     p.bump(op);\n                     if p.at_ts(EXPR_FIRST) {\n-                        expr_bp(p, r, 2, dollar_lvl);\n+                        expr_bp(p, r, 2);\n                     }\n                     return Some((m.complete(p, RANGE_EXPR), BlockLike::NotBlock));\n                 }\n@@ -367,7 +336,7 @@ fn lhs(\n             return Some(postfix_expr(p, lhs, blocklike, !(r.prefer_stmt && blocklike.is_block())));\n         }\n     };\n-    expr_bp(p, r, 255, dollar_lvl);\n+    expr_bp(p, r, 255);\n     Some((m.complete(p, kind), BlockLike::NotBlock))\n }\n "}, {"sha": "6e295fbf9303298c49374710213b600a659bafbb", "filename": "crates/ra_parser/src/grammar/expressions/atom.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9db83d1ac85e83e018333f7aa4c5c5616e82b/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9db83d1ac85e83e018333f7aa4c5c5616e82b/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs?ref=b9d9db83d1ac85e83e018333f7aa4c5c5616e82b", "patch": "@@ -69,6 +69,7 @@ pub(super) fn atom_expr(p: &mut Parser, r: Restrictions) -> Option<(CompletedMar\n     let done = match p.current() {\n         T!['('] => tuple_expr(p),\n         T!['['] => array_expr(p),\n+        L_DOLLAR => meta_var_expr(p),\n         T![|] => lambda_expr(p),\n         T![move] if la == T![|] => lambda_expr(p),\n         T![async] if la == T![|] || (la == T![move] && p.nth(2) == T![|]) => lambda_expr(p),\n@@ -554,3 +555,27 @@ fn box_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n     }\n     m.complete(p, BOX_EXPR)\n }\n+\n+/// Expression from `$var` macro expansion, wrapped in dollars\n+fn meta_var_expr(p: &mut Parser) -> CompletedMarker {\n+    assert!(p.at(L_DOLLAR));\n+    let m = p.start();\n+    p.bump(L_DOLLAR);\n+    let (completed, _is_block) =\n+        expr_bp(p, Restrictions { forbid_structs: false, prefer_stmt: false }, 1);\n+\n+    match (completed, p.current()) {\n+        (Some(it), R_DOLLAR) => {\n+            p.bump(R_DOLLAR);\n+            m.abandon(p);\n+            it\n+        }\n+        _ => {\n+            while !p.at(R_DOLLAR) {\n+                p.bump_any()\n+            }\n+            p.bump(R_DOLLAR);\n+            m.complete(p, ERROR)\n+        }\n+    }\n+}"}, {"sha": "a2ac363fb854aa71b6efa1405810bf8e4ed164bb", "filename": "crates/ra_parser/src/parser.rs", "status": "modified", "additions": 17, "deletions": 56, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9db83d1ac85e83e018333f7aa4c5c5616e82b/crates%2Fra_parser%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9db83d1ac85e83e018333f7aa4c5c5616e82b/crates%2Fra_parser%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fparser.rs?ref=b9d9db83d1ac85e83e018333f7aa4c5c5616e82b", "patch": "@@ -5,7 +5,7 @@ use drop_bomb::DropBomb;\n use crate::{\n     event::Event,\n     ParseError,\n-    SyntaxKind::{self, EOF, ERROR, TOMBSTONE},\n+    SyntaxKind::{self, EOF, ERROR, L_DOLLAR, R_DOLLAR, TOMBSTONE},\n     TokenSet, TokenSource, T,\n };\n \n@@ -211,19 +211,26 @@ impl<'t> Parser<'t> {\n \n     /// Create an error node and consume the next token.\n     pub(crate) fn err_recover(&mut self, message: &str, recovery: TokenSet) {\n-        if self.at(T!['{']) || self.at(T!['}']) || self.at_ts(recovery) {\n-            self.error(message);\n-        } else {\n-            let m = self.start();\n+        match self.current() {\n+            T!['{'] | T!['}'] | L_DOLLAR | R_DOLLAR => {\n+                self.error(message);\n+                return;\n+            }\n+            _ => (),\n+        }\n+\n+        if self.at_ts(recovery) {\n             self.error(message);\n-            self.bump_any();\n-            m.complete(self, ERROR);\n-        };\n+            return;\n+        }\n+\n+        let m = self.start();\n+        self.error(message);\n+        self.bump_any();\n+        m.complete(self, ERROR);\n     }\n \n     fn do_bump(&mut self, kind: SyntaxKind, n_raw_tokens: u8) {\n-        // self.eat_dollars();\n-\n         for _ in 0..n_raw_tokens {\n             self.token_source.bump();\n         }\n@@ -234,52 +241,6 @@ impl<'t> Parser<'t> {\n     fn push_event(&mut self, event: Event) {\n         self.events.push(event)\n     }\n-\n-    pub(crate) fn eat_l_dollars(&mut self) -> usize {\n-        let mut ate_count = 0;\n-        loop {\n-            match self.token_source.current().kind {\n-                k @ SyntaxKind::L_DOLLAR => {\n-                    self.token_source.bump();\n-                    self.push_event(Event::Token { kind: k, n_raw_tokens: 1 });\n-                    ate_count += 1;\n-                }\n-                _ => {\n-                    return ate_count;\n-                }\n-            }\n-        }\n-    }\n-\n-    pub(crate) fn eat_r_dollars(&mut self, max_count: usize) -> usize {\n-        let mut ate_count = 0;\n-        loop {\n-            match self.token_source.current().kind {\n-                k @ SyntaxKind::R_DOLLAR => {\n-                    self.token_source.bump();\n-                    self.push_event(Event::Token { kind: k, n_raw_tokens: 1 });\n-                    ate_count += 1;\n-\n-                    if max_count >= ate_count {\n-                        return ate_count;\n-                    }\n-                }\n-                _ => {\n-                    return ate_count;\n-                }\n-            }\n-        }\n-    }\n-\n-    pub(crate) fn at_l_dollar(&self) -> bool {\n-        let kind = self.token_source.current().kind;\n-        (kind == SyntaxKind::L_DOLLAR)\n-    }\n-\n-    pub(crate) fn at_r_dollar(&self) -> bool {\n-        let kind = self.token_source.current().kind;\n-        (kind == SyntaxKind::R_DOLLAR)\n-    }\n }\n \n /// See `Parser::start`."}]}