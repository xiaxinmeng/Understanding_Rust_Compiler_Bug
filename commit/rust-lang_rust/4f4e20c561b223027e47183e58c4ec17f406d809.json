{"sha": "4f4e20c561b223027e47183e58c4ec17f406d809", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmNGUyMGM1NjFiMjIzMDI3ZTQ3MTgzZTU4YzRlYzE3ZjQwNmQ4MDk=", "commit": {"author": {"name": "Philipp Hansch", "email": "dev@phansch.net", "date": "2018-04-15T11:00:12Z"}, "committer": {"name": "Philipp Hansch", "email": "dev@phansch.net", "date": "2018-04-15T11:59:57Z"}, "message": "Also lint Result.map for unit returns", "tree": {"sha": "45ea8d1ba4f6576f4790b5cac28265e4025ee151", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45ea8d1ba4f6576f4790b5cac28265e4025ee151"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f4e20c561b223027e47183e58c4ec17f406d809", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIcBAABCAAGBQJa0z6+AAoJELb6Bqbg4mZbY60P/3heJiIjVBQdh0JSdWla+PZU\n7r/HO6az4z51EwO8HilTuNk+Yr46fA5B78+Emg9l08sfi/EFy93+J5ftGE9YKpYt\n0sZjjVMCVSyvN02GeIukVZ1Z/Tk18d8BGaq2+vk87xyWtrW9+Y1y2BzUaPrODbz2\nqNPAE7INMVz64or0AfgTKXKe6RFvQNmHZivoGqPld8Oy/6eClKuedLRglzTwTM4q\nXdNvpWBBGVYyu8r9/iqJJpbcbpFOuuiDUwsZE5R065GQXefLXyjc4U2ZkU5I2wji\nYONPLMKUr1WTrP9uUqTT4Xp+D8xBPFL5PVlEjVQ45lxAUK75y9+GlWQjKzHh6+AS\nhNgTPxjweZcxJqA7jsrC3X0B5x9c2W8tA76N2aQnrgffX9Qs0jOGER4TmgWIOjP/\n53oUsCKEUSje8QcCrbTqhdPJAl5NlLVCxkxCG/c9bErCL0T1mYrq4qizQNrtffDn\nlLNvsPHKv9yK0fY2IkBoMwDJeYHSxUWGlI7/CF2y1iA2Wxbf2sDMbzOli6KpwWeu\nBtdVvrlW90Lsn65UWFJFD3fFWAWgd/VvTv8DruHkPWZlZPkVDe9omNtnYiIfV/3b\nUVoaYlFlSAKEStrzL0K/cUglBye8k5kisyTe7C1POwmBRzZtCZwa2nn0gdCl2giz\no7rzTCv6SidsSwkBJO8f\n=xIDj\n-----END PGP SIGNATURE-----", "payload": "tree 45ea8d1ba4f6576f4790b5cac28265e4025ee151\nparent 8307a899e994cf87821547b40ed67dae38a81bee\nauthor Philipp Hansch <dev@phansch.net> 1523790012 +0200\ncommitter Philipp Hansch <dev@phansch.net> 1523793597 +0200\n\nAlso lint Result.map for unit returns\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f4e20c561b223027e47183e58c4ec17f406d809", "html_url": "https://github.com/rust-lang/rust/commit/4f4e20c561b223027e47183e58c4ec17f406d809", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f4e20c561b223027e47183e58c4ec17f406d809/comments", "author": {"login": "phansch", "id": 2042399, "node_id": "MDQ6VXNlcjIwNDIzOTk=", "avatar_url": "https://avatars.githubusercontent.com/u/2042399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/phansch", "html_url": "https://github.com/phansch", "followers_url": "https://api.github.com/users/phansch/followers", "following_url": "https://api.github.com/users/phansch/following{/other_user}", "gists_url": "https://api.github.com/users/phansch/gists{/gist_id}", "starred_url": "https://api.github.com/users/phansch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/phansch/subscriptions", "organizations_url": "https://api.github.com/users/phansch/orgs", "repos_url": "https://api.github.com/users/phansch/repos", "events_url": "https://api.github.com/users/phansch/events{/privacy}", "received_events_url": "https://api.github.com/users/phansch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "phansch", "id": 2042399, "node_id": "MDQ6VXNlcjIwNDIzOTk=", "avatar_url": "https://avatars.githubusercontent.com/u/2042399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/phansch", "html_url": "https://github.com/phansch", "followers_url": "https://api.github.com/users/phansch/followers", "following_url": "https://api.github.com/users/phansch/following{/other_user}", "gists_url": "https://api.github.com/users/phansch/gists{/gist_id}", "starred_url": "https://api.github.com/users/phansch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/phansch/subscriptions", "organizations_url": "https://api.github.com/users/phansch/orgs", "repos_url": "https://api.github.com/users/phansch/repos", "events_url": "https://api.github.com/users/phansch/events{/privacy}", "received_events_url": "https://api.github.com/users/phansch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8307a899e994cf87821547b40ed67dae38a81bee", "url": "https://api.github.com/repos/rust-lang/rust/commits/8307a899e994cf87821547b40ed67dae38a81bee", "html_url": "https://github.com/rust-lang/rust/commit/8307a899e994cf87821547b40ed67dae38a81bee"}], "stats": {"total": 376, "additions": 360, "deletions": 16}, "files": [{"sha": "f66c0086894beada3fe7e9d6d4b7eb66144b94c6", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f4e20c561b223027e47183e58c4ec17f406d809/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/4f4e20c561b223027e47183e58c4ec17f406d809/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=4f4e20c561b223027e47183e58c4ec17f406d809", "patch": "@@ -705,7 +705,7 @@ All notable changes to this project will be documented in this file.\n [`nonsensical_open_options`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#nonsensical_open_options\n [`not_unsafe_ptr_arg_deref`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#not_unsafe_ptr_arg_deref\n [`ok_expect`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#ok_expect\n-[`option_map_unit_fn`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#option_map_unit_fn\n+[`map_unit_fn`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#map_unit_fn\n [`op_ref`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#op_ref\n [`option_map_or_none`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#option_map_or_none\n [`option_map_unwrap_or`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#option_map_unwrap_or"}, {"sha": "ea8478c373b8e1c284b69999021ec9de56f549bd", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f4e20c561b223027e47183e58c4ec17f406d809/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4e20c561b223027e47183e58c4ec17f406d809/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=4f4e20c561b223027e47183e58c4ec17f406d809", "patch": "@@ -444,6 +444,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         infinite_iter::MAYBE_INFINITE_ITER,\n         items_after_statements::ITEMS_AFTER_STATEMENTS,\n         map_unit_fn::OPTION_MAP_UNIT_FN,\n+        map_unit_fn::RESULT_MAP_UNIT_FN,\n         matches::SINGLE_MATCH_ELSE,\n         methods::FILTER_MAP,\n         methods::OPTION_MAP_UNWRAP_OR,"}, {"sha": "c3fc19699ea911959fe019721c47857a0de04017", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 62, "deletions": 15, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/4f4e20c561b223027e47183e58c4ec17f406d809/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4e20c561b223027e47183e58c4ec17f406d809/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=4f4e20c561b223027e47183e58c4ec17f406d809", "patch": "@@ -41,10 +41,43 @@ declare_clippy_lint! {\n     \"using `Option.map(f)`, where f is a function or closure that returns ()\"\n }\n \n+/// **What it does:** Checks for usage of `Result.map(f)` where f is a function\n+/// or closure that returns the unit type.\n+///\n+/// **Why is this bad?** Readability, this can be written more clearly with\n+/// an if statement\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+///\n+/// ```rust\n+/// let x: Result<&str, &str> = do_stuff();\n+/// x.map(log_err_msg);\n+/// x.map(|msg| log_err_msg(format_msg(msg)))\n+/// ```\n+///\n+/// The correct use would be:\n+///\n+/// ```rust\n+/// let x: Result<&str, &str> = do_stuff();\n+/// if let Ok(msg) = x {\n+///     log_err_msg(msg)\n+/// }\n+/// if let Ok(msg) = x {\n+///     log_err_msg(format_msg(msg))\n+/// }\n+/// ```\n+declare_clippy_lint! {\n+    pub RESULT_MAP_UNIT_FN,\n+    complexity,\n+    \"using `Result.map(f)`, where f is a function or closure that returns ()\"\n+}\n+\n \n impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(OPTION_MAP_UNIT_FN)\n+        lint_array!(OPTION_MAP_UNIT_FN, RESULT_MAP_UNIT_FN)\n     }\n }\n \n@@ -147,28 +180,40 @@ fn let_binding_name(cx: &LateContext, var_arg: &hir::Expr) -> String {\n     }\n }\n \n+fn suggestion_msg(function_type: &str, map_type: &str) -> String {\n+    format!(\n+        \"called `map(f)` on an {0} value where `f` is a unit {1}\",\n+        map_type,\n+        function_type\n+    )\n+}\n+\n fn lint_map_unit_fn(cx: &LateContext, stmt: &hir::Stmt, expr: &hir::Expr, map_args: &[hir::Expr]) {\n     let var_arg = &map_args[0];\n     let fn_arg = &map_args[1];\n \n-    if !match_type(cx, cx.tables.expr_ty(var_arg), &paths::OPTION) {\n-        return;\n-    }\n+    let (map_type, variant, lint) =\n+        if match_type(cx, cx.tables.expr_ty(var_arg), &paths::OPTION) {\n+            (\"Option\", \"Some\", OPTION_MAP_UNIT_FN)\n+        } else if match_type(cx, cx.tables.expr_ty(var_arg), &paths::RESULT) {\n+            (\"Result\", \"Ok\", RESULT_MAP_UNIT_FN)\n+        } else {\n+            return\n+        };\n \n     if is_unit_function(cx, fn_arg) {\n-        let msg = \"called `map(f)` on an Option value where `f` is a unit function\";\n-        let suggestion = format!(\"if let Some({0}) = {1} {{ {2}(...) }}\",\n+        let msg = suggestion_msg(\"function\", map_type);\n+        let suggestion = format!(\"if let {0}({1}) = {2} {{ {3}(...) }}\",\n+                                 variant,\n                                  let_binding_name(cx, var_arg),\n                                  snippet(cx, var_arg.span, \"_\"),\n                                  snippet(cx, fn_arg.span, \"_\"));\n \n-        span_lint_and_then(cx,\n-                           OPTION_MAP_UNIT_FN,\n-                           expr.span,\n-                           msg,\n-                           |db| { db.span_approximate_suggestion(stmt.span, \"try this\", suggestion); });\n+        span_lint_and_then(cx, lint, expr.span, &msg, |db| {\n+            db.span_approximate_suggestion(stmt.span, \"try this\", suggestion);\n+        });\n     } else if let Some((binding, closure_expr)) = unit_closure(cx, fn_arg) {\n-        let msg = \"called `map(f)` on an Option value where `f` is a unit closure\";\n+        let msg = suggestion_msg(\"closure\", map_type);\n \n         enum Suggestion {\n             Full(String),\n@@ -177,20 +222,22 @@ fn lint_map_unit_fn(cx: &LateContext, stmt: &hir::Stmt, expr: &hir::Expr, map_ar\n \n         let suggestion = if let Some(expr_span) = reduce_unit_expression(cx, closure_expr) {\n             Suggestion::Full(\n-                format!(\"if let Some({0}) = {1} {{ {2} }}\",\n+                format!(\"if let {0}({1}) = {2} {{ {3} }}\",\n+                        variant,\n                         snippet(cx, binding.pat.span, \"_\"),\n                         snippet(cx, var_arg.span, \"_\"),\n                         snippet(cx, expr_span, \"_\"))\n             )\n         } else {\n             Suggestion::Approx(\n-                format!(\"if let Some({0}) = {1} {{ ... }}\",\n+                format!(\"if let {0}({1}) = {2} {{ ... }}\",\n+                        variant,\n                         snippet(cx, binding.pat.span, \"_\"),\n                         snippet(cx, var_arg.span, \"_\"))\n             )\n         };\n \n-        span_lint_and_then(cx, OPTION_MAP_UNIT_FN, expr.span, msg, |db| {\n+        span_lint_and_then(cx, lint, expr.span, &msg, |db| {\n             match suggestion {\n                 Suggestion::Full(sugg) => db.span_suggestion(stmt.span, \"try this\", sugg),\n                 Suggestion::Approx(sugg) => db.span_approximate_suggestion(stmt.span, \"try this\", sugg),"}, {"sha": "8f3c1579987dcfe3a4e9c623362f44abfc13e0b9", "filename": "tests/ui/result_map_unit_fn.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/4f4e20c561b223027e47183e58c4ec17f406d809/tests%2Fui%2Fresult_map_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4e20c561b223027e47183e58c4ec17f406d809/tests%2Fui%2Fresult_map_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fresult_map_unit_fn.rs?ref=4f4e20c561b223027e47183e58c4ec17f406d809", "patch": "@@ -0,0 +1,102 @@\n+#![warn(result_map_unit_fn)]\n+#![allow(unused)]\n+\n+fn do_nothing<T>(_: T) {}\n+\n+fn diverge<T>(_: T) -> ! {\n+    panic!()\n+}\n+\n+fn plus_one(value: usize) -> usize {\n+    value + 1\n+}\n+\n+struct HasResult {\n+    field: Result<usize, usize>,\n+}\n+\n+impl HasResult {\n+    fn do_result_nothing(self: &Self, value: usize) {}\n+\n+    fn do_result_plus_one(self: &Self, value: usize) -> usize {\n+        value + 1\n+    }\n+}\n+\n+fn result_map_unit_fn() {\n+    let x = HasResult { field: Ok(10) };\n+\n+    x.field.map(plus_one);\n+    let _ : Result<(), usize> = x.field.map(do_nothing);\n+\n+    x.field.map(do_nothing);\n+\n+    x.field.map(do_nothing);\n+\n+    x.field.map(diverge);\n+\n+    let captured = 10;\n+    if let Ok(value) = x.field { do_nothing(value + captured) };\n+    let _ : Result<(), usize> = x.field.map(|value| do_nothing(value + captured));\n+\n+    x.field.map(|value| x.do_result_nothing(value + captured));\n+\n+    x.field.map(|value| { x.do_result_plus_one(value + captured); });\n+\n+\n+    x.field.map(|value| do_nothing(value + captured));\n+\n+    x.field.map(|value| { do_nothing(value + captured) });\n+\n+    x.field.map(|value| { do_nothing(value + captured); });\n+\n+    x.field.map(|value| { { do_nothing(value + captured); } });\n+\n+\n+    x.field.map(|value| diverge(value + captured));\n+\n+    x.field.map(|value| { diverge(value + captured) });\n+\n+    x.field.map(|value| { diverge(value + captured); });\n+\n+    x.field.map(|value| { { diverge(value + captured); } });\n+\n+\n+    x.field.map(|value| plus_one(value + captured));\n+    x.field.map(|value| { plus_one(value + captured) });\n+    x.field.map(|value| { let y = plus_one(value + captured); });\n+\n+    x.field.map(|value| { plus_one(value + captured); });\n+\n+    x.field.map(|value| { { plus_one(value + captured); } });\n+\n+\n+    x.field.map(|ref value| { do_nothing(value + captured) });\n+\n+\n+    x.field.map(|value| { do_nothing(value); do_nothing(value) });\n+\n+    x.field.map(|value| if value > 0 { do_nothing(value); do_nothing(value) });\n+\n+    // Suggestion for the let block should be `{ ... }` as it's too difficult to build a\n+    // proper suggestion for these cases\n+    x.field.map(|value| {\n+        do_nothing(value);\n+        do_nothing(value)\n+    });\n+    x.field.map(|value| { do_nothing(value); do_nothing(value); });\n+\n+    // The following should suggest `if let Ok(_X) ...` as it's difficult to generate a proper let variable name for them\n+    let res: Result<!, usize> = Ok(42).map(diverge);\n+    \"12\".parse::<i32>().map(diverge);\n+\n+    let res: Result<(), usize> = Ok(plus_one(1)).map(do_nothing);\n+\n+    // Should suggest `if let Ok(_y) ...` to not override the existing foo variable\n+    let y: Result<usize, usize> = Ok(42);\n+    y.map(do_nothing);\n+}\n+\n+fn main() {\n+}\n+"}, {"sha": "199f5e7cf97eb118b11a0f99ccc6401532cccb7f", "filename": "tests/ui/result_map_unit_fn.stderr", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/4f4e20c561b223027e47183e58c4ec17f406d809/tests%2Fui%2Fresult_map_unit_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f4e20c561b223027e47183e58c4ec17f406d809/tests%2Fui%2Fresult_map_unit_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fresult_map_unit_fn.stderr?ref=4f4e20c561b223027e47183e58c4ec17f406d809", "patch": "@@ -0,0 +1,194 @@\n+error: called `map(f)` on an Result value where `f` is a unit function\n+  --> $DIR/result_map_unit_fn.rs:32:5\n+   |\n+32 |     x.field.map(do_nothing);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(x_field) = x.field { do_nothing(...) }`\n+   |\n+   = note: `-D result-map-unit-fn` implied by `-D warnings`\n+\n+error: called `map(f)` on an Result value where `f` is a unit function\n+  --> $DIR/result_map_unit_fn.rs:34:5\n+   |\n+34 |     x.field.map(do_nothing);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(x_field) = x.field { do_nothing(...) }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit function\n+  --> $DIR/result_map_unit_fn.rs:36:5\n+   |\n+36 |     x.field.map(diverge);\n+   |     ^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(x_field) = x.field { diverge(...) }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:42:5\n+   |\n+42 |     x.field.map(|value| x.do_result_nothing(value + captured));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(value) = x.field { x.do_result_nothing(value + captured) }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:44:5\n+   |\n+44 |     x.field.map(|value| { x.do_result_plus_one(value + captured); });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(value) = x.field { x.do_result_plus_one(value + captured); }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:47:5\n+   |\n+47 |     x.field.map(|value| do_nothing(value + captured));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(value) = x.field { do_nothing(value + captured) }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:49:5\n+   |\n+49 |     x.field.map(|value| { do_nothing(value + captured) });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(value) = x.field { do_nothing(value + captured) }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:51:5\n+   |\n+51 |     x.field.map(|value| { do_nothing(value + captured); });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(value) = x.field { do_nothing(value + captured); }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:53:5\n+   |\n+53 |     x.field.map(|value| { { do_nothing(value + captured); } });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(value) = x.field { do_nothing(value + captured); }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:56:5\n+   |\n+56 |     x.field.map(|value| diverge(value + captured));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(value) = x.field { diverge(value + captured) }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:58:5\n+   |\n+58 |     x.field.map(|value| { diverge(value + captured) });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(value) = x.field { diverge(value + captured) }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:60:5\n+   |\n+60 |     x.field.map(|value| { diverge(value + captured); });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(value) = x.field { diverge(value + captured); }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:62:5\n+   |\n+62 |     x.field.map(|value| { { diverge(value + captured); } });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(value) = x.field { diverge(value + captured); }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:67:5\n+   |\n+67 |     x.field.map(|value| { let y = plus_one(value + captured); });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(value) = x.field { let y = plus_one(value + captured); }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:69:5\n+   |\n+69 |     x.field.map(|value| { plus_one(value + captured); });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(value) = x.field { plus_one(value + captured); }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:71:5\n+   |\n+71 |     x.field.map(|value| { { plus_one(value + captured); } });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(value) = x.field { plus_one(value + captured); }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:74:5\n+   |\n+74 |     x.field.map(|ref value| { do_nothing(value + captured) });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(ref value) = x.field { do_nothing(value + captured) }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:77:5\n+   |\n+77 |     x.field.map(|value| { do_nothing(value); do_nothing(value) });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(value) = x.field { ... }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:79:5\n+   |\n+79 |     x.field.map(|value| if value > 0 { do_nothing(value); do_nothing(value) });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(value) = x.field { ... }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:83:5\n+   |\n+83 |        x.field.map(|value| {\n+   |   _____^\n+   |  |_____|\n+   | ||\n+84 | ||         do_nothing(value);\n+85 | ||         do_nothing(value)\n+86 | ||     });\n+   | ||______^- help: try this: `if let Ok(value) = x.field { ... }`\n+   | |_______|\n+   | \n+\n+error: called `map(f)` on an Result value where `f` is a unit closure\n+  --> $DIR/result_map_unit_fn.rs:87:5\n+   |\n+87 |     x.field.map(|value| { do_nothing(value); do_nothing(value); });\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(value) = x.field { ... }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit function\n+  --> $DIR/result_map_unit_fn.rs:91:5\n+   |\n+91 |     \"12\".parse::<i32>().map(diverge);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(_) = \"12\".parse::<i32>() { diverge(...) }`\n+\n+error: called `map(f)` on an Result value where `f` is a unit function\n+  --> $DIR/result_map_unit_fn.rs:97:5\n+   |\n+97 |     y.map(do_nothing);\n+   |     ^^^^^^^^^^^^^^^^^-\n+   |     |\n+   |     help: try this: `if let Ok(_y) = y { do_nothing(...) }`\n+\n+error: aborting due to 23 previous errors\n+"}]}