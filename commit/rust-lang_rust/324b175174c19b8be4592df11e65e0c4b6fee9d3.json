{"sha": "324b175174c19b8be4592df11e65e0c4b6fee9d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyNGIxNzUxNzRjMTliOGJlNDU5MmRmMTFlNjVlMGM0YjZmZWU5ZDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-06T14:10:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-06T14:10:13Z"}, "message": "Auto merge of #39500 - michaelwoerister:fix-ich-testing, r=nikomatsakis\n\nLet the dep-tracking test framework check that all #[rustc_dirty] attrs have been actually checked\n\nr? @nikomatsakis", "tree": {"sha": "c898b6e95844adbf2e1df8794f1f1da3c34fce23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c898b6e95844adbf2e1df8794f1f1da3c34fce23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/324b175174c19b8be4592df11e65e0c4b6fee9d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/324b175174c19b8be4592df11e65e0c4b6fee9d3", "html_url": "https://github.com/rust-lang/rust/commit/324b175174c19b8be4592df11e65e0c4b6fee9d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/324b175174c19b8be4592df11e65e0c4b6fee9d3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4711ac314c3380f992e218879b7c94b26ba4102b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4711ac314c3380f992e218879b7c94b26ba4102b", "html_url": "https://github.com/rust-lang/rust/commit/4711ac314c3380f992e218879b7c94b26ba4102b"}, {"sha": "ab3c8269f4d73d4760e99aca82411f954a11e571", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab3c8269f4d73d4760e99aca82411f954a11e571", "html_url": "https://github.com/rust-lang/rust/commit/ab3c8269f4d73d4760e99aca82411f954a11e571"}], "stats": {"total": 364, "additions": 306, "deletions": 58}, "files": [{"sha": "1df67615069935a364ca55a7e09d6050e352cca7", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/324b175174c19b8be4592df11e65e0c4b6fee9d3/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/324b175174c19b8be4592df11e65e0c4b6fee9d3/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=324b175174c19b8be4592df11e65e0c4b6fee9d3", "patch": "@@ -914,6 +914,7 @@ pub fn walk_decl<'v, V: Visitor<'v>>(visitor: &mut V, declaration: &'v Decl) {\n \n pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n     visitor.visit_id(expression.id);\n+    walk_list!(visitor, visit_attribute, expression.attrs.iter());\n     match expression.node {\n         ExprBox(ref subexpression) => {\n             visitor.visit_expr(subexpression)"}, {"sha": "a0bcb54af320fa1a1728ff893ca11ee5a4205e6a", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 122, "deletions": 31, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/324b175174c19b8be4592df11e65e0c4b6fee9d3/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/324b175174c19b8be4592df11e65e0c4b6fee9d3/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=324b175174c19b8be4592df11e65e0c4b6fee9d3", "patch": "@@ -46,6 +46,7 @@ use rustc::dep_graph::{DepGraphQuery, DepNode};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::hir::intravisit;\n use syntax::ast::{self, Attribute, NestedMetaItem};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use syntax_pos::Span;\n@@ -73,17 +74,32 @@ pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let query = tcx.dep_graph.query();\n     debug!(\"query-nodes: {:?}\", query.nodes());\n     let krate = tcx.hir.krate();\n-    krate.visit_all_item_likes(&mut DirtyCleanVisitor {\n+    let mut dirty_clean_visitor = DirtyCleanVisitor {\n         tcx: tcx,\n         query: &query,\n         dirty_inputs: dirty_inputs,\n-    });\n+        checked_attrs: FxHashSet(),\n+    };\n+    krate.visit_all_item_likes(&mut dirty_clean_visitor);\n+\n+    let mut all_attrs = FindAllAttrs {\n+        tcx: tcx,\n+        attr_names: vec![ATTR_DIRTY, ATTR_CLEAN],\n+        found_attrs: vec![],\n+    };\n+    intravisit::walk_crate(&mut all_attrs, krate);\n+\n+    // Note that we cannot use the existing \"unused attribute\"-infrastructure\n+    // here, since that is running before trans. This is also the reason why\n+    // all trans-specific attributes are `Whitelisted` in syntax::feature_gate.\n+    all_attrs.report_unchecked_attrs(&dirty_clean_visitor.checked_attrs);\n }\n \n pub struct DirtyCleanVisitor<'a, 'tcx:'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     query: &'a DepGraphQuery<DefId>,\n     dirty_inputs: FxHashSet<DepNode<DefId>>,\n+    checked_attrs: FxHashSet<ast::AttrId>,\n }\n \n impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n@@ -109,7 +125,7 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n         dep_node.map_def(|&def_id| Some(self.tcx.item_path_str(def_id))).unwrap()\n     }\n \n-    fn assert_dirty(&self, item: &hir::Item, dep_node: DepNode<DefId>) {\n+    fn assert_dirty(&self, item_span: Span, dep_node: DepNode<DefId>) {\n         debug!(\"assert_dirty({:?})\", dep_node);\n \n         match dep_node {\n@@ -121,7 +137,7 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n                 if !self.dirty_inputs.contains(&dep_node) {\n                     let dep_node_str = self.dep_node_str(&dep_node);\n                     self.tcx.sess.span_err(\n-                        item.span,\n+                        item_span,\n                         &format!(\"`{:?}` not found in dirty set, but should be dirty\",\n                                  dep_node_str));\n                 }\n@@ -132,14 +148,14 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n                 if self.query.contains_node(&dep_node) {\n                     let dep_node_str = self.dep_node_str(&dep_node);\n                     self.tcx.sess.span_err(\n-                        item.span,\n+                        item_span,\n                         &format!(\"`{:?}` found in dep graph, but should be dirty\", dep_node_str));\n                 }\n             }\n         }\n     }\n \n-    fn assert_clean(&self, item: &hir::Item, dep_node: DepNode<DefId>) {\n+    fn assert_clean(&self, item_span: Span, dep_node: DepNode<DefId>) {\n         debug!(\"assert_clean({:?})\", dep_node);\n \n         match dep_node {\n@@ -150,7 +166,7 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n                 if self.dirty_inputs.contains(&dep_node) {\n                     let dep_node_str = self.dep_node_str(&dep_node);\n                     self.tcx.sess.span_err(\n-                        item.span,\n+                        item_span,\n                         &format!(\"`{:?}` found in dirty-node set, but should be clean\",\n                                  dep_node_str));\n                 }\n@@ -160,35 +176,43 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n                 if !self.query.contains_node(&dep_node) {\n                     let dep_node_str = self.dep_node_str(&dep_node);\n                     self.tcx.sess.span_err(\n-                        item.span,\n+                        item_span,\n                         &format!(\"`{:?}` not found in dep graph, but should be clean\",\n                                  dep_node_str));\n                 }\n             }\n         }\n     }\n-}\n \n-impl<'a, 'tcx> ItemLikeVisitor<'tcx> for DirtyCleanVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let def_id = self.tcx.hir.local_def_id(item.id);\n+    fn check_item(&mut self, item_id: ast::NodeId, item_span: Span) {\n+        let def_id = self.tcx.hir.local_def_id(item_id);\n         for attr in self.tcx.get_attrs(def_id).iter() {\n             if attr.check_name(ATTR_DIRTY) {\n                 if check_config(self.tcx, attr) {\n-                    self.assert_dirty(item, self.dep_node(attr, def_id));\n+                    self.checked_attrs.insert(attr.id);\n+                    self.assert_dirty(item_span, self.dep_node(attr, def_id));\n                 }\n             } else if attr.check_name(ATTR_CLEAN) {\n                 if check_config(self.tcx, attr) {\n-                    self.assert_clean(item, self.dep_node(attr, def_id));\n+                    self.checked_attrs.insert(attr.id);\n+                    self.assert_clean(item_span, self.dep_node(attr, def_id));\n                 }\n             }\n         }\n     }\n+}\n+\n+impl<'a, 'tcx> ItemLikeVisitor<'tcx> for DirtyCleanVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+        self.check_item(item.id, item.span);\n+    }\n \n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, item: &hir::TraitItem) {\n+        self.check_item(item.id, item.span);\n     }\n \n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, item: &hir::ImplItem) {\n+        self.check_item(item.id, item.span);\n     }\n }\n \n@@ -201,46 +225,69 @@ pub fn check_dirty_clean_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     tcx.dep_graph.with_ignore(||{\n         let krate = tcx.hir.krate();\n-        krate.visit_all_item_likes(&mut DirtyCleanMetadataVisitor {\n+        let mut dirty_clean_visitor = DirtyCleanMetadataVisitor {\n             tcx: tcx,\n             prev_metadata_hashes: prev_metadata_hashes,\n             current_metadata_hashes: current_metadata_hashes,\n-        });\n+            checked_attrs: FxHashSet(),\n+        };\n+        krate.visit_all_item_likes(&mut dirty_clean_visitor);\n+\n+        let mut all_attrs = FindAllAttrs {\n+            tcx: tcx,\n+            attr_names: vec![ATTR_DIRTY_METADATA, ATTR_CLEAN_METADATA],\n+            found_attrs: vec![],\n+        };\n+        intravisit::walk_crate(&mut all_attrs, krate);\n+\n+        // Note that we cannot use the existing \"unused attribute\"-infrastructure\n+        // here, since that is running before trans. This is also the reason why\n+        // all trans-specific attributes are `Whitelisted` in syntax::feature_gate.\n+        all_attrs.report_unchecked_attrs(&dirty_clean_visitor.checked_attrs);\n     });\n }\n \n pub struct DirtyCleanMetadataVisitor<'a, 'tcx:'a, 'm> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     prev_metadata_hashes: &'m FxHashMap<DefId, Fingerprint>,\n     current_metadata_hashes: &'m FxHashMap<DefId, Fingerprint>,\n+    checked_attrs: FxHashSet<ast::AttrId>,\n }\n \n impl<'a, 'tcx, 'm> ItemLikeVisitor<'tcx> for DirtyCleanMetadataVisitor<'a, 'tcx, 'm> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let def_id = self.tcx.hir.local_def_id(item.id);\n+        self.check_item(item.id, item.span);\n+    }\n+\n+    fn visit_trait_item(&mut self, item: &hir::TraitItem) {\n+        self.check_item(item.id, item.span);\n+    }\n+\n+    fn visit_impl_item(&mut self, item: &hir::ImplItem) {\n+        self.check_item(item.id, item.span);\n+    }\n+}\n+\n+impl<'a, 'tcx, 'm> DirtyCleanMetadataVisitor<'a, 'tcx, 'm> {\n+\n+    fn check_item(&mut self, item_id: ast::NodeId, item_span: Span) {\n+        let def_id = self.tcx.hir.local_def_id(item_id);\n \n         for attr in self.tcx.get_attrs(def_id).iter() {\n             if attr.check_name(ATTR_DIRTY_METADATA) {\n                 if check_config(self.tcx, attr) {\n-                    self.assert_state(false, def_id, item.span);\n+                    self.checked_attrs.insert(attr.id);\n+                    self.assert_state(false, def_id, item_span);\n                 }\n             } else if attr.check_name(ATTR_CLEAN_METADATA) {\n                 if check_config(self.tcx, attr) {\n-                    self.assert_state(true, def_id, item.span);\n+                    self.checked_attrs.insert(attr.id);\n+                    self.assert_state(true, def_id, item_span);\n                 }\n             }\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n-    }\n-\n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n-    }\n-}\n-\n-impl<'a, 'tcx, 'm> DirtyCleanMetadataVisitor<'a, 'tcx, 'm> {\n-\n     fn assert_state(&self, should_be_clean: bool, def_id: DefId, span: Span) {\n         let item_path = self.tcx.item_path_str(def_id);\n         debug!(\"assert_state({})\", item_path);\n@@ -274,7 +321,7 @@ impl<'a, 'tcx, 'm> DirtyCleanMetadataVisitor<'a, 'tcx, 'm> {\n /// Given a `#[rustc_dirty]` or `#[rustc_clean]` attribute, scan\n /// for a `cfg=\"foo\"` attribute and check whether we have a cfg\n /// flag called `foo`.\n-fn check_config(tcx: TyCtxt, attr: &ast::Attribute) -> bool {\n+fn check_config(tcx: TyCtxt, attr: &Attribute) -> bool {\n     debug!(\"check_config(attr={:?})\", attr);\n     let config = &tcx.sess.parse_sess.config;\n     debug!(\"check_config: config={:?}\", config);\n@@ -304,3 +351,47 @@ fn expect_associated_value(tcx: TyCtxt, item: &NestedMetaItem) -> ast::Name {\n         tcx.sess.span_fatal(item.span, &msg);\n     }\n }\n+\n+\n+// A visitor that collects all #[rustc_dirty]/#[rustc_clean] attributes from\n+// the HIR. It is used to verfiy that we really ran checks for all annotated\n+// nodes.\n+pub struct FindAllAttrs<'a, 'tcx:'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    attr_names: Vec<&'static str>,\n+    found_attrs: Vec<&'tcx Attribute>,\n+}\n+\n+impl<'a, 'tcx> FindAllAttrs<'a, 'tcx> {\n+\n+    fn is_active_attr(&mut self, attr: &Attribute) -> bool {\n+        for attr_name in &self.attr_names {\n+            if attr.check_name(attr_name) && check_config(self.tcx, attr) {\n+                return true;\n+            }\n+        }\n+\n+        false\n+    }\n+\n+    fn report_unchecked_attrs(&self, checked_attrs: &FxHashSet<ast::AttrId>) {\n+        for attr in &self.found_attrs {\n+            if !checked_attrs.contains(&attr.id) {\n+                self.tcx.sess.span_err(attr.span, &format!(\"found unchecked \\\n+                    #[rustc_dirty]/#[rustc_clean] attribute\"));\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> intravisit::Visitor<'tcx> for FindAllAttrs<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n+        intravisit::NestedVisitorMap::All(&self.tcx.hir)\n+    }\n+\n+    fn visit_attribute(&mut self, attr: &'tcx Attribute) {\n+        if self.is_active_attr(attr) {\n+            self.found_attrs.push(attr);\n+        }\n+    }\n+}"}, {"sha": "fd9ac61046e3a978add0ffde467dc65a420c9d60", "filename": "src/test/incremental/hashes/inherent_impls.rs", "status": "modified", "additions": 51, "deletions": 16, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/324b175174c19b8be4592df11e65e0c4b6fee9d3/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/324b175174c19b8be4592df11e65e0c4b6fee9d3/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs?ref=324b175174c19b8be4592df11e65e0c4b6fee9d3", "patch": "@@ -39,9 +39,7 @@ impl Foo {\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn method_name2() { }\n }\n@@ -60,16 +58,47 @@ impl Foo {\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn method_body() {\n         println!(\"Hello, world!\");\n     }\n }\n \n-// Change Method Privacy -----------------------------------------------------------\n+\n+// Change Method Body (inlined) ------------------------------------------------\n+//\n+// This should affect the method itself, but not the impl.\n+#[cfg(cfail1)]\n+impl Foo {\n+    #[inline]\n+    pub fn method_body_inlined() { }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl Foo {\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    #[inline]\n+    pub fn method_body_inlined() {\n+        println!(\"Hello, world!\");\n+    }\n+}\n+\n+\n+// Change Method Privacy -------------------------------------------------------\n #[cfg(cfail1)]\n impl Foo {\n     pub fn method_privacy() { }\n@@ -142,13 +171,11 @@ impl Foo {\n impl Foo {\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_metadata_clean(cfg=\"cfail2\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn add_method_to_impl1(&self) { }\n \n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn add_method_to_impl2(&self) { }\n }\n@@ -188,9 +215,13 @@ impl Foo {\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    // At the moment we explicitly ignore argument names in metadata, since they\n+    // are not used in downstream crates (except in rustdoc)\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn change_method_parameter_name(&self, b: i64) { }\n }\n@@ -252,9 +283,13 @@ impl Foo {\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    // At the moment we explicitly ignore argument names in metadata, since they\n+    // are not used in downstream crates (except in rustdoc)\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn change_method_parameter_order(&self, b: i64, a: i64) { }\n }\n@@ -465,7 +500,7 @@ impl Bar<u32> {\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl<T> Bar<T> {\n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n@@ -486,7 +521,7 @@ impl Bar<u32> {\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl Bar<u64> {\n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n@@ -507,7 +542,7 @@ impl<T> Bar<T> {\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl<T: 'static> Bar<T> {\n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n@@ -528,7 +563,7 @@ impl<T> Bar<T> {\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl<T: Clone> Bar<T> {\n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]"}, {"sha": "94698506ec53fd6df782c9fcb32fe7775a6a177e", "filename": "src/test/incremental/hashes/trait_defs.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/324b175174c19b8be4592df11e65e0c4b6fee9d3/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/324b175174c19b8be4592df11e65e0c4b6fee9d3/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs?ref=324b175174c19b8be4592df11e65e0c4b6fee9d3", "patch": "@@ -316,8 +316,10 @@ trait TraitChangeModeSelfOwnToMut: Sized {\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitChangeModeSelfOwnToMut: Sized {\n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn method(mut self) {}"}, {"sha": "30e376f04fb87ff78b0a4fa7d4f4db82306c4516", "filename": "src/test/incremental/hashes/trait_impls.rs", "status": "modified", "additions": 40, "deletions": 10, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/324b175174c19b8be4592df11e65e0c4b6fee9d3/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/324b175174c19b8be4592df11e65e0c4b6fee9d3/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_impls.rs?ref=324b175174c19b8be4592df11e65e0c4b6fee9d3", "patch": "@@ -46,9 +46,7 @@ impl ChangeMethodNameTrait for Foo {\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub trait ChangeMethodNameTrait {\n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn method_name2();\n }\n@@ -59,16 +57,14 @@ pub trait ChangeMethodNameTrait {\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl ChangeMethodNameTrait for Foo {\n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn method_name2() { }\n }\n \n // Change Method Body -----------------------------------------------------------\n //\n-// This should affect the method itself, but not the trait.\n+// This should affect the method itself, but not the impl.\n \n pub trait ChangeMethodBodyTrait {\n     fn method_name();\n@@ -85,16 +81,50 @@ impl ChangeMethodBodyTrait for Foo {\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl ChangeMethodBodyTrait for Foo {\n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    fn method_name() {\n+        ()\n+    }\n+}\n+\n+// Change Method Body (inlined fn) ---------------------------------------------\n+//\n+// This should affect the method itself, but not the impl.\n+\n+pub trait ChangeMethodBodyTraitInlined {\n+    fn method_name();\n+}\n+\n+#[cfg(cfail1)]\n+impl ChangeMethodBodyTraitInlined for Foo {\n+    #[inline]\n+    fn method_name() { }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl ChangeMethodBodyTraitInlined for Foo {\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    #[inline]\n     fn method_name() {\n         ()\n     }\n }\n \n-// Change Method Selfness -----------------------------------------------------------\n+// Change Method Selfness ------------------------------------------------------\n \n #[cfg(cfail1)]\n pub trait ChangeMethodSelfnessTrait {\n@@ -447,7 +477,7 @@ impl ChangeSelfTypeOfImpl for u32 {\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl ChangeSelfTypeOfImpl for u64 {\n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n@@ -472,7 +502,7 @@ impl<T> AddLifetimeBoundToImplParameter for T {\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl<T: 'static> AddLifetimeBoundToImplParameter for T {\n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n@@ -497,7 +527,7 @@ impl<T> AddTraitBoundToImplParameter for T {\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl<T: Clone> AddTraitBoundToImplParameter for T {\n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]"}, {"sha": "a81e884f39eacb64687a6565ee5b9b34b02a4ee0", "filename": "src/test/incremental/unchecked_dirty_clean.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/324b175174c19b8be4592df11e65e0c4b6fee9d3/src%2Ftest%2Fincremental%2Funchecked_dirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/324b175174c19b8be4592df11e65e0c4b6fee9d3/src%2Ftest%2Fincremental%2Funchecked_dirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Funchecked_dirty_clean.rs?ref=324b175174c19b8be4592df11e65e0c4b6fee9d3", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: rpass1 cfail2\n+// compile-flags: -Z query-dep-graph\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+\n+// Sanity check for the dirty-clean system. We add #[rustc_dirty]/#[rustc_clean]\n+// attributes in places that are not checked and make sure that this causes an\n+// error.\n+\n+fn main() {\n+\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    //[cfail2]~^ ERROR found unchecked #[rustc_dirty]/#[rustc_clean] attribute\n+    {\n+        // empty block\n+    }\n+\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+    //[cfail2]~^ ERROR found unchecked #[rustc_dirty]/#[rustc_clean] attribute\n+    {\n+        // empty block\n+    }\n+}\n+\n+struct _Struct {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    //[cfail2]~^ ERROR found unchecked #[rustc_dirty]/#[rustc_clean] attribute\n+    _field1: i32,\n+\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+    //[cfail2]~^ ERROR found unchecked #[rustc_dirty]/#[rustc_clean] attribute\n+    _field2: i32,\n+}"}, {"sha": "4017b4d4ba9aee6085c31b165248d9bae6133e40", "filename": "src/test/incremental/unchecked_dirty_clean_metadata.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/324b175174c19b8be4592df11e65e0c4b6fee9d3/src%2Ftest%2Fincremental%2Funchecked_dirty_clean_metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/324b175174c19b8be4592df11e65e0c4b6fee9d3/src%2Ftest%2Fincremental%2Funchecked_dirty_clean_metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Funchecked_dirty_clean_metadata.rs?ref=324b175174c19b8be4592df11e65e0c4b6fee9d3", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: rpass1 cfail2\n+// compile-flags: -Z query-dep-graph\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+\n+// Sanity check for the dirty-clean system. We add\n+// #[rustc_metadata_dirty]/#[rustc_metadata_clean] attributes in places that\n+// are not checked and make sure that this causes an error.\n+\n+fn main() {\n+\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    //[cfail2]~^ ERROR found unchecked #[rustc_dirty]/#[rustc_clean] attribute\n+    {\n+        // empty block\n+    }\n+\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n+    //[cfail2]~^ ERROR found unchecked #[rustc_dirty]/#[rustc_clean] attribute\n+    {\n+        // empty block\n+    }\n+}\n+\n+struct _Struct {\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    //[cfail2]~^ ERROR found unchecked #[rustc_dirty]/#[rustc_clean] attribute\n+    _field1: i32,\n+\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n+    //[cfail2]~^ ERROR found unchecked #[rustc_dirty]/#[rustc_clean] attribute\n+    _field2: i32,\n+}\n+"}]}