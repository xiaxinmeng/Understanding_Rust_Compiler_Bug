{"sha": "64a8ffeffaae2fe72994fb0832ae525346b8a3c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0YThmZmVmZmFhZTJmZTcyOTk0ZmIwODMyYWU1MjUzNDZiOGEzYzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-07T22:54:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-07T22:54:22Z"}, "message": "Auto merge of #30757 - michaelwoerister:mir-visitor-cleanup, r=jroesch\n\nAfter a call to `visit_def_id()` missing in `mir::visit::Visitor` but not `mir::visit::MutVisitor` has caused me a couple hours of error hunting, I decided I'd take the time to get rid of the code duplication between the two implementations.\n\ncc @rust-lang/compiler", "tree": {"sha": "b5f087b77d4a35333e2f841add8b675573612b9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5f087b77d4a35333e2f841add8b675573612b9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64a8ffeffaae2fe72994fb0832ae525346b8a3c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64a8ffeffaae2fe72994fb0832ae525346b8a3c0", "html_url": "https://github.com/rust-lang/rust/commit/64a8ffeffaae2fe72994fb0832ae525346b8a3c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64a8ffeffaae2fe72994fb0832ae525346b8a3c0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c92010d3bf51bd83e2fdab4374b506a1d112fd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c92010d3bf51bd83e2fdab4374b506a1d112fd2", "html_url": "https://github.com/rust-lang/rust/commit/5c92010d3bf51bd83e2fdab4374b506a1d112fd2"}, {"sha": "8f51188a8ec74febddec53826adf6d408ac1a3a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f51188a8ec74febddec53826adf6d408ac1a3a8", "html_url": "https://github.com/rust-lang/rust/commit/8f51188a8ec74febddec53826adf6d408ac1a3a8"}], "stats": {"total": 737, "additions": 281, "deletions": 456}, "files": [{"sha": "6ca39d3ba7a8758f7481adee2297fc9b7c3c3db6", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/64a8ffeffaae2fe72994fb0832ae525346b8a3c0/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a8ffeffaae2fe72994fb0832ae525346b8a3c0/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=64a8ffeffaae2fe72994fb0832ae525346b8a3c0", "patch": "@@ -21,6 +21,7 @@ use std::ascii;\n use std::borrow::{Cow, IntoCow};\n use std::fmt::{self, Debug, Formatter, Write};\n use std::{iter, u32};\n+use std::ops::{Index, IndexMut};\n \n /// Lowered representation of a single function.\n #[derive(RustcEncodable, RustcDecodable)]\n@@ -68,6 +69,22 @@ impl<'tcx> Mir<'tcx> {\n     }\n }\n \n+impl<'tcx> Index<BasicBlock> for Mir<'tcx> {\n+    type Output = BasicBlockData<'tcx>;\n+\n+    #[inline]\n+    fn index(&self, index: BasicBlock) -> &BasicBlockData<'tcx> {\n+        self.basic_block_data(index)\n+    }\n+}\n+\n+impl<'tcx> IndexMut<BasicBlock> for Mir<'tcx> {\n+    #[inline]\n+    fn index_mut(&mut self, index: BasicBlock) -> &mut BasicBlockData<'tcx> {\n+        self.basic_block_data_mut(index)\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Mutability and borrow kinds\n "}, {"sha": "7c8ea22de8e922a315d42de9bb875ccfb5c6535d", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 264, "deletions": 456, "changes": 720, "blob_url": "https://github.com/rust-lang/rust/blob/64a8ffeffaae2fe72994fb0832ae525346b8a3c0/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a8ffeffaae2fe72994fb0832ae525346b8a3c0/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=64a8ffeffaae2fe72994fb0832ae525346b8a3c0", "patch": "@@ -14,545 +14,353 @@ use mir::repr::*;\n use rustc_data_structures::tuple_slice::TupleSlice;\n use syntax::codemap::Span;\n \n-pub trait Visitor<'tcx> {\n-    // Override these, and call `self.super_xxx` to revert back to the\n-    // default behavior.\n+macro_rules! make_mir_visitor {\n+    ($visitor_trait_name:ident, $($mutability:ident)*) => {\n+        pub trait $visitor_trait_name<'tcx> {\n+            // Override these, and call `self.super_xxx` to revert back to the\n+            // default behavior.\n \n-    fn visit_mir(&mut self, mir: &Mir<'tcx>) {\n-        self.super_mir(mir);\n-    }\n-\n-    fn visit_basic_block_data(&mut self, block: BasicBlock, data: &BasicBlockData<'tcx>) {\n-        self.super_basic_block_data(block, data);\n-    }\n-\n-    fn visit_statement(&mut self, block: BasicBlock, statement: &Statement<'tcx>) {\n-        self.super_statement(block, statement);\n-    }\n-\n-    fn visit_assign(&mut self, block: BasicBlock, lvalue: &Lvalue<'tcx>, rvalue: &Rvalue<'tcx>) {\n-        self.super_assign(block, lvalue, rvalue);\n-    }\n-\n-    fn visit_terminator(&mut self, block: BasicBlock, terminator: &Terminator<'tcx>) {\n-        self.super_terminator(block, terminator);\n-    }\n-\n-    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>) {\n-        self.super_rvalue(rvalue);\n-    }\n-\n-    fn visit_operand(&mut self, operand: &Operand<'tcx>) {\n-        self.super_operand(operand);\n-    }\n-\n-    fn visit_lvalue(&mut self, lvalue: &Lvalue<'tcx>, context: LvalueContext) {\n-        self.super_lvalue(lvalue, context);\n-    }\n-\n-    fn visit_branch(&mut self, source: BasicBlock, target: BasicBlock) {\n-        self.super_branch(source, target);\n-    }\n-\n-    fn visit_constant(&mut self, constant: &Constant<'tcx>) {\n-        self.super_constant(constant);\n-    }\n-\n-    fn visit_literal(&mut self, literal: &Literal<'tcx>) {\n-        self.super_literal(literal);\n-    }\n-\n-    fn visit_def_id(&mut self, def_id: DefId) {\n-        self.super_def_id(def_id);\n-    }\n-\n-    fn visit_span(&mut self, span: Span) {\n-        self.super_span(span);\n-    }\n-\n-    // The `super_xxx` methods comprise the default behavior and are\n-    // not meant to be overidden.\n-\n-    fn super_mir(&mut self, mir: &Mir<'tcx>) {\n-        for block in mir.all_basic_blocks() {\n-            let data = mir.basic_block_data(block);\n-            self.visit_basic_block_data(block, data);\n-        }\n-    }\n-\n-    fn super_basic_block_data(&mut self, block: BasicBlock, data: &BasicBlockData<'tcx>) {\n-        for statement in &data.statements {\n-            self.visit_statement(block, statement);\n-        }\n-        data.terminator.as_ref().map(|r| self.visit_terminator(block, r));\n-    }\n-\n-    fn super_statement(&mut self, block: BasicBlock, statement: &Statement<'tcx>) {\n-        self.visit_span(statement.span);\n-\n-        match statement.kind {\n-            StatementKind::Assign(ref lvalue, ref rvalue) => {\n-                self.visit_assign(block, lvalue, rvalue);\n+            fn visit_mir(&mut self, mir: & $($mutability)* Mir<'tcx>) {\n+                self.super_mir(mir);\n             }\n-            StatementKind::Drop(_, ref lvalue) => {\n-                self.visit_lvalue(lvalue, LvalueContext::Drop);\n-            }\n-        }\n-    }\n \n-    fn super_assign(&mut self, _block: BasicBlock, lvalue: &Lvalue<'tcx>, rvalue: &Rvalue<'tcx>) {\n-        self.visit_lvalue(lvalue, LvalueContext::Store);\n-        self.visit_rvalue(rvalue);\n-    }\n-\n-    fn super_terminator(&mut self, block: BasicBlock, terminator: &Terminator<'tcx>) {\n-        match *terminator {\n-            Terminator::Goto { target } => {\n-                self.visit_branch(block, target);\n+            fn visit_basic_block_data(&mut self,\n+                                      block: BasicBlock,\n+                                      data: & $($mutability)* BasicBlockData<'tcx>) {\n+                self.super_basic_block_data(block, data);\n             }\n \n-            Terminator::If { ref cond, ref targets } => {\n-                self.visit_operand(cond);\n-                for &target in targets.as_slice() {\n-                    self.visit_branch(block, target);\n-                }\n+            fn visit_statement(&mut self,\n+                               block: BasicBlock,\n+                               statement: & $($mutability)* Statement<'tcx>) {\n+                self.super_statement(block, statement);\n             }\n \n-            Terminator::Switch { ref discr, adt_def: _, ref targets } => {\n-                self.visit_lvalue(discr, LvalueContext::Inspect);\n-                for &target in targets {\n-                    self.visit_branch(block, target);\n-                }\n+            fn visit_assign(&mut self,\n+                            block: BasicBlock,\n+                            lvalue: & $($mutability)* Lvalue<'tcx>,\n+                            rvalue: & $($mutability)* Rvalue<'tcx>) {\n+                self.super_assign(block, lvalue, rvalue);\n             }\n \n-            Terminator::SwitchInt { ref discr, switch_ty: _, values: _, ref targets } => {\n-                self.visit_lvalue(discr, LvalueContext::Inspect);\n-                for &target in targets {\n-                    self.visit_branch(block, target);\n-                }\n+            fn visit_terminator(&mut self,\n+                                block: BasicBlock,\n+                                terminator: & $($mutability)* Terminator<'tcx>) {\n+                self.super_terminator(block, terminator);\n             }\n \n-            Terminator::Resume |\n-            Terminator::Return => {\n+            fn visit_rvalue(&mut self,\n+                            rvalue: & $($mutability)* Rvalue<'tcx>) {\n+                self.super_rvalue(rvalue);\n             }\n \n-            Terminator::Call { ref func, ref args, ref kind } => {\n-                if let Some(ref destination) = kind.destination() {\n-                    self.visit_lvalue(destination, LvalueContext::Store);\n-                }\n-                self.visit_operand(func);\n-                for arg in args {\n-                    self.visit_operand(arg);\n-                }\n-                for &target in kind.successors() {\n-                    self.visit_branch(block, target);\n-                }\n+            fn visit_operand(&mut self,\n+                             operand: & $($mutability)* Operand<'tcx>) {\n+                self.super_operand(operand);\n             }\n-        }\n-    }\n \n-    fn super_rvalue(&mut self, rvalue: &Rvalue<'tcx>) {\n-        match *rvalue {\n-            Rvalue::Use(ref operand) => {\n-                self.visit_operand(operand);\n+            fn visit_lvalue(&mut self,\n+                            lvalue: & $($mutability)* Lvalue<'tcx>,\n+                            context: LvalueContext) {\n+                self.super_lvalue(lvalue, context);\n             }\n \n-            Rvalue::Repeat(ref value, ref len) => {\n-                self.visit_operand(value);\n-                self.visit_constant(len);\n+            fn visit_branch(&mut self,\n+                            source: BasicBlock,\n+                            target: BasicBlock) {\n+                self.super_branch(source, target);\n             }\n \n-            Rvalue::Ref(r, bk, ref path) => {\n-                self.visit_lvalue(path, LvalueContext::Borrow {\n-                    region: r,\n-                    kind: bk\n-                });\n+            fn visit_constant(&mut self,\n+                              constant: & $($mutability)* Constant<'tcx>) {\n+                self.super_constant(constant);\n             }\n \n-            Rvalue::Len(ref path) => {\n-                self.visit_lvalue(path, LvalueContext::Inspect);\n+            fn visit_literal(&mut self,\n+                             literal: & $($mutability)* Literal<'tcx>) {\n+                self.super_literal(literal);\n             }\n \n-            Rvalue::Cast(_, ref operand, _) => {\n-                self.visit_operand(operand);\n+            fn visit_def_id(&mut self,\n+                            def_id: & $($mutability)* DefId) {\n+                self.super_def_id(def_id);\n             }\n \n-            Rvalue::BinaryOp(_, ref lhs, ref rhs) => {\n-                self.visit_operand(lhs);\n-                self.visit_operand(rhs);\n+            fn visit_span(&mut self,\n+                          span: & $($mutability)* Span) {\n+                self.super_span(span);\n             }\n \n-            Rvalue::UnaryOp(_, ref op) => {\n-                self.visit_operand(op);\n-            }\n+            // The `super_xxx` methods comprise the default behavior and are\n+            // not meant to be overidden.\n \n-            Rvalue::Box(_) => {\n+            fn super_mir(&mut self,\n+                         mir: & $($mutability)* Mir<'tcx>) {\n+                for block in mir.all_basic_blocks() {\n+                    let data = & $($mutability)* mir[block];\n+                    self.visit_basic_block_data(block, data);\n+                }\n             }\n \n-            Rvalue::Aggregate(_, ref operands) => {\n-                for operand in operands {\n-                    self.visit_operand(operand);\n+            fn super_basic_block_data(&mut self,\n+                                      block: BasicBlock,\n+                                      data: & $($mutability)* BasicBlockData<'tcx>) {\n+                for statement in & $($mutability)* data.statements {\n+                    self.visit_statement(block, statement);\n                 }\n-            }\n \n-            Rvalue::Slice { ref input, from_start, from_end } => {\n-                self.visit_lvalue(input, LvalueContext::Slice {\n-                    from_start: from_start,\n-                    from_end: from_end,\n-                });\n+                if let Some(ref $($mutability)* terminator) = data.terminator {\n+                    self.visit_terminator(block, terminator);\n+                }\n             }\n \n-            Rvalue::InlineAsm(_) => {\n-            }\n-        }\n-    }\n+            fn super_statement(&mut self,\n+                               block: BasicBlock,\n+                               statement: & $($mutability)* Statement<'tcx>) {\n+                self.visit_span(& $($mutability)* statement.span);\n \n-    fn super_operand(&mut self, operand: &Operand<'tcx>) {\n-        match *operand {\n-            Operand::Consume(ref lvalue) => {\n-                self.visit_lvalue(lvalue, LvalueContext::Consume);\n-            }\n-            Operand::Constant(ref constant) => {\n-                self.visit_constant(constant);\n-            }\n-        }\n-    }\n-\n-    fn super_lvalue(&mut self, lvalue: &Lvalue<'tcx>, _context: LvalueContext) {\n-        match *lvalue {\n-            Lvalue::Var(_) |\n-            Lvalue::Temp(_) |\n-            Lvalue::Arg(_) |\n-            Lvalue::Static(_) |\n-            Lvalue::ReturnPointer => {\n-            }\n-            Lvalue::Projection(ref proj) => {\n-                self.visit_lvalue(&proj.base, LvalueContext::Projection);\n+                match statement.kind {\n+                    StatementKind::Assign(ref $($mutability)* lvalue,\n+                                          ref $($mutability)* rvalue) => {\n+                        self.visit_assign(block, lvalue, rvalue);\n+                    }\n+                    StatementKind::Drop(_, ref $($mutability)* lvalue) => {\n+                        self.visit_lvalue(lvalue, LvalueContext::Drop);\n+                    }\n+                }\n             }\n-        }\n-    }\n-\n-    fn super_branch(&mut self, _source: BasicBlock, _target: BasicBlock) {\n-    }\n-\n-    fn super_constant(&mut self, constant: &Constant<'tcx>) {\n-        self.visit_span(constant.span);\n-        self.visit_literal(&constant.literal);\n-    }\n \n-    fn super_literal(&mut self, literal: &Literal<'tcx>) {\n-        match *literal {\n-            Literal::Item { def_id, .. } => {\n-                self.visit_def_id(def_id);\n-            },\n-            Literal::Value { .. } => {\n-                // Nothing to do\n+            fn super_assign(&mut self,\n+                            _block: BasicBlock,\n+                            lvalue: &$($mutability)* Lvalue<'tcx>,\n+                            rvalue: &$($mutability)* Rvalue<'tcx>) {\n+                self.visit_lvalue(lvalue, LvalueContext::Store);\n+                self.visit_rvalue(rvalue);\n             }\n-        }\n-    }\n-\n-    fn super_def_id(&mut self, _def_id: DefId) {\n-    }\n-\n-    fn super_span(&mut self, _span: Span) {\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum LvalueContext {\n-    // Appears as LHS of an assignment or as dest of a call\n-    Store,\n-\n-    // Being dropped\n-    Drop,\n-\n-    // Being inspected in some way, like loading a len\n-    Inspect,\n-\n-    // Being borrowed\n-    Borrow { region: Region, kind: BorrowKind },\n-\n-    // Being sliced -- this should be same as being borrowed, probably\n-    Slice { from_start: usize, from_end: usize },\n-\n-    // Used as base for another lvalue, e.g. `x` in `x.y`\n-    Projection,\n-\n-    // Consumed as part of an operand\n-    Consume,\n-}\n-\n-pub trait MutVisitor<'tcx> {\n-    // Override these, and call `self.super_xxx` to revert back to the\n-    // default behavior.\n-\n-    fn visit_mir(&mut self, mir: &mut Mir<'tcx>) {\n-        self.super_mir(mir);\n-    }\n-\n-    fn visit_basic_block_data(&mut self,\n-                              block: BasicBlock,\n-                              data: &mut BasicBlockData<'tcx>) {\n-        self.super_basic_block_data(block, data);\n-    }\n \n-    fn visit_statement(&mut self,\n-                       block: BasicBlock,\n-                       statement: &mut Statement<'tcx>) {\n-        self.super_statement(block, statement);\n-    }\n-\n-    fn visit_assign(&mut self,\n-                    block: BasicBlock,\n-                    lvalue: &mut Lvalue<'tcx>,\n-                    rvalue: &mut Rvalue<'tcx>) {\n-        self.super_assign(block, lvalue, rvalue);\n-    }\n-\n-    fn visit_terminator(&mut self,\n-                        block: BasicBlock,\n-                        terminator: &mut Terminator<'tcx>) {\n-        self.super_terminator(block, terminator);\n-    }\n-\n-    fn visit_rvalue(&mut self, rvalue: &mut Rvalue<'tcx>) {\n-        self.super_rvalue(rvalue);\n-    }\n+            fn super_terminator(&mut self,\n+                                block: BasicBlock,\n+                                terminator: &$($mutability)* Terminator<'tcx>) {\n+                match *terminator {\n+                    Terminator::Goto { target } => {\n+                        self.visit_branch(block, target);\n+                    }\n \n-    fn visit_operand(&mut self, operand: &mut Operand<'tcx>) {\n-        self.super_operand(operand);\n-    }\n+                    Terminator::If { ref $($mutability)* cond,\n+                                     ref $($mutability)* targets } => {\n+                        self.visit_operand(cond);\n+                        for &target in targets.as_slice() {\n+                            self.visit_branch(block, target);\n+                        }\n+                    }\n \n-    fn visit_lvalue(&mut self,\n-                    lvalue: &mut Lvalue<'tcx>,\n-                    context: LvalueContext) {\n-        self.super_lvalue(lvalue, context);\n-    }\n+                    Terminator::Switch { ref $($mutability)* discr,\n+                                         adt_def: _,\n+                                         ref targets } => {\n+                        self.visit_lvalue(discr, LvalueContext::Inspect);\n+                        for &target in targets {\n+                            self.visit_branch(block, target);\n+                        }\n+                    }\n \n-    fn visit_branch(&mut self, source: BasicBlock, target: BasicBlock) {\n-        self.super_branch(source, target);\n-    }\n+                    Terminator::SwitchInt { ref $($mutability)* discr,\n+                                            switch_ty: _,\n+                                            values: _,\n+                                            ref targets } => {\n+                        self.visit_lvalue(discr, LvalueContext::Inspect);\n+                        for &target in targets {\n+                            self.visit_branch(block, target);\n+                        }\n+                    }\n \n-    fn visit_constant(&mut self, constant: &mut Constant<'tcx>) {\n-        self.super_constant(constant);\n-    }\n+                    Terminator::Resume |\n+                    Terminator::Return => {\n+                    }\n \n-    fn visit_literal(&mut self, literal: &mut Literal<'tcx>) {\n-        self.super_literal(literal);\n-    }\n+                    Terminator::Call { ref $($mutability)* func,\n+                                       ref $($mutability)* args,\n+                                       ref $($mutability)* kind } => {\n+                        self.visit_operand(func);\n+                        for arg in args {\n+                            self.visit_operand(arg);\n+                        }\n+                        match *kind {\n+                            CallKind::Converging {\n+                                ref $($mutability)* destination,\n+                                ..\n+                            }        |\n+                            CallKind::ConvergingCleanup {\n+                                ref $($mutability)* destination,\n+                                ..\n+                            } => {\n+                                self.visit_lvalue(destination, LvalueContext::Store);\n+                            }\n+                            CallKind::Diverging           |\n+                            CallKind::DivergingCleanup(_) => {}\n+                        }\n+                        for &target in kind.successors() {\n+                            self.visit_branch(block, target);\n+                        }\n+                    }\n+                }\n+            }\n \n-    fn visit_def_id(&mut self, def_id: &mut DefId) {\n-        self.super_def_id(def_id);\n-    }\n+            fn super_rvalue(&mut self,\n+                            rvalue: & $($mutability)* Rvalue<'tcx>) {\n+                match *rvalue {\n+                    Rvalue::Use(ref $($mutability)* operand) => {\n+                        self.visit_operand(operand);\n+                    }\n \n-    fn visit_span(&mut self, span: &mut Span) {\n-        self.super_span(span);\n-    }\n+                    Rvalue::Repeat(ref $($mutability)* value,\n+                                   ref $($mutability)* len) => {\n+                        self.visit_operand(value);\n+                        self.visit_constant(len);\n+                    }\n \n-    // The `super_xxx` methods comprise the default behavior and are\n-    // not meant to be overidden.\n+                    Rvalue::Ref(r, bk, ref $($mutability)* path) => {\n+                        self.visit_lvalue(path, LvalueContext::Borrow {\n+                            region: r,\n+                            kind: bk\n+                        });\n+                    }\n \n-    fn super_mir(&mut self, mir: &mut Mir<'tcx>) {\n-        for block in mir.all_basic_blocks() {\n-            let data = mir.basic_block_data_mut(block);\n-            self.visit_basic_block_data(block, data);\n-        }\n-    }\n+                    Rvalue::Len(ref $($mutability)* path) => {\n+                        self.visit_lvalue(path, LvalueContext::Inspect);\n+                    }\n \n-    fn super_basic_block_data(&mut self,\n-                              block: BasicBlock,\n-                              data: &mut BasicBlockData<'tcx>) {\n-        for statement in &mut data.statements {\n-            self.visit_statement(block, statement);\n-        }\n-        data.terminator.as_mut().map(|r| self.visit_terminator(block, r));\n-    }\n+                    Rvalue::Cast(_, ref $($mutability)* operand, _) => {\n+                        self.visit_operand(operand);\n+                    }\n \n-    fn super_statement(&mut self,\n-                       block: BasicBlock,\n-                       statement: &mut Statement<'tcx>) {\n-        self.visit_span(&mut statement.span);\n+                    Rvalue::BinaryOp(_,\n+                                     ref $($mutability)* lhs,\n+                                     ref $($mutability)* rhs) => {\n+                        self.visit_operand(lhs);\n+                        self.visit_operand(rhs);\n+                    }\n \n-        match statement.kind {\n-            StatementKind::Assign(ref mut lvalue, ref mut rvalue) => {\n-                self.visit_assign(block, lvalue, rvalue);\n-            }\n-            StatementKind::Drop(_, ref mut lvalue) => {\n-                self.visit_lvalue(lvalue, LvalueContext::Drop);\n-            }\n-        }\n-    }\n+                    Rvalue::UnaryOp(_, ref $($mutability)* op) => {\n+                        self.visit_operand(op);\n+                    }\n \n-    fn super_assign(&mut self,\n-                    _block: BasicBlock,\n-                    lvalue: &mut Lvalue<'tcx>,\n-                    rvalue: &mut Rvalue<'tcx>) {\n-        self.visit_lvalue(lvalue, LvalueContext::Store);\n-        self.visit_rvalue(rvalue);\n-    }\n+                    Rvalue::Box(_) => {\n+                    }\n \n-    fn super_terminator(&mut self,\n-                        block: BasicBlock,\n-                        terminator: &mut Terminator<'tcx>) {\n-        match *terminator {\n-            Terminator::Goto { target } => {\n-                self.visit_branch(block, target);\n-            }\n+                    Rvalue::Aggregate(ref $($mutability)* kind,\n+                                      ref $($mutability)* operands) => {\n+                        match *kind {\n+                            AggregateKind::Closure(ref $($mutability)* def_id, _) => {\n+                                self.visit_def_id(def_id);\n+                            }\n+                            _ => { /* nothing to do */ }\n+                        }\n+\n+                        for operand in & $($mutability)* operands[..] {\n+                            self.visit_operand(operand);\n+                        }\n+                    }\n \n-            Terminator::If { ref mut cond, ref mut targets } => {\n-                self.visit_operand(cond);\n-                for &target in targets.as_slice() {\n-                    self.visit_branch(block, target);\n-                }\n-            }\n+                    Rvalue::Slice { ref $($mutability)* input,\n+                                    from_start,\n+                                    from_end } => {\n+                        self.visit_lvalue(input, LvalueContext::Slice {\n+                            from_start: from_start,\n+                            from_end: from_end,\n+                        });\n+                    }\n \n-            Terminator::Switch { ref mut discr, adt_def: _, ref targets } => {\n-                self.visit_lvalue(discr, LvalueContext::Inspect);\n-                for &target in targets {\n-                    self.visit_branch(block, target);\n+                    Rvalue::InlineAsm(_) => {\n+                    }\n                 }\n             }\n \n-            Terminator::SwitchInt { ref mut discr, switch_ty: _, values: _, ref targets } => {\n-                self.visit_lvalue(discr, LvalueContext::Inspect);\n-                for &target in targets {\n-                    self.visit_branch(block, target);\n+            fn super_operand(&mut self,\n+                             operand: & $($mutability)* Operand<'tcx>) {\n+                match *operand {\n+                    Operand::Consume(ref $($mutability)* lvalue) => {\n+                        self.visit_lvalue(lvalue, LvalueContext::Consume);\n+                    }\n+                    Operand::Constant(ref $($mutability)* constant) => {\n+                        self.visit_constant(constant);\n+                    }\n                 }\n             }\n \n-            Terminator::Resume |\n-            Terminator::Return => {\n-            }\n-\n-            Terminator::Call { ref mut func, ref mut args, ref mut kind } => {\n-                if let Some(ref mut destination) = kind.destination() {\n-                    self.visit_lvalue(destination, LvalueContext::Store);\n-                }\n-                self.visit_operand(func);\n-                for arg in args {\n-                    self.visit_operand(arg);\n-                }\n-                for &target in kind.successors() {\n-                    self.visit_branch(block, target);\n+            fn super_lvalue(&mut self,\n+                            lvalue: & $($mutability)* Lvalue<'tcx>,\n+                            _context: LvalueContext) {\n+                match *lvalue {\n+                    Lvalue::Var(_) |\n+                    Lvalue::Temp(_) |\n+                    Lvalue::Arg(_) |\n+                    Lvalue::ReturnPointer => {\n+                    }\n+                    Lvalue::Static(ref $($mutability)* def_id) => {\n+                        self.visit_def_id(def_id);\n+                    }\n+                    Lvalue::Projection(ref $($mutability)* proj) => {\n+                        self.visit_lvalue(& $($mutability)* proj.base,\n+                                          LvalueContext::Projection);\n+                    }\n                 }\n             }\n-        }\n-    }\n-\n-    fn super_rvalue(&mut self, rvalue: &mut Rvalue<'tcx>) {\n-        match *rvalue {\n-            Rvalue::Use(ref mut operand) => {\n-                self.visit_operand(operand);\n-            }\n-\n-            Rvalue::Repeat(ref mut value, ref mut len) => {\n-                self.visit_operand(value);\n-                self.visit_constant(len);\n-            }\n-\n-            Rvalue::Ref(r, bk, ref mut path) => {\n-                self.visit_lvalue(path, LvalueContext::Borrow {\n-                    region: r,\n-                    kind: bk\n-                });\n-            }\n-\n-            Rvalue::Len(ref mut path) => {\n-                self.visit_lvalue(path, LvalueContext::Inspect);\n-            }\n-\n-            Rvalue::Cast(_, ref mut operand, _) => {\n-                self.visit_operand(operand);\n-            }\n-\n-            Rvalue::BinaryOp(_, ref mut lhs, ref mut rhs) => {\n-                self.visit_operand(lhs);\n-                self.visit_operand(rhs);\n-            }\n \n-            Rvalue::UnaryOp(_, ref mut op) => {\n-                self.visit_operand(op);\n+            fn super_branch(&mut self,\n+                            _source: BasicBlock,\n+                            _target: BasicBlock) {\n             }\n \n-            Rvalue::Box(_) => {\n+            fn super_constant(&mut self,\n+                              constant: & $($mutability)* Constant<'tcx>) {\n+                self.visit_span(& $($mutability)* constant.span);\n+                self.visit_literal(& $($mutability)* constant.literal);\n             }\n \n-            Rvalue::Aggregate(ref mut kind, ref mut operands) => {\n-                match *kind {\n-                    AggregateKind::Closure(ref mut def_id, _) => {\n+            fn super_literal(&mut self,\n+                             literal: & $($mutability)* Literal<'tcx>) {\n+                match *literal {\n+                    Literal::Item { ref $($mutability)* def_id, .. } => {\n                         self.visit_def_id(def_id);\n+                    },\n+                    Literal::Value { .. } => {\n+                        // Nothing to do\n                     }\n-                    _ => { /* nothing to do */ }\n-                }\n-\n-                for operand in &mut operands[..] {\n-                    self.visit_operand(operand);\n                 }\n             }\n \n-            Rvalue::Slice { ref mut input, from_start, from_end } => {\n-                self.visit_lvalue(input, LvalueContext::Slice {\n-                    from_start: from_start,\n-                    from_end: from_end,\n-                });\n+            fn super_def_id(&mut self, _def_id: & $($mutability)* DefId) {\n             }\n \n-            Rvalue::InlineAsm(_) => {\n+            fn super_span(&mut self, _span: & $($mutability)* Span) {\n             }\n         }\n     }\n+}\n \n-    fn super_operand(&mut self, operand: &mut Operand<'tcx>) {\n-        match *operand {\n-            Operand::Consume(ref mut lvalue) => {\n-                self.visit_lvalue(lvalue, LvalueContext::Consume);\n-            }\n-            Operand::Constant(ref mut constant) => {\n-                self.visit_constant(constant);\n-            }\n-        }\n-    }\n+make_mir_visitor!(Visitor,);\n+make_mir_visitor!(MutVisitor,mut);\n \n-    fn super_lvalue(&mut self,\n-                    lvalue: &mut Lvalue<'tcx>,\n-                    _context: LvalueContext) {\n-        match *lvalue {\n-            Lvalue::Var(_) |\n-            Lvalue::Temp(_) |\n-            Lvalue::Arg(_) |\n-            Lvalue::ReturnPointer => {\n-            }\n-            Lvalue::Static(ref mut def_id) => {\n-                self.visit_def_id(def_id);\n-            }\n-            Lvalue::Projection(ref mut proj) => {\n-                self.visit_lvalue(&mut proj.base, LvalueContext::Projection);\n-            }\n-        }\n-    }\n+#[derive(Copy, Clone, Debug)]\n+pub enum LvalueContext {\n+    // Appears as LHS of an assignment or as dest of a call\n+    Store,\n \n-    fn super_branch(&mut self, _source: BasicBlock, _target: BasicBlock) {\n-    }\n+    // Being dropped\n+    Drop,\n \n-    fn super_constant(&mut self, constant: &mut Constant<'tcx>) {\n-        self.visit_span(&mut constant.span);\n-        self.visit_literal(&mut constant.literal);\n-    }\n+    // Being inspected in some way, like loading a len\n+    Inspect,\n \n-    fn super_literal(&mut self, literal: &mut Literal<'tcx>) {\n-        match *literal {\n-            Literal::Item { ref mut def_id, .. } => {\n-                self.visit_def_id(def_id);\n-            },\n-            Literal::Value { .. } => {\n-                // Nothing to do\n-            }\n-        }\n-    }\n+    // Being borrowed\n+    Borrow { region: Region, kind: BorrowKind },\n \n-    fn super_def_id(&mut self, _def_id: &mut DefId) {\n-    }\n+    // Being sliced -- this should be same as being borrowed, probably\n+    Slice { from_start: usize, from_end: usize },\n \n-    fn super_span(&mut self, _span: &mut Span) {\n-    }\n+    // Used as base for another lvalue, e.g. `x` in `x.y`\n+    Projection,\n+\n+    // Consumed as part of an operand\n+    Consume,\n }"}]}