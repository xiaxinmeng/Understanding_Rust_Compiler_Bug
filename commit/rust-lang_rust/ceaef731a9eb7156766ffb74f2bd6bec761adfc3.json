{"sha": "ceaef731a9eb7156766ffb74f2bd6bec761adfc3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlYWVmNzMxYTllYjcxNTY3NjZmZmI3NGYyYmQ2YmVjNzYxYWRmYzM=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-24T17:01:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-24T17:01:36Z"}, "message": "Rollup merge of #74661 - SNCPlay42:lifetime-names-refactor, r=estebank\n\nRefactor `region_name`: add `RegionNameHighlight`\n\nThis PR does not change any diagnostics itself, rather it enables further code changes, but I would like to get approval for the refactoring first before making use of it.\n\nIn `rustc_mir::borrow_check::diagnostics::region_name`, there is code that allows for, when giving a synthesized name like `'1` to an anonymous lifetime, pointing at e.g. the exact '`&`' that introduces the lifetime.\n\nThis PR decouples that code from the specific case of arguments, adding a new enum `RegionNameHighlight`, enabling future changes to use it in other places.\n\nThis allows:\n\n* We could change the other `AnonRegionFrom*` variants to use `RegionNameHighlight` to precisely point at where lifetimes are introduced in other locations when they have type annotations, e.g. a closure return `|...| -> &i32`.\n  * Because of how async functions are lowered this affects async functions as well, see #74072\n* for #74597, we could add a second, optional `RegionNameHighlight` to the `AnonRegionFromArgument` variant that highlights a lifetime in the return type of a function when, due to elision, this is the same as the argument lifetime.\n* in https://github.com/rust-lang/rust/issues/74497#issuecomment-6606229707 I noticed that a diagnostic was trying to introduce a lifetime `'2` in the opaque type `impl std::future::Future`. The code for the case of arguments has [code to handle cases like this](https://github.com/rust-lang/rust/blob/bbebe7351fcd29af1eb9a35e315369b15887ea09/src/librustc_mir/borrow_check/diagnostics/region_name.rs#L365) but not the others. This refactoring would allow the same code path to handle this.\n  * It might be appropriate to add another variant of `RegionNameHighlight` to say something like `lifetime '1 appears in the opaque type impl std::future::Future`.\n\nThese are quite a few changes so I thought I would make sure the refactoring is OK before I start making changes that rely on it. :)", "tree": {"sha": "c3b835475d3b28c8e4e938e4dbb999508f32a130", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3b835475d3b28c8e4e938e4dbb999508f32a130"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ceaef731a9eb7156766ffb74f2bd6bec761adfc3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfGxPwCRBK7hj4Ov3rIwAAdHIIAGSAO/gLjVLY1pW11ItKu6KO\nEG6jKfz1ruWZQNLcQyYpNQptSdLtzAm3GhLpYTcx3D1+NiEiDTBNrWzdeoC1Q8Qh\nKImu1AWAmLnJiWTfLpkv2kZ0KiYEiqMZUdjimYwKQDTxcSbvjxOteZmtFYJdA5he\nykmSj8iH3G03Kv8qo1ExsoaHFOsbrgmATE5TNdUAFZljfZh0s4QL8GCnb2NSsov7\nZ8fcUPucxeWBidwPQxQ+NOShkEVgMW+ZpHLcm3dmIiW3f/JgCFARAvBz4r8Obuc4\nOLC+km6v2ZaN5MVNb9T9uAvm6zlnBtOi/Bct3X8EgbRMSnbUabM3HiyJmu59uUw=\n=af9Q\n-----END PGP SIGNATURE-----\n", "payload": "tree c3b835475d3b28c8e4e938e4dbb999508f32a130\nparent a4024ba4eb7c064c8cb9510da7f1e9b24109d6d1\nparent 8a776ee2390cb99f915cda22393ce4e297208396\nauthor Manish Goregaokar <manishsmail@gmail.com> 1595610096 -0700\ncommitter GitHub <noreply@github.com> 1595610096 -0700\n\nRollup merge of #74661 - SNCPlay42:lifetime-names-refactor, r=estebank\n\nRefactor `region_name`: add `RegionNameHighlight`\n\nThis PR does not change any diagnostics itself, rather it enables further code changes, but I would like to get approval for the refactoring first before making use of it.\n\nIn `rustc_mir::borrow_check::diagnostics::region_name`, there is code that allows for, when giving a synthesized name like `'1` to an anonymous lifetime, pointing at e.g. the exact '`&`' that introduces the lifetime.\n\nThis PR decouples that code from the specific case of arguments, adding a new enum `RegionNameHighlight`, enabling future changes to use it in other places.\n\nThis allows:\n\n* We could change the other `AnonRegionFrom*` variants to use `RegionNameHighlight` to precisely point at where lifetimes are introduced in other locations when they have type annotations, e.g. a closure return `|...| -> &i32`.\n  * Because of how async functions are lowered this affects async functions as well, see #74072\n* for #74597, we could add a second, optional `RegionNameHighlight` to the `AnonRegionFromArgument` variant that highlights a lifetime in the return type of a function when, due to elision, this is the same as the argument lifetime.\n* in https://github.com/rust-lang/rust/issues/74497#issuecomment-6606229707 I noticed that a diagnostic was trying to introduce a lifetime `'2` in the opaque type `impl std::future::Future`. The code for the case of arguments has [code to handle cases like this](https://github.com/rust-lang/rust/blob/bbebe7351fcd29af1eb9a35e315369b15887ea09/src/librustc_mir/borrow_check/diagnostics/region_name.rs#L365) but not the others. This refactoring would allow the same code path to handle this.\n  * It might be appropriate to add another variant of `RegionNameHighlight` to say something like `lifetime '1 appears in the opaque type impl std::future::Future`.\n\nThese are quite a few changes so I thought I would make sure the refactoring is OK before I start making changes that rely on it. :)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ceaef731a9eb7156766ffb74f2bd6bec761adfc3", "html_url": "https://github.com/rust-lang/rust/commit/ceaef731a9eb7156766ffb74f2bd6bec761adfc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ceaef731a9eb7156766ffb74f2bd6bec761adfc3/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4024ba4eb7c064c8cb9510da7f1e9b24109d6d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4024ba4eb7c064c8cb9510da7f1e9b24109d6d1", "html_url": "https://github.com/rust-lang/rust/commit/a4024ba4eb7c064c8cb9510da7f1e9b24109d6d1"}, {"sha": "8a776ee2390cb99f915cda22393ce4e297208396", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a776ee2390cb99f915cda22393ce4e297208396", "html_url": "https://github.com/rust-lang/rust/commit/8a776ee2390cb99f915cda22393ce4e297208396"}], "stats": {"total": 181, "additions": 92, "deletions": 89}, "files": [{"sha": "8521f900988e49a212043b3119e46928b45ad068", "filename": "src/librustc_mir/borrow_check/diagnostics/outlives_suggestion.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ceaef731a9eb7156766ffb74f2bd6bec761adfc3/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Foutlives_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaef731a9eb7156766ffb74f2bd6bec761adfc3/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Foutlives_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Foutlives_suggestion.rs?ref=ceaef731a9eb7156766ffb74f2bd6bec761adfc3", "patch": "@@ -60,9 +60,7 @@ impl OutlivesSuggestionBuilder {\n             // Don't give suggestions for upvars, closure return types, or other unnamable\n             // regions.\n             RegionNameSource::SynthesizedFreeEnvRegion(..)\n-            | RegionNameSource::CannotMatchHirTy(..)\n-            | RegionNameSource::MatchedHirTy(..)\n-            | RegionNameSource::MatchedAdtAndSegment(..)\n+            | RegionNameSource::AnonRegionFromArgument(..)\n             | RegionNameSource::AnonRegionFromUpvar(..)\n             | RegionNameSource::AnonRegionFromOutput(..)\n             | RegionNameSource::AnonRegionFromYieldTy(..)"}, {"sha": "cc8a5e0768cba3ab721919ff033bb08b579fc153", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ceaef731a9eb7156766ffb74f2bd6bec761adfc3/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaef731a9eb7156766ffb74f2bd6bec761adfc3/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=ceaef731a9eb7156766ffb74f2bd6bec761adfc3", "patch": "@@ -19,7 +19,7 @@ use crate::borrow_check::{\n     MirBorrowckCtxt,\n };\n \n-use super::{OutlivesSuggestionBuilder, RegionName, RegionNameSource};\n+use super::{OutlivesSuggestionBuilder, RegionName};\n \n impl ConstraintDescription for ConstraintCategory {\n     fn description(&self) -> &'static str {\n@@ -396,18 +396,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             diag.span_label(upvar_span, \"variable captured here\");\n         }\n \n-        match self.give_region_a_name(*outlived_fr).unwrap().source {\n-            RegionNameSource::NamedEarlyBoundRegion(fr_span)\n-            | RegionNameSource::NamedFreeRegion(fr_span)\n-            | RegionNameSource::SynthesizedFreeEnvRegion(fr_span, _)\n-            | RegionNameSource::CannotMatchHirTy(fr_span, _)\n-            | RegionNameSource::MatchedHirTy(fr_span)\n-            | RegionNameSource::MatchedAdtAndSegment(fr_span)\n-            | RegionNameSource::AnonRegionFromUpvar(fr_span, _)\n-            | RegionNameSource::AnonRegionFromOutput(fr_span, _, _) => {\n-                diag.span_label(fr_span, \"inferred to be a `FnMut` closure\");\n-            }\n-            _ => {}\n+        if let Some(fr_span) = self.give_region_a_name(*outlived_fr).unwrap().span() {\n+            diag.span_label(fr_span, \"inferred to be a `FnMut` closure\");\n         }\n \n         diag.note("}, {"sha": "32195adc60ef87980442f3a9054d650604be7da6", "filename": "src/librustc_mir/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 88, "deletions": 73, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/ceaef731a9eb7156766ffb74f2bd6bec761adfc3/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaef731a9eb7156766ffb74f2bd6bec761adfc3/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=ceaef731a9eb7156766ffb74f2bd6bec761adfc3", "patch": "@@ -34,13 +34,8 @@ crate enum RegionNameSource {\n     Static,\n     /// The free region corresponding to the environment of a closure.\n     SynthesizedFreeEnvRegion(Span, String),\n-    /// The region name corresponds to a region where the type annotation is completely missing\n-    /// from the code, e.g. in a closure arguments `|x| { ... }`, where `x` is a reference.\n-    CannotMatchHirTy(Span, String),\n-    /// The region name corresponds a reference that was found by traversing the type in the HIR.\n-    MatchedHirTy(Span),\n-    /// A region name from the generics list of a struct/enum/union.\n-    MatchedAdtAndSegment(Span),\n+    /// The region corresponding to an argument.\n+    AnonRegionFromArgument(RegionNameHighlight),\n     /// The region corresponding to a closure upvar.\n     AnonRegionFromUpvar(Span, String),\n     /// The region corresponding to the return type of a closure.\n@@ -51,23 +46,52 @@ crate enum RegionNameSource {\n     AnonRegionFromAsyncFn(Span),\n }\n \n+/// Describes what to highlight to explain to the user that we're giving an anonymous region a\n+/// synthesized name, and how to highlight it.\n+#[derive(Debug, Clone)]\n+crate enum RegionNameHighlight {\n+    /// The anonymous region corresponds to a reference that was found by traversing the type in the HIR.\n+    MatchedHirTy(Span),\n+    /// The anonymous region corresponds to a `'_` in the generics list of a struct/enum/union.\n+    MatchedAdtAndSegment(Span),\n+    /// The anonymous region corresponds to a region where the type annotation is completely missing\n+    /// from the code, e.g. in a closure arguments `|x| { ... }`, where `x` is a reference.\n+    CannotMatchHirTy(Span, String),\n+}\n+\n impl RegionName {\n     crate fn was_named(&self) -> bool {\n         match self.source {\n             RegionNameSource::NamedEarlyBoundRegion(..)\n             | RegionNameSource::NamedFreeRegion(..)\n             | RegionNameSource::Static => true,\n             RegionNameSource::SynthesizedFreeEnvRegion(..)\n-            | RegionNameSource::CannotMatchHirTy(..)\n-            | RegionNameSource::MatchedHirTy(..)\n-            | RegionNameSource::MatchedAdtAndSegment(..)\n+            | RegionNameSource::AnonRegionFromArgument(..)\n             | RegionNameSource::AnonRegionFromUpvar(..)\n             | RegionNameSource::AnonRegionFromOutput(..)\n             | RegionNameSource::AnonRegionFromYieldTy(..)\n             | RegionNameSource::AnonRegionFromAsyncFn(..) => false,\n         }\n     }\n \n+    crate fn span(&self) -> Option<Span> {\n+        match self.source {\n+            RegionNameSource::Static => None,\n+            RegionNameSource::NamedEarlyBoundRegion(span)\n+            | RegionNameSource::NamedFreeRegion(span)\n+            | RegionNameSource::SynthesizedFreeEnvRegion(span, _)\n+            | RegionNameSource::AnonRegionFromUpvar(span, _)\n+            | RegionNameSource::AnonRegionFromOutput(span, _, _)\n+            | RegionNameSource::AnonRegionFromYieldTy(span, _)\n+            | RegionNameSource::AnonRegionFromAsyncFn(span) => Some(span),\n+            RegionNameSource::AnonRegionFromArgument(ref highlight) => match *highlight {\n+                RegionNameHighlight::MatchedHirTy(span)\n+                | RegionNameHighlight::MatchedAdtAndSegment(span)\n+                | RegionNameHighlight::CannotMatchHirTy(span, _) => Some(span),\n+            },\n+        }\n+    }\n+\n     crate fn highlight_region_name(&self, diag: &mut DiagnosticBuilder<'_>) {\n         match &self.source {\n             RegionNameSource::NamedFreeRegion(span)\n@@ -81,17 +105,22 @@ impl RegionName {\n                 );\n                 diag.note(&note);\n             }\n-            RegionNameSource::CannotMatchHirTy(span, type_name) => {\n+            RegionNameSource::AnonRegionFromArgument(RegionNameHighlight::CannotMatchHirTy(\n+                span,\n+                type_name,\n+            )) => {\n                 diag.span_label(*span, format!(\"has type `{}`\", type_name));\n             }\n-            RegionNameSource::MatchedHirTy(span)\n+            RegionNameSource::AnonRegionFromArgument(RegionNameHighlight::MatchedHirTy(span))\n             | RegionNameSource::AnonRegionFromAsyncFn(span) => {\n                 diag.span_label(\n                     *span,\n                     format!(\"let's call the lifetime of this reference `{}`\", self),\n                 );\n             }\n-            RegionNameSource::MatchedAdtAndSegment(span) => {\n+            RegionNameSource::AnonRegionFromArgument(\n+                RegionNameHighlight::MatchedAdtAndSegment(span),\n+            ) => {\n                 diag.span_label(*span, format!(\"let's call this `{}`\", self));\n             }\n             RegionNameSource::AnonRegionFromUpvar(span, upvar_name) => {\n@@ -307,21 +336,31 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n \n         let arg_ty = self.regioncx.universal_regions().unnormalized_input_tys\n             [implicit_inputs + argument_index];\n-        if let Some(region_name) =\n-            self.give_name_if_we_can_match_hir_ty_from_argument(fr, arg_ty, argument_index)\n-        {\n-            return Some(region_name);\n-        }\n+        let (_, span) = self.regioncx.get_argument_name_and_span_for_region(\n+            &self.body,\n+            &self.local_names,\n+            argument_index,\n+        );\n \n-        self.give_name_if_we_cannot_match_hir_ty(fr, arg_ty)\n+        self.get_argument_hir_ty_for_highlighting(argument_index)\n+            .and_then(|arg_hir_ty| self.highlight_if_we_can_match_hir_ty(fr, arg_ty, arg_hir_ty))\n+            .or_else(|| {\n+                // `highlight_if_we_cannot_match_hir_ty` needs to know the number we will give to\n+                // the anonymous region. If it succeeds, the `synthesize_region_name` call below\n+                // will increment the counter, \"reserving\" the number we just used.\n+                let counter = *self.next_region_name.try_borrow().unwrap();\n+                self.highlight_if_we_cannot_match_hir_ty(fr, arg_ty, span, counter)\n+            })\n+            .map(|highlight| RegionName {\n+                name: self.synthesize_region_name(),\n+                source: RegionNameSource::AnonRegionFromArgument(highlight),\n+            })\n     }\n \n-    fn give_name_if_we_can_match_hir_ty_from_argument(\n+    fn get_argument_hir_ty_for_highlighting(\n         &self,\n-        needle_fr: RegionVid,\n-        argument_ty: Ty<'tcx>,\n         argument_index: usize,\n-    ) -> Option<RegionName> {\n+    ) -> Option<&hir::Ty<'tcx>> {\n         let mir_hir_id = self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id);\n         let fn_decl = self.infcx.tcx.hir().fn_decl_by_hir_id(mir_hir_id)?;\n         let argument_hir_ty: &hir::Ty<'_> = fn_decl.inputs.get(argument_index)?;\n@@ -333,7 +372,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             // (`give_name_if_anonymous_region_appears_in_arguments`).\n             hir::TyKind::Infer => None,\n \n-            _ => self.give_name_if_we_can_match_hir_ty(needle_fr, argument_ty, argument_hir_ty),\n+            _ => Some(argument_hir_ty),\n         }\n     }\n \n@@ -348,42 +387,28 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     ///  |          |  has type `&'1 u32`\n     ///  |          has type `&'2 u32`\n     /// ```\n-    fn give_name_if_we_cannot_match_hir_ty(\n+    fn highlight_if_we_cannot_match_hir_ty(\n         &self,\n         needle_fr: RegionVid,\n-        argument_ty: Ty<'tcx>,\n-    ) -> Option<RegionName> {\n-        let counter = *self.next_region_name.try_borrow().unwrap();\n+        ty: Ty<'tcx>,\n+        span: Span,\n+        counter: usize,\n+    ) -> Option<RegionNameHighlight> {\n         let mut highlight = RegionHighlightMode::default();\n         highlight.highlighting_region_vid(needle_fr, counter);\n-        let type_name = self.infcx.extract_type_name(&argument_ty, Some(highlight)).0;\n+        let type_name = self.infcx.extract_type_name(&ty, Some(highlight)).0;\n \n         debug!(\n-            \"give_name_if_we_cannot_match_hir_ty: type_name={:?} needle_fr={:?}\",\n+            \"highlight_if_we_cannot_match_hir_ty: type_name={:?} needle_fr={:?}\",\n             type_name, needle_fr\n         );\n-        let assigned_region_name = if type_name.find(&format!(\"'{}\", counter)).is_some() {\n+        if type_name.find(&format!(\"'{}\", counter)).is_some() {\n             // Only add a label if we can confirm that a region was labelled.\n-            let argument_index =\n-                self.regioncx.get_argument_index_for_region(self.infcx.tcx, needle_fr)?;\n-            let (_, span) = self.regioncx.get_argument_name_and_span_for_region(\n-                &self.body,\n-                &self.local_names,\n-                argument_index,\n-            );\n-\n-            Some(RegionName {\n-                // This counter value will already have been used, so this function will increment\n-                // it so the next value will be used next and return the region name that would\n-                // have been used.\n-                name: self.synthesize_region_name(),\n-                source: RegionNameSource::CannotMatchHirTy(span, type_name),\n-            })\n+\n+            Some(RegionNameHighlight::CannotMatchHirTy(span, type_name))\n         } else {\n             None\n-        };\n-\n-        assigned_region_name\n+        }\n     }\n \n     /// Attempts to highlight the specific part of a type annotation\n@@ -395,9 +420,9 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     ///  |                - let's call the lifetime of this reference `'1`\n     /// ```\n     ///\n-    /// the way this works is that we match up `argument_ty`, which is\n+    /// the way this works is that we match up `ty`, which is\n     /// a `Ty<'tcx>` (the internal form of the type) with\n-    /// `argument_hir_ty`, a `hir::Ty` (the syntax of the type\n+    /// `hir_ty`, a `hir::Ty` (the syntax of the type\n     /// annotation). We are descending through the types stepwise,\n     /// looking in to find the region `needle_fr` in the internal\n     /// type. Once we find that, we can use the span of the `hir::Ty`\n@@ -407,18 +432,17 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     /// keep track of the **closest** type we've found. If we fail to\n     /// find the exact `&` or `'_` to highlight, then we may fall back\n     /// to highlighting that closest type instead.\n-    fn give_name_if_we_can_match_hir_ty(\n+    fn highlight_if_we_can_match_hir_ty(\n         &self,\n         needle_fr: RegionVid,\n-        argument_ty: Ty<'tcx>,\n-        argument_hir_ty: &hir::Ty<'_>,\n-    ) -> Option<RegionName> {\n-        let search_stack: &mut Vec<(Ty<'tcx>, &hir::Ty<'_>)> =\n-            &mut vec![(argument_ty, argument_hir_ty)];\n+        ty: Ty<'tcx>,\n+        hir_ty: &hir::Ty<'_>,\n+    ) -> Option<RegionNameHighlight> {\n+        let search_stack: &mut Vec<(Ty<'tcx>, &hir::Ty<'_>)> = &mut vec![(ty, hir_ty)];\n \n         while let Some((ty, hir_ty)) = search_stack.pop() {\n             match (&ty.kind, &hir_ty.kind) {\n-                // Check if the `argument_ty` is `&'X ..` where `'X`\n+                // Check if the `ty` is `&'X ..` where `'X`\n                 // is the region we are looking for -- if so, and we have a `&T`\n                 // on the RHS, then we want to highlight the `&` like so:\n                 //\n@@ -429,16 +453,11 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                     hir::TyKind::Rptr(_lifetime, referent_hir_ty),\n                 ) => {\n                     if region.to_region_vid() == needle_fr {\n-                        let region_name = self.synthesize_region_name();\n-\n                         // Just grab the first character, the `&`.\n                         let source_map = self.infcx.tcx.sess.source_map();\n                         let ampersand_span = source_map.start_point(hir_ty.span);\n \n-                        return Some(RegionName {\n-                            name: region_name,\n-                            source: RegionNameSource::MatchedHirTy(ampersand_span),\n-                        });\n+                        return Some(RegionNameHighlight::MatchedHirTy(ampersand_span));\n                     }\n \n                     // Otherwise, let's descend into the referent types.\n@@ -458,13 +477,13 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                         Res::Def(DefKind::TyAlias, _) => (),\n                         _ => {\n                             if let Some(last_segment) = path.segments.last() {\n-                                if let Some(name) = self.match_adt_and_segment(\n+                                if let Some(highlight) = self.match_adt_and_segment(\n                                     substs,\n                                     needle_fr,\n                                     last_segment,\n                                     search_stack,\n                                 ) {\n-                                    return Some(name);\n+                                    return Some(highlight);\n                                 }\n                             }\n                         }\n@@ -507,7 +526,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         needle_fr: RegionVid,\n         last_segment: &'hir hir::PathSegment<'hir>,\n         search_stack: &mut Vec<(Ty<'tcx>, &'hir hir::Ty<'hir>)>,\n-    ) -> Option<RegionName> {\n+    ) -> Option<RegionNameHighlight> {\n         // Did the user give explicit arguments? (e.g., `Foo<..>`)\n         let args = last_segment.args.as_ref()?;\n         let lifetime =\n@@ -517,12 +536,8 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             | hir::LifetimeName::Error\n             | hir::LifetimeName::Static\n             | hir::LifetimeName::Underscore => {\n-                let region_name = self.synthesize_region_name();\n-                let ampersand_span = lifetime.span;\n-                Some(RegionName {\n-                    name: region_name,\n-                    source: RegionNameSource::MatchedAdtAndSegment(ampersand_span),\n-                })\n+                let lifetime_span = lifetime.span;\n+                Some(RegionNameHighlight::MatchedAdtAndSegment(lifetime_span))\n             }\n \n             hir::LifetimeName::ImplicitObjectLifetimeDefault | hir::LifetimeName::Implicit => {"}]}