{"sha": "7f3c67d4e0c4d8237899c6aa99a174547ff85b09", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmM2M2N2Q0ZTBjNGQ4MjM3ODk5YzZhYTk5YTE3NDU0N2ZmODViMDk=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-17T01:02:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-17T01:02:54Z"}, "message": "Rollup merge of #63149 - petrochenkov:lazypop2, r=eddyb\n\nresolve: Populate external modules in more automatic and lazy way\n\nSo, resolve had this function `populate_module_if_necessary` for loading module children from other crates from metadata.\nI never really understood when it should've been called and when not.\nThis PR removes the function and loads the module children automatically on the first access instead.\n\nr? @eddyb", "tree": {"sha": "d9297710e675bb496df3b1117c04b1ae1487018c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9297710e675bb496df3b1117c04b1ae1487018c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f3c67d4e0c4d8237899c6aa99a174547ff85b09", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdV1I+CRBK7hj4Ov3rIwAAdHIIAIehDYmQpnhmrqqsLzsHcawO\niEvdhAeKCso8bOjzcx6BCPooHARxAsoPwqXJlmLLoQBt52nyAq5ErS1QTzIbdVgH\ncJoYZVxhoUpijfUtpwHm0XZInI5K2Lo+JLSgKH21ynAwnVm1YECXIaRa5BMxcdI3\ngvlrk9T7k148hQzapx5j6LoDJ5oYNHCYTqBx/SZzqpwsRBXCXEzGaudCkjnoysv5\nP1u8WcMKSeqD5Y/LJPObeNiXj8uiYAKslD06v4uYXJ/Vq/34RLtcsEiNU3OqpUE7\nZCmYYLNCD9kSOT/onISpaOpf1h3n5M7Tgf6UN5QrZZGTyU/s5W4nh3G+Y9+ztnk=\n=WrBA\n-----END PGP SIGNATURE-----\n", "payload": "tree d9297710e675bb496df3b1117c04b1ae1487018c\nparent bdfd698f37184da42254a03ed466ab1f90e6fb6c\nparent 5e47cd4a1784bd9d86a3f5a413d606e938679044\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1566003774 +0200\ncommitter GitHub <noreply@github.com> 1566003774 +0200\n\nRollup merge of #63149 - petrochenkov:lazypop2, r=eddyb\n\nresolve: Populate external modules in more automatic and lazy way\n\nSo, resolve had this function `populate_module_if_necessary` for loading module children from other crates from metadata.\nI never really understood when it should've been called and when not.\nThis PR removes the function and loads the module children automatically on the first access instead.\n\nr? @eddyb\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f3c67d4e0c4d8237899c6aa99a174547ff85b09", "html_url": "https://github.com/rust-lang/rust/commit/7f3c67d4e0c4d8237899c6aa99a174547ff85b09", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f3c67d4e0c4d8237899c6aa99a174547ff85b09/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bdfd698f37184da42254a03ed466ab1f90e6fb6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdfd698f37184da42254a03ed466ab1f90e6fb6c", "html_url": "https://github.com/rust-lang/rust/commit/bdfd698f37184da42254a03ed466ab1f90e6fb6c"}, {"sha": "5e47cd4a1784bd9d86a3f5a413d606e938679044", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e47cd4a1784bd9d86a3f5a413d606e938679044", "html_url": "https://github.com/rust-lang/rust/commit/5e47cd4a1784bd9d86a3f5a413d606e938679044"}], "stats": {"total": 261, "additions": 126, "deletions": 135}, "files": [{"sha": "1510d74babb6d8b17abe6213e2f4eb5a4f2385e1", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 53, "deletions": 66, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/7f3c67d4e0c4d8237899c6aa99a174547ff85b09/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3c67d4e0c4d8237899c6aa99a174547ff85b09/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=7f3c67d4e0c4d8237899c6aa99a174547ff85b09", "patch": "@@ -16,6 +16,7 @@ use crate::{ResolutionError, Determinacy, PathResult, CrateLint};\n use rustc::bug;\n use rustc::hir::def::{self, *};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n+use rustc::hir::map::DefCollector;\n use rustc::ty;\n use rustc::middle::cstore::CrateStore;\n use rustc_metadata::cstore::LoadedMacro;\n@@ -159,33 +160,34 @@ impl<'a> Resolver<'a> {\n         Some(ext)\n     }\n \n-    /// Ensures that the reduced graph rooted at the given external module\n-    /// is built, building it if it is not.\n-    crate fn populate_module_if_necessary(&mut self, module: Module<'a>) {\n-        if module.populated.get() { return }\n-        let def_id = module.def_id().unwrap();\n-        for child in self.cstore.item_children_untracked(def_id, self.session) {\n-            let child = child.map_id(|_| panic!(\"unexpected id\"));\n-            BuildReducedGraphVisitor { parent_scope: ParentScope::module(module), r: self }\n-                .build_reduced_graph_for_external_crate_res(child);\n-        }\n-        module.populated.set(true)\n-    }\n-\n     crate fn build_reduced_graph(\n         &mut self, fragment: &AstFragment, parent_scope: ParentScope<'a>\n     ) -> LegacyScope<'a> {\n+        fragment.visit_with(&mut DefCollector::new(&mut self.definitions, parent_scope.expansion));\n         let mut visitor = BuildReducedGraphVisitor { r: self, parent_scope };\n         fragment.visit_with(&mut visitor);\n         visitor.parent_scope.legacy\n     }\n+\n+    crate fn build_reduced_graph_external(&mut self, module: Module<'a>) {\n+        let def_id = module.def_id().expect(\"unpopulated module without a def-id\");\n+        for child in self.cstore.item_children_untracked(def_id, self.session) {\n+            let child = child.map_id(|_| panic!(\"unexpected id\"));\n+            BuildReducedGraphVisitor { r: self, parent_scope: ParentScope::module(module) }\n+                .build_reduced_graph_for_external_crate_res(child);\n+        }\n+    }\n }\n \n struct BuildReducedGraphVisitor<'a, 'b> {\n     r: &'b mut Resolver<'a>,\n     parent_scope: ParentScope<'a>,\n }\n \n+impl<'a> AsMut<Resolver<'a>> for BuildReducedGraphVisitor<'a, '_> {\n+    fn as_mut(&mut self) -> &mut Resolver<'a> { self.r }\n+}\n+\n impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     fn resolve_visibility(&mut self, vis: &ast::Visibility) -> ty::Visibility {\n         let parent_scope = &self.parent_scope;\n@@ -603,8 +605,6 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     self.r.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX })\n                 };\n \n-                self.r.populate_module_if_necessary(module);\n-\n                 let used = self.process_legacy_macro_imports(item, module);\n                 let binding =\n                     (module, ty::Visibility::Public, sp, expansion).to_name_binding(self.r.arenas);\n@@ -879,80 +879,67 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         // This is only a guess, two equivalent idents may incorrectly get different gensyms here.\n         let ident = ident.gensym_if_underscore();\n         let expansion = ExpnId::root(); // FIXME(jseyfried) intercrate hygiene\n+        // Record primary definitions.\n         match res {\n             Res::Def(kind @ DefKind::Mod, def_id)\n-            | Res::Def(kind @ DefKind::Enum, def_id) => {\n+            | Res::Def(kind @ DefKind::Enum, def_id)\n+            | Res::Def(kind @ DefKind::Trait, def_id) => {\n                 let module = self.r.new_module(parent,\n                                              ModuleKind::Def(kind, def_id, ident.name),\n                                              def_id,\n                                              expansion,\n                                              span);\n                 self.r.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, expansion));\n             }\n-            Res::Def(DefKind::Variant, _)\n+            Res::Def(DefKind::Struct, _)\n+            | Res::Def(DefKind::Union, _)\n+            | Res::Def(DefKind::Variant, _)\n             | Res::Def(DefKind::TyAlias, _)\n             | Res::Def(DefKind::ForeignTy, _)\n             | Res::Def(DefKind::OpaqueTy, _)\n             | Res::Def(DefKind::TraitAlias, _)\n+            | Res::Def(DefKind::AssocTy, _)\n+            | Res::Def(DefKind::AssocOpaqueTy, _)\n             | Res::PrimTy(..)\n-            | Res::ToolMod => {\n-                self.r.define(parent, ident, TypeNS, (res, vis, DUMMY_SP, expansion));\n-            }\n+            | Res::ToolMod =>\n+                self.r.define(parent, ident, TypeNS, (res, vis, DUMMY_SP, expansion)),\n             Res::Def(DefKind::Fn, _)\n+            | Res::Def(DefKind::Method, _)\n             | Res::Def(DefKind::Static, _)\n             | Res::Def(DefKind::Const, _)\n-            | Res::Def(DefKind::Ctor(CtorOf::Variant, ..), _) => {\n-                self.r.define(parent, ident, ValueNS, (res, vis, DUMMY_SP, expansion));\n-            }\n-            Res::Def(DefKind::Ctor(CtorOf::Struct, ..), def_id) => {\n-                self.r.define(parent, ident, ValueNS, (res, vis, DUMMY_SP, expansion));\n-\n-                if let Some(struct_def_id) =\n-                        self.r.cstore.def_key(def_id).parent\n-                            .map(|index| DefId { krate: def_id.krate, index: index }) {\n-                    self.r.struct_constructors.insert(struct_def_id, (res, vis));\n-                }\n-            }\n-            Res::Def(DefKind::Trait, def_id) => {\n-                let module_kind = ModuleKind::Def(DefKind::Trait, def_id, ident.name);\n-                let module = self.r.new_module(parent,\n-                                             module_kind,\n-                                             parent.normal_ancestor_id,\n-                                             expansion,\n-                                             span);\n-                self.r.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, expansion));\n-\n-                for child in self.r.cstore.item_children_untracked(def_id, self.r.session) {\n-                    let res = child.res.map_id(|_| panic!(\"unexpected id\"));\n-                    let ns = if let Res::Def(DefKind::AssocTy, _) = res {\n-                        TypeNS\n-                    } else { ValueNS };\n-                    self.r.define(module, child.ident, ns,\n-                                (res, ty::Visibility::Public, DUMMY_SP, expansion));\n-\n-                    if self.r.cstore.associated_item_cloned_untracked(child.res.def_id())\n-                           .method_has_self_argument {\n-                        self.r.has_self.insert(res.def_id());\n-                    }\n-                }\n-                module.populated.set(true);\n-            }\n+            | Res::Def(DefKind::AssocConst, _)\n+            | Res::Def(DefKind::Ctor(..), _) =>\n+                self.r.define(parent, ident, ValueNS, (res, vis, DUMMY_SP, expansion)),\n+            Res::Def(DefKind::Macro(..), _)\n+            | Res::NonMacroAttr(..) =>\n+                self.r.define(parent, ident, MacroNS, (res, vis, DUMMY_SP, expansion)),\n+            Res::Def(DefKind::TyParam, _) | Res::Def(DefKind::ConstParam, _)\n+            | Res::Local(..) | Res::SelfTy(..) | Res::SelfCtor(..) | Res::Err =>\n+                bug!(\"unexpected resolution: {:?}\", res)\n+        }\n+        // Record some extra data for better diagnostics.\n+        match res {\n             Res::Def(DefKind::Struct, def_id) | Res::Def(DefKind::Union, def_id) => {\n-                self.r.define(parent, ident, TypeNS, (res, vis, DUMMY_SP, expansion));\n-\n-                // Record field names for error reporting.\n                 let field_names = self.r.cstore.struct_field_names_untracked(def_id);\n                 self.insert_field_names(def_id, field_names);\n             }\n-            Res::Def(DefKind::Macro(..), _) | Res::NonMacroAttr(..) => {\n-                self.r.define(parent, ident, MacroNS, (res, vis, DUMMY_SP, expansion));\n+            Res::Def(DefKind::Method, def_id) => {\n+                if self.r.cstore.associated_item_cloned_untracked(def_id).method_has_self_argument {\n+                    self.r.has_self.insert(def_id);\n+                }\n+            }\n+            Res::Def(DefKind::Ctor(CtorOf::Struct, ..), def_id) => {\n+                let parent = self.r.cstore.def_key(def_id).parent;\n+                if let Some(struct_def_id) = parent.map(|index| DefId { index, ..def_id }) {\n+                    self.r.struct_constructors.insert(struct_def_id, (res, vis));\n+                }\n             }\n-            _ => bug!(\"unexpected resolution: {:?}\", res)\n+            _ => {}\n         }\n     }\n \n     fn legacy_import_macro(&mut self,\n-                           name: Name,\n+                           name: ast::Name,\n                            binding: &'a NameBinding<'a>,\n                            span: Span,\n                            allow_shadowing: bool) {\n@@ -1021,9 +1008,9 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         if let Some(span) = import_all {\n             let directive = macro_use_directive(self, span);\n             self.r.potentially_unused_imports.push(directive);\n-            module.for_each_child(|ident, ns, binding| if ns == MacroNS {\n-                let imported_binding = self.r.import(binding, directive);\n-                self.legacy_import_macro(ident.name, imported_binding, span, allow_shadowing);\n+            module.for_each_child(self, |this, ident, ns, binding| if ns == MacroNS {\n+                let imported_binding = this.r.import(binding, directive);\n+                this.legacy_import_macro(ident.name, imported_binding, span, allow_shadowing);\n             });\n         } else {\n             for ident in single_imports.iter().cloned() {"}, {"sha": "afdcec19d8ef6014f8a190bb8a742cf3c9df5ae8", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7f3c67d4e0c4d8237899c6aa99a174547ff85b09/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3c67d4e0c4d8237899c6aa99a174547ff85b09/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=7f3c67d4e0c4d8237899c6aa99a174547ff85b09", "patch": "@@ -73,20 +73,23 @@ crate fn add_typo_suggestion(\n     false\n }\n \n-crate fn add_module_candidates(\n-    module: Module<'_>, names: &mut Vec<TypoSuggestion>, filter_fn: &impl Fn(Res) -> bool\n-) {\n-    for (&(ident, _), resolution) in module.resolutions.borrow().iter() {\n-        if let Some(binding) = resolution.borrow().binding {\n-            let res = binding.res();\n-            if filter_fn(res) {\n-                names.push(TypoSuggestion::from_res(ident.name, res));\n+impl<'a> Resolver<'a> {\n+    crate fn add_module_candidates(\n+        &mut self,\n+        module: Module<'a>,\n+        names: &mut Vec<TypoSuggestion>,\n+        filter_fn: &impl Fn(Res) -> bool,\n+    ) {\n+        for (&(ident, _), resolution) in self.resolutions(module).borrow().iter() {\n+            if let Some(binding) = resolution.borrow().binding {\n+                let res = binding.res();\n+                if filter_fn(res) {\n+                    names.push(TypoSuggestion::from_res(ident.name, res));\n+                }\n             }\n         }\n     }\n-}\n \n-impl<'a> Resolver<'a> {\n     /// Combines an error with provided span and emits it.\n     ///\n     /// This takes the error provided, combines it with the span and any additional spans inside the\n@@ -402,10 +405,10 @@ impl<'a> Resolver<'a> {\n                 Scope::CrateRoot => {\n                     let root_ident = Ident::new(kw::PathRoot, ident.span);\n                     let root_module = this.resolve_crate_root(root_ident);\n-                    add_module_candidates(root_module, &mut suggestions, filter_fn);\n+                    this.add_module_candidates(root_module, &mut suggestions, filter_fn);\n                 }\n                 Scope::Module(module) => {\n-                    add_module_candidates(module, &mut suggestions, filter_fn);\n+                    this.add_module_candidates(module, &mut suggestions, filter_fn);\n                 }\n                 Scope::MacroUsePrelude => {\n                     suggestions.extend(this.macro_use_prelude.iter().filter_map(|(name, binding)| {\n@@ -453,7 +456,7 @@ impl<'a> Resolver<'a> {\n                 Scope::StdLibPrelude => {\n                     if let Some(prelude) = this.prelude {\n                         let mut tmp_suggestions = Vec::new();\n-                        add_module_candidates(prelude, &mut tmp_suggestions, filter_fn);\n+                        this.add_module_candidates(prelude, &mut tmp_suggestions, filter_fn);\n                         suggestions.extend(tmp_suggestions.into_iter().filter(|s| {\n                             use_prelude || this.is_builtin_macro(s.res)\n                         }));\n@@ -509,11 +512,9 @@ impl<'a> Resolver<'a> {\n         while let Some((in_module,\n                         path_segments,\n                         in_module_is_extern)) = worklist.pop() {\n-            self.populate_module_if_necessary(in_module);\n-\n             // We have to visit module children in deterministic order to avoid\n             // instabilities in reported imports (#43552).\n-            in_module.for_each_child_stable(|ident, ns, name_binding| {\n+            in_module.for_each_child_stable(self, |this, ident, ns, name_binding| {\n                 // avoid imports entirely\n                 if name_binding.is_import() && !name_binding.is_extern_crate() { return; }\n                 // avoid non-importable candidates as well\n@@ -547,7 +548,7 @@ impl<'a> Resolver<'a> {\n                         // outside crate private modules => no need to check this)\n                         if !in_module_is_extern || name_binding.vis == ty::Visibility::Public {\n                             let did = match res {\n-                                Res::Def(DefKind::Ctor(..), did) => self.parent(did),\n+                                Res::Def(DefKind::Ctor(..), did) => this.parent(did),\n                                 _ => res.opt_def_id(),\n                             };\n                             candidates.push(ImportSuggestion { did, path });\n@@ -607,8 +608,6 @@ impl<'a> Resolver<'a> {\n                         krate: crate_id,\n                         index: CRATE_DEF_INDEX,\n                     });\n-                    self.populate_module_if_necessary(&crate_root);\n-\n                     suggestions.extend(self.lookup_import_candidates_from_module(\n                         lookup_ident, namespace, crate_root, ident, &filter_fn));\n                 }\n@@ -805,7 +804,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     ///            at the root of the crate instead of the module where it is defined\n     /// ```\n     pub(crate) fn check_for_module_export_macro(\n-        &self,\n+        &mut self,\n         directive: &'b ImportDirective<'b>,\n         module: ModuleOrUniformRoot<'b>,\n         ident: Ident,\n@@ -826,7 +825,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             return None;\n         }\n \n-        let resolutions = crate_module.resolutions.borrow();\n+        let resolutions = self.r.resolutions(crate_module).borrow();\n         let resolution = resolutions.get(&(ident, MacroNS))?;\n         let binding = resolution.borrow().binding()?;\n         if let Res::Def(DefKind::Macro(MacroKind::Bang), _) = binding.res() {"}, {"sha": "d8bd86699b7af966982543c6143c77599f8d110d", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f3c67d4e0c4d8237899c6aa99a174547ff85b09/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3c67d4e0c4d8237899c6aa99a174547ff85b09/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=7f3c67d4e0c4d8237899c6aa99a174547ff85b09", "patch": "@@ -1929,7 +1929,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         let mut traits = module.traits.borrow_mut();\n         if traits.is_none() {\n             let mut collected_traits = Vec::new();\n-            module.for_each_child(|name, ns, binding| {\n+            module.for_each_child(self.r, |_, name, ns, binding| {\n                 if ns != TypeNS { return }\n                 match binding.res() {\n                     Res::Def(DefKind::Trait, _) |"}, {"sha": "a822fa049ca1c5467175d881af0110230c7d1b4c", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7f3c67d4e0c4d8237899c6aa99a174547ff85b09/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3c67d4e0c4d8237899c6aa99a174547ff85b09/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=7f3c67d4e0c4d8237899c6aa99a174547ff85b09", "patch": "@@ -1,8 +1,7 @@\n use crate::{CrateLint, Module, ModuleKind, ModuleOrUniformRoot};\n use crate::{PathResult, PathSource, Segment};\n use crate::path_names_to_string;\n-use crate::diagnostics::{add_typo_suggestion, add_module_candidates};\n-use crate::diagnostics::{ImportSuggestion, TypoSuggestion};\n+use crate::diagnostics::{add_typo_suggestion, ImportSuggestion, TypoSuggestion};\n use crate::late::{LateResolutionVisitor, RibKind};\n \n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n@@ -548,7 +547,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n                 // Items in scope\n                 if let RibKind::ModuleRibKind(module) = rib.kind {\n                     // Items from this module\n-                    add_module_candidates(module, &mut names, &filter_fn);\n+                    self.r.add_module_candidates(module, &mut names, &filter_fn);\n \n                     if let ModuleKind::Block(..) = module.kind {\n                         // We can see through blocks\n@@ -577,7 +576,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n                             }));\n \n                             if let Some(prelude) = self.r.prelude {\n-                                add_module_candidates(prelude, &mut names, &filter_fn);\n+                                self.r.add_module_candidates(prelude, &mut names, &filter_fn);\n                             }\n                         }\n                         break;\n@@ -599,7 +598,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n                 mod_path, Some(TypeNS), false, span, CrateLint::No\n             ) {\n                 if let ModuleOrUniformRoot::Module(module) = module {\n-                    add_module_candidates(module, &mut names, &filter_fn);\n+                    self.r.add_module_candidates(module, &mut names, &filter_fn);\n                 }\n             }\n         }\n@@ -717,9 +716,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n             // abort if the module is already found\n             if result.is_some() { break; }\n \n-            self.r.populate_module_if_necessary(in_module);\n-\n-            in_module.for_each_child_stable(|ident, _, name_binding| {\n+            in_module.for_each_child_stable(self.r, |_, ident, _, name_binding| {\n                 // abort if the module is already found or if name_binding is private external\n                 if result.is_some() || !name_binding.vis.is_visible_locally() {\n                     return\n@@ -750,10 +747,8 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n \n     fn collect_enum_variants(&mut self, def_id: DefId) -> Option<Vec<Path>> {\n         self.find_module(def_id).map(|(enum_module, enum_import_suggestion)| {\n-            self.r.populate_module_if_necessary(enum_module);\n-\n             let mut variants = Vec::new();\n-            enum_module.for_each_child_stable(|ident, _, name_binding| {\n+            enum_module.for_each_child_stable(self.r, |_, ident, _, name_binding| {\n                 if let Res::Def(DefKind::Variant, _) = name_binding.res() {\n                     let mut segms = enum_import_suggestion.path.segments.clone();\n                     segms.push(ast::PathSegment::from_ident(ident));"}, {"sha": "12c4f5bfe8e617f8fb538d147c4297ae4d55a279", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 37, "deletions": 15, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7f3c67d4e0c4d8237899c6aa99a174547ff85b09/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3c67d4e0c4d8237899c6aa99a174547ff85b09/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=7f3c67d4e0c4d8237899c6aa99a174547ff85b09", "patch": "@@ -431,6 +431,8 @@ impl ModuleKind {\n     }\n }\n \n+type Resolutions<'a> = RefCell<FxHashMap<(Ident, Namespace), &'a RefCell<NameResolution<'a>>>>;\n+\n /// One node in the tree of modules.\n pub struct ModuleData<'a> {\n     parent: Option<Module<'a>>,\n@@ -439,7 +441,11 @@ pub struct ModuleData<'a> {\n     // The def id of the closest normal module (`mod`) ancestor (including this module).\n     normal_ancestor_id: DefId,\n \n-    resolutions: RefCell<FxHashMap<(Ident, Namespace), &'a RefCell<NameResolution<'a>>>>,\n+    // Mapping between names and their (possibly in-progress) resolutions in this module.\n+    // Resolutions in modules from other crates are not populated until accessed.\n+    lazy_resolutions: Resolutions<'a>,\n+    // True if this is a module from other crate that needs to be populated on access.\n+    populate_on_access: Cell<bool>,\n \n     // Macro invocations that can expand into items in this module.\n     unresolved_invocations: RefCell<FxHashSet<ExpnId>>,\n@@ -452,11 +458,6 @@ pub struct ModuleData<'a> {\n     // Used to memoize the traits in this module for faster searches through all traits in scope.\n     traits: RefCell<Option<Box<[(Ident, &'a NameBinding<'a>)]>>>,\n \n-    // Whether this module is populated. If not populated, any attempt to\n-    // access the children must be preceded with a\n-    // `populate_module_if_necessary` call.\n-    populated: Cell<bool>,\n-\n     /// Span of the module itself. Used for error reporting.\n     span: Span,\n \n@@ -475,30 +476,34 @@ impl<'a> ModuleData<'a> {\n             parent,\n             kind,\n             normal_ancestor_id,\n-            resolutions: Default::default(),\n+            lazy_resolutions: Default::default(),\n+            populate_on_access: Cell::new(!normal_ancestor_id.is_local()),\n             unresolved_invocations: Default::default(),\n             no_implicit_prelude: false,\n             glob_importers: RefCell::new(Vec::new()),\n             globs: RefCell::new(Vec::new()),\n             traits: RefCell::new(None),\n-            populated: Cell::new(normal_ancestor_id.is_local()),\n             span,\n             expansion,\n         }\n     }\n \n-    fn for_each_child<F: FnMut(Ident, Namespace, &'a NameBinding<'a>)>(&self, mut f: F) {\n-        for (&(ident, ns), name_resolution) in self.resolutions.borrow().iter() {\n-            name_resolution.borrow().binding.map(|binding| f(ident, ns, binding));\n+    fn for_each_child<R, F>(&'a self, resolver: &mut R, mut f: F)\n+        where R: AsMut<Resolver<'a>>, F: FnMut(&mut R, Ident, Namespace, &'a NameBinding<'a>)\n+    {\n+        for (&(ident, ns), name_resolution) in resolver.as_mut().resolutions(self).borrow().iter() {\n+            name_resolution.borrow().binding.map(|binding| f(resolver, ident, ns, binding));\n         }\n     }\n \n-    fn for_each_child_stable<F: FnMut(Ident, Namespace, &'a NameBinding<'a>)>(&self, mut f: F) {\n-        let resolutions = self.resolutions.borrow();\n+    fn for_each_child_stable<R, F>(&'a self, resolver: &mut R, mut f: F)\n+        where R: AsMut<Resolver<'a>>, F: FnMut(&mut R, Ident, Namespace, &'a NameBinding<'a>)\n+    {\n+        let resolutions = resolver.as_mut().resolutions(self).borrow();\n         let mut resolutions = resolutions.iter().collect::<Vec<_>>();\n         resolutions.sort_by_cached_key(|&(&(ident, ns), _)| (ident.as_str(), ns));\n         for &(&(ident, ns), &resolution) in resolutions.iter() {\n-            resolution.borrow().binding.map(|binding| f(ident, ns, binding));\n+            resolution.borrow().binding.map(|binding| f(resolver, ident, ns, binding));\n         }\n     }\n \n@@ -983,6 +988,10 @@ impl<'a> ResolverArenas<'a> {\n     }\n }\n \n+impl<'a> AsMut<Resolver<'a>> for Resolver<'a> {\n+    fn as_mut(&mut self) -> &mut Resolver<'a> { self }\n+}\n+\n impl<'a, 'b> ty::DefIdTree for &'a Resolver<'b> {\n     fn parent(self, id: DefId) -> Option<DefId> {\n         match id.krate {\n@@ -1248,6 +1257,20 @@ impl<'a> Resolver<'a> {\n         self.arenas.alloc_module(module)\n     }\n \n+    fn resolutions(&mut self, module: Module<'a>) -> &'a Resolutions<'a> {\n+        if module.populate_on_access.get() {\n+            module.populate_on_access.set(false);\n+            self.build_reduced_graph_external(module);\n+        }\n+        &module.lazy_resolutions\n+    }\n+\n+    fn resolution(&mut self, module: Module<'a>, ident: Ident, ns: Namespace)\n+                  -> &'a RefCell<NameResolution<'a>> {\n+        *self.resolutions(module).borrow_mut().entry((ident.modern(), ns))\n+               .or_insert_with(|| self.arenas.alloc_name_resolution())\n+    }\n+\n     fn record_use(&mut self, ident: Ident, ns: Namespace,\n                   used_binding: &'a NameBinding<'a>, is_lexical_scope: bool) {\n         if let Some((b2, kind)) = used_binding.ambiguity {\n@@ -2634,7 +2657,6 @@ impl<'a> Resolver<'a> {\n                     return None;\n                 };\n                 let crate_root = self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX });\n-                self.populate_module_if_necessary(&crate_root);\n                 Some((crate_root, ty::Visibility::Public, DUMMY_SP, ExpnId::root())\n                     .to_name_binding(self.arenas))\n             }"}, {"sha": "6f49377c187aa91a8103159d65c7c41cedb0a80f", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f3c67d4e0c4d8237899c6aa99a174547ff85b09/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3c67d4e0c4d8237899c6aa99a174547ff85b09/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=7f3c67d4e0c4d8237899c6aa99a174547ff85b09", "patch": "@@ -8,7 +8,6 @@ use crate::{ModuleOrUniformRoot, KNOWN_TOOLS};\n use crate::Namespace::*;\n use crate::resolve_imports::ImportResolver;\n use rustc::hir::def::{self, DefKind, NonMacroAttrKind};\n-use rustc::hir::map::DefCollector;\n use rustc::middle::stability;\n use rustc::{ty, lint, span_bug};\n use syntax::ast::{self, Ident};\n@@ -131,7 +130,6 @@ impl<'a> base::Resolver for Resolver<'a> {\n         parent_scope.module.unresolved_invocations.borrow_mut().extend(derives);\n \n         // Integrate the new AST fragment into all the definition and module structures.\n-        fragment.visit_with(&mut DefCollector::new(&mut self.definitions, expansion));\n         let output_legacy_scope = self.build_reduced_graph(fragment, parent_scope);\n         self.output_legacy_scopes.insert(expansion, output_legacy_scope);\n     }"}, {"sha": "b49f1868706695674667f097f10563e96b2bf7e0", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7f3c67d4e0c4d8237899c6aa99a174547ff85b09/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3c67d4e0c4d8237899c6aa99a174547ff85b09/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=7f3c67d4e0c4d8237899c6aa99a174547ff85b09", "patch": "@@ -7,9 +7,8 @@ use crate::{CrateLint, Module, ModuleOrUniformRoot, PerNS, ScopeSet, ParentScope\n use crate::Determinacy::{self, *};\n use crate::Namespace::{self, TypeNS, MacroNS};\n use crate::{NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyError};\n-use crate::{Resolver, ResolutionError, Segment};\n+use crate::{Resolver, ResolutionError, Segment, ModuleKind};\n use crate::{names_to_string, module_to_string};\n-use crate::ModuleKind;\n use crate::diagnostics::Suggestion;\n \n use errors::Applicability;\n@@ -37,7 +36,7 @@ use syntax_pos::{MultiSpan, Span};\n \n use log::*;\n \n-use std::cell::{Cell, RefCell};\n+use std::cell::Cell;\n use std::{mem, ptr};\n \n type Res = def::Res<NodeId>;\n@@ -161,12 +160,6 @@ impl<'a> NameResolution<'a> {\n }\n \n impl<'a> Resolver<'a> {\n-    crate fn resolution(&self, module: Module<'a>, ident: Ident, ns: Namespace)\n-                  -> &'a RefCell<NameResolution<'a>> {\n-        *module.resolutions.borrow_mut().entry((ident.modern(), ns))\n-               .or_insert_with(|| self.arenas.alloc_name_resolution())\n-    }\n-\n     crate fn resolve_ident_in_module_unadjusted(\n         &mut self,\n         module: ModuleOrUniformRoot<'a>,\n@@ -242,8 +235,6 @@ impl<'a> Resolver<'a> {\n             }\n         };\n \n-        self.populate_module_if_necessary(module);\n-\n         let resolution = self.resolution(module, ident, ns)\n             .try_borrow_mut()\n             .map_err(|_| (Determined, Weak::No))?; // This happens when there is a cycle of imports.\n@@ -1027,7 +1018,8 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n             return if all_ns_failed {\n                 let resolutions = match module {\n-                    ModuleOrUniformRoot::Module(module) => Some(module.resolutions.borrow()),\n+                    ModuleOrUniformRoot::Module(module) =>\n+                        Some(self.r.resolutions(module).borrow()),\n                     _ => None,\n                 };\n                 let resolutions = resolutions.as_ref().into_iter().flat_map(|r| r.iter());\n@@ -1265,8 +1257,6 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             }\n         };\n \n-        self.r.populate_module_if_necessary(module);\n-\n         if module.is_trait() {\n             self.r.session.span_err(directive.span, \"items in traits are not importable.\");\n             return;\n@@ -1282,8 +1272,8 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n         // Ensure that `resolutions` isn't borrowed during `try_define`,\n         // since it might get updated via a glob cycle.\n-        let bindings = module.resolutions.borrow().iter().filter_map(|(&ident, resolution)| {\n-            resolution.borrow().binding().map(|binding| (ident, binding))\n+        let bindings = self.r.resolutions(module).borrow().iter().filter_map(|(ident, resolution)| {\n+            resolution.borrow().binding().map(|binding| (*ident, binding))\n         }).collect::<Vec<_>>();\n         for ((mut ident, ns), binding) in bindings {\n             let scope = match ident.span.reverse_glob_adjust(module.expansion, directive.span) {\n@@ -1310,7 +1300,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n         let mut reexports = Vec::new();\n \n-        for (&(ident, ns), resolution) in module.resolutions.borrow().iter() {\n+        for (&(ident, ns), resolution) in self.r.resolutions(module).borrow().iter() {\n             let resolution = &mut *resolution.borrow_mut();\n             let binding = match resolution.binding {\n                 Some(binding) => binding,\n@@ -1369,8 +1359,8 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                             Some(ModuleOrUniformRoot::Module(module)) => module,\n                             _ => bug!(\"module should exist\"),\n                         };\n-                        let resolutions = imported_module.parent.expect(\"parent should exist\")\n-                            .resolutions.borrow();\n+                        let parent_module = imported_module.parent.expect(\"parent should exist\");\n+                        let resolutions = self.r.resolutions(parent_module).borrow();\n                         let enum_path_segment_index = directive.module_path.len() - 1;\n                         let enum_ident = directive.module_path[enum_path_segment_index].ident;\n "}]}