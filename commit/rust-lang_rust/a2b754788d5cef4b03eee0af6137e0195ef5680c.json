{"sha": "a2b754788d5cef4b03eee0af6137e0195ef5680c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyYjc1NDc4OGQ1Y2VmNGIwM2VlZTBhZjYxMzdlMDE5NWVmNTY4MGM=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-15T04:19:27Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-19T18:02:51Z"}, "message": "convert syntax::attr to use @~strs", "tree": {"sha": "c17a62cdb6b0c8e23262e71e8467676a72eab4f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c17a62cdb6b0c8e23262e71e8467676a72eab4f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2b754788d5cef4b03eee0af6137e0195ef5680c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2b754788d5cef4b03eee0af6137e0195ef5680c", "html_url": "https://github.com/rust-lang/rust/commit/a2b754788d5cef4b03eee0af6137e0195ef5680c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2b754788d5cef4b03eee0af6137e0195ef5680c/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1808d747f65e43f9a8d40b9214e1221700f026d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/1808d747f65e43f9a8d40b9214e1221700f026d8", "html_url": "https://github.com/rust-lang/rust/commit/1808d747f65e43f9a8d40b9214e1221700f026d8"}], "stats": {"total": 262, "additions": 130, "deletions": 132}, "files": [{"sha": "fefd49d7815059da30337f5e0934557956997493", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2b754788d5cef4b03eee0af6137e0195ef5680c/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b754788d5cef4b03eee0af6137e0195ef5680c/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=a2b754788d5cef4b03eee0af6137e0195ef5680c", "patch": "@@ -466,14 +466,14 @@ pub fn build_link_meta(sess: Session, c: &ast::crate, output: &Path,\n         let linkage_metas = attr::find_linkage_metas(c.node.attrs);\n         attr::require_unique_names(sess.diagnostic(), linkage_metas);\n         for linkage_metas.each |meta| {\n-            if attr::get_meta_item_name(*meta) == ~\"name\" {\n+            if *attr::get_meta_item_name(*meta) == ~\"name\" {\n                 match attr::get_meta_item_value_str(*meta) {\n                   // Changing attr would avoid the need for the copy\n                   // here\n                   Some(v) => { name = Some(v.to_managed()); }\n                   None => cmh_items.push(*meta)\n                 }\n-            } else if attr::get_meta_item_name(*meta) == ~\"vers\" {\n+            } else if *attr::get_meta_item_name(*meta) == ~\"vers\" {\n                 match attr::get_meta_item_value_str(*meta) {\n                   Some(v) => { vers = Some(v.to_managed()); }\n                   None => cmh_items.push(*meta)"}, {"sha": "8894aad4816fa8ac3586bbe1f3653186286013b7", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a2b754788d5cef4b03eee0af6137e0195ef5680c/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b754788d5cef4b03eee0af6137e0195ef5680c/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=a2b754788d5cef4b03eee0af6137e0195ef5680c", "patch": "@@ -97,24 +97,24 @@ pub fn default_configuration(sess: Session, +argv0: ~str, input: input) ->\n     };\n \n     return ~[ // Target bindings.\n-         attr::mk_word_item(str::from_slice(os::FAMILY)),\n-         mk(~\"target_os\", tos),\n-         mk(~\"target_family\", str::from_slice(os::FAMILY)),\n-         mk(~\"target_arch\", arch),\n-         mk(~\"target_endian\", end),\n-         mk(~\"target_word_size\", wordsz),\n-         mk(~\"target_libc\", libc),\n+         attr::mk_word_item(@str::from_slice(os::FAMILY)),\n+         mk(@~\"target_os\", @tos),\n+         mk(@~\"target_family\", @str::from_slice(os::FAMILY)),\n+         mk(@~\"target_arch\", @arch),\n+         mk(@~\"target_endian\", @end),\n+         mk(@~\"target_word_size\", @wordsz),\n+         mk(@~\"target_libc\", @libc),\n          // Build bindings.\n-         mk(~\"build_compiler\", argv0),\n-         mk(~\"build_input\", source_name(input))];\n+         mk(@~\"build_compiler\", @argv0),\n+         mk(@~\"build_input\", @source_name(input))];\n }\n \n pub fn append_configuration(+cfg: ast::crate_cfg, +name: ~str)\n                          -> ast::crate_cfg {\n     if attr::contains_name(cfg, name) {\n         cfg\n     } else {\n-        vec::append_one(cfg, attr::mk_word_item(name))\n+        vec::append_one(cfg, attr::mk_word_item(@name))\n     }\n }\n \n@@ -142,7 +142,7 @@ pub fn parse_cfgspecs(cfgspecs: ~[~str]) -> ast::crate_cfg {\n     // meta_word variant.\n     let mut words = ~[];\n     for cfgspecs.each |s| {\n-        words.push(attr::mk_word_item(/*bad*/copy *s));\n+        words.push(attr::mk_word_item(@/*bad*/copy *s));\n     }\n     return words;\n }"}, {"sha": "4d7f55584bb32ebf1f98a2aae69d4ca61b19e514", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2b754788d5cef4b03eee0af6137e0195ef5680c/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b754788d5cef4b03eee0af6137e0195ef5680c/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=a2b754788d5cef4b03eee0af6137e0195ef5680c", "patch": "@@ -310,7 +310,7 @@ pub fn building_library(req_crate_type: crate_type,\n             match syntax::attr::first_attr_value_str_by_name(\n                 crate.node.attrs,\n                 ~\"crate_type\") {\n-              option::Some(~\"lib\") => true,\n+              Some(@~\"lib\") => true,\n               _ => false\n             }\n         }"}, {"sha": "9955ef4a8e920265142b0ad7f46abcc85701fec0", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a2b754788d5cef4b03eee0af6137e0195ef5680c/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b754788d5cef4b03eee0af6137e0195ef5680c/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=a2b754788d5cef4b03eee0af6137e0195ef5680c", "patch": "@@ -57,7 +57,7 @@ pub fn modify_for_testing(sess: session::Session,\n     // configuration, either with the '--test' or '--cfg test'\n     // command line options.\n     let should_test = attr::contains(crate.node.config,\n-                                     attr::mk_word_item(~\"test\"));\n+                                     attr::mk_word_item(@~\"test\"));\n \n     if should_test {\n         generate_test_harness(sess, crate)\n@@ -111,7 +111,7 @@ fn fold_mod(cx: @mut TestCtxt,\n     fn nomain(cx: @mut TestCtxt, item: @ast::item) -> @ast::item {\n         if !*cx.sess.building_library {\n             @ast::item{attrs: item.attrs.filtered(|attr| {\n-                               attr::get_attr_name(attr) != ~\"main\"\n+                               *attr::get_attr_name(attr) != ~\"main\"\n                            }),.. copy *item}\n         } else { item }\n     }\n@@ -310,7 +310,7 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::item {\n \n     // This attribute tells resolve to let us call unexported functions\n     let resolve_unexported_attr =\n-        attr::mk_attr(attr::mk_word_item(~\"!resolve_unexported\"));\n+        attr::mk_attr(attr::mk_word_item(@~\"!resolve_unexported\"));\n \n     let item = ast::item {\n         ident: cx.sess.ident_of(~\"__test\"),\n@@ -366,7 +366,7 @@ fn is_std(cx: &TestCtxt) -> bool {\n     let is_std = {\n         let items = attr::find_linkage_metas(cx.crate.node.attrs);\n         match attr::last_meta_item_value_str_by_name(items, ~\"name\") {\n-          Some(~\"std\") => true,\n+          Some(@~\"std\") => true,\n           _ => false\n         }\n     };"}, {"sha": "b18a52a9486b298a59b26b0d38a4deda63caab9a", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a2b754788d5cef4b03eee0af6137e0195ef5680c/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b754788d5cef4b03eee0af6137e0195ef5680c/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=a2b754788d5cef4b03eee0af6137e0195ef5680c", "patch": "@@ -105,7 +105,7 @@ fn warn_if_multiple_versions(e: @mut Env,\n                 diag.span_note(match_.span, ~\"used here\");\n                 let attrs = ~[\n                     attr::mk_attr(attr::mk_list_item(\n-                        ~\"link\", /*bad*/copy *match_.metas))\n+                        @~\"link\", /*bad*/copy *match_.metas))\n                 ];\n                 loader::note_linkage_attrs(e.intr, diag, attrs);\n             }\n@@ -133,7 +133,7 @@ fn visit_crate(e: @mut Env, c: ast::crate) {\n     for link_args.each |a| {\n         match attr::get_meta_item_value_str(attr::attr_meta(*a)) {\n           Some(ref linkarg) => {\n-            cstore::add_used_link_args(cstore, (/*bad*/copy *linkarg));\n+            cstore::add_used_link_args(cstore, **linkarg);\n           }\n           None => {/* fallthrough */ }\n         }\n@@ -173,21 +173,22 @@ fn visit_item(e: @mut Env, i: @ast::item) {\n                match attr::first_attr_value_str_by_name(i.attrs,\n                                                         ~\"link_name\") {\n                  Some(ref nn) => {\n-                   if (*nn) == ~\"\" {\n+                   if **nn == ~\"\" {\n                       e.diag.span_fatal(\n                           i.span,\n                           ~\"empty #[link_name] not allowed; use #[nolink].\");\n                    }\n                    (/*bad*/copy *nn)\n                  }\n-                None => /*bad*/copy *e.intr.get(i.ident)\n+                None => @/*bad*/copy *e.intr.get(i.ident)\n             };\n             if attr::find_attrs_by_name(i.attrs, ~\"nolink\").is_empty() {\n                 already_added =\n-                    !cstore::add_used_library(cstore, copy foreign_name);\n+                    !cstore::add_used_library(cstore,\n+                                              /*bad*/ copy *foreign_name);\n             }\n             if !link_args.is_empty() && already_added {\n-                e.diag.span_fatal(i.span, ~\"library '\" + foreign_name +\n+                e.diag.span_fatal(i.span, ~\"library '\" + *foreign_name +\n                            ~\"' already added: can't specify link_args.\");\n             }\n           }\n@@ -197,7 +198,7 @@ fn visit_item(e: @mut Env, i: @ast::item) {\n         for link_args.each |a| {\n             match attr::get_meta_item_value_str(attr::attr_meta(*a)) {\n               Some(ref linkarg) => {\n-                cstore::add_used_link_args(cstore, *linkarg);\n+                cstore::add_used_link_args(cstore, /*bad*/copy **linkarg);\n               }\n               None => {/* fallthrough */ }\n             }\n@@ -211,7 +212,7 @@ fn metas_with(+ident: ~str, +key: ~str, +metas: ~[@ast::meta_item])\n     -> ~[@ast::meta_item] {\n     let name_items = attr::find_meta_items_by_name(metas, key);\n     if name_items.is_empty() {\n-        vec::append_one(metas, attr::mk_name_value_item_str(key, ident))\n+        vec::append_one(metas, attr::mk_name_value_item_str(@key, @ident))\n     } else {\n         metas\n     }\n@@ -276,9 +277,9 @@ fn resolve_crate(e: @mut Env,\n             match attr::last_meta_item_value_str_by_name(load_ctxt.metas,\n                                                          ~\"name\") {\n               option::Some(ref v) => (/*bad*/copy *v),\n-              option::None => /*bad*/copy *e.intr.get(ident)\n+              option::None => @/*bad*/copy *e.intr.get(ident)\n             };\n-        let cmeta = @{name: cname, data: cdata,\n+        let cmeta = @{name: /*bad*/copy *cname, data: cdata,\n                       cnum_map: cnum_map, cnum: cnum};\n \n         let cstore = e.cstore;"}, {"sha": "c862490388d98cd63c381067818b5abf76973cb3", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a2b754788d5cef4b03eee0af6137e0195ef5680c/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b754788d5cef4b03eee0af6137e0195ef5680c/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=a2b754788d5cef4b03eee0af6137e0195ef5680c", "patch": "@@ -962,7 +962,7 @@ fn get_meta_items(md: ebml::Doc) -> ~[@ast::meta_item] {\n     for reader::tagged_docs(md, tag_meta_item_word) |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = str::from_bytes(reader::doc_data(nd));\n-        items.push(attr::mk_word_item(n));\n+        items.push(attr::mk_word_item(@n));\n     };\n     for reader::tagged_docs(md, tag_meta_item_name_value) |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n@@ -971,13 +971,13 @@ fn get_meta_items(md: ebml::Doc) -> ~[@ast::meta_item] {\n         let v = str::from_bytes(reader::doc_data(vd));\n         // FIXME (#623): Should be able to decode meta_name_value variants,\n         // but currently the encoder just drops them\n-        items.push(attr::mk_name_value_item_str(n, v));\n+        items.push(attr::mk_name_value_item_str(@n, @v));\n     };\n     for reader::tagged_docs(md, tag_meta_item_list) |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = str::from_bytes(reader::doc_data(nd));\n         let subitems = get_meta_items(meta_item_doc);\n-        items.push(attr::mk_list_item(n, subitems));\n+        items.push(attr::mk_list_item(@n, subitems));\n     };\n     return items;\n }\n@@ -1073,7 +1073,7 @@ pub fn get_crate_vers(data: @~[u8]) -> ~str {\n     let attrs = decoder::get_crate_attributes(data);\n     return match attr::last_meta_item_value_str_by_name(\n         attr::find_linkage_metas(attrs), ~\"vers\") {\n-      Some(ref ver) => (/*bad*/copy *ver),\n+      Some(ref ver) => (/*bad*/copy **ver),\n       None => ~\"0.0\"\n     };\n }"}, {"sha": "cf27c6e65f6db586d53e2b2c33819132f2900b48", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a2b754788d5cef4b03eee0af6137e0195ef5680c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b754788d5cef4b03eee0af6137e0195ef5680c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=a2b754788d5cef4b03eee0af6137e0195ef5680c", "patch": "@@ -1075,11 +1075,11 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: &crate) -> ~[attribute] {\n         assert !ecx.link_meta.vers.is_empty();\n \n         let name_item =\n-            attr::mk_name_value_item_str(~\"name\",\n-                                         ecx.link_meta.name.to_owned());\n+            attr::mk_name_value_item_str(@~\"name\",\n+                                         @ecx.link_meta.name.to_owned());\n         let vers_item =\n-            attr::mk_name_value_item_str(~\"vers\",\n-                                         ecx.link_meta.vers.to_owned());\n+            attr::mk_name_value_item_str(@~\"vers\",\n+                                         @ecx.link_meta.vers.to_owned());\n \n         let other_items =\n             {\n@@ -1088,7 +1088,7 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: &crate) -> ~[attribute] {\n             };\n \n         let meta_items = vec::append(~[name_item, vers_item], other_items);\n-        let link_item = attr::mk_list_item(~\"link\", meta_items);\n+        let link_item = attr::mk_list_item(@~\"link\", meta_items);\n \n         return attr::mk_attr(link_item);\n     }\n@@ -1097,7 +1097,7 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: &crate) -> ~[attribute] {\n     let mut found_link_attr = false;\n     for crate.node.attrs.each |attr| {\n         attrs.push(\n-            if attr::get_attr_name(attr) != ~\"link\" {\n+            if *attr::get_attr_name(attr) != ~\"link\" {\n                 /*bad*/copy *attr\n             } else {\n                 match /*bad*/copy attr.node.value.node {"}, {"sha": "d2650696307c80026d0b92e1ae2e046ae1f278f2", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2b754788d5cef4b03eee0af6137e0195ef5680c/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b754788d5cef4b03eee0af6137e0195ef5680c/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=a2b754788d5cef4b03eee0af6137e0195ef5680c", "patch": "@@ -147,7 +147,7 @@ pub fn crate_name_from_metas(+metas: ~[@ast::meta_item]) -> ~str {\n     match vec::last_opt(name_items) {\n       Some(i) => {\n         match attr::get_meta_item_value_str(i) {\n-          Some(ref n) => (/*bad*/copy *n),\n+          Some(ref n) => /*bad*/copy **n,\n           // FIXME (#2406): Probably want a warning here since the user\n           // is using the wrong type of meta item.\n           _ => fail!()"}, {"sha": "4446eda64b0aebd4ca547a7183d16cf2ee164c66", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2b754788d5cef4b03eee0af6137e0195ef5680c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b754788d5cef4b03eee0af6137e0195ef5680c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=a2b754788d5cef4b03eee0af6137e0195ef5680c", "patch": "@@ -50,7 +50,7 @@ fn abi_info(arch: session::arch) -> cabi::ABIInfo {\n pub fn link_name(ccx: @crate_ctxt, i: @ast::foreign_item) -> ~str {\n     match attr::first_attr_value_str_by_name(i.attrs, ~\"link_name\") {\n         None => ccx.sess.str_of(i.ident),\n-        option::Some(ref ln) => (/*bad*/copy *ln)\n+        option::Some(ref ln) => (/*bad*/copy **ln)\n     }\n }\n "}, {"sha": "bb9ba93cbe06a220f3cb808b0fbd1281843a50bd", "filename": "src/librustdoc/attr_parser.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a2b754788d5cef4b03eee0af6137e0195ef5680c/src%2Flibrustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b754788d5cef4b03eee0af6137e0195ef5680c/src%2Flibrustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_parser.rs?ref=a2b754788d5cef4b03eee0af6137e0195ef5680c", "patch": "@@ -65,9 +65,10 @@ fn doc_metas(\n \n pub fn parse_crate(attrs: ~[ast::attribute]) -> CrateAttrs {\n     let link_metas = attr::find_linkage_metas(attrs);\n+    let name = attr::last_meta_item_value_str_by_name(link_metas, ~\"name\");\n \n     CrateAttrs {\n-        name: attr::last_meta_item_value_str_by_name(link_metas, ~\"name\")\n+        name: name.map(|s| copy **s)\n     }\n }\n \n@@ -97,7 +98,7 @@ fn should_not_extract_crate_name_if_no_name_value_in_link_attribute() {\n \n pub fn parse_desc(attrs: ~[ast::attribute]) -> Option<~str> {\n     let doc_strs = do doc_metas(attrs).filter_mapped |meta| {\n-        attr::get_meta_item_value_str(*meta)\n+        attr::get_meta_item_value_str(*meta).map(|s| copy **s)\n     };\n     if doc_strs.is_empty() {\n         None"}, {"sha": "f2b1e41bbd12c3d25d10d05ade79f4103724f8cb", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2b754788d5cef4b03eee0af6137e0195ef5680c/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b754788d5cef4b03eee0af6137e0195ef5680c/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=a2b754788d5cef4b03eee0af6137e0195ef5680c", "patch": "@@ -81,7 +81,7 @@ fn fold_mod(_ctx: @ReadyCtx, m: ast::_mod,\n     fn strip_main(item: @ast::item) -> @ast::item {\n         @ast::item {\n             attrs: do item.attrs.filtered |attr| {\n-                attr::get_attr_name(*attr) != ~\"main\"\n+                *attr::get_attr_name(attr) != ~\"main\"\n             },\n             .. copy *item\n         }\n@@ -609,7 +609,7 @@ pub fn compile_input(sysroot: Option<Path>, input: driver::input, dir: &Path,\n     let mut crate_cfg = options.cfg;\n \n     for cfgs.each |&cfg| {\n-        crate_cfg.push(attr::mk_word_item(cfg));\n+        crate_cfg.push(attr::mk_word_item(@cfg));\n     }\n \n     let options = @{"}, {"sha": "bbe18a7fcc0dc5bf6c3a7699b13a55303eaab0a9", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 69, "deletions": 73, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/a2b754788d5cef4b03eee0af6137e0195ef5680c/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b754788d5cef4b03eee0af6137e0195ef5680c/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=a2b754788d5cef4b03eee0af6137e0195ef5680c", "patch": "@@ -29,24 +29,24 @@ use std;\n \n /* Constructors */\n \n-pub fn mk_name_value_item_str(name: ~str, value: ~str)\n+pub fn mk_name_value_item_str(name: @~str, value: @~str)\n                            -> @ast::meta_item {\n-    let value_lit = dummy_spanned(ast::lit_str(@value));\n-    return mk_name_value_item(name, value_lit);\n+    let value_lit = dummy_spanned(ast::lit_str(value));\n+    mk_name_value_item(name, value_lit)\n }\n \n-pub fn mk_name_value_item(name: ~str, +value: ast::lit)\n+pub fn mk_name_value_item(name: @~str, +value: ast::lit)\n         -> @ast::meta_item {\n-    return @dummy_spanned(ast::meta_name_value(name, value));\n+    @dummy_spanned(ast::meta_name_value(/*bad*/ copy *name, value))\n }\n \n-pub fn mk_list_item(name: ~str, +items: ~[@ast::meta_item]) ->\n+pub fn mk_list_item(name: @~str, +items: ~[@ast::meta_item]) ->\n    @ast::meta_item {\n-    return @dummy_spanned(ast::meta_list(name, items));\n+    @dummy_spanned(ast::meta_list(/*bad*/ copy *name, items))\n }\n \n-pub fn mk_word_item(name: ~str) -> @ast::meta_item {\n-    return @dummy_spanned(ast::meta_word(name));\n+pub fn mk_word_item(name: @~str) -> @ast::meta_item {\n+    @dummy_spanned(ast::meta_word(/*bad*/ copy *name))\n }\n \n pub fn mk_attr(item: @ast::meta_item) -> ast::attribute {\n@@ -80,39 +80,41 @@ pub fn attr_metas(attrs: ~[ast::attribute]) -> ~[@ast::meta_item] {\n pub fn desugar_doc_attr(attr: &ast::attribute) -> ast::attribute {\n     if attr.node.is_sugared_doc {\n         let comment = get_meta_item_value_str(@attr.node.value).get();\n-        let meta = mk_name_value_item_str(~\"doc\",\n-                                     strip_doc_comment_decoration(comment));\n-        return mk_attr(meta);\n+        let meta = mk_name_value_item_str(@~\"doc\",\n+                                     @strip_doc_comment_decoration(*comment));\n+        mk_attr(meta)\n     } else {\n         *attr\n     }\n }\n \n /* Accessors */\n \n-pub fn get_attr_name(attr: &ast::attribute) -> ~str {\n+pub pure fn get_attr_name(attr: &ast::attribute) -> @~str {\n     get_meta_item_name(@attr.node.value)\n }\n \n-pub fn get_meta_item_name(meta: @ast::meta_item) -> ~str {\n+pub pure fn get_meta_item_name(meta: @ast::meta_item) -> @~str {\n     match meta.node {\n-      ast::meta_word(ref n) => (*n),\n-      ast::meta_name_value(ref n, _) => (*n),\n-      ast::meta_list(ref n, _) => (*n)\n+        ast::meta_word(ref n) => @/*bad*/ copy *n,\n+        ast::meta_name_value(ref n, _) => @/*bad*/ copy *n,\n+        ast::meta_list(ref n, _) => @/*bad*/ copy *n,\n     }\n }\n \n /**\n  * Gets the string value if the meta_item is a meta_name_value variant\n  * containing a string, otherwise none\n  */\n-pub fn get_meta_item_value_str(meta: @ast::meta_item) -> Option<~str> {\n+pub fn get_meta_item_value_str(meta: @ast::meta_item) -> Option<@~str> {\n     match meta.node {\n-        ast::meta_name_value(_, v) => match v.node {\n-            ast::lit_str(s) => option::Some(*s),\n-            _ => option::None\n+        ast::meta_name_value(_, v) => {\n+            match v.node {\n+                ast::lit_str(s) => Some(s),\n+                _ => None,\n+            }\n         },\n-        _ => option::None\n+        _ => None\n     }\n }\n \n@@ -130,11 +132,11 @@ pub fn get_meta_item_list(meta: @ast::meta_item)\n  * a tuple containing the name and string value, otherwise `none`\n  */\n pub fn get_name_value_str_pair(item: @ast::meta_item)\n-                            -> Option<(~str, ~str)> {\n+                            -> Option<(@~str, @~str)> {\n     match attr::get_meta_item_value_str(item) {\n-      Some(ref value) => {\n+      Some(value) => {\n         let name = attr::get_meta_item_name(item);\n-        Some((name, (*value)))\n+        Some((name, value))\n       }\n       None => None\n     }\n@@ -147,7 +149,7 @@ pub fn get_name_value_str_pair(item: @ast::meta_item)\n pub fn find_attrs_by_name(attrs: &[ast::attribute], name: &str) ->\n    ~[ast::attribute] {\n     do vec::filter_mapped(attrs) |a| {\n-        if name == get_attr_name(a) {\n+        if name == *get_attr_name(a) {\n             Some(*a)\n         } else {\n             None\n@@ -160,7 +162,7 @@ pub fn find_meta_items_by_name(metas: &[@ast::meta_item], name: &str) ->\n    ~[@ast::meta_item] {\n     let mut rs = ~[];\n     for metas.each |mi| {\n-        if name == get_meta_item_name(*mi) {\n+        if name == *get_meta_item_name(*mi) {\n             rs.push(*mi)\n         }\n     }\n@@ -213,36 +215,39 @@ pub fn attrs_contains_name(attrs: &[ast::attribute], name: &str) -> bool {\n     !find_attrs_by_name(attrs, name).is_empty()\n }\n \n-pub fn first_attr_value_str_by_name(attrs: ~[ast::attribute], name: ~str)\n-                                 -> Option<~str> {\n+pub fn first_attr_value_str_by_name(attrs: ~[ast::attribute], name: &str)\n+                                 -> Option<@~str> {\n \n     let mattrs = find_attrs_by_name(attrs, name);\n-    if vec::len(mattrs) > 0u {\n-        return get_meta_item_value_str(attr_meta(mattrs[0]));\n+    if mattrs.len() > 0 {\n+        get_meta_item_value_str(attr_meta(mattrs[0]))\n+    } else {\n+        None\n     }\n-    return option::None;\n }\n \n-fn last_meta_item_by_name(items: ~[@ast::meta_item], name: ~str)\n+fn last_meta_item_by_name(items: ~[@ast::meta_item], name: &str)\n     -> Option<@ast::meta_item> {\n \n     let items = attr::find_meta_items_by_name(items, name);\n     vec::last_opt(items)\n }\n \n-pub fn last_meta_item_value_str_by_name(items: ~[@ast::meta_item], name: ~str)\n-                                     -> Option<~str> {\n+pub fn last_meta_item_value_str_by_name(items: ~[@ast::meta_item], name: &str)\n+                                     -> Option<@~str> {\n \n     match last_meta_item_by_name(items, name) {\n-      Some(item) => match attr::get_meta_item_value_str(item) {\n-        Some(ref value) => Some((*value)),\n+        Some(item) => {\n+            match attr::get_meta_item_value_str(item) {\n+                Some(value) => Some(value),\n+                None => None\n+            }\n+        },\n         None => None\n-      },\n-      None => None\n     }\n }\n \n-pub fn last_meta_item_list_by_name(items: ~[@ast::meta_item], name: ~str)\n+pub fn last_meta_item_list_by_name(items: ~[@ast::meta_item], name: &str)\n     -> Option<~[@ast::meta_item]> {\n \n     match last_meta_item_by_name(items, name) {\n@@ -255,20 +260,11 @@ pub fn last_meta_item_list_by_name(items: ~[@ast::meta_item], name: ~str)\n /* Higher-level applications */\n \n pub fn sort_meta_items(+items: ~[@ast::meta_item]) -> ~[@ast::meta_item] {\n-    pure fn lteq(ma: &@ast::meta_item, mb: &@ast::meta_item) -> bool {\n-        pure fn key(m: &ast::meta_item) -> ~str {\n-            match m.node {\n-              ast::meta_word(ref name) => (*name),\n-              ast::meta_name_value(ref name, _) => (*name),\n-              ast::meta_list(ref name, _) => (*name)\n-            }\n-        }\n-        key(*ma) <= key(*mb)\n-    }\n-\n     // This is sort of stupid here, converting to a vec of mutables and back\n     let mut v = items;\n-    std::sort::quick_sort(v, lteq);\n+    do std::sort::quick_sort(v) |ma, mb| {\n+        get_meta_item_name(*ma) <= get_meta_item_name(*mb)\n+    }\n \n     // There doesn't seem to be a more optimal way to do this\n     do v.map |&m| {\n@@ -282,14 +278,14 @@ pub fn sort_meta_items(+items: ~[@ast::meta_item]) -> ~[@ast::meta_item] {\n     }\n }\n \n-pub fn remove_meta_items_by_name(items: ~[@ast::meta_item], name: ~str) ->\n+pub fn remove_meta_items_by_name(items: ~[@ast::meta_item], name: &str) ->\n    ~[@ast::meta_item] {\n \n     return vec::filter_mapped(items, |item| {\n-        if get_meta_item_name(*item) != name {\n-            option::Some(*item)\n+        if name != *get_meta_item_name(*item) {\n+            Some(*item)\n         } else {\n-            option::None\n+            None\n         }\n     });\n }\n@@ -310,21 +306,21 @@ pub fn find_linkage_metas(attrs: &[ast::attribute]) -> ~[@ast::meta_item] {\n pub fn foreign_abi(attrs: ~[ast::attribute])\n                 -> Either<~str, ast::foreign_abi> {\n     return match attr::first_attr_value_str_by_name(attrs, ~\"abi\") {\n-      option::None => {\n-        either::Right(ast::foreign_abi_cdecl)\n-      }\n-      option::Some(~\"rust-intrinsic\") => {\n-        either::Right(ast::foreign_abi_rust_intrinsic)\n-      }\n-      option::Some(~\"cdecl\") => {\n-        either::Right(ast::foreign_abi_cdecl)\n-      }\n-      option::Some(~\"stdcall\") => {\n-        either::Right(ast::foreign_abi_stdcall)\n-      }\n-      option::Some(ref t) => {\n-        either::Left(~\"unsupported abi: \" + (*t))\n-      }\n+        None => {\n+            Right(ast::foreign_abi_cdecl)\n+        }\n+        Some(@~\"rust-intrinsic\") => {\n+            Right(ast::foreign_abi_rust_intrinsic)\n+        }\n+        Some(@~\"cdecl\") => {\n+            Right(ast::foreign_abi_cdecl)\n+        }\n+        Some(@~\"stdcall\") => {\n+            Right(ast::foreign_abi_stdcall)\n+        }\n+        Some(t) => {\n+            Left(~\"unsupported abi: \" + *t)\n+        }\n     };\n }\n \n@@ -371,9 +367,9 @@ pub fn require_unique_names(diagnostic: span_handler,\n         let name = get_meta_item_name(*meta);\n \n         // FIXME: How do I silence the warnings? --pcw (#2619)\n-        if !set.insert(copy name) {\n+        if !set.insert(name) {\n             diagnostic.span_fatal(meta.span,\n-                                  fmt!(\"duplicate meta item `%s`\", name));\n+                                  fmt!(\"duplicate meta item `%s`\", *name));\n         }\n     }\n }"}, {"sha": "9ceaebe6dd1de00b09aa9b2f6c693abc654a24b2", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2b754788d5cef4b03eee0af6137e0195ef5680c/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b754788d5cef4b03eee0af6137e0195ef5680c/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=a2b754788d5cef4b03eee0af6137e0195ef5680c", "patch": "@@ -114,7 +114,7 @@ pub fn expand_auto_encode(\n     in_items: ~[@ast::item]\n ) -> ~[@ast::item] {\n     fn is_auto_encode(a: &ast::attribute) -> bool {\n-        attr::get_attr_name(a) == ~\"auto_encode\"\n+        *attr::get_attr_name(a) == ~\"auto_encode\"\n     }\n \n     fn filter_attrs(item: @ast::item) -> @ast::item {\n@@ -169,7 +169,7 @@ pub fn expand_auto_decode(\n     in_items: ~[@ast::item]\n ) -> ~[@ast::item] {\n     fn is_auto_decode(a: &ast::attribute) -> bool {\n-        attr::get_attr_name(a) == ~\"auto_decode\"\n+        *attr::get_attr_name(a) == ~\"auto_decode\"\n     }\n \n     fn filter_attrs(item: @ast::item) -> @ast::item {"}, {"sha": "3cecf857c915ada7779a128e66dc55d81cd26522", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2b754788d5cef4b03eee0af6137e0195ef5680c/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b754788d5cef4b03eee0af6137e0195ef5680c/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=a2b754788d5cef4b03eee0af6137e0195ef5680c", "patch": "@@ -102,11 +102,11 @@ pub fn expand_mod_items(exts: SyntaxExtensions, cx: ext_ctxt,\n         do vec::foldr(item.attrs, ~[*item]) |attr, items| {\n             let mname = attr::get_attr_name(attr);\n \n-            match exts.find(&mname) {\n+            match exts.find(&*mname) {\n               None | Some(NormalTT(_)) | Some(ItemTT(*)) => items,\n               Some(ItemDecorator(dec_fn)) => {\n                   cx.bt_push(ExpandedFrom({call_site: attr.span,\n-                                           callie: {name: copy mname,\n+                                           callie: {name: /*bad*/ copy *mname,\n                                                     span: None}}));\n                   let r = dec_fn(cx, attr.span, attr.node.value, items);\n                   cx.bt_pop();"}, {"sha": "a16392e1da2909bea46207e08cbb20925f453988", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a2b754788d5cef4b03eee0af6137e0195ef5680c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b754788d5cef4b03eee0af6137e0195ef5680c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=a2b754788d5cef4b03eee0af6137e0195ef5680c", "patch": "@@ -3247,11 +3247,11 @@ pub impl Parser {\n         // on the mod, then we'll go and suck in another file and merge\n         // its contents\n         match ::attr::first_attr_value_str_by_name(outer_attrs, ~\"merge\") {\n-            Some(ref path) => {\n+            Some(path) => {\n                 let prefix = Path(\n                     self.sess.cm.span_to_filename(copy self.span));\n                 let prefix = prefix.dir_path();\n-                let path = Path((*path));\n+                let path = Path(copy *path);\n                 let (new_mod_item, new_attrs) = self.eval_src_mod_from_path(\n                     prefix, path, ~[], id_span);\n \n@@ -3280,7 +3280,7 @@ pub impl Parser {\n         let file_path = match ::attr::first_attr_value_str_by_name(\n             attrs, ~\"path\") {\n \n-            Some(ref d) => (*d),\n+            Some(d) => copy *d,\n             None => copy *default_path\n         };\n         self.mod_path_stack.push(file_path)\n@@ -3300,10 +3300,10 @@ pub impl Parser {\n         let default_path = self.sess.interner.get(id) + ~\".rs\";\n         let file_path = match ::attr::first_attr_value_str_by_name(\n             outer_attrs, ~\"path\") {\n-            Some(ref d) => {\n-                let path = Path(*d);\n+            Some(d) => {\n+                let path = Path(copy *d);\n                 if !path.is_absolute {\n-                    mod_path.push(*d)\n+                    mod_path.push(copy *d)\n                 } else {\n                     path\n                 }\n@@ -3337,7 +3337,7 @@ pub impl Parser {\n \n         fn cdir_path_opt(default: ~str, attrs: ~[ast::attribute]) -> ~str {\n             match ::attr::first_attr_value_str_by_name(attrs, ~\"path\") {\n-                Some(ref d) => (*d),\n+                Some(d) => copy *d,\n                 None => default\n             }\n         }"}, {"sha": "a23c55e063b775cc09c3317e00a19a00e206761b", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a2b754788d5cef4b03eee0af6137e0195ef5680c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b754788d5cef4b03eee0af6137e0195ef5680c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=a2b754788d5cef4b03eee0af6137e0195ef5680c", "patch": "@@ -897,7 +897,7 @@ pub fn print_attribute(s: @ps, attr: ast::attribute) {\n     if attr.node.is_sugared_doc {\n         let meta = attr::attr_meta(attr);\n         let comment = attr::get_meta_item_value_str(meta).get();\n-        word(s.s, comment);\n+        word(s.s, *comment);\n     } else {\n         word(s.s, ~\"#[\");\n         print_meta_item(s, @attr.node.value);\n@@ -1816,14 +1816,14 @@ pub fn print_type_params(s: @ps, &&params: ~[ast::ty_param]) {\n pub fn print_meta_item(s: @ps, &&item: @ast::meta_item) {\n     ibox(s, indent_unit);\n     match item.node {\n-      ast::meta_word(ref name) => word(s.s, (*name)),\n+      ast::meta_word(ref name) => word(s.s, *name),\n       ast::meta_name_value(ref name, value) => {\n-        word_space(s, (*name));\n+        word_space(s, *name);\n         word_space(s, ~\"=\");\n         print_literal(s, @value);\n       }\n       ast::meta_list(ref name, ref items) => {\n-        word(s.s, (*name));\n+        word(s.s, *name);\n         popen(s);\n         commasep(\n             s,"}]}