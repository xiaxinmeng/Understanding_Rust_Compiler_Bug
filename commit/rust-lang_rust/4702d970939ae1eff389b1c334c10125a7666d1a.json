{"sha": "4702d970939ae1eff389b1c334c10125a7666d1a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3MDJkOTcwOTM5YWUxZWZmMzg5YjFjMzM0YzEwMTI1YTc2NjZkMWE=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-12-08T04:30:37Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-12-08T04:30:37Z"}, "message": "Flatten 'interpreter' mod tree into the root.", "tree": {"sha": "73ac6277cb5216becbbbd242030ef9b91e9ddd2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73ac6277cb5216becbbbd242030ef9b91e9ddd2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4702d970939ae1eff389b1c334c10125a7666d1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4702d970939ae1eff389b1c334c10125a7666d1a", "html_url": "https://github.com/rust-lang/rust/commit/4702d970939ae1eff389b1c334c10125a7666d1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4702d970939ae1eff389b1c334c10125a7666d1a/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac21ef4cd95ba2ffa8014a31d4544f339610e9f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac21ef4cd95ba2ffa8014a31d4544f339610e9f3", "html_url": "https://github.com/rust-lang/rust/commit/ac21ef4cd95ba2ffa8014a31d4544f339610e9f3"}], "stats": {"total": 173, "additions": 93, "deletions": 80}, "files": [{"sha": "7a0285da440edd85791a313356fbab3af63692a8", "filename": "src/cast.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4702d970939ae1eff389b1c334c10125a7666d1a/src%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4702d970939ae1eff389b1c334c10125a7666d1a/src%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcast.rs?ref=4702d970939ae1eff389b1c334c10125a7666d1a", "previous_filename": "src/interpreter/cast.rs"}, {"sha": "ab6bda12677e056a0347d074aa661964800ffa6d", "filename": "src/eval_context.rs", "status": "renamed", "additions": 66, "deletions": 56, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/4702d970939ae1eff389b1c334c10125a7666d1a/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4702d970939ae1eff389b1c334c10125a7666d1a/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=4702d970939ae1eff389b1c334c10125a7666d1a", "patch": "@@ -1,6 +1,9 @@\n-use rustc::middle::const_val::ConstVal;\n+use std::cell::Ref;\n+use std::collections::HashMap;\n+\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::definitions::DefPathData;\n+use rustc::middle::const_val::ConstVal;\n use rustc::mir;\n use rustc::traits::Reveal;\n use rustc::ty::layout::{self, Layout, Size};\n@@ -12,39 +15,32 @@ use syntax::codemap::{self, DUMMY_SP};\n use error::{EvalError, EvalResult};\n use memory::{Memory, Pointer};\n use primval::{self, PrimVal, PrimValKind};\n-pub use self::value::Value;\n \n-use std::collections::HashMap;\n-use std::cell::Ref;\n-\n-mod step;\n-mod terminator;\n-mod cast;\n-mod vtable;\n-mod value;\n+// FIXME(solson): Remove this.\n+pub use value::Value;\n \n pub type MirRef<'tcx> = Ref<'tcx, mir::Mir<'tcx>>;\n \n pub struct EvalContext<'a, 'tcx: 'a> {\n     /// The results of the type checker, from rustc.\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub(super) tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     /// The virtual memory system.\n-    memory: Memory<'a, 'tcx>,\n+    pub(super) memory: Memory<'a, 'tcx>,\n \n     /// Precomputed statics, constants and promoteds.\n-    globals: HashMap<GlobalId<'tcx>, Global<'tcx>>,\n+    pub(super) globals: HashMap<GlobalId<'tcx>, Global<'tcx>>,\n \n     /// The virtual call stack.\n-    stack: Vec<Frame<'tcx>>,\n+    pub(super) stack: Vec<Frame<'tcx>>,\n \n     /// The maximum number of stack frames allowed\n-    stack_limit: usize,\n+    pub(super) stack_limit: usize,\n \n     /// The maximum number of operations that may be executed.\n     /// This prevents infinite loops and huge computations from freezing up const eval.\n     /// Remove once halting problem is solved.\n-    steps_remaining: u64,\n+    pub(super) steps_remaining: u64,\n }\n \n /// A stack frame.\n@@ -132,14 +128,16 @@ pub enum LvalueExtra {\n /// Uniquely identifies a specific constant or static\n pub struct GlobalId<'tcx> {\n     /// the def id of the constant/static or in case of promoteds, the def id of the function they belong to\n-    def_id: DefId,\n+    pub(super) def_id: DefId,\n+\n     /// In case of statics and constants this is `Substs::empty()`, so only promoteds and associated\n     /// constants actually have something useful here. We could special case statics and constants,\n     /// but that would only require more branching when working with constants, and not bring any\n     /// real benefits.\n-    substs: &'tcx Substs<'tcx>,\n-    /// this `Option` is `Some` for promoted constants\n-    promoted: Option<mir::Promoted>,\n+    pub(super) substs: &'tcx Substs<'tcx>,\n+\n+    /// The promoted index for this global, if it is a promoted.\n+    pub(super) promoted: Option<mir::Promoted>,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -150,7 +148,7 @@ pub struct Global<'tcx> {\n }\n \n impl<'tcx> Global<'tcx> {\n-    fn uninitialized(ty: Ty<'tcx>) -> Self {\n+    pub(super) fn uninitialized(ty: Ty<'tcx>) -> Self {\n         Global {\n             data: None,\n             mutable: true,\n@@ -228,15 +226,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         &self.stack\n     }\n \n-    fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value> {\n+    pub(super) fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value> {\n         // FIXME: cache these allocs\n         let ptr = self.memory.allocate(s.len() as u64, 1)?;\n         self.memory.write_bytes(ptr, s.as_bytes())?;\n         self.memory.freeze(ptr.alloc_id)?;\n         Ok(Value::ByValPair(PrimVal::from_ptr(ptr), PrimVal::from_uint(s.len() as u64)))\n     }\n \n-    fn const_to_value(&mut self, const_val: &ConstVal) -> EvalResult<'tcx, Value> {\n+    pub(super) fn const_to_value(&mut self, const_val: &ConstVal) -> EvalResult<'tcx, Value> {\n         use rustc::middle::const_val::ConstVal::*;\n         use rustc_const_math::ConstFloat;\n \n@@ -271,7 +269,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(Value::ByVal(primval))\n     }\n \n-    fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n+    pub(super) fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n         // generics are weird, don't run this function on a generic\n         assert!(!ty.needs_subst());\n         ty.is_sized(self.tcx, &self.tcx.empty_parameter_environment(), DUMMY_SP)\n@@ -291,15 +289,19 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.tcx.normalize_associated_type(&substituted)\n     }\n \n-    fn type_size(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<u64>> {\n+    pub(super) fn type_size(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<u64>> {\n         self.type_size_with_substs(ty, self.substs())\n     }\n \n-    fn type_align(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, u64> {\n+    pub(super) fn type_align(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, u64> {\n         self.type_align_with_substs(ty, self.substs())\n     }\n \n-    fn type_size_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> EvalResult<'tcx, Option<u64>> {\n+    fn type_size_with_substs(\n+        &self,\n+        ty: Ty<'tcx>,\n+        substs: &'tcx Substs<'tcx>,\n+    ) -> EvalResult<'tcx, Option<u64>> {\n         let layout = self.type_layout_with_substs(ty, substs)?;\n         if layout.is_unsized() {\n             Ok(None)\n@@ -312,7 +314,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.type_layout_with_substs(ty, substs).map(|layout| layout.align(&self.tcx.data_layout).abi())\n     }\n \n-    fn type_layout(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, &'tcx Layout> {\n+    pub(super) fn type_layout(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, &'tcx Layout> {\n         self.type_layout_with_substs(ty, self.substs())\n     }\n \n@@ -362,7 +364,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn pop_stack_frame(&mut self) -> EvalResult<'tcx, ()> {\n+    pub(super) fn pop_stack_frame(&mut self) -> EvalResult<'tcx, ()> {\n         ::log_settings::settings().indentation -= 1;\n         let frame = self.stack.pop().expect(\"tried to pop a stack frame, but there were none\");\n         match frame.return_to_block {\n@@ -433,7 +435,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     /// Applies the binary operation `op` to the two operands and writes a tuple of the result\n     /// and a boolean signifying the potential overflow to the destination.\n-    fn intrinsic_with_overflow(\n+    pub(super) fn intrinsic_with_overflow(\n         &mut self,\n         op: mir::BinOp,\n         left: &mir::Operand<'tcx>,\n@@ -448,7 +450,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     /// Applies the binary operation `op` to the arguments and writes the result to the\n     /// destination. Returns `true` if the operation overflowed.\n-    fn intrinsic_overflowing(\n+    pub(super) fn intrinsic_overflowing(\n         &mut self,\n         op: mir::BinOp,\n         left: &mir::Operand<'tcx>,\n@@ -483,7 +485,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     ///\n     /// There is no separate `eval_rvalue` function. Instead, the code for handling each rvalue\n     /// type writes its results directly into the memory specified by the lvalue.\n-    fn eval_rvalue_into_lvalue(\n+    pub(super) fn eval_rvalue_into_lvalue(\n         &mut self,\n         rvalue: &mir::Rvalue<'tcx>,\n         lvalue: &mir::Lvalue<'tcx>,\n@@ -739,7 +741,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn nonnull_offset_and_ty(&self, ty: Ty<'tcx>, nndiscr: u64, discrfield: &[u32]) -> EvalResult<'tcx, (Size, Ty<'tcx>)> {\n+    pub(super) fn nonnull_offset_and_ty(\n+        &self,\n+        ty: Ty<'tcx>,\n+        nndiscr: u64,\n+        discrfield: &[u32],\n+    ) -> EvalResult<'tcx, (Size, Ty<'tcx>)> {\n         // Skip the constant 0 at the start meant for LLVM GEP and the outer non-null variant\n         let path = discrfield.iter().skip(2).map(|&i| i as usize);\n \n@@ -827,13 +834,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn eval_operand_to_primval(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, PrimVal> {\n+    pub(super) fn eval_operand_to_primval(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, PrimVal> {\n         let value = self.eval_operand(op)?;\n         let ty = self.operand_ty(op);\n         self.value_to_primval(value, ty)\n     }\n \n-    fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, Value> {\n+    pub(super) fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, Value> {\n         use rustc::mir::Operand::*;\n         match *op {\n             Consume(ref lvalue) => self.eval_and_read_lvalue(lvalue),\n@@ -872,7 +879,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn eval_and_read_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Value> {\n+    pub(super) fn eval_and_read_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Value> {\n         if let mir::Lvalue::Projection(ref proj) = *lvalue {\n             if let mir::Lvalue::Local(index) = proj.base {\n                 if let Some(Value::ByValPair(a, b)) = self.frame().get_local(index) {\n@@ -904,7 +911,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn eval_lvalue(&mut self, mir_lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Lvalue<'tcx>> {\n+    pub(super) fn eval_lvalue(&mut self, mir_lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Lvalue<'tcx>> {\n         use rustc::mir::Lvalue::*;\n         let lvalue = match *mir_lvalue {\n             Local(mir::RETURN_POINTER) => self.frame().return_lvalue,\n@@ -1086,11 +1093,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(Lvalue::Ptr { ptr: ptr, extra: extra })\n     }\n \n-    fn lvalue_ty(&self, lvalue: &mir::Lvalue<'tcx>) -> Ty<'tcx> {\n+    pub(super) fn lvalue_ty(&self, lvalue: &mir::Lvalue<'tcx>) -> Ty<'tcx> {\n         self.monomorphize(lvalue.ty(&self.mir(), self.tcx).to_ty(self.tcx), self.substs())\n     }\n \n-    fn operand_ty(&self, operand: &mir::Operand<'tcx>) -> Ty<'tcx> {\n+    pub(super) fn operand_ty(&self, operand: &mir::Operand<'tcx>) -> Ty<'tcx> {\n         self.monomorphize(operand.ty(&self.mir(), self.tcx), self.substs())\n     }\n \n@@ -1101,7 +1108,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn force_allocation(&mut self, lvalue: Lvalue<'tcx>) -> EvalResult<'tcx, Lvalue<'tcx>> {\n+    pub(super) fn force_allocation(\n+        &mut self,\n+        lvalue: Lvalue<'tcx>,\n+    ) -> EvalResult<'tcx, Lvalue<'tcx>> {\n         let new_lvalue = match lvalue {\n             Lvalue::Local { frame, local } => {\n                 match self.stack[frame].get_local(local) {\n@@ -1146,14 +1156,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     /// ensures this Value is not a ByRef\n-    fn follow_by_ref_value(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n+    pub(super) fn follow_by_ref_value(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         match value {\n             Value::ByRef(ptr) => self.read_value(ptr, ty),\n             other => Ok(other),\n         }\n     }\n \n-    fn value_to_primval(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n+    pub(super) fn value_to_primval(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n         match self.follow_by_ref_value(value, ty)? {\n             Value::ByRef(_) => bug!(\"follow_by_ref_value can't result in `ByRef`\"),\n \n@@ -1166,7 +1176,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn write_primval(\n+    pub(super) fn write_primval(\n         &mut self,\n         dest: Lvalue<'tcx>,\n         val: PrimVal,\n@@ -1194,7 +1204,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn write_value(\n+    pub(super) fn write_value(\n         &mut self,\n         src_val: Value,\n         dest: Lvalue<'tcx>,\n@@ -1277,7 +1287,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn write_value_to_ptr(\n+    pub(super) fn write_value_to_ptr(\n         &mut self,\n         value: Value,\n         dest: Pointer,\n@@ -1293,7 +1303,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn write_pair_to_ptr(\n+    pub(super) fn write_pair_to_ptr(\n         &mut self,\n         a: PrimVal,\n         b: PrimVal,\n@@ -1312,7 +1322,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn ty_to_primval_kind(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimValKind> {\n+    pub(super) fn ty_to_primval_kind(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimValKind> {\n         use syntax::ast::FloatTy;\n \n         let kind = match ty.sty {\n@@ -1396,7 +1406,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn read_value(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n+    pub(super) fn read_value(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         if let Some(val) = self.try_read_value(ptr, ty)? {\n             Ok(val)\n         } else {\n@@ -1484,19 +1494,19 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(Some(Value::ByVal(val)))\n     }\n \n-    fn frame(&self) -> &Frame<'tcx> {\n+    pub(super) fn frame(&self) -> &Frame<'tcx> {\n         self.stack.last().expect(\"no call frames exist\")\n     }\n \n-    pub fn frame_mut(&mut self) -> &mut Frame<'tcx> {\n+    pub(super) fn frame_mut(&mut self) -> &mut Frame<'tcx> {\n         self.stack.last_mut().expect(\"no call frames exist\")\n     }\n \n-    fn mir(&self) -> MirRef<'tcx> {\n+    pub(super) fn mir(&self) -> MirRef<'tcx> {\n         Ref::clone(&self.frame().mir)\n     }\n \n-    fn substs(&self) -> &'tcx Substs<'tcx> {\n+    pub(super) fn substs(&self) -> &'tcx Substs<'tcx> {\n         self.frame().substs\n     }\n \n@@ -1585,7 +1595,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn dump_local(&self, lvalue: Lvalue<'tcx>) {\n+    pub(super) fn dump_local(&self, lvalue: Lvalue<'tcx>) {\n         if let Lvalue::Local { frame, local } = lvalue {\n             if let Some(val) = self.stack[frame].get_local(local) {\n                 match val {\n@@ -1667,15 +1677,15 @@ impl<'tcx> Lvalue<'tcx> {\n         Lvalue::Ptr { ptr: ptr, extra: LvalueExtra::None }\n     }\n \n-    fn to_ptr_and_extra(self) -> (Pointer, LvalueExtra) {\n+    pub(super) fn to_ptr_and_extra(self) -> (Pointer, LvalueExtra) {\n         match self {\n             Lvalue::Ptr { ptr, extra } => (ptr, extra),\n             _ => bug!(\"to_ptr_and_extra: expected Lvalue::Ptr, got {:?}\", self),\n \n         }\n     }\n \n-    fn to_ptr(self) -> Pointer {\n+    pub(super) fn to_ptr(self) -> Pointer {\n         let (ptr, extra) = self.to_ptr_and_extra();\n         assert_eq!(extra, LvalueExtra::None);\n         ptr\n@@ -1775,7 +1785,7 @@ pub fn run_mir_passes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n \n // TODO(solson): Upstream these methods into rustc::ty::layout.\n \n-trait IntegerExt {\n+pub(super) trait IntegerExt {\n     fn size(self) -> Size;\n }\n ", "previous_filename": "src/interpreter/mod.rs"}, {"sha": "a54839b45375d4039f665a7d06bd5b12dea1985b", "filename": "src/lib.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4702d970939ae1eff389b1c334c10125a7666d1a/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4702d970939ae1eff389b1c334c10125a7666d1a/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=4702d970939ae1eff389b1c334c10125a7666d1a", "patch": "@@ -1,36 +1,44 @@\n #![feature(\n     btree_range,\n+    cell_extras,\n     collections,\n     collections_bound,\n-    rustc_private,\n     pub_restricted,\n-    cell_extras,\n+    rustc_private,\n )]\n \n // From rustc.\n-#[macro_use] extern crate rustc;\n+#[macro_use]\n+extern crate log;\n+extern crate log_settings;\n+#[macro_use]\n+extern crate rustc;\n extern crate rustc_borrowck;\n+extern crate rustc_const_math;\n extern crate rustc_data_structures;\n extern crate rustc_mir;\n-extern crate rustc_const_math;\n extern crate syntax;\n-#[macro_use] extern crate log;\n-extern crate log_settings;\n \n // From crates.io.\n extern crate byteorder;\n \n+mod cast;\n mod error;\n-mod interpreter;\n+mod eval_context;\n mod memory;\n mod primval;\n+mod step;\n+mod terminator;\n+mod value;\n+mod vtable;\n+\n \n pub use error::{\n     EvalError,\n     EvalResult,\n };\n \n-pub use interpreter::{\n+pub use eval_context::{\n     EvalContext,\n     Frame,\n     Lvalue,"}, {"sha": "fba8e48731c805396112490eb61d32e7318e4c96", "filename": "src/step.rs", "status": "renamed", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4702d970939ae1eff389b1c334c10125a7666d1a/src%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4702d970939ae1eff389b1c334c10125a7666d1a/src%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstep.rs?ref=4702d970939ae1eff389b1c334c10125a7666d1a", "patch": "@@ -2,21 +2,16 @@\n //!\n //! The main entry point is the `step` method.\n \n-use super::{\n-    GlobalId,\n-    EvalContext,\n-    Lvalue,\n-    StackPopCleanup,\n-    Global,\n-    MirRef,\n-};\n-use error::{EvalResult, EvalError};\n-use rustc::mir;\n-use rustc::ty::{subst, self};\n+use std::cell::Ref;\n+\n use rustc::hir::def_id::DefId;\n use rustc::hir;\n use rustc::mir::visit::{Visitor, LvalueContext};\n-use std::cell::Ref;\n+use rustc::mir;\n+use rustc::ty::{subst, self};\n+\n+use error::{EvalResult, EvalError};\n+use eval_context::{GlobalId, EvalContext, Lvalue, StackPopCleanup, Global, MirRef};\n use syntax::codemap::Span;\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {", "previous_filename": "src/interpreter/step.rs"}, {"sha": "75ca778d39cd05e41016fcc93b3c43660ce4e152", "filename": "src/terminator/intrinsics.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4702d970939ae1eff389b1c334c10125a7666d1a/src%2Fterminator%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4702d970939ae1eff389b1c334c10125a7666d1a/src%2Fterminator%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fintrinsics.rs?ref=4702d970939ae1eff389b1c334c10125a7666d1a", "patch": "@@ -5,9 +5,9 @@ use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty};\n \n use error::{EvalError, EvalResult};\n-use interpreter::value::Value;\n-use interpreter::{EvalContext, Lvalue, LvalueExtra};\n+use eval_context::{EvalContext, Lvalue, LvalueExtra};\n use primval::{self, PrimVal, PrimValKind};\n+use value::Value;\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(super) fn call_intrinsic(", "previous_filename": "src/interpreter/terminator/intrinsics.rs"}, {"sha": "d47166651c83bca11e347bbb21ea0cfd89ab80a4", "filename": "src/terminator/mod.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4702d970939ae1eff389b1c334c10125a7666d1a/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4702d970939ae1eff389b1c334c10125a7666d1a/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=4702d970939ae1eff389b1c334c10125a7666d1a", "patch": "@@ -9,10 +9,10 @@ use syntax::codemap::{DUMMY_SP, Span};\n use syntax::{ast, attr};\n \n use error::{EvalError, EvalResult};\n+use eval_context::{EvalContext, Lvalue, IntegerExt, StackPopCleanup, LvalueExtra, monomorphize_field_ty};\n use memory::Pointer;\n use primval::PrimVal;\n-use super::{EvalContext, Lvalue, IntegerExt, StackPopCleanup, LvalueExtra, monomorphize_field_ty};\n-use super::value::Value;\n+use value::Value;\n \n mod intrinsics;\n ", "previous_filename": "src/interpreter/terminator/mod.rs"}, {"sha": "f31f1ca24bc3c67b3ea26af78a7f372946306913", "filename": "src/value.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4702d970939ae1eff389b1c334c10125a7666d1a/src%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4702d970939ae1eff389b1c334c10125a7666d1a/src%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue.rs?ref=4702d970939ae1eff389b1c334c10125a7666d1a", "previous_filename": "src/interpreter/value.rs"}, {"sha": "89db8e111e40ce2dace357dfc4f8c88ee874e059", "filename": "src/vtable.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4702d970939ae1eff389b1c334c10125a7666d1a/src%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4702d970939ae1eff389b1c334c10125a7666d1a/src%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvtable.rs?ref=4702d970939ae1eff389b1c334c10125a7666d1a", "previous_filename": "src/interpreter/vtable.rs"}]}