{"sha": "cb5e4292911f3651aa3453ad1d81b2794f4b2583", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiNWU0MjkyOTExZjM2NTFhYTM0NTNhZDFkODFiMjc5NGY0YjI1ODM=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-03-12T00:44:02Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-03-17T02:57:42Z"}, "message": "move some tests back to libcollections", "tree": {"sha": "e2b57d316eeee06ce179b1553d22e4dc0018b9e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2b57d316eeee06ce179b1553d22e4dc0018b9e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb5e4292911f3651aa3453ad1d81b2794f4b2583", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb5e4292911f3651aa3453ad1d81b2794f4b2583", "html_url": "https://github.com/rust-lang/rust/commit/cb5e4292911f3651aa3453ad1d81b2794f4b2583", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb5e4292911f3651aa3453ad1d81b2794f4b2583/comments", "author": null, "committer": null, "parents": [{"sha": "e09bf82a31fd5ae1df8cb2d775f372d41ecf5593", "url": "https://api.github.com/repos/rust-lang/rust/commits/e09bf82a31fd5ae1df8cb2d775f372d41ecf5593", "html_url": "https://github.com/rust-lang/rust/commit/e09bf82a31fd5ae1df8cb2d775f372d41ecf5593"}], "stats": {"total": 1076, "additions": 565, "deletions": 511}, "files": [{"sha": "0d1067a87e006f1ff3c58d5b66321f20b049aaf2", "filename": "mk/tests.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb5e4292911f3651aa3453ad1d81b2794f4b2583/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cb5e4292911f3651aa3453ad1d81b2794f4b2583/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=cb5e4292911f3651aa3453ad1d81b2794f4b2583", "patch": "@@ -22,7 +22,7 @@ $(eval $(call RUST_CRATE,coretest))\n DEPS_collectionstest :=\n $(eval $(call RUST_CRATE,collectionstest))\n \n-TEST_TARGET_CRATES = $(filter-out collections core unicode,$(TARGET_CRATES)) \\\n+TEST_TARGET_CRATES = $(filter-out core unicode,$(TARGET_CRATES)) \\\n \t\t\t\t\t\t\t\t\t\t collectionstest coretest\n TEST_DOC_CRATES = $(DOC_CRATES)\n TEST_HOST_CRATES = $(filter-out rustc_typeck rustc_borrowck rustc_resolve rustc_trans rustc_lint,\\"}, {"sha": "b75f346c188fb28da7d8145e69d9284629aea5aa", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb5e4292911f3651aa3453ad1d81b2794f4b2583/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5e4292911f3651aa3453ad1d81b2794f4b2583/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=cb5e4292911f3651aa3453ad1d81b2794f4b2583", "patch": "@@ -47,6 +47,9 @@ extern crate core;\n extern crate unicode;\n extern crate alloc;\n \n+#[cfg(test)] #[macro_use] extern crate std;\n+#[cfg(test)] extern crate test;\n+\n pub use binary_heap::BinaryHeap;\n pub use bit_vec::BitVec;\n pub use bit_set::BitSet;\n@@ -131,6 +134,7 @@ pub mod btree_set {\n #[doc(hidden)]\n pub fn fixme_14344_be_sure_to_link_to_collections() {}\n \n+#[cfg(not(test))]\n mod std {\n     pub use core::ops;      // RangeFull\n }"}, {"sha": "9e0a6d0438100b0d7e9382197b394eba90f0f2e3", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/cb5e4292911f3651aa3453ad1d81b2794f4b2583/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5e4292911f3651aa3453ad1d81b2794f4b2583/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=cb5e4292911f3651aa3453ad1d81b2794f4b2583", "patch": "@@ -938,3 +938,194 @@ impl<A: Hash> Hash for LinkedList<A> {\n         }\n     }\n }\n+\n+#[cfg(test)]\n+mod test {\n+    use std::clone::Clone;\n+    use std::iter::{Iterator, IteratorExt};\n+    use std::option::Option::{Some, None, self};\n+    use std::rand;\n+    use std::thread;\n+    use std::vec::Vec;\n+\n+    use super::{LinkedList, Node};\n+\n+    #[cfg(test)]\n+    fn list_from<T: Clone>(v: &[T]) -> LinkedList<T> {\n+        v.iter().cloned().collect()\n+    }\n+\n+    pub fn check_links<T>(list: &LinkedList<T>) {\n+        let mut len = 0;\n+        let mut last_ptr: Option<&Node<T>> = None;\n+        let mut node_ptr: &Node<T>;\n+        match list.list_head {\n+            None => { assert_eq!(0, list.length); return }\n+            Some(ref node) => node_ptr = &**node,\n+        }\n+        loop {\n+            match (last_ptr, node_ptr.prev.resolve_immut()) {\n+                (None   , None      ) => {}\n+                (None   , _         ) => panic!(\"prev link for list_head\"),\n+                (Some(p), Some(pptr)) => {\n+                    assert_eq!(p as *const Node<T>, pptr as *const Node<T>);\n+                }\n+                _ => panic!(\"prev link is none, not good\"),\n+            }\n+            match node_ptr.next {\n+                Some(ref next) => {\n+                    last_ptr = Some(node_ptr);\n+                    node_ptr = &**next;\n+                    len += 1;\n+                }\n+                None => {\n+                    len += 1;\n+                    break;\n+                }\n+            }\n+        }\n+        assert_eq!(len, list.length);\n+    }\n+\n+    #[test]\n+    fn test_append() {\n+        // Empty to empty\n+        {\n+            let mut m = LinkedList::<i32>::new();\n+            let mut n = LinkedList::new();\n+            m.append(&mut n);\n+            check_links(&m);\n+            assert_eq!(m.len(), 0);\n+            assert_eq!(n.len(), 0);\n+        }\n+        // Non-empty to empty\n+        {\n+            let mut m = LinkedList::new();\n+            let mut n = LinkedList::new();\n+            n.push_back(2);\n+            m.append(&mut n);\n+            check_links(&m);\n+            assert_eq!(m.len(), 1);\n+            assert_eq!(m.pop_back(), Some(2));\n+            assert_eq!(n.len(), 0);\n+            check_links(&m);\n+        }\n+        // Empty to non-empty\n+        {\n+            let mut m = LinkedList::new();\n+            let mut n = LinkedList::new();\n+            m.push_back(2);\n+            m.append(&mut n);\n+            check_links(&m);\n+            assert_eq!(m.len(), 1);\n+            assert_eq!(m.pop_back(), Some(2));\n+            check_links(&m);\n+        }\n+\n+        // Non-empty to non-empty\n+        let v = vec![1,2,3,4,5];\n+        let u = vec![9,8,1,2,3,4,5];\n+        let mut m = list_from(&v);\n+        let mut n = list_from(&u);\n+        m.append(&mut n);\n+        check_links(&m);\n+        let mut sum = v;\n+        sum.push_all(&u);\n+        assert_eq!(sum.len(), m.len());\n+        for elt in sum {\n+            assert_eq!(m.pop_front(), Some(elt))\n+        }\n+        assert_eq!(n.len(), 0);\n+        // let's make sure it's working properly, since we\n+        // did some direct changes to private members\n+        n.push_back(3);\n+        assert_eq!(n.len(), 1);\n+        assert_eq!(n.pop_front(), Some(3));\n+        check_links(&n);\n+    }\n+\n+    #[test]\n+    fn test_insert_prev() {\n+        let mut m = list_from(&[0,2,4,6,8]);\n+        let len = m.len();\n+        {\n+            let mut it = m.iter_mut();\n+            it.insert_next(-2);\n+            loop {\n+                match it.next() {\n+                    None => break,\n+                    Some(elt) => {\n+                        it.insert_next(*elt + 1);\n+                        match it.peek_next() {\n+                            Some(x) => assert_eq!(*x, *elt + 2),\n+                            None => assert_eq!(8, *elt),\n+                        }\n+                    }\n+                }\n+            }\n+            it.insert_next(0);\n+            it.insert_next(1);\n+        }\n+        check_links(&m);\n+        assert_eq!(m.len(), 3 + len * 2);\n+        assert_eq!(m.into_iter().collect::<Vec<_>>(), [-2,0,1,2,3,4,5,6,7,8,9,0,1]);\n+    }\n+\n+    #[test]\n+    fn test_send() {\n+        let n = list_from(&[1,2,3]);\n+        thread::spawn(move || {\n+            check_links(&n);\n+            let a: &[_] = &[&1,&2,&3];\n+            assert_eq!(a, n.iter().collect::<Vec<_>>());\n+        }).join().ok().unwrap();\n+    }\n+\n+    #[test]\n+    fn test_fuzz() {\n+        for _ in 0..25 {\n+            fuzz_test(3);\n+            fuzz_test(16);\n+            fuzz_test(189);\n+        }\n+    }\n+\n+    #[cfg(test)]\n+    fn fuzz_test(sz: i32) {\n+        let mut m: LinkedList<_> = LinkedList::new();\n+        let mut v = vec![];\n+        for i in 0..sz {\n+            check_links(&m);\n+            let r: u8 = rand::random();\n+            match r % 6 {\n+                0 => {\n+                    m.pop_back();\n+                    v.pop();\n+                }\n+                1 => {\n+                    if !v.is_empty() {\n+                        m.pop_front();\n+                        v.remove(0);\n+                    }\n+                }\n+                2 | 4 =>  {\n+                    m.push_front(-i);\n+                    v.insert(0, -i);\n+                }\n+                3 | 5 | _ => {\n+                    m.push_back(i);\n+                    v.push(i);\n+                }\n+            }\n+        }\n+\n+        check_links(&m);\n+\n+        let mut i = 0;\n+        for (a, &b) in m.into_iter().zip(v.iter()) {\n+            i += 1;\n+            assert_eq!(a, b);\n+        }\n+        assert_eq!(i, v.len());\n+    }\n+}"}, {"sha": "be3d8f8dbb63d7ca64f2febd6f0c89dc15ccfea7", "filename": "src/libcollections/macros.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cb5e4292911f3651aa3453ad1d81b2794f4b2583/src%2Flibcollections%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5e4292911f3651aa3453ad1d81b2794f4b2583/src%2Flibcollections%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fmacros.rs?ref=cb5e4292911f3651aa3453ad1d81b2794f4b2583", "patch": "@@ -71,6 +71,7 @@ macro_rules! vec {\n /// Note that unlike array expressions this syntax supports all elements\n /// which implement `Clone` and the number of elements doesn't have to be\n /// a constant.\n+#[cfg(not(test))]\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! vec {\n@@ -83,6 +84,20 @@ macro_rules! vec {\n     ($($x:expr,)*) => (vec![$($x),*])\n }\n \n+// HACK: `impl [T]` is not available in cfg(test), use `::slice::into_vec`, instead of\n+// `<[T]>::to_vec`\n+#[cfg(not(stage0))]\n+#[cfg(test)]\n+macro_rules! vec {\n+    ($elem:expr; $n:expr) => (\n+        $crate::vec::from_elem($elem, $n)\n+    );\n+    ($($x:expr),*) => (\n+        $crate::slice::into_vec($crate::boxed::Box::new([$($x),*]))\n+    );\n+    ($($x:expr,)*) => (vec![$($x),*])\n+}\n+\n /// Use the syntax described in `std::fmt` to create a value of type `String`.\n /// See `std::fmt` for more information.\n ///"}, {"sha": "dafe0edbf32c7030b39f39b0d7060221892493cb", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/cb5e4292911f3651aa3453ad1d81b2794f4b2583/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5e4292911f3651aa3453ad1d81b2794f4b2583/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=cb5e4292911f3651aa3453ad1d81b2794f4b2583", "patch": "@@ -1083,9 +1083,36 @@ impl<T> SliceExt for [T] {\n     }\n }\n \n+// HACK: With cfg(test) `impl [T]` is not available, these three functions are actually methods\n+// that are in `impl [T]` but not in `core::slice::SliceExt` - this is only need for testing\n+#[cfg(test)]\n+pub fn into_vec<T>(mut b: Box<[T]>) -> Vec<T> {\n+    unsafe {\n+        let xs = Vec::from_raw_parts(b.as_mut_ptr(), b.len(), b.len());\n+        mem::forget(b);\n+        xs\n+    }\n+}\n+\n+#[cfg(test)]\n+pub fn permutations<T>(s: &[T]) -> Permutations<T> where T: Clone {\n+    Permutations{\n+        swaps: ElementSwaps::new(s.len()),\n+        v: ::slice::to_vec(s),\n+    }\n+}\n+\n+#[cfg(test)]\n+pub fn to_vec<T>(s: &[T]) -> Vec<T> where T: Clone {\n+    let mut vector = Vec::with_capacity(s.len());\n+    vector.push_all(s);\n+    vector\n+}\n+\n #[cfg(not(stage0))]\n /// Allocating extension methods for slices.\n #[lang = \"slice\"]\n+#[cfg(not(test))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> [T] {\n     /// Sorts the slice, in place, using `compare` to compare\n@@ -2022,7 +2049,13 @@ impl<T> BorrowMut<[T]> for Vec<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> ToOwned for [T] {\n     type Owned = Vec<T>;\n+    #[cfg(not(test))]\n     fn to_owned(&self) -> Vec<T> { self.to_vec() }\n+\n+    // HACK: `impl [T]` is not available in cfg(test), use `::slice::to_vec` instead of\n+    // `<[T]>::to_vec`\n+    #[cfg(test)]\n+    fn to_owned(&self) -> Vec<T> { ::slice::to_vec(self) }\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -2339,3 +2372,63 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n         old\n     }\n }\n+\n+#[cfg(test)]\n+mod test {\n+    use core::iter::{Iterator, IteratorExt};\n+    use core::option::Option::{None, Some};\n+    use string::ToString;\n+\n+    #[test]\n+    fn test_permutations() {\n+        {\n+            let v: [i32; 0] = [];\n+            let mut it = ::slice::permutations(&v);\n+            let (min_size, max_opt) = it.size_hint();\n+            assert_eq!(min_size, 1);\n+            assert_eq!(max_opt.unwrap(), 1);\n+            assert_eq!(it.next(), Some(::slice::to_vec(&v)));\n+            assert_eq!(it.next(), None);\n+        }\n+        {\n+            let v = [\"Hello\".to_string()];\n+            let mut it = ::slice::permutations(&v);\n+            let (min_size, max_opt) = it.size_hint();\n+            assert_eq!(min_size, 1);\n+            assert_eq!(max_opt.unwrap(), 1);\n+            assert_eq!(it.next(), Some(::slice::to_vec(&v)));\n+            assert_eq!(it.next(), None);\n+        }\n+        {\n+            let v = [1, 2, 3];\n+            let mut it = ::slice::permutations(&v);\n+            let (min_size, max_opt) = it.size_hint();\n+            assert_eq!(min_size, 3*2);\n+            assert_eq!(max_opt.unwrap(), 3*2);\n+            assert_eq!(it.next().unwrap(), [1,2,3]);\n+            assert_eq!(it.next().unwrap(), [1,3,2]);\n+            assert_eq!(it.next().unwrap(), [3,1,2]);\n+            let (min_size, max_opt) = it.size_hint();\n+            assert_eq!(min_size, 3);\n+            assert_eq!(max_opt.unwrap(), 3);\n+            assert_eq!(it.next().unwrap(), [3,2,1]);\n+            assert_eq!(it.next().unwrap(), [2,3,1]);\n+            assert_eq!(it.next().unwrap(), [2,1,3]);\n+            assert_eq!(it.next(), None);\n+        }\n+        {\n+            // check that we have N! permutations\n+            let v = ['A', 'B', 'C', 'D', 'E', 'F'];\n+            let mut amt = 0;\n+            let mut it = ::slice::permutations(&v);\n+            let (min_size, max_opt) = it.size_hint();\n+            for _perm in it.by_ref() {\n+                amt += 1;\n+            }\n+            assert_eq!(amt, it.swaps.swaps_made);\n+            assert_eq!(amt, min_size);\n+            assert_eq!(amt, 2 * 3 * 4 * 5 * 6);\n+            assert_eq!(amt, max_opt.unwrap());\n+        }\n+    }\n+}"}, {"sha": "a99372f178b2c75fe0baff7478493b0d319ce87c", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cb5e4292911f3651aa3453ad1d81b2794f4b2583/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5e4292911f3651aa3453ad1d81b2794f4b2583/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=cb5e4292911f3651aa3453ad1d81b2794f4b2583", "patch": "@@ -1562,6 +1562,7 @@ impl StrExt for str {\n #[cfg(not(stage0))]\n /// Any string that can be represented as a slice.\n #[lang = \"str\"]\n+#[cfg(not(test))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl str {\n     /// Escapes each char in `s` with `char::escape_default`."}, {"sha": "fdc7cf993b118af7a26010b0f5b5a667ad7efce7", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cb5e4292911f3651aa3453ad1d81b2794f4b2583/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5e4292911f3651aa3453ad1d81b2794f4b2583/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=cb5e4292911f3651aa3453ad1d81b2794f4b2583", "patch": "@@ -113,10 +113,19 @@ impl String {\n     #[inline]\n     #[unstable(feature = \"collections\",\n                reason = \"needs investigation to see if to_string() can match perf\")]\n+    #[cfg(not(test))]\n     pub fn from_str(string: &str) -> String {\n         String { vec: <[_]>::to_vec(string.as_bytes()) }\n     }\n \n+    // HACK: `impl [T]` is not available in cfg(test), use `::slice::to_vec` instead of\n+    // `<[T]>::to_vec`\n+    #[inline]\n+    #[cfg(test)]\n+    pub fn from_str(string: &str) -> String {\n+        String { vec: ::slice::to_vec(string.as_bytes()) }\n+    }\n+\n     /// Returns the vector as a string buffer, if possible, taking care not to\n     /// copy it.\n     ///"}, {"sha": "6aaebe08f5c26e0e5e879ea222b4d81c010c8893", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb5e4292911f3651aa3453ad1d81b2794f4b2583/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5e4292911f3651aa3453ad1d81b2794f4b2583/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=cb5e4292911f3651aa3453ad1d81b2794f4b2583", "patch": "@@ -1287,8 +1287,14 @@ impl<T:Clone> Clone for Vec<T> {\n     fn clone(&self) -> Vec<T> { ::slice::SliceExt::to_vec(&**self) }\n \n     #[cfg(not(stage0))]\n+    #[cfg(not(test))]\n     fn clone(&self) -> Vec<T> { <[T]>::to_vec(&**self) }\n \n+    // HACK: `impl [T]` not available in cfg(test), use `::slice::to_vec` instead of `<[T]>::to_vec`\n+    #[cfg(not(stage0))]\n+    #[cfg(test)]\n+    fn clone(&self) -> Vec<T> { ::slice::to_vec(&**self) }\n+\n     fn clone_from(&mut self, other: &Vec<T>) {\n         // drop anything in self that will not be overwritten\n         if self.len() > other.len() {"}, {"sha": "95d43fa8fc0d53db51d8839db5a6e3726b994b9d", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/cb5e4292911f3651aa3453ad1d81b2794f4b2583/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5e4292911f3651aa3453ad1d81b2794f4b2583/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=cb5e4292911f3651aa3453ad1d81b2794f4b2583", "patch": "@@ -1768,3 +1768,248 @@ impl<T: fmt::Debug> fmt::Debug for VecDeque<T> {\n         write!(f, \"]\")\n     }\n }\n+\n+#[cfg(test)]\n+mod test {\n+    use core::iter::{IteratorExt, self};\n+    use core::option::Option::Some;\n+\n+    use test;\n+\n+    use super::VecDeque;\n+\n+    #[bench]\n+    fn bench_push_back_100(b: &mut test::Bencher) {\n+        let mut deq = VecDeque::with_capacity(101);\n+        b.iter(|| {\n+            for i in 0..100 {\n+                deq.push_back(i);\n+            }\n+            deq.head = 0;\n+            deq.tail = 0;\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_push_front_100(b: &mut test::Bencher) {\n+        let mut deq = VecDeque::with_capacity(101);\n+        b.iter(|| {\n+            for i in 0..100 {\n+                deq.push_front(i);\n+            }\n+            deq.head = 0;\n+            deq.tail = 0;\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_pop_back_100(b: &mut test::Bencher) {\n+        let mut deq= VecDeque::<i32>::with_capacity(101);\n+\n+        b.iter(|| {\n+            deq.head = 100;\n+            deq.tail = 0;\n+            while !deq.is_empty() {\n+                test::black_box(deq.pop_back());\n+            }\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_pop_front_100(b: &mut test::Bencher) {\n+        let mut deq = VecDeque::<i32>::with_capacity(101);\n+\n+        b.iter(|| {\n+            deq.head = 100;\n+            deq.tail = 0;\n+            while !deq.is_empty() {\n+                test::black_box(deq.pop_front());\n+            }\n+        })\n+    }\n+\n+    #[test]\n+    fn test_swap_front_back_remove() {\n+        fn test(back: bool) {\n+            // This test checks that every single combination of tail position and length is tested.\n+            // Capacity 15 should be large enough to cover every case.\n+            let mut tester = VecDeque::with_capacity(15);\n+            let usable_cap = tester.capacity();\n+            let final_len = usable_cap / 2;\n+\n+            for len in 0..final_len {\n+                let expected = if back {\n+                    (0..len).collect()\n+                } else {\n+                    (0..len).rev().collect()\n+                };\n+                for tail_pos in 0..usable_cap {\n+                    tester.tail = tail_pos;\n+                    tester.head = tail_pos;\n+                    if back {\n+                        for i in 0..len * 2 {\n+                            tester.push_front(i);\n+                        }\n+                        for i in 0..len {\n+                            assert_eq!(tester.swap_back_remove(i), Some(len * 2 - 1 - i));\n+                        }\n+                    } else {\n+                        for i in 0..len * 2 {\n+                            tester.push_back(i);\n+                        }\n+                        for i in 0..len {\n+                            let idx = tester.len() - 1 - i;\n+                            assert_eq!(tester.swap_front_remove(idx), Some(len * 2 - 1 - i));\n+                        }\n+                    }\n+                    assert!(tester.tail < tester.cap);\n+                    assert!(tester.head < tester.cap);\n+                    assert_eq!(tester, expected);\n+                }\n+            }\n+        }\n+        test(true);\n+        test(false);\n+    }\n+\n+    #[test]\n+    fn test_insert() {\n+        // This test checks that every single combination of tail position, length, and\n+        // insertion position is tested. Capacity 15 should be large enough to cover every case.\n+\n+        let mut tester = VecDeque::with_capacity(15);\n+        // can't guarantee we got 15, so have to get what we got.\n+        // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n+        // this test isn't covering what it wants to\n+        let cap = tester.capacity();\n+\n+\n+        // len is the length *after* insertion\n+        for len in 1..cap {\n+            // 0, 1, 2, .., len - 1\n+            let expected = iter::count(0, 1).take(len).collect();\n+            for tail_pos in 0..cap {\n+                for to_insert in 0..len {\n+                    tester.tail = tail_pos;\n+                    tester.head = tail_pos;\n+                    for i in 0..len {\n+                        if i != to_insert {\n+                            tester.push_back(i);\n+                        }\n+                    }\n+                    tester.insert(to_insert, to_insert);\n+                    assert!(tester.tail < tester.cap);\n+                    assert!(tester.head < tester.cap);\n+                    assert_eq!(tester, expected);\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_remove() {\n+        // This test checks that every single combination of tail position, length, and\n+        // removal position is tested. Capacity 15 should be large enough to cover every case.\n+\n+        let mut tester = VecDeque::with_capacity(15);\n+        // can't guarantee we got 15, so have to get what we got.\n+        // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n+        // this test isn't covering what it wants to\n+        let cap = tester.capacity();\n+\n+        // len is the length *after* removal\n+        for len in 0..cap - 1 {\n+            // 0, 1, 2, .., len - 1\n+            let expected = iter::count(0, 1).take(len).collect();\n+            for tail_pos in 0..cap {\n+                for to_remove in 0..len + 1 {\n+                    tester.tail = tail_pos;\n+                    tester.head = tail_pos;\n+                    for i in 0..len {\n+                        if i == to_remove {\n+                            tester.push_back(1234);\n+                        }\n+                        tester.push_back(i);\n+                    }\n+                    if to_remove == len {\n+                        tester.push_back(1234);\n+                    }\n+                    tester.remove(to_remove);\n+                    assert!(tester.tail < tester.cap);\n+                    assert!(tester.head < tester.cap);\n+                    assert_eq!(tester, expected);\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_shrink_to_fit() {\n+        // This test checks that every single combination of head and tail position,\n+        // is tested. Capacity 15 should be large enough to cover every case.\n+\n+        let mut tester = VecDeque::with_capacity(15);\n+        // can't guarantee we got 15, so have to get what we got.\n+        // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n+        // this test isn't covering what it wants to\n+        let cap = tester.capacity();\n+        tester.reserve(63);\n+        let max_cap = tester.capacity();\n+\n+        for len in 0..cap + 1 {\n+            // 0, 1, 2, .., len - 1\n+            let expected = iter::count(0, 1).take(len).collect();\n+            for tail_pos in 0..max_cap + 1 {\n+                tester.tail = tail_pos;\n+                tester.head = tail_pos;\n+                tester.reserve(63);\n+                for i in 0..len {\n+                    tester.push_back(i);\n+                }\n+                tester.shrink_to_fit();\n+                assert!(tester.capacity() <= cap);\n+                assert!(tester.tail < tester.cap);\n+                assert!(tester.head < tester.cap);\n+                assert_eq!(tester, expected);\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_split_off() {\n+        // This test checks that every single combination of tail position, length, and\n+        // split position is tested. Capacity 15 should be large enough to cover every case.\n+\n+        let mut tester = VecDeque::with_capacity(15);\n+        // can't guarantee we got 15, so have to get what we got.\n+        // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n+        // this test isn't covering what it wants to\n+        let cap = tester.capacity();\n+\n+        // len is the length *before* splitting\n+        for len in 0..cap {\n+            // index to split at\n+            for at in 0..len + 1 {\n+                // 0, 1, 2, .., at - 1 (may be empty)\n+                let expected_self = iter::count(0, 1).take(at).collect();\n+                // at, at + 1, .., len - 1 (may be empty)\n+                let expected_other = iter::count(at, 1).take(len - at).collect();\n+\n+                for tail_pos in 0..cap {\n+                    tester.tail = tail_pos;\n+                    tester.head = tail_pos;\n+                    for i in 0..len {\n+                        tester.push_back(i);\n+                    }\n+                    let result = tester.split_off(at);\n+                    assert!(tester.tail < tester.cap);\n+                    assert!(tester.head < tester.cap);\n+                    assert!(result.tail < result.cap);\n+                    assert!(result.head < result.cap);\n+                    assert_eq!(tester, expected_self);\n+                    assert_eq!(result, expected_other);\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "fd73938095f09e4338679c1612ff19e101cbe537", "filename": "src/libcollectionstest/linked_list.rs", "status": "modified", "additions": 0, "deletions": 192, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/cb5e4292911f3651aa3453ad1d81b2794f4b2583/src%2Flibcollectionstest%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5e4292911f3651aa3453ad1d81b2794f4b2583/src%2Flibcollectionstest%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flinked_list.rs?ref=cb5e4292911f3651aa3453ad1d81b2794f4b2583", "patch": "@@ -13,41 +13,6 @@ use std::hash::{SipHasher, self};\n \n use test;\n \n-// FIXME(japaric) privacy\n-/*\n-pub fn check_links<T>(list: &LinkedList<T>) {\n-    let mut len = 0;\n-    let mut last_ptr: Option<&Node<T>> = None;\n-    let mut node_ptr: &Node<T>;\n-    match list.list_head {\n-        None => { assert_eq!(0, list.length); return }\n-        Some(ref node) => node_ptr = &**node,\n-    }\n-    loop {\n-        match (last_ptr, node_ptr.prev.resolve_immut()) {\n-            (None   , None      ) => {}\n-            (None   , _         ) => panic!(\"prev link for list_head\"),\n-            (Some(p), Some(pptr)) => {\n-                assert_eq!(p as *const Node<T>, pptr as *const Node<T>);\n-            }\n-            _ => panic!(\"prev link is none, not good\"),\n-        }\n-        match node_ptr.next {\n-            Some(ref next) => {\n-                last_ptr = Some(node_ptr);\n-                node_ptr = &**next;\n-                len += 1;\n-            }\n-            None => {\n-                len += 1;\n-                break;\n-            }\n-        }\n-    }\n-    assert_eq!(len, list.length);\n-}\n-*/\n-\n #[test]\n fn test_basic() {\n     let mut m = LinkedList::<Box<_>>::new();\n@@ -98,66 +63,6 @@ fn list_from<T: Clone>(v: &[T]) -> LinkedList<T> {\n     v.iter().cloned().collect()\n }\n \n-// FIXME(japaric) privacy\n-/*\n-#[test]\n-fn test_append() {\n-    // Empty to empty\n-    {\n-        let mut m = LinkedList::<i32>::new();\n-        let mut n = LinkedList::new();\n-        m.append(&mut n);\n-        check_links(&m);\n-        assert_eq!(m.len(), 0);\n-        assert_eq!(n.len(), 0);\n-    }\n-    // Non-empty to empty\n-    {\n-        let mut m = LinkedList::new();\n-        let mut n = LinkedList::new();\n-        n.push_back(2);\n-        m.append(&mut n);\n-        check_links(&m);\n-        assert_eq!(m.len(), 1);\n-        assert_eq!(m.pop_back(), Some(2));\n-        assert_eq!(n.len(), 0);\n-        check_links(&m);\n-    }\n-    // Empty to non-empty\n-    {\n-        let mut m = LinkedList::new();\n-        let mut n = LinkedList::new();\n-        m.push_back(2);\n-        m.append(&mut n);\n-        check_links(&m);\n-        assert_eq!(m.len(), 1);\n-        assert_eq!(m.pop_back(), Some(2));\n-        check_links(&m);\n-    }\n-\n-    // Non-empty to non-empty\n-    let v = vec![1,2,3,4,5];\n-    let u = vec![9,8,1,2,3,4,5];\n-    let mut m = list_from(&v);\n-    let mut n = list_from(&u);\n-    m.append(&mut n);\n-    check_links(&m);\n-    let mut sum = v;\n-    sum.push_all(&u);\n-    assert_eq!(sum.len(), m.len());\n-    for elt in sum {\n-        assert_eq!(m.pop_front(), Some(elt))\n-    }\n-    assert_eq!(n.len(), 0);\n-    // let's make sure it's working properly, since we\n-    // did some direct changes to private members\n-    n.push_back(3);\n-    assert_eq!(n.len(), 1);\n-    assert_eq!(n.pop_front(), Some(3));\n-    check_links(&n);\n-}\n-*/\n-\n #[test]\n fn test_split_off() {\n     // singleton\n@@ -318,36 +223,6 @@ fn test_iterator_mut_double_end() {\n     assert!(it.next().is_none());\n }\n \n-// FIXME(japaric) privacy\n-/*\n-#[test]\n-fn test_insert_prev() {\n-    let mut m = list_from(&[0,2,4,6,8]);\n-    let len = m.len();\n-    {\n-        let mut it = m.iter_mut();\n-        it.insert_next(-2);\n-        loop {\n-            match it.next() {\n-                None => break,\n-                Some(elt) => {\n-                    it.insert_next(*elt + 1);\n-                    match it.peek_next() {\n-                        Some(x) => assert_eq!(*x, *elt + 2),\n-                        None => assert_eq!(8, *elt),\n-                    }\n-                }\n-            }\n-        }\n-        it.insert_next(0);\n-        it.insert_next(1);\n-    }\n-    check_links(&m);\n-    assert_eq!(m.len(), 3 + len * 2);\n-    assert_eq!(m.into_iter().collect::<Vec<_>>(), [-2,0,1,2,3,4,5,6,7,8,9,0,1]);\n-}\n-*/\n-\n #[test]\n fn test_mut_rev_iter() {\n     let mut m = generate_test();\n@@ -362,19 +237,6 @@ fn test_mut_rev_iter() {\n     assert!(it.next().is_none());\n }\n \n-// FIXME(japaric) privacy\n-/*\n-#[test]\n-fn test_send() {\n-    let n = list_from(&[1,2,3]);\n-    thread::spawn(move || {\n-        check_links(&n);\n-        let a: &[_] = &[&1,&2,&3];\n-        assert_eq!(a, n.iter().collect::<Vec<_>>());\n-    }).join().ok().unwrap();\n-}\n-*/\n-\n #[test]\n fn test_eq() {\n     let mut n = list_from(&[]);\n@@ -450,18 +312,6 @@ fn test_ord_nan() {\n     assert!(s >= one);\n }\n \n-// FIXME(japaric) privacy\n-/*\n-#[test]\n-fn test_fuzz() {\n-    for _ in 0..25 {\n-        fuzz_test(3);\n-        fuzz_test(16);\n-        fuzz_test(189);\n-    }\n-}\n-*/\n-\n #[test]\n fn test_show() {\n     let list: LinkedList<_> = (0..10).collect();\n@@ -471,48 +321,6 @@ fn test_show() {\n     assert_eq!(format!(\"{:?}\", list), \"[\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n }\n \n-// FIXME(japaric) privacy\n-/*\n-#[cfg(test)]\n-fn fuzz_test(sz: i32) {\n-    let mut m: LinkedList<_> = LinkedList::new();\n-    let mut v = vec![];\n-    for i in 0..sz {\n-        check_links(&m);\n-        let r: u8 = rand::random();\n-        match r % 6 {\n-            0 => {\n-                m.pop_back();\n-                v.pop();\n-            }\n-            1 => {\n-                if !v.is_empty() {\n-                    m.pop_front();\n-                    v.remove(0);\n-                }\n-            }\n-            2 | 4 =>  {\n-                m.push_front(-i);\n-                v.insert(0, -i);\n-            }\n-            3 | 5 | _ => {\n-                m.push_back(i);\n-                v.push(i);\n-            }\n-        }\n-    }\n-\n-    check_links(&m);\n-\n-    let mut i = 0;\n-    for (a, &b) in m.into_iter().zip(v.iter()) {\n-        i += 1;\n-        assert_eq!(a, b);\n-    }\n-    assert_eq!(i, v.len());\n-}\n-*/\n-\n #[bench]\n fn bench_collect_into(b: &mut test::Bencher) {\n     let v = &[0; 64];"}, {"sha": "0c3c82eea780f4db568ef80bd506dfcc33c2ca0e", "filename": "src/libcollectionstest/slice.rs", "status": "modified", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/cb5e4292911f3651aa3453ad1d81b2794f4b2583/src%2Flibcollectionstest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5e4292911f3651aa3453ad1d81b2794f4b2583/src%2Flibcollectionstest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fslice.rs?ref=cb5e4292911f3651aa3453ad1d81b2794f4b2583", "patch": "@@ -406,62 +406,6 @@ fn test_element_swaps() {\n     }\n }\n \n-// FIXME(japaric) privacy\n-/*\n-#[test]\n-fn test_permutations() {\n-    {\n-        let v: [i32; 0] = [];\n-        let mut it = v.permutations();\n-        let (min_size, max_opt) = it.size_hint();\n-        assert_eq!(min_size, 1);\n-        assert_eq!(max_opt.unwrap(), 1);\n-        assert_eq!(it.next(), Some(v.to_vec()));\n-        assert_eq!(it.next(), None);\n-    }\n-    {\n-        let v = [\"Hello\".to_string()];\n-        let mut it = v.permutations();\n-        let (min_size, max_opt) = it.size_hint();\n-        assert_eq!(min_size, 1);\n-        assert_eq!(max_opt.unwrap(), 1);\n-        assert_eq!(it.next(), Some(v.to_vec()));\n-        assert_eq!(it.next(), None);\n-    }\n-    {\n-        let v = [1, 2, 3];\n-        let mut it = v.permutations();\n-        let (min_size, max_opt) = it.size_hint();\n-        assert_eq!(min_size, 3*2);\n-        assert_eq!(max_opt.unwrap(), 3*2);\n-        assert_eq!(it.next(), Some(vec![1,2,3]));\n-        assert_eq!(it.next(), Some(vec![1,3,2]));\n-        assert_eq!(it.next(), Some(vec![3,1,2]));\n-        let (min_size, max_opt) = it.size_hint();\n-        assert_eq!(min_size, 3);\n-        assert_eq!(max_opt.unwrap(), 3);\n-        assert_eq!(it.next(), Some(vec![3,2,1]));\n-        assert_eq!(it.next(), Some(vec![2,3,1]));\n-        assert_eq!(it.next(), Some(vec![2,1,3]));\n-        assert_eq!(it.next(), None);\n-    }\n-    {\n-        // check that we have N! permutations\n-        let v = ['A', 'B', 'C', 'D', 'E', 'F'];\n-        let mut amt = 0;\n-        let mut it = v.permutations();\n-        let (min_size, max_opt) = it.size_hint();\n-        for _perm in it.by_ref() {\n-            amt += 1;\n-        }\n-        assert_eq!(amt, it.swaps.swaps_made);\n-        assert_eq!(amt, min_size);\n-        assert_eq!(amt, 2 * 3 * 4 * 5 * 6);\n-        assert_eq!(amt, max_opt.unwrap());\n-    }\n-}\n-*/\n-\n #[test]\n fn test_lexicographic_permutations() {\n     let v : &mut[_] = &mut[1, 2, 3, 4, 5];"}, {"sha": "38f358c150531dc9d1ab450f4d4351000c3ab867", "filename": "src/libcollectionstest/vec_deque.rs", "status": "modified", "additions": 0, "deletions": 262, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/cb5e4292911f3651aa3453ad1d81b2794f4b2583/src%2Flibcollectionstest%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5e4292911f3651aa3453ad1d81b2794f4b2583/src%2Flibcollectionstest%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec_deque.rs?ref=cb5e4292911f3651aa3453ad1d81b2794f4b2583", "patch": "@@ -137,68 +137,6 @@ fn bench_new(b: &mut test::Bencher) {\n     })\n }\n \n-// FIXME(japaric) privacy\n-/*\n-#[bench]\n-fn bench_push_back_100(b: &mut test::Bencher) {\n-    let mut deq = VecDeque::with_capacity(101);\n-    b.iter(|| {\n-        for i in 0..100 {\n-            deq.push_back(i);\n-        }\n-        deq.head = 0;\n-        deq.tail = 0;\n-    })\n-}\n-*/\n-\n-// FIXME(japaric) privacy\n-/*\n-#[bench]\n-fn bench_push_front_100(b: &mut test::Bencher) {\n-    let mut deq = VecDeque::with_capacity(101);\n-    b.iter(|| {\n-        for i in 0..100 {\n-            deq.push_front(i);\n-        }\n-        deq.head = 0;\n-        deq.tail = 0;\n-    })\n-}\n-*/\n-\n-// FIXME(japaric) privacy\n-/*\n-#[bench]\n-fn bench_pop_back_100(b: &mut test::Bencher) {\n-    let mut deq= VecDeque::<i32>::with_capacity(101);\n-\n-    b.iter(|| {\n-        deq.head = 100;\n-        deq.tail = 0;\n-        while !deq.is_empty() {\n-            test::black_box(deq.pop_back());\n-        }\n-    })\n-}\n-*/\n-\n-// FIXME(japaric) privacy\n-/*\n-#[bench]\n-fn bench_pop_front_100(b: &mut test::Bencher) {\n-    let mut deq = VecDeque::<i32>::with_capacity(101);\n-\n-    b.iter(|| {\n-        deq.head = 100;\n-        deq.tail = 0;\n-        while !deq.is_empty() {\n-            test::black_box(deq.pop_front());\n-        }\n-    })\n-}\n-*/\n-\n #[bench]\n fn bench_grow_1025(b: &mut test::Bencher) {\n     b.iter(|| {\n@@ -860,165 +798,6 @@ fn test_get_mut() {\n     assert_eq!(ring.get_mut(2), None);\n }\n \n-// FIXME(japaric) privacy\n-/*\n-#[test]\n-fn test_swap_front_back_remove() {\n-    fn test(back: bool) {\n-        // This test checks that every single combination of tail position and length is tested.\n-        // Capacity 15 should be large enough to cover every case.\n-        let mut tester = VecDeque::with_capacity(15);\n-        let usable_cap = tester.capacity();\n-        let final_len = usable_cap / 2;\n-\n-        for len in 0..final_len {\n-            let expected = if back {\n-                (0..len).collect()\n-            } else {\n-                (0..len).rev().collect()\n-            };\n-            for tail_pos in 0..usable_cap {\n-                tester.tail = tail_pos;\n-                tester.head = tail_pos;\n-                if back {\n-                    for i in 0..len * 2 {\n-                        tester.push_front(i);\n-                    }\n-                    for i in 0..len {\n-                        assert_eq!(tester.swap_back_remove(i), Some(len * 2 - 1 - i));\n-                    }\n-                } else {\n-                    for i in 0..len * 2 {\n-                        tester.push_back(i);\n-                    }\n-                    for i in 0..len {\n-                        let idx = tester.len() - 1 - i;\n-                        assert_eq!(tester.swap_front_remove(idx), Some(len * 2 - 1 - i));\n-                    }\n-                }\n-                assert!(tester.tail < tester.cap);\n-                assert!(tester.head < tester.cap);\n-                assert_eq!(tester, expected);\n-            }\n-        }\n-    }\n-    test(true);\n-    test(false);\n-}\n-*/\n-\n-// FIXME(japaric) privacy\n-/*\n-#[test]\n-fn test_insert() {\n-    // This test checks that every single combination of tail position, length, and\n-    // insertion position is tested. Capacity 15 should be large enough to cover every case.\n-\n-    let mut tester = VecDeque::with_capacity(15);\n-    // can't guarantee we got 15, so have to get what we got.\n-    // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n-    // this test isn't covering what it wants to\n-    let cap = tester.capacity();\n-\n-\n-    // len is the length *after* insertion\n-    for len in 1..cap {\n-        // 0, 1, 2, .., len - 1\n-        let expected = iter::count(0, 1).take(len).collect();\n-        for tail_pos in 0..cap {\n-            for to_insert in 0..len {\n-                tester.tail = tail_pos;\n-                tester.head = tail_pos;\n-                for i in 0..len {\n-                    if i != to_insert {\n-                        tester.push_back(i);\n-                    }\n-                }\n-                tester.insert(to_insert, to_insert);\n-                assert!(tester.tail < tester.cap);\n-                assert!(tester.head < tester.cap);\n-                assert_eq!(tester, expected);\n-            }\n-        }\n-    }\n-}\n-*/\n-\n-// FIXME(japaric) privacy\n-/*\n-#[test]\n-fn test_remove() {\n-    // This test checks that every single combination of tail position, length, and\n-    // removal position is tested. Capacity 15 should be large enough to cover every case.\n-\n-    let mut tester = VecDeque::with_capacity(15);\n-    // can't guarantee we got 15, so have to get what we got.\n-    // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n-    // this test isn't covering what it wants to\n-    let cap = tester.capacity();\n-\n-    // len is the length *after* removal\n-    for len in 0..cap - 1 {\n-        // 0, 1, 2, .., len - 1\n-        let expected = iter::count(0, 1).take(len).collect();\n-        for tail_pos in 0..cap {\n-            for to_remove in 0..len + 1 {\n-                tester.tail = tail_pos;\n-                tester.head = tail_pos;\n-                for i in 0..len {\n-                    if i == to_remove {\n-                        tester.push_back(1234);\n-                    }\n-                    tester.push_back(i);\n-                }\n-                if to_remove == len {\n-                    tester.push_back(1234);\n-                }\n-                tester.remove(to_remove);\n-                assert!(tester.tail < tester.cap);\n-                assert!(tester.head < tester.cap);\n-                assert_eq!(tester, expected);\n-            }\n-        }\n-    }\n-}\n-*/\n-\n-// FIXME(japaric) privacy\n-/*\n-#[test]\n-fn test_shrink_to_fit() {\n-    // This test checks that every single combination of head and tail position,\n-    // is tested. Capacity 15 should be large enough to cover every case.\n-\n-    let mut tester = VecDeque::with_capacity(15);\n-    // can't guarantee we got 15, so have to get what we got.\n-    // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n-    // this test isn't covering what it wants to\n-    let cap = tester.capacity();\n-    tester.reserve(63);\n-    let max_cap = tester.capacity();\n-\n-    for len in 0..cap + 1 {\n-        // 0, 1, 2, .., len - 1\n-        let expected = iter::count(0, 1).take(len).collect();\n-        for tail_pos in 0..max_cap + 1 {\n-            tester.tail = tail_pos;\n-            tester.head = tail_pos;\n-            tester.reserve(63);\n-            for i in 0..len {\n-                tester.push_back(i);\n-            }\n-            tester.shrink_to_fit();\n-            assert!(tester.capacity() <= cap);\n-            assert!(tester.tail < tester.cap);\n-            assert!(tester.head < tester.cap);\n-            assert_eq!(tester, expected);\n-        }\n-    }\n-}\n-*/\n-\n #[test]\n fn test_front() {\n     let mut ring = VecDeque::new();\n@@ -1087,47 +866,6 @@ fn test_as_mut_slices() {\n     assert_eq!(ring.capacity() as i32, cap);\n }\n \n-// FIXME(japaric) privacy\n-/*\n-#[test]\n-fn test_split_off() {\n-    // This test checks that every single combination of tail position, length, and\n-    // split position is tested. Capacity 15 should be large enough to cover every case.\n-\n-    let mut tester = VecDeque::with_capacity(15);\n-    // can't guarantee we got 15, so have to get what we got.\n-    // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n-    // this test isn't covering what it wants to\n-    let cap = tester.capacity();\n-\n-    // len is the length *before* splitting\n-    for len in 0..cap {\n-        // index to split at\n-        for at in 0..len + 1 {\n-            // 0, 1, 2, .., at - 1 (may be empty)\n-            let expected_self = iter::count(0, 1).take(at).collect();\n-            // at, at + 1, .., len - 1 (may be empty)\n-            let expected_other = iter::count(at, 1).take(len - at).collect();\n-\n-            for tail_pos in 0..cap {\n-                tester.tail = tail_pos;\n-                tester.head = tail_pos;\n-                for i in 0..len {\n-                    tester.push_back(i);\n-                }\n-                let result = tester.split_off(at);\n-                assert!(tester.tail < tester.cap);\n-                assert!(tester.head < tester.cap);\n-                assert!(result.tail < result.cap);\n-                assert!(result.head < result.cap);\n-                assert_eq!(tester, expected_self);\n-                assert_eq!(result, expected_other);\n-            }\n-        }\n-    }\n-}\n-*/\n-\n #[test]\n fn test_append() {\n     let mut a: VecDeque<_> = vec![1, 2, 3].into_iter().collect();"}]}