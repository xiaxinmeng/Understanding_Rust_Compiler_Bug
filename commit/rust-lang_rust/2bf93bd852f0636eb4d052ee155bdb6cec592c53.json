{"sha": "2bf93bd852f0636eb4d052ee155bdb6cec592c53", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiZjkzYmQ4NTJmMDYzNmViNGQwNTJlZTE1NWJkYjZjZWM1OTJjNTM=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-10-24T00:21:18Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-11-16T21:34:57Z"}, "message": "compiler: fold by value", "tree": {"sha": "2b1afcc6ca36800af099b279acedc25de7d88f28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b1afcc6ca36800af099b279acedc25de7d88f28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2bf93bd852f0636eb4d052ee155bdb6cec592c53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2bf93bd852f0636eb4d052ee155bdb6cec592c53", "html_url": "https://github.com/rust-lang/rust/commit/2bf93bd852f0636eb4d052ee155bdb6cec592c53", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2bf93bd852f0636eb4d052ee155bdb6cec592c53/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ec6720bf1af8cb9397e6ad48ec300b6a46b25fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ec6720bf1af8cb9397e6ad48ec300b6a46b25fb", "html_url": "https://github.com/rust-lang/rust/commit/3ec6720bf1af8cb9397e6ad48ec300b6a46b25fb"}], "stats": {"total": 1378, "additions": 679, "deletions": 699}, "files": [{"sha": "7673dfb744c5a74087411484fa9b688e82adfd54", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/create_scope_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -92,7 +92,7 @@ fn make_mir_scope(\n             let callee = cx.tcx.subst_and_normalize_erasing_regions(\n                 instance.substs,\n                 ty::ParamEnv::reveal_all(),\n-                &callee,\n+                callee,\n             );\n             let callee_fn_abi = FnAbi::of_instance(cx, callee, &[]);\n             cx.dbg_scope_fn(callee, &callee_fn_abi, None)"}, {"sha": "5e8ff14f0aaa622f85167a7e30cab6406bcbab9f", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -189,7 +189,7 @@ impl TypeMap<'ll, 'tcx> {\n         // something that provides more than the 64 bits of the DefaultHasher.\n         let mut hasher = StableHasher::new();\n         let mut hcx = cx.tcx.create_stable_hashing_context();\n-        let type_ = cx.tcx.erase_regions(&type_);\n+        let type_ = cx.tcx.erase_regions(type_);\n         hcx.while_hashing_spans(false, |hcx| {\n             hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n                 type_.hash_stable(hcx, &mut hasher);\n@@ -427,7 +427,7 @@ fn subroutine_type_metadata(\n     span: Span,\n ) -> MetadataCreationResult<'ll> {\n     let signature =\n-        cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &signature);\n+        cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), signature);\n \n     let signature_metadata: Vec<_> = iter::once(\n         // return type"}, {"sha": "ccbe7325cc6c2da28f426a20cfe327c90efee786", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -501,7 +501,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                     let impl_self_ty = cx.tcx.subst_and_normalize_erasing_regions(\n                         instance.substs,\n                         ty::ParamEnv::reveal_all(),\n-                        &cx.tcx.type_of(impl_def_id),\n+                        cx.tcx.type_of(impl_def_id),\n                     );\n \n                     // Only \"class\" methods are generally understood by LLVM,"}, {"sha": "ac423d01bf1fc6972ebac9e8819bb363fa90a0d4", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -91,7 +91,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         };\n \n         let sig = callee_ty.fn_sig(tcx);\n-        let sig = tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n+        let sig = tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), sig);\n         let arg_tys = sig.inputs();\n         let ret_ty = sig.output();\n         let name = tcx.item_name(def_id);\n@@ -777,8 +777,8 @@ fn generic_simd_intrinsic(\n     }\n \n     let tcx = bx.tcx();\n-    let sig = tcx\n-        .normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &callee_ty.fn_sig(tcx));\n+    let sig =\n+        tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), callee_ty.fn_sig(tcx));\n     let arg_tys = sig.inputs();\n     let name_str = &*name.as_str();\n "}, {"sha": "8ea4768f77dbd7cd4b80734469438422bffd545c", "filename": "compiler/rustc_codegen_llvm/src/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -252,7 +252,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n \n         // Make sure lifetimes are erased, to avoid generating distinct LLVM\n         // types for Rust types that only differ in the choice of lifetimes.\n-        let normal_ty = cx.tcx.erase_regions(&self.ty);\n+        let normal_ty = cx.tcx.erase_regions(self.ty);\n \n         let mut defer = None;\n         let llty = if self.ty != normal_ty {"}, {"sha": "21138f967a2737c3c891b56898fac07a950c64ff", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -399,7 +399,7 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         // late-bound regions, since late-bound\n         // regions must appear in the argument\n         // listing.\n-        let main_ret_ty = cx.tcx().erase_regions(&main_ret_ty.no_bound_vars().unwrap());\n+        let main_ret_ty = cx.tcx().erase_regions(main_ret_ty.no_bound_vars().unwrap());\n \n         let llfn = match cx.declare_c_main(llfty) {\n             Some(llfn) => llfn,"}, {"sha": "896af8a9191c2fd8e025eb0ef43d7880394b7ebc", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -120,8 +120,8 @@ pub fn push_debuginfo_type_name<'tcx>(\n         }\n         ty::Dynamic(ref trait_data, ..) => {\n             if let Some(principal) = trait_data.principal() {\n-                let principal = tcx\n-                    .normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &principal);\n+                let principal =\n+                    tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), principal);\n                 push_item_name(tcx, principal.def_id, false, output);\n                 push_type_params(tcx, principal.substs, output, visited);\n             } else {\n@@ -159,7 +159,7 @@ pub fn push_debuginfo_type_name<'tcx>(\n \n             output.push_str(\"fn(\");\n \n-            let sig = tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n+            let sig = tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), sig);\n             if !sig.inputs().is_empty() {\n                 for &parameter_type in sig.inputs() {\n                     push_debuginfo_type_name(tcx, parameter_type, true, output, visited);"}, {"sha": "44bb0deeae97f771f074d72ca6cb4df8d8619edf", "filename": "compiler/rustc_codegen_ssa/src/mir/analyze.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -24,7 +24,7 @@ pub fn non_ssa_locals<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     analyzer.visit_body(&mir);\n \n     for (local, decl) in mir.local_decls.iter_enumerated() {\n-        let ty = fx.monomorphize(&decl.ty);\n+        let ty = fx.monomorphize(decl.ty);\n         debug!(\"local {:?} has type `{}`\", local, ty);\n         let layout = fx.cx.spanned_layout_of(ty, decl.source_info.span);\n         if fx.cx.is_backend_immediate(layout) {\n@@ -121,10 +121,10 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n             if is_consume {\n                 let base_ty =\n                     mir::Place::ty_from(place_ref.local, proj_base, self.fx.mir, cx.tcx());\n-                let base_ty = self.fx.monomorphize(&base_ty);\n+                let base_ty = self.fx.monomorphize(base_ty);\n \n                 // ZSTs don't require any actual memory access.\n-                let elem_ty = base_ty.projection_ty(cx.tcx(), self.fx.monomorphize(&elem)).ty;\n+                let elem_ty = base_ty.projection_ty(cx.tcx(), self.fx.monomorphize(elem)).ty;\n                 let span = self.fx.mir.local_decls[place_ref.local].source_info.span;\n                 if cx.spanned_layout_of(elem_ty, span).is_zst() {\n                     return;\n@@ -313,7 +313,7 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n \n             PlaceContext::MutatingUse(MutatingUseContext::Drop) => {\n                 let ty = self.fx.mir.local_decls[local].ty;\n-                let ty = self.fx.monomorphize(&ty);\n+                let ty = self.fx.monomorphize(ty);\n \n                 // Only need the place if we're actually dropping it.\n                 if self.fx.cx.type_needs_drop(ty) {"}, {"sha": "ee40095883ded8710a63ba1a7be8754d4684a727", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -306,7 +306,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         unwind: Option<mir::BasicBlock>,\n     ) {\n         let ty = location.ty(self.mir, bx.tcx()).ty;\n-        let ty = self.monomorphize(&ty);\n+        let ty = self.monomorphize(ty);\n         let drop_fn = Instance::resolve_drop_in_place(bx.tcx(), ty);\n \n         if let ty::InstanceDef::DropGlue(_, None) = drop_fn.def {\n@@ -576,7 +576,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             .iter()\n             .map(|op_arg| {\n                 let op_ty = op_arg.ty(self.mir, bx.tcx());\n-                self.monomorphize(&op_ty)\n+                self.monomorphize(op_ty)\n             })\n             .collect::<Vec<_>>();\n \n@@ -900,7 +900,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     }\n                 }\n                 mir::InlineAsmOperand::SymFn { ref value } => {\n-                    let literal = self.monomorphize(&value.literal);\n+                    let literal = self.monomorphize(value.literal);\n                     if let ty::FnDef(def_id, substs) = *literal.ty.kind() {\n                         let instance = ty::Instance::resolve_for_fn_ptr(\n                             bx.tcx(),"}, {"sha": "c8001b8daf0dbbc2bcde1ca94cf4fb1186143baf", "filename": "compiler/rustc_codegen_ssa/src/mir/constant.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -16,15 +16,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         constant: &mir::Constant<'tcx>,\n     ) -> Result<OperandRef<'tcx, Bx::Value>, ErrorHandled> {\n         let val = self.eval_mir_constant(constant)?;\n-        let ty = self.monomorphize(&constant.literal.ty);\n+        let ty = self.monomorphize(constant.literal.ty);\n         Ok(OperandRef::from_const(bx, val, ty))\n     }\n \n     pub fn eval_mir_constant(\n         &mut self,\n         constant: &mir::Constant<'tcx>,\n     ) -> Result<ConstValue<'tcx>, ErrorHandled> {\n-        match self.monomorphize(&constant.literal).val {\n+        match self.monomorphize(constant.literal).val {\n             ty::ConstKind::Unevaluated(def, substs, promoted) => self\n                 .cx\n                 .tcx()\n@@ -83,7 +83,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             .unwrap_or_else(|_| {\n                 bx.tcx().sess.span_err(span, \"could not evaluate shuffle_indices at compile time\");\n                 // We've errored, so we don't have to produce working code.\n-                let ty = self.monomorphize(&ty);\n+                let ty = self.monomorphize(ty);\n                 let llty = bx.backend_type(bx.layout_of(ty));\n                 (bx.const_undef(llty), ty)\n             })"}, {"sha": "c4191a4e23d9577d52bae704710e82a5dd949717", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -160,7 +160,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             // FIXME(eddyb) is this `+ 1` needed at all?\n                             let kind = VariableKind::ArgumentVariable(arg_index + 1);\n \n-                            let arg_ty = self.monomorphize(&decl.ty);\n+                            let arg_ty = self.monomorphize(decl.ty);\n \n                             self.cx.create_dbg_var(name, arg_ty, dbg_scope, kind, span)\n                         },"}, {"sha": "94340e920481167d0dc675095cc43745072c547c", "filename": "compiler/rustc_codegen_ssa/src/mir/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -64,7 +64,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         };\n \n         let sig = callee_ty.fn_sig(bx.tcx());\n-        let sig = bx.tcx().normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n+        let sig = bx.tcx().normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), sig);\n         let arg_tys = sig.inputs();\n         let ret_ty = sig.output();\n         let name = bx.tcx().item_name(def_id);"}, {"sha": "640f805d5e88f66aad772b354fdef26924c7ca44", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -87,7 +87,7 @@ pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n }\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n-    pub fn monomorphize<T>(&self, value: &T) -> T\n+    pub fn monomorphize<T>(&self, value: T) -> T\n     where\n         T: Copy + TypeFoldable<'tcx>,\n     {\n@@ -208,7 +208,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n         let mut allocate_local = |local| {\n             let decl = &mir.local_decls[local];\n-            let layout = bx.layout_of(fx.monomorphize(&decl.ty));\n+            let layout = bx.layout_of(fx.monomorphize(decl.ty));\n             assert!(!layout.ty.has_erasable_regions());\n \n             if local == mir::RETURN_PLACE && fx.fn_abi.ret.is_indirect() {\n@@ -364,7 +364,7 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 // to reconstruct it into a tuple local variable, from multiple\n                 // individual LLVM function arguments.\n \n-                let arg_ty = fx.monomorphize(&arg_decl.ty);\n+                let arg_ty = fx.monomorphize(arg_decl.ty);\n                 let tupled_arg_tys = match arg_ty.kind() {\n                     ty::Tuple(tys) => tys,\n                     _ => bug!(\"spread argument isn't a tuple?!\"),\n@@ -385,7 +385,7 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             }\n \n             if fx.fn_abi.c_variadic && arg_index == fx.fn_abi.args.len() {\n-                let arg_ty = fx.monomorphize(&arg_decl.ty);\n+                let arg_ty = fx.monomorphize(arg_decl.ty);\n \n                 let va_list = PlaceRef::alloca(bx, bx.layout_of(arg_ty));\n                 bx.va_start(va_list.llval);"}, {"sha": "08a4ae3962bee334880d4e4a58f5732b4cdc14d1", "filename": "compiler/rustc_codegen_ssa/src/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -452,7 +452,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     bx.abort();\n                     // We still have to return an operand but it doesn't matter,\n                     // this code is unreachable.\n-                    let ty = self.monomorphize(&constant.literal.ty);\n+                    let ty = self.monomorphize(constant.literal.ty);\n                     let layout = bx.cx().layout_of(ty);\n                     bx.load_operand(PlaceRef::new_sized(\n                         bx.cx().const_undef(bx.cx().type_ptr_to(bx.cx().backend_type(layout))),"}, {"sha": "e4f4c884470c71785c76e362df22191e235f06c0", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -485,7 +485,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             cg_base.project_index(bx, bx.cx().const_usize(from as u64));\n                         let projected_ty =\n                             PlaceTy::from_ty(cg_base.layout.ty).projection_ty(tcx, elem).ty;\n-                        subslice.layout = bx.cx().layout_of(self.monomorphize(&projected_ty));\n+                        subslice.layout = bx.cx().layout_of(self.monomorphize(projected_ty));\n \n                         if subslice.layout.is_unsized() {\n                             assert!(from_end, \"slice subslices should be `from_end`\");\n@@ -515,6 +515,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn monomorphized_place_ty(&self, place_ref: mir::PlaceRef<'tcx>) -> Ty<'tcx> {\n         let tcx = self.cx.tcx();\n         let place_ty = mir::Place::ty_from(place_ref.local, place_ref.projection, self.mir, tcx);\n-        self.monomorphize(&place_ty.ty)\n+        self.monomorphize(place_ty.ty)\n     }\n }"}, {"sha": "2ad470c2693de89a89f9bd3766025ce04c81e7cc", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -106,7 +106,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 }\n \n                 let count =\n-                    self.monomorphize(&count).eval_usize(bx.cx().tcx(), ty::ParamEnv::reveal_all());\n+                    self.monomorphize(count).eval_usize(bx.cx().tcx(), ty::ParamEnv::reveal_all());\n \n                 bx.write_operand_repeatedly(cg_elem, count, dest)\n             }\n@@ -181,7 +181,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             mir::Rvalue::Cast(ref kind, ref source, mir_cast_ty) => {\n                 let operand = self.codegen_operand(&mut bx, source);\n                 debug!(\"cast operand is {:?}\", operand);\n-                let cast = bx.cx().layout_of(self.monomorphize(&mir_cast_ty));\n+                let cast = bx.cx().layout_of(self.monomorphize(mir_cast_ty));\n \n                 let val = match *kind {\n                     mir::CastKind::Pointer(PointerCast::ReifyFnPointer) => {\n@@ -502,7 +502,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             mir::Rvalue::NullaryOp(mir::NullOp::SizeOf, ty) => {\n-                let ty = self.monomorphize(&ty);\n+                let ty = self.monomorphize(ty);\n                 assert!(bx.cx().type_is_sized(ty));\n                 let val = bx.cx().const_usize(bx.cx().layout_of(ty).size.bytes());\n                 let tcx = self.cx.tcx();\n@@ -516,7 +516,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             mir::Rvalue::NullaryOp(mir::NullOp::Box, content_ty) => {\n-                let content_ty = self.monomorphize(&content_ty);\n+                let content_ty = self.monomorphize(content_ty);\n                 let content_layout = bx.cx().layout_of(content_ty);\n                 let llsize = bx.cx().const_usize(content_layout.size.bytes());\n                 let llalign = bx.cx().const_usize(content_layout.align.abi.bytes());\n@@ -554,7 +554,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 // aggregate rvalues are allowed to be operands.\n                 let ty = rvalue.ty(self.mir, self.cx.tcx());\n                 let operand =\n-                    OperandRef::new_zst(&mut bx, self.cx.layout_of(self.monomorphize(&ty)));\n+                    OperandRef::new_zst(&mut bx, self.cx.layout_of(self.monomorphize(ty)));\n                 (bx, operand)\n             }\n         }\n@@ -774,7 +774,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             mir::Rvalue::Repeat(..) |\n             mir::Rvalue::Aggregate(..) => {\n                 let ty = rvalue.ty(self.mir, self.cx.tcx());\n-                let ty = self.monomorphize(&ty);\n+                let ty = self.monomorphize(ty);\n                 self.cx.spanned_layout_of(ty, span).is_zst()\n             }\n         }"}, {"sha": "6b952f20dd12b0676725c38759871e003a37d54a", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -27,6 +27,7 @@\n #![feature(extend_one)]\n #![feature(const_panic)]\n #![feature(min_const_generics)]\n+#![feature(new_uninit)]\n #![feature(once_cell)]\n #![feature(maybe_uninit_uninit_array)]\n #![allow(rustc::default_hash_types)]\n@@ -70,6 +71,7 @@ pub mod box_region;\n pub mod captures;\n pub mod const_cstr;\n pub mod flock;\n+pub mod functor;\n pub mod fx;\n pub mod graph;\n pub mod jobserver;"}, {"sha": "6781fbc95c0eef955a99ac45219981a40f784f77", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -38,7 +38,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// [c]: https://rust-lang.github.io/chalk/book/canonical_queries/canonicalization.html#canonicalizing-the-query\n     pub fn canonicalize_query<V>(\n         &self,\n-        value: &V,\n+        value: V,\n         query_state: &mut OriginalQueryValues<'tcx>,\n     ) -> Canonicalized<'tcx, V>\n     where\n@@ -80,7 +80,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// out the [chapter in the rustc dev guide][c].\n     ///\n     /// [c]: https://rust-lang.github.io/chalk/book/canonical_queries/canonicalization.html#canonicalizing-the-query-result\n-    pub fn canonicalize_response<V>(&self, value: &V) -> Canonicalized<'tcx, V>\n+    pub fn canonicalize_response<V>(&self, value: V) -> Canonicalized<'tcx, V>\n     where\n         V: TypeFoldable<'tcx>,\n     {\n@@ -94,7 +94,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         )\n     }\n \n-    pub fn canonicalize_user_type_annotation<V>(&self, value: &V) -> Canonicalized<'tcx, V>\n+    pub fn canonicalize_user_type_annotation<V>(&self, value: V) -> Canonicalized<'tcx, V>\n     where\n         V: TypeFoldable<'tcx>,\n     {\n@@ -123,7 +123,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     // and just use `canonicalize_query`.\n     pub fn canonicalize_hr_query_hack<V>(\n         &self,\n-        value: &V,\n+        value: V,\n         query_state: &mut OriginalQueryValues<'tcx>,\n     ) -> Canonicalized<'tcx, V>\n     where\n@@ -293,7 +293,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n         self.tcx\n     }\n \n-    fn fold_binder<T>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T>\n+    fn fold_binder<T>(&mut self, t: ty::Binder<T>) -> ty::Binder<T>\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -479,7 +479,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n     /// The main `canonicalize` method, shared impl of\n     /// `canonicalize_query` and `canonicalize_response`.\n     fn canonicalize<V>(\n-        value: &V,\n+        value: V,\n         infcx: Option<&InferCtxt<'_, 'tcx>>,\n         tcx: TyCtxt<'tcx>,\n         canonicalize_region_mode: &dyn CanonicalizeRegionMode,"}, {"sha": "c8d66cbb695d8dc1923bf521f7a1a9490fc9c507", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -59,7 +59,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         Canonical<'tcx, QueryResponse<'tcx, T>>: ArenaAllocatable<'tcx>,\n     {\n         let query_response = self.make_query_response(inference_vars, answer, fulfill_cx)?;\n-        let canonical_result = self.canonicalize_response(&query_response);\n+        let canonical_result = self.canonicalize_response(query_response);\n \n         debug!(\"make_canonicalized_query_response: canonical_result = {:#?}\", canonical_result);\n \n@@ -83,7 +83,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     where\n         T: Debug + TypeFoldable<'tcx>,\n     {\n-        self.canonicalize_response(&QueryResponse {\n+        self.canonicalize_response(QueryResponse {\n             var_values: inference_vars,\n             region_constraints: QueryRegionConstraints::default(),\n             certainty: Certainty::Proven, // Ambiguities are OK!\n@@ -176,7 +176,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         ));\n \n         let user_result: R =\n-            query_response.substitute_projected(self.tcx, &result_subst, |q_r| &q_r.value);\n+            query_response.substitute_projected(self.tcx, &result_subst, |q_r| q_r.value.clone());\n \n         Ok(InferOk { value: user_result, obligations })\n     }\n@@ -238,7 +238,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         for (index, original_value) in original_values.var_values.iter().enumerate() {\n             // ...with the value `v_r` of that variable from the query.\n             let result_value = query_response.substitute_projected(self.tcx, &result_subst, |v| {\n-                &v.var_values[BoundVar::new(index)]\n+                v.var_values[BoundVar::new(index)]\n             });\n             match (original_value.unpack(), result_value.unpack()) {\n                 (\n@@ -296,7 +296,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n \n         // ...also include the other query region constraints from the query.\n         output_query_region_constraints.outlives.extend(\n-            query_response.value.region_constraints.outlives.iter().filter_map(|r_c| {\n+            query_response.value.region_constraints.outlives.iter().filter_map(|&r_c| {\n                 let r_c = substitute_value(self.tcx, &result_subst, r_c);\n \n                 // Screen out `'a: 'a` cases -- we skip the binder here but\n@@ -314,11 +314,11 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 .region_constraints\n                 .member_constraints\n                 .iter()\n-                .map(|p_c| substitute_value(self.tcx, &result_subst, p_c)),\n+                .map(|p_c| substitute_value(self.tcx, &result_subst, p_c.clone())),\n         );\n \n         let user_result: R =\n-            query_response.substitute_projected(self.tcx, &result_subst, |q_r| &q_r.value);\n+            query_response.substitute_projected(self.tcx, &result_subst, |q_r| q_r.value.clone());\n \n         Ok(InferOk { value: user_result, obligations })\n     }\n@@ -502,7 +502,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         // `query_response.var_values` after applying the substitution\n         // `result_subst`.\n         let substituted_query_response = |index: BoundVar| -> GenericArg<'tcx> {\n-            query_response.substitute_projected(self.tcx, &result_subst, |v| &v.var_values[index])\n+            query_response.substitute_projected(self.tcx, &result_subst, |v| v.var_values[index])\n         };\n \n         // Unify the original value for each variable with the value\n@@ -524,7 +524,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         unsubstituted_region_constraints: &'a [QueryOutlivesConstraint<'tcx>],\n         result_subst: &'a CanonicalVarValues<'tcx>,\n     ) -> impl Iterator<Item = PredicateObligation<'tcx>> + 'a + Captures<'tcx> {\n-        unsubstituted_region_constraints.iter().map(move |constraint| {\n+        unsubstituted_region_constraints.iter().map(move |&constraint| {\n             let ty::OutlivesPredicate(k1, r2) =\n                 substitute_value(self.tcx, result_subst, constraint).skip_binder();\n "}, {"sha": "cd4f1fa3bc30a2c78fe62e28d5ba47488199f154", "filename": "compiler/rustc_infer/src/infer/canonical/substitute.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -28,7 +28,7 @@ pub(super) trait CanonicalExt<'tcx, V> {\n         &self,\n         tcx: TyCtxt<'tcx>,\n         var_values: &CanonicalVarValues<'tcx>,\n-        projection_fn: impl FnOnce(&V) -> &T,\n+        projection_fn: impl FnOnce(&V) -> T,\n     ) -> T\n     where\n         T: TypeFoldable<'tcx>;\n@@ -39,14 +39,14 @@ impl<'tcx, V> CanonicalExt<'tcx, V> for Canonical<'tcx, V> {\n     where\n         V: TypeFoldable<'tcx>,\n     {\n-        self.substitute_projected(tcx, var_values, |value| value)\n+        self.substitute_projected(tcx, var_values, |value| value.clone())\n     }\n \n     fn substitute_projected<T>(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         var_values: &CanonicalVarValues<'tcx>,\n-        projection_fn: impl FnOnce(&V) -> &T,\n+        projection_fn: impl FnOnce(&V) -> T,\n     ) -> T\n     where\n         T: TypeFoldable<'tcx>,\n@@ -60,16 +60,16 @@ impl<'tcx, V> CanonicalExt<'tcx, V> for Canonical<'tcx, V> {\n /// Substitute the values from `var_values` into `value`. `var_values`\n /// must be values for the set of canonical variables that appear in\n /// `value`.\n-pub(super) fn substitute_value<'a, 'tcx, T>(\n+pub(super) fn substitute_value<'tcx, T>(\n     tcx: TyCtxt<'tcx>,\n     var_values: &CanonicalVarValues<'tcx>,\n-    value: &'a T,\n+    value: T,\n ) -> T\n where\n     T: TypeFoldable<'tcx>,\n {\n     if var_values.var_values.is_empty() {\n-        value.clone()\n+        value\n     } else {\n         let fld_r =\n             |br: ty::BoundRegion| match var_values.var_values[br.assert_bound_var()].unpack() {"}, {"sha": "5a164635f4f66c269ee7b6e912b6f55f32ddc34d", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -389,7 +389,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         member_region,\n                         span,\n                     } => {\n-                        let hidden_ty = self.resolve_vars_if_possible(&hidden_ty);\n+                        let hidden_ty = self.resolve_vars_if_possible(hidden_ty);\n                         unexpected_hidden_region_diagnostic(\n                             self.tcx,\n                             span,\n@@ -590,7 +590,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ) {\n         match cause.code {\n             ObligationCauseCode::Pattern { origin_expr: true, span: Some(span), root_ty } => {\n-                let ty = self.resolve_vars_if_possible(&root_ty);\n+                let ty = self.resolve_vars_if_possible(root_ty);\n                 if ty.is_suggestable() {\n                     // don't show type `_`\n                     err.span_label(span, format!(\"this expression has type `{}`\", ty));\n@@ -661,7 +661,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 }\n                 _ => {\n                     // `last_ty` can be `!`, `expected` will have better info when present.\n-                    let t = self.resolve_vars_if_possible(&match exp_found {\n+                    let t = self.resolve_vars_if_possible(match exp_found {\n                         Some(ty::error::ExpectedFound { expected, .. }) => expected,\n                         _ => last_ty,\n                     });\n@@ -1547,7 +1547,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     ValuePairs::TraitRefs(_) => (false, Mismatch::Fixed(\"trait\")),\n                     _ => (false, Mismatch::Fixed(\"type\")),\n                 };\n-                let vals = match self.values_str(&values) {\n+                let vals = match self.values_str(values) {\n                     Some((expected, found)) => Some((expected, found)),\n                     None => {\n                         // Derived error. Cancel the emitter.\n@@ -1893,32 +1893,32 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     fn values_str(\n         &self,\n-        values: &ValuePairs<'tcx>,\n+        values: ValuePairs<'tcx>,\n     ) -> Option<(DiagnosticStyledString, DiagnosticStyledString)> {\n-        match *values {\n-            infer::Types(ref exp_found) => self.expected_found_str_ty(exp_found),\n-            infer::Regions(ref exp_found) => self.expected_found_str(exp_found),\n-            infer::Consts(ref exp_found) => self.expected_found_str(exp_found),\n-            infer::TraitRefs(ref exp_found) => {\n+        match values {\n+            infer::Types(exp_found) => self.expected_found_str_ty(exp_found),\n+            infer::Regions(exp_found) => self.expected_found_str(exp_found),\n+            infer::Consts(exp_found) => self.expected_found_str(exp_found),\n+            infer::TraitRefs(exp_found) => {\n                 let pretty_exp_found = ty::error::ExpectedFound {\n                     expected: exp_found.expected.print_only_trait_path(),\n                     found: exp_found.found.print_only_trait_path(),\n                 };\n-                self.expected_found_str(&pretty_exp_found)\n+                self.expected_found_str(pretty_exp_found)\n             }\n-            infer::PolyTraitRefs(ref exp_found) => {\n+            infer::PolyTraitRefs(exp_found) => {\n                 let pretty_exp_found = ty::error::ExpectedFound {\n                     expected: exp_found.expected.print_only_trait_path(),\n                     found: exp_found.found.print_only_trait_path(),\n                 };\n-                self.expected_found_str(&pretty_exp_found)\n+                self.expected_found_str(pretty_exp_found)\n             }\n         }\n     }\n \n     fn expected_found_str_ty(\n         &self,\n-        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n+        exp_found: ty::error::ExpectedFound<Ty<'tcx>>,\n     ) -> Option<(DiagnosticStyledString, DiagnosticStyledString)> {\n         let exp_found = self.resolve_vars_if_possible(exp_found);\n         if exp_found.references_error() {\n@@ -1931,7 +1931,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// Returns a string of the form \"expected `{}`, found `{}`\".\n     fn expected_found_str<T: fmt::Display + TypeFoldable<'tcx>>(\n         &self,\n-        exp_found: &ty::error::ExpectedFound<T>,\n+        exp_found: ty::error::ExpectedFound<T>,\n     ) -> Option<(DiagnosticStyledString, DiagnosticStyledString)> {\n         let exp_found = self.resolve_vars_if_possible(exp_found);\n         if exp_found.references_error() {\n@@ -2180,7 +2180,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"...\",\n                 );\n                 if let Some(infer::RelateParamBound(_, t)) = origin {\n-                    let t = self.resolve_vars_if_possible(&t);\n+                    let t = self.resolve_vars_if_possible(t);\n                     match t.kind() {\n                         // We've got:\n                         // fn get_later<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n@@ -2237,7 +2237,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             debug!(\"report_sub_sup_conflict: sub_trace.values={:?}\", sub_trace.values);\n \n             if let (Some((sup_expected, sup_found)), Some((sub_expected, sub_found))) =\n-                (self.values_str(&sup_trace.values), self.values_str(&sub_trace.values))\n+                (self.values_str(sup_trace.values), self.values_str(sub_trace.values))\n             {\n                 if sub_expected == sup_expected && sub_found == sup_found {\n                     note_and_explain_region("}, {"sha": "fd8f46a6926c0e3de8eefd10b4eda04a81119683", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -49,7 +49,7 @@ impl<'a, 'tcx> FindHirNodeVisitor<'a, 'tcx> {\n             .and_then(|typeck_results| typeck_results.borrow().node_type_opt(hir_id));\n         match ty_opt {\n             Some(ty) => {\n-                let ty = self.infcx.resolve_vars_if_possible(&ty);\n+                let ty = self.infcx.resolve_vars_if_possible(ty);\n                 if ty.walk().any(|inner| {\n                     inner == self.target\n                         || match (inner.unpack(), self.target.unpack()) {\n@@ -343,7 +343,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         arg: GenericArg<'tcx>,\n         error_code: TypeAnnotationNeeded,\n     ) -> DiagnosticBuilder<'tcx> {\n-        let arg = self.resolve_vars_if_possible(&arg);\n+        let arg = self.resolve_vars_if_possible(arg);\n         let arg_data = self.extract_inference_diagnostics_data(arg, None);\n         let kind_str = match arg.unpack() {\n             GenericArgKind::Type(_) => \"type\",\n@@ -686,7 +686,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         span: Span,\n         ty: Ty<'tcx>,\n     ) -> DiagnosticBuilder<'tcx> {\n-        let ty = self.resolve_vars_if_possible(&ty);\n+        let ty = self.resolve_vars_if_possible(ty);\n         let data = self.extract_inference_diagnostics_data(ty.into(), None);\n \n         let mut err = struct_span_err!("}, {"sha": "e8e0326d978658bdb88d06751832b1c005527311", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -234,14 +234,13 @@ impl NiceRegionError<'me, 'tcx> {\n             false\n         };\n \n-        let expected_trait_ref = self.infcx.resolve_vars_if_possible(&ty::TraitRef {\n+        let expected_trait_ref = self.infcx.resolve_vars_if_possible(ty::TraitRef {\n             def_id: trait_def_id,\n             substs: expected_substs,\n         });\n-        let actual_trait_ref = self.infcx.resolve_vars_if_possible(&ty::TraitRef {\n-            def_id: trait_def_id,\n-            substs: actual_substs,\n-        });\n+        let actual_trait_ref = self\n+            .infcx\n+            .resolve_vars_if_possible(ty::TraitRef { def_id: trait_def_id, substs: actual_substs });\n \n         // Search the expected and actual trait references to see (a)\n         // whether the sub/sup placeholders appear in them (sometimes"}, {"sha": "ede94c3d9f62dcc8fe3f20c8f4b7c4809e244d93", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -414,7 +414,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             tcx,\n             ctxt.param_env,\n             ctxt.assoc_item.def_id,\n-            self.infcx.resolve_vars_if_possible(&ctxt.substs),\n+            self.infcx.resolve_vars_if_possible(ctxt.substs),\n         ) {\n             Ok(Some(instance)) => instance,\n             _ => return false,"}, {"sha": "4d3217a9c0bd977afada57fb34527163c2642667", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/trait_impl_difference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -86,7 +86,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         }\n \n         if let Some((expected, found)) =\n-            self.infcx.expected_found_str_ty(&ExpectedFound { expected, found })\n+            self.infcx.expected_found_str_ty(ExpectedFound { expected, found })\n         {\n             // Highlighted the differences when showing the \"expected/found\" note.\n             err.note_expected_found(&\"\", expected, &\"\", found);"}, {"sha": "8d0100440a8a51cf415e3adecdb03546515138bb", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -55,12 +55,12 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let owner_id = hir.body_owner(body_id);\n         let fn_decl = hir.fn_decl_by_hir_id(owner_id).unwrap();\n         let poly_fn_sig = self.tcx().fn_sig(id);\n-        let fn_sig = self.tcx().liberate_late_bound_regions(id, &poly_fn_sig);\n+        let fn_sig = self.tcx().liberate_late_bound_regions(id, poly_fn_sig);\n         body.params.iter().enumerate().find_map(|(index, param)| {\n             // May return None; sometimes the tables are not yet populated.\n             let ty = fn_sig.inputs()[index];\n             let mut found_anon_region = false;\n-            let new_param_ty = self.tcx().fold_regions(&ty, &mut false, |r, _| {\n+            let new_param_ty = self.tcx().fold_regions(ty, &mut false, |r, _| {\n                 if *r == *anon_region {\n                     found_anon_region = true;\n                     replace_region"}, {"sha": "7fb94332cad5c9629a26f64faba08a48415bcb58", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -24,7 +24,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         };\n         match *origin {\n             infer::Subtype(ref trace) => {\n-                if let Some((expected, found)) = self.values_str(&trace.values) {\n+                if let Some((expected, found)) = self.values_str(trace.values) {\n                     label_or_note(\n                         trace.cause.span,\n                         &format!(\"...so that the {}\", trace.cause.as_requirement_str()),"}, {"sha": "c292b2bdb30403077f27d6e430ea206c83b5a56d", "filename": "compiler/rustc_infer/src/infer/fudge.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -105,7 +105,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let (mut fudger, value) = self.probe(|_| {\n             match f() {\n                 Ok(value) => {\n-                    let value = self.resolve_vars_if_possible(&value);\n+                    let value = self.resolve_vars_if_possible(value);\n \n                     // At this point, `value` could in principle refer\n                     // to inference variables that have been created during"}, {"sha": "9d9ecf5b384e78de43f77162e17cfba0fcd9cd7a", "filename": "compiler/rustc_infer/src/infer/higher_ranked/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -33,14 +33,14 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n         self.infcx.commit_if_ok(|_| {\n             // First, we instantiate each bound region in the supertype with a\n             // fresh placeholder region.\n-            let b_prime = self.infcx.replace_bound_vars_with_placeholders(&b);\n+            let b_prime = self.infcx.replace_bound_vars_with_placeholders(b);\n \n             // Next, we instantiate each bound region in the subtype\n             // with a fresh region variable. These region variables --\n             // but no other pre-existing region variables -- can name\n             // the placeholders.\n             let (a_prime, _) =\n-                self.infcx.replace_bound_vars_with_fresh_vars(span, HigherRankedType, &a);\n+                self.infcx.replace_bound_vars_with_fresh_vars(span, HigherRankedType, a);\n \n             debug!(\"a_prime={:?}\", a_prime);\n             debug!(\"b_prime={:?}\", b_prime);\n@@ -66,7 +66,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// the [rustc dev guide].\n     ///\n     /// [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/traits/hrtb.html\n-    pub fn replace_bound_vars_with_placeholders<T>(&self, binder: &ty::Binder<T>) -> T\n+    pub fn replace_bound_vars_with_placeholders<T>(&self, binder: ty::Binder<T>) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -113,10 +113,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         debug!(\n             \"replace_bound_vars_with_placeholders(\\\n              next_universe={:?}, \\\n-             binder={:?}, \\\n              result={:?}, \\\n              map={:?})\",\n-            next_universe, binder, result, map,\n+            next_universe, result, map,\n         );\n \n         result"}, {"sha": "d7b2ce7ee208383194e2841adfe84678a7ce98ba", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -1001,7 +1001,7 @@ impl<'tcx> LexicalRegionResolutions<'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        tcx.fold_regions(&value, &mut false, |r, _db| match r {\n+        tcx.fold_regions(value, &mut false, |r, _db| match r {\n             ty::ReVar(rid) => self.resolve_var(*rid),\n             _ => r,\n         })"}, {"sha": "a045378f5027d8375c98cba5dbcff342b8b44134", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -345,7 +345,7 @@ pub struct InferCtxt<'a, 'tcx> {\n }\n \n /// See the `error_reporting` module for more details.\n-#[derive(Clone, Debug, PartialEq, Eq, TypeFoldable)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, TypeFoldable)]\n pub enum ValuePairs<'tcx> {\n     Types(ExpectedFound<Ty<'tcx>>),\n     Regions(ExpectedFound<ty::Region<'tcx>>),\n@@ -955,7 +955,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         Some(self.commit_if_ok(|_snapshot| {\n             let ty::SubtypePredicate { a_is_expected, a, b } =\n-                self.replace_bound_vars_with_placeholders(&predicate);\n+                self.replace_bound_vars_with_placeholders(predicate);\n \n             let ok = self.at(cause, param_env).sub_exp(a_is_expected, a, b)?;\n \n@@ -970,7 +970,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ) -> UnitResult<'tcx> {\n         self.commit_if_ok(|_snapshot| {\n             let ty::OutlivesPredicate(r_a, r_b) =\n-                self.replace_bound_vars_with_placeholders(&predicate);\n+                self.replace_bound_vars_with_placeholders(predicate);\n             let origin = SubregionOrigin::from_obligation_cause(cause, || {\n                 RelateRegionParamBound(cause.span)\n             });\n@@ -1266,15 +1266,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn ty_to_string(&self, t: Ty<'tcx>) -> String {\n-        self.resolve_vars_if_possible(&t).to_string()\n+        self.resolve_vars_if_possible(t).to_string()\n     }\n \n     pub fn tys_to_string(&self, ts: &[Ty<'tcx>]) -> String {\n         let tstrs: Vec<String> = ts.iter().map(|t| self.ty_to_string(*t)).collect();\n         format!(\"({})\", tstrs.join(\", \"))\n     }\n \n-    pub fn trait_ref_to_string(&self, t: &ty::TraitRef<'tcx>) -> String {\n+    pub fn trait_ref_to_string(&self, t: ty::TraitRef<'tcx>) -> String {\n         self.resolve_vars_if_possible(t).print_only_trait_path().to_string()\n     }\n \n@@ -1314,7 +1314,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// is left as is. This is an idempotent operation that does\n     /// not affect inference state in any way and so you can do it\n     /// at will.\n-    pub fn resolve_vars_if_possible<T>(&self, value: &T) -> T\n+    pub fn resolve_vars_if_possible<T>(&self, value: T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -1349,7 +1349,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn fully_resolve<T: TypeFoldable<'tcx>>(&self, value: &T) -> FixupResult<'tcx, T> {\n+    pub fn fully_resolve<T: TypeFoldable<'tcx>>(&self, value: T) -> FixupResult<'tcx, T> {\n         /*!\n          * Attempts to resolve all type/region/const variables in\n          * `value`. Region inference must have been run already (e.g.,\n@@ -1383,7 +1383,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     where\n         M: FnOnce(String) -> DiagnosticBuilder<'tcx>,\n     {\n-        let actual_ty = self.resolve_vars_if_possible(&actual_ty);\n+        let actual_ty = self.resolve_vars_if_possible(actual_ty);\n         debug!(\"type_error_struct_with_diag({:?}, {:?})\", sp, actual_ty);\n \n         // Don't report an error if actual type is `Error`.\n@@ -1420,7 +1420,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         span: Span,\n         lbrct: LateBoundRegionConversionTime,\n-        value: &ty::Binder<T>,\n+        value: ty::Binder<T>,\n     ) -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n     where\n         T: TypeFoldable<'tcx>,\n@@ -1508,7 +1508,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         span: Option<Span>,\n     ) -> EvalToConstValueResult<'tcx> {\n         let mut original_values = OriginalQueryValues::default();\n-        let canonical = self.canonicalize_query(&(param_env, substs), &mut original_values);\n+        let canonical = self.canonicalize_query((param_env, substs), &mut original_values);\n \n         let (param_env, substs) = canonical.value;\n         // The return value is the evaluated value which doesn't contain any reference to inference"}, {"sha": "16d86e6243de4ad8817232e0b984d3a6aa6e32ec", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -167,7 +167,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 sup_type, sub_region, origin\n             );\n \n-            let sup_type = self.resolve_vars_if_possible(&sup_type);\n+            let sup_type = self.resolve_vars_if_possible(sup_type);\n \n             if let Some(region_bound_pairs) = region_bound_pairs_map.get(&body_id) {\n                 let outlives = &mut TypeOutlives::new(\n@@ -205,7 +205,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n             implicit_region_bound,\n             param_env,\n         );\n-        let ty = self.resolve_vars_if_possible(&ty);\n+        let ty = self.resolve_vars_if_possible(ty);\n         outlives.type_must_outlive(origin, ty, region);\n     }\n }"}, {"sha": "f69212c599b6258dbb4964098c7a15749aea9e32", "filename": "compiler/rustc_infer/src/infer/outlives/verify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -124,10 +124,10 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         projection_ty: ty::ProjectionTy<'tcx>,\n     ) -> Vec<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n         let projection_ty = GenericKind::Projection(projection_ty).to_ty(self.tcx);\n-        let erased_projection_ty = self.tcx.erase_regions(&projection_ty);\n+        let erased_projection_ty = self.tcx.erase_regions(projection_ty);\n         self.declared_generic_bounds_from_env_with_compare_fn(|ty| {\n             if let ty::Projection(..) = ty.kind() {\n-                let erased_ty = self.tcx.erase_regions(&ty);\n+                let erased_ty = self.tcx.erase_regions(ty);\n                 erased_ty == erased_projection_ty\n             } else {\n                 false"}, {"sha": "d05c90606ccae1b2166abf89e59c5efaf322e7b6", "filename": "compiler/rustc_infer/src/infer/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -164,7 +164,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeFinder<'a, 'tcx> {\n /// Full type resolution replaces all type and region variables with\n /// their concrete results. If any variable cannot be replaced (never unified, etc)\n /// then an `Err` result is returned.\n-pub fn fully_resolve<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>, value: &T) -> FixupResult<'tcx, T>\n+pub fn fully_resolve<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>, value: T) -> FixupResult<'tcx, T>\n where\n     T: TypeFoldable<'tcx>,\n {"}, {"sha": "f7ae77d77153a3bea7d2a92f2c46b806928e41de", "filename": "compiler/rustc_infer/src/traits/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fstructural_impls.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -60,7 +60,7 @@ impl<'tcx> fmt::Debug for traits::MismatchedProjectionTypes<'tcx> {\n // TypeFoldable implementations.\n \n impl<'tcx, O: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Obligation<'tcx, O> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n         traits::Obligation {\n             cause: self.cause.clone(),\n             recursion_depth: self.recursion_depth,"}, {"sha": "b0b0e4372b8cdad54756290158bd598615515b44", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -9,7 +9,7 @@ pub fn anonymize_predicate<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     pred: ty::Predicate<'tcx>,\n ) -> ty::Predicate<'tcx> {\n-    match pred.kind() {\n+    match *pred.kind() {\n         ty::PredicateKind::ForAll(binder) => {\n             let new = ty::PredicateKind::ForAll(tcx.anonymize_late_bound_regions(binder));\n             tcx.reuse_or_mk_predicate(pred, new)"}, {"sha": "eedb0e31bccad4f48d757e3a13a22c8cab2cb6b3", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -880,7 +880,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             return FfiSafe;\n         }\n \n-        match ty.kind() {\n+        match *ty.kind() {\n             ty::Adt(def, _) if def.is_box() && matches!(self.mode, CItemKind::Definition) => {\n                 FfiSafe\n             }\n@@ -1044,7 +1044,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     };\n                 }\n \n-                let sig = tcx.erase_late_bound_regions(&sig);\n+                let sig = tcx.erase_late_bound_regions(sig);\n                 if !sig.output().is_unit() {\n                     let r = self.check_type_for_ffi(cache, sig.output());\n                     match r {\n@@ -1218,7 +1218,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     fn check_foreign_fn(&mut self, id: hir::HirId, decl: &hir::FnDecl<'_>) {\n         let def_id = self.cx.tcx.hir().local_def_id(id);\n         let sig = self.cx.tcx.fn_sig(def_id);\n-        let sig = self.cx.tcx.erase_late_bound_regions(&sig);\n+        let sig = self.cx.tcx.erase_late_bound_regions(sig);\n \n         for (input_ty, input_hir) in sig.inputs().iter().zip(decl.inputs) {\n             self.check_type_for_ffi_and_report_errors(input_hir.span, input_ty, false, false);\n@@ -1295,7 +1295,7 @@ impl<'tcx> LateLintPass<'tcx> for VariantSizeDifferences {\n         if let hir::ItemKind::Enum(ref enum_definition, _) = it.kind {\n             let item_def_id = cx.tcx.hir().local_def_id(it.hir_id);\n             let t = cx.tcx.type_of(item_def_id);\n-            let ty = cx.tcx.erase_regions(&t);\n+            let ty = cx.tcx.erase_regions(t);\n             let layout = match cx.layout_of(ty) {\n                 Ok(layout) => layout,\n                 Err("}, {"sha": "e5d4a2ae9f40a1419868ea2dc43e23099a771fa5", "filename": "compiler/rustc_macros/src/type_foldable.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_macros%2Fsrc%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_macros%2Fsrc%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Ftype_foldable.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -6,6 +6,12 @@ pub fn type_foldable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::\n     }\n \n     s.add_bounds(synstructure::AddBounds::Generics);\n+    let body_visit = s.each(|bind| {\n+        quote! {\n+            ::rustc_middle::ty::fold::TypeFoldable::visit_with(#bind, __folder)?;\n+        }\n+    });\n+    s.bind_with(|_| synstructure::BindStyle::Move);\n     let body_fold = s.each_variant(|vi| {\n         let bindings = vi.bindings();\n         vi.construct(|_, index| {\n@@ -16,20 +22,14 @@ pub fn type_foldable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::\n         })\n     });\n \n-    let body_visit = s.each(|bind| {\n-        quote! {\n-            ::rustc_middle::ty::fold::TypeFoldable::visit_with(#bind, __folder)?;\n-        }\n-    });\n-\n     s.bound_impl(\n         quote!(::rustc_middle::ty::fold::TypeFoldable<'tcx>),\n         quote! {\n             fn super_fold_with<__F: ::rustc_middle::ty::fold::TypeFolder<'tcx>>(\n-                &self,\n+                self,\n                 __folder: &mut __F\n             ) -> Self {\n-                match *self { #body_fold }\n+                match self { #body_fold }\n             }\n \n             fn super_visit_with<__F: ::rustc_middle::ty::fold::TypeVisitor<'tcx>>("}, {"sha": "73aee616e260bd24cde6b9592b56a110608920df", "filename": "compiler/rustc_middle/src/macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -53,10 +53,10 @@ macro_rules! CloneTypeFoldableImpls {\n         $(\n             impl<$tcx> $crate::ty::fold::TypeFoldable<$tcx> for $ty {\n                 fn super_fold_with<F: $crate::ty::fold::TypeFolder<$tcx>>(\n-                    &self,\n+                    self,\n                     _: &mut F\n                 ) -> $ty {\n-                    Clone::clone(self)\n+                    self\n                 }\n \n                 fn super_visit_with<F: $crate::ty::fold::TypeVisitor<$tcx>>(\n@@ -96,7 +96,7 @@ macro_rules! EnumTypeFoldableImpl {\n             $(where $($wc)*)*\n         {\n             fn super_fold_with<V: $crate::ty::fold::TypeFolder<$tcx>>(\n-                &self,\n+                self,\n                 folder: &mut V,\n             ) -> Self {\n                 EnumTypeFoldableImpl!(@FoldVariants(self, folder) input($($variants)*) output())"}, {"sha": "0517ec5bb1a8c83745b10cd46a5476c5c570f3c3", "filename": "compiler/rustc_middle/src/mir/interpret/queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -67,7 +67,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     ) -> EvalToConstValueResult<'tcx> {\n         // Const-eval shouldn't depend on lifetimes at all, so we can erase them, which should\n         // improve caching of queries.\n-        let inputs = self.erase_regions(&param_env.and(cid));\n+        let inputs = self.erase_regions(param_env.and(cid));\n         if let Some(span) = span {\n             self.at(span).eval_to_const_value_raw(inputs)\n         } else {"}, {"sha": "c405170aacf6c4a230ea02afb5c50100629ff54b", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -2455,7 +2455,7 @@ impl UserTypeProjection {\n CloneTypeFoldableAndLiftImpls! { ProjectionKind, }\n \n impl<'tcx> TypeFoldable<'tcx> for UserTypeProjection {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n         use crate::mir::ProjectionElem::*;\n \n         let base = self.base.fold_with(folder);"}, {"sha": "9c66d681ffa902b0fc7e35e4e5d625da739f0cfb", "filename": "compiler/rustc_middle/src/mir/type_foldable.rs", "status": "modified", "additions": 43, "deletions": 47, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -2,6 +2,7 @@\n \n use super::*;\n use crate::ty;\n+use rustc_data_structures::functor::IdFunctor;\n \n CloneTypeFoldableAndLiftImpls! {\n     BlockTailInfo,\n@@ -15,34 +16,33 @@ CloneTypeFoldableAndLiftImpls! {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n         use crate::mir::TerminatorKind::*;\n \n         let kind = match self.kind {\n             Goto { target } => Goto { target },\n-            SwitchInt { ref discr, switch_ty, ref targets } => SwitchInt {\n+            SwitchInt { discr, switch_ty, targets } => SwitchInt {\n                 discr: discr.fold_with(folder),\n                 switch_ty: switch_ty.fold_with(folder),\n                 targets: targets.clone(),\n             },\n-            Drop { ref place, target, unwind } => {\n+            Drop { place, target, unwind } => {\n                 Drop { place: place.fold_with(folder), target, unwind }\n             }\n-            DropAndReplace { ref place, ref value, target, unwind } => DropAndReplace {\n+            DropAndReplace { place, value, target, unwind } => DropAndReplace {\n                 place: place.fold_with(folder),\n                 value: value.fold_with(folder),\n                 target,\n                 unwind,\n             },\n-            Yield { ref value, resume, ref resume_arg, drop } => Yield {\n+            Yield { value, resume, resume_arg, drop } => Yield {\n                 value: value.fold_with(folder),\n                 resume,\n                 resume_arg: resume_arg.fold_with(folder),\n                 drop,\n             },\n-            Call { ref func, ref args, ref destination, cleanup, from_hir_call, fn_span } => {\n-                let dest =\n-                    destination.as_ref().map(|&(ref loc, dest)| (loc.fold_with(folder), dest));\n+            Call { func, args, destination, cleanup, from_hir_call, fn_span } => {\n+                let dest = destination.as_ref().map(|&(loc, dest)| (loc.fold_with(folder), dest));\n \n                 Call {\n                     func: func.fold_with(folder),\n@@ -53,13 +53,13 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                     fn_span,\n                 }\n             }\n-            Assert { ref cond, expected, ref msg, target, cleanup } => {\n+            Assert { cond, expected, msg, target, cleanup } => {\n                 use AssertKind::*;\n                 let msg = match msg {\n                     BoundsCheck { len, index } => {\n                         BoundsCheck { len: len.fold_with(folder), index: index.fold_with(folder) }\n                     }\n-                    Overflow(op, l, r) => Overflow(*op, l.fold_with(folder), r.fold_with(folder)),\n+                    Overflow(op, l, r) => Overflow(op, l.fold_with(folder), r.fold_with(folder)),\n                     OverflowNeg(op) => OverflowNeg(op.fold_with(folder)),\n                     DivisionByZero(op) => DivisionByZero(op.fold_with(folder)),\n                     RemainderByZero(op) => RemainderByZero(op.fold_with(folder)),\n@@ -76,7 +76,7 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                 FalseEdge { real_target, imaginary_target }\n             }\n             FalseUnwind { real_target, unwind } => FalseUnwind { real_target, unwind },\n-            InlineAsm { template, ref operands, options, line_spans, destination } => InlineAsm {\n+            InlineAsm { template, operands, options, line_spans, destination } => InlineAsm {\n                 template,\n                 operands: operands.fold_with(folder),\n                 options,\n@@ -140,8 +140,8 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for GeneratorKind {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n-        *self\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, _: &mut F) -> Self {\n+        self\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<()> {\n@@ -150,7 +150,7 @@ impl<'tcx> TypeFoldable<'tcx> for GeneratorKind {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Place<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n         Place { local: self.local.fold_with(folder), projection: self.projection.fold_with(folder) }\n     }\n \n@@ -161,7 +161,7 @@ impl<'tcx> TypeFoldable<'tcx> for Place<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<PlaceElem<'tcx>> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n         let v = self.iter().map(|t| t.fold_with(folder)).collect::<Vec<_>>();\n         folder.tcx().intern_place_elems(&v)\n     }\n@@ -172,29 +172,25 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<PlaceElem<'tcx>> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n         use crate::mir::Rvalue::*;\n-        match *self {\n-            Use(ref op) => Use(op.fold_with(folder)),\n-            Repeat(ref op, len) => Repeat(op.fold_with(folder), len.fold_with(folder)),\n+        match self {\n+            Use(op) => Use(op.fold_with(folder)),\n+            Repeat(op, len) => Repeat(op.fold_with(folder), len.fold_with(folder)),\n             ThreadLocalRef(did) => ThreadLocalRef(did.fold_with(folder)),\n-            Ref(region, bk, ref place) => {\n-                Ref(region.fold_with(folder), bk, place.fold_with(folder))\n-            }\n-            AddressOf(mutability, ref place) => AddressOf(mutability, place.fold_with(folder)),\n-            Len(ref place) => Len(place.fold_with(folder)),\n-            Cast(kind, ref op, ty) => Cast(kind, op.fold_with(folder), ty.fold_with(folder)),\n-            BinaryOp(op, ref rhs, ref lhs) => {\n-                BinaryOp(op, rhs.fold_with(folder), lhs.fold_with(folder))\n-            }\n-            CheckedBinaryOp(op, ref rhs, ref lhs) => {\n+            Ref(region, bk, place) => Ref(region.fold_with(folder), bk, place.fold_with(folder)),\n+            AddressOf(mutability, place) => AddressOf(mutability, place.fold_with(folder)),\n+            Len(place) => Len(place.fold_with(folder)),\n+            Cast(kind, op, ty) => Cast(kind, op.fold_with(folder), ty.fold_with(folder)),\n+            BinaryOp(op, rhs, lhs) => BinaryOp(op, rhs.fold_with(folder), lhs.fold_with(folder)),\n+            CheckedBinaryOp(op, rhs, lhs) => {\n                 CheckedBinaryOp(op, rhs.fold_with(folder), lhs.fold_with(folder))\n             }\n-            UnaryOp(op, ref val) => UnaryOp(op, val.fold_with(folder)),\n-            Discriminant(ref place) => Discriminant(place.fold_with(folder)),\n+            UnaryOp(op, val) => UnaryOp(op, val.fold_with(folder)),\n+            Discriminant(place) => Discriminant(place.fold_with(folder)),\n             NullaryOp(op, ty) => NullaryOp(op, ty.fold_with(folder)),\n-            Aggregate(ref kind, ref fields) => {\n-                let kind = box match **kind {\n+            Aggregate(kind, fields) => {\n+                let kind = kind.map_id(|kind| match kind {\n                     AggregateKind::Array(ty) => AggregateKind::Array(ty.fold_with(folder)),\n                     AggregateKind::Tuple => AggregateKind::Tuple,\n                     AggregateKind::Adt(def, v, substs, user_ty, n) => AggregateKind::Adt(\n@@ -210,7 +206,7 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n                     AggregateKind::Generator(id, substs, movablity) => {\n                         AggregateKind::Generator(id, substs.fold_with(folder), movablity)\n                     }\n-                };\n+                });\n                 Aggregate(kind, fields.fold_with(folder))\n             }\n         }\n@@ -263,11 +259,11 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Operand<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        match *self {\n-            Operand::Copy(ref place) => Operand::Copy(place.fold_with(folder)),\n-            Operand::Move(ref place) => Operand::Move(place.fold_with(folder)),\n-            Operand::Constant(ref c) => Operand::Constant(c.fold_with(folder)),\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+        match self {\n+            Operand::Copy(place) => Operand::Copy(place.fold_with(folder)),\n+            Operand::Move(place) => Operand::Move(place.fold_with(folder)),\n+            Operand::Constant(c) => Operand::Constant(c.fold_with(folder)),\n         }\n     }\n \n@@ -280,10 +276,10 @@ impl<'tcx> TypeFoldable<'tcx> for Operand<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for PlaceElem<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n         use crate::mir::ProjectionElem::*;\n \n-        match *self {\n+        match self {\n             Deref => Deref,\n             Field(f, ty) => Field(f, ty.fold_with(folder)),\n             Index(v) => Index(v.fold_with(folder)),\n@@ -307,25 +303,25 @@ impl<'tcx> TypeFoldable<'tcx> for PlaceElem<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Field {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n-        *self\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, _: &mut F) -> Self {\n+        self\n     }\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<()> {\n         ControlFlow::CONTINUE\n     }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for GeneratorSavedLocal {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n-        *self\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, _: &mut F) -> Self {\n+        self\n     }\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<()> {\n         ControlFlow::CONTINUE\n     }\n }\n \n impl<'tcx, R: Idx, C: Idx> TypeFoldable<'tcx> for BitMatrix<R, C> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, _: &mut F) -> Self {\n         self.clone()\n     }\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<()> {\n@@ -334,7 +330,7 @@ impl<'tcx, R: Idx, C: Idx> TypeFoldable<'tcx> for BitMatrix<R, C> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Constant<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n         Constant {\n             span: self.span,\n             user_ty: self.user_ty.fold_with(folder),"}, {"sha": "634d50368bd881223c02913435f1a415910d1c69", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -367,7 +367,7 @@ rustc_queries! {\n \n     TypeChecking {\n         /// Erases regions from `ty` to yield a new type.\n-        /// Normally you would just use `tcx.erase_regions(&value)`,\n+        /// Normally you would just use `tcx.erase_regions(value)`,\n         /// however, which uses this query as a kind of cache.\n         query erase_regions_ty(ty: Ty<'tcx>) -> Ty<'tcx> {\n             // This query is not expected to have input -- as a result, it"}, {"sha": "ecf2837b3e423f84c423c65859eed444b149d9b3", "filename": "compiler/rustc_middle/src/ty/consts/kind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -103,9 +103,9 @@ impl<'tcx> ConstKind<'tcx> {\n             // so that we don't try to invoke this query with\n             // any region variables.\n             let param_env_and_substs = tcx\n-                .erase_regions(&param_env)\n+                .erase_regions(param_env)\n                 .with_reveal_all_normalized(tcx)\n-                .and(tcx.erase_regions(&substs));\n+                .and(tcx.erase_regions(substs));\n \n             // HACK(eddyb) when the query key would contain inference variables,\n             // attempt using identity substs and `ParamEnv` instead, that will succeed"}, {"sha": "b8819b8051d5925b541309643110da0a854fde9b", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -1495,7 +1495,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         match ret_ty.kind() {\n             ty::FnDef(_, _) => {\n                 let sig = ret_ty.fn_sig(self);\n-                let output = self.erase_late_bound_regions(&sig.output());\n+                let output = self.erase_late_bound_regions(sig.output());\n                 if output.is_impl_trait() {\n                     let fn_decl = self.hir().fn_decl_by_hir_id(hir_id).unwrap();\n                     Some((output, fn_decl.output.span()))"}, {"sha": "4412ba9408c6cf5a909a2aae75cdfb2731be0be9", "filename": "compiler/rustc_middle/src/ty/erase_regions.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -15,17 +15,17 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Returns an equivalent value with all free regions removed (note\n     /// that late-bound regions remain, because they are important for\n     /// subtyping, but they are anonymized and normalized as well)..\n-    pub fn erase_regions<T>(self, value: &T) -> T\n+    pub fn erase_regions<T>(self, value: T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n         // If there's nothing to erase avoid performing the query at all\n         if !value.has_type_flags(TypeFlags::HAS_RE_LATE_BOUND | TypeFlags::HAS_FREE_REGIONS) {\n-            return value.clone();\n+            return value;\n         }\n-\n+        debug!(\"erase_regions({:?})\", value);\n         let value1 = value.fold_with(&mut RegionEraserVisitor { tcx: self });\n-        debug!(\"erase_regions({:?}) = {:?}\", value, value1);\n+        debug!(\"erase_regions = {:?}\", value1);\n         value1\n     }\n }\n@@ -43,7 +43,7 @@ impl TypeFolder<'tcx> for RegionEraserVisitor<'tcx> {\n         if ty.needs_infer() { ty.super_fold_with(self) } else { self.tcx.erase_regions_ty(ty) }\n     }\n \n-    fn fold_binder<T>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T>\n+    fn fold_binder<T>(&mut self, t: ty::Binder<T>) -> ty::Binder<T>\n     where\n         T: TypeFoldable<'tcx>,\n     {"}, {"sha": "ee5c7a5473a9f6d336d9c66f8d27d75f0604a858", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -44,8 +44,8 @@ use std::ops::ControlFlow;\n ///\n /// To implement this conveniently, use the derive macro located in librustc_macros.\n pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self;\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self;\n+    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n         self.super_fold_with(folder)\n     }\n \n@@ -158,8 +158,8 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n }\n \n impl TypeFoldable<'tcx> for hir::Constness {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n-        *self\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, _: &mut F) -> Self {\n+        self\n     }\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<()> {\n         ControlFlow::CONTINUE\n@@ -174,7 +174,7 @@ impl TypeFoldable<'tcx> for hir::Constness {\n pub trait TypeFolder<'tcx>: Sized {\n     fn tcx<'a>(&'a self) -> TyCtxt<'tcx>;\n \n-    fn fold_binder<T>(&mut self, t: &Binder<T>) -> Binder<T>\n+    fn fold_binder<T>(&mut self, t: Binder<T>) -> Binder<T>\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -266,7 +266,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// and skipped.\n     pub fn fold_regions<T>(\n         self,\n-        value: &T,\n+        value: T,\n         skipped_regions: &mut bool,\n         mut f: impl FnMut(ty::Region<'tcx>, ty::DebruijnIndex) -> ty::Region<'tcx>,\n     ) -> T\n@@ -406,7 +406,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx> {\n         self.tcx\n     }\n \n-    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n+    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: ty::Binder<T>) -> ty::Binder<T> {\n         self.current_index.shift_in(1);\n         let t = t.super_fold_with(self);\n         self.current_index.shift_out(1);\n@@ -466,7 +466,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for BoundVarReplacer<'a, 'tcx> {\n         self.tcx\n     }\n \n-    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n+    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: ty::Binder<T>) -> ty::Binder<T> {\n         self.current_index.shift_in(1);\n         let t = t.super_fold_with(self);\n         self.current_index.shift_out(1);\n@@ -549,7 +549,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// contain escaping bound types.\n     pub fn replace_late_bound_regions<T, F>(\n         self,\n-        value: &Binder<T>,\n+        value: Binder<T>,\n         fld_r: F,\n     ) -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n     where\n@@ -561,15 +561,15 @@ impl<'tcx> TyCtxt<'tcx> {\n         let fld_c = |bound_ct, ty| {\n             self.mk_const(ty::Const { val: ty::ConstKind::Bound(ty::INNERMOST, bound_ct), ty })\n         };\n-        self.replace_escaping_bound_vars(value.as_ref().skip_binder(), fld_r, fld_t, fld_c)\n+        self.replace_escaping_bound_vars(value.skip_binder(), fld_r, fld_t, fld_c)\n     }\n \n     /// Replaces all escaping bound vars. The `fld_r` closure replaces escaping\n     /// bound regions; the `fld_t` closure replaces escaping bound types and the `fld_c`\n     /// closure replaces escaping bound consts.\n     pub fn replace_escaping_bound_vars<T, F, G, H>(\n         self,\n-        value: &T,\n+        value: T,\n         mut fld_r: F,\n         mut fld_t: G,\n         mut fld_c: H,\n@@ -609,7 +609,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// types.\n     pub fn replace_bound_vars<T, F, G, H>(\n         self,\n-        value: &Binder<T>,\n+        value: Binder<T>,\n         fld_r: F,\n         fld_t: G,\n         fld_c: H,\n@@ -620,16 +620,12 @@ impl<'tcx> TyCtxt<'tcx> {\n         H: FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::Const<'tcx>,\n         T: TypeFoldable<'tcx>,\n     {\n-        self.replace_escaping_bound_vars(value.as_ref().skip_binder(), fld_r, fld_t, fld_c)\n+        self.replace_escaping_bound_vars(value.skip_binder(), fld_r, fld_t, fld_c)\n     }\n \n     /// Replaces any late-bound regions bound in `value` with\n     /// free variants attached to `all_outlive_scope`.\n-    pub fn liberate_late_bound_regions<T>(\n-        self,\n-        all_outlive_scope: DefId,\n-        value: &ty::Binder<T>,\n-    ) -> T\n+    pub fn liberate_late_bound_regions<T>(self, all_outlive_scope: DefId, value: ty::Binder<T>) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -683,7 +679,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Replaces any late-bound regions bound in `value` with `'erased`. Useful in codegen but also\n     /// method lookup and a few other places where precise region relationships are not required.\n-    pub fn erase_late_bound_regions<T>(self, value: &Binder<T>) -> T\n+    pub fn erase_late_bound_regions<T>(self, value: Binder<T>) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -698,7 +694,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// `FnSig`s or `TraitRef`s which are equivalent up to region naming will become\n     /// structurally identical. For example, `for<'a, 'b> fn(&'a isize, &'b isize)` and\n     /// `for<'a, 'b> fn(&'b isize, &'a isize)` will become identical after anonymization.\n-    pub fn anonymize_late_bound_regions<T>(self, sig: &Binder<T>) -> Binder<T>\n+    pub fn anonymize_late_bound_regions<T>(self, sig: Binder<T>) -> Binder<T>\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -740,7 +736,7 @@ impl TypeFolder<'tcx> for Shifter<'tcx> {\n         self.tcx\n     }\n \n-    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n+    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: ty::Binder<T>) -> ty::Binder<T> {\n         self.current_index.shift_in(1);\n         let t = t.super_fold_with(self);\n         self.current_index.shift_out(1);\n@@ -804,7 +800,7 @@ pub fn shift_region<'tcx>(\n     }\n }\n \n-pub fn shift_vars<'tcx, T>(tcx: TyCtxt<'tcx>, value: &T, amount: u32) -> T\n+pub fn shift_vars<'tcx, T>(tcx: TyCtxt<'tcx>, value: T, amount: u32) -> T\n where\n     T: TypeFoldable<'tcx>,\n {"}, {"sha": "f52466d85f890aa37323afac72fa6132fe522e31", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -359,15 +359,15 @@ impl<'tcx> Instance<'tcx> {\n         // HACK(eddyb) erase regions in `substs` first, so that `param_env.and(...)`\n         // below is more likely to ignore the bounds in scope (e.g. if the only\n         // generic parameters mentioned by `substs` were lifetime ones).\n-        let substs = tcx.erase_regions(&substs);\n+        let substs = tcx.erase_regions(substs);\n \n         // FIXME(eddyb) should this always use `param_env.with_reveal_all()`?\n         if let Some((did, param_did)) = def.as_const_arg() {\n             tcx.resolve_instance_of_const_arg(\n-                tcx.erase_regions(&param_env.and((did, param_did, substs))),\n+                tcx.erase_regions(param_env.and((did, param_did, substs))),\n             )\n         } else {\n-            tcx.resolve_instance(tcx.erase_regions(&param_env.and((def.did, substs))))\n+            tcx.resolve_instance(tcx.erase_regions(param_env.and((def.did, substs))))\n         }\n     }\n \n@@ -452,7 +452,7 @@ impl<'tcx> Instance<'tcx> {\n         let self_ty = tcx.mk_closure(closure_did, substs);\n \n         let sig = substs.as_closure().sig();\n-        let sig = tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n+        let sig = tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), sig);\n         assert_eq!(sig.inputs().len(), 1);\n         let substs = tcx.mk_substs_trait(self_ty, &[sig.inputs()[0].into()]);\n \n@@ -485,15 +485,15 @@ impl<'tcx> Instance<'tcx> {\n         &self,\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        v: &T,\n+        v: T,\n     ) -> T\n     where\n         T: TypeFoldable<'tcx> + Clone,\n     {\n         if let Some(substs) = self.substs_for_mir_body() {\n             tcx.subst_and_normalize_erasing_regions(substs, param_env, v)\n         } else {\n-            tcx.normalize_erasing_regions(param_env, v.clone())\n+            tcx.normalize_erasing_regions(param_env, v)\n         }\n     }\n "}, {"sha": "acc7d3c4960e8227e6c1f0ebfd416d30d6bc26cc", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -1756,7 +1756,7 @@ impl<'tcx> SizeSkeleton<'tcx> {\n                 match tail.kind() {\n                     ty::Param(_) | ty::Projection(_) => {\n                         debug_assert!(tail.has_param_types_or_consts());\n-                        Ok(SizeSkeleton::Pointer { non_zero, tail: tcx.erase_regions(&tail) })\n+                        Ok(SizeSkeleton::Pointer { non_zero, tail: tcx.erase_regions(tail) })\n                     }\n                     _ => bug!(\n                         \"SizeSkeleton::compute({}): layout errored ({}), yet \\\n@@ -2545,7 +2545,7 @@ where\n     ) -> Self {\n         debug!(\"FnAbi::new_internal({:?}, {:?})\", sig, extra_args);\n \n-        let sig = cx.tcx().normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n+        let sig = cx.tcx().normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), sig);\n \n         use rustc_target::spec::abi::Abi::*;\n         let conv = match cx.tcx().sess.target.adjust_abi(sig.abi) {"}, {"sha": "8fcf19ea48ad202b6fd8d671c82bc8dc278e8b41", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -1788,7 +1788,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ParamEnv<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ParamEnv<'tcx> {\n-    fn super_fold_with<F: ty::fold::TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: ty::fold::TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n         ParamEnv::new(self.caller_bounds().fold_with(folder), self.reveal().fold_with(folder))\n     }\n "}, {"sha": "9d97815a5f1b71f86b1fe90d0a9f503d4b7929ed", "filename": "compiler/rustc_middle/src/ty/normalize_erasing_regions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -30,7 +30,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         // Erase first before we do the real query -- this keeps the\n         // cache from being too polluted.\n-        let value = self.erase_regions(&value);\n+        let value = self.erase_regions(value);\n         if !value.has_projections() {\n             value\n         } else {\n@@ -49,7 +49,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn normalize_erasing_late_bound_regions<T>(\n         self,\n         param_env: ty::ParamEnv<'tcx>,\n-        value: &ty::Binder<T>,\n+        value: ty::Binder<T>,\n     ) -> T\n     where\n         T: TypeFoldable<'tcx>,\n@@ -65,7 +65,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self,\n         param_substs: SubstsRef<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        value: &T,\n+        value: T,\n     ) -> T\n     where\n         T: TypeFoldable<'tcx>,"}, {"sha": "42952ac2cd2ae377804c9b9619ed806c0930de09", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -1750,7 +1750,7 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n         define_scoped_cx!(self);\n \n         let mut region_index = self.region_index;\n-        let new_value = self.tcx.replace_late_bound_regions(value, |br| {\n+        let new_value = self.tcx.replace_late_bound_regions(value.clone(), |br| {\n             let _ = start_or_continue(&mut self, \"for<\", \", \");\n             let br = match br {\n                 ty::BrNamed(_, name) => {"}, {"sha": "afafc6f2a07c8e4ef6053a7c3866aee523fefc69", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 51, "deletions": 49, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -7,6 +7,7 @@ use crate::mir::ProjectionKind;\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use crate::ty::print::{with_no_trimmed_paths, FmtPrinter, Printer};\n use crate::ty::{self, InferConst, Lift, Ty, TyCtxt};\n+use rustc_data_structures::functor::IdFunctor;\n use rustc_hir as hir;\n use rustc_hir::def::Namespace;\n use rustc_hir::def_id::CRATE_DEF_INDEX;\n@@ -725,8 +726,8 @@ impl<'a, 'tcx> Lift<'tcx> for ty::InstanceDef<'a> {\n \n /// AdtDefs are basically the same as a DefId.\n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::AdtDef {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _folder: &mut F) -> Self {\n-        *self\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, _folder: &mut F) -> Self {\n+        self\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> ControlFlow<()> {\n@@ -735,7 +736,7 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::AdtDef {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>, U: TypeFoldable<'tcx>> TypeFoldable<'tcx> for (T, U) {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> (T, U) {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> (T, U) {\n         (self.0.fold_with(folder), self.1.fold_with(folder))\n     }\n \n@@ -748,7 +749,7 @@ impl<'tcx, T: TypeFoldable<'tcx>, U: TypeFoldable<'tcx>> TypeFoldable<'tcx> for\n impl<'tcx, A: TypeFoldable<'tcx>, B: TypeFoldable<'tcx>, C: TypeFoldable<'tcx>> TypeFoldable<'tcx>\n     for (A, B, C)\n {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> (A, B, C) {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> (A, B, C) {\n         (self.0.fold_with(folder), self.1.fold_with(folder), self.2.fold_with(folder))\n     }\n \n@@ -774,8 +775,9 @@ EnumTypeFoldableImpl! {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        Rc::new((**self).fold_with(folder))\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+        // FIXME: Reuse the `Rc` here.\n+        Rc::new((*self).clone().fold_with(folder))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n@@ -784,8 +786,9 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Arc<T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        Arc::new((**self).fold_with(folder))\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+        // FIXME: Reuse the `Arc` here.\n+        Arc::new((*self).clone().fold_with(folder))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n@@ -794,9 +797,8 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Arc<T> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        let content: T = (**self).fold_with(folder);\n-        box content\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+        self.map_id(|value| value.fold_with(folder))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n@@ -805,8 +807,8 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<T> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        self.iter().map(|t| t.fold_with(folder)).collect()\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+        self.map_id(|t| t.fold_with(folder))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n@@ -815,8 +817,8 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<[T]> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        self.iter().map(|t| t.fold_with(folder)).collect::<Vec<_>>().into_boxed_slice()\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+        self.map_id(|t| t.fold_with(folder))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n@@ -825,11 +827,11 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<[T]> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        self.map_bound_ref(|ty| ty.fold_with(folder))\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+        self.map_bound(|ty| ty.fold_with(folder))\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n         folder.fold_binder(self)\n     }\n \n@@ -843,8 +845,8 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        fold_list(*self, folder, |tcx, v| tcx.intern_existential_predicates(v))\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+        fold_list(self, folder, |tcx, v| tcx.intern_existential_predicates(v))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n@@ -853,8 +855,8 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>>\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<Ty<'tcx>> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        fold_list(*self, folder, |tcx, v| tcx.intern_type_list(v))\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+        fold_list(self, folder, |tcx, v| tcx.intern_type_list(v))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n@@ -863,8 +865,8 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<Ty<'tcx>> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ProjectionKind> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        fold_list(*self, folder, |tcx, v| tcx.intern_projs(v))\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+        fold_list(self, folder, |tcx, v| tcx.intern_projs(v))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n@@ -873,7 +875,7 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ProjectionKind> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::instance::Instance<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n         use crate::ty::InstanceDef::*;\n         Self {\n             substs: self.substs.fold_with(folder),\n@@ -915,7 +917,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::instance::Instance<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for interpret::GlobalId<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n         Self { instance: self.instance.fold_with(folder), promoted: self.promoted }\n     }\n \n@@ -925,7 +927,7 @@ impl<'tcx> TypeFoldable<'tcx> for interpret::GlobalId<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n         let kind = match self.kind() {\n             ty::RawPtr(tm) => ty::RawPtr(tm.fold_with(folder)),\n             ty::Array(typ, sz) => ty::Array(typ.fold_with(folder), sz.fold_with(folder)),\n@@ -964,8 +966,8 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n         if *self.kind() == kind { self } else { folder.tcx().mk_ty(kind) }\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        folder.fold_ty(*self)\n+    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+        folder.fold_ty(self)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n@@ -1016,12 +1018,12 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::Region<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _folder: &mut F) -> Self {\n-        *self\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, _folder: &mut F) -> Self {\n+        self\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        folder.fold_region(*self)\n+    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+        folder.fold_region(self)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> ControlFlow<()> {\n@@ -1034,9 +1036,9 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Region<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        let new = ty::PredicateKind::super_fold_with(&self.inner.kind, folder);\n-        folder.tcx().reuse_or_mk_predicate(*self, new)\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+        let new = ty::PredicateKind::super_fold_with(self.inner.kind, folder);\n+        folder.tcx().reuse_or_mk_predicate(self, new)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n@@ -1057,8 +1059,8 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Predicate<'tcx>> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        fold_list(*self, folder, |tcx, v| tcx.intern_predicates(v))\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+        fold_list(self, folder, |tcx, v| tcx.intern_predicates(v))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n@@ -1067,8 +1069,8 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Predicate<'tcx>> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>, I: Idx> TypeFoldable<'tcx> for IndexVec<I, T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        self.iter().map(|x| x.fold_with(folder)).collect()\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+        self.map_id(|x| x.fold_with(folder))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n@@ -1077,18 +1079,18 @@ impl<'tcx, T: TypeFoldable<'tcx>, I: Idx> TypeFoldable<'tcx> for IndexVec<I, T>\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Const<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n         let ty = self.ty.fold_with(folder);\n         let val = self.val.fold_with(folder);\n         if ty != self.ty || val != self.val {\n             folder.tcx().mk_const(ty::Const { ty, val })\n         } else {\n-            *self\n+            self\n         }\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        folder.fold_const(*self)\n+    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+        folder.fold_const(self)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n@@ -1102,8 +1104,8 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Const<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ConstKind<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        match *self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+        match self {\n             ty::ConstKind::Infer(ic) => ty::ConstKind::Infer(ic.fold_with(folder)),\n             ty::ConstKind::Param(p) => ty::ConstKind::Param(p.fold_with(folder)),\n             ty::ConstKind::Unevaluated(did, substs, promoted) => {\n@@ -1112,7 +1114,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ConstKind<'tcx> {\n             ty::ConstKind::Value(_)\n             | ty::ConstKind::Bound(..)\n             | ty::ConstKind::Placeholder(..)\n-            | ty::ConstKind::Error(_) => *self,\n+            | ty::ConstKind::Error(_) => self,\n         }\n     }\n \n@@ -1130,8 +1132,8 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ConstKind<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for InferConst<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _folder: &mut F) -> Self {\n-        *self\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, _folder: &mut F) -> Self {\n+        self\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> ControlFlow<()> {"}, {"sha": "4bf16436855f48b24518aaaf921b42ac3e200427", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -1001,7 +1001,7 @@ impl<T> Binder<T> {\n         T: TypeFoldable<'tcx>,\n     {\n         if value.has_escaping_bound_vars() {\n-            Binder::bind(super::fold::shift_vars(tcx, &value, 1))\n+            Binder::bind(super::fold::shift_vars(tcx, value, 1))\n         } else {\n             Binder::dummy(value)\n         }"}, {"sha": "5aa312d7c29a42d5b8ef51f7dd664d86adb882d6", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -152,7 +152,7 @@ impl<'a, 'tcx> Lift<'tcx> for GenericArg<'a> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for GenericArg<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n         match self.unpack() {\n             GenericArgKind::Lifetime(lt) => lt.fold_with(folder).into(),\n             GenericArgKind::Type(ty) => ty.fold_with(folder).into(),\n@@ -363,7 +363,7 @@ impl<'a, 'tcx> InternalSubsts<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for SubstsRef<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n         // This code is hot enough that it's worth specializing for the most\n         // common length lists, to avoid the overhead of `SmallVec` creation.\n         // The match arms are in order of frequency. The 1, 2, and 0 cases are\n@@ -405,12 +405,12 @@ impl<'tcx> TypeFoldable<'tcx> for SubstsRef<'tcx> {\n // there is more information available (for better errors).\n \n pub trait Subst<'tcx>: Sized {\n-    fn subst(&self, tcx: TyCtxt<'tcx>, substs: &[GenericArg<'tcx>]) -> Self {\n+    fn subst(self, tcx: TyCtxt<'tcx>, substs: &[GenericArg<'tcx>]) -> Self {\n         self.subst_spanned(tcx, substs, None)\n     }\n \n     fn subst_spanned(\n-        &self,\n+        self,\n         tcx: TyCtxt<'tcx>,\n         substs: &[GenericArg<'tcx>],\n         span: Option<Span>,\n@@ -419,13 +419,13 @@ pub trait Subst<'tcx>: Sized {\n \n impl<'tcx, T: TypeFoldable<'tcx>> Subst<'tcx> for T {\n     fn subst_spanned(\n-        &self,\n+        self,\n         tcx: TyCtxt<'tcx>,\n         substs: &[GenericArg<'tcx>],\n         span: Option<Span>,\n     ) -> T {\n         let mut folder = SubstFolder { tcx, substs, span, binders_passed: 0 };\n-        (*self).fold_with(&mut folder)\n+        self.fold_with(&mut folder)\n     }\n }\n \n@@ -448,7 +448,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n         self.tcx\n     }\n \n-    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n+    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: ty::Binder<T>) -> ty::Binder<T> {\n         self.binders_passed += 1;\n         let t = t.super_fold_with(self);\n         self.binders_passed -= 1;\n@@ -634,7 +634,7 @@ impl<'a, 'tcx> SubstFolder<'a, 'tcx> {\n             return val;\n         }\n \n-        let result = ty::fold::shift_vars(self.tcx(), &val, self.binders_passed);\n+        let result = ty::fold::shift_vars(self.tcx(), val, self.binders_passed);\n         debug!(\"shift_vars: shifted result = {:?}\", result);\n \n         result"}, {"sha": "6e12694f5a61f1e453c9c3e0e5aa1c75eed2fdfe", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -160,7 +160,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         // We want the type_id be independent of the types free regions, so we\n         // erase them. The erase_regions() call will also anonymize bound\n         // regions, which is desirable too.\n-        let ty = self.erase_regions(&ty);\n+        let ty = self.erase_regions(ty);\n \n         hcx.while_hashing_spans(false, |hcx| {\n             hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {"}, {"sha": "3586be2804d6a6880ac171264e7d8c0fdd3f0eb2", "filename": "compiler/rustc_mir/src/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -876,7 +876,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n \n             // Type-test failed. Report the error.\n-            let erased_generic_kind = infcx.tcx.erase_regions(&type_test.generic_kind);\n+            let erased_generic_kind = infcx.tcx.erase_regions(type_test.generic_kind);\n \n             // Skip duplicate-ish errors.\n             if deduplicate_errors.insert((\n@@ -1006,7 +1006,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         debug!(\"try_promote_type_test_subject(ty = {:?})\", ty);\n \n-        let ty = tcx.fold_regions(&ty, &mut false, |r, _depth| {\n+        let ty = tcx.fold_regions(ty, &mut false, |r, _depth| {\n             let region_vid = self.to_region_vid(r);\n \n             // The challenge if this. We have some region variable `r`\n@@ -1248,7 +1248,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        tcx.fold_regions(&value, &mut false, |r, _db| {\n+        tcx.fold_regions(value, &mut false, |r, _db| {\n             let vid = self.to_region_vid(r);\n             let scc = self.constraint_sccs.scc(vid);\n             let repr = self.scc_representatives[scc];"}, {"sha": "f7c902355cb50329b35b43ef01243f41dbd28af8", "filename": "compiler/rustc_mir/src/borrow_check/region_infer/opaque_types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fopaque_types.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -63,7 +63,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n                 let mut subst_regions = vec![self.universal_regions.fr_static];\n                 let universal_substs =\n-                    infcx.tcx.fold_regions(&substs, &mut false, |region, _| match *region {\n+                    infcx.tcx.fold_regions(substs, &mut false, |region, _| match *region {\n                         ty::ReVar(vid) => {\n                             subst_regions.push(vid);\n                             self.definitions[vid].external_name.unwrap_or_else(|| {\n@@ -94,7 +94,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 subst_regions.dedup();\n \n                 let universal_concrete_type =\n-                    infcx.tcx.fold_regions(&concrete_type, &mut false, |region, _| match *region {\n+                    infcx.tcx.fold_regions(concrete_type, &mut false, |region, _| match *region {\n                         ty::ReVar(vid) => subst_regions\n                             .iter()\n                             .find(|ur_vid| self.eval_equal(vid, **ur_vid))\n@@ -139,7 +139,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        tcx.fold_regions(&ty, &mut false, |region, _| match *region {\n+        tcx.fold_regions(ty, &mut false, |region, _| match *region {\n             ty::ReVar(vid) => {\n                 // Find something that we can name\n                 let upper_bound = self.approx_universal_upper_bound(vid);"}, {"sha": "e563e37adc22b522d41e9293787955a3fa010f8c", "filename": "compiler/rustc_mir/src/borrow_check/renumber.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Frenumber.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -26,7 +26,7 @@ pub fn renumber_mir<'tcx>(\n \n /// Replaces all regions appearing in `value` with fresh inference\n /// variables.\n-pub fn renumber_regions<'tcx, T>(infcx: &InferCtxt<'_, 'tcx>, value: &T) -> T\n+pub fn renumber_regions<'tcx, T>(infcx: &InferCtxt<'_, 'tcx>, value: T) -> T\n where\n     T: TypeFoldable<'tcx>,\n {\n@@ -43,7 +43,7 @@ struct NLLVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> NLLVisitor<'a, 'tcx> {\n-    fn renumber_regions<T>(&mut self, value: &T) -> T\n+    fn renumber_regions<T>(&mut self, value: T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -70,7 +70,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'tcx> {\n         _: Location,\n     ) -> Option<PlaceElem<'tcx>> {\n         if let PlaceElem::Field(field, ty) = elem {\n-            let new_ty = self.renumber_regions(&ty);\n+            let new_ty = self.renumber_regions(ty);\n \n             if new_ty != ty {\n                 return Some(PlaceElem::Field(field, new_ty));\n@@ -83,7 +83,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'tcx> {\n     fn visit_substs(&mut self, substs: &mut SubstsRef<'tcx>, location: Location) {\n         debug!(\"visit_substs(substs={:?}, location={:?})\", substs, location);\n \n-        *substs = self.renumber_regions(&{ *substs });\n+        *substs = self.renumber_regions(*substs);\n \n         debug!(\"visit_substs: substs={:?}\", substs);\n     }"}, {"sha": "b7d22fab3dde6c7618eb4e71b541086e989b5b21", "filename": "compiler/rustc_mir/src/borrow_check/type_check/input_output.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Finput_output.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -59,7 +59,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             .replace_bound_vars_with_fresh_vars(\n                                 body.span,\n                                 LateBoundRegionConversionTime::FnCall,\n-                                &poly_sig,\n+                                poly_sig,\n                             )\n                             .0,\n                     )"}, {"sha": "a5c45452dec852e1c024a1ba620e339721c7b321", "filename": "compiler/rustc_mir/src/borrow_check/type_check/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -784,7 +784,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         };\n \n         if let Some(field) = variant.fields.get(field.index()) {\n-            Ok(self.cx.normalize(&field.ty(tcx, substs), location))\n+            Ok(self.cx.normalize(field.ty(tcx, substs), location))\n         } else {\n             Err(FieldAccessError::OutOfRange { field_count: variant.fields.len() })\n         }\n@@ -1245,7 +1245,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             anon_owner_def_id,\n                             dummy_body_id,\n                             param_env,\n-                            &anon_ty,\n+                            anon_ty,\n                             locations.span(body),\n                         ));\n                     debug!(\n@@ -1271,7 +1271,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     );\n \n                     for (&opaque_def_id, opaque_decl) in &opaque_type_map {\n-                        let resolved_ty = infcx.resolve_vars_if_possible(&opaque_decl.concrete_ty);\n+                        let resolved_ty = infcx.resolve_vars_if_possible(opaque_decl.concrete_ty);\n                         let concrete_is_opaque = if let ty::Opaque(def_id, _) = resolved_ty.kind() {\n                             *def_id == opaque_def_id\n                         } else {\n@@ -1296,7 +1296,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let subst_opaque_defn_ty =\n                             opaque_defn_ty.concrete_type.subst(tcx, opaque_decl.substs);\n                         let renumbered_opaque_defn_ty =\n-                            renumber::renumber_regions(infcx, &subst_opaque_defn_ty);\n+                            renumber::renumber_regions(infcx, subst_opaque_defn_ty);\n \n                         debug!(\n                             \"eq_opaque_type_and_type: concrete_ty={:?}={:?} opaque_defn_ty={:?}\",\n@@ -1601,7 +1601,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 let (sig, map) = self.infcx.replace_bound_vars_with_fresh_vars(\n                     term.source_info.span,\n                     LateBoundRegionConversionTime::FnCall,\n-                    &sig,\n+                    sig,\n                 );\n                 let sig = self.normalize(sig, term_location);\n                 self.check_call_dest(body, term, &sig, destination, term_location);\n@@ -1900,7 +1900,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         // Erase the regions from `ty` to get a global type.  The\n         // `Sized` bound in no way depends on precise regions, so this\n         // shouldn't affect `is_sized`.\n-        let erased_ty = tcx.erase_regions(&ty);\n+        let erased_ty = tcx.erase_regions(ty);\n         if !erased_ty.is_sized(tcx.at(span), self.param_env) {\n             // in current MIR construction, all non-control-flow rvalue\n             // expressions evaluate through `as_temp` or `into` a return"}, {"sha": "7ad38a1f82cd4747604e6cc2df76d44ef4b41b1e", "filename": "compiler/rustc_mir/src/borrow_check/universal_regions.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Funiversal_regions.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -438,7 +438,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         let inputs_and_output = self.infcx.replace_bound_regions_with_nll_infer_vars(\n             FR,\n             self.mir_def.did,\n-            &bound_inputs_and_output,\n+            bound_inputs_and_output,\n             &mut indices,\n         );\n         // Converse of above, if this is a function then the late-bound regions declared on its\n@@ -522,7 +522,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                 debug!(\"defining_ty (pre-replacement): {:?}\", defining_ty);\n \n                 let defining_ty =\n-                    self.infcx.replace_free_regions_with_nll_infer_vars(FR, &defining_ty);\n+                    self.infcx.replace_free_regions_with_nll_infer_vars(FR, defining_ty);\n \n                 match *defining_ty.kind() {\n                     ty::Closure(def_id, substs) => DefiningTy::Closure(def_id, substs),\n@@ -543,7 +543,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                 assert_eq!(self.mir_def.did.to_def_id(), closure_base_def_id);\n                 let identity_substs = InternalSubsts::identity_for_item(tcx, closure_base_def_id);\n                 let substs =\n-                    self.infcx.replace_free_regions_with_nll_infer_vars(FR, &identity_substs);\n+                    self.infcx.replace_free_regions_with_nll_infer_vars(FR, identity_substs);\n                 DefiningTy::Const(self.mir_def.did.to_def_id(), substs)\n             }\n         }\n@@ -628,7 +628,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n \n             DefiningTy::FnDef(def_id, _) => {\n                 let sig = tcx.fn_sig(def_id);\n-                let sig = indices.fold_to_region_vids(tcx, &sig);\n+                let sig = indices.fold_to_region_vids(tcx, sig);\n                 sig.inputs_and_output()\n             }\n \n@@ -637,7 +637,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                 // \"output\" (the type of the constant).\n                 assert_eq!(self.mir_def.did.to_def_id(), def_id);\n                 let ty = tcx.type_of(self.mir_def.def_id_for_type_of());\n-                let ty = indices.fold_to_region_vids(tcx, &ty);\n+                let ty = indices.fold_to_region_vids(tcx, ty);\n                 ty::Binder::dummy(tcx.intern_type_list(&[ty]))\n             }\n         }\n@@ -648,7 +648,7 @@ trait InferCtxtExt<'tcx> {\n     fn replace_free_regions_with_nll_infer_vars<T>(\n         &self,\n         origin: NLLRegionVariableOrigin,\n-        value: &T,\n+        value: T,\n     ) -> T\n     where\n         T: TypeFoldable<'tcx>;\n@@ -657,7 +657,7 @@ trait InferCtxtExt<'tcx> {\n         &self,\n         origin: NLLRegionVariableOrigin,\n         all_outlive_scope: LocalDefId,\n-        value: &ty::Binder<T>,\n+        value: ty::Binder<T>,\n         indices: &mut UniversalRegionIndices<'tcx>,\n     ) -> T\n     where\n@@ -674,7 +674,7 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n     fn replace_free_regions_with_nll_infer_vars<T>(\n         &self,\n         origin: NLLRegionVariableOrigin,\n-        value: &T,\n+        value: T,\n     ) -> T\n     where\n         T: TypeFoldable<'tcx>,\n@@ -686,7 +686,7 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n         &self,\n         origin: NLLRegionVariableOrigin,\n         all_outlive_scope: LocalDefId,\n-        value: &ty::Binder<T>,\n+        value: ty::Binder<T>,\n         indices: &mut UniversalRegionIndices<'tcx>,\n     ) -> T\n     where\n@@ -771,7 +771,7 @@ impl<'tcx> UniversalRegionIndices<'tcx> {\n \n     /// Replaces all free regions in `value` with region vids, as\n     /// returned by `to_region_vid`.\n-    pub fn fold_to_region_vids<T>(&self, tcx: TyCtxt<'tcx>, value: &T) -> T\n+    pub fn fold_to_region_vids<T>(&self, tcx: TyCtxt<'tcx>, value: T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {"}, {"sha": "d16366fded900fe343ccc8e0c24419a934a10551", "filename": "compiler/rustc_mir/src/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fdrop_flag_effects.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -152,7 +152,7 @@ pub(crate) fn on_all_drop_children_bits<'tcx, F>(\n         let ty = place.ty(body, tcx).ty;\n         debug!(\"on_all_drop_children_bits({:?}, {:?} : {:?})\", path, place, ty);\n \n-        let erased_ty = tcx.erase_regions(&ty);\n+        let erased_ty = tcx.erase_regions(ty);\n         if erased_ty.needs_drop(tcx, ctxt.param_env) {\n             each_child(child);\n         } else {"}, {"sha": "05b4d1c410d18bf18af8267bdc61d630a69894f2", "filename": "compiler/rustc_mir/src/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -505,7 +505,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         frame: &Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>,\n         value: T,\n     ) -> T {\n-        frame.instance.subst_mir_and_normalize_erasing_regions(*self.tcx, self.param_env, &value)\n+        frame.instance.subst_mir_and_normalize_erasing_regions(*self.tcx, self.param_env, value)\n     }\n \n     /// The `substs` are assumed to already be in our interpreter \"universe\" (param_env)."}, {"sha": "fa7036f4e5b02df327b547acb8d563ed6c2521ab", "filename": "compiler/rustc_mir/src/interpret/traits.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Ftraits.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -21,7 +21,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n         trace!(\"get_vtable(trait_ref={:?})\", poly_trait_ref);\n \n-        let (ty, poly_trait_ref) = self.tcx.erase_regions(&(ty, poly_trait_ref));\n+        let (ty, poly_trait_ref) = self.tcx.erase_regions((ty, poly_trait_ref));\n \n         // All vtables must be monomorphic, bail out otherwise.\n         ensure_monomorphic_enough(*self.tcx, ty)?;\n@@ -37,7 +37,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         let methods = if let Some(poly_trait_ref) = poly_trait_ref {\n             let trait_ref = poly_trait_ref.with_self_ty(*self.tcx, ty);\n-            let trait_ref = self.tcx.erase_regions(&trait_ref);\n+            let trait_ref = self.tcx.erase_regions(trait_ref);\n \n             self.tcx.vtable_methods(trait_ref)\n         } else {\n@@ -143,7 +143,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let drop_instance = self.memory.get_fn(drop_fn)?.as_instance()?;\n         trace!(\"Found drop fn: {:?}\", drop_instance);\n         let fn_sig = drop_instance.ty(*self.tcx, self.param_env).fn_sig(*self.tcx);\n-        let fn_sig = self.tcx.normalize_erasing_late_bound_regions(self.param_env, &fn_sig);\n+        let fn_sig = self.tcx.normalize_erasing_late_bound_regions(self.param_env, fn_sig);\n         // The drop function takes `*mut T` where `T` is the type being dropped, so get that.\n         let args = fn_sig.inputs();\n         if args.len() != 1 {"}, {"sha": "a6f9099217253ff272c74f1649480c0b157cde70", "filename": "compiler/rustc_mir/src/monomorphize/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -546,7 +546,7 @@ impl<'a, 'tcx> MirNeighborCollector<'a, 'tcx> {\n         self.instance.subst_mir_and_normalize_erasing_regions(\n             self.tcx,\n             ty::ParamEnv::reveal_all(),\n-            &value,\n+            value,\n         )\n     }\n }\n@@ -1118,7 +1118,7 @@ impl RootCollector<'_, 'v> {\n         // late-bound regions, since late-bound\n         // regions must appear in the argument\n         // listing.\n-        let main_ret_ty = self.tcx.erase_regions(&main_ret_ty.no_bound_vars().unwrap());\n+        let main_ret_ty = self.tcx.erase_regions(main_ret_ty.no_bound_vars().unwrap());\n \n         let start_instance = Instance::resolve(\n             self.tcx,"}, {"sha": "d5a845dd76fb876d1128b7411e8a93e906ac0d2c", "filename": "compiler/rustc_mir/src/monomorphize/partitioning/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fdefault.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -304,7 +304,7 @@ fn characteristic_def_id_of_mono_item<'tcx>(\n                 let impl_self_ty = tcx.subst_and_normalize_erasing_regions(\n                     instance.substs,\n                     ty::ParamEnv::reveal_all(),\n-                    &tcx.type_of(impl_def_id),\n+                    tcx.type_of(impl_def_id),\n                 );\n                 if let Some(def_id) = characteristic_def_id_of_type(impl_self_ty) {\n                     return Some(def_id);"}, {"sha": "3a1fa0018c104f29a541b19a3ee7b07ceb1fa232", "filename": "compiler/rustc_mir/src/shim.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_mir%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_mir%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fshim.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -135,7 +135,7 @@ fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>)\n     // Check if this is a generator, if so, return the drop glue for it\n     if let Some(&ty::Generator(gen_def_id, substs, _)) = ty.map(|ty| ty.kind()) {\n         let body = &**tcx.optimized_mir(gen_def_id).generator_drop.as_ref().unwrap();\n-        return body.subst(tcx, substs);\n+        return body.clone().subst(tcx, substs);\n     }\n \n     let substs = if let Some(ty) = ty {\n@@ -144,7 +144,7 @@ fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>)\n         InternalSubsts::identity_for_item(tcx, def_id)\n     };\n     let sig = tcx.fn_sig(def_id).subst(tcx, substs);\n-    let sig = tcx.erase_late_bound_regions(&sig);\n+    let sig = tcx.erase_late_bound_regions(sig);\n     let span = tcx.def_span(def_id);\n \n     let source_info = SourceInfo::outermost(span);\n@@ -338,7 +338,7 @@ impl CloneShimBuilder<'tcx> {\n         // or access fields of a Place of type TySelf.\n         let substs = tcx.mk_substs_trait(self_ty, &[]);\n         let sig = tcx.fn_sig(def_id).subst(tcx, substs);\n-        let sig = tcx.erase_late_bound_regions(&sig);\n+        let sig = tcx.erase_late_bound_regions(sig);\n         let span = tcx.def_span(def_id);\n \n         CloneShimBuilder {\n@@ -656,7 +656,7 @@ fn build_call_shim<'tcx>(\n     // to substitute into the signature of the shim. It is not necessary for users of this\n     // MIR body to perform further substitutions (see `InstanceDef::has_polymorphic_mir_body`).\n     let (sig_substs, untuple_args) = if let ty::InstanceDef::FnPtrShim(_, ty) = instance {\n-        let sig = tcx.erase_late_bound_regions(&ty.fn_sig(tcx));\n+        let sig = tcx.erase_late_bound_regions(ty.fn_sig(tcx));\n \n         let untuple_args = sig.inputs();\n \n@@ -671,7 +671,7 @@ fn build_call_shim<'tcx>(\n \n     let def_id = instance.def_id();\n     let sig = tcx.fn_sig(def_id);\n-    let mut sig = tcx.erase_late_bound_regions(&sig);\n+    let mut sig = tcx.erase_late_bound_regions(sig);\n \n     assert_eq!(sig_substs.is_some(), !instance.has_polymorphic_mir_body());\n     if let Some(sig_substs) = sig_substs {"}, {"sha": "dc413f8dd2dc5b152ba44ebb7499698943df2daa", "filename": "compiler/rustc_mir/src/transform/generator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -720,13 +720,13 @@ fn sanitize_witness<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n     witness: Ty<'tcx>,\n-    upvars: &Vec<Ty<'tcx>>,\n+    upvars: Vec<Ty<'tcx>>,\n     saved_locals: &GeneratorSavedLocals,\n ) {\n     let did = body.source.def_id();\n     let allowed_upvars = tcx.erase_regions(upvars);\n     let allowed = match witness.kind() {\n-        ty::GeneratorWitness(s) => tcx.erase_late_bound_regions(&s),\n+        &ty::GeneratorWitness(s) => tcx.erase_late_bound_regions(s),\n         _ => {\n             tcx.sess.delay_span_bug(\n                 body.span,\n@@ -1303,7 +1303,7 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n         let liveness_info =\n             locals_live_across_suspend_points(tcx, body, &always_live_locals, movable);\n \n-        sanitize_witness(tcx, body, interior, &upvars, &liveness_info.saved_locals);\n+        sanitize_witness(tcx, body, interior, upvars, &liveness_info.saved_locals);\n \n         if tcx.sess.opts.debugging_opts.validate_mir {\n             let mut vis = EnsureGeneratorFieldAssignmentsNeverAlias {"}, {"sha": "7ba0fc5be678bb769f1adaa96da41b86a10a678a", "filename": "compiler/rustc_mir/src/transform/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -122,7 +122,7 @@ impl Inliner<'tcx> {\n             let callee_body = callsite.callee.subst_mir_and_normalize_erasing_regions(\n                 self.tcx,\n                 self.param_env,\n-                callee_body,\n+                callee_body.clone(),\n             );\n \n             let old_blocks = caller_body.basic_blocks().next_index();"}, {"sha": "c50389a850ec699f3c50075c8486277a89f88b33", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -240,7 +240,7 @@ fn liberated_closure_env_ty(\n     };\n \n     let closure_env_ty = tcx.closure_env_ty(closure_def_id, closure_substs).unwrap();\n-    tcx.erase_late_bound_regions(&closure_env_ty)\n+    tcx.erase_late_bound_regions(closure_env_ty)\n }\n \n #[derive(Debug, PartialEq, Eq)]"}, {"sha": "eba8e1a0613fb5da9b0a04df528abd7a2af4b38d", "filename": "compiler/rustc_symbol_mangling/src/legacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -51,7 +51,7 @@ pub(super) fn mangle(\n \n     // Erase regions because they may not be deterministic when hashed\n     // and should not matter anyhow.\n-    let instance_ty = tcx.erase_regions(&instance_ty);\n+    let instance_ty = tcx.erase_regions(instance_ty);\n \n     let hash = get_symbol_hash(tcx, instance, instance_ty, instantiating_crate);\n "}, {"sha": "a28c8cac728101c3d6f6785cf27b01c87a3b4ffe", "filename": "compiler/rustc_symbol_mangling/src/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -39,7 +39,7 @@ impl SymbolNamesTest<'tcx> {\n                 let def_id = def_id.to_def_id();\n                 let instance = Instance::new(\n                     def_id,\n-                    tcx.erase_regions(&InternalSubsts::identity_for_item(tcx, def_id)),\n+                    tcx.erase_regions(InternalSubsts::identity_for_item(tcx, def_id)),\n                 );\n                 let mangled = tcx.symbol_name(instance);\n                 tcx.sess.span_err(attr.span, &format!(\"symbol-name({})\", mangled));"}, {"sha": "05b6c4a48de1e0816a4c28b24096bb85335071bc", "filename": "compiler/rustc_trait_selection/src/autoderef.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -109,7 +109,7 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n             param_env,\n             state: AutoderefSnapshot {\n                 steps: vec![],\n-                cur_ty: infcx.resolve_vars_if_possible(&base_ty),\n+                cur_ty: infcx.resolve_vars_if_possible(base_ty),\n                 obligations: vec![],\n                 at_start: true,\n                 reached_recursion_limit: false,\n@@ -164,14 +164,14 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n         debug!(\"overloaded_deref_ty({:?}) = ({:?}, {:?})\", ty, normalized_ty, obligations);\n         self.state.obligations.extend(obligations);\n \n-        Some(self.infcx.resolve_vars_if_possible(&normalized_ty))\n+        Some(self.infcx.resolve_vars_if_possible(normalized_ty))\n     }\n \n     /// Returns the final type we ended up with, which may be an inference\n     /// variable (we will resolve it first, if we want).\n     pub fn final_ty(&self, resolve: bool) -> Ty<'tcx> {\n         if resolve {\n-            self.infcx.resolve_vars_if_possible(&self.state.cur_ty)\n+            self.infcx.resolve_vars_if_possible(self.state.cur_ty)\n         } else {\n             self.state.cur_ty\n         }"}, {"sha": "41184ce21168666cdadbe07ed6bde04a950e72dd", "filename": "compiler/rustc_trait_selection/src/infer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -28,7 +28,7 @@ pub trait InferCtxtExt<'tcx> {\n         span: Span,\n         body_id: hir::HirId,\n         param_env: ty::ParamEnv<'tcx>,\n-        value: &T,\n+        value: T,\n     ) -> InferOk<'tcx, T>\n     where\n         T: TypeFoldable<'tcx>;\n@@ -41,7 +41,7 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n         ty: Ty<'tcx>,\n         span: Span,\n     ) -> bool {\n-        let ty = self.resolve_vars_if_possible(&ty);\n+        let ty = self.resolve_vars_if_possible(ty);\n \n         if !(param_env, ty).needs_infer() {\n             return ty.is_copy_modulo_regions(self.tcx.at(span), param_env);\n@@ -63,7 +63,7 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n         span: Span,\n         body_id: hir::HirId,\n         param_env: ty::ParamEnv<'tcx>,\n-        value: &T,\n+        value: T,\n     ) -> InferOk<'tcx, T>\n     where\n         T: TypeFoldable<'tcx>,\n@@ -173,7 +173,7 @@ impl<'tcx> OutlivesEnvironmentExt<'tcx> for OutlivesEnvironment<'tcx> {\n         debug!(\"add_implied_bounds()\");\n \n         for &ty in fn_sig_tys {\n-            let ty = infcx.resolve_vars_if_possible(&ty);\n+            let ty = infcx.resolve_vars_if_possible(ty);\n             debug!(\"add_implied_bounds: ty = {}\", ty);\n             let implied_bounds = infcx.implied_outlives_bounds(self.param_env, body_id, ty, span);\n             self.add_outlives_bounds(Some(infcx), implied_bounds)"}, {"sha": "82bce182d406f72e6def37aae797d8d15f87c14f", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -112,7 +112,7 @@ pub trait InferCtxtExt<'tcx> {\n         parent_def_id: LocalDefId,\n         body_id: hir::HirId,\n         param_env: ty::ParamEnv<'tcx>,\n-        value: &T,\n+        value: T,\n         value_span: Span,\n     ) -> InferOk<'tcx, (T, OpaqueTypeMap<'tcx>)>;\n \n@@ -188,7 +188,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         parent_def_id: LocalDefId,\n         body_id: hir::HirId,\n         param_env: ty::ParamEnv<'tcx>,\n-        value: &T,\n+        value: T,\n         value_span: Span,\n     ) -> InferOk<'tcx, (T, OpaqueTypeMap<'tcx>)> {\n         debug!(\n@@ -402,7 +402,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         let tcx = self.tcx;\n \n-        let concrete_ty = self.resolve_vars_if_possible(&opaque_defn.concrete_ty);\n+        let concrete_ty = self.resolve_vars_if_possible(opaque_defn.concrete_ty);\n \n         debug!(\"constrain_opaque_type: concrete_ty={:?}\", concrete_ty);\n \n@@ -1001,7 +1001,7 @@ struct Instantiator<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n-    fn instantiate_opaque_types_in_map<T: TypeFoldable<'tcx>>(&mut self, value: &T) -> T {\n+    fn instantiate_opaque_types_in_map<T: TypeFoldable<'tcx>>(&mut self, value: T) -> T {\n         debug!(\"instantiate_opaque_types_in_map(value={:?})\", value);\n         let tcx = self.infcx.tcx;\n         value.fold_with(&mut BottomUpFolder {\n@@ -1125,7 +1125,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n \n         let param_env = tcx.param_env(def_id);\n         let InferOk { value: bounds, obligations } =\n-            infcx.partially_normalize_associated_types_in(span, self.body_id, param_env, &bounds);\n+            infcx.partially_normalize_associated_types_in(span, self.body_id, param_env, bounds);\n         self.obligations.extend(obligations);\n \n         debug!(\"instantiate_opaque_types: bounds={:?}\", bounds);\n@@ -1173,7 +1173,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n             // Change the predicate to refer to the type variable,\n             // which will be the concrete type instead of the opaque type.\n             // This also instantiates nested instances of `impl Trait`.\n-            let predicate = self.instantiate_opaque_types_in_map(&predicate);\n+            let predicate = self.instantiate_opaque_types_in_map(predicate);\n \n             let cause = traits::ObligationCause::new(span, self.body_id, traits::MiscObligation);\n "}, {"sha": "6ab16886ed2377ec7ef46137832844274183c9b6", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -304,11 +304,8 @@ impl AutoTraitFinder<'tcx> {\n \n             // Call `infcx.resolve_vars_if_possible` to see if we can\n             // get rid of any inference variables.\n-            let obligation = infcx.resolve_vars_if_possible(&Obligation::new(\n-                dummy_cause.clone(),\n-                new_env,\n-                pred,\n-            ));\n+            let obligation =\n+                infcx.resolve_vars_if_possible(Obligation::new(dummy_cause.clone(), new_env, pred));\n             let result = select.select(&obligation);\n \n             match &result {\n@@ -627,7 +624,7 @@ impl AutoTraitFinder<'tcx> {\n                 fresh_preds.insert(self.clean_pred(select.infcx(), obligation.predicate));\n \n             // Resolve any inference variables that we can, to help selection succeed\n-            let predicate = select.infcx().resolve_vars_if_possible(&obligation.predicate);\n+            let predicate = select.infcx().resolve_vars_if_possible(obligation.predicate);\n \n             // We only add a predicate as a user-displayable bound if\n             // it involves a generic parameter, and doesn't contain"}, {"sha": "026ab414443a871677e094ee57faf397baa6b678", "filename": "compiler/rustc_trait_selection/src/traits/chalk_fulfill.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -37,7 +37,7 @@ impl TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         obligation: PredicateObligation<'tcx>,\n     ) {\n         assert!(!infcx.is_in_snapshot());\n-        let obligation = infcx.resolve_vars_if_possible(&obligation);\n+        let obligation = infcx.resolve_vars_if_possible(obligation);\n \n         self.obligations.insert(obligation);\n     }\n@@ -80,11 +80,11 @@ impl TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n             // We iterate over all obligations, and record if we are able\n             // to unambiguously prove at least one obligation.\n             for obligation in self.obligations.drain(..) {\n-                let obligation = infcx.resolve_vars_if_possible(&obligation);\n+                let obligation = infcx.resolve_vars_if_possible(obligation);\n                 let environment = obligation.param_env.caller_bounds();\n                 let goal = ChalkEnvironmentAndGoal { environment, goal: obligation.predicate };\n                 let mut orig_values = OriginalQueryValues::default();\n-                let canonical_goal = infcx.canonicalize_query(&goal, &mut orig_values);\n+                let canonical_goal = infcx.canonicalize_query(goal, &mut orig_values);\n \n                 match infcx.tcx.evaluate_goal(canonical_goal) {\n                     Ok(response) => {\n@@ -100,7 +100,7 @@ impl TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n                                 Ok(infer_ok) => next_round.extend(\n                                     infer_ok.obligations.into_iter().map(|obligation| {\n                                         assert!(!infcx.is_in_snapshot());\n-                                        infcx.resolve_vars_if_possible(&obligation)\n+                                        infcx.resolve_vars_if_possible(obligation)\n                                     }),\n                                 ),\n "}, {"sha": "657d5c123e8e4b3268d1bfa2968e748e1b9bcc3c", "filename": "compiler/rustc_trait_selection/src/traits/codegen.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -25,7 +25,7 @@ pub fn codegen_fulfill_obligation<'tcx>(\n     (param_env, trait_ref): (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>),\n ) -> Result<ImplSource<'tcx, ()>, ErrorReported> {\n     // Remove any references to regions; this helps improve caching.\n-    let trait_ref = tcx.erase_regions(&trait_ref);\n+    let trait_ref = tcx.erase_regions(trait_ref);\n     // We expect the input to be fully normalized.\n     debug_assert_eq!(trait_ref, tcx.normalize_erasing_regions(param_env, trait_ref));\n     debug!(\n@@ -89,7 +89,7 @@ pub fn codegen_fulfill_obligation<'tcx>(\n             debug!(\"fulfill_obligation: register_predicate_obligation {:?}\", predicate);\n             fulfill_cx.register_predicate_obligation(&infcx, predicate);\n         });\n-        let impl_source = drain_fulfillment_cx_or_panic(&infcx, &mut fulfill_cx, &impl_source);\n+        let impl_source = drain_fulfillment_cx_or_panic(&infcx, &mut fulfill_cx, impl_source);\n \n         info!(\"Cache miss: {:?} => {:?}\", trait_ref, impl_source);\n         Ok(impl_source)\n@@ -110,7 +110,7 @@ pub fn codegen_fulfill_obligation<'tcx>(\n fn drain_fulfillment_cx_or_panic<T>(\n     infcx: &InferCtxt<'_, 'tcx>,\n     fulfill_cx: &mut FulfillmentContext<'tcx>,\n-    result: &T,\n+    result: T,\n ) -> T\n where\n     T: TypeFoldable<'tcx>,\n@@ -128,5 +128,5 @@ where\n     }\n \n     let result = infcx.resolve_vars_if_possible(result);\n-    infcx.tcx.erase_regions(&result)\n+    infcx.tcx.erase_regions(result)\n }"}, {"sha": "9324d55ac1b2d2e5e5c4ab235d909e60f79ea4d6", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -103,7 +103,7 @@ fn with_fresh_ty_vars<'cx, 'tcx>(\n     };\n \n     let Normalized { value: mut header, obligations } =\n-        traits::normalize(selcx, param_env, ObligationCause::dummy(), &header);\n+        traits::normalize(selcx, param_env, ObligationCause::dummy(), header);\n \n     header.predicates.extend(obligations.into_iter().map(|o| o.predicate));\n     header\n@@ -162,7 +162,8 @@ fn overlap_within_probe(\n     let opt_failing_obligation = a_impl_header\n         .predicates\n         .iter()\n-        .chain(&b_impl_header.predicates)\n+        .copied()\n+        .chain(b_impl_header.predicates)\n         .map(|p| infcx.resolve_vars_if_possible(p))\n         .map(|p| Obligation {\n             cause: ObligationCause::dummy(),\n@@ -188,7 +189,7 @@ fn overlap_within_probe(\n         }\n     }\n \n-    let impl_header = selcx.infcx().resolve_vars_if_possible(&a_impl_header);\n+    let impl_header = selcx.infcx().resolve_vars_if_possible(a_impl_header);\n     let intercrate_ambiguity_causes = selcx.take_intercrate_ambiguity_causes();\n     debug!(\"overlap: intercrate_ambiguity_causes={:#?}\", intercrate_ambiguity_causes);\n "}, {"sha": "11c99c7a18470666f03b8ac459341743273256f2", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -182,7 +182,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     where\n         T: fmt::Display + TypeFoldable<'tcx>,\n     {\n-        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n+        let predicate = self.resolve_vars_if_possible(obligation.predicate.clone());\n         let mut err = struct_span_err!(\n             self.tcx.sess,\n             obligation.cause.span,\n@@ -213,7 +213,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     /// we do not suggest increasing the overflow limit, which is not\n     /// going to help).\n     fn report_overflow_error_cycle(&self, cycle: &[PredicateObligation<'tcx>]) -> ! {\n-        let cycle = self.resolve_vars_if_possible(&cycle.to_owned());\n+        let cycle = self.resolve_vars_if_possible(cycle.to_owned());\n         assert!(!cycle.is_empty());\n \n         debug!(\"report_overflow_error_cycle: cycle={:?}\", cycle);\n@@ -259,7 +259,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 match bound_predicate.skip_binder() {\n                     ty::PredicateAtom::Trait(trait_predicate, _) => {\n                         let trait_predicate = bound_predicate.rebind(trait_predicate);\n-                        let trait_predicate = self.resolve_vars_if_possible(&trait_predicate);\n+                        let trait_predicate = self.resolve_vars_if_possible(trait_predicate);\n \n                         if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n                             return;\n@@ -414,17 +414,17 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             err.span_label(enclosing_scope_span, s.as_str());\n                         }\n \n-                        self.suggest_dereferences(&obligation, &mut err, &trait_ref, points_at_arg);\n-                        self.suggest_fn_call(&obligation, &mut err, &trait_ref, points_at_arg);\n-                        self.suggest_remove_reference(&obligation, &mut err, &trait_ref);\n-                        self.suggest_semicolon_removal(&obligation, &mut err, span, &trait_ref);\n+                        self.suggest_dereferences(&obligation, &mut err, trait_ref, points_at_arg);\n+                        self.suggest_fn_call(&obligation, &mut err, trait_ref, points_at_arg);\n+                        self.suggest_remove_reference(&obligation, &mut err, trait_ref);\n+                        self.suggest_semicolon_removal(&obligation, &mut err, span, trait_ref);\n                         self.note_version_mismatch(&mut err, &trait_ref);\n \n                         if Some(trait_ref.def_id()) == tcx.lang_items().try_trait() {\n-                            self.suggest_await_before_try(&mut err, &obligation, &trait_ref, span);\n+                            self.suggest_await_before_try(&mut err, &obligation, trait_ref, span);\n                         }\n \n-                        if self.suggest_impl_trait(&mut err, span, &obligation, &trait_ref) {\n+                        if self.suggest_impl_trait(&mut err, span, &obligation, trait_ref) {\n                             err.emit();\n                             return;\n                         }\n@@ -487,7 +487,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                                 self.suggest_change_mut(\n                                     &obligation,\n                                     &mut err,\n-                                    &trait_ref,\n+                                    trait_ref,\n                                     points_at_arg,\n                                 );\n                             }\n@@ -533,7 +533,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n                     ty::PredicateAtom::RegionOutlives(predicate) => {\n                         let predicate = bound_predicate.rebind(predicate);\n-                        let predicate = self.resolve_vars_if_possible(&predicate);\n+                        let predicate = self.resolve_vars_if_possible(predicate);\n                         let err = self\n                             .region_outlives_predicate(&obligation.cause, predicate)\n                             .err()\n@@ -549,7 +549,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     }\n \n                     ty::PredicateAtom::Projection(..) | ty::PredicateAtom::TypeOutlives(..) => {\n-                        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n+                        let predicate = self.resolve_vars_if_possible(obligation.predicate);\n                         struct_span_err!(\n                             self.tcx.sess,\n                             span,\n@@ -672,8 +672,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n \n             OutputTypeParameterMismatch(ref found_trait_ref, ref expected_trait_ref, _) => {\n-                let found_trait_ref = self.resolve_vars_if_possible(&*found_trait_ref);\n-                let expected_trait_ref = self.resolve_vars_if_possible(&*expected_trait_ref);\n+                let found_trait_ref = self.resolve_vars_if_possible(*found_trait_ref);\n+                let expected_trait_ref = self.resolve_vars_if_possible(*expected_trait_ref);\n \n                 if expected_trait_ref.self_ty().references_error() {\n                     return;\n@@ -1035,7 +1035,7 @@ trait InferCtxtPrivExt<'tcx> {\n     fn mk_trait_obligation_with_new_self_ty(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n-        trait_ref: &ty::PolyTraitRef<'tcx>,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n         new_self_ty: Ty<'tcx>,\n     ) -> PredicateObligation<'tcx>;\n \n@@ -1157,7 +1157,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         obligation: &PredicateObligation<'tcx>,\n         error: &MismatchedProjectionTypes<'tcx>,\n     ) {\n-        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n+        let predicate = self.resolve_vars_if_possible(obligation.predicate);\n \n         if predicate.references_error() {\n             return;\n@@ -1178,7 +1178,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 let (data, _) = self.replace_bound_vars_with_fresh_vars(\n                     obligation.cause.span,\n                     infer::LateBoundRegionConversionTime::HigherRankedType,\n-                    &bound_predicate.rebind(data),\n+                    bound_predicate.rebind(data),\n                 );\n                 let mut obligations = vec![];\n                 let normalized_ty = super::normalize_projection_type(\n@@ -1343,7 +1343,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         // Sort impl candidates so that ordering is consistent for UI tests.\n         let mut normalized_impl_candidates =\n-            impl_candidates.iter().map(normalize).collect::<Vec<String>>();\n+            impl_candidates.iter().copied().map(normalize).collect::<Vec<String>>();\n \n         // Sort before taking the `..end` range,\n         // because the ordering of `impl_candidates` may not be deterministic:\n@@ -1364,7 +1364,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n     ) -> Option<(String, Option<Span>)> {\n         match code {\n             &ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n-                let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n+                let parent_trait_ref = self.resolve_vars_if_possible(data.parent_trait_ref);\n                 match self.get_parent_trait_ref(&data.parent_code) {\n                     Some(t) => Some(t),\n                     None => {\n@@ -1414,7 +1414,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn mk_trait_obligation_with_new_self_ty(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n-        trait_ref: &ty::PolyTraitRef<'tcx>,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n         new_self_ty: Ty<'tcx>,\n     ) -> PredicateObligation<'tcx> {\n         assert!(!new_self_ty.has_escaping_bound_vars());\n@@ -1441,7 +1441,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // ambiguous impls. The latter *ought* to be a\n         // coherence violation, so we don't report it here.\n \n-        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n+        let predicate = self.resolve_vars_if_possible(obligation.predicate);\n         let span = obligation.cause.span;\n \n         debug!(\n@@ -1673,7 +1673,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 &mut selcx,\n                 param_env,\n                 ObligationCause::dummy(),\n-                &cleaned_pred,\n+                cleaned_pred,\n             )\n             .value;\n \n@@ -1808,7 +1808,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         cause_code: &ObligationCauseCode<'tcx>,\n     ) -> bool {\n         if let ObligationCauseCode::BuiltinDerivedObligation(ref data) = cause_code {\n-            let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n+            let parent_trait_ref = self.resolve_vars_if_possible(data.parent_trait_ref);\n \n             if obligated_types.iter().any(|ot| ot == &parent_trait_ref.skip_binder().self_ty()) {\n                 return true;"}, {"sha": "1b5375938af6d4b89c2919c33453c16c8188d225", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     ) -> Option<DefId> {\n         let tcx = self.tcx;\n         let param_env = obligation.param_env;\n-        let trait_ref = tcx.erase_late_bound_regions(&trait_ref);\n+        let trait_ref = tcx.erase_late_bound_regions(trait_ref);\n         let trait_self_ty = trait_ref.self_ty();\n \n         let mut self_match_impls = vec![];"}, {"sha": "7e92df28ca27e5fc9ef8c13277e501116a35be23", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -49,7 +49,7 @@ pub trait InferCtxtExt<'tcx> {\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'tcx>,\n-        trait_ref: &ty::PolyTraitRef<'tcx>,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n         points_at_arg: bool,\n     );\n \n@@ -64,7 +64,7 @@ pub trait InferCtxtExt<'tcx> {\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        trait_ref: ty::Binder<ty::TraitRef<'tcx>>,\n         points_at_arg: bool,\n     );\n \n@@ -81,14 +81,14 @@ pub trait InferCtxtExt<'tcx> {\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        trait_ref: ty::Binder<ty::TraitRef<'tcx>>,\n     );\n \n     fn suggest_change_mut(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        trait_ref: ty::Binder<ty::TraitRef<'tcx>>,\n         points_at_arg: bool,\n     );\n \n@@ -97,7 +97,7 @@ pub trait InferCtxtExt<'tcx> {\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n         span: Span,\n-        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        trait_ref: ty::Binder<ty::TraitRef<'tcx>>,\n     );\n \n     fn return_type_span(&self, obligation: &PredicateObligation<'tcx>) -> Option<Span>;\n@@ -107,7 +107,7 @@ pub trait InferCtxtExt<'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n         span: Span,\n         obligation: &PredicateObligation<'tcx>,\n-        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        trait_ref: ty::Binder<ty::TraitRef<'tcx>>,\n     ) -> bool;\n \n     fn point_at_returns_when_relevant(\n@@ -168,7 +168,7 @@ pub trait InferCtxtExt<'tcx> {\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         obligation: &PredicateObligation<'tcx>,\n-        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        trait_ref: ty::Binder<ty::TraitRef<'tcx>>,\n         span: Span,\n     );\n }\n@@ -462,7 +462,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'tcx>,\n-        trait_ref: &ty::PolyTraitRef<'tcx>,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n         points_at_arg: bool,\n     ) {\n         // It only make sense when suggesting dereferences for arguments\n@@ -475,7 +475,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let real_trait_ref = match &obligation.cause.code {\n             ObligationCauseCode::ImplDerivedObligation(cause)\n             | ObligationCauseCode::DerivedObligation(cause)\n-            | ObligationCauseCode::BuiltinDerivedObligation(cause) => &cause.parent_trait_ref,\n+            | ObligationCauseCode::BuiltinDerivedObligation(cause) => cause.parent_trait_ref,\n             _ => trait_ref,\n         };\n         let real_ty = match real_trait_ref.self_ty().no_bound_vars() {\n@@ -556,7 +556,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        trait_ref: ty::Binder<ty::TraitRef<'tcx>>,\n         points_at_arg: bool,\n     ) {\n         let self_ty = match trait_ref.self_ty().no_bound_vars() {\n@@ -734,7 +734,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        trait_ref: ty::Binder<ty::TraitRef<'tcx>>,\n     ) {\n         let span = obligation.cause.span;\n \n@@ -797,7 +797,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        trait_ref: ty::Binder<ty::TraitRef<'tcx>>,\n         points_at_arg: bool,\n     ) {\n         let span = obligation.cause.span;\n@@ -832,7 +832,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n                 let new_obligation = self.mk_trait_obligation_with_new_self_ty(\n                     obligation.param_env,\n-                    &trait_ref,\n+                    trait_ref,\n                     suggested_ty,\n                 );\n                 let suggested_ty_would_satisfy_obligation = self\n@@ -869,7 +869,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n         span: Span,\n-        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        trait_ref: ty::Binder<ty::TraitRef<'tcx>>,\n     ) {\n         let is_empty_tuple =\n             |ty: ty::Binder<Ty<'_>>| *ty.skip_binder().kind() == ty::Tuple(ty::List::empty());\n@@ -919,7 +919,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n         span: Span,\n         obligation: &PredicateObligation<'tcx>,\n-        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        trait_ref: ty::Binder<ty::TraitRef<'tcx>>,\n     ) -> bool {\n         match obligation.cause.code.peel_derives() {\n             // Only suggest `impl Trait` if the return type is unsized because it is `dyn Trait`.\n@@ -976,12 +976,12 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             .returns\n             .iter()\n             .filter_map(|expr| typeck_results.node_type_opt(expr.hir_id))\n-            .map(|ty| self.resolve_vars_if_possible(&ty));\n+            .map(|ty| self.resolve_vars_if_possible(ty));\n         let (last_ty, all_returns_have_same_type, only_never_return) = ret_types.clone().fold(\n             (None, true, true),\n             |(last_ty, mut same, only_never_return): (std::option::Option<Ty<'_>>, bool, bool),\n              ty| {\n-                let ty = self.resolve_vars_if_possible(&ty);\n+                let ty = self.resolve_vars_if_possible(ty);\n                 same &=\n                     !matches!(ty.kind(), ty::Error(_))\n                         && last_ty.map_or(true, |last_ty| {\n@@ -1133,7 +1133,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             let typeck_results = self.in_progress_typeck_results.map(|t| t.borrow()).unwrap();\n             for expr in &visitor.returns {\n                 if let Some(returned_ty) = typeck_results.node_type_opt(expr.hir_id) {\n-                    let ty = self.resolve_vars_if_possible(&returned_ty);\n+                    let ty = self.resolve_vars_if_possible(returned_ty);\n                     err.span_label(expr.span, &format!(\"this returned value is of type `{}`\", ty));\n                 }\n             }\n@@ -1406,7 +1406,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         // Look for a type inside the generator interior that matches the target type to get\n         // a span.\n-        let target_ty_erased = self.tcx.erase_regions(&target_ty);\n+        let target_ty_erased = self.tcx.erase_regions(target_ty);\n         let ty_matches = |ty| -> bool {\n             // Careful: the regions for types that appear in the\n             // generator interior are not generally known, so we\n@@ -1420,8 +1420,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             // generator frame. Bound regions are preserved by\n             // `erase_regions` and so we must also call\n             // `erase_late_bound_regions`.\n-            let ty_erased = self.tcx.erase_late_bound_regions(&ty::Binder::bind(ty));\n-            let ty_erased = self.tcx.erase_regions(&ty_erased);\n+            let ty_erased = self.tcx.erase_late_bound_regions(ty::Binder::bind(ty));\n+            let ty_erased = self.tcx.erase_regions(ty_erased);\n             let eq = ty::TyS::same_type(ty_erased, target_ty_erased);\n             debug!(\n                 \"maybe_note_obligation_cause_for_async_await: ty_erased={:?} \\\n@@ -1437,7 +1437,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         if let Some(upvars) = self.tcx.upvars_mentioned(generator_did) {\n             interior_or_upvar_span = upvars.iter().find_map(|(upvar_id, upvar)| {\n                 let upvar_ty = typeck_results.node_type(*upvar_id);\n-                let upvar_ty = self.resolve_vars_if_possible(&upvar_ty);\n+                let upvar_ty = self.resolve_vars_if_possible(upvar_ty);\n                 if ty_matches(&upvar_ty) {\n                     Some(GeneratorInteriorOrUpvar::Upvar(upvar.span))\n                 } else {\n@@ -2010,7 +2010,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 err.note(\"shared static variables must have a type that implements `Sync`\");\n             }\n             ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n-                let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n+                let parent_trait_ref = self.resolve_vars_if_possible(data.parent_trait_ref);\n                 let ty = parent_trait_ref.skip_binder().self_ty();\n                 if parent_trait_ref.references_error() {\n                     err.cancel();\n@@ -2025,8 +2025,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     if let ObligationCauseCode::BuiltinDerivedObligation(ref data) =\n                         *data.parent_code\n                     {\n-                        let parent_trait_ref =\n-                            self.resolve_vars_if_possible(&data.parent_trait_ref);\n+                        let parent_trait_ref = self.resolve_vars_if_possible(data.parent_trait_ref);\n                         let ty = parent_trait_ref.skip_binder().self_ty();\n                         matches!(ty.kind(), ty::Generator(..))\n                             || matches!(ty.kind(), ty::Closure(..))\n@@ -2056,7 +2055,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 }\n             }\n             ObligationCauseCode::ImplDerivedObligation(ref data) => {\n-                let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n+                let parent_trait_ref = self.resolve_vars_if_possible(data.parent_trait_ref);\n                 err.note(&format!(\n                     \"required because of the requirements on the impl of `{}` for `{}`\",\n                     parent_trait_ref.print_only_trait_path(),\n@@ -2074,7 +2073,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 });\n             }\n             ObligationCauseCode::DerivedObligation(ref data) => {\n-                let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n+                let parent_trait_ref = self.resolve_vars_if_possible(data.parent_trait_ref);\n                 let parent_predicate = parent_trait_ref.without_const().to_predicate(tcx);\n                 // #74711: avoid a stack overflow\n                 ensure_sufficient_stack(|| {\n@@ -2132,7 +2131,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         obligation: &PredicateObligation<'tcx>,\n-        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        trait_ref: ty::Binder<ty::TraitRef<'tcx>>,\n         span: Span,\n     ) {\n         debug!(\n@@ -2150,13 +2149,13 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             if let Some(hir::GeneratorKind::Async(_)) = body.generator_kind {\n                 let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n \n-                let self_ty = self.resolve_vars_if_possible(&trait_ref.self_ty());\n+                let self_ty = self.resolve_vars_if_possible(trait_ref.self_ty());\n \n                 // Do not check on infer_types to avoid panic in evaluate_obligation.\n                 if self_ty.has_infer_types() {\n                     return;\n                 }\n-                let self_ty = self.tcx.erase_regions(&self_ty);\n+                let self_ty = self.tcx.erase_regions(self_ty);\n \n                 let impls_future = self.tcx.type_implements_trait((\n                     future_trait,\n@@ -2197,7 +2196,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n                 debug!(\n                     \"suggest_await_before_try: normalized_projection_type {:?}\",\n-                    self.resolve_vars_if_possible(&normalized_ty)\n+                    self.resolve_vars_if_possible(normalized_ty)\n                 );\n                 let try_obligation = self.mk_trait_obligation_with_new_self_ty(\n                     obligation.param_env,"}, {"sha": "a04f816b0f8a002bdc1c063a25748852fdd48c68", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -202,7 +202,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n     ) {\n         // this helps to reduce duplicate errors, as well as making\n         // debug output much nicer to read and so on.\n-        let obligation = infcx.resolve_vars_if_possible(&obligation);\n+        let obligation = infcx.resolve_vars_if_possible(obligation);\n \n         debug!(?obligation, \"register_predicate_obligation\");\n \n@@ -298,7 +298,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n         if !change {\n             debug!(\n                 \"process_predicate: pending obligation {:?} still stalled on {:?}\",\n-                self.selcx.infcx().resolve_vars_if_possible(&pending_obligation.obligation),\n+                self.selcx.infcx().resolve_vars_if_possible(pending_obligation.obligation.clone()),\n                 pending_obligation.stalled_on\n             );\n             return ProcessResult::Unchanged;\n@@ -338,14 +338,14 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n \n         if obligation.predicate.has_infer_types_or_consts() {\n             obligation.predicate =\n-                self.selcx.infcx().resolve_vars_if_possible(&obligation.predicate);\n+                self.selcx.infcx().resolve_vars_if_possible(obligation.predicate);\n         }\n \n         debug!(?obligation, ?obligation.cause, \"process_obligation\");\n \n         let infcx = self.selcx.infcx();\n \n-        match obligation.predicate.kind() {\n+        match *obligation.predicate.kind() {\n             ty::PredicateKind::ForAll(binder) => match binder.skip_binder() {\n                 // Evaluation will discard candidates using the leak check.\n                 // This means we need to pass it the bound version of our\n@@ -384,9 +384,9 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                     bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n                 }\n             },\n-            &ty::PredicateKind::Atom(atom) => match atom {\n-                ty::PredicateAtom::Trait(ref data, _) => {\n-                    let trait_obligation = obligation.with(Binder::dummy(*data));\n+            ty::PredicateKind::Atom(atom) => match atom {\n+                ty::PredicateAtom::Trait(data, _) => {\n+                    let trait_obligation = obligation.with(Binder::dummy(data));\n \n                     self.process_trait_obligation(\n                         obligation,\n@@ -639,7 +639,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n \n                 debug!(\n                     \"process_predicate: pending obligation {:?} now stalled on {:?}\",\n-                    infcx.resolve_vars_if_possible(obligation),\n+                    infcx.resolve_vars_if_possible(obligation.clone()),\n                     stalled_on\n                 );\n \n@@ -684,7 +684,7 @@ fn trait_ref_infer_vars<'a, 'tcx>(\n ) -> Vec<TyOrConstInferVar<'tcx>> {\n     selcx\n         .infcx()\n-        .resolve_vars_if_possible(&trait_ref)\n+        .resolve_vars_if_possible(trait_ref)\n         .skip_binder()\n         .substs\n         .iter()"}, {"sha": "cedd1aa54b876ff5bec787ff57a7080e5c025d1a", "filename": "compiler/rustc_trait_selection/src/traits/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -50,7 +50,7 @@ pub fn can_type_implement_copy(\n                 let span = tcx.def_span(field.did);\n                 let cause = ObligationCause::dummy_with_span(span);\n                 let ctx = traits::FulfillmentContext::new();\n-                match traits::fully_normalize(&infcx, ctx, cause, param_env, &ty) {\n+                match traits::fully_normalize(&infcx, ctx, cause, param_env, ty) {\n                     Ok(ty) => {\n                         if !infcx.type_is_copy_modulo_regions(param_env, ty, span) {\n                             infringing.push(field);"}, {"sha": "2d7df2ddd119d1ba12050db49e5259e7ca9aa039", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -223,7 +223,7 @@ fn do_normalize_predicates<'tcx>(\n         // we move over to lazy normalization *anyway*.\n         let fulfill_cx = FulfillmentContext::new_ignoring_regions();\n         let predicates =\n-            match fully_normalize(&infcx, fulfill_cx, cause, elaborated_env, &predicates) {\n+            match fully_normalize(&infcx, fulfill_cx, cause, elaborated_env, predicates) {\n                 Ok(predicates) => predicates,\n                 Err(errors) => {\n                     infcx.report_fulfillment_errors(&errors, None, false);\n@@ -243,7 +243,7 @@ fn do_normalize_predicates<'tcx>(\n             RegionckMode::default(),\n         );\n \n-        let predicates = match infcx.fully_resolve(&predicates) {\n+        let predicates = match infcx.fully_resolve(predicates) {\n             Ok(predicates) => predicates,\n             Err(fixup_err) => {\n                 // If we encounter a fixup error, it means that some type\n@@ -384,7 +384,7 @@ pub fn fully_normalize<'a, 'tcx, T>(\n     mut fulfill_cx: FulfillmentContext<'tcx>,\n     cause: ObligationCause<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    value: &T,\n+    value: T,\n ) -> Result<T, Vec<FulfillmentError<'tcx>>>\n where\n     T: TypeFoldable<'tcx>,\n@@ -404,7 +404,7 @@ where\n     debug!(\"fully_normalize: select_all_or_error start\");\n     fulfill_cx.select_all_or_error(infcx)?;\n     debug!(\"fully_normalize: select_all_or_error complete\");\n-    let resolved_value = infcx.resolve_vars_if_possible(&normalized_value);\n+    let resolved_value = infcx.resolve_vars_if_possible(normalized_value);\n     debug!(\"fully_normalize: resolved_value={:?}\", resolved_value);\n     Ok(resolved_value)\n }\n@@ -424,7 +424,7 @@ pub fn impossible_predicates<'tcx>(\n         let mut fulfill_cx = FulfillmentContext::new();\n         let cause = ObligationCause::dummy();\n         let Normalized { value: predicates, obligations } =\n-            normalize(&mut selcx, param_env, cause.clone(), &predicates);\n+            normalize(&mut selcx, param_env, cause.clone(), predicates);\n         for obligation in obligations {\n             fulfill_cx.register_predicate_obligation(&infcx, obligation);\n         }\n@@ -435,7 +435,7 @@ pub fn impossible_predicates<'tcx>(\n \n         fulfill_cx.select_all_or_error(&infcx).is_err()\n     });\n-    debug!(\"impossible_predicates(predicates={:?}) = {:?}\", predicates, result);\n+    debug!(\"impossible_predicates = {:?}\", result);\n     result\n }\n \n@@ -494,7 +494,7 @@ fn vtable_methods<'tcx>(\n             // erase them if they appear, so that we get the type\n             // at some particular call site.\n             let substs =\n-                tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &substs);\n+                tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), substs);\n \n             // It's possible that the method relies on where-clauses that\n             // do not hold for this particular set of type parameters."}, {"sha": "cc31f6b2c2e5664c0a8ce9227fe6c0e8e1d13281", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -446,7 +446,7 @@ fn virtual_call_violation_for_method<'tcx>(\n     }\n \n     let receiver_ty =\n-        tcx.liberate_late_bound_regions(method.def_id, &sig.map_bound(|sig| sig.inputs()[0]));\n+        tcx.liberate_late_bound_regions(method.def_id, sig.map_bound(|sig| sig.inputs()[0]));\n \n     // Until `unsized_locals` is fully implemented, `self: Self` can't be dispatched on.\n     // However, this is already considered object-safe. We allow it as a special case here."}, {"sha": "de700e4a422ef520a4e56880b8608c954cbde5b0", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -168,7 +168,7 @@ pub(super) fn poly_project_and_unify_type<'cx, 'tcx>(\n     let infcx = selcx.infcx();\n     infcx.commit_if_ok(|_snapshot| {\n         let placeholder_predicate =\n-            infcx.replace_bound_vars_with_placeholders(&obligation.predicate);\n+            infcx.replace_bound_vars_with_placeholders(obligation.predicate);\n \n         let placeholder_obligation = obligation.with(placeholder_predicate);\n         let result = project_and_unify_type(selcx, &placeholder_obligation)?;\n@@ -232,7 +232,7 @@ pub fn normalize<'a, 'b, 'tcx, T>(\n     selcx: &'a mut SelectionContext<'b, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     cause: ObligationCause<'tcx>,\n-    value: &T,\n+    value: T,\n ) -> Normalized<'tcx, T>\n where\n     T: TypeFoldable<'tcx>,\n@@ -246,7 +246,7 @@ pub fn normalize_to<'a, 'b, 'tcx, T>(\n     selcx: &'a mut SelectionContext<'b, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     cause: ObligationCause<'tcx>,\n-    value: &T,\n+    value: T,\n     obligations: &mut Vec<PredicateObligation<'tcx>>,\n ) -> T\n where\n@@ -261,7 +261,7 @@ pub fn normalize_with_depth<'a, 'b, 'tcx, T>(\n     param_env: ty::ParamEnv<'tcx>,\n     cause: ObligationCause<'tcx>,\n     depth: usize,\n-    value: &T,\n+    value: T,\n ) -> Normalized<'tcx, T>\n where\n     T: TypeFoldable<'tcx>,\n@@ -277,7 +277,7 @@ pub fn normalize_with_depth_to<'a, 'b, 'tcx, T>(\n     param_env: ty::ParamEnv<'tcx>,\n     cause: ObligationCause<'tcx>,\n     depth: usize,\n-    value: &T,\n+    value: T,\n     obligations: &mut Vec<PredicateObligation<'tcx>>,\n ) -> T\n where\n@@ -309,7 +309,7 @@ impl<'a, 'b, 'tcx> AssocTypeNormalizer<'a, 'b, 'tcx> {\n         AssocTypeNormalizer { selcx, param_env, cause, obligations, depth }\n     }\n \n-    fn fold<T: TypeFoldable<'tcx>>(&mut self, value: &T) -> T {\n+    fn fold<T: TypeFoldable<'tcx>>(&mut self, value: T) -> T {\n         let value = self.selcx.infcx().resolve_vars_if_possible(value);\n \n         if !value.has_projections() { value } else { value.fold_with(self) }\n@@ -474,7 +474,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n ) -> Result<Option<Ty<'tcx>>, InProgress> {\n     let infcx = selcx.infcx();\n \n-    let projection_ty = infcx.resolve_vars_if_possible(&projection_ty);\n+    let projection_ty = infcx.resolve_vars_if_possible(projection_ty);\n     let cache_key = ProjectionCacheKey::new(projection_ty);\n \n     // FIXME(#20304) For now, I am caching here, which is good, but it\n@@ -567,7 +567,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n                     depth + 1,\n                     &mut projected_obligations,\n                 );\n-                let normalized_ty = normalizer.fold(&projected_ty);\n+                let normalized_ty = normalizer.fold(projected_ty);\n \n                 debug!(?normalized_ty, ?depth);\n \n@@ -1013,8 +1013,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                     if obligation.param_env.reveal() == Reveal::All {\n                         // NOTE(eddyb) inference variables can resolve to parameters, so\n                         // assume `poly_trait_ref` isn't monomorphic, if it contains any.\n-                        let poly_trait_ref =\n-                            selcx.infcx().resolve_vars_if_possible(&poly_trait_ref);\n+                        let poly_trait_ref = selcx.infcx().resolve_vars_if_possible(poly_trait_ref);\n                         !poly_trait_ref.still_further_specializable()\n                     } else {\n                         debug!(\n@@ -1192,7 +1191,7 @@ fn confirm_generator_candidate<'cx, 'tcx>(\n         obligation.param_env,\n         obligation.cause.clone(),\n         obligation.recursion_depth + 1,\n-        &gen_sig,\n+        gen_sig,\n     );\n \n     debug!(?obligation, ?gen_sig, ?obligations, \"confirm_generator_candidate\");\n@@ -1263,7 +1262,7 @@ fn confirm_fn_pointer_candidate<'cx, 'tcx>(\n         obligation.param_env,\n         obligation.cause.clone(),\n         obligation.recursion_depth + 1,\n-        &sig,\n+        sig,\n     );\n \n     confirm_callable_candidate(selcx, obligation, sig, util::TupleArgumentsFlag::Yes)\n@@ -1282,7 +1281,7 @@ fn confirm_closure_candidate<'cx, 'tcx>(\n         obligation.param_env,\n         obligation.cause.clone(),\n         obligation.recursion_depth + 1,\n-        &closure_sig,\n+        closure_sig,\n     );\n \n     debug!(?obligation, ?closure_sig, ?obligations, \"confirm_closure_candidate\");\n@@ -1336,7 +1335,7 @@ fn confirm_param_env_candidate<'cx, 'tcx>(\n     let (cache_entry, _) = infcx.replace_bound_vars_with_fresh_vars(\n         cause.span,\n         LateBoundRegionConversionTime::HigherRankedType,\n-        &poly_cache_entry,\n+        poly_cache_entry,\n     );\n \n     let cache_trait_ref = cache_entry.projection_ty.trait_ref(infcx.tcx);\n@@ -1349,7 +1348,7 @@ fn confirm_param_env_candidate<'cx, 'tcx>(\n                 obligation.param_env,\n                 obligation.cause.clone(),\n                 obligation.recursion_depth + 1,\n-                &cache_trait_ref,\n+                cache_trait_ref,\n                 &mut nested_obligations,\n             )\n         })\n@@ -1445,7 +1444,7 @@ fn assoc_ty_own_obligations<'cx, 'tcx>(\n             obligation.param_env,\n             obligation.cause.clone(),\n             obligation.recursion_depth + 1,\n-            &predicate,\n+            predicate,\n             nested,\n         );\n         nested.push(Obligation::with_depth(\n@@ -1526,7 +1525,7 @@ impl<'tcx> ProjectionCacheKeyExt<'tcx> for ProjectionCacheKey<'tcx> {\n                 // from a specific call to `opt_normalize_projection_type` - if\n                 // there's no precise match, the original cache entry is \"stranded\"\n                 // anyway.\n-                infcx.resolve_vars_if_possible(&predicate.projection_ty),\n+                infcx.resolve_vars_if_possible(predicate.projection_ty),\n             )\n         })\n     }"}, {"sha": "caafd0c5035eb67593b09deefbffcf17f7c65be0", "filename": "compiler/rustc_trait_selection/src/traits/query/dropck_outlives.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -40,7 +40,7 @@ impl<'cx, 'tcx> AtExt<'tcx> for At<'cx, 'tcx> {\n         }\n \n         let mut orig_values = OriginalQueryValues::default();\n-        let c_ty = self.infcx.canonicalize_query(&self.param_env.and(ty), &mut orig_values);\n+        let c_ty = self.infcx.canonicalize_query(self.param_env.and(ty), &mut orig_values);\n         let span = self.cause.span;\n         debug!(\"c_ty = {:?}\", c_ty);\n         if let Ok(result) = &tcx.dropck_outlives(c_ty) {\n@@ -53,7 +53,7 @@ impl<'cx, 'tcx> AtExt<'tcx> for At<'cx, 'tcx> {\n                         result,\n                     )\n                 {\n-                    let ty = self.infcx.resolve_vars_if_possible(&ty);\n+                    let ty = self.infcx.resolve_vars_if_possible(ty);\n                     let kinds = value.into_kinds_reporting_overflows(tcx, span, ty);\n                     return InferOk { value: kinds, obligations };\n                 }"}, {"sha": "b83a4cd1e5775c5af9a5195de09c37819c1669e2", "filename": "compiler/rustc_trait_selection/src/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -65,7 +65,7 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n     ) -> Result<EvaluationResult, OverflowError> {\n         let mut _orig_values = OriginalQueryValues::default();\n         let c_pred = self\n-            .canonicalize_query(&obligation.param_env.and(obligation.predicate), &mut _orig_values);\n+            .canonicalize_query(obligation.param_env.and(obligation.predicate), &mut _orig_values);\n         // Run canonical query. If overflow occurs, rerun from scratch but this time\n         // in standard trait query mode so that overflow is handled appropriately\n         // within `SelectionContext`."}, {"sha": "58ab109c491b0f4766112df7932e1a7de5a5f96f", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -19,7 +19,7 @@ use super::NoSolution;\n pub use rustc_middle::traits::query::NormalizationResult;\n \n pub trait AtExt<'tcx> {\n-    fn normalize<T>(&self, value: &T) -> Result<Normalized<'tcx, T>, NoSolution>\n+    fn normalize<T>(&self, value: T) -> Result<Normalized<'tcx, T>, NoSolution>\n     where\n         T: TypeFoldable<'tcx>;\n }\n@@ -38,7 +38,7 @@ impl<'cx, 'tcx> AtExt<'tcx> for At<'cx, 'tcx> {\n     /// normalizing, but for now should be used only when we actually\n     /// know that normalization will succeed, since error reporting\n     /// and other details are still \"under development\".\n-    fn normalize<T>(&self, value: &T) -> Result<Normalized<'tcx, T>, NoSolution>\n+    fn normalize<T>(&self, value: T) -> Result<Normalized<'tcx, T>, NoSolution>\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -165,7 +165,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                 // so we cannot canonicalize it.\n                 let c_data = self\n                     .infcx\n-                    .canonicalize_hr_query_hack(&self.param_env.and(*data), &mut orig_values);\n+                    .canonicalize_hr_query_hack(self.param_env.and(*data), &mut orig_values);\n                 debug!(\"QueryNormalizer: c_data = {:#?}\", c_data);\n                 debug!(\"QueryNormalizer: orig_values = {:#?}\", orig_values);\n                 match tcx.normalize_projection_ty(c_data) {"}, {"sha": "8896d0a456940d75a29c60b4f971e1345533de8c", "filename": "compiler/rustc_trait_selection/src/traits/query/outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Foutlives_bounds.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -51,7 +51,7 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n         debug!(\"implied_outlives_bounds(ty = {:?})\", ty);\n \n         let mut orig_values = OriginalQueryValues::default();\n-        let key = self.canonicalize_query(&param_env.and(ty), &mut orig_values);\n+        let key = self.canonicalize_query(param_env.and(ty), &mut orig_values);\n         let result = match self.tcx.implied_outlives_bounds(key) {\n             Ok(r) => r,\n             Err(NoSolution) => {"}, {"sha": "1688539165ab51edf36c82cefcb1290877230a6c", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/custom.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -96,7 +96,7 @@ fn scrape_region_constraints<'tcx, R>(\n         region_obligations\n             .iter()\n             .map(|(_, r_o)| (r_o.sup_type, r_o.sub_region))\n-            .map(|(ty, r)| (infcx.resolve_vars_if_possible(&ty), r)),\n+            .map(|(ty, r)| (infcx.resolve_vars_if_possible(ty), r)),\n         &region_constraint_data,\n     );\n "}, {"sha": "e90f61322933f719747d11209dc28e057728c569", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -82,7 +82,7 @@ pub trait QueryTypeOp<'tcx>: fmt::Debug + Sized + TypeFoldable<'tcx> + 'tcx {\n         // `'static` otherwise.\n         let mut canonical_var_values = OriginalQueryValues::default();\n         let canonical_self =\n-            infcx.canonicalize_hr_query_hack(&query_key, &mut canonical_var_values);\n+            infcx.canonicalize_hr_query_hack(query_key.clone(), &mut canonical_var_values);\n         let canonical_result = Self::perform_query(infcx.tcx, canonical_self)?;\n \n         let param_env = query_key.param_env;"}, {"sha": "d2556c44fb453b9e8218e235d3aa0454f2358086", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -229,7 +229,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             param_env: obligation.param_env,\n             cause: obligation.cause.clone(),\n             recursion_depth: obligation.recursion_depth,\n-            predicate: self.infcx().resolve_vars_if_possible(&obligation.predicate),\n+            predicate: self.infcx().resolve_vars_if_possible(obligation.predicate),\n         };\n \n         if obligation.predicate.skip_binder().self_ty().is_ty_var() {\n@@ -604,7 +604,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // The code below doesn't care about regions, and the\n             // self-ty here doesn't escape this probe, so just erase\n             // any LBR.\n-            let self_ty = self.tcx().erase_late_bound_regions(&obligation.self_ty());\n+            let self_ty = self.tcx().erase_late_bound_regions(obligation.self_ty());\n             let poly_trait_ref = match self_ty.kind() {\n                 ty::Dynamic(ref data, ..) => {\n                     if data.auto_traits().any(|did| did == obligation.predicate.def_id()) {\n@@ -639,9 +639,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             debug!(?poly_trait_ref, \"assemble_candidates_from_object_ty\");\n \n-            let poly_trait_predicate = self.infcx().resolve_vars_if_possible(&obligation.predicate);\n+            let poly_trait_predicate = self.infcx().resolve_vars_if_possible(obligation.predicate);\n             let placeholder_trait_predicate =\n-                self.infcx().replace_bound_vars_with_placeholders(&poly_trait_predicate);\n+                self.infcx().replace_bound_vars_with_placeholders(poly_trait_predicate);\n \n             // Count only those upcast versions that match the trait-ref\n             // we are looking for. Specifically, do not only check for the"}, {"sha": "7c155c7684ec25fa3a3b905d5e495898bc5cd0e1", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -126,7 +126,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             let trait_predicate = self.infcx.shallow_resolve(obligation.predicate);\n             let placeholder_trait_predicate =\n-                self.infcx().replace_bound_vars_with_placeholders(&trait_predicate);\n+                self.infcx().replace_bound_vars_with_placeholders(trait_predicate);\n             let placeholder_self_ty = placeholder_trait_predicate.self_ty();\n             let (def_id, substs) = match *placeholder_self_ty.kind() {\n                 ty::Projection(proj) => (proj.item_def_id, proj.substs),\n@@ -144,7 +144,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 obligation.param_env,\n                 obligation.cause.clone(),\n                 obligation.recursion_depth + 1,\n-                &candidate,\n+                candidate,\n                 &mut obligations,\n             );\n \n@@ -163,7 +163,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         obligation.param_env,\n                         obligation.cause.clone(),\n                         obligation.recursion_depth + 1,\n-                        &predicate,\n+                        predicate,\n                         &mut obligations,\n                     );\n                     obligations.push(Obligation::with_depth(\n@@ -285,8 +285,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             let trait_obligations: Vec<PredicateObligation<'_>> =\n                 self.infcx.commit_unconditionally(|_| {\n                     let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n-                    let trait_ref =\n-                        self.infcx.replace_bound_vars_with_placeholders(&poly_trait_ref);\n+                    let trait_ref = self.infcx.replace_bound_vars_with_placeholders(poly_trait_ref);\n                     let cause = obligation.derived_cause(ImplDerivedObligation);\n                     self.impl_or_trait_obligations(\n                         cause,\n@@ -370,11 +369,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let tcx = self.tcx();\n         debug!(?obligation, ?index, \"confirm_object_candidate\");\n \n-        let trait_predicate =\n-            self.infcx.replace_bound_vars_with_placeholders(&obligation.predicate);\n+        let trait_predicate = self.infcx.replace_bound_vars_with_placeholders(obligation.predicate);\n         let self_ty = self.infcx.shallow_resolve(trait_predicate.self_ty());\n         let obligation_trait_ref = ty::Binder::dummy(trait_predicate.trait_ref);\n-        let data = match self_ty.kind() {\n+        let data = match *self_ty.kind() {\n             ty::Dynamic(data, ..) => {\n                 self.infcx\n                     .replace_bound_vars_with_fresh_vars(\n@@ -416,7 +414,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             obligation.param_env,\n             obligation.cause.clone(),\n             obligation.recursion_depth + 1,\n-            &unnormalized_upcast_trait_ref,\n+            unnormalized_upcast_trait_ref,\n             &mut nested,\n         );\n \n@@ -442,7 +440,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     obligation.param_env,\n                     obligation.cause.clone(),\n                     obligation.recursion_depth + 1,\n-                    &super_trait,\n+                    super_trait,\n                     &mut nested,\n                 );\n                 nested.push(Obligation::new(\n@@ -480,7 +478,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     obligation.param_env,\n                     obligation.cause.clone(),\n                     obligation.recursion_depth + 1,\n-                    &subst_bound,\n+                    subst_bound,\n                     &mut nested,\n                 );\n                 nested.push(Obligation::new(\n@@ -520,7 +518,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 obligation.param_env,\n                 obligation.cause.clone(),\n                 obligation.recursion_depth + 1,\n-                &trait_ref,\n+                trait_ref,\n             )\n         });\n \n@@ -541,8 +539,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(?obligation, ?alias_def_id, \"confirm_trait_alias_candidate\");\n \n         self.infcx.commit_unconditionally(|_| {\n-            let predicate =\n-                self.infcx().replace_bound_vars_with_placeholders(&obligation.predicate);\n+            let predicate = self.infcx().replace_bound_vars_with_placeholders(obligation.predicate);\n             let trait_ref = predicate.trait_ref;\n             let trait_def_id = trait_ref.def_id;\n             let substs = trait_ref.substs;\n@@ -584,7 +581,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 obligation.param_env,\n                 obligation.cause.clone(),\n                 obligation.recursion_depth + 1,\n-                &trait_ref,\n+                trait_ref,\n             )\n         });\n \n@@ -627,7 +624,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 obligation.param_env,\n                 obligation.cause.clone(),\n                 obligation.recursion_depth + 1,\n-                &trait_ref,\n+                trait_ref,\n             )\n         });\n "}, {"sha": "05ff9a6fb9ca6ea4d77a793efffce80e5298b9bc", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -1019,7 +1019,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         let obligation = &stack.obligation;\n-        let predicate = self.infcx().resolve_vars_if_possible(&obligation.predicate);\n+        let predicate = self.infcx().resolve_vars_if_possible(obligation.predicate);\n \n         // Okay to skip binder because of the nature of the\n         // trait-ref-is-knowable check, which does not care about\n@@ -1138,9 +1138,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n     ) -> smallvec::SmallVec<[usize; 2]> {\n-        let poly_trait_predicate = self.infcx().resolve_vars_if_possible(&obligation.predicate);\n+        let poly_trait_predicate = self.infcx().resolve_vars_if_possible(obligation.predicate);\n         let placeholder_trait_predicate =\n-            self.infcx().replace_bound_vars_with_placeholders(&poly_trait_predicate);\n+            self.infcx().replace_bound_vars_with_placeholders(poly_trait_predicate);\n         debug!(\n             ?placeholder_trait_predicate,\n             \"match_projection_obligation_against_definition_bounds\"\n@@ -1220,7 +1220,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 obligation.param_env,\n                 obligation.cause.clone(),\n                 obligation.recursion_depth + 1,\n-                &trait_bound,\n+                trait_bound,\n             )\n         });\n         self.infcx\n@@ -1266,12 +1266,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     obligation.param_env,\n                     obligation.cause.clone(),\n                     obligation.recursion_depth + 1,\n-                    &data.map_bound_ref(|data| data.projection_ty),\n+                    data.map_bound(|data| data.projection_ty),\n                     &mut nested_obligations,\n                 )\n             })\n         } else {\n-            data.map_bound_ref(|data| data.projection_ty)\n+            data.map_bound(|data| data.projection_ty)\n         };\n \n         // FIXME(generic_associated_types): Compare the whole projections\n@@ -1737,15 +1737,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let ty: ty::Binder<Ty<'tcx>> = ty::Binder::bind(ty); // <----/\n \n                 self.infcx.commit_unconditionally(|_| {\n-                    let placeholder_ty = self.infcx.replace_bound_vars_with_placeholders(&ty);\n+                    let placeholder_ty = self.infcx.replace_bound_vars_with_placeholders(ty);\n                     let Normalized { value: normalized_ty, mut obligations } =\n                         ensure_sufficient_stack(|| {\n                             project::normalize_with_depth(\n                                 self,\n                                 param_env,\n                                 cause.clone(),\n                                 recursion_depth,\n-                                &placeholder_ty,\n+                                placeholder_ty,\n                             )\n                         });\n                     let placeholder_obligation = predicate_for_trait_def(\n@@ -1807,7 +1807,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         let placeholder_obligation =\n-            self.infcx().replace_bound_vars_with_placeholders(&obligation.predicate);\n+            self.infcx().replace_bound_vars_with_placeholders(obligation.predicate);\n         let placeholder_obligation_trait_ref = placeholder_obligation.trait_ref;\n \n         let impl_substs = self.infcx.fresh_substs_for_item(obligation.cause.span, impl_def_id);\n@@ -1821,7 +1821,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     obligation.param_env,\n                     obligation.cause.clone(),\n                     obligation.recursion_depth + 1,\n-                    &impl_trait_ref,\n+                    impl_trait_ref,\n                 )\n             });\n \n@@ -2028,7 +2028,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 param_env,\n                 cause.clone(),\n                 recursion_depth,\n-                &predicate.subst(tcx, substs),\n+                predicate.subst(tcx, substs),\n                 &mut obligations,\n             );\n             obligations.push(Obligation {"}, {"sha": "512591960f551fcf37009778d259887945226ebd", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -158,7 +158,7 @@ pub(super) fn specializes(tcx: TyCtxt<'_>, (impl1_def_id, impl2_def_id): (DefId,\n             FulfillmentContext::new(),\n             ObligationCause::dummy(),\n             penv,\n-            &impl1_trait_ref,\n+            impl1_trait_ref,\n         ) {\n             Ok(impl1_trait_ref) => impl1_trait_ref,\n             Err(err) => {\n@@ -247,7 +247,7 @@ fn fulfill_implication<'a, 'tcx>(\n \n                 // Now resolve the *substitution* we built for the target earlier, replacing\n                 // the inference variables inside with whatever we got from fulfillment.\n-                Ok(infcx.resolve_vars_if_possible(&target_substs))\n+                Ok(infcx.resolve_vars_if_possible(target_substs))\n             }\n         }\n     })"}, {"sha": "2430620323f72d5c50f3392def69a93e95c60e32", "filename": "compiler/rustc_trait_selection/src/traits/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -205,12 +205,12 @@ pub fn impl_trait_ref_and_oblig<'a, 'tcx>(\n     let impl_trait_ref = selcx.tcx().impl_trait_ref(impl_def_id).unwrap();\n     let impl_trait_ref = impl_trait_ref.subst(selcx.tcx(), impl_substs);\n     let Normalized { value: impl_trait_ref, obligations: normalization_obligations1 } =\n-        super::normalize(selcx, param_env, ObligationCause::dummy(), &impl_trait_ref);\n+        super::normalize(selcx, param_env, ObligationCause::dummy(), impl_trait_ref);\n \n     let predicates = selcx.tcx().predicates_of(impl_def_id);\n     let predicates = predicates.instantiate(selcx.tcx(), impl_substs);\n     let Normalized { value: predicates, obligations: normalization_obligations2 } =\n-        super::normalize(selcx, param_env, ObligationCause::dummy(), &predicates);\n+        super::normalize(selcx, param_env, ObligationCause::dummy(), predicates);\n     let impl_obligations =\n         predicates_for_generics(ObligationCause::dummy(), 0, param_env, predicates);\n "}, {"sha": "e5a792f229d194b930f45f4f8776bdc2c6333e4a", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -269,7 +269,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                 param_env,\n                 cause.clone(),\n                 self.recursion_depth,\n-                &obligation.predicate,\n+                obligation.predicate,\n                 &mut obligations,\n             );\n             obligation.predicate = normalized_predicate;"}, {"sha": "b1b9ef343d5a121bb9e5c3ccba43906209c07144", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -227,7 +227,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         let (inputs_and_output, iobinders, _) = crate::chalk::lowering::collect_bound_vars(\n             &self.interner,\n             self.interner.tcx,\n-            &sig.inputs_and_output().subst(self.interner.tcx, bound_vars),\n+            sig.inputs_and_output().subst(self.interner.tcx, bound_vars),\n         );\n \n         let argument_types = inputs_and_output[..inputs_and_output.len() - 1]\n@@ -461,7 +461,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n     ) -> Arc<chalk_solve::rust_ir::OpaqueTyDatum<RustInterner<'tcx>>> {\n         let bound_vars = ty::fold::shift_vars(\n             self.interner.tcx,\n-            &bound_vars_for_item(self.interner.tcx, opaque_ty_id.0),\n+            bound_vars_for_item(self.interner.tcx, opaque_ty_id.0),\n             1,\n         );\n         let where_clauses = self.where_clauses_for(opaque_ty_id.0, bound_vars);"}, {"sha": "6a5d7f96c824d3991046db29257c73ffab0da185", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -86,7 +86,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n             let (predicate, binders, _named_regions) = collect_bound_vars(\n                 interner,\n                 interner.tcx,\n-                &predicate.bound_atom_with_opt_escaping(interner.tcx),\n+                predicate.bound_atom_with_opt_escaping(interner.tcx),\n             );\n             let consequence = match predicate {\n                 ty::PredicateAtom::TypeWellFormedFromEnv(ty) => {\n@@ -141,7 +141,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n         let (predicate, binders, _named_regions) = collect_bound_vars(\n             interner,\n             interner.tcx,\n-            &self.bound_atom_with_opt_escaping(interner.tcx),\n+            self.bound_atom_with_opt_escaping(interner.tcx),\n         );\n \n         let value = match predicate {\n@@ -293,7 +293,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n             }\n             ty::FnPtr(sig) => {\n                 let (inputs_and_outputs, binders, _named_regions) =\n-                    collect_bound_vars(interner, interner.tcx, &sig.inputs_and_output());\n+                    collect_bound_vars(interner, interner.tcx, sig.inputs_and_output());\n                 chalk_ir::TyKind::Function(chalk_ir::FnPointer {\n                     num_binders: binders.len(interner),\n                     sig: sig.lower_into(interner),\n@@ -578,7 +578,7 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n         let (predicate, binders, _named_regions) = collect_bound_vars(\n             interner,\n             interner.tcx,\n-            &self.bound_atom_with_opt_escaping(interner.tcx),\n+            self.bound_atom_with_opt_escaping(interner.tcx),\n         );\n         let value = match predicate {\n             ty::PredicateAtom::Trait(predicate, _) => {\n@@ -627,10 +627,10 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Binders<chalk_ir::QuantifiedWhereClauses<Ru\n         // Binders<&[Binders<WhereClause<I>>]>\n         // This means that any variables that are escaping `self` need to be\n         // shifted in by one so that they are still escaping.\n-        let shifted_predicates = ty::fold::shift_vars(interner.tcx, &self, 1);\n+        let shifted_predicates = ty::fold::shift_vars(interner.tcx, self, 1);\n \n         let (predicates, binders, _named_regions) =\n-            collect_bound_vars(interner, interner.tcx, &shifted_predicates);\n+            collect_bound_vars(interner, interner.tcx, shifted_predicates);\n         let self_ty = interner.tcx.mk_ty(ty::Bound(\n             // This is going to be wrapped in a binder\n             ty::DebruijnIndex::from_usize(1),\n@@ -707,7 +707,7 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_solve::rust_ir::QuantifiedInlineBound<Ru\n         let (predicate, binders, _named_regions) = collect_bound_vars(\n             interner,\n             interner.tcx,\n-            &self.bound_atom_with_opt_escaping(interner.tcx),\n+            self.bound_atom_with_opt_escaping(interner.tcx),\n         );\n         match predicate {\n             ty::PredicateAtom::Trait(predicate, _) => Some(chalk_ir::Binders::new(\n@@ -808,10 +808,10 @@ impl<'tcx> LowerInto<'tcx, chalk_solve::rust_ir::AliasEqBound<RustInterner<'tcx>\n /// It's important to note that because of prior substitution, we may have\n /// late-bound regions, even outside of fn contexts, since this is the best way\n /// to prep types for chalk lowering.\n-crate fn collect_bound_vars<'a, 'tcx, T: TypeFoldable<'tcx>>(\n+crate fn collect_bound_vars<'tcx, T: TypeFoldable<'tcx>>(\n     interner: &RustInterner<'tcx>,\n     tcx: TyCtxt<'tcx>,\n-    ty: &'a Binder<T>,\n+    ty: Binder<T>,\n ) -> (T, chalk_ir::VariableKinds<RustInterner<'tcx>>, BTreeMap<DefId, u32>) {\n     let mut bound_vars_collector = BoundVarsCollector::new();\n     ty.as_ref().skip_binder().visit_with(&mut bound_vars_collector);\n@@ -824,7 +824,7 @@ crate fn collect_bound_vars<'a, 'tcx, T: TypeFoldable<'tcx>>(\n         .collect();\n \n     let mut bound_var_substitutor = NamedBoundVarSubstitutor::new(tcx, &named_parameters);\n-    let new_ty = ty.as_ref().skip_binder().fold_with(&mut bound_var_substitutor);\n+    let new_ty = ty.skip_binder().fold_with(&mut bound_var_substitutor);\n \n     for var in named_parameters.values() {\n         parameters.insert(*var, chalk_ir::VariableKind::Lifetime);\n@@ -833,7 +833,7 @@ crate fn collect_bound_vars<'a, 'tcx, T: TypeFoldable<'tcx>>(\n     (0..parameters.len()).for_each(|i| {\n         parameters\n             .get(&(i as u32))\n-            .or_else(|| bug!(\"Skipped bound var index: ty={:?}, parameters={:?}\", ty, parameters));\n+            .or_else(|| bug!(\"Skipped bound var index: parameters={:?}\", parameters));\n     });\n \n     let binders =\n@@ -941,7 +941,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for NamedBoundVarSubstitutor<'a, 'tcx> {\n         self.tcx\n     }\n \n-    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> Binder<T> {\n+    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: Binder<T>) -> Binder<T> {\n         self.binder_index.shift_in(1);\n         let result = t.super_fold_with(self);\n         self.binder_index.shift_out(1);\n@@ -1001,7 +1001,7 @@ impl<'tcx> TypeFolder<'tcx> for ParamsSubstitutor<'tcx> {\n         self.tcx\n     }\n \n-    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> Binder<T> {\n+    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: Binder<T>) -> Binder<T> {\n         self.binder_index.shift_in(1);\n         let result = t.super_fold_with(self);\n         self.binder_index.shift_out(1);"}, {"sha": "2827163d854d5d5b83121a4f2fb2f295c5e72f3c", "filename": "compiler/rustc_traits/src/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -106,7 +106,7 @@ fn dropck_outlives<'tcx>(\n                 // do not themselves define a destructor\", more or less. We have\n                 // to push them onto the stack to be expanded.\n                 for ty in constraints.dtorck_types.drain(..) {\n-                    match infcx.at(&cause, param_env).normalize(&ty) {\n+                    match infcx.at(&cause, param_env).normalize(ty) {\n                         Ok(Normalized { value: ty, obligations }) => {\n                             fulfill_cx.register_predicate_obligations(infcx, obligations);\n "}, {"sha": "97017fbf2e56a31965167a6400c4bb376b66b296", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -115,7 +115,7 @@ fn compute_implied_outlives_bounds<'tcx>(\n                     }\n \n                     ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty_a, r_b)) => {\n-                        let ty_a = infcx.resolve_vars_if_possible(&ty_a);\n+                        let ty_a = infcx.resolve_vars_if_possible(ty_a);\n                         let mut components = smallvec![];\n                         tcx.push_outlives_components(ty_a, &mut components);\n                         implied_bounds_from_components(r_b, components)"}, {"sha": "750a0922be4d1c54819da354edd834225cfece70", "filename": "compiler/rustc_traits/src/normalize_erasing_regions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -21,7 +21,7 @@ fn normalize_generic_arg_after_erasing_regions<'tcx>(\n     tcx.sess.perf_stats.normalize_generic_arg_after_erasing_regions.fetch_add(1, Ordering::Relaxed);\n     tcx.infer_ctxt().enter(|infcx| {\n         let cause = ObligationCause::dummy();\n-        match infcx.at(&cause, param_env).normalize(&value) {\n+        match infcx.at(&cause, param_env).normalize(value) {\n             Ok(Normalized { value: normalized_value, obligations: normalized_obligations }) => {\n                 // We don't care about the `obligations`; they are\n                 // always only region relations, and we are about to\n@@ -31,8 +31,8 @@ fn normalize_generic_arg_after_erasing_regions<'tcx>(\n                     None,\n                 );\n \n-                let normalized_value = infcx.resolve_vars_if_possible(&normalized_value);\n-                infcx.tcx.erase_regions(&normalized_value)\n+                let normalized_value = infcx.resolve_vars_if_possible(normalized_value);\n+                infcx.tcx.erase_regions(normalized_value)\n             }\n             Err(NoSolution) => bug!(\"could not fully normalize `{:?}`\", value),\n         }"}, {"sha": "0addde5c44c894b7aaa2b0c21e907743ecc6bcce", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -70,7 +70,7 @@ impl AscribeUserTypeCx<'me, 'tcx> {\n                 DUMMY_SP,\n                 hir::CRATE_HIR_ID,\n                 self.param_env,\n-                &value,\n+                value,\n             )\n             .into_value_registering_obligations(self.infcx, self.fulfill_cx)\n     }\n@@ -184,7 +184,7 @@ where\n {\n     let (param_env, Normalize { value }) = key.into_parts();\n     let Normalized { value, obligations } =\n-        infcx.at(&ObligationCause::dummy(), param_env).normalize(&value)?;\n+        infcx.at(&ObligationCause::dummy(), param_env).normalize(value)?;\n     fulfill_cx.register_predicate_obligations(infcx, obligations);\n     Ok(value)\n }"}, {"sha": "cf2c6efb4711f465d4466cf5a3528579ba1c6e38", "filename": "compiler/rustc_ty/src/instance.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_ty%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_ty%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty%2Fsrc%2Finstance.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -51,7 +51,7 @@ fn inner_resolve_instance<'tcx>(\n         resolve_associated_item(tcx, &item, param_env, trait_def_id, substs)\n     } else {\n         let ty = tcx.type_of(def.def_id_for_type_of());\n-        let item_type = tcx.subst_and_normalize_erasing_regions(substs, param_env, &ty);\n+        let item_type = tcx.subst_and_normalize_erasing_regions(substs, param_env, ty);\n \n         let def = match *item_type.kind() {\n             ty::FnDef(..)\n@@ -146,7 +146,7 @@ fn resolve_associated_item<'tcx>(\n                     substs,\n                     leaf_def.defining_node,\n                 );\n-                infcx.tcx.erase_regions(&substs)\n+                infcx.tcx.erase_regions(substs)\n             });\n \n             // Since this is a trait item, we need to see if the item is either a trait default item\n@@ -172,7 +172,7 @@ fn resolve_associated_item<'tcx>(\n                 return Ok(None);\n             }\n \n-            let substs = tcx.erase_regions(&substs);\n+            let substs = tcx.erase_regions(substs);\n \n             // Check if we just resolved an associated `const` declaration from\n             // a `trait` to an associated `const` definition in an `impl`, where\n@@ -192,7 +192,7 @@ fn resolve_associated_item<'tcx>(\n                 && leaf_def.item.def_id.is_local()\n             {\n                 let normalized_type_of = |def_id, substs| {\n-                    tcx.subst_and_normalize_erasing_regions(substs, param_env, &tcx.type_of(def_id))\n+                    tcx.subst_and_normalize_erasing_regions(substs, param_env, tcx.type_of(def_id))\n                 };\n \n                 let original_ty = normalized_type_of(trait_item.def_id, rcvr_substs);\n@@ -264,7 +264,7 @@ fn resolve_associated_item<'tcx>(\n                     assert_eq!(name, sym::clone_from);\n \n                     // Use the default `fn clone_from` from `trait Clone`.\n-                    let substs = tcx.erase_regions(&rcvr_substs);\n+                    let substs = tcx.erase_regions(rcvr_substs);\n                     Some(ty::Instance::new(def_id, substs))\n                 }\n             } else {"}, {"sha": "d62fc764c76d719e5d859f1cddc72e5006a9067c", "filename": "compiler/rustc_ty/src/needs_drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_ty%2Fsrc%2Fneeds_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_ty%2Fsrc%2Fneeds_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty%2Fsrc%2Fneeds_drop.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -107,7 +107,7 @@ where\n \n                         let witness = substs.witness();\n                         let interior_tys = match witness.kind() {\n-                            ty::GeneratorWitness(tys) => tcx.erase_late_bound_regions(tys),\n+                            &ty::GeneratorWitness(tys) => tcx.erase_late_bound_regions(tys),\n                             _ => {\n                                 tcx.sess.delay_span_bug(\n                                     tcx.hir().span_if_local(def_id).unwrap_or(DUMMY_SP),"}, {"sha": "720ad42da2aaa37d2e0f3ca4bc351c924b3b5a5d", "filename": "compiler/rustc_ty/src/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_ty%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_ty%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty%2Fsrc%2Fty.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -363,7 +363,7 @@ fn well_formed_types_in_env<'tcx>(\n         // well-formed.\n         NodeKind::Fn => {\n             let fn_sig = tcx.fn_sig(def_id);\n-            let fn_sig = tcx.liberate_late_bound_regions(def_id, &fn_sig);\n+            let fn_sig = tcx.liberate_late_bound_regions(def_id, fn_sig);\n \n             inputs.extend(fn_sig.inputs().iter().flat_map(|ty| ty.walk()));\n         }"}, {"sha": "3a5eeb5381becf4bbe3962ef0918253df5b5f08b", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -131,7 +131,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         id,\n                         self.body_id,\n                         self.param_env,\n-                        &ty,\n+                        ty,\n                         arm.body.span,\n                     );\n                     let mut suggest_box = !impl_trait_ret_ty.obligations.is_empty();"}, {"sha": "ebfb401fcf3ad2cb3190b40e9a4960e05ddd1e2a", "filename": "compiler/rustc_typeck/src/check/callee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -133,7 +133,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .replace_bound_vars_with_fresh_vars(\n                             call_expr.span,\n                             infer::FnCall,\n-                            &closure_sig,\n+                            closure_sig,\n                         )\n                         .0;\n                     let adjustments = self.adjust_steps(autoderef);\n@@ -407,8 +407,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // previously appeared within a `Binder<>` and hence would not\n         // have been normalized before.\n         let fn_sig =\n-            self.replace_bound_vars_with_fresh_vars(call_expr.span, infer::FnCall, &fn_sig).0;\n-        let fn_sig = self.normalize_associated_types_in(call_expr.span, &fn_sig);\n+            self.replace_bound_vars_with_fresh_vars(call_expr.span, infer::FnCall, fn_sig).0;\n+        let fn_sig = self.normalize_associated_types_in(call_expr.span, fn_sig);\n \n         // Call the generic checker.\n         let expected_arg_tys = self.expected_inputs_for_expected_output("}, {"sha": "36240a9b41e7d06f4a765f5981f8232e8d735101", "filename": "compiler/rustc_typeck/src/check/cast.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -87,7 +87,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Result<Option<PointerKind<'tcx>>, ErrorReported> {\n         debug!(\"pointer_kind({:?}, {:?})\", t, span);\n \n-        let t = self.resolve_vars_if_possible(&t);\n+        let t = self.resolve_vars_if_possible(t);\n \n         if t.references_error() {\n             return Err(ErrorReported);\n@@ -377,12 +377,12 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                     // Check `impl From<self.expr_ty> for self.cast_ty {}` for accurate suggestion:\n                     if let Ok(snippet) = fcx.tcx.sess.source_map().span_to_snippet(self.expr.span) {\n                         if let Some(from_trait) = fcx.tcx.get_diagnostic_item(sym::from_trait) {\n-                            let ty = fcx.resolve_vars_if_possible(&self.cast_ty);\n+                            let ty = fcx.resolve_vars_if_possible(self.cast_ty);\n                             // Erase regions to avoid panic in `prove_value` when calling\n                             // `type_implements_trait`.\n-                            let ty = fcx.tcx.erase_regions(&ty);\n-                            let expr_ty = fcx.resolve_vars_if_possible(&self.expr_ty);\n-                            let expr_ty = fcx.tcx.erase_regions(&expr_ty);\n+                            let ty = fcx.tcx.erase_regions(ty);\n+                            let expr_ty = fcx.resolve_vars_if_possible(self.expr_ty);\n+                            let expr_ty = fcx.tcx.erase_regions(expr_ty);\n                             let ty_params = fcx.tcx.mk_substs_trait(expr_ty, &[]);\n                             // Check for infer types because cases like `Option<{integer}>` would\n                             // panic otherwise.\n@@ -471,7 +471,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n             self.expr_ty,\n             E0620,\n             \"cast to unsized type: `{}` as `{}`\",\n-            fcx.resolve_vars_if_possible(&self.expr_ty),\n+            fcx.resolve_vars_if_possible(self.expr_ty),\n             tstr\n         );\n         match self.expr_ty.kind() {\n@@ -607,7 +607,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                         // Attempt a coercion to a fn pointer type.\n                         let f = fcx.normalize_associated_types_in(\n                             self.expr.span,\n-                            &self.expr_ty.fn_sig(fcx.tcx),\n+                            self.expr_ty.fn_sig(fcx.tcx),\n                         );\n                         let res = fcx.try_coerce(\n                             self.expr,"}, {"sha": "631d4bb34f8fe305bd4dd276871ff1632393f995", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -75,7 +75,7 @@ pub(super) fn check_fn<'a, 'tcx>(\n     let declared_ret_ty = fn_sig.output();\n \n     let revealed_ret_ty =\n-        fcx.instantiate_opaque_types_from_value(fn_id, &declared_ret_ty, decl.output.span());\n+        fcx.instantiate_opaque_types_from_value(fn_id, declared_ret_ty, decl.output.span());\n     debug!(\"check_fn: declared_ret_ty: {}, revealed_ret_ty: {}\", declared_ret_ty, revealed_ret_ty);\n     fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(revealed_ret_ty)));\n     fcx.ret_type_span = Some(decl.output.span());\n@@ -601,7 +601,7 @@ fn check_opaque_meets_bounds<'tcx>(\n         let misc_cause = traits::ObligationCause::misc(span, hir_id);\n \n         let (_, opaque_type_map) = inh.register_infer_ok_obligations(\n-            infcx.instantiate_opaque_types(def_id, hir_id, param_env, &opaque_ty, span),\n+            infcx.instantiate_opaque_types(def_id, hir_id, param_env, opaque_ty, span),\n         );\n \n         for (def_id, opaque_defn) in opaque_type_map {"}, {"sha": "8082a230216e29a3046f103b0f10b1db038ac109", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -257,7 +257,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let input_tys = if is_fn {\n             let arg_param_ty = trait_ref.skip_binder().substs.type_at(1);\n-            let arg_param_ty = self.resolve_vars_if_possible(&arg_param_ty);\n+            let arg_param_ty = self.resolve_vars_if_possible(arg_param_ty);\n             debug!(\"deduce_sig_from_projection: arg_param_ty={:?}\", arg_param_ty);\n \n             match arg_param_ty.kind() {\n@@ -271,7 +271,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         let ret_param_ty = projection.skip_binder().ty;\n-        let ret_param_ty = self.resolve_vars_if_possible(&ret_param_ty);\n+        let ret_param_ty = self.resolve_vars_if_possible(ret_param_ty);\n         debug!(\"deduce_sig_from_projection: ret_param_ty={:?}\", ret_param_ty);\n \n         let sig = self.tcx.mk_fn_sig(\n@@ -400,7 +400,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // `deduce_expectations_from_expected_type` introduces\n         // late-bound lifetimes defined elsewhere, which we now\n         // anonymize away, so as not to confuse the user.\n-        let bound_sig = self.tcx.anonymize_late_bound_regions(&bound_sig);\n+        let bound_sig = self.tcx.anonymize_late_bound_regions(bound_sig);\n \n         let closure_sigs = self.closure_sigs(expr_def_id, body, bound_sig);\n \n@@ -500,7 +500,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let (supplied_ty, _) = self.infcx.replace_bound_vars_with_fresh_vars(\n                     hir_ty.span,\n                     LateBoundRegionConversionTime::FnCall,\n-                    &ty::Binder::bind(supplied_ty),\n+                    ty::Binder::bind(supplied_ty),\n                 ); // recreated from (*) above\n \n                 // Check that E' = S'.\n@@ -513,7 +513,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let (supplied_output_ty, _) = self.infcx.replace_bound_vars_with_fresh_vars(\n                 decl.output.span(),\n                 LateBoundRegionConversionTime::FnCall,\n-                &supplied_sig.output(),\n+                supplied_sig.output(),\n             );\n             let cause = &self.misc(decl.output.span());\n             let InferOk { value: (), obligations } = self\n@@ -578,7 +578,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         debug!(\"supplied_sig_of_closure: result={:?}\", result);\n \n-        let c_result = self.inh.infcx.canonicalize_response(&result);\n+        let c_result = self.inh.infcx.canonicalize_response(result);\n         self.typeck_results.borrow_mut().user_provided_sigs.insert(expr_def_id, c_result);\n \n         result\n@@ -683,7 +683,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Extract the type from the projection. Note that there can\n         // be no bound variables in this type because the \"self type\"\n         // does not have any regions in it.\n-        let output_ty = self.resolve_vars_if_possible(&predicate.ty);\n+        let output_ty = self.resolve_vars_if_possible(predicate.ty);\n         debug!(\"deduce_future_output_from_projection: output_ty={:?}\", output_ty);\n         Some(output_ty)\n     }\n@@ -723,12 +723,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         body: &hir::Body<'_>,\n         bound_sig: ty::PolyFnSig<'tcx>,\n     ) -> ClosureSignatures<'tcx> {\n-        let liberated_sig = self.tcx().liberate_late_bound_regions(expr_def_id, &bound_sig);\n+        let liberated_sig = self.tcx().liberate_late_bound_regions(expr_def_id, bound_sig);\n         let liberated_sig = self.inh.normalize_associated_types_in(\n             body.value.span,\n             body.value.hir_id,\n             self.param_env,\n-            &liberated_sig,\n+            liberated_sig,\n         );\n         ClosureSignatures { bound_sig, liberated_sig }\n     }"}, {"sha": "0f5f0ab0260875e9b0cc12e04504b7def9c37081", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -606,7 +606,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 // Uncertain or unimplemented.\n                 Ok(None) => {\n                     if trait_pred.def_id() == unsize_did {\n-                        let trait_pred = self.resolve_vars_if_possible(&trait_pred);\n+                        let trait_pred = self.resolve_vars_if_possible(trait_pred);\n                         let self_ty = trait_pred.skip_binder().self_ty();\n                         let unsize_ty = trait_pred.skip_binder().trait_ref.substs[1].expect_ty();\n                         debug!(\"coerce_unsized: ambiguous unsize case for {:?}\", trait_pred);\n@@ -732,7 +732,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 }\n \n                 let InferOk { value: a_sig, mut obligations } =\n-                    self.normalize_associated_types_in_as_infer_ok(self.cause.span, &a_sig);\n+                    self.normalize_associated_types_in_as_infer_ok(self.cause.span, a_sig);\n \n                 let a_fn_pointer = self.tcx.mk_fn_ptr(a_sig);\n                 let InferOk { value, obligations: o2 } = self.coerce_from_safe_fn(\n@@ -973,8 +973,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n         if let (Some(a_sig), Some(b_sig)) = (a_sig, b_sig) {\n             // The signature must match.\n-            let a_sig = self.normalize_associated_types_in(new.span, &a_sig);\n-            let b_sig = self.normalize_associated_types_in(new.span, &b_sig);\n+            let a_sig = self.normalize_associated_types_in(new.span, a_sig);\n+            let b_sig = self.normalize_associated_types_in(new.span, b_sig);\n             let sig = self\n                 .at(cause, self.param_env)\n                 .trace(prev_ty, new_ty)\n@@ -1490,7 +1490,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                         *sp,\n                         &format!(\n                             \"return type inferred to be `{}` here\",\n-                            fcx.resolve_vars_if_possible(&expected)\n+                            fcx.resolve_vars_if_possible(expected)\n                         ),\n                     );\n                 }"}, {"sha": "20090d37606005f1bb707486d6fc245904d116ce", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -224,11 +224,11 @@ fn compare_predicate_entailment<'tcx>(\n         let (impl_m_own_bounds, _) = infcx.replace_bound_vars_with_fresh_vars(\n             impl_m_span,\n             infer::HigherRankedType,\n-            &ty::Binder::bind(impl_m_own_bounds.predicates),\n+            ty::Binder::bind(impl_m_own_bounds.predicates),\n         );\n         for predicate in impl_m_own_bounds {\n             let traits::Normalized { value: predicate, obligations } =\n-                traits::normalize(&mut selcx, param_env, normalize_cause.clone(), &predicate);\n+                traits::normalize(&mut selcx, param_env, normalize_cause.clone(), predicate);\n \n             inh.register_predicates(obligations);\n             inh.register_predicate(traits::Obligation::new(cause.clone(), param_env, predicate));\n@@ -253,17 +253,17 @@ fn compare_predicate_entailment<'tcx>(\n         let (impl_sig, _) = infcx.replace_bound_vars_with_fresh_vars(\n             impl_m_span,\n             infer::HigherRankedType,\n-            &tcx.fn_sig(impl_m.def_id),\n+            tcx.fn_sig(impl_m.def_id),\n         );\n         let impl_sig =\n-            inh.normalize_associated_types_in(impl_m_span, impl_m_hir_id, param_env, &impl_sig);\n+            inh.normalize_associated_types_in(impl_m_span, impl_m_hir_id, param_env, impl_sig);\n         let impl_fty = tcx.mk_fn_ptr(ty::Binder::bind(impl_sig));\n         debug!(\"compare_impl_method: impl_fty={:?}\", impl_fty);\n \n-        let trait_sig = tcx.liberate_late_bound_regions(impl_m.def_id, &tcx.fn_sig(trait_m.def_id));\n+        let trait_sig = tcx.liberate_late_bound_regions(impl_m.def_id, tcx.fn_sig(trait_m.def_id));\n         let trait_sig = trait_sig.subst(tcx, trait_to_placeholder_substs);\n         let trait_sig =\n-            inh.normalize_associated_types_in(impl_m_span, impl_m_hir_id, param_env, &trait_sig);\n+            inh.normalize_associated_types_in(impl_m_span, impl_m_hir_id, param_env, trait_sig);\n         let trait_fty = tcx.mk_fn_ptr(ty::Binder::bind(trait_sig));\n \n         debug!(\"compare_impl_method: trait_fty={:?}\", trait_fty);\n@@ -499,7 +499,7 @@ fn compare_self_type<'tcx>(\n \n         tcx.infer_ctxt().enter(|infcx| {\n             let self_arg_ty =\n-                tcx.liberate_late_bound_regions(method.def_id, &ty::Binder::bind(self_arg_ty));\n+                tcx.liberate_late_bound_regions(method.def_id, ty::Binder::bind(self_arg_ty));\n             let can_eq_self = |ty| infcx.can_eq(param_env, untransformed_self_ty, ty).is_ok();\n             match ExplicitSelf::determine(self_arg_ty, can_eq_self) {\n                 ExplicitSelf::ByValue => \"self\".to_owned(),\n@@ -968,12 +968,12 @@ crate fn compare_const_impl<'tcx>(\n \n         // There is no \"body\" here, so just pass dummy id.\n         let impl_ty =\n-            inh.normalize_associated_types_in(impl_c_span, impl_c_hir_id, param_env, &impl_ty);\n+            inh.normalize_associated_types_in(impl_c_span, impl_c_hir_id, param_env, impl_ty);\n \n         debug!(\"compare_const_impl: impl_ty={:?}\", impl_ty);\n \n         let trait_ty =\n-            inh.normalize_associated_types_in(impl_c_span, impl_c_hir_id, param_env, &trait_ty);\n+            inh.normalize_associated_types_in(impl_c_span, impl_c_hir_id, param_env, trait_ty);\n \n         debug!(\"compare_const_impl: trait_ty={:?}\", trait_ty);\n \n@@ -1136,7 +1136,7 @@ fn compare_type_predicate_entailment<'tcx>(\n \n         for predicate in impl_ty_own_bounds.predicates {\n             let traits::Normalized { value: predicate, obligations } =\n-                traits::normalize(&mut selcx, param_env, normalize_cause.clone(), &predicate);\n+                traits::normalize(&mut selcx, param_env, normalize_cause.clone(), predicate);\n \n             inh.register_predicates(obligations);\n             inh.register_predicate(traits::Obligation::new(cause.clone(), param_env, predicate));\n@@ -1261,7 +1261,7 @@ pub fn check_type_bounds<'tcx>(\n                 &mut selcx,\n                 normalize_param_env,\n                 normalize_cause.clone(),\n-                &obligation.predicate,\n+                obligation.predicate,\n             );\n             debug!(\"compare_projection_bounds: normalized predicate = {:?}\", normalized_predicate);\n             obligation.predicate = normalized_predicate;"}, {"sha": "ad675f1e3833e229bb511c28755d6e796d15cd84", "filename": "compiler/rustc_typeck/src/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -366,8 +366,8 @@ impl TypeRelation<'tcx> for SimpleEqRelation<'tcx> {\n \n         // Anonymizing the LBRs is necessary to solve (Issue #59497).\n         // After we do so, it should be totally fine to skip the binders.\n-        let anon_a = self.tcx.anonymize_late_bound_regions(&a);\n-        let anon_b = self.tcx.anonymize_late_bound_regions(&b);\n+        let anon_a = self.tcx.anonymize_late_bound_regions(a);\n+        let anon_b = self.tcx.anonymize_late_bound_regions(b);\n         self.relate(anon_a.skip_binder(), anon_b.skip_binder())?;\n \n         Ok(a)"}, {"sha": "5a5fc893d658800cfe78be5a8748c56ba3dbd91d", "filename": "compiler/rustc_typeck/src/check/expectation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpectation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpectation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpectation.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -83,9 +83,9 @@ impl<'a, 'tcx> Expectation<'tcx> {\n     fn resolve(self, fcx: &FnCtxt<'a, 'tcx>) -> Expectation<'tcx> {\n         match self {\n             NoExpectation => NoExpectation,\n-            ExpectCastableToType(t) => ExpectCastableToType(fcx.resolve_vars_if_possible(&t)),\n-            ExpectHasType(t) => ExpectHasType(fcx.resolve_vars_if_possible(&t)),\n-            ExpectRvalueLikeUnsized(t) => ExpectRvalueLikeUnsized(fcx.resolve_vars_if_possible(&t)),\n+            ExpectCastableToType(t) => ExpectCastableToType(fcx.resolve_vars_if_possible(t)),\n+            ExpectHasType(t) => ExpectHasType(fcx.resolve_vars_if_possible(t)),\n+            ExpectRvalueLikeUnsized(t) => ExpectRvalueLikeUnsized(fcx.resolve_vars_if_possible(t)),\n         }\n     }\n "}, {"sha": "f7f9e607a74412bbc2b04f12e5fd445700e75e71", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -494,7 +494,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .replace_bound_vars_with_fresh_vars(\n                             expr.span,\n                             infer::LateBoundRegionConversionTime::FnCall,\n-                            &fn_sig.input(i),\n+                            fn_sig.input(i),\n                         )\n                         .0;\n                     self.require_type_is_sized_deferred(\n@@ -514,7 +514,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 .replace_bound_vars_with_fresh_vars(\n                     expr.span,\n                     infer::LateBoundRegionConversionTime::FnCall,\n-                    &fn_sig.output(),\n+                    fn_sig.output(),\n                 )\n                 .0;\n             self.require_type_is_sized_deferred(output, expr.span, traits::SizedReturnType);\n@@ -963,9 +963,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Find the type of `e`. Supply hints based on the type we are casting to,\n         // if appropriate.\n         let t_cast = self.to_ty_saving_user_provided_ty(t);\n-        let t_cast = self.resolve_vars_if_possible(&t_cast);\n+        let t_cast = self.resolve_vars_if_possible(t_cast);\n         let t_expr = self.check_expr_with_expectation(e, ExpectCastableToType(t_cast));\n-        let t_cast = self.resolve_vars_if_possible(&t_cast);\n+        let t_cast = self.resolve_vars_if_possible(t_cast);\n \n         // Eagerly check for some obvious errors.\n         if t_expr.references_error() || t_cast.references_error() {\n@@ -1139,7 +1139,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             .map(|f| {\n                                 self.normalize_associated_types_in(\n                                     expr.span,\n-                                    &f.ty(self.tcx, substs),\n+                                    f.ty(self.tcx, substs),\n                                 )\n                             })\n                             .collect();\n@@ -1571,7 +1571,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ty: Ty<'tcx>,\n     ) {\n         let output_ty = match self.infcx.get_impl_future_output_ty(ty) {\n-            Some(output_ty) => self.resolve_vars_if_possible(&output_ty),\n+            Some(output_ty) => self.resolve_vars_if_possible(output_ty),\n             _ => return,\n         };\n         let mut add_label = true;"}, {"sha": "e1a2f593b8d9b364944a2d3a513c8606a69b8065", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -88,7 +88,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         // If `ty` is a type variable, see whether we already know what it is.\n-        ty = self.resolve_vars_if_possible(&ty);\n+        ty = self.resolve_vars_if_possible(ty);\n         if !ty.has_infer_types_or_consts() {\n             debug!(\"resolve_vars_with_obligations: ty={:?}\", ty);\n             return ty;\n@@ -99,7 +99,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // indirect dependencies that don't seem worth tracking\n         // precisely.\n         self.select_obligations_where_possible(false, |_| {});\n-        ty = self.resolve_vars_if_possible(&ty);\n+        ty = self.resolve_vars_if_possible(ty);\n \n         debug!(\"resolve_vars_with_obligations: ty={:?}\", ty);\n         ty\n@@ -134,12 +134,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     #[inline]\n     pub fn write_ty(&self, id: hir::HirId, ty: Ty<'tcx>) {\n-        debug!(\n-            \"write_ty({:?}, {:?}) in fcx {}\",\n-            id,\n-            self.resolve_vars_if_possible(&ty),\n-            self.tag()\n-        );\n+        debug!(\"write_ty({:?}, {:?}) in fcx {}\", id, self.resolve_vars_if_possible(ty), self.tag());\n         self.typeck_results.borrow_mut().node_types_mut().insert(id, ty);\n \n         if ty.references_error() {\n@@ -195,7 +190,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         user_self_ty: None, // not relevant here\n                     };\n \n-                    self.infcx.canonicalize_user_type_annotation(&UserType::TypeOf(\n+                    self.infcx.canonicalize_user_type_annotation(UserType::TypeOf(\n                         method.def_id,\n                         user_substs,\n                     ))\n@@ -240,7 +235,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n \n         if Self::can_contain_user_lifetime_bounds((substs, user_self_ty)) {\n-            let canonicalized = self.infcx.canonicalize_user_type_annotation(&UserType::TypeOf(\n+            let canonicalized = self.infcx.canonicalize_user_type_annotation(UserType::TypeOf(\n                 def_id,\n                 UserSubsts { substs, user_self_ty },\n             ));\n@@ -326,13 +321,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Basically whenever we are converting from a type scheme into\n     /// the fn body space, we always want to normalize associated\n     /// types as well. This function combines the two.\n-    fn instantiate_type_scheme<T>(&self, span: Span, substs: SubstsRef<'tcx>, value: &T) -> T\n+    fn instantiate_type_scheme<T>(&self, span: Span, substs: SubstsRef<'tcx>, value: T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n+        debug!(\"instantiate_type_scheme(value={:?}, substs={:?})\", value, substs);\n         let value = value.subst(self.tcx, substs);\n-        let result = self.normalize_associated_types_in(span, &value);\n-        debug!(\"instantiate_type_scheme(value={:?}, substs={:?}) = {:?}\", value, substs, result);\n+        let result = self.normalize_associated_types_in(span, value);\n+        debug!(\"instantiate_type_scheme = {:?}\", result);\n         result\n     }\n \n@@ -347,7 +343,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let bounds = self.tcx.predicates_of(def_id);\n         let spans: Vec<Span> = bounds.predicates.iter().map(|(_, span)| *span).collect();\n         let result = bounds.instantiate(self.tcx, substs);\n-        let result = self.normalize_associated_types_in(span, &result);\n+        let result = self.normalize_associated_types_in(span, result);\n         debug!(\n             \"instantiate_bounds(bounds={:?}, substs={:?}) = {:?}, {:?}\",\n             bounds, substs, result, spans,\n@@ -361,7 +357,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(in super::super) fn instantiate_opaque_types_from_value<T: TypeFoldable<'tcx>>(\n         &self,\n         parent_id: hir::HirId,\n-        value: &T,\n+        value: T,\n         value_span: Span,\n     ) -> T {\n         let parent_def_id = self.tcx.hir().local_def_id(parent_id);\n@@ -389,7 +385,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         value\n     }\n \n-    pub(in super::super) fn normalize_associated_types_in<T>(&self, span: Span, value: &T) -> T\n+    pub(in super::super) fn normalize_associated_types_in<T>(&self, span: Span, value: T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -399,7 +395,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(in super::super) fn normalize_associated_types_in_as_infer_ok<T>(\n         &self,\n         span: Span,\n-        value: &T,\n+        value: T,\n     ) -> InferOk<'tcx, T>\n     where\n         T: TypeFoldable<'tcx>,\n@@ -468,7 +464,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         debug!(\"to_ty_saving_user_provided_ty: ty={:?}\", ty);\n \n         if Self::can_contain_user_lifetime_bounds(ty) {\n-            let c_ty = self.infcx.canonicalize_response(&UserType::Ty(ty));\n+            let c_ty = self.infcx.canonicalize_response(UserType::Ty(ty));\n             debug!(\"to_ty_saving_user_provided_ty: c_ty={:?}\", c_ty);\n             self.typeck_results.borrow_mut().user_provided_types_mut().insert(ast_ty.hir_id, c_ty);\n         }\n@@ -851,7 +847,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 // Record all the argument types, with the substitutions\n                 // produced from the above subtyping unification.\n-                Ok(formal_args.iter().map(|ty| self.resolve_vars_if_possible(ty)).collect())\n+                Ok(formal_args.iter().map(|&ty| self.resolve_vars_if_possible(ty)).collect())\n             })\n             .unwrap_or_default();\n         debug!(\n@@ -1204,7 +1200,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if let Res::Local(hid) = res {\n             let ty = self.local_ty(span, hid).decl_ty;\n-            let ty = self.normalize_associated_types_in(span, &ty);\n+            let ty = self.normalize_associated_types_in(span, ty);\n             self.write_ty(hir_id, ty);\n             return (ty, res);\n         }\n@@ -1414,7 +1410,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Substitute the values for the type parameters into the type of\n         // the referenced item.\n-        let ty_substituted = self.instantiate_type_scheme(span, &substs, &ty);\n+        let ty_substituted = self.instantiate_type_scheme(span, &substs, ty);\n \n         if let Some(UserSelfTy { impl_def_id, self_ty }) = user_self_ty {\n             // In the case of `Foo<T>::method` and `<Foo<T>>::method`, if `method`\n@@ -1424,7 +1420,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // This also occurs for an enum variant on a type alias.\n             let ty = tcx.type_of(impl_def_id);\n \n-            let impl_ty = self.instantiate_type_scheme(span, &substs, &ty);\n+            let impl_ty = self.instantiate_type_scheme(span, &substs, ty);\n             match self.at(&self.misc(span), self.param_env).sup(impl_ty, self_ty) {\n                 Ok(ok) => self.register_infer_ok_obligations(ok),\n                 Err(_) => {"}, {"sha": "333bda00dbe817f4fefe808d68898bffbcec5ed4", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -261,9 +261,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         } else {\n             // is the missing argument of type `()`?\n             let sugg_unit = if expected_arg_tys.len() == 1 && supplied_arg_count == 0 {\n-                self.resolve_vars_if_possible(&expected_arg_tys[0]).is_unit()\n+                self.resolve_vars_if_possible(expected_arg_tys[0]).is_unit()\n             } else if fn_inputs.len() == 1 && supplied_arg_count == 0 {\n-                self.resolve_vars_if_possible(&fn_inputs[0]).is_unit()\n+                self.resolve_vars_if_possible(fn_inputs[0]).is_unit()\n             } else {\n                 false\n             };\n@@ -384,7 +384,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                     ty::FnDef(..) => {\n                         let ptr_ty = self.tcx.mk_fn_ptr(arg_ty.fn_sig(self.tcx));\n-                        let ptr_ty = self.resolve_vars_if_possible(&ptr_ty);\n+                        let ptr_ty = self.resolve_vars_if_possible(ptr_ty);\n                         variadic_error(tcx.sess, arg.span, arg_ty, &ptr_ty.to_string());\n                     }\n                     _ => {}\n@@ -927,7 +927,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .map(|&(i, checked_ty, _)| (i, checked_ty))\n                     .chain(final_arg_types.iter().map(|&(i, _, coerced_ty)| (i, coerced_ty)))\n                     .flat_map(|(i, ty)| {\n-                        let ty = self.resolve_vars_if_possible(&ty);\n+                        let ty = self.resolve_vars_if_possible(ty);\n                         // We walk the argument type because the argument's type could have\n                         // been `Option<T>`, but the `FulfillmentError` references `T`.\n                         if ty.walk().any(|arg| arg == predicate.self_ty().into()) {\n@@ -989,7 +989,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                         // from `typeck-default-trait-impl-assoc-type.rs`.\n                                     } else {\n                                         let ty = AstConv::ast_ty_to_ty(self, hir_ty);\n-                                        let ty = self.resolve_vars_if_possible(&ty);\n+                                        let ty = self.resolve_vars_if_possible(ty);\n                                         if ty == predicate.self_ty() {\n                                             error.obligation.cause.make_mut().span = hir_ty.span;\n                                         }"}, {"sha": "f635e0b6f931c96c85250edbf142042700a10d5a", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -262,7 +262,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         let (trait_ref, _) = self.replace_bound_vars_with_fresh_vars(\n             span,\n             infer::LateBoundRegionConversionTime::AssocTypeProjection(item_def_id),\n-            &poly_trait_ref,\n+            poly_trait_ref,\n         );\n \n         let item_substs = <dyn AstConv<'tcx>>::create_substs_for_associated_item("}, {"sha": "17dbf989d668349d7826869c5f7d4adf527ed3c1", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -73,8 +73,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             _ => return false,\n         };\n \n-        let sig = self.replace_bound_vars_with_fresh_vars(expr.span, infer::FnCall, &sig).0;\n-        let sig = self.normalize_associated_types_in(expr.span, &sig);\n+        let sig = self.replace_bound_vars_with_fresh_vars(expr.span, infer::FnCall, sig).0;\n+        let sig = self.normalize_associated_types_in(expr.span, sig);\n         if self.can_coerce(sig.output(), expected) {\n             let (mut sugg_call, applicability) = if sig.inputs().is_empty() {\n                 (String::new(), Applicability::MachineApplicable)"}, {"sha": "825ebc19fa6da93569c252f7696cf4d8dcc57b7a", "filename": "compiler/rustc_typeck/src/check/gather_locals.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgather_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgather_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgather_locals.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -59,16 +59,13 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n                 let o_ty = self.fcx.to_ty(&ty);\n \n                 let revealed_ty = if self.fcx.tcx.features().impl_trait_in_bindings {\n-                    self.fcx.instantiate_opaque_types_from_value(self.parent_id, &o_ty, ty.span)\n+                    self.fcx.instantiate_opaque_types_from_value(self.parent_id, o_ty, ty.span)\n                 } else {\n                     o_ty\n                 };\n \n-                let c_ty = self\n-                    .fcx\n-                    .inh\n-                    .infcx\n-                    .canonicalize_user_type_annotation(&UserType::Ty(revealed_ty));\n+                let c_ty =\n+                    self.fcx.inh.infcx.canonicalize_user_type_annotation(UserType::Ty(revealed_ty));\n                 debug!(\n                     \"visit_local: ty.hir_id={:?} o_ty={:?} revealed_ty={:?} c_ty={:?}\",\n                     ty.hir_id, o_ty, revealed_ty, c_ty"}, {"sha": "602b79802b33d77f3362356a5eb159eb4fae7905", "filename": "compiler/rustc_typeck/src/check/generator_interior.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -80,7 +80,7 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n             });\n \n         if let Some(yield_data) = live_across_yield {\n-            let ty = self.fcx.resolve_vars_if_possible(&ty);\n+            let ty = self.fcx.resolve_vars_if_possible(ty);\n             debug!(\n                 \"type in expr = {:?}, scope = {:?}, type = {:?}, count = {}, yield_span = {:?}\",\n                 expr, scope, ty, self.expr_count, yield_data.span\n@@ -120,7 +120,7 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n                 self.expr_count,\n                 expr.map(|e| e.span)\n             );\n-            let ty = self.fcx.resolve_vars_if_possible(&ty);\n+            let ty = self.fcx.resolve_vars_if_possible(ty);\n             if let Some((unresolved_type, unresolved_type_span)) =\n                 self.fcx.unresolved_type_vars(&ty)\n             {\n@@ -179,13 +179,13 @@ pub fn resolve_interior<'a, 'tcx>(\n         .filter_map(|mut cause| {\n             // Erase regions and canonicalize late-bound regions to deduplicate as many types as we\n             // can.\n-            let erased = fcx.tcx.erase_regions(&cause.ty);\n+            let erased = fcx.tcx.erase_regions(cause.ty);\n             if captured_tys.insert(erased) {\n                 // Replace all regions inside the generator interior with late bound regions.\n                 // Note that each region slot in the types gets a new fresh late bound region,\n                 // which means that none of the regions inside relate to any other, even if\n                 // typeck had previously found constraints that would cause them to be related.\n-                let folded = fcx.tcx.fold_regions(&erased, &mut false, |_, current_depth| {\n+                let folded = fcx.tcx.fold_regions(erased, &mut false, |_, current_depth| {\n                     let r = fcx.tcx.mk_region(ty::ReLateBound(current_depth, ty::BrAnon(counter)));\n                     counter += 1;\n                     r"}, {"sha": "0011a3fc71b59c42cd2f6c0d6105391b62b47f84", "filename": "compiler/rustc_typeck/src/check/inherited.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -156,7 +156,7 @@ impl Inherited<'a, 'tcx> {\n         span: Span,\n         body_id: hir::HirId,\n         param_env: ty::ParamEnv<'tcx>,\n-        value: &T,\n+        value: T,\n     ) -> T\n     where\n         T: TypeFoldable<'tcx>,"}, {"sha": "8ef723d59028511e41a0dca18ed7eb4d356a7aa2", "filename": "compiler/rustc_typeck/src/check/method/confirm.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -90,16 +90,15 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         // traits, no trait system method can be called before this point because they\n         // could alter our Self-type, except for normalizing the receiver from the\n         // signature (which is also done during probing).\n-        let method_sig_rcvr =\n-            self.normalize_associated_types_in(self.span, &method_sig.inputs()[0]);\n+        let method_sig_rcvr = self.normalize_associated_types_in(self.span, method_sig.inputs()[0]);\n         debug!(\n             \"confirm: self_ty={:?} method_sig_rcvr={:?} method_sig={:?} method_predicates={:?}\",\n             self_ty, method_sig_rcvr, method_sig, method_predicates\n         );\n         self.unify_receivers(self_ty, method_sig_rcvr, &pick, all_substs);\n \n         let (method_sig, method_predicates) =\n-            self.normalize_associated_types_in(self.span, &(method_sig, method_predicates));\n+            self.normalize_associated_types_in(self.span, (method_sig, method_predicates));\n \n         // Make sure nobody calls `drop()` explicitly.\n         self.enforce_illegal_method_limitations(&pick);\n@@ -229,7 +228,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n                     let original_poly_trait_ref = principal.with_self_ty(this.tcx, object_ty);\n                     let upcast_poly_trait_ref = this.upcast(original_poly_trait_ref, trait_def_id);\n                     let upcast_trait_ref =\n-                        this.replace_bound_vars_with_fresh_vars(&upcast_poly_trait_ref);\n+                        this.replace_bound_vars_with_fresh_vars(upcast_poly_trait_ref);\n                     debug!(\n                         \"original_poly_trait_ref={:?} upcast_trait_ref={:?} target_trait={:?}\",\n                         original_poly_trait_ref, upcast_trait_ref, trait_def_id\n@@ -249,10 +248,10 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n                 self.fresh_substs_for_item(self.span, trait_def_id)\n             }\n \n-            probe::WhereClausePick(ref poly_trait_ref) => {\n+            probe::WhereClausePick(poly_trait_ref) => {\n                 // Where clauses can have bound regions in them. We need to instantiate\n                 // those to convert from a poly-trait-ref to a trait-ref.\n-                self.replace_bound_vars_with_fresh_vars(&poly_trait_ref).substs\n+                self.replace_bound_vars_with_fresh_vars(poly_trait_ref).substs\n             }\n         }\n     }\n@@ -424,7 +423,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         // N.B., instantiate late-bound regions first so that\n         // `instantiate_type_scheme` can normalize associated types that\n         // may reference those regions.\n-        let method_sig = self.replace_bound_vars_with_fresh_vars(&sig);\n+        let method_sig = self.replace_bound_vars_with_fresh_vars(sig);\n         debug!(\"late-bound lifetimes from method instantiated, method_sig={:?}\", method_sig);\n \n         let method_sig = method_sig.subst(self.tcx, all_substs);\n@@ -530,7 +529,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         upcast_trait_refs.into_iter().next().unwrap()\n     }\n \n-    fn replace_bound_vars_with_fresh_vars<T>(&self, value: &ty::Binder<T>) -> T\n+    fn replace_bound_vars_with_fresh_vars<T>(&self, value: ty::Binder<T>) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {"}, {"sha": "8e13b3746992abfc7509b468ff06196338456174", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -265,7 +265,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         scope: ProbeScope,\n     ) -> probe::PickResult<'tcx> {\n         let mode = probe::Mode::MethodCall;\n-        let self_ty = self.resolve_vars_if_possible(&self_ty);\n+        let self_ty = self.resolve_vars_if_possible(self_ty);\n         self.probe_for_name(\n             span,\n             mode,\n@@ -358,11 +358,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // `instantiate_type_scheme` can normalize associated types that\n         // may reference those regions.\n         let fn_sig = tcx.fn_sig(def_id);\n-        let fn_sig = self.replace_bound_vars_with_fresh_vars(span, infer::FnCall, &fn_sig).0;\n+        let fn_sig = self.replace_bound_vars_with_fresh_vars(span, infer::FnCall, fn_sig).0;\n         let fn_sig = fn_sig.subst(self.tcx, substs);\n \n         let InferOk { value, obligations: o } =\n-            self.normalize_associated_types_in_as_infer_ok(span, &fn_sig);\n+            self.normalize_associated_types_in_as_infer_ok(span, fn_sig);\n         let fn_sig = {\n             obligations.extend(o);\n             value\n@@ -379,7 +379,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let bounds = self.tcx.predicates_of(def_id).instantiate(self.tcx, substs);\n \n         let InferOk { value, obligations: o } =\n-            self.normalize_associated_types_in_as_infer_ok(span, &bounds);\n+            self.normalize_associated_types_in_as_infer_ok(span, bounds);\n         let bounds = {\n             obligations.extend(o);\n             value"}, {"sha": "ed8e4aafb9965afa9218c9a5bf6d113a26d0ab06", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -308,7 +308,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     {\n         let mut orig_values = OriginalQueryValues::default();\n         let param_env_and_self_ty = self.infcx.canonicalize_query(\n-            &ParamEnvAnd { param_env: self.param_env, value: self_ty },\n+            ParamEnvAnd { param_env: self.param_env, value: self_ty },\n             &mut orig_values,\n         );\n \n@@ -730,7 +730,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             let cause = traits::ObligationCause::misc(self.span, self.body_id);\n             let selcx = &mut traits::SelectionContext::new(self.fcx);\n             let traits::Normalized { value: (xform_self_ty, xform_ret_ty), obligations } =\n-                traits::normalize(selcx, self.param_env, cause, &xform_tys);\n+                traits::normalize(selcx, self.param_env, cause, xform_tys);\n             debug!(\n                 \"assemble_inherent_impl_probe: xform_self_ty = {:?}/{:?}\",\n                 xform_self_ty, xform_ret_ty\n@@ -774,7 +774,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         // argument type like `&Trait`.\n         let trait_ref = principal.with_self_ty(self.tcx, self_ty);\n         self.elaborate_bounds(iter::once(trait_ref), |this, new_trait_ref, item| {\n-            let new_trait_ref = this.erase_late_bound_regions(&new_trait_ref);\n+            let new_trait_ref = this.erase_late_bound_regions(new_trait_ref);\n \n             let (xform_self_ty, xform_ret_ty) =\n                 this.xform_self_ty(&item, new_trait_ref.self_ty(), new_trait_ref.substs);\n@@ -820,7 +820,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         });\n \n         self.elaborate_bounds(bounds, |this, poly_trait_ref, item| {\n-            let trait_ref = this.erase_late_bound_regions(&poly_trait_ref);\n+            let trait_ref = this.erase_late_bound_regions(poly_trait_ref);\n \n             let (xform_self_ty, xform_ret_ty) =\n                 this.xform_self_ty(&item, trait_ref.self_ty(), trait_ref.substs);\n@@ -911,7 +911,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     let substs = self.fresh_substs_for_item(self.span, method.def_id);\n                     let fty = fty.subst(self.tcx, substs);\n                     let (fty, _) =\n-                        self.replace_bound_vars_with_fresh_vars(self.span, infer::FnCall, &fty);\n+                        self.replace_bound_vars_with_fresh_vars(self.span, infer::FnCall, fty);\n \n                     if let Some(self_ty) = self_ty {\n                         if self\n@@ -942,7 +942,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             // For trait aliases, assume all super-traits are relevant.\n             let bounds = iter::once(trait_ref.to_poly_trait_ref());\n             self.elaborate_bounds(bounds, |this, new_trait_ref, item| {\n-                let new_trait_ref = this.erase_late_bound_regions(&new_trait_ref);\n+                let new_trait_ref = this.erase_late_bound_regions(new_trait_ref);\n \n                 let (xform_self_ty, xform_ret_ty) =\n                     this.xform_self_ty(&item, new_trait_ref.self_ty(), new_trait_ref.substs);\n@@ -1355,7 +1355,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     let impl_bounds = self.tcx.predicates_of(impl_def_id);\n                     let impl_bounds = impl_bounds.instantiate(self.tcx, substs);\n                     let traits::Normalized { value: impl_bounds, obligations: norm_obligations } =\n-                        traits::normalize(selcx, self.param_env, cause.clone(), &impl_bounds);\n+                        traits::normalize(selcx, self.param_env, cause.clone(), impl_bounds);\n \n                     // Convert the bounds into obligations.\n                     let impl_obligations =\n@@ -1366,7 +1366,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         .chain(ref_obligations.iter().cloned());\n                     // Evaluate those obligations to see if they might possibly hold.\n                     for o in candidate_obligations {\n-                        let o = self.resolve_vars_if_possible(&o);\n+                        let o = self.resolve_vars_if_possible(o);\n                         if !self.predicate_may_hold(&o) {\n                             result = ProbeResult::NoMatch;\n                             possibly_unsatisfied_predicates.push((o.predicate, None));\n@@ -1392,10 +1392,11 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                                     for obligation in impl_source.borrow_nested_obligations() {\n                                         // Determine exactly which obligation wasn't met, so\n                                         // that we can give more context in the error.\n-                                        if !self.predicate_may_hold(&obligation) {\n-                                            let o = self.resolve_vars_if_possible(obligation);\n+                                        if !self.predicate_may_hold(obligation) {\n+                                            let o =\n+                                                self.resolve_vars_if_possible(obligation.clone());\n                                             let predicate =\n-                                                self.resolve_vars_if_possible(&predicate);\n+                                                self.resolve_vars_if_possible(predicate);\n                                             let p = if predicate == o.predicate {\n                                                 // Avoid \"`MyStruct: Foo` which is required by\n                                                 // `MyStruct: Foo`\" in E0599.\n@@ -1410,7 +1411,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                                 _ => {\n                                     // Some nested subobligation of this predicate\n                                     // failed.\n-                                    let predicate = self.resolve_vars_if_possible(&predicate);\n+                                    let predicate = self.resolve_vars_if_possible(predicate);\n                                     possibly_unsatisfied_predicates.push((predicate, None));\n                                 }\n                             }\n@@ -1427,7 +1428,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n             // Evaluate those obligations to see if they might possibly hold.\n             for o in sub_obligations {\n-                let o = self.resolve_vars_if_possible(&o);\n+                let o = self.resolve_vars_if_possible(o);\n                 if !self.predicate_may_hold(&o) {\n                     result = ProbeResult::NoMatch;\n                     possibly_unsatisfied_predicates.push((o.predicate, None));\n@@ -1438,7 +1439,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 if let (Some(return_ty), Some(xform_ret_ty)) =\n                     (self.return_type, probe.xform_ret_ty)\n                 {\n-                    let xform_ret_ty = self.resolve_vars_if_possible(&xform_ret_ty);\n+                    let xform_ret_ty = self.resolve_vars_if_possible(xform_ret_ty);\n                     debug!(\n                         \"comparing return_ty {:?} with xform ret ty {:?}\",\n                         return_ty, probe.xform_ret_ty\n@@ -1604,7 +1605,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n         // Erase any late-bound regions from the method and substitute\n         // in the values from the substitution.\n-        let xform_fn_sig = self.erase_late_bound_regions(&fn_sig);\n+        let xform_fn_sig = self.erase_late_bound_regions(fn_sig);\n \n         if generics.params.is_empty() {\n             xform_fn_sig.subst(self.tcx, substs)\n@@ -1672,7 +1673,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     ///    region got replaced with the same variable, which requires a bit more coordination\n     ///    and/or tracking the substitution and\n     ///    so forth.\n-    fn erase_late_bound_regions<T>(&self, value: &ty::Binder<T>) -> T\n+    fn erase_late_bound_regions<T>(&self, value: ty::Binder<T>) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {"}, {"sha": "3d5ce57a491c5717e1249aea535ead859d6c5827", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -248,7 +248,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }) => {\n                 let tcx = self.tcx;\n \n-                let actual = self.resolve_vars_if_possible(&rcvr_ty);\n+                let actual = self.resolve_vars_if_possible(rcvr_ty);\n                 let ty_str = self.ty_to_string(actual);\n                 let is_method = mode == Mode::MethodCall;\n                 let item_kind = if is_method {\n@@ -870,7 +870,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n     ) {\n         let output_ty = match self.infcx.get_impl_future_output_ty(ty) {\n-            Some(output_ty) => self.resolve_vars_if_possible(&output_ty),\n+            Some(output_ty) => self.resolve_vars_if_possible(output_ty),\n             _ => return,\n         };\n         let method_exists = self.method_exists(item_name, output_ty, call.hir_id, true);"}, {"sha": "b242900a1221f69a43c02d587ab533af1a38b899", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -362,7 +362,7 @@ fn used_trait_imports(tcx: TyCtxt<'_>, def_id: LocalDefId) -> &FxHashSet<LocalDe\n /// conclude that we don't have a defining use of `MyItem`. By mapping inference\n /// variables back to the actual generic parameters, we will correctly see that\n /// we have a defining use of `MyItem`\n-fn fixup_opaque_types<'tcx, T>(tcx: TyCtxt<'tcx>, val: &T) -> T\n+fn fixup_opaque_types<'tcx, T>(tcx: TyCtxt<'tcx>, val: T) -> T\n where\n     T: TypeFoldable<'tcx>,\n {\n@@ -510,15 +510,15 @@ fn typeck_with_fallback<'tcx>(\n             check_abi(tcx, span, fn_sig.abi());\n \n             // Compute the fty from point of view of inside the fn.\n-            let fn_sig = tcx.liberate_late_bound_regions(def_id.to_def_id(), &fn_sig);\n+            let fn_sig = tcx.liberate_late_bound_regions(def_id.to_def_id(), fn_sig);\n             let fn_sig = inh.normalize_associated_types_in(\n                 body.value.span,\n                 body_id.hir_id,\n                 param_env,\n-                &fn_sig,\n+                fn_sig,\n             );\n \n-            let fn_sig = fixup_opaque_types(tcx, &fn_sig);\n+            let fn_sig = fixup_opaque_types(tcx, fn_sig);\n \n             let fcx = check_fn(&inh, param_env, fn_sig, decl, id, body, None).0;\n             fcx\n@@ -543,11 +543,11 @@ fn typeck_with_fallback<'tcx>(\n                     _ => fallback(),\n                 });\n \n-            let expected_type = fcx.normalize_associated_types_in(body.value.span, &expected_type);\n+            let expected_type = fcx.normalize_associated_types_in(body.value.span, expected_type);\n             fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n \n             let revealed_ty = if tcx.features().impl_trait_in_bindings {\n-                fcx.instantiate_opaque_types_from_value(id, &expected_type, body.value.span)\n+                fcx.instantiate_opaque_types_from_value(id, expected_type, body.value.span)\n             } else {\n                 expected_type\n             };"}, {"sha": "1ce2b2cff0631002257325ff7aed0e9bc21499e1", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -660,7 +660,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 method.sig.output()\n             }\n             Err(()) => {\n-                let actual = self.resolve_vars_if_possible(&operand_ty);\n+                let actual = self.resolve_vars_if_possible(operand_ty);\n                 if !actual.references_error() {\n                     let mut err = struct_span_err!(\n                         self.tcx.sess,"}, {"sha": "dd8f4152c7c9e7ad345b65c9806d2514d5f6a933", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -459,7 +459,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Now that we know the types can be unified we find the unified type\n         // and use it to type the entire expression.\n-        let common_type = self.resolve_vars_if_possible(&lhs_ty.or(rhs_ty).unwrap_or(expected));\n+        let common_type = self.resolve_vars_if_possible(lhs_ty.or(rhs_ty).unwrap_or(expected));\n \n         // Subtyping doesn't matter here, as the value is some kind of scalar.\n         let demand_eqtype = |x, y| {"}, {"sha": "b8b98cef7637a849c2f00e79c04f9cda0cd9b376", "filename": "compiler/rustc_typeck/src/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -229,7 +229,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     /// of b will be `&<R0>.i32` and then `*b` will require that `<R0>` be bigger than the let and\n     /// the `*b` expression, so we will effectively resolve `<R0>` to be the block B.\n     pub fn resolve_type(&self, unresolved_ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.resolve_vars_if_possible(&unresolved_ty)\n+        self.resolve_vars_if_possible(unresolved_ty)\n     }\n \n     /// Try to resolve the type for the given node."}, {"sha": "21b9b96213c0d8cf1ea5dab6f3fd1f6a9a0d5805", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -403,12 +403,12 @@ fn check_associated_item(\n         match item.kind {\n             ty::AssocKind::Const => {\n                 let ty = fcx.tcx.type_of(item.def_id);\n-                let ty = fcx.normalize_associated_types_in(span, &ty);\n+                let ty = fcx.normalize_associated_types_in(span, ty);\n                 fcx.register_wf_obligation(ty.into(), span, code.clone());\n             }\n             ty::AssocKind::Fn => {\n                 let sig = fcx.tcx.fn_sig(item.def_id);\n-                let sig = fcx.normalize_associated_types_in(span, &sig);\n+                let sig = fcx.normalize_associated_types_in(span, sig);\n                 let hir_sig = sig_if_method.expect(\"bad signature for method\");\n                 check_fn_or_method(\n                     tcx,\n@@ -427,7 +427,7 @@ fn check_associated_item(\n                 }\n                 if item.defaultness.has_value() {\n                     let ty = fcx.tcx.type_of(item.def_id);\n-                    let ty = fcx.normalize_associated_types_in(span, &ty);\n+                    let ty = fcx.normalize_associated_types_in(span, ty);\n                     fcx.register_wf_obligation(ty.into(), span, code.clone());\n                 }\n             }\n@@ -480,7 +480,7 @@ fn check_type_defn<'tcx, F>(\n             let needs_drop_copy = || {\n                 packed && {\n                     let ty = variant.fields.last().unwrap().ty;\n-                    let ty = fcx.tcx.erase_regions(&ty);\n+                    let ty = fcx.tcx.erase_regions(ty);\n                     if ty.needs_infer() {\n                         fcx_tcx\n                             .sess\n@@ -592,7 +592,7 @@ fn check_associated_type_bounds(fcx: &FnCtxt<'_, '_>, item: &ty::AssocItem, span\n \n     debug!(\"check_associated_type_bounds: bounds={:?}\", bounds);\n     let wf_obligations = bounds.iter().flat_map(|&(bound, bound_span)| {\n-        let normalized_bound = fcx.normalize_associated_types_in(span, &bound);\n+        let normalized_bound = fcx.normalize_associated_types_in(span, bound);\n         traits::wf::predicate_obligations(\n             fcx,\n             fcx.param_env,\n@@ -618,7 +618,7 @@ fn check_item_fn(\n     for_id(tcx, item_id, span).with_fcx(|fcx, tcx| {\n         let def_id = fcx.tcx.hir().local_def_id(item_id);\n         let sig = fcx.tcx.fn_sig(def_id);\n-        let sig = fcx.normalize_associated_types_in(span, &sig);\n+        let sig = fcx.normalize_associated_types_in(span, sig);\n         let mut implied_bounds = vec![];\n         check_fn_or_method(\n             tcx,\n@@ -638,7 +638,7 @@ fn check_item_type(tcx: TyCtxt<'_>, item_id: hir::HirId, ty_span: Span, allow_fo\n \n     for_id(tcx, item_id, ty_span).with_fcx(|fcx, tcx| {\n         let ty = tcx.type_of(tcx.hir().local_def_id(item_id));\n-        let item_ty = fcx.normalize_associated_types_in(ty_span, &ty);\n+        let item_ty = fcx.normalize_associated_types_in(ty_span, ty);\n \n         let mut forbid_unsized = true;\n         if allow_foreign_ty {\n@@ -680,7 +680,7 @@ fn check_impl<'tcx>(\n                 // won't hold).\n                 let trait_ref = fcx.tcx.impl_trait_ref(item_def_id).unwrap();\n                 let trait_ref =\n-                    fcx.normalize_associated_types_in(ast_trait_ref.path.span, &trait_ref);\n+                    fcx.normalize_associated_types_in(ast_trait_ref.path.span, trait_ref);\n                 let obligations = traits::wf::trait_obligations(\n                     fcx,\n                     fcx.param_env,\n@@ -695,7 +695,7 @@ fn check_impl<'tcx>(\n             }\n             None => {\n                 let self_ty = fcx.tcx.type_of(item_def_id);\n-                let self_ty = fcx.normalize_associated_types_in(item.span, &self_ty);\n+                let self_ty = fcx.normalize_associated_types_in(item.span, self_ty);\n                 fcx.register_wf_obligation(\n                     self_ty.into(),\n                     ast_self_ty.span,\n@@ -845,7 +845,7 @@ fn check_where_clauses<'tcx, 'fcx>(\n             // Note the subtle difference from how we handle `predicates`\n             // below: there, we are not trying to prove those predicates\n             // to be *true* but merely *well-formed*.\n-            let pred = fcx.normalize_associated_types_in(sp, &pred);\n+            let pred = fcx.normalize_associated_types_in(sp, pred);\n             let cause =\n                 traits::ObligationCause::new(sp, fcx.body_id, traits::ItemObligation(def_id));\n             traits::Obligation::new(cause, fcx.param_env, pred)\n@@ -856,12 +856,12 @@ fn check_where_clauses<'tcx, 'fcx>(\n     if let Some((mut return_ty, span)) = return_ty {\n         if return_ty.has_infer_types_or_consts() {\n             fcx.select_obligations_where_possible(false, |_| {});\n-            return_ty = fcx.resolve_vars_if_possible(&return_ty);\n+            return_ty = fcx.resolve_vars_if_possible(return_ty);\n         }\n         check_opaque_types(tcx, fcx, def_id.expect_local(), span, return_ty);\n     }\n \n-    let predicates = fcx.normalize_associated_types_in(span, &predicates);\n+    let predicates = fcx.normalize_associated_types_in(span, predicates);\n \n     debug!(\"check_where_clauses: predicates={:?}\", predicates.predicates);\n     assert_eq!(predicates.predicates.len(), predicates.spans.len());\n@@ -885,8 +885,8 @@ fn check_fn_or_method<'fcx, 'tcx>(\n     def_id: DefId,\n     implied_bounds: &mut Vec<Ty<'tcx>>,\n ) {\n-    let sig = fcx.normalize_associated_types_in(span, &sig);\n-    let sig = fcx.tcx.liberate_late_bound_regions(def_id, &sig);\n+    let sig = fcx.normalize_associated_types_in(span, sig);\n+    let sig = fcx.tcx.liberate_late_bound_regions(def_id, sig);\n \n     for (&input_ty, span) in sig.inputs().iter().zip(hir_decl.inputs.iter().map(|t| t.span)) {\n         fcx.register_wf_obligation(input_ty.into(), span, ObligationCauseCode::MiscObligation);\n@@ -1063,19 +1063,19 @@ fn check_method_receiver<'fcx, 'tcx>(\n     let span = fn_sig.decl.inputs[0].span;\n \n     let sig = fcx.tcx.fn_sig(method.def_id);\n-    let sig = fcx.normalize_associated_types_in(span, &sig);\n-    let sig = fcx.tcx.liberate_late_bound_regions(method.def_id, &sig);\n+    let sig = fcx.normalize_associated_types_in(span, sig);\n+    let sig = fcx.tcx.liberate_late_bound_regions(method.def_id, sig);\n \n     debug!(\"check_method_receiver: sig={:?}\", sig);\n \n-    let self_ty = fcx.normalize_associated_types_in(span, &self_ty);\n-    let self_ty = fcx.tcx.liberate_late_bound_regions(method.def_id, &ty::Binder::bind(self_ty));\n+    let self_ty = fcx.normalize_associated_types_in(span, self_ty);\n+    let self_ty = fcx.tcx.liberate_late_bound_regions(method.def_id, ty::Binder::bind(self_ty));\n \n     let receiver_ty = sig.inputs()[0];\n \n-    let receiver_ty = fcx.normalize_associated_types_in(span, &receiver_ty);\n+    let receiver_ty = fcx.normalize_associated_types_in(span, receiver_ty);\n     let receiver_ty =\n-        fcx.tcx.liberate_late_bound_regions(method.def_id, &ty::Binder::bind(receiver_ty));\n+        fcx.tcx.liberate_late_bound_regions(method.def_id, ty::Binder::bind(receiver_ty));\n \n     if fcx.tcx.features().arbitrary_self_types {\n         if !receiver_is_valid(fcx, span, receiver_ty, self_ty, true) {\n@@ -1307,7 +1307,7 @@ fn check_false_global_bounds(fcx: &FnCtxt<'_, '_>, span: Span, id: hir::HirId) {\n         let pred = obligation.predicate;\n         // Match the existing behavior.\n         if pred.is_global() && !pred.has_late_bound_regions() {\n-            let pred = fcx.normalize_associated_types_in(span, &pred);\n+            let pred = fcx.normalize_associated_types_in(span, pred);\n             let obligation = traits::Obligation::new(\n                 traits::ObligationCause::new(span, id, traits::TrivialBound),\n                 empty_env,\n@@ -1405,8 +1405,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .iter()\n             .map(|field| {\n                 let field_ty = self.tcx.type_of(self.tcx.hir().local_def_id(field.hir_id));\n-                let field_ty = self.normalize_associated_types_in(field.ty.span, &field_ty);\n-                let field_ty = self.resolve_vars_if_possible(&field_ty);\n+                let field_ty = self.normalize_associated_types_in(field.ty.span, field_ty);\n+                let field_ty = self.resolve_vars_if_possible(field_ty);\n                 debug!(\"non_enum_variant: type of field {:?} is {:?}\", field, field_ty);\n                 AdtField { ty: field_ty, span: field.ty.span }\n             })\n@@ -1429,7 +1429,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub(super) fn impl_implied_bounds(&self, impl_def_id: DefId, span: Span) -> Vec<Ty<'tcx>> {\n         match self.tcx.impl_trait_ref(impl_def_id) {\n-            Some(ref trait_ref) => {\n+            Some(trait_ref) => {\n                 // Trait impl: take implied bounds from all types that\n                 // appear in the trait reference.\n                 let trait_ref = self.normalize_associated_types_in(span, trait_ref);\n@@ -1439,7 +1439,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             None => {\n                 // Inherent impl: take implied bounds from the `self` type.\n                 let self_ty = self.tcx.type_of(impl_def_id);\n-                let self_ty = self.normalize_associated_types_in(span, &self_ty);\n+                let self_ty = self.normalize_associated_types_in(span, self_ty);\n                 vec![self_ty]\n             }\n         }"}, {"sha": "e54e00864831cd12d5fcb1b8ee7c7059d4ae821d", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -136,7 +136,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         match e.kind {\n             hir::ExprKind::Unary(hir::UnOp::UnNeg | hir::UnOp::UnNot, ref inner) => {\n                 let inner_ty = self.fcx.node_ty(inner.hir_id);\n-                let inner_ty = self.fcx.resolve_vars_if_possible(&inner_ty);\n+                let inner_ty = self.fcx.resolve_vars_if_possible(inner_ty);\n \n                 if inner_ty.is_scalar() {\n                     let mut typeck_results = self.fcx.typeck_results.borrow_mut();\n@@ -147,10 +147,10 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             hir::ExprKind::Binary(ref op, ref lhs, ref rhs)\n             | hir::ExprKind::AssignOp(ref op, ref lhs, ref rhs) => {\n                 let lhs_ty = self.fcx.node_ty(lhs.hir_id);\n-                let lhs_ty = self.fcx.resolve_vars_if_possible(&lhs_ty);\n+                let lhs_ty = self.fcx.resolve_vars_if_possible(lhs_ty);\n \n                 let rhs_ty = self.fcx.node_ty(rhs.hir_id);\n-                let rhs_ty = self.fcx.resolve_vars_if_possible(&rhs_ty);\n+                let rhs_ty = self.fcx.resolve_vars_if_possible(rhs_ty);\n \n                 if lhs_ty.is_scalar() && rhs_ty.is_scalar() {\n                     let mut typeck_results = self.fcx.typeck_results.borrow_mut();\n@@ -209,7 +209,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                         &format!(\"bad index {:?} for base: `{:?}`\", index, base),\n                     )\n                 });\n-                let index_ty = self.fcx.resolve_vars_if_possible(&index_ty);\n+                let index_ty = self.fcx.resolve_vars_if_possible(index_ty);\n \n                 if base_ty.builtin_index().is_some() && index_ty == self.fcx.tcx.types.usize {\n                     // Remove the method call record\n@@ -313,14 +313,14 @@ impl<'cx, 'tcx> Visitor<'tcx> for WritebackCx<'cx, 'tcx> {\n     fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n         intravisit::walk_local(self, l);\n         let var_ty = self.fcx.local_ty(l.span, l.hir_id).decl_ty;\n-        let var_ty = self.resolve(&var_ty, &l.span);\n+        let var_ty = self.resolve(var_ty, &l.span);\n         self.write_ty_to_typeck_results(l.hir_id, var_ty);\n     }\n \n     fn visit_ty(&mut self, hir_ty: &'tcx hir::Ty<'tcx>) {\n         intravisit::walk_ty(self, hir_ty);\n         let ty = self.fcx.node_ty(hir_ty.hir_id);\n-        let ty = self.resolve(&ty, &hir_ty.span);\n+        let ty = self.resolve(ty, &hir_ty.span);\n         self.write_ty_to_typeck_results(hir_ty.hir_id, ty);\n     }\n }\n@@ -432,7 +432,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     fn visit_opaque_types(&mut self, span: Span) {\n         for (&def_id, opaque_defn) in self.fcx.opaque_types.borrow().iter() {\n             let hir_id = self.tcx().hir().local_def_id_to_hir_id(def_id.expect_local());\n-            let instantiated_ty = self.resolve(&opaque_defn.concrete_ty, &hir_id);\n+            let instantiated_ty = self.resolve(opaque_defn.concrete_ty, &hir_id);\n \n             debug_assert!(!instantiated_ty.has_escaping_bound_vars());\n \n@@ -522,13 +522,13 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n         // Resolve the type of the node with id `node_id`\n         let n_ty = self.fcx.node_ty(hir_id);\n-        let n_ty = self.resolve(&n_ty, &span);\n+        let n_ty = self.resolve(n_ty, &span);\n         self.write_ty_to_typeck_results(hir_id, n_ty);\n         debug!(\"node {:?} has type {:?}\", hir_id, n_ty);\n \n         // Resolve any substitutions\n         if let Some(substs) = self.fcx.typeck_results.borrow().node_substs_opt(hir_id) {\n-            let substs = self.resolve(&substs, &span);\n+            let substs = self.resolve(substs, &span);\n             debug!(\"write_substs_to_tcx({:?}, {:?})\", hir_id, substs);\n             assert!(!substs.needs_infer() && !substs.has_placeholders());\n             self.typeck_results.node_substs_mut().insert(hir_id, substs);\n@@ -543,7 +543,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             }\n \n             Some(adjustment) => {\n-                let resolved_adjustment = self.resolve(&adjustment, &span);\n+                let resolved_adjustment = self.resolve(adjustment, &span);\n                 debug!(\"adjustments for node {:?}: {:?}\", hir_id, resolved_adjustment);\n                 self.typeck_results.adjustments_mut().insert(hir_id, resolved_adjustment);\n             }\n@@ -558,7 +558,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             }\n \n             Some(adjustment) => {\n-                let resolved_adjustment = self.resolve(&adjustment, &span);\n+                let resolved_adjustment = self.resolve(adjustment, &span);\n                 debug!(\"pat_adjustments for node {:?}: {:?}\", hir_id, resolved_adjustment);\n                 self.typeck_results.pat_adjustments_mut().insert(hir_id, resolved_adjustment);\n             }\n@@ -570,7 +570,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         assert_eq!(fcx_typeck_results.hir_owner, self.typeck_results.hir_owner);\n         let common_hir_owner = fcx_typeck_results.hir_owner;\n \n-        for (&local_id, fn_sig) in fcx_typeck_results.liberated_fn_sigs().iter() {\n+        for (&local_id, &fn_sig) in fcx_typeck_results.liberated_fn_sigs().iter() {\n             let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n             let fn_sig = self.resolve(fn_sig, &hir_id);\n             self.typeck_results.liberated_fn_sigs_mut().insert(hir_id, fn_sig);\n@@ -584,12 +584,12 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n         for (&local_id, ftys) in fcx_typeck_results.fru_field_types().iter() {\n             let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n-            let ftys = self.resolve(ftys, &hir_id);\n+            let ftys = self.resolve(ftys.clone(), &hir_id);\n             self.typeck_results.fru_field_types_mut().insert(hir_id, ftys);\n         }\n     }\n \n-    fn resolve<T>(&mut self, x: &T, span: &dyn Locatable) -> T\n+    fn resolve<T>(&mut self, x: T, span: &dyn Locatable) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -681,8 +681,8 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        match self.infcx.fully_resolve(&t) {\n-            Ok(t) => self.infcx.tcx.erase_regions(&t),\n+        match self.infcx.fully_resolve(t) {\n+            Ok(t) => self.infcx.tcx.erase_regions(t),\n             Err(_) => {\n                 debug!(\"Resolver::fold_ty: input type `{:?}` not fully resolvable\", t);\n                 self.report_type_error(t);\n@@ -698,8 +698,8 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n     }\n \n     fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        match self.infcx.fully_resolve(&ct) {\n-            Ok(ct) => self.infcx.tcx.erase_regions(&ct),\n+        match self.infcx.fully_resolve(ct) {\n+            Ok(ct) => self.infcx.tcx.erase_regions(ct),\n             Err(_) => {\n                 debug!(\"Resolver::fold_const: input const `{:?}` not fully resolvable\", ct);\n                 self.report_const_error(ct);"}, {"sha": "566aa94a392e9d8aa10a3030a6200c7b8a7900ae", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -386,7 +386,7 @@ impl AstConv<'tcx> for ItemCtxt<'tcx> {\n                                         \"{}::{}\",\n                                         // Replace the existing lifetimes with a new named lifetime.\n                                         self.tcx\n-                                            .replace_late_bound_regions(&poly_trait_ref, |_| {\n+                                            .replace_late_bound_regions(poly_trait_ref, |_| {\n                                                 self.tcx.mk_region(ty::ReEarlyBound(\n                                                     ty::EarlyBoundRegion {\n                                                         def_id: item_def_id,\n@@ -424,7 +424,7 @@ impl AstConv<'tcx> for ItemCtxt<'tcx> {\n                         format!(\n                             \"{}::{}\",\n                             // Erase named lt, we want `<A as B<'_>::C`, not `<A as B<'a>::C`.\n-                            self.tcx.anonymize_late_bound_regions(&poly_trait_ref).skip_binder(),\n+                            self.tcx.anonymize_late_bound_regions(poly_trait_ref).skip_binder(),\n                             item_segment.ident\n                         ),\n                         Applicability::MaybeIncorrect,"}, {"sha": "c4f4c8bc76b46a432917404aec7023ffa9cced05", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -637,7 +637,7 @@ fn infer_placeholder_type(\n     }\n \n     // Typeck doesn't expect erased regions to be returned from `type_of`.\n-    tcx.fold_regions(&ty, &mut false, |r, _| match r {\n+    tcx.fold_regions(ty, &mut false, |r, _| match r {\n         ty::ReErased => tcx.lifetimes.re_static,\n         _ => r,\n     })"}, {"sha": "5db9ff9524de05d1f6a445879869c3248f589f40", "filename": "compiler/rustc_typeck/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -165,7 +165,7 @@ fn get_impl_substs<'tcx>(\n     // Conservatively use an empty `ParamEnv`.\n     let outlives_env = OutlivesEnvironment::new(ty::ParamEnv::empty());\n     infcx.resolve_regions_and_report_errors(impl1_def_id, &outlives_env, RegionckMode::default());\n-    let impl2_substs = match infcx.fully_resolve(&impl2_substs) {\n+    let impl2_substs = match infcx.fully_resolve(impl2_substs) {\n         Ok(s) => s,\n         Err(_) => {\n             tcx.sess.struct_span_err(span, \"could not resolve substs on overridden impl\").emit();"}, {"sha": "9992094117dfc847c9f32e5540bcf5866c6fa776", "filename": "compiler/rustc_typeck/src/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bf93bd852f0636eb4d052ee155bdb6cec592c53/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs?ref=2bf93bd852f0636eb4d052ee155bdb6cec592c53", "patch": "@@ -124,7 +124,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         self.infcx.type_is_copy_modulo_regions(self.param_env, ty, span)\n     }\n \n-    fn resolve_vars_if_possible<T>(&self, value: &T) -> T\n+    fn resolve_vars_if_possible<T>(&self, value: T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -142,7 +142,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     ) -> McResult<Ty<'tcx>> {\n         match ty {\n             Some(ty) => {\n-                let ty = self.resolve_vars_if_possible(&ty);\n+                let ty = self.resolve_vars_if_possible(ty);\n                 if ty.references_error() || ty.is_ty_var() {\n                     debug!(\"resolve_type_vars_or_error: error from {:?}\", ty);\n                     Err(())\n@@ -274,7 +274,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         F: FnOnce() -> McResult<PlaceWithHirId<'tcx>>,\n     {\n         debug!(\"cat_expr_adjusted_with({:?}): {:?}\", adjustment, expr);\n-        let target = self.resolve_vars_if_possible(&adjustment.target);\n+        let target = self.resolve_vars_if_possible(adjustment.target);\n         match adjustment.kind {\n             adjustment::Adjust::Deref(overloaded) => {\n                 // Equivalent to *expr or something similar."}]}