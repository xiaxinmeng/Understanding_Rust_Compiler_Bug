{"sha": "8ef0caa23ca31ccc8ef3769a0aeb35bea15532a6", "node_id": "C_kwDOAAsO6NoAKDhlZjBjYWEyM2NhMzFjY2M4ZWYzNzY5YTBhZWIzNWJlYTE1NTMyYTY", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-02T20:24:42Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-06T18:03:20Z"}, "message": "interpret: remove LocalValue::Unallocated, add Operand::Uninit\n\nOperand::Uninit is an *allocated* operand that is fully uninitialized.\nThis lets us lazily allocate the actual backing store of *all* locals (no matter their ABI).\n\nI also reordered things in pop_stack_frame at the same time.\nI should probably have made that a separate commit...", "tree": {"sha": "c862d0cfbbc015b1fb7740d6fbf205c3aa929374", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c862d0cfbbc015b1fb7740d6fbf205c3aa929374"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ef0caa23ca31ccc8ef3769a0aeb35bea15532a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ef0caa23ca31ccc8ef3769a0aeb35bea15532a6", "html_url": "https://github.com/rust-lang/rust/commit/8ef0caa23ca31ccc8ef3769a0aeb35bea15532a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ef0caa23ca31ccc8ef3769a0aeb35bea15532a6/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "049308cf8b48e9d67e54d6d0b01c10c79d1efc3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/049308cf8b48e9d67e54d6d0b01c10c79d1efc3a", "html_url": "https://github.com/rust-lang/rust/commit/049308cf8b48e9d67e54d6d0b01c10c79d1efc3a"}], "stats": {"total": 356, "additions": 180, "deletions": 176}, "files": [{"sha": "f84dd9521ee57204e379854fb0512981eacbb641", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8ef0caa23ca31ccc8ef3769a0aeb35bea15532a6/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ef0caa23ca31ccc8ef3769a0aeb35bea15532a6/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=8ef0caa23ca31ccc8ef3769a0aeb35bea15532a6", "patch": "@@ -189,6 +189,7 @@ pub(super) fn op_to_const<'tcx>(\n                 let len: usize = len.try_into().unwrap();\n                 ConstValue::Slice { data, start, end: start + len }\n             }\n+            Immediate::Uninit => to_const_value(&op.assert_mem_place()),\n         },\n     }\n }"}, {"sha": "ea65595f05095bc6570ca6062e36b04838518f5d", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8ef0caa23ca31ccc8ef3769a0aeb35bea15532a6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ef0caa23ca31ccc8ef3769a0aeb35bea15532a6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=8ef0caa23ca31ccc8ef3769a0aeb35bea15532a6", "patch": "@@ -153,14 +153,15 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 assert_eq!(dest_layout.size, self.pointer_size());\n                 assert!(src.layout.ty.is_unsafe_ptr());\n                 return match **src {\n-                    Immediate::ScalarPair(data, _) => Ok(data.into()),\n+                    Immediate::ScalarPair(data, _) => Ok(data.check_init()?.into()),\n                     Immediate::Scalar(..) => span_bug!(\n                         self.cur_span(),\n                         \"{:?} input to a fat-to-thin cast ({:?} -> {:?})\",\n                         *src,\n                         src.layout.ty,\n                         cast_ty\n                     ),\n+                    Immediate::Uninit => throw_ub!(InvalidUninitBytes(None)),\n                 };\n             }\n         }"}, {"sha": "767032845ace378f7f348828713b0d63e4216fe2", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 56, "deletions": 53, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/8ef0caa23ca31ccc8ef3769a0aeb35bea15532a6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ef0caa23ca31ccc8ef3769a0aeb35bea15532a6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=8ef0caa23ca31ccc8ef3769a0aeb35bea15532a6", "patch": "@@ -112,6 +112,8 @@ pub struct Frame<'mir, 'tcx, Tag: Provenance = AllocId, Extra = ()> {\n     /// The locals are stored as `Option<Value>`s.\n     /// `None` represents a local that is currently dead, while a live local\n     /// can either directly contain `Scalar` or refer to some part of an `Allocation`.\n+    ///\n+    /// Do *not* access this directly; always go through the machine hook!\n     pub locals: IndexVec<mir::Local, LocalState<'tcx, Tag>>,\n \n     /// The span of the `tracing` crate is stored here.\n@@ -179,10 +181,6 @@ pub struct LocalState<'tcx, Tag: Provenance = AllocId> {\n pub enum LocalValue<Tag: Provenance = AllocId> {\n     /// This local is not currently alive, and cannot be used at all.\n     Dead,\n-    /// This local is alive but not yet allocated. It cannot be read from or have its address taken,\n-    /// and will be allocated on the first write. This is to support unsized locals, where we cannot\n-    /// know their size in advance.\n-    Unallocated,\n     /// A normal, live local.\n     /// Mostly for convenience, we re-use the `Operand` type here.\n     /// This is an optimization over just always having a pointer here;\n@@ -196,12 +194,10 @@ impl<'tcx, Tag: Provenance + 'static> LocalState<'tcx, Tag> {\n     ///\n     /// Note: This may only be invoked from the `Machine::access_local` hook and not from\n     /// anywhere else. You may be invalidating machine invariants if you do!\n-    pub fn access(&self) -> InterpResult<'tcx, Operand<Tag>> {\n-        match self.value {\n-            LocalValue::Dead => throw_ub!(DeadLocal),\n-            LocalValue::Unallocated => {\n-                bug!(\"The type checker should prevent reading from a never-written local\")\n-            }\n+    #[inline]\n+    pub fn access(&self) -> InterpResult<'tcx, &Operand<Tag>> {\n+        match &self.value {\n+            LocalValue::Dead => throw_ub!(DeadLocal), // could even be \"invalid program\"?\n             LocalValue::Live(val) => Ok(val),\n         }\n     }\n@@ -211,15 +207,11 @@ impl<'tcx, Tag: Provenance + 'static> LocalState<'tcx, Tag> {\n     ///\n     /// Note: This may only be invoked from the `Machine::access_local_mut` hook and not from\n     /// anywhere else. You may be invalidating machine invariants if you do!\n-    pub fn access_mut(\n-        &mut self,\n-    ) -> InterpResult<'tcx, Result<&mut LocalValue<Tag>, MemPlace<Tag>>> {\n-        match self.value {\n-            LocalValue::Dead => throw_ub!(DeadLocal),\n-            LocalValue::Live(Operand::Indirect(mplace)) => Ok(Err(mplace)),\n-            ref mut local @ (LocalValue::Live(Operand::Immediate(_)) | LocalValue::Unallocated) => {\n-                Ok(Ok(local))\n-            }\n+    #[inline]\n+    pub fn access_mut(&mut self) -> InterpResult<'tcx, &mut Operand<Tag>> {\n+        match &mut self.value {\n+            LocalValue::Dead => throw_ub!(DeadLocal), // could even be \"invalid program\"?\n+            LocalValue::Live(val) => Ok(val),\n         }\n     }\n }\n@@ -710,16 +702,15 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             })?;\n         }\n \n-        // Locals are initially unallocated.\n-        let dummy = LocalState { value: LocalValue::Unallocated, layout: Cell::new(None) };\n+        // Most locals are initially dead.\n+        let dummy = LocalState { value: LocalValue::Dead, layout: Cell::new(None) };\n         let mut locals = IndexVec::from_elem(dummy, &body.local_decls);\n \n-        // Now mark those locals as dead that we do not want to initialize\n-        // Mark locals that use `Storage*` annotations as dead on function entry.\n+        // Now mark those locals as live that have no `Storage*` annotations.\n         let always_live = always_live_locals(self.body());\n         for local in locals.indices() {\n-            if !always_live.contains(local) {\n-                locals[local].value = LocalValue::Dead;\n+            if always_live.contains(local) {\n+                locals[local].value = LocalValue::Live(Operand::Immediate(Immediate::Uninit));\n             }\n         }\n         // done\n@@ -791,59 +782,69 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             if unwinding { \"during unwinding\" } else { \"returning from function\" }\n         );\n \n-        // Sanity check `unwinding`.\n+        // Check `unwinding`.\n         assert_eq!(\n             unwinding,\n             match self.frame().loc {\n                 Ok(loc) => self.body().basic_blocks()[loc.block].is_cleanup,\n                 Err(_) => true,\n             }\n         );\n-\n         if unwinding && self.frame_idx() == 0 {\n             throw_ub_format!(\"unwinding past the topmost frame of the stack\");\n         }\n \n-        let frame =\n-            self.stack_mut().pop().expect(\"tried to pop a stack frame, but there were none\");\n-\n-        if !unwinding {\n-            let op = self.local_to_op(&frame, mir::RETURN_PLACE, None)?;\n-            self.copy_op_transmute(&op, &frame.return_place)?;\n-            trace!(\"{:?}\", self.dump_place(*frame.return_place));\n-        }\n-\n-        let return_to_block = frame.return_to_block;\n-\n-        // Now where do we jump next?\n+        // Copy return value. Must of course happen *before* we deallocate the locals.\n+        let copy_ret_result = if !unwinding {\n+            let op = self\n+                .local_to_op(self.frame(), mir::RETURN_PLACE, None)\n+                .expect(\"return place should always be live\");\n+            let dest = self.frame().return_place;\n+            let err = self.copy_op_transmute(&op, &dest);\n+            trace!(\"return value: {:?}\", self.dump_place(*dest));\n+            // We delay actually short-circuiting on this error until *after* the stack frame is\n+            // popped, since we want this error to be attributed to the caller, whose type defines\n+            // this transmute.\n+            err\n+        } else {\n+            Ok(())\n+        };\n \n+        // Cleanup: deallocate locals.\n         // Usually we want to clean up (deallocate locals), but in a few rare cases we don't.\n-        // In that case, we return early. We also avoid validation in that case,\n-        // because this is CTFE and the final value will be thoroughly validated anyway.\n+        // We do this while the frame is still on the stack, so errors point to the callee.\n+        let return_to_block = self.frame().return_to_block;\n         let cleanup = match return_to_block {\n             StackPopCleanup::Goto { .. } => true,\n             StackPopCleanup::Root { cleanup, .. } => cleanup,\n         };\n+        if cleanup {\n+            // We need to take the locals out, since we need to mutate while iterating.\n+            let locals = mem::take(&mut self.frame_mut().locals);\n+            for local in &locals {\n+                self.deallocate_local(local.value)?;\n+            }\n+        }\n+\n+        // All right, now it is time to actually pop the frame.\n+        // Note that its locals are gone already, but that's fine.\n+        let frame =\n+            self.stack_mut().pop().expect(\"tried to pop a stack frame, but there were none\");\n+        // Report error from return value copy, if any.\n+        copy_ret_result?;\n \n+        // If we are not doing cleanup, also skip everything else.\n         if !cleanup {\n             assert!(self.stack().is_empty(), \"only the topmost frame should ever be leaked\");\n             assert!(!unwinding, \"tried to skip cleanup during unwinding\");\n-            // Leak the locals, skip validation, skip machine hook.\n+            // Skip machine hook.\n             return Ok(());\n         }\n-\n-        trace!(\"locals: {:#?}\", frame.locals);\n-\n-        // Cleanup: deallocate all locals that are backed by an allocation.\n-        for local in &frame.locals {\n-            self.deallocate_local(local.value)?;\n-        }\n-\n         if M::after_stack_pop(self, frame, unwinding)? == StackPopJump::NoJump {\n             // The hook already did everything.\n-            // We want to skip the `info!` below, hence early return.\n             return Ok(());\n         }\n+\n         // Normal return, figure out where to jump.\n         if unwinding {\n             // Follow the unwind edge.\n@@ -874,7 +875,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         assert!(local != mir::RETURN_PLACE, \"Cannot make return place live\");\n         trace!(\"{:?} is now live\", local);\n \n-        let local_val = LocalValue::Unallocated;\n+        let local_val = LocalValue::Live(Operand::Immediate(Immediate::Uninit));\n         // StorageLive expects the local to be dead, and marks it live.\n         let old = mem::replace(&mut self.frame_mut().locals[local].value, local_val);\n         if !matches!(old, LocalValue::Dead) {\n@@ -977,7 +978,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> std::fmt::Debug\n \n                 match self.ecx.stack()[frame].locals[local].value {\n                     LocalValue::Dead => write!(fmt, \" is dead\")?,\n-                    LocalValue::Unallocated => write!(fmt, \" is unallocated\")?,\n+                    LocalValue::Live(Operand::Immediate(Immediate::Uninit)) => {\n+                        write!(fmt, \" is uninitialized\")?\n+                    }\n                     LocalValue::Live(Operand::Indirect(mplace)) => {\n                         write!(\n                             fmt,"}, {"sha": "b3461b414b67c09a8ad7b964b6367087dfb7e33a", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8ef0caa23ca31ccc8ef3769a0aeb35bea15532a6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ef0caa23ca31ccc8ef3769a0aeb35bea15532a6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=8ef0caa23ca31ccc8ef3769a0aeb35bea15532a6", "patch": "@@ -14,8 +14,7 @@ use rustc_target::spec::abi::Abi;\n \n use super::{\n     AllocId, AllocRange, Allocation, ConstAllocation, Frame, ImmTy, InterpCx, InterpResult,\n-    LocalValue, MemPlace, MemoryKind, OpTy, Operand, PlaceTy, Pointer, Provenance, Scalar,\n-    StackPopUnwind,\n+    MemoryKind, OpTy, Operand, PlaceTy, Pointer, Provenance, Scalar, StackPopUnwind,\n };\n \n /// Data returned by Machine::stack_pop,\n@@ -226,11 +225,13 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Since reading a ZST is not actually accessing memory or locals, this is never invoked\n     /// for ZST reads.\n     #[inline]\n-    fn access_local(\n-        _ecx: &InterpCx<'mir, 'tcx, Self>,\n-        frame: &Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>,\n+    fn access_local<'a>(\n+        frame: &'a Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>,\n         local: mir::Local,\n-    ) -> InterpResult<'tcx, Operand<Self::PointerTag>> {\n+    ) -> InterpResult<'tcx, &'a Operand<Self::PointerTag>>\n+    where\n+        'tcx: 'mir,\n+    {\n         frame.locals[local].access()\n     }\n \n@@ -242,7 +243,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n         frame: usize,\n         local: mir::Local,\n-    ) -> InterpResult<'tcx, Result<&'a mut LocalValue<Self::PointerTag>, MemPlace<Self::PointerTag>>>\n+    ) -> InterpResult<'tcx, &'a mut Operand<Self::PointerTag>>\n     where\n         'tcx: 'mir,\n     {\n@@ -418,12 +419,14 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     }\n \n     /// Called immediately after a stack frame got popped, but before jumping back to the caller.\n+    /// The `locals` have already been destroyed!\n     fn after_stack_pop(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _frame: Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>,\n-        _unwinding: bool,\n+        unwinding: bool,\n     ) -> InterpResult<'tcx, StackPopJump> {\n         // By default, we do not support unwinding from panics\n+        assert!(!unwinding);\n         Ok(StackPopJump::Normal)\n     }\n }"}, {"sha": "805dcb388953920460af1a8d6ef5e6ad7a499c33", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8ef0caa23ca31ccc8ef3769a0aeb35bea15532a6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ef0caa23ca31ccc8ef3769a0aeb35bea15532a6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=8ef0caa23ca31ccc8ef3769a0aeb35bea15532a6", "patch": "@@ -14,7 +14,7 @@ use rustc_target::abi::{self, Abi, Align, HasDataLayout, Size, TagEncoding};\n use rustc_target::abi::{VariantIdx, Variants};\n \n use super::{\n-    alloc_range, from_known_layout, mir_assign_valid_types, AllocId, ConstValue, GlobalId,\n+    alloc_range, from_known_layout, mir_assign_valid_types, AllocId, ConstValue, Frame, GlobalId,\n     InterpCx, InterpResult, MPlaceTy, Machine, MemPlace, Place, PlaceTy, Pointer,\n     PointerArithmetic, Provenance, Scalar, ScalarMaybeUninit,\n };\n@@ -28,8 +28,15 @@ use super::{\n /// defined on `Immediate`, and do not have to work with a `Place`.\n #[derive(Copy, Clone, PartialEq, Eq, HashStable, Hash, Debug)]\n pub enum Immediate<Tag: Provenance = AllocId> {\n+    /// A single scalar value (must have *initialized* `Scalar` ABI).\n+    /// FIXME: we also currently often use this for ZST.\n+    /// `ScalarMaybeUninit` should reject ZST, and we should use `Uninit` for them instead.\n     Scalar(ScalarMaybeUninit<Tag>),\n+    /// A pair of two scalar value (must have `ScalarPair` ABI where both fields are\n+    /// `Scalar::Initialized`).\n     ScalarPair(ScalarMaybeUninit<Tag>, ScalarMaybeUninit<Tag>),\n+    /// A value of fully uninitialized memory. Can have and size and layout.\n+    Uninit,\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n@@ -75,6 +82,7 @@ impl<'tcx, Tag: Provenance> Immediate<Tag> {\n         match self {\n             Immediate::Scalar(val) => val,\n             Immediate::ScalarPair(..) => bug!(\"Got a scalar pair where a scalar was expected\"),\n+            Immediate::Uninit => ScalarMaybeUninit::Uninit,\n         }\n     }\n \n@@ -88,6 +96,7 @@ impl<'tcx, Tag: Provenance> Immediate<Tag> {\n         match self {\n             Immediate::ScalarPair(val1, val2) => (val1, val2),\n             Immediate::Scalar(..) => bug!(\"Got a scalar where a scalar pair was expected\"),\n+            Immediate::Uninit => (ScalarMaybeUninit::Uninit, ScalarMaybeUninit::Uninit),\n         }\n     }\n \n@@ -149,7 +158,10 @@ impl<Tag: Provenance> std::fmt::Display for ImmTy<'_, Tag> {\n                 }\n                 Immediate::ScalarPair(a, b) => {\n                     // FIXME(oli-obk): at least print tuples and slices nicely\n-                    write!(f, \"({:x}, {:x}): {}\", a, b, self.layout.ty,)\n+                    write!(f, \"({:x}, {:x}): {}\", a, b, self.layout.ty)\n+                }\n+                Immediate::Uninit => {\n+                    write!(f, \"uninit: {}\", self.layout.ty)\n                 }\n             }\n         })\n@@ -397,7 +409,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         self.scalar_to_ptr(self.read_scalar(op)?.check_init()?)\n     }\n \n-    // Turn the wide MPlace into a string (must already be dereferenced!)\n+    /// Turn the wide MPlace into a string (must already be dereferenced!)\n     pub fn read_str(&self, mplace: &MPlaceTy<'tcx, M::PointerTag>) -> InterpResult<'tcx, &str> {\n         let len = mplace.len(self)?;\n         let bytes = self.read_bytes_ptr(mplace.ptr, Size::from_bytes(len))?;\n@@ -528,10 +540,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Will not access memory, instead an indirect `Operand` is returned.\n     ///\n     /// This is public because it is used by [priroda](https://github.com/oli-obk/priroda) to get an\n-    /// OpTy from a local\n+    /// OpTy from a local.\n     pub fn local_to_op(\n         &self,\n-        frame: &super::Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>,\n+        frame: &Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>,\n         local: mir::Local,\n         layout: Option<TyAndLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n@@ -540,7 +552,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // Do not read from ZST, they might not be initialized\n             Operand::Immediate(Scalar::ZST.into())\n         } else {\n-            M::access_local(&self, frame, local)?\n+            *M::access_local(frame, local)?\n         };\n         Ok(OpTy { op, layout, align: Some(layout.align.abi) })\n     }"}, {"sha": "5ec6c79a86f97e5c1f22e2cc285e77f23359828d", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 52, "deletions": 81, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/8ef0caa23ca31ccc8ef3769a0aeb35bea15532a6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ef0caa23ca31ccc8ef3769a0aeb35bea15532a6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=8ef0caa23ca31ccc8ef3769a0aeb35bea15532a6", "patch": "@@ -15,8 +15,8 @@ use rustc_target::abi::{HasDataLayout, Size, VariantIdx, Variants};\n \n use super::{\n     alloc_range, mir_assign_valid_types, AllocId, AllocRef, AllocRefMut, CheckInAllocMsg,\n-    ConstAlloc, ImmTy, Immediate, InterpCx, InterpResult, LocalValue, Machine, MemoryKind, OpTy,\n-    Operand, Pointer, Provenance, Scalar, ScalarMaybeUninit,\n+    ConstAlloc, ImmTy, Immediate, InterpCx, InterpResult, Machine, MemoryKind, OpTy, Operand,\n+    Pointer, Provenance, Scalar, ScalarMaybeUninit,\n };\n \n #[derive(Copy, Clone, Hash, PartialEq, Eq, HashStable, Debug)]\n@@ -314,6 +314,7 @@ where\n         let (ptr, meta) = match **val {\n             Immediate::Scalar(ptr) => (ptr, MemPlaceMeta::None),\n             Immediate::ScalarPair(ptr, meta) => (ptr, MemPlaceMeta::Meta(meta.check_init()?)),\n+            Immediate::Uninit => throw_ub!(InvalidUninitBytes(None)),\n         };\n \n         let mplace = MemPlace { ptr: self.scalar_to_ptr(ptr.check_init()?)?, meta };\n@@ -746,14 +747,14 @@ where\n         let mplace = match dest.place {\n             Place::Local { frame, local } => {\n                 match M::access_local_mut(self, frame, local)? {\n-                    Ok(local) => {\n+                    Operand::Immediate(local) => {\n                         // Local can be updated in-place.\n-                        *local = LocalValue::Live(Operand::Immediate(src));\n+                        *local = src;\n                         return Ok(());\n                     }\n-                    Err(mplace) => {\n+                    Operand::Indirect(mplace) => {\n                         // The local is in memory, go on below.\n-                        mplace\n+                        *mplace\n                     }\n                 }\n             }\n@@ -817,6 +818,7 @@ where\n                 alloc.write_scalar(alloc_range(Size::ZERO, a_size), a_val)?;\n                 alloc.write_scalar(alloc_range(b_offset, b_size), b_val)\n             }\n+            Immediate::Uninit => alloc.write_uninit(),\n         }\n     }\n \n@@ -825,25 +827,13 @@ where\n             Ok(mplace) => mplace,\n             Err((frame, local)) => {\n                 match M::access_local_mut(self, frame, local)? {\n-                    Ok(local) => match dest.layout.abi {\n-                        Abi::Scalar(_) => {\n-                            *local = LocalValue::Live(Operand::Immediate(Immediate::Scalar(\n-                                ScalarMaybeUninit::Uninit,\n-                            )));\n-                            return Ok(());\n-                        }\n-                        Abi::ScalarPair(..) => {\n-                            *local = LocalValue::Live(Operand::Immediate(Immediate::ScalarPair(\n-                                ScalarMaybeUninit::Uninit,\n-                                ScalarMaybeUninit::Uninit,\n-                            )));\n-                            return Ok(());\n-                        }\n-                        _ => self.force_allocation(dest)?,\n-                    },\n-                    Err(mplace) => {\n+                    Operand::Immediate(local) => {\n+                        *local = Immediate::Uninit;\n+                        return Ok(());\n+                    }\n+                    Operand::Indirect(mplace) => {\n                         // The local is in memory, go on below.\n-                        MPlaceTy { mplace, layout: dest.layout, align: dest.align }\n+                        MPlaceTy { mplace: *mplace, layout: dest.layout, align: dest.align }\n                     }\n                 }\n             }\n@@ -908,19 +898,18 @@ where\n         // Slow path, this does not fit into an immediate. Just memcpy.\n         trace!(\"copy_op: {:?} <- {:?}: {}\", *dest, src, dest.layout.ty);\n \n-        // This interprets `src.meta` with the `dest` local's layout, if an unsized local\n-        // is being initialized!\n-        let (dest, size) = self.force_allocation_maybe_sized(dest, src.meta)?;\n-        let size = size.unwrap_or_else(|| {\n-            assert!(\n-                !dest.layout.is_unsized(),\n-                \"Cannot copy into already initialized unsized place\"\n-            );\n-            dest.layout.size\n-        });\n-        assert_eq!(src.meta, dest.meta, \"Can only copy between equally-sized instances\");\n-\n-        self.mem_copy(src.ptr, src.align, dest.ptr, dest.align, size, /*nonoverlapping*/ false)\n+        let dest = self.force_allocation(dest)?;\n+        assert!(!(src.layout.is_unsized() || dest.layout.is_unsized()), \"cannot copy unsized data\");\n+        assert_eq!(src.layout.size, dest.layout.size, \"Cannot copy differently-sized data\");\n+\n+        self.mem_copy(\n+            src.ptr,\n+            src.align,\n+            dest.ptr,\n+            dest.align,\n+            dest.layout.size,\n+            /*nonoverlapping*/ false,\n+        )\n     }\n \n     /// Copies the data from an operand to a place. The layouts may disagree, but they must\n@@ -931,9 +920,16 @@ where\n         dest: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         if mir_assign_valid_types(*self.tcx, self.param_env, src.layout, dest.layout) {\n-            // Fast path: Just use normal `copy_op`\n+            // Fast path: Just use normal `copy_op`. This is faster because it tries\n+            // `read_immediate_raw` first before doing `force_allocation`.\n             return self.copy_op(src, dest);\n         }\n+        // Unsized copies rely on interpreting `src.meta` with `dest.layout`, we want\n+        // to avoid that here.\n+        assert!(\n+            !src.layout.is_unsized() && !dest.layout.is_unsized(),\n+            \"Cannot transmute unsized data\"\n+        );\n         // We still require the sizes to match.\n         if src.layout.size != dest.layout.size {\n             span_bug!(\n@@ -943,12 +939,6 @@ where\n                 dest\n             );\n         }\n-        // Unsized copies rely on interpreting `src.meta` with `dest.layout`, we want\n-        // to avoid that here.\n-        assert!(\n-            !src.layout.is_unsized() && !dest.layout.is_unsized(),\n-            \"Cannot transmute unsized data\"\n-        );\n \n         // The hard case is `ScalarPair`.  `src` is already read from memory in this case,\n         // using `src.layout` to figure out which bytes to use for the 1st and 2nd field.\n@@ -976,72 +966,53 @@ where\n     /// If the place currently refers to a local that doesn't yet have a matching allocation,\n     /// create such an allocation.\n     /// This is essentially `force_to_memplace`.\n-    ///\n-    /// This supports unsized types and returns the computed size to avoid some\n-    /// redundant computation when copying; use `force_allocation` for a simpler, sized-only\n-    /// version.\n     #[instrument(skip(self), level = \"debug\")]\n-    pub fn force_allocation_maybe_sized(\n+    pub fn force_allocation(\n         &mut self,\n         place: &PlaceTy<'tcx, M::PointerTag>,\n-        meta: MemPlaceMeta<M::PointerTag>,\n-    ) -> InterpResult<'tcx, (MPlaceTy<'tcx, M::PointerTag>, Option<Size>)> {\n-        let (mplace, size) = match place.place {\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+        let mplace = match place.place {\n             Place::Local { frame, local } => {\n                 match M::access_local_mut(self, frame, local)? {\n-                    Ok(&mut local_val) => {\n+                    &mut Operand::Immediate(local_val) => {\n                         // We need to make an allocation.\n \n                         // We need the layout of the local.  We can NOT use the layout we got,\n                         // that might e.g., be an inner field of a struct with `Scalar` layout,\n                         // that has different alignment than the outer field.\n                         let local_layout =\n                             self.layout_of_local(&self.stack()[frame], local, None)?;\n-                        // We also need to support unsized types, and hence cannot use `allocate`.\n-                        let (size, align) = self\n-                            .size_and_align_of(&meta, &local_layout)?\n-                            .expect(\"Cannot allocate for non-dyn-sized type\");\n-                        let ptr = self.allocate_ptr(size, align, MemoryKind::Stack)?;\n-                        let mplace = MemPlace { ptr: ptr.into(), meta };\n-                        if let LocalValue::Live(Operand::Immediate(value)) = local_val {\n-                            // Preserve old value.\n+                        if local_layout.is_unsized() {\n+                            throw_unsup_format!(\"unsized locals are not supported\");\n+                        }\n+                        let mplace = self.allocate(local_layout, MemoryKind::Stack)?;\n+                        if !matches!(local_val, Immediate::Uninit) {\n+                            // Preserve old value. (As an optimization, we can skip this if it was uninit.)\n                             // We don't have to validate as we can assume the local\n                             // was already valid for its type.\n-                            let mplace = MPlaceTy {\n-                                mplace,\n-                                layout: local_layout,\n-                                align: local_layout.align.abi,\n-                            };\n-                            self.write_immediate_to_mplace_no_validate(value, &mplace)?;\n+                            self.write_immediate_to_mplace_no_validate(local_val, &mplace)?;\n                         }\n                         // Now we can call `access_mut` again, asserting it goes well,\n                         // and actually overwrite things.\n-                        *M::access_local_mut(self, frame, local).unwrap().unwrap() =\n-                            LocalValue::Live(Operand::Indirect(mplace));\n-                        (mplace, Some(size))\n+                        *M::access_local_mut(self, frame, local).unwrap() =\n+                            Operand::Indirect(*mplace);\n+                        *mplace\n                     }\n-                    Err(mplace) => (mplace, None), // this already was an indirect local\n+                    &mut Operand::Indirect(mplace) => mplace, // this already was an indirect local\n                 }\n             }\n-            Place::Ptr(mplace) => (mplace, None),\n+            Place::Ptr(mplace) => mplace,\n         };\n         // Return with the original layout, so that the caller can go on\n-        Ok((MPlaceTy { mplace, layout: place.layout, align: place.align }, size))\n-    }\n-\n-    #[inline(always)]\n-    pub fn force_allocation(\n-        &mut self,\n-        place: &PlaceTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n-        Ok(self.force_allocation_maybe_sized(place, MemPlaceMeta::None)?.0)\n+        Ok(MPlaceTy { mplace, layout: place.layout, align: place.align })\n     }\n \n     pub fn allocate(\n         &mut self,\n         layout: TyAndLayout<'tcx>,\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+        assert!(!layout.is_unsized());\n         let ptr = self.allocate_ptr(layout.size, layout.align.abi, kind)?;\n         Ok(MPlaceTy::from_aligned_ptr(ptr.into(), layout))\n     }"}, {"sha": "71e45a1383b3da9ce4401331d875f52ba533322a", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8ef0caa23ca31ccc8ef3769a0aeb35bea15532a6/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ef0caa23ca31ccc8ef3769a0aeb35bea15532a6/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=8ef0caa23ca31ccc8ef3769a0aeb35bea15532a6", "patch": "@@ -29,9 +29,8 @@ use rustc_trait_selection::traits;\n use crate::MirPass;\n use rustc_const_eval::interpret::{\n     self, compile_time_machine, AllocId, ConstAllocation, ConstValue, CtfeValidationMode, Frame,\n-    ImmTy, Immediate, InterpCx, InterpResult, LocalState, LocalValue, MemPlace, MemoryKind, OpTy,\n-    Operand as InterpOperand, PlaceTy, Pointer, Scalar, ScalarMaybeUninit, StackPopCleanup,\n-    StackPopUnwind,\n+    ImmTy, Immediate, InterpCx, InterpResult, LocalState, LocalValue, MemoryKind, OpTy, PlaceTy,\n+    Pointer, Scalar, ScalarMaybeUninit, StackPopCleanup, StackPopUnwind,\n };\n \n /// The maximum number of bytes that we'll allocate space for a local or the return value.\n@@ -237,15 +236,19 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         throw_machine_stop_str!(\"pointer arithmetic or comparisons aren't supported in ConstProp\")\n     }\n \n-    fn access_local(\n-        _ecx: &InterpCx<'mir, 'tcx, Self>,\n-        frame: &Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>,\n+    fn access_local<'a>(\n+        frame: &'a Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>,\n         local: Local,\n-    ) -> InterpResult<'tcx, InterpOperand<Self::PointerTag>> {\n+    ) -> InterpResult<'tcx, &'a interpret::Operand<Self::PointerTag>> {\n         let l = &frame.locals[local];\n \n-        if l.value == LocalValue::Unallocated {\n-            throw_machine_stop_str!(\"tried to access an unallocated local\")\n+        if matches!(\n+            l.value,\n+            LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit))\n+        ) {\n+            // For us \"uninit\" means \"we don't know its value, might be initiailized or not\".\n+            // So stop here.\n+            throw_machine_stop_str!(\"tried to access alocal with unknown value \")\n         }\n \n         l.access()\n@@ -255,8 +258,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n         frame: usize,\n         local: Local,\n-    ) -> InterpResult<'tcx, Result<&'a mut LocalValue<Self::PointerTag>, MemPlace<Self::PointerTag>>>\n-    {\n+    ) -> InterpResult<'tcx, &'a mut interpret::Operand<Self::PointerTag>> {\n         if ecx.machine.can_const_prop[local] == ConstPropMode::NoPropagation {\n             throw_machine_stop_str!(\"tried to write to a local that is marked as not propagatable\")\n         }\n@@ -436,8 +438,10 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     /// Remove `local` from the pool of `Locals`. Allows writing to them,\n     /// but not reading from them anymore.\n     fn remove_const(ecx: &mut InterpCx<'mir, 'tcx, ConstPropMachine<'mir, 'tcx>>, local: Local) {\n-        ecx.frame_mut().locals[local] =\n-            LocalState { value: LocalValue::Unallocated, layout: Cell::new(None) };\n+        ecx.frame_mut().locals[local] = LocalState {\n+            value: LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit)),\n+            layout: Cell::new(None),\n+        };\n     }\n \n     fn use_ecx<F, T>(&mut self, f: F) -> Option<T>\n@@ -1042,7 +1046,9 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                     let frame = self.ecx.frame_mut();\n                     frame.locals[local].value =\n                         if let StatementKind::StorageLive(_) = statement.kind {\n-                            LocalValue::Unallocated\n+                            LocalValue::Live(interpret::Operand::Immediate(\n+                                interpret::Immediate::Uninit,\n+                            ))\n                         } else {\n                             LocalValue::Dead\n                         };"}, {"sha": "54c55c8f8d50a4601424af48483752ae2761841a", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8ef0caa23ca31ccc8ef3769a0aeb35bea15532a6/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ef0caa23ca31ccc8ef3769a0aeb35bea15532a6/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=8ef0caa23ca31ccc8ef3769a0aeb35bea15532a6", "patch": "@@ -31,8 +31,8 @@ use crate::MirLint;\n use rustc_const_eval::const_eval::ConstEvalErr;\n use rustc_const_eval::interpret::{\n     self, compile_time_machine, AllocId, ConstAllocation, Frame, ImmTy, InterpCx, InterpResult,\n-    LocalState, LocalValue, MemPlace, MemoryKind, OpTy, Operand as InterpOperand, PlaceTy, Pointer,\n-    Scalar, ScalarMaybeUninit, StackPopCleanup, StackPopUnwind,\n+    LocalState, LocalValue, MemoryKind, OpTy, PlaceTy, Pointer, Scalar, ScalarMaybeUninit,\n+    StackPopCleanup, StackPopUnwind,\n };\n \n /// The maximum number of bytes that we'll allocate space for a local or the return value.\n@@ -229,15 +229,19 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         throw_machine_stop_str!(\"pointer arithmetic or comparisons aren't supported in ConstProp\")\n     }\n \n-    fn access_local(\n-        _ecx: &InterpCx<'mir, 'tcx, Self>,\n-        frame: &Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>,\n+    fn access_local<'a>(\n+        frame: &'a Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>,\n         local: Local,\n-    ) -> InterpResult<'tcx, InterpOperand<Self::PointerTag>> {\n+    ) -> InterpResult<'tcx, &'a interpret::Operand<Self::PointerTag>> {\n         let l = &frame.locals[local];\n \n-        if l.value == LocalValue::Unallocated {\n-            throw_machine_stop_str!(\"tried to access an uninitialized local\")\n+        if matches!(\n+            l.value,\n+            LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit))\n+        ) {\n+            // For us \"uninit\" means \"we don't know its value, might be initiailized or not\".\n+            // So stop here.\n+            throw_machine_stop_str!(\"tried to access a local with unknown value\")\n         }\n \n         l.access()\n@@ -247,8 +251,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n         frame: usize,\n         local: Local,\n-    ) -> InterpResult<'tcx, Result<&'a mut LocalValue<Self::PointerTag>, MemPlace<Self::PointerTag>>>\n-    {\n+    ) -> InterpResult<'tcx, &'a mut interpret::Operand<Self::PointerTag>> {\n         if ecx.machine.can_const_prop[local] == ConstPropMode::NoPropagation {\n             throw_machine_stop_str!(\"tried to write to a local that is marked as not propagatable\")\n         }\n@@ -430,8 +433,10 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     /// Remove `local` from the pool of `Locals`. Allows writing to them,\n     /// but not reading from them anymore.\n     fn remove_const(ecx: &mut InterpCx<'mir, 'tcx, ConstPropMachine<'mir, 'tcx>>, local: Local) {\n-        ecx.frame_mut().locals[local] =\n-            LocalState { value: LocalValue::Unallocated, layout: Cell::new(None) };\n+        ecx.frame_mut().locals[local] = LocalState {\n+            value: LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit)),\n+            layout: Cell::new(None),\n+        };\n     }\n \n     fn lint_root(&self, source_info: SourceInfo) -> Option<HirId> {\n@@ -915,7 +920,9 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                     let frame = self.ecx.frame_mut();\n                     frame.locals[local].value =\n                         if let StatementKind::StorageLive(_) = statement.kind {\n-                            LocalValue::Unallocated\n+                            LocalValue::Live(interpret::Operand::Immediate(\n+                                interpret::Immediate::Uninit,\n+                            ))\n                         } else {\n                             LocalValue::Dead\n                         };"}]}