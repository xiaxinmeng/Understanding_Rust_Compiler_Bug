{"sha": "3d7a330f320ac2ebf73df012556d64be9b120445", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkN2EzMzBmMzIwYWMyZWJmNzNkZjAxMjU1NmQ2NGJlOWIxMjA0NDU=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-23T08:07:30Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-23T08:07:30Z"}, "message": "Merge #990\n\n990: Forbid TODO markers on master branch r=matklad a=matklad\n\nthis makes TODO markers useful for things which you want to fix before sending a PR\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "b96c4a3c4f1165fd394ce3a854dbe9e02d370a92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b96c4a3c4f1165fd394ce3a854dbe9e02d370a92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d7a330f320ac2ebf73df012556d64be9b120445", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d7a330f320ac2ebf73df012556d64be9b120445", "html_url": "https://github.com/rust-lang/rust/commit/3d7a330f320ac2ebf73df012556d64be9b120445", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d7a330f320ac2ebf73df012556d64be9b120445/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "15189bc7249fc68a1df0234721514b677a90a305", "url": "https://api.github.com/repos/rust-lang/rust/commits/15189bc7249fc68a1df0234721514b677a90a305", "html_url": "https://github.com/rust-lang/rust/commit/15189bc7249fc68a1df0234721514b677a90a305"}, {"sha": "4fd8cfd6adc554752a63aed9ed71d44b372ec4dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fd8cfd6adc554752a63aed9ed71d44b372ec4dc", "html_url": "https://github.com/rust-lang/rust/commit/4fd8cfd6adc554752a63aed9ed71d44b372ec4dc"}], "stats": {"total": 168, "additions": 96, "deletions": 72}, "files": [{"sha": "a5f4e489f7be7fae3b5da1a86bdfc15b8cb2a939", "filename": "crates/ra_db/src/input.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Finput.rs?ref=3d7a330f320ac2ebf73df012556d64be9b120445", "patch": "@@ -136,7 +136,7 @@ impl CrateGraph {\n         self.arena[&crate_id].edition\n     }\n \n-    // TODO: this only finds one crate with the given root; we could have multiple\n+    // FIXME: this only finds one crate with the given root; we could have multiple\n     pub fn crate_id_for_crate_root(&self, file_id: FileId) -> Option<CrateId> {\n         let (&crate_id, _) = self.arena.iter().find(|(_crate_id, data)| data.file_id == file_id)?;\n         Some(crate_id)"}, {"sha": "62301e4ab6efa0b547a167d62daeb539d580d6b6", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=3d7a330f320ac2ebf73df012556d64be9b120445", "patch": "@@ -51,7 +51,7 @@ impl Crate {\n         crate_graph.edition(self.crate_id)\n     }\n \n-    // TODO: should this be in source_binder?\n+    // FIXME: should this be in source_binder?\n     pub fn source_root_crates(\n         db: &impl PersistentHirDatabase,\n         source_root: SourceRootId,\n@@ -301,7 +301,7 @@ impl Struct {\n         db.type_for_def((*self).into(), Namespace::Values)\n     }\n \n-    // TODO move to a more general type\n+    // FIXME move to a more general type\n     /// Builds a resolver for type references inside this struct.\n     pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n         // take the outer scope...\n@@ -361,7 +361,7 @@ impl Enum {\n         db.type_for_def((*self).into(), Namespace::Types)\n     }\n \n-    // TODO: move to a more general type\n+    // FIXME: move to a more general type\n     /// Builds a resolver for type references inside this struct.\n     pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n         // take the outer scope...\n@@ -513,7 +513,7 @@ impl Function {\n         ImplBlock::containing(module_impls, (*self).into())\n     }\n \n-    // TODO: move to a more general type for 'body-having' items\n+    // FIXME: move to a more general type for 'body-having' items\n     /// Builds a resolver for code inside this item.\n     pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n         // take the outer scope...\n@@ -558,7 +558,7 @@ impl Const {\n         ImplBlock::containing(module_impls, (*self).into())\n     }\n \n-    // TODO: move to a more general type for 'body-having' items\n+    // FIXME: move to a more general type for 'body-having' items\n     /// Builds a resolver for code inside this item.\n     pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n         // take the outer scope..."}, {"sha": "703d99d9bb07c5c1abf434f82c71b612cf5740d8", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=3d7a330f320ac2ebf73df012556d64be9b120445", "patch": "@@ -27,7 +27,7 @@ impl_arena_id!(ExprId);\n /// The body of an item (function, const etc.).\n #[derive(Debug, Eq, PartialEq)]\n pub struct Body {\n-    // TODO: this should be more general, consts & statics also have bodies\n+    // FIXME: this should be more general, consts & statics also have bodies\n     /// The Function of the item this body belongs to\n     owner: Function,\n     exprs: Arena<ExprId, Expr>,\n@@ -406,7 +406,7 @@ pub enum Pat {\n     Struct {\n         path: Option<Path>,\n         args: Vec<FieldPat>,\n-        // TODO: 'ellipsis' option\n+        // FIXME: 'ellipsis' option\n     },\n     Range {\n         start: ExprId,\n@@ -547,7 +547,7 @@ impl ExprCollector {\n                     if condition.pat().is_none() {\n                         self.collect_expr_opt(condition.expr())\n                     } else {\n-                        // TODO handle while let\n+                        // FIXME handle while let\n                         return self.alloc_expr(Expr::Missing, syntax_ptr);\n                     }\n                 } else {\n@@ -610,7 +610,7 @@ impl ExprCollector {\n                 self.alloc_expr(path, syntax_ptr)\n             }\n             ast::ExprKind::ContinueExpr(_e) => {\n-                // TODO: labels\n+                // FIXME: labels\n                 self.alloc_expr(Expr::Continue, syntax_ptr)\n             }\n             ast::ExprKind::BreakExpr(e) => {\n@@ -751,7 +751,7 @@ impl ExprCollector {\n                 self.alloc_expr(Expr::Literal(lit), syntax_ptr)\n             }\n \n-            // TODO implement HIR for these:\n+            // FIXME implement HIR for these:\n             ast::ExprKind::Label(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::ExprKind::IndexExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::ExprKind::RangeExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n@@ -844,7 +844,7 @@ impl ExprCollector {\n                 Pat::Struct { path, args: fields }\n             }\n \n-            // TODO: implement\n+            // FIXME: implement\n             ast::PatKind::LiteralPat(_) => Pat::Missing,\n             ast::PatKind::SlicePat(_) | ast::PatKind::RangePat(_) => Pat::Missing,\n         };\n@@ -910,7 +910,7 @@ pub(crate) fn body_with_source_map_query(\n ) -> (Arc<Body>, Arc<BodySourceMap>) {\n     let mut collector = ExprCollector::new(func);\n \n-    // TODO: consts, etc.\n+    // FIXME: consts, etc.\n     collector.collect_fn_body(&func.source(db).1);\n \n     let (body, source_map) = collector.finish();"}, {"sha": "ed005c9f7006e48eb0ac9e64c17c8654f1c49d34", "filename": "crates/ra_hir/src/expr/scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs?ref=3d7a330f320ac2ebf73df012556d64be9b120445", "patch": "@@ -39,7 +39,7 @@ pub struct ScopeData {\n }\n \n impl ExprScopes {\n-    // TODO: This should take something more general than Function\n+    // FIXME: This should take something more general than Function\n     pub(crate) fn expr_scopes_query(db: &impl HirDatabase, function: Function) -> Arc<ExprScopes> {\n         let body = db.body_hir(function);\n         let res = ExprScopes::new(body);\n@@ -148,7 +148,7 @@ impl ScopesWithSourceMap {\n \n     // XXX: during completion, cursor might be outside of any particular\n     // expression. Try to figure out the correct scope...\n-    // TODO: move this to source binder?\n+    // FIXME: move this to source binder?\n     fn adjust(&self, ptr: SyntaxNodePtr, original_scope: ScopeId, offset: TextUnit) -> ScopeId {\n         let r = ptr.range();\n         let child_scopes = self"}, {"sha": "498ed04f23fd954300a01fc9175112c03c13bf3c", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=3d7a330f320ac2ebf73df012556d64be9b120445", "patch": "@@ -15,7 +15,7 @@ use crate::{\n /// Data about a generic parameter (to a function, struct, impl, ...).\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct GenericParam {\n-    // TODO: give generic params proper IDs\n+    // FIXME: give generic params proper IDs\n     pub(crate) idx: u32,\n     pub(crate) name: Name,\n }"}, {"sha": "0d3861a286e41d8f64929829b4c3ad16d37de417", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=3d7a330f320ac2ebf73df012556d64be9b120445", "patch": "@@ -161,7 +161,7 @@ impl ImplData {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-//TODO: rename to ImplDef?\n+//FIXME: rename to ImplDef?\n pub enum ImplItem {\n     Method(Function),\n     Const(Const),"}, {"sha": "e9235bc599605e6213235610e64d613484cc1ba2", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=3d7a330f320ac2ebf73df012556d64be9b120445", "patch": "@@ -296,7 +296,7 @@ impl CrateDefMap {\n             // plain import or absolute path in 2015: crate-relative with\n             // fallback to extern prelude (with the simplification in\n             // rust-lang/rust#57745)\n-            // TODO there must be a nicer way to write this condition\n+            // FIXME there must be a nicer way to write this condition\n             PathKind::Plain | PathKind::Abs\n                 if self.edition == Edition::Edition2015\n                     && (path.kind == PathKind::Abs || mode == ResolveMode::Import) =>"}, {"sha": "6cc8104f413c8064d60266016435e7a12e138a04", "filename": "crates/ra_hir/src/path.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=3d7a330f320ac2ebf73df012556d64be9b120445", "patch": "@@ -96,7 +96,7 @@ impl Path {\n             if let Some(q) = path.qualifier() {\n                 return Some(q);\n             }\n-            // TODO: this bottom up traversal is not too precise.\n+            // FIXME: this bottom up traversal is not too precise.\n             // Should we handle do a top-down analysis, recording results?\n             let use_tree_list = path.syntax().ancestors().find_map(ast::UseTreeList::cast)?;\n             let use_tree = use_tree_list.parent_use_tree();\n@@ -166,7 +166,7 @@ fn expand_use_tree<'a>(\n             // or `use something::{path::{inner::{innerer}}}` (prefix is `something::path`, path is `inner`)\n             Some(path) => match convert_path(prefix, path) {\n                 Some(it) => Some(it),\n-                None => return, // TODO: report errors somewhere\n+                None => return, // FIXME: report errors somewhere\n             },\n         };\n         for child_tree in use_tree_list.use_trees() {\n@@ -194,7 +194,7 @@ fn expand_use_tree<'a>(\n                     cb(path, Some(segment), alias)\n                 };\n             }\n-            // TODO: report errors somewhere\n+            // FIXME: report errors somewhere\n             // We get here if we do\n         }\n     }"}, {"sha": "f28154517e17927a00db245986969bc4fdb73acc", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=3d7a330f320ac2ebf73df012556d64be9b120445", "patch": "@@ -19,7 +19,7 @@ pub struct Resolver {\n     scopes: Vec<Scope>,\n }\n \n-// TODO how to store these best\n+// FIXME how to store these best\n #[derive(Debug, Clone)]\n pub(crate) struct ModuleItemMap {\n     crate_def_map: Arc<CrateDefMap>,\n@@ -260,7 +260,7 @@ impl Scope {\n     fn collect_names(&self, db: &impl HirDatabase, f: &mut dyn FnMut(Name, PerNs<Resolution>)) {\n         match self {\n             Scope::ModuleScope(m) => {\n-                // TODO: should we provide `self` here?\n+                // FIXME: should we provide `self` here?\n                 // f(\n                 //     Name::self_param(),\n                 //     PerNs::types(Resolution::Def {"}, {"sha": "3645b73b44da358a63f4028e21bafcd492cea329", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=3d7a330f320ac2ebf73df012556d64be9b120445", "patch": "@@ -164,7 +164,7 @@ pub fn resolver_for_position(db: &impl HirDatabase, position: FilePosition) -> R\n                         let scope = scopes.scope_for_offset(position.offset);\n                         Some(expr::resolver_for_scope(func.body(db), db, scope))\n                     } else {\n-                        // TODO const/static/array length\n+                        // FIXME const/static/array length\n                         None\n                     }\n                 } else {\n@@ -184,7 +184,7 @@ pub fn resolver_for_node(db: &impl HirDatabase, file_id: FileId, node: &SyntaxNo\n                     let scope = scopes.scope_for(&node);\n                     Some(expr::resolver_for_scope(func.body(db), db, scope))\n                 } else {\n-                    // TODO const/static/array length\n+                    // FIXME const/static/array length\n                     None\n                 }\n             } else {\n@@ -212,7 +212,7 @@ fn try_get_resolver_for_node(\n     } else if let Some(f) = ast::FnDef::cast(node) {\n         function_from_source(db, file_id, f).map(|f| f.resolver(db))\n     } else {\n-        // TODO add missing cases\n+        // FIXME add missing cases\n         None\n     }\n }"}, {"sha": "ab5f008ef9ba634635afc246cb457d54111709a0", "filename": "crates/ra_hir/src/ty/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs?ref=3d7a330f320ac2ebf73df012556d64be9b120445", "patch": "@@ -15,7 +15,7 @@ impl Ty {\n     }\n \n     fn autoderef_step(&self, _db: &impl HirDatabase) -> Option<Ty> {\n-        // TODO Deref::deref\n+        // FIXME Deref::deref\n         self.builtin_deref()\n     }\n }"}, {"sha": "132ee0ca2d775878948cdcfc67e3825ca1e9469b", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=3d7a330f320ac2ebf73df012556d64be9b120445", "patch": "@@ -207,7 +207,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn make_ty(&mut self, type_ref: &TypeRef) -> Ty {\n         let ty = Ty::from_hir(\n             self.db,\n-            // TODO use right resolver for block\n+            // FIXME use right resolver for block\n             &self.resolver,\n             type_ref,\n         );\n@@ -414,11 +414,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     return None;\n                 }\n                 Resolution::GenericParam(..) => {\n-                    // TODO associated item of generic param\n+                    // FIXME associated item of generic param\n                     return None;\n                 }\n                 Resolution::SelfType(_) => {\n-                    // TODO associated item of self type\n+                    // FIXME associated item of self type\n                     return None;\n                 }\n             };\n@@ -446,7 +446,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         }\n                     }\n \n-                    // TODO: Resolve associated types\n+                    // FIXME: Resolve associated types\n                     crate::ImplItem::TypeAlias(_) => None,\n                 };\n                 match matching_def {\n@@ -504,7 +504,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 return (Ty::Unknown, None);\n             }\n             Some(Resolution::SelfType(..)) => {\n-                // TODO this is allowed in an impl for a struct, handle this\n+                // FIXME this is allowed in an impl for a struct, handle this\n                 return (Ty::Unknown, None);\n             }\n             None => return (Ty::Unknown, None),\n@@ -513,7 +513,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             None => return (Ty::Unknown, None),\n             Some(it) => it,\n         };\n-        // TODO remove the duplication between here and `Ty::from_path`?\n+        // FIXME remove the duplication between here and `Ty::from_path`?\n         let substs = Ty::substs_from_path(self.db, resolver, path, def);\n         match def {\n             TypableDef::Struct(s) => {\n@@ -590,7 +590,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             | Pat::Struct { .. }\n             | Pat::Range { .. }\n             | Pat::Slice { .. } => true,\n-            // TODO: Path/Lit might actually evaluate to ref, but inference is unimplemented.\n+            // FIXME: Path/Lit might actually evaluate to ref, but inference is unimplemented.\n             Pat::Path(..) | Pat::Lit(..) => true,\n             Pat::Wild | Pat::Bind { .. } | Pat::Ref { .. } | Pat::Missing => false,\n         };\n@@ -635,7 +635,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let expectation = match expected.as_reference() {\n                     Some((inner_ty, exp_mut)) => {\n                         if *mutability != exp_mut {\n-                            // TODO: emit type error?\n+                            // FIXME: emit type error?\n                         }\n                         inner_ty\n                     }\n@@ -651,7 +651,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 self.infer_struct_pat(p.as_ref(), fields, expected, default_bm)\n             }\n             Pat::Path(path) => {\n-                // TODO use correct resolver for the surrounding expression\n+                // FIXME use correct resolver for the surrounding expression\n                 let resolver = self.resolver.clone();\n                 self.infer_path_expr(&resolver, &path, pat.into()).unwrap_or(Ty::Unknown)\n             }\n@@ -741,7 +741,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Expr::Block { statements, tail } => self.infer_block(statements, *tail, expected),\n             Expr::Loop { body } => {\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n-                // TODO handle break with value\n+                // FIXME handle break with value\n                 Ty::simple(TypeCtor::Never)\n             }\n             Expr::While { condition, body } => {\n@@ -769,7 +769,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     self.infer_pat(*arg_pat, &expected, BindingMode::default());\n                 }\n \n-                // TODO: infer lambda type etc.\n+                // FIXME: infer lambda type etc.\n                 let _body_ty = self.infer_expr(*body, &Expectation::none());\n                 Ty::Unknown\n             }\n@@ -795,7 +795,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     },\n                     _ => {\n                         // not callable\n-                        // TODO report an error?\n+                        // FIXME report an error?\n                         (Vec::new(), Ty::Unknown)\n                     }\n                 };\n@@ -894,14 +894,14 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 expected.ty\n             }\n             Expr::Path(p) => {\n-                // TODO this could be more efficient...\n+                // FIXME this could be more efficient...\n                 let resolver = expr::resolver_for_expr(self.body.clone(), self.db, tgt_expr);\n                 self.infer_path_expr(&resolver, p, tgt_expr.into()).unwrap_or(Ty::Unknown)\n             }\n             Expr::Continue => Ty::simple(TypeCtor::Never),\n             Expr::Break { expr } => {\n                 if let Some(expr) = expr {\n-                    // TODO handle break with value\n+                    // FIXME handle break with value\n                     self.infer_expr(*expr, &Expectation::none());\n                 }\n                 Ty::simple(TypeCtor::Never)\n@@ -957,21 +957,21 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Expr::Cast { expr, type_ref } => {\n                 let _inner_ty = self.infer_expr(*expr, &Expectation::none());\n                 let cast_ty = self.make_ty(type_ref);\n-                // TODO check the cast...\n+                // FIXME check the cast...\n                 cast_ty\n             }\n             Expr::Ref { expr, mutability } => {\n                 let expectation =\n                     if let Some((exp_inner, exp_mutability)) = &expected.ty.as_reference() {\n                         if *exp_mutability == Mutability::Mut && *mutability == Mutability::Shared {\n-                            // TODO: throw type error - expected mut reference but found shared ref,\n+                            // FIXME: throw type error - expected mut reference but found shared ref,\n                             // which cannot be coerced\n                         }\n                         Expectation::has_type(Ty::clone(exp_inner))\n                     } else {\n                         Expectation::none()\n                     };\n-                // TODO reference coercions etc.\n+                // FIXME reference coercions etc.\n                 let inner_ty = self.infer_expr(*expr, &expectation);\n                 Ty::apply_one(TypeCtor::Ref(*mutability), inner_ty)\n             }\n@@ -982,7 +982,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         if let Some(derefed_ty) = inner_ty.builtin_deref() {\n                             derefed_ty\n                         } else {\n-                            // TODO Deref::deref\n+                            // FIXME Deref::deref\n                             Ty::Unknown\n                         }\n                     }\n@@ -1002,7 +1002,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => {\n                                 inner_ty\n                             }\n-                            // TODO: resolve ops::Neg trait\n+                            // FIXME: resolve ops::Neg trait\n                             _ => Ty::Unknown,\n                         }\n                     }\n@@ -1013,7 +1013,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                                 _ => Ty::Unknown,\n                             },\n                             Ty::Infer(InferTy::IntVar(..)) => inner_ty,\n-                            // TODO: resolve ops::Not trait for inner_ty\n+                            // FIXME: resolve ops::Not trait for inner_ty\n                             _ => Ty::Unknown,\n                         }\n                     }\n@@ -1028,12 +1028,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         _ => Expectation::none(),\n                     };\n                     let lhs_ty = self.infer_expr(*lhs, &lhs_expectation);\n-                    // TODO: find implementation of trait corresponding to operation\n+                    // FIXME: find implementation of trait corresponding to operation\n                     // symbol and resolve associated `Output` type\n                     let rhs_expectation = op::binary_op_rhs_expectation(*op, lhs_ty);\n                     let rhs_ty = self.infer_expr(*rhs, &Expectation::has_type(rhs_expectation));\n \n-                    // TODO: similar as above, return ty is often associated trait type\n+                    // FIXME: similar as above, return ty is often associated trait type\n                     op::binary_op_return_ty(*op, rhs_ty)\n                 }\n                 _ => Ty::Unknown,\n@@ -1227,7 +1227,7 @@ impl InferTy {\n #[derive(Clone, PartialEq, Eq, Debug)]\n struct Expectation {\n     ty: Ty,\n-    // TODO: In some cases, we need to be aware whether the expectation is that\n+    // FIXME: In some cases, we need to be aware whether the expectation is that\n     // the type match exactly what we passed, or whether it just needs to be\n     // coercible to the expected type. See Expectation::rvalue_hint in rustc.\n }"}, {"sha": "003a89f0dce432ad3cf205dac960e6dec9aab975", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=3d7a330f320ac2ebf73df012556d64be9b120445", "patch": "@@ -60,7 +60,7 @@ impl Ty {\n \n     pub(crate) fn from_hir_path(db: &impl HirDatabase, resolver: &Resolver, path: &Path) -> Self {\n         if let Some(name) = path.as_ident() {\n-            // TODO handle primitive type names in resolver as well?\n+            // FIXME handle primitive type names in resolver as well?\n             if let Some(int_ty) = primitive::IntTy::from_type_name(name) {\n                 return Ty::simple(TypeCtor::Int(primitive::UncertainIntTy::Known(int_ty)));\n             } else if let Some(float_ty) = primitive::FloatTy::from_type_name(name) {\n@@ -87,7 +87,7 @@ impl Ty {\n             Some(Resolution::GenericParam(idx)) => {\n                 return Ty::Param {\n                     idx,\n-                    // TODO: maybe return name in resolution?\n+                    // FIXME: maybe return name in resolution?\n                     name: path\n                         .as_ident()\n                         .expect(\"generic param should be single-segment path\")\n@@ -139,7 +139,7 @@ impl Ty {\n             }\n         }\n         // add placeholders for args that were not provided\n-        // TODO: handle defaults\n+        // FIXME: handle defaults\n         let supplied_params = substs.len();\n         for _ in supplied_params..def_generics.count_params_including_parent() {\n             substs.push(Ty::Unknown);"}, {"sha": "b1684acf968412082b437f07c7af3b447cb1586d", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=3d7a330f320ac2ebf73df012556d64be9b120445", "patch": "@@ -120,7 +120,7 @@ fn def_crate(db: &impl HirDatabase, ty: &Ty) -> Option<Crate> {\n }\n \n impl Ty {\n-    // TODO: cache this as a query?\n+    // FIXME: cache this as a query?\n     // - if so, what signature? (TyFingerprint, Name)?\n     // - or maybe cache all names and def_ids of methods per fingerprint?\n     /// Look up the method with the given name, returning the actual autoderefed"}, {"sha": "f54a02d1ddaa24932f77fd890c6597b2b43d3b34", "filename": "crates/ra_ide_api/src/completion/complete_dot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=3d7a330f320ac2ebf73df012556d64be9b120445", "patch": "@@ -30,7 +30,7 @@ fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty)\n                         acc.add_field(ctx, field, &a_ty.parameters);\n                     }\n                 }\n-                // TODO unions\n+                // FIXME unions\n                 TypeCtor::Tuple => {\n                     for (i, ty) in a_ty.parameters.iter().enumerate() {\n                         acc.add_pos_field(ctx, i, ty);"}, {"sha": "7abcd019b12214900e4b7219f5db3b712c665d6e", "filename": "crates/ra_ide_api/src/completion/complete_pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs?ref=3d7a330f320ac2ebf73df012556d64be9b120445", "patch": "@@ -5,7 +5,7 @@ pub(super) fn complete_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n     if !ctx.is_pat_binding {\n         return;\n     }\n-    // TODO: ideally, we should look at the type we are matching against and\n+    // FIXME: ideally, we should look at the type we are matching against and\n     // suggest variants + auto-imports\n     let names = ctx.resolver.all_names(ctx.db);\n     for (name, res) in names.into_iter() {"}, {"sha": "f58bcd03eb8ff57c15c11e0bb5249d7c7ee46c6d", "filename": "crates/ra_ide_api/src/completion/complete_struct_literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_struct_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_struct_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_struct_literal.rs?ref=3d7a330f320ac2ebf73df012556d64be9b120445", "patch": "@@ -26,7 +26,7 @@ pub(super) fn complete_struct_literal(acc: &mut Completions, ctx: &CompletionCon\n             }\n         }\n \n-        // TODO unions\n+        // FIXME unions\n         AdtDef::Enum(_) => (),\n     };\n }"}, {"sha": "660b43cfa3f206fcf71eaa9e13873e3352ffddf9", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=3d7a330f320ac2ebf73df012556d64be9b120445", "patch": "@@ -117,7 +117,7 @@ pub(crate) fn reference_definition(\n                 return Exact(nav);\n             }\n             Some(Resolution::GenericParam(..)) => {\n-                // TODO: go to the generic param def\n+                // FIXME: go to the generic param def\n             }\n             Some(Resolution::SelfType(impl_block)) => {\n                 let ty = impl_block.target_ty(db);"}, {"sha": "3206e68b9fa086fa6c7adff6997ab81dd1b9b3b3", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=3d7a330f320ac2ebf73df012556d64be9b120445", "patch": "@@ -204,7 +204,7 @@ impl NavigationTarget {\n     ///\n     /// e.g. `struct Name`, `enum Name`, `fn Name`\n     fn description(&self, db: &RootDatabase) -> Option<String> {\n-        // TODO: After type inference is done, add type information to improve the output\n+        // FIXME: After type inference is done, add type information to improve the output\n         let node = self.node(db)?;\n \n         fn visit_ascribed_node<T>(node: &T, prefix: &str) -> Option<String>"}, {"sha": "fd33d6767874c5271c43997603e609a9dd6a6be8", "filename": "crates/ra_ide_api/src/line_index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_ide_api%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_ide_api%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fline_index.rs?ref=3d7a330f320ac2ebf73df012556d64be9b120445", "patch": "@@ -77,7 +77,7 @@ impl LineIndex {\n     }\n \n     pub fn offset(&self, line_col: LineCol) -> TextUnit {\n-        //TODO: return Result\n+        //FIXME: return Result\n         let col = self.utf16_to_utf8_col(line_col.line, line_col.col_utf16);\n         self.newlines[line_col.line as usize] + col\n     }"}, {"sha": "0978d164a42c952f7b8ad8f1760da3bdea999feb", "filename": "crates/ra_ide_api/src/symbol_index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_ide_api%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_ide_api%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsymbol_index.rs?ref=3d7a330f320ac2ebf73df012556d64be9b120445", "patch": "@@ -68,7 +68,7 @@ fn file_symbols(db: &impl SymbolsDatabase, file_id: FileId) -> Arc<SymbolIndex>\n \n     let symbols = source_file_to_file_symbols(&source_file, file_id);\n \n-    // TODO: add macros here\n+    // FIXME: add macros here\n \n     Arc::new(SymbolIndex::new(symbols))\n }"}, {"sha": "1f802246fef1a611171f063107a59ca610c8a430", "filename": "crates/ra_parser/src/grammar/items/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fconsts.rs?ref=3d7a330f320ac2ebf73df012556d64be9b120445", "patch": "@@ -11,7 +11,7 @@ pub(super) fn const_def(p: &mut Parser, m: Marker) {\n fn const_or_static(p: &mut Parser, m: Marker, kw: SyntaxKind, def: SyntaxKind) {\n     assert!(p.at(kw));\n     p.bump();\n-    p.eat(MUT_KW); // TODO: validator to forbid const mut\n+    p.eat(MUT_KW); // FIXME: validator to forbid const mut\n     name(p);\n     types::ascription(p);\n     if p.eat(EQ) {"}, {"sha": "e93bd76b81d9a18eea20bc481f4c1e58af876051", "filename": "crates/ra_parser/src/grammar/items/nominal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fnominal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fnominal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fnominal.rs?ref=3d7a330f320ac2ebf73df012556d64be9b120445", "patch": "@@ -15,7 +15,7 @@ pub(super) fn struct_def(p: &mut Parser, m: Marker, kind: SyntaxKind) {\n                 }\n                 L_CURLY => named_field_def_list(p),\n                 _ => {\n-                    //TODO: special case `(` error message\n+                    //FIXME: special case `(` error message\n                     p.error(\"expected `;` or `{`\");\n                 }\n             }"}, {"sha": "f49615f6b4fa27ae5be014f81135313499bf7c22", "filename": "crates/ra_parser/src/grammar/items/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs?ref=3d7a330f320ac2ebf73df012556d64be9b120445", "patch": "@@ -49,7 +49,7 @@ pub(super) fn impl_block(p: &mut Parser) {\n         type_params::opt_type_param_list(p);\n     }\n \n-    // TODO: never type\n+    // FIXME: never type\n     // impl ! {}\n \n     // test impl_block_neg"}, {"sha": "908493789403e5254e32eb91759d0fab4ac912e6", "filename": "crates/ra_parser/src/grammar/items/use_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fuse_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fuse_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fuse_item.rs?ref=3d7a330f320ac2ebf73df012556d64be9b120445", "patch": "@@ -21,7 +21,7 @@ fn use_tree(p: &mut Parser) {\n         // This does not handle cases such as `use some::path::*`\n         // N.B. in Rust 2015 `use *;` imports all from crate root\n         // however in Rust 2018 `use *;` errors: ('cannot glob-import all possible crates')\n-        // TODO: Add this error (if not out of scope)\n+        // FIXME: Add this error (if not out of scope)\n \n         // test use_star\n         // use *;\n@@ -33,7 +33,7 @@ fn use_tree(p: &mut Parser) {\n             // Parse `use ::*;`, which imports all from the crate root in Rust 2015\n             // This is invalid inside a use_tree_list, (e.g. `use some::path::{::*}`)\n             // but still parses and errors later: ('crate root in paths can only be used in start position')\n-            // TODO: Add this error (if not out of scope)\n+            // FIXME: Add this error (if not out of scope)\n             // In Rust 2018, it is always invalid (see above)\n             p.bump();\n             p.bump();"}, {"sha": "56f8b7126500a9093b2d2afdbdb712a6a61b6f52", "filename": "crates/ra_parser/src/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_parser%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_parser%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fparser.rs?ref=3d7a330f320ac2ebf73df012556d64be9b120445", "patch": "@@ -121,7 +121,7 @@ impl<'t> Parser<'t> {\n     /// final tree.\n     pub(crate) fn bump_remap(&mut self, kind: SyntaxKind) {\n         if self.nth(0) == EOF {\n-            // TODO: panic!?\n+            // FIXME: panic!?\n             return;\n         }\n         self.do_bump(kind, 1);\n@@ -135,7 +135,7 @@ impl<'t> Parser<'t> {\n     }\n \n     /// Emit error with the `message`\n-    /// TODO: this should be much more fancy and support\n+    /// FIXME: this should be much more fancy and support\n     /// structured errors with spans and notes, like rustc\n     /// does.\n     pub(crate) fn error<T: Into<String>>(&mut self, message: T) {"}, {"sha": "3bad4f8d358695be2cb9bc4f184fadea83f9bb2f", "filename": "crates/ra_project_model/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_project_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_project_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Flib.rs?ref=3d7a330f320ac2ebf73df012556d64be9b120445", "patch": "@@ -23,7 +23,7 @@ pub use crate::{\n     sysroot::Sysroot,\n };\n \n-// TODO use proper error enum\n+// FIXME use proper error enum\n pub type Result<T> = ::std::result::Result<T, ::failure::Error>;\n \n #[derive(Debug, Clone)]"}, {"sha": "c874e5d08ac4acf40618e04161462bd605be164e", "filename": "crates/ra_syntax/src/validation/char.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fchar.rs?ref=3d7a330f320ac2ebf73df012556d64be9b120445", "patch": "@@ -85,7 +85,7 @@ pub(super) fn is_ascii_escape(code: char) -> bool {\n fn validate_ascii_code_escape(text: &str, range: TextRange, errors: &mut Vec<SyntaxError>) {\n     // An AsciiCodeEscape has 4 chars, example: `\\xDD`\n     if !text.is_ascii() {\n-        // TODO: Give a more precise error message (say what the invalid character was)\n+        // FIXME: Give a more precise error message (say what the invalid character was)\n         errors.push(SyntaxError::new(AsciiCodeEscapeOutOfRange, range));\n     } else if text.chars().count() < 4 {\n         errors.push(SyntaxError::new(TooShortAsciiCodeEscape, range));"}, {"sha": "276756c857d4628c5c54ef8f6ceb6fdea34a29b9", "filename": "crates/ra_syntax/tests/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_syntax%2Ftests%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Fra_syntax%2Ftests%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftests%2Ftest.rs?ref=3d7a330f320ac2ebf73df012556d64be9b120445", "patch": "@@ -61,7 +61,7 @@ fn reparse_fuzz_tests() {\n }\n \n /// Test that Rust-analyzer can parse and validate the rust-analyser\n-/// TODO: Use this as a benchmark\n+/// FIXME: Use this as a benchmark\n #[test]\n fn self_hosting_parsing() {\n     use std::ffi::OsStr;"}, {"sha": "6f82ae61d97390b18f7ba3b79b1324ce06d0f213", "filename": "crates/tools/tests/cli.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Ftools%2Ftests%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d7a330f320ac2ebf73df012556d64be9b120445/crates%2Ftools%2Ftests%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftools%2Ftests%2Fcli.rs?ref=3d7a330f320ac2ebf73df012556d64be9b120445", "patch": "@@ -1,4 +1,6 @@\n-use tools::{generate, gen_tests, run_rustfmt, Verify};\n+use walkdir::WalkDir;\n+\n+use tools::{generate, gen_tests, run_rustfmt, Verify, project_root};\n \n #[test]\n fn generated_grammar_is_fresh() {\n@@ -20,3 +22,25 @@ fn check_code_formatting() {\n         panic!(\"{}. Please format the code by running `cargo format`\", error);\n     }\n }\n+\n+#[test]\n+fn no_todo() {\n+    WalkDir::new(project_root().join(\"crates\")).into_iter().for_each(|e| {\n+        let e = e.unwrap();\n+        if e.path().extension().map(|it| it != \"rs\").unwrap_or(true) {\n+            return;\n+        }\n+        if e.path().ends_with(\"tests/cli.rs\") {\n+            return;\n+        }\n+        let text = std::fs::read_to_string(e.path()).unwrap();\n+        if text.contains(\"TODO\") {\n+            panic!(\n+                \"\\nTODO markers should not be commited to the master branch,\\n\\\n+                 use FIXME instead\\n\\\n+                 {}\\n\",\n+                e.path().display(),\n+            )\n+        }\n+    })\n+}"}]}