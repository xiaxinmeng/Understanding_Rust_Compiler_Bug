{"sha": "50c8d4e27062986e7b0a6c4d4e247c021d0a7cff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwYzhkNGUyNzA2Mjk4NmU3YjBhNmM0ZDRlMjQ3YzAyMWQwYTdjZmY=", "commit": {"author": {"name": "Martin Carton", "email": "cartonmartin+github@gmail.com", "date": "2017-04-28T17:54:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-04-28T17:54:24Z"}, "message": "Merge pull request #1705 from Manishearth/op_ref\n\nOp ref", "tree": {"sha": "938f814be179296d120b06fad6514ee39f4bf2f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/938f814be179296d120b06fad6514ee39f4bf2f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50c8d4e27062986e7b0a6c4d4e247c021d0a7cff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50c8d4e27062986e7b0a6c4d4e247c021d0a7cff", "html_url": "https://github.com/rust-lang/rust/commit/50c8d4e27062986e7b0a6c4d4e247c021d0a7cff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50c8d4e27062986e7b0a6c4d4e247c021d0a7cff/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09c5359b9d6912d6328f46928ddae50160734010", "url": "https://api.github.com/repos/rust-lang/rust/commits/09c5359b9d6912d6328f46928ddae50160734010", "html_url": "https://github.com/rust-lang/rust/commit/09c5359b9d6912d6328f46928ddae50160734010"}, {"sha": "88d3898426c7132164f21b69299a3e74e9eb63e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/88d3898426c7132164f21b69299a3e74e9eb63e1", "html_url": "https://github.com/rust-lang/rust/commit/88d3898426c7132164f21b69299a3e74e9eb63e1"}], "stats": {"total": 268, "additions": 171, "deletions": 97}, "files": [{"sha": "eac72e12e90c7709b968491dda9abd1e4b3342ea", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/50c8d4e27062986e7b0a6c4d4e247c021d0a7cff/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c8d4e27062986e7b0a6c4d4e247c021d0a7cff/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=50c8d4e27062986e7b0a6c4d4e247c021d0a7cff", "patch": "@@ -6,6 +6,7 @@ use rustc_const_eval::lookup_const_by_id;\n use rustc_const_math::ConstInt;\n use rustc::hir::*;\n use rustc::ty::{self, TyCtxt};\n+use rustc::ty::subst::{Substs, Subst};\n use std::cmp::Ordering::{self, Equal};\n use std::cmp::PartialOrd;\n use std::hash::{Hash, Hasher};\n@@ -225,6 +226,7 @@ pub fn constant(lcx: &LateContext, e: &Expr) -> Option<(Constant, bool)> {\n         tcx: lcx.tcx,\n         tables: lcx.tables,\n         needed_resolution: false,\n+        substs: lcx.tcx.intern_substs(&[]),\n     };\n     cx.expr(e).map(|cst| (cst, cx.needed_resolution))\n }\n@@ -237,6 +239,7 @@ struct ConstEvalLateContext<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n     needed_resolution: bool,\n+    substs: &'tcx Substs<'tcx>,\n }\n \n impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n@@ -286,11 +289,17 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n                 let substs = self.tables\n                     .node_id_item_substs(id)\n                     .unwrap_or_else(|| self.tcx.intern_substs(&[]));\n-                if let Some((const_expr, _)) = lookup_const_by_id(self.tcx, def_id, substs) {\n+                let substs = if self.substs.is_empty() {\n+                    substs\n+                } else {\n+                    substs.subst(self.tcx, self.substs)\n+                };\n+                if let Some((def_id, substs)) = lookup_const_by_id(self.tcx, def_id, substs) {\n                     let mut cx = ConstEvalLateContext {\n                         tcx: self.tcx,\n-                        tables: self.tcx.typeck_tables_of(const_expr),\n+                        tables: self.tcx.typeck_tables_of(def_id),\n                         needed_resolution: false,\n+                        substs,\n                     };\n                     let body = if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n                         self.tcx.mir_const_qualif(def_id);"}, {"sha": "1710871a31f7244eabb4658f66fa96d07335ecff", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/50c8d4e27062986e7b0a6c4d4e247c021d0a7cff/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c8d4e27062986e7b0a6c4d4e247c021d0a7cff/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=50c8d4e27062986e7b0a6c4d4e247c021d0a7cff", "patch": "@@ -1,11 +1,10 @@\n use rustc::lint::*;\n-use rustc::ty::subst::Subst;\n use rustc::ty::TypeVariants;\n use rustc::ty;\n use rustc::hir::*;\n use syntax::codemap::Span;\n use utils::paths;\n-use utils::{is_automatically_derived, span_lint_and_then, match_path_old};\n+use utils::{is_automatically_derived, span_lint_and_then, match_path_old, is_copy};\n \n /// **What it does:** Checks for deriving `Hash` but implementing `PartialEq`\n /// explicitly.\n@@ -137,11 +136,8 @@ fn check_hash_peq<'a, 'tcx>(\n /// Implementation of the `EXPL_IMPL_CLONE_ON_COPY` lint.\n fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, item: &Item, trait_ref: &TraitRef, ty: ty::Ty<'tcx>) {\n     if match_path_old(&trait_ref.path, &paths::CLONE_TRAIT) {\n-        let parameter_environment = ty::ParameterEnvironment::for_item(cx.tcx, item.id);\n-        let subst_ty = ty.subst(cx.tcx, parameter_environment.free_substs);\n-\n-        if subst_ty.moves_by_default(cx.tcx.global_tcx(), &parameter_environment, item.span) {\n-            return; // ty is not Copy\n+        if !is_copy(cx, ty, item.id) {\n+            return;\n         }\n \n         match ty.sty {"}, {"sha": "6dedbe4b673e075b17f565af2b9528c4af7c7f1c", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 93, "deletions": 84, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/50c8d4e27062986e7b0a6c4d4e247c021d0a7cff/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c8d4e27062986e7b0a6c4d4e247c021d0a7cff/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=50c8d4e27062986e7b0a6c4d4e247c021d0a7cff", "patch": "@@ -1,7 +1,6 @@\n use rustc::hir::*;\n use rustc::lint::*;\n-use utils::{SpanlessEq, span_lint, span_lint_and_then, multispan_sugg, snippet, implements_trait};\n-use utils::sugg::Sugg;\n+use utils::{SpanlessEq, span_lint, span_lint_and_then, multispan_sugg, snippet, implements_trait, is_copy};\n \n /// **What it does:** Checks for equal operands to comparison, logical and\n /// bitwise, difference and division binary operators (`==`, `>`, etc., `&&`,\n@@ -53,89 +52,99 @@ impl LintPass for EqOp {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprBinary(ref op, ref left, ref right) = e.node {\n-            if is_valid_operator(op) {\n-                if SpanlessEq::new(cx).ignore_fn().eq_expr(left, right) {\n-                    span_lint(cx,\n-                              EQ_OP,\n-                              e.span,\n-                              &format!(\"equal expressions as operands to `{}`\", op.node.as_str()));\n-                } else {\n-                    let trait_id = match op.node {\n-                        BiAdd => cx.tcx.lang_items.add_trait(),\n-                        BiSub => cx.tcx.lang_items.sub_trait(),\n-                        BiMul => cx.tcx.lang_items.mul_trait(),\n-                        BiDiv => cx.tcx.lang_items.div_trait(),\n-                        BiRem => cx.tcx.lang_items.rem_trait(),\n-                        BiAnd | BiOr => None,\n-                        BiBitXor => cx.tcx.lang_items.bitxor_trait(),\n-                        BiBitAnd => cx.tcx.lang_items.bitand_trait(),\n-                        BiBitOr => cx.tcx.lang_items.bitor_trait(),\n-                        BiShl => cx.tcx.lang_items.shl_trait(),\n-                        BiShr => cx.tcx.lang_items.shr_trait(),\n-                        BiNe | BiEq => cx.tcx.lang_items.eq_trait(),\n-                        BiLt | BiLe | BiGe | BiGt => cx.tcx.lang_items.ord_trait(),\n-                    };\n-                    if let Some(trait_id) = trait_id {\n-                        #[allow(match_same_arms)]\n-                        match (&left.node, &right.node) {\n-                            // do not suggest to dereference literals\n-                            (&ExprLit(..), _) |\n-                            (_, &ExprLit(..)) => {},\n-                            // &foo == &bar\n-                            (&ExprAddrOf(_, ref l), &ExprAddrOf(_, ref r)) => {\n-                                if implements_trait(cx, cx.tables.expr_ty(l), trait_id, &[cx.tables.expr_ty(r)], None) {\n-                                    span_lint_and_then(cx,\n-                                                       OP_REF,\n-                                                       e.span,\n-                                                       \"taken reference of both operands, which is done automatically \\\n-                                                        by the operator anyway\",\n-                                                       |db| {\n-                                        let lsnip = snippet(cx, l.span, \"...\").to_string();\n-                                        let rsnip = snippet(cx, r.span, \"...\").to_string();\n-                                        multispan_sugg(db,\n-                                                       \"use the values directly\".to_string(),\n-                                                       vec![(left.span, lsnip),\n-                                                            (right.span, rsnip)]);\n-                                    })\n-                                }\n-                            },\n-                            // &foo == bar\n-                            (&ExprAddrOf(_, ref l), _) => {\n-                                if implements_trait(cx,\n-                                                    cx.tables.expr_ty(l),\n-                                                    trait_id,\n-                                                    &[cx.tables.expr_ty(right)],\n-                                                    None) {\n-                                    span_lint_and_then(cx, OP_REF, e.span, \"taken reference of left operand\", |db| {\n-                                        let lsnip = snippet(cx, l.span, \"...\").to_string();\n-                                        let rsnip = Sugg::hir(cx, right, \"...\").deref().to_string();\n-                                        multispan_sugg(db,\n-                                                       \"dereference the right operand instead\".to_string(),\n-                                                       vec![(left.span, lsnip),\n-                                                            (right.span, rsnip)]);\n-                                    })\n-                                }\n-                            },\n-                            // foo == &bar\n-                            (_, &ExprAddrOf(_, ref r)) => {\n-                                if implements_trait(cx,\n-                                                    cx.tables.expr_ty(left),\n-                                                    trait_id,\n-                                                    &[cx.tables.expr_ty(r)],\n-                                                    None) {\n-                                    span_lint_and_then(cx, OP_REF, e.span, \"taken reference of right operand\", |db| {\n-                                        let lsnip = Sugg::hir(cx, left, \"...\").deref().to_string();\n-                                        let rsnip = snippet(cx, r.span, \"...\").to_string();\n-                                        multispan_sugg(db,\n-                                                       \"dereference the left operand instead\".to_string(),\n-                                                       vec![(left.span, lsnip),\n-                                                            (right.span, rsnip)]);\n-                                    })\n-                                }\n-                            },\n-                            _ => {},\n+            if is_valid_operator(op) && SpanlessEq::new(cx).ignore_fn().eq_expr(left, right) {\n+                span_lint(cx,\n+                            EQ_OP,\n+                            e.span,\n+                            &format!(\"equal expressions as operands to `{}`\", op.node.as_str()));\n+                return;\n+            }\n+            let (trait_id, requires_ref) = match op.node {\n+                BiAdd => (cx.tcx.lang_items.add_trait(), false),\n+                BiSub => (cx.tcx.lang_items.sub_trait(), false),\n+                BiMul => (cx.tcx.lang_items.mul_trait(), false),\n+                BiDiv => (cx.tcx.lang_items.div_trait(), false),\n+                BiRem => (cx.tcx.lang_items.rem_trait(), false),\n+                // don't lint short circuiting ops\n+                BiAnd | BiOr => return,\n+                BiBitXor => (cx.tcx.lang_items.bitxor_trait(), false),\n+                BiBitAnd => (cx.tcx.lang_items.bitand_trait(), false),\n+                BiBitOr => (cx.tcx.lang_items.bitor_trait(), false),\n+                BiShl => (cx.tcx.lang_items.shl_trait(), false),\n+                BiShr => (cx.tcx.lang_items.shr_trait(), false),\n+                BiNe | BiEq => (cx.tcx.lang_items.eq_trait(), true),\n+                BiLt | BiLe | BiGe | BiGt => (cx.tcx.lang_items.ord_trait(), true),\n+            };\n+            let parent = cx.tcx.hir.get_parent(e.id);\n+            if let Some(trait_id) = trait_id {\n+                #[allow(match_same_arms)]\n+                match (&left.node, &right.node) {\n+                    // do not suggest to dereference literals\n+                    (&ExprLit(..), _) |\n+                    (_, &ExprLit(..)) => {},\n+                    // &foo == &bar\n+                    (&ExprAddrOf(_, ref l), &ExprAddrOf(_, ref r)) => {\n+                        let lty = cx.tables.expr_ty(l);\n+                        let rty = cx.tables.expr_ty(r);\n+                        let lcpy = is_copy(cx, lty, parent);\n+                        let rcpy = is_copy(cx, rty, parent);\n+                        // either operator autorefs or both args are copyable\n+                        if (requires_ref || (lcpy && rcpy)) && implements_trait(cx, lty, trait_id, &[rty], None) {\n+                            span_lint_and_then(cx,\n+                                                OP_REF,\n+                                                e.span,\n+                                                \"needlessly taken reference of both operands\",\n+                                                |db| {\n+                                let lsnip = snippet(cx, l.span, \"...\").to_string();\n+                                let rsnip = snippet(cx, r.span, \"...\").to_string();\n+                                multispan_sugg(db,\n+                                                \"use the values directly\".to_string(),\n+                                                vec![(left.span, lsnip),\n+                                                    (right.span, rsnip)]);\n+                            })\n+                        } else if lcpy && !rcpy && implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right)], None) {\n+                            span_lint_and_then(cx,\n+                                                OP_REF,\n+                                                e.span,\n+                                                \"needlessly taken reference of left operand\",\n+                                                |db| {\n+                                let lsnip = snippet(cx, l.span, \"...\").to_string();\n+                                db.span_suggestion(left.span, \"use the left value directly\", lsnip);\n+                            })\n+                        } else if !lcpy && rcpy && implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty], None) {\n+                            span_lint_and_then(cx,\n+                                                OP_REF,\n+                                                e.span,\n+                                                \"needlessly taken reference of right operand\",\n+                                                |db| {\n+                                let rsnip = snippet(cx, r.span, \"...\").to_string();\n+                                db.span_suggestion(right.span, \"use the right value directly\", rsnip);\n+                            })\n+                        }\n+                    },\n+                    // &foo == bar\n+                    (&ExprAddrOf(_, ref l), _) => {\n+                        let lty = cx.tables.expr_ty(l);\n+                        let lcpy = is_copy(cx, lty, parent);\n+                        if (requires_ref || lcpy) && implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right)], None) {\n+                            span_lint_and_then(cx, OP_REF, e.span, \"needlessly taken reference of left operand\", |db| {\n+                                let lsnip = snippet(cx, l.span, \"...\").to_string();\n+                                db.span_suggestion(left.span, \"use the left value directly\", lsnip);\n+                            })\n+                        }\n+                    },\n+                    // foo == &bar\n+                    (_, &ExprAddrOf(_, ref r)) => {\n+                        let rty = cx.tables.expr_ty(r);\n+                        let rcpy = is_copy(cx, rty, parent);\n+                        if (requires_ref || rcpy) && implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty], None) {\n+                            span_lint_and_then(cx, OP_REF, e.span, \"taken reference of right operand\", |db| {\n+                                let rsnip = snippet(cx, r.span, \"...\").to_string();\n+                                db.span_suggestion(left.span, \"use the right value directly\", rsnip);\n+                            })\n                         }\n-                    }\n+                    },\n+                    _ => {},\n                 }\n             }\n         }"}, {"sha": "64a8f72ea0167c48328e5c0d79623ffc130c5b05", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/50c8d4e27062986e7b0a6c4d4e247c021d0a7cff/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c8d4e27062986e7b0a6c4d4e247c021d0a7cff/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=50c8d4e27062986e7b0a6c4d4e247c021d0a7cff", "patch": "@@ -821,7 +821,6 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_ty: ty::Ty) {\n     let ty = cx.tables.expr_ty(expr);\n     let parent = cx.tcx.hir.get_parent(expr.id);\n-    let parameter_environment = ty::ParameterEnvironment::for_item(cx.tcx, parent);\n     if let ty::TyRef(_, ty::TypeAndMut { ty: inner, .. }) = arg_ty.sty {\n         if let ty::TyRef(..) = inner.sty {\n             span_lint_and_then(cx,\n@@ -838,7 +837,7 @@ fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_t\n         }\n     }\n \n-    if !ty.moves_by_default(cx.tcx.global_tcx(), &parameter_environment, expr.span) {\n+    if is_copy(cx, ty, parent) {\n         span_lint_and_then(cx,\n                            CLONE_ON_COPY,\n                            expr.span,"}, {"sha": "a61cd93211d68fce258424f86ff14031bfd9880d", "filename": "tests/run-pass/associated-constant-ice.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/50c8d4e27062986e7b0a6c4d4e247c021d0a7cff/tests%2Frun-pass%2Fassociated-constant-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c8d4e27062986e7b0a6c4d4e247c021d0a7cff/tests%2Frun-pass%2Fassociated-constant-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fassociated-constant-ice.rs?ref=50c8d4e27062986e7b0a6c4d4e247c021d0a7cff", "patch": "@@ -0,0 +1,15 @@\n+#![feature(associated_consts)]\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+pub trait Trait {\n+    const CONSTANT: u8;\n+}\n+\n+impl Trait for u8 {\n+    const CONSTANT: u8 = 2;\n+}\n+\n+fn main() {\n+    println!(\"{}\", u8::CONSTANT * 10);\n+}"}, {"sha": "cbe12b066c9bea583ded3681f3a1b416c8bbef3a", "filename": "tests/ui/eq_op.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/50c8d4e27062986e7b0a6c4d4e247c021d0a7cff/tests%2Fui%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50c8d4e27062986e7b0a6c4d4e247c021d0a7cff/tests%2Fui%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feq_op.rs?ref=50c8d4e27062986e7b0a6c4d4e247c021d0a7cff", "patch": "@@ -2,7 +2,7 @@\n #![plugin(clippy)]\n \n #[deny(eq_op)]\n-#[allow(identity_op, double_parens)]\n+#[allow(identity_op, double_parens, many_single_char_names)]\n #[allow(no_effect, unused_variables, unnecessary_operation, short_circuit_statement)]\n #[deny(nonminimal_bool)]\n fn main() {\n@@ -59,4 +59,40 @@ fn main() {\n     a == a;\n     2*a.len() == 2*a.len(); // ok, functions\n     a.pop() == a.pop(); // ok, functions\n+\n+    use std::ops::BitAnd;\n+    struct X(i32);\n+    impl BitAnd for X {\n+        type Output = X;\n+        fn bitand(self, rhs: X) -> X {\n+            X(self.0 & rhs.0)\n+        }\n+    }\n+    impl<'a> BitAnd<&'a X> for X {\n+        type Output = X;\n+        fn bitand(self, rhs: &'a X) -> X {\n+            X(self.0 & rhs.0)\n+        }\n+    }\n+    let x = X(1);\n+    let y = X(2);\n+    let z = x & &y;\n+\n+    #[derive(Copy, Clone)]\n+    struct Y(i32);\n+    impl BitAnd for Y {\n+        type Output = Y;\n+        fn bitand(self, rhs: Y) -> Y {\n+            Y(self.0 & rhs.0)\n+        }\n+    }\n+    impl<'a> BitAnd<&'a Y> for Y {\n+        type Output = Y;\n+        fn bitand(self, rhs: &'a Y) -> Y {\n+            Y(self.0 & rhs.0)\n+        }\n+    }\n+    let x = Y(1);\n+    let y = Y(2);\n+    let z = x & &y;\n }"}, {"sha": "b4ece862e00b9c590db8f560fb12d05547d0936b", "filename": "tests/ui/eq_op.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/50c8d4e27062986e7b0a6c4d4e247c021d0a7cff/tests%2Fui%2Feq_op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50c8d4e27062986e7b0a6c4d4e247c021d0a7cff/tests%2Fui%2Feq_op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feq_op.stderr?ref=50c8d4e27062986e7b0a6c4d4e247c021d0a7cff", "patch": "@@ -219,5 +219,15 @@ error: equal expressions as operands to `==`\n 59 |     a == a;\n    |     ^^^^^^\n \n+warning: taken reference of right operand\n+  --> $DIR/eq_op.rs:97:13\n+   |\n+97 |     let z = x & &y;\n+   |             ^^^^^^\n+   |\n+   = note: #[warn(op_ref)] on by default\n+help: use the right value directly\n+   |     let z = y & &y;\n+\n error: aborting due to 32 previous errors\n "}, {"sha": "5448429f16471bab7633db5a3aec63cd71ed4628", "filename": "tests/ui/op_ref.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50c8d4e27062986e7b0a6c4d4e247c021d0a7cff/tests%2Fui%2Fop_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50c8d4e27062986e7b0a6c4d4e247c021d0a7cff/tests%2Fui%2Fop_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fop_ref.stderr?ref=50c8d4e27062986e7b0a6c4d4e247c021d0a7cff", "patch": "@@ -1,4 +1,4 @@\n-warning: taken reference of both operands, which is done automatically by the operator anyway\n+warning: needlessly taken reference of both operands\n   --> $DIR/op_ref.rs:13:15\n    |\n 13 |     let foo = &5 - &6;"}]}