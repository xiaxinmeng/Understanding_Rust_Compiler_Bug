{"sha": "859079ff127f8886c81152da7bb74b38f84b6797", "node_id": "C_kwDOAAsO6NoAKDg1OTA3OWZmMTI3Zjg4ODZjODExNTJkYTdiYjc0YjM4Zjg0YjY3OTc", "commit": {"author": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-05-06T02:43:30Z"}, "committer": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-05-06T02:43:30Z"}, "message": "macros: allow `Vec` fields in diagnostic derive\n\nDiagnostics can have multiple primary spans, or have subdiagnostics\nrepeated at multiple locations, so support `Vec<..>` fields in the\ndiagnostic derive which become loops in the generated code.\n\nSigned-off-by: David Wood <david.wood@huawei.com>", "tree": {"sha": "9332802074111a503a3876524d743b57e408b4fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9332802074111a503a3876524d743b57e408b4fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/859079ff127f8886c81152da7bb74b38f84b6797", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/859079ff127f8886c81152da7bb74b38f84b6797", "html_url": "https://github.com/rust-lang/rust/commit/859079ff127f8886c81152da7bb74b38f84b6797", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/859079ff127f8886c81152da7bb74b38f84b6797/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3dac70fcc093a3145c4fa3315d43012090c7968b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3dac70fcc093a3145c4fa3315d43012090c7968b", "html_url": "https://github.com/rust-lang/rust/commit/3dac70fcc093a3145c4fa3315d43012090c7968b"}], "stats": {"total": 132, "additions": 93, "deletions": 39}, "files": [{"sha": "83fc7bcde8ab47d385da4f3325726252aae1a5c2", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic.rs", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/859079ff127f8886c81152da7bb74b38f84b6797/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/859079ff127f8886c81152da7bb74b38f84b6797/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs?ref=859079ff127f8886c81152da7bb74b38f84b6797", "patch": "@@ -5,8 +5,8 @@ use crate::diagnostics::error::{\n     SessionDiagnosticDeriveError,\n };\n use crate::diagnostics::utils::{\n-    option_inner_ty, report_error_if_not_applied_to_span, type_matches_path, Applicability,\n-    FieldInfo, HasFieldMap, SetOnce,\n+    report_error_if_not_applied_to_span, type_matches_path, Applicability, FieldInfo, FieldInnerTy,\n+    HasFieldMap, SetOnce,\n };\n use proc_macro2::TokenStream;\n use quote::{format_ident, quote};\n@@ -353,35 +353,40 @@ impl SessionDiagnosticDeriveBuilder {\n         info: FieldInfo<'_>,\n     ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n         let field_binding = &info.binding.binding;\n-        let option_ty = option_inner_ty(&info.ty);\n-        let generated_code = self.generate_non_option_field_code(\n+\n+        let inner_ty = FieldInnerTy::from_type(&info.ty);\n+        let name = attr.path.segments.last().unwrap().ident.to_string();\n+        let (binding, needs_destructure) = match (name.as_str(), &inner_ty) {\n+            // `primary_span` can accept a `Vec<Span>` so don't destructure that.\n+            (\"primary_span\", FieldInnerTy::Vec(_)) => (quote! { #field_binding.clone() }, false),\n+            _ => (quote! { *#field_binding }, true),\n+        };\n+\n+        let generated_code = self.generate_inner_field_code(\n             attr,\n             FieldInfo {\n                 vis: info.vis,\n                 binding: info.binding,\n-                ty: option_ty.unwrap_or(&info.ty),\n+                ty: inner_ty.inner_type().unwrap_or(&info.ty),\n                 span: info.span,\n             },\n+            binding,\n         )?;\n \n-        if option_ty.is_none() {\n-            Ok(quote! { #generated_code })\n+        if needs_destructure {\n+            Ok(inner_ty.with(field_binding, generated_code))\n         } else {\n-            Ok(quote! {\n-                if let Some(#field_binding) = #field_binding {\n-                    #generated_code\n-                }\n-            })\n+            Ok(generated_code)\n         }\n     }\n \n-    fn generate_non_option_field_code(\n+    fn generate_inner_field_code(\n         &mut self,\n         attr: &Attribute,\n         info: FieldInfo<'_>,\n+        binding: TokenStream,\n     ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n         let diag = &self.diag;\n-        let field_binding = &info.binding.binding;\n \n         let name = attr.path.segments.last().unwrap().ident.to_string();\n         let name = name.as_str();\n@@ -397,14 +402,14 @@ impl SessionDiagnosticDeriveBuilder {\n                 \"primary_span\" => {\n                     report_error_if_not_applied_to_span(attr, &info)?;\n                     Ok(quote! {\n-                        #diag.set_span(*#field_binding);\n+                        #diag.set_span(#binding);\n                     })\n                 }\n                 \"label\" | \"note\" | \"help\" => {\n                     report_error_if_not_applied_to_span(attr, &info)?;\n-                    Ok(self.add_subdiagnostic(field_binding, name, name))\n+                    Ok(self.add_subdiagnostic(binding, name, name))\n                 }\n-                \"subdiagnostic\" => Ok(quote! { #diag.subdiagnostic(*#field_binding); }),\n+                \"subdiagnostic\" => Ok(quote! { #diag.subdiagnostic(#binding); }),\n                 _ => throw_invalid_attr!(attr, &meta, |diag| {\n                     diag\n                         .help(\"only `skip_arg`, `primary_span`, `label`, `note`, `help` and `subdiagnostic` are valid field attributes\")\n@@ -413,7 +418,7 @@ impl SessionDiagnosticDeriveBuilder {\n             Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(ref s), .. }) => match name {\n                 \"label\" | \"note\" | \"help\" => {\n                     report_error_if_not_applied_to_span(attr, &info)?;\n-                    Ok(self.add_subdiagnostic(field_binding, name, &s.value()))\n+                    Ok(self.add_subdiagnostic(binding, name, &s.value()))\n                 }\n                 _ => throw_invalid_attr!(attr, &meta, |diag| {\n                     diag.help(\"only `label`, `note` and `help` are valid field attributes\")\n@@ -509,7 +514,7 @@ impl SessionDiagnosticDeriveBuilder {\n     /// `fluent_attr_identifier`.\n     fn add_subdiagnostic(\n         &self,\n-        field_binding: &proc_macro2::Ident,\n+        field_binding: TokenStream,\n         kind: &str,\n         fluent_attr_identifier: &str,\n     ) -> TokenStream {\n@@ -520,7 +525,7 @@ impl SessionDiagnosticDeriveBuilder {\n         let fn_name = format_ident!(\"span_{}\", kind);\n         quote! {\n             #diag.#fn_name(\n-                *#field_binding,\n+                #field_binding,\n                 rustc_errors::DiagnosticMessage::fluent_attr(#slug, #fluent_attr_identifier)\n             );\n         }"}, {"sha": "65b1328682f823243b4aefed836e2d5c969f11f8", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/859079ff127f8886c81152da7bb74b38f84b6797/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/859079ff127f8886c81152da7bb74b38f84b6797/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=859079ff127f8886c81152da7bb74b38f84b6797", "patch": "@@ -5,8 +5,8 @@ use crate::diagnostics::error::{\n     SessionDiagnosticDeriveError,\n };\n use crate::diagnostics::utils::{\n-    option_inner_ty, report_error_if_not_applied_to_applicability,\n-    report_error_if_not_applied_to_span, Applicability, FieldInfo, HasFieldMap, SetOnce,\n+    report_error_if_not_applied_to_applicability, report_error_if_not_applied_to_span,\n+    Applicability, FieldInfo, FieldInnerTy, HasFieldMap, SetOnce,\n };\n use proc_macro2::TokenStream;\n use quote::{format_ident, quote};\n@@ -301,11 +301,11 @@ impl<'a> SessionSubdiagnosticDeriveBuilder<'a> {\n     ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n         let ast = binding.ast();\n \n-        let option_ty = option_inner_ty(&ast.ty);\n+        let inner_ty = FieldInnerTy::from_type(&ast.ty);\n         let info = FieldInfo {\n             vis: &ast.vis,\n             binding: binding,\n-            ty: option_ty.unwrap_or(&ast.ty),\n+            ty: inner_ty.inner_type().unwrap_or(&ast.ty),\n             span: &ast.span(),\n         };\n \n@@ -353,15 +353,7 @@ impl<'a> SessionSubdiagnosticDeriveBuilder<'a> {\n             );\n         };\n \n-        if option_ty.is_none() {\n-            Ok(quote! { #generated })\n-        } else {\n-            Ok(quote! {\n-                if let Some(#binding) = #binding {\n-                    #generated\n-                }\n-            })\n-        }\n+        Ok(inner_ty.with(binding, generated))\n     }\n \n     fn into_tokens(&mut self) -> Result<TokenStream, SessionDiagnosticDeriveError> {"}, {"sha": "aba861fc6aafa4a0954216f969e07e9da7812a39", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 55, "deletions": 6, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/859079ff127f8886c81152da7bb74b38f84b6797/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/859079ff127f8886c81152da7bb74b38f84b6797/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=859079ff127f8886c81152da7bb74b38f84b6797", "patch": "@@ -1,7 +1,7 @@\n use crate::diagnostics::error::{span_err, throw_span_err, SessionDiagnosticDeriveError};\n use proc_macro::Span;\n use proc_macro2::TokenStream;\n-use quote::{format_ident, quote};\n+use quote::{format_ident, quote, ToTokens};\n use std::collections::BTreeSet;\n use std::str::FromStr;\n use syn::{spanned::Spanned, Attribute, Meta, Type, Visibility};\n@@ -76,22 +76,71 @@ pub(crate) fn report_error_if_not_applied_to_span(\n     report_error_if_not_applied_to_ty(attr, info, &[\"rustc_span\", \"Span\"], \"Span\")\n }\n \n-/// If `ty` is an Option, returns `Some(inner type)`, otherwise returns `None`.\n-pub(crate) fn option_inner_ty(ty: &Type) -> Option<&Type> {\n-    if type_matches_path(ty, &[\"std\", \"option\", \"Option\"]) {\n+/// Inner type of a field and type of wrapper.\n+pub(crate) enum FieldInnerTy<'ty> {\n+    /// Field is wrapped in a `Option<$inner>`.\n+    Option(&'ty Type),\n+    /// Field is wrapped in a `Vec<$inner>`.\n+    Vec(&'ty Type),\n+    /// Field isn't wrapped in an outer type.\n+    None,\n+}\n+\n+impl<'ty> FieldInnerTy<'ty> {\n+    /// Returns inner type for a field, if there is one.\n+    ///\n+    /// - If `ty` is an `Option`, returns `FieldInnerTy::Option { inner: (inner type) }`.\n+    /// - If `ty` is a `Vec`, returns `FieldInnerTy::Vec { inner: (inner type) }`.\n+    /// - Otherwise returns `None`.\n+    pub(crate) fn from_type(ty: &'ty Type) -> Self {\n+        let variant: &dyn Fn(&'ty Type) -> FieldInnerTy<'ty> =\n+            if type_matches_path(ty, &[\"std\", \"option\", \"Option\"]) {\n+                &FieldInnerTy::Option\n+            } else if type_matches_path(ty, &[\"std\", \"vec\", \"Vec\"]) {\n+                &FieldInnerTy::Vec\n+            } else {\n+                return FieldInnerTy::None;\n+            };\n+\n         if let Type::Path(ty_path) = ty {\n             let path = &ty_path.path;\n             let ty = path.segments.iter().last().unwrap();\n             if let syn::PathArguments::AngleBracketed(bracketed) = &ty.arguments {\n                 if bracketed.args.len() == 1 {\n                     if let syn::GenericArgument::Type(ty) = &bracketed.args[0] {\n-                        return Some(ty);\n+                        return variant(ty);\n                     }\n                 }\n             }\n         }\n+\n+        unreachable!();\n+    }\n+\n+    /// Returns `Option` containing inner type if there is one.\n+    pub(crate) fn inner_type(&self) -> Option<&'ty Type> {\n+        match self {\n+            FieldInnerTy::Option(inner) | FieldInnerTy::Vec(inner) => Some(inner),\n+            FieldInnerTy::None => None,\n+        }\n+    }\n+\n+    /// Surrounds `inner` with destructured wrapper type, exposing inner type as `binding`.\n+    pub(crate) fn with(&self, binding: impl ToTokens, inner: impl ToTokens) -> TokenStream {\n+        match self {\n+            FieldInnerTy::Option(..) => quote! {\n+                if let Some(#binding) = #binding {\n+                    #inner\n+                }\n+            },\n+            FieldInnerTy::Vec(..) => quote! {\n+                for #binding in #binding {\n+                    #inner\n+                }\n+            },\n+            FieldInnerTy::None => quote! { #inner },\n+        }\n     }\n-    None\n }\n \n /// Field information passed to the builder. Deliberately omits attrs to discourage the"}, {"sha": "c63410fa35bde6d91233d06a0b8c1ef003cf57f1", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/859079ff127f8886c81152da7bb74b38f84b6797/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/859079ff127f8886c81152da7bb74b38f84b6797/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs?ref=859079ff127f8886c81152da7bb74b38f84b6797", "patch": "@@ -474,3 +474,11 @@ struct Subdiagnostic {\n     #[subdiagnostic]\n     note: Note,\n }\n+\n+#[derive(SessionDiagnostic)]\n+#[error(code = \"E0123\", slug = \"foo\")]\n+struct VecField {\n+    #[primary_span]\n+    #[label]\n+    spans: Vec<Span>,\n+}"}]}