{"sha": "069681a95327d8b49a26a8fd60aa6a9ecaaf52c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2OTY4MWE5NTMyN2Q4YjQ5YTI2YThmZDYwYWE2YTllY2FhZjUyYzQ=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-06-21T06:15:48Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-06-21T06:15:48Z"}, "message": "vec exmaple maybe", "tree": {"sha": "17e0f3d83cdb5a3fb3bad64657a448e0c23e09c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17e0f3d83cdb5a3fb3bad64657a448e0c23e09c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/069681a95327d8b49a26a8fd60aa6a9ecaaf52c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/069681a95327d8b49a26a8fd60aa6a9ecaaf52c4", "html_url": "https://github.com/rust-lang/rust/commit/069681a95327d8b49a26a8fd60aa6a9ecaaf52c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/069681a95327d8b49a26a8fd60aa6a9ecaaf52c4/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f531d9d7e058222cb13a9987a80431906d524b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f531d9d7e058222cb13a9987a80431906d524b9", "html_url": "https://github.com/rust-lang/rust/commit/8f531d9d7e058222cb13a9987a80431906d524b9"}], "stats": {"total": 200, "additions": 174, "deletions": 26}, "files": [{"sha": "7467decb490b93e95ab2c91932c6ff794a08d52b", "filename": "conversions.md", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/069681a95327d8b49a26a8fd60aa6a9ecaaf52c4/conversions.md", "raw_url": "https://github.com/rust-lang/rust/raw/069681a95327d8b49a26a8fd60aa6a9ecaaf52c4/conversions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/conversions.md?ref=069681a95327d8b49a26a8fd60aa6a9ecaaf52c4", "patch": "@@ -168,6 +168,8 @@ applied.\n \n \n \n+TODO: receiver coercions?\n+\n \n # Casts\n \n@@ -212,11 +214,10 @@ For numeric casts, there are quite a few cases to consider:\n * casting from a larger integer to a smaller integer (e.g. u8 -> u32) will\n     * zero-extend if the target is unsigned\n     * sign-extend if the target is signed\n-* casting from a float to an integer will:\n-    * round the float towards zero if finite\n+* casting from a float to an integer will round the float towards zero\n     * **NOTE: currently this will cause Undefined Behaviour if the rounded\n       value cannot be represented by the target integer type**. This is a bug\n-      and will be fixed.\n+      and will be fixed. (TODO: figure out what Inf and NaN do)\n * casting from an integer to float will produce the floating point representation\n   of the integer, rounded if necessary (rounding strategy unspecified).\n * casting from an f32 to an f64 is perfect and lossless.\n@@ -226,21 +227,41 @@ For numeric casts, there are quite a few cases to consider:\n       is finite but larger or smaller than the largest or smallest finite\n       value representable by f32**. This is a bug and will be fixed.\n \n-The casts involving rawptrs also allow us to completely bypass type-safety\n-by re-interpretting a pointer of T to a pointer of U for arbitrary types, as\n-well as interpret integers as addresses. However it is impossible to actually\n-*capitalize* on this violation in Safe Rust, because derefencing a raw ptr is\n-`unsafe`.\n-\n-\n \n \n # Conversion Traits\n \n-TODO\n+TODO?\n \n \n \n \n # Transmuting Types\n \n+Get out of our way type system! We're going to reinterpret these bits or die\n+trying! Even though this book is all about doing things that are unsafe, I really\n+can't emphasize that you should deeply think about finding Another Way than the\n+operations covered in this section. This is really, truly, the most horribly\n+unsafe thing you can do in Rust. The railguards here are dental floss.\n+\n+`mem::transmute<T, U>` takes a value of type `T` and reinterprets it to have\n+type `U`. The only restriction is that the `T` and `U` are verified to have the\n+same size. The ways to cause Undefined Behaviour with this are mind boggling.\n+\n+* First and foremost, creating an instance of *any* type with an invalid state\n+  is going to cause arbitrary chaos that can't really be predicted.\n+* Transmute has an overloaded return type. If you do not specify the return type\n+  it may produce a surprising type to satisfy inference.\n+* Making a primitive with an invalid value is UB\n+* Transmuting between non-repr(C) types is UB\n+* Transmuting an & to &mut is UB\n+* Transmuting to a reference without an explicitly provided lifetime\n+  produces an [unbound lifetime](lifetimes.html#unbounded-lifetimes)\n+\n+`mem::transmute_copy<T, U>` somehow manages to be *even more* wildly unsafe than\n+this. It copies `size_of<U>` bytes out of an `&T` and interprets them as a `U`.\n+The size check that `mem::transmute` has is gone (as it may be valid to copy\n+out a prefix), though it is Undefined Behaviour for `U` to be larger than `T`.\n+\n+Also of course you can get most of the functionality of these functions using\n+pointer casts."}, {"sha": "f380f98a7dc0bcb93778e9bc4a6b5fe66bf9b2c4", "filename": "intro.md", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/069681a95327d8b49a26a8fd60aa6a9ecaaf52c4/intro.md", "raw_url": "https://github.com/rust-lang/rust/raw/069681a95327d8b49a26a8fd60aa6a9ecaaf52c4/intro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/intro.md?ref=069681a95327d8b49a26a8fd60aa6a9ecaaf52c4", "patch": "@@ -23,6 +23,7 @@ stack or heap, we will not explain the syntax.\n * [Uninitialized Memory](uninitialized.html)\n * [Ownership-oriented resource management (RAII)](raii.html)\n * [Concurrency](concurrency.html)\n+* [Example: Implementing Vec](vec.html)\n \n \n \n@@ -232,10 +233,6 @@ struct Vec<T> {\n // We currently live in a nice imaginary world of only postive fixed-size\n // types.\n impl<T> Vec<T> {\n-    fn new() -> Self {\n-        Vec { ptr: heap::EMPTY, len: 0, cap: 0 }\n-    }\n-\n     fn push(&mut self, elem: T) {\n         if self.len == self.cap {\n             // not important for this example\n@@ -246,17 +243,6 @@ impl<T> Vec<T> {\n             self.len += 1;\n         }\n     }\n-\n-    fn pop(&mut self) -> Option<T> {\n-        if self.len > 0 {\n-            self.len -= 1;\n-            unsafe {\n-                Some(ptr::read(self.ptr.offset(self.len as isize)))\n-            }\n-        } else {\n-            None\n-        }\n-    }\n }\n ```\n "}, {"sha": "116626ffc39e4830759f5fc3013db399c216e5b5", "filename": "vec.md", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/069681a95327d8b49a26a8fd60aa6a9ecaaf52c4/vec.md", "raw_url": "https://github.com/rust-lang/rust/raw/069681a95327d8b49a26a8fd60aa6a9ecaaf52c4/vec.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/vec.md?ref=069681a95327d8b49a26a8fd60aa6a9ecaaf52c4", "patch": "@@ -0,0 +1,141 @@\n+% Example: Implementing Vec\n+\n+To bring everything together, we're going to write `std::Vec` from scratch.\n+Because the all the best tools for writing unsafe code are unstable, this\n+project will only work on nightly (as of Rust 1.2.0).\n+\n+First off, we need to come up with the struct layout. Naively we want this\n+design:\n+\n+```\n+struct Vec<T> {\n+\tptr: *mut T,\n+\tcap: usize,\n+\tlen: usize,\n+}\n+```\n+\n+And indeed this would compile. Unfortunately, it would be incorrect. The compiler\n+will give us too strict variance, so e.g. an `&Vec<&'static str>` couldn't be used\n+where an `&Vec<&'a str>` was expected. More importantly, it will give incorrect\n+ownership information to dropck, as it will conservatively assume we don't own\n+any values of type `T`. See [the chapter on ownership and lifetimes]\n+(lifetimes.html) for details.\n+\n+As we saw in the lifetimes chapter, we should use `Unique<T>` in place of `*mut T`\n+when we have a raw pointer to an allocation we own:\n+\n+\n+```\n+#![feature(unique)]\n+\n+use std::ptr::Unique;\n+\n+pub struct Vec<T> {\n+    ptr: Unique<T>,\n+    cap: usize,\n+    len: usize,\n+}\n+```\n+\n+As a recap, Unique is a wrapper around a raw pointer that declares that:\n+\n+* We own at least one value of type `T`\n+* We are Send/Sync iff `T` is Send/Sync\n+* Our pointer is never null (and therefore `Option<Vec>` is null-pointer-optimized)\n+\n+That last point is subtle. First, it makes `Unique::new` unsafe to call, because\n+putting `null` inside of it is Undefined Behaviour. It also throws a\n+wrench in an important feature of Vec (and indeed all of the std collections):\n+an empty Vec doesn't actually allocate at all. So if we can't allocate,\n+but also can't put a null pointer in `ptr`, what do we do in\n+`Vec::new`? Well, we just put some other garbage in there!\n+\n+This is perfectly fine because we already have `cap == 0` as our sentinel for no\n+allocation. We don't even need to handle it specially in almost any code because\n+we usually need to check if `cap > len` or `len > 0` anyway. The traditional\n+Rust value to put here is `0x01`. The standard library actually exposes this\n+as `std::rt::heap::EMPTY`. There are quite a few places where we'll want to use\n+`heap::EMPTY` because there's no real allocation to talk about but `null` would\n+make the compiler angry.\n+\n+All of the `heap` API is totally unstable under the `alloc` feature, though.\n+We could trivially define `heap::EMPTY` ourselves, but we'll want the rest of\n+the `heap` API anyway, so let's just get that dependency over with.\n+\n+So:\n+\n+```rust\n+#![feature(alloc)]\n+\n+use std::rt::heap::EMPTY;\n+use std::mem;\n+\n+impl<T> Vec<T> {\n+\tfn new() -> Self {\n+\t\tassert!(mem::size_of::<T>() != 0, \"We're not ready to handle ZSTs\");\n+\t\tunsafe {\n+\t\t\t// need to cast EMPTY to the actual ptr type we want, let\n+\t\t\t// inference handle it.\n+\t\t\tVec { ptr: Unique::new(heap::EMPTY as *mut _), len: 0, cap: 0 }\n+\t\t}\n+\t}\n+}\n+```\n+\n+I slipped in that assert there because zero-sized types will require some\n+special handling throughout our code, and I want to defer the issue for now.\n+Without this assert, some of our early drafts will do some Very Bad Things.\n+\n+Next we need to figure out what to actually do when we *do* want space. For that,\n+we'll need to use the rest of the heap APIs. These basically allow us to\n+talk directly to Rust's instance of jemalloc.\n+\n+We'll also need a way to handle out-of-memory conditions. The standard library\n+calls the `abort` intrinsic, but calling intrinsics from normal Rust code is a\n+pretty bad idea. Unfortunately, the `abort` exposed by the standard library\n+allocates. Not something we want to do during `oom`! Instead, we'll call\n+`std::process::exit`.\n+\n+```rust\n+fn oom() {\n+    ::std::process::exit(-9999);\n+}\n+```\n+\n+Okay, now we can write growing:\n+\n+```rust\n+fn grow(&mut self) {\n+    unsafe {\n+        let align = mem::min_align_of::<T>();\n+        let elem_size = mem::size_of::<T>();\n+\n+        let (new_cap, ptr) = if self.cap == 0 {\n+            let ptr = heap::allocate(elem_size, align);\n+            (1, ptr)\n+        } else {\n+            let new_cap = 2 * self.cap;\n+            let ptr = heap::reallocate(*self.ptr as *mut _,\n+                                        self.cap * elem_size,\n+                                        new_cap * elem_size,\n+                                        align);\n+            (new_cap, ptr)\n+        };\n+\n+        // If allocate or reallocate fail, we'll get `null` back\n+        if ptr.is_null() { oom() }\n+\n+        self.ptr = Unique::new(ptr as *mut _);\n+        self.cap = new_cap;\n+    }\n+}\n+```\n+\n+There's nothing particularly tricky in here: if we're totally empty, we need\n+to do a fresh allocation. Otherwise, we need to reallocate the current pointer.\n+Although we have a subtle bug here with the multiply overflow.\n+\n+TODO: rest of this\n+\n+"}]}