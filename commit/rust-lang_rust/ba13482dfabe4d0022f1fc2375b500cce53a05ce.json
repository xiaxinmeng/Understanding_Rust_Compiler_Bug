{"sha": "ba13482dfabe4d0022f1fc2375b500cce53a05ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhMTM0ODJkZmFiZTRkMDAyMmYxZmMyMzc1YjUwMGNjZTUzYTA1Y2U=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-06-20T19:13:22Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-07-08T17:53:44Z"}, "message": "update ptr intrinsics and rewrite vec routines to be more correct.\n\nIn particular, it is not valid to go around passing uninitialized or zero'd\nmemory as arguments. Rust should generally be free to assume that the arguments\nit gets are valid input values, but the output of intrinsics::uninit() and\nintrinsics::init() are not (e.g., an @T is just null, leading to an error\nif we should try to increment the ref count).", "tree": {"sha": "83ea14cb1ba75f72b9de1aed3e3dfe1a16a76f06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83ea14cb1ba75f72b9de1aed3e3dfe1a16a76f06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba13482dfabe4d0022f1fc2375b500cce53a05ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba13482dfabe4d0022f1fc2375b500cce53a05ce", "html_url": "https://github.com/rust-lang/rust/commit/ba13482dfabe4d0022f1fc2375b500cce53a05ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba13482dfabe4d0022f1fc2375b500cce53a05ce/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1670a8cfb13fd384d9fd4ca47034cef99118c7a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/1670a8cfb13fd384d9fd4ca47034cef99118c7a7", "html_url": "https://github.com/rust-lang/rust/commit/1670a8cfb13fd384d9fd4ca47034cef99118c7a7"}], "stats": {"total": 184, "additions": 144, "deletions": 40}, "files": [{"sha": "add2bbd7d44f494b0bcd38a07b196a4656f54cf6", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ba13482dfabe4d0022f1fc2375b500cce53a05ce/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba13482dfabe4d0022f1fc2375b500cce53a05ce/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=ba13482dfabe4d0022f1fc2375b500cce53a05ce", "patch": "@@ -142,6 +142,30 @@ pub unsafe fn set_memory<T>(dst: *mut T, c: u8, count: uint) {\n     memset64(dst, c, count as u64);\n }\n \n+/**\n+ * Zeroes out `count` bytes of memory at `dst`\n+ */\n+#[inline]\n+#[cfg(not(stage0))]\n+pub unsafe fn zero_memory<T>(dst: *mut T, count: uint) {\n+    set_memory(dst, 0, count);\n+}\n+\n+/**\n+ * Zeroes out `count * size_of::<T>` bytes of memory at `dst`\n+ */\n+#[inline]\n+#[cfg(stage0)]\n+pub unsafe fn zero_memory<T>(dst: *mut T, count: uint) {\n+    let mut count = count * sys::size_of::<T>();\n+    let mut dst = dst as *mut u8;\n+    while count > 0 {\n+        *dst = 0;\n+        dst = mut_offset(dst, 1);\n+        count -= 1;\n+    }\n+}\n+\n /**\n  * Swap the values at two mutable locations of the same type, without\n  * deinitialising or copying either one.\n@@ -172,6 +196,32 @@ pub unsafe fn replace_ptr<T>(dest: *mut T, mut src: T) -> T {\n     src\n }\n \n+/**\n+ * Reads the value from `*src` and returns it. Does not copy `*src`.\n+ */\n+#[inline(always)]\n+pub unsafe fn read_ptr<T>(src: *mut T) -> T {\n+    let mut tmp: T = intrinsics::uninit();\n+    let t: *mut T = &mut tmp;\n+    copy_memory(t, src, 1);\n+    tmp\n+}\n+\n+/**\n+ * Reads the value from `*src` and nulls it out.\n+ * This currently prevents destructors from executing.\n+ */\n+#[inline(always)]\n+pub unsafe fn read_and_zero_ptr<T>(dest: *mut T) -> T {\n+    // Copy the data out from `dest`:\n+    let tmp = read_ptr(dest);\n+\n+    // Now zero out `dest`:\n+    zero_memory(dest, 1);\n+\n+    tmp\n+}\n+\n /// Transform a region pointer - &T - to an unsafe pointer - *T.\n #[inline]\n pub fn to_unsafe_ptr<T>(thing: &T) -> *T {"}, {"sha": "cacb3156b75c577dc7fad460e226dfd952bf31b6", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 94, "deletions": 40, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/ba13482dfabe4d0022f1fc2375b500cce53a05ce/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba13482dfabe4d0022f1fc2375b500cce53a05ce/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=ba13482dfabe4d0022f1fc2375b500cce53a05ce", "patch": "@@ -1256,16 +1256,15 @@ impl<T> OwnedVector<T> for ~[T] {\n     /// ~~~\n     #[inline]\n     fn push_all_move(&mut self, mut rhs: ~[T]) {\n-        let new_len = self.len() + rhs.len();\n+        let self_len = self.len();\n+        let rhs_len = rhs.len();\n+        let new_len = self_len + rhs_len;\n         self.reserve(new_len);\n-        unsafe {\n-            do rhs.as_mut_buf |p, len| {\n-                for uint::range(0, len) |i| {\n-                    let x = ptr::replace_ptr(ptr::mut_offset(p, i),\n-                                             intrinsics::uninit());\n-                    self.push(x);\n-                }\n-            }\n+        unsafe { // Note: infallible.\n+            let self_p = vec::raw::to_mut_ptr(*self);\n+            let rhs_p = vec::raw::to_ptr(rhs);\n+            ptr::copy_memory(ptr::mut_offset(self_p, self_len), rhs_p, rhs_len);\n+            raw::set_len(self, new_len);\n             raw::set_len(&mut rhs, 0);\n         }\n     }\n@@ -1277,9 +1276,8 @@ impl<T> OwnedVector<T> for ~[T] {\n             ln => {\n                 let valptr = ptr::to_mut_unsafe_ptr(&mut self[ln - 1u]);\n                 unsafe {\n-                    let val = ptr::replace_ptr(valptr, intrinsics::init());\n-                    raw::set_len(self, ln - 1u);\n-                    Some(val)\n+                    raw::set_len(v, ln - 1u);\n+                    ptr::read_ptr(valptr)\n                 }\n             }\n         }\n@@ -1410,7 +1408,7 @@ impl<T> OwnedVector<T> for ~[T] {\n             unsafe {\n                 // This loop is optimized out for non-drop types.\n                 for uint::range(newlen, oldlen) |i| {\n-                    ptr::replace_ptr(ptr::mut_offset(p, i), intrinsics::uninit());\n+                    ptr::read_and_zero_ptr(ptr::mut_offset(p, i))\n                 }\n             }\n         }\n@@ -1555,37 +1553,93 @@ pub trait OwnedEqVector<T:Eq> {\n \n impl<T:Eq> OwnedEqVector<T> for ~[T] {\n     /**\n-     * Remove consecutive repeated elements from a vector; if the vector is\n-     * sorted, this removes all duplicates.\n-     */\n-    pub fn dedup(&mut self) {\n+    * Remove consecutive repeated elements from a vector; if the vector is\n+    * sorted, this removes all duplicates.\n+    */\n+    pub fn dedup<T:Eq>(&mut self) {\n         unsafe {\n-            if self.len() == 0 { return; }\n-            let mut last_written = 0;\n-            let mut next_to_read = 1;\n-            do self.as_mut_buf |p, ln| {\n-                // last_written < next_to_read <= ln\n-                while next_to_read < ln {\n-                    // last_written < next_to_read < ln\n-                    if *ptr::mut_offset(p, next_to_read) ==\n-                        *ptr::mut_offset(p, last_written) {\n-                        ptr::replace_ptr(ptr::mut_offset(p, next_to_read),\n-                                         intrinsics::uninit());\n-                    } else {\n-                        last_written += 1;\n-                        // last_written <= next_to_read < ln\n-                        if next_to_read != last_written {\n-                            ptr::swap_ptr(ptr::mut_offset(p, last_written),\n-                                          ptr::mut_offset(p, next_to_read));\n-                        }\n+            // Although we have a mutable reference to `self`, we cannot make\n+            // *arbitrary* changes. There exists the possibility that this\n+            // vector is contained with an `@mut` box and hence is still\n+            // readable by the outside world during the `Eq` comparisons.\n+            // Moreover, those comparisons could fail, so we must ensure\n+            // that the vector is in a valid state at all time.\n+            //\n+            // The way that we handle this is by using swaps; we iterate\n+            // over all the elements, swapping as we go so that at the end\n+            // the elements we wish to keep are in the front, and those we\n+            // wish to reject are at the back. We can then truncate the\n+            // vector. This operation is still O(n).\n+            //\n+            // Example: We start in this state, where `r` represents \"next\n+            // read\" and `w` represents \"next_write`.\n+            //\n+            //           r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //           w\n+            //\n+            // Comparing self[r] against self[w-1], tis is not a duplicate, so\n+            // we swap self[r] and self[w] (no effect as r==w) and then increment both\n+            // r and w, leaving us with:\n+            //\n+            //               r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //               w\n+            //\n+            // Comparing self[r] against self[w-1], this value is a duplicate,\n+            // so we increment `r` but leave everything else unchanged:\n+            //\n+            //                   r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //               w\n+            //\n+            // Comparing self[r] against self[w-1], this is not a duplicate,\n+            // so swap self[r] and self[w] and advance r and w:\n+            //\n+            //                       r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 2 | 1 | 3 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //                   w\n+            //\n+            // Not a duplicate, repeat:\n+            //\n+            //                           r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 2 | 3 | 1 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //                       w\n+            //\n+            // Duplicate, advance r. End of vec. Truncate to w.\n+\n+            let ln = self.len();\n+            if ln < 1 { return; }\n+\n+            // Avoid bounds checks by using unsafe pointers.\n+            let p = vec::raw::to_mut_ptr(*self);\n+            let mut r = 1;\n+            let mut w = 1;\n+\n+            while r < ln {\n+                let p_r = ptr::mut_offset(p, r);\n+                let p_wm1 = ptr::mut_offset(p, w - 1);\n+                if *p_r != *p_wm1 {\n+                    if r != w {\n+                        let p_w = ptr::mut_offset(p_wm1, 1);\n+                        util::swap(&mut *p_r, &mut *p_w);\n                     }\n-                    // last_written <= next_to_read < ln\n-                    next_to_read += 1;\n-                    // last_written < next_to_read <= ln\n+                    w += 1;\n                 }\n+                r += 1;\n             }\n-            // last_written < next_to_read == ln\n-            raw::set_len(self, last_written + 1);\n+\n+            self.truncate(w);\n         }\n     }\n }"}]}