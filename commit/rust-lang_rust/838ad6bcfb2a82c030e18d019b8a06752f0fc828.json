{"sha": "838ad6bcfb2a82c030e18d019b8a06752f0fc828", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzOGFkNmJjZmIyYTgyYzAzMGUxOGQwMTliOGEwNjc1MmYwZmM4Mjg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-02-23T10:09:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-23T10:09:35Z"}, "message": "Merge #3279\n\n3279: Add basic parameter name hints heuristics r=matklad a=SomeoneToIgnore\n\n\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>", "tree": {"sha": "8291c9a198751b4c31e4de0dbf6cb3d7b69c723c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8291c9a198751b4c31e4de0dbf6cb3d7b69c723c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/838ad6bcfb2a82c030e18d019b8a06752f0fc828", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeUk9fCRBK7hj4Ov3rIwAAdHIIACrs5zeZGnn1glAaZvBwl3mc\n0qQQzpUd8Rs2Tvx5sBUenHfLTFfhX2AxGZDXVBUf6rfah2HCBrh+ps8eTrvYmY4t\njCTfzz8LCIkPnm8A5ycNCTHRSstbMMac62sc6D7M5rwL0CA/3SeegXPRoNKjA9c7\ndJYOhrLFS5+tMh/osWns+Ws0SPCRUKUaL/0WrlFjKT9e0DDtH/VelnLp4aInwtZ3\nMIFzi9BY9D3XNWH8lRyhUXrIHZvGFJxGX8Ti4EmWT7nl5QyPEPWFW5Uk3SNNGhLP\npHWohtdjO3yFwK3aK4lPlnThfnfftmhe9FVFBQLPYUti3ctKOfLRFMH0+V+I+Jw=\n=rDGH\n-----END PGP SIGNATURE-----\n", "payload": "tree 8291c9a198751b4c31e4de0dbf6cb3d7b69c723c\nparent 58d44c6ba2de32a31a09bbcaf61365a69b69374c\nparent b2a7b29bb9e195e75ad04dc69c572d02f98fe5ce\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1582452575 +0000\ncommitter GitHub <noreply@github.com> 1582452575 +0000\n\nMerge #3279\n\n3279: Add basic parameter name hints heuristics r=matklad a=SomeoneToIgnore\n\n\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/838ad6bcfb2a82c030e18d019b8a06752f0fc828", "html_url": "https://github.com/rust-lang/rust/commit/838ad6bcfb2a82c030e18d019b8a06752f0fc828", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/838ad6bcfb2a82c030e18d019b8a06752f0fc828/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58d44c6ba2de32a31a09bbcaf61365a69b69374c", "url": "https://api.github.com/repos/rust-lang/rust/commits/58d44c6ba2de32a31a09bbcaf61365a69b69374c", "html_url": "https://github.com/rust-lang/rust/commit/58d44c6ba2de32a31a09bbcaf61365a69b69374c"}, {"sha": "b2a7b29bb9e195e75ad04dc69c572d02f98fe5ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2a7b29bb9e195e75ad04dc69c572d02f98fe5ce", "html_url": "https://github.com/rust-lang/rust/commit/b2a7b29bb9e195e75ad04dc69c572d02f98fe5ce"}], "stats": {"total": 229, "additions": 188, "deletions": 41}, "files": [{"sha": "2c4c932de9028bcc6ce2d6829f5a85d7338b3323", "filename": "crates/ra_ide/src/display/function_signature.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/838ad6bcfb2a82c030e18d019b8a06752f0fc828/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/838ad6bcfb2a82c030e18d019b8a06752f0fc828/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs?ref=838ad6bcfb2a82c030e18d019b8a06752f0fc828", "patch": "@@ -38,6 +38,8 @@ pub struct FunctionSignature {\n     pub ret_type: Option<String>,\n     /// Where predicates\n     pub where_predicates: Vec<String>,\n+    /// Self param presence\n+    pub has_self_param: bool,\n }\n \n impl FunctionSignature {\n@@ -78,6 +80,7 @@ impl FunctionSignature {\n                 generic_parameters: generic_parameters(&node),\n                 where_predicates: where_predicates(&node),\n                 doc: None,\n+                has_self_param: false,\n             }\n             .with_doc_opt(st.docs(db)),\n         )\n@@ -115,6 +118,7 @@ impl FunctionSignature {\n                 generic_parameters: vec![],\n                 where_predicates: vec![],\n                 doc: None,\n+                has_self_param: false,\n             }\n             .with_doc_opt(variant.docs(db)),\n         )\n@@ -136,6 +140,7 @@ impl FunctionSignature {\n                 generic_parameters: vec![],\n                 where_predicates: vec![],\n                 doc: None,\n+                has_self_param: false,\n             }\n             .with_doc_opt(macro_def.docs(db)),\n         )\n@@ -144,16 +149,18 @@ impl FunctionSignature {\n \n impl From<&'_ ast::FnDef> for FunctionSignature {\n     fn from(node: &ast::FnDef) -> FunctionSignature {\n-        fn param_list(node: &ast::FnDef) -> Vec<String> {\n+        fn param_list(node: &ast::FnDef) -> (bool, Vec<String>) {\n             let mut res = vec![];\n+            let mut has_self_param = false;\n             if let Some(param_list) = node.param_list() {\n                 if let Some(self_param) = param_list.self_param() {\n+                    has_self_param = true;\n                     res.push(self_param.syntax().text().to_string())\n                 }\n \n                 res.extend(param_list.params().map(|param| param.syntax().text().to_string()));\n             }\n-            res\n+            (has_self_param, res)\n         }\n \n         fn param_name_list(node: &ast::FnDef) -> Vec<String> {\n@@ -183,6 +190,8 @@ impl From<&'_ ast::FnDef> for FunctionSignature {\n             res\n         }\n \n+        let (has_self_param, parameters) = param_list(node);\n+\n         FunctionSignature {\n             kind: CallableKind::Function,\n             visibility: node.visibility().map(|n| n.syntax().text().to_string()),\n@@ -191,12 +200,13 @@ impl From<&'_ ast::FnDef> for FunctionSignature {\n                 .ret_type()\n                 .and_then(|r| r.type_ref())\n                 .map(|n| n.syntax().text().to_string()),\n-            parameters: param_list(node),\n+            parameters,\n             parameter_names: param_name_list(node),\n             generic_parameters: generic_parameters(node),\n             where_predicates: where_predicates(node),\n             // docs are processed separately\n             doc: None,\n+            has_self_param,\n         }\n     }\n }"}, {"sha": "a484dfdebfde745cd9ce641335f676a98bb9cf34", "filename": "crates/ra_ide/src/inlay_hints.rs", "status": "modified", "additions": 175, "deletions": 38, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/838ad6bcfb2a82c030e18d019b8a06752f0fc828/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/838ad6bcfb2a82c030e18d019b8a06752f0fc828/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs?ref=838ad6bcfb2a82c030e18d019b8a06752f0fc828", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-use hir::{Function, HirDisplay, SourceAnalyzer, SourceBinder};\n+use hir::{HirDisplay, SourceAnalyzer, SourceBinder};\n use once_cell::unsync::Lazy;\n use ra_ide_db::RootDatabase;\n use ra_prof::profile;\n@@ -112,58 +112,74 @@ fn get_param_name_hints(\n     // we need args len to determine whether to skip or not the &self parameter\n     .collect::<Vec<_>>();\n \n-    let (has_self_param, fn_signature) = get_fn_signature(db, analyzer, &expr)?;\n-    let parameters = if has_self_param && fn_signature.parameter_names.len() > args.len() {\n-        fn_signature.parameter_names.into_iter().skip(1)\n-    } else {\n-        fn_signature.parameter_names.into_iter().skip(0)\n-    };\n-\n-    let hints =\n-        parameters\n-            .zip(args)\n-            .filter_map(|(param, arg)| {\n-                if !param.is_empty() {\n-                    Some((arg.syntax().text_range(), param))\n-                } else {\n-                    None\n-                }\n-            })\n-            .map(|(range, param_name)| InlayHint {\n-                range,\n-                kind: InlayKind::ParameterHint,\n-                label: param_name.into(),\n-            });\n+    let fn_signature = get_fn_signature(db, analyzer, &expr)?;\n+    let n_params_to_skip =\n+        if fn_signature.has_self_param && fn_signature.parameter_names.len() > args.len() {\n+            1\n+        } else {\n+            0\n+        };\n+    let parameters = fn_signature.parameter_names.iter().skip(n_params_to_skip);\n+\n+    let hints = parameters\n+        .zip(args)\n+        .filter(|(param, arg)| {\n+            should_show_param_hint(&fn_signature, param, &arg.syntax().to_string())\n+        })\n+        .map(|(param_name, arg)| InlayHint {\n+            range: arg.syntax().text_range(),\n+            kind: InlayKind::ParameterHint,\n+            label: param_name.into(),\n+        });\n \n     acc.extend(hints);\n     Some(())\n }\n \n+fn should_show_param_hint(\n+    fn_signature: &FunctionSignature,\n+    param_name: &str,\n+    argument_string: &str,\n+) -> bool {\n+    if param_name.is_empty() || argument_string.ends_with(param_name) {\n+        return false;\n+    }\n+\n+    let parameters_len = if fn_signature.has_self_param {\n+        fn_signature.parameters.len() - 1\n+    } else {\n+        fn_signature.parameters.len()\n+    };\n+    // avoid displaying hints for common functions like map, filter, etc.\n+    if parameters_len == 1 && (param_name.len() == 1 || param_name == \"predicate\") {\n+        return false;\n+    }\n+\n+    true\n+}\n+\n fn get_fn_signature(\n     db: &RootDatabase,\n     analyzer: &SourceAnalyzer,\n     expr: &ast::Expr,\n-) -> Option<(bool, FunctionSignature)> {\n+) -> Option<FunctionSignature> {\n     match expr {\n         ast::Expr::CallExpr(expr) => {\n             // FIXME: Type::as_callable is broken for closures\n             let callable_def = analyzer.type_of(db, &expr.expr()?)?.as_callable()?;\n             match callable_def {\n                 hir::CallableDef::FunctionId(it) => {\n-                    let fn_def: Function = it.into();\n-                    Some((fn_def.has_self_param(db), FunctionSignature::from_hir(db, fn_def)))\n+                    Some(FunctionSignature::from_hir(db, it.into()))\n                 }\n-                hir::CallableDef::StructId(it) => FunctionSignature::from_struct(db, it.into())\n-                    .map(|signature| (false, signature)),\n+                hir::CallableDef::StructId(it) => FunctionSignature::from_struct(db, it.into()),\n                 hir::CallableDef::EnumVariantId(it) => {\n                     FunctionSignature::from_enum_variant(db, it.into())\n-                        .map(|signature| (false, signature))\n                 }\n             }\n         }\n         ast::Expr::MethodCallExpr(expr) => {\n             let fn_def = analyzer.resolve_method_call(&expr)?;\n-            Some((fn_def.has_self_param(db), FunctionSignature::from_hir(db, fn_def)))\n+            Some(FunctionSignature::from_hir(db, fn_def))\n         }\n         _ => None,\n     }\n@@ -723,12 +739,42 @@ fn main() {\n     fn function_call_parameter_hint() {\n         let (analysis, file_id) = single_file(\n             r#\"\n+enum CustomOption<T> {\n+    None,\n+    Some(T),\n+}\n+\n+struct FileId {}\n+struct SmolStr {}\n+\n+impl From<&str> for SmolStr {\n+    fn from(_: &str) -> Self {\n+        unimplemented!()\n+    }\n+}\n+\n+struct TextRange {}\n+struct SyntaxKind {}\n+struct NavigationTarget {}\n+\n struct Test {}\n \n impl Test {\n     fn method(&self, mut param: i32) -> i32 {\n         param * 2\n     }\n+\n+    fn from_syntax(\n+        file_id: FileId,\n+        name: SmolStr,\n+        focus_range: CustomOption<TextRange>,\n+        full_range: TextRange,\n+        kind: SyntaxKind,\n+        docs: CustomOption<String>,\n+        description: CustomOption<String>,\n+    ) -> NavigationTarget {\n+        NavigationTarget {}\n+    }\n }\n \n fn test_func(mut foo: i32, bar: i32, msg: &str, _: i32, last: i32) -> i32 {\n@@ -741,53 +787,144 @@ fn main() {\n     let t: Test = Test {};\n     t.method(123);\n     Test::method(&t, 3456);\n+\n+    Test::from_syntax(\n+        FileId {},\n+        \"impl\".into(),\n+        CustomOption::None,\n+        TextRange {},\n+        SyntaxKind {},\n+        CustomOption::None,\n+        CustomOption::None,\n+    );\n }\"#,\n         );\n \n         assert_debug_snapshot!(analysis.inlay_hints(file_id, None).unwrap(), @r###\"\n         [\n             InlayHint {\n-                range: [215; 226),\n+                range: [777; 788),\n                 kind: TypeHint,\n                 label: \"i32\",\n             },\n             InlayHint {\n-                range: [259; 260),\n+                range: [821; 822),\n                 kind: ParameterHint,\n                 label: \"foo\",\n             },\n             InlayHint {\n-                range: [262; 263),\n+                range: [824; 825),\n                 kind: ParameterHint,\n                 label: \"bar\",\n             },\n             InlayHint {\n-                range: [265; 272),\n+                range: [827; 834),\n                 kind: ParameterHint,\n                 label: \"msg\",\n             },\n             InlayHint {\n-                range: [277; 288),\n+                range: [839; 850),\n                 kind: ParameterHint,\n                 label: \"last\",\n             },\n             InlayHint {\n-                range: [331; 334),\n+                range: [893; 896),\n                 kind: ParameterHint,\n                 label: \"param\",\n             },\n             InlayHint {\n-                range: [354; 356),\n+                range: [916; 918),\n                 kind: ParameterHint,\n                 label: \"&self\",\n             },\n             InlayHint {\n-                range: [358; 362),\n+                range: [920; 924),\n                 kind: ParameterHint,\n                 label: \"param\",\n             },\n+            InlayHint {\n+                range: [959; 968),\n+                kind: ParameterHint,\n+                label: \"file_id\",\n+            },\n+            InlayHint {\n+                range: [978; 991),\n+                kind: ParameterHint,\n+                label: \"name\",\n+            },\n+            InlayHint {\n+                range: [1001; 1019),\n+                kind: ParameterHint,\n+                label: \"focus_range\",\n+            },\n+            InlayHint {\n+                range: [1029; 1041),\n+                kind: ParameterHint,\n+                label: \"full_range\",\n+            },\n+            InlayHint {\n+                range: [1051; 1064),\n+                kind: ParameterHint,\n+                label: \"kind\",\n+            },\n+            InlayHint {\n+                range: [1074; 1092),\n+                kind: ParameterHint,\n+                label: \"docs\",\n+            },\n+            InlayHint {\n+                range: [1102; 1120),\n+                kind: ParameterHint,\n+                label: \"description\",\n+            },\n         ]\n         \"###\n         );\n     }\n+\n+    #[test]\n+    fn omitted_parameters_hints_heuristics() {\n+        let (analysis, file_id) = single_file(\n+            r#\"\n+fn map(f: i32) {}\n+fn filter(predicate: i32) {}\n+\n+struct TestVarContainer {\n+    test_var: i32,\n+}\n+\n+struct Test {}\n+\n+impl Test {\n+    fn map(self, f: i32) -> Self {\n+        self\n+    }\n+\n+    fn filter(self, predicate: i32) -> Self {\n+        self\n+    }\n+\n+    fn no_hints_expected(&self, _: i32, test_var: i32) {}\n+}\n+\n+fn main() {\n+    let container: TestVarContainer = TestVarContainer { test_var: 42 };\n+    let test: Test = Test {};\n+\n+    map(22);\n+    filter(33);\n+\n+    let test_processed: Test = test.map(1).filter(2);\n+\n+    let test_var: i32 = 55;\n+    test_processed.no_hints_expected(22, test_var);\n+    test_processed.no_hints_expected(33, container.test_var);\n+}\"#,\n+        );\n+\n+        assert_debug_snapshot!(analysis.inlay_hints(file_id, Some(8)).unwrap(), @r###\"\n+        []\n+        \"###\n+        );\n+    }\n }"}]}