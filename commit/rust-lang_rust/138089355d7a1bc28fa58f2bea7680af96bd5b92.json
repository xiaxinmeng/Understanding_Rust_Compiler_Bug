{"sha": "138089355d7a1bc28fa58f2bea7680af96bd5b92", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzODA4OTM1NWQ3YTFiYzI4ZmE1OGYyYmVhNzY4MGFmOTZiZDViOTI=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2014-05-15T12:13:33Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2014-05-29T12:19:57Z"}, "message": "debuginfo: Add documentation comments to debuginfo.rs\n\nConflicts:\n\tsrc/librustc/middle/trans/debuginfo.rs", "tree": {"sha": "5b15c9abb1e37722b475f97c246a5f650acf7020", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b15c9abb1e37722b475f97c246a5f650acf7020"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/138089355d7a1bc28fa58f2bea7680af96bd5b92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/138089355d7a1bc28fa58f2bea7680af96bd5b92", "html_url": "https://github.com/rust-lang/rust/commit/138089355d7a1bc28fa58f2bea7680af96bd5b92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/138089355d7a1bc28fa58f2bea7680af96bd5b92/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff2bf58e9e0c1e7b154b88fc7ba8c52584e9f768", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff2bf58e9e0c1e7b154b88fc7ba8c52584e9f768", "html_url": "https://github.com/rust-lang/rust/commit/ff2bf58e9e0c1e7b154b88fc7ba8c52584e9f768"}], "stats": {"total": 222, "additions": 134, "deletions": 88}, "files": [{"sha": "af599eb91a2eda7c8756332a3072dac687264ace", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 134, "deletions": 88, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/138089355d7a1bc28fa58f2bea7680af96bd5b92/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/138089355d7a1bc28fa58f2bea7680af96bd5b92/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=138089355d7a1bc28fa58f2bea7680af96bd5b92", "patch": "@@ -1208,33 +1208,108 @@ fn pointer_type_metadata(cx: &CrateContext,\n     return ptr_metadata;\n }\n \n+//=-------------------------------------------------------------------------------------------------\n+// Common facilities for record-like types (structs, enums, tuples)\n+//=-------------------------------------------------------------------------------------------------\n+\n+enum MemberOffset {\n+    FixedMemberOffset { bytes: uint },\n+    // For ComputedMemberOffset, the offset is read from the llvm type definition\n+    ComputedMemberOffset\n+}\n+\n+// Description of a type member, which can either be a regular field (as in structs or tuples) or\n+// an enum variant\n+struct MemberDescription {\n+    name: String,\n+    llvm_type: Type,\n+    type_metadata: DIType,\n+    offset: MemberOffset,\n+}\n+\n+// A factory for MemberDescriptions. It produces a list of member descriptions for some record-like\n+// type. MemberDescriptionFactories are used to defer the creation of type member descriptions in\n+// order to break cycles arising from recursive type definitions.\n enum MemberDescriptionFactory {\n-    StructMD(StructMemberDescriptionFactory),\n-    TupleMD(TupleMemberDescriptionFactory),\n-    GeneralMD(GeneralMemberDescriptionFactory),\n-    EnumVariantMD(EnumVariantMemberDescriptionFactory)\n+    StructMDF(StructMemberDescriptionFactory),\n+    TupleMDF(TupleMemberDescriptionFactory),\n+    EnumMDF(EnumMemberDescriptionFactory),\n+    VariantMDF(VariantMemberDescriptionFactory)\n }\n \n impl MemberDescriptionFactory {\n-    fn create_member_descriptions(&self, cx: &CrateContext)\n-                                  -> Vec<MemberDescription> {\n+    fn create_member_descriptions(&self, cx: &CrateContext) -> Vec<MemberDescription> {\n         match *self {\n-            StructMD(ref this) => {\n+            StructMDF(ref this) => {\n                 this.create_member_descriptions(cx)\n             }\n-            TupleMD(ref this) => {\n+            TupleMDF(ref this) => {\n                 this.create_member_descriptions(cx)\n             }\n-            GeneralMD(ref this) => {\n+            EnumMDF(ref this) => {\n                 this.create_member_descriptions(cx)\n             }\n-            EnumVariantMD(ref this) => {\n+            VariantMDF(ref this) => {\n                 this.create_member_descriptions(cx)\n             }\n         }\n     }\n }\n \n+// A description of some recursive type. It can either be already finished (as with FinalMetadata)\n+// or it is not yet finished, but contains all information needed to generate the missing parts of\n+// the description. See the documentation section on Recursive Types at the top of this file for\n+// more information.\n+enum RecursiveTypeDescription {\n+    UnfinishedMetadata {\n+        cache_id: uint,\n+        metadata_stub: DICompositeType,\n+        llvm_type: Type,\n+        file_metadata: DIFile,\n+        member_description_factory: MemberDescriptionFactory,\n+    },\n+    FinalMetadata(DICompositeType)\n+}\n+\n+impl RecursiveTypeDescription {\n+    // Finishes up the description of the type in question (mostly by providing description of the\n+    // fields of the given type) and returns the final type metadata.\n+    fn finalize(&self, cx: &CrateContext) -> DICompositeType {\n+        match *self {\n+            FinalMetadata(metadata) => metadata,\n+            UnfinishedMetadata {\n+                cache_id,\n+                metadata_stub,\n+                llvm_type,\n+                file_metadata,\n+                ref member_description_factory\n+            } => {\n+                // Insert the stub into the cache in order to allow recursive references ...\n+                debug_context(cx).created_types.borrow_mut()\n+                                 .insert(cache_id, metadata_stub);\n+\n+                // ... then create the member descriptions ...\n+                let member_descriptions = member_description_factory.create_member_descriptions(cx);\n+\n+                // ... and attach them to the stub to complete it.\n+                set_members_of_composite_type(cx,\n+                                              metadata_stub,\n+                                              llvm_type,\n+                                              member_descriptions.as_slice(),\n+                                              file_metadata,\n+                                              codemap::DUMMY_SP);\n+                return metadata_stub;\n+            }\n+        }\n+    }\n+}\n+\n+\n+//=-------------------------------------------------------------------------------------------------\n+// Structs\n+//=-------------------------------------------------------------------------------------------------\n+\n+// Creates MemberDescriptions for the fields of a struct\n struct StructMemberDescriptionFactory {\n     fields: Vec<ty::field>,\n     is_simd: bool,\n@@ -1248,7 +1323,7 @@ impl StructMemberDescriptionFactory {\n         }\n \n         let field_size = if self.is_simd {\n-            machine::llsize_of_alloc(cx, type_of::type_of(cx, self.fields.get(0).mt.ty))\n+            machine::llsize_of_alloc(cx, type_of::type_of(cx, self.fields.get(0).mt.ty)) as uint\n         } else {\n             0xdeadbeef\n         };\n@@ -1262,7 +1337,7 @@ impl StructMemberDescriptionFactory {\n \n             let offset = if self.is_simd {\n                 assert!(field_size != 0xdeadbeef);\n-                FixedMemberOffset { bytes: i as u64 * field_size }\n+                FixedMemberOffset { bytes: i * field_size }\n             } else {\n                 ComputedMemberOffset\n             };\n@@ -1305,57 +1380,20 @@ fn prepare_struct_metadata(cx: &CrateContext,\n         metadata_stub: struct_metadata_stub,\n         llvm_type: struct_llvm_type,\n         file_metadata: file_metadata,\n-        member_description_factory: StructMD(StructMemberDescriptionFactory {\n+        member_description_factory: StructMDF(StructMemberDescriptionFactory {\n             fields: fields,\n             is_simd: ty::type_is_simd(cx.tcx(), struct_type),\n             span: span,\n         }),\n     }\n }\n \n-enum RecursiveTypeDescription {\n-    UnfinishedMetadata {\n-        cache_id: uint,\n-        metadata_stub: DICompositeType,\n-        llvm_type: Type,\n-        file_metadata: DIFile,\n-        member_description_factory: MemberDescriptionFactory,\n-    },\n-    FinalMetadata(DICompositeType)\n-}\n-\n-impl RecursiveTypeDescription {\n-\n-    fn finalize(&self, cx: &CrateContext) -> DICompositeType {\n-        match *self {\n-            FinalMetadata(metadata) => metadata,\n-            UnfinishedMetadata {\n-                cache_id,\n-                metadata_stub,\n-                llvm_type,\n-                file_metadata,\n-                ref member_description_factory\n-            } => {\n-                // Insert the stub into the cache in order to allow recursive references ...\n-                debug_context(cx).created_types.borrow_mut()\n-                                 .insert(cache_id, metadata_stub);\n-\n-                // ... then create the member descriptions ...\n-                let member_descriptions = member_description_factory.create_member_descriptions(cx);\n \n-                // ... and attach them to the stub to complete it.\n-                set_members_of_composite_type(cx,\n-                                              metadata_stub,\n-                                              llvm_type,\n-                                              member_descriptions.as_slice(),\n-                                              file_metadata,\n-                                              codemap::DUMMY_SP);\n-                return metadata_stub;\n-            }\n-        }\n-    }\n-}\n+//=-------------------------------------------------------------------------------------------------\n+// Tuples\n+//=-------------------------------------------------------------------------------------------------\n \n+// Creates MemberDescriptions for the fields of a tuple\n struct TupleMemberDescriptionFactory {\n     component_types: Vec<ty::t> ,\n     span: Span,\n@@ -1396,25 +1434,33 @@ fn prepare_tuple_metadata(cx: &CrateContext,\n                                           span),\n         llvm_type: tuple_llvm_type,\n         file_metadata: file_metadata,\n-        member_description_factory: TupleMD(TupleMemberDescriptionFactory {\n+        member_description_factory: TupleMDF(TupleMemberDescriptionFactory {\n             component_types: Vec::from_slice(component_types),\n             span: span,\n         })\n     }\n }\n \n-struct GeneralMemberDescriptionFactory {\n+\n+//=-------------------------------------------------------------------------------------------------\n+// Enums\n+//=-------------------------------------------------------------------------------------------------\n+\n+// Describes the members of an enum value: An enum is described as a union of structs in DWARF. This\n+// MemberDescriptionFactory provides the description for the members of this union; so for every\n+// variant of the given enum, this factory will produce one MemberDescription (all with no name and\n+// a fixed offset of zero bytes).\n+struct EnumMemberDescriptionFactory {\n     type_rep: Rc<adt::Repr>,\n     variants: Rc<Vec<Rc<ty::VariantInfo>>>,\n-    discriminant_type_metadata: ValueRef,\n+    discriminant_type_metadata: DIType,\n     containing_scope: DIScope,\n     file_metadata: DIFile,\n     span: Span,\n }\n \n-impl GeneralMemberDescriptionFactory {\n-    fn create_member_descriptions(&self, cx: &CrateContext)\n-                                  -> Vec<MemberDescription> {\n+impl EnumMemberDescriptionFactory {\n+    fn create_member_descriptions(&self, cx: &CrateContext) -> Vec<MemberDescription> {\n         // Capture type_rep, so we don't have to copy the struct_defs array\n         let struct_defs = match *self.type_rep {\n             adt::General(_, ref struct_defs) => struct_defs,\n@@ -1429,7 +1475,7 @@ impl GeneralMemberDescriptionFactory {\n                     describe_enum_variant(cx,\n                                           struct_def,\n                                           &**self.variants.get(i),\n-                                          Some(self.discriminant_type_metadata),\n+                                          RegularDiscriminant(self.discriminant_type_metadata),\n                                           self.containing_scope,\n                                           self.file_metadata,\n                                           self.span);\n@@ -1453,15 +1499,15 @@ impl GeneralMemberDescriptionFactory {\n     }\n }\n \n-struct EnumVariantMemberDescriptionFactory {\n+// Creates MemberDescriptions for the fields of a single enum variant\n+struct VariantMemberDescriptionFactory {\n     args: Vec<(String, ty::t)> ,\n     discriminant_type_metadata: Option<DIType>,\n     span: Span,\n }\n \n-impl EnumVariantMemberDescriptionFactory {\n-    fn create_member_descriptions(&self, cx: &CrateContext)\n-                                  -> Vec<MemberDescription> {\n+impl VariantMemberDescriptionFactory {\n+    fn create_member_descriptions(&self, cx: &CrateContext) -> Vec<MemberDescription> {\n         self.args.iter().enumerate().map(|(i, &(ref name, ty))| {\n             MemberDescription {\n                 name: name.to_string(),\n@@ -1476,10 +1522,19 @@ impl EnumVariantMemberDescriptionFactory {\n     }\n }\n \n+enum EnumDiscriminantInfo {\n+    RegularDiscriminant(DIType),\n+    OptimizedDiscriminant(uint),\n+    NoDiscriminant\n+}\n+\n+// Returns a tuple of (1) type_metadata_stub of the variant, (2) the llvm_type of the variant, and\n+// (3) a MemberDescriptionFactory for producing the descriptions of the fields of the variant. This\n+// is a rudimentary version of a full RecursiveTypeDescription.\n fn describe_enum_variant(cx: &CrateContext,\n                          struct_def: &adt::Struct,\n                          variant_info: &ty::VariantInfo,\n-                         discriminant_type_metadata: Option<DIType>,\n+                         discriminant_info: EnumDiscriminantInfo,\n                          containing_scope: DIScope,\n                          file_metadata: DIFile,\n                          span: Span)\n@@ -1520,9 +1575,10 @@ fn describe_enum_variant(cx: &CrateContext,\n     };\n \n     // If this is not a univariant enum, there is also the (unnamed) discriminant field\n-    if discriminant_type_metadata.is_some() {\n-        arg_names.insert(0, \"\".to_string());\n-    }\n+    match discriminant_info {\n+        RegularDiscriminant(_) => arg_names.insert(0, \"\".to_string()),\n+        _ => { /* do nothing */ }\n+    };\n \n     // Build an array of (field name, field type) pairs to be captured in the factory closure.\n     let args: Vec<(String, ty::t)> = arg_names.iter()\n@@ -1531,9 +1587,12 @@ fn describe_enum_variant(cx: &CrateContext,\n         .collect();\n \n     let member_description_factory =\n-        EnumVariantMD(EnumVariantMemberDescriptionFactory {\n+        VariantMDF(VariantMemberDescriptionFactory {\n             args: args,\n-            discriminant_type_metadata: discriminant_type_metadata,\n+            discriminant_type_metadata: match discriminant_info {\n+                RegularDiscriminant(discriminant_type_metadata) => Some(discriminant_type_metadata),\n+                _ => None\n+            },\n             span: span,\n         });\n \n@@ -1638,7 +1697,7 @@ fn prepare_enum_metadata(cx: &CrateContext,\n                     describe_enum_variant(cx,\n                                           struct_def,\n                                           &**variants.get(0),\n-                                          None,\n+                                          NoDiscriminant,\n                                           containing_scope,\n                                           file_metadata,\n                                           span);\n@@ -1680,7 +1739,7 @@ fn prepare_enum_metadata(cx: &CrateContext,\n                 metadata_stub: enum_metadata,\n                 llvm_type: enum_llvm_type,\n                 file_metadata: file_metadata,\n-                member_description_factory: GeneralMD(GeneralMemberDescriptionFactory {\n+                member_description_factory: EnumMDF(EnumMemberDescriptionFactory {\n                     type_rep: type_rep.clone(),\n                     variants: variants,\n                     discriminant_type_metadata: discriminant_type_metadata,\n@@ -1693,14 +1752,14 @@ fn prepare_enum_metadata(cx: &CrateContext,\n         adt::RawNullablePointer { nnty, .. } => {\n             FinalMetadata(type_metadata(cx, nnty, span))\n         }\n-        adt::StructWrappedNullablePointer { nonnull: ref struct_def, nndiscr, .. } => {\n+        adt::StructWrappedNullablePointer { nonnull: ref struct_def, nndiscr, ptrfield, .. } => {\n             let (metadata_stub,\n                  variant_llvm_type,\n                  member_description_factory) =\n                     describe_enum_variant(cx,\n                                           struct_def,\n                                           &**variants.get(nndiscr as uint),\n-                                          None,\n+                                          OptimizedDiscriminant(ptrfield),\n                                           containing_scope,\n                                           file_metadata,\n                                           span);\n@@ -1725,19 +1784,6 @@ fn prepare_enum_metadata(cx: &CrateContext,\n     }\n }\n \n-enum MemberOffset {\n-    FixedMemberOffset { bytes: u64 },\n-    // For ComputedMemberOffset, the offset is read from the llvm type definition\n-    ComputedMemberOffset\n-}\n-\n-struct MemberDescription {\n-    name: String,\n-    llvm_type: Type,\n-    type_metadata: DIType,\n-    offset: MemberOffset,\n-}\n-\n /// Creates debug information for a composite type, that is, anything that results in a LLVM struct.\n ///\n /// Examples of Rust types to use this are: structs, tuples, boxes, vecs, and enums."}]}