{"sha": "60e82aef64ed62a40ec06357a9946196909ce953", "node_id": "C_kwDOAAsO6NoAKDYwZTgyYWVmNjRlZDYyYTQwZWMwNjM1N2E5OTQ2MTk2OTA5Y2U5NTM", "commit": {"author": {"name": "est31", "email": "MTest31@outlook.com", "date": "2023-02-05T00:07:25Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2023-02-05T02:47:22Z"}, "message": "rustc_expand: remove huge error imports", "tree": {"sha": "1f5835c60cef258b3230c4ce0988960efd0e522f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f5835c60cef258b3230c4ce0988960efd0e522f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60e82aef64ed62a40ec06357a9946196909ce953", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60e82aef64ed62a40ec06357a9946196909ce953", "html_url": "https://github.com/rust-lang/rust/commit/60e82aef64ed62a40ec06357a9946196909ce953", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60e82aef64ed62a40ec06357a9946196909ce953/comments", "author": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3de7d7fb22a579a3d59ddb1c959d1b3da224aafa", "url": "https://api.github.com/repos/rust-lang/rust/commits/3de7d7fb22a579a3d59ddb1c959d1b3da224aafa", "html_url": "https://github.com/rust-lang/rust/commit/3de7d7fb22a579a3d59ddb1c959d1b3da224aafa"}], "stats": {"total": 48, "additions": 25, "deletions": 23}, "files": [{"sha": "cf7cff739b340f346ac59d75309c3a13f4fd109c", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/60e82aef64ed62a40ec06357a9946196909ce953/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60e82aef64ed62a40ec06357a9946196909ce953/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=60e82aef64ed62a40ec06357a9946196909ce953", "patch": "@@ -1,11 +1,6 @@\n #![deny(rustc::untranslatable_diagnostic)]\n \n-use crate::errors::{\n-    ArgumentNotAttributes, AttrNoArguments, AttributeMetaItem, AttributeSingleWord,\n-    AttributesWrongForm, CannotBeNameOfMacro, ExpectedCommaInList, HelperAttributeNameInvalid,\n-    MacroBodyStability, MacroConstStability, NotAMetaItem, OnlyOneArgument, OnlyOneWord,\n-    ResolveRelativePath, TakesNoArguments, TraceMacro,\n-};\n+use crate::errors;\n use crate::expand::{self, AstFragment, Invocation};\n use crate::module::DirOwnership;\n \n@@ -796,13 +791,13 @@ impl SyntaxExtension {\n             .unwrap_or_else(|| (None, helper_attrs));\n         let (stability, const_stability, body_stability) = attr::find_stability(&sess, attrs, span);\n         if let Some((_, sp)) = const_stability {\n-            sess.emit_err(MacroConstStability {\n+            sess.emit_err(errors::MacroConstStability {\n                 span: sp,\n                 head_span: sess.source_map().guess_head_span(span),\n             });\n         }\n         if let Some((_, sp)) = body_stability {\n-            sess.emit_err(MacroBodyStability {\n+            sess.emit_err(errors::MacroBodyStability {\n                 span: sp,\n                 head_span: sess.source_map().guess_head_span(span),\n             });\n@@ -1143,7 +1138,7 @@ impl<'a> ExtCtxt<'a> {\n     }\n     pub fn trace_macros_diag(&mut self) {\n         for (span, notes) in self.expansions.iter() {\n-            let mut db = self.sess.parse_sess.create_note(TraceMacro { span: *span });\n+            let mut db = self.sess.parse_sess.create_note(errors::TraceMacro { span: *span });\n             for note in notes {\n                 db.note(note);\n             }\n@@ -1197,7 +1192,7 @@ pub fn resolve_path(\n                 .expect(\"attempting to resolve a file path in an external file\"),\n             FileName::DocTest(path, _) => path,\n             other => {\n-                return Err(ResolveRelativePath {\n+                return Err(errors::ResolveRelativePath {\n                     span,\n                     path: parse_sess.source_map().filename_for_diagnostics(&other).to_string(),\n                 }\n@@ -1279,7 +1274,7 @@ pub fn expr_to_string(\n /// done as rarely as possible).\n pub fn check_zero_tts(cx: &ExtCtxt<'_>, span: Span, tts: TokenStream, name: &str) {\n     if !tts.is_empty() {\n-        cx.emit_err(TakesNoArguments { span, name });\n+        cx.emit_err(errors::TakesNoArguments { span, name });\n     }\n }\n \n@@ -1307,14 +1302,14 @@ pub fn get_single_str_from_tts(\n ) -> Option<Symbol> {\n     let mut p = cx.new_parser_from_tts(tts);\n     if p.token == token::Eof {\n-        cx.emit_err(OnlyOneArgument { span, name });\n+        cx.emit_err(errors::OnlyOneArgument { span, name });\n         return None;\n     }\n     let ret = parse_expr(&mut p)?;\n     let _ = p.eat(&token::Comma);\n \n     if p.token != token::Eof {\n-        cx.emit_err(OnlyOneArgument { span, name });\n+        cx.emit_err(errors::OnlyOneArgument { span, name });\n     }\n     expr_to_string(cx, ret, \"argument must be a string literal\").map(|(s, _)| s)\n }\n@@ -1336,7 +1331,7 @@ pub fn get_exprs_from_tts(cx: &mut ExtCtxt<'_>, tts: TokenStream) -> Option<Vec<\n             continue;\n         }\n         if p.token != token::Eof {\n-            cx.emit_err(ExpectedCommaInList { span: p.token.span });\n+            cx.emit_err(errors::ExpectedCommaInList { span: p.token.span });\n             return None;\n         }\n     }\n@@ -1353,51 +1348,58 @@ pub fn parse_macro_name_and_helper_attrs(\n     // `#[proc_macro_derive(Foo, attributes(A, ..))]`\n     let list = attr.meta_item_list()?;\n     if list.len() != 1 && list.len() != 2 {\n-        diag.emit_err(AttrNoArguments { span: attr.span });\n+        diag.emit_err(errors::AttrNoArguments { span: attr.span });\n         return None;\n     }\n     let Some(trait_attr) = list[0].meta_item() else {\n-        diag.emit_err(NotAMetaItem {span: list[0].span()});\n+        diag.emit_err(errors::NotAMetaItem {span: list[0].span()});\n         return None;\n     };\n     let trait_ident = match trait_attr.ident() {\n         Some(trait_ident) if trait_attr.is_word() => trait_ident,\n         _ => {\n-            diag.emit_err(OnlyOneWord { span: trait_attr.span });\n+            diag.emit_err(errors::OnlyOneWord { span: trait_attr.span });\n             return None;\n         }\n     };\n \n     if !trait_ident.name.can_be_raw() {\n-        diag.emit_err(CannotBeNameOfMacro { span: trait_attr.span, trait_ident, macro_type });\n+        diag.emit_err(errors::CannotBeNameOfMacro {\n+            span: trait_attr.span,\n+            trait_ident,\n+            macro_type,\n+        });\n     }\n \n     let attributes_attr = list.get(1);\n     let proc_attrs: Vec<_> = if let Some(attr) = attributes_attr {\n         if !attr.has_name(sym::attributes) {\n-            diag.emit_err(ArgumentNotAttributes { span: attr.span() });\n+            diag.emit_err(errors::ArgumentNotAttributes { span: attr.span() });\n         }\n         attr.meta_item_list()\n             .unwrap_or_else(|| {\n-                diag.emit_err(AttributesWrongForm { span: attr.span() });\n+                diag.emit_err(errors::AttributesWrongForm { span: attr.span() });\n                 &[]\n             })\n             .iter()\n             .filter_map(|attr| {\n                 let Some(attr) = attr.meta_item() else {\n-                    diag.emit_err(AttributeMetaItem { span: attr.span() });\n+                    diag.emit_err(errors::AttributeMetaItem { span: attr.span() });\n                     return None;\n                 };\n \n                 let ident = match attr.ident() {\n                     Some(ident) if attr.is_word() => ident,\n                     _ => {\n-                        diag.emit_err(AttributeSingleWord { span: attr.span });\n+                        diag.emit_err(errors::AttributeSingleWord { span: attr.span });\n                         return None;\n                     }\n                 };\n                 if !ident.name.can_be_raw() {\n-                    diag.emit_err(HelperAttributeNameInvalid { span: attr.span, name: ident });\n+                    diag.emit_err(errors::HelperAttributeNameInvalid {\n+                        span: attr.span,\n+                        name: ident,\n+                    });\n                 }\n \n                 Some(ident.name)"}]}