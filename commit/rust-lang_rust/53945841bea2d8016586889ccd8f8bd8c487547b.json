{"sha": "53945841bea2d8016586889ccd8f8bd8c487547b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzOTQ1ODQxYmVhMmQ4MDE2NTg2ODg5Y2NkOGY4YmQ4YzQ4NzU0N2I=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-08T21:17:17Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-08T21:17:17Z"}, "message": "Extract path resolution submodule", "tree": {"sha": "71b497f6375149ff424d6440889111eabeec7b98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71b497f6375149ff424d6440889111eabeec7b98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53945841bea2d8016586889ccd8f8bd8c487547b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53945841bea2d8016586889ccd8f8bd8c487547b", "html_url": "https://github.com/rust-lang/rust/commit/53945841bea2d8016586889ccd8f8bd8c487547b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53945841bea2d8016586889ccd8f8bd8c487547b/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "785887b3829e2753cefcde48f527cf829fd051f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/785887b3829e2753cefcde48f527cf829fd051f4", "html_url": "https://github.com/rust-lang/rust/commit/785887b3829e2753cefcde48f527cf829fd051f4"}], "stats": {"total": 512, "additions": 269, "deletions": 243}, "files": [{"sha": "115b0264cc9b254915ce7b80e23007c66dcd599c", "filename": "crates/ra_hir_def/src/nameres.rs", "status": "modified", "additions": 6, "deletions": 241, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/53945841bea2d8016586889ccd8f8bd8c487547b/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53945841bea2d8016586889ccd8f8bd8c487547b/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs?ref=53945841bea2d8016586889ccd8f8bd8c487547b", "patch": "@@ -52,6 +52,7 @@ pub mod raw;\n pub mod per_ns;\n mod collector;\n mod mod_resolution;\n+mod path_resolution;\n \n #[cfg(test)]\n mod tests;\n@@ -65,14 +66,15 @@ use ra_db::{CrateId, Edition, FileId};\n use ra_prof::profile;\n use ra_syntax::ast;\n use rustc_hash::{FxHashMap, FxHashSet};\n-use test_utils::tested_by;\n \n use crate::{\n     builtin_type::BuiltinType,\n     db::DefDatabase2,\n-    nameres::{diagnostics::DefDiagnostic, per_ns::PerNs, raw::ImportId},\n-    path::{Path, PathKind},\n-    AdtId, AstId, CrateModuleId, EnumVariantId, ModuleDefId, ModuleId, TraitId,\n+    nameres::{\n+        diagnostics::DefDiagnostic, path_resolution::ResolveMode, per_ns::PerNs, raw::ImportId,\n+    },\n+    path::Path,\n+    AstId, CrateModuleId, ModuleDefId, ModuleId, TraitId,\n };\n \n /// Contains all top-level defs from a macro-expanded crate\n@@ -195,39 +197,6 @@ pub struct Resolution {\n     pub import: Option<ImportId>,\n }\n \n-#[derive(Debug, Clone)]\n-struct ResolvePathResult {\n-    resolved_def: PerNs,\n-    segment_index: Option<usize>,\n-    reached_fixedpoint: ReachedFixedPoint,\n-}\n-\n-impl ResolvePathResult {\n-    fn empty(reached_fixedpoint: ReachedFixedPoint) -> ResolvePathResult {\n-        ResolvePathResult::with(PerNs::none(), reached_fixedpoint, None)\n-    }\n-\n-    fn with(\n-        resolved_def: PerNs,\n-        reached_fixedpoint: ReachedFixedPoint,\n-        segment_index: Option<usize>,\n-    ) -> ResolvePathResult {\n-        ResolvePathResult { resolved_def, reached_fixedpoint, segment_index }\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-enum ResolveMode {\n-    Import,\n-    Other,\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-enum ReachedFixedPoint {\n-    Yes,\n-    No,\n-}\n-\n impl CrateDefMap {\n     pub(crate) fn crate_def_map_query(\n         // Note that this doesn't have `+ AstDatabase`!\n@@ -290,210 +259,6 @@ impl CrateDefMap {\n         let res = self.resolve_path_fp_with_macro(db, ResolveMode::Other, original_module, path);\n         (res.resolved_def, res.segment_index)\n     }\n-\n-    // Returns Yes if we are sure that additions to `ItemMap` wouldn't change\n-    // the result.\n-    fn resolve_path_fp_with_macro(\n-        &self,\n-        db: &impl DefDatabase2,\n-        mode: ResolveMode,\n-        original_module: CrateModuleId,\n-        path: &Path,\n-    ) -> ResolvePathResult {\n-        let mut segments = path.segments.iter().enumerate();\n-        let mut curr_per_ns: PerNs = match path.kind {\n-            PathKind::DollarCrate(krate) => {\n-                if krate == self.krate {\n-                    tested_by!(macro_dollar_crate_self);\n-                    PerNs::types(ModuleId { krate: self.krate, module_id: self.root }.into())\n-                } else {\n-                    let def_map = db.crate_def_map(krate);\n-                    let module = ModuleId { krate, module_id: def_map.root };\n-                    tested_by!(macro_dollar_crate_other);\n-                    PerNs::types(module.into())\n-                }\n-            }\n-            PathKind::Crate => {\n-                PerNs::types(ModuleId { krate: self.krate, module_id: self.root }.into())\n-            }\n-            PathKind::Self_ => {\n-                PerNs::types(ModuleId { krate: self.krate, module_id: original_module }.into())\n-            }\n-            // plain import or absolute path in 2015: crate-relative with\n-            // fallback to extern prelude (with the simplification in\n-            // rust-lang/rust#57745)\n-            // FIXME there must be a nicer way to write this condition\n-            PathKind::Plain | PathKind::Abs\n-                if self.edition == Edition::Edition2015\n-                    && (path.kind == PathKind::Abs || mode == ResolveMode::Import) =>\n-            {\n-                let segment = match segments.next() {\n-                    Some((_, segment)) => segment,\n-                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n-                };\n-                log::debug!(\"resolving {:?} in crate root (+ extern prelude)\", segment);\n-                self.resolve_name_in_crate_root_or_extern_prelude(&segment.name)\n-            }\n-            PathKind::Plain => {\n-                let segment = match segments.next() {\n-                    Some((_, segment)) => segment,\n-                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n-                };\n-                log::debug!(\"resolving {:?} in module\", segment);\n-                self.resolve_name_in_module(db, original_module, &segment.name)\n-            }\n-            PathKind::Super => {\n-                if let Some(p) = self.modules[original_module].parent {\n-                    PerNs::types(ModuleId { krate: self.krate, module_id: p }.into())\n-                } else {\n-                    log::debug!(\"super path in root module\");\n-                    return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n-                }\n-            }\n-            PathKind::Abs => {\n-                // 2018-style absolute path -- only extern prelude\n-                let segment = match segments.next() {\n-                    Some((_, segment)) => segment,\n-                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n-                };\n-                if let Some(def) = self.extern_prelude.get(&segment.name) {\n-                    log::debug!(\"absolute path {:?} resolved to crate {:?}\", path, def);\n-                    PerNs::types(*def)\n-                } else {\n-                    return ResolvePathResult::empty(ReachedFixedPoint::No); // extern crate declarations can add to the extern prelude\n-                }\n-            }\n-            PathKind::Type(_) => {\n-                // This is handled in `infer::infer_path_expr`\n-                // The result returned here does not matter\n-                return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n-            }\n-        };\n-\n-        for (i, segment) in segments {\n-            let curr = match curr_per_ns.take_types() {\n-                Some(r) => r,\n-                None => {\n-                    // we still have path segments left, but the path so far\n-                    // didn't resolve in the types namespace => no resolution\n-                    // (don't break here because `curr_per_ns` might contain\n-                    // something in the value namespace, and it would be wrong\n-                    // to return that)\n-                    return ResolvePathResult::empty(ReachedFixedPoint::No);\n-                }\n-            };\n-            // resolve segment in curr\n-\n-            curr_per_ns = match curr {\n-                ModuleDefId::ModuleId(module) => {\n-                    if module.krate != self.krate {\n-                        let path =\n-                            Path { segments: path.segments[i..].to_vec(), kind: PathKind::Self_ };\n-                        log::debug!(\"resolving {:?} in other crate\", path);\n-                        let defp_map = db.crate_def_map(module.krate);\n-                        let (def, s) = defp_map.resolve_path(db, module.module_id, &path);\n-                        return ResolvePathResult::with(\n-                            def,\n-                            ReachedFixedPoint::Yes,\n-                            s.map(|s| s + i),\n-                        );\n-                    }\n-\n-                    // Since it is a qualified path here, it should not contains legacy macros\n-                    match self[module.module_id].scope.get(&segment.name) {\n-                        Some(res) => res.def,\n-                        _ => {\n-                            log::debug!(\"path segment {:?} not found\", segment.name);\n-                            return ResolvePathResult::empty(ReachedFixedPoint::No);\n-                        }\n-                    }\n-                }\n-                ModuleDefId::AdtId(AdtId::EnumId(e)) => {\n-                    // enum variant\n-                    tested_by!(can_import_enum_variant);\n-                    let enum_data = db.enum_data(e);\n-                    match enum_data.variant(&segment.name) {\n-                        Some(local_id) => {\n-                            let variant = EnumVariantId { parent: e, local_id };\n-                            PerNs::both(variant.into(), variant.into())\n-                        }\n-                        None => {\n-                            return ResolvePathResult::with(\n-                                PerNs::types(e.into()),\n-                                ReachedFixedPoint::Yes,\n-                                Some(i),\n-                            );\n-                        }\n-                    }\n-                }\n-                s => {\n-                    // could be an inherent method call in UFCS form\n-                    // (`Struct::method`), or some other kind of associated item\n-                    log::debug!(\n-                        \"path segment {:?} resolved to non-module {:?}, but is not last\",\n-                        segment.name,\n-                        curr,\n-                    );\n-\n-                    return ResolvePathResult::with(\n-                        PerNs::types(s),\n-                        ReachedFixedPoint::Yes,\n-                        Some(i),\n-                    );\n-                }\n-            };\n-        }\n-        ResolvePathResult::with(curr_per_ns, ReachedFixedPoint::Yes, None)\n-    }\n-\n-    fn resolve_name_in_crate_root_or_extern_prelude(&self, name: &Name) -> PerNs {\n-        let from_crate_root =\n-            self[self.root].scope.get(name).map_or_else(PerNs::none, |res| res.def);\n-        let from_extern_prelude = self.resolve_name_in_extern_prelude(name);\n-\n-        from_crate_root.or(from_extern_prelude)\n-    }\n-\n-    fn resolve_name_in_module(\n-        &self,\n-        db: &impl DefDatabase2,\n-        module: CrateModuleId,\n-        name: &Name,\n-    ) -> PerNs {\n-        // Resolve in:\n-        //  - legacy scope of macro\n-        //  - current module / scope\n-        //  - extern prelude\n-        //  - std prelude\n-        let from_legacy_macro =\n-            self[module].scope.get_legacy_macro(name).map_or_else(PerNs::none, PerNs::macros);\n-        let from_scope = self[module].scope.get(name).map_or_else(PerNs::none, |res| res.def);\n-        let from_extern_prelude =\n-            self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it));\n-        let from_prelude = self.resolve_in_prelude(db, name);\n-\n-        from_legacy_macro.or(from_scope).or(from_extern_prelude).or(from_prelude)\n-    }\n-\n-    fn resolve_name_in_extern_prelude(&self, name: &Name) -> PerNs {\n-        self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it))\n-    }\n-\n-    fn resolve_in_prelude(&self, db: &impl DefDatabase2, name: &Name) -> PerNs {\n-        if let Some(prelude) = self.prelude {\n-            let keep;\n-            let def_map = if prelude.krate == self.krate {\n-                self\n-            } else {\n-                // Extend lifetime\n-                keep = db.crate_def_map(prelude.krate);\n-                &keep\n-            };\n-            def_map[prelude.module_id].scope.get(name).map_or_else(PerNs::none, |res| res.def)\n-        } else {\n-            PerNs::none()\n-        }\n-    }\n }\n \n mod diagnostics {"}, {"sha": "aacd50df8862cd9eb2c480b06e43768e4b32400d", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53945841bea2d8016586889ccd8f8bd8c487547b/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53945841bea2d8016586889ccd8f8bd8c487547b/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=53945841bea2d8016586889ccd8f8bd8c487547b", "patch": "@@ -14,8 +14,8 @@ use crate::{\n     attr::Attr,\n     db::DefDatabase2,\n     nameres::{\n-        diagnostics::DefDiagnostic, mod_resolution::ModDir, per_ns::PerNs, raw, CrateDefMap,\n-        ModuleData, ReachedFixedPoint, Resolution, ResolveMode,\n+        diagnostics::DefDiagnostic, mod_resolution::ModDir, path_resolution::ReachedFixedPoint,\n+        per_ns::PerNs, raw, CrateDefMap, ModuleData, Resolution, ResolveMode,\n     },\n     path::{Path, PathKind},\n     AdtId, AstId, AstItemDef, ConstId, CrateModuleId, EnumId, EnumVariantId, FunctionId,"}, {"sha": "95692f82611aef6a64e59a30d79dc87197c8a440", "filename": "crates/ra_hir_def/src/nameres/path_resolution.rs", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/53945841bea2d8016586889ccd8f8bd8c487547b/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53945841bea2d8016586889ccd8f8bd8c487547b/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=53945841bea2d8016586889ccd8f8bd8c487547b", "patch": "@@ -0,0 +1,261 @@\n+//! This modules implements a function to resolve a path `foo::bar::baz` to a\n+//! def, which is used within the name resolution.\n+//!\n+//! When name resolution is finished, the result of resolving a path is either\n+//! `Some(def)` or `None`. However, when we are in process of resolving imports\n+//! or macros, there's a third possibility:\n+//!\n+//!   I can't resolve this path right now, but I might be resolve this path\n+//!   later, when more macros are expanded.\n+//!\n+//! `ReachedFixedPoint` signals about this.\n+\n+use hir_expand::name::Name;\n+use ra_db::Edition;\n+use test_utils::tested_by;\n+\n+use crate::{\n+    db::DefDatabase2,\n+    nameres::{per_ns::PerNs, CrateDefMap},\n+    path::{Path, PathKind},\n+    AdtId, CrateModuleId, EnumVariantId, ModuleDefId, ModuleId,\n+};\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub(super) enum ResolveMode {\n+    Import,\n+    Other,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub(super) enum ReachedFixedPoint {\n+    Yes,\n+    No,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub(super) struct ResolvePathResult {\n+    pub(super) resolved_def: PerNs,\n+    pub(super) segment_index: Option<usize>,\n+    pub(super) reached_fixedpoint: ReachedFixedPoint,\n+}\n+\n+impl ResolvePathResult {\n+    fn empty(reached_fixedpoint: ReachedFixedPoint) -> ResolvePathResult {\n+        ResolvePathResult::with(PerNs::none(), reached_fixedpoint, None)\n+    }\n+\n+    fn with(\n+        resolved_def: PerNs,\n+        reached_fixedpoint: ReachedFixedPoint,\n+        segment_index: Option<usize>,\n+    ) -> ResolvePathResult {\n+        ResolvePathResult { resolved_def, reached_fixedpoint, segment_index }\n+    }\n+}\n+\n+impl CrateDefMap {\n+    pub(super) fn resolve_name_in_extern_prelude(&self, name: &Name) -> PerNs {\n+        self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it))\n+    }\n+\n+    // Returns Yes if we are sure that additions to `ItemMap` wouldn't change\n+    // the result.\n+    pub(super) fn resolve_path_fp_with_macro(\n+        &self,\n+        db: &impl DefDatabase2,\n+        mode: ResolveMode,\n+        original_module: CrateModuleId,\n+        path: &Path,\n+    ) -> ResolvePathResult {\n+        let mut segments = path.segments.iter().enumerate();\n+        let mut curr_per_ns: PerNs = match path.kind {\n+            PathKind::DollarCrate(krate) => {\n+                if krate == self.krate {\n+                    tested_by!(macro_dollar_crate_self);\n+                    PerNs::types(ModuleId { krate: self.krate, module_id: self.root }.into())\n+                } else {\n+                    let def_map = db.crate_def_map(krate);\n+                    let module = ModuleId { krate, module_id: def_map.root };\n+                    tested_by!(macro_dollar_crate_other);\n+                    PerNs::types(module.into())\n+                }\n+            }\n+            PathKind::Crate => {\n+                PerNs::types(ModuleId { krate: self.krate, module_id: self.root }.into())\n+            }\n+            PathKind::Self_ => {\n+                PerNs::types(ModuleId { krate: self.krate, module_id: original_module }.into())\n+            }\n+            // plain import or absolute path in 2015: crate-relative with\n+            // fallback to extern prelude (with the simplification in\n+            // rust-lang/rust#57745)\n+            // FIXME there must be a nicer way to write this condition\n+            PathKind::Plain | PathKind::Abs\n+                if self.edition == Edition::Edition2015\n+                    && (path.kind == PathKind::Abs || mode == ResolveMode::Import) =>\n+            {\n+                let segment = match segments.next() {\n+                    Some((_, segment)) => segment,\n+                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n+                };\n+                log::debug!(\"resolving {:?} in crate root (+ extern prelude)\", segment);\n+                self.resolve_name_in_crate_root_or_extern_prelude(&segment.name)\n+            }\n+            PathKind::Plain => {\n+                let segment = match segments.next() {\n+                    Some((_, segment)) => segment,\n+                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n+                };\n+                log::debug!(\"resolving {:?} in module\", segment);\n+                self.resolve_name_in_module(db, original_module, &segment.name)\n+            }\n+            PathKind::Super => {\n+                if let Some(p) = self.modules[original_module].parent {\n+                    PerNs::types(ModuleId { krate: self.krate, module_id: p }.into())\n+                } else {\n+                    log::debug!(\"super path in root module\");\n+                    return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n+                }\n+            }\n+            PathKind::Abs => {\n+                // 2018-style absolute path -- only extern prelude\n+                let segment = match segments.next() {\n+                    Some((_, segment)) => segment,\n+                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n+                };\n+                if let Some(def) = self.extern_prelude.get(&segment.name) {\n+                    log::debug!(\"absolute path {:?} resolved to crate {:?}\", path, def);\n+                    PerNs::types(*def)\n+                } else {\n+                    return ResolvePathResult::empty(ReachedFixedPoint::No); // extern crate declarations can add to the extern prelude\n+                }\n+            }\n+            PathKind::Type(_) => {\n+                // This is handled in `infer::infer_path_expr`\n+                // The result returned here does not matter\n+                return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n+            }\n+        };\n+\n+        for (i, segment) in segments {\n+            let curr = match curr_per_ns.take_types() {\n+                Some(r) => r,\n+                None => {\n+                    // we still have path segments left, but the path so far\n+                    // didn't resolve in the types namespace => no resolution\n+                    // (don't break here because `curr_per_ns` might contain\n+                    // something in the value namespace, and it would be wrong\n+                    // to return that)\n+                    return ResolvePathResult::empty(ReachedFixedPoint::No);\n+                }\n+            };\n+            // resolve segment in curr\n+\n+            curr_per_ns = match curr {\n+                ModuleDefId::ModuleId(module) => {\n+                    if module.krate != self.krate {\n+                        let path =\n+                            Path { segments: path.segments[i..].to_vec(), kind: PathKind::Self_ };\n+                        log::debug!(\"resolving {:?} in other crate\", path);\n+                        let defp_map = db.crate_def_map(module.krate);\n+                        let (def, s) = defp_map.resolve_path(db, module.module_id, &path);\n+                        return ResolvePathResult::with(\n+                            def,\n+                            ReachedFixedPoint::Yes,\n+                            s.map(|s| s + i),\n+                        );\n+                    }\n+\n+                    // Since it is a qualified path here, it should not contains legacy macros\n+                    match self[module.module_id].scope.get(&segment.name) {\n+                        Some(res) => res.def,\n+                        _ => {\n+                            log::debug!(\"path segment {:?} not found\", segment.name);\n+                            return ResolvePathResult::empty(ReachedFixedPoint::No);\n+                        }\n+                    }\n+                }\n+                ModuleDefId::AdtId(AdtId::EnumId(e)) => {\n+                    // enum variant\n+                    tested_by!(can_import_enum_variant);\n+                    let enum_data = db.enum_data(e);\n+                    match enum_data.variant(&segment.name) {\n+                        Some(local_id) => {\n+                            let variant = EnumVariantId { parent: e, local_id };\n+                            PerNs::both(variant.into(), variant.into())\n+                        }\n+                        None => {\n+                            return ResolvePathResult::with(\n+                                PerNs::types(e.into()),\n+                                ReachedFixedPoint::Yes,\n+                                Some(i),\n+                            );\n+                        }\n+                    }\n+                }\n+                s => {\n+                    // could be an inherent method call in UFCS form\n+                    // (`Struct::method`), or some other kind of associated item\n+                    log::debug!(\n+                        \"path segment {:?} resolved to non-module {:?}, but is not last\",\n+                        segment.name,\n+                        curr,\n+                    );\n+\n+                    return ResolvePathResult::with(\n+                        PerNs::types(s),\n+                        ReachedFixedPoint::Yes,\n+                        Some(i),\n+                    );\n+                }\n+            };\n+        }\n+        ResolvePathResult::with(curr_per_ns, ReachedFixedPoint::Yes, None)\n+    }\n+\n+    fn resolve_name_in_module(\n+        &self,\n+        db: &impl DefDatabase2,\n+        module: CrateModuleId,\n+        name: &Name,\n+    ) -> PerNs {\n+        // Resolve in:\n+        //  - legacy scope of macro\n+        //  - current module / scope\n+        //  - extern prelude\n+        //  - std prelude\n+        let from_legacy_macro =\n+            self[module].scope.get_legacy_macro(name).map_or_else(PerNs::none, PerNs::macros);\n+        let from_scope = self[module].scope.get(name).map_or_else(PerNs::none, |res| res.def);\n+        let from_extern_prelude =\n+            self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it));\n+        let from_prelude = self.resolve_in_prelude(db, name);\n+\n+        from_legacy_macro.or(from_scope).or(from_extern_prelude).or(from_prelude)\n+    }\n+\n+    fn resolve_name_in_crate_root_or_extern_prelude(&self, name: &Name) -> PerNs {\n+        let from_crate_root =\n+            self[self.root].scope.get(name).map_or_else(PerNs::none, |res| res.def);\n+        let from_extern_prelude = self.resolve_name_in_extern_prelude(name);\n+\n+        from_crate_root.or(from_extern_prelude)\n+    }\n+\n+    fn resolve_in_prelude(&self, db: &impl DefDatabase2, name: &Name) -> PerNs {\n+        if let Some(prelude) = self.prelude {\n+            let keep;\n+            let def_map = if prelude.krate == self.krate {\n+                self\n+            } else {\n+                // Extend lifetime\n+                keep = db.crate_def_map(prelude.krate);\n+                &keep\n+            };\n+            def_map[prelude.module_id].scope.get(name).map_or_else(PerNs::none, |res| res.def)\n+        } else {\n+            PerNs::none()\n+        }\n+    }\n+}"}]}