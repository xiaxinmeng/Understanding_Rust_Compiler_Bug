{"sha": "4c8e6e89aa05ea654534715399fe178f14a3b85a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjOGU2ZTg5YWEwNWVhNjU0NTM0NzE1Mzk5ZmUxNzhmMTRhM2I4NWE=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-17T11:03:34Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-17T11:03:34Z"}, "message": "Merge #1145\n\n1145: Fix #1099, plug self type type parameters in infer_path_expr r=flodiebold a=edwin0cheng\n\nAs discussed in #1099, this PR try to \"plug\" a `self type` type parameters in `infer_path_expr`.\r\nAll the cases in 1099 was fixed and tested.\r\nAnd luckily, this PR fixed bug #1030 again and make the test output correct.\r\n\r\n\r\n\r\n\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "fd2dcd9f5c3ed91b965a33ce805ab339ddf704de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd2dcd9f5c3ed91b965a33ce805ab339ddf704de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c8e6e89aa05ea654534715399fe178f14a3b85a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c8e6e89aa05ea654534715399fe178f14a3b85a", "html_url": "https://github.com/rust-lang/rust/commit/4c8e6e89aa05ea654534715399fe178f14a3b85a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c8e6e89aa05ea654534715399fe178f14a3b85a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "feaa30cf674d665bf2629b28a996ac8438ad7a33", "url": "https://api.github.com/repos/rust-lang/rust/commits/feaa30cf674d665bf2629b28a996ac8438ad7a33", "html_url": "https://github.com/rust-lang/rust/commit/feaa30cf674d665bf2629b28a996ac8438ad7a33"}, {"sha": "8747c903a2fd9b09e07b9d9a1310c7c3acc36e2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8747c903a2fd9b09e07b9d9a1310c7c3acc36e2f", "html_url": "https://github.com/rust-lang/rust/commit/8747c903a2fd9b09e07b9d9a1310c7c3acc36e2f"}], "stats": {"total": 125, "additions": 117, "deletions": 8}, "files": [{"sha": "7ca1ff595746a7f33f12251d509d2aeb2a4ca06b", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 56, "deletions": 6, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/4c8e6e89aa05ea654534715399fe178f14a3b85a/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c8e6e89aa05ea654534715399fe178f14a3b85a/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=4c8e6e89aa05ea654534715399fe178f14a3b85a", "patch": "@@ -35,16 +35,17 @@ use crate::{\n     expr::{Body, Expr, BindingAnnotation, Literal, ExprId, Pat, PatId, UnaryOp, BinaryOp, Statement, FieldPat,Array, self},\n     generics::{GenericParams, HasGenericParams},\n     path::{GenericArgs, GenericArg},\n+    ModuleDef,\n     adt::VariantDef,\n     resolve::{Resolver, Resolution},\n     nameres::Namespace,\n+    ty::infer::diagnostics::InferenceDiagnostic,\n     diagnostics::DiagnosticSink,\n };\n use super::{\n     Ty, TypableDef, Substs, primitive, op, ApplicationTy, TypeCtor, CallableDef, TraitRef,\n     traits::{ Solution, Obligation, Guidance},\n };\n-use self::diagnostics::InferenceDiagnostic;\n \n /// The entry point of type inference.\n pub fn infer(db: &impl HirDatabase, def: DefWithBody) -> Arc<InferenceResult> {\n@@ -459,18 +460,28 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             if remaining_index.is_none() { def.take_values()? } else { def.take_types()? };\n \n         let remaining_index = remaining_index.unwrap_or(path.segments.len());\n+        let mut actual_def_ty: Option<Ty> = None;\n \n         // resolve intermediate segments\n-        for segment in &path.segments[remaining_index..] {\n+        for (i, segment) in path.segments[remaining_index..].iter().enumerate() {\n             let ty = match resolved {\n                 Resolution::Def(def) => {\n                     // FIXME resolve associated items from traits as well\n                     let typable: Option<TypableDef> = def.into();\n                     let typable = typable?;\n \n-                    let substs =\n-                        Ty::substs_from_path_segment(self.db, &self.resolver, segment, typable);\n-                    self.db.type_for_def(typable, Namespace::Types).subst(&substs)\n+                    let ty = self.db.type_for_def(typable, Namespace::Types);\n+\n+                    // For example, this substs will take `Gen::*<u32>*::make`\n+                    assert!(remaining_index > 0);\n+                    let substs = Ty::substs_from_path_segment(\n+                        self.db,\n+                        &self.resolver,\n+                        &path.segments[remaining_index + i - 1],\n+                        typable,\n+                    );\n+\n+                    ty.subst(&substs)\n                 }\n                 Resolution::LocalBinding(_) => {\n                     // can't have a local binding in an associated item path\n@@ -489,6 +500,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             // Attempt to find an impl_item for the type which has a name matching\n             // the current segment\n             log::debug!(\"looking for path segment: {:?}\", segment);\n+            actual_def_ty = Some(ty.clone());\n+\n             let item: crate::ModuleDef = ty.iterate_impl_items(self.db, |item| {\n                 let matching_def: Option<crate::ModuleDef> = match item {\n                     crate::ImplItem::Method(func) => {\n@@ -528,8 +541,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Resolution::Def(def) => {\n                 let typable: Option<TypableDef> = def.into();\n                 let typable = typable?;\n+                let mut ty = self.db.type_for_def(typable, Namespace::Values);\n+                if let Some(sts) = self.find_self_types(&def, actual_def_ty) {\n+                    ty = ty.subst(&sts);\n+                }\n+\n                 let substs = Ty::substs_from_path(self.db, &self.resolver, path, typable);\n-                let ty = self.db.type_for_def(typable, Namespace::Values).subst(&substs);\n+                let ty = ty.subst(&substs);\n                 let ty = self.insert_type_vars(ty);\n                 Some(ty)\n             }\n@@ -549,6 +567,38 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         }\n     }\n \n+    fn find_self_types(&self, def: &ModuleDef, actual_def_ty: Option<Ty>) -> Option<Substs> {\n+        let actual_def_ty = actual_def_ty?;\n+\n+        if let crate::ModuleDef::Function(func) = def {\n+            // We only do the infer if parent has generic params\n+            let gen = func.generic_params(self.db);\n+            if gen.count_parent_params() == 0 {\n+                return None;\n+            }\n+\n+            let impl_block = func.impl_block(self.db)?.target_ty(self.db);\n+            let impl_block_substs = impl_block.substs()?;\n+            let actual_substs = actual_def_ty.substs()?;\n+\n+            let mut new_substs = vec![Ty::Unknown; gen.count_parent_params()];\n+\n+            // The following code *link up* the function actual parma type\n+            // and impl_block type param index\n+            impl_block_substs.iter().zip(actual_substs.iter()).for_each(|(param, pty)| {\n+                if let Ty::Param { idx, .. } = param {\n+                    if let Some(s) = new_substs.get_mut(*idx as usize) {\n+                        *s = pty.clone();\n+                    }\n+                }\n+            });\n+\n+            Some(Substs(new_substs.into()))\n+        } else {\n+            None\n+        }\n+    }\n+\n     fn resolve_variant(&mut self, path: Option<&Path>) -> (Ty, Option<VariantDef>) {\n         let path = match path {\n             Some(path) => path,"}, {"sha": "8d8a0eaaa69e628ec81e2353b5ebdcf2dba6e724", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 61, "deletions": 2, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4c8e6e89aa05ea654534715399fe178f14a3b85a/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c8e6e89aa05ea654534715399fe178f14a3b85a/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=4c8e6e89aa05ea654534715399fe178f14a3b85a", "patch": "@@ -1426,6 +1426,65 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn infer_associated_method_generics_without_args() {\n+    assert_snapshot_matches!(\n+        infer(r#\"\n+struct Gen<T> {\n+    val: T\n+}\n+\n+impl<T> Gen<T> {\n+    pub fn make() -> Gen<T> {\n+        loop { }\n+    }\n+}\n+\n+fn test() {\n+    let a = Gen::<u32>::make();\n+}\n+\"#),\n+        @r###\"\n+[76; 100) '{     ...     }': !\n+[86; 94) 'loop { }': !\n+[91; 94) '{ }': ()\n+[114; 149) '{     ...e(); }': ()\n+[124; 125) 'a': Gen<u32>\n+[128; 144) 'Gen::<...::make': fn make<u32>() -> Gen<T>\n+[128; 146) 'Gen::<...make()': Gen<u32>\"###\n+    );\n+}\n+\n+#[test]\n+fn infer_associated_method_generics_2_type_params_without_args() {\n+    assert_snapshot_matches!(\n+        infer(r#\"\n+struct Gen<T, U> {\n+    val: T,\n+    val2: U,\n+}\n+\n+impl<T> Gen<u32, T> {\n+    pub fn make() -> Gen<u32,T> {\n+        loop { }\n+    }\n+}\n+\n+fn test() {\n+    let a = Gen::<u32, u64>::make();\n+}\n+\"#),\n+        @r###\"\n+[102; 126) '{     ...     }': !\n+[112; 120) 'loop { }': !\n+[117; 120) '{ }': ()\n+[140; 180) '{     ...e(); }': ()\n+[150; 151) 'a': Gen<u32, u64>\n+[154; 175) 'Gen::<...::make': fn make<u64>() -> Gen<u32, T>\n+[154; 177) 'Gen::<...make()': Gen<u32, u64>\"###\n+    );\n+}\n+\n #[test]\n fn infer_type_alias() {\n     assert_snapshot_matches!(\n@@ -1814,8 +1873,8 @@ pub fn main_loop() {\n     @r###\"\n [144; 146) '{}': ()\n [169; 198) '{     ...t(); }': ()\n-[175; 193) 'FxHash...efault': fn default<{unknown}, {unknown}>() -> HashSet<T, H>\n-[175; 195) 'FxHash...ault()': HashSet<{unknown}, {unknown}>\"###\n+[175; 193) 'FxHash...efault': fn default<{unknown}, FxHasher>() -> HashSet<T, H>\n+[175; 195) 'FxHash...ault()': HashSet<{unknown}, FxHasher>\"###\n     );\n }\n "}]}