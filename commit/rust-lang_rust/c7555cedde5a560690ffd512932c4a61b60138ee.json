{"sha": "c7555cedde5a560690ffd512932c4a61b60138ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3NTU1Y2VkZGU1YTU2MDY5MGZmZDUxMjkzMmM0YTYxYjYwMTM4ZWU=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2018-07-26T15:18:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-07-26T15:18:27Z"}, "message": "Rollup merge of #52635 - yodaldevoid:issue_18804, r=oli-obk\n\nFix #[linkage] propagation though generic functions\n\nFixes #18804\n\nIn the non-local branch of `get_static` (where the fix was implemented) `span_fatal` had to be replaced with `bug!` as we have no span in that case.", "tree": {"sha": "ee06536fe094f12ea3eeba7116c7b0a946e993e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee06536fe094f12ea3eeba7116c7b0a946e993e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7555cedde5a560690ffd512932c4a61b60138ee", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbWeZECRBK7hj4Ov3rIwAAdHIIAFD8hWL+S00u4CEpm1fIQdyB\nZ8yhoV8JtWr1wsMQ31A1qsXHOaFWm6ZbHrjN536T1EhtfUDJwbzBCq/VK9KKPLw7\nVzje+AawH5UiHnuzFdpJrChAw6aXOMdJ1juKbHaPwvDL6CMccAxp2zE99qqN5dGp\ncOAaAxzwelskrdS44RLr9FD8yMP2J8IaktBbko2euPRp5FGbOUnz+lUuKG4X1Byd\nv+XnpF7O+5d3q3kJfpnVgqV3aUw8pEiCXzjy8VMfd839FnLkf82REoega4eQCanZ\nPBcyMQndjOKJ8AzLKT2qLgXahAgEo9blecpWVErTueYBSofz0NhPr84R82+FfCg=\n=yR2Y\n-----END PGP SIGNATURE-----\n", "payload": "tree ee06536fe094f12ea3eeba7116c7b0a946e993e4\nparent 2aeb76500e979c2acebf056f99db0a0cc96d07d5\nparent be5b668a2e892c4c892986809b0a7d119980037a\nauthor Mark Rousskov <mark.simulacrum@gmail.com> 1532618307 -0600\ncommitter GitHub <noreply@github.com> 1532618307 -0600\n\nRollup merge of #52635 - yodaldevoid:issue_18804, r=oli-obk\n\nFix #[linkage] propagation though generic functions\n\nFixes #18804\n\nIn the non-local branch of `get_static` (where the fix was implemented) `span_fatal` had to be replaced with `bug!` as we have no span in that case.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7555cedde5a560690ffd512932c4a61b60138ee", "html_url": "https://github.com/rust-lang/rust/commit/c7555cedde5a560690ffd512932c4a61b60138ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7555cedde5a560690ffd512932c4a61b60138ee/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2aeb76500e979c2acebf056f99db0a0cc96d07d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/2aeb76500e979c2acebf056f99db0a0cc96d07d5", "html_url": "https://github.com/rust-lang/rust/commit/2aeb76500e979c2acebf056f99db0a0cc96d07d5"}, {"sha": "be5b668a2e892c4c892986809b0a7d119980037a", "url": "https://api.github.com/repos/rust-lang/rust/commits/be5b668a2e892c4c892986809b0a7d119980037a", "html_url": "https://github.com/rust-lang/rust/commit/be5b668a2e892c4c892986809b0a7d119980037a"}], "stats": {"total": 168, "additions": 121, "deletions": 47}, "files": [{"sha": "f0b5f4b887971f1cffa7bc150ef450d24d7c2ab0", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 78, "deletions": 47, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/c7555cedde5a560690ffd512932c4a61b60138ee/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7555cedde5a560690ffd512932c4a61b60138ee/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=c7555cedde5a560690ffd512932c4a61b60138ee", "patch": "@@ -20,12 +20,14 @@ use monomorphize::MonoItem;\n use common::{CodegenCx, val_ty};\n use declare;\n use monomorphize::Instance;\n+use syntax_pos::Span;\n+use syntax_pos::symbol::LocalInternedString;\n use type_::Type;\n use type_of::LayoutLlvmExt;\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc::ty::layout::{Align, LayoutOf};\n \n-use rustc::hir::{self, CodegenFnAttrFlags};\n+use rustc::hir::{self, CodegenFnAttrs, CodegenFnAttrFlags};\n \n use std::ffi::{CStr, CString};\n \n@@ -119,6 +121,8 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n     let ty = instance.ty(cx.tcx);\n     let sym = cx.tcx.symbol_name(instance).as_str();\n \n+    debug!(\"get_static: sym={} instance={:?}\", sym, instance);\n+\n     let g = if let Some(id) = cx.tcx.hir.as_local_node_id(def_id) {\n \n         let llty = cx.layout_of(ty).llvm_type(cx);\n@@ -144,50 +148,15 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n             hir_map::NodeForeignItem(&hir::ForeignItem {\n                 ref attrs, span, node: hir::ForeignItemKind::Static(..), ..\n             }) => {\n-                let g = if let Some(linkage) = cx.tcx.codegen_fn_attrs(def_id).linkage {\n-                    // If this is a static with a linkage specified, then we need to handle\n-                    // it a little specially. The typesystem prevents things like &T and\n-                    // extern \"C\" fn() from being non-null, so we can't just declare a\n-                    // static and call it a day. Some linkages (like weak) will make it such\n-                    // that the static actually has a null value.\n-                    let llty2 = match ty.sty {\n-                        ty::TyRawPtr(ref mt) => cx.layout_of(mt.ty).llvm_type(cx),\n-                        _ => {\n-                            cx.sess().span_fatal(span, \"must have type `*const T` or `*mut T`\");\n-                        }\n-                    };\n-                    unsafe {\n-                        // Declare a symbol `foo` with the desired linkage.\n-                        let g1 = declare::declare_global(cx, &sym, llty2);\n-                        llvm::LLVMRustSetLinkage(g1, base::linkage_to_llvm(linkage));\n-\n-                        // Declare an internal global `extern_with_linkage_foo` which\n-                        // is initialized with the address of `foo`.  If `foo` is\n-                        // discarded during linking (for example, if `foo` has weak\n-                        // linkage and there are no definitions), then\n-                        // `extern_with_linkage_foo` will instead be initialized to\n-                        // zero.\n-                        let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n-                        real_name.push_str(&sym);\n-                        let g2 = declare::define_global(cx, &real_name, llty).unwrap_or_else(||{\n-                            cx.sess().span_fatal(span,\n-                                &format!(\"symbol `{}` is already defined\", &sym))\n-                        });\n-                        llvm::LLVMRustSetLinkage(g2, llvm::Linkage::InternalLinkage);\n-                        llvm::LLVMSetInitializer(g2, g1);\n-                        g2\n-                    }\n-                } else {\n-                    // Generate an external declaration.\n-                    declare::declare_global(cx, &sym, llty)\n-                };\n-\n-                (g, attrs)\n+                let fn_attrs = cx.tcx.codegen_fn_attrs(def_id);\n+                (check_and_apply_linkage(cx, &fn_attrs, ty, sym, Some(span)), attrs)\n             }\n \n             item => bug!(\"get_static: expected static, found {:?}\", item)\n         };\n \n+        debug!(\"get_static: sym={} attrs={:?}\", sym, attrs);\n+\n         for attr in attrs {\n             if attr.check_name(\"thread_local\") {\n                 llvm::set_thread_local_mode(g, cx.tls_model);\n@@ -197,19 +166,21 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n         g\n     } else {\n         // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n-        // FIXME(nagisa): investigate whether it can be changed into define_global\n-        let g = declare::declare_global(cx, &sym, cx.layout_of(ty).llvm_type(cx));\n+        debug!(\"get_static: sym={} item_attr={:?}\", sym, cx.tcx.item_attrs(def_id));\n+\n+        let attrs = cx.tcx.codegen_fn_attrs(def_id);\n+        let g = check_and_apply_linkage(cx, &attrs, ty, sym, None);\n+\n         // Thread-local statics in some other crate need to *always* be linked\n         // against in a thread-local fashion, so we need to be sure to apply the\n         // thread-local attribute locally if it was present remotely. If we\n         // don't do this then linker errors can be generated where the linker\n         // complains that one object files has a thread local version of the\n         // symbol and another one doesn't.\n-        for attr in cx.tcx.get_attrs(def_id).iter() {\n-            if attr.check_name(\"thread_local\") {\n-                llvm::set_thread_local_mode(g, cx.tls_model);\n-            }\n+        if attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL) {\n+            llvm::set_thread_local_mode(g, cx.tls_model);\n         }\n+\n         if cx.use_dll_storage_attrs && !cx.tcx.is_foreign_item(def_id) {\n             // This item is external but not foreign, i.e. it originates from an external Rust\n             // crate. Since we don't know whether this crate will be linked dynamically or\n@@ -242,6 +213,66 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n     g\n }\n \n+fn check_and_apply_linkage<'tcx>(\n+    cx: &CodegenCx<'_, 'tcx>,\n+    attrs: &CodegenFnAttrs,\n+    ty: Ty<'tcx>,\n+    sym: LocalInternedString,\n+    span: Option<Span>\n+) -> ValueRef {\n+    let llty = cx.layout_of(ty).llvm_type(cx);\n+    if let Some(linkage) = attrs.linkage {\n+        debug!(\"get_static: sym={} linkage={:?}\", sym, linkage);\n+\n+        // If this is a static with a linkage specified, then we need to handle\n+        // it a little specially. The typesystem prevents things like &T and\n+        // extern \"C\" fn() from being non-null, so we can't just declare a\n+        // static and call it a day. Some linkages (like weak) will make it such\n+        // that the static actually has a null value.\n+        let llty2 = match ty.sty {\n+            ty::TyRawPtr(ref mt) => cx.layout_of(mt.ty).llvm_type(cx),\n+            _ => {\n+                if span.is_some() {\n+                    cx.sess().span_fatal(span.unwrap(), \"must have type `*const T` or `*mut T`\")\n+                } else {\n+                    bug!(\"must have type `*const T` or `*mut T`\")\n+                }\n+            }\n+        };\n+        unsafe {\n+            // Declare a symbol `foo` with the desired linkage.\n+            let g1 = declare::declare_global(cx, &sym, llty2);\n+            llvm::LLVMRustSetLinkage(g1, base::linkage_to_llvm(linkage));\n+\n+            // Declare an internal global `extern_with_linkage_foo` which\n+            // is initialized with the address of `foo`.  If `foo` is\n+            // discarded during linking (for example, if `foo` has weak\n+            // linkage and there are no definitions), then\n+            // `extern_with_linkage_foo` will instead be initialized to\n+            // zero.\n+            let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n+            real_name.push_str(&sym);\n+            let g2 = declare::define_global(cx, &real_name, llty).unwrap_or_else(||{\n+                if span.is_some() {\n+                    cx.sess().span_fatal(\n+                        span.unwrap(),\n+                        &format!(\"symbol `{}` is already defined\", &sym)\n+                    )\n+                } else {\n+                    bug!(\"symbol `{}` is already defined\", &sym)\n+                }\n+            });\n+            llvm::LLVMRustSetLinkage(g2, llvm::Linkage::InternalLinkage);\n+            llvm::LLVMSetInitializer(g2, g1);\n+            g2\n+        }\n+    } else {\n+        // Generate an external declaration.\n+        // FIXME(nagisa): investigate whether it can be changed into define_global\n+        declare::declare_global(cx, &sym, llty)\n+    }\n+}\n+\n pub fn codegen_static<'a, 'tcx>(\n     cx: &CodegenCx<'a, 'tcx>,\n     def_id: DefId,"}, {"sha": "06d454b2c890a8e35086f130139ab7ad608d8d00", "filename": "src/test/run-pass/issue-18804/auxiliary/lib.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c7555cedde5a560690ffd512932c4a61b60138ee/src%2Ftest%2Frun-pass%2Fissue-18804%2Fauxiliary%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7555cedde5a560690ffd512932c4a61b60138ee/src%2Ftest%2Frun-pass%2Fissue-18804%2Fauxiliary%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18804%2Fauxiliary%2Flib.rs?ref=c7555cedde5a560690ffd512932c4a61b60138ee", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"rlib\"]\n+#![feature(linkage)]\n+\n+pub fn foo<T>() -> *const() {\n+    extern {\n+        #[linkage = \"extern_weak\"]\n+        static FOO: *const();\n+    }\n+    unsafe { FOO }\n+}"}, {"sha": "b5aa052034936338c41860a799b54cee4c7dd5ee", "filename": "src/test/run-pass/issue-18804/main.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c7555cedde5a560690ffd512932c4a61b60138ee/src%2Ftest%2Frun-pass%2Fissue-18804%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7555cedde5a560690ffd512932c4a61b60138ee/src%2Ftest%2Frun-pass%2Fissue-18804%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18804%2Fmain.rs?ref=c7555cedde5a560690ffd512932c4a61b60138ee", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test for issue #18804, #[linkage] does not propagate thorugh generic\n+// functions. Failure results in a linker error.\n+\n+// ignore-asmjs no weak symbol support\n+// ignore-emscripten no weak symbol support\n+\n+// aux-build:lib.rs\n+\n+extern crate lib;\n+\n+fn main() {\n+    lib::foo::<i32>();\n+}"}]}