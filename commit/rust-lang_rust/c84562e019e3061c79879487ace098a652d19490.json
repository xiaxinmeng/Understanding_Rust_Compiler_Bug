{"sha": "c84562e019e3061c79879487ace098a652d19490", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4NDU2MmUwMTllMzA2MWM3OTg3OTQ4N2FjZTA5OGE2NTJkMTk0OTA=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-08-02T23:30:03Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-08-06T20:20:05Z"}, "message": "Avoid modifying invocations in place for derive helper attributes", "tree": {"sha": "26a0747bcbbb41c22e79096074a418783cb1ccc8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26a0747bcbbb41c22e79096074a418783cb1ccc8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c84562e019e3061c79879487ace098a652d19490", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c84562e019e3061c79879487ace098a652d19490", "html_url": "https://github.com/rust-lang/rust/commit/c84562e019e3061c79879487ace098a652d19490", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c84562e019e3061c79879487ace098a652d19490/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "467a7ab2b1e108857c4555fed202a7e7bc5c5407", "url": "https://api.github.com/repos/rust-lang/rust/commits/467a7ab2b1e108857c4555fed202a7e7bc5c5407", "html_url": "https://github.com/rust-lang/rust/commit/467a7ab2b1e108857c4555fed202a7e7bc5c5407"}], "stats": {"total": 87, "additions": 28, "deletions": 59}, "files": [{"sha": "a283992c804e4592199635adc5087d4e1f75a538", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 24, "deletions": 38, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/c84562e019e3061c79879487ace098a652d19490/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84562e019e3061c79879487ace098a652d19490/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=c84562e019e3061c79879487ace098a652d19490", "patch": "@@ -20,13 +20,12 @@ use rustc::hir::map::{self, DefCollector};\n use rustc::{ty, lint};\n use rustc::middle::cstore::CrateStore;\n use syntax::ast::{self, Name, Ident};\n-use syntax::attr::{self, HasAttrs};\n+use syntax::attr;\n use syntax::errors::DiagnosticBuilder;\n-use syntax::ext::base::{self, Annotatable, Determinacy, MultiModifier, MultiDecorator};\n+use syntax::ext::base::{self, Determinacy, MultiModifier, MultiDecorator};\n use syntax::ext::base::{MacroKind, SyntaxExtension, Resolver as SyntaxResolver};\n-use syntax::ext::expand::{self, AstFragment, AstFragmentKind, Invocation, InvocationKind};\n+use syntax::ext::expand::{AstFragment, Invocation, InvocationKind};\n use syntax::ext::hygiene::{self, Mark};\n-use syntax::ext::placeholders::placeholder;\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{self, feature_err, emit_feature_err, is_builtin_attr_name, GateIssue};\n use syntax::fold::{self, Folder};\n@@ -320,7 +319,7 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n         None\n     }\n \n-    fn resolve_invoc(&mut self, invoc: &mut Invocation, scope: Mark, force: bool)\n+    fn resolve_invoc(&mut self, invoc: &Invocation, scope: Mark, force: bool)\n                      -> Result<Option<Lrc<SyntaxExtension>>, Determinacy> {\n         let def = match invoc.kind {\n             InvocationKind::Attr { attr: None, .. } => return Ok(None),\n@@ -330,17 +329,22 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n             self.report_proc_macro_stub(invoc.span());\n             return Err(Determinacy::Determined);\n         } else if let Def::NonMacroAttr(attr_kind) = def {\n-            let is_attr = if let InvocationKind::Attr { .. } = invoc.kind { true } else { false };\n-            if is_attr && attr_kind == NonMacroAttrKind::Tool {\n-                if !self.session.features_untracked().tool_attributes {\n-                    feature_err(&self.session.parse_sess, \"tool_attributes\",\n-                                invoc.span(), GateIssue::Language,\n-                                \"tool attributes are unstable\").emit();\n+            let is_attr_invoc =\n+                if let InvocationKind::Attr { .. } = invoc.kind { true } else { false };\n+            match attr_kind {\n+                NonMacroAttrKind::Tool | NonMacroAttrKind::DeriveHelper if is_attr_invoc => {\n+                    if attr_kind == NonMacroAttrKind::Tool &&\n+                       !self.session.features_untracked().tool_attributes {\n+                        feature_err(&self.session.parse_sess, \"tool_attributes\",\n+                                    invoc.span(), GateIssue::Language,\n+                                    \"tool attributes are unstable\").emit();\n+                    }\n+                    return Ok(Some(Lrc::new(SyntaxExtension::NonMacroAttr)));\n+                }\n+                _ => {\n+                    self.report_non_macro_attr(invoc.path_span(), def);\n+                    return Err(Determinacy::Determined);\n                 }\n-                return Ok(Some(Lrc::new(SyntaxExtension::NonMacroAttr)));\n-            } else {\n-                self.report_non_macro_attr(invoc.path_span(), def);\n-                return Err(Determinacy::Determined);\n             }\n         }\n         let def_id = def.def_id();\n@@ -401,10 +405,10 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         self.session.span_err(span, &format!(\"expected a macro, found {}\", def.kind_name()));\n     }\n \n-    fn resolve_invoc_to_def(&mut self, invoc: &mut Invocation, scope: Mark, force: bool)\n+    fn resolve_invoc_to_def(&mut self, invoc: &Invocation, scope: Mark, force: bool)\n                             -> Result<Def, Determinacy> {\n-        let (attr, traits, item) = match invoc.kind {\n-            InvocationKind::Attr { ref mut attr, ref traits, ref mut item } => (attr, traits, item),\n+        let (attr, traits) = match invoc.kind {\n+            InvocationKind::Attr { ref attr, ref traits, .. } => (attr, traits),\n             InvocationKind::Bang { ref mac, .. } => {\n                 return self.resolve_macro_to_def(scope, &mac.node.path, MacroKind::Bang, force);\n             }\n@@ -413,7 +417,6 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             }\n         };\n \n-\n         let path = attr.as_ref().unwrap().path.clone();\n         let mut determinacy = Determinacy::Determined;\n         match self.resolve_macro_to_def(scope, &path, MacroKind::Attr, force) {\n@@ -434,11 +437,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         // This loop here looks through all of the derive annotations in scope\n         // and tries to resolve them. If they themselves successfully resolve\n         // *and* the resolve mentions that this attribute's name is a registered\n-        // custom attribute then we flag this attribute as known and update\n-        // `invoc` above to point to the next invocation.\n-        //\n-        // By then returning `Undetermined` we should continue resolution to\n-        // resolve the next attribute.\n+        // custom attribute then we return that custom attribute as the resolution result.\n         let attr_name = match path.segments.len() {\n             1 => path.segments[0].ident.name,\n             _ => return Err(determinacy),\n@@ -447,20 +446,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             match self.resolve_macro(scope, path, MacroKind::Derive, force) {\n                 Ok(ext) => if let SyntaxExtension::ProcMacroDerive(_, ref inert_attrs, _) = *ext {\n                     if inert_attrs.contains(&attr_name) {\n-                        // FIXME(jseyfried) Avoid `mem::replace` here.\n-                        let dummy_item = placeholder(AstFragmentKind::Items, ast::DUMMY_NODE_ID)\n-                            .make_items().pop().unwrap();\n-                        let dummy_item = Annotatable::Item(dummy_item);\n-                        *item = mem::replace(item, dummy_item).map_attrs(|mut attrs| {\n-                            let inert_attr = attr.take().unwrap();\n-                            attr::mark_known(&inert_attr);\n-                            if self.use_extern_macros {\n-                                *attr = expand::find_attr_invoc(&mut attrs);\n-                            }\n-                            attrs.push(inert_attr);\n-                            attrs\n-                        });\n-                        return Err(Determinacy::Undetermined)\n+                        return Ok(Def::NonMacroAttr(NonMacroAttrKind::DeriveHelper));\n                     }\n                 },\n                 Err(Determinacy::Undetermined) => determinacy = Determinacy::Undetermined,"}, {"sha": "1bc5cb93c11a6fcc60c458b75425e45e77c06f3f", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c84562e019e3061c79879487ace098a652d19490/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84562e019e3061c79879487ace098a652d19490/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=c84562e019e3061c79879487ace098a652d19490", "patch": "@@ -726,7 +726,7 @@ pub trait Resolver {\n     fn find_legacy_attr_invoc(&mut self, attrs: &mut Vec<Attribute>, allow_derive: bool)\n                               -> Option<Attribute>;\n \n-    fn resolve_invoc(&mut self, invoc: &mut Invocation, scope: Mark, force: bool)\n+    fn resolve_invoc(&mut self, invoc: &Invocation, scope: Mark, force: bool)\n                      -> Result<Option<Lrc<SyntaxExtension>>, Determinacy>;\n     fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind, force: bool)\n                      -> Result<Lrc<SyntaxExtension>, Determinacy>;\n@@ -754,7 +754,7 @@ impl Resolver for DummyResolver {\n     fn resolve_imports(&mut self) {}\n     fn find_legacy_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>, _allow_derive: bool)\n                               -> Option<Attribute> { None }\n-    fn resolve_invoc(&mut self, _invoc: &mut Invocation, _scope: Mark, _force: bool)\n+    fn resolve_invoc(&mut self, _invoc: &Invocation, _scope: Mark, _force: bool)\n                      -> Result<Option<Lrc<SyntaxExtension>>, Determinacy> {\n         Err(Determinacy::Determined)\n     }"}, {"sha": "7148f3c00f2d6f0c691dfea308a96cf638d10eb4", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c84562e019e3061c79879487ace098a652d19490/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84562e019e3061c79879487ace098a652d19490/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=c84562e019e3061c79879487ace098a652d19490", "patch": "@@ -252,13 +252,6 @@ impl Invocation {\n             InvocationKind::Derive { ref path, .. } => path.span,\n         }\n     }\n-\n-    pub fn attr_id(&self) -> Option<ast::AttrId> {\n-        match self.kind {\n-            InvocationKind::Attr { attr: Some(ref attr), .. } => Some(attr.id),\n-            _ => None,\n-        }\n-    }\n }\n \n pub struct MacroExpander<'a, 'b:'a> {\n@@ -338,7 +331,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         let mut undetermined_invocations = Vec::new();\n         let (mut progress, mut force) = (false, !self.monotonic);\n         loop {\n-            let mut invoc = if let Some(invoc) = invocations.pop() {\n+            let invoc = if let Some(invoc) = invocations.pop() {\n                 invoc\n             } else {\n                 self.resolve_imports();\n@@ -350,20 +343,10 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n             let scope =\n                 if self.monotonic { invoc.expansion_data.mark } else { orig_expansion_data.mark };\n-            let attr_id_before = invoc.attr_id();\n-            let ext = match self.cx.resolver.resolve_invoc(&mut invoc, scope, force) {\n+            let ext = match self.cx.resolver.resolve_invoc(&invoc, scope, force) {\n                 Ok(ext) => Some(ext),\n                 Err(Determinacy::Determined) => None,\n                 Err(Determinacy::Undetermined) => {\n-                    // Sometimes attributes which we thought were invocations\n-                    // end up being custom attributes for custom derives. If\n-                    // that's the case our `invoc` will have changed out from\n-                    // under us. If this is the case we're making progress so we\n-                    // want to flag it as such, and we test this by looking if\n-                    // the `attr_id()` method has been changing over time.\n-                    if invoc.attr_id() != attr_id_before {\n-                        progress = true;\n-                    }\n                     undetermined_invocations.push(invoc);\n                     continue\n                 }"}]}