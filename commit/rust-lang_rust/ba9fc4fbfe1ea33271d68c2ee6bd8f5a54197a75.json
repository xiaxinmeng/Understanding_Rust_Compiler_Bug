{"sha": "ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75", "node_id": "C_kwDOAAsO6NoAKGJhOWZjNGZiZmUxZWEzMzI3MWQ2OGMyZWU2YmQ4ZjVhNTQxOTdhNzU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-06T06:58:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-06T06:58:41Z"}, "message": "Auto merge of #91565 - dtolnay:printhelpers, r=jackh726\n\nDelete duplicated helpers from HIR printer\n\nThese functions (`cbox`, `nbsp`, `word_nbsp`, `head`, `bopen`, `space_if_not_bol`, `break_offset_if_not_bol`, `synth_comment`, `maybe_print_trailing_comment`, `print_remaining_comments`) are duplicated with identical behavior across the AST printer and HIR printer, but are not specific to AST or HIR data structures.", "tree": {"sha": "76829cdba8922892b24fb1056f3288ef7e197b10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76829cdba8922892b24fb1056f3288ef7e197b10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75", "html_url": "https://github.com/rust-lang/rust/commit/ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87dce6e8dfdae605c9c2a713cf0133066a52022a", "url": "https://api.github.com/repos/rust-lang/rust/commits/87dce6e8dfdae605c9c2a713cf0133066a52022a", "html_url": "https://github.com/rust-lang/rust/commit/87dce6e8dfdae605c9c2a713cf0133066a52022a"}, {"sha": "596e33ac32beca194f20949a0005be27c5cad08e", "url": "https://api.github.com/repos/rust-lang/rust/commits/596e33ac32beca194f20949a0005be27c5cad08e", "html_url": "https://github.com/rust-lang/rust/commit/596e33ac32beca194f20949a0005be27c5cad08e"}], "stats": {"total": 144, "additions": 30, "deletions": 114}, "files": [{"sha": "5ec71cddf7de6bfc86be59362e38af97dcc16499", "filename": "compiler/rustc_ast_pretty/src/helpers.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75/compiler%2Frustc_ast_pretty%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75/compiler%2Frustc_ast_pretty%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fhelpers.rs?ref=ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75", "patch": "@@ -35,4 +35,14 @@ impl Printer {\n         self.word(w);\n         self.nbsp()\n     }\n+\n+    // Synthesizes a comment that was not textually present in the original\n+    // source file.\n+    pub fn synth_comment(&mut self, text: impl Into<Cow<'static, str>>) {\n+        self.word(\"/*\");\n+        self.space();\n+        self.word(text);\n+        self.space();\n+        self.word(\"*/\")\n+    }\n }"}, {"sha": "95d45f07e9dccd10e60c4490bc3b185927b41483", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 19, "deletions": 33, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75", "patch": "@@ -349,6 +349,25 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n         self.comments().as_mut().and_then(|c| c.next())\n     }\n \n+    fn maybe_print_trailing_comment(&mut self, span: rustc_span::Span, next_pos: Option<BytePos>) {\n+        if let Some(cmnts) = self.comments() {\n+            if let Some(cmnt) = cmnts.trailing_comment(span, next_pos) {\n+                self.print_comment(&cmnt);\n+            }\n+        }\n+    }\n+\n+    fn print_remaining_comments(&mut self) {\n+        // If there aren't any remaining comments, then we need to manually\n+        // make sure there is a line break at the end.\n+        if self.next_comment().is_none() {\n+            self.hardbreak();\n+        }\n+        while let Some(ref cmnt) = self.next_comment() {\n+            self.print_comment(cmnt)\n+        }\n+    }\n+\n     fn print_literal(&mut self, lit: &ast::Lit) {\n         self.maybe_print_comment(lit.span.lo());\n         self.word(lit.token.to_string())\n@@ -893,16 +912,6 @@ impl<'a> State<'a> {\n         State { s: pp::mk_printer(), comments: None, ann: &NoAnn }\n     }\n \n-    // Synthesizes a comment that was not textually present in the original source\n-    // file.\n-    pub fn synth_comment(&mut self, text: String) {\n-        self.s.word(\"/*\");\n-        self.s.space();\n-        self.s.word(text);\n-        self.s.space();\n-        self.s.word(\"*/\")\n-    }\n-\n     crate fn commasep_cmnt<T, F, G>(&mut self, b: Breaks, elts: &[T], mut op: F, mut get_span: G)\n     where\n         F: FnMut(&mut State<'_>, &T),\n@@ -2920,29 +2929,6 @@ impl<'a> State<'a> {\n         self.end();\n     }\n \n-    crate fn maybe_print_trailing_comment(\n-        &mut self,\n-        span: rustc_span::Span,\n-        next_pos: Option<BytePos>,\n-    ) {\n-        if let Some(cmnts) = self.comments() {\n-            if let Some(cmnt) = cmnts.trailing_comment(span, next_pos) {\n-                self.print_comment(&cmnt);\n-            }\n-        }\n-    }\n-\n-    crate fn print_remaining_comments(&mut self) {\n-        // If there aren't any remaining comments, then we need to manually\n-        // make sure there is a line break at the end.\n-        if self.next_comment().is_none() {\n-            self.s.hardbreak();\n-        }\n-        while let Some(ref cmnt) = self.next_comment() {\n-            self.print_comment(cmnt);\n-        }\n-    }\n-\n     crate fn print_fn_header_info(&mut self, header: ast::FnHeader) {\n         self.print_constness(header.constness);\n         self.print_asyncness(header.asyncness);"}, {"sha": "6b1ef598b45539008e7f546775f7150d2045db4b", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 81, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75", "patch": "@@ -10,7 +10,7 @@ use rustc_hir::{GenericArg, GenericParam, GenericParamKind, Node};\n use rustc_hir::{GenericBound, PatKind, RangeEnd, TraitBoundModifier};\n use rustc_span::source_map::{SourceMap, Spanned};\n use rustc_span::symbol::{kw, Ident, IdentPrinter, Symbol};\n-use rustc_span::{self, BytePos, FileName};\n+use rustc_span::{self, FileName};\n use rustc_target::spec::abi::Abi;\n \n use std::borrow::Cow;\n@@ -241,36 +241,6 @@ pub fn enum_def_to_string(\n }\n \n impl<'a> State<'a> {\n-    pub fn cbox(&mut self, u: usize) {\n-        self.s.cbox(u);\n-    }\n-\n-    pub fn nbsp(&mut self) {\n-        self.s.word(\" \")\n-    }\n-\n-    pub fn word_nbsp<S: Into<Cow<'static, str>>>(&mut self, w: S) {\n-        self.s.word(w);\n-        self.nbsp()\n-    }\n-\n-    pub fn head<S: Into<Cow<'static, str>>>(&mut self, w: S) {\n-        let w = w.into();\n-        // outer-box is consistent\n-        self.cbox(INDENT_UNIT);\n-        // head-box is inconsistent\n-        self.ibox(w.len() + 1);\n-        // keyword that starts the head\n-        if !w.is_empty() {\n-            self.word_nbsp(w);\n-        }\n-    }\n-\n-    pub fn bopen(&mut self) {\n-        self.s.word(\"{\");\n-        self.end(); // close the head-box\n-    }\n-\n     pub fn bclose_maybe_open(&mut self, span: rustc_span::Span, close_box: bool) {\n         self.maybe_print_comment(span.hi());\n         self.break_offset_if_not_bol(1, -(INDENT_UNIT as isize));\n@@ -284,33 +254,6 @@ impl<'a> State<'a> {\n         self.bclose_maybe_open(span, true)\n     }\n \n-    pub fn space_if_not_bol(&mut self) {\n-        if !self.s.is_beginning_of_line() {\n-            self.s.space();\n-        }\n-    }\n-\n-    pub fn break_offset_if_not_bol(&mut self, n: usize, off: isize) {\n-        if !self.s.is_beginning_of_line() {\n-            self.s.break_offset(n, off)\n-        } else if off != 0 && self.s.last_token().is_hardbreak_tok() {\n-            // We do something pretty sketchy here: tuck the nonzero\n-            // offset-adjustment we were going to deposit along with the\n-            // break into the previous hardbreak.\n-            self.s.replace_last_token(pp::Printer::hardbreak_tok_offset(off));\n-        }\n-    }\n-\n-    // Synthesizes a comment that was not textually present in the original source\n-    // file.\n-    pub fn synth_comment(&mut self, text: String) {\n-        self.s.word(\"/*\");\n-        self.s.space();\n-        self.s.word(text);\n-        self.s.space();\n-        self.s.word(\"*/\")\n-    }\n-\n     pub fn commasep_cmnt<T, F, G>(&mut self, b: Breaks, elts: &[T], mut op: F, mut get_span: G)\n     where\n         F: FnMut(&mut State<'_>, &T),\n@@ -2408,29 +2351,6 @@ impl<'a> State<'a> {\n         self.end();\n     }\n \n-    pub fn maybe_print_trailing_comment(\n-        &mut self,\n-        span: rustc_span::Span,\n-        next_pos: Option<BytePos>,\n-    ) {\n-        if let Some(cmnts) = self.comments() {\n-            if let Some(cmnt) = cmnts.trailing_comment(span, next_pos) {\n-                self.print_comment(&cmnt);\n-            }\n-        }\n-    }\n-\n-    pub fn print_remaining_comments(&mut self) {\n-        // If there aren't any remaining comments, then we need to manually\n-        // make sure there is a line break at the end.\n-        if self.next_comment().is_none() {\n-            self.s.hardbreak();\n-        }\n-        while let Some(ref cmnt) = self.next_comment() {\n-            self.print_comment(cmnt)\n-        }\n-    }\n-\n     pub fn print_fn_header_info(&mut self, header: hir::FnHeader, vis: &hir::Visibility<'_>) {\n         self.s.word(visibility_qualified(vis, \"\"));\n "}]}