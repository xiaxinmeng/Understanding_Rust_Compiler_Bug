{"sha": "2fce2290865f012391b8f3e581c3852a248031fa", "node_id": "C_kwDOAAsO6NoAKDJmY2UyMjkwODY1ZjAxMjM5MWI4ZjNlNTgxYzM4NTJhMjQ4MDMxZmE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-28T06:32:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-28T06:32:01Z"}, "message": "Auto merge of #110924 - matthiaskrgr:rollup-jvznpq2, r=matthiaskrgr\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #110766 (More core::fmt::rt cleanup.)\n - #110873 (Migrate trivially translatable `rustc_parse` diagnostics)\n - #110904 (rustdoc: rebind bound vars to type-outlives predicates)\n - #110913 (Add some missing built-in lints)\n - #110918 (`remove_dir_all`: try deleting the directory even if `FILE_LIST_DIRECTORY` access is denied)\n - #110920 (Fix unavailable url)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "e28cb411ec3d66bcaeb15a1dc3e43dff84a60d5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e28cb411ec3d66bcaeb15a1dc3e43dff84a60d5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fce2290865f012391b8f3e581c3852a248031fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fce2290865f012391b8f3e581c3852a248031fa", "html_url": "https://github.com/rust-lang/rust/commit/2fce2290865f012391b8f3e581c3852a248031fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fce2290865f012391b8f3e581c3852a248031fa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "033aa092ab23ba14cdad27073c5e37ba0eddb428", "url": "https://api.github.com/repos/rust-lang/rust/commits/033aa092ab23ba14cdad27073c5e37ba0eddb428", "html_url": "https://github.com/rust-lang/rust/commit/033aa092ab23ba14cdad27073c5e37ba0eddb428"}, {"sha": "dda14941e0075357a1645773889689b5413518c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/dda14941e0075357a1645773889689b5413518c1", "html_url": "https://github.com/rust-lang/rust/commit/dda14941e0075357a1645773889689b5413518c1"}], "stats": {"total": 1536, "additions": 898, "deletions": 638}, "files": [{"sha": "3ed342ce48b43194ab30a70997f5c2b5d34536df", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -2976,7 +2976,7 @@ pub enum ItemKind {\n }\n \n impl ItemKind {\n-    pub fn article(&self) -> &str {\n+    pub fn article(&self) -> &'static str {\n         use ItemKind::*;\n         match self {\n             Use(..) | Static(..) | Const(..) | Fn(..) | Mod(..) | GlobalAsm(..) | TyAlias(..)\n@@ -2985,7 +2985,7 @@ impl ItemKind {\n         }\n     }\n \n-    pub fn descr(&self) -> &str {\n+    pub fn descr(&self) -> &'static str {\n         match self {\n             ItemKind::ExternCrate(..) => \"extern crate\",\n             ItemKind::Use(..) => \"`use` import\","}, {"sha": "c081162ea1467eb5b46425ffc1433e354c57aba2", "filename": "compiler/rustc_ast_lowering/src/format.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -186,7 +186,7 @@ enum ArgumentType {\n /// Generates:\n ///\n /// ```text\n-///     <core::fmt::ArgumentV1>::new_\u2026(arg)\n+///     <core::fmt::Argument>::new_\u2026(arg)\n /// ```\n fn make_argument<'hir>(\n     ctx: &mut LoweringContext<'_, 'hir>,\n@@ -327,7 +327,7 @@ fn make_format_spec<'hir>(\n             None => sym::Unknown,\n         },\n     );\n-    // This needs to match `FlagV1` in library/core/src/fmt/mod.rs.\n+    // This needs to match `Flag` in library/core/src/fmt/rt.rs.\n     let flags: u32 = ((sign == Some(FormatSign::Plus)) as u32)\n         | ((sign == Some(FormatSign::Minus)) as u32) << 1\n         | (alternate as u32) << 2\n@@ -438,7 +438,7 @@ fn expand_format_args<'hir>(\n     // If the args array contains exactly all the original arguments once,\n     // in order, we can use a simple array instead of a `match` construction.\n     // However, if there's a yield point in any argument except the first one,\n-    // we don't do this, because an ArgumentV1 cannot be kept across yield points.\n+    // we don't do this, because an Argument cannot be kept across yield points.\n     //\n     // This is an optimization, speeding up compilation about 1-2% in some cases.\n     // See https://github.com/rust-lang/rust/pull/106770#issuecomment-1380790609\n@@ -449,9 +449,9 @@ fn expand_format_args<'hir>(\n     let args = if use_simple_array {\n         // Generate:\n         //     &[\n-        //         <core::fmt::ArgumentV1>::new_display(&arg0),\n-        //         <core::fmt::ArgumentV1>::new_lower_hex(&arg1),\n-        //         <core::fmt::ArgumentV1>::new_debug(&arg2),\n+        //         <core::fmt::Argument>::new_display(&arg0),\n+        //         <core::fmt::Argument>::new_lower_hex(&arg1),\n+        //         <core::fmt::Argument>::new_debug(&arg2),\n         //         \u2026\n         //     ]\n         let elements: Vec<_> = arguments\n@@ -477,9 +477,9 @@ fn expand_format_args<'hir>(\n         // Generate:\n         //     &match (&arg0, &arg1, &\u2026) {\n         //         args => [\n-        //             <core::fmt::ArgumentV1>::new_display(args.0),\n-        //             <core::fmt::ArgumentV1>::new_lower_hex(args.1),\n-        //             <core::fmt::ArgumentV1>::new_debug(args.0),\n+        //             <core::fmt::Argument>::new_display(args.0),\n+        //             <core::fmt::Argument>::new_lower_hex(args.1),\n+        //             <core::fmt::Argument>::new_debug(args.0),\n         //             \u2026\n         //         ]\n         //     }"}, {"sha": "4fb668545712e58ae0a84807edb15b45015d578a", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -296,7 +296,7 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n                 diag_trait(&mut err, self_ty, tcx.require_lang_item(LangItem::Deref, Some(span)));\n                 err\n             }\n-            _ if tcx.opt_parent(callee) == tcx.get_diagnostic_item(sym::ArgumentV1Methods) => ccx\n+            _ if tcx.opt_parent(callee) == tcx.get_diagnostic_item(sym::ArgumentMethods) => ccx\n                 .tcx\n                 .sess\n                 .create_err(errors::NonConstFmtMacroCall { span, kind: ccx.const_kind() }),"}, {"sha": "a3d7bd3ef59a357f3f2abcb4d8d00cf8a7429468", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 93, "deletions": 88, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -3273,110 +3273,115 @@ declare_lint_pass! {\n     /// Does nothing as a lint pass, but registers some `Lint`s\n     /// that are used by other parts of the compiler.\n     HardwiredLints => [\n-        FORBIDDEN_LINT_GROUPS,\n-        ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n+        // tidy-alphabetical-start\n+        ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE,\n+        AMBIGUOUS_ASSOCIATED_ITEMS,\n+        AMBIGUOUS_GLOB_REEXPORTS,\n         ARITHMETIC_OVERFLOW,\n-        UNCONDITIONAL_PANIC,\n-        UNUSED_IMPORTS,\n-        UNUSED_EXTERN_CRATES,\n-        UNUSED_CRATE_DEPENDENCIES,\n-        UNUSED_QUALIFICATIONS,\n-        UNKNOWN_LINTS,\n-        UNFULFILLED_LINT_EXPECTATIONS,\n-        UNUSED_VARIABLES,\n-        UNUSED_ASSIGNMENTS,\n-        DEAD_CODE,\n-        UNREACHABLE_CODE,\n-        UNREACHABLE_PATTERNS,\n-        OVERLAPPING_RANGE_ENDPOINTS,\n+        ASM_SUB_REGISTER,\n+        BAD_ASM_STYLE,\n+        BARE_TRAIT_OBJECTS,\n         BINDINGS_WITH_VARIANT_NAME,\n-        UNUSED_MACROS,\n-        UNUSED_MACRO_RULES,\n-        WARNINGS,\n-        UNUSED_FEATURES,\n-        STABLE_FEATURES,\n-        UNKNOWN_CRATE_TYPES,\n-        TRIVIAL_CASTS,\n-        TRIVIAL_NUMERIC_CASTS,\n-        PRIVATE_IN_PUBLIC,\n-        EXPORTED_PRIVATE_DEPENDENCIES,\n-        PUB_USE_OF_PRIVATE_EXTERN_CRATE,\n-        INVALID_TYPE_PARAM_DEFAULT,\n-        RENAMED_AND_REMOVED_LINTS,\n-        CONST_ITEM_MUTATION,\n-        PATTERNS_IN_FNS_WITHOUT_BODY,\n-        MISSING_FRAGMENT_SPECIFIER,\n-        LATE_BOUND_LIFETIME_ARGUMENTS,\n-        ORDER_DEPENDENT_TRAIT_OBJECTS,\n+        BREAK_WITH_LABEL_AND_LOOP,\n+        BYTE_SLICE_IN_PACKED_STRUCT_WITH_DERIVE,\n+        CENUM_IMPL_DROP_CAST,\n         COHERENCE_LEAK_CHECK,\n+        CONFLICTING_REPR_HINTS,\n+        CONST_EVALUATABLE_UNCHECKED,\n+        CONST_ITEM_MUTATION,\n+        DEAD_CODE,\n         DEPRECATED,\n-        UNUSED_UNSAFE,\n-        UNUSED_MUT,\n-        UNCONDITIONAL_RECURSION,\n-        SINGLE_USE_LIFETIMES,\n-        UNUSED_LIFETIMES,\n-        UNUSED_LABELS,\n-        TYVAR_BEHIND_RAW_POINTER,\n+        DEPRECATED_CFG_ATTR_CRATE_TYPE_NAME,\n+        DEPRECATED_IN_FUTURE,\n+        DEPRECATED_WHERE_CLAUSE_LOCATION,\n+        DUPLICATE_MACRO_ATTRIBUTES,\n         ELIDED_LIFETIMES_IN_PATHS,\n-        BARE_TRAIT_OBJECTS,\n-        ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE,\n-        UNSTABLE_NAME_COLLISIONS,\n-        IRREFUTABLE_LET_PATTERNS,\n-        WHERE_CLAUSES_OBJECT_SAFETY,\n-        PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n-        MACRO_USE_EXTERN_CRATE,\n-        MACRO_EXPANDED_MACRO_EXPORTS_ACCESSED_BY_ABSOLUTE_PATHS,\n+        EXPORTED_PRIVATE_DEPENDENCIES,\n+        FFI_UNWIND_CALLS,\n+        FORBIDDEN_LINT_GROUPS,\n+        FUNCTION_ITEM_REFERENCES,\n+        FUZZY_PROVENANCE_CASTS,\n         ILL_FORMED_ATTRIBUTE_INPUT,\n-        CONFLICTING_REPR_HINTS,\n-        META_VARIABLE_MISUSE,\n-        DEPRECATED_IN_FUTURE,\n-        AMBIGUOUS_ASSOCIATED_ITEMS,\n-        INDIRECT_STRUCTURAL_MATCH,\n-        POINTER_STRUCTURAL_MATCH,\n-        NONTRIVIAL_STRUCTURAL_MATCH,\n-        SOFT_UNSTABLE,\n-        UNSTABLE_SYNTAX_PRE_EXPANSION,\n-        INLINE_NO_SANITIZE,\n-        BAD_ASM_STYLE,\n-        ASM_SUB_REGISTER,\n-        UNSAFE_OP_IN_UNSAFE_FN,\n+        ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n+        IMPLIED_BOUNDS_ENTAILMENT,\n         INCOMPLETE_INCLUDE,\n-        CENUM_IMPL_DROP_CAST,\n-        FUZZY_PROVENANCE_CASTS,\n-        LOSSY_PROVENANCE_CASTS,\n-        CONST_EVALUATABLE_UNCHECKED,\n+        INDIRECT_STRUCTURAL_MATCH,\n         INEFFECTIVE_UNSTABLE_TRAIT_IMPL,\n-        MUST_NOT_SUSPEND,\n-        UNINHABITED_STATIC,\n-        FUNCTION_ITEM_REFERENCES,\n-        USELESS_DEPRECATED,\n-        MISSING_ABI,\n+        INLINE_NO_SANITIZE,\n+        INVALID_ALIGNMENT,\n         INVALID_DOC_ATTRIBUTES,\n-        SEMICOLON_IN_EXPRESSIONS_FROM_MACROS,\n-        RUST_2021_INCOMPATIBLE_CLOSURE_CAPTURES,\n+        INVALID_MACRO_EXPORT_ARGUMENTS,\n+        INVALID_TYPE_PARAM_DEFAULT,\n+        IRREFUTABLE_LET_PATTERNS,\n+        LARGE_ASSIGNMENTS,\n+        LATE_BOUND_LIFETIME_ARGUMENTS,\n         LEGACY_DERIVE_HELPERS,\n+        LOSSY_PROVENANCE_CASTS,\n+        MACRO_EXPANDED_MACRO_EXPORTS_ACCESSED_BY_ABSOLUTE_PATHS,\n+        MACRO_USE_EXTERN_CRATE,\n+        META_VARIABLE_MISUSE,\n+        MISSING_ABI,\n+        MISSING_FRAGMENT_SPECIFIER,\n+        MUST_NOT_SUSPEND,\n+        NAMED_ARGUMENTS_USED_POSITIONALLY,\n+        NON_EXHAUSTIVE_OMITTED_PATTERNS,\n+        NONTRIVIAL_STRUCTURAL_MATCH,\n+        ORDER_DEPENDENT_TRAIT_OBJECTS,\n+        OVERLAPPING_RANGE_ENDPOINTS,\n+        PATTERNS_IN_FNS_WITHOUT_BODY,\n+        POINTER_STRUCTURAL_MATCH,\n+        PRIVATE_IN_PUBLIC,\n         PROC_MACRO_BACK_COMPAT,\n+        PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n+        PUB_USE_OF_PRIVATE_EXTERN_CRATE,\n+        RENAMED_AND_REMOVED_LINTS,\n+        REPR_TRANSPARENT_EXTERNAL_PRIVATE_FIELDS,\n+        RUST_2021_INCOMPATIBLE_CLOSURE_CAPTURES,\n         RUST_2021_INCOMPATIBLE_OR_PATTERNS,\n-        LARGE_ASSIGNMENTS,\n-        RUST_2021_PRELUDE_COLLISIONS,\n         RUST_2021_PREFIXES_INCOMPATIBLE_SYNTAX,\n+        RUST_2021_PRELUDE_COLLISIONS,\n+        SEMICOLON_IN_EXPRESSIONS_FROM_MACROS,\n+        SINGLE_USE_LIFETIMES,\n+        SOFT_UNSTABLE,\n+        STABLE_FEATURES,\n+        SUSPICIOUS_AUTO_TRAIT_IMPLS,\n+        TEST_UNSTABLE_LINT,\n+        TEXT_DIRECTION_CODEPOINT_IN_COMMENT,\n+        TRIVIAL_CASTS,\n+        TRIVIAL_NUMERIC_CASTS,\n+        TYVAR_BEHIND_RAW_POINTER,\n+        UNCONDITIONAL_PANIC,\n+        UNCONDITIONAL_RECURSION,\n+        UNDEFINED_NAKED_FUNCTION_ABI,\n+        UNFULFILLED_LINT_EXPECTATIONS,\n+        UNINHABITED_STATIC,\n+        UNKNOWN_CRATE_TYPES,\n+        UNKNOWN_LINTS,\n+        UNREACHABLE_CODE,\n+        UNREACHABLE_PATTERNS,\n+        UNSAFE_OP_IN_UNSAFE_FN,\n+        UNSTABLE_NAME_COLLISIONS,\n+        UNSTABLE_SYNTAX_PRE_EXPANSION,\n         UNSUPPORTED_CALLING_CONVENTIONS,\n-        BREAK_WITH_LABEL_AND_LOOP,\n+        UNUSED_ASSIGNMENTS,\n         UNUSED_ATTRIBUTES,\n+        UNUSED_CRATE_DEPENDENCIES,\n+        UNUSED_EXTERN_CRATES,\n+        UNUSED_FEATURES,\n+        UNUSED_IMPORTS,\n+        UNUSED_LABELS,\n+        UNUSED_LIFETIMES,\n+        UNUSED_MACRO_RULES,\n+        UNUSED_MACROS,\n+        UNUSED_MUT,\n+        UNUSED_QUALIFICATIONS,\n         UNUSED_TUPLE_STRUCT_FIELDS,\n-        NON_EXHAUSTIVE_OMITTED_PATTERNS,\n-        TEXT_DIRECTION_CODEPOINT_IN_COMMENT,\n-        DEPRECATED_CFG_ATTR_CRATE_TYPE_NAME,\n-        DUPLICATE_MACRO_ATTRIBUTES,\n-        SUSPICIOUS_AUTO_TRAIT_IMPLS,\n-        DEPRECATED_WHERE_CLAUSE_LOCATION,\n-        TEST_UNSTABLE_LINT,\n-        FFI_UNWIND_CALLS,\n-        REPR_TRANSPARENT_EXTERNAL_PRIVATE_FIELDS,\n-        NAMED_ARGUMENTS_USED_POSITIONALLY,\n-        IMPLIED_BOUNDS_ENTAILMENT,\n-        BYTE_SLICE_IN_PACKED_STRUCT_WITH_DERIVE,\n-        AMBIGUOUS_GLOB_REEXPORTS,\n+        UNUSED_UNSAFE,\n+        UNUSED_VARIABLES,\n+        USELESS_DEPRECATED,\n+        WARNINGS,\n+        WHERE_CLAUSES_OBJECT_SAFETY,\n+        // tidy-alphabetical-end\n     ]\n }\n "}, {"sha": "9c4fac84fc294f0c40e6780b7e7afbbdeefd5a84", "filename": "compiler/rustc_parse/messages.ftl", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/compiler%2Frustc_parse%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/compiler%2Frustc_parse%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fmessages.ftl?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -772,3 +772,75 @@ parse_const_bounds_missing_tilde = const bounds must start with `~`\n     .suggestion = add `~`\n \n parse_underscore_literal_suffix = underscore literal suffix is not allowed\n+\n+parse_expect_label_found_ident = expected a label, found an identifier\n+    .suggestion = labels start with a tick\n+\n+parse_inappropriate_default = {$article} {$descr} cannot be `default`\n+    .label = `default` because of this\n+    .note = only associated `fn`, `const`, and `type` items can be `default`\n+\n+parse_recover_import_as_use = expected item, found {$token_name}\n+    .suggestion = items are imported using the `use` keyword\n+\n+parse_single_colon_import_path = expected `::`, found `:`\n+    .suggestion = use double colon\n+    .note = import paths are delimited using `::`\n+\n+parse_bad_item_kind = {$descr} is not supported in {$ctx}\n+    .help = consider moving the {$descr} out to a nearby module scope\n+\n+parse_single_colon_struct_type = found single colon in a struct field type path\n+    .suggestion = write a path separator here\n+\n+parse_equals_struct_default = default values on `struct` fields aren't supported\n+    .suggestion = remove this unsupported default value\n+\n+parse_macro_rules_missing_bang = expected `!` after `macro_rules`\n+    .suggestion = add a `!`\n+\n+parse_macro_name_remove_bang = macro names aren't followed by a `!`\n+    .suggestion = remove the `!`\n+\n+parse_macro_rules_visibility = can't qualify macro_rules invocation with `{$vis}`\n+    .suggestion = try exporting the macro\n+\n+parse_macro_invocation_visibility = can't qualify macro invocation with `pub`\n+    .suggestion = remove the visibility\n+    .help = try adjusting the macro to put `{$vis}` inside the invocation\n+\n+parse_nested_adt = `{$kw_str}` definition cannot be nested inside `{$keyword}`\n+    .suggestion = consider creating a new `{$kw_str}` definition instead of nesting\n+\n+parse_function_body_equals_expr = function body cannot be `= expression;`\n+    .suggestion = surround the expression with `{\"{\"}` and `{\"}\"}` instead of `=` and `;`\n+\n+parse_box_not_pat = expected pattern, found {$descr}\n+    .note = `box` is a reserved keyword\n+    .suggestion = escape `box` to use it as an identifier\n+\n+parse_unmatched_angle = unmatched angle {$plural ->\n+    [true] brackets\n+    *[false] bracket\n+    }\n+    .suggestion = remove extra angle {$plural ->\n+    [true] brackets\n+    *[false] bracket\n+    }\n+\n+parse_missing_plus_in_bounds = expected `+` between lifetime and {$sym}\n+    .suggestion = add `+`\n+\n+parse_incorrect_braces_trait_bounds = incorrect braces around trait bounds\n+    .suggestion = remove the parentheses\n+\n+parse_kw_bad_case = keyword `{$kw}` is written in the wrong case\n+    .suggestion = write it in the correct case\n+\n+parse_meta_bad_delim = wrong meta list delimiters\n+parse_cfg_attr_bad_delim = wrong `cfg_attr` delimiters\n+parse_meta_bad_delim_suggestion = the delimiters should be `(` and `)`\n+\n+parse_malformed_cfg_attr = malformed `cfg_attr` attribute input\n+    .suggestion = missing condition and attribute\n+    .note = for more information, visit <https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute>"}, {"sha": "f286707a9c0df5621e5b265c4c209ec1db99d5fd", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -2421,3 +2421,227 @@ pub(crate) struct UnderscoreLiteralSuffix {\n     #[primary_span]\n     pub span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_expect_label_found_ident)]\n+pub(crate) struct ExpectedLabelFoundIdent {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \"'\", applicability = \"machine-applicable\", style = \"short\")]\n+    pub start: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_inappropriate_default)]\n+#[note]\n+pub(crate) struct InappropriateDefault {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub article: &'static str,\n+    pub descr: &'static str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_recover_import_as_use)]\n+pub(crate) struct RecoverImportAsUse {\n+    #[primary_span]\n+    #[suggestion(code = \"use\", applicability = \"machine-applicable\", style = \"short\")]\n+    pub span: Span,\n+    pub token_name: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_single_colon_import_path)]\n+#[note]\n+pub(crate) struct SingleColonImportPath {\n+    #[primary_span]\n+    #[suggestion(code = \"::\", applicability = \"machine-applicable\", style = \"short\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_bad_item_kind)]\n+#[help]\n+pub(crate) struct BadItemKind {\n+    #[primary_span]\n+    pub span: Span,\n+    pub descr: &'static str,\n+    pub ctx: &'static str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_single_colon_struct_type)]\n+pub(crate) struct SingleColonStructType {\n+    #[primary_span]\n+    #[suggestion(code = \"::\", applicability = \"maybe-incorrect\", style = \"verbose\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_equals_struct_default)]\n+pub(crate) struct EqualsStructDefault {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_macro_rules_missing_bang)]\n+pub(crate) struct MacroRulesMissingBang {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \"!\", applicability = \"machine-applicable\", style = \"verbose\")]\n+    pub hi: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_macro_name_remove_bang)]\n+pub(crate) struct MacroNameRemoveBang {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_macro_rules_visibility)]\n+pub(crate) struct MacroRulesVisibility<'a> {\n+    #[primary_span]\n+    #[suggestion(code = \"#[macro_export]\", applicability = \"maybe-incorrect\")]\n+    pub span: Span,\n+    pub vis: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_macro_invocation_visibility)]\n+#[help]\n+pub(crate) struct MacroInvocationVisibility<'a> {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+    pub vis: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_nested_adt)]\n+pub(crate) struct NestedAdt<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \"\", applicability = \"maybe-incorrect\")]\n+    pub item: Span,\n+    pub keyword: &'a str,\n+    pub kw_str: Cow<'a, str>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_function_body_equals_expr)]\n+pub(crate) struct FunctionBodyEqualsExpr {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sugg: FunctionBodyEqualsExprSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parse_suggestion, applicability = \"machine-applicable\")]\n+pub(crate) struct FunctionBodyEqualsExprSugg {\n+    #[suggestion_part(code = \"{{\")]\n+    pub eq: Span,\n+    #[suggestion_part(code = \" }}\")]\n+    pub semi: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_box_not_pat)]\n+pub(crate) struct BoxNotPat {\n+    #[primary_span]\n+    pub span: Span,\n+    #[note]\n+    pub kw: Span,\n+    #[suggestion(code = \"r#\", applicability = \"maybe-incorrect\", style = \"verbose\")]\n+    pub lo: Span,\n+    pub descr: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_unmatched_angle)]\n+pub(crate) struct UnmatchedAngle {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+    pub plural: bool,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_missing_plus_in_bounds)]\n+pub(crate) struct MissingPlusBounds {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \" +\", applicability = \"maybe-incorrect\", style = \"verbose\")]\n+    pub hi: Span,\n+    pub sym: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_incorrect_braces_trait_bounds)]\n+pub(crate) struct IncorrectBracesTraitBounds {\n+    #[primary_span]\n+    pub span: Vec<Span>,\n+    #[subdiagnostic]\n+    pub sugg: IncorrectBracesTraitBoundsSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parse_suggestion, applicability = \"machine-applicable\")]\n+pub(crate) struct IncorrectBracesTraitBoundsSugg {\n+    #[suggestion_part(code = \" \")]\n+    pub l: Span,\n+    #[suggestion_part(code = \"\")]\n+    pub r: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_kw_bad_case)]\n+pub(crate) struct KwBadCase<'a> {\n+    #[primary_span]\n+    #[suggestion(code = \"{kw}\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+    pub kw: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_meta_bad_delim)]\n+pub(crate) struct MetaBadDelim {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sugg: MetaBadDelimSugg,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_cfg_attr_bad_delim)]\n+pub(crate) struct CfgAttrBadDelim {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sugg: MetaBadDelimSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parse_meta_bad_delim_suggestion, applicability = \"machine-applicable\")]\n+pub(crate) struct MetaBadDelimSugg {\n+    #[suggestion_part(code = \"(\")]\n+    pub open: Span,\n+    #[suggestion_part(code = \")\")]\n+    pub close: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_malformed_cfg_attr)]\n+#[note]\n+pub(crate) struct MalformedCfgAttr {\n+    #[primary_span]\n+    #[suggestion(code = \"{sugg}\")]\n+    pub span: Span,\n+    pub sugg: &'static str,\n+}"}, {"sha": "61a1cdeb540e940f63c931e96b9b1022c0500cd4", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -18,7 +18,7 @@ use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::{AttrItem, Attribute, MetaItem};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{Applicability, Diagnostic, FatalError, Level, PResult};\n+use rustc_errors::{Diagnostic, FatalError, Level, PResult};\n use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n use rustc_fluent_macro::fluent_messages;\n use rustc_session::parse::ParseSess;\n@@ -243,8 +243,7 @@ pub fn parse_cfg_attr(\n         ast::AttrArgs::Delimited(ast::DelimArgs { dspan, delim, ref tokens })\n             if !tokens.is_empty() =>\n         {\n-            let msg = \"wrong `cfg_attr` delimiters\";\n-            crate::validate_attr::check_meta_bad_delim(parse_sess, dspan, delim, msg);\n+            crate::validate_attr::check_cfg_attr_bad_delim(parse_sess, dspan, delim);\n             match parse_in(parse_sess, tokens.clone(), \"`cfg_attr` input\", |p| p.parse_cfg_attr()) {\n                 Ok(r) => return Some(r),\n                 Err(mut e) => {\n@@ -265,15 +264,5 @@ const CFG_ATTR_NOTE_REF: &str = \"for more information, visit \\\n     #the-cfg_attr-attribute>\";\n \n fn error_malformed_cfg_attr_missing(span: Span, parse_sess: &ParseSess) {\n-    parse_sess\n-        .span_diagnostic\n-        .struct_span_err(span, \"malformed `cfg_attr` attribute input\")\n-        .span_suggestion(\n-            span,\n-            \"missing condition and attribute\",\n-            CFG_ATTR_GRAMMAR_HELP,\n-            Applicability::HasPlaceholders,\n-        )\n-        .note(CFG_ATTR_NOTE_REF)\n-        .emit();\n+    parse_sess.emit_err(errors::MalformedCfgAttr { span, sugg: CFG_ATTR_GRAMMAR_HELP });\n }"}, {"sha": "27de9bd72685fbc02fa697adc12b67be44135dda", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -3151,14 +3151,10 @@ impl<'a> Parser<'a> {\n         let label = format!(\"'{}\", ident.name);\n         let ident = Ident { name: Symbol::intern(&label), span: ident.span };\n \n-        self.struct_span_err(ident.span, \"expected a label, found an identifier\")\n-            .span_suggestion(\n-                ident.span,\n-                \"labels start with a tick\",\n-                label,\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+        self.sess.emit_err(errors::ExpectedLabelFoundIdent {\n+            span: ident.span,\n+            start: ident.span.shrink_to_lo(),\n+        });\n \n         Label { ident }\n     }"}, {"sha": "9e003bfc09747727ad8e9ef812f84a751328309c", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 29, "deletions": 90, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -181,11 +181,11 @@ impl<'a> Parser<'a> {\n     /// Error in-case `default` was parsed in an in-appropriate context.\n     fn error_on_unconsumed_default(&self, def: Defaultness, kind: &ItemKind) {\n         if let Defaultness::Default(span) = def {\n-            let msg = format!(\"{} {} cannot be `default`\", kind.article(), kind.descr());\n-            self.struct_span_err(span, &msg)\n-                .span_label(span, \"`default` because of this\")\n-                .note(\"only associated `fn`, `const`, and `type` items can be `default`\")\n-                .emit();\n+            self.sess.emit_err(errors::InappropriateDefault {\n+                span,\n+                article: kind.article(),\n+                descr: kind.descr(),\n+            });\n         }\n     }\n \n@@ -310,14 +310,7 @@ impl<'a> Parser<'a> {\n         self.bump();\n         match self.parse_use_item() {\n             Ok(u) => {\n-                self.struct_span_err(span, format!(\"expected item, found {token_name}\"))\n-                    .span_suggestion_short(\n-                        span,\n-                        \"items are imported using the `use` keyword\",\n-                        \"use\",\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n+                self.sess.emit_err(errors::RecoverImportAsUse { span, token_name });\n                 Ok(Some(u))\n             }\n             Err(e) => {\n@@ -963,15 +956,8 @@ impl<'a> Parser<'a> {\n             } else {\n                 // Recover from using a colon as path separator.\n                 while self.eat_noexpect(&token::Colon) {\n-                    self.struct_span_err(self.prev_token.span, \"expected `::`, found `:`\")\n-                        .span_suggestion_short(\n-                            self.prev_token.span,\n-                            \"use double colon\",\n-                            \"::\",\n-                            Applicability::MachineApplicable,\n-                        )\n-                        .note_once(\"import paths are delimited using `::`\")\n-                        .emit();\n+                    self.sess\n+                        .emit_err(errors::SingleColonImportPath { span: self.prev_token.span });\n \n                     // We parse the rest of the path and append it to the original prefix.\n                     self.parse_path_segments(&mut prefix.segments, PathStyle::Mod, None)?;\n@@ -1134,13 +1120,11 @@ impl<'a> Parser<'a> {\n         ))\n     }\n \n-    fn error_bad_item_kind<T>(&self, span: Span, kind: &ItemKind, ctx: &str) -> Option<T> {\n+    fn error_bad_item_kind<T>(&self, span: Span, kind: &ItemKind, ctx: &'static str) -> Option<T> {\n         // FIXME(#100717): needs variant for each `ItemKind` (instead of using `ItemKind::descr()`)\n         let span = self.sess.source_map().guess_head_span(span);\n         let descr = kind.descr();\n-        self.struct_span_err(span, &format!(\"{descr} is not supported in {ctx}\"))\n-            .help(&format!(\"consider moving the {descr} out to a nearby module scope\"))\n-            .emit();\n+        self.sess.emit_err(errors::BadItemKind { span, descr, ctx });\n         None\n     }\n \n@@ -1713,27 +1697,13 @@ impl<'a> Parser<'a> {\n         self.expect_field_ty_separator()?;\n         let ty = self.parse_ty()?;\n         if self.token.kind == token::Colon && self.look_ahead(1, |tok| tok.kind != token::Colon) {\n-            self.struct_span_err(self.token.span, \"found single colon in a struct field type path\")\n-                .span_suggestion_verbose(\n-                    self.token.span,\n-                    \"write a path separator here\",\n-                    \"::\",\n-                    Applicability::MaybeIncorrect,\n-                )\n-                .emit();\n+            self.sess.emit_err(errors::SingleColonStructType { span: self.token.span });\n         }\n         if self.token.kind == token::Eq {\n             self.bump();\n             let const_expr = self.parse_expr_anon_const()?;\n             let sp = ty.span.shrink_to_hi().to(const_expr.value.span);\n-            self.struct_span_err(sp, \"default values on `struct` fields aren't supported\")\n-                .span_suggestion(\n-                    sp,\n-                    \"remove this unsupported default value\",\n-                    \"\",\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n+            self.sess.emit_err(errors::EqualsStructDefault { span: sp });\n         }\n         Ok(FieldDef {\n             span: lo.to(self.prev_token.span),\n@@ -1871,14 +1841,10 @@ impl<'a> Parser<'a> {\n                 return IsMacroRulesItem::Yes { has_bang: true };\n             } else if self.look_ahead(1, |t| (t.is_ident())) {\n                 // macro_rules foo\n-                self.struct_span_err(macro_rules_span, \"expected `!` after `macro_rules`\")\n-                    .span_suggestion(\n-                        macro_rules_span,\n-                        \"add a `!`\",\n-                        \"macro_rules!\",\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n+                self.sess.emit_err(errors::MacroRulesMissingBang {\n+                    span: macro_rules_span,\n+                    hi: macro_rules_span.shrink_to_hi(),\n+                });\n \n                 return IsMacroRulesItem::Yes { has_bang: false };\n             }\n@@ -1903,9 +1869,7 @@ impl<'a> Parser<'a> {\n         if self.eat(&token::Not) {\n             // Handle macro_rules! foo!\n             let span = self.prev_token.span;\n-            self.struct_span_err(span, \"macro names aren't followed by a `!`\")\n-                .span_suggestion(span, \"remove the `!`\", \"\", Applicability::MachineApplicable)\n-                .emit();\n+            self.sess.emit_err(errors::MacroNameRemoveBang { span });\n         }\n \n         let body = self.parse_delim_args()?;\n@@ -1925,25 +1889,9 @@ impl<'a> Parser<'a> {\n         let vstr = pprust::vis_to_string(vis);\n         let vstr = vstr.trim_end();\n         if macro_rules {\n-            let msg = format!(\"can't qualify macro_rules invocation with `{vstr}`\");\n-            self.struct_span_err(vis.span, &msg)\n-                .span_suggestion(\n-                    vis.span,\n-                    \"try exporting the macro\",\n-                    \"#[macro_export]\",\n-                    Applicability::MaybeIncorrect, // speculative\n-                )\n-                .emit();\n+            self.sess.emit_err(errors::MacroRulesVisibility { span: vis.span, vis: vstr });\n         } else {\n-            self.struct_span_err(vis.span, \"can't qualify macro invocation with `pub`\")\n-                .span_suggestion(\n-                    vis.span,\n-                    \"remove the visibility\",\n-                    \"\",\n-                    Applicability::MachineApplicable,\n-                )\n-                .help(&format!(\"try adjusting the macro to put `{vstr}` inside the invocation\"))\n-                .emit();\n+            self.sess.emit_err(errors::MacroInvocationVisibility { span: vis.span, vis: vstr });\n         }\n     }\n \n@@ -1989,18 +1937,12 @@ impl<'a> Parser<'a> {\n             let kw_token = self.token.clone();\n             let kw_str = pprust::token_to_string(&kw_token);\n             let item = self.parse_item(ForceCollect::No)?;\n-\n-            self.struct_span_err(\n-                kw_token.span,\n-                &format!(\"`{kw_str}` definition cannot be nested inside `{keyword}`\"),\n-            )\n-            .span_suggestion(\n-                item.unwrap().span,\n-                &format!(\"consider creating a new `{kw_str}` definition instead of nesting\"),\n-                \"\",\n-                Applicability::MaybeIncorrect,\n-            )\n-            .emit();\n+            self.sess.emit_err(errors::NestedAdt {\n+                span: kw_token.span,\n+                item: item.unwrap().span,\n+                kw_str,\n+                keyword: keyword.as_str(),\n+            });\n             // We successfully parsed the item but we must inform the caller about nested problem.\n             return Ok(false);\n         }\n@@ -2139,13 +2081,10 @@ impl<'a> Parser<'a> {\n             let _ = self.parse_expr()?;\n             self.expect_semi()?; // `;`\n             let span = eq_sp.to(self.prev_token.span);\n-            self.struct_span_err(span, \"function body cannot be `= expression;`\")\n-                .multipart_suggestion(\n-                    \"surround the expression with `{` and `}` instead of `=` and `;`\",\n-                    vec![(eq_sp, \"{\".to_string()), (self.prev_token.span, \" }\".to_string())],\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n+            self.sess.emit_err(errors::FunctionBodyEqualsExpr {\n+                span,\n+                sugg: errors::FunctionBodyEqualsExprSugg { eq: eq_sp, semi: self.prev_token.span },\n+            });\n             (AttrVec::new(), Some(self.mk_block_err(span)))\n         } else {\n             let expected = if req_body {"}, {"sha": "1c34e491f210ead9703f6faf266cb4939a822c4c", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -43,7 +43,7 @@ use thin_vec::ThinVec;\n use tracing::debug;\n \n use crate::errors::{\n-    IncorrectVisibilityRestriction, MismatchedClosingDelimiter, NonStringAbiLiteral,\n+    self, IncorrectVisibilityRestriction, MismatchedClosingDelimiter, NonStringAbiLiteral,\n };\n \n bitflags::bitflags! {\n@@ -663,15 +663,10 @@ impl<'a> Parser<'a> {\n         if case == Case::Insensitive\n         && let Some((ident, /* is_raw */ false)) = self.token.ident()\n         && ident.as_str().to_lowercase() == kw.as_str().to_lowercase() {\n-            self\n-                .struct_span_err(ident.span, format!(\"keyword `{kw}` is written in a wrong case\"))\n-                .span_suggestion(\n-                    ident.span,\n-                    \"write it in the correct case\",\n-                    kw,\n-                    Applicability::MachineApplicable\n-                ).emit();\n-\n+            self.sess.emit_err(errors::KwBadCase {\n+                span: ident.span,\n+                kw: kw.as_str()\n+            });\n             self.bump();\n             return true;\n         }"}, {"sha": "f2422fe307c5fd6c38cd886a9da98f392ed1afda", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -1,6 +1,6 @@\n use super::{ForceCollect, Parser, PathStyle, TrailingToken};\n use crate::errors::{\n-    AmbiguousRangePattern, DotDotDotForRemainingFields, DotDotDotRangeToPatternNotAllowed,\n+    self, AmbiguousRangePattern, DotDotDotForRemainingFields, DotDotDotRangeToPatternNotAllowed,\n     DotDotDotRestPattern, EnumPatternInsteadOfIdentifier, ExpectedBindingLeftOfAt,\n     ExpectedCommaAfterPatternField, InclusiveRangeExtraEquals, InclusiveRangeMatchArrow,\n     InclusiveRangeNoEnd, InvalidMutInPattern, PatternOnWrongSideOfAt, RefMutOrderIncorrect,\n@@ -908,18 +908,13 @@ impl<'a> Parser<'a> {\n         let box_span = self.prev_token.span;\n \n         if self.isnt_pattern_start() {\n-            self.struct_span_err(\n-                self.token.span,\n-                format!(\"expected pattern, found {}\", super::token_descr(&self.token)),\n-            )\n-            .span_note(box_span, \"`box` is a reserved keyword\")\n-            .span_suggestion_verbose(\n-                box_span.shrink_to_lo(),\n-                \"escape `box` to use it as an identifier\",\n-                \"r#\",\n-                Applicability::MaybeIncorrect,\n-            )\n-            .emit();\n+            let descr = super::token_descr(&self.token);\n+            self.sess.emit_err(errors::BoxNotPat {\n+                span: self.token.span,\n+                kw: box_span,\n+                lo: box_span.shrink_to_lo(),\n+                descr,\n+            });\n \n             // We cannot use `parse_pat_ident()` since it will complain `box`\n             // is not an identifier."}, {"sha": "ae73760bd8cab28c9a7b92ae463d6bd0f6f9a23f", "filename": "compiler/rustc_parse/src/parser/path.rs", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -8,7 +8,7 @@ use rustc_ast::{\n     AssocConstraintKind, BlockCheckMode, GenericArg, GenericArgs, Generics, ParenthesizedArgs,\n     Path, PathSegment, QSelf,\n };\n-use rustc_errors::{pluralize, Applicability, PResult};\n+use rustc_errors::{Applicability, PResult};\n use rustc_span::source_map::{BytePos, Span};\n use rustc_span::symbol::{kw, sym, Ident};\n use std::mem;\n@@ -464,23 +464,10 @@ impl<'a> Parser<'a> {\n                     // i.e. no multibyte characters, in this range.\n                     let span =\n                         lo.with_hi(lo.lo() + BytePos(snapshot.unmatched_angle_bracket_count));\n-                    self.struct_span_err(\n+                    self.sess.emit_err(errors::UnmatchedAngle {\n                         span,\n-                        &format!(\n-                            \"unmatched angle bracket{}\",\n-                            pluralize!(snapshot.unmatched_angle_bracket_count)\n-                        ),\n-                    )\n-                    .span_suggestion(\n-                        span,\n-                        &format!(\n-                            \"remove extra angle bracket{}\",\n-                            pluralize!(snapshot.unmatched_angle_bracket_count)\n-                        ),\n-                        \"\",\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n+                        plural: snapshot.unmatched_angle_bracket_count > 1,\n+                    });\n \n                     // Try again without unmatched angle bracket characters.\n                     self.parse_angle_args(ty_generics)"}, {"sha": "3ceb3a2bef16e57f0ab2cee56314583031556dff", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -588,20 +588,14 @@ impl<'a> Parser<'a> {\n         // Always parse bounds greedily for better error recovery.\n         if self.token.is_lifetime() {\n             self.look_ahead(1, |t| {\n-                if let token::Ident(symname, _) = t.kind {\n+                if let token::Ident(sym, _) = t.kind {\n                     // parse pattern with \"'a Sized\" we're supposed to give suggestion like\n                     // \"'a + Sized\"\n-                    self.struct_span_err(\n-                        self.token.span,\n-                        &format!(\"expected `+` between lifetime and {}\", symname),\n-                    )\n-                    .span_suggestion_verbose(\n-                        self.token.span.shrink_to_hi(),\n-                        \"add `+`\",\n-                        \" +\",\n-                        Applicability::MaybeIncorrect,\n-                    )\n-                    .emit();\n+                    self.sess.emit_err(errors::MissingPlusBounds {\n+                        span: self.token.span,\n+                        hi: self.token.span.shrink_to_hi(),\n+                        sym,\n+                    });\n                 }\n             })\n         }\n@@ -926,14 +920,10 @@ impl<'a> Parser<'a> {\n                 self.parse_remaining_bounds(bounds, true)?;\n                 self.expect(&token::CloseDelim(Delimiter::Parenthesis))?;\n                 let sp = vec![lo, self.prev_token.span];\n-                let sugg = vec![(lo, String::from(\" \")), (self.prev_token.span, String::new())];\n-                self.struct_span_err(sp, \"incorrect braces around trait bounds\")\n-                    .multipart_suggestion(\n-                        \"remove the parentheses\",\n-                        sugg,\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n+                self.sess.emit_err(errors::IncorrectBracesTraitBounds {\n+                    span: sp,\n+                    sugg: errors::IncorrectBracesTraitBoundsSugg { l: lo, r: self.prev_token.span },\n+                });\n             } else {\n                 self.expect(&token::CloseDelim(Delimiter::Parenthesis))?;\n             }"}, {"sha": "815b7c8567918d0695c8c74aa5c3534c3b587fca", "filename": "compiler/rustc_parse/src/validate_attr.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -1,6 +1,6 @@\n //! Meta-syntax validation logic of attributes for post-expansion.\n \n-use crate::parse_in;\n+use crate::{errors, parse_in};\n \n use rustc_ast::tokenstream::DelimSpan;\n use rustc_ast::MetaItemKind;\n@@ -45,7 +45,7 @@ pub fn parse_meta<'a>(sess: &'a ParseSess, attr: &Attribute) -> PResult<'a, Meta\n         kind: match &item.args {\n             AttrArgs::Empty => MetaItemKind::Word,\n             AttrArgs::Delimited(DelimArgs { dspan, delim, tokens }) => {\n-                check_meta_bad_delim(sess, *dspan, *delim, \"wrong meta list delimiters\");\n+                check_meta_bad_delim(sess, *dspan, *delim);\n                 let nmis = parse_in(sess, tokens.clone(), \"meta list\", |p| p.parse_meta_seq_top())?;\n                 MetaItemKind::List(nmis)\n             }\n@@ -84,19 +84,24 @@ pub fn parse_meta<'a>(sess: &'a ParseSess, attr: &Attribute) -> PResult<'a, Meta\n     })\n }\n \n-pub fn check_meta_bad_delim(sess: &ParseSess, span: DelimSpan, delim: MacDelimiter, msg: &str) {\n+pub fn check_meta_bad_delim(sess: &ParseSess, span: DelimSpan, delim: MacDelimiter) {\n     if let ast::MacDelimiter::Parenthesis = delim {\n         return;\n     }\n+    sess.emit_err(errors::MetaBadDelim {\n+        span: span.entire(),\n+        sugg: errors::MetaBadDelimSugg { open: span.open, close: span.close },\n+    });\n+}\n \n-    sess.span_diagnostic\n-        .struct_span_err(span.entire(), msg)\n-        .multipart_suggestion(\n-            \"the delimiters should be `(` and `)`\",\n-            vec![(span.open, \"(\".to_string()), (span.close, \")\".to_string())],\n-            Applicability::MachineApplicable,\n-        )\n-        .emit();\n+pub fn check_cfg_attr_bad_delim(sess: &ParseSess, span: DelimSpan, delim: MacDelimiter) {\n+    if let ast::MacDelimiter::Parenthesis = delim {\n+        return;\n+    }\n+    sess.emit_err(errors::CfgAttrBadDelim {\n+        span: span.entire(),\n+        sugg: errors::MetaBadDelimSugg { open: span.open, close: span.close },\n+    });\n }\n \n /// Checks that the given meta-item is compatible with this `AttributeTemplate`."}, {"sha": "c261995621988400b29cc02bacfd448df0e38358", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -129,8 +129,7 @@ symbols! {\n         Any,\n         Arc,\n         Argument,\n-        ArgumentV1,\n-        ArgumentV1Methods,\n+        ArgumentMethods,\n         Arguments,\n         AsMut,\n         AsRef,"}, {"sha": "f4f3223257047a888e1d8b7d436d8d11582b08ec", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 52, "deletions": 194, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -251,145 +251,48 @@ impl<'a> Formatter<'a> {\n     }\n }\n \n-// NB. Argument is essentially an optimized partially applied formatting function,\n-// equivalent to `exists T.(&T, fn(&T, &mut Formatter<'_>) -> Result`.\n-\n-extern \"C\" {\n-    type Opaque;\n-}\n-\n-/// This struct represents the generic \"argument\" which is taken by the Xprintf\n-/// family of functions. It contains a function to format the given value. At\n-/// compile time it is ensured that the function and the value have the correct\n-/// types, and then this struct is used to canonicalize arguments to one type.\n-#[lang = \"format_argument\"]\n+/// This structure represents a safely precompiled version of a format string\n+/// and its arguments. This cannot be generated at runtime because it cannot\n+/// safely be done, so no constructors are given and the fields are private\n+/// to prevent modification.\n+///\n+/// The [`format_args!`] macro will safely create an instance of this structure.\n+/// The macro validates the format string at compile-time so usage of the\n+/// [`write()`] and [`format()`] functions can be safely performed.\n+///\n+/// You can use the `Arguments<'a>` that [`format_args!`] returns in `Debug`\n+/// and `Display` contexts as seen below. The example also shows that `Debug`\n+/// and `Display` format to the same thing: the interpolated format string\n+/// in `format_args!`.\n+///\n+/// ```rust\n+/// let debug = format!(\"{:?}\", format_args!(\"{} foo {:?}\", 1, 2));\n+/// let display = format!(\"{}\", format_args!(\"{} foo {:?}\", 1, 2));\n+/// assert_eq!(\"1 foo 2\", display);\n+/// assert_eq!(display, debug);\n+/// ```\n+///\n+/// [`format()`]: ../../std/fmt/fn.format.html\n+#[lang = \"format_arguments\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Copy, Clone)]\n-#[allow(missing_debug_implementations)]\n-#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n-#[doc(hidden)]\n-pub struct ArgumentV1<'a> {\n-    value: &'a Opaque,\n-    formatter: fn(&Opaque, &mut Formatter<'_>) -> Result,\n-}\n-\n-/// This struct represents the unsafety of constructing an `Arguments`.\n-/// It exists, rather than an unsafe function, in order to simplify the expansion\n-/// of `format_args!(..)` and reduce the scope of the `unsafe` block.\n-#[lang = \"format_unsafe_arg\"]\n-#[allow(missing_debug_implementations)]\n-#[doc(hidden)]\n-#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n-pub struct UnsafeArg {\n-    _private: (),\n-}\n-\n-impl UnsafeArg {\n-    /// See documentation where `UnsafeArg` is required to know when it is safe to\n-    /// create and use `UnsafeArg`.\n-    #[doc(hidden)]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n-    #[inline(always)]\n-    pub unsafe fn new() -> Self {\n-        Self { _private: () }\n-    }\n-}\n-\n-// This guarantees a single stable value for the function pointer associated with\n-// indices/counts in the formatting infrastructure.\n-//\n-// Note that a function defined as such would not be correct as functions are\n-// always tagged unnamed_addr with the current lowering to LLVM IR, so their\n-// address is not considered important to LLVM and as such the as_usize cast\n-// could have been miscompiled. In practice, we never call as_usize on non-usize\n-// containing data (as a matter of static generation of the formatting\n-// arguments), so this is merely an additional check.\n-//\n-// We primarily want to ensure that the function pointer at `USIZE_MARKER` has\n-// an address corresponding *only* to functions that also take `&usize` as their\n-// first argument. The read_volatile here ensures that we can safely ready out a\n-// usize from the passed reference and that this address does not point at a\n-// non-usize taking function.\n-#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n-static USIZE_MARKER: fn(&usize, &mut Formatter<'_>) -> Result = |ptr, _| {\n-    // SAFETY: ptr is a reference\n-    let _v: usize = unsafe { crate::ptr::read_volatile(ptr) };\n-    loop {}\n-};\n-\n-macro_rules! arg_new {\n-    ($f: ident, $t: ident) => {\n-        #[doc(hidden)]\n-        #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n-        #[inline]\n-        pub fn $f<'b, T: $t>(x: &'b T) -> ArgumentV1<'_> {\n-            Self::new(x, $t::fmt)\n-        }\n-    };\n-}\n-\n-#[rustc_diagnostic_item = \"ArgumentV1Methods\"]\n-impl<'a> ArgumentV1<'a> {\n-    #[doc(hidden)]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n-    #[inline]\n-    pub fn new<'b, T>(x: &'b T, f: fn(&T, &mut Formatter<'_>) -> Result) -> ArgumentV1<'b> {\n-        // SAFETY: `mem::transmute(x)` is safe because\n-        //     1. `&'b T` keeps the lifetime it originated with `'b`\n-        //              (so as to not have an unbounded lifetime)\n-        //     2. `&'b T` and `&'b Opaque` have the same memory layout\n-        //              (when `T` is `Sized`, as it is here)\n-        // `mem::transmute(f)` is safe since `fn(&T, &mut Formatter<'_>) -> Result`\n-        // and `fn(&Opaque, &mut Formatter<'_>) -> Result` have the same ABI\n-        // (as long as `T` is `Sized`)\n-        unsafe { ArgumentV1 { formatter: mem::transmute(f), value: mem::transmute(x) } }\n-    }\n-\n-    arg_new!(new_display, Display);\n-    arg_new!(new_debug, Debug);\n-    arg_new!(new_octal, Octal);\n-    arg_new!(new_lower_hex, LowerHex);\n-    arg_new!(new_upper_hex, UpperHex);\n-    arg_new!(new_pointer, Pointer);\n-    arg_new!(new_binary, Binary);\n-    arg_new!(new_lower_exp, LowerExp);\n-    arg_new!(new_upper_exp, UpperExp);\n+pub struct Arguments<'a> {\n+    // Format string pieces to print.\n+    pieces: &'a [&'static str],\n \n-    #[doc(hidden)]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n-    pub fn from_usize(x: &usize) -> ArgumentV1<'_> {\n-        ArgumentV1::new(x, USIZE_MARKER)\n-    }\n-\n-    fn as_usize(&self) -> Option<usize> {\n-        // We are type punning a bit here: USIZE_MARKER only takes an &usize but\n-        // formatter takes an &Opaque. Rust understandably doesn't think we should compare\n-        // the function pointers if they don't have the same signature, so we cast to\n-        // usizes to tell it that we just want to compare addresses.\n-        if self.formatter as usize == USIZE_MARKER as usize {\n-            // SAFETY: The `formatter` field is only set to USIZE_MARKER if\n-            // the value is a usize, so this is safe\n-            Some(unsafe { *(self.value as *const _ as *const usize) })\n-        } else {\n-            None\n-        }\n-    }\n-}\n+    // Placeholder specs, or `None` if all specs are default (as in \"{}{}\").\n+    fmt: Option<&'a [rt::Placeholder]>,\n \n-// flags available in the v1 format of format_args\n-#[derive(Copy, Clone)]\n-enum FlagV1 {\n-    SignPlus,\n-    SignMinus,\n-    Alternate,\n-    SignAwareZeroPad,\n-    DebugLowerHex,\n-    DebugUpperHex,\n+    // Dynamic arguments for interpolation, to be interleaved with string\n+    // pieces. (Every argument is preceded by a string piece.)\n+    args: &'a [rt::Argument<'a>],\n }\n \n+/// Used by the format_args!() macro to create a fmt::Arguments object.\n+#[doc(hidden)]\n+#[unstable(feature = \"fmt_internals\", issue = \"none\")]\n impl<'a> Arguments<'a> {\n-    #[doc(hidden)]\n     #[inline]\n-    #[unstable(feature = \"fmt_internals\", issue = \"none\")]\n     #[rustc_const_unstable(feature = \"const_fmt_arguments_new\", issue = \"none\")]\n     pub const fn new_const(pieces: &'a [&'static str]) -> Self {\n         if pieces.len() > 1 {\n@@ -401,22 +304,18 @@ impl<'a> Arguments<'a> {\n     /// When using the format_args!() macro, this function is used to generate the\n     /// Arguments structure.\n     #[cfg(not(bootstrap))]\n-    #[doc(hidden)]\n     #[inline]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n-    pub fn new_v1(pieces: &'a [&'static str], args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n+    pub fn new_v1(pieces: &'a [&'static str], args: &'a [rt::Argument<'a>]) -> Arguments<'a> {\n         if pieces.len() < args.len() || pieces.len() > args.len() + 1 {\n             panic!(\"invalid args\");\n         }\n         Arguments { pieces, fmt: None, args }\n     }\n \n     #[cfg(bootstrap)]\n-    #[doc(hidden)]\n     #[inline]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n     #[rustc_const_unstable(feature = \"const_fmt_arguments_new\", issue = \"none\")]\n-    pub const fn new_v1(pieces: &'a [&'static str], args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n+    pub const fn new_v1(pieces: &'a [&'static str], args: &'a [rt::Argument<'a>]) -> Arguments<'a> {\n         if pieces.len() < args.len() || pieces.len() > args.len() + 1 {\n             panic!(\"invalid args\");\n         }\n@@ -425,19 +324,17 @@ impl<'a> Arguments<'a> {\n \n     /// This function is used to specify nonstandard formatting parameters.\n     ///\n-    /// An `UnsafeArg` is required because the following invariants must be held\n+    /// An `rt::UnsafeArg` is required because the following invariants must be held\n     /// in order for this function to be safe:\n     /// 1. The `pieces` slice must be at least as long as `fmt`.\n     /// 2. Every `rt::Placeholder::position` value within `fmt` must be a valid index of `args`.\n     /// 3. Every `rt::Count::Param` within `fmt` must contain a valid index of `args`.\n-    #[doc(hidden)]\n     #[inline]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n     pub fn new_v1_formatted(\n         pieces: &'a [&'static str],\n-        args: &'a [ArgumentV1<'a>],\n+        args: &'a [rt::Argument<'a>],\n         fmt: &'a [rt::Placeholder],\n-        _unsafe_arg: UnsafeArg,\n+        _unsafe_arg: rt::UnsafeArg,\n     ) -> Arguments<'a> {\n         Arguments { pieces, fmt: Some(fmt), args }\n     }\n@@ -446,9 +343,7 @@ impl<'a> Arguments<'a> {\n     ///\n     /// This is intended to be used for setting initial `String` capacity\n     /// when using `format!`. Note: this is neither the lower nor upper bound.\n-    #[doc(hidden)]\n     #[inline]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n     pub fn estimated_capacity(&self) -> usize {\n         let pieces_length: usize = self.pieces.iter().map(|x| x.len()).sum();\n \n@@ -468,43 +363,6 @@ impl<'a> Arguments<'a> {\n     }\n }\n \n-/// This structure represents a safely precompiled version of a format string\n-/// and its arguments. This cannot be generated at runtime because it cannot\n-/// safely be done, so no constructors are given and the fields are private\n-/// to prevent modification.\n-///\n-/// The [`format_args!`] macro will safely create an instance of this structure.\n-/// The macro validates the format string at compile-time so usage of the\n-/// [`write()`] and [`format()`] functions can be safely performed.\n-///\n-/// You can use the `Arguments<'a>` that [`format_args!`] returns in `Debug`\n-/// and `Display` contexts as seen below. The example also shows that `Debug`\n-/// and `Display` format to the same thing: the interpolated format string\n-/// in `format_args!`.\n-///\n-/// ```rust\n-/// let debug = format!(\"{:?}\", format_args!(\"{} foo {:?}\", 1, 2));\n-/// let display = format!(\"{}\", format_args!(\"{} foo {:?}\", 1, 2));\n-/// assert_eq!(\"1 foo 2\", display);\n-/// assert_eq!(display, debug);\n-/// ```\n-///\n-/// [`format()`]: ../../std/fmt/fn.format.html\n-#[lang = \"format_arguments\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Copy, Clone)]\n-pub struct Arguments<'a> {\n-    // Format string pieces to print.\n-    pieces: &'a [&'static str],\n-\n-    // Placeholder specs, or `None` if all specs are default (as in \"{}{}\").\n-    fmt: Option<&'a [rt::Placeholder]>,\n-\n-    // Dynamic arguments for interpolation, to be interleaved with string\n-    // pieces. (Every argument is preceded by a string piece.)\n-    args: &'a [ArgumentV1<'a>],\n-}\n-\n impl<'a> Arguments<'a> {\n     /// Get the formatted string, if it has no arguments to be formatted at runtime.\n     ///\n@@ -1244,7 +1102,7 @@ pub fn write(output: &mut dyn Write, args: Arguments<'_>) -> Result {\n                 if !piece.is_empty() {\n                     formatter.buf.write_str(*piece)?;\n                 }\n-                (arg.formatter)(arg.value, &mut formatter)?;\n+                arg.fmt(&mut formatter)?;\n                 idx += 1;\n             }\n         }\n@@ -1274,7 +1132,7 @@ pub fn write(output: &mut dyn Write, args: Arguments<'_>) -> Result {\n     Ok(())\n }\n \n-unsafe fn run(fmt: &mut Formatter<'_>, arg: &rt::Placeholder, args: &[ArgumentV1<'_>]) -> Result {\n+unsafe fn run(fmt: &mut Formatter<'_>, arg: &rt::Placeholder, args: &[rt::Argument<'_>]) -> Result {\n     fmt.fill = arg.fill;\n     fmt.align = arg.align;\n     fmt.flags = arg.flags;\n@@ -1292,10 +1150,10 @@ unsafe fn run(fmt: &mut Formatter<'_>, arg: &rt::Placeholder, args: &[ArgumentV1\n     let value = unsafe { args.get_unchecked(arg.position) };\n \n     // Then actually do some printing\n-    (value.formatter)(value.value, fmt)\n+    value.fmt(fmt)\n }\n \n-unsafe fn getcount(args: &[ArgumentV1<'_>], cnt: &rt::Count) -> Option<usize> {\n+unsafe fn getcount(args: &[rt::Argument<'_>], cnt: &rt::Count) -> Option<usize> {\n     match *cnt {\n         rt::Count::Is(n) => Some(n),\n         rt::Count::Implied => None,\n@@ -1878,7 +1736,7 @@ impl<'a> Formatter<'a> {\n     #[must_use]\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n     pub fn sign_plus(&self) -> bool {\n-        self.flags & (1 << FlagV1::SignPlus as u32) != 0\n+        self.flags & (1 << rt::Flag::SignPlus as u32) != 0\n     }\n \n     /// Determines if the `-` flag was specified.\n@@ -1907,7 +1765,7 @@ impl<'a> Formatter<'a> {\n     #[must_use]\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n     pub fn sign_minus(&self) -> bool {\n-        self.flags & (1 << FlagV1::SignMinus as u32) != 0\n+        self.flags & (1 << rt::Flag::SignMinus as u32) != 0\n     }\n \n     /// Determines if the `#` flag was specified.\n@@ -1935,7 +1793,7 @@ impl<'a> Formatter<'a> {\n     #[must_use]\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n     pub fn alternate(&self) -> bool {\n-        self.flags & (1 << FlagV1::Alternate as u32) != 0\n+        self.flags & (1 << rt::Flag::Alternate as u32) != 0\n     }\n \n     /// Determines if the `0` flag was specified.\n@@ -1961,17 +1819,17 @@ impl<'a> Formatter<'a> {\n     #[must_use]\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n     pub fn sign_aware_zero_pad(&self) -> bool {\n-        self.flags & (1 << FlagV1::SignAwareZeroPad as u32) != 0\n+        self.flags & (1 << rt::Flag::SignAwareZeroPad as u32) != 0\n     }\n \n     // FIXME: Decide what public API we want for these two flags.\n     // https://github.com/rust-lang/rust/issues/48584\n     fn debug_lower_hex(&self) -> bool {\n-        self.flags & (1 << FlagV1::DebugLowerHex as u32) != 0\n+        self.flags & (1 << rt::Flag::DebugLowerHex as u32) != 0\n     }\n \n     fn debug_upper_hex(&self) -> bool {\n-        self.flags & (1 << FlagV1::DebugUpperHex as u32) != 0\n+        self.flags & (1 << rt::Flag::DebugUpperHex as u32) != 0\n     }\n \n     /// Creates a [`DebugStruct`] builder designed to assist with creation of\n@@ -2531,13 +2389,13 @@ pub(crate) fn pointer_fmt_inner(ptr_addr: usize, f: &mut Formatter<'_>) -> Resul\n     // or not to zero extend, and then unconditionally set it to get the\n     // prefix.\n     if f.alternate() {\n-        f.flags |= 1 << (FlagV1::SignAwareZeroPad as u32);\n+        f.flags |= 1 << (rt::Flag::SignAwareZeroPad as u32);\n \n         if f.width.is_none() {\n             f.width = Some((usize::BITS / 4) as usize + 2);\n         }\n     }\n-    f.flags |= 1 << (FlagV1::Alternate as u32);\n+    f.flags |= 1 << (rt::Flag::Alternate as u32);\n \n     let ret = LowerHex::fmt(&ptr_addr, f);\n "}, {"sha": "0596f6c30ce6dad5dcce353ccf59a0ff0937d08a", "filename": "library/core/src/fmt/rt.rs", "status": "modified", "additions": 148, "deletions": 6, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/library%2Fcore%2Fsrc%2Ffmt%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/library%2Fcore%2Fsrc%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Frt.rs?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -3,6 +3,8 @@\n \n //! These are the lang items used by format_args!().\n \n+use super::*;\n+\n #[lang = \"format_placeholder\"]\n #[derive(Copy, Clone)]\n pub struct Placeholder {\n@@ -28,21 +30,17 @@ impl Placeholder {\n     }\n }\n \n-/// Possible alignments that can be requested as part of a formatting directive.\n #[lang = \"format_alignment\"]\n #[derive(Copy, Clone, PartialEq, Eq)]\n pub enum Alignment {\n-    /// Indication that contents should be left-aligned.\n     Left,\n-    /// Indication that contents should be right-aligned.\n     Right,\n-    /// Indication that contents should be center-aligned.\n     Center,\n-    /// No alignment was requested.\n     Unknown,\n }\n \n-/// Used by [width](https://doc.rust-lang.org/std/fmt/#width) and [precision](https://doc.rust-lang.org/std/fmt/#precision) specifiers.\n+/// Used by [width](https://doc.rust-lang.org/std/fmt/#width)\n+/// and [precision](https://doc.rust-lang.org/std/fmt/#precision) specifiers.\n #[lang = \"format_count\"]\n #[derive(Copy, Clone)]\n pub enum Count {\n@@ -53,3 +51,147 @@ pub enum Count {\n     /// Not specified\n     Implied,\n }\n+\n+// This needs to match the order of flags in compiler/rustc_ast_lowering/src/format.rs.\n+#[derive(Copy, Clone)]\n+pub(super) enum Flag {\n+    SignPlus,\n+    SignMinus,\n+    Alternate,\n+    SignAwareZeroPad,\n+    DebugLowerHex,\n+    DebugUpperHex,\n+}\n+\n+/// This struct represents the generic \"argument\" which is taken by format_args!().\n+/// It contains a function to format the given value. At compile time it is ensured that the\n+/// function and the value have the correct types, and then this struct is used to canonicalize\n+/// arguments to one type.\n+///\n+/// Argument is essentially an optimized partially applied formatting function,\n+/// equivalent to `exists T.(&T, fn(&T, &mut Formatter<'_>) -> Result`.\n+#[lang = \"format_argument\"]\n+#[derive(Copy, Clone)]\n+pub struct Argument<'a> {\n+    value: &'a Opaque,\n+    formatter: fn(&Opaque, &mut Formatter<'_>) -> Result,\n+}\n+\n+#[rustc_diagnostic_item = \"ArgumentMethods\"]\n+impl<'a> Argument<'a> {\n+    #[inline(always)]\n+    fn new<'b, T>(x: &'b T, f: fn(&T, &mut Formatter<'_>) -> Result) -> Argument<'b> {\n+        // SAFETY: `mem::transmute(x)` is safe because\n+        //     1. `&'b T` keeps the lifetime it originated with `'b`\n+        //              (so as to not have an unbounded lifetime)\n+        //     2. `&'b T` and `&'b Opaque` have the same memory layout\n+        //              (when `T` is `Sized`, as it is here)\n+        // `mem::transmute(f)` is safe since `fn(&T, &mut Formatter<'_>) -> Result`\n+        // and `fn(&Opaque, &mut Formatter<'_>) -> Result` have the same ABI\n+        // (as long as `T` is `Sized`)\n+        unsafe { Argument { formatter: mem::transmute(f), value: mem::transmute(x) } }\n+    }\n+\n+    #[inline(always)]\n+    pub fn new_display<'b, T: Display>(x: &'b T) -> Argument<'_> {\n+        Self::new(x, Display::fmt)\n+    }\n+    #[inline(always)]\n+    pub fn new_debug<'b, T: Debug>(x: &'b T) -> Argument<'_> {\n+        Self::new(x, Debug::fmt)\n+    }\n+    #[inline(always)]\n+    pub fn new_octal<'b, T: Octal>(x: &'b T) -> Argument<'_> {\n+        Self::new(x, Octal::fmt)\n+    }\n+    #[inline(always)]\n+    pub fn new_lower_hex<'b, T: LowerHex>(x: &'b T) -> Argument<'_> {\n+        Self::new(x, LowerHex::fmt)\n+    }\n+    #[inline(always)]\n+    pub fn new_upper_hex<'b, T: UpperHex>(x: &'b T) -> Argument<'_> {\n+        Self::new(x, UpperHex::fmt)\n+    }\n+    #[inline(always)]\n+    pub fn new_pointer<'b, T: Pointer>(x: &'b T) -> Argument<'_> {\n+        Self::new(x, Pointer::fmt)\n+    }\n+    #[inline(always)]\n+    pub fn new_binary<'b, T: Binary>(x: &'b T) -> Argument<'_> {\n+        Self::new(x, Binary::fmt)\n+    }\n+    #[inline(always)]\n+    pub fn new_lower_exp<'b, T: LowerExp>(x: &'b T) -> Argument<'_> {\n+        Self::new(x, LowerExp::fmt)\n+    }\n+    #[inline(always)]\n+    pub fn new_upper_exp<'b, T: UpperExp>(x: &'b T) -> Argument<'_> {\n+        Self::new(x, UpperExp::fmt)\n+    }\n+    #[inline(always)]\n+    pub fn from_usize(x: &usize) -> Argument<'_> {\n+        Self::new(x, USIZE_MARKER)\n+    }\n+\n+    #[inline(always)]\n+    pub(super) fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n+        (self.formatter)(self.value, f)\n+    }\n+\n+    #[inline(always)]\n+    pub(super) fn as_usize(&self) -> Option<usize> {\n+        // We are type punning a bit here: USIZE_MARKER only takes an &usize but\n+        // formatter takes an &Opaque. Rust understandably doesn't think we should compare\n+        // the function pointers if they don't have the same signature, so we cast to\n+        // usizes to tell it that we just want to compare addresses.\n+        if self.formatter as usize == USIZE_MARKER as usize {\n+            // SAFETY: The `formatter` field is only set to USIZE_MARKER if\n+            // the value is a usize, so this is safe\n+            Some(unsafe { *(self.value as *const _ as *const usize) })\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// This struct represents the unsafety of constructing an `Arguments`.\n+/// It exists, rather than an unsafe function, in order to simplify the expansion\n+/// of `format_args!(..)` and reduce the scope of the `unsafe` block.\n+#[lang = \"format_unsafe_arg\"]\n+pub struct UnsafeArg {\n+    _private: (),\n+}\n+\n+impl UnsafeArg {\n+    /// See documentation where `UnsafeArg` is required to know when it is safe to\n+    /// create and use `UnsafeArg`.\n+    #[inline(always)]\n+    pub unsafe fn new() -> Self {\n+        Self { _private: () }\n+    }\n+}\n+\n+extern \"C\" {\n+    type Opaque;\n+}\n+\n+// This guarantees a single stable value for the function pointer associated with\n+// indices/counts in the formatting infrastructure.\n+//\n+// Note that a function defined as such would not be correct as functions are\n+// always tagged unnamed_addr with the current lowering to LLVM IR, so their\n+// address is not considered important to LLVM and as such the as_usize cast\n+// could have been miscompiled. In practice, we never call as_usize on non-usize\n+// containing data (as a matter of static generation of the formatting\n+// arguments), so this is merely an additional check.\n+//\n+// We primarily want to ensure that the function pointer at `USIZE_MARKER` has\n+// an address corresponding *only* to functions that also take `&usize` as their\n+// first argument. The read_volatile here ensures that we can safely ready out a\n+// usize from the passed reference and that this address does not point at a\n+// non-usize taking function.\n+static USIZE_MARKER: fn(&usize, &mut Formatter<'_>) -> Result = |ptr, _| {\n+    // SAFETY: ptr is a reference\n+    let _v: usize = unsafe { crate::ptr::read_volatile(ptr) };\n+    loop {}\n+};"}, {"sha": "8ed62cdddcd9c33559cf0702300022575747356e", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -1132,26 +1132,29 @@ fn remove_dir_all_iterative(f: &File, delete: fn(&File) -> io::Result<()>) -> io\n                     &dir,\n                     &name,\n                     c::SYNCHRONIZE | c::DELETE | c::FILE_LIST_DIRECTORY,\n-                )?;\n-                dirlist.push(child_dir);\n-            } else {\n-                for i in 1..=MAX_RETRIES {\n-                    let result = open_link_no_reparse(&dir, &name, c::SYNCHRONIZE | c::DELETE);\n-                    match result {\n-                        Ok(f) => delete(&f)?,\n-                        // Already deleted, so skip.\n-                        Err(e) if e.kind() == io::ErrorKind::NotFound => break,\n-                        // Retry a few times if the file is locked or a delete is already in progress.\n-                        Err(e)\n-                            if i < MAX_RETRIES\n-                                && (e.raw_os_error() == Some(c::ERROR_DELETE_PENDING as _)\n-                                    || e.raw_os_error()\n-                                        == Some(c::ERROR_SHARING_VIOLATION as _)) => {}\n-                        // Otherwise return the error.\n-                        Err(e) => return Err(e),\n-                    }\n-                    thread::yield_now();\n+                );\n+                // On success, add the handle to the queue.\n+                // If opening the directory fails we treat it the same as a file\n+                if let Ok(child_dir) = child_dir {\n+                    dirlist.push(child_dir);\n+                    continue;\n+                }\n+            }\n+            for i in 1..=MAX_RETRIES {\n+                let result = open_link_no_reparse(&dir, &name, c::SYNCHRONIZE | c::DELETE);\n+                match result {\n+                    Ok(f) => delete(&f)?,\n+                    // Already deleted, so skip.\n+                    Err(e) if e.kind() == io::ErrorKind::NotFound => break,\n+                    // Retry a few times if the file is locked or a delete is already in progress.\n+                    Err(e)\n+                        if i < MAX_RETRIES\n+                            && (e.raw_os_error() == Some(c::ERROR_DELETE_PENDING as _)\n+                                || e.raw_os_error() == Some(c::ERROR_SHARING_VIOLATION as _)) => {}\n+                    // Otherwise return the error.\n+                    Err(e) => return Err(e),\n                 }\n+                thread::yield_now();\n             }\n         }\n         // If there were no more files then delete the directory."}, {"sha": "c4381e202b9458144ac43d36b75d773b2cce3c64", "filename": "src/etc/lldb_providers.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/src%2Fetc%2Flldb_providers.py", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/src%2Fetc%2Flldb_providers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_providers.py?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -31,7 +31,7 @@\n #\n # You can find more information and examples here:\n #   1. https://lldb.llvm.org/varformats.html\n-#   2. https://lldb.llvm.org/python-reference.html\n+#   2. https://lldb.llvm.org/use/python-reference.html\n #   3. https://lldb.llvm.org/python_reference/lldb.formatters.cpp.libcxx-pysrc.html\n #   4. https://github.com/llvm-mirror/lldb/tree/master/examples/summaries/cocoa\n ####################################################################################################"}, {"sha": "8ccdb16b784ef75354115e48c1b6222aa6e3529a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -304,7 +304,7 @@ pub(crate) fn clean_predicate<'tcx>(\n             clean_region_outlives_predicate(pred)\n         }\n         ty::PredicateKind::Clause(ty::Clause::TypeOutlives(pred)) => {\n-            clean_type_outlives_predicate(pred, cx)\n+            clean_type_outlives_predicate(bound_predicate.rebind(pred), cx)\n         }\n         ty::PredicateKind::Clause(ty::Clause::Projection(pred)) => {\n             Some(clean_projection_predicate(bound_predicate.rebind(pred), cx))\n@@ -345,7 +345,7 @@ fn clean_poly_trait_predicate<'tcx>(\n }\n \n fn clean_region_outlives_predicate<'tcx>(\n-    pred: ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>,\n+    pred: ty::RegionOutlivesPredicate<'tcx>,\n ) -> Option<WherePredicate> {\n     let ty::OutlivesPredicate(a, b) = pred;\n \n@@ -358,13 +358,13 @@ fn clean_region_outlives_predicate<'tcx>(\n }\n \n fn clean_type_outlives_predicate<'tcx>(\n-    pred: ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>,\n+    pred: ty::Binder<'tcx, ty::TypeOutlivesPredicate<'tcx>>,\n     cx: &mut DocContext<'tcx>,\n ) -> Option<WherePredicate> {\n-    let ty::OutlivesPredicate(ty, lt) = pred;\n+    let ty::OutlivesPredicate(ty, lt) = pred.skip_binder();\n \n     Some(WherePredicate::BoundPredicate {\n-        ty: clean_middle_ty(ty::Binder::dummy(ty), cx, None),\n+        ty: clean_middle_ty(pred.rebind(ty), cx, None),\n         bounds: vec![GenericBound::Outlives(\n             clean_middle_region(lt).expect(\"failed to clean lifetimes\"),\n         )],"}, {"sha": "f04dfab36cad8e46755a8e624a787971c738076d", "filename": "src/tools/miri/tests/fail/panic/double_panic.stderr", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fpanic%2Fdouble_panic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fpanic%2Fdouble_panic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fpanic%2Fdouble_panic.stderr?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -12,57 +12,59 @@ stack backtrace:\n  at RUSTLIB/std/src/sys_common/backtrace.rs:LL:CC\n    4: <std::sys_common::backtrace::_print::DisplayBacktrace as std::fmt::Display>::fmt\n  at RUSTLIB/std/src/sys_common/backtrace.rs:LL:CC\n-   5: std::fmt::write\n+   5: core::fmt::rt::Argument::fmt\n+ at RUSTLIB/core/src/fmt/rt.rs:LL:CC\n+   6: std::fmt::write\n  at RUSTLIB/core/src/fmt/mod.rs:LL:CC\n-   6: <std::sys::PLATFORM::stdio::Stderr as std::io::Write>::write_fmt\n+   7: <std::sys::PLATFORM::stdio::Stderr as std::io::Write>::write_fmt\n  at RUSTLIB/std/src/io/mod.rs:LL:CC\n-   7: std::sys_common::backtrace::_print\n+   8: std::sys_common::backtrace::_print\n  at RUSTLIB/std/src/sys_common/backtrace.rs:LL:CC\n-   8: std::sys_common::backtrace::print\n+   9: std::sys_common::backtrace::print\n  at RUSTLIB/std/src/sys_common/backtrace.rs:LL:CC\n-   9: std::panicking::default_hook::{closure#1}\n+  10: std::panicking::default_hook::{closure#1}\n  at RUSTLIB/std/src/panicking.rs:LL:CC\n-  10: std::panicking::default_hook\n+  11: std::panicking::default_hook\n  at RUSTLIB/std/src/panicking.rs:LL:CC\n-  11: std::panicking::rust_panic_with_hook\n+  12: std::panicking::rust_panic_with_hook\n  at RUSTLIB/std/src/panicking.rs:LL:CC\n-  12: std::rt::begin_panic::{closure#0}\n+  13: std::rt::begin_panic::{closure#0}\n  at RUSTLIB/std/src/panicking.rs:LL:CC\n-  13: std::sys_common::backtrace::__rust_end_short_backtrace\n+  14: std::sys_common::backtrace::__rust_end_short_backtrace\n  at RUSTLIB/std/src/sys_common/backtrace.rs:LL:CC\n-  14: std::rt::begin_panic\n+  15: std::rt::begin_panic\n  at RUSTLIB/std/src/panicking.rs:LL:CC\n-  15: <Foo as std::ops::Drop>::drop\n+  16: <Foo as std::ops::Drop>::drop\n  at $DIR/double_panic.rs:LL:CC\n-  16: std::ptr::drop_in_place - shim(Some(Foo))\n+  17: std::ptr::drop_in_place - shim(Some(Foo))\n  at RUSTLIB/core/src/ptr/mod.rs:LL:CC\n-  17: main\n+  18: main\n  at $DIR/double_panic.rs:LL:CC\n-  18: <fn() as std::ops::FnOnce<()>>::call_once - shim(fn())\n+  19: <fn() as std::ops::FnOnce<()>>::call_once - shim(fn())\n  at RUSTLIB/core/src/ops/function.rs:LL:CC\n-  19: std::sys_common::backtrace::__rust_begin_short_backtrace\n+  20: std::sys_common::backtrace::__rust_begin_short_backtrace\n  at RUSTLIB/std/src/sys_common/backtrace.rs:LL:CC\n-  20: std::rt::lang_start::{closure#0}\n+  21: std::rt::lang_start::{closure#0}\n  at RUSTLIB/std/src/rt.rs:LL:CC\n-  21: std::ops::function::impls::call_once\n+  22: std::ops::function::impls::call_once\n  at RUSTLIB/core/src/ops/function.rs:LL:CC\n-  22: std::panicking::r#try::do_call\n+  23: std::panicking::r#try::do_call\n  at RUSTLIB/std/src/panicking.rs:LL:CC\n-  23: std::panicking::r#try\n+  24: std::panicking::r#try\n  at RUSTLIB/std/src/panicking.rs:LL:CC\n-  24: std::panic::catch_unwind\n+  25: std::panic::catch_unwind\n  at RUSTLIB/std/src/panic.rs:LL:CC\n-  25: std::rt::lang_start_internal::{closure#2}\n+  26: std::rt::lang_start_internal::{closure#2}\n  at RUSTLIB/std/src/rt.rs:LL:CC\n-  26: std::panicking::r#try::do_call\n+  27: std::panicking::r#try::do_call\n  at RUSTLIB/std/src/panicking.rs:LL:CC\n-  27: std::panicking::r#try\n+  28: std::panicking::r#try\n  at RUSTLIB/std/src/panicking.rs:LL:CC\n-  28: std::panic::catch_unwind\n+  29: std::panic::catch_unwind\n  at RUSTLIB/std/src/panic.rs:LL:CC\n-  29: std::rt::lang_start_internal\n+  30: std::rt::lang_start_internal\n  at RUSTLIB/std/src/rt.rs:LL:CC\n-  30: std::rt::lang_start\n+  31: std::rt::lang_start\n  at RUSTLIB/std/src/rt.rs:LL:CC\n thread panicked while panicking. aborting.\n error: abnormal termination: the program aborted execution"}, {"sha": "5fbd1789b3a9a9a13520f0072d1cc3fff583a530", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/builtin_fn_macro.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -201,7 +201,7 @@ macro_rules! format_args {\n }\n \n fn main() {\n-    $crate::fmt::Arguments::new_v1(&[], &[$crate::fmt::ArgumentV1::new(&(arg1(a, b, c)), $crate::fmt::Display::fmt), $crate::fmt::ArgumentV1::new(&(arg2), $crate::fmt::Display::fmt), ]);\n+    $crate::fmt::Arguments::new_v1(&[], &[$crate::fmt::Argument::new(&(arg1(a, b, c)), $crate::fmt::Display::fmt), $crate::fmt::Argument::new(&(arg2), $crate::fmt::Display::fmt), ]);\n }\n \"#]],\n     );\n@@ -229,7 +229,7 @@ macro_rules! format_args {\n }\n \n fn main() {\n-    $crate::fmt::Arguments::new_v1(&[], &[$crate::fmt::ArgumentV1::new(&(a::<A, B>()), $crate::fmt::Display::fmt), $crate::fmt::ArgumentV1::new(&(b), $crate::fmt::Display::fmt), ]);\n+    $crate::fmt::Arguments::new_v1(&[], &[$crate::fmt::Argument::new(&(a::<A, B>()), $crate::fmt::Display::fmt), $crate::fmt::Argument::new(&(b), $crate::fmt::Display::fmt), ]);\n }\n \"#]],\n     );\n@@ -260,7 +260,7 @@ macro_rules! format_args {\n fn main() {\n     let _ =\n         /* parse error: expected field name or number */\n-$crate::fmt::Arguments::new_v1(&[], &[$crate::fmt::ArgumentV1::new(&(a.), $crate::fmt::Display::fmt), ]);\n+$crate::fmt::Arguments::new_v1(&[], &[$crate::fmt::Argument::new(&(a.), $crate::fmt::Display::fmt), ]);\n }\n \"#]],\n     );"}, {"sha": "a9c5e1488aac0b77deba020d3bb9e6e73191c510", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/builtin_fn_macro.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -241,8 +241,8 @@ fn format_args_expand(\n     // We expand `format_args!(\"\", a1, a2)` to\n     // ```\n     // $crate::fmt::Arguments::new_v1(&[], &[\n-    //   $crate::fmt::ArgumentV1::new(&arg1,$crate::fmt::Display::fmt),\n-    //   $crate::fmt::ArgumentV1::new(&arg2,$crate::fmt::Display::fmt),\n+    //   $crate::fmt::Argument::new(&arg1,$crate::fmt::Display::fmt),\n+    //   $crate::fmt::Argument::new(&arg2,$crate::fmt::Display::fmt),\n     // ])\n     // ```,\n     // which is still not really correct, but close enough for now\n@@ -267,7 +267,7 @@ fn format_args_expand(\n     }\n     let _format_string = args.remove(0);\n     let arg_tts = args.into_iter().flat_map(|arg| {\n-        quote! { #DOLLAR_CRATE::fmt::ArgumentV1::new(&(#arg), #DOLLAR_CRATE::fmt::Display::fmt), }\n+        quote! { #DOLLAR_CRATE::fmt::Argument::new(&(#arg), #DOLLAR_CRATE::fmt::Display::fmt), }\n     }.token_trees);\n     let expanded = quote! {\n         #DOLLAR_CRATE::fmt::Arguments::new_v1(&[], &[##arg_tts])"}, {"sha": "9bda5f575c99f0069d0b35972794c758af95c035", "filename": "tests/mir-opt/sroa/lifetimes.foo.ScalarReplacementOfAggregates.diff", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/tests%2Fmir-opt%2Fsroa%2Flifetimes.foo.ScalarReplacementOfAggregates.diff", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/tests%2Fmir-opt%2Fsroa%2Flifetimes.foo.ScalarReplacementOfAggregates.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fsroa%2Flifetimes.foo.ScalarReplacementOfAggregates.diff?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -15,14 +15,14 @@\n       let mut _13: &[&str; 3];             // in scope 0 at $DIR/lifetimes.rs:+10:19: +10:28\n       let _14: &[&str; 3];                 // in scope 0 at $DIR/lifetimes.rs:+10:19: +10:28\n       let _15: [&str; 3];                  // in scope 0 at $DIR/lifetimes.rs:+10:19: +10:28\n-      let mut _16: &[core::fmt::ArgumentV1<'_>]; // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let mut _17: &[core::fmt::ArgumentV1<'_>; 2]; // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let _18: &[core::fmt::ArgumentV1<'_>; 2]; // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let _19: [core::fmt::ArgumentV1<'_>; 2]; // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let mut _20: core::fmt::ArgumentV1<'_>; // in scope 0 at $DIR/lifetimes.rs:+10:20: +10:23\n+      let mut _16: &[core::fmt::rt::Argument<'_>]; // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n+      let mut _17: &[core::fmt::rt::Argument<'_>; 2]; // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n+      let _18: &[core::fmt::rt::Argument<'_>; 2]; // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n+      let _19: [core::fmt::rt::Argument<'_>; 2]; // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n+      let mut _20: core::fmt::rt::Argument<'_>; // in scope 0 at $DIR/lifetimes.rs:+10:20: +10:23\n       let mut _21: &std::boxed::Box<dyn std::fmt::Display>; // in scope 0 at $DIR/lifetimes.rs:+10:20: +10:23\n       let _22: &std::boxed::Box<dyn std::fmt::Display>; // in scope 0 at $DIR/lifetimes.rs:+10:20: +10:23\n-      let mut _23: core::fmt::ArgumentV1<'_>; // in scope 0 at $DIR/lifetimes.rs:+10:24: +10:27\n+      let mut _23: core::fmt::rt::Argument<'_>; // in scope 0 at $DIR/lifetimes.rs:+10:24: +10:27\n       let mut _24: &u32;                   // in scope 0 at $DIR/lifetimes.rs:+10:24: +10:27\n       let _25: &u32;                       // in scope 0 at $DIR/lifetimes.rs:+10:24: +10:27\n       let mut _27: bool;                   // in scope 0 at $DIR/lifetimes.rs:+12:1: +12:2\n@@ -113,11 +113,11 @@\n           StorageLive(_22);                // scope 4 at $DIR/lifetimes.rs:+10:20: +10:23\n           _22 = &_8;                       // scope 4 at $DIR/lifetimes.rs:+10:20: +10:23\n           _21 = &(*_22);                   // scope 4 at $DIR/lifetimes.rs:+10:20: +10:23\n-          _20 = core::fmt::ArgumentV1::<'_>::new_display::<Box<dyn std::fmt::Display>>(move _21) -> [return: bb3, unwind unreachable]; // scope 4 at $DIR/lifetimes.rs:+10:20: +10:23\n+          _20 = core::fmt::rt::Argument::<'_>::new_display::<Box<dyn std::fmt::Display>>(move _21) -> [return: bb3, unwind unreachable]; // scope 4 at $DIR/lifetimes.rs:+10:20: +10:23\n                                            // mir::Constant\n                                            // + span: $DIR/lifetimes.rs:27:20: 27:23\n                                            // + user_ty: UserType(4)\n-                                           // + literal: Const { ty: for<'b> fn(&'b Box<dyn std::fmt::Display>) -> core::fmt::ArgumentV1<'b> {core::fmt::ArgumentV1::<'_>::new_display::<Box<dyn std::fmt::Display>>}, val: Value(<ZST>) }\n+                                           // + literal: Const { ty: for<'b> fn(&'b Box<dyn std::fmt::Display>) -> core::fmt::rt::Argument<'b> {core::fmt::rt::Argument::<'_>::new_display::<Box<dyn std::fmt::Display>>}, val: Value(<ZST>) }\n       }\n   \n       bb3: {\n@@ -127,11 +127,11 @@\n           StorageLive(_25);                // scope 4 at $DIR/lifetimes.rs:+10:24: +10:27\n           _25 = &_6;                       // scope 4 at $DIR/lifetimes.rs:+10:24: +10:27\n           _24 = &(*_25);                   // scope 4 at $DIR/lifetimes.rs:+10:24: +10:27\n-          _23 = core::fmt::ArgumentV1::<'_>::new_display::<u32>(move _24) -> [return: bb4, unwind unreachable]; // scope 4 at $DIR/lifetimes.rs:+10:24: +10:27\n+          _23 = core::fmt::rt::Argument::<'_>::new_display::<u32>(move _24) -> [return: bb4, unwind unreachable]; // scope 4 at $DIR/lifetimes.rs:+10:24: +10:27\n                                            // mir::Constant\n                                            // + span: $DIR/lifetimes.rs:27:24: 27:27\n                                            // + user_ty: UserType(5)\n-                                           // + literal: Const { ty: for<'b> fn(&'b u32) -> core::fmt::ArgumentV1<'b> {core::fmt::ArgumentV1::<'_>::new_display::<u32>}, val: Value(<ZST>) }\n+                                           // + literal: Const { ty: for<'b> fn(&'b u32) -> core::fmt::rt::Argument<'b> {core::fmt::rt::Argument::<'_>::new_display::<u32>}, val: Value(<ZST>) }\n       }\n   \n       bb4: {\n@@ -141,13 +141,13 @@\n           StorageDead(_20);                // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n           _18 = &_19;                      // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n           _17 = &(*_18);                   // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          _16 = move _17 as &[core::fmt::ArgumentV1<'_>] (Pointer(Unsize)); // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          _16 = move _17 as &[core::fmt::rt::Argument<'_>] (Pointer(Unsize)); // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n           StorageDead(_17);                // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n           _11 = Arguments::<'_>::new_v1(move _12, move _16) -> [return: bb5, unwind unreachable]; // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/std/src/macros.rs:LL:COL\n                                            // + user_ty: UserType(3)\n-                                           // + literal: Const { ty: fn(&[&'static str], &[core::fmt::ArgumentV1<'_>]) -> Arguments<'_> {Arguments::<'_>::new_v1}, val: Value(<ZST>) }\n+                                           // + literal: Const { ty: fn(&[&'static str], &[core::fmt::rt::Argument<'_>]) -> Arguments<'_> {Arguments::<'_>::new_v1}, val: Value(<ZST>) }\n       }\n   \n       bb5: {"}, {"sha": "e3154baf860a32ed360b09c49c286771a17db35e", "filename": "tests/rustdoc-ui/issue-110900.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/tests%2Frustdoc-ui%2Fissue-110900.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/tests%2Frustdoc-ui%2Fissue-110900.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fissue-110900.rs?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -0,0 +1,28 @@\n+// check-pass\n+\n+#![crate_type=\"lib\"]\n+#![feature(associated_type_bounds)]\n+\n+trait A<'a> {}\n+trait B<'b> {}\n+\n+trait C<'c>: for<'a> A<'a> + for<'b> B<'b> {\n+    type As;\n+}\n+\n+trait E<'e> {\n+    type As;\n+}\n+trait F<'f>: for<'a> A<'a> + for<'e> E<'e> {}\n+struct G<T>\n+where\n+    T: for<'l, 'i> H<'l, 'i, As: for<'a> A<'a> + 'i>\n+{\n+    t: std::marker::PhantomData<T>,\n+}\n+\n+trait I<'a, 'b, 'c> {\n+    type As;\n+}\n+\n+trait H<'d, 'e>: for<'f> I<'d, 'f, 'e> + 'd {}"}, {"sha": "644acc27b58e2185f6da7a3479ebf0ea402c82b7", "filename": "tests/ui/attributes/invalid_macro_export_argument.deny.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/tests%2Fui%2Fattributes%2Finvalid_macro_export_argument.deny.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/tests%2Fui%2Fattributes%2Finvalid_macro_export_argument.deny.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fattributes%2Finvalid_macro_export_argument.deny.stderr?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -0,0 +1,20 @@\n+error: `#[macro_export]` can only take 1 or 0 arguments\n+  --> $DIR/invalid_macro_export_argument.rs:7:1\n+   |\n+LL | #[macro_export(hello, world)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/invalid_macro_export_argument.rs:4:24\n+   |\n+LL | #![cfg_attr(deny, deny(invalid_macro_export_arguments))]\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `not_local_inner_macros` isn't a valid `#[macro_export]` argument\n+  --> $DIR/invalid_macro_export_argument.rs:13:16\n+   |\n+LL | #[macro_export(not_local_inner_macros)]\n+   |                ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "a0ed5fd1c8fa213eda08e751276c2d3dd318ae58", "filename": "tests/ui/attributes/invalid_macro_export_argument.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/tests%2Fui%2Fattributes%2Finvalid_macro_export_argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/tests%2Fui%2Fattributes%2Finvalid_macro_export_argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fattributes%2Finvalid_macro_export_argument.rs?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -1,10 +1,17 @@\n-// check-pass\n-#[macro_export(hello, world)] //~ WARN `#[macro_export]` can only take 1 or 0 arguments\n+// revisions: deny allow\n+//[allow] check-pass\n+\n+#![cfg_attr(deny, deny(invalid_macro_export_arguments))]\n+#![cfg_attr(allow, allow(invalid_macro_export_arguments))]\n+\n+#[macro_export(hello, world)]\n+//[deny]~^ ERROR `#[macro_export]` can only take 1 or 0 arguments\n macro_rules! a {\n     () => ()\n }\n \n-#[macro_export(not_local_inner_macros)] //~ WARN `not_local_inner_macros` isn't a valid `#[macro_export]` argument\n+#[macro_export(not_local_inner_macros)]\n+//[deny]~^ ERROR `not_local_inner_macros` isn't a valid `#[macro_export]` argument\n macro_rules! b {\n     () => ()\n }"}, {"sha": "a4e17642c2aac289523128602b3f209935585a81", "filename": "tests/ui/attributes/invalid_macro_export_argument.stderr", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/033aa092ab23ba14cdad27073c5e37ba0eddb428/tests%2Fui%2Fattributes%2Finvalid_macro_export_argument.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/033aa092ab23ba14cdad27073c5e37ba0eddb428/tests%2Fui%2Fattributes%2Finvalid_macro_export_argument.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fattributes%2Finvalid_macro_export_argument.stderr?ref=033aa092ab23ba14cdad27073c5e37ba0eddb428", "patch": "@@ -1,16 +0,0 @@\n-warning: `#[macro_export]` can only take 1 or 0 arguments\n-  --> $DIR/invalid_macro_export_argument.rs:2:1\n-   |\n-LL | #[macro_export(hello, world)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `#[warn(invalid_macro_export_arguments)]` on by default\n-\n-warning: `not_local_inner_macros` isn't a valid `#[macro_export]` argument\n-  --> $DIR/invalid_macro_export_argument.rs:7:16\n-   |\n-LL | #[macro_export(not_local_inner_macros)]\n-   |                ^^^^^^^^^^^^^^^^^^^^^^\n-\n-warning: 2 warnings emitted\n-"}, {"sha": "ed008c454a31ceb9df071bfd931e26edd85fcab6", "filename": "tests/ui/fmt/ifmt-bad-arg.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/tests%2Fui%2Ffmt%2Fifmt-bad-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/tests%2Fui%2Ffmt%2Fifmt-bad-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffmt%2Fifmt-bad-arg.stderr?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -307,7 +307,7 @@ LL |     println!(\"{} {:.*} {}\", 1, 3.2, 4);\n    = note: expected reference `&usize`\n               found reference `&{float}`\n note: associated function defined here\n-  --> $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+  --> $SRC_DIR/core/src/fmt/rt.rs:LL:COL\n    = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0308]: mismatched types\n@@ -321,7 +321,7 @@ LL |     println!(\"{} {:07$.*} {}\", 1, 3.2, 4);\n    = note: expected reference `&usize`\n               found reference `&{float}`\n note: associated function defined here\n-  --> $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+  --> $SRC_DIR/core/src/fmt/rt.rs:LL:COL\n    = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 38 previous errors"}, {"sha": "cc316e55f5cb673e3dc164a9148fa6c03a0d2c90", "filename": "tests/ui/fmt/ifmt-unimpl.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/tests%2Fui%2Ffmt%2Fifmt-unimpl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/tests%2Fui%2Ffmt%2Fifmt-unimpl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffmt%2Fifmt-unimpl.stderr?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -17,9 +17,9 @@ LL |     format!(\"{:X}\", \"3\");\n              NonZeroIsize\n            and 21 others\n    = note: required for `&str` to implement `UpperHex`\n-note: required by a bound in `core::fmt::ArgumentV1::<'a>::new_upper_hex`\n-  --> $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-   = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `arg_new` (in Nightly builds, run with -Z macro-backtrace for more info)\n+note: required by a bound in `core::fmt::rt::Argument::<'a>::new_upper_hex`\n+  --> $SRC_DIR/core/src/fmt/rt.rs:LL:COL\n+   = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "b517a342e634d16d341f9a5dbf7d23c161d1a37a", "filename": "tests/ui/fmt/send-sync.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/tests%2Fui%2Ffmt%2Fsend-sync.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/tests%2Fui%2Ffmt%2Fsend-sync.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffmt%2Fsend-sync.stderr?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -1,36 +1,36 @@\n-error[E0277]: `core::fmt::Opaque` cannot be shared between threads safely\n+error[E0277]: `core::fmt::rt::Opaque` cannot be shared between threads safely\n   --> $DIR/send-sync.rs:8:10\n    |\n LL |     send(format_args!(\"{:?}\", c));\n-   |     ---- ^^^^^^^^^^^^^^^^^^^^^^^ `core::fmt::Opaque` cannot be shared between threads safely\n+   |     ---- ^^^^^^^^^^^^^^^^^^^^^^^ `core::fmt::rt::Opaque` cannot be shared between threads safely\n    |     |\n    |     required by a bound introduced by this call\n    |\n-   = help: within `[core::fmt::ArgumentV1<'_>]`, the trait `Sync` is not implemented for `core::fmt::Opaque`\n-   = note: required because it appears within the type `&core::fmt::Opaque`\n-   = note: required because it appears within the type `ArgumentV1<'_>`\n-   = note: required because it appears within the type `[ArgumentV1<'_>]`\n-   = note: required for `&[core::fmt::ArgumentV1<'_>]` to implement `Send`\n+   = help: within `[core::fmt::rt::Argument<'_>]`, the trait `Sync` is not implemented for `core::fmt::rt::Opaque`\n+   = note: required because it appears within the type `&core::fmt::rt::Opaque`\n+   = note: required because it appears within the type `Argument<'_>`\n+   = note: required because it appears within the type `[Argument<'_>]`\n+   = note: required for `&[core::fmt::rt::Argument<'_>]` to implement `Send`\n    = note: required because it appears within the type `Arguments<'_>`\n note: required by a bound in `send`\n   --> $DIR/send-sync.rs:1:12\n    |\n LL | fn send<T: Send>(_: T) {}\n    |            ^^^^ required by this bound in `send`\n \n-error[E0277]: `core::fmt::Opaque` cannot be shared between threads safely\n+error[E0277]: `core::fmt::rt::Opaque` cannot be shared between threads safely\n   --> $DIR/send-sync.rs:9:10\n    |\n LL |     sync(format_args!(\"{:?}\", c));\n-   |     ---- ^^^^^^^^^^^^^^^^^^^^^^^ `core::fmt::Opaque` cannot be shared between threads safely\n+   |     ---- ^^^^^^^^^^^^^^^^^^^^^^^ `core::fmt::rt::Opaque` cannot be shared between threads safely\n    |     |\n    |     required by a bound introduced by this call\n    |\n-   = help: within `Arguments<'_>`, the trait `Sync` is not implemented for `core::fmt::Opaque`\n-   = note: required because it appears within the type `&core::fmt::Opaque`\n-   = note: required because it appears within the type `ArgumentV1<'_>`\n-   = note: required because it appears within the type `[ArgumentV1<'_>]`\n-   = note: required because it appears within the type `&[ArgumentV1<'_>]`\n+   = help: within `Arguments<'_>`, the trait `Sync` is not implemented for `core::fmt::rt::Opaque`\n+   = note: required because it appears within the type `&core::fmt::rt::Opaque`\n+   = note: required because it appears within the type `Argument<'_>`\n+   = note: required because it appears within the type `[Argument<'_>]`\n+   = note: required because it appears within the type `&[Argument<'_>]`\n    = note: required because it appears within the type `Arguments<'_>`\n note: required by a bound in `sync`\n   --> $DIR/send-sync.rs:2:12"}, {"sha": "aa78c9a6906438837aa34315966dcc9e0dc6ee89", "filename": "tests/ui/macros/missing-bang-in-decl.stderr", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/tests%2Fui%2Fmacros%2Fmissing-bang-in-decl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/tests%2Fui%2Fmacros%2Fmissing-bang-in-decl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Fmissing-bang-in-decl.stderr?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -2,13 +2,23 @@ error: expected `!` after `macro_rules`\n   --> $DIR/missing-bang-in-decl.rs:5:1\n    |\n LL | macro_rules foo {\n-   | ^^^^^^^^^^^ help: add a `!`: `macro_rules!`\n+   | ^^^^^^^^^^^\n+   |\n+help: add a `!`\n+   |\n+LL | macro_rules! foo {\n+   |            +\n \n error: expected `!` after `macro_rules`\n   --> $DIR/missing-bang-in-decl.rs:10:1\n    |\n LL | macro_rules bar! {\n-   | ^^^^^^^^^^^ help: add a `!`: `macro_rules!`\n+   | ^^^^^^^^^^^\n+   |\n+help: add a `!`\n+   |\n+LL | macro_rules! bar! {\n+   |            +\n \n error: macro names aren't followed by a `!`\n   --> $DIR/missing-bang-in-decl.rs:10:16"}, {"sha": "4b99537fbf7f4e88816f0fb5b9c4146d8bd0de8e", "filename": "tests/ui/parser/item-kw-case-mismatch.fixed", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/tests%2Fui%2Fparser%2Fitem-kw-case-mismatch.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/tests%2Fui%2Fparser%2Fitem-kw-case-mismatch.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fitem-kw-case-mismatch.fixed?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -4,31 +4,31 @@\n \n fn main() {}\n \n-use std::ptr::read;  //~ ERROR keyword `use` is written in a wrong case\n-use std::ptr::write; //~ ERROR keyword `use` is written in a wrong case\n+use std::ptr::read;  //~ ERROR keyword `use` is written in the wrong case\n+use std::ptr::write; //~ ERROR keyword `use` is written in the wrong case\n \n async fn _a() {}\n-//~^ ERROR keyword `fn` is written in a wrong case\n+//~^ ERROR keyword `fn` is written in the wrong case\n \n fn _b() {}\n-//~^ ERROR keyword `fn` is written in a wrong case\n+//~^ ERROR keyword `fn` is written in the wrong case\n \n async fn _c() {}\n-//~^ ERROR keyword `async` is written in a wrong case\n-//~| ERROR keyword `fn` is written in a wrong case\n+//~^ ERROR keyword `async` is written in the wrong case\n+//~| ERROR keyword `fn` is written in the wrong case\n \n async fn _d() {}\n-//~^ ERROR keyword `async` is written in a wrong case\n+//~^ ERROR keyword `async` is written in the wrong case\n \n const unsafe fn _e() {}\n-//~^ ERROR keyword `const` is written in a wrong case\n-//~| ERROR keyword `unsafe` is written in a wrong case\n-//~| ERROR keyword `fn` is written in a wrong case\n+//~^ ERROR keyword `const` is written in the wrong case\n+//~| ERROR keyword `unsafe` is written in the wrong case\n+//~| ERROR keyword `fn` is written in the wrong case\n \n unsafe extern fn _f() {}\n-//~^ ERROR keyword `unsafe` is written in a wrong case\n-//~| ERROR keyword `extern` is written in a wrong case\n+//~^ ERROR keyword `unsafe` is written in the wrong case\n+//~| ERROR keyword `extern` is written in the wrong case\n \n extern \"C\" fn _g() {}\n-//~^ ERROR keyword `extern` is written in a wrong case\n-//~| ERROR keyword `fn` is written in a wrong case\n+//~^ ERROR keyword `extern` is written in the wrong case\n+//~| ERROR keyword `fn` is written in the wrong case"}, {"sha": "b11ec93754fc5808bb091e7d49aeda5a84813198", "filename": "tests/ui/parser/item-kw-case-mismatch.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/tests%2Fui%2Fparser%2Fitem-kw-case-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/tests%2Fui%2Fparser%2Fitem-kw-case-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fitem-kw-case-mismatch.rs?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -4,31 +4,31 @@\n \n fn main() {}\n \n-Use std::ptr::read;  //~ ERROR keyword `use` is written in a wrong case\n-USE std::ptr::write; //~ ERROR keyword `use` is written in a wrong case\n+Use std::ptr::read;  //~ ERROR keyword `use` is written in the wrong case\n+USE std::ptr::write; //~ ERROR keyword `use` is written in the wrong case\n \n async Fn _a() {}\n-//~^ ERROR keyword `fn` is written in a wrong case\n+//~^ ERROR keyword `fn` is written in the wrong case\n \n Fn _b() {}\n-//~^ ERROR keyword `fn` is written in a wrong case\n+//~^ ERROR keyword `fn` is written in the wrong case\n \n aSYNC fN _c() {}\n-//~^ ERROR keyword `async` is written in a wrong case\n-//~| ERROR keyword `fn` is written in a wrong case\n+//~^ ERROR keyword `async` is written in the wrong case\n+//~| ERROR keyword `fn` is written in the wrong case\n \n Async fn _d() {}\n-//~^ ERROR keyword `async` is written in a wrong case\n+//~^ ERROR keyword `async` is written in the wrong case\n \n CONST UNSAFE FN _e() {}\n-//~^ ERROR keyword `const` is written in a wrong case\n-//~| ERROR keyword `unsafe` is written in a wrong case\n-//~| ERROR keyword `fn` is written in a wrong case\n+//~^ ERROR keyword `const` is written in the wrong case\n+//~| ERROR keyword `unsafe` is written in the wrong case\n+//~| ERROR keyword `fn` is written in the wrong case\n \n unSAFE EXTern fn _f() {}\n-//~^ ERROR keyword `unsafe` is written in a wrong case\n-//~| ERROR keyword `extern` is written in a wrong case\n+//~^ ERROR keyword `unsafe` is written in the wrong case\n+//~| ERROR keyword `extern` is written in the wrong case\n \n EXTERN \"C\" FN _g() {}\n-//~^ ERROR keyword `extern` is written in a wrong case\n-//~| ERROR keyword `fn` is written in a wrong case\n+//~^ ERROR keyword `extern` is written in the wrong case\n+//~| ERROR keyword `fn` is written in the wrong case"}, {"sha": "ba59ea853633831dc5a572514ffda2921969a4ae", "filename": "tests/ui/parser/item-kw-case-mismatch.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/tests%2Fui%2Fparser%2Fitem-kw-case-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/tests%2Fui%2Fparser%2Fitem-kw-case-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fitem-kw-case-mismatch.stderr?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -1,82 +1,82 @@\n-error: keyword `use` is written in a wrong case\n+error: keyword `use` is written in the wrong case\n   --> $DIR/item-kw-case-mismatch.rs:7:1\n    |\n LL | Use std::ptr::read;\n    | ^^^ help: write it in the correct case (notice the capitalization): `use`\n \n-error: keyword `use` is written in a wrong case\n+error: keyword `use` is written in the wrong case\n   --> $DIR/item-kw-case-mismatch.rs:8:1\n    |\n LL | USE std::ptr::write;\n    | ^^^ help: write it in the correct case: `use`\n \n-error: keyword `fn` is written in a wrong case\n+error: keyword `fn` is written in the wrong case\n   --> $DIR/item-kw-case-mismatch.rs:10:7\n    |\n LL | async Fn _a() {}\n    |       ^^ help: write it in the correct case (notice the capitalization): `fn`\n \n-error: keyword `fn` is written in a wrong case\n+error: keyword `fn` is written in the wrong case\n   --> $DIR/item-kw-case-mismatch.rs:13:1\n    |\n LL | Fn _b() {}\n    | ^^ help: write it in the correct case (notice the capitalization): `fn`\n \n-error: keyword `async` is written in a wrong case\n+error: keyword `async` is written in the wrong case\n   --> $DIR/item-kw-case-mismatch.rs:16:1\n    |\n LL | aSYNC fN _c() {}\n    | ^^^^^ help: write it in the correct case: `async`\n \n-error: keyword `fn` is written in a wrong case\n+error: keyword `fn` is written in the wrong case\n   --> $DIR/item-kw-case-mismatch.rs:16:7\n    |\n LL | aSYNC fN _c() {}\n    |       ^^ help: write it in the correct case: `fn`\n \n-error: keyword `async` is written in a wrong case\n+error: keyword `async` is written in the wrong case\n   --> $DIR/item-kw-case-mismatch.rs:20:1\n    |\n LL | Async fn _d() {}\n    | ^^^^^ help: write it in the correct case: `async`\n \n-error: keyword `const` is written in a wrong case\n+error: keyword `const` is written in the wrong case\n   --> $DIR/item-kw-case-mismatch.rs:23:1\n    |\n LL | CONST UNSAFE FN _e() {}\n    | ^^^^^ help: write it in the correct case: `const`\n \n-error: keyword `unsafe` is written in a wrong case\n+error: keyword `unsafe` is written in the wrong case\n   --> $DIR/item-kw-case-mismatch.rs:23:7\n    |\n LL | CONST UNSAFE FN _e() {}\n    |       ^^^^^^ help: write it in the correct case: `unsafe`\n \n-error: keyword `fn` is written in a wrong case\n+error: keyword `fn` is written in the wrong case\n   --> $DIR/item-kw-case-mismatch.rs:23:14\n    |\n LL | CONST UNSAFE FN _e() {}\n    |              ^^ help: write it in the correct case: `fn`\n \n-error: keyword `unsafe` is written in a wrong case\n+error: keyword `unsafe` is written in the wrong case\n   --> $DIR/item-kw-case-mismatch.rs:28:1\n    |\n LL | unSAFE EXTern fn _f() {}\n    | ^^^^^^ help: write it in the correct case: `unsafe`\n \n-error: keyword `extern` is written in a wrong case\n+error: keyword `extern` is written in the wrong case\n   --> $DIR/item-kw-case-mismatch.rs:28:8\n    |\n LL | unSAFE EXTern fn _f() {}\n    |        ^^^^^^ help: write it in the correct case: `extern`\n \n-error: keyword `extern` is written in a wrong case\n+error: keyword `extern` is written in the wrong case\n   --> $DIR/item-kw-case-mismatch.rs:32:1\n    |\n LL | EXTERN \"C\" FN _g() {}\n    | ^^^^^^ help: write it in the correct case: `extern`\n \n-error: keyword `fn` is written in a wrong case\n+error: keyword `fn` is written in the wrong case\n   --> $DIR/item-kw-case-mismatch.rs:32:12\n    |\n LL | EXTERN \"C\" FN _g() {}"}, {"sha": "fbd108ca613c72e34a6a33a2970d173c5b72108b", "filename": "tests/ui/parser/recover-unticked-labels.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/tests%2Fui%2Fparser%2Frecover-unticked-labels.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/tests%2Fui%2Fparser%2Frecover-unticked-labels.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Frecover-unticked-labels.stderr?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -2,13 +2,17 @@ error: expected a label, found an identifier\n   --> $DIR/recover-unticked-labels.rs:5:26\n    |\n LL |     'label: loop { break label 0 };\n-   |                          ^^^^^ help: labels start with a tick: `'label`\n+   |                          -^^^^\n+   |                          |\n+   |                          help: labels start with a tick\n \n error: expected a label, found an identifier\n   --> $DIR/recover-unticked-labels.rs:6:29\n    |\n LL |     'label: loop { continue label };\n-   |                             ^^^^^ help: labels start with a tick: `'label`\n+   |                             -^^^^\n+   |                             |\n+   |                             help: labels start with a tick\n \n error[E0425]: cannot find value `label` in this scope\n   --> $DIR/recover-unticked-labels.rs:4:26"}, {"sha": "bfc5374ef9d2d1e4d39e24ecc26194891d4abfb3", "filename": "tests/ui/parser/use-colon-as-mod-sep.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2fce2290865f012391b8f3e581c3852a248031fa/tests%2Fui%2Fparser%2Fuse-colon-as-mod-sep.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2fce2290865f012391b8f3e581c3852a248031fa/tests%2Fui%2Fparser%2Fuse-colon-as-mod-sep.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fuse-colon-as-mod-sep.stderr?ref=2fce2290865f012391b8f3e581c3852a248031fa", "patch": "@@ -11,18 +11,24 @@ error: expected `::`, found `:`\n    |\n LL | use std:fs::File;\n    |        ^ help: use double colon\n+   |\n+   = note: import paths are delimited using `::`\n \n error: expected `::`, found `:`\n   --> $DIR/use-colon-as-mod-sep.rs:7:8\n    |\n LL | use std:collections:HashMap;\n    |        ^ help: use double colon\n+   |\n+   = note: import paths are delimited using `::`\n \n error: expected `::`, found `:`\n   --> $DIR/use-colon-as-mod-sep.rs:7:20\n    |\n LL | use std:collections:HashMap;\n    |                    ^ help: use double colon\n+   |\n+   = note: import paths are delimited using `::`\n \n error: aborting due to 4 previous errors\n "}]}