{"sha": "7a322f9afff05b88507a6956a2d84a3abef0a0d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhMzIyZjlhZmZmMDViODg1MDdhNjk1NmEyZDg0YTNhYmVmMGEwZDY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-03-03T17:30:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-03T17:30:08Z"}, "message": "Merge #3392\n\n3392: Implement concat eager macro  r=matklad a=edwin0cheng\n\nThis PR implements the following things:\r\n\r\n1. Add basic eager macro infrastructure by introducing `EagerCallId` such that the new `MacroCallId` is defined as :\r\n\r\n```\r\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\r\npub enum MacroCallId {\r\n    LazyMacro(LazyMacroId),\r\n    EagerMacro(EagerMacroId),\r\n}\r\n```\r\n\r\n2. Add `concat!` builtin macro.\r\n\r\n\r\n\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "f811a7f405edca2b7e0c32666604117ef6486229", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f811a7f405edca2b7e0c32666604117ef6486229"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a322f9afff05b88507a6956a2d84a3abef0a0d6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeXpQgCRBK7hj4Ov3rIwAAdHIIAFLwJfOqdnWlvOAURMRiO5zx\nWzH094X0WYMVKuLyaWR5fll5FI/BGymgqvtE4KjXvxs+3WoJaJeDRXXqCyCdMJqj\nLI08J1YT+BAPOtuP3Ag1GKLZFiX5C0xIXP7xvE1SWVVPNX+ZENT9mtt3+zVpiCbY\n/gZ2+2h83/osCyNj8kq94Eoqsl7nKBvwCEbwUFYMT4i4GIdLAy5RsPbf0GGZsDN7\n/J1wqkDfOWyuSk4kCvHclvFx9adzDU9E8GfDdK0tbI0ntppglbF/StvIFxuFa7Eh\nHacFqs3LtLRhUvGt8itfiGqhu1TosG/+648N64Ec25/ulmy2Q88/Oz/TJPC6Tso=\n=7SXj\n-----END PGP SIGNATURE-----\n", "payload": "tree f811a7f405edca2b7e0c32666604117ef6486229\nparent 13b25d73b56ede36d1680efc19f5c11b0669b96c\nparent 4d5e80c6c86aa6bfee50e9f8b80b365c3120ed80\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1583256608 +0000\ncommitter GitHub <noreply@github.com> 1583256608 +0000\n\nMerge #3392\n\n3392: Implement concat eager macro  r=matklad a=edwin0cheng\n\nThis PR implements the following things:\r\n\r\n1. Add basic eager macro infrastructure by introducing `EagerCallId` such that the new `MacroCallId` is defined as :\r\n\r\n```\r\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\r\npub enum MacroCallId {\r\n    LazyMacro(LazyMacroId),\r\n    EagerMacro(EagerMacroId),\r\n}\r\n```\r\n\r\n2. Add `concat!` builtin macro.\r\n\r\n\r\n\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a322f9afff05b88507a6956a2d84a3abef0a0d6", "html_url": "https://github.com/rust-lang/rust/commit/7a322f9afff05b88507a6956a2d84a3abef0a0d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a322f9afff05b88507a6956a2d84a3abef0a0d6/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13b25d73b56ede36d1680efc19f5c11b0669b96c", "url": "https://api.github.com/repos/rust-lang/rust/commits/13b25d73b56ede36d1680efc19f5c11b0669b96c", "html_url": "https://github.com/rust-lang/rust/commit/13b25d73b56ede36d1680efc19f5c11b0669b96c"}, {"sha": "4d5e80c6c86aa6bfee50e9f8b80b365c3120ed80", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d5e80c6c86aa6bfee50e9f8b80b365c3120ed80", "html_url": "https://github.com/rust-lang/rust/commit/4d5e80c6c86aa6bfee50e9f8b80b365c3120ed80"}], "stats": {"total": 481, "additions": 399, "deletions": 82}, "files": [{"sha": "a3d617e1f0d35d3d5e59b1bc9316987602d0d574", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7a322f9afff05b88507a6956a2d84a3abef0a0d6/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a322f9afff05b88507a6956a2d84a3abef0a0d6/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=7a322f9afff05b88507a6956a2d84a3abef0a0d6", "patch": "@@ -47,8 +47,8 @@ mod marks;\n use std::hash::Hash;\n \n use hir_expand::{\n-    ast_id_map::FileAstId, db::AstDatabase, hygiene::Hygiene, AstId, HirFileId, InFile,\n-    MacroCallId, MacroCallKind, MacroDefId,\n+    ast_id_map::FileAstId, db::AstDatabase, eager::expand_eager_macro, hygiene::Hygiene, AstId,\n+    HirFileId, InFile, MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n };\n use ra_arena::{impl_arena_id, RawId};\n use ra_db::{impl_intern_key, salsa, CrateId};\n@@ -459,8 +459,21 @@ impl AsMacroCall for AstIdWithPath<ast::MacroCall> {\n         db: &impl AstDatabase,\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n     ) -> Option<MacroCallId> {\n-        let def = resolver(self.path.clone())?;\n-        Some(def.as_call_id(db, MacroCallKind::FnLike(self.ast_id)))\n+        let def: MacroDefId = resolver(self.path.clone())?;\n+\n+        if let MacroDefKind::BuiltInEager(_) = def.kind {\n+            let macro_call = InFile::new(self.ast_id.file_id, self.ast_id.to_node(db));\n+            let hygiene = Hygiene::new(db, self.ast_id.file_id);\n+\n+            Some(\n+                expand_eager_macro(db, macro_call, def, &|path: ast::Path| {\n+                    resolver(path::ModPath::from_src(path, &hygiene)?)\n+                })?\n+                .into(),\n+            )\n+        } else {\n+            Some(def.as_lazy_macro(db, MacroCallKind::FnLike(self.ast_id)).into())\n+        }\n     }\n }\n \n@@ -471,6 +484,6 @@ impl AsMacroCall for AstIdWithPath<ast::ModuleItem> {\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n     ) -> Option<MacroCallId> {\n         let def = resolver(self.path.clone())?;\n-        Some(def.as_call_id(db, MacroCallKind::Attr(self.ast_id)))\n+        Some(def.as_lazy_macro(db, MacroCallKind::Attr(self.ast_id)).into())\n     }\n }"}, {"sha": "87224481ce6d2c9bd2597041cec21d6ec80c039d", "filename": "crates/ra_hir_expand/src/builtin_derive.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7a322f9afff05b88507a6956a2d84a3abef0a0d6/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a322f9afff05b88507a6956a2d84a3abef0a0d6/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_derive.rs?ref=7a322f9afff05b88507a6956a2d84a3abef0a0d6", "patch": "@@ -9,7 +9,7 @@ use ra_syntax::{\n };\n \n use crate::db::AstDatabase;\n-use crate::{name, quote, MacroCallId, MacroDefId, MacroDefKind};\n+use crate::{name, quote, LazyMacroId, MacroDefId, MacroDefKind};\n \n macro_rules! register_builtin {\n     ( $($trait:ident => $expand:ident),* ) => {\n@@ -22,7 +22,7 @@ macro_rules! register_builtin {\n             pub fn expand(\n                 &self,\n                 db: &dyn AstDatabase,\n-                id: MacroCallId,\n+                id: LazyMacroId,\n                 tt: &tt::Subtree,\n             ) -> Result<tt::Subtree, mbe::ExpandError> {\n                 let expander = match *self {\n@@ -155,71 +155,71 @@ fn expand_simple_derive(\n \n fn copy_expand(\n     _db: &dyn AstDatabase,\n-    _id: MacroCallId,\n+    _id: LazyMacroId,\n     tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     expand_simple_derive(tt, quote! { std::marker::Copy })\n }\n \n fn clone_expand(\n     _db: &dyn AstDatabase,\n-    _id: MacroCallId,\n+    _id: LazyMacroId,\n     tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     expand_simple_derive(tt, quote! { std::clone::Clone })\n }\n \n fn default_expand(\n     _db: &dyn AstDatabase,\n-    _id: MacroCallId,\n+    _id: LazyMacroId,\n     tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     expand_simple_derive(tt, quote! { std::default::Default })\n }\n \n fn debug_expand(\n     _db: &dyn AstDatabase,\n-    _id: MacroCallId,\n+    _id: LazyMacroId,\n     tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     expand_simple_derive(tt, quote! { std::fmt::Debug })\n }\n \n fn hash_expand(\n     _db: &dyn AstDatabase,\n-    _id: MacroCallId,\n+    _id: LazyMacroId,\n     tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     expand_simple_derive(tt, quote! { std::hash::Hash })\n }\n \n fn eq_expand(\n     _db: &dyn AstDatabase,\n-    _id: MacroCallId,\n+    _id: LazyMacroId,\n     tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     expand_simple_derive(tt, quote! { std::cmp::Eq })\n }\n \n fn partial_eq_expand(\n     _db: &dyn AstDatabase,\n-    _id: MacroCallId,\n+    _id: LazyMacroId,\n     tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     expand_simple_derive(tt, quote! { std::cmp::PartialEq })\n }\n \n fn ord_expand(\n     _db: &dyn AstDatabase,\n-    _id: MacroCallId,\n+    _id: LazyMacroId,\n     tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     expand_simple_derive(tt, quote! { std::cmp::Ord })\n }\n \n fn partial_ord_expand(\n     _db: &dyn AstDatabase,\n-    _id: MacroCallId,\n+    _id: LazyMacroId,\n     tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     expand_simple_derive(tt, quote! { std::cmp::PartialOrd })\n@@ -228,7 +228,7 @@ fn partial_ord_expand(\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::{test_db::TestDB, AstId, MacroCallKind, MacroCallLoc};\n+    use crate::{test_db::TestDB, AstId, MacroCallId, MacroCallKind, MacroCallLoc};\n     use ra_db::{fixture::WithFixture, SourceDatabase};\n \n     fn expand_builtin_derive(s: &str, expander: BuiltinDeriveExpander) -> String {\n@@ -248,7 +248,7 @@ mod tests {\n             kind: MacroCallKind::Attr(AstId::new(file_id.into(), ast_id_map.ast_id(&items[0]))),\n         };\n \n-        let id = db.intern_macro(loc);\n+        let id: MacroCallId = db.intern_macro(loc).into();\n         let parsed = db.parse_or_expand(id.as_file()).unwrap();\n \n         // FIXME text() for syntax nodes parsed from token tree looks weird"}, {"sha": "1f380b5716c3c0b34684341ec9496777541e9ff2", "filename": "crates/ra_hir_expand/src/builtin_macro.rs", "status": "modified", "additions": 91, "deletions": 33, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/7a322f9afff05b88507a6956a2d84a3abef0a0d6/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a322f9afff05b88507a6956a2d84a3abef0a0d6/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs?ref=7a322f9afff05b88507a6956a2d84a3abef0a0d6", "patch": "@@ -1,53 +1,86 @@\n //! Builtin macro\n use crate::db::AstDatabase;\n use crate::{\n-    ast::{self},\n-    name, AstId, CrateId, MacroCallId, MacroDefId, MacroDefKind, TextUnit,\n+    ast::{self, AstToken, HasStringValue},\n+    name, AstId, CrateId, MacroDefId, MacroDefKind, TextUnit,\n };\n \n-use crate::quote;\n+use crate::{quote, LazyMacroId};\n+use either::Either;\n+use ra_parser::FragmentKind;\n \n macro_rules! register_builtin {\n-    ( $(($name:ident, $kind: ident) => $expand:ident),* ) => {\n+    ( LAZY: $(($name:ident, $kind: ident) => $expand:ident),* , EAGER: $(($e_name:ident, $e_kind: ident) => $e_expand:ident),*  ) => {\n         #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n         pub enum BuiltinFnLikeExpander {\n             $($kind),*\n         }\n \n+        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+        pub enum EagerExpander {\n+            $($e_kind),*\n+        }\n+\n         impl BuiltinFnLikeExpander {\n             pub fn expand(\n                 &self,\n                 db: &dyn AstDatabase,\n-                id: MacroCallId,\n+                id: LazyMacroId,\n                 tt: &tt::Subtree,\n             ) -> Result<tt::Subtree, mbe::ExpandError> {\n                 let expander = match *self {\n                     $( BuiltinFnLikeExpander::$kind => $expand, )*\n                 };\n                 expander(db, id, tt)\n             }\n+        }\n \n-            fn by_name(ident: &name::Name) -> Option<BuiltinFnLikeExpander> {\n-                match ident {\n-                    $( id if id == &name::name![$name] => Some(BuiltinFnLikeExpander::$kind), )*\n-                    _ => return None,\n-                }\n+        impl EagerExpander {\n+            pub fn expand(\n+                &self,\n+                tt: &tt::Subtree,\n+            ) -> Result<(tt::Subtree, FragmentKind), mbe::ExpandError> {\n+                let expander = match *self {\n+                    $( EagerExpander::$e_kind => $e_expand, )*\n+                };\n+                expander(tt)\n             }\n         }\n \n-        pub fn find_builtin_macro(\n-            ident: &name::Name,\n-            krate: CrateId,\n-            ast_id: AstId<ast::MacroCall>,\n-        ) -> Option<MacroDefId> {\n-            let kind = BuiltinFnLikeExpander::by_name(ident)?;\n-\n-            Some(MacroDefId { krate: Some(krate), ast_id: Some(ast_id), kind: MacroDefKind::BuiltIn(kind) })\n+        fn find_by_name(ident: &name::Name) -> Option<Either<BuiltinFnLikeExpander, EagerExpander>> {\n+            match ident {\n+                $( id if id == &name::name![$name] => Some(Either::Left(BuiltinFnLikeExpander::$kind)), )*\n+                $( id if id == &name::name![$e_name] => Some(Either::Right(EagerExpander::$e_kind)), )*\n+                _ => return None,\n+            }\n         }\n     };\n }\n \n+pub fn find_builtin_macro(\n+    ident: &name::Name,\n+    krate: CrateId,\n+    ast_id: AstId<ast::MacroCall>,\n+) -> Option<MacroDefId> {\n+    let kind = find_by_name(ident)?;\n+\n+    match kind {\n+        Either::Left(kind) => Some(MacroDefId {\n+            krate: Some(krate),\n+            ast_id: Some(ast_id),\n+            kind: MacroDefKind::BuiltIn(kind),\n+        }),\n+        Either::Right(kind) => Some(MacroDefId {\n+            krate: Some(krate),\n+            ast_id: Some(ast_id),\n+            kind: MacroDefKind::BuiltInEager(kind),\n+        }),\n+    }\n+}\n+\n register_builtin! {\n+    LAZY:\n+\n     (column, Column) => column_expand,\n     (compile_error, CompileError) => compile_error_expand,\n     (file, File) => file_expand,\n@@ -58,12 +91,16 @@ register_builtin! {\n     (option_env, OptionEnv) => option_env_expand,\n     // format_args_nl only differs in that it adds a newline in the end,\n     // so we use the same stub expansion for now\n-    (format_args_nl, FormatArgsNl) => format_args_expand\n+    (format_args_nl, FormatArgsNl) => format_args_expand,\n+\n+    EAGER:\n+    // eagers\n+    (concat, Concat) => concat_expand\n }\n \n fn line_expand(\n     _db: &dyn AstDatabase,\n-    _id: MacroCallId,\n+    _id: LazyMacroId,\n     _tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     // dummy implementation for type-checking purposes\n@@ -77,7 +114,7 @@ fn line_expand(\n \n fn stringify_expand(\n     db: &dyn AstDatabase,\n-    id: MacroCallId,\n+    id: LazyMacroId,\n     _tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     let loc = db.lookup_intern_macro(id);\n@@ -99,7 +136,7 @@ fn stringify_expand(\n \n fn env_expand(\n     _db: &dyn AstDatabase,\n-    _id: MacroCallId,\n+    _id: LazyMacroId,\n     _tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     // dummy implementation for type-checking purposes\n@@ -110,7 +147,7 @@ fn env_expand(\n \n fn option_env_expand(\n     _db: &dyn AstDatabase,\n-    _id: MacroCallId,\n+    _id: LazyMacroId,\n     _tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     // dummy implementation for type-checking purposes\n@@ -121,7 +158,7 @@ fn option_env_expand(\n \n fn column_expand(\n     _db: &dyn AstDatabase,\n-    _id: MacroCallId,\n+    _id: LazyMacroId,\n     _tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     // dummy implementation for type-checking purposes\n@@ -135,7 +172,7 @@ fn column_expand(\n \n fn file_expand(\n     _db: &dyn AstDatabase,\n-    _id: MacroCallId,\n+    _id: LazyMacroId,\n     _tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     // FIXME: RA purposefully lacks knowledge of absolute file names\n@@ -151,7 +188,7 @@ fn file_expand(\n \n fn compile_error_expand(\n     _db: &dyn AstDatabase,\n-    _id: MacroCallId,\n+    _id: LazyMacroId,\n     tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     if tt.count() == 1 {\n@@ -168,7 +205,7 @@ fn compile_error_expand(\n \n fn format_args_expand(\n     _db: &dyn AstDatabase,\n-    _id: MacroCallId,\n+    _id: LazyMacroId,\n     tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     // We expand `format_args!(\"\", a1, a2)` to\n@@ -208,23 +245,44 @@ fn format_args_expand(\n     Ok(expanded)\n }\n \n+fn unquote_str(lit: &tt::Literal) -> Option<String> {\n+    let lit = ast::make::tokens::literal(&lit.to_string());\n+    let token = ast::String::cast(lit)?;\n+    token.value()\n+}\n+\n+fn concat_expand(tt: &tt::Subtree) -> Result<(tt::Subtree, FragmentKind), mbe::ExpandError> {\n+    let mut text = String::new();\n+    for (i, t) in tt.token_trees.iter().enumerate() {\n+        match t {\n+            tt::TokenTree::Leaf(tt::Leaf::Literal(it)) if i % 2 == 0 => {\n+                text += &unquote_str(&it).ok_or_else(|| mbe::ExpandError::ConversionError)?;\n+            }\n+            tt::TokenTree::Leaf(tt::Leaf::Punct(punct)) if i % 2 == 1 && punct.char == ',' => (),\n+            _ => return Err(mbe::ExpandError::UnexpectedToken),\n+        }\n+    }\n+\n+    Ok((quote!(#text), FragmentKind::Expr))\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::{name::AsName, test_db::TestDB, AstNode, MacroCallKind, MacroCallLoc};\n+    use crate::{name::AsName, test_db::TestDB, AstNode, MacroCallId, MacroCallKind, MacroCallLoc};\n     use ra_db::{fixture::WithFixture, SourceDatabase};\n     use ra_syntax::ast::NameOwner;\n \n-    fn expand_builtin_macro(s: &str) -> String {\n-        let (db, file_id) = TestDB::with_single_file(&s);\n+    fn expand_builtin_macro(ra_fixture: &str) -> String {\n+        let (db, file_id) = TestDB::with_single_file(&ra_fixture);\n         let parsed = db.parse(file_id);\n         let macro_calls: Vec<_> =\n             parsed.syntax_node().descendants().filter_map(ast::MacroCall::cast).collect();\n \n         let ast_id_map = db.ast_id_map(file_id.into());\n \n-        let expander =\n-            BuiltinFnLikeExpander::by_name(&macro_calls[0].name().unwrap().as_name()).unwrap();\n+        let expander = find_by_name(&macro_calls[0].name().unwrap().as_name()).unwrap();\n+        let expander = expander.left().unwrap();\n \n         // the first one should be a macro_rules\n         let def = MacroDefId {\n@@ -241,7 +299,7 @@ mod tests {\n             )),\n         };\n \n-        let id = db.intern_macro(loc);\n+        let id: MacroCallId = db.intern_macro(loc).into();\n         let parsed = db.parse_or_expand(id.as_file()).unwrap();\n \n         parsed.text().to_string()"}, {"sha": "32e0d5ced3379aa80c564f27244f5a1501ef16b8", "filename": "crates/ra_hir_expand/src/db.rs", "status": "modified", "additions": 47, "deletions": 11, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/7a322f9afff05b88507a6956a2d84a3abef0a0d6/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a322f9afff05b88507a6956a2d84a3abef0a0d6/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs?ref=7a322f9afff05b88507a6956a2d84a3abef0a0d6", "patch": "@@ -9,8 +9,9 @@ use ra_prof::profile;\n use ra_syntax::{AstNode, Parse, SyntaxKind::*, SyntaxNode};\n \n use crate::{\n-    ast_id_map::AstIdMap, BuiltinDeriveExpander, BuiltinFnLikeExpander, HirFileId, HirFileIdRepr,\n-    MacroCallId, MacroCallLoc, MacroDefId, MacroDefKind, MacroFile,\n+    ast_id_map::AstIdMap, BuiltinDeriveExpander, BuiltinFnLikeExpander, EagerCallLoc, EagerMacroId,\n+    HirFileId, HirFileIdRepr, LazyMacroId, MacroCallId, MacroCallLoc, MacroDefId, MacroDefKind,\n+    MacroFile,\n };\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n@@ -24,7 +25,7 @@ impl TokenExpander {\n     pub fn expand(\n         &self,\n         db: &dyn AstDatabase,\n-        id: MacroCallId,\n+        id: LazyMacroId,\n         tt: &tt::Subtree,\n     ) -> Result<tt::Subtree, mbe::ExpandError> {\n         match self {\n@@ -60,12 +61,15 @@ pub trait AstDatabase: SourceDatabase {\n     fn parse_or_expand(&self, file_id: HirFileId) -> Option<SyntaxNode>;\n \n     #[salsa::interned]\n-    fn intern_macro(&self, macro_call: MacroCallLoc) -> MacroCallId;\n+    fn intern_macro(&self, macro_call: MacroCallLoc) -> LazyMacroId;\n     fn macro_arg(&self, id: MacroCallId) -> Option<Arc<(tt::Subtree, mbe::TokenMap)>>;\n     fn macro_def(&self, id: MacroDefId) -> Option<Arc<(TokenExpander, mbe::TokenMap)>>;\n     fn parse_macro(&self, macro_file: MacroFile)\n         -> Option<(Parse<SyntaxNode>, Arc<mbe::TokenMap>)>;\n     fn macro_expand(&self, macro_call: MacroCallId) -> Result<Arc<tt::Subtree>, String>;\n+\n+    #[salsa::interned]\n+    fn intern_eager_expansion(&self, eager: EagerCallLoc) -> EagerMacroId;\n }\n \n pub(crate) fn ast_id_map(db: &dyn AstDatabase, file_id: HirFileId) -> Arc<AstIdMap> {\n@@ -101,13 +105,21 @@ pub(crate) fn macro_def(\n         MacroDefKind::BuiltInDerive(expander) => {\n             Some(Arc::new((TokenExpander::BuiltinDerive(expander), mbe::TokenMap::default())))\n         }\n+        MacroDefKind::BuiltInEager(_expander) => None,\n     }\n }\n \n pub(crate) fn macro_arg(\n     db: &dyn AstDatabase,\n     id: MacroCallId,\n ) -> Option<Arc<(tt::Subtree, mbe::TokenMap)>> {\n+    let id = match id {\n+        MacroCallId::LazyMacro(id) => id,\n+        MacroCallId::EagerMacro(_id) => {\n+            // FIXME: support macro_arg for eager macro\n+            return None;\n+        }\n+    };\n     let loc = db.lookup_intern_macro(id);\n     let arg = loc.kind.arg(db)?;\n     let (tt, tmap) = mbe::syntax_node_to_token_tree(&arg)?;\n@@ -118,11 +130,18 @@ pub(crate) fn macro_expand(\n     db: &dyn AstDatabase,\n     id: MacroCallId,\n ) -> Result<Arc<tt::Subtree>, String> {\n-    let loc = db.lookup_intern_macro(id);\n+    let lazy_id = match id {\n+        MacroCallId::LazyMacro(id) => id,\n+        MacroCallId::EagerMacro(id) => {\n+            return Ok(db.lookup_intern_eager_expansion(id).subtree);\n+        }\n+    };\n+\n+    let loc = db.lookup_intern_macro(lazy_id);\n     let macro_arg = db.macro_arg(id).ok_or(\"Fail to args in to tt::TokenTree\")?;\n \n     let macro_rules = db.macro_def(loc.def).ok_or(\"Fail to find macro definition\")?;\n-    let tt = macro_rules.0.expand(db, id, &macro_arg.0).map_err(|err| format!(\"{:?}\", err))?;\n+    let tt = macro_rules.0.expand(db, lazy_id, &macro_arg.0).map_err(|err| format!(\"{:?}\", err))?;\n     // Set a hard limit for the expanded tt\n     let count = tt.count();\n     if count > 65536 {\n@@ -153,9 +172,20 @@ pub(crate) fn parse_macro(\n             // Note:\n             // The final goal we would like to make all parse_macro success,\n             // such that the following log will not call anyway.\n-            let loc: MacroCallLoc = db.lookup_intern_macro(macro_call_id);\n-            let node = loc.kind.node(db);\n-            log::warn!(\"fail on macro_parse: (reason: {} macro_call: {:#})\", err, node.value);\n+            match macro_call_id {\n+                MacroCallId::LazyMacro(id) => {\n+                    let loc: MacroCallLoc = db.lookup_intern_macro(id);\n+                    let node = loc.kind.node(db);\n+                    log::warn!(\n+                        \"fail on macro_parse: (reason: {} macro_call: {:#})\",\n+                        err,\n+                        node.value\n+                    );\n+                }\n+                _ => {\n+                    log::warn!(\"fail on macro_parse: (reason: {})\", err);\n+                }\n+            }\n         })\n         .ok()?;\n \n@@ -167,8 +197,14 @@ pub(crate) fn parse_macro(\n \n /// Given a `MacroCallId`, return what `FragmentKind` it belongs to.\n /// FIXME: Not completed\n-fn to_fragment_kind(db: &dyn AstDatabase, macro_call_id: MacroCallId) -> FragmentKind {\n-    let syn = db.lookup_intern_macro(macro_call_id).kind.node(db).value;\n+fn to_fragment_kind(db: &dyn AstDatabase, id: MacroCallId) -> FragmentKind {\n+    let lazy_id = match id {\n+        MacroCallId::LazyMacro(id) => id,\n+        MacroCallId::EagerMacro(id) => {\n+            return db.lookup_intern_eager_expansion(id).fragment;\n+        }\n+    };\n+    let syn = db.lookup_intern_macro(lazy_id).kind.node(db).value;\n \n     let parent = match syn.parent() {\n         Some(it) => it,"}, {"sha": "7fcdfab5aec74a9097235ea7c93c25ce3383fa6a", "filename": "crates/ra_hir_expand/src/eager.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/7a322f9afff05b88507a6956a2d84a3abef0a0d6/crates%2Fra_hir_expand%2Fsrc%2Feager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a322f9afff05b88507a6956a2d84a3abef0a0d6/crates%2Fra_hir_expand%2Fsrc%2Feager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Feager.rs?ref=7a322f9afff05b88507a6956a2d84a3abef0a0d6", "patch": "@@ -0,0 +1,112 @@\n+//! Eager expansion related utils\n+//!\n+//! Here is a dump of a discussion from Vadim Petrochenkov about Eager Expansion and\n+//! Its name resolution :\n+//!\n+//! > Eagerly expanded macros (and also macros eagerly expanded by eagerly expanded macros,\n+//! > which actually happens in practice too!) are resolved at the location of the \"root\" macro\n+//! > that performs the eager expansion on its arguments.\n+//! > If some name cannot be resolved at the eager expansion time it's considered unresolved,\n+//! > even if becomes available later (e.g. from a glob import or other macro).\n+//!\n+//! > Eagerly expanded macros don't add anything to the module structure of the crate and\n+//! > don't build any speculative module structures, i.e. they are expanded in a \"flat\"\n+//! > way even if tokens in them look like modules.\n+//!\n+//! > In other words, it kinda works for simple cases for which it was originally intended,\n+//! > and we need to live with it because it's available on stable and widely relied upon.\n+//!\n+//!\n+//! See the full discussion : https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/Eager.20expansion.20of.20built-in.20macros\n+\n+use crate::{\n+    ast::{self, AstNode},\n+    db::AstDatabase,\n+    EagerCallLoc, EagerMacroId, InFile, MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n+};\n+\n+use ra_parser::FragmentKind;\n+use ra_syntax::{algo::replace_descendants, SyntaxElement, SyntaxNode};\n+use std::{collections::HashMap, sync::Arc};\n+\n+pub fn expand_eager_macro(\n+    db: &impl AstDatabase,\n+    macro_call: InFile<ast::MacroCall>,\n+    def: MacroDefId,\n+    resolver: &dyn Fn(ast::Path) -> Option<MacroDefId>,\n+) -> Option<EagerMacroId> {\n+    let args = macro_call.value.token_tree()?;\n+    let parsed_args = mbe::ast_to_token_tree(&args)?.0;\n+    let parsed_args = mbe::token_tree_to_syntax_node(&parsed_args, FragmentKind::Expr).ok()?.0;\n+    let result = eager_macro_recur(db, macro_call.with_value(parsed_args.syntax_node()), resolver)?;\n+\n+    let subtree = to_subtree(&result)?;\n+\n+    if let MacroDefKind::BuiltInEager(eager) = def.kind {\n+        let (subtree, fragment) = eager.expand(&subtree).ok()?;\n+        let eager =\n+            EagerCallLoc { def, fragment, subtree: Arc::new(subtree), file_id: macro_call.file_id };\n+\n+        Some(db.intern_eager_expansion(eager))\n+    } else {\n+        None\n+    }\n+}\n+\n+fn to_subtree(node: &SyntaxNode) -> Option<tt::Subtree> {\n+    let mut subtree = mbe::syntax_node_to_token_tree(node)?.0;\n+    subtree.delimiter = None;\n+    Some(subtree)\n+}\n+\n+fn lazy_expand(\n+    db: &impl AstDatabase,\n+    def: &MacroDefId,\n+    macro_call: InFile<ast::MacroCall>,\n+) -> Option<InFile<SyntaxNode>> {\n+    let ast_id = db.ast_id_map(macro_call.file_id).ast_id(&macro_call.value);\n+\n+    let id: MacroCallId =\n+        def.as_lazy_macro(db, MacroCallKind::FnLike(macro_call.with_value(ast_id))).into();\n+\n+    db.parse_or_expand(id.as_file()).map(|node| InFile::new(id.as_file(), node))\n+}\n+\n+fn eager_macro_recur(\n+    db: &impl AstDatabase,\n+    curr: InFile<SyntaxNode>,\n+    macro_resolver: &dyn Fn(ast::Path) -> Option<MacroDefId>,\n+) -> Option<SyntaxNode> {\n+    let mut original = curr.value.clone();\n+\n+    let children = curr.value.descendants().filter_map(ast::MacroCall::cast);\n+    let mut replaces: HashMap<SyntaxElement, SyntaxElement> = HashMap::default();\n+\n+    // Collect replacement\n+    for child in children {\n+        let def: MacroDefId = macro_resolver(child.path()?)?;\n+        let insert = match def.kind {\n+            MacroDefKind::BuiltInEager(_) => {\n+                let id: MacroCallId =\n+                    expand_eager_macro(db, curr.with_value(child.clone()), def, macro_resolver)?\n+                        .into();\n+                db.parse_or_expand(id.as_file())?\n+            }\n+            MacroDefKind::Declarative\n+            | MacroDefKind::BuiltIn(_)\n+            | MacroDefKind::BuiltInDerive(_) => {\n+                let expanded = lazy_expand(db, &def, curr.with_value(child.clone()))?;\n+                // replace macro inside\n+                eager_macro_recur(db, expanded, macro_resolver)?\n+            }\n+        };\n+\n+        replaces.insert(child.syntax().clone().into(), insert.into());\n+    }\n+\n+    if !replaces.is_empty() {\n+        original = replace_descendants(&original, |n| replaces.get(n).cloned());\n+    }\n+\n+    Some(original)\n+}"}, {"sha": "cb554ae4bef4df914eb6fbf454bad0e0ff16ac5f", "filename": "crates/ra_hir_expand/src/hygiene.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7a322f9afff05b88507a6956a2d84a3abef0a0d6/crates%2Fra_hir_expand%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a322f9afff05b88507a6956a2d84a3abef0a0d6/crates%2Fra_hir_expand%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fhygiene.rs?ref=7a322f9afff05b88507a6956a2d84a3abef0a0d6", "patch": "@@ -9,7 +9,7 @@ use ra_syntax::ast;\n use crate::{\n     db::AstDatabase,\n     name::{AsName, Name},\n-    HirFileId, HirFileIdRepr, MacroDefKind,\n+    HirFileId, HirFileIdRepr, MacroCallId, MacroDefKind,\n };\n \n #[derive(Debug)]\n@@ -22,14 +22,18 @@ impl Hygiene {\n     pub fn new(db: &impl AstDatabase, file_id: HirFileId) -> Hygiene {\n         let def_crate = match file_id.0 {\n             HirFileIdRepr::FileId(_) => None,\n-            HirFileIdRepr::MacroFile(macro_file) => {\n-                let loc = db.lookup_intern_macro(macro_file.macro_call_id);\n-                match loc.def.kind {\n-                    MacroDefKind::Declarative => loc.def.krate,\n-                    MacroDefKind::BuiltIn(_) => None,\n-                    MacroDefKind::BuiltInDerive(_) => None,\n+            HirFileIdRepr::MacroFile(macro_file) => match macro_file.macro_call_id {\n+                MacroCallId::LazyMacro(id) => {\n+                    let loc = db.lookup_intern_macro(id);\n+                    match loc.def.kind {\n+                        MacroDefKind::Declarative => loc.def.krate,\n+                        MacroDefKind::BuiltIn(_) => None,\n+                        MacroDefKind::BuiltInDerive(_) => None,\n+                        MacroDefKind::BuiltInEager(_) => None,\n+                    }\n                 }\n-            }\n+                MacroCallId::EagerMacro(_id) => None,\n+            },\n         };\n         Hygiene { def_crate }\n     }"}, {"sha": "3fce73e8ad3507dc0eae3e050d13dfe983b24cff", "filename": "crates/ra_hir_expand/src/lib.rs", "status": "modified", "additions": 78, "deletions": 10, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/7a322f9afff05b88507a6956a2d84a3abef0a0d6/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a322f9afff05b88507a6956a2d84a3abef0a0d6/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Flib.rs?ref=7a322f9afff05b88507a6956a2d84a3abef0a0d6", "patch": "@@ -12,6 +12,7 @@ pub mod diagnostics;\n pub mod builtin_derive;\n pub mod builtin_macro;\n pub mod quote;\n+pub mod eager;\n \n use std::hash::Hash;\n use std::sync::Arc;\n@@ -25,7 +26,7 @@ use ra_syntax::{\n \n use crate::ast_id_map::FileAstId;\n use crate::builtin_derive::BuiltinDeriveExpander;\n-use crate::builtin_macro::BuiltinFnLikeExpander;\n+use crate::builtin_macro::{BuiltinFnLikeExpander, EagerExpander};\n \n #[cfg(test)]\n mod test_db;\n@@ -70,8 +71,17 @@ impl HirFileId {\n         match self.0 {\n             HirFileIdRepr::FileId(file_id) => file_id,\n             HirFileIdRepr::MacroFile(macro_file) => {\n-                let loc = db.lookup_intern_macro(macro_file.macro_call_id);\n-                loc.kind.file_id().original_file(db)\n+                let file_id = match macro_file.macro_call_id {\n+                    MacroCallId::LazyMacro(id) => {\n+                        let loc = db.lookup_intern_macro(id);\n+                        loc.kind.file_id()\n+                    }\n+                    MacroCallId::EagerMacro(id) => {\n+                        let loc = db.lookup_intern_eager_expansion(id);\n+                        loc.file_id\n+                    }\n+                };\n+                file_id.original_file(db)\n             }\n         }\n     }\n@@ -81,7 +91,14 @@ impl HirFileId {\n         match self.0 {\n             HirFileIdRepr::FileId(_) => None,\n             HirFileIdRepr::MacroFile(macro_file) => {\n-                let loc = db.lookup_intern_macro(macro_file.macro_call_id);\n+                let lazy_id = match macro_file.macro_call_id {\n+                    MacroCallId::LazyMacro(id) => id,\n+                    MacroCallId::EagerMacro(_id) => {\n+                        // FIXME: handle call node for eager macro\n+                        return None;\n+                    }\n+                };\n+                let loc = db.lookup_intern_macro(lazy_id);\n                 Some(loc.kind.node(db))\n             }\n         }\n@@ -92,7 +109,14 @@ impl HirFileId {\n         match self.0 {\n             HirFileIdRepr::FileId(_) => None,\n             HirFileIdRepr::MacroFile(macro_file) => {\n-                let loc: MacroCallLoc = db.lookup_intern_macro(macro_file.macro_call_id);\n+                let lazy_id = match macro_file.macro_call_id {\n+                    MacroCallId::LazyMacro(id) => id,\n+                    MacroCallId::EagerMacro(_id) => {\n+                        // FIXME: handle expansion_info for eager macro\n+                        return None;\n+                    }\n+                };\n+                let loc: MacroCallLoc = db.lookup_intern_macro(lazy_id);\n \n                 let arg_tt = loc.kind.arg(db)?;\n                 let def_tt = loc.def.ast_id?.to_node(db).token_tree()?;\n@@ -118,7 +142,13 @@ impl HirFileId {\n         match self.0 {\n             HirFileIdRepr::FileId(_) => None,\n             HirFileIdRepr::MacroFile(macro_file) => {\n-                let loc: MacroCallLoc = db.lookup_intern_macro(macro_file.macro_call_id);\n+                let lazy_id = match macro_file.macro_call_id {\n+                    MacroCallId::LazyMacro(id) => id,\n+                    MacroCallId::EagerMacro(_id) => {\n+                        return None;\n+                    }\n+                };\n+                let loc: MacroCallLoc = db.lookup_intern_macro(lazy_id);\n                 let item = match loc.def.kind {\n                     MacroDefKind::BuiltInDerive(_) => loc.kind.node(db),\n                     _ => return None,\n@@ -137,16 +167,44 @@ pub struct MacroFile {\n /// `MacroCallId` identifies a particular macro invocation, like\n /// `println!(\"Hello, {}\", world)`.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct MacroCallId(salsa::InternId);\n-impl salsa::InternKey for MacroCallId {\n+pub enum MacroCallId {\n+    LazyMacro(LazyMacroId),\n+    EagerMacro(EagerMacroId),\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct LazyMacroId(salsa::InternId);\n+impl salsa::InternKey for LazyMacroId {\n+    fn from_intern_id(v: salsa::InternId) -> Self {\n+        LazyMacroId(v)\n+    }\n+    fn as_intern_id(&self) -> salsa::InternId {\n+        self.0\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct EagerMacroId(salsa::InternId);\n+impl salsa::InternKey for EagerMacroId {\n     fn from_intern_id(v: salsa::InternId) -> Self {\n-        MacroCallId(v)\n+        EagerMacroId(v)\n     }\n     fn as_intern_id(&self) -> salsa::InternId {\n         self.0\n     }\n }\n \n+impl From<LazyMacroId> for MacroCallId {\n+    fn from(it: LazyMacroId) -> Self {\n+        MacroCallId::LazyMacro(it)\n+    }\n+}\n+impl From<EagerMacroId> for MacroCallId {\n+    fn from(it: EagerMacroId) -> Self {\n+        MacroCallId::EagerMacro(it)\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct MacroDefId {\n     // FIXME: krate and ast_id are currently optional because we don't have a\n@@ -161,7 +219,7 @@ pub struct MacroDefId {\n }\n \n impl MacroDefId {\n-    pub fn as_call_id(self, db: &dyn db::AstDatabase, kind: MacroCallKind) -> MacroCallId {\n+    pub fn as_lazy_macro(self, db: &dyn db::AstDatabase, kind: MacroCallKind) -> LazyMacroId {\n         db.intern_macro(MacroCallLoc { def: self, kind })\n     }\n }\n@@ -172,6 +230,7 @@ pub enum MacroDefKind {\n     BuiltIn(BuiltinFnLikeExpander),\n     // FIXME: maybe just Builtin and rename BuiltinFnLikeExpander to BuiltinExpander\n     BuiltInDerive(BuiltinDeriveExpander),\n+    BuiltInEager(EagerExpander),\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -217,6 +276,14 @@ impl MacroCallId {\n     }\n }\n \n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct EagerCallLoc {\n+    pub(crate) def: MacroDefId,\n+    pub(crate) fragment: FragmentKind,\n+    pub(crate) subtree: Arc<tt::Subtree>,\n+    pub(crate) file_id: HirFileId,\n+}\n+\n /// ExpansionInfo mainly describes how to map text range between src and expanded macro\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct ExpansionInfo {\n@@ -230,6 +297,7 @@ pub struct ExpansionInfo {\n }\n \n pub use mbe::Origin;\n+use ra_parser::FragmentKind;\n \n impl ExpansionInfo {\n     pub fn call_node(&self) -> Option<InFile<SyntaxNode>> {"}, {"sha": "036cf7d1e047fa0833dab92e4e7944e56d95da5d", "filename": "crates/ra_hir_expand/src/name.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a322f9afff05b88507a6956a2d84a3abef0a0d6/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a322f9afff05b88507a6956a2d84a3abef0a0d6/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fname.rs?ref=7a322f9afff05b88507a6956a2d84a3abef0a0d6", "patch": "@@ -173,6 +173,7 @@ pub mod known {\n         compile_error,\n         line,\n         stringify,\n+        concat,\n         format_args,\n         format_args_nl,\n         env,"}, {"sha": "55386c03038f3785d953fab6f3e30c9aaa1e4bb9", "filename": "crates/ra_hir_ty/src/tests/macros.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7a322f9afff05b88507a6956a2d84a3abef0a0d6/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a322f9afff05b88507a6956a2d84a3abef0a0d6/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs?ref=7a322f9afff05b88507a6956a2d84a3abef0a0d6", "patch": "@@ -419,6 +419,25 @@ fn main() {\n     );\n }\n \n+#[test]\n+fn infer_builtin_macros_concat() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[rustc_builtin_macro]\n+macro_rules! concat {() => {}}\n+\n+fn main() {\n+    let x = concat!(\"hello\", concat!(\"world\", \"!\"));\n+}\n+\"#),\n+        @r###\"\n+    ![0; 13) '\"helloworld!\"': &str\n+    [66; 122) '{     ...\")); }': ()\n+    [76; 77) 'x': &str\n+    \"###\n+    );\n+}\n+\n #[test]\n fn infer_derive_clone_simple() {\n     let (db, pos) = TestDB::with_position("}, {"sha": "652492c1ed964dd0176ccf358e64d4b1d794af9d", "filename": "crates/ra_parser/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a322f9afff05b88507a6956a2d84a3abef0a0d6/crates%2Fra_parser%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a322f9afff05b88507a6956a2d84a3abef0a0d6/crates%2Fra_parser%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Flib.rs?ref=7a322f9afff05b88507a6956a2d84a3abef0a0d6", "patch": "@@ -83,7 +83,7 @@ pub fn parse(token_source: &mut dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n     parse_from_tokens(token_source, tree_sink, grammar::root);\n }\n \n-#[derive(Clone, Copy)]\n+#[derive(Debug, Clone, Copy, Eq, PartialEq, Hash)]\n pub enum FragmentKind {\n     Path,\n     Expr,"}, {"sha": "0da24560ead46fd6918dc71c0c4e6ef81c7389a5", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a322f9afff05b88507a6956a2d84a3abef0a0d6/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a322f9afff05b88507a6956a2d84a3abef0a0d6/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=7a322f9afff05b88507a6956a2d84a3abef0a0d6", "patch": "@@ -219,7 +219,7 @@ fn unroot(n: SyntaxNode) -> SyntaxNode {\n }\n \n pub mod tokens {\n-    use crate::{AstNode, Parse, SourceFile, SyntaxKind::*, SyntaxToken, T};\n+    use crate::{ast, AstNode, Parse, SourceFile, SyntaxKind::*, SyntaxToken, T};\n     use once_cell::sync::Lazy;\n \n     pub(super) static SOURCE_FILE: Lazy<Parse<SourceFile>> =\n@@ -251,6 +251,12 @@ pub mod tokens {\n         sf.syntax().first_child_or_token().unwrap().into_token().unwrap()\n     }\n \n+    pub fn literal(text: &str) -> SyntaxToken {\n+        assert_eq!(text.trim(), text);\n+        let lit: ast::Literal = super::ast_from_text(&format!(\"fn f() {{ let _ = {}; }}\", text));\n+        lit.syntax().first_child_or_token().unwrap().into_token().unwrap()\n+    }\n+\n     pub fn single_newline() -> SyntaxToken {\n         SOURCE_FILE\n             .tree()"}]}