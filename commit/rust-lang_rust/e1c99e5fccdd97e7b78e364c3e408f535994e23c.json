{"sha": "e1c99e5fccdd97e7b78e364c3e408f535994e23c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxYzk5ZTVmY2NkZDk3ZTdiNzhlMzY0YzNlNDA4ZjUzNTk5NGUyM2M=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-03-16T18:32:00Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-03-30T16:10:06Z"}, "message": "Remove the parallel version.", "tree": {"sha": "acc41de4b26ffaa9167e720b6b060316d1301c26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/acc41de4b26ffaa9167e720b6b060316d1301c26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1c99e5fccdd97e7b78e364c3e408f535994e23c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1c99e5fccdd97e7b78e364c3e408f535994e23c", "html_url": "https://github.com/rust-lang/rust/commit/e1c99e5fccdd97e7b78e364c3e408f535994e23c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1c99e5fccdd97e7b78e364c3e408f535994e23c/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8208872fa28550068e9e30075af09da1a8144fb4", "url": "https://api.github.com/repos/rust-lang/rust/commits/8208872fa28550068e9e30075af09da1a8144fb4", "html_url": "https://github.com/rust-lang/rust/commit/8208872fa28550068e9e30075af09da1a8144fb4"}], "stats": {"total": 148, "additions": 13, "deletions": 135}, "files": [{"sha": "6cb728bf0a8558a2acd4a76e64781ddc380404dc", "filename": "compiler/rustc_query_system/src/dep_graph/serialized.rs", "status": "modified", "additions": 13, "deletions": 135, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/e1c99e5fccdd97e7b78e364c3e408f535994e23c/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1c99e5fccdd97e7b78e364c3e408f535994e23c/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs?ref=e1c99e5fccdd97e7b78e364c3e408f535994e23c", "patch": "@@ -4,18 +4,13 @@ use super::query::DepGraphQuery;\n use super::{DepKind, DepNode, DepNodeIndex};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::sync::{AtomicU32, Lock, Lrc, Ordering};\n-use rustc_index::vec::IndexVec;\n+use rustc_data_structures::sync::{Lock, Lrc};\n+use rustc_index::vec::{Idx, IndexVec};\n use rustc_serialize::opaque::{self, FileEncodeResult, FileEncoder, IntEncodedWithFixedSize};\n use rustc_serialize::{Decodable, Decoder, Encodable};\n use smallvec::SmallVec;\n use std::convert::TryInto;\n \n-#[cfg(parallel_compiler)]\n-use {\n-    rustc_data_structures::sync::WorkerLocal, rustc_index::vec::Idx, std::sync::mpsc, std::thread,\n-};\n-\n // The maximum value of `SerializedDepNodeIndex` leaves the upper two bits\n // unused so that we can store multiple index types in `CompressedHybridIndex`,\n // and use those bits to encode which index type it contains.\n@@ -146,12 +141,8 @@ fn encode_node<K: DepKind>(\n ) -> FileEncodeResult {\n     #[cfg(debug_assertions)]\n     if let Some(record_graph) = &_record_graph {\n-        if let Some(record_graph) = &mut if cfg!(parallel_compiler) {\n-            Some(record_graph.lock())\n-        } else {\n-            // Do not ICE when a query is called from within `with_query`.\n-            record_graph.try_lock()\n-        } {\n+        // Do not ICE when a query is called from within `with_query`.\n+        if let Some(record_graph) = &mut record_graph.try_lock() {\n             record_graph.push(_index, node.node, &node.edges);\n         }\n     }\n@@ -190,19 +181,8 @@ fn encode_counts(\n     encoder.flush()\n }\n \n-#[cfg(not(parallel_compiler))]\n pub struct GraphEncoder<K: DepKind> {\n-    status: Lock<(FileEncoder, usize, FileEncodeResult)>,\n-    counter: AtomicU32,\n-    record_graph: Option<Lrc<Lock<DepGraphQuery<K>>>>,\n-    record_stats: Option<Lrc<Lock<Stats<K>>>>,\n-}\n-\n-#[cfg(parallel_compiler)]\n-pub struct GraphEncoder<K: DepKind> {\n-    send: WorkerLocal<mpsc::Sender<(DepNodeIndex, NodeInfo<K>)>>,\n-    thread: thread::JoinHandle<FileEncodeResult>,\n-    counter: AtomicU32,\n+    status: Lock<(FileEncoder, DepNodeIndex, usize, FileEncodeResult)>,\n     record_graph: Option<Lrc<Lock<DepGraphQuery<K>>>>,\n     record_stats: Option<Lrc<Lock<Stats<K>>>>,\n }\n@@ -228,29 +208,8 @@ impl<K: DepKind + Encodable<FileEncoder>> GraphEncoder<K> {\n         } else {\n             None\n         };\n-        let counter = AtomicU32::new(0);\n-\n-        #[cfg(not(parallel_compiler))]\n-        {\n-            let status = Lock::new((encoder, 0, Ok(())));\n-            GraphEncoder { status, counter, record_graph, record_stats }\n-        }\n-        #[cfg(parallel_compiler)]\n-        {\n-            let (send, recv) = mpsc::channel();\n-            let thread = {\n-                let record_graph = record_graph.clone();\n-                let record_stats = record_stats.clone();\n-                thread::spawn(move || {\n-                    encode_graph(encoder, recv, |encoder, index, node| {\n-                        encode_node(encoder, index, node, &record_graph, &record_stats)\n-                    })\n-                })\n-            };\n-            let send = WorkerLocal::new(move |_| send.clone());\n-\n-            GraphEncoder { send, thread, counter, record_graph, record_stats }\n-        }\n+        let status = Lock::new((encoder, DepNodeIndex::new(0), 0, Ok(())));\n+        GraphEncoder { status, record_graph, record_stats }\n     }\n \n     pub(crate) fn with_query(&self, f: impl Fn(&DepGraphQuery<K>)) {\n@@ -314,19 +273,17 @@ impl<K: DepKind + Encodable<FileEncoder>> GraphEncoder<K> {\n             eprintln!(\"[incremental]\");\n         }\n     }\n-}\n \n-#[cfg(not(parallel_compiler))]\n-impl<K: DepKind + Encodable<FileEncoder>> GraphEncoder<K> {\n     pub(crate) fn send(\n         &self,\n         node: DepNode<K>,\n         fingerprint: Fingerprint,\n         edges: SmallVec<[DepNodeIndex; 8]>,\n     ) -> DepNodeIndex {\n-        let index = self.counter.fetch_add(1, Ordering::SeqCst);\n-        let index = DepNodeIndex::from_u32(index);\n-        let &mut (ref mut encoder, ref mut edge_count, ref mut result) = &mut *self.status.lock();\n+        let &mut (ref mut encoder, ref mut next_index, ref mut edge_count, ref mut result) =\n+            &mut *self.status.lock();\n+        let index = next_index.clone();\n+        next_index.increment_by(1);\n         *edge_count += edges.len();\n         *result = std::mem::replace(result, Ok(())).and_then(|()| {\n             let node = NodeInfo { node, fingerprint, edges };\n@@ -336,89 +293,10 @@ impl<K: DepKind + Encodable<FileEncoder>> GraphEncoder<K> {\n     }\n \n     pub fn finish(self) -> FileEncodeResult {\n-        let (encoder, edge_count, result) = self.status.into_inner();\n+        let (encoder, node_count, edge_count, result) = self.status.into_inner();\n         let () = result?;\n-        let node_count = self.counter.into_inner() as usize;\n+        let node_count = node_count.index();\n \n         encode_counts(encoder, node_count, edge_count)\n     }\n }\n-\n-#[cfg(parallel_compiler)]\n-impl<K: DepKind + Encodable<FileEncoder>> GraphEncoder<K> {\n-    pub(crate) fn send(\n-        &self,\n-        node: DepNode<K>,\n-        fingerprint: Fingerprint,\n-        edges: SmallVec<[DepNodeIndex; 8]>,\n-    ) -> DepNodeIndex {\n-        let node = NodeInfo { node, fingerprint, edges };\n-        let index = self.counter.fetch_add(1, Ordering::SeqCst);\n-        let index = DepNodeIndex::from_u32(index);\n-        self.send.send((index, node)).unwrap();\n-        index\n-    }\n-\n-    pub fn finish(self) -> FileEncodeResult {\n-        std::mem::drop(self.send);\n-        self.thread.join().unwrap()\n-    }\n-}\n-\n-#[cfg(parallel_compiler)]\n-#[instrument(skip(encoder, recv, process))]\n-fn encode_graph<K: DepKind + Encodable<FileEncoder>>(\n-    mut encoder: FileEncoder,\n-    recv: mpsc::Receiver<(DepNodeIndex, NodeInfo<K>)>,\n-    process: impl Fn(&mut FileEncoder, DepNodeIndex, &NodeInfo<K>) -> FileEncodeResult,\n-) -> FileEncodeResult {\n-    let mut edge_count: usize = 0;\n-    let node_count: usize = ordered_recv(recv, |index, node| {\n-        edge_count += node.edges.len();\n-        process(&mut encoder, index, node)\n-    })?;\n-\n-    encode_counts(encoder, node_count, edge_count)\n-}\n-\n-/// Since there are multiple producers assigning the DepNodeIndex using an atomic,\n-/// the messages may not arrive in order. This function sorts them as they come.\n-#[cfg(parallel_compiler)]\n-fn ordered_recv<K: DepKind + Encodable<opaque::FileEncoder>>(\n-    recv: mpsc::Receiver<(DepNodeIndex, NodeInfo<K>)>,\n-    mut f: impl FnMut(DepNodeIndex, &NodeInfo<K>) -> FileEncodeResult,\n-) -> Result<usize, std::io::Error> {\n-    let mut pending = Vec::<(DepNodeIndex, _)>::new();\n-    let mut expected = DepNodeIndex::new(0);\n-\n-    // INVARIANT: No message can arrive with an index less than `expected`.\n-    'outer: loop {\n-        pending.sort_by_key(|n| n.0);\n-        for (index, node) in pending.drain_filter(|(index, _)| {\n-            if *index == expected {\n-                expected.increment_by(1);\n-                true\n-            } else {\n-                false\n-            }\n-        }) {\n-            f(index, &node)?;\n-        }\n-\n-        while let Ok((index, node)) = recv.recv() {\n-            if index > expected {\n-                pending.push((index, node));\n-            } else if index == expected {\n-                f(index, &node)?;\n-                expected.increment_by(1);\n-                continue 'outer;\n-            } else {\n-                panic!(\"Unexpected index {:?} while waiting for {:?}\", index, expected);\n-            }\n-        }\n-\n-        break;\n-    }\n-\n-    Ok(expected.as_u32() as usize)\n-}"}]}