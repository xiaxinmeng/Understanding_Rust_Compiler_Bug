{"sha": "93613901d004ccf0b8a240bf328559a4128ac3b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzNjEzOTAxZDAwNGNjZjBiOGEyNDBiZjMyODU1OWE0MTI4YWMzYjI=", "commit": {"author": {"name": "C", "email": "DeveloperC@protonmail.com", "date": "2020-12-05T00:45:20Z"}, "committer": {"name": "C", "email": "DeveloperC@protonmail.com", "date": "2020-12-29T14:03:29Z"}, "message": "refactor: moved IntoIter into into_iter.rs", "tree": {"sha": "5864709a9719c853dac4a82499a5337387325161", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5864709a9719c853dac4a82499a5337387325161"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93613901d004ccf0b8a240bf328559a4128ac3b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93613901d004ccf0b8a240bf328559a4128ac3b2", "html_url": "https://github.com/rust-lang/rust/commit/93613901d004ccf0b8a240bf328559a4128ac3b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93613901d004ccf0b8a240bf328559a4128ac3b2/comments", "author": {"login": "DeveloperC286", "id": 65925405, "node_id": "MDQ6VXNlcjY1OTI1NDA1", "avatar_url": "https://avatars.githubusercontent.com/u/65925405?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DeveloperC286", "html_url": "https://github.com/DeveloperC286", "followers_url": "https://api.github.com/users/DeveloperC286/followers", "following_url": "https://api.github.com/users/DeveloperC286/following{/other_user}", "gists_url": "https://api.github.com/users/DeveloperC286/gists{/gist_id}", "starred_url": "https://api.github.com/users/DeveloperC286/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DeveloperC286/subscriptions", "organizations_url": "https://api.github.com/users/DeveloperC286/orgs", "repos_url": "https://api.github.com/users/DeveloperC286/repos", "events_url": "https://api.github.com/users/DeveloperC286/events{/privacy}", "received_events_url": "https://api.github.com/users/DeveloperC286/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DeveloperC286", "id": 65925405, "node_id": "MDQ6VXNlcjY1OTI1NDA1", "avatar_url": "https://avatars.githubusercontent.com/u/65925405?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DeveloperC286", "html_url": "https://github.com/DeveloperC286", "followers_url": "https://api.github.com/users/DeveloperC286/followers", "following_url": "https://api.github.com/users/DeveloperC286/following{/other_user}", "gists_url": "https://api.github.com/users/DeveloperC286/gists{/gist_id}", "starred_url": "https://api.github.com/users/DeveloperC286/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DeveloperC286/subscriptions", "organizations_url": "https://api.github.com/users/DeveloperC286/orgs", "repos_url": "https://api.github.com/users/DeveloperC286/repos", "events_url": "https://api.github.com/users/DeveloperC286/events{/privacy}", "received_events_url": "https://api.github.com/users/DeveloperC286/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2580822b919257c8b7c81d3343c43733c216e26c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2580822b919257c8b7c81d3343c43733c216e26c", "html_url": "https://github.com/rust-lang/rust/commit/2580822b919257c8b7c81d3343c43733c216e26c"}], "stats": {"total": 540, "additions": 276, "deletions": 264}, "files": [{"sha": "623792a631612a384d3d6fbd319ab19b8a7e8d47", "filename": "library/alloc/src/vec/into_iter.rs", "status": "added", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/93613901d004ccf0b8a240bf328559a4128ac3b2/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93613901d004ccf0b8a240bf328559a4128ac3b2/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs?ref=93613901d004ccf0b8a240bf328559a4128ac3b2", "patch": "@@ -0,0 +1,270 @@\n+use crate::alloc::{Allocator, Global};\n+use crate::raw_vec::RawVec;\n+use core::marker::PhantomData;\n+use core::intrinsics::{arith_offset};\n+use core::mem::{self};\n+use core::fmt;\n+use core::ptr::{self, NonNull};\n+use core::slice::{self};\n+use core::iter::{\n+    FusedIterator, InPlaceIterable, SourceIter, TrustedLen, TrustedRandomAccess,\n+};\n+\n+/// An iterator that moves out of a vector.\n+///\n+/// This `struct` is created by the `into_iter` method on [`Vec`] (provided\n+/// by the [`IntoIterator`] trait).\n+///\n+/// # Example\n+///\n+/// ```\n+/// let v = vec![0, 1, 2];\n+/// let iter: std::vec::IntoIter<_> = v.into_iter();\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct IntoIter<\n+    T,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+> {\n+    pub(super) buf: NonNull<T>,\n+    pub(super) phantom: PhantomData<T>,\n+    pub(super) cap: usize,\n+    pub(super) alloc: A,\n+    pub(super) ptr: *const T,\n+    pub(super) end: *const T,\n+}\n+\n+#[stable(feature = \"vec_intoiter_debug\", since = \"1.13.0\")]\n+impl<T: fmt::Debug, A: Allocator> fmt::Debug for IntoIter<T, A> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"IntoIter\").field(&self.as_slice()).finish()\n+    }\n+}\n+\n+impl<T, A: Allocator> IntoIter<T, A> {\n+    /// Returns the remaining items of this iterator as a slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let vec = vec!['a', 'b', 'c'];\n+    /// let mut into_iter = vec.into_iter();\n+    /// assert_eq!(into_iter.as_slice(), &['a', 'b', 'c']);\n+    /// let _ = into_iter.next().unwrap();\n+    /// assert_eq!(into_iter.as_slice(), &['b', 'c']);\n+    /// ```\n+    #[stable(feature = \"vec_into_iter_as_slice\", since = \"1.15.0\")]\n+    pub fn as_slice(&self) -> &[T] {\n+        unsafe { slice::from_raw_parts(self.ptr, self.len()) }\n+    }\n+\n+    /// Returns the remaining items of this iterator as a mutable slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let vec = vec!['a', 'b', 'c'];\n+    /// let mut into_iter = vec.into_iter();\n+    /// assert_eq!(into_iter.as_slice(), &['a', 'b', 'c']);\n+    /// into_iter.as_mut_slice()[2] = 'z';\n+    /// assert_eq!(into_iter.next().unwrap(), 'a');\n+    /// assert_eq!(into_iter.next().unwrap(), 'b');\n+    /// assert_eq!(into_iter.next().unwrap(), 'z');\n+    /// ```\n+    #[stable(feature = \"vec_into_iter_as_slice\", since = \"1.15.0\")]\n+    pub fn as_mut_slice(&mut self) -> &mut [T] {\n+        unsafe { &mut *self.as_raw_mut_slice() }\n+    }\n+\n+    /// Returns a reference to the underlying allocator.\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[inline]\n+    pub fn allocator(&self) -> &A {\n+        &self.alloc\n+    }\n+\n+    fn as_raw_mut_slice(&mut self) -> *mut [T] {\n+        ptr::slice_from_raw_parts_mut(self.ptr as *mut T, self.len())\n+    }\n+\n+    pub(super) fn drop_remaining(&mut self) {\n+        unsafe {\n+            ptr::drop_in_place(self.as_mut_slice());\n+        }\n+        self.ptr = self.end;\n+    }\n+\n+    /// Relinquishes the backing allocation, equivalent to\n+    /// `ptr::write(&mut self, Vec::new().into_iter())`\n+    pub(super) fn forget_allocation(&mut self) {\n+        self.cap = 0;\n+        self.buf = unsafe { NonNull::new_unchecked(RawVec::NEW.ptr()) };\n+        self.ptr = self.buf.as_ptr();\n+        self.end = self.buf.as_ptr();\n+    }\n+}\n+\n+#[stable(feature = \"vec_intoiter_as_ref\", since = \"1.46.0\")]\n+impl<T, A: Allocator> AsRef<[T]> for IntoIter<T, A> {\n+    fn as_ref(&self) -> &[T] {\n+        self.as_slice()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<T: Send, A: Allocator + Send> Send for IntoIter<T, A> {}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<T: Sync, A: Allocator> Sync for IntoIter<T, A> {}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n+    type Item = T;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<T> {\n+        if self.ptr as *const _ == self.end {\n+            None\n+        } else if mem::size_of::<T>() == 0 {\n+            // purposefully don't use 'ptr.offset' because for\n+            // vectors with 0-size elements this would return the\n+            // same pointer.\n+            self.ptr = unsafe { arith_offset(self.ptr as *const i8, 1) as *mut T };\n+\n+            // Make up a value of this ZST.\n+            Some(unsafe { mem::zeroed() })\n+        } else {\n+            let old = self.ptr;\n+            self.ptr = unsafe { self.ptr.offset(1) };\n+\n+            Some(unsafe { ptr::read(old) })\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let exact = if mem::size_of::<T>() == 0 {\n+            (self.end as usize).wrapping_sub(self.ptr as usize)\n+        } else {\n+            unsafe { self.end.offset_from(self.ptr) as usize }\n+        };\n+        (exact, Some(exact))\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.len()\n+    }\n+\n+    unsafe fn __iterator_get_unchecked(&mut self, i: usize) -> Self::Item\n+        where\n+            Self: TrustedRandomAccess,\n+    {\n+        // SAFETY: the caller must guarantee that `i` is in bounds of the\n+        // `Vec<T>`, so `i` cannot overflow an `isize`, and the `self.ptr.add(i)`\n+        // is guaranteed to pointer to an element of the `Vec<T>` and\n+        // thus guaranteed to be valid to dereference.\n+        //\n+        // Also note the implementation of `Self: TrustedRandomAccess` requires\n+        // that `T: Copy` so reading elements from the buffer doesn't invalidate\n+        // them for `Drop`.\n+        unsafe {\n+            if mem::size_of::<T>() == 0 { mem::zeroed() } else { ptr::read(self.ptr.add(i)) }\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T, A: Allocator> DoubleEndedIterator for IntoIter<T, A> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<T> {\n+        if self.end == self.ptr {\n+            None\n+        } else if mem::size_of::<T>() == 0 {\n+            // See above for why 'ptr.offset' isn't used\n+            self.end = unsafe { arith_offset(self.end as *const i8, -1) as *mut T };\n+\n+            // Make up a value of this ZST.\n+            Some(unsafe { mem::zeroed() })\n+        } else {\n+            self.end = unsafe { self.end.offset(-1) };\n+\n+            Some(unsafe { ptr::read(self.end) })\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T, A: Allocator> ExactSizeIterator for IntoIter<T, A> {\n+    fn is_empty(&self) -> bool {\n+        self.ptr == self.end\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<T, A: Allocator> FusedIterator for IntoIter<T, A> {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T, A: Allocator> TrustedLen for IntoIter<T, A> {}\n+\n+#[doc(hidden)]\n+#[unstable(issue = \"none\", feature = \"std_internals\")]\n+// T: Copy as approximation for !Drop since get_unchecked does not advance self.ptr\n+// and thus we can't implement drop-handling\n+unsafe impl<T, A: Allocator> TrustedRandomAccess for IntoIter<T, A>\n+    where\n+        T: Copy,\n+{\n+    fn may_have_side_effect() -> bool {\n+        false\n+    }\n+}\n+\n+#[stable(feature = \"vec_into_iter_clone\", since = \"1.8.0\")]\n+impl<T: Clone, A: Allocator + Clone> Clone for IntoIter<T, A> {\n+    #[cfg(not(test))]\n+    fn clone(&self) -> Self {\n+        self.as_slice().to_vec_in(self.alloc.clone()).into_iter()\n+    }\n+    #[cfg(test)]\n+    fn clone(&self) -> Self {\n+        crate::slice::to_vec(self.as_slice(), self.alloc.clone()).into_iter()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<#[may_dangle] T, A: Allocator> Drop for IntoIter<T, A> {\n+    fn drop(&mut self) {\n+        struct DropGuard<'a, T, A: Allocator>(&'a mut IntoIter<T, A>);\n+\n+        impl<T, A: Allocator> Drop for DropGuard<'_, T, A> {\n+            fn drop(&mut self) {\n+                unsafe {\n+                    // `IntoIter::alloc` is not used anymore after this\n+                    let alloc = ptr::read(&self.0.alloc);\n+                    // RawVec handles deallocation\n+                    let _ = RawVec::from_raw_parts_in(self.0.buf.as_ptr(), self.0.cap, alloc);\n+                }\n+            }\n+        }\n+\n+        let guard = DropGuard(self);\n+        // destroy the remaining elements\n+        unsafe {\n+            ptr::drop_in_place(guard.0.as_raw_mut_slice());\n+        }\n+        // now `guard` will be dropped and do the rest\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<T, A: Allocator> InPlaceIterable for IntoIter<T, A> {}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<T, A: Allocator> SourceIter for IntoIter<T, A> {\n+    type Source = Self;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut Self::Source {\n+        self\n+    }\n+}"}, {"sha": "b6508bfea08186e449b021a4a83a59e18c40f2a5", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 6, "deletions": 264, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/93613901d004ccf0b8a240bf328559a4128ac3b2/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93613901d004ccf0b8a240bf328559a4128ac3b2/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=93613901d004ccf0b8a240bf328559a4128ac3b2", "patch": "@@ -60,7 +60,7 @@ use core::fmt;\n use core::hash::{Hash, Hasher};\n use core::intrinsics::{arith_offset, assume};\n use core::iter::{\n-    FromIterator, FusedIterator, InPlaceIterable, SourceIter, TrustedLen, TrustedRandomAccess,\n+    FromIterator, InPlaceIterable, SourceIter, TrustedLen,\n };\n use core::marker::PhantomData;\n use core::mem::{self, ManuallyDrop, MaybeUninit};\n@@ -91,6 +91,11 @@ mod drain;\n \n mod cow;\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::into_iter::IntoIter;\n+\n+mod into_iter;\n+\n /// A contiguous growable array type, written `Vec<T>` but pronounced 'vector'.\n ///\n /// # Examples\n@@ -3015,269 +3020,6 @@ impl<T, A: Allocator, const N: usize> TryFrom<Vec<T, A>> for [T; N] {\n     }\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n-// Iterators\n-////////////////////////////////////////////////////////////////////////////////\n-\n-/// An iterator that moves out of a vector.\n-///\n-/// This `struct` is created by the `into_iter` method on [`Vec`] (provided\n-/// by the [`IntoIterator`] trait).\n-///\n-/// # Example\n-///\n-/// ```\n-/// let v = vec![0, 1, 2];\n-/// let iter: std::vec::IntoIter<_> = v.into_iter();\n-/// ```\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct IntoIter<\n-    T,\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n-> {\n-    buf: NonNull<T>,\n-    phantom: PhantomData<T>,\n-    cap: usize,\n-    alloc: A,\n-    ptr: *const T,\n-    end: *const T,\n-}\n-\n-#[stable(feature = \"vec_intoiter_debug\", since = \"1.13.0\")]\n-impl<T: fmt::Debug, A: Allocator> fmt::Debug for IntoIter<T, A> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"IntoIter\").field(&self.as_slice()).finish()\n-    }\n-}\n-\n-impl<T, A: Allocator> IntoIter<T, A> {\n-    /// Returns the remaining items of this iterator as a slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let vec = vec!['a', 'b', 'c'];\n-    /// let mut into_iter = vec.into_iter();\n-    /// assert_eq!(into_iter.as_slice(), &['a', 'b', 'c']);\n-    /// let _ = into_iter.next().unwrap();\n-    /// assert_eq!(into_iter.as_slice(), &['b', 'c']);\n-    /// ```\n-    #[stable(feature = \"vec_into_iter_as_slice\", since = \"1.15.0\")]\n-    pub fn as_slice(&self) -> &[T] {\n-        unsafe { slice::from_raw_parts(self.ptr, self.len()) }\n-    }\n-\n-    /// Returns the remaining items of this iterator as a mutable slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let vec = vec!['a', 'b', 'c'];\n-    /// let mut into_iter = vec.into_iter();\n-    /// assert_eq!(into_iter.as_slice(), &['a', 'b', 'c']);\n-    /// into_iter.as_mut_slice()[2] = 'z';\n-    /// assert_eq!(into_iter.next().unwrap(), 'a');\n-    /// assert_eq!(into_iter.next().unwrap(), 'b');\n-    /// assert_eq!(into_iter.next().unwrap(), 'z');\n-    /// ```\n-    #[stable(feature = \"vec_into_iter_as_slice\", since = \"1.15.0\")]\n-    pub fn as_mut_slice(&mut self) -> &mut [T] {\n-        unsafe { &mut *self.as_raw_mut_slice() }\n-    }\n-\n-    /// Returns a reference to the underlying allocator.\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    #[inline]\n-    pub fn allocator(&self) -> &A {\n-        &self.alloc\n-    }\n-\n-    fn as_raw_mut_slice(&mut self) -> *mut [T] {\n-        ptr::slice_from_raw_parts_mut(self.ptr as *mut T, self.len())\n-    }\n-\n-    fn drop_remaining(&mut self) {\n-        unsafe {\n-            ptr::drop_in_place(self.as_mut_slice());\n-        }\n-        self.ptr = self.end;\n-    }\n-\n-    /// Relinquishes the backing allocation, equivalent to\n-    /// `ptr::write(&mut self, Vec::new().into_iter())`\n-    fn forget_allocation(&mut self) {\n-        self.cap = 0;\n-        self.buf = unsafe { NonNull::new_unchecked(RawVec::NEW.ptr()) };\n-        self.ptr = self.buf.as_ptr();\n-        self.end = self.buf.as_ptr();\n-    }\n-}\n-\n-#[stable(feature = \"vec_intoiter_as_ref\", since = \"1.46.0\")]\n-impl<T, A: Allocator> AsRef<[T]> for IntoIter<T, A> {\n-    fn as_ref(&self) -> &[T] {\n-        self.as_slice()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Send, A: Allocator + Send> Send for IntoIter<T, A> {}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Sync, A: Allocator> Sync for IntoIter<T, A> {}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n-    type Item = T;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<T> {\n-        if self.ptr as *const _ == self.end {\n-            None\n-        } else if mem::size_of::<T>() == 0 {\n-            // purposefully don't use 'ptr.offset' because for\n-            // vectors with 0-size elements this would return the\n-            // same pointer.\n-            self.ptr = unsafe { arith_offset(self.ptr as *const i8, 1) as *mut T };\n-\n-            // Make up a value of this ZST.\n-            Some(unsafe { mem::zeroed() })\n-        } else {\n-            let old = self.ptr;\n-            self.ptr = unsafe { self.ptr.offset(1) };\n-\n-            Some(unsafe { ptr::read(old) })\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let exact = if mem::size_of::<T>() == 0 {\n-            (self.end as usize).wrapping_sub(self.ptr as usize)\n-        } else {\n-            unsafe { self.end.offset_from(self.ptr) as usize }\n-        };\n-        (exact, Some(exact))\n-    }\n-\n-    #[inline]\n-    fn count(self) -> usize {\n-        self.len()\n-    }\n-\n-    unsafe fn __iterator_get_unchecked(&mut self, i: usize) -> Self::Item\n-    where\n-        Self: TrustedRandomAccess,\n-    {\n-        // SAFETY: the caller must guarantee that `i` is in bounds of the\n-        // `Vec<T>`, so `i` cannot overflow an `isize`, and the `self.ptr.add(i)`\n-        // is guaranteed to pointer to an element of the `Vec<T>` and\n-        // thus guaranteed to be valid to dereference.\n-        //\n-        // Also note the implementation of `Self: TrustedRandomAccess` requires\n-        // that `T: Copy` so reading elements from the buffer doesn't invalidate\n-        // them for `Drop`.\n-        unsafe {\n-            if mem::size_of::<T>() == 0 { mem::zeroed() } else { ptr::read(self.ptr.add(i)) }\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, A: Allocator> DoubleEndedIterator for IntoIter<T, A> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<T> {\n-        if self.end == self.ptr {\n-            None\n-        } else if mem::size_of::<T>() == 0 {\n-            // See above for why 'ptr.offset' isn't used\n-            self.end = unsafe { arith_offset(self.end as *const i8, -1) as *mut T };\n-\n-            // Make up a value of this ZST.\n-            Some(unsafe { mem::zeroed() })\n-        } else {\n-            self.end = unsafe { self.end.offset(-1) };\n-\n-            Some(unsafe { ptr::read(self.end) })\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, A: Allocator> ExactSizeIterator for IntoIter<T, A> {\n-    fn is_empty(&self) -> bool {\n-        self.ptr == self.end\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T, A: Allocator> FusedIterator for IntoIter<T, A> {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<T, A: Allocator> TrustedLen for IntoIter<T, A> {}\n-\n-#[doc(hidden)]\n-#[unstable(issue = \"none\", feature = \"std_internals\")]\n-// T: Copy as approximation for !Drop since get_unchecked does not advance self.ptr\n-// and thus we can't implement drop-handling\n-unsafe impl<T, A: Allocator> TrustedRandomAccess for IntoIter<T, A>\n-where\n-    T: Copy,\n-{\n-    fn may_have_side_effect() -> bool {\n-        false\n-    }\n-}\n-\n-#[stable(feature = \"vec_into_iter_clone\", since = \"1.8.0\")]\n-impl<T: Clone, A: Allocator + Clone> Clone for IntoIter<T, A> {\n-    #[cfg(not(test))]\n-    fn clone(&self) -> Self {\n-        self.as_slice().to_vec_in(self.alloc.clone()).into_iter()\n-    }\n-    #[cfg(test)]\n-    fn clone(&self) -> Self {\n-        crate::slice::to_vec(self.as_slice(), self.alloc.clone()).into_iter()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<#[may_dangle] T, A: Allocator> Drop for IntoIter<T, A> {\n-    fn drop(&mut self) {\n-        struct DropGuard<'a, T, A: Allocator>(&'a mut IntoIter<T, A>);\n-\n-        impl<T, A: Allocator> Drop for DropGuard<'_, T, A> {\n-            fn drop(&mut self) {\n-                unsafe {\n-                    // `IntoIter::alloc` is not used anymore after this\n-                    let alloc = ptr::read(&self.0.alloc);\n-                    // RawVec handles deallocation\n-                    let _ = RawVec::from_raw_parts_in(self.0.buf.as_ptr(), self.0.cap, alloc);\n-                }\n-            }\n-        }\n-\n-        let guard = DropGuard(self);\n-        // destroy the remaining elements\n-        unsafe {\n-            ptr::drop_in_place(guard.0.as_raw_mut_slice());\n-        }\n-        // now `guard` will be dropped and do the rest\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<T, A: Allocator> InPlaceIterable for IntoIter<T, A> {}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<T, A: Allocator> SourceIter for IntoIter<T, A> {\n-    type Source = Self;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut Self::Source {\n-        self\n-    }\n-}\n-\n // internal helper trait for in-place iteration specialization.\n #[rustc_specialization_trait]\n pub(crate) trait AsIntoIter {"}]}