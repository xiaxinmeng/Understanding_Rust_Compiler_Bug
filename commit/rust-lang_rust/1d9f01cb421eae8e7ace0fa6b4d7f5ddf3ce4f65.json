{"sha": "1d9f01cb421eae8e7ace0fa6b4d7f5ddf3ce4f65", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkOWYwMWNiNDIxZWFlOGU3YWNlMGZhNmI0ZDdmNWRkZjNjZTRmNjU=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-07-28T00:42:32Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-07-28T00:42:42Z"}, "message": "Comments in the new macro system, reflecting conversation with pauls.", "tree": {"sha": "973488d3c58ff4205756e3fc9d14e18d2f5c13ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/973488d3c58ff4205756e3fc9d14e18d2f5c13ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d9f01cb421eae8e7ace0fa6b4d7f5ddf3ce4f65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d9f01cb421eae8e7ace0fa6b4d7f5ddf3ce4f65", "html_url": "https://github.com/rust-lang/rust/commit/1d9f01cb421eae8e7ace0fa6b4d7f5ddf3ce4f65", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d9f01cb421eae8e7ace0fa6b4d7f5ddf3ce4f65/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7382c454fb92f6c28ac6198821304c0ae2a080a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7382c454fb92f6c28ac6198821304c0ae2a080a", "html_url": "https://github.com/rust-lang/rust/commit/f7382c454fb92f6c28ac6198821304c0ae2a080a"}], "stats": {"total": 131, "additions": 125, "deletions": 6}, "files": [{"sha": "23aaab479502e1ba4d1ed3932712743eba001d81", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 46, "deletions": 4, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1d9f01cb421eae8e7ace0fa6b4d7f5ddf3ce4f65/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d9f01cb421eae8e7ace0fa6b4d7f5ddf3ce4f65/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=1d9f01cb421eae8e7ace0fa6b4d7f5ddf3ce4f65", "patch": "@@ -376,6 +376,47 @@ enum token_tree {\n type matcher = spanned<matcher_>;\n \n #[auto_serialize]\n+//\n+// Matchers are nodes defined-by and recognized-by the main rust parser and\n+// language, but they're only ever found inside syntax-extension invocations.\n+// They represent a small sub-language for pattern-matching token-trees, and\n+// are thus primarily used by the macro-defining extension itself.\n+//\n+// mtc_tok   ===>   A matcher that matches a single token,\n+//                  denoted by the token itself. So long as\n+//                  there's no $ involved.\n+//\n+//\n+// mtc_rep   ===>   A matcher that matches a sequence of\n+//                  sub-matchers, denoted various ways:\n+//\n+//             $(M)*       zero or more Ms\n+//             $(M)+       one or more Ms\n+//             $(M),+      one or more comma-separated Ms\n+//             $(A B C);*  zero or more semi-separated 'A B C' seqs\n+//\n+//\n+// mtc_bb ===> A matcher that matches one of a few interesting named rust\n+//             nonterminals, such as types, expressions, items, or raw\n+//             token-trees. A black-box matcher on expr, for example, binds an\n+//             expr to a given ident, and that ident can re-occur as an\n+//             interpolation in the RHS of a macro-by-example rule. For\n+//             example:\n+//\n+//        $foo:expr   =>     1 + $foo    // interpolate an expr\n+//        $foo:tt     =>     $foo        // interpolate a token-tree\n+//        $foo:tt     =>     bar! $foo   // only other valid interpolation\n+//                                       // is in arg position for another macro\n+//\n+// As a final, horrifying aside, note that macro-by-example's input is\n+// also matched by one of these matchers. Holy self-referential! It is matched\n+// by an mtc_rep, specifically this one:\n+//\n+//                   $( $lhs:mtcs => $rhs:tt );+\n+//\n+// If you understand that, you have closed to loop and understand the whole\n+// macro system. Congratulations.\n+//\n enum matcher_ {\n     /* match one token */\n     mtc_tok(token::token),\n@@ -401,10 +442,11 @@ type mac_body = option<mac_body_>;\n #[auto_serialize]\n enum mac_ {\n     mac_invoc(@path, mac_arg, mac_body),\n-    mac_invoc_tt(@path,~[token_tree]),//will kill mac_invoc and steal its name\n-    mac_embed_type(@ty),\n-    mac_embed_block(blk),\n-    mac_ellipsis,\n+    mac_invoc_tt(@path,~[token_tree]), // will kill mac_invoc and steal its name\n+    mac_embed_type(@ty),  // obsolete quoter\n+    mac_embed_block(blk), // obsolete quoter\n+    mac_ellipsis,         // obsolete pattern-match terminal\n+\n     // the span is used by the quoter/anti-quoter ...\n     mac_aq(span /* span of quote */, @expr), // anti-quote\n     mac_var(uint)"}, {"sha": "5fca084b18133e167ff6007af1adcd309b678f46", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1d9f01cb421eae8e7ace0fa6b4d7f5ddf3ce4f65/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d9f01cb421eae8e7ace0fa6b4d7f5ddf3ce4f65/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=1d9f01cb421eae8e7ace0fa6b4d7f5ddf3ce4f65", "patch": "@@ -4,15 +4,43 @@ import diagnostic::span_handler;\n import codemap::{codemap, span, expn_info, expanded_from};\n import std::map::str_hash;\n \n+\n+// Nomenclature / abbreviations in the ext modules:\n+//\n+//     ms: matcher span, wraps a matcher with fake span\n+//    mtc: matcher\n+//   mtcs: matchers\n+//     tt: token tree\n+//     bt: backtrace\n+//     cx: expansion context\n+//     mr: macro result\n+//\n+\n+// obsolete old-style #macro code:\n+//\n+//    syntax_expander, normal, macro_defining, macro_definer,\n+//    builtin\n+//\n+// new-style macro! tt code:\n+//\n+//    syntax_expander_tt, syntax_expander_tt_item, mac_result,\n+//    expr_tt, item_tt\n+//\n+// also note that ast::mac has way too many cases and can probably\n+// be trimmed down substantially.\n+\n // second argument is the span to blame for general argument problems\n type syntax_expander_ =\n     fn@(ext_ctxt, span, ast::mac_arg, ast::mac_body) -> @ast::expr;\n // second argument is the origin of the macro, if user-defined\n type syntax_expander = {expander: syntax_expander_, span: option<span>};\n \n type macro_def = {ident: ast::ident, ext: syntax_extension};\n+\n+// macro_definer is obsolete, remove when #old_macros go away.\n type macro_definer =\n     fn@(ext_ctxt, span, ast::mac_arg, ast::mac_body) -> macro_def;\n+\n type item_decorator =\n     fn@(ext_ctxt, span, ast::meta_item, ~[@ast::item]) -> ~[@ast::item];\n \n@@ -32,10 +60,17 @@ enum mac_result {\n }\n \n enum syntax_extension {\n+\n+    // normal() is obsolete, remove when #old_macros go away.\n     normal(syntax_expander),\n+\n+    // macro_defining() is obsolete, remove when #old_macros go away.\n     macro_defining(macro_definer),\n+\n+    // #[auto_serialize] and such. will probably survive death of #old_macros\n     item_decorator(item_decorator),\n \n+    // Token-tree expanders\n     expr_tt(syntax_expander_tt),\n     item_tt(syntax_expander_tt_item),\n }\n@@ -87,6 +122,10 @@ fn syntax_expander_table() -> hashmap<~str, syntax_extension> {\n     ret syntax_expanders;\n }\n \n+\n+// One of these is made during expansion and incrementally updated as we go;\n+// when a macro expansion occurs, the resulting nodes have the backtrace()\n+// -> expn_info of their expansion context stored into their span.\n iface ext_ctxt {\n     fn codemap() -> codemap;\n     fn parse_sess() -> parse::parse_sess;\n@@ -244,6 +283,9 @@ fn get_mac_body(cx: ext_ctxt, sp: span, args: ast::mac_body)\n     }\n }\n \n+// Massage syntactic form of new-style arguments to internal representation\n+// of old-style macro args, such that old-style macro can be run and invoked\n+// using new syntax. This will be obsolete when #old_macros go away.\n fn tt_args_to_original_flavor(cx: ext_ctxt, sp: span, arg: ~[ast::token_tree])\n     -> ast::mac_arg {\n     import ast::{matcher, matcher_, mtc_tok, mtc_rep, mtc_bb};"}, {"sha": "e453a0f556f2fe8204d06cb2d4198115dce435de", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1d9f01cb421eae8e7ace0fa6b4d7f5ddf3ce4f65/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d9f01cb421eae8e7ace0fa6b4d7f5ddf3ce4f65/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=1d9f01cb421eae8e7ace0fa6b4d7f5ddf3ce4f65", "patch": "@@ -16,7 +16,12 @@ fn expand_expr(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n     -> (expr_, span)\n {\n     ret alt e {\n+      // expr_mac should really be expr_ext or something; it's the\n+      // entry-point for all syntax extensions.\n           expr_mac(mac) {\n+\n+            // Old-style macros, for compatibility, will erase this whole\n+            // block once we've transitioned.\n             alt mac.node {\n               mac_invoc(pth, args, body) {\n                 assert (vec::len(pth.idents) > 0u);\n@@ -58,6 +63,9 @@ fn expand_expr(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n                   }\n                 }\n               }\n+\n+              // Token-tree macros, these will be the only case when we're\n+              // finished transitioning.\n               mac_invoc_tt(pth, tts) {\n                 assert (vec::len(pth.idents) == 1u);\n                 let extname = pth.idents[0];\n@@ -111,6 +119,15 @@ fn expand_expr(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n         };\n }\n \n+// This is a secondary mechanism for invoking syntax extensions on items:\n+// \"decorator\" attributes, such as #[auto_serialize]. These are invoked by an\n+// attribute prefixing an item, and are interpreted by feeding the item\n+// through the named attribute _as a syntax extension_ and splicing in the\n+// resulting item vec into place in favour of the decorator. Note that\n+// these do _not_ work for macro extensions, just item_decorator ones.\n+//\n+// NB: there is some redundancy between this and expand_item, below, and\n+// they might benefit from some amount of semantic and language-UI merger.\n fn expand_mod_items(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n                     module: ast::_mod, fld: ast_fold,\n                     orig: fn@(ast::_mod, ast_fold) -> ast::_mod)\n@@ -145,7 +162,8 @@ fn expand_mod_items(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n     ret {items: new_items with module};\n }\n \n-/* record module we enter for `#mod` */\n+// Support for item-position macro invocations, exactly the same\n+// logic as for expression-position macro invocations.\n fn expand_item(exts: hashmap<~str, syntax_extension>,\n                cx: ext_ctxt, &&it: @ast::item, fld: ast_fold,\n                orig: fn@(&&@ast::item, ast_fold) -> option<@ast::item>)"}, {"sha": "be331a08fcfee0d68875686c853c4c04e7d40bc6", "filename": "src/libsyntax/ext/tt/earley_parser.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1d9f01cb421eae8e7ace0fa6b4d7f5ddf3ce4f65/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d9f01cb421eae8e7ace0fa6b4d7f5ddf3ce4f65/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs?ref=1d9f01cb421eae8e7ace0fa6b4d7f5ddf3ce4f65", "patch": "@@ -77,7 +77,24 @@ fn initial_matcher_pos(ms: ~[matcher], sep: option<token>, lo: uint)\n       match_lo: 0u, match_hi: match_idx_hi, sp_lo: lo}\n }\n \n-/* logically, an arb_depth should contain only one kind of nonterminal */\n+// arb_depth is a pattern-match result for a single black-box matcher\n+// (ast::mtc_bb): so it is associated with a single ident in a parse, and all\n+// leaves in the arb_depth have the same nonterminal type (expr, item,\n+// etc). All the leaves in a single arb_depth correspond to a single mtc_bb in\n+// the ast::matcher that produced it.\n+//\n+// It should probably be renamed, it has more or less exact correspondence to\n+// ast::match nodes, and the in-memory structure of a particular arb_depth\n+// represents the match that occurred when a particular subset of an\n+// ast::match -- those ast::matcher nodes leading to a single mtc_bb -- was\n+// applied to a particular token tree.\n+//\n+// The width of each seq in the arb_depth, and the identity of the leaf nodes,\n+// will depend on the token tree it was applied to: each seq corresponds to a\n+// single mtc_rep in the originating ast::matcher. The depth of the arb_depth\n+// structure will therefore depend only on the nesting depth of mtc_reps in\n+// the originating ast::matcher it was derived from.\n+\n enum arb_depth { leaf(whole_nt), seq(~[@arb_depth], codemap::span) }\n \n type earley_item = matcher_pos;"}]}