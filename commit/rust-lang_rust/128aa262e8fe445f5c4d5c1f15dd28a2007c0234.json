{"sha": "128aa262e8fe445f5c4d5c1f15dd28a2007c0234", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyOGFhMjYyZThmZTQ0NWY1YzRkNWMxZjE1ZGQyOGEyMDA3YzAyMzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-28T18:53:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-28T18:53:24Z"}, "message": "Auto merge of #41368 - nikomatsakis:incr-comp-dep-tracking-map, r=eddyb\n\nmake *most* maps private\n\nCurrently we access the `DepTrackingMap` fields directly rather than using the query accessors. This seems bad. This branch removes several such uses, but not all, and extends the macro so that queries can hide their maps (so we can prevent regressions). The extension to the macro is kind of ugly :/ but couldn't find a simple way to do it otherwise (I guess I could use a nested macro...). Anyway I figure it's only temporary.\n\nr? @eddyb", "tree": {"sha": "bc8be43bbd513f2977e66100a9cd14ddb3d262b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc8be43bbd513f2977e66100a9cd14ddb3d262b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/128aa262e8fe445f5c4d5c1f15dd28a2007c0234", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/128aa262e8fe445f5c4d5c1f15dd28a2007c0234", "html_url": "https://github.com/rust-lang/rust/commit/128aa262e8fe445f5c4d5c1f15dd28a2007c0234", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/128aa262e8fe445f5c4d5c1f15dd28a2007c0234/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad1461efb92ae85ce8227f52ca79149e368529d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad1461efb92ae85ce8227f52ca79149e368529d1", "html_url": "https://github.com/rust-lang/rust/commit/ad1461efb92ae85ce8227f52ca79149e368529d1"}, {"sha": "d7d3f197f62d7d0a1a612b7243f4617428cae53f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7d3f197f62d7d0a1a612b7243f4617428cae53f", "html_url": "https://github.com/rust-lang/rust/commit/d7d3f197f62d7d0a1a612b7243f4617428cae53f"}], "stats": {"total": 423, "additions": 251, "deletions": 172}, "files": [{"sha": "622bf4dd0bd0835f4c126a26f9ed85f7bd8b86ee", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/128aa262e8fe445f5c4d5c1f15dd28a2007c0234/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128aa262e8fe445f5c4d5c1f15dd28a2007c0234/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=128aa262e8fe445f5c4d5c1f15dd28a2007c0234", "patch": "@@ -475,14 +475,13 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n         // This is done to handle the case where, for example, the static\n         // method of a private type is used, but the type itself is never\n         // called directly.\n-        if let Some(impl_list) =\n-                self.tcx.maps.inherent_impls.borrow().get(&self.tcx.hir.local_def_id(id)) {\n-            for &impl_did in impl_list.iter() {\n-                for &item_did in &self.tcx.associated_item_def_ids(impl_did)[..] {\n-                    if let Some(item_node_id) = self.tcx.hir.as_local_node_id(item_did) {\n-                        if self.live_symbols.contains(&item_node_id) {\n-                            return true;\n-                        }\n+        let def_id = self.tcx.hir.local_def_id(id);\n+        let inherent_impls = self.tcx.inherent_impls(def_id);\n+        for &impl_did in inherent_impls.iter() {\n+            for &item_did in &self.tcx.associated_item_def_ids(impl_did)[..] {\n+                if let Some(item_node_id) = self.tcx.hir.as_local_node_id(item_did) {\n+                    if self.live_symbols.contains(&item_node_id) {\n+                        return true;\n                     }\n                 }\n             }"}, {"sha": "16d5d1187fc8bf5de52ee2b6cd934f5e709f8896", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/128aa262e8fe445f5c4d5c1f15dd28a2007c0234/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128aa262e8fe445f5c4d5c1f15dd28a2007c0234/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=128aa262e8fe445f5c4d5c1f15dd28a2007c0234", "patch": "@@ -13,16 +13,19 @@ use hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use ty::{self, Ty, TyCtxt};\n use syntax::ast;\n use syntax::symbol::Symbol;\n+use syntax_pos::DUMMY_SP;\n \n use std::cell::Cell;\n \n thread_local! {\n-    static FORCE_ABSOLUTE: Cell<bool> = Cell::new(false)\n+    static FORCE_ABSOLUTE: Cell<bool> = Cell::new(false);\n+    static FORCE_IMPL_FILENAME_LINE: Cell<bool> = Cell::new(false);\n }\n \n-/// Enforces that item_path_str always returns an absolute path.\n-/// This is useful when building symbols that contain types,\n-/// where we want the crate name to be part of the symbol.\n+/// Enforces that item_path_str always returns an absolute path and\n+/// also enables \"type-based\" impl paths. This is used when building\n+/// symbols that contain types, where we want the crate name to be\n+/// part of the symbol.\n pub fn with_forced_absolute_paths<F: FnOnce() -> R, R>(f: F) -> R {\n     FORCE_ABSOLUTE.with(|force| {\n         let old = force.get();\n@@ -33,6 +36,20 @@ pub fn with_forced_absolute_paths<F: FnOnce() -> R, R>(f: F) -> R {\n     })\n }\n \n+/// Force us to name impls with just the filename/line number. We\n+/// normally try to use types. But at some points, notably while printing\n+/// cycle errors, this can result in extra or suboptimal error output,\n+/// so this variable disables that check.\n+pub fn with_forced_impl_filename_line<F: FnOnce() -> R, R>(f: F) -> R {\n+    FORCE_IMPL_FILENAME_LINE.with(|force| {\n+        let old = force.get();\n+        force.set(true);\n+        let result = f();\n+        force.set(old);\n+        result\n+    })\n+}\n+\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Returns a string identifying this def-id. This string is\n     /// suitable for user output. It is relative to the current crate\n@@ -199,14 +216,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     {\n         let parent_def_id = self.parent_def_id(impl_def_id).unwrap();\n \n-        let use_types = if !impl_def_id.is_local() {\n-            // always have full types available for extern crates\n-            true\n-        } else {\n-            // for local crates, check whether type info is\n-            // available; typeck might not have completed yet\n-            self.maps.impl_trait_ref.borrow().contains_key(&impl_def_id) &&\n-                self.maps.type_of.borrow().contains_key(&impl_def_id)\n+        // Always use types for non-local impls, where types are always\n+        // available, and filename/line-number is mostly uninteresting.\n+        let use_types = !impl_def_id.is_local() || {\n+            // Otherwise, use filename/line-number if forced.\n+            let force_no_types = FORCE_IMPL_FILENAME_LINE.with(|f| f.get());\n+            !force_no_types && {\n+                // Otherwise, use types if we can query them without inducing a cycle.\n+                ty::queries::impl_trait_ref::try_get(self, DUMMY_SP, impl_def_id).is_ok() &&\n+                    ty::queries::type_of::try_get(self, DUMMY_SP, impl_def_id).is_ok()\n+            }\n         };\n \n         if !use_types {"}, {"sha": "1749c90b5892ac7c4f784a918aee59f16a5fe573", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 75, "deletions": 54, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/128aa262e8fe445f5c4d5c1f15dd28a2007c0234/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128aa262e8fe445f5c4d5c1f15dd28a2007c0234/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=128aa262e8fe445f5c4d5c1f15dd28a2007c0234", "patch": "@@ -17,11 +17,13 @@ use middle::privacy::AccessLevels;\n use mir;\n use session::CompileResult;\n use ty::{self, CrateInherentImpls, Ty, TyCtxt};\n+use ty::item_path;\n use ty::subst::Substs;\n use util::nodemap::NodeSet;\n \n use rustc_data_structures::indexed_vec::IndexVec;\n use std::cell::{RefCell, RefMut};\n+use std::mem;\n use std::ops::Deref;\n use std::rc::Rc;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -139,24 +141,36 @@ pub struct CycleError<'a, 'tcx: 'a> {\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn report_cycle(self, CycleError { span, cycle }: CycleError) {\n-        assert!(!cycle.is_empty());\n-\n-        let mut err = struct_span_err!(self.sess, span, E0391,\n-            \"unsupported cyclic reference between types/traits detected\");\n-        err.span_label(span, &format!(\"cyclic reference\"));\n-\n-        err.span_note(cycle[0].0, &format!(\"the cycle begins when {}...\",\n-                                           cycle[0].1.describe(self)));\n-\n-        for &(span, ref query) in &cycle[1..] {\n-            err.span_note(span, &format!(\"...which then requires {}...\",\n-                                         query.describe(self)));\n-        }\n+        // Subtle: release the refcell lock before invoking `describe()`\n+        // below by dropping `cycle`.\n+        let stack = cycle.to_vec();\n+        mem::drop(cycle);\n+\n+        assert!(!stack.is_empty());\n+\n+        // Disable naming impls with types in this path, since that\n+        // sometimes cycles itself, leading to extra cycle errors.\n+        // (And cycle errors around impls tend to occur during the\n+        // collect/coherence phases anyhow.)\n+        item_path::with_forced_impl_filename_line(|| {\n+            let mut err =\n+                struct_span_err!(self.sess, span, E0391,\n+                                 \"unsupported cyclic reference between types/traits detected\");\n+            err.span_label(span, &format!(\"cyclic reference\"));\n+\n+            err.span_note(stack[0].0, &format!(\"the cycle begins when {}...\",\n+                                               stack[0].1.describe(self)));\n+\n+            for &(span, ref query) in &stack[1..] {\n+                err.span_note(span, &format!(\"...which then requires {}...\",\n+                                             query.describe(self)));\n+            }\n \n-        err.note(&format!(\"...which then again requires {}, completing the cycle.\",\n-                          cycle[0].1.describe(self)));\n+            err.note(&format!(\"...which then again requires {}, completing the cycle.\",\n+                              stack[0].1.describe(self)));\n \n-        err.emit();\n+            err.emit();\n+        });\n     }\n \n     fn cycle_check<F, R>(self, span: Span, query: Query<'gcx>, compute: F)\n@@ -274,11 +288,11 @@ impl<'tcx> QueryDescription for queries::describe_def<'tcx> {\n macro_rules! define_maps {\n     (<$tcx:tt>\n      $($(#[$attr:meta])*\n-       pub $name:ident: $node:ident($K:ty) -> $V:ty),*) => {\n+       [$($pub:tt)*] $name:ident: $node:ident($K:ty) -> $V:ty),*) => {\n         pub struct Maps<$tcx> {\n             providers: IndexVec<CrateNum, Providers<$tcx>>,\n             query_stack: RefCell<Vec<(Span, Query<$tcx>)>>,\n-            $($(#[$attr])* pub $name: RefCell<DepTrackingMap<queries::$name<$tcx>>>),*\n+            $($(#[$attr])* $($pub)* $name: RefCell<DepTrackingMap<queries::$name<$tcx>>>),*\n         }\n \n         impl<$tcx> Maps<$tcx> {\n@@ -335,6 +349,11 @@ macro_rules! define_maps {\n                                   -> Result<R, CycleError<'a, $tcx>>\n                 where F: FnOnce(&$V) -> R\n             {\n+                debug!(\"ty::queries::{}::try_get_with(key={:?}, span={:?})\",\n+                       stringify!($name),\n+                       key,\n+                       span);\n+\n                 if let Some(result) = tcx.maps.$name.borrow().get(&key) {\n                     return Ok(f(result));\n                 }\n@@ -441,52 +460,52 @@ macro_rules! define_maps {\n // the driver creates (using several `rustc_*` crates).\n define_maps! { <'tcx>\n     /// Records the type of every item.\n-    pub type_of: ItemSignature(DefId) -> Ty<'tcx>,\n+    [] type_of: ItemSignature(DefId) -> Ty<'tcx>,\n \n     /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n     /// associated generics and predicates.\n-    pub generics_of: ItemSignature(DefId) -> &'tcx ty::Generics,\n-    pub predicates_of: ItemSignature(DefId) -> ty::GenericPredicates<'tcx>,\n+    [] generics_of: ItemSignature(DefId) -> &'tcx ty::Generics,\n+    [] predicates_of: ItemSignature(DefId) -> ty::GenericPredicates<'tcx>,\n \n     /// Maps from the def-id of a trait to the list of\n     /// super-predicates. This is a subset of the full list of\n     /// predicates. We store these in a separate map because we must\n     /// evaluate them even during type conversion, often before the\n     /// full predicates are available (note that supertraits have\n     /// additional acyclicity requirements).\n-    pub super_predicates_of: ItemSignature(DefId) -> ty::GenericPredicates<'tcx>,\n+    [] super_predicates_of: ItemSignature(DefId) -> ty::GenericPredicates<'tcx>,\n \n     /// To avoid cycles within the predicates of a single item we compute\n     /// per-type-parameter predicates for resolving `T::AssocTy`.\n-    pub type_param_predicates: TypeParamPredicates((DefId, DefId))\n+    [] type_param_predicates: TypeParamPredicates((DefId, DefId))\n         -> ty::GenericPredicates<'tcx>,\n \n-    pub trait_def: ItemSignature(DefId) -> &'tcx ty::TraitDef,\n-    pub adt_def: ItemSignature(DefId) -> &'tcx ty::AdtDef,\n-    pub adt_destructor: AdtDestructor(DefId) -> Option<ty::Destructor>,\n-    pub adt_sized_constraint: SizedConstraint(DefId) -> &'tcx [Ty<'tcx>],\n-    pub adt_dtorck_constraint: DtorckConstraint(DefId) -> ty::DtorckConstraint<'tcx>,\n+    [] trait_def: ItemSignature(DefId) -> &'tcx ty::TraitDef,\n+    [] adt_def: ItemSignature(DefId) -> &'tcx ty::AdtDef,\n+    [] adt_destructor: AdtDestructor(DefId) -> Option<ty::Destructor>,\n+    [] adt_sized_constraint: SizedConstraint(DefId) -> &'tcx [Ty<'tcx>],\n+    [] adt_dtorck_constraint: DtorckConstraint(DefId) -> ty::DtorckConstraint<'tcx>,\n \n     /// True if this is a foreign item (i.e., linked via `extern { ... }`).\n-    pub is_foreign_item: IsForeignItem(DefId) -> bool,\n+    [] is_foreign_item: IsForeignItem(DefId) -> bool,\n \n     /// Maps from def-id of a type or region parameter to its\n     /// (inferred) variance.\n-    pub variances_of: ItemSignature(DefId) -> Rc<Vec<ty::Variance>>,\n+    [pub] variances_of: ItemSignature(DefId) -> Rc<Vec<ty::Variance>>,\n \n     /// Maps from an impl/trait def-id to a list of the def-ids of its items\n-    pub associated_item_def_ids: AssociatedItemDefIds(DefId) -> Rc<Vec<DefId>>,\n+    [] associated_item_def_ids: AssociatedItemDefIds(DefId) -> Rc<Vec<DefId>>,\n \n     /// Maps from a trait item to the trait item \"descriptor\"\n-    pub associated_item: AssociatedItems(DefId) -> ty::AssociatedItem,\n+    [] associated_item: AssociatedItems(DefId) -> ty::AssociatedItem,\n \n-    pub impl_trait_ref: ItemSignature(DefId) -> Option<ty::TraitRef<'tcx>>,\n-    pub impl_polarity: ItemSignature(DefId) -> hir::ImplPolarity,\n+    [] impl_trait_ref: ItemSignature(DefId) -> Option<ty::TraitRef<'tcx>>,\n+    [] impl_polarity: ItemSignature(DefId) -> hir::ImplPolarity,\n \n     /// Maps a DefId of a type to a list of its inherent impls.\n     /// Contains implementations of methods that are inherent to a type.\n     /// Methods in these implementations don't need to be exported.\n-    pub inherent_impls: InherentImpls(DefId) -> Rc<Vec<DefId>>,\n+    [] inherent_impls: InherentImpls(DefId) -> Rc<Vec<DefId>>,\n \n     /// Maps from the def-id of a function/method or const/static\n     /// to its MIR. Mutation is done at an item granularity to\n@@ -495,59 +514,61 @@ define_maps! { <'tcx>\n     ///\n     /// Note that cross-crate MIR appears to be always borrowed\n     /// (in the `RefCell` sense) to prevent accidental mutation.\n-    pub mir: Mir(DefId) -> &'tcx RefCell<mir::Mir<'tcx>>,\n+    [pub] mir: Mir(DefId) -> &'tcx RefCell<mir::Mir<'tcx>>,\n \n     /// Maps DefId's that have an associated Mir to the result\n     /// of the MIR qualify_consts pass. The actual meaning of\n     /// the value isn't known except to the pass itself.\n-    pub mir_const_qualif: Mir(DefId) -> u8,\n+    [] mir_const_qualif: Mir(DefId) -> u8,\n \n     /// Records the type of each closure. The def ID is the ID of the\n     /// expression defining the closure.\n-    pub closure_kind: ItemSignature(DefId) -> ty::ClosureKind,\n+    [] closure_kind: ItemSignature(DefId) -> ty::ClosureKind,\n \n     /// Records the type of each closure. The def ID is the ID of the\n     /// expression defining the closure.\n-    pub closure_type: ItemSignature(DefId) -> ty::PolyFnSig<'tcx>,\n+    [] closure_type: ItemSignature(DefId) -> ty::PolyFnSig<'tcx>,\n \n     /// Caches CoerceUnsized kinds for impls on custom types.\n-    pub coerce_unsized_info: ItemSignature(DefId)\n+    [] coerce_unsized_info: ItemSignature(DefId)\n         -> ty::adjustment::CoerceUnsizedInfo,\n \n-    pub typeck_item_bodies: typeck_item_bodies_dep_node(CrateNum) -> CompileResult,\n+    [] typeck_item_bodies: typeck_item_bodies_dep_node(CrateNum) -> CompileResult,\n \n-    pub typeck_tables_of: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx>,\n+    [] typeck_tables_of: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx>,\n \n-    pub coherent_trait: coherent_trait_dep_node((CrateNum, DefId)) -> (),\n+    [] has_typeck_tables: TypeckTables(DefId) -> bool,\n \n-    pub borrowck: BorrowCheck(DefId) -> (),\n+    [] coherent_trait: coherent_trait_dep_node((CrateNum, DefId)) -> (),\n+\n+    [] borrowck: BorrowCheck(DefId) -> (),\n \n     /// Gets a complete map from all types to their inherent impls.\n     /// Not meant to be used directly outside of coherence.\n     /// (Defined only for LOCAL_CRATE)\n-    pub crate_inherent_impls: crate_inherent_impls_dep_node(CrateNum) -> CrateInherentImpls,\n+    [] crate_inherent_impls: crate_inherent_impls_dep_node(CrateNum) -> CrateInherentImpls,\n \n     /// Checks all types in the krate for overlap in their inherent impls. Reports errors.\n     /// Not meant to be used directly outside of coherence.\n     /// (Defined only for LOCAL_CRATE)\n-    pub crate_inherent_impls_overlap_check: crate_inherent_impls_dep_node(CrateNum) -> (),\n+    [] crate_inherent_impls_overlap_check: crate_inherent_impls_dep_node(CrateNum) -> (),\n \n     /// Results of evaluating const items or constants embedded in\n     /// other items (such as enum variant explicit discriminants).\n-    pub const_eval: const_eval_dep_node((DefId, &'tcx Substs<'tcx>))\n+    [] const_eval: const_eval_dep_node((DefId, &'tcx Substs<'tcx>))\n         -> const_val::EvalResult<'tcx>,\n \n     /// Performs the privacy check and computes \"access levels\".\n-    pub privacy_access_levels: PrivacyAccessLevels(CrateNum) -> Rc<AccessLevels>,\n+    [] privacy_access_levels: PrivacyAccessLevels(CrateNum) -> Rc<AccessLevels>,\n \n-    pub reachable_set: reachability_dep_node(CrateNum) -> Rc<NodeSet>,\n+    [] reachable_set: reachability_dep_node(CrateNum) -> Rc<NodeSet>,\n \n-    pub mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx RefCell<mir::Mir<'tcx>>,\n+    [] mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx RefCell<mir::Mir<'tcx>>,\n \n-    pub def_symbol_name: SymbolName(DefId) -> ty::SymbolName,\n-    pub symbol_name: symbol_name_dep_node(ty::Instance<'tcx>) -> ty::SymbolName,\n+    [] def_symbol_name: SymbolName(DefId) -> ty::SymbolName,\n+    [] symbol_name: symbol_name_dep_node(ty::Instance<'tcx>) -> ty::SymbolName,\n \n-    pub describe_def: meta_data_node(DefId) -> Option<Def>\n+    [] describe_def: meta_data_node(DefId) -> Option<Def>\n }\n \n fn coherent_trait_dep_node((_, def_id): (CrateNum, DefId)) -> DepNode<DefId> {\n@@ -582,4 +603,4 @@ fn const_eval_dep_node((def_id, _): (DefId, &Substs)) -> DepNode<DefId> {\n \n fn meta_data_node(def_id: DefId) -> DepNode<DefId> {\n     DepNode::MetaData(def_id)\n-}\n\\ No newline at end of file\n+}"}, {"sha": "ff4bded012e9ef84c68898299e9d646ade8c659d", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/128aa262e8fe445f5c4d5c1f15dd28a2007c0234/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128aa262e8fe445f5c4d5c1f15dd28a2007c0234/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=128aa262e8fe445f5c4d5c1f15dd28a2007c0234", "patch": "@@ -2139,6 +2139,26 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n+    pub fn opt_associated_item(self, def_id: DefId) -> Option<AssociatedItem> {\n+        let is_associated_item = if let Some(node_id) = self.hir.as_local_node_id(def_id) {\n+            match self.hir.get(node_id) {\n+                hir_map::NodeTraitItem(_) | hir_map::NodeImplItem(_) => true,\n+                _ => false,\n+            }\n+        } else {\n+            match self.describe_def(def_id).expect(\"no def for def-id\") {\n+                Def::AssociatedConst(_) | Def::Method(_) | Def::AssociatedTy(_) => true,\n+                _ => false,\n+            }\n+        };\n+\n+        if is_associated_item {\n+            Some(self.associated_item(def_id))\n+        } else {\n+            None\n+        }\n+    }\n+\n     fn associated_item_from_trait_item_ref(self,\n                                            parent_def_id: DefId,\n                                            parent_vis: &hir::Visibility,\n@@ -2391,7 +2411,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 None\n             }\n         } else {\n-            self.maps.associated_item.borrow().get(&def_id).cloned()\n+            self.opt_associated_item(def_id)\n         };\n \n         match item {\n@@ -2412,15 +2432,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         if def_id.krate != LOCAL_CRATE {\n             return self.sess.cstore.trait_of_item(def_id);\n         }\n-        match self.maps.associated_item.borrow().get(&def_id) {\n-            Some(associated_item) => {\n+        self.opt_associated_item(def_id)\n+            .and_then(|associated_item| {\n                 match associated_item.container {\n                     TraitContainer(def_id) => Some(def_id),\n                     ImplContainer(_) => None\n                 }\n-            }\n-            None => None\n-        }\n+            })\n     }\n \n     /// Construct a parameter environment suitable for static contexts or other contexts where there\n@@ -2588,11 +2606,12 @@ fn associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n             }\n         }\n \n-        ref r => {\n-            panic!(\"unexpected container of associated items: {:?}\", r)\n-        }\n+        _ => { }\n     }\n-    panic!(\"associated item not found for def_id: {:?}\", def_id);\n+\n+    span_bug!(parent_item.span,\n+              \"unexpected parent of trait or impl item or item not found: {:?}\",\n+              parent_item.node)\n }\n \n /// Calculates the Sized-constraint."}, {"sha": "d4b8f0a4924619ebcdb3ce53cf3992f56768f59e", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/128aa262e8fe445f5c4d5c1f15dd28a2007c0234/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128aa262e8fe445f5c4d5c1f15dd28a2007c0234/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=128aa262e8fe445f5c4d5c1f15dd28a2007c0234", "patch": "@@ -27,19 +27,15 @@ pub enum MethodLateContext {\n     PlainImpl,\n }\n \n-pub fn method_context(cx: &LateContext, id: ast::NodeId, span: Span) -> MethodLateContext {\n+pub fn method_context(cx: &LateContext, id: ast::NodeId) -> MethodLateContext {\n     let def_id = cx.tcx.hir.local_def_id(id);\n-    match cx.tcx.maps.associated_item.borrow().get(&def_id) {\n-        None => span_bug!(span, \"missing method descriptor?!\"),\n-        Some(item) => {\n-            match item.container {\n-                ty::TraitContainer(..) => MethodLateContext::TraitDefaultImpl,\n-                ty::ImplContainer(cid) => {\n-                    match cx.tcx.impl_trait_ref(cid) {\n-                        Some(_) => MethodLateContext::TraitImpl,\n-                        None => MethodLateContext::PlainImpl,\n-                    }\n-                }\n+    let item = cx.tcx.associated_item(def_id);\n+    match item.container {\n+        ty::TraitContainer(..) => MethodLateContext::TraitDefaultImpl,\n+        ty::ImplContainer(cid) => {\n+            match cx.tcx.impl_trait_ref(cid) {\n+                Some(_) => MethodLateContext::TraitImpl,\n+                None => MethodLateContext::PlainImpl,\n             }\n         }\n     }\n@@ -244,7 +240,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n                 id: ast::NodeId) {\n         match fk {\n             FnKind::Method(name, ..) => {\n-                match method_context(cx, id, span) {\n+                match method_context(cx, id) {\n                     MethodLateContext::PlainImpl => {\n                         self.check_snake_case(cx, \"method\", &name.as_str(), Some(span))\n                     }"}, {"sha": "57ed298809635d5093324e94f95c9431a9247900", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/128aa262e8fe445f5c4d5c1f15dd28a2007c0234/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128aa262e8fe445f5c4d5c1f15dd28a2007c0234/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=128aa262e8fe445f5c4d5c1f15dd28a2007c0234", "patch": "@@ -432,7 +432,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n \n     fn check_impl_item(&mut self, cx: &LateContext, impl_item: &hir::ImplItem) {\n         // If the method is an impl for a trait, don't doc.\n-        if method_context(cx, impl_item.id, impl_item.span) == MethodLateContext::TraitImpl {\n+        if method_context(cx, impl_item.id) == MethodLateContext::TraitImpl {\n             return;\n         }\n "}, {"sha": "28fea2eec60f08c36f5359182f76429777e868f6", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/128aa262e8fe445f5c4d5c1f15dd28a2007c0234/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128aa262e8fe445f5c4d5c1f15dd28a2007c0234/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=128aa262e8fe445f5c4d5c1f15dd28a2007c0234", "patch": "@@ -827,7 +827,7 @@ impl<'a, 'tcx> CrateMetadata {\n             EntryKind::AssociatedType(container) => {\n                 (ty::AssociatedKind::Type, container, false)\n             }\n-            _ => bug!()\n+            _ => bug!(\"cannot get associated-item of `{:?}`\", def_key)\n         };\n \n         ty::AssociatedItem {"}, {"sha": "189b94a1b6285e43bd8f3335ff7c8819c5e53a61", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/128aa262e8fe445f5c4d5c1f15dd28a2007c0234/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128aa262e8fe445f5c4d5c1f15dd28a2007c0234/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=128aa262e8fe445f5c4d5c1f15dd28a2007c0234", "patch": "@@ -627,14 +627,14 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n     // Encodes the inherent implementations of a structure, enumeration, or trait.\n     fn encode_inherent_implementations(&mut self, def_id: DefId) -> LazySeq<DefIndex> {\n         debug!(\"EntryBuilder::encode_inherent_implementations({:?})\", def_id);\n-        match self.tcx.maps.inherent_impls.borrow().get(&def_id) {\n-            None => LazySeq::empty(),\n-            Some(implementations) => {\n-                self.lazy_seq(implementations.iter().map(|&def_id| {\n-                    assert!(def_id.is_local());\n-                    def_id.index\n-                }))\n-            }\n+        let implementations = self.tcx.inherent_impls(def_id);\n+        if implementations.is_empty() {\n+            LazySeq::empty()\n+        } else {\n+            self.lazy_seq(implementations.iter().map(|&def_id| {\n+                assert!(def_id.is_local());\n+                def_id.index\n+            }))\n         }\n     }\n "}, {"sha": "26780c48a1392e68a863ff67ec5ef99131fc05d9", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/128aa262e8fe445f5c4d5c1f15dd28a2007c0234/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128aa262e8fe445f5c4d5c1f15dd28a2007c0234/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=128aa262e8fe445f5c4d5c1f15dd28a2007c0234", "patch": "@@ -115,14 +115,14 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         where F: FnOnce(&mut DumpVisitor<'l, 'tcx, 'll, D>)\n     {\n         let item_def_id = self.tcx.hir.local_def_id(item_id);\n-        match self.tcx.maps.typeck_tables_of.borrow().get(&item_def_id) {\n-            Some(tables) => {\n-                let old_tables = self.save_ctxt.tables;\n-                self.save_ctxt.tables = tables;\n-                f(self);\n-                self.save_ctxt.tables = old_tables;\n-            }\n-            None => f(self),\n+        if self.tcx.has_typeck_tables(item_def_id) {\n+            let tables = self.tcx.typeck_tables_of(item_def_id);\n+            let old_tables = self.save_ctxt.tables;\n+            self.save_ctxt.tables = tables;\n+            f(self);\n+            self.save_ctxt.tables = old_tables;\n+        } else {\n+            f(self)\n         }\n     }\n "}, {"sha": "0186755e30a624ba889201f27a61964760e843b5", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 72, "deletions": 45, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/128aa262e8fe445f5c4d5c1f15dd28a2007c0234/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128aa262e8fe445f5c4d5c1f15dd28a2007c0234/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=128aa262e8fe445f5c4d5c1f15dd28a2007c0234", "patch": "@@ -637,6 +637,7 @@ pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n         typeck_item_bodies,\n         typeck_tables_of,\n+        has_typeck_tables,\n         closure_type,\n         closure_kind,\n         adt_destructor,\n@@ -664,55 +665,49 @@ fn adt_destructor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tcx.calculate_dtor(def_id, &mut dropck::check_drop_impl)\n }\n \n-fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           def_id: DefId)\n-                           -> &'tcx ty::TypeckTables<'tcx> {\n-    // Closures' tables come from their outermost function,\n-    // as they are part of the same \"inference environment\".\n-    let outer_def_id = tcx.closure_base_def_id(def_id);\n-    if outer_def_id != def_id {\n-        return tcx.typeck_tables_of(outer_def_id);\n-    }\n-\n-    let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    let span = tcx.hir.span(id);\n-    let unsupported = || {\n-        span_bug!(span, \"can't type-check body of {:?}\", def_id);\n-    };\n-\n-    // Figure out what primary body this item has.\n-    let mut fn_decl = None;\n-    let body_id = match tcx.hir.get(id) {\n+/// If this def-id is a \"primary tables entry\", returns `Some((body_id, decl))`\n+/// with information about it's body-id and fn-decl (if any). Otherwise,\n+/// returns `None`.\n+///\n+/// If this function returns \"some\", then `typeck_tables(def_id)` will\n+/// succeed; if it returns `None`, then `typeck_tables(def_id)` may or\n+/// may not succeed.  In some cases where this function returns `None`\n+/// (notably closures), `typeck_tables(def_id)` would wind up\n+/// redirecting to the owning function.\n+fn primary_body_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             id: ast::NodeId)\n+                             -> Option<(hir::BodyId, Option<&'tcx hir::FnDecl>)>\n+{\n+    match tcx.hir.get(id) {\n         hir::map::NodeItem(item) => {\n             match item.node {\n                 hir::ItemConst(_, body) |\n-                hir::ItemStatic(_, _, body) => body,\n-                hir::ItemFn(ref decl, .., body) => {\n-                    fn_decl = Some(decl);\n-                    body\n-                }\n-                _ => unsupported()\n+                hir::ItemStatic(_, _, body) =>\n+                    Some((body, None)),\n+                hir::ItemFn(ref decl, .., body) =>\n+                    Some((body, Some(decl))),\n+                _ =>\n+                    None,\n             }\n         }\n         hir::map::NodeTraitItem(item) => {\n             match item.node {\n-                hir::TraitItemKind::Const(_, Some(body)) => body,\n-                hir::TraitItemKind::Method(ref sig,\n-                    hir::TraitMethod::Provided(body)) => {\n-                        fn_decl = Some(&sig.decl);\n-                        body\n-                    }\n-                _ => unsupported()\n+                hir::TraitItemKind::Const(_, Some(body)) =>\n+                    Some((body, None)),\n+                hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Provided(body)) =>\n+                    Some((body, Some(&sig.decl))),\n+                _ =>\n+                    None,\n             }\n         }\n         hir::map::NodeImplItem(item) => {\n             match item.node {\n-                hir::ImplItemKind::Const(_, body) => body,\n-                hir::ImplItemKind::Method(ref sig, body) => {\n-                    fn_decl = Some(&sig.decl);\n-                    body\n-                }\n-                _ => unsupported()\n+                hir::ImplItemKind::Const(_, body) =>\n+                    Some((body, None)),\n+                hir::ImplItemKind::Method(ref sig, body) =>\n+                    Some((body, Some(&sig.decl))),\n+                _ =>\n+                    None,\n             }\n         }\n         hir::map::NodeExpr(expr) => {\n@@ -723,15 +718,47 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // Assume that everything other than closures\n             // is a constant \"initializer\" expression.\n             match expr.node {\n-                hir::ExprClosure(..) => {\n-                    // We should've bailed out above for closures.\n-                    span_bug!(expr.span, \"unexpected closure\")\n-                }\n-                _ => hir::BodyId { node_id: expr.id }\n+                hir::ExprClosure(..) =>\n+                    None,\n+                _ =>\n+                    Some((hir::BodyId { node_id: expr.id }, None)),\n             }\n         }\n-        _ => unsupported()\n-    };\n+        _ => None,\n+    }\n+}\n+\n+fn has_typeck_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                               def_id: DefId)\n+                               -> bool {\n+    // Closures' tables come from their outermost function,\n+    // as they are part of the same \"inference environment\".\n+    let outer_def_id = tcx.closure_base_def_id(def_id);\n+    if outer_def_id != def_id {\n+        return tcx.has_typeck_tables(outer_def_id);\n+    }\n+\n+    let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    primary_body_of(tcx, id).is_some()\n+}\n+\n+fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              def_id: DefId)\n+                              -> &'tcx ty::TypeckTables<'tcx> {\n+    // Closures' tables come from their outermost function,\n+    // as they are part of the same \"inference environment\".\n+    let outer_def_id = tcx.closure_base_def_id(def_id);\n+    if outer_def_id != def_id {\n+        return tcx.typeck_tables_of(outer_def_id);\n+    }\n+\n+    let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    let span = tcx.hir.span(id);\n+\n+    // Figure out what primary body this item has.\n+    let (body_id, fn_decl) = primary_body_of(tcx, id).unwrap_or_else(|| {\n+        span_bug!(span, \"can't type-check body of {:?}\", def_id);\n+    });\n     let body = tcx.hir.body(body_id);\n \n     Inherited::build(tcx, id).enter(|inh| {"}, {"sha": "1af55d4d840d9b0fa852923539632a75a896c1b6", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/128aa262e8fe445f5c4d5c1f15dd28a2007c0234/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128aa262e8fe445f5c4d5c1f15dd28a2007c0234/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=128aa262e8fe445f5c4d5c1f15dd28a2007c0234", "patch": "@@ -63,17 +63,11 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CheckVisitor<'a, 'tcx> {\n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut used_trait_imports = DefIdSet();\n     for &body_id in tcx.hir.krate().bodies.keys() {\n-        let item_id = tcx.hir.body_owner(body_id);\n-        let item_def_id = tcx.hir.local_def_id(item_id);\n-\n-        // this will have been written by the main typeck pass\n-        if let Some(tables) = tcx.maps.typeck_tables_of.borrow().get(&item_def_id) {\n-            let imports = &tables.used_trait_imports;\n-            debug!(\"GatherVisitor: item_def_id={:?} with imports {:#?}\", item_def_id, imports);\n-            used_trait_imports.extend(imports);\n-        } else {\n-            debug!(\"GatherVisitor: item_def_id={:?} with no imports\", item_def_id);\n-        }\n+        let item_def_id = tcx.hir.body_owner_def_id(body_id);\n+        let tables = tcx.typeck_tables_of(item_def_id);\n+        let imports = &tables.used_trait_imports;\n+        debug!(\"GatherVisitor: item_def_id={:?} with imports {:#?}\", item_def_id, imports);\n+        used_trait_imports.extend(imports);\n     }\n \n     let mut visitor = CheckVisitor { tcx, used_trait_imports };"}, {"sha": "238952865c7bd91e3525e19fc3e6b5e8e8471c37", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/128aa262e8fe445f5c4d5c1f15dd28a2007c0234/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128aa262e8fe445f5c4d5c1f15dd28a2007c0234/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=128aa262e8fe445f5c4d5c1f15dd28a2007c0234", "patch": "@@ -66,11 +66,15 @@ pub fn inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     //\n     // [the plan]: https://github.com/rust-lang/rust-roadmap/issues/4\n \n+    thread_local! {\n+        static EMPTY_DEF_ID_VEC: Rc<Vec<DefId>> = Rc::new(vec![])\n+    }\n+\n     let result = tcx.dep_graph.with_ignore(|| {\n         let crate_map = tcx.crate_inherent_impls(ty_def_id.krate);\n         match crate_map.inherent_impls.get(&ty_def_id) {\n             Some(v) => v.clone(),\n-            None => Rc::new(vec![]),\n+            None => EMPTY_DEF_ID_VEC.with(|v| v.clone())\n         }\n     });\n "}]}