{"sha": "c04b0f435b4d2b29147bcfc33cdd42639e68fc00", "node_id": "C_kwDOAAsO6NoAKGMwNGIwZjQzNWI0ZDJiMjkxNDdiY2ZjMzNjZGQ0MjYzOWU2OGZjMDA", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-03-08T22:51:48Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-03-08T22:51:48Z"}, "message": "Move hir to new MacroId", "tree": {"sha": "7b798b10d13d7f0481e11a04ceeff23ccb945cb5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b798b10d13d7f0481e11a04ceeff23ccb945cb5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c04b0f435b4d2b29147bcfc33cdd42639e68fc00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c04b0f435b4d2b29147bcfc33cdd42639e68fc00", "html_url": "https://github.com/rust-lang/rust/commit/c04b0f435b4d2b29147bcfc33cdd42639e68fc00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c04b0f435b4d2b29147bcfc33cdd42639e68fc00/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad54ee293982f65a4ea72f2eae3f14b52fe2284e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad54ee293982f65a4ea72f2eae3f14b52fe2284e", "html_url": "https://github.com/rust-lang/rust/commit/ad54ee293982f65a4ea72f2eae3f14b52fe2284e"}], "stats": {"total": 361, "additions": 212, "deletions": 149}, "files": [{"sha": "0bd37934001094d901dd75cc11eedd48ac69dd32", "filename": "crates/hir/src/attrs.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c04b0f435b4d2b29147bcfc33cdd42639e68fc00/crates%2Fhir%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c04b0f435b4d2b29147bcfc33cdd42639e68fc00/crates%2Fhir%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fattrs.rs?ref=c04b0f435b4d2b29147bcfc33cdd42639e68fc00", "patch": "@@ -1,6 +1,5 @@\n //! Attributes & documentation for hir types.\n \n-use either::Either;\n use hir_def::{\n     attr::{AttrsWithOwner, Documentation},\n     item_scope::ItemInNs,\n@@ -9,13 +8,13 @@ use hir_def::{\n     resolver::HasResolver,\n     AttrDefId, GenericParamId, ModuleDefId,\n };\n-use hir_expand::{hygiene::Hygiene, MacroDefId};\n+use hir_expand::hygiene::Hygiene;\n use hir_ty::db::HirDatabase;\n use syntax::{ast, AstNode};\n \n use crate::{\n     Adt, AssocItem, Const, ConstParam, Enum, Field, Function, GenericParam, Impl, LifetimeParam,\n-    MacroDef, Module, ModuleDef, Static, Struct, Trait, TypeAlias, TypeParam, Union, Variant,\n+    Macro, Module, ModuleDef, Static, Struct, Trait, TypeAlias, TypeParam, Union, Variant,\n };\n \n pub trait HasAttrs {\n@@ -26,7 +25,7 @@ pub trait HasAttrs {\n         db: &dyn HirDatabase,\n         link: &str,\n         ns: Option<Namespace>,\n-    ) -> Option<Either<ModuleDef, MacroDef>>;\n+    ) -> Option<ModuleDef>;\n }\n \n #[derive(PartialEq, Eq, Hash, Copy, Clone, Debug)]\n@@ -47,9 +46,9 @@ macro_rules! impl_has_attrs {\n                 let def = AttrDefId::$def_id(self.into());\n                 db.attrs(def).docs()\n             }\n-            fn resolve_doc_path(self, db: &dyn HirDatabase, link: &str, ns: Option<Namespace>) -> Option<Either<ModuleDef, MacroDef>> {\n+            fn resolve_doc_path(self, db: &dyn HirDatabase, link: &str, ns: Option<Namespace>) -> Option<ModuleDef> {\n                 let def = AttrDefId::$def_id(self.into());\n-                resolve_doc_path(db, def, link, ns).map(|it| it.map_left(ModuleDef::from).map_right(MacroDef::from))\n+                resolve_doc_path(db, def, link, ns).map(ModuleDef::from)\n             }\n         }\n     )*};\n@@ -62,7 +61,7 @@ impl_has_attrs![\n     (Const, ConstId),\n     (Trait, TraitId),\n     (TypeAlias, TypeAliasId),\n-    (MacroDef, MacroDefId),\n+    (Macro, MacroId),\n     (Function, FunctionId),\n     (Adt, AdtId),\n     (Module, ModuleId),\n@@ -79,7 +78,7 @@ macro_rules! impl_has_attrs_enum {\n             fn docs(self, db: &dyn HirDatabase) -> Option<Documentation> {\n                 $enum::$variant(self).docs(db)\n             }\n-            fn resolve_doc_path(self, db: &dyn HirDatabase, link: &str, ns: Option<Namespace>) -> Option<Either<ModuleDef, MacroDef>> {\n+            fn resolve_doc_path(self, db: &dyn HirDatabase, link: &str, ns: Option<Namespace>) -> Option<ModuleDef> {\n                 $enum::$variant(self).resolve_doc_path(db, link, ns)\n             }\n         }\n@@ -111,7 +110,7 @@ impl HasAttrs for AssocItem {\n         db: &dyn HirDatabase,\n         link: &str,\n         ns: Option<Namespace>,\n-    ) -> Option<Either<ModuleDef, MacroDef>> {\n+    ) -> Option<ModuleDef> {\n         match self {\n             AssocItem::Function(it) => it.resolve_doc_path(db, link, ns),\n             AssocItem::Const(it) => it.resolve_doc_path(db, link, ns),\n@@ -125,7 +124,7 @@ fn resolve_doc_path(\n     def: AttrDefId,\n     link: &str,\n     ns: Option<Namespace>,\n-) -> Option<Either<ModuleDefId, MacroDefId>> {\n+) -> Option<ModuleDefId> {\n     let resolver = match def {\n         AttrDefId::ModuleId(it) => it.resolver(db.upcast()),\n         AttrDefId::FieldId(it) => it.parent.resolver(db.upcast()),\n@@ -138,14 +137,13 @@ fn resolve_doc_path(\n         AttrDefId::TypeAliasId(it) => it.resolver(db.upcast()),\n         AttrDefId::ImplId(it) => it.resolver(db.upcast()),\n         AttrDefId::ExternBlockId(it) => it.resolver(db.upcast()),\n+        AttrDefId::MacroId(it) => it.resolver(db.upcast()),\n         AttrDefId::GenericParamId(it) => match it {\n             GenericParamId::TypeParamId(it) => it.parent(),\n             GenericParamId::ConstParamId(it) => it.parent(),\n             GenericParamId::LifetimeParamId(it) => it.parent,\n         }\n         .resolver(db.upcast()),\n-        // FIXME\n-        AttrDefId::MacroDefId(_) => return None,\n     };\n \n     let modpath = {\n@@ -167,13 +165,13 @@ fn resolve_doc_path(\n         resolved\n     };\n     match ns {\n-        Some(Namespace::Types) => resolved.take_types().map(Either::Left),\n-        Some(Namespace::Values) => resolved.take_values().map(Either::Left),\n-        Some(Namespace::Macros) => resolved.take_macros().map(Either::Right),\n+        Some(Namespace::Types) => resolved.take_types(),\n+        Some(Namespace::Values) => resolved.take_values(),\n+        Some(Namespace::Macros) => resolved.take_macros().map(ModuleDefId::MacroId),\n         None => resolved.iter_items().next().map(|it| match it {\n-            ItemInNs::Types(it) => Either::Left(it),\n-            ItemInNs::Values(it) => Either::Left(it),\n-            ItemInNs::Macros(it) => Either::Right(it),\n+            ItemInNs::Types(it) => it,\n+            ItemInNs::Values(it) => it,\n+            ItemInNs::Macros(it) => ModuleDefId::MacroId(it),\n         }),\n     }\n }"}, {"sha": "5ee7556481c197280700c85bad155877ca4b7d4f", "filename": "crates/hir/src/from_id.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c04b0f435b4d2b29147bcfc33cdd42639e68fc00/crates%2Fhir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c04b0f435b4d2b29147bcfc33cdd42639e68fc00/crates%2Fhir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Ffrom_id.rs?ref=c04b0f435b4d2b29147bcfc33cdd42639e68fc00", "patch": "@@ -45,7 +45,7 @@ from_id![\n     (hir_def::TypeParamId, crate::TypeParam),\n     (hir_def::ConstParamId, crate::ConstParam),\n     (hir_def::LifetimeParamId, crate::LifetimeParam),\n-    (hir_expand::MacroDefId, crate::MacroDef)\n+    (hir_def::MacroId, crate::Macro)\n ];\n \n impl From<AdtId> for Adt {\n@@ -112,6 +112,7 @@ impl From<ModuleDefId> for ModuleDef {\n             ModuleDefId::TraitId(it) => ModuleDef::Trait(it.into()),\n             ModuleDefId::TypeAliasId(it) => ModuleDef::TypeAlias(it.into()),\n             ModuleDefId::BuiltinType(it) => ModuleDef::BuiltinType(it.into()),\n+            ModuleDefId::MacroId(it) => ModuleDef::Macro(it.into()),\n         }\n     }\n }\n@@ -128,6 +129,7 @@ impl From<ModuleDef> for ModuleDefId {\n             ModuleDef::Trait(it) => ModuleDefId::TraitId(it.into()),\n             ModuleDef::TypeAlias(it) => ModuleDefId::TypeAliasId(it.into()),\n             ModuleDef::BuiltinType(it) => ModuleDefId::BuiltinType(it.into()),\n+            ModuleDef::Macro(it) => ModuleDefId::MacroId(it.into()),\n         }\n     }\n }"}, {"sha": "037f51ec8e0e5dae0f72424abd2ed1c137e19a77", "filename": "crates/hir/src/has_source.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c04b0f435b4d2b29147bcfc33cdd42639e68fc00/crates%2Fhir%2Fsrc%2Fhas_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c04b0f435b4d2b29147bcfc33cdd42639e68fc00/crates%2Fhir%2Fsrc%2Fhas_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fhas_source.rs?ref=c04b0f435b4d2b29147bcfc33cdd42639e68fc00", "patch": "@@ -4,13 +4,13 @@ use either::Either;\n use hir_def::{\n     nameres::{ModuleOrigin, ModuleSource},\n     src::{HasChildSource, HasSource as _},\n-    Lookup, VariantId,\n+    Lookup, MacroId, VariantId,\n };\n use hir_expand::InFile;\n use syntax::ast;\n \n use crate::{\n-    db::HirDatabase, Adt, Const, Enum, Field, FieldSource, Function, Impl, LifetimeParam, MacroDef,\n+    db::HirDatabase, Adt, Const, Enum, Field, FieldSource, Function, Impl, LifetimeParam, Macro,\n     Module, Static, Struct, Trait, TypeAlias, TypeOrConstParam, Union, Variant,\n };\n \n@@ -123,13 +123,26 @@ impl HasSource for TypeAlias {\n         Some(self.id.lookup(db.upcast()).source(db.upcast()))\n     }\n }\n-impl HasSource for MacroDef {\n+impl HasSource for Macro {\n     type Ast = Either<ast::Macro, ast::Fn>;\n     fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {\n-        Some(self.id.ast_id().either(\n-            |id| id.with_value(Either::Left(id.to_node(db.upcast()))),\n-            |id| id.with_value(Either::Right(id.to_node(db.upcast()))),\n-        ))\n+        match self.id {\n+            MacroId::Macro2Id(it) => Some(\n+                it.lookup(db.upcast())\n+                    .source(db.upcast())\n+                    .map(ast::Macro::MacroDef)\n+                    .map(Either::Left),\n+            ),\n+            MacroId::MacroRulesId(it) => Some(\n+                it.lookup(db.upcast())\n+                    .source(db.upcast())\n+                    .map(ast::Macro::MacroRules)\n+                    .map(Either::Left),\n+            ),\n+            MacroId::ProcMacroId(it) => {\n+                Some(it.lookup(db.upcast()).source(db.upcast()).map(Either::Right))\n+            }\n+        }\n     }\n }\n impl HasSource for Impl {"}, {"sha": "76bbe80e1f7323a861aa8bd5c94e6b8dcdebf074", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 87, "deletions": 71, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/c04b0f435b4d2b29147bcfc33cdd42639e68fc00/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c04b0f435b4d2b29147bcfc33cdd42639e68fc00/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=c04b0f435b4d2b29147bcfc33cdd42639e68fc00", "patch": "@@ -49,10 +49,10 @@ use hir_def::{\n     src::HasSource as _,\n     AdtId, AssocItemId, AssocItemLoc, AttrDefId, ConstId, ConstParamId, DefWithBodyId, EnumId,\n     FunctionId, GenericDefId, HasModule, ImplId, ItemContainerId, LifetimeParamId,\n-    LocalEnumVariantId, LocalFieldId, Lookup, ModuleId, StaticId, StructId, TraitId, TypeAliasId,\n-    TypeOrConstParamId, TypeParamId, UnionId,\n+    LocalEnumVariantId, LocalFieldId, Lookup, MacroId, ModuleId, StaticId, StructId, TraitId,\n+    TypeAliasId, TypeOrConstParamId, TypeParamId, UnionId,\n };\n-use hir_expand::{name::name, MacroCallKind, MacroDefId, MacroDefKind};\n+use hir_expand::{name::name, MacroCallKind};\n use hir_ty::{\n     autoderef,\n     consteval::{eval_const, ComputedExpr, ConstEvalCtx, ConstEvalError, ConstExt},\n@@ -207,7 +207,7 @@ impl Crate {\n         self,\n         db: &dyn DefDatabase,\n         query: import_map::Query,\n-    ) -> impl Iterator<Item = Either<ModuleDef, MacroDef>> {\n+    ) -> impl Iterator<Item = Either<ModuleDef, Macro>> {\n         let _p = profile::span(\"query_external_importables\");\n         import_map::search_dependencies(db, self.into(), query).into_iter().map(|item| {\n             match ItemInNs::from(item) {\n@@ -272,6 +272,7 @@ pub enum ModuleDef {\n     Trait(Trait),\n     TypeAlias(TypeAlias),\n     BuiltinType(BuiltinType),\n+    Macro(Macro),\n }\n impl_from!(\n     Module,\n@@ -282,7 +283,8 @@ impl_from!(\n     Static,\n     Trait,\n     TypeAlias,\n-    BuiltinType\n+    BuiltinType,\n+    Macro\n     for ModuleDef\n );\n \n@@ -307,6 +309,7 @@ impl ModuleDef {\n             ModuleDef::Static(it) => Some(it.module(db)),\n             ModuleDef::Trait(it) => Some(it.module(db)),\n             ModuleDef::TypeAlias(it) => Some(it.module(db)),\n+            ModuleDef::Macro(it) => Some(it.module(db)),\n             ModuleDef::BuiltinType(_) => None,\n         }\n     }\n@@ -337,6 +340,7 @@ impl ModuleDef {\n             ModuleDef::Variant(it) => it.name(db),\n             ModuleDef::TypeAlias(it) => it.name(db),\n             ModuleDef::Static(it) => it.name(db),\n+            ModuleDef::Macro(it) => it.name(db)?,\n             ModuleDef::BuiltinType(it) => it.name(),\n         };\n         Some(name)\n@@ -390,6 +394,7 @@ impl ModuleDef {\n             | ModuleDef::Variant(_)\n             | ModuleDef::Trait(_)\n             | ModuleDef::TypeAlias(_)\n+            | ModuleDef::Macro(_)\n             | ModuleDef::BuiltinType(_) => None,\n         }\n     }\n@@ -404,6 +409,7 @@ impl ModuleDef {\n             ModuleDef::Static(it) => it.attrs(db),\n             ModuleDef::Trait(it) => it.attrs(db),\n             ModuleDef::TypeAlias(it) => it.attrs(db),\n+            ModuleDef::Macro(it) => it.attrs(db),\n             ModuleDef::BuiltinType(_) => return None,\n         })\n     }\n@@ -420,6 +426,8 @@ impl HasVisibility for ModuleDef {\n             ModuleDef::Trait(it) => it.visibility(db),\n             ModuleDef::TypeAlias(it) => it.visibility(db),\n             ModuleDef::Variant(it) => it.visibility(db),\n+            // FIXME\n+            ModuleDef::Macro(_) => Visibility::Public,\n             ModuleDef::BuiltinType(_) => Visibility::Public,\n         }\n     }\n@@ -1376,25 +1384,27 @@ impl Function {\n         db.function_data(self.id).has_body()\n     }\n \n-    pub fn as_proc_macro(self, db: &dyn HirDatabase) -> Option<MacroDef> {\n-        let function_data = db.function_data(self.id);\n-        let attrs = &function_data.attrs;\n-        if !(attrs.is_proc_macro()\n-            || attrs.is_proc_macro_attribute()\n-            || attrs.is_proc_macro_derive())\n-        {\n-            return None;\n-        }\n-        let loc = self.id.lookup(db.upcast());\n-        let krate = loc.krate(db);\n-        let def_map = db.crate_def_map(krate.into());\n-        let ast_id =\n-            InFile::new(loc.id.file_id(), loc.id.item_tree(db.upcast())[loc.id.value].ast_id);\n-\n-        let mut exported_proc_macros = def_map.exported_proc_macros();\n-        exported_proc_macros\n-            .find(|&(id, _)| matches!(id.kind, MacroDefKind::ProcMacro(_, _, id) if id == ast_id))\n-            .map(|(id, _)| MacroDef { id })\n+    pub fn as_proc_macro(self, _db: &dyn HirDatabase) -> Option<Macro> {\n+        // let function_data = db.function_data(self.id);\n+        // let attrs = &function_data.attrs;\n+        // if !(attrs.is_proc_macro()\n+        //     || attrs.is_proc_macro_attribute()\n+        //     || attrs.is_proc_macro_derive())\n+        // {\n+        //     return None;\n+        // }\n+        // let loc = self.id.lookup(db.upcast());\n+        // let krate = loc.krate(db);\n+        // let def_map = db.crate_def_map(krate.into());\n+        // let ast_id =\n+        //     InFile::new(loc.id.file_id(), loc.id.item_tree(db.upcast())[loc.id.value].ast_id);\n+\n+        // let mut exported_proc_macros = def_map.exported_proc_macros();\n+        // exported_proc_macros\n+        //     .find(|&(id, _)| matches!(id.kind, MacroDefKind::ProcMacro(_, _, id) if id == ast_id))\n+        //     .map(|(id, _)| Macro { id })\n+        // FIXME\n+        None\n     }\n \n     /// A textual representation of the HIR of this function for debugging purposes.\n@@ -1747,73 +1757,82 @@ pub enum MacroKind {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct MacroDef {\n-    pub(crate) id: MacroDefId,\n+pub struct Macro {\n+    pub(crate) id: MacroId,\n }\n \n-impl MacroDef {\n-    /// FIXME: right now, this just returns the root module of the crate that\n-    /// defines this macro. The reasons for this is that macros are expanded\n-    /// early, in `hir_expand`, where modules simply do not exist yet.\n-    pub fn module(self, db: &dyn HirDatabase) -> Option<Module> {\n-        let krate = self.id.krate;\n-        let def_map = db.crate_def_map(krate);\n-        let module_id = def_map.root();\n-        Some(Module { id: def_map.module_id(module_id) })\n+impl Macro {\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n+        Module { id: self.id.module(db.upcast()) }\n     }\n \n-    /// XXX: this parses the file\n-    pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n-        match self.source(db)?.value {\n-            Either::Left(it) => it.name().map(|it| it.as_name()),\n-            Either::Right(_) => {\n-                let krate = self.id.krate;\n-                let def_map = db.crate_def_map(krate);\n-                let (_, name) = def_map.exported_proc_macros().find(|&(id, _)| id == self.id)?;\n-                Some(name)\n-            }\n+    pub fn name(self, _db: &dyn HirDatabase) -> Option<Name> {\n+        match self.id {\n+            MacroId::Macro2Id(_id) => todo!(),\n+            MacroId::MacroRulesId(_id) => todo!(),\n+            MacroId::ProcMacroId(_id) => todo!(),\n         }\n     }\n \n-    pub fn kind(&self) -> MacroKind {\n-        match self.id.kind {\n-            MacroDefKind::Declarative(_) => MacroKind::Declarative,\n-            MacroDefKind::BuiltIn(_, _) | MacroDefKind::BuiltInEager(_, _) => MacroKind::BuiltIn,\n-            MacroDefKind::BuiltInDerive(_, _) => MacroKind::Derive,\n-            MacroDefKind::BuiltInAttr(_, _) => MacroKind::Attr,\n-            MacroDefKind::ProcMacro(_, base_db::ProcMacroKind::CustomDerive, _) => {\n-                MacroKind::Derive\n-            }\n-            MacroDefKind::ProcMacro(_, base_db::ProcMacroKind::Attr, _) => MacroKind::Attr,\n-            MacroDefKind::ProcMacro(_, base_db::ProcMacroKind::FuncLike, _) => MacroKind::ProcMacro,\n+    pub fn kind(&self, db: &dyn HirDatabase) -> MacroKind {\n+        match self.id {\n+            MacroId::Macro2Id(it) => match it.lookup(db.upcast()).expander {\n+                hir_def::MacroExpander::Declarative => MacroKind::Declarative,\n+                hir_def::MacroExpander::BuiltIn(_) => MacroKind::BuiltIn,\n+                hir_def::MacroExpander::BuiltInAttr(_) => MacroKind::Attr,\n+                hir_def::MacroExpander::BuiltInDerive(_) => MacroKind::Derive,\n+                hir_def::MacroExpander::BuiltInEager(_) => MacroKind::BuiltIn,\n+            },\n+            MacroId::MacroRulesId(it) => match it.lookup(db.upcast()).expander {\n+                hir_def::MacroExpander::Declarative => MacroKind::Declarative,\n+                hir_def::MacroExpander::BuiltIn(_) => MacroKind::BuiltIn,\n+                hir_def::MacroExpander::BuiltInAttr(_) => MacroKind::Attr,\n+                hir_def::MacroExpander::BuiltInDerive(_) => MacroKind::Derive,\n+                hir_def::MacroExpander::BuiltInEager(_) => MacroKind::BuiltIn,\n+            },\n+            MacroId::ProcMacroId(it) => match it.lookup(db.upcast()).kind {\n+                base_db::ProcMacroKind::CustomDerive => MacroKind::Derive,\n+                base_db::ProcMacroKind::FuncLike => MacroKind::ProcMacro,\n+                base_db::ProcMacroKind::Attr => MacroKind::Attr,\n+            },\n         }\n     }\n \n-    pub fn is_fn_like(&self) -> bool {\n-        match self.kind() {\n+    pub fn is_fn_like(&self, db: &dyn HirDatabase) -> bool {\n+        match self.kind(db) {\n             MacroKind::Declarative | MacroKind::BuiltIn | MacroKind::ProcMacro => true,\n             MacroKind::Attr | MacroKind::Derive => false,\n         }\n     }\n \n-    pub fn is_builtin_derive(&self) -> bool {\n-        matches!(self.id.kind, MacroDefKind::BuiltInAttr(exp, _) if exp.is_derive())\n+    pub fn is_builtin_derive(&self, db: &dyn HirDatabase) -> bool {\n+        match self.id {\n+            MacroId::Macro2Id(it) => match it.lookup(db.upcast()).expander {\n+                hir_def::MacroExpander::BuiltInDerive(_) => true,\n+                _ => false,\n+            },\n+            MacroId::MacroRulesId(it) => match it.lookup(db.upcast()).expander {\n+                hir_def::MacroExpander::BuiltInDerive(_) => true,\n+                _ => false,\n+            },\n+            MacroId::ProcMacroId(_) => false,\n+        }\n     }\n \n-    pub fn is_attr(&self) -> bool {\n-        matches!(self.kind(), MacroKind::Attr)\n+    pub fn is_attr(&self, db: &dyn HirDatabase) -> bool {\n+        matches!(self.kind(db), MacroKind::Attr)\n     }\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n pub enum ItemInNs {\n     Types(ModuleDef),\n     Values(ModuleDef),\n-    Macros(MacroDef),\n+    Macros(Macro),\n }\n \n-impl From<MacroDef> for ItemInNs {\n-    fn from(it: MacroDef) -> Self {\n+impl From<Macro> for ItemInNs {\n+    fn from(it: Macro) -> Self {\n         Self::Macros(it)\n     }\n }\n@@ -1841,7 +1860,7 @@ impl ItemInNs {\n     pub fn krate(&self, db: &dyn HirDatabase) -> Option<Crate> {\n         match self {\n             ItemInNs::Types(did) | ItemInNs::Values(did) => did.module(db).map(|m| m.krate()),\n-            ItemInNs::Macros(id) => id.module(db).map(|m| m.krate()),\n+            ItemInNs::Macros(id) => Some(id.module(db).krate()),\n         }\n     }\n \n@@ -3224,7 +3243,6 @@ impl Callable {\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum ScopeDef {\n     ModuleDef(ModuleDef),\n-    MacroDef(MacroDef),\n     GenericParam(GenericParam),\n     ImplSelfType(Impl),\n     AdtSelfType(Adt),\n@@ -3255,7 +3273,7 @@ impl ScopeDef {\n         };\n \n         if let Some(macro_def_id) = def.take_macros() {\n-            items.push(ScopeDef::MacroDef(macro_def_id.into()));\n+            items.push(ScopeDef::ModuleDef(ModuleDef::Macro(macro_def_id.into())));\n         }\n \n         if items.is_empty() {\n@@ -3268,7 +3286,6 @@ impl ScopeDef {\n     pub fn attrs(&self, db: &dyn HirDatabase) -> Option<AttrsWithOwner> {\n         match self {\n             ScopeDef::ModuleDef(it) => it.attrs(db),\n-            ScopeDef::MacroDef(it) => Some(it.attrs(db)),\n             ScopeDef::GenericParam(it) => Some(it.attrs(db)),\n             ScopeDef::ImplSelfType(_)\n             | ScopeDef::AdtSelfType(_)\n@@ -3281,7 +3298,6 @@ impl ScopeDef {\n     pub fn krate(&self, db: &dyn HirDatabase) -> Option<Crate> {\n         match self {\n             ScopeDef::ModuleDef(it) => it.module(db).map(|m| m.krate()),\n-            ScopeDef::MacroDef(it) => it.module(db).map(|m| m.krate()),\n             ScopeDef::GenericParam(it) => Some(it.module(db).krate()),\n             ScopeDef::ImplSelfType(_) => None,\n             ScopeDef::AdtSelfType(it) => Some(it.module(db).krate()),\n@@ -3297,7 +3313,7 @@ impl From<ItemInNs> for ScopeDef {\n         match item {\n             ItemInNs::Types(id) => ScopeDef::ModuleDef(id),\n             ItemInNs::Values(id) => ScopeDef::ModuleDef(id),\n-            ItemInNs::Macros(id) => ScopeDef::MacroDef(id),\n+            ItemInNs::Macros(id) => ScopeDef::ModuleDef(ModuleDef::Macro(id)),\n         }\n     }\n }"}, {"sha": "6d6a86fc8ab542e01e0dae4490750d7df522f83a", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 51, "deletions": 22, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/c04b0f435b4d2b29147bcfc33cdd42639e68fc00/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c04b0f435b4d2b29147bcfc33cdd42639e68fc00/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=c04b0f435b4d2b29147bcfc33cdd42639e68fc00", "patch": "@@ -6,11 +6,12 @@ use std::{cell::RefCell, fmt, iter};\n \n use base_db::{FileId, FileRange};\n use hir_def::{\n-    body,\n+    body, macro_id_to_def_id,\n     resolver::{self, HasResolver, Resolver, TypeNs},\n-    AsMacroCall, FunctionId, TraitId, VariantId,\n+    AsMacroCall, FunctionId, MacroId, TraitId, VariantId,\n };\n use hir_expand::{\n+    db::AstDatabase,\n     name::{known, AsName},\n     ExpansionInfo, MacroCallId,\n };\n@@ -29,7 +30,7 @@ use crate::{\n     semantics::source_to_def::{ChildContainer, SourceToDefCache, SourceToDefCtx},\n     source_analyzer::{resolve_hir_path, SourceAnalyzer},\n     Access, AssocItem, BuiltinAttr, Callable, ConstParam, Crate, Field, Function, HasSource,\n-    HirFileId, Impl, InFile, Label, LifetimeParam, Local, MacroDef, Module, ModuleDef, Name, Path,\n+    HirFileId, Impl, InFile, Label, LifetimeParam, Local, Macro, Module, ModuleDef, Name, Path,\n     ScopeDef, ToolModule, Trait, Type, TypeAlias, TypeParam, VariantDef,\n };\n \n@@ -44,7 +45,6 @@ pub enum PathResolution {\n     /// A const parameter\n     ConstParam(ConstParam),\n     SelfType(Impl),\n-    Macro(MacroDef),\n     AssocItem(AssocItem),\n     BuiltinAttr(BuiltinAttr),\n     ToolModule(ToolModule),\n@@ -60,6 +60,7 @@ impl PathResolution {\n             PathResolution::Def(\n                 ModuleDef::Const(_)\n                 | ModuleDef::Variant(_)\n+                | ModuleDef::Macro(_)\n                 | ModuleDef::Function(_)\n                 | ModuleDef::Module(_)\n                 | ModuleDef::Static(_)\n@@ -71,7 +72,6 @@ impl PathResolution {\n             PathResolution::BuiltinAttr(_)\n             | PathResolution::ToolModule(_)\n             | PathResolution::Local(_)\n-            | PathResolution::Macro(_)\n             | PathResolution::ConstParam(_) => None,\n             PathResolution::TypeParam(param) => Some(TypeNs::GenericParam((*param).into())),\n             PathResolution::SelfType(impl_def) => Some(TypeNs::SelfType((*impl_def).into())),\n@@ -151,7 +151,7 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.expand_attr_macro(item)\n     }\n \n-    pub fn resolve_derive_macro(&self, derive: &ast::Attr) -> Option<Vec<Option<MacroDef>>> {\n+    pub fn resolve_derive_macro(&self, derive: &ast::Attr) -> Option<Vec<Option<Macro>>> {\n         self.imp.resolve_derive_macro(derive)\n     }\n \n@@ -331,11 +331,11 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.resolve_record_pat_field(field)\n     }\n \n-    pub fn resolve_macro_call(&self, macro_call: &ast::MacroCall) -> Option<MacroDef> {\n+    pub fn resolve_macro_call(&self, macro_call: &ast::MacroCall) -> Option<Macro> {\n         self.imp.resolve_macro_call(macro_call)\n     }\n \n-    pub fn resolve_attr_macro_call(&self, item: &ast::Item) -> Option<MacroDef> {\n+    pub fn resolve_attr_macro_call(&self, item: &ast::Item) -> Option<Macro> {\n         self.imp.resolve_attr_macro_call(item)\n     }\n \n@@ -443,13 +443,18 @@ impl<'db> SemanticsImpl<'db> {\n         Some(node)\n     }\n \n-    fn resolve_derive_macro(&self, attr: &ast::Attr) -> Option<Vec<Option<MacroDef>>> {\n-        let res = self\n-            .derive_macro_calls(attr)?\n-            .into_iter()\n-            .map(|call| Some(MacroDef { id: self.db.lookup_intern_macro_call(call?).def }))\n-            .collect();\n-        Some(res)\n+    fn resolve_derive_macro(&self, attr: &ast::Attr) -> Option<Vec<Option<Macro>>> {\n+        let calls = self.derive_macro_calls(attr)?;\n+        self.with_ctx(|ctx| {\n+            Some(\n+                calls\n+                    .into_iter()\n+                    .map(|call| {\n+                        macro_call_to_macro_id(ctx, self.db.upcast(), call?).map(|id| Macro { id })\n+                    })\n+                    .collect(),\n+            )\n+        })\n     }\n \n     fn expand_derive_macro(&self, attr: &ast::Attr) -> Option<Vec<SyntaxNode>> {\n@@ -500,7 +505,9 @@ impl<'db> SemanticsImpl<'db> {\n         let macro_call = InFile::new(file_id, actual_macro_call);\n         let krate = resolver.krate()?;\n         let macro_call_id = macro_call.as_call_id(self.db.upcast(), krate, |path| {\n-            resolver.resolve_path_as_macro(self.db.upcast(), &path)\n+            resolver\n+                .resolve_path_as_macro(self.db.upcast(), &path)\n+                .map(|it| macro_id_to_def_id(self.db.upcast(), it))\n         })?;\n         hir_expand::db::expand_speculative(\n             self.db.upcast(),\n@@ -895,16 +902,19 @@ impl<'db> SemanticsImpl<'db> {\n         self.analyze(field.syntax()).resolve_record_pat_field(self.db, field)\n     }\n \n-    fn resolve_macro_call(&self, macro_call: &ast::MacroCall) -> Option<MacroDef> {\n+    fn resolve_macro_call(&self, macro_call: &ast::MacroCall) -> Option<Macro> {\n         let sa = self.analyze(macro_call.syntax());\n         let macro_call = self.find_file(macro_call.syntax()).with_value(macro_call);\n         sa.resolve_macro_call(self.db, macro_call)\n     }\n \n-    fn resolve_attr_macro_call(&self, item: &ast::Item) -> Option<MacroDef> {\n+    fn resolve_attr_macro_call(&self, item: &ast::Item) -> Option<Macro> {\n         let item_in_file = self.wrap_node_infile(item.clone());\n-        let macro_call_id = self.with_ctx(|ctx| ctx.item_to_macro_call(item_in_file))?;\n-        Some(MacroDef { id: self.db.lookup_intern_macro_call(macro_call_id).def })\n+        let id = self.with_ctx(|ctx| {\n+            let macro_call_id = ctx.item_to_macro_call(item_in_file)?;\n+            macro_call_to_macro_id(ctx, self.db.upcast(), macro_call_id)\n+        })?;\n+        Some(Macro { id })\n     }\n \n     fn resolve_path(&self, path: &ast::Path) -> Option<PathResolution> {\n@@ -1152,6 +1162,26 @@ impl<'db> SemanticsImpl<'db> {\n     }\n }\n \n+fn macro_call_to_macro_id(\n+    ctx: &mut SourceToDefCtx,\n+    db: &dyn AstDatabase,\n+    macro_call_id: MacroCallId,\n+) -> Option<MacroId> {\n+    let loc = db.lookup_intern_macro_call(macro_call_id);\n+    match loc.def.kind {\n+        hir_expand::MacroDefKind::Declarative(it)\n+        | hir_expand::MacroDefKind::BuiltIn(_, it)\n+        | hir_expand::MacroDefKind::BuiltInAttr(_, it)\n+        | hir_expand::MacroDefKind::BuiltInDerive(_, it)\n+        | hir_expand::MacroDefKind::BuiltInEager(_, it) => {\n+            ctx.macro_to_def(InFile::new(it.file_id, it.to_node(db)))\n+        }\n+        hir_expand::MacroDefKind::ProcMacro(_, _, it) => {\n+            ctx.proc_macro_to_def(InFile::new(it.file_id, it.to_node(db)))\n+        }\n+    }\n+}\n+\n pub trait ToDef: AstNode + Clone {\n     type Def;\n \n@@ -1188,7 +1218,7 @@ to_def_impls![\n     (crate::LifetimeParam, ast::LifetimeParam, lifetime_param_to_def),\n     (crate::ConstParam, ast::ConstParam, const_param_to_def),\n     (crate::GenericParam, ast::GenericParam, generic_param_to_def),\n-    (crate::MacroDef, ast::Macro, macro_to_def),\n+    (crate::Macro, ast::Macro, macro_to_def),\n     (crate::Local, ast::IdentPat, bind_pat_to_def),\n     (crate::Local, ast::SelfParam, self_param_to_def),\n     (crate::Label, ast::Label, label_to_def),\n@@ -1250,7 +1280,6 @@ impl<'a> SemanticsScope<'a> {\n             for entry in entries {\n                 let def = match entry {\n                     resolver::ScopeDef::ModuleDef(it) => ScopeDef::ModuleDef(it.into()),\n-                    resolver::ScopeDef::MacroDef(it) => ScopeDef::MacroDef(it.into()),\n                     resolver::ScopeDef::Unknown => ScopeDef::Unknown,\n                     resolver::ScopeDef::ImplSelfType(it) => ScopeDef::ImplSelfType(it.into()),\n                     resolver::ScopeDef::AdtSelfType(it) => ScopeDef::AdtSelfType(it.into()),"}, {"sha": "986ea0cf2a664cb863634ca2461089d32895d1c8", "filename": "crates/hir/src/semantics/source_to_def.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c04b0f435b4d2b29147bcfc33cdd42639e68fc00/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c04b0f435b4d2b29147bcfc33cdd42639e68fc00/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=c04b0f435b4d2b29147bcfc33cdd42639e68fc00", "patch": "@@ -93,10 +93,10 @@ use hir_def::{\n     expr::{LabelId, PatId},\n     keys::{self, Key},\n     AdtId, ConstId, ConstParamId, DefWithBodyId, EnumId, EnumVariantId, FieldId, FunctionId,\n-    GenericDefId, GenericParamId, ImplId, LifetimeParamId, ModuleId, StaticId, StructId, TraitId,\n-    TypeAliasId, TypeParamId, UnionId, VariantId,\n+    GenericDefId, GenericParamId, ImplId, LifetimeParamId, MacroId, ModuleId, StaticId, StructId,\n+    TraitId, TypeAliasId, TypeParamId, UnionId, VariantId,\n };\n-use hir_expand::{name::AsName, AstId, HirFileId, MacroCallId, MacroDefId, MacroDefKind};\n+use hir_expand::{name::AsName, HirFileId, MacroCallId};\n use rustc_hash::FxHashMap;\n use smallvec::SmallVec;\n use stdx::impl_from;\n@@ -317,20 +317,18 @@ impl SourceToDefCtx<'_, '_> {\n         }\n     }\n \n-    pub(super) fn macro_to_def(&mut self, src: InFile<ast::Macro>) -> Option<MacroDefId> {\n-        let makro = self.dyn_map(src.as_ref()).and_then(|it| it[keys::MACRO].get(&src.value));\n-        if let Some(&makro) = makro {\n-            return Some(makro);\n-        }\n+    pub(super) fn macro_to_def(&mut self, src: InFile<ast::Macro>) -> Option<MacroId> {\n+        self.dyn_map(src.as_ref()).and_then(|it| match &src.value {\n+            ast::Macro::MacroRules(value) => {\n+                it[keys::MACRO_RULES].get(value).copied().map(MacroId::from)\n+            }\n+            ast::Macro::MacroDef(value) => it[keys::MACRO2].get(value).copied().map(MacroId::from),\n+        })\n+    }\n \n-        // Not all macros are recorded in the dyn map, only the ones behaving like items, so fall back\n-        // for the non-item like definitions.\n-        let file_ast_id = self.db.ast_id_map(src.file_id).ast_id(&src.value);\n-        let ast_id = AstId::new(src.file_id, file_ast_id.upcast());\n-        let kind = MacroDefKind::Declarative(ast_id);\n-        let file_id = src.file_id.original_file(self.db.upcast());\n-        let krate = self.file_to_def(file_id).get(0).copied()?.krate();\n-        Some(MacroDefId { krate, kind, local_inner: false })\n+    pub(super) fn proc_macro_to_def(&mut self, src: InFile<ast::Fn>) -> Option<MacroId> {\n+        self.dyn_map(src.as_ref())\n+            .and_then(|it| it[keys::PROC_MACRO].get(&src.value).copied().map(MacroId::from))\n     }\n \n     pub(super) fn find_container(&mut self, src: InFile<&SyntaxNode>) -> Option<ChildContainer> {"}, {"sha": "1789fc319a36b02f2c97204475ca863c7b7019a5", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c04b0f435b4d2b29147bcfc33cdd42639e68fc00/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c04b0f435b4d2b29147bcfc33cdd42639e68fc00/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=c04b0f435b4d2b29147bcfc33cdd42639e68fc00", "patch": "@@ -17,6 +17,7 @@ use hir_def::{\n         Body, BodySourceMap,\n     },\n     expr::{ExprId, Pat, PatId},\n+    macro_id_to_def_id,\n     path::{ModPath, Path, PathKind},\n     resolver::{resolver_for_scope, Resolver, TypeNs, ValueNs},\n     AsMacroCall, DefWithBodyId, FieldId, FunctionId, LocalFieldId, ModuleDefId, VariantId,\n@@ -33,8 +34,7 @@ use syntax::{\n \n use crate::{\n     db::HirDatabase, semantics::PathResolution, Adt, BuiltinAttr, BuiltinType, Const, Field,\n-    Function, Local, MacroDef, ModuleDef, Static, Struct, ToolModule, Trait, Type, TypeAlias,\n-    Variant,\n+    Function, Local, Macro, ModuleDef, Static, Struct, ToolModule, Trait, Type, TypeAlias, Variant,\n };\n use base_db::CrateId;\n \n@@ -248,7 +248,7 @@ impl SourceAnalyzer {\n         &self,\n         db: &dyn HirDatabase,\n         macro_call: InFile<&ast::MacroCall>,\n-    ) -> Option<MacroDef> {\n+    ) -> Option<Macro> {\n         let ctx = body::LowerCtx::new(db.upcast(), macro_call.file_id);\n         let path = macro_call.value.path().and_then(|ast| Path::from_src(ast, &ctx))?;\n         self.resolver.resolve_path_as_macro(db.upcast(), path.mod_path()).map(|it| it.into())\n@@ -371,7 +371,7 @@ impl SourceAnalyzer {\n                 return builtin.map(PathResolution::BuiltinAttr);\n             }\n             return match resolve_hir_path_as_macro(db, &self.resolver, &hir_path) {\n-                Some(m) => Some(PathResolution::Macro(m)),\n+                Some(m) => Some(PathResolution::Def(ModuleDef::Macro(m))),\n                 // this labels any path that starts with a tool module as the tool itself, this is technically wrong\n                 // but there is no benefit in differentiating these two cases for the time being\n                 None => path.first_segment().and_then(|it| it.name_ref()).and_then(|name_ref| {\n@@ -453,7 +453,9 @@ impl SourceAnalyzer {\n     ) -> Option<HirFileId> {\n         let krate = self.resolver.krate()?;\n         let macro_call_id = macro_call.as_call_id(db.upcast(), krate, |path| {\n-            self.resolver.resolve_path_as_macro(db.upcast(), &path)\n+            self.resolver\n+                .resolve_path_as_macro(db.upcast(), &path)\n+                .map(|it| macro_id_to_def_id(db.upcast(), it))\n         })?;\n         Some(macro_call_id.as_file()).filter(|it| it.expansion_level(db.upcast()) < 64)\n     }\n@@ -571,7 +573,7 @@ pub(crate) fn resolve_hir_path_as_macro(\n     db: &dyn HirDatabase,\n     resolver: &Resolver,\n     path: &Path,\n-) -> Option<MacroDef> {\n+) -> Option<Macro> {\n     resolver.resolve_path_as_macro(db.upcast(), path.mod_path()).map(Into::into)\n }\n \n@@ -666,7 +668,7 @@ fn resolve_hir_path_(\n     let macros = || {\n         resolver\n             .resolve_path_as_macro(db.upcast(), path.mod_path())\n-            .map(|def| PathResolution::Macro(def.into()))\n+            .map(|def| PathResolution::Def(ModuleDef::Macro(def.into())))\n     };\n \n     if prefer_value_ns { values().or_else(types) } else { types().or_else(values) }"}, {"sha": "11dccbe8a6d139fc66b696f8208286742400ef9c", "filename": "crates/hir/src/symbols.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c04b0f435b4d2b29147bcfc33cdd42639e68fc00/crates%2Fhir%2Fsrc%2Fsymbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c04b0f435b4d2b29147bcfc33cdd42639e68fc00/crates%2Fhir%2Fsrc%2Fsymbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsymbols.rs?ref=c04b0f435b4d2b29147bcfc33cdd42639e68fc00", "patch": "@@ -4,13 +4,13 @@ use base_db::FileRange;\n use either::Either;\n use hir_def::{\n     item_tree::ItemTreeNode, src::HasSource, AdtId, AssocItemId, AssocItemLoc, DefWithBodyId,\n-    ImplId, ItemContainerId, ItemLoc, Lookup, ModuleDefId, ModuleId, TraitId,\n+    ImplId, ItemContainerId, Lookup, MacroId, ModuleDefId, ModuleId, TraitId,\n };\n use hir_expand::{HirFileId, InFile};\n use hir_ty::db::HirDatabase;\n use syntax::{ast::HasName, AstNode, SmolStr, SyntaxNode, SyntaxNodePtr};\n \n-use crate::{HasSource as _, MacroDef, Module, Semantics};\n+use crate::{HasSource as _, Macro, Module, Semantics};\n \n /// The actual data that is stored in the index. It should be as compact as\n /// possible.\n@@ -157,6 +157,11 @@ impl<'a> SymbolCollector<'a> {\n                 ModuleDefId::TypeAliasId(id) => {\n                     self.push_decl_assoc(id, FileSymbolKind::TypeAlias);\n                 }\n+                ModuleDefId::MacroId(id) => match id {\n+                    MacroId::Macro2Id(id) => self.push_decl(id, FileSymbolKind::Macro),\n+                    MacroId::MacroRulesId(id) => self.push_decl(id, FileSymbolKind::Macro),\n+                    MacroId::ProcMacroId(id) => self.push_decl(id, FileSymbolKind::Macro),\n+                },\n                 // Don't index these.\n                 ModuleDefId::BuiltinType(_) => {}\n                 ModuleDefId::EnumVariantId(_) => {}\n@@ -283,11 +288,11 @@ impl<'a> SymbolCollector<'a> {\n         })\n     }\n \n-    fn push_decl<L, T>(&mut self, id: L, kind: FileSymbolKind)\n+    fn push_decl<L>(&mut self, id: L, kind: FileSymbolKind)\n     where\n-        L: Lookup<Data = ItemLoc<T>>,\n-        T: ItemTreeNode,\n-        <T as ItemTreeNode>::Source: HasName,\n+        L: Lookup,\n+        <L as Lookup>::Data: HasSource,\n+        <<L as Lookup>::Data as HasSource>::Value: HasName,\n     {\n         self.push_file_symbol(|s| {\n             let loc = id.lookup(s.db.upcast());\n@@ -328,7 +333,7 @@ impl<'a> SymbolCollector<'a> {\n         })\n     }\n \n-    fn push_decl_macro(&mut self, macro_def: MacroDef) {\n+    fn push_decl_macro(&mut self, macro_def: Macro) {\n         self.push_file_symbol(|s| {\n             let name = macro_def.name(s.db)?.as_text()?;\n             let source = macro_def.source(s.db)?;"}]}