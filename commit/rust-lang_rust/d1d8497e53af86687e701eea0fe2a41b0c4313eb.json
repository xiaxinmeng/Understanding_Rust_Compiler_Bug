{"sha": "d1d8497e53af86687e701eea0fe2a41b0c4313eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxZDg0OTdlNTNhZjg2Njg3ZTcwMWVlYTBmZTJhNDFiMGM0MzEzZWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-18T18:41:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-18T18:41:23Z"}, "message": "auto merge of #13588 : alexcrichton/rust/no-more-growing, r=thestinger\n\nThis is all in preparation for DST. This removes all the growable/shrinkable methods from `~[T]`.", "tree": {"sha": "ac2ffc0405647555976c3b6b90e98a4e9398eb11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac2ffc0405647555976c3b6b90e98a4e9398eb11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1d8497e53af86687e701eea0fe2a41b0c4313eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1d8497e53af86687e701eea0fe2a41b0c4313eb", "html_url": "https://github.com/rust-lang/rust/commit/d1d8497e53af86687e701eea0fe2a41b0c4313eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1d8497e53af86687e701eea0fe2a41b0c4313eb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce2bab68d69ee04e17c0165dbdb7b583d5a7c991", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce2bab68d69ee04e17c0165dbdb7b583d5a7c991", "html_url": "https://github.com/rust-lang/rust/commit/ce2bab68d69ee04e17c0165dbdb7b583d5a7c991"}, {"sha": "675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "url": "https://api.github.com/repos/rust-lang/rust/commits/675b82657e7d9fd4c824ff3c6dbead1edd1ab515", "html_url": "https://github.com/rust-lang/rust/commit/675b82657e7d9fd4c824ff3c6dbead1edd1ab515"}], "stats": {"total": 1649, "additions": 483, "deletions": 1166}, "files": [{"sha": "17b5aa4a83af3a0bdc39a4a2b884b50dccf29ae8", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -33,7 +33,6 @@ use std::os;\n use std::str;\n use std::strbuf::StrBuf;\n use std::task;\n-use std::slice;\n use test::MetricMap;\n \n pub fn run(config: config, testfile: ~str) {\n@@ -509,7 +508,7 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n                          proc_res: &ProcRes) {\n \n     // true if we found the error in question\n-    let mut found_flags = slice::from_elem(\n+    let mut found_flags = Vec::from_elem(\n         expected_errors.len(), false);\n \n     if proc_res.status.success() {\n@@ -554,13 +553,13 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n     for line in proc_res.stderr.lines() {\n         let mut was_expected = false;\n         for (i, ee) in expected_errors.iter().enumerate() {\n-            if !found_flags[i] {\n+            if !*found_flags.get(i) {\n                 debug!(\"prefix={} ee.kind={} ee.msg={} line={}\",\n                        *prefixes.get(i), ee.kind, ee.msg, line);\n                 if prefix_matches(line, *prefixes.get(i)) &&\n                     line.contains(ee.kind) &&\n                     line.contains(ee.msg) {\n-                    found_flags[i] = true;\n+                    *found_flags.get_mut(i) = true;\n                     was_expected = true;\n                     break;\n                 }"}, {"sha": "5dd58ccb61d9c1fddc68c2ef2c52b946aa8fe1f2", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -255,10 +255,9 @@ might look like the example below.\n \n ~~~\n # use std::task::spawn;\n-# use std::slice;\n \n // Create a vector of ports, one for each child task\n-let rxs = slice::from_fn(3, |init_val| {\n+let rxs = Vec::from_fn(3, |init_val| {\n     let (tx, rx) = channel();\n     spawn(proc() {\n         tx.send(some_expensive_computation(init_val));\n@@ -304,7 +303,6 @@ be distributed on the available cores.\n \n ~~~\n # extern crate sync;\n-# use std::slice;\n fn partial_sum(start: uint) -> f64 {\n     let mut local_sum = 0f64;\n     for num in range(start*100000, (start+1)*100000) {\n@@ -314,7 +312,7 @@ fn partial_sum(start: uint) -> f64 {\n }\n \n fn main() {\n-    let mut futures = slice::from_fn(1000, |ind| sync::Future::spawn( proc() { partial_sum(ind) }));\n+    let mut futures = Vec::from_fn(1000, |ind| sync::Future::spawn( proc() { partial_sum(ind) }));\n \n     let mut final_res = 0f64;\n     for ft in futures.mut_iter()  {\n@@ -342,25 +340,24 @@ a single large vector of floats. Each task needs the full vector to perform its\n extern crate rand;\n extern crate sync;\n \n-use std::slice;\n use sync::Arc;\n \n-fn pnorm(nums: &~[f64], p: uint) -> f64 {\n+fn pnorm(nums: &[f64], p: uint) -> f64 {\n     nums.iter().fold(0.0, |a,b| a+(*b).powf(&(p as f64)) ).powf(&(1.0 / (p as f64)))\n }\n \n fn main() {\n-    let numbers = slice::from_fn(1000000, |_| rand::random::<f64>());\n+    let numbers = Vec::from_fn(1000000, |_| rand::random::<f64>());\n     let numbers_arc = Arc::new(numbers);\n \n     for num in range(1u, 10) {\n         let (tx, rx) = channel();\n         tx.send(numbers_arc.clone());\n \n         spawn(proc() {\n-            let local_arc : Arc<~[f64]> = rx.recv();\n+            let local_arc : Arc<Vec<f64>> = rx.recv();\n             let task_numbers = &*local_arc;\n-            println!(\"{}-norm = {}\", num, pnorm(task_numbers, num));\n+            println!(\"{}-norm = {}\", num, pnorm(task_numbers.as_slice(), num));\n         });\n     }\n }\n@@ -374,9 +371,8 @@ created by the line\n # extern crate sync;\n # extern crate rand;\n # use sync::Arc;\n-# use std::slice;\n # fn main() {\n-# let numbers = slice::from_fn(1000000, |_| rand::random::<f64>());\n+# let numbers = Vec::from_fn(1000000, |_| rand::random::<f64>());\n let numbers_arc=Arc::new(numbers);\n # }\n ~~~\n@@ -387,9 +383,8 @@ and a clone of it is sent to each task\n # extern crate sync;\n # extern crate rand;\n # use sync::Arc;\n-# use std::slice;\n # fn main() {\n-# let numbers=slice::from_fn(1000000, |_| rand::random::<f64>());\n+# let numbers=Vec::from_fn(1000000, |_| rand::random::<f64>());\n # let numbers_arc = Arc::new(numbers);\n # let (tx, rx) = channel();\n tx.send(numbers_arc.clone());\n@@ -404,13 +399,12 @@ Each task recovers the underlying data by\n # extern crate sync;\n # extern crate rand;\n # use sync::Arc;\n-# use std::slice;\n # fn main() {\n-# let numbers=slice::from_fn(1000000, |_| rand::random::<f64>());\n+# let numbers=Vec::from_fn(1000000, |_| rand::random::<f64>());\n # let numbers_arc=Arc::new(numbers);\n # let (tx, rx) = channel();\n # tx.send(numbers_arc.clone());\n-# let local_arc : Arc<~[f64]> = rx.recv();\n+# let local_arc : Arc<Vec<f64>> = rx.recv();\n let task_numbers = &*local_arc;\n # }\n ~~~"}, {"sha": "336f296ba2503d98704d93fe9e6acf0a1f50519f", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -1582,12 +1582,12 @@ the elements are mutable if the vector is mutable.\n use std::strbuf::StrBuf;\n \n // A dynamically sized vector (unique vector)\n-let mut numbers = ~[1, 2, 3];\n+let mut numbers = vec![1, 2, 3];\n numbers.push(4);\n numbers.push(5);\n \n // The type of a unique vector is written as `~[int]`\n-let more_numbers: ~[int] = numbers;\n+let more_numbers: ~[int] = numbers.move_iter().collect();\n \n // The original `numbers` value can no longer be used, due to move semantics.\n \n@@ -1955,8 +1955,8 @@ vector consisting of the result of applying `function` to each element\n of `vector`:\n \n ~~~~\n-fn map<T, U>(vector: &[T], function: |v: &T| -> U) -> ~[U] {\n-    let mut accumulator = ~[];\n+fn map<T, U>(vector: &[T], function: |v: &T| -> U) -> Vec<U> {\n+    let mut accumulator = Vec::new();\n     for element in vector.iter() {\n         accumulator.push(function(element));\n     }"}, {"sha": "71944202205ffcd47118e3f6e524f3c8ad739fcd", "filename": "src/libnative/io/addrinfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibnative%2Fio%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibnative%2Fio%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Faddrinfo.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -57,7 +57,7 @@ impl GetAddrInfoRequest {\n         }\n \n         // Collect all the results we found\n-        let mut addrs = ~[];\n+        let mut addrs = Vec::new();\n         let mut rp = res;\n         while rp.is_not_null() {\n             unsafe {\n@@ -80,7 +80,7 @@ impl GetAddrInfoRequest {\n \n         unsafe { freeaddrinfo(res); }\n \n-        Ok(addrs)\n+        Ok(addrs.move_iter().collect())\n     }\n }\n "}, {"sha": "d97a0430fea4b185b48155b217398a2c10e1c702", "filename": "src/libnative/io/file_unix.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibnative%2Fio%2Ffile_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibnative%2Fio%2Ffile_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_unix.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -18,7 +18,6 @@ use libc::{c_int, c_void};\n use libc;\n use std::mem;\n use std::rt::rtio;\n-use std::slice;\n \n use io::{IoResult, retry, keep_going};\n \n@@ -416,7 +415,7 @@ pub fn readlink(p: &CString) -> IoResult<Path> {\n     if len == -1 {\n         len = 1024; // FIXME: read PATH_MAX from C ffi?\n     }\n-    let mut buf = slice::with_capacity::<u8>(len as uint);\n+    let mut buf: Vec<u8> = Vec::with_capacity(len as uint);\n     match retry(|| unsafe {\n         libc::readlink(p, buf.as_ptr() as *mut libc::c_char,\n                        len as libc::size_t) as libc::c_int"}, {"sha": "385287d998e630677fba84fc96e374aa79ecf259", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -74,7 +74,7 @@ impl Process {\n             return Err(super::unimpl());\n         }\n \n-        fn get_io(io: p::StdioContainer, ret: &mut ~[Option<file::FileDesc>])\n+        fn get_io(io: p::StdioContainer, ret: &mut Vec<Option<file::FileDesc>>)\n             -> (Option<os::Pipe>, c_int)\n         {\n             match io {\n@@ -93,7 +93,7 @@ impl Process {\n             }\n         }\n \n-        let mut ret_io = ~[];\n+        let mut ret_io = Vec::new();\n         let (in_pipe, in_fd) = get_io(config.stdin, &mut ret_io);\n         let (out_pipe, out_fd) = get_io(config.stdout, &mut ret_io);\n         let (err_pipe, err_fd) = get_io(config.stderr, &mut ret_io);\n@@ -117,7 +117,7 @@ impl Process {\n                         exit_code: None,\n                         exit_signal: None,\n                     },\n-                    ret_io))\n+                    ret_io.move_iter().collect()))\n             }\n             Err(e) => Err(e)\n         }\n@@ -641,12 +641,10 @@ fn spawn_process_os(config: p::ProcessConfig,\n \n #[cfg(unix)]\n fn with_argv<T>(prog: &str, args: &[~str], cb: proc(**libc::c_char) -> T) -> T {\n-    use std::slice;\n-\n     // We can't directly convert `str`s into `*char`s, as someone needs to hold\n     // a reference to the intermediary byte buffers. So first build an array to\n     // hold all the ~[u8] byte strings.\n-    let mut tmps = slice::with_capacity(args.len() + 1);\n+    let mut tmps = Vec::with_capacity(args.len() + 1);\n \n     tmps.push(prog.to_c_str());\n \n@@ -667,14 +665,12 @@ fn with_argv<T>(prog: &str, args: &[~str], cb: proc(**libc::c_char) -> T) -> T {\n \n #[cfg(unix)]\n fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: proc(*c_void) -> T) -> T {\n-    use std::slice;\n-\n     // On posixy systems we can pass a char** for envp, which is a\n     // null-terminated array of \"k=v\\n\" strings. Like `with_argv`, we have to\n     // have a temporary buffer to hold the intermediary `~[u8]` byte strings.\n     match env {\n         Some(env) => {\n-            let mut tmps = slice::with_capacity(env.len());\n+            let mut tmps = Vec::with_capacity(env.len());\n \n             for pair in env.iter() {\n                 let kv = format!(\"{}={}\", *pair.ref0(), *pair.ref1());\n@@ -700,7 +696,7 @@ fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: |*mut c_void| -> T) -> T {\n     // \\0 to terminate.\n     match env {\n         Some(env) => {\n-            let mut blk = ~[];\n+            let mut blk = Vec::new();\n \n             for pair in env.iter() {\n                 let kv = format!(\"{}={}\", *pair.ref0(), *pair.ref1());"}, {"sha": "b96e4b06c46d3937bf6fe1d60aa2d1c3852eadd2", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -156,8 +156,6 @@ pub fn minimize_rpaths(rpaths: &[~str]) -> Vec<~str> {\n \n #[cfg(unix, test)]\n mod test {\n-    use std::os;\n-\n     use back::rpath::get_install_prefix_rpath;\n     use back::rpath::{minimize_rpaths, rpaths_to_flags, get_rpath_relative_to_output};\n     use syntax::abi;"}, {"sha": "7b1d0068035c88ca6f86bce60e2b5b898db396ee", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -223,13 +223,13 @@ pub fn describe_codegen_flags() {\n }\n \n pub fn run_compiler(args: &[~str]) {\n-    let mut args = args.to_owned();\n+    let mut args = Vec::from_slice(args);\n     let binary = args.shift().unwrap();\n \n     if args.is_empty() { usage(binary); return; }\n \n     let matches =\n-        &match getopts::getopts(args, d::optgroups().as_slice()) {\n+        &match getopts::getopts(args.as_slice(), d::optgroups().as_slice()) {\n           Ok(m) => m,\n           Err(f) => {\n             d::early_error(f.to_err_msg());"}, {"sha": "f7a30ff44599771a3502086ee319d12e82de93a3", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -18,7 +18,6 @@\n \n \n use std::io;\n-use std::slice;\n use std::strbuf::StrBuf;\n use std::uint;\n use syntax::ast;\n@@ -308,13 +307,13 @@ impl<'a, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, O> {\n                 changed: true\n             };\n \n-            let mut temp = slice::from_elem(self.words_per_id, 0u);\n+            let mut temp = Vec::from_elem(self.words_per_id, 0u);\n             let mut loop_scopes = Vec::new();\n \n             while propcx.changed {\n                 propcx.changed = false;\n-                propcx.reset(temp);\n-                propcx.walk_block(blk, temp, &mut loop_scopes);\n+                propcx.reset(temp.as_mut_slice());\n+                propcx.walk_block(blk, temp.as_mut_slice(), &mut loop_scopes);\n             }\n         }\n "}, {"sha": "4aaa9760e8941538242bfe16ce5fa77fd8cfac69", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -16,8 +16,6 @@\n  * closure.\n  */\n \n-use std::slice;\n-\n use back::abi;\n use driver::session;\n use lib::llvm::{ValueRef, NoAliasAttribute, StructRetAttribute, NoCaptureAttribute};\n@@ -221,11 +219,12 @@ fn resolve_default_method_vtables(bcx: &Block,\n         Some(vtables) => {\n             let num_impl_type_parameters =\n                 vtables.len() - num_method_vtables;\n-            vtables.tailn(num_impl_type_parameters).to_owned()\n+            Vec::from_slice(vtables.tailn(num_impl_type_parameters))\n         },\n-        None => slice::from_elem(num_method_vtables, @Vec::new())\n+        None => Vec::from_elem(num_method_vtables, @Vec::new())\n     };\n \n+    let method_vtables = method_vtables.as_slice();\n     let param_vtables = @((*trait_vtables_fixed).clone().append(method_vtables));\n \n     let self_vtables = resolve_param_vtables_under_param_substs("}, {"sha": "03b442bae218f723a5a3f2e73f746582af41eb4a", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -593,11 +593,11 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                 const_eval::const_uint(i) => i as uint,\n                 _ => cx.sess().span_bug(count.span, \"count must be integral const expression.\")\n             };\n-            let vs = slice::from_elem(n, const_expr(cx, elem, is_local).val0());\n+            let vs = Vec::from_elem(n, const_expr(cx, elem, is_local).val0());\n             let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n-                C_struct(cx, vs, false)\n+                C_struct(cx, vs.as_slice(), false)\n             } else {\n-                C_array(llunitty, vs)\n+                C_array(llunitty, vs.as_slice())\n             };\n             (v, true)\n           }"}, {"sha": "60c6c5ee97aa444bf3a09b0a6a9070fba67f2a5a", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -148,7 +148,6 @@ use collections::HashMap;\n use collections::HashSet;\n use libc::{c_uint, c_ulonglong, c_longlong};\n use std::ptr;\n-use std::slice;\n use std::strbuf::StrBuf;\n use std::sync::atomics;\n use syntax::codemap::{Span, Pos};\n@@ -776,7 +775,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n             return create_DIArray(DIB(cx), []);\n         }\n \n-        let mut signature = slice::with_capacity(fn_decl.inputs.len() + 1);\n+        let mut signature = Vec::with_capacity(fn_decl.inputs.len() + 1);\n \n         // Return type -- llvm::DIBuilder wants this at index 0\n         match fn_decl.output.node {\n@@ -818,7 +817,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n             signature.push(type_metadata(cx, arg_type, codemap::DUMMY_SP));\n         }\n \n-        return create_DIArray(DIB(cx), signature);\n+        return create_DIArray(DIB(cx), signature.as_slice());\n     }\n \n     fn get_template_parameters(cx: &CrateContext,\n@@ -961,15 +960,15 @@ fn compile_unit_metadata(cx: &CrateContext) {\n                             // prepend \"./\" if necessary\n                             let dotdot = bytes!(\"..\");\n                             let prefix = &[dotdot[0], ::std::path::SEP_BYTE];\n-                            let mut path_bytes = p.as_vec().to_owned();\n+                            let mut path_bytes = Vec::from_slice(p.as_vec());\n \n                             if path_bytes.slice_to(2) != prefix &&\n                                path_bytes.slice_to(2) != dotdot {\n                                 path_bytes.insert(0, prefix[0]);\n                                 path_bytes.insert(1, prefix[1]);\n                             }\n \n-                            path_bytes.to_c_str()\n+                            path_bytes.as_slice().to_c_str()\n                         }\n                     _ => fallback_path(cx)\n                 }"}, {"sha": "ba050e8db33fe31fe798f08ff9d7c6ff57503646", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -71,7 +71,6 @@ use util::nodemap::NodeMap;\n use middle::trans::machine::{llsize_of, llsize_of_alloc};\n use middle::trans::type_::Type;\n \n-use std::slice;\n use syntax::ast;\n use syntax::codemap;\n use syntax::print::pprust::{expr_to_str};\n@@ -969,15 +968,15 @@ fn trans_rec_or_struct<'a>(\n     let ty = node_id_type(bcx, id);\n     let tcx = bcx.tcx();\n     with_field_tys(tcx, ty, Some(id), |discr, field_tys| {\n-        let mut need_base = slice::from_elem(field_tys.len(), true);\n+        let mut need_base = Vec::from_elem(field_tys.len(), true);\n \n         let numbered_fields = fields.iter().map(|field| {\n             let opt_pos =\n                 field_tys.iter().position(|field_ty|\n                                           field_ty.ident.name == field.ident.node.name);\n             match opt_pos {\n                 Some(i) => {\n-                    need_base[i] = false;\n+                    *need_base.get_mut(i) = false;\n                     (i, field.expr)\n                 }\n                 None => {"}, {"sha": "b2529e4402607d524453086a4097e372855e5aa7", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -118,7 +118,6 @@ use std::cell::{Cell, RefCell};\n use collections::HashMap;\n use std::mem::replace;\n use std::result;\n-use std::slice;\n use std::vec::Vec;\n use syntax::abi;\n use syntax::ast::{Provided, Required};\n@@ -3906,13 +3905,13 @@ pub fn check_bounds_are_used(ccx: &CrateCtxt,\n \n     // make a vector of booleans initially false, set to true when used\n     if tps.len() == 0u { return; }\n-    let mut tps_used = slice::from_elem(tps.len(), false);\n+    let mut tps_used = Vec::from_elem(tps.len(), false);\n \n     ty::walk_ty(ty, |t| {\n             match ty::get(t).sty {\n                 ty::ty_param(param_ty {idx, ..}) => {\n                     debug!(\"Found use of ty param \\\\#{}\", idx);\n-                    tps_used[idx] = true;\n+                    *tps_used.get_mut(idx) = true;\n                 }\n                 _ => ()\n             }"}, {"sha": "a446b94027b29ff2a061ede79829ce03716be7d1", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -26,7 +26,6 @@ use util::ppaux::{Repr};\n \n use std::cell::{Cell, RefCell};\n use std::uint;\n-use std::slice;\n use collections::{HashMap, HashSet};\n use syntax::ast;\n \n@@ -1004,7 +1003,7 @@ impl<'a> RegionVarBindings<'a> {\n         // idea is to report errors that derive from independent\n         // regions of the graph, but not those that derive from\n         // overlapping locations.\n-        let mut dup_vec = slice::from_elem(self.num_vars(), uint::MAX);\n+        let mut dup_vec = Vec::from_elem(self.num_vars(), uint::MAX);\n \n         let mut opt_graph = None;\n \n@@ -1052,11 +1051,13 @@ impl<'a> RegionVarBindings<'a> {\n                     match var_data[idx].classification {\n                         Expanding => {\n                             self.collect_error_for_expanding_node(\n-                                graph, var_data, dup_vec, node_vid, errors);\n+                                graph, var_data, dup_vec.as_mut_slice(),\n+                                node_vid, errors);\n                         }\n                         Contracting => {\n                             self.collect_error_for_contracting_node(\n-                                graph, var_data, dup_vec, node_vid, errors);\n+                                graph, var_data, dup_vec.as_mut_slice(),\n+                                node_vid, errors);\n                         }\n                     }\n                 }"}, {"sha": "8fba8589d4d3848082e92b26822003f72182000a", "filename": "src/librustc/util/sha2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibrustc%2Futil%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibrustc%2Futil%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsha2.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -525,7 +525,6 @@ mod tests {\n \n     use super::{Digest, Sha256, FixedBuffer};\n     use std::num::Bounded;\n-    use std::slice;\n     use self::rand::isaac::IsaacRng;\n     use self::rand::Rng;\n     use serialize::hex::FromHex;\n@@ -600,7 +599,7 @@ mod tests {\n     /// correct.\n     fn test_digest_1million_random<D: Digest>(digest: &mut D, blocksize: uint, expected: &str) {\n         let total_size = 1000000;\n-        let buffer = slice::from_elem(blocksize * 2, 'a' as u8);\n+        let buffer = Vec::from_elem(blocksize * 2, 'a' as u8);\n         let mut rng = IsaacRng::new_unseeded();\n         let mut count = 0;\n "}, {"sha": "1fb43c34b4e23aa15f9cdd34832594bc98e33302", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -38,7 +38,6 @@ use std::fmt;\n use std::io::{fs, File, BufferedWriter, MemWriter, BufferedReader};\n use std::io;\n use std::local_data;\n-use std::slice;\n use std::str;\n use std::strbuf::StrBuf;\n \n@@ -1047,7 +1046,7 @@ fn item_module(w: &mut Writer, cx: &Context,\n                item: &clean::Item, items: &[clean::Item]) -> fmt::Result {\n     try!(document(w, item));\n     debug!(\"{:?}\", items);\n-    let mut indices = slice::from_fn(items.len(), |i| i);\n+    let mut indices = Vec::from_fn(items.len(), |i| i);\n \n     fn cmp(i1: &clean::Item, i2: &clean::Item, idx1: uint, idx2: uint) -> Ordering {\n         if shortty(i1) == shortty(i2) {"}, {"sha": "30582fb0e41e21e0e596e76a3c43e42700ba3646", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -169,8 +169,8 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n \n fn maketest(s: &str, cratename: &str, loose_feature_gating: bool) -> ~str {\n     let mut prog = StrBuf::from_str(r\"\n-#![deny(warnings)];\n-#![allow(unused_variable, dead_assignment, unused_mut, attribute_usage, dead_code)];\n+#![deny(warnings)]\n+#![allow(unused_variable, dead_assignment, unused_mut, attribute_usage, dead_code)]\n \");\n \n     if loose_feature_gating {"}, {"sha": "94a084fe055aefee17ba157532e4188b4de35219", "filename": "src/librustuv/addrinfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibrustuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibrustuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faddrinfo.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -138,7 +138,7 @@ pub fn accum_addrinfo(addr: &Addrinfo) -> ~[ai::Info] {\n     unsafe {\n         let mut addr = addr.handle;\n \n-        let mut addrs = ~[];\n+        let mut addrs = Vec::new();\n         loop {\n             let rustaddr = net::sockaddr_to_addr(cast::transmute((*addr).ai_addr),\n                                                  (*addr).ai_addrlen as uint);\n@@ -180,6 +180,6 @@ pub fn accum_addrinfo(addr: &Addrinfo) -> ~[ai::Info] {\n             }\n         }\n \n-        return addrs;\n+        return addrs.move_iter().collect();\n     }\n }"}, {"sha": "cde5cfa97c1d751f86a84901c0305001ee3f3418", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -469,7 +469,6 @@ mod test {\n     use libc::{O_CREAT, O_RDWR, O_RDONLY, S_IWUSR, S_IRUSR};\n     use std::io;\n     use std::str;\n-    use std::slice;\n     use super::FsRequest;\n     use super::super::Loop;\n     use super::super::local_loop;\n@@ -505,8 +504,8 @@ mod test {\n             let fd = result.fd;\n \n             // read\n-            let mut read_mem = slice::from_elem(1000, 0u8);\n-            let result = FsRequest::read(l(), fd, read_mem, 0);\n+            let mut read_mem = Vec::from_elem(1000, 0u8);\n+            let result = FsRequest::read(l(), fd, read_mem.as_mut_slice(), 0);\n             assert!(result.is_ok());\n \n             let nread = result.unwrap();"}, {"sha": "7b5b5d3235ba0a916fa026c75b43e19cfe69ee8f", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -15,7 +15,6 @@ use libc;\n use std::ptr;\n use std::rt::rtio::RtioProcess;\n use std::rt::task::BlockedTask;\n-use std::slice;\n \n use homing::{HomingIO, HomeHandle};\n use pipe::PipeWatcher;\n@@ -44,12 +43,12 @@ impl Process {\n                 -> Result<(~Process, ~[Option<PipeWatcher>]), UvError>\n     {\n         let cwd = config.cwd.map(|s| s.to_c_str());\n-        let mut io = ~[config.stdin, config.stdout, config.stderr];\n+        let mut io = vec![config.stdin, config.stdout, config.stderr];\n         for slot in config.extra_io.iter() {\n             io.push(*slot);\n         }\n-        let mut stdio = slice::with_capacity::<uvll::uv_stdio_container_t>(io.len());\n-        let mut ret_io = slice::with_capacity(io.len());\n+        let mut stdio = Vec::<uvll::uv_stdio_container_t>::with_capacity(io.len());\n+        let mut ret_io = Vec::with_capacity(io.len());\n         unsafe {\n             stdio.set_len(io.len());\n             for (slot, other) in stdio.iter().zip(io.iter()) {\n@@ -104,7 +103,7 @@ impl Process {\n         });\n \n         match ret {\n-            Ok(p) => Ok((p, ret_io)),\n+            Ok(p) => Ok((p, ret_io.move_iter().collect())),\n             Err(e) => Err(e),\n         }\n     }\n@@ -167,14 +166,14 @@ unsafe fn set_stdio(dst: *uvll::uv_stdio_container_t,\n fn with_argv<T>(prog: &str, args: &[~str], f: |**libc::c_char| -> T) -> T {\n     // First, allocation space to put all the C-strings (we need to have\n     // ownership of them somewhere\n-    let mut c_strs = slice::with_capacity(args.len() + 1);\n+    let mut c_strs = Vec::with_capacity(args.len() + 1);\n     c_strs.push(prog.to_c_str());\n     for arg in args.iter() {\n         c_strs.push(arg.to_c_str());\n     }\n \n     // Next, create the char** array\n-    let mut c_args = slice::with_capacity(c_strs.len() + 1);\n+    let mut c_args = Vec::with_capacity(c_strs.len() + 1);\n     for s in c_strs.iter() {\n         c_args.push(s.with_ref(|p| p));\n     }\n@@ -189,11 +188,11 @@ fn with_env<T>(env: Option<&[(~str, ~str)]>, f: |**libc::c_char| -> T) -> T {\n         None => { return f(ptr::null()); }\n     };\n     // As with argv, create some temporary storage and then the actual array\n-    let mut envp = slice::with_capacity(env.len());\n+    let mut envp = Vec::with_capacity(env.len());\n     for &(ref key, ref value) in env.iter() {\n         envp.push(format!(\"{}={}\", *key, *value).to_c_str());\n     }\n-    let mut c_envp = slice::with_capacity(envp.len() + 1);\n+    let mut c_envp = Vec::with_capacity(envp.len() + 1);\n     for s in envp.iter() {\n         c_envp.push(s.with_ref(|p| p));\n     }"}, {"sha": "92622e6c59fa3515f404e985648491a9dc300ab9", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -79,7 +79,7 @@ impl<'a> ToBase64 for &'a [u8] {\n             UrlSafe => URLSAFE_CHARS\n         };\n \n-        let mut v: ~[u8] = ~[];\n+        let mut v = Vec::new();\n         let mut i = 0;\n         let mut cur_length = 0;\n         let len = self.len();\n@@ -146,7 +146,7 @@ impl<'a> ToBase64 for &'a [u8] {\n         }\n \n         unsafe {\n-            str::raw::from_utf8_owned(v)\n+            str::raw::from_utf8_owned(v.move_iter().collect())\n         }\n     }\n }\n@@ -208,7 +208,7 @@ impl<'a> FromBase64 for &'a str {\n      * ```\n      */\n     fn from_base64(&self) -> Result<~[u8], FromBase64Error> {\n-        let mut r = ~[];\n+        let mut r = Vec::new();\n         let mut buf: u32 = 0;\n         let mut modulus = 0;\n \n@@ -256,7 +256,7 @@ impl<'a> FromBase64 for &'a str {\n             _ => return Err(InvalidBase64Length),\n         }\n \n-        Ok(r)\n+        Ok(r.move_iter().collect())\n     }\n }\n \n@@ -337,12 +337,12 @@ mod tests {\n     #[test]\n     fn test_base64_random() {\n         use self::rand::{task_rng, random, Rng};\n-        use std::slice;\n \n         for _ in range(0, 1000) {\n             let times = task_rng().gen_range(1u, 100);\n-            let v = slice::from_fn(times, |_| random::<u8>());\n-            assert_eq!(v.to_base64(STANDARD).from_base64().unwrap(), v);\n+            let v = Vec::from_fn(times, |_| random::<u8>());\n+            assert_eq!(v.as_slice().to_base64(STANDARD).from_base64().unwrap(),\n+                       v.as_slice().to_owned());\n         }\n     }\n "}, {"sha": "486150f1741f6f9386fc0673f2ff6450c62f906b", "filename": "src/libserialize/ebml.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibserialize%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibserialize%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Febml.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -1099,8 +1099,7 @@ mod bench {\n \n     #[bench]\n     pub fn vuint_at_A_aligned(b: &mut Bencher) {\n-        use std::slice;\n-        let data = slice::from_fn(4*100, |i| {\n+        let data = Vec::from_fn(4*100, |i| {\n             match i % 2 {\n               0 => 0x80u8,\n               _ => i as u8,\n@@ -1110,16 +1109,15 @@ mod bench {\n         b.iter(|| {\n             let mut i = 0;\n             while i < data.len() {\n-                sum += reader::vuint_at(data, i).unwrap().val;\n+                sum += reader::vuint_at(data.as_slice(), i).unwrap().val;\n                 i += 4;\n             }\n         });\n     }\n \n     #[bench]\n     pub fn vuint_at_A_unaligned(b: &mut Bencher) {\n-        use std::slice;\n-        let data = slice::from_fn(4*100+1, |i| {\n+        let data = Vec::from_fn(4*100+1, |i| {\n             match i % 2 {\n               1 => 0x80u8,\n               _ => i as u8\n@@ -1129,16 +1127,15 @@ mod bench {\n         b.iter(|| {\n             let mut i = 1;\n             while i < data.len() {\n-                sum += reader::vuint_at(data, i).unwrap().val;\n+                sum += reader::vuint_at(data.as_slice(), i).unwrap().val;\n                 i += 4;\n             }\n         });\n     }\n \n     #[bench]\n     pub fn vuint_at_D_aligned(b: &mut Bencher) {\n-        use std::slice;\n-        let data = slice::from_fn(4*100, |i| {\n+        let data = Vec::from_fn(4*100, |i| {\n             match i % 4 {\n               0 => 0x10u8,\n               3 => i as u8,\n@@ -1149,16 +1146,15 @@ mod bench {\n         b.iter(|| {\n             let mut i = 0;\n             while i < data.len() {\n-                sum += reader::vuint_at(data, i).unwrap().val;\n+                sum += reader::vuint_at(data.as_slice(), i).unwrap().val;\n                 i += 4;\n             }\n         });\n     }\n \n     #[bench]\n     pub fn vuint_at_D_unaligned(b: &mut Bencher) {\n-        use std::slice;\n-        let data = slice::from_fn(4*100+1, |i| {\n+        let data = Vec::from_fn(4*100+1, |i| {\n             match i % 4 {\n               1 => 0x10u8,\n               0 => i as u8,\n@@ -1169,7 +1165,7 @@ mod bench {\n         b.iter(|| {\n             let mut i = 1;\n             while i < data.len() {\n-                sum += reader::vuint_at(data, i).unwrap().val;\n+                sum += reader::vuint_at(data.as_slice(), i).unwrap().val;\n                 i += 4;\n             }\n         });"}, {"sha": "fa383bef2dc530763e344c795ece43066288ac64", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -10,7 +10,6 @@\n \n //! Hex binary-to-text encoding\n use std::str;\n-use std::slice;\n use std::fmt;\n \n /// A trait for converting a value to hexadecimal encoding\n@@ -39,14 +38,14 @@ impl<'a> ToHex for &'a [u8] {\n      * ```\n      */\n     fn to_hex(&self) -> ~str {\n-        let mut v = slice::with_capacity(self.len() * 2);\n+        let mut v = Vec::with_capacity(self.len() * 2);\n         for &byte in self.iter() {\n             v.push(CHARS[(byte >> 4) as uint]);\n             v.push(CHARS[(byte & 0xf) as uint]);\n         }\n \n         unsafe {\n-            str::raw::from_utf8_owned(v)\n+            str::raw::from_utf8_owned(v.move_iter().collect())\n         }\n     }\n }\n@@ -106,7 +105,7 @@ impl<'a> FromHex for &'a str {\n      */\n     fn from_hex(&self) -> Result<~[u8], FromHexError> {\n         // This may be an overestimate if there is any whitespace\n-        let mut b = slice::with_capacity(self.len() / 2);\n+        let mut b = Vec::with_capacity(self.len() / 2);\n         let mut modulus = 0;\n         let mut buf = 0u8;\n \n@@ -132,7 +131,7 @@ impl<'a> FromHex for &'a str {\n         }\n \n         match modulus {\n-            0 => Ok(b),\n+            0 => Ok(b.move_iter().collect()),\n             _ => Err(InvalidHexLength),\n         }\n     }"}, {"sha": "606f2b12af1635e88e49fa4f9946f6cfbfbb2851", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -1230,11 +1230,11 @@ impl<T : Iterator<char>> Parser<T> {\n         self.bump();\n         self.parse_whitespace();\n \n-        let mut values = ~[];\n+        let mut values = Vec::new();\n \n         if self.ch_is(']') {\n             self.bump();\n-            return Ok(List(values));\n+            return Ok(List(values.move_iter().collect()));\n         }\n \n         loop {\n@@ -1252,7 +1252,7 @@ impl<T : Iterator<char>> Parser<T> {\n                 self.bump();\n             } else if self.ch_is(']') {\n                 self.bump();\n-                return Ok(List(values));\n+                return Ok(List(values.move_iter().collect()));\n             } else {\n                 return self.error(~\"expected `,` or `]`\")\n             }\n@@ -1332,14 +1332,14 @@ pub fn from_str(s: &str) -> DecodeResult<Json> {\n \n /// A structure to decode JSON to values in rust.\n pub struct Decoder {\n-    stack: ~[Json],\n+    stack: Vec<Json>,\n }\n \n impl Decoder {\n     /// Creates a new decoder instance for decoding the specified JSON value.\n     pub fn new(json: Json) -> Decoder {\n         Decoder {\n-            stack: ~[json]\n+            stack: vec!(json),\n         }\n     }\n }"}, {"sha": "09b30077f6f64aa464cf3850250aa2c150165c1a", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -16,7 +16,6 @@ Core encoding and decoding interfaces.\n \n use std::path;\n use std::rc::Rc;\n-use std::slice;\n \n pub trait Encoder<E> {\n     // Primitive types:\n@@ -443,11 +442,15 @@ impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for ~[T] {\n impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for ~[T] {\n     fn decode(d: &mut D) -> Result<~[T], E> {\n         d.read_seq(|d, len| {\n-            let mut v: ~[T] = slice::with_capacity(len);\n+            let mut v: Vec<T> = Vec::with_capacity(len);\n             for i in range(0, len) {\n                 v.push(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n             }\n-            Ok(v)\n+            println!(\"-------\");\n+            println!(\"{}\", v.len());\n+            let k = v.move_iter().collect::<~[T]>();\n+            println!(\"{}\", k.len());\n+            Ok(k)\n         })\n     }\n }\n@@ -594,11 +597,11 @@ pub trait DecoderHelpers<E> {\n impl<E, D:Decoder<E>> DecoderHelpers<E> for D {\n     fn read_to_vec<T>(&mut self, f: |&mut D| -> Result<T, E>) -> Result<~[T], E> {\n         self.read_seq(|this, len| {\n-            let mut v = slice::with_capacity(len);\n+            let mut v = Vec::with_capacity(len);\n             for i in range(0, len) {\n                 v.push(try!(this.read_seq_elt(i, |this| f(this))));\n             }\n-            Ok(v)\n+            Ok(v.move_iter().collect())\n         })\n     }\n }"}, {"sha": "c0f1aeae26b13a6893324215a55aadb66c096727", "filename": "src/libstd/comm/shared.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fcomm%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fcomm%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fshared.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -30,7 +30,6 @@ use rt::task::{Task, BlockedTask};\n use rt::thread::Thread;\n use sync::atomics;\n use unstable::mutex::NativeMutex;\n-use slice::OwnedVector;\n \n use mpsc = sync::mpsc_queue;\n "}, {"sha": "44070dc44602003f76c9e451171c7ddf0cb6fb0f", "filename": "src/libstd/comm/stream.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fcomm%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fcomm%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fstream.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -30,7 +30,6 @@ use rt::task::{Task, BlockedTask};\n use rt::thread::Thread;\n use spsc = sync::spsc_queue;\n use sync::atomics;\n-use slice::OwnedVector;\n \n static DISCONNECTED: int = int::MIN;\n #[cfg(test)]"}, {"sha": "eee8e416231e5047a15a77ed060d021477f5b352", "filename": "src/libstd/hash/sip.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash%2Fsip.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -359,13 +359,8 @@ pub fn hash_with_keys<T: Hash<SipState>>(k0: u64, k1: u64, value: &T) -> u64 {\n #[cfg(test)]\n mod tests {\n     extern crate test;\n-    use io::Writer;\n-    use iter::Iterator;\n+    use prelude::*;\n     use num::ToStrRadix;\n-    use option::{Some, None};\n-    use str::Str;\n-    use strbuf::StrBuf;\n-    use slice::{Vector, ImmutableVector, OwnedVector};\n     use self::test::Bencher;\n \n     use super::super::Hash;\n@@ -454,7 +449,7 @@ mod tests {\n \n         let k0 = 0x_07_06_05_04_03_02_01_00_u64;\n         let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08_u64;\n-        let mut buf : ~[u8] = ~[];\n+        let mut buf = Vec::new();\n         let mut t = 0;\n         let mut state_inc = SipState::new_with_keys(k0, k1);\n         let mut state_full = SipState::new_with_keys(k0, k1);\n@@ -496,7 +491,7 @@ mod tests {\n             assert_eq!(vec, out);\n \n             state_full.reset();\n-            state_full.write(buf);\n+            state_full.write(buf.as_slice());\n             let f = result_str(state_full.result());\n             let i = result_str(state_inc.result());\n             let v = to_hex_str(&vecs[t]);"}, {"sha": "c541eb91d06bbdcfd02a6efbec9444f42eec0175", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -17,7 +17,7 @@ use iter::ExactSize;\n use ops::Drop;\n use option::{Some, None, Option};\n use result::{Ok, Err};\n-use slice::{OwnedVector, ImmutableVector, MutableVector};\n+use slice::{ImmutableVector, MutableVector};\n use slice;\n use vec::Vec;\n \n@@ -391,7 +391,7 @@ mod test {\n \n     /// A dummy reader intended at testing short-reads propagation.\n     pub struct ShortReader {\n-        lengths: ~[uint],\n+        lengths: Vec<uint>,\n     }\n \n     impl Reader for ShortReader {\n@@ -554,7 +554,7 @@ mod test {\n \n     #[test]\n     fn test_short_reads() {\n-        let inner = ShortReader{lengths: ~[0, 1, 2, 0, 1, 0]};\n+        let inner = ShortReader{lengths: vec![0, 1, 2, 0, 1, 0]};\n         let mut reader = BufferedReader::new(inner);\n         let mut buf = [0, 0];\n         assert_eq!(reader.read(buf), Ok(0));"}, {"sha": "955d4c07d28b871906c8a7955f449eb5634a0402", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -21,7 +21,7 @@ use option::{Option, Some, None};\n use result::{Ok, Err};\n use io;\n use io::{IoError, IoResult, Reader};\n-use slice::{OwnedVector, ImmutableVector, Vector};\n+use slice::{ImmutableVector, Vector};\n use ptr::RawPtr;\n \n /// An iterator that reads a single byte on each iteration,\n@@ -503,21 +503,22 @@ mod test {\n #[cfg(test)]\n mod bench {\n     extern crate test;\n-    use self::test::Bencher;\n+\n     use container::Container;\n+    use prelude::*;\n+    use self::test::Bencher;\n \n     macro_rules! u64_from_be_bytes_bench_impl(\n         ($size:expr, $stride:expr, $start_index:expr) =>\n         ({\n-            use slice;\n             use super::u64_from_be_bytes;\n \n-            let data = slice::from_fn($stride*100+$start_index, |i| i as u8);\n+            let data = Vec::from_fn($stride*100+$start_index, |i| i as u8);\n             let mut sum = 0u64;\n             b.iter(|| {\n                 let mut i = $start_index;\n                 while i < data.len() {\n-                    sum += u64_from_be_bytes(data, i, $size);\n+                    sum += u64_from_be_bytes(data.as_slice(), i, $size);\n                     i += $stride;\n                 }\n             });"}, {"sha": "aa3820bcd1ffb84c3a97c5a675758304393be74e", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -17,7 +17,7 @@ use result::{Err, Ok};\n use io;\n use io::{Reader, Writer, Seek, Buffer, IoError, SeekStyle, IoResult};\n use slice;\n-use slice::{Vector, ImmutableVector, MutableVector, OwnedCloneableVector};\n+use slice::{Vector, ImmutableVector, MutableVector};\n use vec::Vec;\n \n fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64> {"}, {"sha": "6864f18d26c567bd3bb94c8c9b25b7477707f193", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -228,11 +228,11 @@ use os;\n use option::{Option, Some, None};\n use path::Path;\n use result::{Ok, Err, Result};\n-use str::{StrSlice, OwnedStr};\n+use str::StrSlice;\n use str;\n use uint;\n use unstable::finally::try_finally;\n-use slice::{Vector, OwnedVector, MutableVector, ImmutableVector, OwnedCloneableVector};\n+use slice::{Vector, MutableVector, ImmutableVector};\n use vec::Vec;\n \n // Reexports"}, {"sha": "26ead9e1e5392a8dd3f41248b408b645f3b4db63", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -16,6 +16,7 @@ use fmt;\n use io::IoResult;\n use io;\n use libc;\n+use mem;\n use rt::rtio::{RtioProcess, IoFactory, LocalIo};\n \n /// Signal a process to exit, without forcibly killing it. Corresponds to\n@@ -416,12 +417,7 @@ impl Drop for Process {\n         drop(self.stdin.take());\n         drop(self.stdout.take());\n         drop(self.stderr.take());\n-        loop {\n-            match self.extra_io.pop() {\n-                Some(_) => (),\n-                None => break,\n-            }\n-        }\n+        drop(mem::replace(&mut self.extra_io, ~[]));\n \n         self.wait();\n     }"}, {"sha": "e7dae59acb8819c82eaea0877a7b21b55c984c5e", "filename": "src/libstd/io/signal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -28,7 +28,7 @@ use mem::drop;\n use option::{Some, None};\n use result::{Ok, Err};\n use rt::rtio::{IoFactory, LocalIo, RtioSignal};\n-use slice::{ImmutableVector, OwnedVector};\n+use slice::ImmutableVector;\n use vec::Vec;\n \n /// Signals that can be sent and received"}, {"sha": "78a66f1f7621caf9ebb4dcfde27973bf38191b6b", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -46,7 +46,7 @@ use kinds::Send;\n use mem::replace;\n use option::{None, Option, Some};\n use rt::task::{Task, LocalStorage};\n-use slice::{ImmutableVector, MutableVector, OwnedVector};\n+use slice::{ImmutableVector, MutableVector};\n use vec::Vec;\n \n /**"}, {"sha": "3228b5a1a490a34169898ed8d3cb3930046dd835", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -277,13 +277,13 @@ impl ToStrRadix for $T {\n     /// Convert to a string in a given base.\n     #[inline]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n-        let mut buf: ~[u8] = ~[];\n+        let mut buf = Vec::new();\n         strconv::int_to_str_bytes_common(*self, radix, strconv::SignNeg, |i| {\n             buf.push(i);\n         });\n         // We know we generated valid utf-8, so we don't need to go through that\n         // check.\n-        unsafe { str::raw::from_utf8_owned(buf) }\n+        unsafe { str::raw::from_utf8_owned(buf.move_iter().collect()) }\n     }\n }\n "}, {"sha": "12befed743a52123fd6ef5f196fdbe2f1dfbf719", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -1779,12 +1779,11 @@ mod bench {\n     extern crate test;\n     use self::test::Bencher;\n     use num;\n-    use slice;\n     use prelude::*;\n \n     #[bench]\n     fn bench_pow_function(b: &mut Bencher) {\n-        let v = slice::from_fn(1024, |n| n);\n+        let v = Vec::from_fn(1024, |n| n);\n         b.iter(|| {v.iter().fold(0, |old, new| num::pow(old, *new));});\n     }\n }"}, {"sha": "ffcb129d635724f7ef9b41e34c6de65383477670", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -10,19 +10,21 @@\n \n #![allow(missing_doc)]\n \n+use char;\n use clone::Clone;\n use container::Container;\n-use std::cmp::{Ord, Eq};\n+use iter::Iterator;\n+use num::{NumCast, Zero, One, cast, Int};\n+use num::{Round, Float, FPNaN, FPInfinite, ToPrimitive};\n+use num;\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use option::{None, Option, Some};\n-use char;\n+use slice::OwnedVector;\n+use slice::{CloneableVector, ImmutableVector, MutableVector};\n+use std::cmp::{Ord, Eq};\n use str::{StrSlice};\n use str;\n-use slice::{CloneableVector, ImmutableVector, MutableVector};\n-use slice::OwnedVector;\n-use num;\n-use num::{NumCast, Zero, One, cast, Int};\n-use num::{Round, Float, FPNaN, FPInfinite, ToPrimitive};\n+use vec::Vec;\n \n /// A flag that specifies whether to use exponential (scientific) notation.\n pub enum ExponentFormat {\n@@ -293,7 +295,7 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+Round+\n     }\n \n     let neg = num < _0 || (negative_zero && _1 / num == Float::neg_infinity());\n-    let mut buf: ~[u8] = ~[];\n+    let mut buf = Vec::new();\n     let radix_gen: T   = cast(radix as int).unwrap();\n \n     let (num, exp) = match exp_format {\n@@ -411,23 +413,23 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+Round+\n                     // If reached left end of number, have to\n                     // insert additional digit:\n                     if i < 0\n-                    || buf[i as uint] == '-' as u8\n-                    || buf[i as uint] == '+' as u8 {\n+                    || *buf.get(i as uint) == '-' as u8\n+                    || *buf.get(i as uint) == '+' as u8 {\n                         buf.insert((i + 1) as uint, value2ascii(1));\n                         break;\n                     }\n \n                     // Skip the '.'\n-                    if buf[i as uint] == '.' as u8 { i -= 1; continue; }\n+                    if *buf.get(i as uint) == '.' as u8 { i -= 1; continue; }\n \n                     // Either increment the digit,\n                     // or set to 0 if max and carry the 1.\n-                    let current_digit = ascii2value(buf[i as uint]);\n+                    let current_digit = ascii2value(*buf.get(i as uint));\n                     if current_digit < (radix - 1) {\n-                        buf[i as uint] = value2ascii(current_digit+1);\n+                        *buf.get_mut(i as uint) = value2ascii(current_digit+1);\n                         break;\n                     } else {\n-                        buf[i as uint] = value2ascii(0);\n+                        *buf.get_mut(i as uint) = value2ascii(0);\n                         i -= 1;\n                     }\n                 }\n@@ -444,25 +446,25 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+Round+\n         let mut i = buf_max_i;\n \n         // discover trailing zeros of fractional part\n-        while i > start_fractional_digits && buf[i] == '0' as u8 {\n+        while i > start_fractional_digits && *buf.get(i) == '0' as u8 {\n             i -= 1;\n         }\n \n         // Only attempt to truncate digits if buf has fractional digits\n         if i >= start_fractional_digits {\n             // If buf ends with '.', cut that too.\n-            if buf[i] == '.' as u8 { i -= 1 }\n+            if *buf.get(i) == '.' as u8 { i -= 1 }\n \n             // only resize buf if we actually remove digits\n             if i < buf_max_i {\n-                buf = buf.slice(0, i + 1).to_owned();\n+                buf = Vec::from_slice(buf.slice(0, i + 1));\n             }\n         }\n     } // If exact and trailing '.', just cut that\n     else {\n         let max_i = buf.len() - 1;\n-        if buf[max_i] == '.' as u8 {\n-            buf = buf.slice(0, max_i).to_owned();\n+        if *buf.get(max_i) == '.' as u8 {\n+            buf = Vec::from_slice(buf.slice(0, max_i));\n         }\n     }\n \n@@ -481,7 +483,7 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+Round+\n         }\n     }\n \n-    (buf, false)\n+    (buf.move_iter().collect(), false)\n }\n \n /**"}, {"sha": "61723f339ae1438fc8af4e97b1d056b457713ea0", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -191,13 +191,13 @@ impl ToStrRadix for $T {\n     /// Convert to a string in a given base.\n     #[inline]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n-        let mut buf = ~[];\n+        let mut buf = Vec::new();\n         strconv::int_to_str_bytes_common(*self, radix, strconv::SignNone, |i| {\n             buf.push(i);\n         });\n         // We know we generated valid utf-8, so we don't need to go through that\n         // check.\n-        unsafe { str::raw::from_utf8_owned(buf) }\n+        unsafe { str::raw::from_utf8_owned(buf.move_iter().collect()) }\n     }\n }\n "}, {"sha": "dbb9530487397df15ecd3bec96fff1da0fed4831", "filename": "src/libstd/os.rs", "status": "modified", "additions": 31, "deletions": 39, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -28,10 +28,6 @@\n \n #![allow(missing_doc)]\n \n-#[cfg(target_os = \"macos\")]\n-#[cfg(windows)]\n-use iter::range;\n-\n use clone::Clone;\n use container::Container;\n use libc;\n@@ -49,6 +45,7 @@ use path::{Path, GenericPath};\n use iter::Iterator;\n use slice::{Vector, CloneableVector, ImmutableVector, MutableVector, OwnedVector};\n use ptr::RawPtr;\n+use vec::Vec;\n \n #[cfg(unix)]\n use c_str::ToCStr;\n@@ -96,15 +93,16 @@ pub fn getcwd() -> Path {\n \n #[cfg(windows)]\n pub mod win32 {\n+    use iter::Iterator;\n     use libc::types::os::arch::extra::DWORD;\n     use libc;\n     use option::{None, Option};\n     use option;\n     use os::TMPBUF_SZ;\n+    use slice::{MutableVector, ImmutableVector, OwnedVector};\n     use str::StrSlice;\n     use str;\n-    use slice::{MutableVector, ImmutableVector, OwnedVector};\n-    use slice;\n+    use vec::Vec;\n \n     pub fn fill_utf16_buf_and_decode(f: |*mut u16, DWORD| -> DWORD)\n         -> Option<~str> {\n@@ -114,7 +112,7 @@ pub mod win32 {\n             let mut res = None;\n             let mut done = false;\n             while !done {\n-                let mut buf = slice::from_elem(n as uint, 0u16);\n+                let mut buf = Vec::from_elem(n as uint, 0u16);\n                 let k = f(buf.as_mut_ptr(), n);\n                 if k == (0 as DWORD) {\n                     done = true;\n@@ -142,7 +140,7 @@ pub mod win32 {\n     }\n \n     pub fn as_utf16_p<T>(s: &str, f: |*u16| -> T) -> T {\n-        let mut t = s.to_utf16();\n+        let mut t = s.to_utf16().move_iter().collect::<Vec<u16>>();\n         // Null terminate before passing on.\n         t.push(0u16);\n         f(t.as_ptr())\n@@ -182,7 +180,7 @@ pub fn env() -> ~[(~str,~str)] {\n pub fn env_as_bytes() -> ~[(~[u8],~[u8])] {\n     unsafe {\n         #[cfg(windows)]\n-        unsafe fn get_env_pairs() -> ~[~[u8]] {\n+        unsafe fn get_env_pairs() -> Vec<~[u8]> {\n             use c_str;\n             use str::StrSlice;\n \n@@ -195,15 +193,15 @@ pub fn env_as_bytes() -> ~[(~[u8],~[u8])] {\n                 fail!(\"os::env() failure getting env string from OS: {}\",\n                        os::last_os_error());\n             }\n-            let mut result = ~[];\n+            let mut result = Vec::new();\n             c_str::from_c_multistring(ch as *c_char, None, |cstr| {\n                 result.push(cstr.as_bytes_no_nul().to_owned());\n             });\n             FreeEnvironmentStringsA(ch);\n             result\n         }\n         #[cfg(unix)]\n-        unsafe fn get_env_pairs() -> ~[~[u8]] {\n+        unsafe fn get_env_pairs() -> Vec<~[u8]> {\n             use c_str::CString;\n \n             extern {\n@@ -214,16 +212,16 @@ pub fn env_as_bytes() -> ~[(~[u8],~[u8])] {\n                 fail!(\"os::env() failure getting env string from OS: {}\",\n                        os::last_os_error());\n             }\n-            let mut result = ~[];\n+            let mut result = Vec::new();\n             ptr::array_each(environ, |e| {\n                 let env_pair = CString::new(e, false).as_bytes_no_nul().to_owned();\n                 result.push(env_pair);\n             });\n             result\n         }\n \n-        fn env_convert(input: ~[~[u8]]) -> ~[(~[u8], ~[u8])] {\n-            let mut pairs = ~[];\n+        fn env_convert(input: Vec<~[u8]>) -> Vec<(~[u8], ~[u8])> {\n+            let mut pairs = Vec::new();\n             for p in input.iter() {\n                 let vs: ~[&[u8]] = p.splitn(1, |b| *b == '=' as u8).collect();\n                 let key = vs[0].to_owned();\n@@ -234,7 +232,7 @@ pub fn env_as_bytes() -> ~[(~[u8],~[u8])] {\n         }\n         with_env_lock(|| {\n             let unparsed_environ = get_env_pairs();\n-            env_convert(unparsed_environ)\n+            env_convert(unparsed_environ).move_iter().collect()\n         })\n     }\n }\n@@ -457,15 +455,14 @@ pub fn self_exe_name() -> Option<Path> {\n     fn load_self() -> Option<~[u8]> {\n         unsafe {\n             use libc::funcs::extra::_NSGetExecutablePath;\n-            use slice;\n             let mut sz: u32 = 0;\n             _NSGetExecutablePath(ptr::mut_null(), &mut sz);\n             if sz == 0 { return None; }\n-            let mut v: ~[u8] = slice::with_capacity(sz as uint);\n+            let mut v: Vec<u8> = Vec::with_capacity(sz as uint);\n             let err = _NSGetExecutablePath(v.as_mut_ptr() as *mut i8, &mut sz);\n             if err != 0 { return None; }\n             v.set_len(sz as uint - 1); // chop off trailing NUL\n-            Some(v)\n+            Some(v.move_iter().collect())\n         }\n     }\n \n@@ -795,11 +792,9 @@ pub fn get_exit_status() -> int {\n unsafe fn load_argc_and_argv(argc: int, argv: **c_char) -> ~[~[u8]] {\n     use c_str::CString;\n \n-    let mut args = ~[];\n-    for i in range(0u, argc as uint) {\n-        args.push(CString::new(*argv.offset(i as int), false).as_bytes_no_nul().to_owned())\n-    }\n-    args\n+    Vec::from_fn(argc as uint, |i| {\n+        CString::new(*argv.offset(i as int), false).as_bytes_no_nul().to_owned()\n+    }).move_iter().collect()\n }\n \n /**\n@@ -842,27 +837,24 @@ fn real_args() -> ~[~str] {\n     let lpCmdLine = unsafe { GetCommandLineW() };\n     let szArgList = unsafe { CommandLineToArgvW(lpCmdLine, lpArgCount) };\n \n-    let mut args = ~[];\n-    for i in range(0u, nArgs as uint) {\n-        unsafe {\n-            // Determine the length of this argument.\n-            let ptr = *szArgList.offset(i as int);\n-            let mut len = 0;\n-            while *ptr.offset(len as int) != 0 { len += 1; }\n-\n-            // Push it onto the list.\n-            let opt_s = slice::raw::buf_as_slice(ptr, len, |buf| {\n-                    str::from_utf16(str::truncate_utf16_at_nul(buf))\n-                });\n-            args.push(opt_s.expect(\"CommandLineToArgvW returned invalid UTF-16\"));\n-        }\n-    }\n+    let args = Vec::from_fn(nArgs as uint, |i| unsafe {\n+        // Determine the length of this argument.\n+        let ptr = *szArgList.offset(i as int);\n+        let mut len = 0;\n+        while *ptr.offset(len as int) != 0 { len += 1; }\n+\n+        // Push it onto the list.\n+        let opt_s = slice::raw::buf_as_slice(ptr, len, |buf| {\n+            str::from_utf16(str::truncate_utf16_at_nul(buf))\n+        });\n+        opt_s.expect(\"CommandLineToArgvW returned invalid UTF-16\")\n+    });\n \n     unsafe {\n         LocalFree(szArgList as *c_void);\n     }\n \n-    return args;\n+    return args.move_iter().collect();\n }\n \n #[cfg(windows)]"}, {"sha": "2960d55f337c731ea73ab334193feba9bac2ccbe", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -74,7 +74,7 @@ use option::{Option, None, Some};\n use str;\n use str::{MaybeOwned, Str, StrSlice, from_utf8_lossy};\n use strbuf::StrBuf;\n-use slice::{OwnedCloneableVector, OwnedVector, Vector};\n+use slice::Vector;\n use slice::{ImmutableEqVector, ImmutableVector};\n use vec::Vec;\n "}, {"sha": "47f9604d63fe10dc45f12b3070650b353068b688", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -21,7 +21,7 @@ use option::{Option, None, Some};\n use str;\n use str::Str;\n use slice::{CloneableVector, RevSplits, Splits, Vector, VectorVector,\n-            ImmutableEqVector, OwnedVector, ImmutableVector, OwnedCloneableVector};\n+            ImmutableEqVector, OwnedVector, ImmutableVector};\n use vec::Vec;\n \n use super::{BytesContainer, GenericPath, GenericPathUnsafe};"}, {"sha": "58c7aaa2d32aea474471c5cfb6e153220d543c11", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -21,7 +21,7 @@ use io::Writer;\n use iter::{AdditiveIterator, DoubleEndedIterator, Extendable, Rev, Iterator, Map};\n use option::{Option, Some, None};\n use slice::{Vector, OwnedVector, ImmutableVector};\n-use str::{CharSplits, OwnedStr, Str, StrVector, StrSlice};\n+use str::{CharSplits, Str, StrVector, StrSlice};\n use strbuf::StrBuf;\n use vec::Vec;\n "}, {"sha": "a44b23c42494eb7baf96bf89a9095e51b792022f", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -56,7 +56,7 @@ pub use tuple::{Tuple1, Tuple2, Tuple3, Tuple4};\n pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};\n pub use tuple::{Tuple9, Tuple10, Tuple11, Tuple12};\n pub use slice::{ImmutableEqVector, ImmutableTotalOrdVector, ImmutableCloneableVector};\n-pub use slice::{OwnedVector, OwnedCloneableVector, OwnedEqVector};\n+pub use slice::{OwnedVector};\n pub use slice::{MutableVector, MutableTotalOrdVector};\n pub use slice::{Vector, VectorVector, CloneableVector, ImmutableVector};\n pub use strbuf::StrBuf;"}, {"sha": "61461096ed9c48ee0a6462375fdc71f2860feb0d", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -170,10 +170,9 @@ pub fn mut_null<T>() -> *mut T { 0 as *mut T }\n ///\n /// ```\n /// use std::ptr;\n-/// use std::slice;\n ///\n-/// unsafe fn from_buf_raw<T>(ptr: *T, elts: uint) -> ~[T] {\n-///     let mut dst = slice::with_capacity(elts);\n+/// unsafe fn from_buf_raw<T>(ptr: *T, elts: uint) -> Vec<T> {\n+///     let mut dst = Vec::with_capacity(elts);\n ///     dst.set_len(elts);\n ///     ptr::copy_memory(dst.as_mut_ptr(), ptr, elts);\n ///     dst"}, {"sha": "61238f508c177108bc4435f856d0dca37da3a01a", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -28,7 +28,7 @@ use reflect::{MovePtr, align};\n use result::{Ok, Err};\n use str::StrSlice;\n use to_str::ToStr;\n-use slice::{Vector, OwnedVector};\n+use slice::Vector;\n use intrinsics::{Disr, Opaque, TyDesc, TyVisitor, get_tydesc, visit_tydesc};\n use raw;\n use vec::Vec;"}, {"sha": "abe2e2ab1dcf51ce923bb3b4bbfbabfcfc7162c4", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -125,13 +125,14 @@ mod imp {\n     unsafe fn load_argc_and_argv(argc: int, argv: **u8) -> ~[~[u8]] {\n         use c_str::CString;\n         use ptr::RawPtr;\n-        use {slice, libc};\n+        use libc;\n         use slice::CloneableVector;\n+        use vec::Vec;\n \n-        slice::from_fn(argc as uint, |i| {\n+        Vec::from_fn(argc as uint, |i| {\n             let cs = CString::new(*(argv as **libc::c_char).offset(i as int), false);\n             cs.as_bytes_no_nul().to_owned()\n-        })\n+        }).move_iter().collect()\n     }\n \n     #[cfg(test)]"}, {"sha": "4210b2ec670ebd5420dcda5071d1424233f3dbb8", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 218, "deletions": 834, "changes": 1052, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -54,9 +54,9 @@ An example is the method `.push(element)` that will add an element at the end\n of the vector:\n \n ```rust\n-let mut numbers = ~[0, 1, 2];\n+let mut numbers = vec![0, 1, 2];\n numbers.push(7);\n-// numbers is now ~[0, 1, 2, 7];\n+// numbers is now vec![0, 1, 2, 7];\n  ```\n \n ## Implementations of other traits\n@@ -99,117 +99,31 @@ There are a number of free functions that create or take vectors, for example:\n \n */\n \n-#![warn(non_camel_case_types)]\n-\n use cast;\n use cast::transmute;\n use ops::Drop;\n use clone::Clone;\n-use container::{Container, Mutable};\n+use container::Container;\n use cmp::{Eq, TotalOrd, Ordering, Less, Equal, Greater};\n use cmp;\n use default::Default;\n use fmt;\n use iter::*;\n-use num::{CheckedAdd, Saturating, checked_next_power_of_two, div_rem};\n+use num::{CheckedAdd, Saturating, div_rem};\n+use num::CheckedMul;\n use option::{None, Option, Some};\n use ptr;\n use ptr::RawPtr;\n-use rt::global_heap::{malloc_raw, realloc_raw, exchange_free};\n+use rt::global_heap::{malloc_raw, exchange_free};\n use result::{Ok, Err};\n use mem;\n use mem::size_of;\n use kinds::marker;\n use uint;\n use unstable::finally::try_finally;\n-use raw::{Repr, Slice, Vec};\n-\n-/**\n- * Creates and initializes an owned vector.\n- *\n- * Creates an owned vector of size `n_elts` and initializes the elements\n- * to the value returned by the function `op`.\n- */\n-pub fn from_fn<T>(n_elts: uint, op: |uint| -> T) -> ~[T] {\n-    unsafe {\n-        let mut v = with_capacity(n_elts);\n-        let p = v.as_mut_ptr();\n-        let mut i = 0;\n-        try_finally(\n-            &mut i, (),\n-            |i, ()| while *i < n_elts {\n-                mem::move_val_init(\n-                    &mut(*p.offset(*i as int)),\n-                    op(*i));\n-                *i += 1u;\n-            },\n-            |i| v.set_len(*i));\n-        v\n-    }\n-}\n-\n-/**\n- * Creates and initializes an owned vector.\n- *\n- * Creates an owned vector of size `n_elts` and initializes the elements\n- * to the value `t`.\n- */\n-pub fn from_elem<T:Clone>(n_elts: uint, t: T) -> ~[T] {\n-    // FIXME (#7136): manually inline from_fn for 2x plus speedup (sadly very\n-    // important, from_elem is a bottleneck in borrowck!). Unfortunately it\n-    // still is substantially slower than using the unsafe\n-    // slice::with_capacity/ptr::set_memory for primitive types.\n-    unsafe {\n-        let mut v = with_capacity(n_elts);\n-        let p = v.as_mut_ptr();\n-        let mut i = 0u;\n-        try_finally(\n-            &mut i, (),\n-            |i, ()| while *i < n_elts {\n-                mem::move_val_init(\n-                    &mut(*p.offset(*i as int)),\n-                    t.clone());\n-                *i += 1u;\n-            },\n-            |i| v.set_len(*i));\n-        v\n-    }\n-}\n-\n-/// Creates a new vector with a capacity of `capacity`\n-#[inline]\n-pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n-    unsafe {\n-        let alloc = capacity * mem::nonzero_size_of::<T>();\n-        let size = alloc + mem::size_of::<Vec<()>>();\n-        if alloc / mem::nonzero_size_of::<T>() != capacity || size < alloc {\n-            fail!(\"vector size is too large: {}\", capacity);\n-        }\n-        let ptr = malloc_raw(size) as *mut Vec<()>;\n-        (*ptr).alloc = alloc;\n-        (*ptr).fill = 0;\n-        transmute(ptr)\n-    }\n-}\n-\n-/**\n- * Builds a vector by calling a provided function with an argument\n- * function that pushes an element to the back of a vector.\n- * The initial capacity for the vector may optionally be specified.\n- *\n- * # Arguments\n- *\n- * * size - An option, maybe containing initial size of the vector to reserve\n- * * builder - A function that will construct the vector. It receives\n- *             as an argument a function that will push an element\n- *             onto the vector being constructed.\n- */\n-#[inline]\n-pub fn build<A>(size: Option<uint>, builder: |push: |v: A||) -> ~[A] {\n-    let mut vec = with_capacity(size.unwrap_or(4));\n-    builder(|x| vec.push(x));\n-    vec\n-}\n+use raw::{Repr, Slice};\n+use RawVec = raw::Vec;\n+use vec::Vec;\n \n /**\n  * Converts a pointer to A into a slice of length 1 (without copying).\n@@ -326,26 +240,6 @@ impl<'a, T> Iterator<&'a [T]> for RevSplits<'a, T> {\n     }\n }\n \n-// Appending\n-\n-/// Iterates over the `rhs` vector, copying each element and appending it to the\n-/// `lhs`. Afterwards, the `lhs` is then returned for use again.\n-#[inline]\n-pub fn append<T:Clone>(lhs: ~[T], rhs: &[T]) -> ~[T] {\n-    let mut v = lhs;\n-    v.push_all(rhs);\n-    v\n-}\n-\n-/// Appends one element to the vector provided. The vector itself is then\n-/// returned for use again.\n-#[inline]\n-pub fn append_one<T>(lhs: ~[T], x: T) -> ~[T] {\n-    let mut v = lhs;\n-    v.push(x);\n-    v\n-}\n-\n // Functional utilities\n \n #[allow(missing_doc)]\n@@ -362,22 +256,22 @@ pub trait VectorVector<T> {\n impl<'a, T: Clone, V: Vector<T>> VectorVector<T> for &'a [V] {\n     fn concat_vec(&self) -> ~[T] {\n         let size = self.iter().fold(0u, |acc, v| acc + v.as_slice().len());\n-        let mut result = with_capacity(size);\n+        let mut result = Vec::with_capacity(size);\n         for v in self.iter() {\n             result.push_all(v.as_slice())\n         }\n-        result\n+        result.move_iter().collect()\n     }\n \n     fn connect_vec(&self, sep: &T) -> ~[T] {\n         let size = self.iter().fold(0u, |acc, v| acc + v.as_slice().len());\n-        let mut result = with_capacity(size + self.len());\n+        let mut result = Vec::with_capacity(size + self.len());\n         let mut first = true;\n         for v in self.iter() {\n             if first { first = false } else { result.push(sep.clone()) }\n             result.push_all(v.as_slice())\n         }\n-        result\n+        result.move_iter().collect()\n     }\n }\n \n@@ -391,13 +285,13 @@ impl<'a, T: Clone, V: Vector<T>> VectorVector<T> for &'a [V] {\n  */\n pub fn unzip<T, U, V: Iterator<(T, U)>>(mut iter: V) -> (~[T], ~[U]) {\n     let (lo, _) = iter.size_hint();\n-    let mut ts = with_capacity(lo);\n-    let mut us = with_capacity(lo);\n+    let mut ts = Vec::with_capacity(lo);\n+    let mut us = Vec::with_capacity(lo);\n     for (t, u) in iter {\n         ts.push(t);\n         us.push(u);\n     }\n-    (ts, us)\n+    (ts.move_iter().collect(), us.move_iter().collect())\n }\n \n /// An Iterator that yields the element swaps needed to produce\n@@ -618,8 +512,9 @@ pub mod traits {\n     use container::Container;\n     use clone::Clone;\n     use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Equiv};\n-    use iter::order;\n+    use iter::{order, Iterator};\n     use ops::Add;\n+    use vec::Vec;\n \n     impl<'a,T:Eq> Eq for &'a [T] {\n         fn eq(&self, other: & &'a [T]) -> bool {\n@@ -696,10 +591,10 @@ pub mod traits {\n     impl<'a,T:Clone, V: Vector<T>> Add<V, ~[T]> for &'a [T] {\n         #[inline]\n         fn add(&self, rhs: &V) -> ~[T] {\n-            let mut res = with_capacity(self.len() + rhs.as_slice().len());\n+            let mut res = Vec::with_capacity(self.len() + rhs.as_slice().len());\n             res.push_all(*self);\n             res.push_all(rhs.as_slice());\n-            res\n+            res.move_iter().collect()\n         }\n     }\n \n@@ -761,7 +656,7 @@ impl<'a, T: Clone> CloneableVector<T> for &'a [T] {\n     #[inline]\n     fn to_owned(&self) -> ~[T] {\n         let len = self.len();\n-        let mut result = with_capacity(len);\n+        let mut result = Vec::with_capacity(len);\n         // Unsafe code so this can be optimised to a memcpy (or something\n         // similarly fast) when T is Copy. LLVM is easily confused, so any\n         // extra operations during the loop can prevent this optimisation\n@@ -780,7 +675,7 @@ impl<'a, T: Clone> CloneableVector<T> for &'a [T] {\n                 },\n                 |i| result.set_len(*i));\n         }\n-        result\n+        result.move_iter().collect()\n     }\n \n     #[inline(always)]\n@@ -1215,8 +1110,8 @@ pub trait ImmutableCloneableVector<T> {\n impl<'a,T:Clone> ImmutableCloneableVector<T> for &'a [T] {\n     #[inline]\n     fn partitioned(&self, f: |&T| -> bool) -> (~[T], ~[T]) {\n-        let mut lefts  = ~[];\n-        let mut rights = ~[];\n+        let mut lefts  = Vec::new();\n+        let mut rights = Vec::new();\n \n         for elt in self.iter() {\n             if f(elt) {\n@@ -1226,7 +1121,7 @@ impl<'a,T:Clone> ImmutableCloneableVector<T> for &'a [T] {\n             }\n         }\n \n-        (lefts, rights)\n+        (lefts.move_iter().collect(), rights.move_iter().collect())\n     }\n \n     fn permutations(self) -> Permutations<T> {\n@@ -1258,149 +1153,11 @@ pub trait OwnedVector<T> {\n     /// reverse order.\n     fn move_rev_iter(self) -> RevMoveItems<T>;\n \n-    /**\n-     * Reserves capacity for exactly `n` elements in the given vector.\n-     *\n-     * If the capacity for `self` is already equal to or greater than the requested\n-     * capacity, then no action is taken.\n-     *\n-     * # Arguments\n-     *\n-     * * n - The number of elements to reserve space for\n-     *\n-     * # Failure\n-     *\n-     * This method always succeeds in reserving space for `n` elements, or it does\n-     * not return.\n-     */\n-    fn reserve_exact(&mut self, n: uint);\n-    /**\n-     * Reserves capacity for at least `n` elements in the given vector.\n-     *\n-     * This function will over-allocate in order to amortize the allocation costs\n-     * in scenarios where the caller may need to repeatedly reserve additional\n-     * space.\n-     *\n-     * If the capacity for `self` is already equal to or greater than the requested\n-     * capacity, then no action is taken.\n-     *\n-     * # Arguments\n-     *\n-     * * n - The number of elements to reserve space for\n-     */\n-    fn reserve(&mut self, n: uint);\n-    /**\n-     * Reserves capacity for at least `n` additional elements in the given vector.\n-     *\n-     * # Failure\n-     *\n-     * Fails if the new required capacity overflows uint.\n-     *\n-     * May also fail if `reserve` fails.\n-     */\n-    fn reserve_additional(&mut self, n: uint);\n-    /// Returns the number of elements the vector can hold without reallocating.\n-    fn capacity(&self) -> uint;\n-    /// Shrink the capacity of the vector to match the length\n-    fn shrink_to_fit(&mut self);\n-\n-    /// Append an element to a vector\n-    fn push(&mut self, t: T);\n-    /// Takes ownership of the vector `rhs`, moving all elements into\n-    /// the current vector. This does not copy any elements, and it is\n-    /// illegal to use the `rhs` vector after calling this method\n-    /// (because it is moved here).\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut a = ~[~1];\n-    /// a.push_all_move(~[~2, ~3, ~4]);\n-    /// assert!(a == ~[~1, ~2, ~3, ~4]);\n-    /// ```\n-    fn push_all_move(&mut self, rhs: ~[T]);\n-    /// Remove the last element from a vector and return it, or `None` if it is empty\n-    fn pop(&mut self) -> Option<T>;\n-    /// Removes the first element from a vector and return it, or `None` if it is empty\n-    fn shift(&mut self) -> Option<T>;\n-    /// Prepend an element to the vector\n-    fn unshift(&mut self, x: T);\n-\n-    /// Insert an element at position i within v, shifting all\n-    /// elements after position i one position to the right.\n-    fn insert(&mut self, i: uint, x:T);\n-\n-    /// Remove and return the element at position `i` within `v`,\n-    /// shifting all elements after position `i` one position to the\n-    /// left. Returns `None` if `i` is out of bounds.\n-    ///\n-    /// # Example\n-    /// ```rust\n-    /// let mut v = ~[1, 2, 3];\n-    /// assert_eq!(v.remove(1), Some(2));\n-    /// assert_eq!(v, ~[1, 3]);\n-    ///\n-    /// assert_eq!(v.remove(4), None);\n-    /// // v is unchanged:\n-    /// assert_eq!(v, ~[1, 3]);\n-    /// ```\n-    fn remove(&mut self, i: uint) -> Option<T>;\n-\n-    /// Remove an element from anywhere in the vector and return it, replacing it\n-    /// with the last element. This does not preserve ordering, but is O(1).\n-    ///\n-    /// Returns `None` if `index` is out of bounds.\n-    ///\n-    /// # Example\n-    /// ```rust\n-    /// let mut v = ~[~\"foo\", ~\"bar\", ~\"baz\", ~\"qux\"];\n-    ///\n-    /// assert_eq!(v.swap_remove(1), Some(~\"bar\"));\n-    /// assert_eq!(v, ~[~\"foo\", ~\"qux\", ~\"baz\"]);\n-    ///\n-    /// assert_eq!(v.swap_remove(0), Some(~\"foo\"));\n-    /// assert_eq!(v, ~[~\"baz\", ~\"qux\"]);\n-    ///\n-    /// assert_eq!(v.swap_remove(2), None);\n-    /// ```\n-    fn swap_remove(&mut self, index: uint) -> Option<T>;\n-\n-    /// Shorten a vector, dropping excess elements.\n-    fn truncate(&mut self, newlen: uint);\n-\n-    /**\n-     * Like `filter()`, but in place.  Preserves order of `v`.  Linear time.\n-     */\n-    fn retain(&mut self, f: |t: &T| -> bool);\n-\n     /**\n      * Partitions the vector into two vectors `(A,B)`, where all\n      * elements of `A` satisfy `f` and all elements of `B` do not.\n      */\n     fn partition(self, f: |&T| -> bool) -> (~[T], ~[T]);\n-\n-    /**\n-     * Expands a vector in place, initializing the new elements to the result of\n-     * a function.\n-     *\n-     * Function `init_op` is called `n` times with the values [0..`n`)\n-     *\n-     * # Arguments\n-     *\n-     * * n - The number of elements to add\n-     * * init_op - A function to call to retrieve each appended element's\n-     *             value\n-     */\n-    fn grow_fn(&mut self, n: uint, op: |uint| -> T);\n-\n-    /**\n-     * Sets the length of a vector\n-     *\n-     * This will explicitly set the size of the vector, without actually\n-     * modifying its buffers, so it is up to the caller to ensure that\n-     * the vector is actually the specified size.\n-     */\n-    unsafe fn set_len(&mut self, new_len: uint);\n }\n \n impl<T> OwnedVector<T> for ~[T] {\n@@ -1418,202 +1175,10 @@ impl<T> OwnedVector<T> for ~[T] {\n         self.move_iter().rev()\n     }\n \n-    fn reserve_exact(&mut self, n: uint) {\n-        // Only make the (slow) call into the runtime if we have to\n-        if self.capacity() < n {\n-            unsafe {\n-                let ptr: *mut *mut Vec<()> = transmute(self);\n-                let alloc = n * mem::nonzero_size_of::<T>();\n-                let size = alloc + mem::size_of::<Vec<()>>();\n-                if alloc / mem::nonzero_size_of::<T>() != n || size < alloc {\n-                    fail!(\"vector size is too large: {}\", n);\n-                }\n-                *ptr = realloc_raw(*ptr as *mut u8, size)\n-                                   as *mut Vec<()>;\n-                (**ptr).alloc = alloc;\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn reserve(&mut self, n: uint) {\n-        self.reserve_exact(checked_next_power_of_two(n).unwrap_or(n));\n-    }\n-\n-    #[inline]\n-    fn reserve_additional(&mut self, n: uint) {\n-        if self.capacity() - self.len() < n {\n-            match self.len().checked_add(&n) {\n-                None => fail!(\"slice::reserve_additional: `uint` overflow\"),\n-                Some(new_cap) => self.reserve(new_cap)\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn capacity(&self) -> uint {\n-        unsafe {\n-            let repr: **Vec<()> = transmute(self);\n-            (**repr).alloc / mem::nonzero_size_of::<T>()\n-        }\n-    }\n-\n-    fn shrink_to_fit(&mut self) {\n-        unsafe {\n-            let ptr: *mut *mut Vec<()> = transmute(self);\n-            let alloc = (**ptr).fill;\n-            let size = alloc + mem::size_of::<Vec<()>>();\n-            *ptr = realloc_raw(*ptr as *mut u8, size) as *mut Vec<()>;\n-            (**ptr).alloc = alloc;\n-        }\n-    }\n-\n-    #[inline]\n-    fn push(&mut self, t: T) {\n-        unsafe {\n-            let repr: **Vec<()> = transmute(&mut *self);\n-            let fill = (**repr).fill;\n-            if (**repr).alloc <= fill {\n-                self.reserve_additional(1);\n-            }\n-\n-            push_fast(self, t);\n-        }\n-\n-        // This doesn't bother to make sure we have space.\n-        #[inline] // really pretty please\n-        unsafe fn push_fast<T>(this: &mut ~[T], t: T) {\n-            let repr: **mut Vec<u8> = transmute(this);\n-            let fill = (**repr).fill;\n-            (**repr).fill += mem::nonzero_size_of::<T>();\n-            let p = &((**repr).data) as *u8;\n-            let p = p.offset(fill as int) as *mut T;\n-            mem::move_val_init(&mut(*p), t);\n-        }\n-    }\n-\n-    #[inline]\n-    fn push_all_move(&mut self, mut rhs: ~[T]) {\n-        let self_len = self.len();\n-        let rhs_len = rhs.len();\n-        let new_len = self_len + rhs_len;\n-        self.reserve_additional(rhs.len());\n-        unsafe { // Note: infallible.\n-            let self_p = self.as_mut_ptr();\n-            let rhs_p = rhs.as_ptr();\n-            ptr::copy_memory(self_p.offset(self_len as int), rhs_p, rhs_len);\n-            self.set_len(new_len);\n-            rhs.set_len(0);\n-        }\n-    }\n-\n-    fn pop(&mut self) -> Option<T> {\n-        match self.len() {\n-            0  => None,\n-            ln => {\n-                let valptr = &mut self[ln - 1u] as *mut T;\n-                unsafe {\n-                    self.set_len(ln - 1u);\n-                    Some(ptr::read(&*valptr))\n-                }\n-            }\n-        }\n-    }\n-\n-\n-    #[inline]\n-    fn shift(&mut self) -> Option<T> {\n-        self.remove(0)\n-    }\n-\n-    #[inline]\n-    fn unshift(&mut self, x: T) {\n-        self.insert(0, x)\n-    }\n-\n-    fn insert(&mut self, i: uint, x: T) {\n-        let len = self.len();\n-        assert!(i <= len);\n-        // space for the new element\n-        self.reserve_additional(1);\n-\n-        unsafe { // infallible\n-            // The spot to put the new value\n-            let p = self.as_mut_ptr().offset(i as int);\n-            // Shift everything over to make space. (Duplicating the\n-            // `i`th element into two consecutive places.)\n-            ptr::copy_memory(p.offset(1), &*p, len - i);\n-            // Write it in, overwriting the first copy of the `i`th\n-            // element.\n-            mem::move_val_init(&mut *p, x);\n-            self.set_len(len + 1);\n-        }\n-    }\n-\n-    fn remove(&mut self, i: uint) -> Option<T> {\n-        let len = self.len();\n-        if i < len {\n-            unsafe { // infallible\n-                // the place we are taking from.\n-                let ptr = self.as_mut_ptr().offset(i as int);\n-                // copy it out, unsafely having a copy of the value on\n-                // the stack and in the vector at the same time.\n-                let ret = Some(ptr::read(ptr as *T));\n-\n-                // Shift everything down to fill in that spot.\n-                ptr::copy_memory(ptr, &*ptr.offset(1), len - i - 1);\n-                self.set_len(len - 1);\n-\n-                ret\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-    fn swap_remove(&mut self, index: uint) -> Option<T> {\n-        let ln = self.len();\n-        if index < ln - 1 {\n-            self.swap(index, ln - 1);\n-        } else if index >= ln {\n-            return None\n-        }\n-        self.pop()\n-    }\n-    fn truncate(&mut self, newlen: uint) {\n-        let oldlen = self.len();\n-        assert!(newlen <= oldlen);\n-\n-        unsafe {\n-            let p = self.as_mut_ptr();\n-            // This loop is optimized out for non-drop types.\n-            for i in range(newlen, oldlen) {\n-                ptr::read_and_zero(p.offset(i as int));\n-            }\n-        }\n-        unsafe { self.set_len(newlen); }\n-    }\n-\n-    fn retain(&mut self, f: |t: &T| -> bool) {\n-        let len = self.len();\n-        let mut deleted: uint = 0;\n-\n-        for i in range(0u, len) {\n-            if !f(&self[i]) {\n-                deleted += 1;\n-            } else if deleted > 0 {\n-                self.swap(i - deleted, i);\n-            }\n-        }\n-\n-        if deleted > 0 {\n-            self.truncate(len - deleted);\n-        }\n-    }\n-\n     #[inline]\n     fn partition(self, f: |&T| -> bool) -> (~[T], ~[T]) {\n-        let mut lefts  = ~[];\n-        let mut rights = ~[];\n+        let mut lefts  = Vec::new();\n+        let mut rights = Vec::new();\n \n         for elt in self.move_iter() {\n             if f(&elt) {\n@@ -1623,184 +1188,7 @@ impl<T> OwnedVector<T> for ~[T] {\n             }\n         }\n \n-        (lefts, rights)\n-    }\n-    fn grow_fn(&mut self, n: uint, op: |uint| -> T) {\n-        let new_len = self.len() + n;\n-        self.reserve(new_len);\n-        let mut i: uint = 0u;\n-        while i < n {\n-            self.push(op(i));\n-            i += 1u;\n-        }\n-    }\n-\n-    #[inline]\n-    unsafe fn set_len(&mut self, new_len: uint) {\n-        let repr: **mut Vec<()> = transmute(self);\n-        (**repr).fill = new_len * mem::nonzero_size_of::<T>();\n-    }\n-}\n-\n-impl<T> Mutable for ~[T] {\n-    /// Clear the vector, removing all values.\n-    fn clear(&mut self) { self.truncate(0) }\n-}\n-\n-/// Extension methods for owned vectors containing `Clone` elements.\n-pub trait OwnedCloneableVector<T:Clone> {\n-    /// Iterates over the slice `rhs`, copies each element, and then appends it to\n-    /// the vector provided `v`. The `rhs` vector is traversed in-order.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut a = ~[1];\n-    /// a.push_all([2, 3, 4]);\n-    /// assert!(a == ~[1, 2, 3, 4]);\n-    /// ```\n-    fn push_all(&mut self, rhs: &[T]);\n-\n-    /**\n-     * Expands a vector in place, initializing the new elements to a given value\n-     *\n-     * # Arguments\n-     *\n-     * * n - The number of elements to add\n-     * * initval - The value for the new elements\n-     */\n-    fn grow(&mut self, n: uint, initval: &T);\n-\n-    /**\n-     * Sets the value of a vector element at a given index, growing the vector as\n-     * needed\n-     *\n-     * Sets the element at position `index` to `val`. If `index` is past the end\n-     * of the vector, expands the vector by replicating `initval` to fill the\n-     * intervening space.\n-     */\n-    fn grow_set(&mut self, index: uint, initval: &T, val: T);\n-}\n-\n-impl<T:Clone> OwnedCloneableVector<T> for ~[T] {\n-    #[inline]\n-    fn push_all(&mut self, rhs: &[T]) {\n-        let new_len = self.len() + rhs.len();\n-        self.reserve_exact(new_len);\n-\n-        for elt in rhs.iter() {\n-            self.push((*elt).clone())\n-        }\n-    }\n-    fn grow(&mut self, n: uint, initval: &T) {\n-        let new_len = self.len() + n;\n-        self.reserve(new_len);\n-        let mut i: uint = 0u;\n-\n-        while i < n {\n-            self.push((*initval).clone());\n-            i += 1u;\n-        }\n-    }\n-    fn grow_set(&mut self, index: uint, initval: &T, val: T) {\n-        let l = self.len();\n-        if index >= l { self.grow(index - l + 1u, initval); }\n-        self[index] = val;\n-    }\n-}\n-\n-/// Extension methods for owned vectors containing `Eq` elements.\n-pub trait OwnedEqVector<T:Eq> {\n-    /**\n-    * Remove consecutive repeated elements from a vector; if the vector is\n-    * sorted, this removes all duplicates.\n-    */\n-    fn dedup(&mut self);\n-}\n-\n-impl<T:Eq> OwnedEqVector<T> for ~[T] {\n-    fn dedup(&mut self) {\n-        unsafe {\n-            // Although we have a mutable reference to `self`, we cannot make\n-            // *arbitrary* changes. The `Eq` comparisons could fail, so we\n-            // must ensure that the vector is in a valid state at all time.\n-            //\n-            // The way that we handle this is by using swaps; we iterate\n-            // over all the elements, swapping as we go so that at the end\n-            // the elements we wish to keep are in the front, and those we\n-            // wish to reject are at the back. We can then truncate the\n-            // vector. This operation is still O(n).\n-            //\n-            // Example: We start in this state, where `r` represents \"next\n-            // read\" and `w` represents \"next_write`.\n-            //\n-            //           r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //           w\n-            //\n-            // Comparing self[r] against self[w-1], tis is not a duplicate, so\n-            // we swap self[r] and self[w] (no effect as r==w) and then increment both\n-            // r and w, leaving us with:\n-            //\n-            //               r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //               w\n-            //\n-            // Comparing self[r] against self[w-1], this value is a duplicate,\n-            // so we increment `r` but leave everything else unchanged:\n-            //\n-            //                   r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //               w\n-            //\n-            // Comparing self[r] against self[w-1], this is not a duplicate,\n-            // so swap self[r] and self[w] and advance r and w:\n-            //\n-            //                       r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 2 | 1 | 3 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //                   w\n-            //\n-            // Not a duplicate, repeat:\n-            //\n-            //                           r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 2 | 3 | 1 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //                       w\n-            //\n-            // Duplicate, advance r. End of vec. Truncate to w.\n-\n-            let ln = self.len();\n-            if ln < 1 { return; }\n-\n-            // Avoid bounds checks by using unsafe pointers.\n-            let p = self.as_mut_ptr();\n-            let mut r = 1;\n-            let mut w = 1;\n-\n-            while r < ln {\n-                let p_r = p.offset(r as int);\n-                let p_wm1 = p.offset((w - 1) as int);\n-                if *p_r != *p_wm1 {\n-                    if r != w {\n-                        let p_w = p_wm1.offset(1);\n-                        mem::swap(&mut *p_r, &mut *p_w);\n-                    }\n-                    w += 1;\n-                }\n-                r += 1;\n-            }\n-\n-            self.truncate(w);\n-        }\n+        (lefts.move_iter().collect(), rights.move_iter().collect())\n     }\n }\n \n@@ -1872,7 +1260,7 @@ fn merge_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n     // length 0 so we can keep shallow copies of the contents of `v`\n     // without risking the dtors running on an object twice if\n     // `compare` fails.\n-    let mut working_space = with_capacity(2 * len);\n+    let mut working_space = Vec::with_capacity(2 * len);\n     // these both are buffers of length `len`.\n     let mut buf_dat = working_space.as_mut_ptr();\n     let mut buf_tmp = unsafe {buf_dat.offset(len as int)};\n@@ -2475,10 +1863,12 @@ pub unsafe fn from_buf<T>(ptr: *T, elts: uint) -> ~[T] {\n /// Unsafe operations\n pub mod raw {\n     use cast::transmute;\n-    use ptr;\n+    use iter::Iterator;\n     use ptr::RawPtr;\n-    use slice::{with_capacity, MutableVector, OwnedVector};\n+    use ptr;\n     use raw::Slice;\n+    use slice::{MutableVector, OwnedVector};\n+    use vec::Vec;\n \n     /**\n      * Form a slice from a pointer and length (as a number of units,\n@@ -2521,10 +1911,10 @@ pub mod raw {\n     // Was in raw, but needs to be called by net_tcp::on_tcp_read_cb\n     #[inline]\n     pub unsafe fn from_buf_raw<T>(ptr: *T, elts: uint) -> ~[T] {\n-        let mut dst = with_capacity(elts);\n+        let mut dst = Vec::with_capacity(elts);\n         dst.set_len(elts);\n         ptr::copy_memory(dst.as_mut_ptr(), ptr, elts);\n-        dst\n+        dst.move_iter().collect()\n     }\n \n     /**\n@@ -2556,9 +1946,8 @@ pub mod raw {\n /// Operations on `[u8]`.\n pub mod bytes {\n     use container::Container;\n-    use slice::{MutableVector, OwnedVector, ImmutableVector};\n+    use slice::MutableVector;\n     use ptr;\n-    use ptr::RawPtr;\n \n     /// A trait for operations on mutable `[u8]`s.\n     pub trait MutableByteVector {\n@@ -2582,19 +1971,6 @@ pub mod bytes {\n         // Bound checks are done at .copy_memory.\n         unsafe { dst.copy_memory(src) }\n     }\n-\n-    /**\n-     * Allocate space in `dst` and append the data to `src`.\n-     */\n-    #[inline]\n-    pub fn push_bytes(dst: &mut ~[u8], src: &[u8]) {\n-        let old_len = dst.len();\n-        dst.reserve_additional(src.len());\n-        unsafe {\n-            ptr::copy_memory(dst.as_mut_ptr().offset(old_len as int), src.as_ptr(), src.len());\n-            dst.set_len(old_len + src.len());\n-        }\n-    }\n }\n \n impl<A: Clone> Clone for ~[A] {\n@@ -2603,17 +1979,6 @@ impl<A: Clone> Clone for ~[A] {\n         // Use the fast to_owned on &[A] for cloning\n         self.as_slice().to_owned()\n     }\n-\n-    fn clone_from(&mut self, source: &~[A]) {\n-        if self.len() < source.len() {\n-            *self = source.clone()\n-        } else {\n-            self.truncate(source.len());\n-            for (x, y) in self.mut_iter().zip(source.iter()) {\n-                x.clone_from(y);\n-            }\n-        }\n-    }\n }\n \n impl<'a, T: fmt::Show> fmt::Show for &'a [T] {\n@@ -2914,22 +2279,35 @@ pub type RevMoveItems<T> = Rev<MoveItems<T>>;\n \n impl<A> FromIterator<A> for ~[A] {\n     fn from_iter<T: Iterator<A>>(mut iterator: T) -> ~[A] {\n-        let (lower, _) = iterator.size_hint();\n-        let mut xs = with_capacity(lower);\n-        for x in iterator {\n-            xs.push(x);\n-        }\n-        xs\n-    }\n-}\n+        let mut xs: Vec<A> = iterator.collect();\n \n-impl<A> Extendable<A> for ~[A] {\n-    fn extend<T: Iterator<A>>(&mut self, mut iterator: T) {\n-        let (lower, _) = iterator.size_hint();\n-        let len = self.len();\n-        self.reserve_exact(len + lower);\n-        for x in iterator {\n-            self.push(x);\n+        // Must shrink so the capacity is the same as the length. The length of\n+        // the ~[T] vector must exactly match the length of the allocation.\n+        xs.shrink_to_fit();\n+\n+        let len = xs.len();\n+        assert!(len == xs.capacity());\n+        let data = xs.as_mut_ptr();\n+\n+        let data_size = len.checked_mul(&mem::size_of::<A>());\n+        let data_size = data_size.expect(\"overflow in from_iter()\");\n+        let size = mem::size_of::<RawVec<()>>().checked_add(&data_size);\n+        let size = size.expect(\"overflow in from_iter()\");\n+\n+\n+        // This is some terribly awful code. Note that all of this will go away\n+        // with DST because creating ~[T] from Vec<T> will just be some pointer\n+        // swizzling.\n+        unsafe {\n+            let ret = malloc_raw(size) as *mut RawVec<()>;\n+\n+            (*ret).fill = len * mem::nonzero_size_of::<A>();\n+            (*ret).alloc = len * mem::nonzero_size_of::<A>();\n+            ptr::copy_nonoverlapping_memory(&mut (*ret).data as *mut _ as *mut u8,\n+                                            data as *u8,\n+                                            data_size);\n+            xs.set_len(0); // ownership has been transferred\n+            cast::transmute(ret)\n         }\n     }\n }\n@@ -2974,38 +2352,50 @@ mod tests {\n     #[test]\n     fn test_from_fn() {\n         // Test on-stack from_fn.\n-        let mut v = from_fn(3u, square);\n-        assert_eq!(v.len(), 3u);\n-        assert_eq!(v[0], 0u);\n-        assert_eq!(v[1], 1u);\n-        assert_eq!(v[2], 4u);\n+        let mut v = Vec::from_fn(3u, square);\n+        {\n+            let v = v.as_slice();\n+            assert_eq!(v.len(), 3u);\n+            assert_eq!(v[0], 0u);\n+            assert_eq!(v[1], 1u);\n+            assert_eq!(v[2], 4u);\n+        }\n \n         // Test on-heap from_fn.\n-        v = from_fn(5u, square);\n-        assert_eq!(v.len(), 5u);\n-        assert_eq!(v[0], 0u);\n-        assert_eq!(v[1], 1u);\n-        assert_eq!(v[2], 4u);\n-        assert_eq!(v[3], 9u);\n-        assert_eq!(v[4], 16u);\n+        v = Vec::from_fn(5u, square);\n+        {\n+            let v = v.as_slice();\n+            assert_eq!(v.len(), 5u);\n+            assert_eq!(v[0], 0u);\n+            assert_eq!(v[1], 1u);\n+            assert_eq!(v[2], 4u);\n+            assert_eq!(v[3], 9u);\n+            assert_eq!(v[4], 16u);\n+        }\n     }\n \n     #[test]\n     fn test_from_elem() {\n         // Test on-stack from_elem.\n-        let mut v = from_elem(2u, 10u);\n-        assert_eq!(v.len(), 2u);\n-        assert_eq!(v[0], 10u);\n-        assert_eq!(v[1], 10u);\n+        let mut v = Vec::from_elem(2u, 10u);\n+        {\n+            let v = v.as_slice();\n+            assert_eq!(v.len(), 2u);\n+            assert_eq!(v[0], 10u);\n+            assert_eq!(v[1], 10u);\n+        }\n \n         // Test on-heap from_elem.\n-        v = from_elem(6u, 20u);\n-        assert_eq!(v[0], 20u);\n-        assert_eq!(v[1], 20u);\n-        assert_eq!(v[2], 20u);\n-        assert_eq!(v[3], 20u);\n-        assert_eq!(v[4], 20u);\n-        assert_eq!(v[5], 20u);\n+        v = Vec::from_elem(6u, 20u);\n+        {\n+            let v = v.as_slice();\n+            assert_eq!(v[0], 20u);\n+            assert_eq!(v[1], 20u);\n+            assert_eq!(v[2], 20u);\n+            assert_eq!(v[3], 20u);\n+            assert_eq!(v[4], 20u);\n+            assert_eq!(v[5], 20u);\n+        }\n     }\n \n     #[test]\n@@ -3164,7 +2554,7 @@ mod tests {\n \n     #[test]\n     fn test_pop() {\n-        let mut v = ~[5];\n+        let mut v = vec![5];\n         let e = v.pop();\n         assert_eq!(v.len(), 0);\n         assert_eq!(e, Some(5));\n@@ -3176,25 +2566,25 @@ mod tests {\n \n     #[test]\n     fn test_swap_remove() {\n-        let mut v = ~[1, 2, 3, 4, 5];\n+        let mut v = vec![1, 2, 3, 4, 5];\n         let mut e = v.swap_remove(0);\n         assert_eq!(e, Some(1));\n-        assert_eq!(v, ~[5, 2, 3, 4]);\n+        assert_eq!(v, vec![5, 2, 3, 4]);\n         e = v.swap_remove(3);\n         assert_eq!(e, Some(4));\n-        assert_eq!(v, ~[5, 2, 3]);\n+        assert_eq!(v, vec![5, 2, 3]);\n \n         e = v.swap_remove(3);\n         assert_eq!(e, None);\n-        assert_eq!(v, ~[5, 2, 3]);\n+        assert_eq!(v, vec![5, 2, 3]);\n     }\n \n     #[test]\n     fn test_swap_remove_noncopyable() {\n         // Tests that we don't accidentally run destructors twice.\n-        let mut v = ~[::unstable::sync::Exclusive::new(()),\n-                      ::unstable::sync::Exclusive::new(()),\n-                      ::unstable::sync::Exclusive::new(())];\n+        let mut v = vec![::unstable::sync::Exclusive::new(()),\n+                         ::unstable::sync::Exclusive::new(()),\n+                         ::unstable::sync::Exclusive::new(())];\n         let mut _e = v.swap_remove(0);\n         assert_eq!(v.len(), 2);\n         _e = v.swap_remove(1);\n@@ -3206,41 +2596,48 @@ mod tests {\n     #[test]\n     fn test_push() {\n         // Test on-stack push().\n-        let mut v = ~[];\n+        let mut v = vec![];\n         v.push(1);\n         assert_eq!(v.len(), 1u);\n-        assert_eq!(v[0], 1);\n+        assert_eq!(v.as_slice()[0], 1);\n \n         // Test on-heap push().\n         v.push(2);\n         assert_eq!(v.len(), 2u);\n-        assert_eq!(v[0], 1);\n-        assert_eq!(v[1], 2);\n+        assert_eq!(v.as_slice()[0], 1);\n+        assert_eq!(v.as_slice()[1], 2);\n     }\n \n     #[test]\n     fn test_grow() {\n         // Test on-stack grow().\n-        let mut v = ~[];\n+        let mut v = vec![];\n         v.grow(2u, &1);\n-        assert_eq!(v.len(), 2u);\n-        assert_eq!(v[0], 1);\n-        assert_eq!(v[1], 1);\n+        {\n+            let v = v.as_slice();\n+            assert_eq!(v.len(), 2u);\n+            assert_eq!(v[0], 1);\n+            assert_eq!(v[1], 1);\n+        }\n \n         // Test on-heap grow().\n         v.grow(3u, &2);\n-        assert_eq!(v.len(), 5u);\n-        assert_eq!(v[0], 1);\n-        assert_eq!(v[1], 1);\n-        assert_eq!(v[2], 2);\n-        assert_eq!(v[3], 2);\n-        assert_eq!(v[4], 2);\n+        {\n+            let v = v.as_slice();\n+            assert_eq!(v.len(), 5u);\n+            assert_eq!(v[0], 1);\n+            assert_eq!(v[1], 1);\n+            assert_eq!(v[2], 2);\n+            assert_eq!(v[3], 2);\n+            assert_eq!(v[4], 2);\n+        }\n     }\n \n     #[test]\n     fn test_grow_fn() {\n-        let mut v = ~[];\n+        let mut v = vec![];\n         v.grow_fn(3u, square);\n+        let v = v.as_slice();\n         assert_eq!(v.len(), 3u);\n         assert_eq!(v[0], 0u);\n         assert_eq!(v[1], 1u);\n@@ -3249,8 +2646,9 @@ mod tests {\n \n     #[test]\n     fn test_grow_set() {\n-        let mut v = ~[1, 2, 3];\n+        let mut v = vec![1, 2, 3];\n         v.grow_set(4u, &4, 5);\n+        let v = v.as_slice();\n         assert_eq!(v.len(), 5u);\n         assert_eq!(v[0], 1);\n         assert_eq!(v[1], 2);\n@@ -3261,45 +2659,46 @@ mod tests {\n \n     #[test]\n     fn test_truncate() {\n-        let mut v = ~[~6,~5,~4];\n+        let mut v = vec![~6,~5,~4];\n         v.truncate(1);\n+        let v = v.as_slice();\n         assert_eq!(v.len(), 1);\n         assert_eq!(*(v[0]), 6);\n         // If the unsafe block didn't drop things properly, we blow up here.\n     }\n \n     #[test]\n     fn test_clear() {\n-        let mut v = ~[~6,~5,~4];\n+        let mut v = vec![~6,~5,~4];\n         v.clear();\n         assert_eq!(v.len(), 0);\n         // If the unsafe block didn't drop things properly, we blow up here.\n     }\n \n     #[test]\n     fn test_dedup() {\n-        fn case(a: ~[uint], b: ~[uint]) {\n+        fn case(a: Vec<uint>, b: Vec<uint>) {\n             let mut v = a;\n             v.dedup();\n             assert_eq!(v, b);\n         }\n-        case(~[], ~[]);\n-        case(~[1], ~[1]);\n-        case(~[1,1], ~[1]);\n-        case(~[1,2,3], ~[1,2,3]);\n-        case(~[1,1,2,3], ~[1,2,3]);\n-        case(~[1,2,2,3], ~[1,2,3]);\n-        case(~[1,2,3,3], ~[1,2,3]);\n-        case(~[1,1,2,2,2,3,3], ~[1,2,3]);\n+        case(vec![], vec![]);\n+        case(vec![1], vec![1]);\n+        case(vec![1,1], vec![1]);\n+        case(vec![1,2,3], vec![1,2,3]);\n+        case(vec![1,1,2,3], vec![1,2,3]);\n+        case(vec![1,2,2,3], vec![1,2,3]);\n+        case(vec![1,2,3,3], vec![1,2,3]);\n+        case(vec![1,1,2,2,2,3,3], vec![1,2,3]);\n     }\n \n     #[test]\n     fn test_dedup_unique() {\n-        let mut v0 = ~[~1, ~1, ~2, ~3];\n+        let mut v0 = vec![~1, ~1, ~2, ~3];\n         v0.dedup();\n-        let mut v1 = ~[~1, ~2, ~2, ~3];\n+        let mut v1 = vec![~1, ~2, ~2, ~3];\n         v1.dedup();\n-        let mut v2 = ~[~1, ~2, ~3, ~3];\n+        let mut v2 = vec![~1, ~2, ~3, ~3];\n         v2.dedup();\n         /*\n          * If the ~pointers were leaked or otherwise misused, valgrind and/or\n@@ -3309,11 +2708,11 @@ mod tests {\n \n     #[test]\n     fn test_dedup_shared() {\n-        let mut v0 = ~[~1, ~1, ~2, ~3];\n+        let mut v0 = vec![~1, ~1, ~2, ~3];\n         v0.dedup();\n-        let mut v1 = ~[~1, ~2, ~2, ~3];\n+        let mut v1 = vec![~1, ~2, ~2, ~3];\n         v1.dedup();\n-        let mut v2 = ~[~1, ~2, ~3, ~3];\n+        let mut v2 = vec![~1, ~2, ~3, ~3];\n         v2.dedup();\n         /*\n          * If the pointers were leaked or otherwise misused, valgrind and/or\n@@ -3323,14 +2722,14 @@ mod tests {\n \n     #[test]\n     fn test_retain() {\n-        let mut v = ~[1, 2, 3, 4, 5];\n+        let mut v = vec![1, 2, 3, 4, 5];\n         v.retain(is_odd);\n-        assert_eq!(v, ~[1, 3, 5]);\n+        assert_eq!(v, vec![1, 3, 5]);\n     }\n \n     #[test]\n     fn test_zip_unzip() {\n-        let z1 = ~[(1, 4), (2, 5), (3, 6)];\n+        let z1 = vec![(1, 4), (2, 5), (3, 6)];\n \n         let (left, right) = unzip(z1.iter().map(|&x| x));\n \n@@ -3559,9 +2958,9 @@ mod tests {\n \n     #[test]\n     fn test_shift() {\n-        let mut x = ~[1, 2, 3];\n+        let mut x = vec![1, 2, 3];\n         assert_eq!(x.shift(), Some(1));\n-        assert_eq!(&x, &~[2, 3]);\n+        assert_eq!(&x, &vec![2, 3]);\n         assert_eq!(x.shift(), Some(2));\n         assert_eq!(x.shift(), Some(3));\n         assert_eq!(x.shift(), None);\n@@ -3570,73 +2969,73 @@ mod tests {\n \n     #[test]\n     fn test_unshift() {\n-        let mut x = ~[1, 2, 3];\n+        let mut x = vec![1, 2, 3];\n         x.unshift(0);\n-        assert_eq!(x, ~[0, 1, 2, 3]);\n+        assert_eq!(x, vec![0, 1, 2, 3]);\n     }\n \n     #[test]\n     fn test_insert() {\n-        let mut a = ~[1, 2, 4];\n+        let mut a = vec![1, 2, 4];\n         a.insert(2, 3);\n-        assert_eq!(a, ~[1, 2, 3, 4]);\n+        assert_eq!(a, vec![1, 2, 3, 4]);\n \n-        let mut a = ~[1, 2, 3];\n+        let mut a = vec![1, 2, 3];\n         a.insert(0, 0);\n-        assert_eq!(a, ~[0, 1, 2, 3]);\n+        assert_eq!(a, vec![0, 1, 2, 3]);\n \n-        let mut a = ~[1, 2, 3];\n+        let mut a = vec![1, 2, 3];\n         a.insert(3, 4);\n-        assert_eq!(a, ~[1, 2, 3, 4]);\n+        assert_eq!(a, vec![1, 2, 3, 4]);\n \n-        let mut a = ~[];\n+        let mut a = vec![];\n         a.insert(0, 1);\n-        assert_eq!(a, ~[1]);\n+        assert_eq!(a, vec![1]);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_insert_oob() {\n-        let mut a = ~[1, 2, 3];\n+        let mut a = vec![1, 2, 3];\n         a.insert(4, 5);\n     }\n \n     #[test]\n     fn test_remove() {\n-        let mut a = ~[1,2,3,4];\n+        let mut a = vec![1,2,3,4];\n \n         assert_eq!(a.remove(2), Some(3));\n-        assert_eq!(a, ~[1,2,4]);\n+        assert_eq!(a, vec![1,2,4]);\n \n         assert_eq!(a.remove(2), Some(4));\n-        assert_eq!(a, ~[1,2]);\n+        assert_eq!(a, vec![1,2]);\n \n         assert_eq!(a.remove(2), None);\n-        assert_eq!(a, ~[1,2]);\n+        assert_eq!(a, vec![1,2]);\n \n         assert_eq!(a.remove(0), Some(1));\n-        assert_eq!(a, ~[2]);\n+        assert_eq!(a, vec![2]);\n \n         assert_eq!(a.remove(0), Some(2));\n-        assert_eq!(a, ~[]);\n+        assert_eq!(a, vec![]);\n \n         assert_eq!(a.remove(0), None);\n         assert_eq!(a.remove(10), None);\n     }\n \n     #[test]\n     fn test_capacity() {\n-        let mut v = ~[0u64];\n+        let mut v = vec![0u64];\n         v.reserve_exact(10u);\n         assert_eq!(v.capacity(), 10u);\n-        let mut v = ~[0u32];\n+        let mut v = vec![0u32];\n         v.reserve_exact(10u);\n         assert_eq!(v.capacity(), 10u);\n     }\n \n     #[test]\n     fn test_slice_2() {\n-        let v = ~[1, 2, 3, 4, 5];\n+        let v = vec![1, 2, 3, 4, 5];\n         let v = v.slice(1u, 3u);\n         assert_eq!(v.len(), 2u);\n         assert_eq!(v[0], 2);\n@@ -3647,7 +3046,7 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_from_fn_fail() {\n-        from_fn(100, |v| {\n+        Vec::from_fn(100, |v| {\n             if v == 50 { fail!() }\n             ~0\n         });\n@@ -3674,27 +3073,14 @@ mod tests {\n         }\n \n         let s = S { f: 0, boxes: (~0, Rc::new(0)) };\n-        let _ = from_elem(100, s);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_build_fail() {\n-        use rc::Rc;\n-        build(None, |push| {\n-            push((~0, Rc::new(0)));\n-            push((~0, Rc::new(0)));\n-            push((~0, Rc::new(0)));\n-            push((~0, Rc::new(0)));\n-            fail!();\n-        });\n+        let _ = Vec::from_elem(100, s);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_grow_fn_fail() {\n         use rc::Rc;\n-        let mut v = ~[];\n+        let mut v = vec![];\n         v.grow_fn(100, |i| {\n             if i == 50 {\n                 fail!()\n@@ -4036,6 +3422,7 @@ mod tests {\n \n         t!(&[int]);\n         t!(~[int]);\n+        t!(Vec<int>);\n     }\n \n     #[test]\n@@ -4051,7 +3438,7 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_overflow_does_not_cause_segfault() {\n-        let mut v = ~[];\n+        let mut v = vec![];\n         v.reserve_exact(-1);\n         v.push(1);\n         v.push(2);\n@@ -4061,7 +3448,7 @@ mod tests {\n     #[should_fail]\n     fn test_overflow_does_not_cause_segfault_managed() {\n         use rc::Rc;\n-        let mut v = ~[Rc::new(1)];\n+        let mut v = vec![Rc::new(1)];\n         v.reserve_exact(-1);\n         v.push(Rc::new(2));\n     }\n@@ -4090,7 +3477,7 @@ mod tests {\n \n     #[test]\n     fn test_iter_zero_sized() {\n-        let mut v = ~[Foo, Foo, Foo];\n+        let mut v = vec![Foo, Foo, Foo];\n         assert_eq!(v.len(), 3);\n         let mut cnt = 0;\n \n@@ -4118,7 +3505,7 @@ mod tests {\n         }\n         assert_eq!(cnt, 11);\n \n-        let xs = ~[Foo, Foo, Foo];\n+        let xs = vec![Foo, Foo, Foo];\n         assert_eq!(format!(\"{:?}\", xs.slice(0, 2).to_owned()),\n                    ~\"~[slice::tests::Foo, slice::tests::Foo]\");\n \n@@ -4135,14 +3522,14 @@ mod tests {\n \n     #[test]\n     fn test_shrink_to_fit() {\n-        let mut xs = ~[0, 1, 2, 3];\n+        let mut xs = vec![0, 1, 2, 3];\n         for i in range(4, 100) {\n             xs.push(i)\n         }\n         assert_eq!(xs.capacity(), 128);\n         xs.shrink_to_fit();\n         assert_eq!(xs.capacity(), 100);\n-        assert_eq!(xs, range(0, 100).collect::<~[_]>());\n+        assert_eq!(xs, range(0, 100).collect::<Vec<_>>());\n     }\n \n     #[test]\n@@ -4300,13 +3687,12 @@ mod bench {\n     use prelude::*;\n     use ptr;\n     use rand::{weak_rng, Rng};\n-    use slice;\n \n     #[bench]\n     fn iterator(b: &mut Bencher) {\n         // peculiar numbers to stop LLVM from optimising the summation\n         // out.\n-        let v = slice::from_fn(100, |i| i ^ (i << 1) ^ (i >> 1));\n+        let v = Vec::from_fn(100, |i| i ^ (i << 1) ^ (i >> 1));\n \n         b.iter(|| {\n             let mut sum = 0;\n@@ -4320,7 +3706,7 @@ mod bench {\n \n     #[bench]\n     fn mut_iterator(b: &mut Bencher) {\n-        let mut v = slice::from_elem(100, 0);\n+        let mut v = Vec::from_elem(100, 0);\n \n         b.iter(|| {\n             let mut i = 0;\n@@ -4342,23 +3728,23 @@ mod bench {\n \n     #[bench]\n     fn concat(b: &mut Bencher) {\n-        let xss: &[~[uint]] = slice::from_fn(100, |i| range(0, i).collect());\n+        let xss: Vec<Vec<uint>> = Vec::from_fn(100, |i| range(0, i).collect());\n         b.iter(|| {\n-            let _ = xss.concat_vec();\n+            xss.as_slice().concat_vec()\n         });\n     }\n \n     #[bench]\n     fn connect(b: &mut Bencher) {\n-        let xss: &[~[uint]] = slice::from_fn(100, |i| range(0, i).collect());\n+        let xss: Vec<Vec<uint>> = Vec::from_fn(100, |i| range(0, i).collect());\n         b.iter(|| {\n-            let _ = xss.connect_vec(&0);\n+            xss.as_slice().connect_vec(&0)\n         });\n     }\n \n     #[bench]\n     fn push(b: &mut Bencher) {\n-        let mut vec: ~[uint] = ~[0u];\n+        let mut vec: Vec<uint> = vec![];\n         b.iter(|| {\n             vec.push(0);\n             &vec\n@@ -4367,59 +3753,59 @@ mod bench {\n \n     #[bench]\n     fn starts_with_same_vector(b: &mut Bencher) {\n-        let vec: ~[uint] = slice::from_fn(100, |i| i);\n+        let vec: Vec<uint> = Vec::from_fn(100, |i| i);\n         b.iter(|| {\n-            vec.starts_with(vec)\n+            vec.as_slice().starts_with(vec.as_slice())\n         })\n     }\n \n     #[bench]\n     fn starts_with_single_element(b: &mut Bencher) {\n-        let vec: ~[uint] = ~[0u];\n+        let vec: Vec<uint> = vec![0];\n         b.iter(|| {\n-            vec.starts_with(vec)\n+            vec.as_slice().starts_with(vec.as_slice())\n         })\n     }\n \n     #[bench]\n     fn starts_with_diff_one_element_at_end(b: &mut Bencher) {\n-        let vec: ~[uint] = slice::from_fn(100, |i| i);\n-        let mut match_vec: ~[uint] = slice::from_fn(99, |i| i);\n+        let vec: Vec<uint> = Vec::from_fn(100, |i| i);\n+        let mut match_vec: Vec<uint> = Vec::from_fn(99, |i| i);\n         match_vec.push(0);\n         b.iter(|| {\n-            vec.starts_with(match_vec)\n+            vec.as_slice().starts_with(match_vec.as_slice())\n         })\n     }\n \n     #[bench]\n     fn ends_with_same_vector(b: &mut Bencher) {\n-        let vec: ~[uint] = slice::from_fn(100, |i| i);\n+        let vec: Vec<uint> = Vec::from_fn(100, |i| i);\n         b.iter(|| {\n-            vec.ends_with(vec)\n+            vec.as_slice().ends_with(vec.as_slice())\n         })\n     }\n \n     #[bench]\n     fn ends_with_single_element(b: &mut Bencher) {\n-        let vec: ~[uint] = ~[0u];\n+        let vec: Vec<uint> = vec![0];\n         b.iter(|| {\n-            vec.ends_with(vec)\n+            vec.as_slice().ends_with(vec.as_slice())\n         })\n     }\n \n     #[bench]\n     fn ends_with_diff_one_element_at_beginning(b: &mut Bencher) {\n-        let vec: ~[uint] = slice::from_fn(100, |i| i);\n-        let mut match_vec: ~[uint] = slice::from_fn(100, |i| i);\n-        match_vec[0] = 200;\n+        let vec: Vec<uint> = Vec::from_fn(100, |i| i);\n+        let mut match_vec: Vec<uint> = Vec::from_fn(100, |i| i);\n+        match_vec.as_mut_slice()[0] = 200;\n         b.iter(|| {\n-            vec.starts_with(match_vec)\n+            vec.as_slice().starts_with(match_vec.as_slice())\n         })\n     }\n \n     #[bench]\n     fn contains_last_element(b: &mut Bencher) {\n-        let vec: ~[uint] = slice::from_fn(100, |i| i);\n+        let vec: Vec<uint> = Vec::from_fn(100, |i| i);\n         b.iter(|| {\n             vec.contains(&99u)\n         })\n@@ -4428,14 +3814,14 @@ mod bench {\n     #[bench]\n     fn zero_1kb_from_elem(b: &mut Bencher) {\n         b.iter(|| {\n-            let _v: ~[u8] = slice::from_elem(1024, 0u8);\n+            Vec::from_elem(1024, 0u8)\n         });\n     }\n \n     #[bench]\n     fn zero_1kb_set_memory(b: &mut Bencher) {\n         b.iter(|| {\n-            let mut v: ~[u8] = slice::with_capacity(1024);\n+            let mut v: Vec<uint> = Vec::with_capacity(1024);\n             unsafe {\n                 let vp = v.as_mut_ptr();\n                 ptr::set_memory(vp, 0, 1024);\n@@ -4454,23 +3840,21 @@ mod bench {\n \n     #[bench]\n     fn zero_1kb_loop_set(b: &mut Bencher) {\n-        // Slower because the { len, cap, [0 x T] }* repr allows a pointer to the length\n-        // field to be aliased (in theory) and prevents LLVM from optimizing loads away.\n         b.iter(|| {\n-            let mut v: ~[u8] = slice::with_capacity(1024);\n+            let mut v: Vec<uint> = Vec::with_capacity(1024);\n             unsafe {\n                 v.set_len(1024);\n             }\n             for i in range(0u, 1024) {\n-                v[i] = 0;\n+                *v.get_mut(i) = 0;\n             }\n         });\n     }\n \n     #[bench]\n     fn zero_1kb_mut_iter(b: &mut Bencher) {\n         b.iter(|| {\n-            let mut v: ~[u8] = slice::with_capacity(1024);\n+            let mut v = Vec::with_capacity(1024);\n             unsafe {\n                 v.set_len(1024);\n             }\n@@ -4485,7 +3869,7 @@ mod bench {\n     fn random_inserts(b: &mut Bencher) {\n         let mut rng = weak_rng();\n         b.iter(|| {\n-                let mut v = slice::from_elem(30, (0u, 0u));\n+                let mut v = Vec::from_elem(30, (0u, 0u));\n                 for _ in range(0, 100) {\n                     let l = v.len();\n                     v.insert(rng.gen::<uint>() % (l + 1),\n@@ -4497,7 +3881,7 @@ mod bench {\n     fn random_removes(b: &mut Bencher) {\n         let mut rng = weak_rng();\n         b.iter(|| {\n-                let mut v = slice::from_elem(130, (0u, 0u));\n+                let mut v = Vec::from_elem(130, (0u, 0u));\n                 for _ in range(0, 100) {\n                     let l = v.len();\n                     v.remove(rng.gen::<uint>() % l);\n@@ -4537,11 +3921,11 @@ mod bench {\n \n     #[bench]\n     fn sort_sorted(b: &mut Bencher) {\n-        let mut v = slice::from_fn(10000, |i| i);\n+        let mut v = Vec::from_fn(10000, |i| i);\n         b.iter(|| {\n             v.sort();\n         });\n-        b.bytes = (v.len() * mem::size_of_val(&v[0])) as u64;\n+        b.bytes = (v.len() * mem::size_of_val(v.get(0))) as u64;\n     }\n \n     type BigSortable = (u64,u64,u64,u64);\n@@ -4578,10 +3962,10 @@ mod bench {\n \n     #[bench]\n     fn sort_big_sorted(b: &mut Bencher) {\n-        let mut v = slice::from_fn(10000u, |i| (i, i, i, i));\n+        let mut v = Vec::from_fn(10000u, |i| (i, i, i, i));\n         b.iter(|| {\n             v.sort();\n         });\n-        b.bytes = (v.len() * mem::size_of_val(&v[0])) as u64;\n+        b.bytes = (v.len() * mem::size_of_val(v.get(0))) as u64;\n     }\n }"}, {"sha": "ed4a8c652f7318a7f49585a32f81a626d0c8e136", "filename": "src/libstd/str.rs", "status": "modified", "additions": 31, "deletions": 62, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -80,7 +80,7 @@ use char;\n use char::Char;\n use clone::Clone;\n use cmp::{Eq, TotalEq, Ord, TotalOrd, Equiv, Ordering};\n-use container::{Container, Mutable};\n+use container::Container;\n use fmt;\n use io::Writer;\n use iter::{Iterator, FromIterator, Extendable, range};\n@@ -92,7 +92,7 @@ use option::{None, Option, Some};\n use ptr;\n use from_str::FromStr;\n use slice;\n-use slice::{OwnedVector, OwnedCloneableVector, ImmutableVector, MutableVector};\n+use slice::{OwnedVector, ImmutableVector, MutableVector};\n use slice::{Vector};\n use vec::Vec;\n use default::Default;\n@@ -588,7 +588,7 @@ enum NormalizationForm {\n pub struct Normalizations<'a> {\n     kind: NormalizationForm,\n     iter: Chars<'a>,\n-    buffer: ~[(char, u8)],\n+    buffer: Vec<(char, u8)>,\n     sorted: bool\n }\n \n@@ -597,7 +597,7 @@ impl<'a> Iterator<char> for Normalizations<'a> {\n     fn next(&mut self) -> Option<char> {\n         use unicode::decompose::canonical_combining_class;\n \n-        match self.buffer.head() {\n+        match self.buffer.as_slice().head() {\n             Some(&(c, 0)) => {\n                 self.sorted = false;\n                 self.buffer.shift();\n@@ -622,7 +622,7 @@ impl<'a> Iterator<char> for Normalizations<'a> {\n                 decomposer(ch, |d| {\n                     let class = canonical_combining_class(d);\n                     if class == 0 && !*sorted {\n-                        canonical_sort(*buffer);\n+                        canonical_sort(buffer.as_mut_slice());\n                         *sorted = true;\n                     }\n                     buffer.push((d, class));\n@@ -632,7 +632,7 @@ impl<'a> Iterator<char> for Normalizations<'a> {\n         }\n \n         if !self.sorted {\n-            canonical_sort(self.buffer);\n+            canonical_sort(self.buffer.as_mut_slice());\n             self.sorted = true;\n         }\n \n@@ -1336,22 +1336,23 @@ impl<'a> fmt::Show for MaybeOwned<'a> {\n pub mod raw {\n     use cast;\n     use container::Container;\n+    use iter::Iterator;\n     use libc;\n-    use ptr;\n     use ptr::RawPtr;\n-    use str::{is_utf8, OwnedStr, StrSlice};\n-    use slice;\n-    use slice::{MutableVector, ImmutableVector, OwnedVector};\n+    use ptr;\n     use raw::Slice;\n+    use slice::{MutableVector, ImmutableVector, OwnedVector, Vector};\n+    use str::{is_utf8, StrSlice};\n+    use vec::Vec;\n \n     /// Create a Rust string from a *u8 buffer of the given length\n     pub unsafe fn from_buf_len(buf: *u8, len: uint) -> ~str {\n-        let mut v: ~[u8] = slice::with_capacity(len);\n+        let mut v = Vec::with_capacity(len);\n         ptr::copy_memory(v.as_mut_ptr(), buf, len);\n         v.set_len(len);\n \n-        assert!(is_utf8(v));\n-        ::cast::transmute(v)\n+        assert!(is_utf8(v.as_slice()));\n+        ::cast::transmute(v.move_iter().collect::<~[u8]>())\n     }\n \n     #[lang=\"strdup_uniq\"]\n@@ -1594,16 +1595,6 @@ impl Container for ~str {\n     fn len(&self) -> uint { self.as_slice().len() }\n }\n \n-impl Mutable for ~str {\n-    /// Remove all content, make the string empty\n-    #[inline]\n-    fn clear(&mut self) {\n-        unsafe {\n-            self.set_len(0)\n-        }\n-    }\n-}\n-\n /// Methods for string slices\n pub trait StrSlice<'a> {\n     /// Returns true if one string contains another\n@@ -2396,7 +2387,7 @@ impl<'a> StrSlice<'a> for &'a str {\n     fn nfd_chars(&self) -> Normalizations<'a> {\n         Normalizations {\n             iter: self.chars(),\n-            buffer: ~[],\n+            buffer: Vec::new(),\n             sorted: false,\n             kind: NFD\n         }\n@@ -2406,7 +2397,7 @@ impl<'a> StrSlice<'a> for &'a str {\n     fn nfkd_chars(&self) -> Normalizations<'a> {\n         Normalizations {\n             iter: self.chars(),\n-            buffer: ~[],\n+            buffer: Vec::new(),\n             sorted: false,\n             kind: NFKD\n         }\n@@ -2544,22 +2535,22 @@ impl<'a> StrSlice<'a> for &'a str {\n     fn to_owned(&self) -> ~str {\n         let len = self.len();\n         unsafe {\n-            let mut v = slice::with_capacity(len);\n+            let mut v = Vec::with_capacity(len);\n \n             ptr::copy_memory(v.as_mut_ptr(), self.as_ptr(), len);\n             v.set_len(len);\n-            ::cast::transmute(v)\n+            ::cast::transmute(v.move_iter().collect::<~[u8]>())\n         }\n     }\n \n     fn to_utf16(&self) -> ~[u16] {\n-        let mut u = ~[];\n+        let mut u = Vec::new();;\n         for ch in self.chars() {\n             let mut buf = [0u16, ..2];\n             let n = ch.encode_utf16(buf /* as mut slice! */);\n             u.push_all(buf.slice_to(n));\n         }\n-        u\n+        u.move_iter().collect()\n     }\n \n     #[inline]\n@@ -2694,29 +2685,30 @@ impl<'a> StrSlice<'a> for &'a str {\n         if slen == 0 { return tlen; }\n         if tlen == 0 { return slen; }\n \n-        let mut dcol = slice::from_fn(tlen + 1, |x| x);\n+        let mut dcol = Vec::from_fn(tlen + 1, |x| x);\n \n         for (i, sc) in self.chars().enumerate() {\n \n             let mut current = i;\n-            dcol[0] = current + 1;\n+            *dcol.get_mut(0) = current + 1;\n \n             for (j, tc) in t.chars().enumerate() {\n \n-                let next = dcol[j + 1];\n+                let next = *dcol.get(j + 1);\n \n                 if sc == tc {\n-                    dcol[j + 1] = current;\n+                    *dcol.get_mut(j + 1) = current;\n                 } else {\n-                    dcol[j + 1] = ::cmp::min(current, next);\n-                    dcol[j + 1] = ::cmp::min(dcol[j + 1], dcol[j]) + 1;\n+                    *dcol.get_mut(j + 1) = ::cmp::min(current, next);\n+                    *dcol.get_mut(j + 1) = ::cmp::min(*dcol.get(j + 1),\n+                                                      *dcol.get(j)) + 1;\n                 }\n \n                 current = next;\n             }\n         }\n \n-        return dcol[tlen];\n+        return *dcol.get(tlen);\n     }\n \n     fn subslice_offset(&self, inner: &str) -> uint {\n@@ -2738,43 +2730,21 @@ impl<'a> StrSlice<'a> for &'a str {\n \n /// Methods for owned strings\n pub trait OwnedStr {\n-    /// Shorten a string to the specified length (which must be <= the current length)\n-    fn truncate(&mut self, len: uint);\n-\n     /// Consumes the string, returning the underlying byte buffer.\n     ///\n     /// The buffer does not have a null terminator.\n     fn into_bytes(self) -> ~[u8];\n \n-    /// Sets the length of a string\n-    ///\n-    /// This will explicitly set the size of the string, without actually\n-    /// modifying its buffers, so it is up to the caller to ensure that\n-    /// the string is actually the specified size.\n-    unsafe fn set_len(&mut self, new_len: uint);\n-\n     /// Pushes the given string onto this string, returning the concatenation of the two strings.\n     fn append(self, rhs: &str) -> ~str;\n }\n \n impl OwnedStr for ~str {\n-    #[inline]\n-    fn truncate(&mut self, len: uint) {\n-        assert!(len <= self.len());\n-        assert!(self.is_char_boundary(len));\n-        unsafe { self.set_len(len); }\n-    }\n-\n     #[inline]\n     fn into_bytes(self) -> ~[u8] {\n         unsafe { cast::transmute(self) }\n     }\n \n-    #[inline]\n-    unsafe fn set_len(&mut self, new_len: uint) {\n-        raw::as_owned_vec(self).set_len(new_len)\n-    }\n-\n     #[inline]\n     fn append(self, rhs: &str) -> ~str {\n         let mut new_str = StrBuf::from_owned_str(self);\n@@ -3409,8 +3379,7 @@ mod tests {\n         assert_eq!(a.subslice_offset(c), 0);\n \n         let string = \"a\\nb\\nc\";\n-        let mut lines = ~[];\n-        for line in string.lines() { lines.push(line) }\n+        let lines: ~[&str] = string.lines().collect();\n         assert_eq!(string.subslice_offset(lines[0]), 0);\n         assert_eq!(string.subslice_offset(lines[1]), 2);\n         assert_eq!(string.subslice_offset(lines[2]), 4);\n@@ -4259,9 +4228,9 @@ mod bench {\n \n     #[bench]\n     fn from_utf8_lossy_100_invalid(b: &mut Bencher) {\n-        let s = ::slice::from_elem(100, 0xF5u8);\n+        let s = Vec::from_elem(100, 0xF5u8);\n         b.iter(|| {\n-            let _ = from_utf8_lossy(s);\n+            let _ = from_utf8_lossy(s.as_slice());\n         });\n     }\n "}, {"sha": "498a6252a8fb90f937d9e1d43462e17e9fffef6e", "filename": "src/libstd/sync/arc.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fsync%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fsync%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Farc.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -23,12 +23,13 @@\n \n use cast;\n use clone::Clone;\n+use iter::Iterator;\n use kinds::Send;\n use ops::Drop;\n use ptr::RawPtr;\n use sync::atomics::{fence, AtomicUint, Relaxed, Acquire, Release};\n-use slice;\n use ty::Unsafe;\n+use vec::Vec;\n \n /// An atomically reference counted pointer.\n ///\n@@ -73,7 +74,8 @@ impl<T: Send> UnsafeArc<T> {\n                 ~[] // need to free data here\n             } else {\n                 let ptr = new_inner(data, num_handles);\n-                slice::from_fn(num_handles, |_| UnsafeArc { data: ptr })\n+                let v = Vec::from_fn(num_handles, |_| UnsafeArc { data: ptr });\n+                v.move_iter().collect()\n             }\n         }\n     }"}, {"sha": "97239707d329af6a8ba106a700f88bb1beb67981", "filename": "src/libstd/sync/deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fdeque.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -61,7 +61,7 @@ use ptr::RawPtr;\n use sync::arc::UnsafeArc;\n use sync::atomics::{AtomicInt, AtomicPtr, SeqCst};\n use unstable::sync::Exclusive;\n-use slice::{OwnedVector, ImmutableVector};\n+use slice::ImmutableVector;\n use vec::Vec;\n \n // Once the queue is less than 1/K full, then it will be downsized. Note that"}, {"sha": "b7f6d730d12bc11249469c44ec2dd6319e0622d8", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -115,7 +115,7 @@ mod tests {\n     #[test]\n     fn exclusive_new_arc() {\n         unsafe {\n-            let mut futures = ~[];\n+            let mut futures = Vec::new();\n \n             let num_tasks = 10;\n             let count = 10;"}, {"sha": "5480805478c0a7188e2f16f0ff8861a5bb6b65d1", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -614,13 +614,9 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n-        // See the comment in as_slice() for what's going on here.\n-        let slice = if mem::size_of::<T>() == 0 {\n-            Slice { data: 1 as *T, len: self.len }\n-        } else {\n-            Slice { data: self.ptr as *T, len: self.len }\n-        };\n-        unsafe { transmute(slice) }\n+        unsafe {\n+            transmute(Slice { data: self.as_mut_ptr() as *T, len: self.len })\n+        }\n     }\n \n     /// Creates a consuming iterator, that is, one that moves each\n@@ -1143,7 +1139,15 @@ impl<T> Vec<T> {\n     /// would also make any pointers to it invalid.\n     #[inline]\n     pub fn as_ptr(&self) -> *T {\n-        self.as_slice().as_ptr()\n+        // If we have a 0-sized vector, then the base pointer should not be NULL\n+        // because an iterator over the slice will attempt to yield the base\n+        // pointer as the first element in the vector, but this will end up\n+        // being Some(NULL) which is optimized to None.\n+        if mem::size_of::<T>() == 0 {\n+            1 as *T\n+        } else {\n+            self.ptr as *T\n+        }\n     }\n \n     /// Returns a mutable unsafe pointer to the vector's buffer.\n@@ -1155,7 +1159,12 @@ impl<T> Vec<T> {\n     /// would also make any pointers to it invalid.\n     #[inline]\n     pub fn as_mut_ptr(&mut self) -> *mut T {\n-        self.as_mut_slice().as_mut_ptr()\n+        // see above for the 0-size check\n+        if mem::size_of::<T>() == 0 {\n+            1 as *mut T\n+        } else {\n+            self.ptr\n+        }\n     }\n \n     /// Retains only the elements specified by the predicate.\n@@ -1356,16 +1365,7 @@ impl<T> Vector<T> for Vec<T> {\n     /// ```\n     #[inline]\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n-        // If we have a 0-sized vector, then the base pointer should not be NULL\n-        // because an iterator over the slice will attempt to yield the base\n-        // pointer as the first element in the vector, but this will end up\n-        // being Some(NULL) which is optimized to None.\n-        let slice = if mem::size_of::<T>() == 0 {\n-            Slice { data: 1 as *T, len: self.len }\n-        } else {\n-            Slice { data: self.ptr as *T, len: self.len }\n-        };\n-        unsafe { transmute(slice) }\n+        unsafe { transmute(Slice { data: self.as_ptr(), len: self.len }) }\n     }\n }\n "}, {"sha": "84021f6362b7c9c1a916ec98a1ff0a3d837a08d2", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -20,7 +20,6 @@ use rsparse = parse;\n \n use std::fmt::parse;\n use collections::{HashMap, HashSet};\n-use std::slice;\n \n #[deriving(Eq)]\n enum ArgumentType {\n@@ -609,7 +608,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     fn to_expr(&self, extra: @ast::Expr) -> @ast::Expr {\n         let mut lets = Vec::new();\n         let mut locals = Vec::new();\n-        let mut names = slice::from_fn(self.name_positions.len(), |_| None);\n+        let mut names = Vec::from_fn(self.name_positions.len(), |_| None);\n         let mut pats = Vec::new();\n         let mut heads = Vec::new();\n \n@@ -673,7 +672,7 @@ impl<'a, 'b> Context<'a, 'b> {\n             let lname = self.ecx.ident_of(format!(\"__arg{}\", *name));\n             pats.push(self.ecx.pat_ident(e.span, lname));\n             heads.push(self.ecx.expr_addr_of(e.span, e));\n-            names[*self.name_positions.get(name)] =\n+            *names.get_mut(*self.name_positions.get(name)) =\n                 Some(self.format_arg(e.span,\n                                      Named((*name).clone()),\n                                      self.ecx.expr_ident(e.span, lname)));"}, {"sha": "4405245b9a0e1279e72add3e5bb5d55cc47598e2", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -16,7 +16,6 @@ use collections::{TrieMap, TreeMap, HashMap, HashSet};\n use std::os;\n use rand::{Rng, IsaacRng, SeedableRng};\n use std::uint;\n-use std::slice;\n \n fn timed(label: &str, f: ||) {\n     let start = time::precise_time_s();\n@@ -99,7 +98,7 @@ fn main() {\n         }\n     };\n \n-    let mut rand = slice::with_capacity(n_keys);\n+    let mut rand = Vec::with_capacity(n_keys);\n \n     {\n         let mut rng: IsaacRng = SeedableRng::from_seed(&[1, 1, 1, 1, 1, 1, 1]);\n@@ -130,7 +129,7 @@ fn main() {\n     {\n         println!(\" Random integers:\");\n         let mut map: TreeMap<uint,uint> = TreeMap::new();\n-        vector(&mut map, n_keys, rand);\n+        vector(&mut map, n_keys, rand.as_slice());\n     }\n \n     // FIXME: #9970\n@@ -149,7 +148,7 @@ fn main() {\n     {\n         println!(\" Random integers:\");\n         let mut map: HashMap<uint,uint> = HashMap::new();\n-        vector(&mut map, n_keys, rand);\n+        vector(&mut map, n_keys, rand.as_slice());\n     }\n \n     // FIXME: #9970\n@@ -168,6 +167,6 @@ fn main() {\n     {\n         println!(\" Random integers:\");\n         let mut map: TrieMap<uint> = TrieMap::new();\n-        vector(&mut map, n_keys, rand);\n+        vector(&mut map, n_keys, rand.as_slice());\n     }\n }"}, {"sha": "fbea63e65f1264f4be72327b0e87c734e5bf0894", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use std::os;\n-use std::slice;\n \n fn max(a: i32, b: i32) -> i32 {\n     if a > b {\n@@ -20,13 +19,17 @@ fn max(a: i32, b: i32) -> i32 {\n }\n \n fn fannkuch_redux(n: i32) -> i32 {\n-    let mut perm = slice::from_elem(n as uint, 0i32);\n-    let mut perm1 = slice::from_fn(n as uint, |i| i as i32);\n-    let mut count = slice::from_elem(n as uint, 0i32);\n+    let mut perm = Vec::from_elem(n as uint, 0i32);\n+    let mut perm1 = Vec::from_fn(n as uint, |i| i as i32);\n+    let mut count = Vec::from_elem(n as uint, 0i32);\n     let mut max_flips_count = 0i32;\n     let mut perm_count = 0i32;\n     let mut checksum = 0i32;\n \n+    let perm = perm.as_mut_slice();\n+    let perm1 = perm1.as_mut_slice();\n+    let count = count.as_mut_slice();\n+\n     let mut r = n;\n     loop {\n         while r != 1 {"}, {"sha": "01b75fa422f924474eb9a2e5bdfcb6923e740bc8", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -12,7 +12,6 @@ use std::cmp::min;\n use std::io::{stdout, IoResult};\n use std::os;\n use std::slice::bytes::copy_memory;\n-use std::slice;\n \n static LINE_LEN: uint = 60;\n static LOOKUP_SIZE: uint = 4 * 1024;\n@@ -90,10 +89,10 @@ impl<'a, W: Writer> RepeatFasta<'a, W> {\n \n     fn make(&mut self, n: uint) -> IoResult<()> {\n         let alu_len = self.alu.len();\n-        let mut buf = slice::from_elem(alu_len + LINE_LEN, 0u8);\n+        let mut buf = Vec::from_elem(alu_len + LINE_LEN, 0u8);\n         let alu: &[u8] = self.alu.as_bytes();\n \n-        copy_memory(buf, alu);\n+        copy_memory(buf.as_mut_slice(), alu);\n         let buf_len = buf.len();\n         copy_memory(buf.mut_slice(alu_len, buf_len),\n                     alu.slice_to(LINE_LEN));"}, {"sha": "f0cdc020dc371a44931efb5f3a818a247b6c2717", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -14,7 +14,6 @@ use std::from_str::FromStr;\n use std::iter::count;\n use std::cmp::min;\n use std::os;\n-use std::slice::from_elem;\n use sync::{Arc, RWLock};\n \n fn A(i: uint, j: uint) -> f64 {"}, {"sha": "537f3c9f48a99ea0a384e9408c7556c13fa25991", "filename": "src/test/compile-fail/lint-deprecated-owned-vector.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Ftest%2Fcompile-fail%2Flint-deprecated-owned-vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Ftest%2Fcompile-fail%2Flint-deprecated-owned-vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-deprecated-owned-vector.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -13,5 +13,4 @@\n fn main() {\n     ~[1]; //~ ERROR use of deprecated `~[]`\n     //~^ ERROR use of deprecated `~[]`\n-    std::slice::with_capacity::<int>(10); //~ ERROR use of deprecated `~[]`\n }"}, {"sha": "3a4844301d62e51f6a839363b8b94671a648d93a", "filename": "src/test/compile-fail/lint-unused-imports.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -29,7 +29,12 @@ use test::B;\n \n // Make sure this import is warned about when at least one of its imported names\n // is unused\n-use std::slice::{from_fn, from_elem};   //~ ERROR unused import\n+use test2::{foo, bar}; //~ ERROR unused import\n+\n+mod test2 {\n+    pub fn foo() {}\n+    pub fn bar() {}\n+}\n \n mod test {\n     pub trait A { fn a(&self) {} }\n@@ -66,5 +71,5 @@ fn main() {\n     let mut b = 4;\n     swap(&mut a, &mut b);\n     test::C.b();\n-    let _a = from_elem(0, 0);\n+    let _a = foo();\n }"}, {"sha": "bf4e15c7ef51f1427784ac9092a711ef6b27ead0", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1d8497e53af86687e701eea0fe2a41b0c4313eb/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=d1d8497e53af86687e701eea0fe2a41b0c4313eb", "patch": "@@ -36,7 +36,7 @@ fn double() {\n }\n \n fn runtest(me: &str) {\n-    let mut env = os::env();\n+    let mut env = os::env().move_iter().collect::<Vec<(~str, ~str)>>();\n     match env.iter().position(|&(ref s, _)| \"RUST_BACKTRACE\" == *s) {\n         Some(i) => { env.remove(i); }\n         None => {}"}]}