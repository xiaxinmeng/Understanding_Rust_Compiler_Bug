{"sha": "e9d166fac54dc3944e293121c732ff709acfd9e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5ZDE2NmZhYzU0ZGMzOTQ0ZTI5MzEyMWM3MzJmZjcwOWFjZmQ5ZTM=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2020-02-08T04:18:34Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2020-03-14T21:52:29Z"}, "message": "Clean up the collector", "tree": {"sha": "98e4f36a8b339328869ed668ce9a796f149614e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98e4f36a8b339328869ed668ce9a796f149614e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9d166fac54dc3944e293121c732ff709acfd9e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9d166fac54dc3944e293121c732ff709acfd9e3", "html_url": "https://github.com/rust-lang/rust/commit/e9d166fac54dc3944e293121c732ff709acfd9e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9d166fac54dc3944e293121c732ff709acfd9e3/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa09db846832aa106264a449ae625e143b605319", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa09db846832aa106264a449ae625e143b605319", "html_url": "https://github.com/rust-lang/rust/commit/fa09db846832aa106264a449ae625e143b605319"}], "stats": {"total": 173, "additions": 34, "deletions": 139}, "files": [{"sha": "b9ab43ed289ca193de064daf8fb7d65b28f0b4b8", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 25, "deletions": 107, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/e9d166fac54dc3944e293121c732ff709acfd9e3/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d166fac54dc3944e293121c732ff709acfd9e3/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=e9d166fac54dc3944e293121c732ff709acfd9e3", "patch": "@@ -1,7 +1,6 @@\n use crate::arena::Arena;\n-use crate::dep_graph::{DepGraph, DepKind, DepNode, DepNodeIndex};\n use crate::hir::map::definitions::{self, DefPathHash};\n-use crate::hir::map::{Entry, HirEntryMap, Map};\n+use crate::hir::map::{Entry, Map};\n use crate::hir::{HirItem, HirOwner, HirOwnerItems};\n use crate::ich::StableHashingContext;\n use crate::middle::cstore::CrateStore;\n@@ -35,70 +34,38 @@ pub(super) struct NodeCollector<'a, 'hir> {\n     owner_map: FxHashMap<DefIndex, &'hir HirOwner<'hir>>,\n     owner_items_map: FxHashMap<DefIndex, &'hir mut HirOwnerItems<'hir>>,\n \n-    /// The node map\n-    map: HirEntryMap<'hir>,\n     /// The parent of this node\n     parent_node: hir::HirId,\n \n-    // These fields keep track of the currently relevant DepNodes during\n-    // the visitor's traversal.\n     current_dep_node_owner: DefIndex,\n-    current_signature_dep_index: DepNodeIndex,\n-    current_full_dep_index: DepNodeIndex,\n-    currently_in_body: bool,\n \n-    dep_graph: &'a DepGraph,\n     definitions: &'a definitions::Definitions,\n     hir_to_node_id: &'a FxHashMap<HirId, NodeId>,\n \n     hcx: StableHashingContext<'a>,\n \n     // We are collecting `DepNode::HirBody` hashes here so we can compute the\n-    // crate hash from then later on.\n+    // crate hash from them later on.\n     hir_body_nodes: Vec<(DefPathHash, Fingerprint)>,\n }\n \n-fn input_dep_node_and_hash(\n-    dep_graph: &DepGraph,\n+fn hash(\n     hcx: &mut StableHashingContext<'_>,\n-    dep_node: DepNode,\n     input: impl for<'a> HashStable<StableHashingContext<'a>>,\n-) -> (DepNodeIndex, Fingerprint) {\n-    let dep_node_index = dep_graph.input_task(dep_node, &mut *hcx, &input).1;\n-\n-    let hash = if dep_graph.is_fully_enabled() {\n-        dep_graph.fingerprint_of(dep_node_index)\n-    } else {\n-        let mut stable_hasher = StableHasher::new();\n-        input.hash_stable(hcx, &mut stable_hasher);\n-        stable_hasher.finish()\n-    };\n-\n-    (dep_node_index, hash)\n+) -> Fingerprint {\n+    let mut stable_hasher = StableHasher::new();\n+    input.hash_stable(hcx, &mut stable_hasher);\n+    stable_hasher.finish()\n }\n \n-fn alloc_hir_dep_nodes(\n-    dep_graph: &DepGraph,\n+fn hash_body(\n     hcx: &mut StableHashingContext<'_>,\n     def_path_hash: DefPathHash,\n     item_like: impl for<'a> HashStable<StableHashingContext<'a>>,\n     hir_body_nodes: &mut Vec<(DefPathHash, Fingerprint)>,\n-) -> (DepNodeIndex, DepNodeIndex) {\n-    let sig = dep_graph\n-        .input_task(\n-            DepNode::from_def_path_hash(def_path_hash, DepKind::Hir),\n-            &mut *hcx,\n-            HirItemLike { item_like: &item_like, hash_bodies: false },\n-        )\n-        .1;\n-    let (full, hash) = input_dep_node_and_hash(\n-        dep_graph,\n-        hcx,\n-        DepNode::from_def_path_hash(def_path_hash, DepKind::HirBody),\n-        HirItemLike { item_like: &item_like, hash_bodies: true },\n-    );\n+) {\n+    let hash = hash(hcx, HirItemLike { item_like: &item_like });\n     hir_body_nodes.push((def_path_hash, hash));\n-    (sig, full)\n }\n \n fn upstream_crates(cstore: &dyn CrateStore) -> Vec<(Symbol, Fingerprint, Svh)> {\n@@ -121,7 +88,6 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         sess: &'a Session,\n         arena: &'hir Arena<'hir>,\n         krate: &'hir Crate<'hir>,\n-        dep_graph: &'a DepGraph,\n         definitions: &'a definitions::Definitions,\n         hir_to_node_id: &'a FxHashMap<HirId, NodeId>,\n         mut hcx: StableHashingContext<'a>,\n@@ -130,8 +96,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n \n         let mut hir_body_nodes = Vec::new();\n \n-        // Allocate `DepNode`s for the root module.\n-        let (root_mod_sig_dep_index, root_mod_full_dep_index) = {\n+        {\n             let Crate {\n                 ref item,\n                 // These fields are handled separately:\n@@ -147,40 +112,31 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n                 proc_macros: _,\n             } = *krate;\n \n-            alloc_hir_dep_nodes(\n-                dep_graph,\n-                &mut hcx,\n-                root_mod_def_path_hash,\n-                item,\n-                &mut hir_body_nodes,\n-            )\n+            hash_body(&mut hcx, root_mod_def_path_hash, item, &mut hir_body_nodes)\n         };\n \n         let mut collector = NodeCollector {\n             arena,\n             krate,\n             source_map: sess.source_map(),\n-            map: IndexVec::from_elem_n(IndexVec::new(), definitions.def_index_count()),\n             parent_node: hir::CRATE_HIR_ID,\n-            current_signature_dep_index: root_mod_sig_dep_index,\n-            current_full_dep_index: root_mod_full_dep_index,\n             current_dep_node_owner: CRATE_DEF_INDEX,\n-            currently_in_body: false,\n-            dep_graph,\n             definitions,\n             hir_to_node_id,\n             hcx,\n             hir_body_nodes,\n-            owner_map: FxHashMap::default(),\n-            owner_items_map: FxHashMap::default(),\n+            owner_map: FxHashMap::with_capacity_and_hasher(\n+                definitions.def_index_count(),\n+                Default::default(),\n+            ),\n+            owner_items_map: FxHashMap::with_capacity_and_hasher(\n+                definitions.def_index_count(),\n+                Default::default(),\n+            ),\n         };\n         collector.insert_entry(\n             hir::CRATE_HIR_ID,\n-            Entry {\n-                parent: hir::CRATE_HIR_ID,\n-                dep_node: root_mod_sig_dep_index,\n-                node: Node::Crate(&krate.item),\n-            },\n+            Entry { parent: hir::CRATE_HIR_ID, node: Node::Crate(&krate.item) },\n         );\n \n         collector\n@@ -192,7 +148,6 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         cstore: &dyn CrateStore,\n         commandline_args_hash: u64,\n     ) -> (\n-        HirEntryMap<'hir>,\n         FxHashMap<DefIndex, &'hir HirOwner<'hir>>,\n         FxHashMap<DefIndex, &'hir mut HirOwnerItems<'hir>>,\n         Svh,\n@@ -239,7 +194,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         let crate_hash: Fingerprint = stable_hasher.finish();\n \n         let svh = Svh::new(crate_hash.to_smaller_hash());\n-        (self.map, self.owner_map, self.owner_items_map, svh)\n+        (self.owner_map, self.owner_items_map, svh)\n     }\n \n     fn insert_entry(&mut self, id: HirId, entry: Entry<'hir>) {\n@@ -266,26 +221,10 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             items.items[id.local_id] =\n                 Some(HirItem { parent: entry.parent.local_id, node: entry.node });\n         }\n-\n-        debug!(\"hir_map: {:?} => {:?}\", id, entry);\n-        let local_map = &mut self.map[id.owner];\n-        let len = local_map.len();\n-        if i >= len {\n-            local_map.extend(repeat(None).take(i - len + 1));\n-        }\n-        local_map[id.local_id] = Some(entry);\n     }\n \n     fn insert(&mut self, span: Span, hir_id: HirId, node: Node<'hir>) {\n-        let entry = Entry {\n-            parent: self.parent_node,\n-            dep_node: if self.currently_in_body {\n-                self.current_full_dep_index\n-            } else {\n-                self.current_signature_dep_index\n-            },\n-            node,\n-        };\n+        let entry = Entry { parent: self.parent_node, node };\n \n         // Make sure that the DepNode of some node coincides with the HirId\n         // owner of that node.\n@@ -340,29 +279,14 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         f: F,\n     ) {\n         let prev_owner = self.current_dep_node_owner;\n-        let prev_signature_dep_index = self.current_signature_dep_index;\n-        let prev_full_dep_index = self.current_full_dep_index;\n-        let prev_in_body = self.currently_in_body;\n \n         let def_path_hash = self.definitions.def_path_hash(dep_node_owner);\n \n-        let (signature_dep_index, full_dep_index) = alloc_hir_dep_nodes(\n-            self.dep_graph,\n-            &mut self.hcx,\n-            def_path_hash,\n-            item_like,\n-            &mut self.hir_body_nodes,\n-        );\n-        self.current_signature_dep_index = signature_dep_index;\n-        self.current_full_dep_index = full_dep_index;\n+        hash_body(&mut self.hcx, def_path_hash, item_like, &mut self.hir_body_nodes);\n \n         self.current_dep_node_owner = dep_node_owner;\n-        self.currently_in_body = false;\n         f(self);\n-        self.currently_in_body = prev_in_body;\n         self.current_dep_node_owner = prev_owner;\n-        self.current_full_dep_index = prev_full_dep_index;\n-        self.current_signature_dep_index = prev_signature_dep_index;\n     }\n }\n \n@@ -391,10 +315,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_nested_body(&mut self, id: BodyId) {\n-        let prev_in_body = self.currently_in_body;\n-        self.currently_in_body = true;\n         self.visit_body(self.krate.body(id));\n-        self.currently_in_body = prev_in_body;\n     }\n \n     fn visit_param(&mut self, param: &'hir Param<'hir>) {\n@@ -617,19 +538,16 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n }\n \n-// This is a wrapper structure that allows determining if span values within\n-// the wrapped item should be hashed or not.\n struct HirItemLike<T> {\n     item_like: T,\n-    hash_bodies: bool,\n }\n \n impl<'hir, T> HashStable<StableHashingContext<'hir>> for HirItemLike<T>\n where\n     T: HashStable<StableHashingContext<'hir>>,\n {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'hir>, hasher: &mut StableHasher) {\n-        hcx.while_hashing_hir_bodies(self.hash_bodies, |hcx| {\n+        hcx.while_hashing_hir_bodies(true, |hcx| {\n             self.item_like.hash_stable(hcx, hasher);\n         });\n     }"}, {"sha": "0c6415a1308a5be761df4e7f1defb3797ce12166", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9d166fac54dc3944e293121c732ff709acfd9e3/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d166fac54dc3944e293121c732ff709acfd9e3/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=e9d166fac54dc3944e293121c732ff709acfd9e3", "patch": "@@ -8,8 +8,8 @@ use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::{HirId, ItemLocalId};*/\n \n pub fn check_crate(hir_map: &EarlyMap<'_>, sess: &rustc_session::Session) {\n-    hir_map.dep_graph.assert_ignored();\n-    /*\n+    /*hir_map.dep_graph.assert_ignored();\n+\n     let errors = Lock::new(Vec::new());\n \n     par_iter(&hir_map.krate.modules).for_each(|(module_id, _)| {"}, {"sha": "96ee938a1725840110ac0c9a40c45a7e8b4a7ffa", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 4, "deletions": 26, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e9d166fac54dc3944e293121c732ff709acfd9e3/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d166fac54dc3944e293121c732ff709acfd9e3/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=e9d166fac54dc3944e293121c732ff709acfd9e3", "patch": "@@ -4,7 +4,6 @@ pub use self::definitions::{\n };\n \n use crate::arena::Arena;\n-use crate::dep_graph::{DepGraph, DepNodeIndex};\n use crate::hir::{HirOwner, HirOwnerItems};\n use crate::middle::cstore::CrateStoreDyn;\n use crate::ty::query::Providers;\n@@ -18,7 +17,6 @@ use rustc_hir::intravisit;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::print::Nested;\n use rustc_hir::*;\n-use rustc_index::vec::IndexVec;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::kw;\n@@ -34,7 +32,6 @@ mod hir_id_validator;\n #[derive(Copy, Clone, Debug)]\n pub struct Entry<'hir> {\n     parent: HirId,\n-    dep_node: DepNodeIndex,\n     node: Node<'hir>,\n }\n \n@@ -132,26 +129,16 @@ fn is_body_owner<'hir>(node: Node<'hir>, hir_id: HirId) -> bool {\n     }\n }\n \n-/// This type is effectively a `HashMap<HirId, Entry<'hir>>`,\n-/// but it is implemented as 2 layers of arrays.\n-/// - first we have `A = IndexVec<DefIndex, B>` mapping `DefIndex`s to an inner value\n-/// - which is `B = IndexVec<ItemLocalId, Option<Entry<'hir>>` which gives you the `Entry`.\n-pub(super) type HirEntryMap<'hir> = IndexVec<DefIndex, IndexVec<ItemLocalId, Option<Entry<'hir>>>>;\n-\n /// Represents a mapping from `NodeId`s to AST elements and their parent `NodeId`s.\n pub struct EarlyMap<'hir> {\n     pub krate: &'hir Crate<'hir>,\n \n-    pub dep_graph: DepGraph,\n-\n     /// The SVH of the local crate.\n     pub crate_hash: Svh,\n \n     pub(super) owner_map: FxHashMap<DefIndex, &'hir HirOwner<'hir>>,\n     pub(super) owner_items_map: FxHashMap<DefIndex, &'hir HirOwnerItems<'hir>>,\n \n-    pub(super) map: HirEntryMap<'hir>,\n-\n     pub(crate) definitions: &'hir Definitions,\n \n     /// The reverse mapping of `node_to_hir_id`.\n@@ -164,8 +151,6 @@ pub struct Map<'hir> {\n \n     pub(super) krate: &'hir Crate<'hir>,\n \n-    pub dep_graph: DepGraph,\n-\n     /// The SVH of the local crate.\n     pub crate_hash: Svh,\n \n@@ -383,15 +368,11 @@ impl<'hir> Map<'hir> {\n     fn get_entry(&self, id: HirId) -> Entry<'hir> {\n         if id.local_id == ItemLocalId::from_u32_const(0) {\n             let owner = self.tcx.hir_owner(id.owner_def_id());\n-            Entry { parent: owner.parent, node: owner.node, dep_node: DepNodeIndex::INVALID }\n+            Entry { parent: owner.parent, node: owner.node }\n         } else {\n             let owner = self.tcx.hir_owner_items(id.owner_def_id());\n             let item = owner.items[id.local_id].as_ref().unwrap();\n-            Entry {\n-                parent: HirId { owner: id.owner, local_id: item.parent },\n-                node: item.node,\n-                dep_node: DepNodeIndex::INVALID,\n-            }\n+            Entry { parent: HirId { owner: id.owner, local_id: item.parent }, node: item.node }\n         }\n     }\n \n@@ -1069,7 +1050,6 @@ pub fn map_crate<'hir>(\n     arena: &'hir Arena<'hir>,\n     cstore: &CrateStoreDyn,\n     krate: &'hir Crate<'hir>,\n-    dep_graph: DepGraph,\n     definitions: Definitions,\n ) -> EarlyMap<'hir> {\n     let _prof_timer = sess.prof.generic_activity(\"build_hir_map\");\n@@ -1081,11 +1061,11 @@ pub fn map_crate<'hir>(\n         .map(|(node_id, &hir_id)| (hir_id, node_id))\n         .collect();\n \n-    let (map, owner_map, owner_items_map, crate_hash) = {\n+    let (owner_map, owner_items_map, crate_hash) = {\n         let hcx = crate::ich::StableHashingContext::new(sess, krate, &definitions, cstore);\n \n         let mut collector =\n-            NodeCollector::root(sess, arena, krate, &dep_graph, &definitions, &hir_to_node_id, hcx);\n+            NodeCollector::root(sess, arena, krate, &definitions, &hir_to_node_id, hcx);\n         intravisit::walk_crate(&mut collector, krate);\n \n         let crate_disambiguator = sess.local_crate_disambiguator();\n@@ -1095,9 +1075,7 @@ pub fn map_crate<'hir>(\n \n     let map = EarlyMap {\n         krate,\n-        dep_graph,\n         crate_hash,\n-        map,\n         owner_map,\n         owner_items_map: owner_items_map.into_iter().map(|(k, v)| (k, &*v)).collect(),\n         hir_to_node_id,"}, {"sha": "590ad1b69956d4329fe244f90d4a3863346f3302", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9d166fac54dc3944e293121c732ff709acfd9e3/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d166fac54dc3944e293121c732ff709acfd9e3/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=e9d166fac54dc3944e293121c732ff709acfd9e3", "patch": "@@ -100,8 +100,6 @@ pub fn provide(providers: &mut Providers<'_>) {\n             tcx,\n             krate: early.krate,\n \n-            dep_graph: early.dep_graph,\n-\n             crate_hash: early.crate_hash,\n \n             owner_map: early.owner_map,"}, {"sha": "0d6c185e8ed1304dd3ede329d75d2242cc436319", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9d166fac54dc3944e293121c732ff709acfd9e3/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d166fac54dc3944e293121c732ff709acfd9e3/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=e9d166fac54dc3944e293121c732ff709acfd9e3", "patch": "@@ -1121,6 +1121,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         arena: &'tcx WorkerLocal<Arena<'tcx>>,\n         resolutions: ty::ResolverOutputs,\n         hir: hir_map::EarlyMap<'tcx>,\n+        dep_graph: DepGraph,\n         on_disk_query_result_cache: query::OnDiskCache<'tcx>,\n         crate_name: &str,\n         output_filenames: &OutputFilenames,\n@@ -1132,7 +1133,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         let common_types = CommonTypes::new(&interners);\n         let common_lifetimes = CommonLifetimes::new(&interners);\n         let common_consts = CommonConsts::new(&interners, &common_types);\n-        let dep_graph = hir.dep_graph.clone();\n         let definitions = hir.definitions;\n         let cstore = resolutions.cstore;\n         let crates = cstore.crates_untracked();"}, {"sha": "c1a373bb06b2b83c5dd3596ca2707af62e367b57", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9d166fac54dc3944e293121c732ff709acfd9e3/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d166fac54dc3944e293121c732ff709acfd9e3/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=e9d166fac54dc3944e293121c732ff709acfd9e3", "patch": "@@ -716,7 +716,7 @@ pub fn create_global_ctxt<'tcx>(\n     let defs = mem::take(&mut resolver_outputs.definitions);\n \n     // Construct the HIR map.\n-    let hir_map = map::map_crate(sess, &**arena, &*resolver_outputs.cstore, krate, dep_graph, defs);\n+    let hir_map = map::map_crate(sess, &**arena, &*resolver_outputs.cstore, krate, defs);\n \n     let query_result_on_disk_cache = rustc_incremental::load_query_result_cache(sess);\n \n@@ -743,6 +743,7 @@ pub fn create_global_ctxt<'tcx>(\n                 arena,\n                 resolver_outputs,\n                 hir_map,\n+                dep_graph,\n                 query_result_on_disk_cache,\n                 &crate_name,\n                 &outputs,"}]}