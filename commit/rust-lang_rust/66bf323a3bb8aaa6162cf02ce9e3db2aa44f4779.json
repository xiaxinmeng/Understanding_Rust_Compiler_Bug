{"sha": "66bf323a3bb8aaa6162cf02ce9e3db2aa44f4779", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2YmYzMjNhM2JiOGFhYTYxNjJjZjAyY2U5ZTNkYjJhYTQ0ZjQ3Nzk=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-30T04:42:56Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-30T04:42:56Z"}, "message": "syntax: cleanup `parse_visibility`.", "tree": {"sha": "100e2519704ef432678332e59efdc7c7083569a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/100e2519704ef432678332e59efdc7c7083569a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66bf323a3bb8aaa6162cf02ce9e3db2aa44f4779", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66bf323a3bb8aaa6162cf02ce9e3db2aa44f4779", "html_url": "https://github.com/rust-lang/rust/commit/66bf323a3bb8aaa6162cf02ce9e3db2aa44f4779", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66bf323a3bb8aaa6162cf02ce9e3db2aa44f4779/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b80ead489beab6ed1e8f0f4951b7d982bd789ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b80ead489beab6ed1e8f0f4951b7d982bd789ab", "html_url": "https://github.com/rust-lang/rust/commit/5b80ead489beab6ed1e8f0f4951b7d982bd789ab"}], "stats": {"total": 122, "additions": 69, "deletions": 53}, "files": [{"sha": "438466851856ff617d24d680a4ffa3adc153ce13", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 69, "deletions": 53, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/66bf323a3bb8aaa6162cf02ce9e3db2aa44f4779/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66bf323a3bb8aaa6162cf02ce9e3db2aa44f4779/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=66bf323a3bb8aaa6162cf02ce9e3db2aa44f4779", "patch": "@@ -1417,68 +1417,84 @@ impl<'a> Parser<'a> {\n             // `()` or a tuple might be allowed. For example, `struct Struct(pub (), pub (usize));`.\n             // Because of this, we only `bump` the `(` if we're assured it is appropriate to do so\n             // by the following tokens.\n-            if self.is_keyword_ahead(1, &[kw::Crate]) &&\n-                self.look_ahead(2, |t| t != &token::ModSep) // account for `pub(crate::foo)`\n+            if self.is_keyword_ahead(1, &[kw::Crate])\n+                && self.look_ahead(2, |t| t != &token::ModSep) // account for `pub(crate::foo)`\n             {\n-                // `pub(crate)`\n-                self.bump(); // `(`\n-                self.bump(); // `crate`\n-                self.expect(&token::CloseDelim(token::Paren))?; // `)`\n-                let vis = respan(\n-                    lo.to(self.prev_span),\n-                    VisibilityKind::Crate(CrateSugar::PubCrate),\n-                );\n-                return Ok(vis)\n+                return self.parse_vis_pub_crate(lo);\n             } else if self.is_keyword_ahead(1, &[kw::In]) {\n-                // `pub(in path)`\n-                self.bump(); // `(`\n-                self.bump(); // `in`\n-                let path = self.parse_path(PathStyle::Mod)?; // `path`\n-                self.expect(&token::CloseDelim(token::Paren))?; // `)`\n-                let vis = respan(lo.to(self.prev_span), VisibilityKind::Restricted {\n-                    path: P(path),\n-                    id: ast::DUMMY_NODE_ID,\n-                });\n-                return Ok(vis)\n-            } else if self.look_ahead(2, |t| t == &token::CloseDelim(token::Paren)) &&\n-                      self.is_keyword_ahead(1, &[kw::Super, kw::SelfLower])\n+                return self.parse_vis_pub_in(lo);\n+            } else if self.look_ahead(2, |t| t == &token::CloseDelim(token::Paren))\n+                && self.is_keyword_ahead(1, &[kw::Super, kw::SelfLower])\n             {\n-                // `pub(self)` or `pub(super)`\n-                self.bump(); // `(`\n-                let path = self.parse_path(PathStyle::Mod)?; // `super`/`self`\n-                self.expect(&token::CloseDelim(token::Paren))?; // `)`\n-                let vis = respan(lo.to(self.prev_span), VisibilityKind::Restricted {\n-                    path: P(path),\n-                    id: ast::DUMMY_NODE_ID,\n-                });\n-                return Ok(vis)\n-            } else if !can_take_tuple {  // Provide this diagnostic if this is not a tuple struct\n-                // `pub(something) fn ...` or `struct X { pub(something) y: Z }`\n-                self.bump(); // `(`\n-                let msg = \"incorrect visibility restriction\";\n-                let suggestion = r##\"some possible visibility restrictions are:\n-`pub(crate)`: visible only on the current crate\n-`pub(super)`: visible only in the current module's parent\n-`pub(in path::to::module)`: visible only on the specified path\"##;\n-                let path = self.parse_path(PathStyle::Mod)?;\n-                let sp = path.span;\n-                let help_msg = format!(\"make this visible only to module `{}` with `in`\", path);\n-                self.expect(&token::CloseDelim(token::Paren))?;  // `)`\n-                struct_span_err!(self.sess.span_diagnostic, sp, E0704, \"{}\", msg)\n-                    .help(suggestion)\n-                    .span_suggestion(\n-                        sp,\n-                        &help_msg,\n-                        format!(\"in {}\", path),\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit(); // Emit diagnostic, but continue with public visibility.\n+                return self.parse_vis_self_super(lo);\n+            } else if !can_take_tuple { // Provide this diagnostic if this is not a tuple struct.\n+                self.recover_incorrect_vis_restriction()?;\n+                // Emit diagnostic, but continue with public visibility.\n             }\n         }\n \n         Ok(respan(lo, VisibilityKind::Public))\n     }\n \n+    /// Parse `pub(crate)`.\n+    fn parse_vis_pub_crate(&mut self, lo: Span) -> PResult<'a, Visibility> {\n+        self.bump(); // `(`\n+        self.bump(); // `crate`\n+        self.expect(&token::CloseDelim(token::Paren))?; // `)`\n+        Ok(respan(\n+            lo.to(self.prev_span),\n+            VisibilityKind::Crate(CrateSugar::PubCrate),\n+        ))\n+    }\n+\n+    /// Parse `pub(in path)`.\n+    fn parse_vis_pub_in(&mut self, lo: Span) -> PResult<'a, Visibility> {\n+        self.bump(); // `(`\n+        self.bump(); // `in`\n+        let path = self.parse_path(PathStyle::Mod)?; // `path`\n+        self.expect(&token::CloseDelim(token::Paren))?; // `)`\n+        Ok(respan(lo.to(self.prev_span), VisibilityKind::Restricted {\n+            path: P(path),\n+            id: ast::DUMMY_NODE_ID,\n+        }))\n+    }\n+\n+    /// Parse `pub(self)` or `pub(super)`.\n+    fn parse_vis_self_super(&mut self, lo: Span) -> PResult<'a, Visibility> {\n+        self.bump(); // `(`\n+        let path = self.parse_path(PathStyle::Mod)?; // `super`/`self`\n+        self.expect(&token::CloseDelim(token::Paren))?; // `)`\n+        Ok(respan(lo.to(self.prev_span), VisibilityKind::Restricted {\n+            path: P(path),\n+            id: ast::DUMMY_NODE_ID,\n+        }))\n+    }\n+\n+    /// Recovery for e.g. `pub(something) fn ...` or `struct X { pub(something) y: Z }`\n+    fn recover_incorrect_vis_restriction(&mut self) -> PResult<'a, ()> {\n+        self.bump(); // `(`\n+        let path = self.parse_path(PathStyle::Mod)?;\n+        self.expect(&token::CloseDelim(token::Paren))?;  // `)`\n+\n+        let msg = \"incorrect visibility restriction\";\n+        let suggestion = r##\"some possible visibility restrictions are:\n+`pub(crate)`: visible only on the current crate\n+`pub(super)`: visible only in the current module's parent\n+`pub(in path::to::module)`: visible only on the specified path\"##;\n+\n+        struct_span_err!(self.sess.span_diagnostic, path.span, E0704, \"{}\", msg)\n+            .help(suggestion)\n+            .span_suggestion(\n+                path.span,\n+                &format!(\"make this visible only to module `{}` with `in`\", path),\n+                format!(\"in {}\", path),\n+                Applicability::MachineApplicable,\n+            )\n+            .emit();\n+\n+        Ok(())\n+    }\n+\n     /// Parses a string as an ABI spec on an extern type or module. Consumes\n     /// the `extern` keyword, if one is found.\n     fn parse_opt_abi(&mut self) -> PResult<'a, Option<Abi>> {"}]}