{"sha": "44808edeac9d888dba1e40fe7cb7ed11be74c1fa", "node_id": "C_kwDOAAsO6NoAKDQ0ODA4ZWRlYWM5ZDg4OGRiYTFlNDBmZTdjYjdlZDExYmU3NGMxZmE", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-10-22T20:48:48Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-10-22T20:53:33Z"}, "message": "add scalar-abi-only field retagging option", "tree": {"sha": "2c5101eff6e0951d382d692c1889b45e514c6894", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c5101eff6e0951d382d692c1889b45e514c6894"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44808edeac9d888dba1e40fe7cb7ed11be74c1fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44808edeac9d888dba1e40fe7cb7ed11be74c1fa", "html_url": "https://github.com/rust-lang/rust/commit/44808edeac9d888dba1e40fe7cb7ed11be74c1fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44808edeac9d888dba1e40fe7cb7ed11be74c1fa/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "233542bf424af3153f031cdc54c010959e1bb403", "url": "https://api.github.com/repos/rust-lang/rust/commits/233542bf424af3153f031cdc54c010959e1bb403", "html_url": "https://github.com/rust-lang/rust/commit/233542bf424af3153f031cdc54c010959e1bb403"}], "stats": {"total": 138, "additions": 128, "deletions": 10}, "files": [{"sha": "81c4f5ffef4ecaa733e2fb602c43b9448608769a", "filename": "src/tools/miri/README.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/44808edeac9d888dba1e40fe7cb7ed11be74c1fa/src%2Ftools%2Fmiri%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/44808edeac9d888dba1e40fe7cb7ed11be74c1fa/src%2Ftools%2Fmiri%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FREADME.md?ref=44808edeac9d888dba1e40fe7cb7ed11be74c1fa", "patch": "@@ -377,6 +377,11 @@ to Miri failing to detect cases of undefined behavior in a program.\n * `-Zmiri-retag-fields` changes Stacked Borrows retagging to recurse into fields.\n   This means that references in fields of structs/enums/tuples/arrays/... are retagged,\n   and in particular, they are protected when passed as function arguments.\n+* `-Zmiri-retag-fields=<all|none|scalar>` controls when Stacked Borrows retagging recurses into\n+  fields. `all` means it always recurses (like `-Zmiri-retag-fields`), `none` means it never\n+  recurses (the default), `scalar` means it only recurses for types where we would also emit\n+  `noalias` annotations in the generated LLVM IR (types passed as indivudal scalars or pairs of\n+  scalars).\n * `-Zmiri-tag-gc=<blocks>` configures how often the pointer tag garbage collector runs. The default\n   is to search for and remove unreachable tags once every `10000` basic blocks. Setting this to\n   `0` disables the garbage collector, which causes some programs to have explosive memory usage"}, {"sha": "2e114c71d662aa86adc5ef14135cb24ae7d6b2b3", "filename": "src/tools/miri/src/bin/miri.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/44808edeac9d888dba1e40fe7cb7ed11be74c1fa/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44808edeac9d888dba1e40fe7cb7ed11be74c1fa/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs?ref=44808edeac9d888dba1e40fe7cb7ed11be74c1fa", "patch": "@@ -32,7 +32,7 @@ use rustc_middle::{\n };\n use rustc_session::{config::CrateType, search_paths::PathKind, CtfeBacktrace};\n \n-use miri::{BacktraceStyle, ProvenanceMode};\n+use miri::{BacktraceStyle, ProvenanceMode, RetagFields};\n \n struct MiriCompilerCalls {\n     miri_config: miri::MiriConfig,\n@@ -426,7 +426,14 @@ fn main() {\n         } else if arg == \"-Zmiri-mute-stdout-stderr\" {\n             miri_config.mute_stdout_stderr = true;\n         } else if arg == \"-Zmiri-retag-fields\" {\n-            miri_config.retag_fields = true;\n+            miri_config.retag_fields = RetagFields::Yes;\n+        } else if let Some(retag_fields) = arg.strip_prefix(\"-Zmiri-retag-fields=\") {\n+            miri_config.retag_fields = match retag_fields {\n+                \"all\" => RetagFields::Yes,\n+                \"none\" => RetagFields::No,\n+                \"scalar\" => RetagFields::OnlyScalar,\n+                _ => show_error!(\"`-Zmiri-retag-fields` can only be `all`, `none`, or `scalar`\"),\n+            };\n         } else if arg == \"-Zmiri-track-raw-pointers\" {\n             eprintln!(\n                 \"WARNING: `-Zmiri-track-raw-pointers` has no effect; it is enabled by default\""}, {"sha": "a3fc343f8b67ce5c24554760c1135876260d6e50", "filename": "src/tools/miri/src/eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44808edeac9d888dba1e40fe7cb7ed11be74c1fa/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44808edeac9d888dba1e40fe7cb7ed11be74c1fa/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs?ref=44808edeac9d888dba1e40fe7cb7ed11be74c1fa", "patch": "@@ -126,7 +126,7 @@ pub struct MiriConfig {\n     /// Report the current instruction being executed every N basic blocks.\n     pub report_progress: Option<u32>,\n     /// Whether Stacked Borrows retagging should recurse into fields of datatypes.\n-    pub retag_fields: bool,\n+    pub retag_fields: RetagFields,\n     /// The location of a shared object file to load when calling external functions\n     /// FIXME! consider allowing users to specify paths to multiple SO files, or to a directory\n     pub external_so_file: Option<PathBuf>,\n@@ -163,7 +163,7 @@ impl Default for MiriConfig {\n             mute_stdout_stderr: false,\n             preemption_rate: 0.01, // 1%\n             report_progress: None,\n-            retag_fields: false,\n+            retag_fields: RetagFields::No,\n             external_so_file: None,\n             gc_interval: 10_000,\n             num_cpus: 1,"}, {"sha": "21e65bb1b706e1d2c4d97065c149f9f1ea84f15e", "filename": "src/tools/miri/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44808edeac9d888dba1e40fe7cb7ed11be74c1fa/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44808edeac9d888dba1e40fe7cb7ed11be74c1fa/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs?ref=44808edeac9d888dba1e40fe7cb7ed11be74c1fa", "patch": "@@ -105,7 +105,7 @@ pub use crate::mono_hash_map::MonoHashMap;\n pub use crate::operator::EvalContextExt as _;\n pub use crate::range_map::RangeMap;\n pub use crate::stacked_borrows::{\n-    CallId, EvalContextExt as _, Item, Permission, SbTag, Stack, Stacks,\n+    CallId, EvalContextExt as _, Item, Permission, RetagFields, SbTag, Stack, Stacks,\n };\n pub use crate::tag_gc::{EvalContextExt as _, VisitTags};\n "}, {"sha": "959e351d1a145b2abc7563d1227d47d0a5d45514", "filename": "src/tools/miri/src/stacked_borrows/mod.rs", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/44808edeac9d888dba1e40fe7cb7ed11be74c1fa/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44808edeac9d888dba1e40fe7cb7ed11be74c1fa/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs?ref=44808edeac9d888dba1e40fe7cb7ed11be74c1fa", "patch": "@@ -17,6 +17,7 @@ use rustc_middle::ty::{\n     Ty,\n };\n use rustc_span::DUMMY_SP;\n+use rustc_target::abi::Abi;\n use rustc_target::abi::Size;\n use smallvec::SmallVec;\n \n@@ -114,7 +115,18 @@ pub struct GlobalStateInner {\n     /// The call ids to trace\n     tracked_call_ids: FxHashSet<CallId>,\n     /// Whether to recurse into datatypes when searching for pointers to retag.\n-    retag_fields: bool,\n+    retag_fields: RetagFields,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum RetagFields {\n+    /// Don't retag any fields.\n+    No,\n+    /// Retag all fields.\n+    Yes,\n+    /// Only retag fields of types with Scalar and ScalarPair layout,\n+    /// to match the LLVM `noalias` we generate.\n+    OnlyScalar,\n }\n \n impl VisitTags for GlobalStateInner {\n@@ -173,7 +185,7 @@ impl GlobalStateInner {\n     pub fn new(\n         tracked_pointer_tags: FxHashSet<SbTag>,\n         tracked_call_ids: FxHashSet<CallId>,\n-        retag_fields: bool,\n+        retag_fields: RetagFields,\n     ) -> Self {\n         GlobalStateInner {\n             next_ptr_tag: SbTag(NonZeroU64::new(1).unwrap()),\n@@ -999,7 +1011,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             ecx: &'ecx mut MiriInterpCx<'mir, 'tcx>,\n             kind: RetagKind,\n             retag_cause: RetagCause,\n-            retag_fields: bool,\n+            retag_fields: RetagFields,\n         }\n         impl<'ecx, 'mir, 'tcx> RetagVisitor<'ecx, 'mir, 'tcx> {\n             #[inline(always)] // yes this helps in our benchmarks\n@@ -1046,6 +1058,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     return Ok(());\n                 }\n \n+                let recurse_for_fields = || {\n+                    match self.retag_fields {\n+                        RetagFields::No => false,\n+                        RetagFields::Yes => true,\n+                        RetagFields::OnlyScalar => {\n+                            // Matching `ArgAbi::new` at the time of writing, only fields of\n+                            // `Scalar` and `ScalarPair` ABI are considered.\n+                            matches!(place.layout.abi, Abi::Scalar(..) | Abi::ScalarPair(..))\n+                        }\n+                    }\n+                };\n+\n                 if let Some((ref_kind, protector)) = qualify(place.layout.ty, self.kind) {\n                     self.retag_place(place, ref_kind, self.retag_cause, protector)?;\n                 } else if matches!(place.layout.ty.kind(), ty::RawPtr(..)) {\n@@ -1054,7 +1078,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     // Do *not* recurse into them.\n                     // (No need to worry about wide references, those always \"qualify\". And Boxes\n                     // are handles specially by the visitor anyway.)\n-                } else if self.retag_fields\n+                } else if recurse_for_fields()\n                     || place.layout.ty.ty_adt_def().is_some_and(|adt| adt.is_box())\n                 {\n                     // Recurse deeper. Need to always recurse for `Box` to even hit `visit_box`."}, {"sha": "5cefdb08e7879d6816a0d06c5ad0b9a7d2a18a7b", "filename": "src/tools/miri/tests/fail/stacked_borrows/newtype_pair_retagging.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/44808edeac9d888dba1e40fe7cb7ed11be74c1fa/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44808edeac9d888dba1e40fe7cb7ed11be74c1fa/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.rs?ref=44808edeac9d888dba1e40fe7cb7ed11be74c1fa", "patch": "@@ -0,0 +1,19 @@\n+//@compile-flags: -Zmiri-retag-fields=scalar\n+//@error-pattern: which is protected\n+struct Newtype<'a>(&'a mut i32, i32);\n+\n+fn dealloc_while_running(_n: Newtype<'_>, dealloc: impl FnOnce()) {\n+    dealloc();\n+}\n+\n+// Make sure that we protect references inside structs that are passed as ScalarPair.\n+fn main() {\n+    let ptr = Box::into_raw(Box::new(0i32));\n+    #[rustfmt::skip] // I like my newlines\n+    unsafe {\n+        dealloc_while_running(\n+            Newtype(&mut *ptr, 0),\n+            || drop(Box::from_raw(ptr)),\n+        )\n+    };\n+}"}, {"sha": "60a8b2a6260ba5c2cdadb53670f5357ce6e81d47", "filename": "src/tools/miri/tests/fail/stacked_borrows/newtype_pair_retagging.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/44808edeac9d888dba1e40fe7cb7ed11be74c1fa/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/44808edeac9d888dba1e40fe7cb7ed11be74c1fa/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.stderr?ref=44808edeac9d888dba1e40fe7cb7ed11be74c1fa", "patch": "@@ -0,0 +1,44 @@\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+  --> RUSTLIB/alloc/src/boxed.rs:LL:CC\n+   |\n+LL |         Box(unsafe { Unique::new_unchecked(raw) }, alloc)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n+   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n+help: <TAG> was created by a SharedReadWrite retag at offsets [0x0..0x4]\n+  --> $DIR/newtype_pair_retagging.rs:LL:CC\n+   |\n+LL |     let ptr = Box::into_raw(Box::new(0i32));\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: <TAG> is this argument\n+  --> $DIR/newtype_pair_retagging.rs:LL:CC\n+   |\n+LL | fn dealloc_while_running(_n: Newtype<'_>, dealloc: impl FnOnce()) {\n+   |                          ^^\n+   = note: BACKTRACE:\n+   = note: inside `std::boxed::Box::<i32>::from_raw_in` at RUSTLIB/alloc/src/boxed.rs:LL:CC\n+   = note: inside `std::boxed::Box::<i32>::from_raw` at RUSTLIB/alloc/src/boxed.rs:LL:CC\n+note: inside closure at $DIR/newtype_pair_retagging.rs:LL:CC\n+  --> $DIR/newtype_pair_retagging.rs:LL:CC\n+   |\n+LL |             || drop(Box::from_raw(ptr)),\n+   |                     ^^^^^^^^^^^^^^^^^^\n+note: inside `dealloc_while_running::<[closure@$DIR/newtype_pair_retagging.rs:LL:CC]>` at $DIR/newtype_pair_retagging.rs:LL:CC\n+  --> $DIR/newtype_pair_retagging.rs:LL:CC\n+   |\n+LL |     dealloc();\n+   |     ^^^^^^^^^\n+note: inside `main` at $DIR/newtype_pair_retagging.rs:LL:CC\n+  --> $DIR/newtype_pair_retagging.rs:LL:CC\n+   |\n+LL | /         dealloc_while_running(\n+LL | |             Newtype(&mut *ptr, 0),\n+LL | |             || drop(Box::from_raw(ptr)),\n+LL | |         )\n+   | |_________^\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "bc3883575c333381643c7c2f7eb5459cdd967cb1", "filename": "src/tools/miri/tests/fail/stacked_borrows/newtype_retagging.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44808edeac9d888dba1e40fe7cb7ed11be74c1fa/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44808edeac9d888dba1e40fe7cb7ed11be74c1fa/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs?ref=44808edeac9d888dba1e40fe7cb7ed11be74c1fa", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-retag-fields\n+//@compile-flags: -Zmiri-retag-fields=scalar\n //@error-pattern: which is protected\n struct Newtype<'a>(&'a mut i32);\n "}, {"sha": "ddedc19c99980300b5aa3541e7d7185508e77e9d", "filename": "src/tools/miri/tests/pass/stacked-borrows/non_scalar_field_retagging.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/44808edeac9d888dba1e40fe7cb7ed11be74c1fa/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fnon_scalar_field_retagging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44808edeac9d888dba1e40fe7cb7ed11be74c1fa/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fnon_scalar_field_retagging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fnon_scalar_field_retagging.rs?ref=44808edeac9d888dba1e40fe7cb7ed11be74c1fa", "patch": "@@ -0,0 +1,19 @@\n+//@compile-flags: -Zmiri-retag-fields=scalar\n+\n+struct Newtype<'a>(&'a mut i32, i32, i32);\n+\n+fn dealloc_while_running(_n: Newtype<'_>, dealloc: impl FnOnce()) {\n+    dealloc();\n+}\n+\n+// Make sure that with -Zmiri-retag-fields=scalar, we do *not* retag the fields of `Newtype`.\n+fn main() {\n+    let ptr = Box::into_raw(Box::new(0i32));\n+    #[rustfmt::skip] // I like my newlines\n+    unsafe {\n+        dealloc_while_running(\n+            Newtype(&mut *ptr, 0, 0),\n+            || drop(Box::from_raw(ptr)),\n+        )\n+    };\n+}"}]}