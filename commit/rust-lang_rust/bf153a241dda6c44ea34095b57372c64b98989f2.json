{"sha": "bf153a241dda6c44ea34095b57372c64b98989f2", "node_id": "C_kwDOAAsO6NoAKGJmMTUzYTI0MWRkYTZjNDRlYTM0MDk1YjU3MzcyYzY0Yjk4OTg5ZjI", "commit": {"author": {"name": "Jakob Degen", "email": "jakob.e.degen@gmail.com", "date": "2022-05-10T00:12:03Z"}, "committer": {"name": "Jakob Degen", "email": "jakob.e.degen@gmail.com", "date": "2022-05-25T02:50:21Z"}, "message": "Add dead store elimination pass", "tree": {"sha": "a4863e719e91d1cda86604f29e7258f520981132", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4863e719e91d1cda86604f29e7258f520981132"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf153a241dda6c44ea34095b57372c64b98989f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf153a241dda6c44ea34095b57372c64b98989f2", "html_url": "https://github.com/rust-lang/rust/commit/bf153a241dda6c44ea34095b57372c64b98989f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf153a241dda6c44ea34095b57372c64b98989f2/comments", "author": {"login": "JakobDegen", "id": 51179609, "node_id": "MDQ6VXNlcjUxMTc5NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/51179609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JakobDegen", "html_url": "https://github.com/JakobDegen", "followers_url": "https://api.github.com/users/JakobDegen/followers", "following_url": "https://api.github.com/users/JakobDegen/following{/other_user}", "gists_url": "https://api.github.com/users/JakobDegen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JakobDegen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JakobDegen/subscriptions", "organizations_url": "https://api.github.com/users/JakobDegen/orgs", "repos_url": "https://api.github.com/users/JakobDegen/repos", "events_url": "https://api.github.com/users/JakobDegen/events{/privacy}", "received_events_url": "https://api.github.com/users/JakobDegen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JakobDegen", "id": 51179609, "node_id": "MDQ6VXNlcjUxMTc5NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/51179609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JakobDegen", "html_url": "https://github.com/JakobDegen", "followers_url": "https://api.github.com/users/JakobDegen/followers", "following_url": "https://api.github.com/users/JakobDegen/following{/other_user}", "gists_url": "https://api.github.com/users/JakobDegen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JakobDegen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JakobDegen/subscriptions", "organizations_url": "https://api.github.com/users/JakobDegen/orgs", "repos_url": "https://api.github.com/users/JakobDegen/repos", "events_url": "https://api.github.com/users/JakobDegen/events{/privacy}", "received_events_url": "https://api.github.com/users/JakobDegen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f80e454450c891c075617d23532c6eb317f4471d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f80e454450c891c075617d23532c6eb317f4471d", "html_url": "https://github.com/rust-lang/rust/commit/f80e454450c891c075617d23532c6eb317f4471d"}], "stats": {"total": 521, "additions": 496, "deletions": 25}, "files": [{"sha": "f1fb484a801ba97c2c723d5166dfef813176b2a3", "filename": "compiler/rustc_middle/src/mir/tcx.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bf153a241dda6c44ea34095b57372c64b98989f2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf153a241dda6c44ea34095b57372c64b98989f2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs?ref=bf153a241dda6c44ea34095b57372c64b98989f2", "patch": "@@ -4,6 +4,7 @@\n  */\n \n use crate::mir::*;\n+use crate::ty::cast::CastTy;\n use crate::ty::subst::Subst;\n use crate::ty::{self, Ty, TyCtxt};\n use rustc_hir as hir;\n@@ -223,6 +224,22 @@ impl<'tcx> Rvalue<'tcx> {\n             _ => RvalueInitializationState::Deep,\n         }\n     }\n+\n+    pub fn is_pointer_int_cast<D>(&self, local_decls: &D, tcx: TyCtxt<'tcx>) -> bool\n+    where\n+        D: HasLocalDecls<'tcx>,\n+    {\n+        if let Rvalue::Cast(CastKind::Misc, src_op, dest_ty) = self {\n+            if let Some(CastTy::Int(_)) = CastTy::from_ty(*dest_ty) {\n+                let src_ty = src_op.ty(local_decls, tcx);\n+                if let Some(CastTy::FnPtr | CastTy::Ptr(_)) = CastTy::from_ty(src_ty) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        false\n+    }\n }\n \n impl<'tcx> Operand<'tcx> {"}, {"sha": "4350eb6cdd3b1fa3943beb4bb612f6aaba32ba92", "filename": "compiler/rustc_mir_dataflow/src/impls/liveness.rs", "status": "modified", "additions": 160, "deletions": 22, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/bf153a241dda6c44ea34095b57372c64b98989f2/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf153a241dda6c44ea34095b57372c64b98989f2/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs?ref=bf153a241dda6c44ea34095b57372c64b98989f2", "patch": "@@ -1,8 +1,9 @@\n-use rustc_index::bit_set::BitSet;\n+use rustc_index::bit_set::{BitSet, ChunkedBitSet};\n use rustc_middle::mir::visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor};\n-use rustc_middle::mir::{self, Local, Location};\n+use rustc_middle::mir::{self, Local, LocalDecls, Location, Place, StatementKind};\n+use rustc_middle::ty::TyCtxt;\n \n-use crate::{AnalysisDomain, Backward, CallReturnPlaces, GenKill, GenKillAnalysis};\n+use crate::{Analysis, AnalysisDomain, Backward, CallReturnPlaces, GenKill, GenKillAnalysis};\n \n /// A [live-variable dataflow analysis][liveness].\n ///\n@@ -98,30 +99,27 @@ where\n     T: GenKill<Local>,\n {\n     fn visit_place(&mut self, place: &mir::Place<'tcx>, context: PlaceContext, location: Location) {\n-        let mir::Place { projection, local } = *place;\n+        let local = place.local;\n \n         // We purposefully do not call `super_place` here to avoid calling `visit_local` for this\n         // place with one of the `Projection` variants of `PlaceContext`.\n         self.visit_projection(place.as_ref(), context, location);\n \n-        match DefUse::for_place(context) {\n-            // Treat derefs as a use of the base local. `*p = 4` is not a def of `p` but a use.\n-            Some(_) if place.is_indirect() => self.0.gen(local),\n-\n-            Some(DefUse::Def) if projection.is_empty() => self.0.kill(local),\n+        match DefUse::for_place(*place, context) {\n+            Some(DefUse::Def) => self.0.kill(local),\n             Some(DefUse::Use) => self.0.gen(local),\n-            _ => {}\n+            None => {}\n         }\n     }\n \n     fn visit_local(&mut self, &local: &Local, context: PlaceContext, _: Location) {\n         // Because we do not call `super_place` above, `visit_local` is only called for locals that\n         // do not appear as part of  a `Place` in the MIR. This handles cases like the implicit use\n         // of the return place in a `Return` terminator or the index in an `Index` projection.\n-        match DefUse::for_place(context) {\n+        match DefUse::for_place(local.into(), context) {\n             Some(DefUse::Def) => self.0.kill(local),\n             Some(DefUse::Use) => self.0.gen(local),\n-            _ => {}\n+            None => {}\n         }\n     }\n }\n@@ -133,27 +131,37 @@ enum DefUse {\n }\n \n impl DefUse {\n-    fn for_place(context: PlaceContext) -> Option<DefUse> {\n+    fn for_place<'tcx>(place: Place<'tcx>, context: PlaceContext) -> Option<DefUse> {\n         match context {\n             PlaceContext::NonUse(_) => None,\n \n             PlaceContext::MutatingUse(MutatingUseContext::Store | MutatingUseContext::Deinit) => {\n-                Some(DefUse::Def)\n+                if place.is_indirect() {\n+                    // Treat derefs as a use of the base local. `*p = 4` is not a def of `p` but a\n+                    // use.\n+                    Some(DefUse::Use)\n+                } else if place.projection.is_empty() {\n+                    Some(DefUse::Def)\n+                } else {\n+                    None\n+                }\n             }\n \n             // Setting the discriminant is not a use because it does no reading, but it is also not\n             // a def because it does not overwrite the whole place\n-            PlaceContext::MutatingUse(MutatingUseContext::SetDiscriminant) => None,\n+            PlaceContext::MutatingUse(MutatingUseContext::SetDiscriminant) => {\n+                place.is_indirect().then_some(DefUse::Use)\n+            }\n \n-            // `MutatingUseContext::Call` and `MutatingUseContext::Yield` indicate that this is the\n-            // destination place for a `Call` return or `Yield` resume respectively. Since this is\n-            // only a `Def` when the function returns successfully, we handle this case separately\n-            // in `call_return_effect` above.\n+            // For the associated terminators, this is only a `Def` when the terminator returns\n+            // \"successfully.\" As such, we handle this case separately in `call_return_effect`\n+            // above. However, if the place looks like `*_5`, this is still unconditionally a use of\n+            // `_5`.\n             PlaceContext::MutatingUse(\n                 MutatingUseContext::Call\n-                | MutatingUseContext::AsmOutput\n-                | MutatingUseContext::Yield,\n-            ) => None,\n+                | MutatingUseContext::Yield\n+                | MutatingUseContext::AsmOutput,\n+            ) => place.is_indirect().then_some(DefUse::Use),\n \n             // All other contexts are uses...\n             PlaceContext::MutatingUse(\n@@ -179,3 +187,133 @@ impl DefUse {\n         }\n     }\n }\n+\n+/// Like `MaybeLiveLocals`, but does not mark locals as live if they are used in a dead assignment.\n+///\n+/// This is basically written for dead store elimination and nothing else.\n+///\n+/// All of the caveats of `MaybeLiveLocals` apply.\n+pub struct MaybeTransitiveLiveLocals<'a, 'tcx> {\n+    always_live: &'a BitSet<Local>,\n+    local_decls: &'a LocalDecls<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+}\n+\n+impl<'a, 'tcx> MaybeTransitiveLiveLocals<'a, 'tcx> {\n+    /// The `always_alive` set is the set of locals to which all stores should unconditionally be\n+    /// considered live.\n+    ///\n+    /// This should include at least all locals that are ever borrowed.\n+    pub fn new(\n+        always_live: &'a BitSet<Local>,\n+        local_decls: &'a LocalDecls<'tcx>,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> Self {\n+        MaybeTransitiveLiveLocals { always_live, local_decls, tcx }\n+    }\n+}\n+\n+impl<'a, 'tcx> AnalysisDomain<'tcx> for MaybeTransitiveLiveLocals<'a, 'tcx> {\n+    type Domain = ChunkedBitSet<Local>;\n+    type Direction = Backward;\n+\n+    const NAME: &'static str = \"transitive liveness\";\n+\n+    fn bottom_value(&self, body: &mir::Body<'tcx>) -> Self::Domain {\n+        // bottom = not live\n+        ChunkedBitSet::new_empty(body.local_decls.len())\n+    }\n+\n+    fn initialize_start_block(&self, _: &mir::Body<'tcx>, _: &mut Self::Domain) {\n+        // No variables are live until we observe a use\n+    }\n+}\n+\n+struct TransferWrapper<'a>(&'a mut ChunkedBitSet<Local>);\n+\n+impl<'a> GenKill<Local> for TransferWrapper<'a> {\n+    fn gen(&mut self, l: Local) {\n+        self.0.insert(l);\n+    }\n+\n+    fn kill(&mut self, l: Local) {\n+        self.0.remove(l);\n+    }\n+}\n+\n+impl<'a, 'tcx> Analysis<'tcx> for MaybeTransitiveLiveLocals<'a, 'tcx> {\n+    fn apply_statement_effect(\n+        &self,\n+        trans: &mut Self::Domain,\n+        statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    ) {\n+        // Compute the place that we are storing to, if any\n+        let destination = match &statement.kind {\n+            StatementKind::Assign(assign) => {\n+                if assign.1.is_pointer_int_cast(self.local_decls, self.tcx) {\n+                    // Pointer to int casts may be side-effects due to exposing the provenance.\n+                    // While the model is undecided, we should be conservative. See\n+                    // <https://www.ralfj.de/blog/2022/04/11/provenance-exposed.html>\n+                    None\n+                } else {\n+                    Some(assign.0)\n+                }\n+            }\n+            StatementKind::SetDiscriminant { place, .. } | StatementKind::Deinit(place) => {\n+                Some(**place)\n+            }\n+            StatementKind::FakeRead(_)\n+            | StatementKind::StorageLive(_)\n+            | StatementKind::StorageDead(_)\n+            | StatementKind::Retag(..)\n+            | StatementKind::AscribeUserType(..)\n+            | StatementKind::Coverage(..)\n+            | StatementKind::CopyNonOverlapping(..)\n+            | StatementKind::Nop => None,\n+        };\n+        if let Some(destination) = destination {\n+            if !destination.is_indirect()\n+                && !trans.contains(destination.local)\n+                && !self.always_live.contains(destination.local)\n+            {\n+                // This store is dead\n+                return;\n+            }\n+        }\n+        TransferFunction(&mut TransferWrapper(trans)).visit_statement(statement, location);\n+    }\n+\n+    fn apply_terminator_effect(\n+        &self,\n+        trans: &mut Self::Domain,\n+        terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    ) {\n+        TransferFunction(&mut TransferWrapper(trans)).visit_terminator(terminator, location);\n+    }\n+\n+    fn apply_call_return_effect(\n+        &self,\n+        trans: &mut Self::Domain,\n+        _block: mir::BasicBlock,\n+        return_places: CallReturnPlaces<'_, 'tcx>,\n+    ) {\n+        return_places.for_each(|place| {\n+            if let Some(local) = place.as_local() {\n+                trans.remove(local);\n+            }\n+        });\n+    }\n+\n+    fn apply_yield_resume_effect(\n+        &self,\n+        trans: &mut Self::Domain,\n+        _resume_block: mir::BasicBlock,\n+        resume_place: mir::Place<'tcx>,\n+    ) {\n+        if let Some(local) = resume_place.as_local() {\n+            trans.remove(local);\n+        }\n+    }\n+}"}, {"sha": "41cf43fc8e186767e417e9a0b612ba6197b6f1e7", "filename": "compiler/rustc_mir_dataflow/src/impls/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bf153a241dda6c44ea34095b57372c64b98989f2/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf153a241dda6c44ea34095b57372c64b98989f2/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs?ref=bf153a241dda6c44ea34095b57372c64b98989f2", "patch": "@@ -26,6 +26,7 @@ mod storage_liveness;\n pub use self::borrowed_locals::MaybeBorrowedLocals;\n pub use self::init_locals::MaybeInitializedLocals;\n pub use self::liveness::MaybeLiveLocals;\n+pub use self::liveness::MaybeTransitiveLiveLocals;\n pub use self::storage_liveness::{MaybeRequiresStorage, MaybeStorageLive};\n \n /// `MaybeInitializedPlaces` tracks all places that might be"}, {"sha": "84f2ee639e4d8a2ca3b8998185b4cf5be8ec74a2", "filename": "compiler/rustc_mir_transform/src/dead_store_elimination.rs", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/bf153a241dda6c44ea34095b57372c64b98989f2/compiler%2Frustc_mir_transform%2Fsrc%2Fdead_store_elimination.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf153a241dda6c44ea34095b57372c64b98989f2/compiler%2Frustc_mir_transform%2Fsrc%2Fdead_store_elimination.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdead_store_elimination.rs?ref=bf153a241dda6c44ea34095b57372c64b98989f2", "patch": "@@ -0,0 +1,148 @@\n+//! This module implements a dead store elimination (DSE) routine.\n+//!\n+//! This transformation was written specifically for the needs of dest prop. Although it is\n+//! perfectly sound to use it in any context that might need it, its behavior should not be changed\n+//! without analyzing the interaction this will have with dest prop. Specifically, in addition to\n+//! the soundness of this pass in general, dest prop needs it to satisfy two additional conditions:\n+//!\n+//!  1. It's idempotent, meaning that running this pass a second time immediately after running it a\n+//!     first time will not cause any further changes.\n+//!  2. This idempotence persists across dest prop's main transform, in other words inserting any\n+//!     number of iterations of dest prop between the first and second application of this transform\n+//!     will still not cause any further changes.\n+//!\n+\n+use rustc_index::bit_set::BitSet;\n+use rustc_middle::{\n+    mir::{visit::Visitor, *},\n+    ty::TyCtxt,\n+};\n+use rustc_mir_dataflow::{impls::MaybeTransitiveLiveLocals, Analysis};\n+\n+/// Performs the optimization on the body\n+///\n+/// The `borrowed` set must be a `BitSet` of all the locals that are ever borrowed in this body. It\n+/// can be generated via the [`get_borrowed_locals`] function.\n+pub fn eliminate<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>, borrowed: &BitSet<Local>) {\n+    let mut live = MaybeTransitiveLiveLocals::new(borrowed, &body.local_decls, tcx)\n+        .into_engine(tcx, body)\n+        .iterate_to_fixpoint()\n+        .into_results_cursor(body);\n+\n+    let mut patch = Vec::new();\n+    for (bb, bb_data) in traversal::preorder(body) {\n+        for (statement_index, statement) in bb_data.statements.iter().enumerate().rev() {\n+            let loc = Location { block: bb, statement_index };\n+            if let StatementKind::Assign(assign) = &statement.kind {\n+                if assign.1.is_pointer_int_cast(&body.local_decls, tcx) {\n+                    continue;\n+                }\n+            }\n+            match &statement.kind {\n+                StatementKind::Assign(box (place, _))\n+                | StatementKind::SetDiscriminant { place: box place, .. }\n+                | StatementKind::Deinit(box place) => {\n+                    if !place.is_indirect() && !borrowed.contains(place.local) {\n+                        live.seek_before_primary_effect(loc);\n+                        if !live.get().contains(place.local) {\n+                            patch.push(loc);\n+                        }\n+                    }\n+                }\n+                StatementKind::Retag(_, _)\n+                | StatementKind::StorageLive(_)\n+                | StatementKind::StorageDead(_)\n+                | StatementKind::Coverage(_)\n+                | StatementKind::CopyNonOverlapping(_)\n+                | StatementKind::Nop => (),\n+\n+                StatementKind::FakeRead(_) | StatementKind::AscribeUserType(_, _) => {\n+                    bug!(\"{:?} not found in this MIR phase!\", &statement.kind)\n+                }\n+            }\n+        }\n+    }\n+\n+    if patch.is_empty() {\n+        return;\n+    }\n+\n+    let bbs = body.basic_blocks_mut();\n+    for Location { block, statement_index } in patch {\n+        bbs[block].statements[statement_index].make_nop();\n+    }\n+}\n+\n+pub fn get_borrowed_locals(body: &Body<'_>) -> BitSet<Local> {\n+    let mut b = BorrowedLocals(BitSet::new_empty(body.local_decls.len()));\n+    b.visit_body(body);\n+    b.0\n+}\n+\n+struct BorrowedLocals(BitSet<Local>);\n+\n+impl<'tcx> Visitor<'tcx> for BorrowedLocals {\n+    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, loc: Location) {\n+        self.super_rvalue(rvalue, loc);\n+        match rvalue {\n+            Rvalue::AddressOf(_, borrowed_place) | Rvalue::Ref(_, _, borrowed_place) => {\n+                if !borrowed_place.is_indirect() {\n+                    self.0.insert(borrowed_place.local);\n+                }\n+            }\n+\n+            Rvalue::Cast(..)\n+            | Rvalue::ShallowInitBox(..)\n+            | Rvalue::Use(..)\n+            | Rvalue::Repeat(..)\n+            | Rvalue::Len(..)\n+            | Rvalue::BinaryOp(..)\n+            | Rvalue::CheckedBinaryOp(..)\n+            | Rvalue::NullaryOp(..)\n+            | Rvalue::UnaryOp(..)\n+            | Rvalue::Discriminant(..)\n+            | Rvalue::Aggregate(..)\n+            | Rvalue::ThreadLocalRef(..) => {}\n+        }\n+    }\n+\n+    fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n+        self.super_terminator(terminator, location);\n+\n+        match terminator.kind {\n+            TerminatorKind::Drop { place: dropped_place, .. } => {\n+                if !dropped_place.is_indirect() {\n+                    self.0.insert(dropped_place.local);\n+                }\n+            }\n+\n+            TerminatorKind::Abort\n+            | TerminatorKind::DropAndReplace { .. }\n+            | TerminatorKind::Assert { .. }\n+            | TerminatorKind::Call { .. }\n+            | TerminatorKind::FalseEdge { .. }\n+            | TerminatorKind::FalseUnwind { .. }\n+            | TerminatorKind::GeneratorDrop\n+            | TerminatorKind::Goto { .. }\n+            | TerminatorKind::Resume\n+            | TerminatorKind::Return\n+            | TerminatorKind::SwitchInt { .. }\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::Yield { .. }\n+            | TerminatorKind::InlineAsm { .. } => {}\n+        }\n+    }\n+}\n+\n+pub struct DeadStoreElimination;\n+\n+impl<'tcx> MirPass<'tcx> for DeadStoreElimination {\n+    fn is_enabled(&self, sess: &rustc_session::Session) -> bool {\n+        sess.mir_opt_level() >= 2\n+    }\n+\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        let borrowed = get_borrowed_locals(body);\n+        eliminate(tcx, body, &borrowed);\n+    }\n+}"}, {"sha": "0e57c3c69799970bccb597d8f08adb570cb6d958", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf153a241dda6c44ea34095b57372c64b98989f2/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf153a241dda6c44ea34095b57372c64b98989f2/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=bf153a241dda6c44ea34095b57372c64b98989f2", "patch": "@@ -49,6 +49,7 @@ mod const_goto;\n mod const_prop;\n mod const_prop_lint;\n mod coverage;\n+mod dead_store_elimination;\n mod deaggregator;\n mod deduplicate_blocks;\n mod deref_separator;\n@@ -481,17 +482,18 @@ fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n             &const_prop::ConstProp,\n             //\n             // Const-prop runs unconditionally, but doesn't mutate the MIR at mir-opt-level=0.\n+            &const_debuginfo::ConstDebugInfo,\n             &o1(simplify_branches::SimplifyConstCondition::new(\"after-const-prop\")),\n             &early_otherwise_branch::EarlyOtherwiseBranch,\n             &simplify_comparison_integral::SimplifyComparisonIntegral,\n             &simplify_try::SimplifyArmIdentity,\n             &simplify_try::SimplifyBranchSame,\n+            &dead_store_elimination::DeadStoreElimination,\n             &dest_prop::DestinationPropagation,\n             &o1(simplify_branches::SimplifyConstCondition::new(\"final\")),\n             &o1(remove_noop_landing_pads::RemoveNoopLandingPads),\n             &o1(simplify::SimplifyCfg::new(\"final\")),\n             &nrvo::RenameReturnPlace,\n-            &const_debuginfo::ConstDebugInfo,\n             &simplify::SimplifyLocals,\n             &multiple_return_terminators::MultipleReturnTerminators,\n             &deduplicate_blocks::DeduplicateBlocks,"}, {"sha": "cd4b471b28cc18cfc017b758315134d2ef7bbcec", "filename": "src/test/mir-opt/const_debuginfo.main.ConstDebugInfo.diff", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bf153a241dda6c44ea34095b57372c64b98989f2/src%2Ftest%2Fmir-opt%2Fconst_debuginfo.main.ConstDebugInfo.diff", "raw_url": "https://github.com/rust-lang/rust/raw/bf153a241dda6c44ea34095b57372c64b98989f2/src%2Ftest%2Fmir-opt%2Fconst_debuginfo.main.ConstDebugInfo.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_debuginfo.main.ConstDebugInfo.diff?ref=bf153a241dda6c44ea34095b57372c64b98989f2", "patch": "@@ -99,6 +99,7 @@\n           _13 = const 64_u32;              // scope 8 at $DIR/const_debuginfo.rs:21:13: 21:22\n           StorageDead(_15);                // scope 8 at $DIR/const_debuginfo.rs:21:21: 21:22\n           StorageDead(_14);                // scope 8 at $DIR/const_debuginfo.rs:21:21: 21:22\n+          nop;                             // scope 0 at $DIR/const_debuginfo.rs:8:11: 22:2\n           StorageDead(_13);                // scope 8 at $DIR/const_debuginfo.rs:22:1: 22:2\n           StorageDead(_12);                // scope 7 at $DIR/const_debuginfo.rs:22:1: 22:2\n           StorageDead(_11);                // scope 6 at $DIR/const_debuginfo.rs:22:1: 22:2"}, {"sha": "6037f89086dc125677fead02f7cbf10e59031ec3", "filename": "src/test/mir-opt/dead-store-elimination/cycle.cycle.DeadStoreElimination.diff", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/bf153a241dda6c44ea34095b57372c64b98989f2/src%2Ftest%2Fmir-opt%2Fdead-store-elimination%2Fcycle.cycle.DeadStoreElimination.diff", "raw_url": "https://github.com/rust-lang/rust/raw/bf153a241dda6c44ea34095b57372c64b98989f2/src%2Ftest%2Fmir-opt%2Fdead-store-elimination%2Fcycle.cycle.DeadStoreElimination.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdead-store-elimination%2Fcycle.cycle.DeadStoreElimination.diff?ref=bf153a241dda6c44ea34095b57372c64b98989f2", "patch": "@@ -0,0 +1,75 @@\n+- // MIR for `cycle` before DeadStoreElimination\n++ // MIR for `cycle` after DeadStoreElimination\n+  \n+  fn cycle(_1: i32, _2: i32, _3: i32) -> () {\n+      debug x => _1;                       // in scope 0 at $DIR/cycle.rs:9:10: 9:15\n+      debug y => _2;                       // in scope 0 at $DIR/cycle.rs:9:22: 9:27\n+      debug z => _3;                       // in scope 0 at $DIR/cycle.rs:9:34: 9:39\n+      let mut _0: ();                      // return place in scope 0 at $DIR/cycle.rs:9:46: 9:46\n+      let mut _4: ();                      // in scope 0 at $DIR/cycle.rs:9:1: 18:2\n+      let mut _5: bool;                    // in scope 0 at $DIR/cycle.rs:12:11: 12:17\n+      let _6: i32;                         // in scope 0 at $DIR/cycle.rs:13:13: 13:17\n+      let mut _7: i32;                     // in scope 0 at $DIR/cycle.rs:14:13: 14:14\n+      let mut _8: i32;                     // in scope 0 at $DIR/cycle.rs:15:13: 15:14\n+      let mut _9: i32;                     // in scope 0 at $DIR/cycle.rs:16:13: 16:17\n+      let mut _10: !;                      // in scope 0 at $DIR/cycle.rs:12:5: 17:6\n+      let _11: ();                         // in scope 0 at $DIR/cycle.rs:12:5: 17:6\n+      let mut _12: !;                      // in scope 0 at $DIR/cycle.rs:12:5: 17:6\n+      scope 1 {\n+          debug temp => _6;                // in scope 1 at $DIR/cycle.rs:13:13: 13:17\n+      }\n+  \n+      bb0: {\n+          goto -> bb1;                     // scope 0 at $DIR/cycle.rs:12:5: 17:6\n+      }\n+  \n+      bb1: {\n+          StorageLive(_5);                 // scope 0 at $DIR/cycle.rs:12:11: 12:17\n+          _5 = cond() -> bb2;              // scope 0 at $DIR/cycle.rs:12:11: 12:17\n+                                           // mir::Constant\n+                                           // + span: $DIR/cycle.rs:12:11: 12:15\n+                                           // + literal: Const { ty: fn() -> bool {cond}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb2: {\n+          switchInt(move _5) -> [false: bb4, otherwise: bb3]; // scope 0 at $DIR/cycle.rs:12:11: 12:17\n+      }\n+  \n+      bb3: {\n+          StorageLive(_6);                 // scope 0 at $DIR/cycle.rs:13:13: 13:17\n+-         _6 = _3;                         // scope 0 at $DIR/cycle.rs:13:20: 13:21\n++         nop;                             // scope 0 at $DIR/cycle.rs:13:20: 13:21\n+          StorageLive(_7);                 // scope 1 at $DIR/cycle.rs:14:13: 14:14\n+-         _7 = _2;                         // scope 1 at $DIR/cycle.rs:14:13: 14:14\n+-         _3 = move _7;                    // scope 1 at $DIR/cycle.rs:14:9: 14:14\n++         nop;                             // scope 1 at $DIR/cycle.rs:14:13: 14:14\n++         nop;                             // scope 1 at $DIR/cycle.rs:14:9: 14:14\n+          StorageDead(_7);                 // scope 1 at $DIR/cycle.rs:14:13: 14:14\n+          StorageLive(_8);                 // scope 1 at $DIR/cycle.rs:15:13: 15:14\n+-         _8 = _1;                         // scope 1 at $DIR/cycle.rs:15:13: 15:14\n+-         _2 = move _8;                    // scope 1 at $DIR/cycle.rs:15:9: 15:14\n++         nop;                             // scope 1 at $DIR/cycle.rs:15:13: 15:14\n++         nop;                             // scope 1 at $DIR/cycle.rs:15:9: 15:14\n+          StorageDead(_8);                 // scope 1 at $DIR/cycle.rs:15:13: 15:14\n+          StorageLive(_9);                 // scope 1 at $DIR/cycle.rs:16:13: 16:17\n+-         _9 = _6;                         // scope 1 at $DIR/cycle.rs:16:13: 16:17\n+-         _1 = move _9;                    // scope 1 at $DIR/cycle.rs:16:9: 16:17\n++         nop;                             // scope 1 at $DIR/cycle.rs:16:13: 16:17\n++         nop;                             // scope 1 at $DIR/cycle.rs:16:9: 16:17\n+          StorageDead(_9);                 // scope 1 at $DIR/cycle.rs:16:16: 16:17\n+-         _4 = const ();                   // scope 0 at $DIR/cycle.rs:12:18: 17:6\n++         nop;                             // scope 0 at $DIR/cycle.rs:12:18: 17:6\n+          StorageDead(_6);                 // scope 0 at $DIR/cycle.rs:17:5: 17:6\n+          StorageDead(_5);                 // scope 0 at $DIR/cycle.rs:17:5: 17:6\n+          goto -> bb1;                     // scope 0 at $DIR/cycle.rs:12:5: 17:6\n+      }\n+  \n+      bb4: {\n+          StorageLive(_11);                // scope 0 at $DIR/cycle.rs:12:5: 17:6\n+          _0 = const ();                   // scope 0 at $DIR/cycle.rs:12:5: 17:6\n+          StorageDead(_11);                // scope 0 at $DIR/cycle.rs:17:5: 17:6\n+          StorageDead(_5);                 // scope 0 at $DIR/cycle.rs:17:5: 17:6\n+          return;                          // scope 0 at $DIR/cycle.rs:18:2: 18:2\n+      }\n+  }\n+  "}, {"sha": "b35ce0bcb5ad1de071ec29bca04d8a649371afe5", "filename": "src/test/mir-opt/dead-store-elimination/cycle.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bf153a241dda6c44ea34095b57372c64b98989f2/src%2Ftest%2Fmir-opt%2Fdead-store-elimination%2Fcycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf153a241dda6c44ea34095b57372c64b98989f2/src%2Ftest%2Fmir-opt%2Fdead-store-elimination%2Fcycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdead-store-elimination%2Fcycle.rs?ref=bf153a241dda6c44ea34095b57372c64b98989f2", "patch": "@@ -0,0 +1,22 @@\n+// unit-test: DeadStoreElimination\n+\n+#[inline(never)]\n+fn cond() -> bool {\n+    false\n+}\n+\n+// EMIT_MIR cycle.cycle.DeadStoreElimination.diff\n+fn cycle(mut x: i32, mut y: i32, mut z: i32) {\n+    // This example is interesting because the non-transitive version of `MaybeLiveLocals` would\n+    // report that *all* of these stores are live.\n+    while cond() {\n+        let temp = z;\n+        z = y;\n+        y = x;\n+        x = temp;\n+    }\n+}\n+\n+fn main() {\n+    cycle(1, 2, 3);\n+}"}, {"sha": "2250159c8166784ae5065a10b6b5d3dea550bca7", "filename": "src/test/mir-opt/dead-store-elimination/provenance_soundness.pointer_to_int.DeadStoreElimination.diff", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bf153a241dda6c44ea34095b57372c64b98989f2/src%2Ftest%2Fmir-opt%2Fdead-store-elimination%2Fprovenance_soundness.pointer_to_int.DeadStoreElimination.diff", "raw_url": "https://github.com/rust-lang/rust/raw/bf153a241dda6c44ea34095b57372c64b98989f2/src%2Ftest%2Fmir-opt%2Fdead-store-elimination%2Fprovenance_soundness.pointer_to_int.DeadStoreElimination.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdead-store-elimination%2Fprovenance_soundness.pointer_to_int.DeadStoreElimination.diff?ref=bf153a241dda6c44ea34095b57372c64b98989f2", "patch": "@@ -0,0 +1,35 @@\n+- // MIR for `pointer_to_int` before DeadStoreElimination\n++ // MIR for `pointer_to_int` after DeadStoreElimination\n+  \n+  fn pointer_to_int(_1: *mut i32) -> () {\n+      debug p => _1;                       // in scope 0 at $DIR/provenance_soundness.rs:7:19: 7:20\n+      let mut _0: ();                      // return place in scope 0 at $DIR/provenance_soundness.rs:7:32: 7:32\n+      let _2: usize;                       // in scope 0 at $DIR/provenance_soundness.rs:8:9: 8:11\n+      let mut _3: *mut i32;                // in scope 0 at $DIR/provenance_soundness.rs:8:14: 8:15\n+      let mut _5: *mut i32;                // in scope 0 at $DIR/provenance_soundness.rs:9:14: 9:15\n+      scope 1 {\n+          debug _x => _2;                  // in scope 1 at $DIR/provenance_soundness.rs:8:9: 8:11\n+          let _4: isize;                   // in scope 1 at $DIR/provenance_soundness.rs:9:9: 9:11\n+          scope 2 {\n+              debug _y => _4;              // in scope 2 at $DIR/provenance_soundness.rs:9:9: 9:11\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 0 at $DIR/provenance_soundness.rs:8:9: 8:11\n+          StorageLive(_3);                 // scope 0 at $DIR/provenance_soundness.rs:8:14: 8:15\n+          _3 = _1;                         // scope 0 at $DIR/provenance_soundness.rs:8:14: 8:15\n+          _2 = move _3 as usize (Misc);    // scope 0 at $DIR/provenance_soundness.rs:8:14: 8:24\n+          StorageDead(_3);                 // scope 0 at $DIR/provenance_soundness.rs:8:23: 8:24\n+          StorageLive(_4);                 // scope 1 at $DIR/provenance_soundness.rs:9:9: 9:11\n+          StorageLive(_5);                 // scope 1 at $DIR/provenance_soundness.rs:9:14: 9:15\n+          _5 = _1;                         // scope 1 at $DIR/provenance_soundness.rs:9:14: 9:15\n+          _4 = move _5 as isize (Misc);    // scope 1 at $DIR/provenance_soundness.rs:9:14: 9:24\n+          StorageDead(_5);                 // scope 1 at $DIR/provenance_soundness.rs:9:23: 9:24\n+          _0 = const ();                   // scope 0 at $DIR/provenance_soundness.rs:7:32: 10:2\n+          StorageDead(_4);                 // scope 1 at $DIR/provenance_soundness.rs:10:1: 10:2\n+          StorageDead(_2);                 // scope 0 at $DIR/provenance_soundness.rs:10:1: 10:2\n+          return;                          // scope 0 at $DIR/provenance_soundness.rs:10:2: 10:2\n+      }\n+  }\n+  "}, {"sha": "0bfffb6dca3dca9c326b57cf1af0019f11f6d3af", "filename": "src/test/mir-opt/dead-store-elimination/provenance_soundness.retags.DeadStoreElimination.diff", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bf153a241dda6c44ea34095b57372c64b98989f2/src%2Ftest%2Fmir-opt%2Fdead-store-elimination%2Fprovenance_soundness.retags.DeadStoreElimination.diff", "raw_url": "https://github.com/rust-lang/rust/raw/bf153a241dda6c44ea34095b57372c64b98989f2/src%2Ftest%2Fmir-opt%2Fdead-store-elimination%2Fprovenance_soundness.retags.DeadStoreElimination.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdead-store-elimination%2Fprovenance_soundness.retags.DeadStoreElimination.diff?ref=bf153a241dda6c44ea34095b57372c64b98989f2", "patch": "@@ -0,0 +1,14 @@\n+- // MIR for `retags` before DeadStoreElimination\n++ // MIR for `retags` after DeadStoreElimination\n+  \n+  fn retags(_1: &mut i32) -> () {\n+      debug _r => _1;                      // in scope 0 at $DIR/provenance_soundness.rs:13:11: 13:13\n+      let mut _0: ();                      // return place in scope 0 at $DIR/provenance_soundness.rs:13:25: 13:25\n+  \n+      bb0: {\n+          Retag([fn entry] _1);            // scope 0 at $DIR/provenance_soundness.rs:13:1: 13:27\n+          _0 = const ();                   // scope 0 at $DIR/provenance_soundness.rs:13:25: 13:27\n+          return;                          // scope 0 at $DIR/provenance_soundness.rs:13:27: 13:27\n+      }\n+  }\n+  "}, {"sha": "11314e990982c579677fe57991e84d27adbaacce", "filename": "src/test/mir-opt/dead-store-elimination/provenance_soundness.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bf153a241dda6c44ea34095b57372c64b98989f2/src%2Ftest%2Fmir-opt%2Fdead-store-elimination%2Fprovenance_soundness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf153a241dda6c44ea34095b57372c64b98989f2/src%2Ftest%2Fmir-opt%2Fdead-store-elimination%2Fprovenance_soundness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdead-store-elimination%2Fprovenance_soundness.rs?ref=bf153a241dda6c44ea34095b57372c64b98989f2", "patch": "@@ -0,0 +1,18 @@\n+// unit-test: DeadStoreElimination\n+// compile-flags: -Zmir-emit-retag\n+\n+// Test that we don't remove pointer to int casts or retags\n+\n+// EMIT_MIR provenance_soundness.pointer_to_int.DeadStoreElimination.diff\n+fn pointer_to_int(p: *mut i32) {\n+    let _x = p as usize;\n+    let _y = p as isize;\n+}\n+\n+// EMIT_MIR provenance_soundness.retags.DeadStoreElimination.diff\n+fn retags(_r: &mut i32) {}\n+\n+fn main() {\n+    pointer_to_int(&mut 5 as *mut _);\n+    retags(&mut 5);\n+}"}, {"sha": "b67e6cb4708546b8404bcaec13efa6d6bcb56f7f", "filename": "src/test/mir-opt/dest-prop/copy_propagation_arg.arg_src.DestinationPropagation.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf153a241dda6c44ea34095b57372c64b98989f2/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcopy_propagation_arg.arg_src.DestinationPropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/bf153a241dda6c44ea34095b57372c64b98989f2/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcopy_propagation_arg.arg_src.DestinationPropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcopy_propagation_arg.arg_src.DestinationPropagation.diff?ref=bf153a241dda6c44ea34095b57372c64b98989f2", "patch": "@@ -2,7 +2,7 @@\n + // MIR for `arg_src` after DestinationPropagation\n   \n   fn arg_src(_1: i32) -> i32 {\n-      debug x => _1;                       // in scope 0 at $DIR/copy_propagation_arg.rs:27:12: 27:17\n+      debug x => const 123_i32;            // in scope 0 at $DIR/copy_propagation_arg.rs:27:12: 27:17\n       let mut _0: i32;                     // return place in scope 0 at $DIR/copy_propagation_arg.rs:27:27: 27:30\n       let _2: i32;                         // in scope 0 at $DIR/copy_propagation_arg.rs:28:9: 28:10\n       scope 1 {"}, {"sha": "1b8772b6a68afa61f95535c1c665f49ed9d1d7c6", "filename": "src/test/mir-opt/dest-prop/copy_propagation_arg.bar.DestinationPropagation.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf153a241dda6c44ea34095b57372c64b98989f2/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcopy_propagation_arg.bar.DestinationPropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/bf153a241dda6c44ea34095b57372c64b98989f2/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcopy_propagation_arg.bar.DestinationPropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcopy_propagation_arg.bar.DestinationPropagation.diff?ref=bf153a241dda6c44ea34095b57372c64b98989f2", "patch": "@@ -2,7 +2,7 @@\n + // MIR for `bar` after DestinationPropagation\n   \n   fn bar(_1: u8) -> () {\n-      debug x => _1;                       // in scope 0 at $DIR/copy_propagation_arg.rs:15:8: 15:13\n+      debug x => const 5_u8;               // in scope 0 at $DIR/copy_propagation_arg.rs:15:8: 15:13\n       let mut _0: ();                      // return place in scope 0 at $DIR/copy_propagation_arg.rs:15:19: 15:19\n       let _2: u8;                          // in scope 0 at $DIR/copy_propagation_arg.rs:16:5: 16:13\n       let mut _3: u8;                      // in scope 0 at $DIR/copy_propagation_arg.rs:16:11: 16:12"}]}