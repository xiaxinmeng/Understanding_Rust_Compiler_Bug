{"sha": "126e3df4065623802eda752e79839d1b6fde59be", "node_id": "C_kwDOAAsO6NoAKDEyNmUzZGY0MDY1NjIzODAyZWRhNzUyZTc5ODM5ZDFiNmZkZTU5YmU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-29T00:20:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-29T00:20:57Z"}, "message": "Auto merge of #98376 - nnethercote:improve-derive-PartialEq, r=petrochenkov\n\nImprove some deriving code and add a test\n\nThe `.stdout` test is particularly useful.\n\nr? `@petrochenkov`", "tree": {"sha": "f80a08d194067d83d67c56fb207d5c850ddd436f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f80a08d194067d83d67c56fb207d5c850ddd436f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/126e3df4065623802eda752e79839d1b6fde59be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/126e3df4065623802eda752e79839d1b6fde59be", "html_url": "https://github.com/rust-lang/rust/commit/126e3df4065623802eda752e79839d1b6fde59be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/126e3df4065623802eda752e79839d1b6fde59be/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2953edc7b7a00d14c4ba940ebb46b4e7148a9d71", "url": "https://api.github.com/repos/rust-lang/rust/commits/2953edc7b7a00d14c4ba940ebb46b4e7148a9d71", "html_url": "https://github.com/rust-lang/rust/commit/2953edc7b7a00d14c4ba940ebb46b4e7148a9d71"}, {"sha": "02d2cdfc288c4ef8f041f66bc207ad3087b3cbac", "url": "https://api.github.com/repos/rust-lang/rust/commits/02d2cdfc288c4ef8f041f66bc207ad3087b3cbac", "html_url": "https://github.com/rust-lang/rust/commit/02d2cdfc288c4ef8f041f66bc207ad3087b3cbac"}], "stats": {"total": 1382, "additions": 1251, "deletions": 131}, "files": [{"sha": "8331710699063296518cf1eed8d0af1009af8b15", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/126e3df4065623802eda752e79839d1b6fde59be/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126e3df4065623802eda752e79839d1b6fde59be/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=126e3df4065623802eda752e79839d1b6fde59be", "patch": "@@ -3,9 +3,9 @@ use crate::deriving::generic::*;\n use crate::deriving::path_std;\n \n use rustc_ast::ptr::P;\n-use rustc_ast::{self as ast, Expr, GenericArg, Generics, ItemKind, MetaItem, VariantData};\n+use rustc_ast::{self as ast, Expr, Generics, ItemKind, MetaItem, VariantData};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n-use rustc_span::symbol::{kw, sym, Ident, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n \n pub fn expand_deriving_clone(\n@@ -107,44 +107,38 @@ fn cs_clone_shallow(\n     substr: &Substructure<'_>,\n     is_union: bool,\n ) -> P<Expr> {\n-    fn assert_ty_bounds(\n-        cx: &mut ExtCtxt<'_>,\n-        stmts: &mut Vec<ast::Stmt>,\n-        ty: P<ast::Ty>,\n-        span: Span,\n-        helper_name: &str,\n-    ) {\n-        // Generate statement `let _: helper_name<ty>;`,\n-        // set the expn ID so we can use the unstable struct.\n-        let span = cx.with_def_site_ctxt(span);\n-        let assert_path = cx.path_all(\n-            span,\n-            true,\n-            cx.std_path(&[sym::clone, Symbol::intern(helper_name)]),\n-            vec![GenericArg::Type(ty)],\n-        );\n-        stmts.push(cx.stmt_let_type_only(span, cx.ty_path(assert_path)));\n-    }\n-    fn process_variant(cx: &mut ExtCtxt<'_>, stmts: &mut Vec<ast::Stmt>, variant: &VariantData) {\n+    let mut stmts = Vec::new();\n+    let mut process_variant = |variant: &VariantData| {\n         for field in variant.fields() {\n             // let _: AssertParamIsClone<FieldTy>;\n-            assert_ty_bounds(cx, stmts, field.ty.clone(), field.span, \"AssertParamIsClone\");\n+            super::assert_ty_bounds(\n+                cx,\n+                &mut stmts,\n+                field.ty.clone(),\n+                field.span,\n+                &[sym::clone, sym::AssertParamIsClone],\n+            );\n         }\n-    }\n+    };\n \n-    let mut stmts = Vec::new();\n     if is_union {\n         // let _: AssertParamIsCopy<Self>;\n         let self_ty = cx.ty_path(cx.path_ident(trait_span, Ident::with_dummy_span(kw::SelfUpper)));\n-        assert_ty_bounds(cx, &mut stmts, self_ty, trait_span, \"AssertParamIsCopy\");\n+        super::assert_ty_bounds(\n+            cx,\n+            &mut stmts,\n+            self_ty,\n+            trait_span,\n+            &[sym::clone, sym::AssertParamIsCopy],\n+        );\n     } else {\n         match *substr.fields {\n             StaticStruct(vdata, ..) => {\n-                process_variant(cx, &mut stmts, vdata);\n+                process_variant(vdata);\n             }\n             StaticEnum(enum_def, ..) => {\n                 for variant in &enum_def.variants {\n-                    process_variant(cx, &mut stmts, &variant.data);\n+                    process_variant(&variant.data);\n                 }\n             }\n             _ => cx.span_bug("}, {"sha": "f54ded3c87cab836853f779f0c2b4d9d33cc4135", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/eq.rs", "status": "modified", "additions": 14, "deletions": 30, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/126e3df4065623802eda752e79839d1b6fde59be/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126e3df4065623802eda752e79839d1b6fde59be/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs?ref=126e3df4065623802eda752e79839d1b6fde59be", "patch": "@@ -3,9 +3,9 @@ use crate::deriving::generic::*;\n use crate::deriving::path_std;\n \n use rustc_ast::ptr::P;\n-use rustc_ast::{self as ast, Expr, GenericArg, MetaItem};\n+use rustc_ast::{self as ast, Expr, MetaItem};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n-use rustc_span::symbol::{sym, Ident, Symbol};\n+use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n \n pub fn expand_deriving_eq(\n@@ -55,43 +55,27 @@ fn cs_total_eq_assert(\n     trait_span: Span,\n     substr: &Substructure<'_>,\n ) -> P<Expr> {\n-    fn assert_ty_bounds(\n-        cx: &mut ExtCtxt<'_>,\n-        stmts: &mut Vec<ast::Stmt>,\n-        ty: P<ast::Ty>,\n-        span: Span,\n-        helper_name: &str,\n-    ) {\n-        // Generate statement `let _: helper_name<ty>;`,\n-        // set the expn ID so we can use the unstable struct.\n-        let span = cx.with_def_site_ctxt(span);\n-        let assert_path = cx.path_all(\n-            span,\n-            true,\n-            cx.std_path(&[sym::cmp, Symbol::intern(helper_name)]),\n-            vec![GenericArg::Type(ty)],\n-        );\n-        stmts.push(cx.stmt_let_type_only(span, cx.ty_path(assert_path)));\n-    }\n-    fn process_variant(\n-        cx: &mut ExtCtxt<'_>,\n-        stmts: &mut Vec<ast::Stmt>,\n-        variant: &ast::VariantData,\n-    ) {\n+    let mut stmts = Vec::new();\n+    let mut process_variant = |variant: &ast::VariantData| {\n         for field in variant.fields() {\n             // let _: AssertParamIsEq<FieldTy>;\n-            assert_ty_bounds(cx, stmts, field.ty.clone(), field.span, \"AssertParamIsEq\");\n+            super::assert_ty_bounds(\n+                cx,\n+                &mut stmts,\n+                field.ty.clone(),\n+                field.span,\n+                &[sym::cmp, sym::AssertParamIsEq],\n+            );\n         }\n-    }\n+    };\n \n-    let mut stmts = Vec::new();\n     match *substr.fields {\n         StaticStruct(vdata, ..) => {\n-            process_variant(cx, &mut stmts, vdata);\n+            process_variant(vdata);\n         }\n         StaticEnum(enum_def, ..) => {\n             for variant in &enum_def.variants {\n-                process_variant(cx, &mut stmts, &variant.data);\n+                process_variant(&variant.data);\n             }\n         }\n         _ => cx.span_bug(trait_span, \"unexpected substructure in `derive(Eq)`\"),"}, {"sha": "8347cded2fe0bb0adb9913421ea3bf0778b9b4cc", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 36, "deletions": 73, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/126e3df4065623802eda752e79839d1b6fde59be/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126e3df4065623802eda752e79839d1b6fde59be/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=126e3df4065623802eda752e79839d1b6fde59be", "patch": "@@ -1126,75 +1126,43 @@ impl<'a> MethodDef<'a> {\n     ///     A1,\n     ///     A2(i32)\n     /// }\n-    ///\n-    /// // is equivalent to\n-    ///\n-    /// impl PartialEq for A {\n+    /// ```\n+    /// is equivalent to:\n+    /// ```\n+    /// impl ::core::cmp::PartialEq for A {\n+    ///     #[inline]\n     ///     fn eq(&self, other: &A) -> bool {\n-    ///         use A::*;\n-    ///         match (&*self, &*other) {\n-    ///             (&A1, &A1) => true,\n-    ///             (&A2(ref self_0),\n-    ///              &A2(ref __arg_1_0)) => (*self_0).eq(&(*__arg_1_0)),\n-    ///             _ => {\n-    ///                 let __self_vi = match *self { A1 => 0, A2(..) => 1 };\n-    ///                 let __arg_1_vi = match *other { A1 => 0, A2(..) => 1 };\n-    ///                 false\n+    ///         {\n+    ///             let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+    ///             let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+    ///             if true && __self_vi == __arg_1_vi {\n+    ///                 match (&*self, &*other) {\n+    ///                     (&A::A2(ref __self_0), &A::A2(ref __arg_1_0)) =>\n+    ///                         (*__self_0) == (*__arg_1_0),\n+    ///                     _ => true,\n+    ///                 }\n+    ///             } else {\n+    ///                 false // catch-all handler\n     ///             }\n     ///         }\n     ///     }\n     /// }\n     /// ```\n-    ///\n-    /// (Of course `__self_vi` and `__arg_1_vi` are unused for\n-    /// `PartialEq`, and those subcomputations will hopefully be removed\n-    /// as their results are unused. The point of `__self_vi` and\n-    /// `__arg_1_vi` is for `PartialOrd`; see #15503.)\n-    fn expand_enum_method_body<'b>(\n-        &self,\n-        cx: &mut ExtCtxt<'_>,\n-        trait_: &TraitDef<'b>,\n-        enum_def: &'b EnumDef,\n-        type_ident: Ident,\n-        self_args: Vec<P<Expr>>,\n-        nonself_args: &[P<Expr>],\n-    ) -> P<Expr> {\n-        self.build_enum_match_tuple(cx, trait_, enum_def, type_ident, self_args, nonself_args)\n-    }\n-\n     /// Creates a match for a tuple of all `self_args`, where either all\n     /// variants match, or it falls into a catch-all for when one variant\n     /// does not match.\n-\n+    ///\n     /// There are N + 1 cases because is a case for each of the N\n     /// variants where all of the variants match, and one catch-all for\n     /// when one does not match.\n-\n+    ///\n     /// As an optimization we generate code which checks whether all variants\n     /// match first which makes llvm see that C-like enums can be compiled into\n     /// a simple equality check (for PartialEq).\n-\n+    ///\n     /// The catch-all handler is provided access the variant index values\n     /// for each of the self-args, carried in precomputed variables.\n-\n-    /// ```{.text}\n-    /// let __self0_vi = std::intrinsics::discriminant_value(&self);\n-    /// let __self1_vi = std::intrinsics::discriminant_value(&arg1);\n-    /// let __self2_vi = std::intrinsics::discriminant_value(&arg2);\n-    ///\n-    /// if __self0_vi == __self1_vi && __self0_vi == __self2_vi && ... {\n-    ///     match (...) {\n-    ///         (Variant1, Variant1, ...) => Body1\n-    ///         (Variant2, Variant2, ...) => Body2,\n-    ///         ...\n-    ///         _ => ::core::intrinsics::unreachable()\n-    ///     }\n-    /// }\n-    /// else {\n-    ///     ... // catch-all remainder can inspect above variant index values.\n-    /// }\n-    /// ```\n-    fn build_enum_match_tuple<'b>(\n+    fn expand_enum_method_body<'b>(\n         &self,\n         cx: &mut ExtCtxt<'_>,\n         trait_: &TraitDef<'b>,\n@@ -1392,37 +1360,32 @@ impl<'a> MethodDef<'a> {\n             //\n             // i.e., for `enum E<T> { A, B(1), C(T, T) }`, and a deriving\n             // with three Self args, builds three statements:\n-            //\n             // ```\n-            // let __self0_vi = std::intrinsics::discriminant_value(&self);\n-            // let __self1_vi = std::intrinsics::discriminant_value(&arg1);\n-            // let __self2_vi = std::intrinsics::discriminant_value(&arg2);\n+            // let __self_vi = std::intrinsics::discriminant_value(&self);\n+            // let __arg_1_vi = std::intrinsics::discriminant_value(&arg1);\n+            // let __arg_2_vi = std::intrinsics::discriminant_value(&arg2);\n             // ```\n             let mut index_let_stmts: Vec<ast::Stmt> = Vec::with_capacity(vi_idents.len() + 1);\n \n-            // We also build an expression which checks whether all discriminants are equal\n-            // discriminant_test = __self0_vi == __self1_vi && __self0_vi == __self2_vi && ...\n+            // We also build an expression which checks whether all discriminants are equal:\n+            // `__self_vi == __arg_1_vi && __self_vi == __arg_2_vi && ...`\n             let mut discriminant_test = cx.expr_bool(span, true);\n-\n-            let mut first_ident = None;\n-            for (&ident, self_arg) in iter::zip(&vi_idents, &self_args) {\n+            for (i, (&ident, self_arg)) in iter::zip(&vi_idents, &self_args).enumerate() {\n                 let self_addr = cx.expr_addr_of(span, self_arg.clone());\n                 let variant_value =\n                     deriving::call_intrinsic(cx, span, sym::discriminant_value, vec![self_addr]);\n                 let let_stmt = cx.stmt_let(span, false, ident, variant_value);\n                 index_let_stmts.push(let_stmt);\n \n-                match first_ident {\n-                    Some(first) => {\n-                        let first_expr = cx.expr_ident(span, first);\n-                        let id = cx.expr_ident(span, ident);\n-                        let test = cx.expr_binary(span, BinOpKind::Eq, first_expr, id);\n-                        discriminant_test =\n-                            cx.expr_binary(span, BinOpKind::And, discriminant_test, test)\n-                    }\n-                    None => {\n-                        first_ident = Some(ident);\n-                    }\n+                if i > 0 {\n+                    let id0 = cx.expr_ident(span, vi_idents[0]);\n+                    let id = cx.expr_ident(span, ident);\n+                    let test = cx.expr_binary(span, BinOpKind::Eq, id0, id);\n+                    discriminant_test = if i == 1 {\n+                        test\n+                    } else {\n+                        cx.expr_binary(span, BinOpKind::And, discriminant_test, test)\n+                    };\n                 }\n             }\n \n@@ -1453,7 +1416,7 @@ impl<'a> MethodDef<'a> {\n             //      }\n             //  }\n             //  else {\n-            //      <delegated expression referring to __self0_vi, et al.>\n+            //      <delegated expression referring to __self_vi, et al.>\n             //  }\n             let all_match = cx.expr_match(span, match_arg, match_arms);\n             let arm_expr = cx.expr_if(span, discriminant_test, all_match, Some(arm_expr));"}, {"sha": "c1ca089da221f3c12fcd0561f6e6a3858f915d5a", "filename": "compiler/rustc_builtin_macros/src/deriving/mod.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/126e3df4065623802eda752e79839d1b6fde59be/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126e3df4065623802eda752e79839d1b6fde59be/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs?ref=126e3df4065623802eda752e79839d1b6fde59be", "patch": "@@ -2,7 +2,7 @@\n \n use rustc_ast as ast;\n use rustc_ast::ptr::P;\n-use rustc_ast::{Impl, ItemKind, MetaItem};\n+use rustc_ast::{GenericArg, Impl, ItemKind, MetaItem};\n use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, MultiItemModifier};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n@@ -193,3 +193,16 @@ fn inject_impl_of_structural_trait(\n \n     push(Annotatable::Item(newitem));\n }\n+\n+fn assert_ty_bounds(\n+    cx: &mut ExtCtxt<'_>,\n+    stmts: &mut Vec<ast::Stmt>,\n+    ty: P<ast::Ty>,\n+    span: Span,\n+    assert_path: &[Symbol],\n+) {\n+    // Generate statement `let _: assert_path<ty>;`.\n+    let span = cx.with_def_site_ctxt(span);\n+    let assert_path = cx.path_all(span, true, cx.std_path(assert_path), vec![GenericArg::Type(ty)]);\n+    stmts.push(cx.stmt_let_type_only(span, cx.ty_path(assert_path)));\n+}"}, {"sha": "4e28d2b6001edfe3268b8b1c3879bb1d190065a8", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/126e3df4065623802eda752e79839d1b6fde59be/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126e3df4065623802eda752e79839d1b6fde59be/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=126e3df4065623802eda752e79839d1b6fde59be", "patch": "@@ -135,6 +135,9 @@ symbols! {\n         Arguments,\n         AsMut,\n         AsRef,\n+        AssertParamIsClone,\n+        AssertParamIsCopy,\n+        AssertParamIsEq,\n         AtomicBool,\n         AtomicI128,\n         AtomicI16,"}, {"sha": "2f6ef74ac49410866b0cf515bdd4aba01619ca84", "filename": "src/test/ui/deriving/deriving-all-codegen.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/126e3df4065623802eda752e79839d1b6fde59be/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/126e3df4065623802eda752e79839d1b6fde59be/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.rs?ref=126e3df4065623802eda752e79839d1b6fde59be", "patch": "@@ -0,0 +1,63 @@\n+// check-pass\n+// compile-flags: -Zunpretty=expanded\n+// edition:2021\n+//\n+// This test checks the code generated for all[*] the builtin derivable traits\n+// on a variety of structs and enums. It protects against accidental changes to\n+// the generated code, and makes deliberate changes to the generated code\n+// easier to review.\n+//\n+// [*] It excludes `Copy` in some cases, because that changes the code\n+// generated for `Clone`.\n+//\n+// [*] It excludes `RustcEncodable` and `RustDecodable`, which are obsolete and\n+// also require the `rustc_serialize` crate.\n+\n+#![crate_type = \"lib\"]\n+#![allow(dead_code)]\n+#![allow(deprecated)]\n+\n+// Empty struct.\n+#[derive(Clone, Copy, Debug, Default, Hash, PartialEq, Eq, PartialOrd, Ord)]\n+struct Empty;\n+\n+// A basic struct.\n+#[derive(Clone, Copy, Debug, Default, Hash, PartialEq, Eq, PartialOrd, Ord)]\n+struct Point {\n+    x: u32,\n+    y: u32,\n+}\n+\n+// A long struct.\n+#[derive(Clone, Debug, Default, Hash, PartialEq, Eq, PartialOrd, Ord)]\n+struct Big {\n+    b1: u32, b2: u32, b3: u32, b4: u32, b5: u32, b6: u32, b7: u32, b8:u32,\n+}\n+\n+// A C-like, fieldless enum.\n+#[derive(Clone, Copy, Debug, Default, Hash, PartialEq, Eq, PartialOrd, Ord)]\n+enum Fieldless {\n+    #[default]\n+    A,\n+    B,\n+    C,\n+}\n+\n+// An enum with multiple fieldless and fielded variants.\n+#[derive(Clone, Copy, Debug, Default, Hash, PartialEq, Eq, PartialOrd, Ord)]\n+enum Mixed {\n+    #[default]\n+    P,\n+    Q,\n+    R(u32),\n+    S { d1: u32, d2: u32 },\n+}\n+\n+// An enum with no fieldless variants. Note that `Default` cannot be derived\n+// for this enum.\n+#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]\n+enum Fielded {\n+    X(u32),\n+    Y(bool),\n+    Z(Option<i32>),\n+}"}, {"sha": "faa5a3c3ddf1b875b184662f2d093435e518adad", "filename": "src/test/ui/deriving/deriving-all-codegen.stdout", "status": "added", "additions": 1100, "deletions": 0, "changes": 1100, "blob_url": "https://github.com/rust-lang/rust/blob/126e3df4065623802eda752e79839d1b6fde59be/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/126e3df4065623802eda752e79839d1b6fde59be/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout?ref=126e3df4065623802eda752e79839d1b6fde59be", "patch": "@@ -0,0 +1,1100 @@\n+#![feature(prelude_import)]\n+// check-pass\n+// compile-flags: -Zunpretty=expanded\n+// edition:2021\n+//\n+// This test checks the code generated for all[*] the builtin derivable traits\n+// on a variety of structs and enums. It protects against accidental changes to\n+// the generated code, and makes deliberate changes to the generated code\n+// easier to review.\n+//\n+// [*] It excludes `Copy` in some cases, because that changes the code\n+// generated for `Clone`.\n+//\n+// [*] It excludes `RustcEncodable` and `RustDecodable`, which are obsolete and\n+// also require the `rustc_serialize` crate.\n+\n+#![crate_type = \"lib\"]\n+#![allow(dead_code)]\n+#![allow(deprecated)]\n+#[prelude_import]\n+use std::prelude::rust_2021::*;\n+#[macro_use]\n+extern crate std;\n+\n+// Empty struct.\n+struct Empty;\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::clone::Clone for Empty {\n+    #[inline]\n+    fn clone(&self) -> Empty { { *self } }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::marker::Copy for Empty { }\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::fmt::Debug for Empty {\n+    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n+        match *self { Self => ::core::fmt::Formatter::write_str(f, \"Empty\"), }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::default::Default for Empty {\n+    #[inline]\n+    fn default() -> Empty { Empty {} }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::hash::Hash for Empty {\n+    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n+        match *self { Self => {} }\n+    }\n+}\n+impl ::core::marker::StructuralPartialEq for Empty {}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::PartialEq for Empty {\n+    #[inline]\n+    fn eq(&self, other: &Empty) -> bool {\n+        match *other { Self => match *self { Self => true, }, }\n+    }\n+}\n+impl ::core::marker::StructuralEq for Empty {}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::Eq for Empty {\n+    #[inline]\n+    #[doc(hidden)]\n+    #[no_coverage]\n+    fn assert_receiver_is_total_eq(&self) -> () { {} }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::PartialOrd for Empty {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Empty)\n+        -> ::core::option::Option<::core::cmp::Ordering> {\n+        match *other {\n+            Self =>\n+                match *self {\n+                    Self =>\n+                        ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+                },\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::Ord for Empty {\n+    #[inline]\n+    fn cmp(&self, other: &Empty) -> ::core::cmp::Ordering {\n+        match *other {\n+            Self => match *self { Self => ::core::cmp::Ordering::Equal, },\n+        }\n+    }\n+}\n+\n+// A basic struct.\n+struct Point {\n+    x: u32,\n+    y: u32,\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::clone::Clone for Point {\n+    #[inline]\n+    fn clone(&self) -> Point {\n+        {\n+            let _: ::core::clone::AssertParamIsClone<u32>;\n+            let _: ::core::clone::AssertParamIsClone<u32>;\n+            *self\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::marker::Copy for Point { }\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::fmt::Debug for Point {\n+    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n+        match *self {\n+            Self { x: ref __self_0_0, y: ref __self_0_1 } =>\n+                ::core::fmt::Formatter::debug_struct_field2_finish(f, \"Point\",\n+                    \"x\", &&(*__self_0_0), \"y\", &&(*__self_0_1)),\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::default::Default for Point {\n+    #[inline]\n+    fn default() -> Point {\n+        Point {\n+            x: ::core::default::Default::default(),\n+            y: ::core::default::Default::default(),\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::hash::Hash for Point {\n+    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n+        match *self {\n+            Self { x: ref __self_0_0, y: ref __self_0_1 } => {\n+                ::core::hash::Hash::hash(&(*__self_0_0), state);\n+                ::core::hash::Hash::hash(&(*__self_0_1), state)\n+            }\n+        }\n+    }\n+}\n+impl ::core::marker::StructuralPartialEq for Point {}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::PartialEq for Point {\n+    #[inline]\n+    fn eq(&self, other: &Point) -> bool {\n+        match *other {\n+            Self { x: ref __self_1_0, y: ref __self_1_1 } =>\n+                match *self {\n+                    Self { x: ref __self_0_0, y: ref __self_0_1 } =>\n+                        (*__self_0_0) == (*__self_1_0) &&\n+                            (*__self_0_1) == (*__self_1_1),\n+                },\n+        }\n+    }\n+    #[inline]\n+    fn ne(&self, other: &Point) -> bool {\n+        match *other {\n+            Self { x: ref __self_1_0, y: ref __self_1_1 } =>\n+                match *self {\n+                    Self { x: ref __self_0_0, y: ref __self_0_1 } =>\n+                        (*__self_0_0) != (*__self_1_0) ||\n+                            (*__self_0_1) != (*__self_1_1),\n+                },\n+        }\n+    }\n+}\n+impl ::core::marker::StructuralEq for Point {}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::Eq for Point {\n+    #[inline]\n+    #[doc(hidden)]\n+    #[no_coverage]\n+    fn assert_receiver_is_total_eq(&self) -> () {\n+        {\n+            let _: ::core::cmp::AssertParamIsEq<u32>;\n+            let _: ::core::cmp::AssertParamIsEq<u32>;\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::PartialOrd for Point {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Point)\n+        -> ::core::option::Option<::core::cmp::Ordering> {\n+        match *other {\n+            Self { x: ref __self_1_0, y: ref __self_1_1 } =>\n+                match *self {\n+                    Self { x: ref __self_0_0, y: ref __self_0_1 } =>\n+                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),\n+                                &(*__self_1_0)) {\n+                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                =>\n+                                match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),\n+                                        &(*__self_1_1)) {\n+                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                        =>\n+                                        ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+                                    cmp => cmp,\n+                                },\n+                            cmp => cmp,\n+                        },\n+                },\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::Ord for Point {\n+    #[inline]\n+    fn cmp(&self, other: &Point) -> ::core::cmp::Ordering {\n+        match *other {\n+            Self { x: ref __self_1_0, y: ref __self_1_1 } =>\n+                match *self {\n+                    Self { x: ref __self_0_0, y: ref __self_0_1 } =>\n+                        match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0))\n+                            {\n+                            ::core::cmp::Ordering::Equal =>\n+                                match ::core::cmp::Ord::cmp(&(*__self_0_1), &(*__self_1_1))\n+                                    {\n+                                    ::core::cmp::Ordering::Equal =>\n+                                        ::core::cmp::Ordering::Equal,\n+                                    cmp => cmp,\n+                                },\n+                            cmp => cmp,\n+                        },\n+                },\n+        }\n+    }\n+}\n+\n+// A long struct.\n+struct Big {\n+    b1: u32,\n+    b2: u32,\n+    b3: u32,\n+    b4: u32,\n+    b5: u32,\n+    b6: u32,\n+    b7: u32,\n+    b8: u32,\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::clone::Clone for Big {\n+    #[inline]\n+    fn clone(&self) -> Big {\n+        match *self {\n+            Self {\n+                b1: ref __self_0_0,\n+                b2: ref __self_0_1,\n+                b3: ref __self_0_2,\n+                b4: ref __self_0_3,\n+                b5: ref __self_0_4,\n+                b6: ref __self_0_5,\n+                b7: ref __self_0_6,\n+                b8: ref __self_0_7 } =>\n+                Big {\n+                    b1: ::core::clone::Clone::clone(&(*__self_0_0)),\n+                    b2: ::core::clone::Clone::clone(&(*__self_0_1)),\n+                    b3: ::core::clone::Clone::clone(&(*__self_0_2)),\n+                    b4: ::core::clone::Clone::clone(&(*__self_0_3)),\n+                    b5: ::core::clone::Clone::clone(&(*__self_0_4)),\n+                    b6: ::core::clone::Clone::clone(&(*__self_0_5)),\n+                    b7: ::core::clone::Clone::clone(&(*__self_0_6)),\n+                    b8: ::core::clone::Clone::clone(&(*__self_0_7)),\n+                },\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::fmt::Debug for Big {\n+    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n+        match *self {\n+            Self {\n+                b1: ref __self_0_0,\n+                b2: ref __self_0_1,\n+                b3: ref __self_0_2,\n+                b4: ref __self_0_3,\n+                b5: ref __self_0_4,\n+                b6: ref __self_0_5,\n+                b7: ref __self_0_6,\n+                b8: ref __self_0_7 } => {\n+                let names: &'static _ =\n+                    &[\"b1\", \"b2\", \"b3\", \"b4\", \"b5\", \"b6\", \"b7\", \"b8\"];\n+                let values: &[&dyn ::core::fmt::Debug] =\n+                    &[&&(*__self_0_0), &&(*__self_0_1), &&(*__self_0_2),\n+                                &&(*__self_0_3), &&(*__self_0_4), &&(*__self_0_5),\n+                                &&(*__self_0_6), &&(*__self_0_7)];\n+                ::core::fmt::Formatter::debug_struct_fields_finish(f, \"Big\",\n+                    names, values)\n+            }\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::default::Default for Big {\n+    #[inline]\n+    fn default() -> Big {\n+        Big {\n+            b1: ::core::default::Default::default(),\n+            b2: ::core::default::Default::default(),\n+            b3: ::core::default::Default::default(),\n+            b4: ::core::default::Default::default(),\n+            b5: ::core::default::Default::default(),\n+            b6: ::core::default::Default::default(),\n+            b7: ::core::default::Default::default(),\n+            b8: ::core::default::Default::default(),\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::hash::Hash for Big {\n+    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n+        match *self {\n+            Self {\n+                b1: ref __self_0_0,\n+                b2: ref __self_0_1,\n+                b3: ref __self_0_2,\n+                b4: ref __self_0_3,\n+                b5: ref __self_0_4,\n+                b6: ref __self_0_5,\n+                b7: ref __self_0_6,\n+                b8: ref __self_0_7 } => {\n+                ::core::hash::Hash::hash(&(*__self_0_0), state);\n+                ::core::hash::Hash::hash(&(*__self_0_1), state);\n+                ::core::hash::Hash::hash(&(*__self_0_2), state);\n+                ::core::hash::Hash::hash(&(*__self_0_3), state);\n+                ::core::hash::Hash::hash(&(*__self_0_4), state);\n+                ::core::hash::Hash::hash(&(*__self_0_5), state);\n+                ::core::hash::Hash::hash(&(*__self_0_6), state);\n+                ::core::hash::Hash::hash(&(*__self_0_7), state)\n+            }\n+        }\n+    }\n+}\n+impl ::core::marker::StructuralPartialEq for Big {}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::PartialEq for Big {\n+    #[inline]\n+    fn eq(&self, other: &Big) -> bool {\n+        match *other {\n+            Self {\n+                b1: ref __self_1_0,\n+                b2: ref __self_1_1,\n+                b3: ref __self_1_2,\n+                b4: ref __self_1_3,\n+                b5: ref __self_1_4,\n+                b6: ref __self_1_5,\n+                b7: ref __self_1_6,\n+                b8: ref __self_1_7 } =>\n+                match *self {\n+                    Self {\n+                        b1: ref __self_0_0,\n+                        b2: ref __self_0_1,\n+                        b3: ref __self_0_2,\n+                        b4: ref __self_0_3,\n+                        b5: ref __self_0_4,\n+                        b6: ref __self_0_5,\n+                        b7: ref __self_0_6,\n+                        b8: ref __self_0_7 } =>\n+                        (*__self_0_0) == (*__self_1_0) &&\n+                                                    (*__self_0_1) == (*__self_1_1) &&\n+                                                (*__self_0_2) == (*__self_1_2) &&\n+                                            (*__self_0_3) == (*__self_1_3) &&\n+                                        (*__self_0_4) == (*__self_1_4) &&\n+                                    (*__self_0_5) == (*__self_1_5) &&\n+                                (*__self_0_6) == (*__self_1_6) &&\n+                            (*__self_0_7) == (*__self_1_7),\n+                },\n+        }\n+    }\n+    #[inline]\n+    fn ne(&self, other: &Big) -> bool {\n+        match *other {\n+            Self {\n+                b1: ref __self_1_0,\n+                b2: ref __self_1_1,\n+                b3: ref __self_1_2,\n+                b4: ref __self_1_3,\n+                b5: ref __self_1_4,\n+                b6: ref __self_1_5,\n+                b7: ref __self_1_6,\n+                b8: ref __self_1_7 } =>\n+                match *self {\n+                    Self {\n+                        b1: ref __self_0_0,\n+                        b2: ref __self_0_1,\n+                        b3: ref __self_0_2,\n+                        b4: ref __self_0_3,\n+                        b5: ref __self_0_4,\n+                        b6: ref __self_0_5,\n+                        b7: ref __self_0_6,\n+                        b8: ref __self_0_7 } =>\n+                        (*__self_0_0) != (*__self_1_0) ||\n+                                                    (*__self_0_1) != (*__self_1_1) ||\n+                                                (*__self_0_2) != (*__self_1_2) ||\n+                                            (*__self_0_3) != (*__self_1_3) ||\n+                                        (*__self_0_4) != (*__self_1_4) ||\n+                                    (*__self_0_5) != (*__self_1_5) ||\n+                                (*__self_0_6) != (*__self_1_6) ||\n+                            (*__self_0_7) != (*__self_1_7),\n+                },\n+        }\n+    }\n+}\n+impl ::core::marker::StructuralEq for Big {}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::Eq for Big {\n+    #[inline]\n+    #[doc(hidden)]\n+    #[no_coverage]\n+    fn assert_receiver_is_total_eq(&self) -> () {\n+        {\n+            let _: ::core::cmp::AssertParamIsEq<u32>;\n+            let _: ::core::cmp::AssertParamIsEq<u32>;\n+            let _: ::core::cmp::AssertParamIsEq<u32>;\n+            let _: ::core::cmp::AssertParamIsEq<u32>;\n+            let _: ::core::cmp::AssertParamIsEq<u32>;\n+            let _: ::core::cmp::AssertParamIsEq<u32>;\n+            let _: ::core::cmp::AssertParamIsEq<u32>;\n+            let _: ::core::cmp::AssertParamIsEq<u32>;\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::PartialOrd for Big {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Big)\n+        -> ::core::option::Option<::core::cmp::Ordering> {\n+        match *other {\n+            Self {\n+                b1: ref __self_1_0,\n+                b2: ref __self_1_1,\n+                b3: ref __self_1_2,\n+                b4: ref __self_1_3,\n+                b5: ref __self_1_4,\n+                b6: ref __self_1_5,\n+                b7: ref __self_1_6,\n+                b8: ref __self_1_7 } =>\n+                match *self {\n+                    Self {\n+                        b1: ref __self_0_0,\n+                        b2: ref __self_0_1,\n+                        b3: ref __self_0_2,\n+                        b4: ref __self_0_3,\n+                        b5: ref __self_0_4,\n+                        b6: ref __self_0_5,\n+                        b7: ref __self_0_6,\n+                        b8: ref __self_0_7 } =>\n+                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),\n+                                &(*__self_1_0)) {\n+                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                =>\n+                                match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),\n+                                        &(*__self_1_1)) {\n+                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                        =>\n+                                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_2),\n+                                                &(*__self_1_2)) {\n+                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                                =>\n+                                                match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_3),\n+                                                        &(*__self_1_3)) {\n+                                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                                        =>\n+                                                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_4),\n+                                                                &(*__self_1_4)) {\n+                                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                                                =>\n+                                                                match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_5),\n+                                                                        &(*__self_1_5)) {\n+                                                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                                                        =>\n+                                                                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_6),\n+                                                                                &(*__self_1_6)) {\n+                                                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                                                                =>\n+                                                                                match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_7),\n+                                                                                        &(*__self_1_7)) {\n+                                                                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                                                                        =>\n+                                                                                        ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+                                                                                    cmp => cmp,\n+                                                                                },\n+                                                                            cmp => cmp,\n+                                                                        },\n+                                                                    cmp => cmp,\n+                                                                },\n+                                                            cmp => cmp,\n+                                                        },\n+                                                    cmp => cmp,\n+                                                },\n+                                            cmp => cmp,\n+                                        },\n+                                    cmp => cmp,\n+                                },\n+                            cmp => cmp,\n+                        },\n+                },\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::Ord for Big {\n+    #[inline]\n+    fn cmp(&self, other: &Big) -> ::core::cmp::Ordering {\n+        match *other {\n+            Self {\n+                b1: ref __self_1_0,\n+                b2: ref __self_1_1,\n+                b3: ref __self_1_2,\n+                b4: ref __self_1_3,\n+                b5: ref __self_1_4,\n+                b6: ref __self_1_5,\n+                b7: ref __self_1_6,\n+                b8: ref __self_1_7 } =>\n+                match *self {\n+                    Self {\n+                        b1: ref __self_0_0,\n+                        b2: ref __self_0_1,\n+                        b3: ref __self_0_2,\n+                        b4: ref __self_0_3,\n+                        b5: ref __self_0_4,\n+                        b6: ref __self_0_5,\n+                        b7: ref __self_0_6,\n+                        b8: ref __self_0_7 } =>\n+                        match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0))\n+                            {\n+                            ::core::cmp::Ordering::Equal =>\n+                                match ::core::cmp::Ord::cmp(&(*__self_0_1), &(*__self_1_1))\n+                                    {\n+                                    ::core::cmp::Ordering::Equal =>\n+                                        match ::core::cmp::Ord::cmp(&(*__self_0_2), &(*__self_1_2))\n+                                            {\n+                                            ::core::cmp::Ordering::Equal =>\n+                                                match ::core::cmp::Ord::cmp(&(*__self_0_3), &(*__self_1_3))\n+                                                    {\n+                                                    ::core::cmp::Ordering::Equal =>\n+                                                        match ::core::cmp::Ord::cmp(&(*__self_0_4), &(*__self_1_4))\n+                                                            {\n+                                                            ::core::cmp::Ordering::Equal =>\n+                                                                match ::core::cmp::Ord::cmp(&(*__self_0_5), &(*__self_1_5))\n+                                                                    {\n+                                                                    ::core::cmp::Ordering::Equal =>\n+                                                                        match ::core::cmp::Ord::cmp(&(*__self_0_6), &(*__self_1_6))\n+                                                                            {\n+                                                                            ::core::cmp::Ordering::Equal =>\n+                                                                                match ::core::cmp::Ord::cmp(&(*__self_0_7), &(*__self_1_7))\n+                                                                                    {\n+                                                                                    ::core::cmp::Ordering::Equal =>\n+                                                                                        ::core::cmp::Ordering::Equal,\n+                                                                                    cmp => cmp,\n+                                                                                },\n+                                                                            cmp => cmp,\n+                                                                        },\n+                                                                    cmp => cmp,\n+                                                                },\n+                                                            cmp => cmp,\n+                                                        },\n+                                                    cmp => cmp,\n+                                                },\n+                                            cmp => cmp,\n+                                        },\n+                                    cmp => cmp,\n+                                },\n+                            cmp => cmp,\n+                        },\n+                },\n+        }\n+    }\n+}\n+\n+// A C-like, fieldless enum.\n+enum Fieldless {\n+\n+    #[default]\n+    A,\n+    B,\n+    C,\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::clone::Clone for Fieldless {\n+    #[inline]\n+    fn clone(&self) -> Fieldless { { *self } }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::marker::Copy for Fieldless { }\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::fmt::Debug for Fieldless {\n+    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n+        match (&*self,) {\n+            (&Fieldless::A,) => ::core::fmt::Formatter::write_str(f, \"A\"),\n+            (&Fieldless::B,) => ::core::fmt::Formatter::write_str(f, \"B\"),\n+            (&Fieldless::C,) => ::core::fmt::Formatter::write_str(f, \"C\"),\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::default::Default for Fieldless {\n+    #[inline]\n+    fn default() -> Fieldless { Self::A }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::hash::Hash for Fieldless {\n+    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n+        match (&*self,) {\n+            _ => {\n+                ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n+                    state)\n+            }\n+        }\n+    }\n+}\n+impl ::core::marker::StructuralPartialEq for Fieldless {}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::PartialEq for Fieldless {\n+    #[inline]\n+    fn eq(&self, other: &Fieldless) -> bool {\n+        {\n+            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+            if __self_vi == __arg_1_vi {\n+                    match (&*self, &*other) { _ => true, }\n+                } else { false }\n+        }\n+    }\n+}\n+impl ::core::marker::StructuralEq for Fieldless {}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::Eq for Fieldless {\n+    #[inline]\n+    #[doc(hidden)]\n+    #[no_coverage]\n+    fn assert_receiver_is_total_eq(&self) -> () { {} }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::PartialOrd for Fieldless {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Fieldless)\n+        -> ::core::option::Option<::core::cmp::Ordering> {\n+        {\n+            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+            if __self_vi == __arg_1_vi {\n+                    match (&*self, &*other) {\n+                        _ =>\n+                            ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+                    }\n+                } else {\n+                   ::core::cmp::PartialOrd::partial_cmp(&__self_vi,\n+                       &__arg_1_vi)\n+               }\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::Ord for Fieldless {\n+    #[inline]\n+    fn cmp(&self, other: &Fieldless) -> ::core::cmp::Ordering {\n+        {\n+            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+            if __self_vi == __arg_1_vi {\n+                    match (&*self, &*other) {\n+                        _ => ::core::cmp::Ordering::Equal,\n+                    }\n+                } else { ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi) }\n+        }\n+    }\n+}\n+\n+// An enum with multiple fieldless and fielded variants.\n+enum Mixed {\n+\n+    #[default]\n+    P,\n+    Q,\n+    R(u32),\n+    S {\n+        d1: u32,\n+        d2: u32,\n+    },\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::clone::Clone for Mixed {\n+    #[inline]\n+    fn clone(&self) -> Mixed {\n+        {\n+            let _: ::core::clone::AssertParamIsClone<u32>;\n+            let _: ::core::clone::AssertParamIsClone<u32>;\n+            let _: ::core::clone::AssertParamIsClone<u32>;\n+            *self\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::marker::Copy for Mixed { }\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::fmt::Debug for Mixed {\n+    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n+        match (&*self,) {\n+            (&Mixed::P,) => ::core::fmt::Formatter::write_str(f, \"P\"),\n+            (&Mixed::Q,) => ::core::fmt::Formatter::write_str(f, \"Q\"),\n+            (&Mixed::R(ref __self_0),) =>\n+                ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"R\",\n+                    &&(*__self_0)),\n+            (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },) =>\n+                ::core::fmt::Formatter::debug_struct_field2_finish(f, \"S\",\n+                    \"d1\", &&(*__self_0), \"d2\", &&(*__self_1)),\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::default::Default for Mixed {\n+    #[inline]\n+    fn default() -> Mixed { Self::P }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::hash::Hash for Mixed {\n+    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n+        match (&*self,) {\n+            (&Mixed::R(ref __self_0),) => {\n+                ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n+                    state);\n+                ::core::hash::Hash::hash(&(*__self_0), state)\n+            }\n+            (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },) => {\n+                ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n+                    state);\n+                ::core::hash::Hash::hash(&(*__self_0), state);\n+                ::core::hash::Hash::hash(&(*__self_1), state)\n+            }\n+            _ => {\n+                ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n+                    state)\n+            }\n+        }\n+    }\n+}\n+impl ::core::marker::StructuralPartialEq for Mixed {}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::PartialEq for Mixed {\n+    #[inline]\n+    fn eq(&self, other: &Mixed) -> bool {\n+        {\n+            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+            if __self_vi == __arg_1_vi {\n+                    match (&*self, &*other) {\n+                        (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n+                            (*__self_0) == (*__arg_1_0),\n+                        (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n+                            &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n+                            (*__self_0) == (*__arg_1_0) && (*__self_1) == (*__arg_1_1),\n+                        _ => true,\n+                    }\n+                } else { false }\n+        }\n+    }\n+    #[inline]\n+    fn ne(&self, other: &Mixed) -> bool {\n+        {\n+            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+            if __self_vi == __arg_1_vi {\n+                    match (&*self, &*other) {\n+                        (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n+                            (*__self_0) != (*__arg_1_0),\n+                        (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n+                            &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n+                            (*__self_0) != (*__arg_1_0) || (*__self_1) != (*__arg_1_1),\n+                        _ => false,\n+                    }\n+                } else { true }\n+        }\n+    }\n+}\n+impl ::core::marker::StructuralEq for Mixed {}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::Eq for Mixed {\n+    #[inline]\n+    #[doc(hidden)]\n+    #[no_coverage]\n+    fn assert_receiver_is_total_eq(&self) -> () {\n+        {\n+            let _: ::core::cmp::AssertParamIsEq<u32>;\n+            let _: ::core::cmp::AssertParamIsEq<u32>;\n+            let _: ::core::cmp::AssertParamIsEq<u32>;\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::PartialOrd for Mixed {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Mixed)\n+        -> ::core::option::Option<::core::cmp::Ordering> {\n+        {\n+            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+            if __self_vi == __arg_1_vi {\n+                    match (&*self, &*other) {\n+                        (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n+                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0),\n+                                    &(*__arg_1_0)) {\n+                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                    =>\n+                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+                                cmp => cmp,\n+                            },\n+                        (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n+                            &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n+                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0),\n+                                    &(*__arg_1_0)) {\n+                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                    =>\n+                                    match ::core::cmp::PartialOrd::partial_cmp(&(*__self_1),\n+                                            &(*__arg_1_1)) {\n+                                        ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                            =>\n+                                            ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+                                        cmp => cmp,\n+                                    },\n+                                cmp => cmp,\n+                            },\n+                        _ =>\n+                            ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+                    }\n+                } else {\n+                   ::core::cmp::PartialOrd::partial_cmp(&__self_vi,\n+                       &__arg_1_vi)\n+               }\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::Ord for Mixed {\n+    #[inline]\n+    fn cmp(&self, other: &Mixed) -> ::core::cmp::Ordering {\n+        {\n+            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+            if __self_vi == __arg_1_vi {\n+                    match (&*self, &*other) {\n+                        (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n+                            match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {\n+                                ::core::cmp::Ordering::Equal =>\n+                                    ::core::cmp::Ordering::Equal,\n+                                cmp => cmp,\n+                            },\n+                        (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n+                            &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n+                            match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {\n+                                ::core::cmp::Ordering::Equal =>\n+                                    match ::core::cmp::Ord::cmp(&(*__self_1), &(*__arg_1_1)) {\n+                                        ::core::cmp::Ordering::Equal =>\n+                                            ::core::cmp::Ordering::Equal,\n+                                        cmp => cmp,\n+                                    },\n+                                cmp => cmp,\n+                            },\n+                        _ => ::core::cmp::Ordering::Equal,\n+                    }\n+                } else { ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi) }\n+        }\n+    }\n+}\n+\n+// An enum with no fieldless variants. Note that `Default` cannot be derived\n+// for this enum.\n+enum Fielded { X(u32), Y(bool), Z(Option<i32>), }\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::clone::Clone for Fielded {\n+    #[inline]\n+    fn clone(&self) -> Fielded {\n+        match (&*self,) {\n+            (&Fielded::X(ref __self_0),) =>\n+                Fielded::X(::core::clone::Clone::clone(&(*__self_0))),\n+            (&Fielded::Y(ref __self_0),) =>\n+                Fielded::Y(::core::clone::Clone::clone(&(*__self_0))),\n+            (&Fielded::Z(ref __self_0),) =>\n+                Fielded::Z(::core::clone::Clone::clone(&(*__self_0))),\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::fmt::Debug for Fielded {\n+    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n+        match (&*self,) {\n+            (&Fielded::X(ref __self_0),) =>\n+                ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"X\",\n+                    &&(*__self_0)),\n+            (&Fielded::Y(ref __self_0),) =>\n+                ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"Y\",\n+                    &&(*__self_0)),\n+            (&Fielded::Z(ref __self_0),) =>\n+                ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"Z\",\n+                    &&(*__self_0)),\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::hash::Hash for Fielded {\n+    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n+        match (&*self,) {\n+            (&Fielded::X(ref __self_0),) => {\n+                ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n+                    state);\n+                ::core::hash::Hash::hash(&(*__self_0), state)\n+            }\n+            (&Fielded::Y(ref __self_0),) => {\n+                ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n+                    state);\n+                ::core::hash::Hash::hash(&(*__self_0), state)\n+            }\n+            (&Fielded::Z(ref __self_0),) => {\n+                ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n+                    state);\n+                ::core::hash::Hash::hash(&(*__self_0), state)\n+            }\n+        }\n+    }\n+}\n+impl ::core::marker::StructuralPartialEq for Fielded {}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::PartialEq for Fielded {\n+    #[inline]\n+    fn eq(&self, other: &Fielded) -> bool {\n+        {\n+            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+            if __self_vi == __arg_1_vi {\n+                    match (&*self, &*other) {\n+                        (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n+                            (*__self_0) == (*__arg_1_0),\n+                        (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n+                            (*__self_0) == (*__arg_1_0),\n+                        (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n+                            (*__self_0) == (*__arg_1_0),\n+                        _ => unsafe { ::core::intrinsics::unreachable() }\n+                    }\n+                } else { false }\n+        }\n+    }\n+    #[inline]\n+    fn ne(&self, other: &Fielded) -> bool {\n+        {\n+            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+            if __self_vi == __arg_1_vi {\n+                    match (&*self, &*other) {\n+                        (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n+                            (*__self_0) != (*__arg_1_0),\n+                        (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n+                            (*__self_0) != (*__arg_1_0),\n+                        (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n+                            (*__self_0) != (*__arg_1_0),\n+                        _ => unsafe { ::core::intrinsics::unreachable() }\n+                    }\n+                } else { true }\n+        }\n+    }\n+}\n+impl ::core::marker::StructuralEq for Fielded {}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::Eq for Fielded {\n+    #[inline]\n+    #[doc(hidden)]\n+    #[no_coverage]\n+    fn assert_receiver_is_total_eq(&self) -> () {\n+        {\n+            let _: ::core::cmp::AssertParamIsEq<u32>;\n+            let _: ::core::cmp::AssertParamIsEq<bool>;\n+            let _: ::core::cmp::AssertParamIsEq<Option<i32>>;\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::PartialOrd for Fielded {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Fielded)\n+        -> ::core::option::Option<::core::cmp::Ordering> {\n+        {\n+            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+            if __self_vi == __arg_1_vi {\n+                    match (&*self, &*other) {\n+                        (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n+                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0),\n+                                    &(*__arg_1_0)) {\n+                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                    =>\n+                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+                                cmp => cmp,\n+                            },\n+                        (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n+                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0),\n+                                    &(*__arg_1_0)) {\n+                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                    =>\n+                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+                                cmp => cmp,\n+                            },\n+                        (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n+                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0),\n+                                    &(*__arg_1_0)) {\n+                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                                    =>\n+                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+                                cmp => cmp,\n+                            },\n+                        _ => unsafe { ::core::intrinsics::unreachable() }\n+                    }\n+                } else {\n+                   ::core::cmp::PartialOrd::partial_cmp(&__self_vi,\n+                       &__arg_1_vi)\n+               }\n+        }\n+    }\n+}\n+#[automatically_derived]\n+#[allow(unused_qualifications)]\n+impl ::core::cmp::Ord for Fielded {\n+    #[inline]\n+    fn cmp(&self, other: &Fielded) -> ::core::cmp::Ordering {\n+        {\n+            let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n+            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+            if __self_vi == __arg_1_vi {\n+                    match (&*self, &*other) {\n+                        (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n+                            match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {\n+                                ::core::cmp::Ordering::Equal =>\n+                                    ::core::cmp::Ordering::Equal,\n+                                cmp => cmp,\n+                            },\n+                        (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n+                            match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {\n+                                ::core::cmp::Ordering::Equal =>\n+                                    ::core::cmp::Ordering::Equal,\n+                                cmp => cmp,\n+                            },\n+                        (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n+                            match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {\n+                                ::core::cmp::Ordering::Equal =>\n+                                    ::core::cmp::Ordering::Equal,\n+                                cmp => cmp,\n+                            },\n+                        _ => unsafe { ::core::intrinsics::unreachable() }\n+                    }\n+                } else { ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi) }\n+        }\n+    }\n+}"}]}