{"sha": "e6ab222b814f20375041a5dd39e7605eed079c70", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2YWIyMjJiODE0ZjIwMzc1MDQxYTVkZDM5ZTc2MDVlZWQwNzljNzA=", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-07-06T16:51:15Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-07-13T13:57:16Z"}, "message": "Refactor format macro parsing", "tree": {"sha": "82ae7ab2e8dac56761496438d8ace4f44c317390", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82ae7ab2e8dac56761496438d8ace4f44c317390"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6ab222b814f20375041a5dd39e7605eed079c70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6ab222b814f20375041a5dd39e7605eed079c70", "html_url": "https://github.com/rust-lang/rust/commit/e6ab222b814f20375041a5dd39e7605eed079c70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6ab222b814f20375041a5dd39e7605eed079c70/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20dbb277cf1b12546e7e604066b46d7b0f575bb0", "url": "https://api.github.com/repos/rust-lang/rust/commits/20dbb277cf1b12546e7e604066b46d7b0f575bb0", "html_url": "https://github.com/rust-lang/rust/commit/20dbb277cf1b12546e7e604066b46d7b0f575bb0"}], "stats": {"total": 420, "additions": 203, "deletions": 217}, "files": [{"sha": "eaea70a429407acd4a78b9394bd83020fa5a6db7", "filename": "clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 11, "deletions": 33, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e6ab222b814f20375041a5dd39e7605eed079c70/clippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ab222b814f20375041a5dd39e7605eed079c70/clippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexplicit_write.rs?ref=e6ab222b814f20375041a5dd39e7605eed079c70", "patch": "@@ -1,9 +1,9 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg};\n+use clippy_utils::higher::FormatArgsExpn;\n use clippy_utils::{is_expn_of, match_function_call, paths};\n use if_chain::if_chain;\n-use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n-use rustc_hir::{BorrowKind, Expr, ExprKind};\n+use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n@@ -34,29 +34,26 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             // match call to unwrap\n-            if let ExprKind::MethodCall(unwrap_fun, _, unwrap_args, _) = expr.kind;\n+            if let ExprKind::MethodCall(unwrap_fun, _, [write_call], _) = expr.kind;\n             if unwrap_fun.ident.name == sym::unwrap;\n             // match call to write_fmt\n-            if !unwrap_args.is_empty();\n-            if let ExprKind::MethodCall(write_fun, _, write_args, _) =\n-                unwrap_args[0].kind;\n+            if let ExprKind::MethodCall(write_fun, _, [write_recv, write_arg], _) = write_call.kind;\n             if write_fun.ident.name == sym!(write_fmt);\n             // match calls to std::io::stdout() / std::io::stderr ()\n-            if !write_args.is_empty();\n-            if let Some(dest_name) = if match_function_call(cx, &write_args[0], &paths::STDOUT).is_some() {\n+            if let Some(dest_name) = if match_function_call(cx, write_recv, &paths::STDOUT).is_some() {\n                 Some(\"stdout\")\n-            } else if match_function_call(cx, &write_args[0], &paths::STDERR).is_some() {\n+            } else if match_function_call(cx, write_recv, &paths::STDERR).is_some() {\n                 Some(\"stderr\")\n             } else {\n                 None\n             };\n+            if let Some(format_args) = FormatArgsExpn::parse(write_arg);\n             then {\n-                let write_span = unwrap_args[0].span;\n                 let calling_macro =\n                     // ordering is important here, since `writeln!` uses `write!` internally\n-                    if is_expn_of(write_span, \"writeln\").is_some() {\n+                    if is_expn_of(write_call.span, \"writeln\").is_some() {\n                         Some(\"writeln\")\n-                    } else if is_expn_of(write_span, \"write\").is_some() {\n+                    } else if is_expn_of(write_call.span, \"write\").is_some() {\n                         Some(\"write\")\n                     } else {\n                         None\n@@ -70,7 +67,8 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n                 // We need to remove the last trailing newline from the string because the\n                 // underlying `fmt::write` function doesn't know whether `println!` or `print!` was\n                 // used.\n-                if let Some(mut write_output) = write_output_string(write_args) {\n+                if let [write_output] = *format_args.format_string_symbols {\n+                    let mut write_output = write_output.to_string();\n                     if write_output.ends_with('\\n') {\n                         write_output.pop();\n                     }\n@@ -129,23 +127,3 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n         }\n     }\n }\n-\n-// Extract the output string from the given `write_args`.\n-fn write_output_string(write_args: &[Expr<'_>]) -> Option<String> {\n-    if_chain! {\n-        // Obtain the string that should be printed\n-        if write_args.len() > 1;\n-        if let ExprKind::Call(_, output_args) = write_args[1].kind;\n-        if !output_args.is_empty();\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, output_string_expr) = output_args[0].kind;\n-        if let ExprKind::Array(string_exprs) = output_string_expr.kind;\n-        // we only want to provide an automatic suggestion for simple (non-format) strings\n-        if string_exprs.len() == 1;\n-        if let ExprKind::Lit(ref lit) = string_exprs[0].kind;\n-        if let LitKind::Str(ref write_output, _) = lit.node;\n-        then {\n-            return Some(write_output.to_string())\n-        }\n-    }\n-    None\n-}"}, {"sha": "ca3490d8edad98c95df69f46abab20acf2335791", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 68, "deletions": 124, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/e6ab222b814f20375041a5dd39e7605eed079c70/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ab222b814f20375041a5dd39e7605eed079c70/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=e6ab222b814f20375041a5dd39e7605eed079c70", "patch": "@@ -1,18 +1,16 @@\n-use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::paths;\n-use clippy_utils::source::{snippet, snippet_opt};\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher::FormatExpn;\n+use clippy_utils::last_path_segment;\n+use clippy_utils::source::{snippet_opt, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{is_expn_of, last_path_segment, match_def_path, match_function_call};\n use if_chain::if_chain;\n-use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n-use rustc_hir::{Arm, BorrowKind, Expr, ExprKind, MatchSource, PatKind};\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_hir::{BorrowKind, Expr, ExprKind, QPath};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Span;\n-use rustc_span::sym;\n use rustc_span::symbol::kw;\n+use rustc_span::{sym, Span};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for the use of `format!(\"string literal with no\n@@ -45,131 +43,78 @@ declare_lint_pass!(UselessFormat => [USELESS_FORMAT]);\n \n impl<'tcx> LateLintPass<'tcx> for UselessFormat {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        let span = match is_expn_of(expr.span, \"format\") {\n-            Some(s) if !s.from_expansion() => s,\n+        let FormatExpn { call_site, format_args } = match FormatExpn::parse(expr) {\n+            Some(e) if !e.call_site.from_expansion() => e,\n             _ => return,\n         };\n \n-        // Operate on the only argument of `alloc::fmt::format`.\n-        if let Some(sugg) = on_new_v1(cx, expr) {\n-            span_useless_format(cx, span, \"consider using `.to_string()`\", sugg);\n-        } else if let Some(sugg) = on_new_v1_fmt(cx, expr) {\n-            span_useless_format(cx, span, \"consider using `.to_string()`\", sugg);\n-        }\n-    }\n-}\n-\n-fn span_useless_format<T: LintContext>(cx: &T, span: Span, help: &str, mut sugg: String) {\n-    let to_replace = span.source_callsite();\n-\n-    // The callsite span contains the statement semicolon for some reason.\n-    let snippet = snippet(cx, to_replace, \"..\");\n-    if snippet.ends_with(';') {\n-        sugg.push(';');\n-    }\n-\n-    span_lint_and_then(cx, USELESS_FORMAT, span, \"useless use of `format!`\", |diag| {\n-        diag.span_suggestion(\n-            to_replace,\n-            help,\n-            sugg,\n-            Applicability::MachineApplicable, // snippet\n-        );\n-    });\n-}\n-\n-fn on_argumentv1_new<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, arms: &'tcx [Arm<'_>]) -> Option<String> {\n-    if_chain! {\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, format_args) = expr.kind;\n-        if let ExprKind::Array(elems) = arms[0].body.kind;\n-        if elems.len() == 1;\n-        if let Some(args) = match_function_call(cx, &elems[0], &paths::FMT_ARGUMENTV1_NEW);\n-        // matches `core::fmt::Display::fmt`\n-        if args.len() == 2;\n-        if let ExprKind::Path(ref qpath) = args[1].kind;\n-        if let Some(did) = cx.qpath_res(qpath, args[1].hir_id).opt_def_id();\n-        if match_def_path(cx, did, &paths::DISPLAY_FMT_METHOD);\n-        // check `(arg0,)` in match block\n-        if let PatKind::Tuple(pats, None) = arms[0].pat.kind;\n-        if pats.len() == 1;\n-        then {\n-            let ty = cx.typeck_results().pat_ty(pats[0]).peel_refs();\n-            if *ty.kind() != rustc_middle::ty::Str && !is_type_diagnostic_item(cx, ty, sym::string_type) {\n-                return None;\n-            }\n-            if let ExprKind::Lit(ref lit) = format_args.kind {\n-                if let LitKind::Str(ref s, _) = lit.node {\n-                    return Some(format!(\"{:?}.to_string()\", s.as_str()));\n+        let mut applicability = Applicability::MachineApplicable;\n+        if format_args.value_args.is_empty() {\n+            if_chain! {\n+                if let [e] = &*format_args.format_string_parts;\n+                if let ExprKind::Lit(lit) = &e.kind;\n+                if let Some(s_src) = snippet_opt(cx, lit.span);\n+                then {\n+                    // Simulate macro expansion, converting {{ and }} to { and }.\n+                    let s_expand = s_src.replace(\"{{\", \"{\").replace(\"}}\", \"}\");\n+                    let sugg = format!(\"{}.to_string()\", s_expand);\n+                    span_useless_format(cx, call_site, sugg, applicability);\n                 }\n-            } else {\n-                let sugg = Sugg::hir(cx, format_args, \"<arg>\");\n-                if let ExprKind::MethodCall(path, _, _, _) = format_args.kind {\n-                    if path.ident.name == sym!(to_string) {\n-                        return Some(format!(\"{}\", sugg));\n-                    }\n-                } else if let ExprKind::Binary(..) = format_args.kind {\n-                    return Some(format!(\"{}\", sugg));\n+            }\n+        } else if let [value] = *format_args.value_args {\n+            if_chain! {\n+                if format_args.format_string_symbols == [kw::Empty];\n+                if match cx.typeck_results().expr_ty(value).peel_refs().kind() {\n+                    ty::Adt(adt, _) => cx.tcx.is_diagnostic_item(sym::string_type, adt.did),\n+                    ty::Str => true,\n+                    _ => false,\n+                };\n+                if format_args.args.iter().all(|e| is_display_arg(e));\n+                if format_args.fmt_expr.map_or(true, |e| check_unformatted(e));\n+                then {\n+                    let is_new_string = match value.kind {\n+                        ExprKind::Binary(..) => true,\n+                        ExprKind::MethodCall(path, ..) => path.ident.name.as_str() == \"to_string\",\n+                        _ => false,\n+                    };\n+                    let sugg = if is_new_string {\n+                        snippet_with_applicability(cx, value.span, \"..\", &mut applicability).into_owned()\n+                    } else {\n+                        let sugg = Sugg::hir_with_applicability(cx, value, \"<arg>\", &mut applicability);\n+                        format!(\"{}.to_string()\", sugg.maybe_par())\n+                    };\n+                    span_useless_format(cx, call_site, sugg, applicability);\n                 }\n-                return Some(format!(\"{}.to_string()\", sugg.maybe_par()));\n             }\n-        }\n+        };\n     }\n-    None\n }\n \n-fn on_new_v1<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<String> {\n-    if_chain! {\n-        if let Some(args) = match_function_call(cx, expr, &paths::FMT_ARGUMENTS_NEW_V1);\n-        if args.len() == 2;\n-        // Argument 1 in `new_v1()`\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, arr) = args[0].kind;\n-        if let ExprKind::Array(pieces) = arr.kind;\n-        if pieces.len() == 1;\n-        if let ExprKind::Lit(ref lit) = pieces[0].kind;\n-        if let LitKind::Str(ref s, _) = lit.node;\n-        // Argument 2 in `new_v1()`\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, arg1) = args[1].kind;\n-        if let ExprKind::Match(matchee, arms, MatchSource::Normal) = arg1.kind;\n-        if arms.len() == 1;\n-        if let ExprKind::Tup(tup) = matchee.kind;\n-        then {\n-            // `format!(\"foo\")` expansion contains `match () { () => [], }`\n-            if tup.is_empty() {\n-                if let Some(s_src) = snippet_opt(cx, lit.span) {\n-                    // Simulate macro expansion, converting {{ and }} to { and }.\n-                    let s_expand = s_src.replace(\"{{\", \"{\").replace(\"}}\", \"}\");\n-                    return Some(format!(\"{}.to_string()\", s_expand));\n-                }\n-            } else if s.as_str().is_empty() {\n-                return on_argumentv1_new(cx, &tup[0], arms);\n-            }\n-        }\n+fn span_useless_format(cx: &LateContext<'_>, span: Span, mut sugg: String, mut applicability: Applicability) {\n+    // The callsite span contains the statement semicolon for some reason.\n+    if snippet_with_applicability(cx, span, \"..\", &mut applicability).ends_with(';') {\n+        sugg.push(';');\n     }\n-    None\n+\n+    span_lint_and_sugg(\n+        cx,\n+        USELESS_FORMAT,\n+        span,\n+        \"useless use of `format!`\",\n+        \"consider using `.to_string()`\",\n+        sugg,\n+        applicability,\n+    );\n }\n \n-fn on_new_v1_fmt<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<String> {\n+fn is_display_arg(expr: &Expr<'_>) -> bool {\n     if_chain! {\n-        if let Some(args) = match_function_call(cx, expr, &paths::FMT_ARGUMENTS_NEW_V1_FORMATTED);\n-        if args.len() == 3;\n-        if check_unformatted(&args[2]);\n-        // Argument 1 in `new_v1_formatted()`\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, arr) = args[0].kind;\n-        if let ExprKind::Array(pieces) = arr.kind;\n-        if pieces.len() == 1;\n-        if let ExprKind::Lit(ref lit) = pieces[0].kind;\n-        if let LitKind::Str(symbol, _) = lit.node;\n-        if symbol == kw::Empty;\n-        // Argument 2 in `new_v1_formatted()`\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, arg1) = args[1].kind;\n-        if let ExprKind::Match(matchee, arms, MatchSource::Normal) = arg1.kind;\n-        if arms.len() == 1;\n-        if let ExprKind::Tup(tup) = matchee.kind;\n-        then {\n-            return on_argumentv1_new(cx, &tup[0], arms);\n-        }\n+        if let ExprKind::Call(_, [_, fmt]) = expr.kind;\n+        if let ExprKind::Path(QPath::Resolved(_, path)) = fmt.kind;\n+        if let [.., t, _] = path.segments;\n+        if t.ident.name.as_str() == \"Display\";\n+        then { true } else { false }\n     }\n-    None\n }\n \n /// Checks if the expression matches\n@@ -186,10 +131,9 @@ fn on_new_v1_fmt<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<S\n fn check_unformatted(expr: &Expr<'_>) -> bool {\n     if_chain! {\n         if let ExprKind::AddrOf(BorrowKind::Ref, _, expr) = expr.kind;\n-        if let ExprKind::Array(exprs) = expr.kind;\n-        if exprs.len() == 1;\n+        if let ExprKind::Array([expr]) = expr.kind;\n         // struct `core::fmt::rt::v1::Argument`\n-        if let ExprKind::Struct(_, fields, _) = exprs[0].kind;\n+        if let ExprKind::Struct(_, fields, _) = expr.kind;\n         if let Some(format_field) = fields.iter().find(|f| f.ident.name == sym::format);\n         // struct `core::fmt::rt::v1::FormatSpec`\n         if let ExprKind::Struct(_, fields, _) = format_field.expr.kind;"}, {"sha": "f8ee31a00df821ebc0e6f7834d666b3adb3a40d5", "filename": "clippy_lints/src/methods/expect_fun_call.rs", "status": "modified", "additions": 18, "deletions": 54, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/e6ab222b814f20375041a5dd39e7605eed079c70/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ab222b814f20375041a5dd39e7605eed079c70/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs?ref=e6ab222b814f20375041a5dd39e7605eed079c70", "patch": "@@ -1,8 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::is_expn_of;\n-use clippy_utils::source::{snippet, snippet_with_applicability};\n+use clippy_utils::higher::FormatExpn;\n+use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n@@ -94,27 +93,6 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, method_span: Spa\n         }\n     }\n \n-    fn generate_format_arg_snippet(\n-        cx: &LateContext<'_>,\n-        a: &hir::Expr<'_>,\n-        applicability: &mut Applicability,\n-    ) -> Vec<String> {\n-        if_chain! {\n-            if let hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, format_arg) = a.kind;\n-            if let hir::ExprKind::Match(format_arg_expr, _, _) = format_arg.kind;\n-            if let hir::ExprKind::Tup(format_arg_expr_tup) = format_arg_expr.kind;\n-\n-            then {\n-                format_arg_expr_tup\n-                    .iter()\n-                    .map(|a| snippet_with_applicability(cx, a.span, \"..\", applicability).into_owned())\n-                    .collect()\n-            } else {\n-                unreachable!()\n-            }\n-        }\n-    }\n-\n     fn is_call(node: &hir::ExprKind<'_>) -> bool {\n         match node {\n             hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, expr) => {\n@@ -150,36 +128,22 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, method_span: Spa\n     let mut applicability = Applicability::MachineApplicable;\n \n     //Special handling for `format!` as arg_root\n-    if_chain! {\n-        if let hir::ExprKind::Block(block, None) = &arg_root.kind;\n-        if block.stmts.len() == 1;\n-        if let hir::StmtKind::Local(local) = &block.stmts[0].kind;\n-        if let Some(arg_root) = &local.init;\n-        if let hir::ExprKind::Call(inner_fun, inner_args) = arg_root.kind;\n-        if is_expn_of(inner_fun.span, \"format\").is_some() && inner_args.len() == 1;\n-        if let hir::ExprKind::Call(_, format_args) = &inner_args[0].kind;\n-        then {\n-            let fmt_spec = &format_args[0];\n-            let fmt_args = &format_args[1];\n-\n-            let mut args = vec![snippet(cx, fmt_spec.span, \"..\").into_owned()];\n-\n-            args.extend(generate_format_arg_snippet(cx, fmt_args, &mut applicability));\n-\n-            let sugg = args.join(\", \");\n-\n-            span_lint_and_sugg(\n-                cx,\n-                EXPECT_FUN_CALL,\n-                span_replace_word,\n-                &format!(\"use of `{}` followed by a function call\", name),\n-                \"try this\",\n-                format!(\"unwrap_or_else({} panic!({}))\", closure_args, sugg),\n-                applicability,\n-            );\n-\n-            return;\n-        }\n+    if let Some(format_expn) = FormatExpn::parse(arg_root) {\n+        let span = match *format_expn.format_args.value_args {\n+            [] => format_expn.format_args.format_string_span,\n+            [.., last] => format_expn.format_args.format_string_span.to(last.span),\n+        };\n+        let sugg = snippet_with_applicability(cx, span, \"..\", &mut applicability);\n+        span_lint_and_sugg(\n+            cx,\n+            EXPECT_FUN_CALL,\n+            span_replace_word,\n+            &format!(\"use of `{}` followed by a function call\", name),\n+            \"try this\",\n+            format!(\"unwrap_or_else({} panic!({}))\", closure_args, sugg),\n+            applicability,\n+        );\n+        return;\n     }\n \n     let mut arg_root_snippet: Cow<'_, _> = snippet_with_applicability(cx, arg_root.span, \"..\", &mut applicability);"}, {"sha": "5ffd88f41404814d336e51579117981f5029fe72", "filename": "clippy_utils/src/higher.rs", "status": "modified", "additions": 106, "deletions": 2, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/e6ab222b814f20375041a5dd39e7605eed079c70/clippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ab222b814f20375041a5dd39e7605eed079c70/clippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhigher.rs?ref=e6ab222b814f20375041a5dd39e7605eed079c70", "patch": "@@ -5,11 +5,11 @@\n \n use crate::{is_expn_of, match_def_path, paths};\n use if_chain::if_chain;\n-use rustc_ast::ast;\n+use rustc_ast::ast::{self, LitKind};\n use rustc_hir as hir;\n use rustc_hir::{BorrowKind, Expr, ExprKind, StmtKind, UnOp};\n use rustc_lint::LateContext;\n-use rustc_span::source_map::Span;\n+use rustc_span::{sym, ExpnKind, Span, Symbol};\n \n /// Converts a hir binary operator to the corresponding `ast` type.\n #[must_use]\n@@ -266,3 +266,107 @@ pub fn extract_assert_macro_args<'tcx>(e: &'tcx Expr<'tcx>) -> Option<Vec<&'tcx\n     }\n     None\n }\n+\n+/// A parsed `format!` expansion\n+pub struct FormatExpn<'tcx> {\n+    /// Span of `format!(..)`\n+    pub call_site: Span,\n+    /// Inner `format_args!` expansion\n+    pub format_args: FormatArgsExpn<'tcx>,\n+}\n+\n+impl FormatExpn<'tcx> {\n+    /// Parses an expanded `format!` invocation\n+    pub fn parse(expr: &'tcx Expr<'tcx>) -> Option<Self> {\n+        if_chain! {\n+            if let ExprKind::Block(block, _) = expr.kind;\n+            if let [stmt] = block.stmts;\n+            if let StmtKind::Local(local) = stmt.kind;\n+            if let Some(init) = local.init;\n+            if let ExprKind::Call(_, [format_args]) = init.kind;\n+            let expn_data = expr.span.ctxt().outer_expn_data();\n+            if let ExpnKind::Macro { name: sym::format, .. } = expn_data.kind;\n+            if let Some(format_args) = FormatArgsExpn::parse(format_args);\n+            then {\n+                Some(FormatExpn {\n+                    call_site: expn_data.call_site,\n+                    format_args,\n+                })\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+}\n+\n+/// A parsed `format_args!` expansion\n+pub struct FormatArgsExpn<'tcx> {\n+    /// Span of the first argument, the format string\n+    pub format_string_span: Span,\n+    /// Values passed after the format string\n+    pub value_args: Vec<&'tcx Expr<'tcx>>,\n+\n+    /// String literal expressions which represent the format string split by \"{}\"\n+    pub format_string_parts: &'tcx [Expr<'tcx>],\n+    /// Symbols corresponding to [`format_string_parts`]\n+    pub format_string_symbols: Vec<Symbol>,\n+    /// Expressions like `ArgumentV1::new(arg0, Debug::fmt)`\n+    pub args: &'tcx [Expr<'tcx>],\n+    /// The final argument passed to `Arguments::new_v1_formatted`, if applicable\n+    pub fmt_expr: Option<&'tcx Expr<'tcx>>,\n+}\n+\n+impl FormatArgsExpn<'tcx> {\n+    /// Parses an expanded `format_args!` or `format_args_nl!` invocation\n+    pub fn parse(expr: &'tcx Expr<'tcx>) -> Option<Self> {\n+        if_chain! {\n+            if let ExpnKind::Macro { name, .. } = expr.span.ctxt().outer_expn_data().kind;\n+            let name = name.as_str();\n+            if name.ends_with(\"format_args\") || name.ends_with(\"format_args_nl\");\n+            if let ExprKind::Call(_, args) = expr.kind;\n+            if let Some((strs_ref, args, fmt_expr)) = match args {\n+                // Arguments::new_v1\n+                [strs_ref, args] => Some((strs_ref, args, None)),\n+                // Arguments::new_v1_formatted\n+                [strs_ref, args, fmt_expr] => Some((strs_ref, args, Some(fmt_expr))),\n+                _ => None,\n+            };\n+            if let ExprKind::AddrOf(BorrowKind::Ref, _, strs_arr) = strs_ref.kind;\n+            if let ExprKind::Array(format_string_parts) = strs_arr.kind;\n+            if let Some(format_string_symbols) = format_string_parts\n+                .iter()\n+                .map(|e| {\n+                    if let ExprKind::Lit(lit) = &e.kind {\n+                        if let LitKind::Str(symbol, _style) = lit.node {\n+                            return Some(symbol);\n+                        }\n+                    }\n+                    None\n+                })\n+                .collect();\n+            if let ExprKind::AddrOf(BorrowKind::Ref, _, args) = args.kind;\n+            if let ExprKind::Match(args, [arm], _) = args.kind;\n+            if let ExprKind::Tup(value_args) = args.kind;\n+            if let Some(value_args) = value_args\n+                .iter()\n+                .map(|e| match e.kind {\n+                    ExprKind::AddrOf(_, _, e) => Some(e),\n+                    _ => None,\n+                })\n+                .collect();\n+            if let ExprKind::Array(args) = arm.body.kind;\n+            then {\n+                Some(FormatArgsExpn {\n+                    format_string_span: strs_ref.span,\n+                    value_args,\n+                    format_string_parts,\n+                    format_string_symbols,\n+                    args,\n+                    fmt_expr,\n+                })\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+}"}, {"sha": "c960eec306414620449cd6d05e189080b8752867", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e6ab222b814f20375041a5dd39e7605eed079c70/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ab222b814f20375041a5dd39e7605eed079c70/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=e6ab222b814f20375041a5dd39e7605eed079c70", "patch": "@@ -38,7 +38,6 @@ pub const DEFAULT_TRAIT_METHOD: [&str; 4] = [\"core\", \"default\", \"Default\", \"defa\n pub const DEREF_MUT_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"DerefMut\", \"deref_mut\"];\n pub const DEREF_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"Deref\", \"deref\"];\n pub const DIR_BUILDER: [&str; 3] = [\"std\", \"fs\", \"DirBuilder\"];\n-pub const DISPLAY_FMT_METHOD: [&str; 4] = [\"core\", \"fmt\", \"Display\", \"fmt\"];\n pub const DISPLAY_TRAIT: [&str; 3] = [\"core\", \"fmt\", \"Display\"];\n pub const DOUBLE_ENDED_ITERATOR: [&str; 4] = [\"core\", \"iter\", \"traits\", \"DoubleEndedIterator\"];\n pub const DROP: [&str; 3] = [\"core\", \"mem\", \"drop\"];\n@@ -50,9 +49,6 @@ pub const F32_EPSILON: [&str; 4] = [\"core\", \"f32\", \"<impl f32>\", \"EPSILON\"];\n pub const F64_EPSILON: [&str; 4] = [\"core\", \"f64\", \"<impl f64>\", \"EPSILON\"];\n pub const FILE: [&str; 3] = [\"std\", \"fs\", \"File\"];\n pub const FILE_TYPE: [&str; 3] = [\"std\", \"fs\", \"FileType\"];\n-pub const FMT_ARGUMENTS_NEW_V1: [&str; 4] = [\"core\", \"fmt\", \"Arguments\", \"new_v1\"];\n-pub const FMT_ARGUMENTS_NEW_V1_FORMATTED: [&str; 4] = [\"core\", \"fmt\", \"Arguments\", \"new_v1_formatted\"];\n-pub const FMT_ARGUMENTV1_NEW: [&str; 4] = [\"core\", \"fmt\", \"ArgumentV1\", \"new\"];\n pub const FROM_FROM: [&str; 4] = [\"core\", \"convert\", \"From\", \"from\"];\n pub const FROM_ITERATOR: [&str; 5] = [\"core\", \"iter\", \"traits\", \"collect\", \"FromIterator\"];\n pub const FROM_ITERATOR_METHOD: [&str; 6] = [\"core\", \"iter\", \"traits\", \"collect\", \"FromIterator\", \"from_iter\"];"}]}