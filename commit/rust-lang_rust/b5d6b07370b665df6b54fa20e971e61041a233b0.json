{"sha": "b5d6b07370b665df6b54fa20e971e61041a233b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1ZDZiMDczNzBiNjY1ZGY2YjU0ZmEyMGU5NzFlNjEwNDFhMjMzYjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-02T14:06:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-02T14:06:50Z"}, "message": "auto merge of #13879 : huonw/rust/more-re, r=alexcrichton\n\nCommits for details.\r\n\r\nThis shouldn't change the generated code at all (except for switching to `LitBinary` from an explicit ExprVec of individual ExprLit bytes for `prefix_bytes`).", "tree": {"sha": "4a43dbe1601f640ebb8bade6d67898c74bdea0e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a43dbe1601f640ebb8bade6d67898c74bdea0e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5d6b07370b665df6b54fa20e971e61041a233b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5d6b07370b665df6b54fa20e971e61041a233b0", "html_url": "https://github.com/rust-lang/rust/commit/b5d6b07370b665df6b54fa20e971e61041a233b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5d6b07370b665df6b54fa20e971e61041a233b0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e97d4e6c190764de1240c2e8a5ac253a60faac6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e97d4e6c190764de1240c2e8a5ac253a60faac6b", "html_url": "https://github.com/rust-lang/rust/commit/e97d4e6c190764de1240c2e8a5ac253a60faac6b"}, {"sha": "1ad0cba5e6a837fdebf5f5543d4b169929972705", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ad0cba5e6a837fdebf5f5543d4b169929972705", "html_url": "https://github.com/rust-lang/rust/commit/1ad0cba5e6a837fdebf5f5543d4b169929972705"}], "stats": {"total": 183, "additions": 77, "deletions": 106}, "files": [{"sha": "6706fb16136dc4dc8e18e1f7547f4747de67c582", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 37, "deletions": 87, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/b5d6b07370b665df6b54fa20e971e61041a233b0/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5d6b07370b665df6b54fa20e971e61041a233b0/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=b5d6b07370b665df6b54fa20e971e61041a233b0", "patch": "@@ -24,8 +24,11 @@\n extern crate regex;\n extern crate syntax;\n \n+use std::rc::Rc;\n+\n use syntax::ast;\n use syntax::codemap;\n+use syntax::ext::build::AstBuilder;\n use syntax::ext::base::{\n     SyntaxExtension, ExtCtxt, MacResult, MacExpr, DummyResult,\n     NormalTT, BasicMacroExpander,\n@@ -112,24 +115,26 @@ impl<'a> NfaGen<'a> {\n         // expression returned.\n         let num_cap_locs = 2 * self.prog.num_captures();\n         let num_insts = self.prog.insts.len();\n-        let cap_names = self.vec_expr(self.names.as_slice(),\n-            |cx, name| match name {\n-                &Some(ref name) => {\n+        let cap_names = self.vec_expr(self.names.as_slice().iter(),\n+            |cx, name| match *name {\n+                Some(ref name) => {\n                     let name = name.as_slice();\n                     quote_expr!(cx, Some($name.to_owned()))\n                 }\n-                &None => quote_expr!(cx, None),\n+                None => cx.expr_none(self.sp),\n             }\n         );\n         let prefix_anchor =\n             match self.prog.insts.as_slice()[1] {\n                 EmptyBegin(flags) if flags & FLAG_MULTI == 0 => true,\n                 _ => false,\n             };\n-        let init_groups = self.vec_from_fn(num_cap_locs,\n-                                           |cx| quote_expr!(cx, None));\n-        let prefix_bytes = self.vec_expr(self.prog.prefix.as_slice().as_bytes(),\n-                                         |cx, b| quote_expr!(cx, $b));\n+        let init_groups = self.vec_expr(range(0, num_cap_locs),\n+                                        |cx, _| cx.expr_none(self.sp));\n+\n+        let prefix_lit = Rc::new(Vec::from_slice(self.prog.prefix.as_slice().as_bytes()));\n+        let prefix_bytes = self.cx.expr_lit(self.sp, ast::LitBinary(prefix_lit));\n+\n         let check_prefix = self.check_prefix();\n         let step_insts = self.step_insts();\n         let add_insts = self.add_insts();\n@@ -320,12 +325,11 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n             let nextpc = pc + 1;\n             let body = match *inst {\n                 EmptyBegin(flags) => {\n-                    let nl = '\\n';\n                     let cond =\n                         if flags & FLAG_MULTI > 0 {\n                             quote_expr!(self.cx,\n                                 self.chars.is_begin()\n-                                || self.chars.prev == Some($nl)\n+                                || self.chars.prev == Some('\\n')\n                             )\n                         } else {\n                             quote_expr!(self.cx, self.chars.is_begin())\n@@ -336,12 +340,11 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n                     })\n                 }\n                 EmptyEnd(flags) => {\n-                    let nl = '\\n';\n                     let cond =\n                         if flags & FLAG_MULTI > 0 {\n                             quote_expr!(self.cx,\n                                 self.chars.is_end()\n-                                || self.chars.cur == Some($nl)\n+                                || self.chars.cur == Some('\\n')\n                             )\n                         } else {\n                             quote_expr!(self.cx, self.chars.is_end())\n@@ -489,16 +492,16 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n                     if flags & FLAG_DOTNL > 0 {\n                         quote_expr!(self.cx, self.add(nlist, $nextpc, caps))\n                     } else {\n-                        let nl = '\\n'; // no char lits allowed? wtf?\n                         quote_expr!(self.cx, {\n-                            if self.chars.prev != Some($nl) {\n+                            if self.chars.prev != Some('\\n') {\n                                 self.add(nlist, $nextpc, caps)\n                             }\n+                            ()\n                         })\n                     }\n                 }\n                 // EmptyBegin, EmptyEnd, EmptyWordBoundary, Save, Jump, Split\n-                _ => quote_expr!(self.cx, {}),\n+                _ => self.empty_block(),\n             };\n             self.arm_inst(pc, body)\n         }).collect::<Vec<ast::Arm>>();\n@@ -510,36 +513,30 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n     // This avoids a binary search (and is hopefully replaced by a jump\n     // table).\n     fn match_class(&self, casei: bool, ranges: &[(char, char)]) -> @ast::Expr {\n+        let expr_true = quote_expr!(self.cx, true);\n+\n         let mut arms = ranges.iter().map(|&(mut start, mut end)| {\n             if casei {\n                 start = start.to_uppercase();\n                 end = end.to_uppercase();\n             }\n-            ast::Arm {\n-                attrs: vec!(),\n-                pats: vec!(@ast::Pat{\n-                    id: ast::DUMMY_NODE_ID,\n-                    span: self.sp,\n-                    node: ast::PatRange(quote_expr!(self.cx, $start),\n-                                        quote_expr!(self.cx, $end)),\n-                }),\n-                guard: None,\n-                body: quote_expr!(self.cx, true),\n-            }\n+            let pat = self.cx.pat(self.sp, ast::PatRange(quote_expr!(self.cx, $start),\n+                                                         quote_expr!(self.cx, $end)));\n+            self.cx.arm(self.sp, vec!(pat), expr_true)\n         }).collect::<Vec<ast::Arm>>();\n \n         arms.push(self.wild_arm_expr(quote_expr!(self.cx, false)));\n \n         let match_on = quote_expr!(self.cx, c);\n-        self.dummy_expr(ast::ExprMatch(match_on, arms))\n+        self.cx.expr_match(self.sp, match_on, arms)\n     }\n \n     // Generates code for checking a literal prefix of the search string.\n     // The code is only generated if the regex *has* a literal prefix.\n     // Otherwise, a no-op is returned.\n     fn check_prefix(&self) -> @ast::Expr {\n         if self.prog.prefix.len() == 0 {\n-            quote_expr!(self.cx, {})\n+            self.empty_block()\n         } else {\n             quote_expr!(self.cx,\n                 if clist.size == 0 {\n@@ -562,24 +559,20 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n     // never be used, but is added to satisfy the compiler complaining about\n     // non-exhaustive patterns.\n     fn match_insts(&self, mut arms: Vec<ast::Arm>) -> @ast::Expr {\n-        let mat_pc = quote_expr!(self.cx, pc);\n-        arms.push(self.wild_arm_expr(quote_expr!(self.cx, {})));\n-        self.dummy_expr(ast::ExprMatch(mat_pc, arms))\n+        arms.push(self.wild_arm_expr(self.empty_block()));\n+        self.cx.expr_match(self.sp, quote_expr!(self.cx, pc), arms)\n+    }\n+\n+    fn empty_block(&self) -> @ast::Expr {\n+        quote_expr!(self.cx, {})\n     }\n \n     // Creates a match arm for the instruction at `pc` with the expression\n     // `body`.\n     fn arm_inst(&self, pc: uint, body: @ast::Expr) -> ast::Arm {\n-        ast::Arm {\n-            attrs: vec!(),\n-            pats: vec!(@ast::Pat{\n-                id: ast::DUMMY_NODE_ID,\n-                span: self.sp,\n-                node: ast::PatLit(quote_expr!(self.cx, $pc)),\n-            }),\n-            guard: None,\n-            body: body,\n-        }\n+        let pc_pat = self.cx.pat_lit(self.sp, quote_expr!(self.cx, $pc));\n+\n+        self.cx.arm(self.sp, vec!(pc_pat), body)\n     }\n \n     // Creates a wild-card match arm with the expression `body`.\n@@ -596,56 +589,13 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n         }\n     }\n \n-    // Builds a `[a, b, .., len]` expression where each element is the result\n-    // of executing `to_expr`.\n-    fn vec_from_fn(&self, len: uint, to_expr: |&ExtCtxt| -> @ast::Expr)\n-                  -> @ast::Expr {\n-        self.vec_expr(Vec::from_elem(len, ()).as_slice(),\n-                      |cx, _| to_expr(cx))\n-    }\n \n     // Converts `xs` to a `[x1, x2, .., xN]` expression by calling `to_expr`\n     // on each element in `xs`.\n-    fn vec_expr<T>(&self, xs: &[T], to_expr: |&ExtCtxt, &T| -> @ast::Expr)\n+    fn vec_expr<T, It: Iterator<T>>(&self, xs: It, to_expr: |&ExtCtxt, T| -> @ast::Expr)\n                   -> @ast::Expr {\n-        let mut exprs = vec!();\n-        for x in xs.iter() {\n-            exprs.push(to_expr(self.cx, x))\n-        }\n-        let vec_exprs = self.dummy_expr(ast::ExprVec(exprs));\n-        quote_expr!(self.cx, $vec_exprs)\n-    }\n-\n-    // Creates an expression with a dummy node ID given an underlying\n-    // `ast::Expr_`.\n-    fn dummy_expr(&self, e: ast::Expr_) -> @ast::Expr {\n-        @ast::Expr {\n-            id: ast::DUMMY_NODE_ID,\n-            node: e,\n-            span: self.sp,\n-        }\n-    }\n-}\n-\n-// This trait is defined in the quote module in the syntax crate, but I\n-// don't think it's exported.\n-// Interestingly, quote_expr! only requires that a 'to_tokens' method be\n-// defined rather than satisfying a particular trait.\n-#[doc(hidden)]\n-trait ToTokens {\n-    fn to_tokens(&self, cx: &ExtCtxt) -> Vec<ast::TokenTree>;\n-}\n-\n-impl ToTokens for char {\n-    fn to_tokens(&self, _: &ExtCtxt) -> Vec<ast::TokenTree> {\n-        vec!(ast::TTTok(codemap::DUMMY_SP, token::LIT_CHAR((*self) as u32)))\n-    }\n-}\n-\n-impl ToTokens for bool {\n-    fn to_tokens(&self, _: &ExtCtxt) -> Vec<ast::TokenTree> {\n-        let ident = token::IDENT(token::str_to_ident(self.to_str()), false);\n-        vec!(ast::TTTok(codemap::DUMMY_SP, ident))\n+        let exprs = xs.map(|x| to_expr(self.cx, x)).collect();\n+        self.cx.expr_vec(self.sp, exprs)\n     }\n }\n "}, {"sha": "06d768b4342503f6746601d0c84f5ed6de149bac", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b5d6b07370b665df6b54fa20e971e61041a233b0/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5d6b07370b665df6b54fa20e971e61041a233b0/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=b5d6b07370b665df6b54fa20e971e61041a233b0", "patch": "@@ -26,7 +26,6 @@ use rustc::metadata::decoder;\n \n use std::local_data;\n use std::strbuf::StrBuf;\n-use std;\n \n use core;\n use doctree;\n@@ -1246,7 +1245,7 @@ fn lit_to_str(lit: &ast::Lit) -> ~str {\n     match lit.node {\n         ast::LitStr(ref st, _) => st.get().to_owned(),\n         ast::LitBinary(ref data) => format!(\"{:?}\", data.as_slice()),\n-        ast::LitChar(c) => \"'\".to_owned() + std::char::from_u32(c).unwrap().to_str() + \"'\",\n+        ast::LitChar(c) => format!(\"'{}'\", c),\n         ast::LitInt(i, _t) => i.to_str(),\n         ast::LitUint(u, _t) => u.to_str(),\n         ast::LitIntUnsuffixed(i) => i.to_str(),"}, {"sha": "49617a44a863fbd2cf00a7e62294e7c425d2b0c7", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5d6b07370b665df6b54fa20e971e61041a233b0/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5d6b07370b665df6b54fa20e971e61041a233b0/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=b5d6b07370b665df6b54fa20e971e61041a233b0", "patch": "@@ -653,7 +653,7 @@ pub type Lit = Spanned<Lit_>;\n pub enum Lit_ {\n     LitStr(InternedString, StrStyle),\n     LitBinary(Rc<Vec<u8> >),\n-    LitChar(u32),\n+    LitChar(char),\n     LitInt(i64, IntTy),\n     LitUint(u64, UintTy),\n     LitIntUnsuffixed(i64),"}, {"sha": "c6349d616eca3d478fe84a6a74b6833e485aecb9", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5d6b07370b665df6b54fa20e971e61041a233b0/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5d6b07370b665df6b54fa20e971e61041a233b0/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=b5d6b07370b665df6b54fa20e971e61041a233b0", "patch": "@@ -16,8 +16,6 @@ use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n \n-use std::char;\n-\n pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) -> ~base::MacResult {\n     // Gather all argument expressions\n     let exprs = match get_exprs_from_tts(cx, sp, tts) {\n@@ -59,7 +57,7 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) ->\n \n                 // char literal, push to vector expression\n                 ast::LitChar(v) => {\n-                    if char::from_u32(v).unwrap().is_ascii() {\n+                    if v.is_ascii() {\n                         bytes.push(cx.expr_u8(expr.span, v as u8));\n                     } else {\n                         cx.span_err(expr.span, \"non-ascii char literal in bytes!\")"}, {"sha": "fe7fa636e7d59c6b87b7e85c9f1e1bc11bc8c692", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b5d6b07370b665df6b54fa20e971e61041a233b0/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5d6b07370b665df6b54fa20e971e61041a233b0/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=b5d6b07370b665df6b54fa20e971e61041a233b0", "patch": "@@ -14,7 +14,6 @@ use ext::base;\n use ext::build::AstBuilder;\n use parse::token;\n \n-use std::char;\n use std::strbuf::StrBuf;\n \n pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n@@ -35,7 +34,7 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                         accumulator.push_str(s.get());\n                     }\n                     ast::LitChar(c) => {\n-                        accumulator.push_char(char::from_u32(c).unwrap());\n+                        accumulator.push_char(c);\n                     }\n                     ast::LitInt(i, _) | ast::LitIntUnsuffixed(i) => {\n                         accumulator.push_str(format!(\"{}\", i));"}, {"sha": "df79b1054443247f67f351a9bb3c20df64afc081", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5d6b07370b665df6b54fa20e971e61041a233b0/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5d6b07370b665df6b54fa20e971e61041a233b0/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=b5d6b07370b665df6b54fa20e971e61041a233b0", "patch": "@@ -561,7 +561,7 @@ impl<'a, 'b> Context<'a, 'b> {\n \n                 // Translate the format\n                 let fill = match arg.format.fill { Some(c) => c, None => ' ' };\n-                let fill = self.ecx.expr_lit(sp, ast::LitChar(fill as u32));\n+                let fill = self.ecx.expr_lit(sp, ast::LitChar(fill));\n                 let align = match arg.format.align {\n                     parse::AlignLeft => {\n                         self.ecx.path_global(sp, self.parsepath(\"AlignLeft\"))"}, {"sha": "fc7f772235474af10ab0d3a1db58057b17045bbf", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b5d6b07370b665df6b54fa20e971e61041a233b0/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5d6b07370b665df6b54fa20e971e61041a233b0/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=b5d6b07370b665df6b54fa20e971e61041a233b0", "patch": "@@ -125,6 +125,26 @@ pub mod rt {\n         }\n     }\n \n+    impl ToSource for () {\n+        fn to_source(&self) -> ~str {\n+            \"()\".to_owned()\n+        }\n+    }\n+\n+    impl ToSource for bool {\n+        fn to_source(&self) -> ~str {\n+            let lit = dummy_spanned(ast::LitBool(*self));\n+            pprust::lit_to_str(&lit)\n+        }\n+    }\n+\n+    impl ToSource for char {\n+        fn to_source(&self) -> ~str {\n+            let lit = dummy_spanned(ast::LitChar(*self));\n+            pprust::lit_to_str(&lit)\n+        }\n+    }\n+\n     impl ToSource for int {\n         fn to_source(&self) -> ~str {\n             let lit = dummy_spanned(ast::LitInt(*self as i64, ast::TyI));\n@@ -227,6 +247,9 @@ pub mod rt {\n     impl_to_tokens!(@ast::Expr)\n     impl_to_tokens!(ast::Block)\n     impl_to_tokens_self!(&'a str)\n+    impl_to_tokens!(())\n+    impl_to_tokens!(char)\n+    impl_to_tokens!(bool)\n     impl_to_tokens!(int)\n     impl_to_tokens!(i8)\n     impl_to_tokens!(i16)"}, {"sha": "c1f6e21f923c311093c84f0682952e72fbd680b8", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b5d6b07370b665df6b54fa20e971e61041a233b0/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5d6b07370b665df6b54fa20e971e61041a233b0/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=b5d6b07370b665df6b54fa20e971e61041a233b0", "patch": "@@ -874,7 +874,7 @@ fn next_token_inner(rdr: &mut StringReader) -> token::Token {\n                                \"unterminated character constant\".to_owned());\n         }\n         bump(rdr); // advance curr past token\n-        return token::LIT_CHAR(c2 as u32);\n+        return token::LIT_CHAR(c2);\n       }\n       '\"' => {\n         let mut accum_str = StrBuf::new();\n@@ -1097,17 +1097,17 @@ mod test {\n \n     #[test] fn character_a() {\n         assert_eq!(setup(&mk_sh(), \"'a'\".to_owned()).next_token().tok,\n-                   token::LIT_CHAR('a' as u32));\n+                   token::LIT_CHAR('a'));\n     }\n \n     #[test] fn character_space() {\n         assert_eq!(setup(&mk_sh(), \"' '\".to_owned()).next_token().tok,\n-                   token::LIT_CHAR(' ' as u32));\n+                   token::LIT_CHAR(' '));\n     }\n \n     #[test] fn character_escaped() {\n         assert_eq!(setup(&mk_sh(), \"'\\\\n'\".to_owned()).next_token().tok,\n-                   token::LIT_CHAR('\\n' as u32));\n+                   token::LIT_CHAR('\\n'));\n     }\n \n     #[test] fn lifetime_name() {\n@@ -1128,7 +1128,7 @@ mod test {\n \n     #[test] fn nested_block_comments() {\n         assert_eq!(setup(&mk_sh(), \"/* /* */ */'a'\".to_owned()).next_token().tok,\n-                   token::LIT_CHAR('a' as u32));\n+                   token::LIT_CHAR('a'));\n     }\n \n }"}, {"sha": "519a7d141d33f411b93a4b83f3b5578165f8d41a", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b5d6b07370b665df6b54fa20e971e61041a233b0/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5d6b07370b665df6b54fa20e971e61041a233b0/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=b5d6b07370b665df6b54fa20e971e61041a233b0", "patch": "@@ -18,7 +18,6 @@ use util::interner;\n \n use serialize::{Decodable, Decoder, Encodable, Encoder};\n use std::cast;\n-use std::char;\n use std::fmt;\n use std::local_data;\n use std::path::BytesContainer;\n@@ -81,7 +80,7 @@ pub enum Token {\n     DOLLAR,\n \n     /* Literals */\n-    LIT_CHAR(u32),\n+    LIT_CHAR(char),\n     LIT_INT(i64, ast::IntTy),\n     LIT_UINT(u64, ast::UintTy),\n     LIT_INT_UNSUFFIXED(i64),\n@@ -195,7 +194,7 @@ pub fn to_str(t: &Token) -> ~str {\n       /* Literals */\n       LIT_CHAR(c) => {\n           let mut res = StrBuf::from_str(\"'\");\n-          char::from_u32(c).unwrap().escape_default(|c| {\n+          c.escape_default(|c| {\n               res.push_char(c);\n           });\n           res.push_char('\\'');"}, {"sha": "afb66ab831750864775903a7ea43613d3ee800b8", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b5d6b07370b665df6b54fa20e971e61041a233b0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5d6b07370b665df6b54fa20e971e61041a233b0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=b5d6b07370b665df6b54fa20e971e61041a233b0", "patch": "@@ -26,7 +26,6 @@ use print::pp::{Breaks, Consistent, Inconsistent, eof};\n use print::pp;\n \n use std::cast;\n-use std::char;\n use std::io::{IoResult, MemWriter};\n use std::io;\n use std::rc::Rc;\n@@ -2196,7 +2195,7 @@ impl<'a> State<'a> {\n             ast::LitStr(ref st, style) => self.print_string(st.get(), style),\n             ast::LitChar(ch) => {\n                 let mut res = StrBuf::from_str(\"'\");\n-                char::from_u32(ch).unwrap().escape_default(|c| res.push_char(c));\n+                ch.escape_default(|c| res.push_char(c));\n                 res.push_char('\\'');\n                 word(&mut self.s, res.into_owned())\n             }"}, {"sha": "7c25246807d57a514036611f33e61955adf2c4b1", "filename": "src/test/run-pass-fulldeps/quote-tokens.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5d6b07370b665df6b54fa20e971e61041a233b0/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5d6b07370b665df6b54fa20e971e61041a233b0/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs?ref=b5d6b07370b665df6b54fa20e971e61041a233b0", "patch": "@@ -26,6 +26,10 @@ fn syntax_extension(cx: &ExtCtxt) {\n     let _c: @syntax::ast::Pat = quote_pat!(cx, (x, 1 .. 4, *) );\n     let _d: @syntax::ast::Stmt = quote_stmt!(cx, let x = $a; );\n     let _e: @syntax::ast::Expr = quote_expr!(cx, match foo { $p_toks => 10 } );\n+\n+    let _f: @syntax::ast::Expr = quote_expr!(cx, ());\n+    let _g: @syntax::ast::Expr = quote_expr!(cx, true);\n+    let _h: @syntax::ast::Expr = quote_expr!(cx, 'a');\n }\n \n fn main() {"}]}