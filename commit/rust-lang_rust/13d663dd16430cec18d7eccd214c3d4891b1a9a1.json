{"sha": "13d663dd16430cec18d7eccd214c3d4891b1a9a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzZDY2M2RkMTY0MzBjZWMxOGQ3ZWNjZDIxNGMzZDQ4OTFiMWE5YTE=", "commit": {"author": {"name": "Yoshua Wuyts", "email": "yoshuawuyts+github@gmail.com", "date": "2021-02-05T00:57:39Z"}, "committer": {"name": "Yoshua Wuyts", "email": "yoshuawuyts@gmail.com", "date": "2021-02-05T10:28:11Z"}, "message": "add `generate-enum-match` assist", "tree": {"sha": "626b5048ded809a840b215e413f37f19388bc9f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/626b5048ded809a840b215e413f37f19388bc9f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/13d663dd16430cec18d7eccd214c3d4891b1a9a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/13d663dd16430cec18d7eccd214c3d4891b1a9a1", "html_url": "https://github.com/rust-lang/rust/commit/13d663dd16430cec18d7eccd214c3d4891b1a9a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/13d663dd16430cec18d7eccd214c3d4891b1a9a1/comments", "author": {"login": "yoshuawuyts", "id": 2467194, "node_id": "MDQ6VXNlcjI0NjcxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2467194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yoshuawuyts", "html_url": "https://github.com/yoshuawuyts", "followers_url": "https://api.github.com/users/yoshuawuyts/followers", "following_url": "https://api.github.com/users/yoshuawuyts/following{/other_user}", "gists_url": "https://api.github.com/users/yoshuawuyts/gists{/gist_id}", "starred_url": "https://api.github.com/users/yoshuawuyts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yoshuawuyts/subscriptions", "organizations_url": "https://api.github.com/users/yoshuawuyts/orgs", "repos_url": "https://api.github.com/users/yoshuawuyts/repos", "events_url": "https://api.github.com/users/yoshuawuyts/events{/privacy}", "received_events_url": "https://api.github.com/users/yoshuawuyts/received_events", "type": "User", "site_admin": false}, "committer": {"login": "yoshuawuyts", "id": 2467194, "node_id": "MDQ6VXNlcjI0NjcxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2467194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yoshuawuyts", "html_url": "https://github.com/yoshuawuyts", "followers_url": "https://api.github.com/users/yoshuawuyts/followers", "following_url": "https://api.github.com/users/yoshuawuyts/following{/other_user}", "gists_url": "https://api.github.com/users/yoshuawuyts/gists{/gist_id}", "starred_url": "https://api.github.com/users/yoshuawuyts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yoshuawuyts/subscriptions", "organizations_url": "https://api.github.com/users/yoshuawuyts/orgs", "repos_url": "https://api.github.com/users/yoshuawuyts/repos", "events_url": "https://api.github.com/users/yoshuawuyts/events{/privacy}", "received_events_url": "https://api.github.com/users/yoshuawuyts/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "842033b15055eba9aabfc730468cd076a30a5f29", "url": "https://api.github.com/repos/rust-lang/rust/commits/842033b15055eba9aabfc730468cd076a30a5f29", "html_url": "https://github.com/rust-lang/rust/commit/842033b15055eba9aabfc730468cd076a30a5f29"}], "stats": {"total": 322, "additions": 322, "deletions": 0}, "files": [{"sha": "079ed27bd3681a0c5dbb8a8623e7685e53df53c2", "filename": "crates/assists/src/handlers/generate_enum_match_method.rs", "status": "added", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/13d663dd16430cec18d7eccd214c3d4891b1a9a1/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_enum_match_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13d663dd16430cec18d7eccd214c3d4891b1a9a1/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_enum_match_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_enum_match_method.rs?ref=13d663dd16430cec18d7eccd214c3d4891b1a9a1", "patch": "@@ -0,0 +1,293 @@\n+use hir::Adt;\n+use stdx::format_to;\n+use syntax::ast::{self, AstNode, NameOwner};\n+use syntax::{ast::VisibilityOwner, T};\n+use test_utils::mark;\n+\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n+\n+// Assist: generate_enum_match_method\n+//\n+// Generate an `is_` method for an enum variant.\n+//\n+// ```\n+// enum Version {\n+//  Undefined,\n+//  Minor$0,\n+//  Major,\n+// }\n+// ```\n+// ->\n+// ```\n+// enum Version {\n+//  Undefined,\n+//  Minor,\n+//  Major,\n+// }\n+//\n+// impl Version {\n+//     fn is_minor(&self) -> bool {\n+//         matches!(self, Self::Minor)\n+//     }\n+// }\n+// ```\n+pub(crate) fn generate_enum_match_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let variant = ctx.find_node_at_offset::<ast::Variant>()?;\n+    let variant_name = variant.name()?;\n+    let parent_enum = variant.parent_enum();\n+    if !matches!(variant.kind(), ast::StructKind::Unit) {\n+        mark::hit!(test_gen_enum_match_on_non_unit_variant_not_implemented);\n+        return None;\n+    }\n+\n+    let fn_name = to_lower_snake_case(&format!(\"{}\", variant_name));\n+\n+    // Return early if we've found an existing new fn\n+    let impl_def = find_struct_impl(&ctx, &parent_enum, format!(\"is_{}\", fn_name).as_str())?;\n+\n+    let target = variant.syntax().text_range();\n+    acc.add(\n+        AssistId(\"generate_enum_match_method\", AssistKind::Generate),\n+        \"Generate an `is_` method for an enum variant\",\n+        target,\n+        |builder| {\n+            let mut buf = String::with_capacity(512);\n+\n+            if impl_def.is_some() {\n+                buf.push('\\n');\n+            }\n+\n+            let vis = parent_enum.visibility().map_or(String::new(), |v| format!(\"{} \", v));\n+\n+            format_to!(\n+                buf,\n+                \"    {}fn is_{}(&self) -> bool {{\n+        matches!(self, Self::{})\n+    }}\",\n+                vis,\n+                fn_name,\n+                variant_name\n+            );\n+\n+            let start_offset = impl_def\n+                .and_then(|impl_def| {\n+                    buf.push('\\n');\n+                    let start = impl_def\n+                        .syntax()\n+                        .descendants_with_tokens()\n+                        .find(|t| t.kind() == T!['{'])?\n+                        .text_range()\n+                        .end();\n+\n+                    Some(start)\n+                })\n+                .unwrap_or_else(|| {\n+                    buf = generate_impl_text(&parent_enum, &buf);\n+                    parent_enum.syntax().text_range().end()\n+                });\n+\n+            builder.insert(start_offset, buf);\n+        },\n+    )\n+}\n+\n+// Generates the surrounding `impl Type { <code> }` including type and lifetime\n+// parameters\n+fn generate_impl_text(strukt: &ast::Enum, code: &str) -> String {\n+    let mut buf = String::with_capacity(code.len());\n+    buf.push_str(\"\\n\\nimpl\");\n+    buf.push_str(\" \");\n+    buf.push_str(strukt.name().unwrap().text());\n+    format_to!(buf, \" {{\\n{}\\n}}\", code);\n+    buf\n+}\n+\n+fn to_lower_snake_case(s: &str) -> String {\n+    let mut buf = String::with_capacity(s.len());\n+    let mut prev = false;\n+    for c in s.chars() {\n+        if c.is_ascii_uppercase() && prev {\n+            buf.push('_')\n+        }\n+        prev = true;\n+\n+        buf.push(c.to_ascii_lowercase());\n+    }\n+    buf\n+}\n+\n+// Uses a syntax-driven approach to find any impl blocks for the struct that\n+// exist within the module/file\n+//\n+// Returns `None` if we've found an existing `new` fn\n+//\n+// FIXME: change the new fn checking to a more semantic approach when that's more\n+// viable (e.g. we process proc macros, etc)\n+fn find_struct_impl(\n+    ctx: &AssistContext,\n+    strukt: &ast::Enum,\n+    name: &str,\n+) -> Option<Option<ast::Impl>> {\n+    let db = ctx.db();\n+    let module = strukt.syntax().ancestors().find(|node| {\n+        ast::Module::can_cast(node.kind()) || ast::SourceFile::can_cast(node.kind())\n+    })?;\n+\n+    let struct_def = ctx.sema.to_def(strukt)?;\n+\n+    let block = module.descendants().filter_map(ast::Impl::cast).find_map(|impl_blk| {\n+        let blk = ctx.sema.to_def(&impl_blk)?;\n+\n+        // FIXME: handle e.g. `struct S<T>; impl<U> S<U> {}`\n+        // (we currently use the wrong type parameter)\n+        // also we wouldn't want to use e.g. `impl S<u32>`\n+        let same_ty = match blk.target_ty(db).as_adt() {\n+            Some(def) => def == Adt::Enum(struct_def),\n+            None => false,\n+        };\n+        let not_trait_impl = blk.target_trait(db).is_none();\n+\n+        if !(same_ty && not_trait_impl) {\n+            None\n+        } else {\n+            Some(impl_blk)\n+        }\n+    });\n+\n+    if let Some(ref impl_blk) = block {\n+        if has_fn(impl_blk, name) {\n+            mark::hit!(test_gen_enum_match_impl_already_exists);\n+            return None;\n+        }\n+    }\n+\n+    Some(block)\n+}\n+\n+fn has_fn(imp: &ast::Impl, rhs_name: &str) -> bool {\n+    if let Some(il) = imp.assoc_item_list() {\n+        for item in il.assoc_items() {\n+            if let ast::AssocItem::Fn(f) = item {\n+                if let Some(name) = f.name() {\n+                    if name.text().eq_ignore_ascii_case(rhs_name) {\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    false\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use ide_db::helpers::FamousDefs;\n+    use test_utils::mark;\n+\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    fn check_not_applicable(ra_fixture: &str) {\n+        let fixture =\n+            format!(\"//- /main.rs crate:main deps:core\\n{}\\n{}\", ra_fixture, FamousDefs::FIXTURE);\n+        check_assist_not_applicable(generate_enum_match_method, &fixture)\n+    }\n+\n+    #[test]\n+    fn test_generate_enum_match_from_variant() {\n+        check_assist(\n+            generate_enum_match_method,\n+            r#\"\n+enum Variant {\n+    Undefined,\n+    Minor$0,\n+    Major,\n+}\"#,\n+            r#\"enum Variant {\n+    Undefined,\n+    Minor,\n+    Major,\n+}\n+\n+impl Variant {\n+    fn is_minor(&self) -> bool {\n+        matches!(self, Self::Minor)\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_enum_match_already_implemented() {\n+        mark::check!(test_gen_enum_match_impl_already_exists);\n+        check_not_applicable(\n+            r#\"\n+enum Variant {\n+    Undefined,\n+    Minor$0,\n+    Major,\n+}\n+\n+impl Variant {\n+    fn is_minor(&self) -> bool {\n+        matches!(self, Self::Minor)\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_add_from_impl_no_element() {\n+        mark::check!(test_gen_enum_match_on_non_unit_variant_not_implemented);\n+        check_not_applicable(\n+            r#\"\n+enum Variant {\n+    Undefined,\n+    Minor(u32)$0,\n+    Major,\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_enum_match_from_variant_with_one_variant() {\n+        check_assist(\n+            generate_enum_match_method,\n+            r#\"enum Variant { Undefi$0ned }\"#,\n+            r#\"\n+enum Variant { Undefined }\n+\n+impl Variant {\n+    fn is_undefined(&self) -> bool {\n+        matches!(self, Self::Undefined)\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_enum_match_from_variant_with_visibility_marker() {\n+        check_assist(\n+            generate_enum_match_method,\n+            r#\"\n+pub(crate) enum Variant {\n+    Undefined,\n+    Minor$0,\n+    Major,\n+}\"#,\n+            r#\"pub(crate) enum Variant {\n+    Undefined,\n+    Minor,\n+    Major,\n+}\n+\n+impl Variant {\n+    pub(crate) fn is_minor(&self) -> bool {\n+        matches!(self, Self::Minor)\n+    }\n+}\"#,\n+        );\n+    }\n+}"}, {"sha": "a18232877db8844285e405328e7486ae02a0db89", "filename": "crates/assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/13d663dd16430cec18d7eccd214c3d4891b1a9a1/crates%2Fassists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13d663dd16430cec18d7eccd214c3d4891b1a9a1/crates%2Fassists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Flib.rs?ref=13d663dd16430cec18d7eccd214c3d4891b1a9a1", "patch": "@@ -126,6 +126,7 @@ mod handlers {\n     mod flip_trait_bound;\n     mod generate_default_from_enum_variant;\n     mod generate_derive;\n+    mod generate_enum_match_method;\n     mod generate_from_impl_for_enum;\n     mod generate_function;\n     mod generate_impl;\n@@ -183,6 +184,7 @@ mod handlers {\n             flip_trait_bound::flip_trait_bound,\n             generate_default_from_enum_variant::generate_default_from_enum_variant,\n             generate_derive::generate_derive,\n+            generate_enum_match_method::generate_enum_match_method,\n             generate_from_impl_for_enum::generate_from_impl_for_enum,\n             generate_function::generate_function,\n             generate_impl::generate_impl,"}, {"sha": "ae7b400e208798114445eb07463c6a524946538b", "filename": "crates/assists/src/tests/generated.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/13d663dd16430cec18d7eccd214c3d4891b1a9a1/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13d663dd16430cec18d7eccd214c3d4891b1a9a1/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs?ref=13d663dd16430cec18d7eccd214c3d4891b1a9a1", "patch": "@@ -432,6 +432,33 @@ struct Point {\n     )\n }\n \n+#[test]\n+fn doctest_generate_enum_match_method() {\n+    check_doc_test(\n+        \"generate_enum_match_method\",\n+        r#####\"\n+enum Version {\n+ Undefined,\n+ Minor$0,\n+ Major,\n+}\n+\"#####,\n+        r#####\"\n+enum Version {\n+ Undefined,\n+ Minor,\n+ Major,\n+}\n+\n+impl Version {\n+    fn is_minor(&self) -> bool {\n+        matches!(self, Self::Minor)\n+    }\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_generate_from_impl_for_enum() {\n     check_doc_test("}]}