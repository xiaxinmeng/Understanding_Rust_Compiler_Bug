{"sha": "7ebf9bc5c22155d622537ded42b4ebf94238b296", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlYmY5YmM1YzIyMTU1ZDYyMjUzN2RlZDQyYjRlYmY5NDIzOGIyOTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-07T02:04:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-07T02:04:47Z"}, "message": "Auto merge of #21505 - GuillaumeGomez:interned_string, r=alexcrichton\n\nIt's in order to make the code more homogeneous.", "tree": {"sha": "b3f937f2f554e961236d3a2048778441ab062c5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3f937f2f554e961236d3a2048778441ab062c5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ebf9bc5c22155d622537ded42b4ebf94238b296", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ebf9bc5c22155d622537ded42b4ebf94238b296", "html_url": "https://github.com/rust-lang/rust/commit/7ebf9bc5c22155d622537ded42b4ebf94238b296", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ebf9bc5c22155d622537ded42b4ebf94238b296/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3732a12e896ab98aa27eaffab99a78bbaf837e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3732a12e896ab98aa27eaffab99a78bbaf837e4", "html_url": "https://github.com/rust-lang/rust/commit/d3732a12e896ab98aa27eaffab99a78bbaf837e4"}, {"sha": "a2e01c62d5b6259d55b6688c8b059ac28e5dd03e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2e01c62d5b6259d55b6688c8b059ac28e5dd03e", "html_url": "https://github.com/rust-lang/rust/commit/a2e01c62d5b6259d55b6688c8b059ac28e5dd03e"}], "stats": {"total": 595, "additions": 295, "deletions": 300}, "files": [{"sha": "638ecf4572d5d5404cb3338af5c4d3a56b2c0602", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -699,7 +699,7 @@ impl LintPass for UnusedAttributes {\n \n         if !attr::is_used(attr) {\n             cx.span_lint(UNUSED_ATTRIBUTES, attr.span, \"unused attribute\");\n-            if CRATE_ATTRS.contains(&attr.name().get()) {\n+            if CRATE_ATTRS.contains(&&attr.name()[]) {\n                 let msg = match attr.node.style {\n                     ast::AttrOuter => \"crate-level attribute should be an inner \\\n                                        attribute: add an exclamation mark: #![foo]\",\n@@ -801,10 +801,10 @@ impl LintPass for UnusedResults {\n                         None => {}\n                         Some(s) => {\n                             msg.push_str(\": \");\n-                            msg.push_str(s.get());\n+                            msg.push_str(&s);\n                         }\n                     }\n-                    cx.span_lint(UNUSED_MUST_USE, sp, &msg[]);\n+                    cx.span_lint(UNUSED_MUST_USE, sp, &msg);\n                     return true;\n                 }\n             }\n@@ -826,8 +826,8 @@ impl NonCamelCaseTypes {\n     fn check_case(&self, cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n         fn is_camel_case(ident: ast::Ident) -> bool {\n             let ident = token::get_ident(ident);\n-            if ident.get().is_empty() { return true; }\n-            let ident = ident.get().trim_matches('_');\n+            if ident.is_empty() { return true; }\n+            let ident = ident.trim_matches('_');\n \n             // start with a non-lowercase letter rather than non-uppercase\n             // ones (some scripts don't have a concept of upper/lowercase)\n@@ -844,7 +844,7 @@ impl NonCamelCaseTypes {\n         let s = token::get_ident(ident);\n \n         if !is_camel_case(ident) {\n-            let c = to_camel_case(s.get());\n+            let c = to_camel_case(&s);\n             let m = if c.is_empty() {\n                 format!(\"{} `{}` should have a camel case name such as `CamelCase`\", sort, s)\n             } else {\n@@ -977,8 +977,8 @@ impl NonSnakeCase {\n     fn check_snake_case(&self, cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n         fn is_snake_case(ident: ast::Ident) -> bool {\n             let ident = token::get_ident(ident);\n-            if ident.get().is_empty() { return true; }\n-            let ident = ident.get().trim_left_matches('\\'');\n+            if ident.is_empty() { return true; }\n+            let ident = ident.trim_left_matches('\\'');\n             let ident = ident.trim_matches('_');\n \n             let mut allow_underscore = true;\n@@ -996,8 +996,8 @@ impl NonSnakeCase {\n         let s = token::get_ident(ident);\n \n         if !is_snake_case(ident) {\n-            let sc = NonSnakeCase::to_snake_case(s.get());\n-            if sc != s.get() {\n+            let sc = NonSnakeCase::to_snake_case(&s);\n+            if sc != &s[] {\n                 cx.span_lint(NON_SNAKE_CASE, span,\n                     &*format!(\"{} `{}` should have a snake case name such as `{}`\",\n                             sort, s, sc));\n@@ -1077,10 +1077,10 @@ impl NonUpperCaseGlobals {\n     fn check_upper_case(cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n         let s = token::get_ident(ident);\n \n-        if s.get().chars().any(|c| c.is_lowercase()) {\n-            let uc: String = NonSnakeCase::to_snake_case(s.get()).chars()\n+        if s.chars().any(|c| c.is_lowercase()) {\n+            let uc: String = NonSnakeCase::to_snake_case(&s).chars()\n                                            .map(|c| c.to_uppercase()).collect();\n-            if uc != s.get() {\n+            if uc != &s[] {\n                 cx.span_lint(NON_UPPER_CASE_GLOBALS, span,\n                     &format!(\"{} `{}` should have an upper case name such as `{}`\",\n                              sort, s, uc));\n@@ -1241,7 +1241,7 @@ impl LintPass for UnusedImportBraces {\n                             match items[0].node {\n                                 ast::PathListIdent {ref name, ..} => {\n                                     let m = format!(\"braces around {} is unnecessary\",\n-                                                    token::get_ident(*name).get());\n+                                                    &token::get_ident(*name));\n                                     cx.span_lint(UNUSED_IMPORT_BRACES, item.span,\n                                                  &m[]);\n                                 },\n@@ -1358,7 +1358,7 @@ impl UnusedMut {\n             pat_util::pat_bindings(&cx.tcx.def_map, &**p, |mode, id, _, path1| {\n                 let ident = path1.node;\n                 if let ast::BindByValue(ast::MutMutable) = mode {\n-                    if !token::get_ident(ident).get().starts_with(\"_\") {\n+                    if !token::get_ident(ident).starts_with(\"_\") {\n                         match mutables.entry(ident.name.usize()) {\n                             Vacant(entry) => { entry.insert(vec![id]); },\n                             Occupied(mut entry) => { entry.get_mut().push(id); },"}, {"sha": "18628f6903f5deabb57a3e446b5bbdc4ec0610cb", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -341,7 +341,7 @@ pub fn gather_attrs(attrs: &[ast::Attribute])\n                     -> Vec<Result<(InternedString, Level, Span), Span>> {\n     let mut out = vec!();\n     for attr in attrs {\n-        let level = match Level::from_str(attr.name().get()) {\n+        let level = match Level::from_str(&attr.name()) {\n             None => continue,\n             Some(lvl) => lvl,\n         };\n@@ -499,10 +499,10 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n                     continue;\n                 }\n                 Ok((lint_name, level, span)) => {\n-                    match self.lints.find_lint(lint_name.get(), &self.tcx.sess, Some(span)) {\n+                    match self.lints.find_lint(&lint_name, &self.tcx.sess, Some(span)) {\n                         Some(lint_id) => vec![(lint_id, level, span)],\n                         None => {\n-                            match self.lints.lint_groups.get(lint_name.get()) {\n+                            match self.lints.lint_groups.get(&lint_name[]) {\n                                 Some(&(ref v, _)) => v.iter()\n                                                       .map(|lint_id: &LintId|\n                                                            (*lint_id, level, span))"}, {"sha": "d15c902c7e1e3921840012713b7b81abe76e7727", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -170,7 +170,7 @@ impl<'a> CrateReader<'a> {\n     fn process_crate(&self, c: &ast::Crate) {\n         for a in c.attrs.iter().filter(|m| m.name() == \"link_args\") {\n             match a.value_str() {\n-                Some(ref linkarg) => self.sess.cstore.add_used_link_args(linkarg.get()),\n+                Some(ref linkarg) => self.sess.cstore.add_used_link_args(&linkarg),\n                 None => { /* fallthrough */ }\n             }\n         }\n@@ -184,15 +184,15 @@ impl<'a> CrateReader<'a> {\n                        ident, path_opt);\n                 let name = match *path_opt {\n                     Some((ref path_str, _)) => {\n-                        let name = path_str.get().to_string();\n+                        let name = path_str.to_string();\n                         validate_crate_name(Some(self.sess), &name[],\n                                             Some(i.span));\n                         name\n                     }\n-                    None => ident.get().to_string(),\n+                    None => ident.to_string(),\n                 };\n                 Some(CrateInfo {\n-                    ident: ident.get().to_string(),\n+                    ident: ident.to_string(),\n                     name: name,\n                     id: i.id,\n                     should_link: should_link(i),\n@@ -237,7 +237,7 @@ impl<'a> CrateReader<'a> {\n                     .collect::<Vec<&ast::Attribute>>();\n                 for m in &link_args {\n                     match m.value_str() {\n-                        Some(linkarg) => self.sess.cstore.add_used_link_args(linkarg.get()),\n+                        Some(linkarg) => self.sess.cstore.add_used_link_args(&linkarg),\n                         None => { /* fallthrough */ }\n                     }\n                 }\n@@ -289,7 +289,7 @@ impl<'a> CrateReader<'a> {\n                                 }\n                             };\n                             register_native_lib(self.sess, Some(m.span),\n-                                                n.get().to_string(), kind);\n+                                                n.to_string(), kind);\n                         }\n                         None => {}\n                     }"}, {"sha": "b151856e30941e3eb0dcc68dd2a2d159809481db", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -383,7 +383,7 @@ pub fn is_staged_api(cstore: &cstore::CStore, def: ast::DefId) -> bool {\n     let cdata = cstore.get_crate_data(def.krate);\n     let attrs = decoder::get_crate_attributes(cdata.data());\n     for attr in &attrs {\n-        if attr.name().get() == \"staged_api\" {\n+        if &attr.name()[] == \"staged_api\" {\n             match attr.node.value.node { ast::MetaWord(_) => return true, _ => (/*pass*/) }\n         }\n     }"}, {"sha": "37055f851b41ae743d2b145421f1469601ad2012", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -86,11 +86,11 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n }\n \n fn encode_name(rbml_w: &mut Encoder, name: ast::Name) {\n-    rbml_w.wr_tagged_str(tag_paths_data_name, token::get_name(name).get());\n+    rbml_w.wr_tagged_str(tag_paths_data_name, &token::get_name(name));\n }\n \n fn encode_impl_type_basename(rbml_w: &mut Encoder, name: ast::Ident) {\n-    rbml_w.wr_tagged_str(tag_item_impl_type_basename, token::get_ident(name).get());\n+    rbml_w.wr_tagged_str(tag_item_impl_type_basename, &token::get_ident(name));\n }\n \n pub fn encode_def_id(rbml_w: &mut Encoder, id: DefId) {\n@@ -372,7 +372,7 @@ fn encode_path<PI: Iterator<Item=PathElem>>(rbml_w: &mut Encoder, path: PI) {\n             ast_map::PathMod(_) => tag_path_elem_mod,\n             ast_map::PathName(_) => tag_path_elem_name\n         };\n-        rbml_w.wr_tagged_str(tag, token::get_name(pe.name()).get());\n+        rbml_w.wr_tagged_str(tag, &token::get_name(pe.name()));\n     }\n     rbml_w.end_tag();\n }\n@@ -915,7 +915,7 @@ fn encode_method_argument_names(rbml_w: &mut Encoder,\n         rbml_w.start_tag(tag_method_argument_name);\n         if let ast::PatIdent(_, ref path1, _) = arg.pat.node {\n             let name = token::get_ident(path1.node);\n-            rbml_w.writer.write_all(name.get().as_bytes());\n+            rbml_w.writer.write_all(name.as_bytes());\n         }\n         rbml_w.end_tag();\n     }\n@@ -1636,7 +1636,7 @@ fn encode_meta_item(rbml_w: &mut Encoder, mi: &ast::MetaItem) {\n       ast::MetaWord(ref name) => {\n         rbml_w.start_tag(tag_meta_item_word);\n         rbml_w.start_tag(tag_meta_item_name);\n-        rbml_w.writer.write_all(name.get().as_bytes());\n+        rbml_w.writer.write_all(name.as_bytes());\n         rbml_w.end_tag();\n         rbml_w.end_tag();\n       }\n@@ -1645,10 +1645,10 @@ fn encode_meta_item(rbml_w: &mut Encoder, mi: &ast::MetaItem) {\n           ast::LitStr(ref value, _) => {\n             rbml_w.start_tag(tag_meta_item_name_value);\n             rbml_w.start_tag(tag_meta_item_name);\n-            rbml_w.writer.write_all(name.get().as_bytes());\n+            rbml_w.writer.write_all(name.as_bytes());\n             rbml_w.end_tag();\n             rbml_w.start_tag(tag_meta_item_value);\n-            rbml_w.writer.write_all(value.get().as_bytes());\n+            rbml_w.writer.write_all(value.as_bytes());\n             rbml_w.end_tag();\n             rbml_w.end_tag();\n           }\n@@ -1658,7 +1658,7 @@ fn encode_meta_item(rbml_w: &mut Encoder, mi: &ast::MetaItem) {\n       ast::MetaList(ref name, ref items) => {\n         rbml_w.start_tag(tag_meta_item_list);\n         rbml_w.start_tag(tag_meta_item_name);\n-        rbml_w.writer.write_all(name.get().as_bytes());\n+        rbml_w.writer.write_all(name.as_bytes());\n         rbml_w.end_tag();\n         for inner_item in items {\n             encode_meta_item(rbml_w, &**inner_item);\n@@ -1695,7 +1695,7 @@ fn encode_paren_sugar(rbml_w: &mut Encoder, paren_sugar: bool) {\n fn encode_associated_type_names(rbml_w: &mut Encoder, names: &[ast::Name]) {\n     rbml_w.start_tag(tag_associated_type_names);\n     for &name in names {\n-        rbml_w.wr_tagged_str(tag_associated_type_name, token::get_name(name).get());\n+        rbml_w.wr_tagged_str(tag_associated_type_name, &token::get_name(name));\n     }\n     rbml_w.end_tag();\n }"}, {"sha": "dda34426bfc45b66225b35e88d6e8856815dd50c", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -249,11 +249,11 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n                             span_warn!(cx.tcx.sess, p.span, E0170,\n                                 \"pattern binding `{}` is named the same as one \\\n                                  of the variants of the type `{}`\",\n-                                token::get_ident(ident.node).get(), ty_to_string(cx.tcx, pat_ty));\n+                                &token::get_ident(ident.node), ty_to_string(cx.tcx, pat_ty));\n                             span_help!(cx.tcx.sess, p.span,\n                                 \"if you meant to match on a variant, \\\n                                  consider making the path in the pattern qualified: `{}::{}`\",\n-                                ty_to_string(cx.tcx, pat_ty), token::get_ident(ident.node).get());\n+                                ty_to_string(cx.tcx, pat_ty), &token::get_ident(ident.node));\n                         }\n                     }\n                 }"}, {"sha": "6bb0516c89b6fcd50af77a5f477e440f51e45c49", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -610,7 +610,7 @@ pub fn lit_to_const(lit: &ast::Lit) -> const_val {\n         ast::LitInt(n, ast::UnsignedIntLit(_)) => const_uint(n),\n         ast::LitFloat(ref n, _) |\n         ast::LitFloatUnsuffixed(ref n) => {\n-            const_float(n.get().parse::<f64>().unwrap() as f64)\n+            const_float(n.parse::<f64>().unwrap() as f64)\n         }\n         ast::LitBool(b) => const_bool(b)\n     }"}, {"sha": "a157d5d712b58759032dc29ab196277c0742fc85", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -321,7 +321,7 @@ fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {\n     for attr in lint::gather_attrs(attrs) {\n         match attr {\n             Ok((ref name, lint::Allow, _))\n-                if name.get() == dead_code => return true,\n+                if &name[] == dead_code => return true,\n             _ => (),\n         }\n     }"}, {"sha": "1b513a13588c9360bf2d628cc73c0c0598c79842", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -514,7 +514,6 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                             lifetime of captured variable `{}`...\",\n                             ty::local_var_name_str(self.tcx,\n                                                    upvar_id.var_id)\n-                                .get()\n                                 .to_string());\n                 note_and_explain_region(\n                     self.tcx,\n@@ -526,7 +525,6 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     &format!(\"...but `{}` is only valid for \",\n                             ty::local_var_name_str(self.tcx,\n                                                    upvar_id.var_id)\n-                                .get()\n                                 .to_string())[],\n                     sup,\n                     \"\");\n@@ -570,8 +568,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     &format!(\"captured variable `{}` does not \\\n                             outlive the enclosing closure\",\n                             ty::local_var_name_str(self.tcx,\n-                                                   id).get()\n-                                                      .to_string())[]);\n+                                                   id).to_string())[]);\n                 note_and_explain_region(\n                     self.tcx,\n                     \"captured variable is valid for \",\n@@ -959,7 +956,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n             // choice of lifetime name deterministic and thus easier to test.\n             let mut names = Vec::new();\n             for rn in region_names {\n-                let lt_name = token::get_name(*rn).get().to_string();\n+                let lt_name = token::get_name(*rn).to_string();\n                 names.push(lt_name);\n             }\n             names.sort();\n@@ -1438,15 +1435,15 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n             infer::EarlyBoundRegion(_, name) => {\n                 format!(\" for lifetime parameter `{}`\",\n-                        token::get_name(name).get())\n+                        &token::get_name(name))\n             }\n             infer::BoundRegionInCoherence(name) => {\n                 format!(\" for lifetime parameter `{}` in coherence check\",\n-                        token::get_name(name).get())\n+                        &token::get_name(name))\n             }\n             infer::UpvarRegion(ref upvar_id, _) => {\n                 format!(\" for capture of `{}` by closure\",\n-                        ty::local_var_name_str(self.tcx, upvar_id.var_id).get().to_string())\n+                        ty::local_var_name_str(self.tcx, upvar_id.var_id).to_string())\n             }\n         };\n \n@@ -1527,7 +1524,6 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     &format!(\n                         \"...so that closure can access `{}`\",\n                         ty::local_var_name_str(self.tcx, upvar_id.var_id)\n-                            .get()\n                             .to_string())[])\n             }\n             infer::InfStackClosure(span) => {\n@@ -1553,7 +1549,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                             does not outlive the enclosing closure\",\n                             ty::local_var_name_str(\n                                 self.tcx,\n-                                id).get().to_string())[]);\n+                                id).to_string())[]);\n             }\n             infer::IndexSlice(span) => {\n                 self.tcx.sess.span_note(\n@@ -1730,7 +1726,7 @@ impl LifeGiver {\n     fn with_taken(taken: &[ast::LifetimeDef]) -> LifeGiver {\n         let mut taken_ = HashSet::new();\n         for lt in taken {\n-            let lt_name = token::get_name(lt.lifetime.name).get().to_string();\n+            let lt_name = token::get_name(lt.lifetime.name).to_string();\n             taken_.insert(lt_name);\n         }\n         LifeGiver {"}, {"sha": "05969d4ea4398564863a576851fa188ebb58684c", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -149,7 +149,7 @@ impl<'a, 'v> Visitor<'v> for LanguageItemCollector<'a> {\n     fn visit_item(&mut self, item: &ast::Item) {\n         match extract(&item.attrs) {\n             Some(value) => {\n-                let item_index = self.item_refs.get(value.get()).map(|x| *x);\n+                let item_index = self.item_refs.get(&value[]).map(|x| *x);\n \n                 match item_index {\n                     Some(item_index) => {"}, {"sha": "fcc5d70a7a564b327203e6cf03966d308ad7d2ea", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -333,7 +333,7 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n     fn variable_name(&self, var: Variable) -> String {\n         match self.var_kinds[var.get()] {\n             Local(LocalInfo { ident: nm, .. }) | Arg(_, nm) => {\n-                token::get_ident(nm).get().to_string()\n+                token::get_ident(nm).to_string()\n             },\n             ImplicitRet => \"<implicit-ret>\".to_string(),\n             CleanExit => \"<clean-exit>\".to_string()"}, {"sha": "3e7aa0ff1d04e982f009434416c3634503a1d21a", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -1543,7 +1543,7 @@ impl<'tcx> Repr<'tcx> for InteriorKind {\n     fn repr(&self, _tcx: &ty::ctxt) -> String {\n         match *self {\n             InteriorField(NamedField(fld)) => {\n-                token::get_name(fld).get().to_string()\n+                token::get_name(fld).to_string()\n             }\n             InteriorField(PositionalField(i)) => format!(\"#{}\", i),\n             InteriorElement(_) => \"[]\".to_string(),"}, {"sha": "0ed672baf56e6656dfe0613dba898f791ca6305d", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -180,7 +180,7 @@ impl Index {\n     pub fn new(krate: &Crate) -> Index {\n         let mut staged_api = false;\n         for attr in &krate.attrs {\n-            if attr.name().get() == \"staged_api\" {\n+            if &attr.name()[] == \"staged_api\" {\n                 match attr.node.value.node {\n                     ast::MetaWord(_) => {\n                         attr::mark_used(attr);\n@@ -240,12 +240,12 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                 if !self.active_features.contains(feature) {\n                     let msg = match *reason {\n                         Some(ref r) => format!(\"use of unstable library feature '{}': {}\",\n-                                               feature.get(), r.get()),\n-                        None => format!(\"use of unstable library feature '{}'\", feature.get())\n+                                               &feature, &r),\n+                        None => format!(\"use of unstable library feature '{}'\", &feature)\n                     };\n \n                     emit_feature_warn(&self.tcx.sess.parse_sess.span_diagnostic,\n-                                      feature.get(), span, &msg[]);\n+                                      &feature, span, &msg);\n                 }\n             }\n             Some(Stability { level, ref feature, .. }) => {"}, {"sha": "2197cbeb85db4afb7ead1629b4cc500a468ea140", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -86,7 +86,7 @@ fn report_on_unimplemented<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                               }).collect::<HashMap<String, String>>();\n                 generic_map.insert(\"Self\".to_string(),\n                                    trait_ref.self_ty().user_string(infcx.tcx));\n-                let parser = Parser::new(istring.get());\n+                let parser = Parser::new(&istring);\n                 let mut errored = false;\n                 let err: String = parser.filter_map(|p| {\n                     match p {"}, {"sha": "b29a23924bb12d6b460d168e78ab7fd01cc03fca", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -4644,7 +4644,7 @@ pub fn field_idx_strict(tcx: &ctxt, name: ast::Name, fields: &[field])\n         \"no field named `{}` found in the list of fields `{:?}`\",\n         token::get_name(name),\n         fields.iter()\n-              .map(|f| token::get_name(f.name).get().to_string())\n+              .map(|f| token::get_name(f.name).to_string())\n               .collect::<Vec<String>>())[]);\n }\n "}, {"sha": "ee3fd681a005223af9a6df5537ce566c1b99f1bc", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -55,7 +55,7 @@ pub fn check_crate(krate: &ast::Crate,\n \n pub fn link_name(attrs: &[ast::Attribute]) -> Option<InternedString> {\n     lang_items::extract(attrs).and_then(|name| {\n-        $(if name.get() == stringify!($name) {\n+        $(if &name[] == stringify!($name) {\n             Some(InternedString::new(stringify!($sym)))\n         } else)* {\n             None\n@@ -110,7 +110,7 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n     fn visit_foreign_item(&mut self, i: &ast::ForeignItem) {\n         match lang_items::extract(&i.attrs) {\n             None => {}\n-            Some(lang_item) => self.register(lang_item.get(), i.span),\n+            Some(lang_item) => self.register(&lang_item, i.span),\n         }\n         visit::walk_foreign_item(self, i)\n     }"}, {"sha": "1a15e169d6ade49034084a707fe608c1e53efc04", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -109,7 +109,7 @@ impl<'a, 'v> Visitor<'v> for PluginLoader<'a> {\n         let mut reexport = HashSet::new();\n         for attr in &item.attrs {\n             let mut used = true;\n-            match attr.name().get() {\n+            match &attr.name()[] {\n                 \"phase\" => {\n                     self.sess.span_err(attr.span, \"#[phase] is deprecated; use \\\n                                        #[macro_use], #[plugin], and/or #[no_link]\");"}, {"sha": "c72b7fdf7ad4d63c04fbd526f62571365abc4bf1", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -217,7 +217,7 @@ pub fn region_to_string(cx: &ctxt, prefix: &str, space: bool, region: Region) ->\n     match region {\n         ty::ReScope(_) => prefix.to_string(),\n         ty::ReEarlyBound(_, _, _, name) => {\n-            token::get_name(name).get().to_string()\n+            token::get_name(name).to_string()\n         }\n         ty::ReLateBound(_, br) => bound_region_to_string(cx, prefix, space, br),\n         ty::ReFree(ref fr) => bound_region_to_string(cx, prefix, space, fr.bound_region),\n@@ -277,7 +277,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         match ident {\n             Some(i) => {\n                 s.push(' ');\n-                s.push_str(token::get_ident(i).get());\n+                s.push_str(&token::get_ident(i));\n             }\n             _ => { }\n         }\n@@ -1020,19 +1020,19 @@ impl<'tcx> Repr<'tcx> for ty::Method<'tcx> {\n \n impl<'tcx> Repr<'tcx> for ast::Name {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        token::get_name(*self).get().to_string()\n+        token::get_name(*self).to_string()\n     }\n }\n \n impl<'tcx> UserString<'tcx> for ast::Name {\n     fn user_string(&self, _tcx: &ctxt) -> String {\n-        token::get_name(*self).get().to_string()\n+        token::get_name(*self).to_string()\n     }\n }\n \n impl<'tcx> Repr<'tcx> for ast::Ident {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        token::get_ident(*self).get().to_string()\n+        token::get_ident(*self).to_string()\n     }\n }\n \n@@ -1220,7 +1220,7 @@ impl<'tcx, T> UserString<'tcx> for ty::Binder<T>\n                 }\n             })\n         });\n-        let names: Vec<_> = names.iter().map(|s| s.get()).collect();\n+        let names: Vec<_> = names.iter().map(|s| &s[]).collect();\n \n         let value_str = unbound_value.user_string(tcx);\n         if names.len() == 0 {\n@@ -1248,7 +1248,7 @@ impl<'tcx> UserString<'tcx> for Ty<'tcx> {\n \n impl<'tcx> UserString<'tcx> for ast::Ident {\n     fn user_string(&self, _tcx: &ctxt) -> String {\n-        token::get_name(self.name).get().to_string()\n+        token::get_name(self.name).to_string()\n     }\n }\n "}, {"sha": "c33d10bfbab39aaef7a08149d03304f76cfe0230", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -329,7 +329,7 @@ mod svh_visitor {\n             // macro invocations, namely macro_rules definitions,\n             // *can* appear as items, even in the expanded crate AST.\n \n-            if macro_name(mac).get() == \"macro_rules\" {\n+            if &macro_name(mac)[] == \"macro_rules\" {\n                 // Pretty-printing definition to a string strips out\n                 // surface artifacts (currently), such as the span\n                 // information, yielding a content-based hash."}, {"sha": "e86388a59349f312ac70fec177b3ead9d00dd905", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -906,7 +906,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         match loan_path.kind {\n             LpUpvar(ty::UpvarId{ var_id: id, closure_expr_id: _ }) |\n             LpVar(id) => {\n-                out.push_str(ty::local_var_name_str(self.tcx, id).get());\n+                out.push_str(&ty::local_var_name_str(self.tcx, id));\n             }\n \n             LpDowncast(ref lp_base, variant_def_id) => {\n@@ -923,7 +923,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 match fname {\n                     mc::NamedField(fname) => {\n                         out.push('.');\n-                        out.push_str(token::get_name(fname).get());\n+                        out.push_str(&token::get_name(fname));\n                     }\n                     mc::PositionalField(idx) => {\n                         out.push('.');"}, {"sha": "042718b4412e53b95c40b81aa051636ef1433490", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -914,7 +914,7 @@ pub fn build_output_filenames(input: &Input,\n \n             // If a crate name is present, we use it as the link name\n             let stem = sess.opts.crate_name.clone().or_else(|| {\n-                attr::find_crate_name(attrs).map(|n| n.get().to_string())\n+                attr::find_crate_name(attrs).map(|n| n.to_string())\n             }).unwrap_or(input.filestem());\n \n             OutputFilenames {"}, {"sha": "2f25f34a92ad07434340f8a6ab5b5fdaa85a910e", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -307,8 +307,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     ViewPathSimple(binding, ref full_path) => {\n                         let source_name =\n                             full_path.segments.last().unwrap().identifier.name;\n-                        if token::get_name(source_name).get() == \"mod\" ||\n-                           token::get_name(source_name).get() == \"self\" {\n+                        if &token::get_name(source_name)[] == \"mod\" ||\n+                           &token::get_name(source_name)[] == \"self\" {\n                             self.resolve_error(view_path.span,\n                                 \"`self` imports are only allowed within a { } list\");\n                         }\n@@ -1020,7 +1020,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                         self.handle_external_def(def,\n                                                  def_visibility,\n                                                  &*child_name_bindings,\n-                                                 token::get_name(name).get(),\n+                                                 &token::get_name(name),\n                                                  name,\n                                                  root);\n                     }"}, {"sha": "a261599a70656877ab8bc01597956f520f599f4a", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -1093,7 +1093,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             } else {\n                 result.push_str(\"::\")\n             }\n-            result.push_str(token::get_name(*name).get());\n+            result.push_str(&token::get_name(*name));\n         };\n         result\n     }\n@@ -1111,7 +1111,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                         -> String {\n         match subclass {\n             SingleImport(_, source) => {\n-                token::get_name(source).get().to_string()\n+                token::get_name(source).to_string()\n             }\n             GlobImport => \"*\".to_string()\n         }\n@@ -1708,7 +1708,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         debug!(\"(resolving glob import) writing resolution `{}` in `{}` \\\n                to `{}`\",\n-               token::get_name(name).get(),\n+               &token::get_name(name),\n                self.module_to_string(&*containing_module),\n                self.module_to_string(module_));\n \n@@ -1725,7 +1725,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         let msg = format!(\"a {} named `{}` has already been imported \\\n                                            in this module\",\n                                           namespace_name,\n-                                          token::get_name(name).get());\n+                                          &token::get_name(name));\n                         span_err!(self.session, import_directive.span, E0251, \"{}\", msg);\n                     } else {\n                         let target = Target::new(containing_module.clone(),\n@@ -1757,7 +1757,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     name: Name,\n                                     namespace: Namespace) {\n         debug!(\"check_for_conflicting_import: {}; target exists: {}\",\n-               token::get_name(name).get(),\n+               &token::get_name(name),\n                target.is_some());\n \n         match *target {\n@@ -1768,7 +1768,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     TypeNS => \"type\",\n                                     ValueNS => \"value\",\n                                   },\n-                                  token::get_name(name).get());\n+                                  &token::get_name(name));\n                 span_err!(self.session, import_span, E0252, \"{}\", &msg[]);\n             }\n             Some(_) | None => {}\n@@ -1804,7 +1804,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let msg = format!(\"import `{0}` conflicts with imported \\\n                                        crate in this module \\\n                                        (maybe you meant `use {0}::*`?)\",\n-                                      token::get_name(name).get());\n+                                      &token::get_name(name));\n                     span_err!(self.session, import_span, E0254, \"{}\", &msg[]);\n                 }\n                 Some(_) | None => {}\n@@ -1826,7 +1826,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 if let Some(ref value) = *name_bindings.value_def.borrow() {\n                     let msg = format!(\"import `{}` conflicts with value \\\n                                        in this module\",\n-                                      token::get_name(name).get());\n+                                      &token::get_name(name));\n                     span_err!(self.session, import_span, E0255, \"{}\", &msg[]);\n                     if let Some(span) = value.value_span {\n                         self.session.span_note(span,\n@@ -1844,7 +1844,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         None => {\n                             let msg = format!(\"import `{}` conflicts with type in \\\n                                                this module\",\n-                                              token::get_name(name).get());\n+                                              &token::get_name(name));\n                             span_err!(self.session, import_span, E0256, \"{}\", &msg[]);\n                             if let Some(span) = ty.type_span {\n                                 self.session.span_note(span,\n@@ -1866,7 +1866,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 _ => {\n                                     let msg = format!(\"import `{}` conflicts with existing \\\n                                                        submodule\",\n-                                                      token::get_name(name).get());\n+                                                      &token::get_name(name));\n                                     span_err!(self.session, import_span, E0258, \"{}\", &msg[]);\n                                     if let Some(span) = ty.type_span {\n                                         self.session.span_note(span,\n@@ -1892,7 +1892,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 span_err!(self.session, span, E0259,\n                           \"an external crate named `{}` has already \\\n                                    been imported into this module\",\n-                                  token::get_name(name).get());\n+                                  &token::get_name(name));\n         }\n     }\n \n@@ -1906,7 +1906,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                           \"the name `{}` conflicts with an external \\\n                                    crate that has been imported into this \\\n                                    module\",\n-                                  token::get_name(name).get());\n+                                  &token::get_name(name));\n         }\n     }\n \n@@ -1955,7 +1955,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let module_name = self.module_to_string(&*search_module);\n                     let mut span = span;\n                     let msg = if \"???\" == &module_name[] {\n-                        span.hi = span.lo + Pos::from_usize(segment_name.get().len());\n+                        span.hi = span.lo + Pos::from_usize(segment_name.len());\n \n                         match search_parent_externals(name,\n                                                      &self.current_module) {\n@@ -2368,11 +2368,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let mut containing_module;\n         let mut i;\n         let first_module_path_string = token::get_name(module_path[0]);\n-        if \"self\" == first_module_path_string.get() {\n+        if \"self\" == &first_module_path_string[] {\n             containing_module =\n                 self.get_nearest_normal_module_parent_or_self(module_);\n             i = 1;\n-        } else if \"super\" == first_module_path_string.get() {\n+        } else if \"super\" == &first_module_path_string[] {\n             containing_module =\n                 self.get_nearest_normal_module_parent_or_self(module_);\n             i = 0;  // We'll handle `super` below.\n@@ -2383,7 +2383,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // Now loop through all the `super`s we find.\n         while i < module_path.len() {\n             let string = token::get_name(module_path[i]);\n-            if \"super\" != string.get() {\n+            if \"super\" != &string[] {\n                 break\n             }\n             debug!(\"(resolving module prefix) resolving `super` at {}\",\n@@ -2417,7 +2417,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                               allow_private_imports: bool)\n                               -> ResolveResult<(Target, bool)> {\n         debug!(\"(resolving name in module) resolving `{}` in `{}`\",\n-               token::get_name(name).get(),\n+               &token::get_name(name),\n                self.module_to_string(&*module_));\n \n         // First, check the direct children of the module.\n@@ -2493,7 +2493,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // We're out of luck.\n         debug!(\"(resolving name in module) failed to resolve `{}`\",\n-               token::get_name(name).get());\n+               &token::get_name(name));\n         return Failed(None);\n     }\n \n@@ -4372,7 +4372,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         let mut smallest = 0;\n         for (i, other) in maybes.iter().enumerate() {\n-            values[i] = lev_distance(name, other.get());\n+            values[i] = lev_distance(name, &other);\n \n             if values[i] <= values[smallest] {\n                 smallest = i;\n@@ -4383,9 +4383,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             values[smallest] != uint::MAX &&\n             values[smallest] < name.len() + 2 &&\n             values[smallest] <= max_distance &&\n-            name != maybes[smallest].get() {\n+            name != &maybes[smallest][] {\n \n-            Some(maybes[smallest].get().to_string())\n+            Some(maybes[smallest].to_string())\n \n         } else {\n             None\n@@ -4475,7 +4475,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     false // Stop advancing\n                                 });\n \n-                                if method_scope && token::get_name(self.self_name).get()\n+                                if method_scope && &token::get_name(self.self_name)[]\n                                                                    == path_name {\n                                         self.resolve_error(\n                                             expr.span,"}, {"sha": "9f26e9182ab1e5d04e820dd4fa9bfba46f71ce46", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -141,7 +141,7 @@ pub fn find_crate_name(sess: Option<&Session>,\n     if let Some(sess) = sess {\n         if let Some(ref s) = sess.opts.crate_name {\n             if let Some((attr, ref name)) = attr_crate_name {\n-                if *s != name.get() {\n+                if *s != &name[] {\n                     let msg = format!(\"--crate-name and #[crate_name] are \\\n                                        required to match, but `{}` != `{}`\",\n                                       s, name);\n@@ -153,7 +153,7 @@ pub fn find_crate_name(sess: Option<&Session>,\n     }\n \n     if let Some((attr, s)) = attr_crate_name {\n-        return validate(s.get().to_string(), Some(attr.span));\n+        return validate(s.to_string(), Some(attr.span));\n     }\n     if let Input::File(ref path) = *input {\n         if let Some(s) = path.filestem_str() {\n@@ -293,7 +293,7 @@ pub fn mangle<PI: Iterator<Item=PathElem>>(path: PI,\n \n     // First, connect each component with <len, name> pairs.\n     for e in path {\n-        push(&mut n, &token::get_name(e.name()).get()[])\n+        push(&mut n, &token::get_name(e.name()))\n     }\n \n     match hash {"}, {"sha": "e80564097df2302148bb4c390567652504354cdd", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -355,7 +355,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             },\n         };\n \n-        let qualname = format!(\"{}::{}\", qualname, get_ident(method.pe_ident()).get());\n+        let qualname = format!(\"{}::{}\", qualname, &get_ident(method.pe_ident()));\n         let qualname = &qualname[];\n \n         // record the decl for this def (if it has one)\n@@ -436,7 +436,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     Some(sub_span) => self.fmt.field_str(field.span,\n                                                          Some(sub_span),\n                                                          field.node.id,\n-                                                         &name.get()[],\n+                                                         &name[],\n                                                          &qualname[],\n                                                          &typ[],\n                                                          scope_id),\n@@ -525,7 +525,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.fmt.static_str(item.span,\n                             sub_span,\n                             item.id,\n-                            get_ident(item.ident).get(),\n+                            &get_ident(item.ident),\n                             &qualname[],\n                             &value[],\n                             &ty_to_string(&*typ)[],\n@@ -548,7 +548,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.fmt.static_str(item.span,\n                             sub_span,\n                             item.id,\n-                            get_ident(item.ident).get(),\n+                            &get_ident(item.ident),\n                             &qualname[],\n                             \"\",\n                             &ty_to_string(&*typ)[],\n@@ -607,7 +607,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         }\n         for variant in &enum_definition.variants {\n             let name = get_ident(variant.node.name);\n-            let name = name.get();\n+            let name = &name;\n             let mut qualname = enum_name.clone();\n             qualname.push_str(\"::\");\n             qualname.push_str(name);\n@@ -1094,7 +1094,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                                sub_span,\n                                                item.id,\n                                                mod_id,\n-                                               get_ident(ident).get(),\n+                                               &get_ident(ident),\n                                                self.cur_scope);\n                         self.write_sub_paths_truncated(path, true);\n                     }\n@@ -1149,9 +1149,9 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n             }\n             ast::ItemExternCrate(ref s) => {\n                 let name = get_ident(item.ident);\n-                let name = name.get();\n+                let name = &name;\n                 let location = match *s {\n-                    Some((ref s, _)) => s.get().to_string(),\n+                    Some((ref s, _)) => s.to_string(),\n                     None => name.to_string(),\n                 };\n                 let alias_span = self.span.span_for_last_ident(item.span);\n@@ -1259,7 +1259,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                     },\n                 };\n \n-                qualname.push_str(get_ident(method_type.ident).get());\n+                qualname.push_str(&get_ident(method_type.ident));\n                 let qualname = &qualname[];\n \n                 let sub_span = self.span.sub_span_after_keyword(method_type.span, keywords::Fn);\n@@ -1541,7 +1541,7 @@ pub fn process_crate(sess: &Session,\n \n     assert!(analysis.glob_map.is_some());\n     let cratename = match attr::find_crate_name(&krate.attrs[]) {\n-        Some(name) => name.get().to_string(),\n+        Some(name) => name.to_string(),\n         None => {\n             info!(\"Could not find crate name, using 'unknown_crate'\");\n             String::from_str(\"unknown_crate\")"}, {"sha": "e419be65fc4cc33f1a141aff8bf5e2dbf775d8c1", "filename": "src/librustc_trans/trans/asm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fasm.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -77,13 +77,13 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n     fcx.pop_custom_cleanup_scope(temp_scope);\n \n     let mut constraints = constraints.iter()\n-                                     .map(|s| s.get().to_string())\n+                                     .map(|s| s.to_string())\n                                      .chain(ext_constraints.into_iter())\n                                      .collect::<Vec<String>>()\n                                      .connect(\",\");\n \n     let mut clobbers = ia.clobbers.iter()\n-                                  .map(|s| format!(\"~{{{}}}\", s.get()))\n+                                  .map(|s| format!(\"~{{{}}}\", &s))\n                                   .collect::<Vec<String>>()\n                                   .connect(\",\");\n     let more_clobbers = get_clobbers();\n@@ -120,7 +120,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n         ast::AsmIntel => llvm::AD_Intel\n     };\n \n-    let asm = CString::from_slice(ia.asm.get().as_bytes());\n+    let asm = CString::from_slice(ia.asm.as_bytes());\n     let constraints = CString::from_slice(constraints.as_bytes());\n     let r = InlineAsmCall(bcx,\n                           asm.as_ptr(),"}, {"sha": "0edc2c213fb1d7cc0f4608a9540018475bb449a9", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -444,7 +444,7 @@ pub fn set_llvm_fn_attrs(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: Val\n \n     for attr in attrs {\n         let mut used = true;\n-        match attr.name().get() {\n+        match &attr.name()[] {\n             \"no_stack_check\" => unset_split_stack(llfn),\n             \"no_split_stack\" => {\n                 unset_split_stack(llfn);\n@@ -2254,7 +2254,7 @@ pub fn update_linkage(ccx: &CrateContext,\n         let item = ccx.tcx().map.get(id);\n         if let ast_map::NodeItem(i) = item {\n             if let Some(name) = attr::first_attr_value_str_by_name(&i.attrs, \"linkage\") {\n-                if let Some(linkage) = llvm_linkage_by_name(name.get()) {\n+                if let Some(linkage) = llvm_linkage_by_name(&name) {\n                     llvm::SetLinkage(llval, linkage);\n                 } else {\n                     ccx.sess().span_fatal(i.span, \"invalid linkage specified\");\n@@ -2727,15 +2727,15 @@ fn exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, id: ast::NodeId,\n \n     match attr::first_attr_value_str_by_name(attrs, \"export_name\") {\n         // Use provided name\n-        Some(name) => name.get().to_string(),\n+        Some(name) => name.to_string(),\n \n         _ => ccx.tcx().map.with_path(id, |path| {\n             if attr::contains_name(attrs, \"no_mangle\") {\n                 // Don't mangle\n                 path.last().unwrap().to_string()\n             } else {\n                 match weak_lang_items::link_name(attrs) {\n-                    Some(name) => name.get().to_string(),\n+                    Some(name) => name.to_string(),\n                     None => {\n                         // Usual name mangling\n                         mangle_exported_name(ccx, path, ty, id)\n@@ -2830,12 +2830,12 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             match attr::first_attr_value_str_by_name(&i.attrs[],\n                                                      \"link_section\") {\n                 Some(sect) => {\n-                    if contains_null(sect.get()) {\n+                    if contains_null(&sect) {\n                         ccx.sess().fatal(&format!(\"Illegal null byte in link_section value: `{}`\",\n-                                                 sect.get())[]);\n+                                                 &sect)[]);\n                     }\n                     unsafe {\n-                        let buf = CString::from_slice(sect.get().as_bytes());\n+                        let buf = CString::from_slice(sect.as_bytes());\n                         llvm::LLVMSetSection(v, buf.as_ptr());\n                     }\n                 },\n@@ -2875,7 +2875,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     let abi = ccx.tcx().map.get_foreign_abi(id);\n                     let ty = ty::node_id_to_type(ccx.tcx(), ni.id);\n                     let name = foreign::link_name(&*ni);\n-                    foreign::register_foreign_item_fn(ccx, abi, ty, &name.get()[])\n+                    foreign::register_foreign_item_fn(ccx, abi, ty, &name)\n                 }\n                 ast::ForeignItemStatic(..) => {\n                     foreign::register_static(ccx, &*ni)"}, {"sha": "87b7f413fd1e55b112cc1259f275766caba222f8", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -590,7 +590,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n     pub fn sess(&self) -> &'blk Session { self.fcx.ccx.sess() }\n \n     pub fn ident(&self, ident: Ident) -> String {\n-        token::get_ident(ident).get().to_string()\n+        token::get_ident(ident).to_string()\n     }\n \n     pub fn node_id_to_string(&self, id: ast::NodeId) -> String {\n@@ -834,8 +834,8 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n         }\n \n         let sc = llvm::LLVMConstStringInContext(cx.llcx(),\n-                                                s.get().as_ptr() as *const c_char,\n-                                                s.get().len() as c_uint,\n+                                                s.as_ptr() as *const c_char,\n+                                                s.len() as c_uint,\n                                                 !null_terminated as Bool);\n \n         let gsym = token::gensym(\"str\");\n@@ -853,7 +853,7 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n // NB: Do not use `do_spill_noroot` to make this into a constant string, or\n // you will be kicked off fast isel. See issue #4352 for an example of this.\n pub fn C_str_slice(cx: &CrateContext, s: InternedString) -> ValueRef {\n-    let len = s.get().len();\n+    let len = s.len();\n     let cs = consts::ptrcast(C_cstr(cx, s, false), Type::i8p(cx));\n     C_named_struct(cx.tn().find_type(\"str_slice\").unwrap(), &[cs, C_uint(cx, len)])\n }"}, {"sha": "278323d186b21cb88de133cf3726ab2c71e206e7", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -58,13 +58,13 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n             }\n         }\n         ast::LitFloat(ref fs, t) => {\n-            C_floating(fs.get(), Type::float_from_ty(cx, t))\n+            C_floating(&fs, Type::float_from_ty(cx, t))\n         }\n         ast::LitFloatUnsuffixed(ref fs) => {\n             let lit_float_ty = ty::node_id_to_type(cx.tcx(), e.id);\n             match lit_float_ty.sty {\n                 ty::ty_float(t) => {\n-                    C_floating(fs.get(), Type::float_from_ty(cx, t))\n+                    C_floating(&fs, Type::float_from_ty(cx, t))\n                 }\n                 _ => {\n                     cx.sess().span_bug(lit.span,"}, {"sha": "e5e9ac6a6c209facdabb2cba3a9dab97a37a51a5", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -802,7 +802,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     let variable_type = ty::node_id_to_type(cx.tcx(), node_id);\n     let type_metadata = type_metadata(cx, variable_type, span);\n     let namespace_node = namespace_for_item(cx, ast_util::local_def(node_id));\n-    let var_name = token::get_ident(ident).get().to_string();\n+    let var_name = token::get_ident(ident).to_string();\n     let linkage_name =\n         namespace_node.mangled_name_of_contained_item(&var_name[]);\n     let var_scope = namespace_node.scope;\n@@ -1350,7 +1350,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     // Get_template_parameters() will append a `<...>` clause to the function\n     // name if necessary.\n-    let mut function_name = String::from_str(token::get_ident(ident).get());\n+    let mut function_name = String::from_str(&token::get_ident(ident));\n     let template_parameters = get_template_parameters(cx,\n                                                       generics,\n                                                       param_substs,\n@@ -1499,7 +1499,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 let ident = special_idents::type_self;\n \n                 let ident = token::get_ident(ident);\n-                let name = CString::from_slice(ident.get().as_bytes());\n+                let name = CString::from_slice(ident.as_bytes());\n                 let param_metadata = unsafe {\n                     llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n                         DIB(cx),\n@@ -1533,7 +1533,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             if cx.sess().opts.debuginfo == FullDebugInfo {\n                 let actual_type_metadata = type_metadata(cx, actual_type, codemap::DUMMY_SP);\n                 let ident = token::get_ident(ident);\n-                let name = CString::from_slice(ident.get().as_bytes());\n+                let name = CString::from_slice(ident.as_bytes());\n                 let param_metadata = unsafe {\n                     llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n                         DIB(cx),\n@@ -1656,7 +1656,7 @@ fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         CapturedVariable => (0, DW_TAG_auto_variable)\n     };\n \n-    let name = CString::from_slice(name.get().as_bytes());\n+    let name = CString::from_slice(name.as_bytes());\n     match (variable_access, [].as_slice()) {\n         (DirectVariable { alloca }, address_operations) |\n         (IndirectVariable {alloca, address_operations}, _) => {\n@@ -1993,7 +1993,7 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n             let name = if field.name == special_idents::unnamed_field.name {\n                 \"\".to_string()\n             } else {\n-                token::get_name(field.name).get().to_string()\n+                token::get_name(field.name).to_string()\n             };\n \n             let offset = if self.is_simd {\n@@ -2223,7 +2223,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 // MemberDescription of the struct's single field.\n                 let sole_struct_member_description = MemberDescription {\n                     name: match non_null_variant.arg_names {\n-                        Some(ref names) => token::get_ident(names[0]).get().to_string(),\n+                        Some(ref names) => token::get_ident(names[0]).to_string(),\n                         None => \"\".to_string()\n                     },\n                     llvm_type: non_null_llvm_type,\n@@ -2237,13 +2237,13 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                                                       .get_unique_type_id_of_enum_variant(\n                                                           cx,\n                                                           self.enum_type,\n-                                                          non_null_variant_name.get());\n+                                                          &non_null_variant_name);\n \n                 // Now we can create the metadata of the artificial struct\n                 let artificial_struct_metadata =\n                     composite_type_metadata(cx,\n                                             artificial_struct_llvm_type,\n-                                            non_null_variant_name.get(),\n+                                            &non_null_variant_name,\n                                             unique_type_id,\n                                             &[sole_struct_member_description],\n                                             self.containing_scope,\n@@ -2373,7 +2373,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     // Could do some consistency checks here: size, align, field count, discr type\n \n     let variant_name = token::get_name(variant_info.name);\n-    let variant_name = variant_name.get();\n+    let variant_name = &variant_name;\n     let unique_type_id = debug_context(cx).type_map\n                                           .borrow_mut()\n                                           .get_unique_type_id_of_enum_variant(\n@@ -2392,7 +2392,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         Some(ref names) => {\n             names.iter()\n                  .map(|ident| {\n-                     token::get_ident(*ident).get().to_string()\n+                     token::get_ident(*ident).to_string()\n                  }).collect()\n         }\n         None => variant_info.args.iter().map(|_| \"\".to_string()).collect()\n@@ -2443,7 +2443,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         .iter()\n         .map(|v| {\n             let token = token::get_name(v.name);\n-            let name = CString::from_slice(token.get().as_bytes());\n+            let name = CString::from_slice(token.as_bytes());\n             unsafe {\n                 llvm::LLVMDIBuilderCreateEnumerator(\n                     DIB(cx),\n@@ -2473,7 +2473,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                   codemap::DUMMY_SP);\n                 let discriminant_name = get_enum_discriminant_name(cx, enum_def_id);\n \n-                let name = CString::from_slice(discriminant_name.get().as_bytes());\n+                let name = CString::from_slice(discriminant_name.as_bytes());\n                 let discriminant_type_metadata = unsafe {\n                     llvm::LLVMDIBuilderCreateEnumerationType(\n                         DIB(cx),\n@@ -3126,7 +3126,7 @@ fn contains_nodebug_attribute(attributes: &[ast::Attribute]) -> bool {\n     attributes.iter().any(|attr| {\n         let meta_item: &ast::MetaItem = &*attr.node.value;\n         match meta_item.node {\n-            ast::MetaWord(ref value) => value.get() == \"no_debug\",\n+            ast::MetaWord(ref value) => &value[] == \"no_debug\",\n             _ => false\n         }\n     })\n@@ -3847,7 +3847,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 let mut path_element_count = 0;\n                 for path_element in path {\n                     let name = token::get_name(path_element.name());\n-                    output.push_str(name.get());\n+                    output.push_str(&name);\n                     output.push_str(\"::\");\n                     path_element_count += 1;\n                 }\n@@ -3862,7 +3862,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 let name = token::get_name(path.last()\n                                                .expect(\"debuginfo: Empty item path?\")\n                                                .name());\n-                output.push_str(name.get());\n+                output.push_str(&name);\n             }\n         });\n     }\n@@ -3912,8 +3912,8 @@ impl NamespaceTreeNode {\n                 None => {}\n             }\n             let string = token::get_name(node.name);\n-            output.push_str(&format!(\"{}\", string.get().len())[]);\n-            output.push_str(string.get());\n+            output.push_str(&format!(\"{}\", string.len())[]);\n+            output.push_str(&string);\n         }\n \n         let mut name = String::from_str(\"_ZN\");\n@@ -3970,7 +3970,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTree\n                     };\n                     let namespace_name = token::get_name(name);\n                     let namespace_name = CString::from_slice(namespace_name\n-                                                                .get().as_bytes());\n+                                                                .as_bytes());\n                     let scope = unsafe {\n                         llvm::LLVMDIBuilderCreateNameSpace(\n                             DIB(cx),"}, {"sha": "80b27a8b9859f4c85f4a961b459d23b09fe6db2e", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -118,7 +118,7 @@ pub fn register_static(ccx: &CrateContext,\n         // static and call it a day. Some linkages (like weak) will make it such\n         // that the static actually has a null value.\n         Some(name) => {\n-            let linkage = match llvm_linkage_by_name(name.get()) {\n+            let linkage = match llvm_linkage_by_name(&name) {\n                 Some(linkage) => linkage,\n                 None => {\n                     ccx.sess().span_fatal(foreign_item.span,\n@@ -134,7 +134,7 @@ pub fn register_static(ccx: &CrateContext,\n             };\n             unsafe {\n                 // Declare a symbol `foo` with the desired linkage.\n-                let buf = CString::from_slice(ident.get().as_bytes());\n+                let buf = CString::from_slice(ident.as_bytes());\n                 let g1 = llvm::LLVMAddGlobal(ccx.llmod(), llty2.to_ref(),\n                                              buf.as_ptr());\n                 llvm::SetLinkage(g1, linkage);\n@@ -146,7 +146,7 @@ pub fn register_static(ccx: &CrateContext,\n                 // `extern_with_linkage_foo` will instead be initialized to\n                 // zero.\n                 let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n-                real_name.push_str(ident.get());\n+                real_name.push_str(&ident);\n                 let real_name = CString::from_vec(real_name.into_bytes());\n                 let g2 = llvm::LLVMAddGlobal(ccx.llmod(), llty.to_ref(),\n                                              real_name.as_ptr());\n@@ -157,7 +157,7 @@ pub fn register_static(ccx: &CrateContext,\n         }\n         None => unsafe {\n             // Generate an external declaration.\n-            let buf = CString::from_slice(ident.get().as_bytes());\n+            let buf = CString::from_slice(ident.as_bytes());\n             llvm::LLVMAddGlobal(ccx.llmod(), llty.to_ref(), buf.as_ptr())\n         }\n     }\n@@ -468,7 +468,7 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n                     }\n \n                     register_foreign_item_fn(ccx, abi, ty,\n-                                             &lname.get()[]);\n+                                             &lname);\n                     // Unlike for other items, we shouldn't call\n                     // `base::update_linkage` here.  Foreign items have\n                     // special linkage requirements, which are handled\n@@ -478,7 +478,7 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n         }\n \n         ccx.item_symbols().borrow_mut().insert(foreign_item.id,\n-                                             lname.get().to_string());\n+                                             lname.to_string());\n     }\n }\n "}, {"sha": "5687247561e9cfe13f6e1b4bfb47031e7b6c2aec", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -36,7 +36,7 @@ use syntax::parse::token;\n use util::ppaux::{Repr, ty_to_string};\n \n pub fn get_simple_intrinsic(ccx: &CrateContext, item: &ast::ForeignItem) -> Option<ValueRef> {\n-    let name = match token::get_ident(item.ident).get() {\n+    let name = match &token::get_ident(item.ident)[] {\n         \"sqrtf32\" => \"llvm.sqrt.f32\",\n         \"sqrtf64\" => \"llvm.sqrt.f64\",\n         \"powif32\" => \"llvm.powi.f32\",\n@@ -166,7 +166,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let name = token::get_ident(foreign_item.ident);\n \n     // For `transmute` we can just trans the input expr directly into dest\n-    if name.get() == \"transmute\" {\n+    if &name[] == \"transmute\" {\n         let llret_ty = type_of::type_of(ccx, ret_ty.unwrap());\n         match args {\n             callee::ArgExprs(arg_exprs) => {\n@@ -274,13 +274,13 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let call_debug_location = DebugLoc::At(call_info.id, call_info.span);\n \n     // These are the only intrinsic functions that diverge.\n-    if name.get() == \"abort\" {\n+    if &name[] == \"abort\" {\n         let llfn = ccx.get_intrinsic(&(\"llvm.trap\"));\n         Call(bcx, llfn, &[], None, call_debug_location);\n         fcx.pop_and_trans_custom_cleanup_scope(bcx, cleanup_scope);\n         Unreachable(bcx);\n         return Result::new(bcx, C_undef(Type::nil(ccx).ptr_to()));\n-    } else if name.get() == \"unreachable\" {\n+    } else if &name[] == \"unreachable\" {\n         fcx.pop_and_trans_custom_cleanup_scope(bcx, cleanup_scope);\n         Unreachable(bcx);\n         return Result::new(bcx, C_nil(ccx));\n@@ -307,7 +307,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     };\n \n     let simple = get_simple_intrinsic(ccx, &*foreign_item);\n-    let llval = match (simple, name.get()) {\n+    let llval = match (simple, &name[]) {\n         (Some(llfn), _) => {\n             Call(bcx, llfn, &llargs, None, call_debug_location)\n         }"}, {"sha": "bce93cbf2eb9d3971c55d6bcee3f32220c5e418a", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -209,7 +209,7 @@ pub fn trans_lit_str<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     match dest {\n         Ignore => bcx,\n         SaveIn(lldest) => {\n-            let bytes = str_lit.get().len();\n+            let bytes = str_lit.len();\n             let llbytes = C_uint(bcx.ccx(), bytes);\n             let llcstr = C_cstr(bcx.ccx(), str_lit, false);\n             let llcstr = consts::ptrcast(llcstr, Type::i8p(bcx.ccx()));\n@@ -242,7 +242,7 @@ pub fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     match dest {\n                         Ignore => return bcx,\n                         SaveIn(lldest) => {\n-                            let bytes = s.get().len();\n+                            let bytes = s.len();\n                             let llbytes = C_uint(bcx.ccx(), bytes);\n                             let llcstr = C_cstr(bcx.ccx(), (*s).clone(), false);\n                             base::call_memcpy(bcx,\n@@ -343,7 +343,7 @@ pub fn elements_required(bcx: Block, content_expr: &ast::Expr) -> uint {\n     match content_expr.node {\n         ast::ExprLit(ref lit) => {\n             match lit.node {\n-                ast::LitStr(ref s, _) => s.get().len(),\n+                ast::LitStr(ref s, _) => s.len(),\n                 _ => {\n                     bcx.tcx().sess.span_bug(content_expr.span,\n                                             \"unexpected evec content\")"}, {"sha": "60771d126b51bc1274778fc9a39d7a632c7f19ef", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -1160,12 +1160,11 @@ pub fn ast_ty_to_ty<'tcx>(\n                                                    using the syntax `<Type \\\n                                                    as {}>::{}`\",\n                                                   path_str,\n-                                                  token::get_ident(\n+                                                  &token::get_ident(\n                                                       path.segments\n                                                           .last()\n                                                           .unwrap()\n-                                                          .identifier)\n-                                                  .get());\n+                                                          .identifier));\n                         this.tcx().types.err\n                     }\n                     def::DefAssociatedPath(provenance, assoc_ident) => {"}, {"sha": "9c0d6f7dae386c48de85dc3c8e9d325661121d6c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -805,7 +805,7 @@ fn check_trait_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         a.check_name(\"rustc_on_unimplemented\")\n     }) {\n         if let Some(ref istring) = attr.value_str() {\n-            let parser = Parser::new(istring.get());\n+            let parser = Parser::new(&istring);\n             let types = &*generics.ty_params;\n             for token in parser {\n                 match token {\n@@ -3104,7 +3104,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                  tcx : &ty::ctxt<'tcx>,\n                                  skip : Vec<&str>) {\n         let ident = token::get_ident(field.node);\n-        let name = ident.get();\n+        let name = &ident;\n         // only find fits with at least one matching letter\n         let mut best_dist = name.len();\n         let fields = ty::lookup_struct_fields(tcx, id);\n@@ -3286,7 +3286,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     let (_, seen) = class_field_map[name];\n                     if !seen {\n                         missing_fields.push(\n-                            format!(\"`{}`\", token::get_name(name).get()))\n+                            format!(\"`{}`\", &token::get_name(name)))\n                     }\n                 }\n \n@@ -5223,8 +5223,8 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n \n     let tcx = ccx.tcx;\n     let name = token::get_ident(it.ident);\n-    let (n_tps, inputs, output) = if name.get().starts_with(\"atomic_\") {\n-        let split : Vec<&str> = name.get().split('_').collect();\n+    let (n_tps, inputs, output) = if name.starts_with(\"atomic_\") {\n+        let split : Vec<&str> = name.split('_').collect();\n         assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n \n         //We only care about the operation here\n@@ -5253,10 +5253,10 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             }\n         };\n         (n_tps, inputs, ty::FnConverging(output))\n-    } else if name.get() == \"abort\" || name.get() == \"unreachable\" {\n+    } else if &name[] == \"abort\" || &name[] == \"unreachable\" {\n         (0, Vec::new(), ty::FnDiverging)\n     } else {\n-        let (n_tps, inputs, output) = match name.get() {\n+        let (n_tps, inputs, output) = match &name[] {\n             \"breakpoint\" => (0, Vec::new(), ty::mk_nil(tcx)),\n             \"size_of\" |\n             \"pref_align_of\" | \"min_align_of\" => (1, Vec::new(), ccx.tcx.types.uint),"}, {"sha": "fca40df7aaa6af71a3a032d8bbbbbaf125d0c6e2", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -405,7 +405,7 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n                     let span = self.reason.span(self.tcx);\n                     span_err!(self.tcx.sess, span, E0104,\n                         \"cannot resolve lifetime for captured variable `{}`: {}\",\n-                        ty::local_var_name_str(self.tcx, upvar_id.var_id).get().to_string(),\n+                        ty::local_var_name_str(self.tcx, upvar_id.var_id).to_string(),\n                         infer::fixup_err_to_string(e));\n                 }\n "}, {"sha": "3641370d818490b96900c04a5184e667e689fdf5", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -410,12 +410,12 @@ pub enum Attribute {\n impl Clean<Attribute> for ast::MetaItem {\n     fn clean(&self, cx: &DocContext) -> Attribute {\n         match self.node {\n-            ast::MetaWord(ref s) => Word(s.get().to_string()),\n+            ast::MetaWord(ref s) => Word(s.to_string()),\n             ast::MetaList(ref s, ref l) => {\n-                List(s.get().to_string(), l.clean(cx))\n+                List(s.to_string(), l.clean(cx))\n             }\n             ast::MetaNameValue(ref s, ref v) => {\n-                NameValue(s.get().to_string(), lit_to_string(v))\n+                NameValue(s.to_string(), lit_to_string(v))\n             }\n         }\n     }\n@@ -700,19 +700,19 @@ impl Lifetime {\n \n impl Clean<Lifetime> for ast::Lifetime {\n     fn clean(&self, _: &DocContext) -> Lifetime {\n-        Lifetime(token::get_name(self.name).get().to_string())\n+        Lifetime(token::get_name(self.name).to_string())\n     }\n }\n \n impl Clean<Lifetime> for ast::LifetimeDef {\n     fn clean(&self, _: &DocContext) -> Lifetime {\n-        Lifetime(token::get_name(self.lifetime.name).get().to_string())\n+        Lifetime(token::get_name(self.lifetime.name).to_string())\n     }\n }\n \n impl Clean<Lifetime> for ty::RegionParameterDef {\n     fn clean(&self, _: &DocContext) -> Lifetime {\n-        Lifetime(token::get_name(self.name).get().to_string())\n+        Lifetime(token::get_name(self.name).to_string())\n     }\n }\n \n@@ -721,7 +721,7 @@ impl Clean<Option<Lifetime>> for ty::Region {\n         match *self {\n             ty::ReStatic => Some(Lifetime::statik()),\n             ty::ReLateBound(_, ty::BrNamed(_, name)) =>\n-                Some(Lifetime(token::get_name(name).get().to_string())),\n+                Some(Lifetime(token::get_name(name).to_string())),\n             ty::ReEarlyBound(_, _, _, name) => Some(Lifetime(name.clean(cx))),\n \n             ty::ReLateBound(..) |\n@@ -1953,20 +1953,20 @@ fn path_to_string(p: &ast::Path) -> String {\n         } else {\n             first = false;\n         }\n-        s.push_str(i.get());\n+        s.push_str(&i);\n     }\n     s\n }\n \n impl Clean<String> for ast::Ident {\n     fn clean(&self, _: &DocContext) -> String {\n-        token::get_ident(*self).get().to_string()\n+        token::get_ident(*self).to_string()\n     }\n }\n \n impl Clean<String> for ast::Name {\n     fn clean(&self, _: &DocContext) -> String {\n-        token::get_name(*self).get().to_string()\n+        token::get_name(*self).to_string()\n     }\n }\n \n@@ -2158,7 +2158,7 @@ impl Clean<Vec<Item>> for doctree::Import {\n         // forcefully don't inline if this is not public or if the\n         // #[doc(no_inline)] attribute is present.\n         let denied = self.vis != ast::Public || self.attrs.iter().any(|a| {\n-            a.name().get() == \"doc\" && match a.meta_item_list() {\n+            &a.name()[] == \"doc\" && match a.meta_item_list() {\n                 Some(l) => attr::contains_name(l, \"no_inline\"),\n                 None => false,\n             }\n@@ -2311,7 +2311,7 @@ impl ToSource for syntax::codemap::Span {\n \n fn lit_to_string(lit: &ast::Lit) -> String {\n     match lit.node {\n-        ast::LitStr(ref st, _) => st.get().to_string(),\n+        ast::LitStr(ref st, _) => st.to_string(),\n         ast::LitBinary(ref data) => format!(\"{:?}\", data),\n         ast::LitByte(b) => {\n             let mut res = String::from_str(\"b'\");\n@@ -2323,8 +2323,8 @@ fn lit_to_string(lit: &ast::Lit) -> String {\n         },\n         ast::LitChar(c) => format!(\"'{}'\", c),\n         ast::LitInt(i, _t) => i.to_string(),\n-        ast::LitFloat(ref f, _t) => f.get().to_string(),\n-        ast::LitFloatUnsuffixed(ref f) => f.get().to_string(),\n+        ast::LitFloat(ref f, _t) => f.to_string(),\n+        ast::LitFloatUnsuffixed(ref f) => f.to_string(),\n         ast::LitBool(b) => b.to_string(),\n     }\n }\n@@ -2336,7 +2336,7 @@ fn name_from_pat(p: &ast::Pat) -> String {\n     match p.node {\n         PatWild(PatWildSingle) => \"_\".to_string(),\n         PatWild(PatWildMulti) => \"..\".to_string(),\n-        PatIdent(_, ref p, _) => token::get_ident(p.node).get().to_string(),\n+        PatIdent(_, ref p, _) => token::get_ident(p.node).to_string(),\n         PatEnum(ref p, _) => path_to_string(p),\n         PatStruct(ref name, ref fields, etc) => {\n             format!(\"{} {{ {}{} }}\", path_to_string(name),\n@@ -2486,11 +2486,11 @@ impl Clean<Stability> for attr::Stability {\n     fn clean(&self, _: &DocContext) -> Stability {\n         Stability {\n             level: self.level,\n-            feature: self.feature.get().to_string(),\n+            feature: self.feature.to_string(),\n             since: self.since.as_ref().map_or(\"\".to_string(),\n-                                              |interned| interned.get().to_string()),\n+                                              |interned| interned.to_string()),\n             reason: self.reason.as_ref().map_or(\"\".to_string(),\n-                                                |interned| interned.get().to_string()),\n+                                                |interned| interned.to_string()),\n         }\n     }\n }"}, {"sha": "6acd15379461cfbafcc91f9f2fb9cb56b7c16822", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -142,7 +142,7 @@ fn doit(sess: &parse::ParseSess, mut lexer: lexer::StringReader,\n \n             // keywords are also included in the identifier set\n             token::Ident(ident, _is_mod_sep) => {\n-                match token::get_ident(ident).get() {\n+                match &token::get_ident(ident)[] {\n                     \"ref\" | \"mut\" => \"kw-2\",\n \n                     \"self\" => \"self\","}, {"sha": "ac1a02854124afda82d3183550ebd9e7c63a6933", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -237,7 +237,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             ast::ItemExternCrate(ref p) => {\n                 let path = match *p {\n                     None => None,\n-                    Some((ref x, _)) => Some(x.get().to_string()),\n+                    Some((ref x, _)) => Some(x.to_string()),\n                 };\n                 om.extern_crates.push(ExternCrate {\n                     name: name,\n@@ -253,7 +253,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     let please_inline = item.attrs.iter().any(|item| {\n                         match item.meta_item_list() {\n                             Some(list) => {\n-                                list.iter().any(|i| i.name().get() == \"inline\")\n+                                list.iter().any(|i| &i.name()[] == \"inline\")\n                             }\n                             None => false,\n                         }"}, {"sha": "7e1bf7a2230b892261f6fe520cf8fc2b5a84879e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -112,13 +112,13 @@ impl fmt::Display for Ident {\n impl fmt::Debug for Name {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let Name(nm) = *self;\n-        write!(f, \"{:?}({})\", token::get_name(*self).get(), nm)\n+        write!(f, \"{:?}({})\", token::get_name(*self), nm)\n     }\n }\n \n impl fmt::Display for Name {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(token::get_name(*self).get(), f)\n+        fmt::Display::fmt(&token::get_name(*self), f)\n     }\n }\n \n@@ -174,7 +174,7 @@ impl Name {\n     pub fn as_str<'a>(&'a self) -> &'a str {\n         unsafe {\n             // FIXME #12938: can't use copy_lifetime since &str isn't a &T\n-            ::std::mem::transmute::<&str,&str>(token::get_name(*self).get())\n+            ::std::mem::transmute::<&str,&str>(&token::get_name(*self))\n         }\n     }\n \n@@ -193,7 +193,7 @@ pub type Mrk = u32;\n \n impl Encodable for Ident {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_str(token::get_ident(*self).get())\n+        s.emit_str(&token::get_ident(*self))\n     }\n }\n "}, {"sha": "b8d4c90f74523fdb48c575dd7b13c0079ed7288b", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -27,7 +27,7 @@ use std::u32;\n pub fn path_name_i(idents: &[Ident]) -> String {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n     idents.iter().map(|i| {\n-        token::get_ident(*i).get().to_string()\n+        token::get_ident(*i).to_string()\n     }).collect::<Vec<String>>().connect(\"::\")\n }\n "}, {"sha": "a3afe5780d0d509cf7109e2b4e20bb56f2cf2215", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -44,7 +44,7 @@ pub fn is_used(attr: &Attribute) -> bool {\n \n pub trait AttrMetaMethods {\n     fn check_name(&self, name: &str) -> bool {\n-        name == self.name().get()\n+        name == &self.name()[]\n     }\n \n     /// Retrieve the name of the meta item, e.g. `foo` in `#[foo]`,\n@@ -62,7 +62,7 @@ pub trait AttrMetaMethods {\n \n impl AttrMetaMethods for Attribute {\n     fn check_name(&self, name: &str) -> bool {\n-        let matches = name == self.name().get();\n+        let matches = name == &self.name()[];\n         if matches {\n             mark_used(self);\n         }\n@@ -142,7 +142,7 @@ impl AttributeMethods for Attribute {\n             let meta = mk_name_value_item_str(\n                 InternedString::new(\"doc\"),\n                 token::intern_and_get_ident(&strip_doc_comment_decoration(\n-                        comment.get())[]));\n+                        &comment)[]));\n             if self.node.style == ast::AttrOuter {\n                 f(&mk_attr_outer(self.node.id, meta))\n             } else {\n@@ -209,7 +209,7 @@ pub fn mk_attr_outer(id: AttrId, item: P<MetaItem>) -> Attribute {\n pub fn mk_sugared_doc_attr(id: AttrId, text: InternedString, lo: BytePos,\n                            hi: BytePos)\n                            -> Attribute {\n-    let style = doc_comment_style(text.get());\n+    let style = doc_comment_style(&text);\n     let lit = spanned(lo, hi, ast::LitStr(text, ast::CookedStr));\n     let attr = Attribute_ {\n         id: id,\n@@ -326,11 +326,11 @@ pub fn requests_inline(attrs: &[Attribute]) -> bool {\n /// Tests if a cfg-pattern matches the cfg set\n pub fn cfg_matches(diagnostic: &SpanHandler, cfgs: &[P<MetaItem>], cfg: &ast::MetaItem) -> bool {\n     match cfg.node {\n-        ast::MetaList(ref pred, ref mis) if pred.get() == \"any\" =>\n+        ast::MetaList(ref pred, ref mis) if &pred[] == \"any\" =>\n             mis.iter().any(|mi| cfg_matches(diagnostic, cfgs, &**mi)),\n-        ast::MetaList(ref pred, ref mis) if pred.get() == \"all\" =>\n+        ast::MetaList(ref pred, ref mis) if &pred[] == \"all\" =>\n             mis.iter().all(|mi| cfg_matches(diagnostic, cfgs, &**mi)),\n-        ast::MetaList(ref pred, ref mis) if pred.get() == \"not\" => {\n+        ast::MetaList(ref pred, ref mis) if &pred[] == \"not\" => {\n             if mis.len() != 1 {\n                 diagnostic.span_err(cfg.span, \"expected 1 cfg-pattern\");\n                 return false;\n@@ -382,7 +382,7 @@ fn find_stability_generic<'a,\n \n     'outer: for attr in attrs {\n         let tag = attr.name();\n-        let tag = tag.get();\n+        let tag = &tag[];\n         if tag != \"deprecated\" && tag != \"unstable\" && tag != \"stable\" {\n             continue // not a stability level\n         }\n@@ -394,8 +394,8 @@ fn find_stability_generic<'a,\n                 let mut feature = None;\n                 let mut since = None;\n                 let mut reason = None;\n-                for meta in metas {\n-                    if meta.name().get() == \"feature\" {\n+                for meta in metas.iter() {\n+                    if meta.name() == \"feature\" {\n                         match meta.value_str() {\n                             Some(v) => feature = Some(v),\n                             None => {\n@@ -404,7 +404,7 @@ fn find_stability_generic<'a,\n                             }\n                         }\n                     }\n-                    if meta.name().get() == \"since\" {\n+                    if &meta.name()[] == \"since\" {\n                         match meta.value_str() {\n                             Some(v) => since = Some(v),\n                             None => {\n@@ -413,7 +413,7 @@ fn find_stability_generic<'a,\n                             }\n                         }\n                     }\n-                    if meta.name().get() == \"reason\" {\n+                    if &meta.name()[] == \"reason\" {\n                         match meta.value_str() {\n                             Some(v) => reason = Some(v),\n                             None => {\n@@ -521,11 +521,11 @@ pub fn find_repr_attrs(diagnostic: &SpanHandler, attr: &Attribute) -> Vec<ReprAt\n             for item in items {\n                 match item.node {\n                     ast::MetaWord(ref word) => {\n-                        let hint = match word.get() {\n+                        let hint = match &word[] {\n                             // Can't use \"extern\" because it's not a lexical identifier.\n                             \"C\" => Some(ReprExtern),\n                             \"packed\" => Some(ReprPacked),\n-                            _ => match int_type_of_word(word.get()) {\n+                            _ => match int_type_of_word(&word) {\n                                 Some(ity) => Some(ReprInt(item.span, ity)),\n                                 None => {\n                                     // Not a word we recognize"}, {"sha": "833a6d52acb9798ef77c766aa69ee65535b298e6", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -10,6 +10,7 @@\n \n use std::cell::RefCell;\n use std::collections::BTreeMap;\n+\n use ast;\n use ast::{Ident, Name, TokenTree};\n use codemap::Span;\n@@ -57,7 +58,7 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n         match diagnostics.insert(code.name, span) {\n             Some(previous_span) => {\n                 ecx.span_warn(span, &format!(\n-                    \"diagnostic code {} already used\", token::get_ident(code).get()\n+                    \"diagnostic code {} already used\", &token::get_ident(code)\n                 )[]);\n                 ecx.span_note(previous_span, \"previous invocation\");\n             },\n@@ -68,7 +69,7 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n     with_registered_diagnostics(|diagnostics| {\n         if !diagnostics.contains_key(&code.name) {\n             ecx.span_err(span, &format!(\n-                \"used diagnostic code {} not registered\", token::get_ident(code).get()\n+                \"used diagnostic code {} not registered\", &token::get_ident(code)\n             )[]);\n         }\n     });\n@@ -93,12 +94,12 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n     with_registered_diagnostics(|diagnostics| {\n         if diagnostics.insert(code.name, description).is_some() {\n             ecx.span_err(span, &format!(\n-                \"diagnostic code {} already registered\", token::get_ident(*code).get()\n+                \"diagnostic code {} already registered\", &token::get_ident(*code)\n             )[]);\n         }\n     });\n     let sym = Ident::new(token::gensym(&(\n-        \"__register_diagnostic_\".to_string() + token::get_ident(*code).get()\n+        \"__register_diagnostic_\".to_string() + &token::get_ident(*code)\n     )[]));\n     MacItems::new(vec![quote_item!(ecx, mod $sym {}).unwrap()].into_iter())\n }"}, {"sha": "1ceda2e08dd8219663623d3457689c5ea71114b5", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -102,7 +102,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                     // It's the opposite of '=&' which means that the memory\n                     // cannot be shared with any other operand (usually when\n                     // a register is clobbered early.)\n-                    let output = match constraint.get().slice_shift_char() {\n+                    let output = match constraint.slice_shift_char() {\n                         Some(('=', _)) => None,\n                         Some(('+', operand)) => {\n                             Some(token::intern_and_get_ident(&format!(\n@@ -129,9 +129,9 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n                     let (constraint, _str_style) = p.parse_str();\n \n-                    if constraint.get().starts_with(\"=\") {\n+                    if constraint.starts_with(\"=\") {\n                         cx.span_err(p.last_span, \"input operand constraint contains '='\");\n-                    } else if constraint.get().starts_with(\"+\") {\n+                    } else if constraint.starts_with(\"+\") {\n                         cx.span_err(p.last_span, \"input operand constraint contains '+'\");\n                     }\n \n@@ -213,7 +213,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     MacExpr::new(P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprInlineAsm(ast::InlineAsm {\n-            asm: token::intern_and_get_ident(asm.get()),\n+            asm: token::intern_and_get_ident(&asm),\n             asm_str_style: asm_str_style.unwrap(),\n             outputs: outputs,\n             inputs: inputs,"}, {"sha": "b5f6893a8c279f933ec8475f652a896c1938cca9", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -790,7 +790,7 @@ pub fn get_single_str_from_tts(cx: &mut ExtCtxt,\n         cx.span_err(sp, &format!(\"{} takes 1 argument\", name)[]);\n     }\n     expr_to_string(cx, ret, \"argument must be a string literal\").map(|(s, _)| {\n-        s.get().to_string()\n+        s.to_string()\n     })\n }\n "}, {"sha": "55faf692e98f31867e2bba6e9b16da40cbf982bc", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -21,7 +21,6 @@ use parse::token::InternedString;\n use parse::token;\n use ptr::P;\n \n-\n // Transitional reexports so qquote can find the paths it is looking for\n mod syntax {\n     pub use ext;\n@@ -576,7 +575,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn expr_field_access(&self, sp: Span, expr: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr> {\n         let field_name = token::get_ident(ident);\n         let field_span = Span {\n-            lo: sp.lo - Pos::from_usize(field_name.get().len()),\n+            lo: sp.lo - Pos::from_usize(field_name.len()),\n             hi: sp.hi,\n             expn_id: sp.expn_id,\n         };"}, {"sha": "80d128959eaf3a652632f6748fdddb330a68a4cb", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -32,7 +32,7 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                     ast::LitStr(ref s, _) |\n                     ast::LitFloat(ref s, _) |\n                     ast::LitFloatUnsuffixed(ref s) => {\n-                        accumulator.push_str(s.get());\n+                        accumulator.push_str(&s);\n                     }\n                     ast::LitChar(c) => {\n                         accumulator.push(c);"}, {"sha": "364cacd735cc73386c45e4ea0e540f277914f795", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -31,7 +31,7 @@ pub fn expand_syntax_ext<'cx>(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]\n         } else {\n             match *e {\n                 ast::TtToken(_, token::Ident(ident, _)) => {\n-                    res_str.push_str(token::get_ident(ident).get())\n+                    res_str.push_str(&token::get_ident(ident))\n                 },\n                 _ => {\n                     cx.span_err(sp, \"concat_idents! requires ident args.\");"}, {"sha": "1c82ca5d2add78c3f772675cb1b78d51f284b9fb", "filename": "src/libsyntax/ext/deriving/bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -24,7 +24,7 @@ pub fn expand_deriving_bound<F>(cx: &mut ExtCtxt,\n {\n     let name = match mitem.node {\n         MetaWord(ref tname) => {\n-            match tname.get() {\n+            match &tname[] {\n                 \"Copy\" => \"Copy\",\n                 \"Send\" | \"Sync\" => {\n                     return cx.span_err(span,"}, {"sha": "28573ef757b1295c7efc55eefe6e1e92f5048213", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -363,7 +363,7 @@ impl<'a> TraitDef<'a> {\n         // generated implementations are linted\n         let mut attrs = newitem.attrs.clone();\n         attrs.extend(item.attrs.iter().filter(|a| {\n-            match a.name().get() {\n+            match &a.name()[] {\n                 \"allow\" | \"warn\" | \"deny\" | \"forbid\" => true,\n                 _ => false,\n             }"}, {"sha": "318b748ad7ff22354064a61319fd198d165828fb", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -74,7 +74,7 @@ pub fn expand_meta_derive(cx: &mut ExtCtxt,\n                                                    |i| push(i)))\n                         }\n \n-                        match tname.get() {\n+                        match &tname[] {\n                             \"Clone\" => expand!(clone::expand_deriving_clone),\n \n                             \"Hash\" => expand!(hash::expand_deriving_hash),"}, {"sha": "821fdeaa86a1fadc41f0cda6b3d1d9e93db3a823", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -72,7 +72,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n         }\n     };\n \n-    let mut format_string = String::from_str(token::get_ident(name).get());\n+    let mut format_string = String::from_str(&token::get_ident(name));\n     // the internal fields we're actually formatting\n     let mut exprs = Vec::new();\n \n@@ -107,7 +107,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n \n                     let name = token::get_ident(field.name.unwrap());\n                     format_string.push_str(\" \");\n-                    format_string.push_str(name.get());\n+                    format_string.push_str(&name);\n                     format_string.push_str(\": {:?}\");\n \n                     exprs.push(field.self_.clone());"}, {"sha": "417506cf3aadb1413c595e781f5cff12133060e6", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -101,12 +101,12 @@ pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         }\n     }\n \n-    let e = match env::var_string(var.get()) {\n-        Err(..) => {\n-            cx.span_err(sp, msg.get());\n+    let e = match env::var_string(&var[]) {\n+        Err(_) => {\n+            cx.span_err(sp, &msg);\n             cx.expr_usize(sp, 0)\n         }\n-        Ok(s) => cx.expr_str(sp, token::intern_and_get_ident(&s[]))\n+        Ok(s) => cx.expr_str(sp, token::intern_and_get_ident(&s))\n     };\n     MacExpr::new(e)\n }"}, {"sha": "33712dae900b8fd311df68bd68c2a6743e821965", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -375,7 +375,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                     fld.cx.span_err(\n                         pth.span,\n                         &format!(\"macro undefined: '{}!'\",\n-                                extnamestr.get())[]);\n+                                &extnamestr)[]);\n \n                     // let compilation continue\n                     None\n@@ -385,7 +385,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                         fld.cx.bt_push(ExpnInfo {\n                                 call_site: span,\n                                 callee: NameAndSpan {\n-                                    name: extnamestr.get().to_string(),\n+                                    name: extnamestr.to_string(),\n                                     format: MacroBang,\n                                     span: exp_span,\n                                 },\n@@ -411,7 +411,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                                 fld.cx.span_err(\n                                     pth.span,\n                                     &format!(\"non-expression macro in expression position: {}\",\n-                                            &extnamestr.get()[]\n+                                            &extnamestr[]\n                                             )[]);\n                                 return None;\n                             }\n@@ -422,7 +422,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                         fld.cx.span_err(\n                             pth.span,\n                             &format!(\"'{}' is not a tt-style macro\",\n-                                    extnamestr.get())[]);\n+                                    &extnamestr)[]);\n                         None\n                     }\n                 }\n@@ -506,14 +506,14 @@ fn expand_item_modifiers(mut it: P<ast::Item>, fld: &mut MacroExpander)\n     for attr in &modifiers {\n         let mname = attr.name();\n \n-        match fld.cx.syntax_env.find(&intern(mname.get())) {\n+        match fld.cx.syntax_env.find(&intern(&mname)) {\n             Some(rc) => match *rc {\n                 Modifier(ref mac) => {\n                     attr::mark_used(attr);\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: attr.span,\n                         callee: NameAndSpan {\n-                            name: mname.get().to_string(),\n+                            name: mname.to_string(),\n                             format: MacroAttribute,\n                             span: None,\n                         }\n@@ -613,7 +613,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: it.span,\n                         callee: NameAndSpan {\n-                            name: extnamestr.get().to_string(),\n+                            name: extnamestr.to_string(),\n                             format: MacroBang,\n                             span: span\n                         }\n@@ -626,13 +626,13 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                     if it.ident.name == parse::token::special_idents::invalid.name {\n                         fld.cx.span_err(path_span,\n                                         &format!(\"macro {}! expects an ident argument\",\n-                                                extnamestr.get())[]);\n+                                                &extnamestr)[]);\n                         return SmallVector::zero();\n                     }\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: it.span,\n                         callee: NameAndSpan {\n-                            name: extnamestr.get().to_string(),\n+                            name: extnamestr.to_string(),\n                             format: MacroBang,\n                             span: span\n                         }\n@@ -651,7 +651,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: it.span,\n                         callee: NameAndSpan {\n-                            name: extnamestr.get().to_string(),\n+                            name: extnamestr.to_string(),\n                             format: MacroBang,\n                             span: None,\n                         }\n@@ -677,7 +677,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                 _ => {\n                     fld.cx.span_err(it.span,\n                                     &format!(\"{}! is not legal in item position\",\n-                                            extnamestr.get())[]);\n+                                            &extnamestr)[]);\n                     return SmallVector::zero();\n                 }\n             }\n@@ -696,7 +696,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n         None => {\n             fld.cx.span_err(path_span,\n                             &format!(\"non-item macro in item position: {}\",\n-                                    extnamestr.get())[]);\n+                                    &extnamestr)[]);\n             return SmallVector::zero();\n         }\n     };\n@@ -950,7 +950,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: span,\n                         callee: NameAndSpan {\n-                            name: extnamestr.get().to_string(),\n+                            name: extnamestr.to_string(),\n                             format: MacroBang,\n                             span: tt_span\n                         }\n@@ -968,7 +968,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n                                 pth.span,\n                                 &format!(\n                                     \"non-pattern macro in pattern position: {}\",\n-                                    extnamestr.get()\n+                                    &extnamestr\n                                     )[]\n                             );\n                             return DummyResult::raw_pat(span);\n@@ -981,7 +981,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n                 _ => {\n                     fld.cx.span_err(span,\n                                     &format!(\"{}! is not legal in pattern position\",\n-                                            extnamestr.get())[]);\n+                                            &extnamestr)[]);\n                     return DummyResult::raw_pat(span);\n                 }\n             }\n@@ -1065,7 +1065,7 @@ fn expand_annotatable(a: Annotatable,\n     for attr in a.attrs() {\n         let mname = attr.name();\n \n-        match fld.cx.syntax_env.find(&intern(mname.get())) {\n+        match fld.cx.syntax_env.find(&intern(&mname)) {\n             Some(rc) => match *rc {\n                 Decorator(ref dec) => {\n                     let it = match a {\n@@ -1079,7 +1079,7 @@ fn expand_annotatable(a: Annotatable,\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: attr.span,\n                         callee: NameAndSpan {\n-                            name: mname.get().to_string(),\n+                            name: mname.to_string(),\n                             format: MacroAttribute,\n                             span: None\n                         }\n@@ -1180,7 +1180,7 @@ fn modifiers(attrs: &Vec<ast::Attribute>,\n              fld: &MacroExpander)\n              -> (Vec<ast::Attribute>, Vec<ast::Attribute>) {\n     attrs.iter().cloned().partition(|attr| {\n-        match fld.cx.syntax_env.find(&intern(attr.name().get())) {\n+        match fld.cx.syntax_env.find(&intern(&attr.name())) {\n             Some(rc) => match *rc {\n                 Modifier(_) => true,\n                 _ => false\n@@ -1195,7 +1195,7 @@ fn multi_modifiers(attrs: &[ast::Attribute],\n                    fld: &MacroExpander)\n                    -> (Vec<ast::Attribute>, Vec<ast::Attribute>) {\n     attrs.iter().cloned().partition(|attr| {\n-        match fld.cx.syntax_env.find(&intern(attr.name().get())) {\n+        match fld.cx.syntax_env.find(&intern(&attr.name())) {\n             Some(rc) => match *rc {\n                 MultiModifier(_) => true,\n                 _ => false\n@@ -1220,14 +1220,14 @@ fn expand_item_multi_modifier(mut it: Annotatable,\n     for attr in &modifiers {\n         let mname = attr.name();\n \n-        match fld.cx.syntax_env.find(&intern(mname.get())) {\n+        match fld.cx.syntax_env.find(&intern(&mname)) {\n             Some(rc) => match *rc {\n                 MultiModifier(ref mac) => {\n                     attr::mark_used(attr);\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: attr.span,\n                         callee: NameAndSpan {\n-                            name: mname.get().to_string(),\n+                            name: mname.to_string(),\n                             format: MacroAttribute,\n                             span: None,\n                         }\n@@ -1862,7 +1862,7 @@ mod test {\n                         .collect();\n                     println!(\"varref #{}: {:?}, resolves to {}\",idx, varref_idents, varref_name);\n                     let string = token::get_ident(final_varref_ident);\n-                    println!(\"varref's first segment's string: \\\"{}\\\"\", string.get());\n+                    println!(\"varref's first segment's string: \\\"{}\\\"\", &string[]);\n                     println!(\"binding #{}: {}, resolves to {}\",\n                              binding_idx, bindings[binding_idx], binding_name);\n                     mtwt::with_sctable(|x| mtwt::display_sctable(x));\n@@ -1915,7 +1915,7 @@ foo_module!();\n         let cxbinds: Vec<&ast::Ident> =\n             bindings.iter().filter(|b| {\n                 let ident = token::get_ident(**b);\n-                let string = ident.get();\n+                let string = &ident[];\n                 \"xx\" == string\n             }).collect();\n         let cxbinds: &[&ast::Ident] = &cxbinds[];\n@@ -1929,7 +1929,7 @@ foo_module!();\n         // the xx binding should bind all of the xx varrefs:\n         for (idx,v) in varrefs.iter().filter(|p| {\n             p.segments.len() == 1\n-            && \"xx\" == token::get_ident(p.segments[0].identifier).get()\n+            && \"xx\" == &token::get_ident(p.segments[0].identifier)[]\n         }).enumerate() {\n             if mtwt::resolve(v.segments[0].identifier) != resolved_binding {\n                 println!(\"uh oh, xx binding didn't match xx varref:\");"}, {"sha": "96055e3635a60e43afe1be8504171e4200dcff42", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -118,7 +118,8 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                 }\n             };\n             let interned_name = token::get_ident(ident);\n-            let name = interned_name.get();\n+            let name = &interned_name[];\n+\n             p.expect(&token::Eq);\n             let e = p.parse_expr();\n             match names.get(name) {\n@@ -672,7 +673,8 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n         None => return DummyResult::raw_expr(sp)\n     };\n \n-    let mut parser = parse::Parser::new(fmt.get());\n+    let mut parser = parse::Parser::new(&fmt);\n+\n     loop {\n         match parser.next() {\n             Some(piece) => {"}, {"sha": "67990895d071affa20ed0b129ef4b395e0adc9ec", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -161,7 +161,7 @@ pub mod rt {\n \n     impl ToSource for ast::Ident {\n         fn to_source(&self) -> String {\n-            token::get_ident(*self).get().to_string()\n+            token::get_ident(*self).to_string()\n         }\n     }\n "}, {"sha": "be02ba5ddc2209ff0fc6775f8c11a16fffb30740", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -73,7 +73,7 @@ pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n     let string = cx.mod_path()\n                    .iter()\n-                   .map(|x| token::get_ident(*x).get().to_string())\n+                   .map(|x| token::get_ident(*x).to_string())\n                    .collect::<Vec<String>>()\n                    .connect(\"::\");\n     base::MacExpr::new(cx.expr_str("}, {"sha": "d752e34c11253c149318013f13e1c02269a205f9", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -229,7 +229,7 @@ pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n                         p_s.span_diagnostic\n                            .span_fatal(sp,\n                                        &format!(\"duplicated bind name: {}\",\n-                                               string.get())[])\n+                                               &string)[])\n                     }\n                 }\n             }\n@@ -487,8 +487,8 @@ pub fn parse(sess: &ParseSess,\n                     let name_string = token::get_ident(name);\n                     let match_cur = ei.match_cur;\n                     (&mut ei.matches[match_cur]).push(Rc::new(MatchedNonterminal(\n-                        parse_nt(&mut rust_parser, span, name_string.get()))));\n-                    ei.idx += 1;\n+                        parse_nt(&mut rust_parser, span, &name_string))));\n+                    ei.idx += 1us;\n                     ei.match_cur += 1;\n                   }\n                   _ => panic!()"}, {"sha": "12efd959918e1e50ae9510e9643be773029a5c19", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -21,6 +21,7 @@\n //! For the purpose of future feature-tracking, once code for detection of feature\n //! gate usage is added, *do not remove it again* even once the feature\n //! becomes stable.\n+\n use self::Status::*;\n \n use abi::RustIntrinsic;\n@@ -255,7 +256,7 @@ impl<'a> PostExpansionVisitor<'a> {\n \n impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     fn visit_name(&mut self, sp: Span, name: ast::Name) {\n-        if !token::get_name(name).get().is_ascii() {\n+        if !token::get_name(name).is_ascii() {\n             self.gate_feature(\"non_ascii_idents\", sp,\n                               \"non-ascii idents are not fully supported.\");\n         }\n@@ -382,7 +383,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n \n         let links_to_llvm = match attr::first_attr_value_str_by_name(&i.attrs,\n                                                                      \"link_name\") {\n-            Some(val) => val.get().starts_with(\"llvm.\"),\n+            Some(val) => val.starts_with(\"llvm.\"),\n             _ => false\n         };\n         if links_to_llvm {"}, {"sha": "5f4cf9af5ee75cc588eba2a8cf753ebcddb1b38f", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -1201,19 +1201,19 @@ mod test {\n         let source = \"/// doc comment\\r\\nfn foo() {}\".to_string();\n         let item = parse_item_from_source_str(name.clone(), source, Vec::new(), &sess).unwrap();\n         let doc = first_attr_value_str_by_name(&item.attrs, \"doc\").unwrap();\n-        assert_eq!(doc.get(), \"/// doc comment\");\n+        assert_eq!(&doc[], \"/// doc comment\");\n \n         let source = \"/// doc comment\\r\\n/// line 2\\r\\nfn foo() {}\".to_string();\n         let item = parse_item_from_source_str(name.clone(), source, Vec::new(), &sess).unwrap();\n-        let docs = item.attrs.iter().filter(|a| a.name().get() == \"doc\")\n-                    .map(|a| a.value_str().unwrap().get().to_string()).collect::<Vec<_>>();\n+        let docs = item.attrs.iter().filter(|a| &a.name()[] == \"doc\")\n+                    .map(|a| a.value_str().unwrap().to_string()).collect::<Vec<_>>();\n         let b: &[_] = &[\"/// doc comment\".to_string(), \"/// line 2\".to_string()];\n         assert_eq!(&docs[], b);\n \n         let source = \"/** doc comment\\r\\n *  with CRLF */\\r\\nfn foo() {}\".to_string();\n         let item = parse_item_from_source_str(name, source, Vec::new(), &sess).unwrap();\n         let doc = first_attr_value_str_by_name(&item.attrs, \"doc\").unwrap();\n-        assert_eq!(doc.get(), \"/** doc comment\\n *  with CRLF */\");\n+        assert_eq!(&doc[], \"/** doc comment\\n *  with CRLF */\");\n     }\n \n     #[test]"}, {"sha": "3107f47de7859b83613478b5a193f0ef06221a3e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -5133,7 +5133,7 @@ impl<'a> Parser<'a> {\n                 outer_attrs, \"path\") {\n             Some(d) => (dir_path.join(d), true),\n             None => {\n-                let mod_name = mod_string.get().to_string();\n+                let mod_name = mod_string.to_string();\n                 let default_path_str = format!(\"{}.rs\", mod_name);\n                 let secondary_path_str = format!(\"{}/mod.rs\", mod_name);\n                 let default_path = dir_path.join(&default_path_str[]);\n@@ -5145,7 +5145,7 @@ impl<'a> Parser<'a> {\n                     self.span_err(id_sp,\n                                   \"cannot declare a new module at this location\");\n                     let this_module = match self.mod_path_stack.last() {\n-                        Some(name) => name.get().to_string(),\n+                        Some(name) => name.to_string(),\n                         None => self.root_module_name.as_ref().unwrap().clone(),\n                     };\n                     self.span_note(id_sp,\n@@ -5191,7 +5191,7 @@ impl<'a> Parser<'a> {\n         };\n \n         self.eval_src_mod_from_path(file_path, owns_directory,\n-                                    mod_string.get().to_string(), id_sp)\n+                                    mod_string.to_string(), id_sp)\n     }\n \n     fn eval_src_mod_from_path(&mut self,"}, {"sha": "45f4f044ea4d1ff7502cecf0fbed90c9e880eb6a", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -625,11 +625,6 @@ impl InternedString {\n             string: string,\n         }\n     }\n-\n-    #[inline]\n-    pub fn get<'a>(&'a self) -> &'a str {\n-        &self.string[]\n-    }\n }\n \n impl Deref for InternedString {\n@@ -644,7 +639,7 @@ impl BytesContainer for InternedString {\n         // of `BytesContainer`, which is itself a workaround for the lack of\n         // DST.\n         unsafe {\n-            let this = self.get();\n+            let this = &self[];\n             mem::transmute::<&[u8],&[u8]>(this.container_as_bytes())\n         }\n     }"}, {"sha": "c177cd1fafa55985ef7d3218eedceacb7c20a051", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -258,7 +258,7 @@ pub fn token_to_string(tok: &Token) -> String {\n         }\n \n         /* Name components */\n-        token::Ident(s, _)          => token::get_ident(s).get().to_string(),\n+        token::Ident(s, _)          => token::get_ident(s).to_string(),\n         token::Lifetime(s)          => format!(\"{}\", token::get_ident(s)),\n         token::Underscore           => \"_\".to_string(),\n \n@@ -798,7 +798,7 @@ impl<'a> State<'a> {\n                 try!(self.head(&visibility_qualified(item.vis,\n                                                      \"extern crate\")[]));\n                 if let Some((ref p, style)) = *optional_path {\n-                    try!(self.print_string(p.get(), style));\n+                    try!(self.print_string(p, style));\n                     try!(space(&mut self.s));\n                     try!(word(&mut self.s, \"as\"));\n                     try!(space(&mut self.s));\n@@ -1313,7 +1313,7 @@ impl<'a> State<'a> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(attr.span.lo));\n         if attr.node.is_sugared_doc {\n-            word(&mut self.s, attr.value_str().unwrap().get())\n+            word(&mut self.s, &attr.value_str().unwrap())\n         } else {\n             match attr.node.style {\n                 ast::AttrInner => try!(word(&mut self.s, \"#![\")),\n@@ -1847,17 +1847,17 @@ impl<'a> State<'a> {\n             ast::ExprInlineAsm(ref a) => {\n                 try!(word(&mut self.s, \"asm!\"));\n                 try!(self.popen());\n-                try!(self.print_string(a.asm.get(), a.asm_str_style));\n+                try!(self.print_string(&a.asm, a.asm_str_style));\n                 try!(self.word_space(\":\"));\n \n                 try!(self.commasep(Inconsistent, &a.outputs[],\n                                    |s, &(ref co, ref o, is_rw)| {\n-                    match co.get().slice_shift_char() {\n+                    match co.slice_shift_char() {\n                         Some(('=', operand)) if is_rw => {\n                             try!(s.print_string(&format!(\"+{}\", operand)[],\n                                                 ast::CookedStr))\n                         }\n-                        _ => try!(s.print_string(co.get(), ast::CookedStr))\n+                        _ => try!(s.print_string(&co, ast::CookedStr))\n                     }\n                     try!(s.popen());\n                     try!(s.print_expr(&**o));\n@@ -1869,7 +1869,7 @@ impl<'a> State<'a> {\n \n                 try!(self.commasep(Inconsistent, &a.inputs[],\n                                    |s, &(ref co, ref o)| {\n-                    try!(s.print_string(co.get(), ast::CookedStr));\n+                    try!(s.print_string(&co, ast::CookedStr));\n                     try!(s.popen());\n                     try!(s.print_expr(&**o));\n                     try!(s.pclose());\n@@ -1880,7 +1880,7 @@ impl<'a> State<'a> {\n \n                 try!(self.commasep(Inconsistent, &a.clobbers[],\n                                    |s, co| {\n-                    try!(s.print_string(co.get(), ast::CookedStr));\n+                    try!(s.print_string(&co, ast::CookedStr));\n                     Ok(())\n                 }));\n \n@@ -1954,7 +1954,7 @@ impl<'a> State<'a> {\n             let encoded = ident.encode_with_hygiene();\n             try!(word(&mut self.s, &encoded[]))\n         } else {\n-            try!(word(&mut self.s, token::get_ident(ident).get()))\n+            try!(word(&mut self.s, &token::get_ident(ident)))\n         }\n         self.ann.post(self, NodeIdent(&ident))\n     }\n@@ -1964,7 +1964,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_name(&mut self, name: ast::Name) -> IoResult<()> {\n-        try!(word(&mut self.s, token::get_name(name).get()));\n+        try!(word(&mut self.s, &token::get_name(name)));\n         self.ann.post(self, NodeName(&name))\n     }\n \n@@ -2532,15 +2532,15 @@ impl<'a> State<'a> {\n         try!(self.ibox(indent_unit));\n         match item.node {\n             ast::MetaWord(ref name) => {\n-                try!(word(&mut self.s, name.get()));\n+                try!(word(&mut self.s, &name));\n             }\n             ast::MetaNameValue(ref name, ref value) => {\n-                try!(self.word_space(name.get()));\n+                try!(self.word_space(&name[]));\n                 try!(self.word_space(\"=\"));\n                 try!(self.print_literal(value));\n             }\n             ast::MetaList(ref name, ref items) => {\n-                try!(word(&mut self.s, name.get()));\n+                try!(word(&mut self.s, &name));\n                 try!(self.popen());\n                 try!(self.commasep(Consistent,\n                                    &items[],\n@@ -2731,7 +2731,7 @@ impl<'a> State<'a> {\n             _ => ()\n         }\n         match lit.node {\n-            ast::LitStr(ref st, style) => self.print_string(st.get(), style),\n+            ast::LitStr(ref st, style) => self.print_string(&st, style),\n             ast::LitByte(byte) => {\n                 let mut res = String::from_str(\"b'\");\n                 ascii::escape_default(byte, |c| res.push(c as char));\n@@ -2772,10 +2772,10 @@ impl<'a> State<'a> {\n                 word(&mut self.s,\n                      &format!(\n                          \"{}{}\",\n-                         f.get(),\n+                         &f,\n                          &ast_util::float_ty_to_string(t)[])[])\n             }\n-            ast::LitFloatUnsuffixed(ref f) => word(&mut self.s, f.get()),\n+            ast::LitFloatUnsuffixed(ref f) => word(&mut self.s, &f[]),\n             ast::LitBool(val) => {\n                 if val { word(&mut self.s, \"true\") } else { word(&mut self.s, \"false\") }\n             }"}, {"sha": "1a8cb2b376aeb1e9fe73271f34b56c65022562eb", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -512,7 +512,7 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n     });\n     let reexport = cx.reexport_test_harness_main.as_ref().map(|s| {\n         // building `use <ident> = __test::main`\n-        let reexport_ident = token::str_to_ident(s.get());\n+        let reexport_ident = token::str_to_ident(&s);\n \n         let use_path =\n             nospan(ast::ViewPathSimple(reexport_ident,\n@@ -575,7 +575,7 @@ fn mk_tests(cx: &TestCtxt) -> P<ast::Item> {\n \n fn is_test_crate(krate: &ast::Crate) -> bool {\n     match attr::find_crate_name(&krate.attrs[]) {\n-        Some(ref s) if \"test\" == &s.get()[] => true,\n+        Some(ref s) if \"test\" == &s[] => true,\n         _ => false\n     }\n }"}, {"sha": "36b3091852bce5c4e52f5a7e4588d791f6ca3f3b", "filename": "src/test/auxiliary/lint_group_plugin_test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -37,9 +37,9 @@ impl LintPass for Pass {\n \n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n         let name = token::get_ident(it.ident);\n-        if name.get() == \"lintme\" {\n+        if &name[] == \"lintme\" {\n             cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\");\n-        } else if name.get() == \"pleaselintme\" {\n+        } else if &name[] == \"pleaselintme\" {\n             cx.span_lint(PLEASE_LINT, it.span, \"item is named 'pleaselintme'\");\n         }\n     }"}, {"sha": "9020bb7b0fb2ebd6fb0637c2ce76813f87d57bdf", "filename": "src/test/auxiliary/lint_plugin_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -35,7 +35,7 @@ impl LintPass for Pass {\n \n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n         let name = token::get_ident(it.ident);\n-        if name.get() == \"lintme\" {\n+        if &name[] == \"lintme\" {\n             cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\");\n         }\n     }"}, {"sha": "30a3183c808560d99b06a4a1e041e844f61bfdf4", "filename": "src/test/run-pass/issue-15149.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Ftest%2Frun-pass%2Fissue-15149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebf9bc5c22155d622537ded42b4ebf94238b296/src%2Ftest%2Frun-pass%2Fissue-15149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15149.rs?ref=7ebf9bc5c22155d622537ded42b4ebf94238b296", "patch": "@@ -1,3 +1,5 @@\n+// no-prefer-dynamic\n+\n // Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT."}]}