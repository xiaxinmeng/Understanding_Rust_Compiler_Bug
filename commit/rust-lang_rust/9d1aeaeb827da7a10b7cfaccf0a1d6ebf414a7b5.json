{"sha": "9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "node_id": "C_kwDOAAsO6NoAKDlkMWFlYWViODI3ZGE3YTEwYjdjZmFjY2YwYTFkNmViZjQxNGE3YjU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-29T14:12:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-29T14:12:42Z"}, "message": "Auto merge of #94214 - nikic:rust-opaque-pointers, r=cuviper\n\nPrepare Rust for opaque pointers\n\nFix one codegen bug with opaque pointers, and update our IR tests to accept both typed pointer and opaque pointer IR. This is a bit annoying, but unavoidable if we want decent test coverage on both LLVM 14 and LLVM 15.\n\nThis prepares Rust for when LLVM will enable opaque pointers by default.", "tree": {"sha": "29ff4633cbd3297d37ddd756a6402fe929ea6721", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29ff4633cbd3297d37ddd756a6402fe929ea6721"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "html_url": "https://github.com/rust-lang/rust/commit/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abc7681a76c7aa5adef896b85c3894047a4492d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/abc7681a76c7aa5adef896b85c3894047a4492d4", "html_url": "https://github.com/rust-lang/rust/commit/abc7681a76c7aa5adef896b85c3894047a4492d4"}, {"sha": "1ff051a9c53511473a12a37fe772e8c5f3e3e32b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ff051a9c53511473a12a37fe772e8c5f3e3e32b", "html_url": "https://github.com/rust-lang/rust/commit/1ff051a9c53511473a12a37fe772e8c5f3e3e32b"}], "stats": {"total": 554, "additions": 265, "deletions": 289}, "files": [{"sha": "c41a41980eb0b5e927e8db244134dfe8f126933c", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -509,15 +509,20 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n             OperandValue::Ref(place.llval, Some(llextra), place.align)\n         } else if place.layout.is_llvm_immediate() {\n             let mut const_llval = None;\n+            let llty = place.layout.llvm_type(self);\n             unsafe {\n                 if let Some(global) = llvm::LLVMIsAGlobalVariable(place.llval) {\n                     if llvm::LLVMIsGlobalConstant(global) == llvm::True {\n-                        const_llval = llvm::LLVMGetInitializer(global);\n+                        if let Some(init) = llvm::LLVMGetInitializer(global) {\n+                            if self.val_ty(init) == llty {\n+                                const_llval = Some(init);\n+                            }\n+                        }\n                     }\n                 }\n             }\n             let llval = const_llval.unwrap_or_else(|| {\n-                let load = self.load(place.layout.llvm_type(self), place.llval, place.align);\n+                let load = self.load(llty, place.llval, place.align);\n                 if let abi::Abi::Scalar(scalar) = place.layout.abi {\n                     scalar_load_metadata(self, load, scalar, place.layout, Size::ZERO);\n                 }"}, {"sha": "913cf4eea13a30f90e03bb83f7fcd17ecff9e430", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -304,8 +304,8 @@ impl CodegenBackend for LlvmCodegenBackend {\n           local stack variable in the ABI.)\n \n     basic\n-        Generate stack canaries in functions with:\n-        - local variables of `[T; N]` type, where `T` is byte-sized and `N` > 8.\n+        Generate stack canaries in functions with local variables of `[T; N]`\n+        type, where `T` is byte-sized and `N` >= 8.\n \n     none\n         Do not generate stack canaries."}, {"sha": "b2d7ccb01cf9e7521a0815387eca59b2fcd299c2", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -738,6 +738,10 @@ impl Step for Lld {\n             .define(\"LLVM_CONFIG_PATH\", llvm_config_shim)\n             .define(\"LLVM_INCLUDE_TESTS\", \"OFF\");\n \n+        if builder.config.llvm_allow_old_toolchain {\n+            cfg.define(\"LLVM_TEMPORARILY_ALLOW_OLD_TOOLCHAIN\", \"YES\");\n+        }\n+\n         // While we're using this horrible workaround to shim the execution of\n         // llvm-config, let's just pile on more. I can't seem to figure out how\n         // to build LLD as a standalone project and also cross-compile it at the"}, {"sha": "7c2b605509053c7fb4d8e974d50973203b038cc8", "filename": "src/test/assembly/stack-protector/stack-protector-heuristics-effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fassembly%2Fstack-protector%2Fstack-protector-heuristics-effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fassembly%2Fstack-protector%2Fstack-protector-heuristics-effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fstack-protector%2Fstack-protector-heuristics-effect.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -78,7 +78,7 @@ pub fn array_u8_1(f: fn(*const u8)) {\n #[no_mangle]\n pub fn array_u8_small(f: fn(*const u8)) {\n     let a = [0u8; 2];\n-    let b = [0u8; 8];\n+    let b = [0u8; 7];\n     f(&a as *const _);\n     f(&b as *const _);\n "}, {"sha": "31b19a54276e7c48e1143506e78963d3f5e14f54", "filename": "src/test/codegen/abi-main-signature-32bit-c-int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fabi-main-signature-32bit-c-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fabi-main-signature-32bit-c-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fabi-main-signature-32bit-c-int.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -7,4 +7,4 @@\n fn main() {\n }\n \n-// CHECK: define i32 @main(i32{{( %0)?}}, i8**{{( %1)?}})\n+// CHECK: define i32 @main(i32{{( %0)?}}, {{i8\\*\\*|ptr}}{{( %1)?}})"}, {"sha": "39880c9341f4f96aea9585835053c12f00f93775", "filename": "src/test/codegen/adjustments.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fadjustments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fadjustments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fadjustments.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -13,9 +13,9 @@ pub fn helper(_: usize) {\n pub fn no_op_slice_adjustment(x: &[u8]) -> &[u8] {\n     // We used to generate an extra alloca and memcpy for the block's trailing expression value, so\n     // check that we copy directly to the return value slot\n-// CHECK: %0 = insertvalue { [0 x i8]*, [[USIZE]] } undef, [0 x i8]* %x.0, 0\n-// CHECK: %1 = insertvalue { [0 x i8]*, [[USIZE]] } %0, [[USIZE]] %x.1, 1\n-// CHECK: ret { [0 x i8]*, [[USIZE]] } %1\n+// CHECK: %0 = insertvalue { {{\\[0 x i8\\]\\*|ptr}}, [[USIZE]] } undef, {{\\[0 x i8\\]\\*|ptr}} %x.0, 0\n+// CHECK: %1 = insertvalue { {{\\[0 x i8\\]\\*|ptr}}, [[USIZE]] } %0, [[USIZE]] %x.1, 1\n+// CHECK: ret { {{\\[0 x i8\\]\\*|ptr}}, [[USIZE]] } %1\n     { x }\n }\n "}, {"sha": "70f09ace0062cd9bc0e3052417515f96d70f9360", "filename": "src/test/codegen/align-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Falign-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Falign-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Falign-enum.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -20,7 +20,7 @@ pub struct Nested64 {\n #[no_mangle]\n pub fn align64(a: u32) -> Align64 {\n // CHECK: %a64 = alloca %Align64, align 64\n-// CHECK: call void @llvm.memcpy.{{.*}}(i8* align 64 %{{.*}}, i8* align 64 %{{.*}}, i{{[0-9]+}} 64, i1 false)\n+// CHECK: call void @llvm.memcpy.{{.*}}({{i8\\*|ptr}} align 64 %{{.*}}, {{i8\\*|ptr}} align 64 %{{.*}}, i{{[0-9]+}} 64, i1 false)\n     let a64 = Align64::A(a);\n     a64\n }"}, {"sha": "a2f47354b2b37afda843d81f8f767cad7ed049b0", "filename": "src/test/codegen/align-struct.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Falign-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Falign-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Falign-struct.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -32,7 +32,7 @@ pub enum Enum64 {\n #[no_mangle]\n pub fn align64(i : i32) -> Align64 {\n // CHECK: %a64 = alloca %Align64, align 64\n-// CHECK: call void @llvm.memcpy.{{.*}}(i8* align 64 %{{.*}}, i8* align 64 %{{.*}}, i{{[0-9]+}} 64, i1 false)\n+// CHECK: call void @llvm.memcpy.{{.*}}({{i8\\*|ptr}} align 64 %{{.*}}, {{i8\\*|ptr}} align 64 %{{.*}}, i{{[0-9]+}} 64, i1 false)\n     let a64 = Align64(i);\n     a64\n }\n@@ -42,8 +42,7 @@ pub fn align64(i : i32) -> Align64 {\n // CHECK-LABEL: @align64_load\n #[no_mangle]\n pub fn align64_load(a: Align64) -> i32 {\n-// CHECK: [[FIELD:%.*]] = bitcast %Align64* %{{.*}} to i32*\n-// CHECK: {{%.*}} = load i32, i32* [[FIELD]], align 64\n+// CHECK: {{%.*}} = load i32, {{i32\\*|ptr}} {{%.*}}, align 64\n     a.0\n }\n "}, {"sha": "cd5e82a9205c1052420006085fb00f4fa35a43fb", "filename": "src/test/codegen/array-equality.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Farray-equality.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Farray-equality.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Farray-equality.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -16,8 +16,8 @@ pub fn array_eq_value(a: [u16; 3], b: [u16; 3]) -> bool {\n #[no_mangle]\n pub fn array_eq_ref(a: &[u16; 3], b: &[u16; 3]) -> bool {\n     // CHECK: start:\n-    // CHECK: load i48, i48* %{{.+}}, align 2\n-    // CHECK: load i48, i48* %{{.+}}, align 2\n+    // CHECK: load i48, {{i48\\*|ptr}} %{{.+}}, align 2\n+    // CHECK: load i48, {{i48\\*|ptr}} %{{.+}}, align 2\n     // CHECK: icmp eq i48\n     // CHECK-NEXT: ret\n     a == b\n@@ -27,9 +27,7 @@ pub fn array_eq_ref(a: &[u16; 3], b: &[u16; 3]) -> bool {\n #[no_mangle]\n pub fn array_eq_value_still_passed_by_pointer(a: [u16; 9], b: [u16; 9]) -> bool {\n     // CHECK-NEXT: start:\n-    // CHECK-NEXT: bitcast\n-    // CHECK-NEXT: bitcast\n-    // CHECK-NEXT: %[[CMP:.+]] = tail call i32 @{{bcmp|memcmp}}(i8* {{.*}} dereferenceable(18) %{{.+}}, i8* {{.*}} dereferenceable(18) %{{.+}}, i64 18)\n+    // CHECK: %[[CMP:.+]] = tail call i32 @{{bcmp|memcmp}}({{i8\\*|ptr}} {{.*}} dereferenceable(18) %{{.+}}, {{i8\\*|ptr}} {{.*}} dereferenceable(18) %{{.+}}, i64 18)\n     // CHECK-NEXT: %[[EQ:.+]] = icmp eq i32 %[[CMP]], 0\n     // CHECK-NEXT: ret i1 %[[EQ]]\n     a == b\n@@ -39,9 +37,7 @@ pub fn array_eq_value_still_passed_by_pointer(a: [u16; 9], b: [u16; 9]) -> bool\n #[no_mangle]\n pub fn array_eq_long(a: &[u16; 1234], b: &[u16; 1234]) -> bool {\n     // CHECK-NEXT: start:\n-    // CHECK-NEXT: bitcast\n-    // CHECK-NEXT: bitcast\n-    // CHECK-NEXT: %[[CMP:.+]] = tail call i32 @{{bcmp|memcmp}}(i8* {{.*}} dereferenceable(2468) %{{.+}}, i8* {{.*}} dereferenceable(2468) %{{.+}}, i64 2468)\n+    // CHECK: %[[CMP:.+]] = tail call i32 @{{bcmp|memcmp}}({{i8\\*|ptr}} {{.*}} dereferenceable(2468) %{{.+}}, {{i8\\*|ptr}} {{.*}} dereferenceable(2468) %{{.+}}, i64 2468)\n     // CHECK-NEXT: %[[EQ:.+]] = icmp eq i32 %[[CMP]], 0\n     // CHECK-NEXT: ret i1 %[[EQ]]\n     a == b\n@@ -56,18 +52,17 @@ pub fn array_eq_zero_short(x: [u16; 3]) -> bool {\n     x == [0; 3]\n }\n \n-// CHECK-LABEL: @array_eq_zero_mid([8 x i16]*\n+// CHECK-LABEL: @array_eq_zero_mid(\n #[no_mangle]\n pub fn array_eq_zero_mid(x: [u16; 8]) -> bool {\n     // CHECK-NEXT: start:\n-    // CHECK-NEXT: bitcast\n-    // CHECK-NEXT: %[[LOAD:.+]] = load i128,\n+    // CHECK: %[[LOAD:.+]] = load i128,\n     // CHECK-NEXT: %[[EQ:.+]] = icmp eq i128 %[[LOAD]], 0\n     // CHECK-NEXT: ret i1 %[[EQ]]\n     x == [0; 8]\n }\n \n-// CHECK-LABEL: @array_eq_zero_long([1234 x i16]*\n+// CHECK-LABEL: @array_eq_zero_long(\n #[no_mangle]\n pub fn array_eq_zero_long(x: [u16; 1234]) -> bool {\n     // CHECK-NEXT: start:"}, {"sha": "a14f63726bb9a8748aa324131f1f483526f3a395", "filename": "src/test/codegen/atomic-operations.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fatomic-operations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fatomic-operations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fatomic-operations.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -8,25 +8,25 @@ use std::sync::atomic::{AtomicI32, Ordering::*};\n // CHECK-LABEL: @compare_exchange\n #[no_mangle]\n pub fn compare_exchange(a: &AtomicI32) {\n-    // CHECK: cmpxchg i32* %{{.*}}, i32 0, i32 10 monotonic monotonic\n+    // CHECK: cmpxchg {{i32\\*|ptr}} %{{.*}}, i32 0, i32 10 monotonic monotonic\n     let _ = a.compare_exchange(0, 10, Relaxed, Relaxed);\n \n-    // CHECK: cmpxchg i32* %{{.*}}, i32 0, i32 20 release monotonic\n+    // CHECK: cmpxchg {{i32\\*|ptr}} %{{.*}}, i32 0, i32 20 release monotonic\n     let _ = a.compare_exchange(0, 20, Release, Relaxed);\n \n-    // CHECK: cmpxchg i32* %{{.*}}, i32 0, i32 30 acquire monotonic\n-    // CHECK: cmpxchg i32* %{{.*}}, i32 0, i32 31 acquire acquire\n+    // CHECK: cmpxchg {{i32\\*|ptr}} %{{.*}}, i32 0, i32 30 acquire monotonic\n+    // CHECK: cmpxchg {{i32\\*|ptr}} %{{.*}}, i32 0, i32 31 acquire acquire\n     let _ = a.compare_exchange(0, 30, Acquire, Relaxed);\n     let _ = a.compare_exchange(0, 31, Acquire, Acquire);\n \n-    // CHECK: cmpxchg i32* %{{.*}}, i32 0, i32 40 acq_rel monotonic\n-    // CHECK: cmpxchg i32* %{{.*}}, i32 0, i32 41 acq_rel acquire\n+    // CHECK: cmpxchg {{i32\\*|ptr}} %{{.*}}, i32 0, i32 40 acq_rel monotonic\n+    // CHECK: cmpxchg {{i32\\*|ptr}} %{{.*}}, i32 0, i32 41 acq_rel acquire\n     let _ = a.compare_exchange(0, 40, AcqRel, Relaxed);\n     let _ = a.compare_exchange(0, 41, AcqRel, Acquire);\n \n-    // CHECK: cmpxchg i32* %{{.*}}, i32 0, i32 50 seq_cst monotonic\n-    // CHECK: cmpxchg i32* %{{.*}}, i32 0, i32 51 seq_cst acquire\n-    // CHECK: cmpxchg i32* %{{.*}}, i32 0, i32 52 seq_cst seq_cst\n+    // CHECK: cmpxchg {{i32\\*|ptr}} %{{.*}}, i32 0, i32 50 seq_cst monotonic\n+    // CHECK: cmpxchg {{i32\\*|ptr}} %{{.*}}, i32 0, i32 51 seq_cst acquire\n+    // CHECK: cmpxchg {{i32\\*|ptr}} %{{.*}}, i32 0, i32 52 seq_cst seq_cst\n     let _ = a.compare_exchange(0, 50, SeqCst, Relaxed);\n     let _ = a.compare_exchange(0, 51, SeqCst, Acquire);\n     let _ = a.compare_exchange(0, 52, SeqCst, SeqCst);\n@@ -35,25 +35,25 @@ pub fn compare_exchange(a: &AtomicI32) {\n // CHECK-LABEL: @compare_exchange_weak\n #[no_mangle]\n pub fn compare_exchange_weak(w: &AtomicI32) {\n-    // CHECK: cmpxchg weak i32* %{{.*}}, i32 1, i32 10 monotonic monotonic\n+    // CHECK: cmpxchg weak {{i32\\*|ptr}} %{{.*}}, i32 1, i32 10 monotonic monotonic\n     let _ = w.compare_exchange_weak(1, 10, Relaxed, Relaxed);\n \n-    // CHECK: cmpxchg weak i32* %{{.*}}, i32 1, i32 20 release monotonic\n+    // CHECK: cmpxchg weak {{i32\\*|ptr}} %{{.*}}, i32 1, i32 20 release monotonic\n     let _ = w.compare_exchange_weak(1, 20, Release, Relaxed);\n \n-    // CHECK: cmpxchg weak i32* %{{.*}}, i32 1, i32 30 acquire monotonic\n-    // CHECK: cmpxchg weak i32* %{{.*}}, i32 1, i32 31 acquire acquire\n+    // CHECK: cmpxchg weak {{i32\\*|ptr}} %{{.*}}, i32 1, i32 30 acquire monotonic\n+    // CHECK: cmpxchg weak {{i32\\*|ptr}} %{{.*}}, i32 1, i32 31 acquire acquire\n     let _ = w.compare_exchange_weak(1, 30, Acquire, Relaxed);\n     let _ = w.compare_exchange_weak(1, 31, Acquire, Acquire);\n \n-    // CHECK: cmpxchg weak i32* %{{.*}}, i32 1, i32 40 acq_rel monotonic\n-    // CHECK: cmpxchg weak i32* %{{.*}}, i32 1, i32 41 acq_rel acquire\n+    // CHECK: cmpxchg weak {{i32\\*|ptr}} %{{.*}}, i32 1, i32 40 acq_rel monotonic\n+    // CHECK: cmpxchg weak {{i32\\*|ptr}} %{{.*}}, i32 1, i32 41 acq_rel acquire\n     let _ = w.compare_exchange_weak(1, 40, AcqRel, Relaxed);\n     let _ = w.compare_exchange_weak(1, 41, AcqRel, Acquire);\n \n-    // CHECK: cmpxchg weak i32* %{{.*}}, i32 1, i32 50 seq_cst monotonic\n-    // CHECK: cmpxchg weak i32* %{{.*}}, i32 1, i32 51 seq_cst acquire\n-    // CHECK: cmpxchg weak i32* %{{.*}}, i32 1, i32 52 seq_cst seq_cst\n+    // CHECK: cmpxchg weak {{i32\\*|ptr}} %{{.*}}, i32 1, i32 50 seq_cst monotonic\n+    // CHECK: cmpxchg weak {{i32\\*|ptr}} %{{.*}}, i32 1, i32 51 seq_cst acquire\n+    // CHECK: cmpxchg weak {{i32\\*|ptr}} %{{.*}}, i32 1, i32 52 seq_cst seq_cst\n     let _ = w.compare_exchange_weak(1, 50, SeqCst, Relaxed);\n     let _ = w.compare_exchange_weak(1, 51, SeqCst, Acquire);\n     let _ = w.compare_exchange_weak(1, 52, SeqCst, SeqCst);"}, {"sha": "a5be56c47be81e131c5ec114531dbc4f56f76804", "filename": "src/test/codegen/c-variadic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fc-variadic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fc-variadic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fc-variadic.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -28,21 +28,21 @@ pub unsafe extern \"C\" fn use_foreign_c_variadic_0() {\n // Ensure that we do not remove the `va_list` passed to the foreign function when\n // removing the \"spoofed\" `VaListImpl` that is used by Rust defined C-variadics.\n pub unsafe extern \"C\" fn use_foreign_c_variadic_1_0(ap: VaList) {\n-    // CHECK: call void ({{.*}}*, ...) @foreign_c_variadic_1({{.*}} %ap)\n+    // CHECK: call void ({{.*}}, ...) @foreign_c_variadic_1({{.*}} %ap)\n     foreign_c_variadic_1(ap);\n }\n \n pub unsafe extern \"C\" fn use_foreign_c_variadic_1_1(ap: VaList) {\n-    // CHECK: call void ({{.*}}*, ...) @foreign_c_variadic_1({{.*}} %ap, [[PARAM]] 42)\n+    // CHECK: call void ({{.*}}, ...) @foreign_c_variadic_1({{.*}} %ap, [[PARAM]] 42)\n     foreign_c_variadic_1(ap, 42i32);\n }\n pub unsafe extern \"C\" fn use_foreign_c_variadic_1_2(ap: VaList) {\n-    // CHECK: call void ({{.*}}*, ...) @foreign_c_variadic_1({{.*}} %ap, [[PARAM]] 2, [[PARAM]] 42)\n+    // CHECK: call void ({{.*}}, ...) @foreign_c_variadic_1({{.*}} %ap, [[PARAM]] 2, [[PARAM]] 42)\n     foreign_c_variadic_1(ap, 2i32, 42i32);\n }\n \n pub unsafe extern \"C\" fn use_foreign_c_variadic_1_3(ap: VaList) {\n-    // CHECK: call void ({{.*}}*, ...) @foreign_c_variadic_1({{.*}} %ap, [[PARAM]] 2, [[PARAM]] 42, [[PARAM]] 0)\n+    // CHECK: call void ({{.*}}, ...) @foreign_c_variadic_1({{.*}} %ap, [[PARAM]] 2, [[PARAM]] 42, [[PARAM]] 0)\n     foreign_c_variadic_1(ap, 2i32, 42i32, 0i32);\n }\n "}, {"sha": "c97223879ca3ab4c806918dfd8b51fc2adb3838a", "filename": "src/test/codegen/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fconsts.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -43,14 +43,14 @@ pub fn inline_enum_const() -> E<i8, i16> {\n #[no_mangle]\n pub fn low_align_const() -> E<i16, [i16; 3]> {\n     // Check that low_align_const and high_align_const use the same constant\n-    // CHECK: memcpy.p0i8.p0i8.i{{(32|64)}}(i8* align 2 %1, i8* align 2 getelementptr inbounds (<{ [4 x i8], [4 x i8] }>, <{ [4 x i8], [4 x i8] }>* [[LOW_HIGH]], i32 0, i32 0, i32 0), i{{(32|64)}} 8, i1 false)\n+    // CHECK: memcpy.{{.+}}({{i8\\*|ptr}} align 2 %{{[0-9]+}}, {{i8\\*|ptr}} align 2 {{.*}}[[LOW_HIGH]]{{.*}}, i{{(32|64)}} 8, i1 false)\n     *&E::A(0)\n }\n \n // CHECK-LABEL: @high_align_const\n #[no_mangle]\n pub fn high_align_const() -> E<i16, i32> {\n     // Check that low_align_const and high_align_const use the same constant\n-    // CHECK: memcpy.p0i8.p0i8.i{{(32|64)}}(i8* align 4 %1, i8* align 4 getelementptr inbounds (<{ [4 x i8], [4 x i8] }>, <{ [4 x i8], [4 x i8] }>* [[LOW_HIGH]], i32 0, i32 0, i32 0), i{{(32|64)}} 8, i1 false)\n+    // CHECK: memcpy.{{.+}}({{i8\\*|ptr}} align 4 %{{[0-9]+}}, {{i8\\*|ptr}} align 4 {{.*}}[[LOW_HIGH]]{{.*}}, i{{(32|64)}} 8, i1 false)\n     *&E::A(0)\n }"}, {"sha": "d426ade28dd12696dd41073ef60b46ff526f8793", "filename": "src/test/codegen/fastcall-inreg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Ffastcall-inreg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Ffastcall-inreg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffastcall-inreg.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -19,7 +19,7 @@ pub mod tests {\n     #[no_mangle]\n     pub extern \"fastcall\" fn f1(_: i32, _: i32, _: i32) {}\n \n-    // CHECK: @f2(i32* inreg %_1, i32* inreg %_2, i32* %_3)\n+    // CHECK: @f2({{i32\\*|ptr}} inreg %_1, {{i32\\*|ptr}} inreg %_2, {{i32\\*|ptr}} %_3)\n     #[no_mangle]\n     pub extern \"fastcall\" fn f2(_: *const i32, _: *const i32, _: *const i32) {}\n "}, {"sha": "099726b2f086e3c02764709de3b4aa40689f65b4", "filename": "src/test/codegen/ffi-out-of-bounds-loads.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fffi-out-of-bounds-loads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fffi-out-of-bounds-loads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fffi-out-of-bounds-loads.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -18,7 +18,7 @@ extern \"C\" {\n fn main() {\n     let s = S { f1: 1, f2: 2, f3: 3 };\n     unsafe {\n-        // CHECK: load { i64, i32 }, { i64, i32 }* {{.*}}, align 4\n+        // CHECK: load { i64, i32 }, {{.*}}, align 4\n         // CHECK: call void @foo({ i64, i32 } {{.*}})\n         foo(s);\n     }"}, {"sha": "ff76405a4ea323338c45c98751756216f76f4f30", "filename": "src/test/codegen/function-arguments-noopt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Ffunction-arguments-noopt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Ffunction-arguments-noopt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffunction-arguments-noopt.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -23,7 +23,7 @@ pub fn boolean_call(x: bool, f: fn(bool) -> bool) -> bool {\n   f(x)\n }\n \n-// CHECK: align 4 i32* @borrow(i32* align 4 %x)\n+// CHECK: align 4 {{i32\\*|ptr}} @borrow({{i32\\*|ptr}} align 4 %x)\n #[no_mangle]\n pub fn borrow(x: &i32) -> &i32 {\n   x\n@@ -32,11 +32,11 @@ pub fn borrow(x: &i32) -> &i32 {\n // CHECK-LABEL: @borrow_call\n #[no_mangle]\n pub fn borrow_call(x: &i32, f: fn(&i32) -> &i32) -> &i32 {\n-  // CHECK: call align 4 i32* %f(i32* align 4 %x)\n+  // CHECK: call align 4 {{i32\\*|ptr}} %f({{i32\\*|ptr}} align 4 %x)\n   f(x)\n }\n \n-// CHECK: void @struct_(%S* sret(%S){{( %0)?}}, %S* %x)\n+// CHECK: void @struct_({{%S\\*|ptr}} sret(%S){{( %0)?}}, {{%S\\*|ptr}} %x)\n #[no_mangle]\n pub fn struct_(x: S) -> S {\n   x\n@@ -45,7 +45,7 @@ pub fn struct_(x: S) -> S {\n // CHECK-LABEL: @struct_call\n #[no_mangle]\n pub fn struct_call(x: S, f: fn(S) -> S) -> S {\n-  // CHECK: call void %f(%S* sret(%S){{( %0)?}}, %S* %{{.+}})\n+  // CHECK: call void %f({{%S\\*|ptr}} sret(%S){{( %0)?}}, {{%S\\*|ptr}} %{{.+}})\n   f(x)\n }\n "}, {"sha": "ae6abe7a184c65f4ba86558ce5a1492ff8c7da25", "filename": "src/test/codegen/function-arguments.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -73,67 +73,67 @@ pub fn option_nonzero_int(x: Option<NonZeroU64>) -> Option<NonZeroU64> {\n   x\n }\n \n-// CHECK: @readonly_borrow(i32* noalias noundef readonly align 4 dereferenceable(4) %_1)\n+// CHECK: @readonly_borrow({{i32\\*|ptr}} noalias noundef readonly align 4 dereferenceable(4) %_1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn readonly_borrow(_: &i32) {\n }\n \n-// CHECK: @static_borrow(i32* noalias noundef readonly align 4 dereferenceable(4) %_1)\n+// CHECK: @static_borrow({{i32\\*|ptr}} noalias noundef readonly align 4 dereferenceable(4) %_1)\n // static borrow may be captured\n #[no_mangle]\n pub fn static_borrow(_: &'static i32) {\n }\n \n-// CHECK: @named_borrow(i32* noalias noundef readonly align 4 dereferenceable(4) %_1)\n+// CHECK: @named_borrow({{i32\\*|ptr}} noalias noundef readonly align 4 dereferenceable(4) %_1)\n // borrow with named lifetime may be captured\n #[no_mangle]\n pub fn named_borrow<'r>(_: &'r i32) {\n }\n \n-// CHECK: @unsafe_borrow(i16* noundef align 2 dereferenceable(2) %_1)\n+// CHECK: @unsafe_borrow({{i16\\*|ptr}} noundef align 2 dereferenceable(2) %_1)\n // unsafe interior means this isn't actually readonly and there may be aliases ...\n #[no_mangle]\n pub fn unsafe_borrow(_: &UnsafeInner) {\n }\n \n-// CHECK: @mutable_unsafe_borrow(i16* noalias noundef align 2 dereferenceable(2) %_1)\n+// CHECK: @mutable_unsafe_borrow({{i16\\*|ptr}} noalias noundef align 2 dereferenceable(2) %_1)\n // ... unless this is a mutable borrow, those never alias\n #[no_mangle]\n pub fn mutable_unsafe_borrow(_: &mut UnsafeInner) {\n }\n \n-// CHECK: @mutable_borrow(i32* noalias noundef align 4 dereferenceable(4) %_1)\n+// CHECK: @mutable_borrow({{i32\\*|ptr}} noalias noundef align 4 dereferenceable(4) %_1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn mutable_borrow(_: &mut i32) {\n }\n \n-// CHECK: @indirect_struct(%S* noalias nocapture noundef dereferenceable(32) %_1)\n+// CHECK: @indirect_struct({{%S\\*|ptr}} noalias nocapture noundef dereferenceable(32) %_1)\n #[no_mangle]\n pub fn indirect_struct(_: S) {\n }\n \n-// CHECK: @borrowed_struct(%S* noalias noundef readonly align 4 dereferenceable(32) %_1)\n+// CHECK: @borrowed_struct({{%S\\*|ptr}} noalias noundef readonly align 4 dereferenceable(32) %_1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn borrowed_struct(_: &S) {\n }\n \n-// CHECK: @raw_struct(%S* %_1)\n+// CHECK: @raw_struct({{%S\\*|ptr}} %_1)\n #[no_mangle]\n pub fn raw_struct(_: *const S) {\n }\n \n // `Box` can get deallocated during execution of the function, so it should\n // not get `dereferenceable`.\n-// CHECK: noalias noundef nonnull align 4 i32* @_box(i32* noalias noundef nonnull align 4 %x)\n+// CHECK: noalias noundef nonnull align 4 {{i32\\*|ptr}} @_box({{i32\\*|ptr}} noalias noundef nonnull align 4 %x)\n #[no_mangle]\n pub fn _box(x: Box<i32>) -> Box<i32> {\n   x\n }\n \n-// CHECK: @struct_return(%S* noalias nocapture noundef sret(%S) dereferenceable(32){{( %0)?}})\n+// CHECK: @struct_return({{%S\\*|ptr}} noalias nocapture noundef sret(%S) dereferenceable(32){{( %0)?}})\n #[no_mangle]\n pub fn struct_return() -> S {\n   S {\n@@ -147,58 +147,58 @@ pub fn struct_return() -> S {\n pub fn helper(_: usize) {\n }\n \n-// CHECK: @slice([0 x i8]* noalias noundef nonnull readonly align 1 %_1.0, [[USIZE]] %_1.1)\n+// CHECK: @slice({{\\[0 x i8\\]\\*|ptr}} noalias noundef nonnull readonly align 1 %_1.0, [[USIZE]] %_1.1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn slice(_: &[u8]) {\n }\n \n-// CHECK: @mutable_slice([0 x i8]* noalias noundef nonnull align 1 %_1.0, [[USIZE]] %_1.1)\n+// CHECK: @mutable_slice({{\\[0 x i8\\]\\*|ptr}} noalias noundef nonnull align 1 %_1.0, [[USIZE]] %_1.1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn mutable_slice(_: &mut [u8]) {\n }\n \n-// CHECK: @unsafe_slice([0 x i16]* noundef nonnull align 2 %_1.0, [[USIZE]] %_1.1)\n+// CHECK: @unsafe_slice({{\\[0 x i16\\]\\*|ptr}} noundef nonnull align 2 %_1.0, [[USIZE]] %_1.1)\n // unsafe interior means this isn't actually readonly and there may be aliases ...\n #[no_mangle]\n pub fn unsafe_slice(_: &[UnsafeInner]) {\n }\n \n-// CHECK: @raw_slice([0 x i8]* %_1.0, [[USIZE]] %_1.1)\n+// CHECK: @raw_slice({{\\[0 x i8\\]\\*|ptr}} %_1.0, [[USIZE]] %_1.1)\n #[no_mangle]\n pub fn raw_slice(_: *const [u8]) {\n }\n \n-// CHECK: @str([0 x i8]* noalias noundef nonnull readonly align 1 %_1.0, [[USIZE]] %_1.1)\n+// CHECK: @str({{\\[0 x i8\\]\\*|ptr}} noalias noundef nonnull readonly align 1 %_1.0, [[USIZE]] %_1.1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn str(_: &[u8]) {\n }\n \n-// CHECK: @trait_borrow({}* noundef nonnull align 1 %_1.0, [3 x [[USIZE]]]* noalias noundef readonly align {{.*}} dereferenceable({{.*}}) %_1.1)\n+// CHECK: @trait_borrow({{\\{\\}\\*|ptr}} noundef nonnull align 1 %_1.0, {{.+}} noalias noundef readonly align {{.*}} dereferenceable({{.*}}) %_1.1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn trait_borrow(_: &Drop) {\n }\n \n-// CHECK: @trait_raw({}* %_1.0, [3 x [[USIZE]]]* noalias noundef readonly align {{.*}} dereferenceable({{.*}}) %_1.1)\n+// CHECK: @trait_raw({{\\{\\}\\*|ptr}} %_1.0, {{.+}} noalias noundef readonly align {{.*}} dereferenceable({{.*}}) %_1.1)\n #[no_mangle]\n pub fn trait_raw(_: *const Drop) {\n }\n \n-// CHECK: @trait_box({}* noalias noundef nonnull align 1{{( %0)?}}, [3 x [[USIZE]]]* noalias noundef readonly align {{.*}} dereferenceable({{.*}}){{( %1)?}})\n+// CHECK: @trait_box({{\\{\\}\\*|ptr}} noalias noundef nonnull align 1{{( %0)?}}, {{.+}} noalias noundef readonly align {{.*}} dereferenceable({{.*}}){{( %1)?}})\n #[no_mangle]\n pub fn trait_box(_: Box<Drop>) {\n }\n \n-// CHECK: { i8*, i8* } @trait_option(i8* noalias noundef align 1 %x.0, i8* %x.1)\n+// CHECK: { {{i8\\*|ptr}}, {{i8\\*|ptr}} } @trait_option({{i8\\*|ptr}} noalias noundef align 1 %x.0, {{i8\\*|ptr}} %x.1)\n #[no_mangle]\n pub fn trait_option(x: Option<Box<Drop>>) -> Option<Box<Drop>> {\n   x\n }\n \n-// CHECK: { [0 x i16]*, [[USIZE]] } @return_slice([0 x i16]* noalias noundef nonnull readonly align 2 %x.0, [[USIZE]] %x.1)\n+// CHECK: { {{\\[0 x i16\\]\\*|ptr}}, [[USIZE]] } @return_slice({{\\[0 x i16\\]\\*|ptr}} noalias noundef nonnull readonly align 2 %x.0, [[USIZE]] %x.1)\n #[no_mangle]\n pub fn return_slice(x: &[u16]) -> &[u16] {\n   x\n@@ -216,7 +216,7 @@ pub fn enum_id_2(x: Option<u8>) -> Option<u8> {\n   x\n }\n \n-// CHECK: noalias i8* @allocator()\n+// CHECK: noalias {{i8\\*|ptr}} @allocator()\n #[no_mangle]\n #[rustc_allocator]\n pub fn allocator() -> *const i8 {"}, {"sha": "002be8d1b419233ca33760a36ba2b57468f1960b", "filename": "src/test/codegen/gdb_debug_script_load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fgdb_debug_script_load.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fgdb_debug_script_load.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fgdb_debug_script_load.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -9,7 +9,7 @@\n #![feature(start)]\n \n // CHECK-LABEL: @main\n-// CHECK: load volatile i8, i8* getelementptr inbounds ([[B:\\[[0-9]* x i8\\]]], [[B]]* @__rustc_debug_gdb_scripts_section__, i32 0, i32 0), align 1\n+// CHECK: load volatile i8, {{.+}} @__rustc_debug_gdb_scripts_section__\n \n #[start]\n fn start(_: isize, _: *const *const u8) -> isize {"}, {"sha": "d8ee29452662032e86e745481bb77d040860a808", "filename": "src/test/codegen/intrinsics/nontemporal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fintrinsics%2Fnontemporal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fintrinsics%2Fnontemporal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fintrinsics%2Fnontemporal.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -6,7 +6,7 @@\n #[no_mangle]\n pub fn a(a: &mut u32, b: u32) {\n     // CHECK-LABEL: define{{.*}}void @a\n-    // CHECK: store i32 %b, i32* %a, align 4, !nontemporal\n+    // CHECK: store i32 %b, {{i32\\*|ptr}} %a, align 4, !nontemporal\n     unsafe {\n         std::intrinsics::nontemporal_store(a, b);\n     }"}, {"sha": "59d7fa6381b8f4d1c9146fde9476c6b25c733491", "filename": "src/test/codegen/intrinsics/prefetch.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fintrinsics%2Fprefetch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fintrinsics%2Fprefetch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fintrinsics%2Fprefetch.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -9,55 +9,55 @@ use std::intrinsics::{prefetch_read_data, prefetch_write_data,\n #[no_mangle]\n pub fn check_prefetch_read_data(data: &[i8]) {\n     unsafe {\n-        // CHECK: call void @llvm.prefetch{{.*}}(i8* %{{.*}}, i32 0, i32 0, i32 1)\n+        // CHECK: call void @llvm.prefetch{{.*}}({{.*}}, i32 0, i32 0, i32 1)\n         prefetch_read_data(data.as_ptr(), 0);\n-        // CHECK: call void @llvm.prefetch{{.*}}(i8* %{{.*}}, i32 0, i32 1, i32 1)\n+        // CHECK: call void @llvm.prefetch{{.*}}({{.*}}, i32 0, i32 1, i32 1)\n         prefetch_read_data(data.as_ptr(), 1);\n-        // CHECK: call void @llvm.prefetch{{.*}}(i8* %{{.*}}, i32 0, i32 2, i32 1)\n+        // CHECK: call void @llvm.prefetch{{.*}}({{.*}}, i32 0, i32 2, i32 1)\n         prefetch_read_data(data.as_ptr(), 2);\n-        // CHECK: call void @llvm.prefetch{{.*}}(i8* %{{.*}}, i32 0, i32 3, i32 1)\n+        // CHECK: call void @llvm.prefetch{{.*}}({{.*}}, i32 0, i32 3, i32 1)\n         prefetch_read_data(data.as_ptr(), 3);\n     }\n }\n \n #[no_mangle]\n pub fn check_prefetch_write_data(data: &[i8]) {\n     unsafe {\n-        // CHECK: call void @llvm.prefetch{{.*}}(i8* %{{.*}}, i32 1, i32 0, i32 1)\n+        // CHECK: call void @llvm.prefetch{{.*}}({{.*}}, i32 1, i32 0, i32 1)\n         prefetch_write_data(data.as_ptr(), 0);\n-        // CHECK: call void @llvm.prefetch{{.*}}(i8* %{{.*}}, i32 1, i32 1, i32 1)\n+        // CHECK: call void @llvm.prefetch{{.*}}({{.*}}, i32 1, i32 1, i32 1)\n         prefetch_write_data(data.as_ptr(), 1);\n-        // CHECK: call void @llvm.prefetch{{.*}}(i8* %{{.*}}, i32 1, i32 2, i32 1)\n+        // CHECK: call void @llvm.prefetch{{.*}}({{.*}}, i32 1, i32 2, i32 1)\n         prefetch_write_data(data.as_ptr(), 2);\n-        // CHECK: call void @llvm.prefetch{{.*}}(i8* %{{.*}}, i32 1, i32 3, i32 1)\n+        // CHECK: call void @llvm.prefetch{{.*}}({{.*}}, i32 1, i32 3, i32 1)\n         prefetch_write_data(data.as_ptr(), 3);\n     }\n }\n \n #[no_mangle]\n pub fn check_prefetch_read_instruction(data: &[i8]) {\n     unsafe {\n-        // CHECK: call void @llvm.prefetch{{.*}}(i8* %{{.*}}, i32 0, i32 0, i32 0)\n+        // CHECK: call void @llvm.prefetch{{.*}}({{.*}}, i32 0, i32 0, i32 0)\n         prefetch_read_instruction(data.as_ptr(), 0);\n-        // CHECK: call void @llvm.prefetch{{.*}}(i8* %{{.*}}, i32 0, i32 1, i32 0)\n+        // CHECK: call void @llvm.prefetch{{.*}}({{.*}}, i32 0, i32 1, i32 0)\n         prefetch_read_instruction(data.as_ptr(), 1);\n-        // CHECK: call void @llvm.prefetch{{.*}}(i8* %{{.*}}, i32 0, i32 2, i32 0)\n+        // CHECK: call void @llvm.prefetch{{.*}}({{.*}}, i32 0, i32 2, i32 0)\n         prefetch_read_instruction(data.as_ptr(), 2);\n-        // CHECK: call void @llvm.prefetch{{.*}}(i8* %{{.*}}, i32 0, i32 3, i32 0)\n+        // CHECK: call void @llvm.prefetch{{.*}}({{.*}}, i32 0, i32 3, i32 0)\n         prefetch_read_instruction(data.as_ptr(), 3);\n     }\n }\n \n #[no_mangle]\n pub fn check_prefetch_write_instruction(data: &[i8]) {\n     unsafe {\n-        // CHECK: call void @llvm.prefetch{{.*}}(i8* %{{.*}}, i32 1, i32 0, i32 0)\n+        // CHECK: call void @llvm.prefetch{{.*}}({{.*}}, i32 1, i32 0, i32 0)\n         prefetch_write_instruction(data.as_ptr(), 0);\n-        // CHECK: call void @llvm.prefetch{{.*}}(i8* %{{.*}}, i32 1, i32 1, i32 0)\n+        // CHECK: call void @llvm.prefetch{{.*}}({{.*}}, i32 1, i32 1, i32 0)\n         prefetch_write_instruction(data.as_ptr(), 1);\n-        // CHECK: call void @llvm.prefetch{{.*}}(i8* %{{.*}}, i32 1, i32 2, i32 0)\n+        // CHECK: call void @llvm.prefetch{{.*}}({{.*}}, i32 1, i32 2, i32 0)\n         prefetch_write_instruction(data.as_ptr(), 2);\n-        // CHECK: call void @llvm.prefetch{{.*}}(i8* %{{.*}}, i32 1, i32 3, i32 0)\n+        // CHECK: call void @llvm.prefetch{{.*}}({{.*}}, i32 1, i32 3, i32 0)\n         prefetch_write_instruction(data.as_ptr(), 3);\n     }\n }"}, {"sha": "7980c00e7e729c69c94ccbe46716a1fe34238d8d", "filename": "src/test/codegen/intrinsics/volatile.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fintrinsics%2Fvolatile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fintrinsics%2Fvolatile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fintrinsics%2Fvolatile.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -8,21 +8,21 @@ use std::intrinsics;\n // CHECK-LABEL: @volatile_copy_memory\n #[no_mangle]\n pub unsafe fn volatile_copy_memory(a: *mut u8, b: *const u8) {\n-    // CHECK: llvm.memmove.p0i8.p0i8.{{\\w*(.*true)}}\n+    // CHECK: llvm.memmove.{{\\w*(.*true)}}\n     intrinsics::volatile_copy_memory(a, b, 1)\n }\n \n // CHECK-LABEL: @volatile_copy_nonoverlapping_memory\n #[no_mangle]\n pub unsafe fn volatile_copy_nonoverlapping_memory(a: *mut u8, b: *const u8) {\n-    // CHECK: llvm.memcpy.p0i8.p0i8.{{\\w*(.*true)}}\n+    // CHECK: llvm.memcpy.{{\\w*(.*true)}}\n     intrinsics::volatile_copy_nonoverlapping_memory(a, b, 1)\n }\n \n // CHECK-LABEL: @volatile_set_memory\n #[no_mangle]\n pub unsafe fn volatile_set_memory(a: *mut u8, b: u8) {\n-    // CHECK: llvm.memset.p0i8.{{\\w*(.*true)}}\n+    // CHECK: llvm.memset.{{\\w*(.*true)}}\n     intrinsics::volatile_set_memory(a, b, 1)\n }\n "}, {"sha": "99469831a6c40c961ae325cb765cebd73342b7dd", "filename": "src/test/codegen/intrinsics/volatile_order.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fintrinsics%2Fvolatile_order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fintrinsics%2Fvolatile_order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fintrinsics%2Fvolatile_order.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -13,6 +13,6 @@ pub unsafe fn test_volatile_order() {\n     volatile_store(&mut *a, 12);\n     // CHECK: store volatile\n     unaligned_volatile_store(&mut *a, 12);\n-    // CHECK: llvm.memset.p0i8\n+    // CHECK: llvm.memset.p0\n     volatile_set_memory(&mut *a, 12, 1)\n }"}, {"sha": "ee63a783f52db909a8e7d0941ad58af58ef1299a", "filename": "src/test/codegen/issue-37945.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fissue-37945.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fissue-37945.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fissue-37945.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -15,9 +15,9 @@ use std::slice::Iter;\n pub fn is_empty_1(xs: Iter<f32>) -> bool {\n // CHECK-LABEL: @is_empty_1(\n // CHECK-NEXT:  start:\n-// CHECK-NEXT:    [[A:%.*]] = icmp ne i32* %xs.1, null\n+// CHECK-NEXT:    [[A:%.*]] = icmp ne {{i32\\*|ptr}} %xs.1, null\n // CHECK-NEXT:    tail call void @llvm.assume(i1 [[A]])\n-// CHECK-NEXT:    [[B:%.*]] = icmp eq i32* %xs.0, %xs.1\n+// CHECK-NEXT:    [[B:%.*]] = icmp eq {{i32\\*|ptr}} %xs.0, %xs.1\n // CHECK-NEXT:    ret i1 [[B:%.*]]\n     {xs}.next().is_none()\n }\n@@ -26,9 +26,9 @@ pub fn is_empty_1(xs: Iter<f32>) -> bool {\n pub fn is_empty_2(xs: Iter<f32>) -> bool {\n // CHECK-LABEL: @is_empty_2\n // CHECK-NEXT:  start:\n-// CHECK-NEXT:    [[C:%.*]] = icmp ne i32* %xs.1, null\n+// CHECK-NEXT:    [[C:%.*]] = icmp ne {{i32\\*|ptr}} %xs.1, null\n // CHECK-NEXT:    tail call void @llvm.assume(i1 [[C]])\n-// CHECK-NEXT:    [[D:%.*]] = icmp eq i32* %xs.0, %xs.1\n+// CHECK-NEXT:    [[D:%.*]] = icmp eq {{i32\\*|ptr}} %xs.0, %xs.1\n // CHECK-NEXT:    ret i1 [[D:%.*]]\n     xs.map(|&x| x).next().is_none()\n }"}, {"sha": "4dc9ebfebbcdf2af63c7f11d213dacfc4820638b", "filename": "src/test/codegen/issue-56267-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fissue-56267-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fissue-56267-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fissue-56267-2.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -11,7 +11,7 @@ pub struct Foo<T> {\n // The load from bar.1 should have alignment 4. Not checking\n // other loads here, as the alignment will be platform-dependent.\n \n-// CHECK: %{{.+}} = load i32, i32* %{{.+}}, align 4\n+// CHECK: %{{.+}} = load i32, {{i32\\*|ptr}} %{{.+}}, align 4\n #[no_mangle]\n pub fn test(x: Foo<(i32, i32)>) -> (i32, i32) {\n     x.bar"}, {"sha": "7bdd2577998327d62837556010a7cac2658e53e6", "filename": "src/test/codegen/issue-56267.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fissue-56267.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fissue-56267.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fissue-56267.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -11,7 +11,7 @@ pub struct Foo<T> {\n // The store writing to bar.1 should have alignment 4. Not checking\n // other stores here, as the alignment will be platform-dependent.\n \n-// CHECK: store i32 [[TMP1:%.+]], i32* [[TMP2:%.+]], align 4\n+// CHECK: store i32 [[TMP1:%.+]], {{i32\\*|ptr}} [[TMP2:%.+]], align 4\n #[no_mangle]\n pub fn test(x: (i32, i32)) -> Foo<(i32, i32)> {\n     Foo { foo: 0, bar: x }"}, {"sha": "044d721814bd345565615596019aa216ae2f17e3", "filename": "src/test/codegen/issue-56927.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fissue-56927.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fissue-56927.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fissue-56927.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -8,10 +8,10 @@ pub struct S {\n }\n \n // CHECK-LABEL: @test1\n-// CHECK: store i32 0, i32* %{{.+}}, align 16\n-// CHECK: store i32 1, i32* %{{.+}}, align 4\n-// CHECK: store i32 2, i32* %{{.+}}, align 8\n-// CHECK: store i32 3, i32* %{{.+}}, align 4\n+// CHECK: store i32 0, {{i32\\*|ptr}} %{{.+}}, align 16\n+// CHECK: store i32 1, {{i32\\*|ptr}} %{{.+}}, align 4\n+// CHECK: store i32 2, {{i32\\*|ptr}} %{{.+}}, align 8\n+// CHECK: store i32 3, {{i32\\*|ptr}} %{{.+}}, align 4\n #[no_mangle]\n pub fn test1(s: &mut S) {\n     s.arr[0] = 0;\n@@ -21,22 +21,22 @@ pub fn test1(s: &mut S) {\n }\n \n // CHECK-LABEL: @test2\n-// CHECK: store i32 4, i32* %{{.+}}, align 4\n+// CHECK: store i32 4, {{i32\\*|ptr}} %{{.+}}, align 4\n #[allow(unconditional_panic)]\n #[no_mangle]\n pub fn test2(s: &mut S) {\n     s.arr[usize::MAX / 4 + 1] = 4;\n }\n \n // CHECK-LABEL: @test3\n-// CHECK: store i32 5, i32* %{{.+}}, align 4\n+// CHECK: store i32 5, {{i32\\*|ptr}} %{{.+}}, align 4\n #[no_mangle]\n pub fn test3(s: &mut S, i: usize) {\n     s.arr[i] = 5;\n }\n \n // CHECK-LABEL: @test4\n-// CHECK: store i32 6, i32* %{{.+}}, align 4\n+// CHECK: store i32 6, {{i32\\*|ptr}} %{{.+}}, align 4\n #[no_mangle]\n pub fn test4(s: &mut S) {\n     s.arr = [6; 4];"}, {"sha": "0900a33377bcdc41993464d83fb5043e9bccde70", "filename": "src/test/codegen/issue-58881.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fissue-58881.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fissue-58881.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fissue-58881.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -16,6 +16,6 @@ struct Bar(u64, u64, u64);\n \n // Ensure that emit arguments of the correct type.\n pub unsafe fn test_call_variadic() {\n-    // CHECK: call void (i32, ...) @variadic_fn(i32 0, i8 {{.*}}, %Bar* {{.*}})\n+    // CHECK: call void (i32, ...) @variadic_fn(i32 0, i8 {{.*}}, {{%Bar\\*|ptr}} {{.*}})\n     variadic_fn(0, Foo(0), Bar(0, 0, 0))\n }"}, {"sha": "471a0b8cedd78aff34d617f868c4e18551a4c6a5", "filename": "src/test/codegen/lifetime_start_end.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Flifetime_start_end.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Flifetime_start_end.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Flifetime_start_end.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -5,38 +5,30 @@\n // CHECK-LABEL: @test\n #[no_mangle]\n pub fn test() {\n-    let a = 0;\n+    let a = 0u8;\n     &a; // keep variable in an alloca\n \n-// CHECK: [[S_a:%[0-9]+]] = bitcast i32* %a to i8*\n-// CHECK: call void @llvm.lifetime.start{{.*}}(i{{[0-9 ]+}}, i8* [[S_a]])\n+// CHECK: call void @llvm.lifetime.start{{.*}}(i{{[0-9 ]+}}, {{i8\\*|ptr}} %a)\n \n     {\n         let b = &Some(a);\n         &b; // keep variable in an alloca\n \n-// CHECK: [[S_b:%[0-9]+]] = bitcast { i32, i32 }** %b to i8*\n-// CHECK: call void @llvm.lifetime.start{{.*}}(i{{[0-9 ]+}}, i8* [[S_b]])\n+// CHECK: call void @llvm.lifetime.start{{.*}}(i{{[0-9 ]+}}, {{.*}})\n \n-// CHECK: [[S__4:%[0-9]+]] = bitcast { i32, i32 }* %_5 to i8*\n-// CHECK: call void @llvm.lifetime.start{{.*}}(i{{[0-9 ]+}}, i8* [[S__4]])\n+// CHECK: call void @llvm.lifetime.start{{.*}}(i{{[0-9 ]+}}, {{.*}})\n \n-// CHECK: [[E__4:%[0-9]+]] = bitcast { i32, i32 }* %_5 to i8*\n-// CHECK: call void @llvm.lifetime.end{{.*}}(i{{[0-9 ]+}}, i8* [[E__4]])\n+// CHECK: call void @llvm.lifetime.end{{.*}}(i{{[0-9 ]+}}, {{.*}})\n \n-// CHECK: [[E_b:%[0-9]+]] = bitcast { i32, i32 }** %b to i8*\n-// CHECK: call void @llvm.lifetime.end{{.*}}(i{{[0-9 ]+}}, i8* [[E_b]])\n+// CHECK: call void @llvm.lifetime.end{{.*}}(i{{[0-9 ]+}}, {{.*}})\n     }\n \n-    let c = 1;\n+    let c = 1u8;\n     &c; // keep variable in an alloca\n \n-// CHECK: [[S_c:%[0-9]+]] = bitcast i32* %c to i8*\n-// CHECK: call void @llvm.lifetime.start{{.*}}(i{{[0-9 ]+}}, i8* [[S_c]])\n+// CHECK: call void @llvm.lifetime.start{{.*}}(i{{[0-9 ]+}}, {{i8\\*|ptr}} %c)\n \n-// CHECK: [[E_c:%[0-9]+]] = bitcast i32* %c to i8*\n-// CHECK: call void @llvm.lifetime.end{{.*}}(i{{[0-9 ]+}}, i8* [[E_c]])\n+// CHECK: call void @llvm.lifetime.end{{.*}}(i{{[0-9 ]+}}, {{i8\\*|ptr}} %c)\n \n-// CHECK: [[E_a:%[0-9]+]] = bitcast i32* %a to i8*\n-// CHECK: call void @llvm.lifetime.end{{.*}}(i{{[0-9 ]+}}, i8* [[E_a]])\n+// CHECK: call void @llvm.lifetime.end{{.*}}(i{{[0-9 ]+}}, {{i8\\*|ptr}} %a)\n }"}, {"sha": "07de385193f749232f0c20e9238c9de7fbcefb45", "filename": "src/test/codegen/loads.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Floads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Floads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Floads.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -21,108 +21,108 @@ pub enum MyBool {\n #[repr(align(16))]\n pub struct Align16(u128);\n \n-// CHECK: @ptr_alignment_helper({}** {{.*}}align [[PTR_ALIGNMENT:[0-9]+]]\n+// CHECK: @ptr_alignment_helper({{.*}}align [[PTR_ALIGNMENT:[0-9]+]]\n #[no_mangle]\n pub fn ptr_alignment_helper(x: &&()) {}\n \n // CHECK-LABEL: @load_ref\n #[no_mangle]\n pub fn load_ref<'a>(x: &&'a i32) -> &'a i32 {\n-// CHECK: load i32*, i32** %x, align [[PTR_ALIGNMENT]], !nonnull !{{[0-9]+}}, !align ![[ALIGN_4_META:[0-9]+]], !noundef !{{[0-9]+}}\n+// CHECK: load {{i32\\*|ptr}}, {{i32\\*\\*|ptr}} %x, align [[PTR_ALIGNMENT]], !nonnull !{{[0-9]+}}, !align ![[ALIGN_4_META:[0-9]+]], !noundef !{{[0-9]+}}\n     *x\n }\n \n // CHECK-LABEL: @load_ref_higher_alignment\n #[no_mangle]\n pub fn load_ref_higher_alignment<'a>(x: &&'a Align16) -> &'a Align16 {\n-// CHECK: load {{%Align16|i128}}*, {{%Align16|i128}}** %x, align [[PTR_ALIGNMENT]], !nonnull !{{[0-9]+}}, !align ![[ALIGN_16_META:[0-9]+]], !noundef !{{[0-9]+}}\n+// CHECK: load {{%Align16\\*|i128\\*|ptr}}, {{%Align16\\*\\*|i128\\*\\*|ptr}} %x, align [[PTR_ALIGNMENT]], !nonnull !{{[0-9]+}}, !align ![[ALIGN_16_META:[0-9]+]], !noundef !{{[0-9]+}}\n     *x\n }\n \n // CHECK-LABEL: @load_scalar_pair\n #[no_mangle]\n pub fn load_scalar_pair<'a>(x: &(&'a i32, &'a Align16)) -> (&'a i32, &'a Align16) {\n-// CHECK: load i32*, i32** %{{.+}}, align [[PTR_ALIGNMENT]], !nonnull !{{[0-9]+}}, !align ![[ALIGN_4_META]], !noundef !{{[0-9]+}}\n-// CHECK: load i64*, i64** %{{.+}}, align [[PTR_ALIGNMENT]], !nonnull !{{[0-9]+}}, !align ![[ALIGN_16_META]], !noundef !{{[0-9]+}}\n+// CHECK: load {{i32\\*|ptr}}, {{i32\\*\\*|ptr}} %{{.+}}, align [[PTR_ALIGNMENT]], !nonnull !{{[0-9]+}}, !align ![[ALIGN_4_META]], !noundef !{{[0-9]+}}\n+// CHECK: load {{i64\\*|ptr}}, {{i64\\*\\*|ptr}} %{{.+}}, align [[PTR_ALIGNMENT]], !nonnull !{{[0-9]+}}, !align ![[ALIGN_16_META]], !noundef !{{[0-9]+}}\n     *x\n }\n \n // CHECK-LABEL: @load_raw_pointer\n #[no_mangle]\n pub fn load_raw_pointer<'a>(x: &*const i32) -> *const i32 {\n // loaded raw pointer should not have !nonnull, !align, or !noundef metadata\n-// CHECK: load i32*, i32** %x, align [[PTR_ALIGNMENT]]{{$}}\n+// CHECK: load {{i32\\*|ptr}}, {{i32\\*\\*|ptr}} %x, align [[PTR_ALIGNMENT]]{{$}}\n     *x\n }\n \n // CHECK-LABEL: @load_box\n #[no_mangle]\n pub fn load_box<'a>(x: Box<Box<i32>>) -> Box<i32> {\n-// CHECK: load i32*, i32** %x, align [[PTR_ALIGNMENT]], !nonnull !{{[0-9]+}}, !align ![[ALIGN_4_META]], !noundef !{{[0-9]+}}\n+// CHECK: load {{i32\\*|ptr}}, {{i32\\*\\*|ptr}} %x, align [[PTR_ALIGNMENT]], !nonnull !{{[0-9]+}}, !align ![[ALIGN_4_META]], !noundef !{{[0-9]+}}\n     *x\n }\n \n // CHECK-LABEL: @load_bool\n #[no_mangle]\n pub fn load_bool(x: &bool) -> bool {\n-// CHECK: load i8, i8* %x, align 1, !range ![[BOOL_RANGE:[0-9]+]], !noundef !{{[0-9]+}}\n+// CHECK: load i8, {{i8\\*|ptr}} %x, align 1, !range ![[BOOL_RANGE:[0-9]+]], !noundef !{{[0-9]+}}\n     *x\n }\n \n // CHECK-LABEL: @load_maybeuninit_bool\n #[no_mangle]\n pub fn load_maybeuninit_bool(x: &MaybeUninit<bool>) -> MaybeUninit<bool> {\n-// CHECK: load i8, i8* %x, align 1{{$}}\n+// CHECK: load i8, {{i8\\*|ptr}} %x, align 1{{$}}\n     *x\n }\n \n // CHECK-LABEL: @load_enum_bool\n #[no_mangle]\n pub fn load_enum_bool(x: &MyBool) -> MyBool {\n-// CHECK: load i8, i8* %x, align 1, !range ![[BOOL_RANGE]], !noundef !{{[0-9]+}}\n+// CHECK: load i8, {{i8\\*|ptr}} %x, align 1, !range ![[BOOL_RANGE]], !noundef !{{[0-9]+}}\n     *x\n }\n \n // CHECK-LABEL: @load_maybeuninit_enum_bool\n #[no_mangle]\n pub fn load_maybeuninit_enum_bool(x: &MaybeUninit<MyBool>) -> MaybeUninit<MyBool> {\n-// CHECK: load i8, i8* %x, align 1{{$}}\n+// CHECK: load i8, {{i8\\*|ptr}} %x, align 1{{$}}\n     *x\n }\n \n // CHECK-LABEL: @load_int\n #[no_mangle]\n pub fn load_int(x: &u16) -> u16 {\n-// CHECK: load i16, i16* %x, align 2{{$}}\n+// CHECK: load i16, {{i16\\*|ptr}} %x, align 2{{$}}\n     *x\n }\n \n // CHECK-LABEL: @load_nonzero_int\n #[no_mangle]\n pub fn load_nonzero_int(x: &NonZeroU16) -> NonZeroU16 {\n-// CHECK: load i16, i16* %x, align 2, !range ![[NONZEROU16_RANGE:[0-9]+]], !noundef !{{[0-9]+}}\n+// CHECK: load i16, {{i16\\*|ptr}} %x, align 2, !range ![[NONZEROU16_RANGE:[0-9]+]], !noundef !{{[0-9]+}}\n     *x\n }\n \n // CHECK-LABEL: @load_option_nonzero_int\n #[no_mangle]\n pub fn load_option_nonzero_int(x: &Option<NonZeroU16>) -> Option<NonZeroU16> {\n-// CHECK: load i16, i16* %x, align 2{{$}}\n+// CHECK: load i16, {{i16\\*|ptr}} %x, align 2{{$}}\n     *x\n }\n \n // CHECK-LABEL: @borrow\n #[no_mangle]\n pub fn borrow(x: &i32) -> &i32 {\n-// CHECK: load {{(i32\\*, )?}}i32** %x{{.*}}, !nonnull\n+// CHECK: load {{i32\\*|ptr}}, {{i32\\*\\*|ptr}} %x{{.*}}, !nonnull\n     &x; // keep variable in an alloca\n     x\n }\n \n // CHECK-LABEL: @_box\n #[no_mangle]\n pub fn _box(x: Box<i32>) -> i32 {\n-// CHECK: load {{(i32\\*, )?}}i32** %x{{.*}}, !nonnull\n+// CHECK: load {{i32\\*|ptr}}, {{i32\\*\\*|ptr}} %x{{.*}}, !nonnull\n     *x\n }\n \n@@ -131,7 +131,7 @@ pub fn _box(x: Box<i32>) -> i32 {\n // dependent alignment\n #[no_mangle]\n pub fn small_array_alignment(x: [i8; 4]) -> [i8; 4] {\n-// CHECK: [[VAR:%[0-9]+]] = load {{(i32, )?}}i32* %{{.*}}, align 1\n+// CHECK: [[VAR:%[0-9]+]] = load i32, {{i32\\*|ptr}} %{{.*}}, align 1\n // CHECK: ret i32 [[VAR]]\n     x\n }\n@@ -141,7 +141,7 @@ pub fn small_array_alignment(x: [i8; 4]) -> [i8; 4] {\n // dependent alignment\n #[no_mangle]\n pub fn small_struct_alignment(x: Bytes) -> Bytes {\n-// CHECK: [[VAR:%[0-9]+]] = load {{(i32, )?}}i32* %{{.*}}, align 1\n+// CHECK: [[VAR:%[0-9]+]] = load i32, {{i32\\*|ptr}} %{{.*}}, align 1\n // CHECK: ret i32 [[VAR]]\n     x\n }"}, {"sha": "b203641fddbd051b62a88131fc43105b4a6ea007", "filename": "src/test/codegen/match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fmatch.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -17,10 +17,10 @@ pub fn exhaustive_match(e: E) -> u8 {\n // CHECK: [[OTHERWISE]]:\n // CHECK-NEXT: unreachable\n // CHECK: [[A]]:\n-// CHECK-NEXT: store i8 0, i8* %1, align 1\n+// CHECK-NEXT: store i8 0, {{i8\\*|ptr}} %1, align 1\n // CHECK-NEXT: br label %[[EXIT:[a-zA-Z0-9_]+]]\n // CHECK: [[B]]:\n-// CHECK-NEXT: store i8 1, i8* %1, align 1\n+// CHECK-NEXT: store i8 1, {{i8\\*|ptr}} %1, align 1\n // CHECK-NEXT: br label %[[EXIT:[a-zA-Z0-9_]+]]\n     match e {\n         E::A => 0,"}, {"sha": "d1c4c56dbe46804487e2687516a876149f484915", "filename": "src/test/codegen/mem-replace-direct-memcpy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fmem-replace-direct-memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fmem-replace-direct-memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fmem-replace-direct-memcpy.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -17,9 +17,9 @@ pub fn replace_byte(dst: &mut u8, src: u8) -> u8 {\n // CHECK-NOT: call void @llvm.memcpy\n // CHECK: ; core::ptr::read\n // CHECK-NOT: call void @llvm.memcpy\n-// CHECK: call void @llvm.memcpy.p0i8.p0i8.i{{.*}}(i8* align 1 %{{.*}}, i8* align 1 %src, i{{.*}} 1, i1 false)\n+// CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 1 %{{.*}}, {{i8\\*|ptr}} align 1 %src, i{{.*}} 1, i1 false)\n // CHECK-NOT: call void @llvm.memcpy\n // CHECK: ; core::ptr::write\n // CHECK-NOT: call void @llvm.memcpy\n-// CHECK: call void @llvm.memcpy.p0i8.p0i8.i{{.*}}(i8* align 1 %dst, i8* align 1 %src, i{{.*}} 1, i1 false)\n+// CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 1 %dst, {{i8\\*|ptr}} align 1 %src, i{{.*}} 1, i1 false)\n // CHECK-NOT: call void @llvm.memcpy"}, {"sha": "fd63b4f0acd5c8c0fd9f0c4a2ad2be1a847e6de2", "filename": "src/test/codegen/packed.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fpacked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fpacked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fpacked.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -18,8 +18,8 @@ pub struct Packed2 {\n // CHECK-LABEL: @write_pkd1\n #[no_mangle]\n pub fn write_pkd1(pkd: &mut Packed1) -> u32 {\n-// CHECK: %{{.*}} = load i32, i32* %{{.*}}, align 1\n-// CHECK: store i32 42, i32* %{{.*}}, align 1\n+// CHECK: %{{.*}} = load i32, {{i32\\*|ptr}} %{{.*}}, align 1\n+// CHECK: store i32 42, {{i32\\*|ptr}} %{{.*}}, align 1\n     let result = pkd.data;\n     pkd.data = 42;\n     result\n@@ -28,8 +28,8 @@ pub fn write_pkd1(pkd: &mut Packed1) -> u32 {\n // CHECK-LABEL: @write_pkd2\n #[no_mangle]\n pub fn write_pkd2(pkd: &mut Packed2) -> u32 {\n-// CHECK: %{{.*}} = load i32, i32* %{{.*}}, align 2\n-// CHECK: store i32 42, i32* %{{.*}}, align 2\n+// CHECK: %{{.*}} = load i32, {{i32\\*|ptr}} %{{.*}}, align 2\n+// CHECK: store i32 42, {{i32\\*|ptr}} %{{.*}}, align 2\n     let result = pkd.data;\n     pkd.data = 42;\n     result\n@@ -52,8 +52,8 @@ pub struct BigPacked2 {\n #[no_mangle]\n pub fn call_pkd1(f: fn() -> Array) -> BigPacked1 {\n // CHECK: [[ALLOCA:%[_a-z0-9]+]] = alloca %Array\n-// CHECK: call void %{{.*}}(%Array* noalias nocapture noundef sret{{.*}} dereferenceable(32) [[ALLOCA]])\n-// CHECK: call void @llvm.memcpy.{{.*}}(i8* align 1 %{{.*}}, i8* align 4 %{{.*}}, i{{[0-9]+}} 32, i1 false)\n+// CHECK: call void %{{.*}}({{%Array\\*|ptr}} noalias nocapture noundef sret{{.*}} dereferenceable(32) [[ALLOCA]])\n+// CHECK: call void @llvm.memcpy.{{.*}}({{i8\\*|ptr}} align 1 %{{.*}}, {{i8\\*|ptr}} align 4 %{{.*}}, i{{[0-9]+}} 32, i1 false)\n     // check that calls whose destination is a field of a packed struct\n     // go through an alloca rather than calling the function with an\n     // unaligned destination.\n@@ -64,18 +64,18 @@ pub fn call_pkd1(f: fn() -> Array) -> BigPacked1 {\n #[no_mangle]\n pub fn call_pkd2(f: fn() -> Array) -> BigPacked2 {\n // CHECK: [[ALLOCA:%[_a-z0-9]+]] = alloca %Array\n-// CHECK: call void %{{.*}}(%Array* noalias nocapture noundef sret{{.*}} dereferenceable(32) [[ALLOCA]])\n-// CHECK: call void @llvm.memcpy.{{.*}}(i8* align 2 %{{.*}}, i8* align 4 %{{.*}}, i{{[0-9]+}} 32, i1 false)\n+// CHECK: call void %{{.*}}({{%Array\\*|ptr}} noalias nocapture noundef sret{{.*}} dereferenceable(32) [[ALLOCA]])\n+// CHECK: call void @llvm.memcpy.{{.*}}({{i8\\*|ptr}} align 2 %{{.*}}, {{i8\\*|ptr}} align 4 %{{.*}}, i{{[0-9]+}} 32, i1 false)\n     // check that calls whose destination is a field of a packed struct\n     // go through an alloca rather than calling the function with an\n     // unaligned destination.\n     BigPacked2 { dealign: 0, data: f() }\n }\n \n // CHECK-LABEL: @write_packed_array1\n-// CHECK: store i32 0, i32* %{{.+}}, align 1\n-// CHECK: store i32 1, i32* %{{.+}}, align 1\n-// CHECK: store i32 2, i32* %{{.+}}, align 1\n+// CHECK: store i32 0, {{i32\\*|ptr}} %{{.+}}, align 1\n+// CHECK: store i32 1, {{i32\\*|ptr}} %{{.+}}, align 1\n+// CHECK: store i32 2, {{i32\\*|ptr}} %{{.+}}, align 1\n #[no_mangle]\n pub fn write_packed_array1(p: &mut BigPacked1) {\n     p.data.0[0] = 0;\n@@ -84,9 +84,9 @@ pub fn write_packed_array1(p: &mut BigPacked1) {\n }\n \n // CHECK-LABEL: @write_packed_array2\n-// CHECK: store i32 0, i32* %{{.+}}, align 2\n-// CHECK: store i32 1, i32* %{{.+}}, align 2\n-// CHECK: store i32 2, i32* %{{.+}}, align 2\n+// CHECK: store i32 0, {{i32\\*|ptr}} %{{.+}}, align 2\n+// CHECK: store i32 1, {{i32\\*|ptr}} %{{.+}}, align 2\n+// CHECK: store i32 2, {{i32\\*|ptr}} %{{.+}}, align 2\n #[no_mangle]\n pub fn write_packed_array2(p: &mut BigPacked2) {\n     p.data.0[0] = 0;\n@@ -95,14 +95,14 @@ pub fn write_packed_array2(p: &mut BigPacked2) {\n }\n \n // CHECK-LABEL: @repeat_packed_array1\n-// CHECK: store i32 42, i32* %{{.+}}, align 1\n+// CHECK: store i32 42, {{i32\\*|ptr}} %{{.+}}, align 1\n #[no_mangle]\n pub fn repeat_packed_array1(p: &mut BigPacked1) {\n     p.data.0 = [42; 8];\n }\n \n // CHECK-LABEL: @repeat_packed_array2\n-// CHECK: store i32 42, i32* %{{.+}}, align 2\n+// CHECK: store i32 42, {{i32\\*|ptr}} %{{.+}}, align 2\n #[no_mangle]\n pub fn repeat_packed_array2(p: &mut BigPacked2) {\n     p.data.0 = [42; 8];\n@@ -119,14 +119,14 @@ pub struct Packed2Pair(u8, u32);\n // CHECK-LABEL: @pkd1_pair\n #[no_mangle]\n pub fn pkd1_pair(pair1: &mut Packed1Pair, pair2: &mut Packed1Pair) {\n-// CHECK: call void @llvm.memcpy.{{.*}}(i8* align 1 %{{.*}}, i8* align 1 %{{.*}}, i{{[0-9]+}} 5, i1 false)\n+// CHECK: call void @llvm.memcpy.{{.*}}({{i8\\*|ptr}} align 1 %{{.*}}, {{i8\\*|ptr}} align 1 %{{.*}}, i{{[0-9]+}} 5, i1 false)\n     *pair2 = *pair1;\n }\n \n // CHECK-LABEL: @pkd2_pair\n #[no_mangle]\n pub fn pkd2_pair(pair1: &mut Packed2Pair, pair2: &mut Packed2Pair) {\n-// CHECK: call void @llvm.memcpy.{{.*}}(i8* align 2 %{{.*}}, i8* align 2 %{{.*}}, i{{[0-9]+}} 6, i1 false)\n+// CHECK: call void @llvm.memcpy.{{.*}}({{i8\\*|ptr}} align 2 %{{.*}}, {{i8\\*|ptr}} align 2 %{{.*}}, i{{[0-9]+}} 6, i1 false)\n     *pair2 = *pair1;\n }\n \n@@ -141,13 +141,13 @@ pub struct Packed2NestedPair((u32, u32));\n // CHECK-LABEL: @pkd1_nested_pair\n #[no_mangle]\n pub fn pkd1_nested_pair(pair1: &mut Packed1NestedPair, pair2: &mut Packed1NestedPair) {\n-// CHECK: call void @llvm.memcpy.{{.*}}(i8* align 1 %{{.*}}, i8* align 1 %{{.*}}, i{{[0-9]+}} 8, i1 false)\n+// CHECK: call void @llvm.memcpy.{{.*}}({{i8\\*|ptr}} align 1 %{{.*}}, {{i8\\*|ptr}} align 1 %{{.*}}, i{{[0-9]+}} 8, i1 false)\n     *pair2 = *pair1;\n }\n \n // CHECK-LABEL: @pkd2_nested_pair\n #[no_mangle]\n pub fn pkd2_nested_pair(pair1: &mut Packed2NestedPair, pair2: &mut Packed2NestedPair) {\n-// CHECK: call void @llvm.memcpy.{{.*}}(i8* align 2 %{{.*}}, i8* align 2 %{{.*}}, i{{[0-9]+}} 8, i1 false)\n+// CHECK: call void @llvm.memcpy.{{.*}}({{i8\\*|ptr}} align 2 %{{.*}}, {{i8\\*|ptr}} align 2 %{{.*}}, i{{[0-9]+}} 8, i1 false)\n     *pair2 = *pair1;\n }"}, {"sha": "2104022f57874bc0f6316a7297decc6faa3f3b67", "filename": "src/test/codegen/personality_lifetimes.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fpersonality_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fpersonality_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fpersonality_lifetimes.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -21,13 +21,11 @@ pub fn test() {\n     let _s = S;\n     // Check that the personality slot alloca gets a lifetime start in each cleanup block, not just\n     // in the first one.\n-    // CHECK: [[SLOT:%[0-9]+]] = alloca { i8*, i32 }\n+    // CHECK: [[SLOT:%[0-9]+]] = alloca { {{i8\\*|ptr}}, i32 }\n     // CHECK-LABEL: cleanup:\n-    // CHECK: [[BITCAST:%[0-9]+]] = bitcast { i8*, i32 }* [[SLOT]] to i8*\n-    // CHECK-NEXT: call void @llvm.lifetime.start.{{.*}}({{.*}}, i8* [[BITCAST]])\n+    // CHECK: call void @llvm.lifetime.start.{{.*}}({{.*}})\n     // CHECK-LABEL: cleanup1:\n-    // CHECK: [[BITCAST1:%[0-9]+]] = bitcast { i8*, i32 }* [[SLOT]] to i8*\n-    // CHECK-NEXT: call void @llvm.lifetime.start.{{.*}}({{.*}}, i8* [[BITCAST1]])\n+    // CHECK: call void @llvm.lifetime.start.{{.*}}({{.*}})\n     might_unwind();\n     let _t = S;\n     might_unwind();"}, {"sha": "0b796754d1d861f8c15b6387d181827c03bd0f2d", "filename": "src/test/codegen/refs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Frefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Frefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frefs.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -13,10 +13,10 @@ pub fn helper(_: usize) {\n pub fn ref_dst(s: &[u8]) {\n     // We used to generate an extra alloca and memcpy to ref the dst, so check that we copy\n     // directly to the alloca for \"x\"\n-// CHECK: [[X0:%[0-9]+]] = getelementptr {{.*}} { [0 x i8]*, [[USIZE]] }* %x, i32 0, i32 0\n-// CHECK: store [0 x i8]* %s.0, [0 x i8]** [[X0]]\n-// CHECK: [[X1:%[0-9]+]] = getelementptr {{.*}} { [0 x i8]*, [[USIZE]] }* %x, i32 0, i32 1\n-// CHECK: store [[USIZE]] %s.1, [[USIZE]]* [[X1]]\n+// CHECK: [[X0:%[0-9]+]] = getelementptr inbounds { {{\\[0 x i8\\]\\*|ptr}}, [[USIZE]] }, {{.*}}  %x, i32 0, i32 0\n+// CHECK: store {{\\[0 x i8\\]\\*|ptr}} %s.0, {{.*}} [[X0]]\n+// CHECK: [[X1:%[0-9]+]] = getelementptr inbounds { {{\\[0 x i8\\]\\*|ptr}}, [[USIZE]] }, {{.*}} %x, i32 0, i32 1\n+// CHECK: store [[USIZE]] %s.1, {{.*}} [[X1]]\n \n     let x = &*s;\n     &x; // keep variable in an alloca"}, {"sha": "7aebd3ec7df0a93d3cecba8b02e9bd224d3f3e2e", "filename": "src/test/codegen/repeat-trusted-len.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Frepeat-trusted-len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Frepeat-trusted-len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frepeat-trusted-len.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -8,6 +8,6 @@ use std::iter;\n // CHECK-LABEL: @repeat_take_collect\n #[no_mangle]\n pub fn repeat_take_collect() -> Vec<u8> {\n-// CHECK: call void @llvm.memset.p0i8.i{{[0-9]+}}(i8* {{.*}}align 1{{.*}} %{{[0-9]+}}, i8 42, i{{[0-9]+}} 100000, i1 false)\n+// CHECK: call void @llvm.memset.{{.+}}({{i8\\*|ptr}} {{.*}}align 1{{.*}} %{{[0-9]+}}, i8 42, i{{[0-9]+}} 100000, i1 false)\n     iter::repeat(42).take(100000).collect()\n }"}, {"sha": "9d18c5f03c665151ce0757988ba88588376e2996", "filename": "src/test/codegen/repr-transparent-aggregates-1.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Frepr-transparent-aggregates-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Frepr-transparent-aggregates-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frepr-transparent-aggregates-1.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -33,19 +33,19 @@ pub enum TeBigS {\n     Variant(BigS),\n }\n \n-// CHECK: define{{.*}}void @test_BigS(%BigS* [[BIGS_RET_ATTRS1:.*]] sret(%BigS) [[BIGS_RET_ATTRS2:.*]], %BigS* [[BIGS_ARG_ATTRS1:.*]] byval(%BigS) [[BIGS_ARG_ATTRS2:.*]])\n+// CHECK: define{{.*}}void @test_BigS({{%BigS\\*|ptr}} [[BIGS_RET_ATTRS1:.*]] sret(%BigS) [[BIGS_RET_ATTRS2:.*]], {{%BigS\\*|ptr}} [[BIGS_ARG_ATTRS1:.*]] byval(%BigS) [[BIGS_ARG_ATTRS2:.*]])\n #[no_mangle]\n pub extern \"C\" fn test_BigS(_: BigS) -> BigS { loop {} }\n \n-// CHECK: define{{.*}}void @test_TsBigS(%TsBigS* [[BIGS_RET_ATTRS1]] sret(%TsBigS) [[BIGS_RET_ATTRS2]], %TsBigS* [[BIGS_ARG_ATTRS1]] byval(%TsBigS) [[BIGS_ARG_ATTRS2:.*]])\n+// CHECK: define{{.*}}void @test_TsBigS({{%TsBigS\\*|ptr}} [[BIGS_RET_ATTRS1]] sret(%TsBigS) [[BIGS_RET_ATTRS2]], {{%TsBigS\\*|ptr}} [[BIGS_ARG_ATTRS1]] byval(%TsBigS) [[BIGS_ARG_ATTRS2:.*]])\n #[no_mangle]\n pub extern \"C\" fn test_TsBigS(_: TsBigS) -> TsBigS { loop {} }\n \n-// CHECK: define{{.*}}void @test_TuBigS(%TuBigS* [[BIGS_RET_ATTRS1]] sret(%TuBigS) [[BIGS_RET_ATTRS2]], %TuBigS* [[BIGS_ARG_ATTRS1]] byval(%TuBigS) [[BIGS_ARG_ATTRS2:.*]])\n+// CHECK: define{{.*}}void @test_TuBigS({{%TuBigS\\*|ptr}} [[BIGS_RET_ATTRS1]] sret(%TuBigS) [[BIGS_RET_ATTRS2]], {{%TuBigS\\*|ptr}} [[BIGS_ARG_ATTRS1]] byval(%TuBigS) [[BIGS_ARG_ATTRS2:.*]])\n #[no_mangle]\n pub extern \"C\" fn test_TuBigS(_: TuBigS) -> TuBigS { loop {} }\n \n-// CHECK: define{{.*}}void @test_TeBigS(%\"TeBigS::Variant\"* [[BIGS_RET_ATTRS1]] sret(%\"TeBigS::Variant\") [[BIGS_RET_ATTRS2]], %\"TeBigS::Variant\"* [[BIGS_ARG_ATTRS1]] byval(%\"TeBigS::Variant\") [[BIGS_ARG_ATTRS2]])\n+// CHECK: define{{.*}}void @test_TeBigS({{%\"TeBigS::Variant\"\\*|ptr}} [[BIGS_RET_ATTRS1]] sret(%\"TeBigS::Variant\") [[BIGS_RET_ATTRS2]], {{%\"TeBigS::Variant\"\\*|ptr}} [[BIGS_ARG_ATTRS1]] byval(%\"TeBigS::Variant\") [[BIGS_ARG_ATTRS2]])\n #[no_mangle]\n pub extern \"C\" fn test_TeBigS(_: TeBigS) -> TeBigS { loop {} }\n \n@@ -69,18 +69,18 @@ pub enum TeBigU {\n     Variant(BigU),\n }\n \n-// CHECK: define{{.*}}void @test_BigU(%BigU* [[BIGU_RET_ATTRS1:.*]] sret(%BigU) [[BIGU_RET_ATTRS2:.*]], %BigU* [[BIGU_ARG_ATTRS1:.*]] byval(%BigU) [[BIGU_ARG_ATTRS2:.*]])\n+// CHECK: define{{.*}}void @test_BigU({{%BigU\\*|ptr}} [[BIGU_RET_ATTRS1:.*]] sret(%BigU) [[BIGU_RET_ATTRS2:.*]], {{%BigU\\*|ptr}} [[BIGU_ARG_ATTRS1:.*]] byval(%BigU) [[BIGU_ARG_ATTRS2:.*]])\n #[no_mangle]\n pub extern \"C\" fn test_BigU(_: BigU) -> BigU { loop {} }\n \n-// CHECK: define{{.*}}void @test_TsBigU(%TsBigU* [[BIGU_RET_ATTRS1:.*]] sret(%TsBigU) [[BIGU_RET_ATTRS2:.*]], %TsBigU* [[BIGU_ARG_ATTRS1]] byval(%TsBigU) [[BIGU_ARG_ATTRS2]])\n+// CHECK: define{{.*}}void @test_TsBigU({{%TsBigU\\*|ptr}} [[BIGU_RET_ATTRS1:.*]] sret(%TsBigU) [[BIGU_RET_ATTRS2:.*]], {{%TsBigU\\*|ptr}} [[BIGU_ARG_ATTRS1]] byval(%TsBigU) [[BIGU_ARG_ATTRS2]])\n #[no_mangle]\n pub extern \"C\" fn test_TsBigU(_: TsBigU) -> TsBigU { loop {} }\n \n-// CHECK: define{{.*}}void @test_TuBigU(%TuBigU* [[BIGU_RET_ATTRS1]] sret(%TuBigU) [[BIGU_RET_ATTRS2:.*]], %TuBigU* [[BIGU_ARG_ATTRS1]] byval(%TuBigU) [[BIGU_ARG_ATTRS2]])\n+// CHECK: define{{.*}}void @test_TuBigU({{%TuBigU\\*|ptr}} [[BIGU_RET_ATTRS1]] sret(%TuBigU) [[BIGU_RET_ATTRS2:.*]], {{%TuBigU\\*|ptr}} [[BIGU_ARG_ATTRS1]] byval(%TuBigU) [[BIGU_ARG_ATTRS2]])\n #[no_mangle]\n pub extern \"C\" fn test_TuBigU(_: TuBigU) -> TuBigU { loop {} }\n \n-// CHECK: define{{.*}}void @test_TeBigU(%\"TeBigU::Variant\"* [[BIGU_RET_ATTRS1]] sret(%\"TeBigU::Variant\") [[BIGU_RET_ATTRS2:.*]], %\"TeBigU::Variant\"* [[BIGU_ARG_ATTRS1]] byval(%\"TeBigU::Variant\") [[BIGU_ARG_ATTRS2]])\n+// CHECK: define{{.*}}void @test_TeBigU({{%\"TeBigU::Variant\"\\*|ptr}} [[BIGU_RET_ATTRS1]] sret(%\"TeBigU::Variant\") [[BIGU_RET_ATTRS2:.*]], {{%\"TeBigU::Variant\"\\*|ptr}} [[BIGU_ARG_ATTRS1]] byval(%\"TeBigU::Variant\") [[BIGU_ARG_ATTRS2]])\n #[no_mangle]\n pub extern \"C\" fn test_TeBigU(_: TeBigU) -> TeBigU { loop {} }"}, {"sha": "c68ba8460cb1409d91fc4508aef19da815a50e58", "filename": "src/test/codegen/repr-transparent.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Frepr-transparent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Frepr-transparent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frepr-transparent.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -24,7 +24,7 @@ pub extern \"C\" fn test_F32(_: F32) -> F32 { loop {} }\n #[repr(transparent)]\n pub struct Ptr(*mut u8);\n \n-// CHECK: define{{.*}}i8* @test_Ptr(i8* %_1)\n+// CHECK: define{{.*}}{{i8\\*|ptr}} @test_Ptr({{i8\\*|ptr}} %_1)\n #[no_mangle]\n pub extern \"C\" fn test_Ptr(_: Ptr) -> Ptr { loop {} }\n \n@@ -39,7 +39,7 @@ pub extern \"C\" fn test_WithZst(_: WithZst) -> WithZst { loop {} }\n pub struct WithZeroSizedArray(*const f32, [i8; 0]);\n \n // Apparently we use i32* when newtype-unwrapping f32 pointers. Whatever.\n-// CHECK: define{{.*}}i32* @test_WithZeroSizedArray(i32* %_1)\n+// CHECK: define{{.*}}{{i32\\*|ptr}} @test_WithZeroSizedArray({{i32\\*|ptr}} %_1)\n #[no_mangle]\n pub extern \"C\" fn test_WithZeroSizedArray(_: WithZeroSizedArray) -> WithZeroSizedArray { loop {} }\n \n@@ -63,7 +63,7 @@ pub extern \"C\" fn test_Gpz(_: GenericPlusZst<Bool>) -> GenericPlusZst<Bool> { lo\n #[repr(transparent)]\n pub struct LifetimePhantom<'a, T: 'a>(*const T, PhantomData<&'a T>);\n \n-// CHECK: define{{.*}}i16* @test_LifetimePhantom(i16* %_1)\n+// CHECK: define{{.*}}{{i16\\*|ptr}} @test_LifetimePhantom({{i16\\*|ptr}} %_1)\n #[no_mangle]\n pub extern \"C\" fn test_LifetimePhantom(_: LifetimePhantom<i16>) -> LifetimePhantom<i16> { loop {} }\n "}, {"sha": "61c4b7b51af7be5344eb86985277d8605baa2820", "filename": "src/test/codegen/riscv-abi/riscv64-lp64-lp64f-lp64d-abi.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Friscv-abi%2Friscv64-lp64-lp64f-lp64d-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Friscv-abi%2Friscv64-lp64-lp64f-lp64d-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Friscv-abi%2Friscv64-lp64-lp64f-lp64d-abi.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -127,18 +127,18 @@ pub struct Large {\n     d: i64,\n }\n \n-// CHECK: define void @f_agg_large(%Large* {{.*}}%x)\n+// CHECK: define void @f_agg_large({{%Large\\*|ptr}} {{.*}}%x)\n #[no_mangle]\n pub extern \"C\" fn f_agg_large(mut x: Large) {\n }\n \n-// CHECK: define void @f_agg_large_ret(%Large* {{.*}}sret{{.*}}, i32 signext %i, i8 signext %j)\n+// CHECK: define void @f_agg_large_ret({{%Large\\*|ptr}} {{.*}}sret{{.*}}, i32 signext %i, i8 signext %j)\n #[no_mangle]\n pub extern \"C\" fn f_agg_large_ret(i: i32, j: i8) -> Large {\n     Large { a: 1, b: 2, c: 3, d: 4 }\n }\n \n-// CHECK: define void @f_scalar_stack_1(i64 %0, [2 x i64] %1, i128 %2, %Large* {{.*}}%d, i8 zeroext %e, i8 signext %f, i8 %g, i8 %h)\n+// CHECK: define void @f_scalar_stack_1(i64 %0, [2 x i64] %1, i128 %2, {{%Large\\*|ptr}} {{.*}}%d, i8 zeroext %e, i8 signext %f, i8 %g, i8 %h)\n #[no_mangle]\n pub extern \"C\" fn f_scalar_stack_1(\n     a: Tiny,\n@@ -152,7 +152,7 @@ pub extern \"C\" fn f_scalar_stack_1(\n ) {\n }\n \n-// CHECK: define void @f_scalar_stack_2(%Large* {{.*}}sret{{.*}} %0, i64 %a, i128 %1, i128 %2, i64 %d, i8 zeroext %e, i8 %f, i8 %g)\n+// CHECK: define void @f_scalar_stack_2({{%Large\\*|ptr}} {{.*}}sret{{.*}} %0, i64 %a, i128 %1, i128 %2, i64 %d, i8 zeroext %e, i8 %f, i8 %g)\n #[no_mangle]\n pub extern \"C\" fn f_scalar_stack_2(\n     a: u64,\n@@ -172,7 +172,7 @@ extern \"C\" {\n \n #[no_mangle]\n pub unsafe extern \"C\" fn f_va_caller() {\n-    // CHECK: call signext i32 (i32, ...) @f_va_callee(i32 signext 1, i32 signext 2, i64 3, double {{.*}}, double {{.*}}, i64 {{.*}}, [2 x i64] {{.*}}, i128 {{.*}}, %Large* {{.*}})\n+    // CHECK: call signext i32 (i32, ...) @f_va_callee(i32 signext 1, i32 signext 2, i64 3, double {{.*}}, double {{.*}}, i64 {{.*}}, [2 x i64] {{.*}}, i128 {{.*}}, {{%Large\\*|ptr}} {{.*}})\n     f_va_callee(\n         1,\n         2i32,"}, {"sha": "cacc32f2f1b669fc23703040284957e3c80c4446", "filename": "src/test/codegen/simd-intrinsic/simd-intrinsic-generic-gather.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-gather.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-gather.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-gather.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -23,14 +23,14 @@ extern \"platform-intrinsic\" {\n #[no_mangle]\n pub unsafe fn gather_f32x2(pointers: Vec2<*const f32>, mask: Vec2<i32>,\n                            values: Vec2<f32>) -> Vec2<f32> {\n-    // CHECK: call <2 x float> @llvm.masked.gather.v2f32.v2p0f32(<2 x float*> {{.*}}, i32 {{.*}}, <2 x i1> {{.*}}, <2 x float> {{.*}})\n+    // CHECK: call <2 x float> @llvm.masked.gather.v2f32.{{.+}}(<2 x {{float\\*|ptr}}> {{.*}}, i32 {{.*}}, <2 x i1> {{.*}}, <2 x float> {{.*}})\n     simd_gather(values, pointers, mask)\n }\n \n // CHECK-LABEL: @gather_pf32x2\n #[no_mangle]\n pub unsafe fn gather_pf32x2(pointers: Vec2<*const *const f32>, mask: Vec2<i32>,\n                            values: Vec2<*const f32>) -> Vec2<*const f32> {\n-    // CHECK: call <2 x float*> @llvm.masked.gather.v2p0f32.v2p0p0f32(<2 x float**> {{.*}}, i32 {{.*}}, <2 x i1> {{.*}}, <2 x float*> {{.*}})\n+    // CHECK: call <2 x {{float\\*|ptr}}> @llvm.masked.gather.{{.+}}(<2 x {{float\\*\\*|ptr}}> {{.*}}, i32 {{.*}}, <2 x i1> {{.*}}, <2 x {{float\\*|ptr}}> {{.*}})\n     simd_gather(values, pointers, mask)\n }"}, {"sha": "94ecaf6096d5c8ac4936cf11c2b93bfc084d7400", "filename": "src/test/codegen/simd-intrinsic/simd-intrinsic-generic-scatter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-scatter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-scatter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-scatter.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -23,7 +23,7 @@ extern \"platform-intrinsic\" {\n #[no_mangle]\n pub unsafe fn scatter_f32x2(pointers: Vec2<*mut f32>, mask: Vec2<i32>,\n                             values: Vec2<f32>) {\n-    // CHECK: call void @llvm.masked.scatter.v2f32.v2p0f32(<2 x float> {{.*}}, <2 x float*> {{.*}}, i32 {{.*}}, <2 x i1> {{.*}})\n+    // CHECK: call void @llvm.masked.scatter.v2f32.v2p0{{.*}}(<2 x float> {{.*}}, <2 x {{float\\*|ptr}}> {{.*}}, i32 {{.*}}, <2 x i1> {{.*}})\n     simd_scatter(values, pointers, mask)\n }\n \n@@ -32,6 +32,6 @@ pub unsafe fn scatter_f32x2(pointers: Vec2<*mut f32>, mask: Vec2<i32>,\n #[no_mangle]\n pub unsafe fn scatter_pf32x2(pointers: Vec2<*mut *const f32>, mask: Vec2<i32>,\n                              values: Vec2<*const f32>) {\n-    // CHECK: call void @llvm.masked.scatter.v2p0f32.v2p0p0f32(<2 x float*> {{.*}}, <2 x float**> {{.*}}, i32 {{.*}}, <2 x i1> {{.*}})\n+    // CHECK: call void @llvm.masked.scatter.v2p0{{.*}}.v2p0{{.*}}(<2 x {{float\\*|ptr}}> {{.*}}, <2 x {{float\\*\\*|ptr}}> {{.*}}, i32 {{.*}}, <2 x i1> {{.*}})\n     simd_scatter(values, pointers, mask)\n }"}, {"sha": "db5b60567faa48a4000fc3da3d0278a50466b628", "filename": "src/test/codegen/simd-intrinsic/simd-intrinsic-transmute-array.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-transmute-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-transmute-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-transmute-array.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -21,23 +21,23 @@ pub struct U(f32, f32, f32, f32);\n // CHECK-LABEL: @build_array_s\n #[no_mangle]\n pub fn build_array_s(x: [f32; 4]) -> S<4> {\n-    // CHECK: call void @llvm.memcpy.p0i8.p0i8.i{{[0-9]+}}(i8* {{.*}} %{{[0-9]+}}, i8* {{.*}} %{{[0-9]+}}, i{{[0-9]+}} 16, i1 false)\n-    // CHECK: call void @llvm.memcpy.p0i8.p0i8.i{{[0-9]+}}(i8* {{.*}} %{{[0-9]+}}, i8* {{.*}} %{{[0-9]+}}, i{{[0-9]+}} 16, i1 false)\n+    // CHECK: call void @llvm.memcpy.{{.+}}({{.*}}, i{{[0-9]+}} 16, i1 false)\n+    // CHECK: call void @llvm.memcpy.{{.+}}({{.*}}, i{{[0-9]+}} 16, i1 false)\n     S::<4>(x)\n }\n \n // CHECK-LABEL: @build_array_t\n #[no_mangle]\n pub fn build_array_t(x: [f32; 4]) -> T {\n-    // CHECK: call void @llvm.memcpy.p0i8.p0i8.i{{[0-9]+}}(i8* {{.*}} %{{[0-9]+}}, i8* {{.*}} %{{[0-9]+}}, i{{[0-9]+}} 16, i1 false)\n-    // CHECK: call void @llvm.memcpy.p0i8.p0i8.i{{[0-9]+}}(i8* {{.*}} %{{[0-9]+}}, i8* {{.*}} %{{[0-9]+}}, i{{[0-9]+}} 16, i1 false)\n+    // CHECK: call void @llvm.memcpy.{{.+}}({{.*}}, i{{[0-9]+}} 16, i1 false)\n+    // CHECK: call void @llvm.memcpy.{{.+}}({{.*}}, i{{[0-9]+}} 16, i1 false)\n     T(x)\n }\n \n // CHECK-LABEL: @build_array_u\n #[no_mangle]\n pub fn build_array_u(x: [f32; 4]) -> U {\n-    // CHECK: call void @llvm.memcpy.p0i8.p0i8.i{{[0-9]+}}(i8* {{.*}} %{{[0-9]+}}, i8* {{.*}} %{{[0-9]+}}, i{{[0-9]+}} 16, i1 false)\n-    // CHECK: call void @llvm.memcpy.p0i8.p0i8.i{{[0-9]+}}(i8* {{.*}} %{{[0-9]+}}, i8* {{.*}} %{{[0-9]+}}, i{{[0-9]+}} 16, i1 false)\n+    // CHECK: call void @llvm.memcpy.{{.+}}({{.*}}, i{{[0-9]+}} 16, i1 false)\n+    // CHECK: call void @llvm.memcpy.{{.+}}({{.*}}, i{{[0-9]+}} 16, i1 false)\n     unsafe { std::mem::transmute(x) }\n }"}, {"sha": "7b623a22a0b21789e3eb1fea66fd24290ac8d1a1", "filename": "src/test/codegen/simd_arith_offset.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fsimd_arith_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fsimd_arith_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd_arith_offset.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -21,6 +21,6 @@ pub struct Simd<T, const LANES: usize>([T; LANES]);\n // CHECK-LABEL: smoke\n #[no_mangle]\n pub fn smoke(ptrs: SimdConstPtr<u8, 8>, offsets: Simd<usize, 8>) -> SimdConstPtr<u8, 8> {\n-    // CHECK: getelementptr i8, <8 x i8*> %_3, <8 x i64> %_4\n+    // CHECK: getelementptr i8, <8 x {{i8\\*|ptr}}> %_3, <8 x i64> %_4\n     unsafe { simd_arith_offset(ptrs, offsets) }\n }"}, {"sha": "794b773a7763cca629f3486ac34c1cfad614c21e", "filename": "src/test/codegen/slice-init.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fslice-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fslice-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fslice-init.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -6,7 +6,7 @@\n #[no_mangle]\n pub fn zero_sized_elem() {\n     // CHECK-NOT: br label %repeat_loop_header{{.*}}\n-    // CHECK-NOT: call void @llvm.memset.p0i8\n+    // CHECK-NOT: call void @llvm.memset.p0\n     let x = [(); 4];\n     drop(&x);\n }\n@@ -15,15 +15,15 @@ pub fn zero_sized_elem() {\n #[no_mangle]\n pub fn zero_len_array() {\n     // CHECK-NOT: br label %repeat_loop_header{{.*}}\n-    // CHECK-NOT: call void @llvm.memset.p0i8\n+    // CHECK-NOT: call void @llvm.memset.p0\n     let x = [4; 0];\n     drop(&x);\n }\n \n // CHECK-LABEL: @byte_array\n #[no_mangle]\n pub fn byte_array() {\n-    // CHECK: call void @llvm.memset.p0i8.i[[WIDTH:[0-9]+]](i8* {{.*}}, i8 7, i[[WIDTH]] 4\n+    // CHECK: call void @llvm.memset.{{.+}}({{i8\\*|ptr}} {{.*}}, i8 7, i{{[0-9]+}} 4\n     // CHECK-NOT: br label %repeat_loop_header{{.*}}\n     let x = [7u8; 4];\n     drop(&x);\n@@ -39,7 +39,7 @@ enum Init {\n // CHECK-LABEL: @byte_enum_array\n #[no_mangle]\n pub fn byte_enum_array() {\n-    // CHECK: call void @llvm.memset.p0i8.i[[WIDTH:[0-9]+]](i8* {{.*}}, i8 {{.*}}, i[[WIDTH]] 4\n+    // CHECK: call void @llvm.memset.{{.+}}({{i8\\*|ptr}} {{.*}}, i8 {{.*}}, i{{[0-9]+}} 4\n     // CHECK-NOT: br label %repeat_loop_header{{.*}}\n     let x = [Init::Memset; 4];\n     drop(&x);\n@@ -48,7 +48,7 @@ pub fn byte_enum_array() {\n // CHECK-LABEL: @zeroed_integer_array\n #[no_mangle]\n pub fn zeroed_integer_array() {\n-    // CHECK: call void @llvm.memset.p0i8.i[[WIDTH:[0-9]+]](i8* {{.*}}, i8 0, i[[WIDTH]] 16\n+    // CHECK: call void @llvm.memset.{{.+}}({{i8\\*|ptr}} {{.*}}, i8 0, i{{[0-9]+}} 16\n     // CHECK-NOT: br label %repeat_loop_header{{.*}}\n     let x = [0u32; 4];\n     drop(&x);\n@@ -58,7 +58,7 @@ pub fn zeroed_integer_array() {\n #[no_mangle]\n pub fn nonzero_integer_array() {\n     // CHECK: br label %repeat_loop_header{{.*}}\n-    // CHECK-NOT: call void @llvm.memset.p0i8\n+    // CHECK-NOT: call void @llvm.memset.p0\n     let x = [0x1a_2b_3c_4d_u32; 4];\n     drop(&x);\n }"}, {"sha": "fd19e624cdddb676391427e522dc9b97137a854c", "filename": "src/test/codegen/slice-iter-len-eq-zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fslice-iter-len-eq-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fslice-iter-len-eq-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fslice-iter-len-eq-zero.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -8,7 +8,7 @@ type Demo = [u8; 3];\n #[no_mangle]\n pub fn slice_iter_len_eq_zero(y: std::slice::Iter<'_, Demo>) -> bool {\n     // CHECK-NOT: sub\n-    // CHECK: %2 = icmp eq i8* %1, %0\n+    // CHECK: %2 = icmp eq {{i8\\*|ptr}} %1, %0\n     // CHECK: ret i1 %2\n     y.len() == 0\n }"}, {"sha": "e5cde5e9e7460abb1f92e662ee25ff811627f291", "filename": "src/test/codegen/slice-ref-equality.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fslice-ref-equality.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fslice-ref-equality.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fslice-ref-equality.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -13,9 +13,7 @@\n // CHECK-LABEL: @is_zero_slice_long\n #[no_mangle]\n pub fn is_zero_slice_long(data: &[u8; 456]) -> bool {\n-    // CHECK: :\n-    // CHECK-NEXT: %{{.+}} = getelementptr {{.+}}\n-    // CHECK-NEXT: %[[BCMP:.+]] = tail call i32 @{{bcmp|memcmp}}({{.+}})\n+    // CHECK: %[[BCMP:.+]] = tail call i32 @{{bcmp|memcmp}}({{.+}})\n     // CHECK-NEXT: %[[EQ:.+]] = icmp eq i32 %[[BCMP]], 0\n     // CHECK-NEXT: ret i1 %[[EQ]]\n     &data[..] == [0; 456]\n@@ -24,9 +22,7 @@ pub fn is_zero_slice_long(data: &[u8; 456]) -> bool {\n // CHECK-LABEL: @is_zero_slice_short\n #[no_mangle]\n pub fn is_zero_slice_short(data: &[u8; 4]) -> bool {\n-    // CHECK: :\n-    // CHECK-NEXT: %[[PTR:.+]] = bitcast [4 x i8]* {{.+}} to i32*\n-    // CHECK-NEXT: %[[LOAD:.+]] = load i32, i32* %[[PTR]], align 1\n+    // CHECK: %[[LOAD:.+]] = load i32, {{i32\\*|ptr}} %{{.+}}, align 1\n     // CHECK-NEXT: %[[EQ:.+]] = icmp eq i32 %[[LOAD]], 0\n     // CHECK-NEXT: ret i1 %[[EQ]]\n     &data[..] == [0; 4]\n@@ -35,9 +31,7 @@ pub fn is_zero_slice_short(data: &[u8; 4]) -> bool {\n // CHECK-LABEL: @is_zero_array\n #[no_mangle]\n pub fn is_zero_array(data: &[u8; 4]) -> bool {\n-    // CHECK: start:\n-    // CHECK-NEXT: %[[PTR:.+]] = bitcast [4 x i8]* {{.+}} to i32*\n-    // CHECK-NEXT: %[[LOAD:.+]] = load i32, i32* %[[PTR]], align 1\n+    // CHECK: %[[LOAD:.+]] = load i32, {{i32\\*|ptr}} %{{.+}}, align 1\n     // CHECK-NEXT: %[[EQ:.+]] = icmp eq i32 %[[LOAD]], 0\n     // CHECK-NEXT: ret i1 %[[EQ]]\n     *data == [0; 4]"}, {"sha": "837256e53694206f927b932eb5f69b5253086f93", "filename": "src/test/codegen/stores.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fstores.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fstores.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fstores.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -17,10 +17,8 @@ pub struct Bytes {\n pub fn small_array_alignment(x: &mut [i8; 4], y: [i8; 4]) {\n // CHECK: [[TMP:%.+]] = alloca i32\n // CHECK: %y = alloca [4 x i8]\n-// CHECK: store i32 %0, i32* [[TMP]]\n-// CHECK: [[Y8:%[0-9]+]] = bitcast [4 x i8]* %y to i8*\n-// CHECK: [[TMP8:%[0-9]+]] = bitcast i32* [[TMP]] to i8*\n-// CHECK: call void @llvm.memcpy.{{.*}}(i8* align 1 [[Y8]], i8* align 4 [[TMP8]], i{{[0-9]+}} 4, i1 false)\n+// CHECK: store i32 %0, {{i32\\*|ptr}} [[TMP]]\n+// CHECK: call void @llvm.memcpy.{{.*}}({{i8\\*|ptr}} align 1 {{.+}}, {{i8\\*|ptr}} align 4 {{.+}}, i{{[0-9]+}} 4, i1 false)\n     *x = y;\n }\n \n@@ -31,9 +29,7 @@ pub fn small_array_alignment(x: &mut [i8; 4], y: [i8; 4]) {\n pub fn small_struct_alignment(x: &mut Bytes, y: Bytes) {\n // CHECK: [[TMP:%.+]] = alloca i32\n // CHECK: %y = alloca %Bytes\n-// CHECK: store i32 %0, i32* [[TMP]]\n-// CHECK: [[Y8:%[0-9]+]] = bitcast %Bytes* %y to i8*\n-// CHECK: [[TMP8:%[0-9]+]] = bitcast i32* [[TMP]] to i8*\n-// CHECK: call void @llvm.memcpy.{{.*}}(i8* align 1 [[Y8]], i8* align 4 [[TMP8]], i{{[0-9]+}} 4, i1 false)\n+// CHECK: store i32 %0, {{i32\\*|ptr}} [[TMP]]\n+// CHECK: call void @llvm.memcpy.{{.*}}({{i8\\*|ptr}} align 1 {{.+}}, {{i8\\*|ptr}} align 4 {{.+}}, i{{[0-9]+}} 4, i1 false)\n     *x = y;\n }"}, {"sha": "4a68403578d1e4288e6e7351990884e5ec0c6297", "filename": "src/test/codegen/swap-large-types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fswap-large-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fswap-large-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fswap-large-types.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -83,9 +83,9 @@ pub struct BigButHighlyAligned([u8; 64 * 3]);\n #[no_mangle]\n pub fn swap_big_aligned(x: &mut BigButHighlyAligned, y: &mut BigButHighlyAligned) {\n // CHECK-NOT: call void @llvm.memcpy\n-// CHECK: call void @llvm.memcpy.p0i8.p0i8.i64(i8* noundef nonnull align 64 dereferenceable(192)\n-// CHECK: call void @llvm.memcpy.p0i8.p0i8.i64(i8* noundef nonnull align 64 dereferenceable(192)\n-// CHECK: call void @llvm.memcpy.p0i8.p0i8.i64(i8* noundef nonnull align 64 dereferenceable(192)\n+// CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} noundef nonnull align 64 dereferenceable(192)\n+// CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} noundef nonnull align 64 dereferenceable(192)\n+// CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} noundef nonnull align 64 dereferenceable(192)\n // CHECK-NOT: call void @llvm.memcpy\n     swap(x, y)\n }"}, {"sha": "0f1b29ca79bc6ae5230d67a1055f6e677b2ddd2d", "filename": "src/test/codegen/thread-local.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fthread-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fthread-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fthread-local.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -19,31 +19,31 @@ thread_local!(static A: Cell<u32> = const { Cell::new(1) });\n // CHECK-LABEL: @get\n #[no_mangle]\n fn get() -> u32 {\n-    // CHECK: %0 = load i32, i32* {{.*}}[[TLS]]{{.*}}\n+    // CHECK: %0 = load i32, {{.*}}[[TLS]]{{.*}}\n     // CHECK-NEXT: ret i32 %0\n     A.with(|a| a.get())\n }\n \n // CHECK-LABEL: @set\n #[no_mangle]\n fn set(v: u32) {\n-    // CHECK: store i32 %0, i32* {{.*}}[[TLS]]{{.*}}\n+    // CHECK: store i32 %0, {{.*}}[[TLS]]{{.*}}\n     // CHECK-NEXT: ret void\n     A.with(|a| a.set(v))\n }\n \n // CHECK-LABEL: @get_aux\n #[no_mangle]\n fn get_aux() -> u64 {\n-    // CHECK: %0 = load i64, i64* [[TLS_AUX]]\n+    // CHECK: %0 = load i64, {{.*}}[[TLS_AUX]]\n     // CHECK-NEXT: ret i64 %0\n     aux::A.with(|a| a.get())\n }\n \n // CHECK-LABEL: @set_aux\n #[no_mangle]\n fn set_aux(v: u64) {\n-    // CHECK: store i64 %0, i64* [[TLS_AUX]]\n+    // CHECK: store i64 %0, {{.*}}[[TLS_AUX]]\n     // CHECK-NEXT: ret void\n     aux::A.with(|a| a.set(v))\n }"}, {"sha": "a7e5deeffd8e24f16874a3dee1b9bbc62f4af637", "filename": "src/test/codegen/transmute-scalar.rs", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Ftransmute-scalar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Ftransmute-scalar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ftransmute-scalar.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -6,19 +6,18 @@\n // scalar `bitcast`, more special-casing is required to remove `alloca` usage.\n \n // CHECK-LABEL: define{{.*}}i32 @f32_to_bits(float %x)\n-// CHECK: %2 = bitcast float %x to i32\n-// CHECK-NEXT: store i32 %2, i32* %0\n-// CHECK-NEXT: %3 = load i32, i32* %0\n-// CHECK: ret i32 %3\n+// CHECK: store i32 %{{.*}}, {{.*}} %0\n+// CHECK-NEXT: %[[RES:.*]] = load i32, {{.*}} %0\n+// CHECK: ret i32 %[[RES]]\n #[no_mangle]\n pub fn f32_to_bits(x: f32) -> u32 {\n     unsafe { std::mem::transmute(x) }\n }\n \n // CHECK-LABEL: define{{.*}}i8 @bool_to_byte(i1 noundef zeroext %b)\n // CHECK: %1 = zext i1 %b to i8\n-// CHECK-NEXT: store i8 %1, i8* %0\n-// CHECK-NEXT: %2 = load i8, i8* %0\n+// CHECK-NEXT: store i8 %1, {{.*}} %0\n+// CHECK-NEXT: %2 = load i8, {{.*}} %0\n // CHECK: ret i8 %2\n #[no_mangle]\n pub fn bool_to_byte(b: bool) -> u8 {\n@@ -28,20 +27,19 @@ pub fn bool_to_byte(b: bool) -> u8 {\n // CHECK-LABEL: define{{.*}}noundef zeroext i1 @byte_to_bool(i8 %byte)\n // CHECK: %1 = trunc i8 %byte to i1\n // CHECK-NEXT: %2 = zext i1 %1 to i8\n-// CHECK-NEXT: store i8 %2, i8* %0\n-// CHECK-NEXT: %3 = load i8, i8* %0\n+// CHECK-NEXT: store i8 %2, {{.*}} %0\n+// CHECK-NEXT: %3 = load i8, {{.*}} %0\n // CHECK-NEXT: %4 = trunc i8 %3 to i1\n // CHECK: ret i1 %4\n #[no_mangle]\n pub unsafe fn byte_to_bool(byte: u8) -> bool {\n     std::mem::transmute(byte)\n }\n \n-// CHECK-LABEL: define{{.*}}i8* @ptr_to_ptr(i16* %p)\n-// CHECK: %2 = bitcast i16* %p to i8*\n-// CHECK-NEXT: store i8* %2, i8** %0\n-// CHECK-NEXT: %3 = load i8*, i8** %0\n-// CHECK: ret i8* %3\n+// CHECK-LABEL: define{{.*}}{{i8\\*|ptr}} @ptr_to_ptr({{i16\\*|ptr}} %p)\n+// CHECK: store {{i8\\*|ptr}} %{{.*}}, {{.*}} %0\n+// CHECK-NEXT: %[[RES:.*]] = load {{i8\\*|ptr}}, {{.*}} %0\n+// CHECK: ret {{i8\\*|ptr}} %[[RES]]\n #[no_mangle]\n pub fn ptr_to_ptr(p: *mut u16) -> *mut u8 {\n     unsafe { std::mem::transmute(p) }\n@@ -54,31 +52,29 @@ pub fn ptr_to_ptr(p: *mut u16) -> *mut u8 {\n // Tests below show the non-special-cased behavior (with the possible\n // future special-cased instructions in the \"NOTE(eddyb)\" comments).\n \n-// CHECK: define{{.*}}[[USIZE:i[0-9]+]] @ptr_to_int(i16* %p)\n+// CHECK: define{{.*}}[[USIZE:i[0-9]+]] @ptr_to_int({{i16\\*|ptr}} %p)\n \n // NOTE(eddyb) see above, the following two CHECK lines should ideally be this:\n //        %2 = ptrtoint i16* %p to [[USIZE]]\n //             store [[USIZE]] %2, [[USIZE]]* %0\n-// CHECK: %2 = bitcast [[USIZE]]* %0 to i16**\n-// CHECK-NEXT: store i16* %p, i16** %2\n+// CHECK: store {{i16\\*|ptr}} %p, {{.*}}\n \n-// CHECK-NEXT: %3 = load [[USIZE]], [[USIZE]]* %0\n-// CHECK: ret [[USIZE]] %3\n+// CHECK-NEXT: %[[RES:.*]] = load [[USIZE]], {{.*}} %0\n+// CHECK: ret [[USIZE]] %[[RES]]\n #[no_mangle]\n pub fn ptr_to_int(p: *mut u16) -> usize {\n     unsafe { std::mem::transmute(p) }\n }\n \n-// CHECK: define{{.*}}i16* @int_to_ptr([[USIZE]] %i)\n+// CHECK: define{{.*}}{{i16\\*|ptr}} @int_to_ptr([[USIZE]] %i)\n \n // NOTE(eddyb) see above, the following two CHECK lines should ideally be this:\n //        %2 = inttoptr [[USIZE]] %i to i16*\n //             store i16* %2, i16** %0\n-// CHECK: %2 = bitcast i16** %0 to [[USIZE]]*\n-// CHECK-NEXT: store [[USIZE]] %i, [[USIZE]]* %2\n+// CHECK: store [[USIZE]] %i, {{.*}}\n \n-// CHECK-NEXT: %3 = load i16*, i16** %0\n-// CHECK: ret i16* %3\n+// CHECK-NEXT: %[[RES:.*]] = load {{i16\\*|ptr}}, {{.*}} %0\n+// CHECK: ret {{i16\\*|ptr}} %[[RES]]\n #[no_mangle]\n pub fn int_to_ptr(i: usize) -> *mut u16 {\n     unsafe { std::mem::transmute(i) }"}, {"sha": "4c07740b3560420eb3cc38acab4643e3ec60cf70", "filename": "src/test/codegen/uninit-consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Funinit-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Funinit-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funinit-consts.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -26,30 +26,30 @@ pub struct PartiallyUninit {\n #[no_mangle]\n pub const fn fully_uninit() -> MaybeUninit<[u8; 10]> {\n     const M: MaybeUninit<[u8; 10]> = MaybeUninit::uninit();\n-    // CHECK: call void @llvm.memcpy.p0i8.p0i8.i{{(32|64)}}(i8* align 1 %1, i8* align 1 getelementptr inbounds (<{ [10 x i8] }>, <{ [10 x i8] }>* [[FULLY_UNINIT]], i32 0, i32 0, i32 0), i{{(32|64)}} 10, i1 false)\n+    // CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 1 %{{[0-9]+}}, {{i8\\*|ptr}} align 1 {{.*}}[[FULLY_UNINIT]]{{.*}}, i{{(32|64)}} 10, i1 false)\n     M\n }\n \n // CHECK-LABEL: @partially_uninit\n #[no_mangle]\n pub const fn partially_uninit() -> PartiallyUninit {\n     const X: PartiallyUninit = PartiallyUninit { x: 0xdeadbeef, y: MaybeUninit::uninit() };\n-    // CHECK: call void @llvm.memcpy.p0i8.p0i8.i{{(32|64)}}(i8* align 4 %1, i8* align 4 getelementptr inbounds (<{ [4 x i8], [12 x i8] }>, <{ [4 x i8], [12 x i8] }>* [[PARTIALLY_UNINIT]], i32 0, i32 0, i32 0), i{{(32|64)}} 16, i1 false)\n+    // CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 4 %{{[0-9]+}}, {{i8\\*|ptr}} align 4 {{.*}}[[PARTIALLY_UNINIT]]{{.*}}, i{{(32|64)}} 16, i1 false)\n     X\n }\n \n // CHECK-LABEL: @uninit_padding_huge\n #[no_mangle]\n pub const fn uninit_padding_huge() -> [(u32, u8); 4096] {\n     const X: [(u32, u8); 4096] = [(123, 45); 4096];\n-    // CHECK: call void @llvm.memcpy.p0i8.p0i8.i{{(32|64)}}(i8* align 4 %1, i8* align 4 getelementptr inbounds (<{ [32768 x i8] }>, <{ [32768 x i8] }>* [[UNINIT_PADDING_HUGE]], i32 0, i32 0, i32 0), i{{(32|64)}} 32768, i1 false)\n+    // CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 4 %{{[0-9]+}}, {{i8\\*|ptr}} align 4 {{.*}}[[UNINIT_PADDING_HUGE]]{{.*}}, i{{(32|64)}} 32768, i1 false)\n     X\n }\n \n // CHECK-LABEL: @fully_uninit_huge\n #[no_mangle]\n pub const fn fully_uninit_huge() -> MaybeUninit<[u32; 4096]> {\n     const F: MaybeUninit<[u32; 4096]> = MaybeUninit::uninit();\n-    // CHECK: call void @llvm.memcpy.p0i8.p0i8.i{{(32|64)}}(i8* align 4 %1, i8* align 4 getelementptr inbounds (<{ [16384 x i8] }>, <{ [16384 x i8] }>* [[FULLY_UNINIT_HUGE]], i32 0, i32 0, i32 0), i{{(32|64)}} 16384, i1 false)\n+    // CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 4 %{{[0-9]+}}, {{i8\\*|ptr}} align 4 {{.*}}[[FULLY_UNINIT_HUGE]]{{.*}}, i{{(32|64)}} 16384, i1 false)\n     F\n }"}, {"sha": "c18f2a49fc36942feb3828c92b371077b3ae66ab", "filename": "src/test/codegen/union-abi.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Funion-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Funion-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funion-abi.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -17,25 +17,25 @@ pub struct i64x4(i64, i64, i64, i64);\n #[derive(Copy, Clone)]\n pub union UnionI64x4{ a:(), b: i64x4 }\n \n-// CHECK: define void @test_UnionI64x4(<4 x i64>* {{.*}} %_1)\n+// CHECK: define void @test_UnionI64x4({{<4 x i64>\\*|ptr}} {{.*}} %_1)\n #[no_mangle]\n pub fn test_UnionI64x4(_: UnionI64x4) { loop {} }\n \n pub union UnionI64x4_{ a: i64x4, b: (), c:i64x4, d: Unhab, e: ((),()), f: UnionI64x4 }\n \n-// CHECK: define void @test_UnionI64x4_(<4 x i64>* {{.*}} %_1)\n+// CHECK: define void @test_UnionI64x4_({{<4 x i64>\\*|ptr}} {{.*}} %_1)\n #[no_mangle]\n pub fn test_UnionI64x4_(_: UnionI64x4_) { loop {} }\n \n pub union UnionI64x4I64{ a: i64x4, b: i64 }\n \n-// CHECK: define void @test_UnionI64x4I64(%UnionI64x4I64* {{.*}} %_1)\n+// CHECK: define void @test_UnionI64x4I64({{%UnionI64x4I64\\*|ptr}} {{.*}} %_1)\n #[no_mangle]\n pub fn test_UnionI64x4I64(_: UnionI64x4I64) { loop {} }\n \n pub union UnionI64x4Tuple{ a: i64x4, b: (i64, i64, i64, i64) }\n \n-// CHECK: define void @test_UnionI64x4Tuple(%UnionI64x4Tuple* {{.*}} %_1)\n+// CHECK: define void @test_UnionI64x4Tuple({{%UnionI64x4Tuple\\*|ptr}} {{.*}} %_1)\n #[no_mangle]\n pub fn test_UnionI64x4Tuple(_: UnionI64x4Tuple) { loop {} }\n \n@@ -65,7 +65,7 @@ pub fn test_UnionU128(_: UnionU128) -> UnionU128 { loop {} }\n \n #[repr(C)]\n pub union CUnionU128{a:u128}\n-// CHECK: define void @test_CUnionU128(%CUnionU128* {{.*}} %_1)\n+// CHECK: define void @test_CUnionU128({{%CUnionU128\\*|ptr}} {{.*}} %_1)\n #[no_mangle]\n pub fn test_CUnionU128(_: CUnionU128) { loop {} }\n "}, {"sha": "4515cb2aed0c137c427d50130c496e3b1780a820", "filename": "src/test/codegen/used_with_arg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fused_with_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fused_with_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fused_with_arg.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -1,10 +1,10 @@\n #![crate_type = \"lib\"]\n #![feature(used_with_arg)]\n \n-// CHECK: @llvm.used = appending global [1 x i8*]{{.*}}USED_LINKER\n+// CHECK: @llvm.used = appending global {{.*}}USED_LINKER\n #[used(linker)]\n static mut USED_LINKER: [usize; 1] = [0];\n \n-// CHECK-NEXT: @llvm.compiler.used = appending global [1 x i8*]{{.*}}USED_COMPILER\n+// CHECK-NEXT: @llvm.compiler.used = appending global {{.*}}USED_COMPILER\n #[used(compiler)]\n static mut USED_COMPILER: [usize; 1] = [0];"}, {"sha": "29d2a1754a3afb7f6202bada58ffd11eae9875ef", "filename": "src/test/codegen/zst-offset.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fzst-offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Fcodegen%2Fzst-offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fzst-offset.rs?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -13,8 +13,7 @@ pub fn helper(_: usize) {\n // CHECK-LABEL: @scalar_layout\n #[no_mangle]\n pub fn scalar_layout(s: &(u64, ())) {\n-// CHECK: [[X0:%[0-9]+]] = bitcast i64* %s to i8*\n-// CHECK-NEXT: [[X1:%[0-9]+]] = getelementptr i8, i8* [[X0]], [[USIZE]] 8\n+// CHECK: getelementptr i8, {{.+}}, [[USIZE]] 8\n     let x = &s.1;\n     &x; // keep variable in an alloca\n }\n@@ -23,8 +22,7 @@ pub fn scalar_layout(s: &(u64, ())) {\n // CHECK-LABEL: @scalarpair_layout\n #[no_mangle]\n pub fn scalarpair_layout(s: &(u64, u32, ())) {\n-// CHECK: [[X0:%[0-9]+]] = bitcast { i64, i32 }* %s to i8*\n-// CHECK-NEXT: [[X1:%[0-9]+]] = getelementptr i8, i8* [[X0]], [[USIZE]] 12\n+// CHECK: getelementptr i8, {{.+}}, [[USIZE]] 12\n     let x = &s.2;\n     &x; // keep variable in an alloca\n }\n@@ -36,8 +34,7 @@ pub struct U64x4(u64, u64, u64, u64);\n // CHECK-LABEL: @vector_layout\n #[no_mangle]\n pub fn vector_layout(s: &(U64x4, ())) {\n-// CHECK: [[X0:%[0-9]+]] = bitcast <4 x i64>* %s to i8*\n-// CHECK-NEXT: [[X1:%[0-9]+]] = getelementptr i8, i8* [[X0]], [[USIZE]] 32\n+// CHECK: getelementptr i8, {{.+}}, [[USIZE]] 32\n     let x = &s.1;\n     &x; // keep variable in an alloca\n }"}, {"sha": "7a5f21922770196bd837f44cdc4a055c2e010a5e", "filename": "src/test/run-make-fulldeps/coverage-llvmir/filecheck.testprog.txt", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-llvmir%2Ffilecheck.testprog.txt", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-llvmir%2Ffilecheck.testprog.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-llvmir%2Ffilecheck.testprog.txt?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -29,20 +29,20 @@ CHECK:        @__llvm_prf_nm = private constant\n CHECK-SAME:   section \"[[INSTR_PROF_NAME]]\", align 1\n \n CHECK:        @llvm.used = appending global\n-CHECK-SAME:   i8* bitcast ({ {{.*}} }* @__llvm_coverage_mapping to i8*)\n-CHECK-SAME:   i8* getelementptr inbounds ({{.*}}* @__llvm_prf_nm, i32 0, i32 0)\n+CHECK-SAME:   @__llvm_coverage_mapping\n+CHECK-SAME:   @__llvm_prf_nm\n CHECK-SAME:   section \"llvm.metadata\"\n \n CHECK:        [[DEFINE_INTERNAL]] { {{.*}} } @_R{{[a-zA-Z0-9_]+}}testprog14will_be_called() unnamed_addr #{{[0-9]+}} {\n CHECK-NEXT:   start:\n CHECK-NOT:    [[DEFINE_INTERNAL]]\n-CHECK:        %pgocount = load i64, i64* getelementptr inbounds\n-CHECK-SAME:   * @__profc__R{{[a-zA-Z0-9_]+}}testprog14will_be_called,\n+CHECK:        %pgocount = load i64, {{i64\\*|ptr}}\n+CHECK-SAME:   @__profc__R{{[a-zA-Z0-9_]+}}testprog14will_be_called,\n \n-CHECK:        declare void @llvm.instrprof.increment(i8*, i64, i32, i32) #[[LLVM_INSTRPROF_INCREMENT_ATTR:[0-9]+]]\n+CHECK:        declare void @llvm.instrprof.increment({{i8\\*|ptr}}, i64, i32, i32) #[[LLVM_INSTRPROF_INCREMENT_ATTR:[0-9]+]]\n \n WINDOWS:      define linkonce_odr hidden i32 @__llvm_profile_runtime_user() #[[LLVM_PROFILE_RUNTIME_USER_ATTR:[0-9]+]] comdat {\n-WINDOWS-NEXT: %1 = load i32, i32* @__llvm_profile_runtime\n+WINDOWS-NEXT: %1 = load i32, {{i32\\*|ptr}} @__llvm_profile_runtime\n WINDOWS-NEXT: ret i32 %1\n WINDOWS-NEXT: }\n "}, {"sha": "e19c78350e9d98e8d5db50429a3387957dc14f7f", "filename": "src/test/run-make-fulldeps/pgo-indirect-call-promotion/filecheck-patterns.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Frun-make-fulldeps%2Fpgo-indirect-call-promotion%2Ffilecheck-patterns.txt", "raw_url": "https://github.com/rust-lang/rust/raw/9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5/src%2Ftest%2Frun-make-fulldeps%2Fpgo-indirect-call-promotion%2Ffilecheck-patterns.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fpgo-indirect-call-promotion%2Ffilecheck-patterns.txt?ref=9d1aeaeb827da7a10b7cfaccf0a1d6ebf414a7b5", "patch": "@@ -2,7 +2,7 @@ CHECK: define void @call_a_bunch_of_functions({{.*}} {\n \n # Make sure that indirect call promotion inserted a check against the most\n # frequently called function.\n-CHECK: %{{.*}} = icmp eq void ()* %{{.*}}, @function_called_always\n+CHECK: %{{.*}} = icmp eq {{void \\(\\)\\*|ptr}} %{{.*}}, @function_called_always\n \n # Check that the call to `function_called_always` was inlined, so that we\n # directly call `opaque_f1` from the upstream crate.\n@@ -12,5 +12,5 @@ CHECK: call void @opaque_f1()\n # Same checks as above, repeated for the trait object case\n \n CHECK: define void @call_a_bunch_of_trait_methods({{.*}}\n-CHECK: %{{.*}} = icmp eq void ({}*)* %{{.*}}, {{.*}} @foo\n+CHECK: %{{.*}} = icmp eq {{void \\(\\{\\}\\*\\)\\*|ptr}} %{{.*}}, {{.*}}@foo\n CHECK: tail call void @opaque_f2()"}]}