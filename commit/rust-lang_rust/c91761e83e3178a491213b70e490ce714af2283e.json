{"sha": "c91761e83e3178a491213b70e490ce714af2283e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5MTc2MWU4M2UzMTc4YTQ5MTIxM2I3MGU0OTBjZTcxNGFmMjI4M2U=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-12-23T19:34:08Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-01-21T14:27:26Z"}, "message": "rustc_trans: fix fallout of merging ast::ViewItem into ast::Item.", "tree": {"sha": "276cf367df803cb524471abcec0b9089d448f82f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/276cf367df803cb524471abcec0b9089d448f82f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c91761e83e3178a491213b70e490ce714af2283e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c91761e83e3178a491213b70e490ce714af2283e", "html_url": "https://github.com/rust-lang/rust/commit/c91761e83e3178a491213b70e490ce714af2283e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c91761e83e3178a491213b70e490ce714af2283e/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9370ae1abf316ed4174abe21cf4ea93f8dec55aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/9370ae1abf316ed4174abe21cf4ea93f8dec55aa", "html_url": "https://github.com/rust-lang/rust/commit/9370ae1abf316ed4174abe21cf4ea93f8dec55aa"}], "stats": {"total": 218, "additions": 104, "deletions": 114}, "files": [{"sha": "8de7f82c9d36604a27f0bf3f2a09e93571cee346", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 104, "deletions": 113, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/c91761e83e3178a491213b70e490ce714af2283e/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c91761e83e3178a491213b70e490ce714af2283e/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=c91761e83e3178a491213b70e490ce714af2283e", "patch": "@@ -1037,6 +1037,110 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n         }\n \n         match item.node {\n+            ast::ItemUse(ref use_item) => {\n+                match use_item.node {\n+                    ast::ViewPathSimple(ident, ref path) => {\n+                        let sub_span = self.span.span_for_last_ident(path.span);\n+                        let mod_id = match self.lookup_type_ref(item.id) {\n+                            Some(def_id) => {\n+                                match self.lookup_def_kind(item.id, path.span) {\n+                                    Some(kind) => self.fmt.ref_str(kind,\n+                                                                   path.span,\n+                                                                   sub_span,\n+                                                                   def_id,\n+                                                                   self.cur_scope),\n+                                    None => {},\n+                                }\n+                                Some(def_id)\n+                            },\n+                            None => None,\n+                        };\n+\n+                        // 'use' always introduces an alias, if there is not an explicit\n+                        // one, there is an implicit one.\n+                        let sub_span =\n+                            match self.span.sub_span_after_keyword(use_item.span, keywords::As) {\n+                                Some(sub_span) => Some(sub_span),\n+                                None => sub_span,\n+                            };\n+\n+                        self.fmt.use_alias_str(path.span,\n+                                               sub_span,\n+                                               item.id,\n+                                               mod_id,\n+                                               get_ident(ident).get(),\n+                                               self.cur_scope);\n+                        self.write_sub_paths_truncated(path);\n+                    }\n+                    ast::ViewPathGlob(ref path) => {\n+                        // Make a comma-separated list of names of imported modules.\n+                        let mut name_string = String::new();\n+                        let glob_map = &self.analysis.glob_map;\n+                        let glob_map = glob_map.as_ref().unwrap();\n+                        if glob_map.contains_key(&item.id) {\n+                            for n in glob_map[item.id].iter() {\n+                                if name_string.len() > 0 {\n+                                    name_string.push_str(\", \");\n+                                }\n+                                name_string.push_str(n.as_str());\n+                            }\n+                        }\n+\n+                        let sub_span = self.span.sub_span_of_token(path.span,\n+                                                                   token::BinOp(token::Star));\n+                        self.fmt.use_glob_str(path.span,\n+                                              sub_span,\n+                                              item.id,\n+                                              name_string.as_slice(),\n+                                              self.cur_scope);\n+                        self.write_sub_paths(path);\n+                    }\n+                    ast::ViewPathList(ref path, ref list) => {\n+                        for plid in list.iter() {\n+                            match plid.node {\n+                                ast::PathListIdent { id, .. } => {\n+                                    match self.lookup_type_ref(id) {\n+                                        Some(def_id) =>\n+                                            match self.lookup_def_kind(id, plid.span) {\n+                                                Some(kind) => {\n+                                                    self.fmt.ref_str(\n+                                                        kind, plid.span,\n+                                                        Some(plid.span),\n+                                                        def_id, self.cur_scope);\n+                                                }\n+                                                None => ()\n+                                            },\n+                                        None => ()\n+                                    }\n+                                },\n+                                ast::PathListMod { .. } => ()\n+                            }\n+                        }\n+\n+                        self.write_sub_paths(path);\n+                    }\n+                }\n+            }\n+            ast::ItemExternCrate(ref s) => {\n+                let name = get_ident(item.ident);\n+                let name = name.get();\n+                let s = match *s {\n+                    Some((ref s, _)) => s.get().to_string(),\n+                    None => name.to_string(),\n+                };\n+                let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Crate);\n+                let cnum = match self.sess.cstore.find_extern_mod_stmt_cnum(item.id) {\n+                    Some(cnum) => cnum,\n+                    None => 0,\n+                };\n+                self.fmt.extern_crate_str(item.span,\n+                                          sub_span,\n+                                          item.id,\n+                                          cnum,\n+                                          name,\n+                                          &s[],\n+                                          self.cur_scope);\n+            }\n             ast::ItemFn(ref decl, _, _, ref ty_params, ref body) =>\n                 self.process_fn(item, &**decl, ty_params, &**body),\n             ast::ItemStatic(ref typ, mt, ref expr) =>\n@@ -1160,119 +1264,6 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n         }\n     }\n \n-    fn visit_view_item(&mut self, i: &ast::ViewItem) {\n-        if generated_code(i.span) {\n-            return\n-        }\n-\n-        match i.node {\n-            ast::ViewItemUse(ref item) => {\n-                match item.node {\n-                    ast::ViewPathSimple(ident, ref path, id) => {\n-                        let sub_span = self.span.span_for_last_ident(path.span);\n-                        let mod_id = match self.lookup_type_ref(id) {\n-                            Some(def_id) => {\n-                                match self.lookup_def_kind(id, path.span) {\n-                                    Some(kind) => self.fmt.ref_str(kind,\n-                                                                   path.span,\n-                                                                   sub_span,\n-                                                                   def_id,\n-                                                                   self.cur_scope),\n-                                    None => {},\n-                                }\n-                                Some(def_id)\n-                            },\n-                            None => None,\n-                        };\n-\n-                        // 'use' always introduces an alias, if there is not an explicit\n-                        // one, there is an implicit one.\n-                        let sub_span =\n-                            match self.span.sub_span_after_keyword(item.span, keywords::As) {\n-                                Some(sub_span) => Some(sub_span),\n-                                None => sub_span,\n-                            };\n-\n-                        self.fmt.use_alias_str(path.span,\n-                                               sub_span,\n-                                               id,\n-                                               mod_id,\n-                                               get_ident(ident).get(),\n-                                               self.cur_scope);\n-                        self.write_sub_paths_truncated(path);\n-                    }\n-                    ast::ViewPathGlob(ref path, id) => {\n-                        // Make a comma-separated list of names of imported modules.\n-                        let mut name_string = String::new();\n-                        let glob_map = &self.analysis.glob_map;\n-                        let glob_map = glob_map.as_ref().unwrap();\n-                        if glob_map.contains_key(&id) {\n-                            for n in glob_map[id].iter() {\n-                                if name_string.len() > 0 {\n-                                    name_string.push_str(\", \");\n-                                }\n-                                name_string.push_str(n.as_str());\n-                            }\n-                        }\n-\n-                        let sub_span = self.span.sub_span_of_token(path.span,\n-                                                                   token::BinOp(token::Star));\n-                        self.fmt.use_glob_str(path.span,\n-                                              sub_span,\n-                                              id,\n-                                              name_string.as_slice(),\n-                                              self.cur_scope);\n-                        self.write_sub_paths(path);\n-                    }\n-                    ast::ViewPathList(ref path, ref list, _) => {\n-                        for plid in list.iter() {\n-                            match plid.node {\n-                                ast::PathListIdent { id, .. } => {\n-                                    match self.lookup_type_ref(id) {\n-                                        Some(def_id) =>\n-                                            match self.lookup_def_kind(id, plid.span) {\n-                                                Some(kind) => {\n-                                                    self.fmt.ref_str(\n-                                                        kind, plid.span,\n-                                                        Some(plid.span),\n-                                                        def_id, self.cur_scope);\n-                                                }\n-                                                None => ()\n-                                            },\n-                                        None => ()\n-                                    }\n-                                },\n-                                ast::PathListMod { .. } => ()\n-                            }\n-                        }\n-\n-                        self.write_sub_paths(path);\n-                    }\n-                }\n-            },\n-            ast::ViewItemExternCrate(ident, ref s, id) => {\n-                let name = get_ident(ident);\n-                let name = name.get();\n-                let s = match *s {\n-                    Some((ref s, _)) => s.get().to_string(),\n-                    None => name.to_string(),\n-                };\n-                let sub_span = self.span.sub_span_after_keyword(i.span, keywords::Crate);\n-                let cnum = match self.sess.cstore.find_extern_mod_stmt_cnum(id) {\n-                    Some(cnum) => cnum,\n-                    None => 0,\n-                };\n-                self.fmt.extern_crate_str(i.span,\n-                                          sub_span,\n-                                          id,\n-                                          cnum,\n-                                          name,\n-                                          &s[],\n-                                          self.cur_scope);\n-            },\n-        }\n-    }\n-\n     fn visit_ty(&mut self, t: &ast::Ty) {\n         if generated_code(t.span) {\n             return"}, {"sha": "93076260349abd5c81aee5d5801823a800ec4a2d", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c91761e83e3178a491213b70e490ce714af2283e/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c91761e83e3178a491213b70e490ce714af2283e/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=c91761e83e3178a491213b70e490ce714af2283e", "patch": "@@ -274,7 +274,6 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ast_map::NodeArg(..) |\n         ast_map::NodeBlock(..) |\n         ast_map::NodePat(..) |\n-        ast_map::NodeViewItem(..) |\n         ast_map::NodeLocal(..) => {\n             ccx.sess().bug(&format!(\"can't monomorphize a {:?}\",\n                                    map_node)[])"}]}