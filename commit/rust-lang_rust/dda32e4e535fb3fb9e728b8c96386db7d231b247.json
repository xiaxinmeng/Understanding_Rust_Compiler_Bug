{"sha": "dda32e4e535fb3fb9e728b8c96386db7d231b247", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkYTMyZTRlNTM1ZmIzZmI5ZTcyOGI4Yzk2Mzg2ZGI3ZDIzMWIyNDc=", "commit": {"author": {"name": "Vita Batrla", "email": "vita.batrla@gmail.com", "date": "2020-01-17T21:46:32Z"}, "committer": {"name": "Vita Batrla", "email": "vita.batrla@gmail.com", "date": "2020-01-17T21:46:32Z"}, "message": "refactor fix using cfg_if!", "tree": {"sha": "1396d585240db7759f1e05a1d158e1a6a0eb4751", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1396d585240db7759f1e05a1d158e1a6a0eb4751"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dda32e4e535fb3fb9e728b8c96386db7d231b247", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dda32e4e535fb3fb9e728b8c96386db7d231b247", "html_url": "https://github.com/rust-lang/rust/commit/dda32e4e535fb3fb9e728b8c96386db7d231b247", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dda32e4e535fb3fb9e728b8c96386db7d231b247/comments", "author": null, "committer": null, "parents": [{"sha": "34878d7b05813e090b370f48b8d437e4bd875094", "url": "https://api.github.com/repos/rust-lang/rust/commits/34878d7b05813e090b370f48b8d437e4bd875094", "html_url": "https://github.com/rust-lang/rust/commit/34878d7b05813e090b370f48b8d437e4bd875094"}], "stats": {"total": 175, "additions": 55, "deletions": 120}, "files": [{"sha": "152da978bfd852d8c4f7b058fd99af9682c719ca", "filename": "src/libstd/sys_common/net.rs", "status": "modified", "additions": 55, "deletions": 120, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/dda32e4e535fb3fb9e728b8c96386db7d231b247/src%2Flibstd%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dda32e4e535fb3fb9e728b8c96386db7d231b247/src%2Flibstd%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fnet.rs?ref=dda32e4e535fb3fb9e728b8c96386db7d231b247", "patch": "@@ -12,80 +12,43 @@ use crate::sys_common::{AsInner, FromInner, IntoInner};\n use crate::time::Duration;\n \n use libc::{c_int, c_void};\n-#[cfg(any(target_os = \"dragonfly\", target_os = \"freebsd\",\n-          target_os = \"openbsd\", target_os = \"netbsd\",\n-          target_os = \"solaris\"))]\n-use libc::{c_uchar};\n-\n-#[cfg(not(any(\n-    target_os = \"dragonfly\",\n-    target_os = \"freebsd\",\n-    target_os = \"ios\",\n-    target_os = \"macos\",\n-    target_os = \"openbsd\",\n-    target_os = \"netbsd\",\n-    target_os = \"solaris\",\n-    target_os = \"haiku\",\n-    target_os = \"l4re\"\n-)))]\n-use crate::sys::net::netc::IPV6_ADD_MEMBERSHIP;\n-#[cfg(not(any(\n-    target_os = \"dragonfly\",\n-    target_os = \"freebsd\",\n-    target_os = \"ios\",\n-    target_os = \"macos\",\n-    target_os = \"openbsd\",\n-    target_os = \"netbsd\",\n-    target_os = \"solaris\",\n-    target_os = \"haiku\",\n-    target_os = \"l4re\"\n-)))]\n-use crate::sys::net::netc::IPV6_DROP_MEMBERSHIP;\n-#[cfg(any(\n-    target_os = \"dragonfly\",\n-    target_os = \"freebsd\",\n-    target_os = \"ios\",\n-    target_os = \"macos\",\n-    target_os = \"openbsd\",\n-    target_os = \"netbsd\",\n-    target_os = \"solaris\",\n-    target_os = \"haiku\",\n-    target_os = \"l4re\"\n-))]\n-use crate::sys::net::netc::IPV6_JOIN_GROUP as IPV6_ADD_MEMBERSHIP;\n-#[cfg(any(\n-    target_os = \"dragonfly\",\n-    target_os = \"freebsd\",\n-    target_os = \"ios\",\n-    target_os = \"macos\",\n-    target_os = \"openbsd\",\n-    target_os = \"netbsd\",\n-    target_os = \"solaris\",\n-    target_os = \"haiku\",\n-    target_os = \"l4re\"\n-))]\n-use crate::sys::net::netc::IPV6_LEAVE_GROUP as IPV6_DROP_MEMBERSHIP;\n-\n-#[cfg(any(\n-    target_os = \"linux\",\n-    target_os = \"android\",\n-    target_os = \"dragonfly\",\n-    target_os = \"freebsd\",\n-    target_os = \"openbsd\",\n-    target_os = \"netbsd\",\n-    target_os = \"haiku\"\n-))]\n-use libc::MSG_NOSIGNAL;\n-#[cfg(not(any(\n-    target_os = \"linux\",\n-    target_os = \"android\",\n-    target_os = \"dragonfly\",\n-    target_os = \"freebsd\",\n-    target_os = \"openbsd\",\n-    target_os = \"netbsd\",\n-    target_os = \"haiku\"\n-)))]\n-const MSG_NOSIGNAL: c_int = 0x0;\n+\n+cfg_if::cfg_if! {\n+    if #[cfg(any(\n+        target_os = \"dragonfly\", target_os = \"freebsd\",\n+        target_os = \"ios\", target_os = \"macos\",\n+        target_os = \"openbsd\", target_os = \"netbsd\",\n+        target_os = \"solaris\", target_os = \"haiku\", target_os = \"l4re\"))] {\n+        use crate::sys::net::netc::IPV6_JOIN_GROUP as IPV6_ADD_MEMBERSHIP;\n+        use crate::sys::net::netc::IPV6_LEAVE_GROUP as IPV6_DROP_MEMBERSHIP;\n+    } else {\n+        use crate::sys::net::netc::IPV6_ADD_MEMBERSHIP;\n+        use crate::sys::net::netc::IPV6_DROP_MEMBERSHIP;\n+    }\n+}\n+\n+cfg_if::cfg_if! {\n+    if #[cfg(any(\n+        target_os = \"linux\", target_os = \"android\",\n+        target_os = \"dragonfly\", target_os = \"freebsd\",\n+        target_os = \"openbsd\", target_os = \"netbsd\",\n+        target_os = \"haiku\"))] {\n+        use libc::MSG_NOSIGNAL;\n+    } else {\n+        const MSG_NOSIGNAL: c_int = 0x0;\n+    }\n+}\n+\n+cfg_if::cfg_if! {\n+    if #[cfg(any(\n+        target_os = \"dragonfly\", target_os = \"freebsd\",\n+        target_os = \"openbsd\", target_os = \"netbsd\",\n+        target_os = \"solaris\"))] {\n+        type ip_mcast_type_v4 = c_uchar;\n+    } else {\n+        type ip_mcast_type_v4 = c_int;\n+    }\n+}\n \n ////////////////////////////////////////////////////////////////////////////////\n // sockaddr and misc bindings\n@@ -569,6 +532,24 @@ impl UdpSocket {\n         Ok(raw != 0)\n     }\n \n+    pub fn set_multicast_loop_v4(&self, multicast_loop_v4: bool) -> io::Result<()> {\n+        setsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_LOOP, multicast_loop_v4 as ip_mcast_type_v4)\n+    }\n+\n+    pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n+        let raw: ip_mcast_type_v4 = getsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_LOOP)?;\n+        Ok(raw != 0)\n+    }\n+\n+    pub fn set_multicast_ttl_v4(&self, multicast_ttl_v4: u32) -> io::Result<()> {\n+        setsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_TTL, multicast_ttl_v4 as ip_mcast_type_v4)\n+    }\n+\n+    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n+        let raw: ip_mcast_type_v4 = getsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_TTL)?;\n+        Ok(raw as u32)\n+    }\n+\n     pub fn set_multicast_loop_v6(&self, multicast_loop_v6: bool) -> io::Result<()> {\n         setsockopt(&self.inner, c::IPPROTO_IPV6, c::IPV6_MULTICAST_LOOP, multicast_loop_v6 as c_int)\n     }\n@@ -649,52 +630,6 @@ impl UdpSocket {\n     }\n }\n \n-#[cfg(not(any(target_os = \"dragonfly\", target_os = \"freebsd\",\n-              target_os = \"openbsd\", target_os = \"netbsd\",\n-              target_os = \"solaris\")))]\n-impl UdpSocket {\n-    pub fn set_multicast_loop_v4(&self, multicast_loop_v4: bool) -> io::Result<()> {\n-        setsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_LOOP, multicast_loop_v4 as c_int)\n-    }\n-\n-    pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n-        let raw: c_int = getsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_LOOP)?;\n-        Ok(raw != 0)\n-    }\n-\n-    pub fn set_multicast_ttl_v4(&self, multicast_ttl_v4: u32) -> io::Result<()> {\n-        setsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_TTL, multicast_ttl_v4 as c_int)\n-    }\n-\n-    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n-        let raw: c_int = getsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_TTL)?;\n-        Ok(raw as u32)\n-    }\n-}\n-\n-#[cfg(any(target_os = \"dragonfly\", target_os = \"freebsd\",\n-          target_os = \"openbsd\", target_os = \"netbsd\",\n-          target_os = \"solaris\"))]\n-impl UdpSocket {\n-    pub fn set_multicast_loop_v4(&self, multicast_loop_v4: bool) -> io::Result<()> {\n-        setsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_LOOP, multicast_loop_v4 as c_uchar)\n-    }\n-\n-    pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n-        let raw: c_uchar = getsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_LOOP)?;\n-        Ok(raw != 0)\n-    }\n-\n-    pub fn set_multicast_ttl_v4(&self, multicast_ttl_v4: u32) -> io::Result<()> {\n-        setsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_TTL, multicast_ttl_v4 as c_uchar)\n-    }\n-\n-    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n-        let raw: c_uchar = getsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_TTL)?;\n-        Ok(raw as u32)\n-    }\n-}\n-\n impl FromInner<Socket> for UdpSocket {\n     fn from_inner(socket: Socket) -> UdpSocket {\n         UdpSocket { inner: socket }"}]}