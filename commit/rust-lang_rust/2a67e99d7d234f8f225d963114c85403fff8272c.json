{"sha": "2a67e99d7d234f8f225d963114c85403fff8272c", "node_id": "C_kwDOAAsO6NoAKDJhNjdlOTlkN2QyMzRmOGYyMjVkOTYzMTE0Yzg1NDAzZmZmODI3MmM", "commit": {"author": {"name": "Nathan Fenner", "email": "nfenneremail@gmail.com", "date": "2023-01-04T03:54:11Z"}, "committer": {"name": "Nathan Fenner", "email": "nfenneremail@gmail.com", "date": "2023-01-23T21:37:58Z"}, "message": "Point at specific field in struct literal when trait fulfillment fails", "tree": {"sha": "a873aa1ecc4bf9b511040a70eff90b633232a5bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a873aa1ecc4bf9b511040a70eff90b633232a5bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a67e99d7d234f8f225d963114c85403fff8272c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a67e99d7d234f8f225d963114c85403fff8272c", "html_url": "https://github.com/rust-lang/rust/commit/2a67e99d7d234f8f225d963114c85403fff8272c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a67e99d7d234f8f225d963114c85403fff8272c/comments", "author": {"login": "Nathan-Fenner", "id": 6179181, "node_id": "MDQ6VXNlcjYxNzkxODE=", "avatar_url": "https://avatars.githubusercontent.com/u/6179181?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nathan-Fenner", "html_url": "https://github.com/Nathan-Fenner", "followers_url": "https://api.github.com/users/Nathan-Fenner/followers", "following_url": "https://api.github.com/users/Nathan-Fenner/following{/other_user}", "gists_url": "https://api.github.com/users/Nathan-Fenner/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nathan-Fenner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nathan-Fenner/subscriptions", "organizations_url": "https://api.github.com/users/Nathan-Fenner/orgs", "repos_url": "https://api.github.com/users/Nathan-Fenner/repos", "events_url": "https://api.github.com/users/Nathan-Fenner/events{/privacy}", "received_events_url": "https://api.github.com/users/Nathan-Fenner/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nathan-Fenner", "id": 6179181, "node_id": "MDQ6VXNlcjYxNzkxODE=", "avatar_url": "https://avatars.githubusercontent.com/u/6179181?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nathan-Fenner", "html_url": "https://github.com/Nathan-Fenner", "followers_url": "https://api.github.com/users/Nathan-Fenner/followers", "following_url": "https://api.github.com/users/Nathan-Fenner/following{/other_user}", "gists_url": "https://api.github.com/users/Nathan-Fenner/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nathan-Fenner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nathan-Fenner/subscriptions", "organizations_url": "https://api.github.com/users/Nathan-Fenner/orgs", "repos_url": "https://api.github.com/users/Nathan-Fenner/repos", "events_url": "https://api.github.com/users/Nathan-Fenner/events{/privacy}", "received_events_url": "https://api.github.com/users/Nathan-Fenner/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8e6a9e8b6251bbc8276cb78cabe1998deecbed7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7", "html_url": "https://github.com/rust-lang/rust/commit/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7"}], "stats": {"total": 1263, "additions": 1151, "deletions": 112}, "files": [{"sha": "2eab68050d43043d6395205cbb863cb908445677", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/adjust_fulfillment_errors.rs", "status": "added", "additions": 457, "deletions": 0, "changes": 457, "blob_url": "https://github.com/rust-lang/rust/blob/2a67e99d7d234f8f225d963114c85403fff8272c/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a67e99d7d234f8f225d963114c85403fff8272c/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs?ref=2a67e99d7d234f8f225d963114c85403fff8272c", "patch": "@@ -0,0 +1,457 @@\n+use crate::FnCtxt;\n+use rustc_hir as hir;\n+use rustc_hir::def::Res;\n+use rustc_middle::ty::{self, DefIdTree, Ty};\n+use rustc_trait_selection::traits;\n+\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    /**\n+     * Recursively searches for the most-specific blamable expression.\n+     * For example, if you have a chain of constraints like:\n+     * - want `Vec<i32>: Copy`\n+     * - because `Option<Vec<i32>>: Copy` needs `Vec<i32>: Copy` because `impl <T: Copy> Copy for Option<T>`\n+     * - because `(Option<Vec<i32>, bool)` needs `Option<Vec<i32>>: Copy` because `impl <A: Copy, B: Copy> Copy for (A, B)`\n+     * then if you pass in `(Some(vec![1, 2, 3]), false)`, this helper `point_at_specific_expr_if_possible`\n+     * will find the expression `vec![1, 2, 3]` as the \"most blameable\" reason for this missing constraint.\n+     *\n+     * This function only updates the error span.\n+     */\n+    pub fn blame_specific_expr_if_possible(\n+        &self,\n+        error: &mut traits::FulfillmentError<'tcx>,\n+        expr: &'tcx hir::Expr<'tcx>,\n+    ) {\n+        // Whether it succeeded or failed, it likely made some amount of progress.\n+        // In the very worst case, it's just the same `expr` we originally passed in.\n+        let expr = match self.blame_specific_expr_if_possible_for_obligation_cause_code(\n+            &error.obligation.cause.code(),\n+            expr,\n+        ) {\n+            Ok(expr) => expr,\n+            Err(expr) => expr,\n+        };\n+\n+        // Either way, use this expression to update the error span.\n+        // If it doesn't overlap the existing span at all, use the original span.\n+        // FIXME: It would possibly be better to do this more continuously, at each level...\n+        error.obligation.cause.span = expr\n+            .span\n+            .find_ancestor_in_same_ctxt(error.obligation.cause.span)\n+            .unwrap_or(error.obligation.cause.span);\n+    }\n+\n+    fn blame_specific_expr_if_possible_for_obligation_cause_code(\n+        &self,\n+        obligation_cause_code: &traits::ObligationCauseCode<'tcx>,\n+        expr: &'tcx hir::Expr<'tcx>,\n+    ) -> Result<&'tcx hir::Expr<'tcx>, &'tcx hir::Expr<'tcx>> {\n+        match obligation_cause_code {\n+            traits::ObligationCauseCode::ExprBindingObligation(_, _, _, _) => {\n+                // This is the \"root\"; we assume that the `expr` is already pointing here.\n+                // Therefore, we return `Ok` so that this `expr` can be refined further.\n+                Ok(expr)\n+            }\n+            traits::ObligationCauseCode::ImplDerivedObligation(impl_derived) => self\n+                .blame_specific_expr_if_possible_for_derived_predicate_obligation(\n+                    impl_derived,\n+                    expr,\n+                ),\n+            _ => {\n+                // We don't recognize this kind of constraint, so we cannot refine the expression\n+                // any further.\n+                Err(expr)\n+            }\n+        }\n+    }\n+\n+    /// We want to achieve the error span in the following example:\n+    ///\n+    /// ```ignore (just for demonstration)\n+    /// struct Burrito<Filling> {\n+    ///   filling: Filling,\n+    /// }\n+    /// impl <Filling: Delicious> Delicious for Burrito<Filling> {}\n+    /// fn eat_delicious_food<Food: Delicious>(_food: Food) {}\n+    ///\n+    /// fn will_type_error() {\n+    ///   eat_delicious_food(Burrito { filling: Kale });\n+    /// } //                                    ^--- The trait bound `Kale: Delicious`\n+    ///   //                                         is not satisfied\n+    /// ```\n+    ///\n+    /// Without calling this function, the error span will cover the entire argument expression.\n+    ///\n+    /// Before we do any of this logic, we recursively call `point_at_specific_expr_if_possible` on the parent\n+    /// obligation. Hence we refine the `expr` \"outwards-in\" and bail at the first kind of expression/impl we don't recognize.\n+    ///\n+    /// This function returns a `Result<&Expr, &Expr>` - either way, it returns the `Expr` whose span should be\n+    /// reported as an error. If it is `Ok`, then it means it refined successfull. If it is `Err`, then it may be\n+    /// only a partial success - but it cannot be refined even further.\n+    fn blame_specific_expr_if_possible_for_derived_predicate_obligation(\n+        &self,\n+        obligation: &traits::ImplDerivedObligationCause<'tcx>,\n+        expr: &'tcx hir::Expr<'tcx>,\n+    ) -> Result<&'tcx hir::Expr<'tcx>, &'tcx hir::Expr<'tcx>> {\n+        // First, we attempt to refine the `expr` for our span using the parent obligation.\n+        // If this cannot be done, then we are already stuck, so we stop early (hence the use\n+        // of the `?` try operator here).\n+        let expr = self.blame_specific_expr_if_possible_for_obligation_cause_code(\n+            &*obligation.derived.parent_code,\n+            expr,\n+        )?;\n+\n+        // This is the \"trait\" (meaning, the predicate \"proved\" by this `impl`) which provides the `Self` type we care about.\n+        // For the purposes of this function, we hope that it is a `struct` type, and that our current `expr` is a literal of\n+        // that struct type.\n+        let impl_trait_self_ref: Option<ty::TraitRef<'tcx>> =\n+            self.tcx.impl_trait_ref(obligation.impl_def_id).map(|impl_def| impl_def.skip_binder());\n+\n+        let Some(impl_trait_self_ref) = impl_trait_self_ref else {\n+            // It is possible that this is absent. In this case, we make no progress.\n+            return Err(expr);\n+        };\n+\n+        // We only really care about the `Self` type itself, which we extract from the ref.\n+        let impl_self_ty: Ty<'tcx> = impl_trait_self_ref.self_ty();\n+\n+        let impl_predicates: ty::GenericPredicates<'tcx> =\n+            self.tcx.predicates_of(obligation.impl_def_id);\n+        let Some(impl_predicate_index) = obligation.impl_def_predicate_index else {\n+            // We don't have the index, so we can only guess.\n+            return Err(expr);\n+        };\n+\n+        if impl_predicate_index >= impl_predicates.predicates.len() {\n+            // This shouldn't happen, but since this is only a diagnostic improvement, avoid breaking things.\n+            return Err(expr);\n+        }\n+        let relevant_broken_predicate: ty::PredicateKind<'tcx> =\n+            impl_predicates.predicates[impl_predicate_index].0.kind().skip_binder();\n+\n+        match relevant_broken_predicate {\n+            ty::PredicateKind::Clause(ty::Clause::Trait(broken_trait)) => {\n+                // ...\n+                self.blame_specific_part_of_expr_corresponding_to_generic_param(\n+                    broken_trait.trait_ref.self_ty().into(),\n+                    expr,\n+                    impl_self_ty.into(),\n+                )\n+            }\n+            _ => Err(expr),\n+        }\n+    }\n+\n+    /// Drills into `expr` to arrive at the equivalent location of `find_generic_param` in `in_ty`.\n+    /// For example, given\n+    /// - expr: `(Some(vec![1, 2, 3]), false)`\n+    /// - param: `T`\n+    /// - in_ty: `(Option<Vec<T>, bool)`\n+    /// we would drill until we arrive at `vec![1, 2, 3]`.\n+    ///\n+    /// If successful, we return `Ok(refined_expr)`. If unsuccesful, we return `Err(partially_refined_expr`),\n+    /// which will go as far as possible. For example, given `(foo(), false)` instead, we would drill to\n+    /// `foo()` and then return `Err(\"foo()\")`.\n+    ///\n+    /// This means that you can (and should) use the `?` try operator to chain multiple calls to this\n+    /// function with different types, since you can only continue drilling the second time if you\n+    /// succeeded the first time.\n+    fn blame_specific_part_of_expr_corresponding_to_generic_param(\n+        &self,\n+        param: ty::GenericArg<'tcx>,\n+        expr: &'tcx hir::Expr<'tcx>,\n+        in_ty: ty::GenericArg<'tcx>,\n+    ) -> Result<&'tcx hir::Expr<'tcx>, &'tcx hir::Expr<'tcx>> {\n+        if param == in_ty {\n+            // The types match exactly, so we have drilled as far as we can.\n+            return Ok(expr);\n+        }\n+\n+        let ty::GenericArgKind::Type(in_ty) = in_ty.unpack() else {\n+            return Err(expr);\n+        };\n+\n+        if let (hir::ExprKind::Tup(expr_elements), ty::Tuple(in_ty_elements)) =\n+            (&expr.kind, in_ty.kind())\n+        {\n+            if in_ty_elements.len() != expr_elements.len() {\n+                return Err(expr);\n+            }\n+            // Find out which of `in_ty_elements` refer to `param`.\n+            // FIXME: It may be better to take the first if there are multiple,\n+            // just so that the error points to a smaller expression.\n+            let Some((drill_expr, drill_ty)) = Self::is_iterator_singleton(expr_elements.iter().zip( in_ty_elements.iter()).filter(|(_expr_elem, in_ty_elem)| {\n+                Self::find_param_in_ty((*in_ty_elem).into(), param)\n+            })) else {\n+                // The param is not mentioned, or it is mentioned in multiple indexes.\n+                return Err(expr);\n+            };\n+\n+            return self.blame_specific_part_of_expr_corresponding_to_generic_param(\n+                param,\n+                drill_expr,\n+                drill_ty.into(),\n+            );\n+        }\n+\n+        if let (\n+            hir::ExprKind::Struct(expr_struct_path, expr_struct_fields, _expr_struct_rest),\n+            ty::Adt(in_ty_adt, in_ty_adt_generic_args),\n+        ) = (&expr.kind, in_ty.kind())\n+        {\n+            // First, confirm that this struct is the same one as in the types, and if so,\n+            // find the right variant.\n+            let Res::Def(expr_struct_def_kind, expr_struct_def_id) = self.typeck_results.borrow().qpath_res(expr_struct_path, expr.hir_id) else {\n+                return Err(expr);\n+            };\n+\n+            let variant_def_id = match expr_struct_def_kind {\n+                hir::def::DefKind::Struct => {\n+                    if in_ty_adt.did() != expr_struct_def_id {\n+                        // FIXME: Deal with type aliases?\n+                        return Err(expr);\n+                    }\n+                    expr_struct_def_id\n+                }\n+                hir::def::DefKind::Variant => {\n+                    // If this is a variant, its parent is the type definition.\n+                    if in_ty_adt.did() != self.tcx.parent(expr_struct_def_id) {\n+                        // FIXME: Deal with type aliases?\n+                        return Err(expr);\n+                    }\n+                    expr_struct_def_id\n+                }\n+                _ => {\n+                    return Err(expr);\n+                }\n+            };\n+\n+            // We need to know which of the generic parameters mentions our target param.\n+            // We expect that at least one of them does, since it is expected to be mentioned.\n+            let Some((drill_generic_index, generic_argument_type)) =\n+                Self::is_iterator_singleton(\n+                    in_ty_adt_generic_args.iter().enumerate().filter(\n+                        |(_index, in_ty_generic)| {\n+                            Self::find_param_in_ty(*in_ty_generic, param)\n+                        },\n+                    ),\n+                ) else {\n+                    return Err(expr);\n+                };\n+\n+            let struct_generic_parameters: &ty::Generics = self.tcx.generics_of(in_ty_adt.did());\n+            if drill_generic_index >= struct_generic_parameters.params.len() {\n+                return Err(expr);\n+            }\n+\n+            let param_to_point_at_in_struct = self.tcx.mk_param_from_def(\n+                struct_generic_parameters.param_at(drill_generic_index, self.tcx),\n+            );\n+\n+            // We make 3 steps:\n+            // Suppose we have a type like\n+            // ```ignore (just for demonstration)\n+            // struct ExampleStruct<T> {\n+            //   enabled: bool,\n+            //   item: Option<(usize, T, bool)>,\n+            // }\n+            //\n+            // f(ExampleStruct {\n+            //   enabled: false,\n+            //   item: Some((0, Box::new(String::new()), 1) }, true)),\n+            // });\n+            // ```\n+            // Here, `f` is passed a `ExampleStruct<Box<String>>`, but it wants\n+            // for `String: Copy`, which isn't true here.\n+            //\n+            // (1) First, we drill into `.item` and highlight that expression\n+            // (2) Then we use the template type `Option<(usize, T, bool)>` to\n+            //     drill into the `T`, arriving at a `Box<String>` expression.\n+            // (3) Then we keep going, drilling into this expression using our\n+            //     outer contextual information.\n+\n+            // (1) Find the (unique) field which mentions the type in our constraint:\n+            let (field_expr, field_type) = self\n+                .point_at_field_if_possible(\n+                    in_ty_adt.did(),\n+                    param_to_point_at_in_struct,\n+                    variant_def_id,\n+                    expr_struct_fields,\n+                )\n+                .ok_or(expr)?;\n+\n+            // (2) Continue drilling into the struct, ignoring the struct's\n+            // generic argument types.\n+            let expr = self.blame_specific_part_of_expr_corresponding_to_generic_param(\n+                param_to_point_at_in_struct,\n+                field_expr,\n+                field_type.into(),\n+            )?;\n+\n+            // (3) Continue drilling into the expression, having \"passed\n+            // through\" the struct entirely.\n+            return self.blame_specific_part_of_expr_corresponding_to_generic_param(\n+                param,\n+                expr,\n+                generic_argument_type,\n+            );\n+        }\n+\n+        if let (\n+            hir::ExprKind::Call(expr_callee, expr_args),\n+            ty::Adt(in_ty_adt, in_ty_adt_generic_args),\n+        ) = (&expr.kind, in_ty.kind())\n+        {\n+            let hir::ExprKind::Path(expr_callee_path) = &expr_callee.kind else {\n+                // FIXME: This case overlaps with another one worth handling,\n+                // which should happen above since it applies to non-ADTs:\n+                // we can drill down into regular generic functions.\n+                return Err(expr);\n+            };\n+            // This is (possibly) a constructor call, like `Some(...)` or `MyStruct(a, b, c)`.\n+\n+            let Res::Def(expr_struct_def_kind, expr_ctor_def_id) = self.typeck_results.borrow().qpath_res(expr_callee_path, expr_callee.hir_id) else {\n+                return Err(expr);\n+            };\n+\n+            let variant_def_id = match expr_struct_def_kind {\n+                hir::def::DefKind::Ctor(hir::def::CtorOf::Struct, hir::def::CtorKind::Fn) => {\n+                    if in_ty_adt.did() != self.tcx.parent(expr_ctor_def_id) {\n+                        // FIXME: Deal with type aliases?\n+                        return Err(expr);\n+                    }\n+                    self.tcx.parent(expr_ctor_def_id)\n+                }\n+                hir::def::DefKind::Ctor(hir::def::CtorOf::Variant, hir::def::CtorKind::Fn) => {\n+                    // If this is a variant, its parent is the type definition.\n+                    if in_ty_adt.did() != self.tcx.parent(expr_ctor_def_id) {\n+                        // FIXME: Deal with type aliases?\n+                        return Err(expr);\n+                    }\n+                    expr_ctor_def_id\n+                }\n+                _ => {\n+                    return Err(expr);\n+                }\n+            };\n+\n+            // We need to know which of the generic parameters mentions our target param.\n+            // We expect that at least one of them does, since it is expected to be mentioned.\n+            let Some((drill_generic_index, generic_argument_type)) =\n+                Self::is_iterator_singleton(\n+                    in_ty_adt_generic_args.iter().enumerate().filter(\n+                        |(_index, in_ty_generic)| {\n+                            Self::find_param_in_ty(*in_ty_generic, param)\n+                        },\n+                    ),\n+                ) else {\n+                    return Err(expr);\n+                };\n+\n+            let struct_generic_parameters: &ty::Generics = self.tcx.generics_of(in_ty_adt.did());\n+            if drill_generic_index >= struct_generic_parameters.params.len() {\n+                return Err(expr);\n+            }\n+\n+            let param_to_point_at_in_struct = self.tcx.mk_param_from_def(\n+                struct_generic_parameters.param_at(drill_generic_index, self.tcx),\n+            );\n+\n+            // We make 3 steps:\n+            // Suppose we have a type like\n+            // ```ignore (just for demonstration)\n+            // struct ExampleStruct<T> {\n+            //   enabled: bool,\n+            //   item: Option<(usize, T, bool)>,\n+            // }\n+            //\n+            // f(ExampleStruct {\n+            //   enabled: false,\n+            //   item: Some((0, Box::new(String::new()), 1) }, true)),\n+            // });\n+            // ```\n+            // Here, `f` is passed a `ExampleStruct<Box<String>>`, but it wants\n+            // for `String: Copy`, which isn't true here.\n+            //\n+            // (1) First, we drill into `.item` and highlight that expression\n+            // (2) Then we use the template type `Option<(usize, T, bool)>` to\n+            //     drill into the `T`, arriving at a `Box<String>` expression.\n+            // (3) Then we keep going, drilling into this expression using our\n+            //     outer contextual information.\n+\n+            // (1) Find the (unique) field index which mentions the type in our constraint:\n+            let Some((field_index, field_type)) = Self::is_iterator_singleton(\n+                in_ty_adt\n+                    .variant_with_id(variant_def_id)\n+                    .fields\n+                    .iter()\n+                    .map(|field| field.ty(self.tcx, *in_ty_adt_generic_args))\n+                    .enumerate()\n+                    .filter(|(_index, field_type)| Self::find_param_in_ty((*field_type).into(), param))\n+            ) else {\n+                return Err(expr);\n+            };\n+\n+            if field_index >= expr_args.len() {\n+                return Err(expr);\n+            }\n+\n+            // (2) Continue drilling into the struct, ignoring the struct's\n+            // generic argument types.\n+            let expr = self.blame_specific_part_of_expr_corresponding_to_generic_param(\n+                param_to_point_at_in_struct,\n+                &expr_args[field_index],\n+                field_type.into(),\n+            )?;\n+\n+            // (3) Continue drilling into the expression, having \"passed\n+            // through\" the struct entirely.\n+            return self.blame_specific_part_of_expr_corresponding_to_generic_param(\n+                param,\n+                expr,\n+                generic_argument_type,\n+            );\n+        }\n+\n+        // At this point, none of the basic patterns matched.\n+        // One major possibility which remains is that we have a function call.\n+        // In this case, it's often possible to dive deeper into the call to find something to blame,\n+        // but this is not always possible.\n+\n+        Err(expr)\n+    }\n+\n+    // FIXME: This can be made into a private, non-impl function later.\n+    /// Traverses the given ty (either a `ty::Ty` or a `ty::GenericArg`) and searches for references\n+    /// to the given `param_to_point_at`. Returns `true` if it finds any use of the param.\n+    pub fn find_param_in_ty(\n+        ty: ty::GenericArg<'tcx>,\n+        param_to_point_at: ty::GenericArg<'tcx>,\n+    ) -> bool {\n+        let mut walk = ty.walk();\n+        while let Some(arg) = walk.next() {\n+            if arg == param_to_point_at {\n+            return true;\n+        } else if let ty::GenericArgKind::Type(ty) = arg.unpack()\n+            && let ty::Alias(ty::Projection, ..) = ty.kind()\n+        {\n+            // This logic may seem a bit strange, but typically when\n+            // we have a projection type in a function signature, the\n+            // argument that's being passed into that signature is\n+            // not actually constraining that projection's substs in\n+            // a meaningful way. So we skip it, and see improvements\n+            // in some UI tests.\n+            walk.skip_current_subtree();\n+        }\n+        }\n+        false\n+    }\n+\n+    // FIXME: This can be made into a private, non-impl function later.\n+    /// Returns `Some(iterator.next())` if it has exactly one item, and `None` otherwise.\n+    pub fn is_iterator_singleton<T>(mut iterator: impl Iterator<Item = T>) -> Option<T> {\n+        match (iterator.next(), iterator.next()) {\n+            (_, Some(_)) => None,\n+            (first, _) => first,\n+        }\n+    }\n+}"}, {"sha": "56b256cfbe4febc62544dc891da8ab6263bcee83", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/2a67e99d7d234f8f225d963114c85403fff8272c/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a67e99d7d234f8f225d963114c85403fff8272c/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=2a67e99d7d234f8f225d963114c85403fff8272c", "patch": "@@ -34,9 +34,10 @@ use rustc_trait_selection::traits::{self, ObligationCauseCode, SelectionContext}\n \n use std::iter;\n use std::mem;\n-use std::ops::ControlFlow;\n use std::slice;\n \n+use std::ops::ControlFlow;\n+\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(in super::super) fn check_casts(&mut self) {\n         // don't hold the borrow to deferred_cast_checks while checking to avoid borrow checker errors\n@@ -1837,7 +1838,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .into_iter()\n                         .flatten()\n                     {\n-                        if self.point_at_arg_if_possible(\n+                        if self.blame_specific_arg_if_possible(\n                                 error,\n                                 def_id,\n                                 param,\n@@ -1867,7 +1868,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .into_iter()\n                     .flatten()\n                 {\n-                    if self.point_at_arg_if_possible(\n+                    if self.blame_specific_arg_if_possible(\n                         error,\n                         def_id,\n                         param,\n@@ -1892,16 +1893,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     for param in\n                         [param_to_point_at, fallback_param_to_point_at, self_param_to_point_at]\n                     {\n-                        if let Some(param) = param\n-                            && self.point_at_field_if_possible(\n-                                error,\n+                        if let Some(param) = param {\n+                            let refined_expr = self.point_at_field_if_possible(\n                                 def_id,\n                                 param,\n                                 variant_def_id,\n                                 fields,\n-                            )\n-                        {\n-                            return true;\n+                            );\n+\n+                            match refined_expr {\n+                                None => {}\n+                                Some((refined_expr, _)) => {\n+                                    error.obligation.cause.span = refined_expr\n+                                        .span\n+                                        .find_ancestor_in_same_ctxt(error.obligation.cause.span)\n+                                        .unwrap_or(refined_expr.span);\n+                                    return true;\n+                                }\n+                            }\n                         }\n                     }\n                 }\n@@ -1934,7 +1943,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn point_at_arg_if_possible(\n+    /// - `blame_specific_*` means that the function will recursively traverse the expression,\n+    /// looking for the most-specific-possible span to blame.\n+    ///\n+    /// - `point_at_*` means that the function will only go \"one level\", pointing at the specific\n+    /// expression mentioned.\n+    ///\n+    /// `blame_specific_arg_if_possible` will find the most-specific expression anywhere inside\n+    /// the provided function call expression, and mark it as responsible for the fullfillment\n+    /// error.\n+    fn blame_specific_arg_if_possible(\n         &self,\n         error: &mut traits::FulfillmentError<'tcx>,\n         def_id: DefId,\n@@ -1953,13 +1971,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .inputs()\n             .iter()\n             .enumerate()\n-            .filter(|(_, ty)| find_param_in_ty(**ty, param_to_point_at))\n+            .filter(|(_, ty)| Self::find_param_in_ty((**ty).into(), param_to_point_at))\n             .collect();\n         // If there's one field that references the given generic, great!\n         if let [(idx, _)] = args_referencing_param.as_slice()\n             && let Some(arg) = receiver\n                 .map_or(args.get(*idx), |rcvr| if *idx == 0 { Some(rcvr) } else { args.get(*idx - 1) }) {\n+\n             error.obligation.cause.span = arg.span.find_ancestor_in_same_ctxt(error.obligation.cause.span).unwrap_or(arg.span);\n+\n+            if let hir::Node::Expr(arg_expr) = self.tcx.hir().get(arg.hir_id) {\n+                // This is more specific than pointing at the entire argument.\n+                self.blame_specific_expr_if_possible(error, arg_expr)\n+            }\n+\n             error.obligation.cause.map_code(|parent_code| {\n                 ObligationCauseCode::FunctionArgumentObligation {\n                     arg_hir_id: arg.hir_id,\n@@ -1977,14 +2002,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         false\n     }\n \n-    fn point_at_field_if_possible(\n+    // FIXME: Make this private and move to mod adjust_fulfillment_errors\n+    pub fn point_at_field_if_possible(\n         &self,\n-        error: &mut traits::FulfillmentError<'tcx>,\n         def_id: DefId,\n         param_to_point_at: ty::GenericArg<'tcx>,\n         variant_def_id: DefId,\n         expr_fields: &[hir::ExprField<'tcx>],\n-    ) -> bool {\n+    ) -> Option<(&'tcx hir::Expr<'tcx>, Ty<'tcx>)> {\n         let def = self.tcx.adt_def(def_id);\n \n         let identity_substs = ty::InternalSubsts::identity_for_item(self.tcx, def_id);\n@@ -1994,7 +2019,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .iter()\n             .filter(|field| {\n                 let field_ty = field.ty(self.tcx, identity_substs);\n-                find_param_in_ty(field_ty, param_to_point_at)\n+                Self::find_param_in_ty(field_ty.into(), param_to_point_at)\n             })\n             .collect();\n \n@@ -2004,17 +2029,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // same rules that check_expr_struct uses for macro hygiene.\n                 if self.tcx.adjust_ident(expr_field.ident, variant_def_id) == field.ident(self.tcx)\n                 {\n-                    error.obligation.cause.span = expr_field\n-                        .expr\n-                        .span\n-                        .find_ancestor_in_same_ctxt(error.obligation.cause.span)\n-                        .unwrap_or(expr_field.span);\n-                    return true;\n+                    return Some((expr_field.expr, self.tcx.type_of(field.did)));\n                 }\n             }\n         }\n \n-        false\n+        None\n     }\n \n     fn point_at_path_if_possible(\n@@ -2234,23 +2254,3 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n }\n-\n-fn find_param_in_ty<'tcx>(ty: Ty<'tcx>, param_to_point_at: ty::GenericArg<'tcx>) -> bool {\n-    let mut walk = ty.walk();\n-    while let Some(arg) = walk.next() {\n-        if arg == param_to_point_at {\n-            return true;\n-        } else if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-            && let ty::Alias(ty::Projection, ..) = ty.kind()\n-        {\n-            // This logic may seem a bit strange, but typically when\n-            // we have a projection type in a function signature, the\n-            // argument that's being passed into that signature is\n-            // not actually constraining that projection's substs in\n-            // a meaningful way. So we skip it, and see improvements\n-            // in some UI tests.\n-            walk.skip_current_subtree();\n-        }\n-    }\n-    false\n-}"}, {"sha": "b1f9a020964531388c3b28c05caccd29c124259b", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a67e99d7d234f8f225d963114c85403fff8272c/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a67e99d7d234f8f225d963114c85403fff8272c/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=2a67e99d7d234f8f225d963114c85403fff8272c", "patch": "@@ -1,4 +1,5 @@\n mod _impl;\n+mod adjust_fulfillment_errors;\n mod arg_matrix;\n mod checks;\n mod suggestions;"}, {"sha": "87f5857986b545904304e883286f98b1b0fdc422", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a67e99d7d234f8f225d963114c85403fff8272c/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a67e99d7d234f8f225d963114c85403fff8272c/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=2a67e99d7d234f8f225d963114c85403fff8272c", "patch": "@@ -1568,6 +1568,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                                     traits::ImplDerivedObligationCause {\n                                         derived,\n                                         impl_def_id,\n+                                        impl_def_predicate_index: None,\n                                         span,\n                                     },\n                                 ))"}, {"sha": "18a966449aa72f2e9432ab3c833d8bdc1ba22bae", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2a67e99d7d234f8f225d963114c85403fff8272c/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a67e99d7d234f8f225d963114c85403fff8272c/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=2a67e99d7d234f8f225d963114c85403fff8272c", "patch": "@@ -145,30 +145,32 @@ impl<'tcx> Elaborator<'tcx> {\n                 // Get predicates declared on the trait.\n                 let predicates = tcx.super_predicates_of(data.def_id());\n \n-                let obligations = predicates.predicates.iter().map(|&(mut pred, span)| {\n-                    // when parent predicate is non-const, elaborate it to non-const predicates.\n-                    if data.constness == ty::BoundConstness::NotConst {\n-                        pred = pred.without_const(tcx);\n-                    }\n-\n-                    let cause = obligation.cause.clone().derived_cause(\n-                        bound_predicate.rebind(data),\n-                        |derived| {\n-                            traits::ImplDerivedObligation(Box::new(\n-                                traits::ImplDerivedObligationCause {\n-                                    derived,\n-                                    impl_def_id: data.def_id(),\n-                                    span,\n-                                },\n-                            ))\n-                        },\n-                    );\n-                    predicate_obligation(\n-                        pred.subst_supertrait(tcx, &bound_predicate.rebind(data.trait_ref)),\n-                        obligation.param_env,\n-                        cause,\n-                    )\n-                });\n+                let obligations =\n+                    predicates.predicates.iter().enumerate().map(|(index, &(mut pred, span))| {\n+                        // when parent predicate is non-const, elaborate it to non-const predicates.\n+                        if data.constness == ty::BoundConstness::NotConst {\n+                            pred = pred.without_const(tcx);\n+                        }\n+\n+                        let cause = obligation.cause.clone().derived_cause(\n+                            bound_predicate.rebind(data),\n+                            |derived| {\n+                                traits::ImplDerivedObligation(Box::new(\n+                                    traits::ImplDerivedObligationCause {\n+                                        derived,\n+                                        impl_def_id: data.def_id(),\n+                                        impl_def_predicate_index: Some(index),\n+                                        span,\n+                                    },\n+                                ))\n+                            },\n+                        );\n+                        predicate_obligation(\n+                            pred.subst_supertrait(tcx, &bound_predicate.rebind(data.trait_ref)),\n+                            obligation.param_env,\n+                            cause,\n+                        )\n+                    });\n                 debug!(?data, ?obligations, \"super_predicates\");\n \n                 // Only keep those bounds that we haven't already seen."}, {"sha": "b26ef2a29931f4948920e1750d651d9f5e630fa6", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a67e99d7d234f8f225d963114c85403fff8272c/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a67e99d7d234f8f225d963114c85403fff8272c/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=2a67e99d7d234f8f225d963114c85403fff8272c", "patch": "@@ -467,6 +467,8 @@ pub enum WellFormedLoc {\n pub struct ImplDerivedObligationCause<'tcx> {\n     pub derived: DerivedObligationCause<'tcx>,\n     pub impl_def_id: DefId,\n+    /// The index of the derived predicate in the parent impl's predicates.\n+    pub impl_def_predicate_index: Option<usize>,\n     pub span: Span,\n }\n "}, {"sha": "4aeaf3ce7144eeb9d06611a908012ab6af2d8ef2", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a67e99d7d234f8f225d963114c85403fff8272c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a67e99d7d234f8f225d963114c85403fff8272c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=2a67e99d7d234f8f225d963114c85403fff8272c", "patch": "@@ -1224,6 +1224,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ImplDerivedObligation(Box::new(ImplDerivedObligationCause {\n                     derived,\n                     impl_def_id,\n+                    impl_def_predicate_index: None,\n                     span: obligation.cause.span,\n                 }))\n             });"}, {"sha": "7bfc098e4cdf7746e608068a95c0be606f1ac1c5", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a67e99d7d234f8f225d963114c85403fff8272c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a67e99d7d234f8f225d963114c85403fff8272c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=2a67e99d7d234f8f225d963114c85403fff8272c", "patch": "@@ -2562,11 +2562,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         assert_eq!(predicates.parent, None);\n         let predicates = predicates.instantiate_own(tcx, substs);\n         let mut obligations = Vec::with_capacity(predicates.len());\n-        for (predicate, span) in predicates {\n+        for (index, (predicate, span)) in predicates.into_iter().enumerate() {\n             let cause = cause.clone().derived_cause(parent_trait_pred, |derived| {\n                 ImplDerivedObligation(Box::new(ImplDerivedObligationCause {\n                     derived,\n                     impl_def_id: def_id,\n+                    impl_def_predicate_index: Some(index),\n                     span,\n                 }))\n             });"}, {"sha": "2bd5d42c9956369132228da6409f0e68da56c51a", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=2a67e99d7d234f8f225d963114c85403fff8272c", "patch": "@@ -1 +1 @@\n-Subproject commit 2cd1b5593d26dc6a03c20f8619187ad4b2485552\n+Subproject commit 2bd5d42c9956369132228da6409f0e68da56c51a"}, {"sha": "8ca261268068d80c0969260fff15199bad87b587", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=2a67e99d7d234f8f225d963114c85403fff8272c", "patch": "@@ -1 +1 @@\n-Subproject commit 960d610e7f33889a2577f5f17c26f0d5c82b30df\n+Subproject commit 8ca261268068d80c0969260fff15199bad87b587"}, {"sha": "3ae62681ff236d5528ef7c8c28ba7c6b2ecc6731", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=2a67e99d7d234f8f225d963114c85403fff8272c", "patch": "@@ -1 +1 @@\n-Subproject commit 2cb0ed9ba56360949f492f9866afe8c293f9f9da\n+Subproject commit 3ae62681ff236d5528ef7c8c28ba7c6b2ecc6731"}, {"sha": "8888f9428fe9a48f31de6bd2cef9b9bf80791edc", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=2a67e99d7d234f8f225d963114c85403fff8272c", "patch": "@@ -1 +1 @@\n-Subproject commit a9fb7d13eadfcc5f457962731f105b97f9a7474a\n+Subproject commit 8888f9428fe9a48f31de6bd2cef9b9bf80791edc"}, {"sha": "8c460b2237a6359a7e3335890db8da049bdd62fc", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=2a67e99d7d234f8f225d963114c85403fff8272c", "patch": "@@ -1 +1 @@\n-Subproject commit 985d561f0bb9b76ec043a2b12511790ec7a2b954\n+Subproject commit 8c460b2237a6359a7e3335890db8da049bdd62fc"}, {"sha": "c0c2215c04adb44d520aa84fe983587948d661a0", "filename": "tests/ui/derives/deriving-copyclone.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2a67e99d7d234f8f225d963114c85403fff8272c/tests%2Fui%2Fderives%2Fderiving-copyclone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a67e99d7d234f8f225d963114c85403fff8272c/tests%2Fui%2Fderives%2Fderiving-copyclone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderives%2Fderiving-copyclone.stderr?ref=2a67e99d7d234f8f225d963114c85403fff8272c", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `B<C>: Copy` is not satisfied\n-  --> $DIR/deriving-copyclone.rs:31:13\n+  --> $DIR/deriving-copyclone.rs:31:26\n    |\n LL |     is_copy(B { a: 1, b: C });\n-   |     ------- ^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `B<C>`\n+   |     -------              ^ the trait `Copy` is not implemented for `B<C>`\n    |     |\n    |     required by a bound introduced by this call\n    |\n@@ -19,14 +19,14 @@ LL | fn is_copy<T: Copy>(_: T) {}\n    = note: this error originates in the derive macro `Copy` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider borrowing here\n    |\n-LL |     is_copy(&B { a: 1, b: C });\n-   |             +\n+LL |     is_copy(B { a: 1, b: &C });\n+   |                          +\n \n error[E0277]: the trait bound `B<C>: Clone` is not satisfied\n-  --> $DIR/deriving-copyclone.rs:32:14\n+  --> $DIR/deriving-copyclone.rs:32:27\n    |\n LL |     is_clone(B { a: 1, b: C });\n-   |     -------- ^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `B<C>`\n+   |     --------              ^ the trait `Clone` is not implemented for `B<C>`\n    |     |\n    |     required by a bound introduced by this call\n    |\n@@ -43,14 +43,14 @@ LL | fn is_clone<T: Clone>(_: T) {}\n    = note: this error originates in the derive macro `Clone` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider borrowing here\n    |\n-LL |     is_clone(&B { a: 1, b: C });\n-   |              +\n+LL |     is_clone(B { a: 1, b: &C });\n+   |                           +\n \n error[E0277]: the trait bound `B<D>: Copy` is not satisfied\n-  --> $DIR/deriving-copyclone.rs:35:13\n+  --> $DIR/deriving-copyclone.rs:35:26\n    |\n LL |     is_copy(B { a: 1, b: D });\n-   |     ------- ^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `B<D>`\n+   |     -------              ^ the trait `Copy` is not implemented for `B<D>`\n    |     |\n    |     required by a bound introduced by this call\n    |\n@@ -67,8 +67,8 @@ LL | fn is_copy<T: Copy>(_: T) {}\n    = note: this error originates in the derive macro `Copy` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider borrowing here\n    |\n-LL |     is_copy(&B { a: 1, b: D });\n-   |             +\n+LL |     is_copy(B { a: 1, b: &D });\n+   |                          +\n \n error: aborting due to 3 previous errors\n "}, {"sha": "5134c672f5f4ed70c5e53e73b0aa28bb32ec4681", "filename": "tests/ui/errors/trait-bound-error-spans/blame-trait-error.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2a67e99d7d234f8f225d963114c85403fff8272c/tests%2Fui%2Ferrors%2Ftrait-bound-error-spans%2Fblame-trait-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a67e99d7d234f8f225d963114c85403fff8272c/tests%2Fui%2Ferrors%2Ftrait-bound-error-spans%2Fblame-trait-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferrors%2Ftrait-bound-error-spans%2Fblame-trait-error.rs?ref=2a67e99d7d234f8f225d963114c85403fff8272c", "patch": "@@ -0,0 +1,28 @@\n+trait T1 {}\n+trait T2 {}\n+trait T3 {}\n+trait T4 {}\n+\n+impl<B: T2> T1 for Wrapper<B> {}\n+\n+impl T2 for i32 {}\n+impl T3 for i32 {}\n+\n+impl<A: T3> T2 for Burrito<A> {}\n+\n+struct Wrapper<W> {\n+    value: W,\n+}\n+\n+struct Burrito<F> {\n+    filling: F,\n+}\n+\n+fn want<V: T1>(_x: V) {}\n+\n+fn example<Q>(q: Q) {\n+    want(Wrapper { value: Burrito { filling: q } });\n+    //~^ ERROR the trait bound `Q: T3` is not satisfied [E0277]\n+}\n+\n+fn main() {}"}, {"sha": "27b002db1306a5a4c44a79a49fbd145d50bd892e", "filename": "tests/ui/errors/trait-bound-error-spans/blame-trait-error.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2a67e99d7d234f8f225d963114c85403fff8272c/tests%2Fui%2Ferrors%2Ftrait-bound-error-spans%2Fblame-trait-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a67e99d7d234f8f225d963114c85403fff8272c/tests%2Fui%2Ferrors%2Ftrait-bound-error-spans%2Fblame-trait-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferrors%2Ftrait-bound-error-spans%2Fblame-trait-error.stderr?ref=2a67e99d7d234f8f225d963114c85403fff8272c", "patch": "@@ -0,0 +1,35 @@\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error.rs:24:46\n+   |\n+LL |     want(Wrapper { value: Burrito { filling: q } });\n+   |     ----                                     ^ the trait `T3` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `Burrito<Q>` to implement `T2`\n+  --> $DIR/blame-trait-error.rs:11:13\n+   |\n+LL | impl<A: T3> T2 for Burrito<A> {}\n+   |         --  ^^     ^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required for `Wrapper<Burrito<Q>>` to implement `T1`\n+  --> $DIR/blame-trait-error.rs:6:13\n+   |\n+LL | impl<B: T2> T1 for Wrapper<B> {}\n+   |         --  ^^     ^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error.rs:21:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "2b75f43241289f1c41a70f5626f7113f6dfb327a", "filename": "tests/ui/errors/traits/blame-trait-error-spans-on-exprs.rs", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/2a67e99d7d234f8f225d963114c85403fff8272c/tests%2Fui%2Ferrors%2Ftraits%2Fblame-trait-error-spans-on-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a67e99d7d234f8f225d963114c85403fff8272c/tests%2Fui%2Ferrors%2Ftraits%2Fblame-trait-error-spans-on-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferrors%2Ftraits%2Fblame-trait-error-spans-on-exprs.rs?ref=2a67e99d7d234f8f225d963114c85403fff8272c", "patch": "@@ -0,0 +1,131 @@\n+// This test examines the error spans reported when a generic `impl` fails.\n+// For example, if a function wants an `Option<T>` where `T: Copy` but you pass `Some(vec![1, 2])`,\n+// then we want to point at the `vec![1, 2]` and not the `Some( ... )` expression.\n+\n+trait T1 {}\n+trait T2 {}\n+trait T3 {}\n+trait T4 {}\n+\n+impl T2 for i32 {}\n+impl T3 for i32 {}\n+\n+struct Wrapper<W> {\n+    value: W,\n+}\n+impl<B: T2> T1 for Wrapper<B> {}\n+\n+struct Burrito<F> {\n+    spicy: bool,\n+    filling: F,\n+}\n+impl<A: T3> T2 for Burrito<A> {}\n+\n+struct BurritoTuple<F>(F);\n+impl<C: T3> T2 for BurritoTuple<C> {}\n+\n+enum BurritoKinds<G> {\n+    SmallBurrito { spicy: bool, small_filling: G },\n+    LargeBurrito { spicy: bool, large_filling: G },\n+    MultiBurrito { first_filling: G, second_filling: G },\n+}\n+impl<D: T3> T2 for BurritoKinds<D> {}\n+\n+struct Taco<H>(bool, H);\n+impl<E: T3> T2 for Taco<E> {}\n+\n+enum TacoKinds<H> {\n+    OneTaco(bool, H),\n+    TwoTacos(bool, H, H),\n+}\n+impl<F: T3> T2 for TacoKinds<F> {}\n+\n+struct GenericBurrito<Spiciness, Filling> {\n+    spiciness: Spiciness,\n+    filling: Filling,\n+}\n+impl<X, Y: T3> T2 for GenericBurrito<X, Y> {}\n+struct NotSpicy;\n+\n+impl<A: T3, B: T3> T2 for (A, B) {}\n+impl<A: T2, B: T2> T1 for (A, B) {}\n+\n+fn want<V: T1>(_x: V) {}\n+\n+// Some more-complex examples:\n+type AliasBurrito<T> = GenericBurrito<T, T>;\n+\n+// The following example is fairly confusing. The idea is that we want to \"misdirect\" the location\n+// of the error.\n+\n+struct Two<A, B> {\n+    a: A,\n+    b: B,\n+}\n+\n+impl<X, Y: T1, Z> T1 for Two<Two<X, Y>, Z> {}\n+\n+struct DoubleWrapper<T> {\n+    item: Wrapper<T>,\n+}\n+\n+impl<T: T1> T1 for DoubleWrapper<T> {}\n+\n+fn example<Q>(q: Q) {\n+    // In each of the following examples, we expect the error span to point at the 'q' variable,\n+    // since the missing constraint is `Q: T3`.\n+\n+    // Verifies for struct:\n+    want(Wrapper { value: Burrito { spicy: false, filling: q } });\n+    //~^ ERROR the trait bound `Q: T3` is not satisfied [E0277]\n+\n+    // Verifies for enum with named fields in variant:\n+    want(Wrapper { value: BurritoKinds::SmallBurrito { spicy: true, small_filling: q } });\n+    //~^ ERROR the trait bound `Q: T3` is not satisfied [E0277]\n+\n+    // Verifies for tuple struct:\n+    want(Wrapper { value: Taco(false, q) });\n+    //~^ ERROR the trait bound `Q: T3` is not satisfied [E0277]\n+\n+    // Verifies for tuple enum variant:\n+    want(Wrapper { value: TacoKinds::OneTaco(false, q) });\n+    //~^ ERROR the trait bound `Q: T3` is not satisfied [E0277]\n+\n+    // Verifies for generic type with multiple parameters:\n+    want(Wrapper { value: GenericBurrito { spiciness: NotSpicy, filling: q } });\n+    //~^ ERROR the trait bound `Q: T3` is not satisfied [E0277]\n+\n+    // Verifies for tuple:\n+    want((3, q));\n+    //~^ ERROR the trait bound `Q: T2` is not satisfied [E0277]\n+\n+    // Verifies for nested tuple:\n+    want(Wrapper { value: (3, q) });\n+    //~^ ERROR the trait bound `Q: T3` is not satisfied [E0277]\n+\n+    // Verifies for nested tuple:\n+    want(((3, q), 5));\n+    //~^ ERROR the trait bound `Q: T3` is not satisfied [E0277]\n+\n+    want(DoubleWrapper { item: Wrapper { value: q } });\n+    //~^ ERROR the trait bound `Q: T1` is not satisfied [E0277]\n+\n+    want(DoubleWrapper { item: Wrapper { value: DoubleWrapper { item: Wrapper { value: q } } } });\n+    //~^ ERROR the trait bound `Q: T1` is not satisfied [E0277]\n+\n+    // Verifies for type alias to struct:\n+    want(Wrapper { value: AliasBurrito { spiciness: q, filling: q } });\n+    //~^ ERROR the trait bound `Q: T3` is not satisfied [E0277]\n+\n+    want(Two { a: Two { a: (), b: q }, b: () });\n+    //~^ ERROR the trait bound `Q: T1` is not satisfied [E0277]\n+\n+    // We *should* blame the 'q'.\n+    // FIXME: Right now, the wrong field is blamed.\n+    want(\n+        Two { a: Two { a: (), b: Two { a: Two { a: (), b: q }, b: () } }, b: () },\n+        //~^ ERROR the trait bound `Q: T1` is not satisfied [E0277]\n+    );\n+}\n+\n+fn main() {}"}, {"sha": "5f87c670d8acd7ef3df6dc900d77bc1aff9e322b", "filename": "tests/ui/errors/traits/blame-trait-error-spans-on-exprs.stderr", "status": "added", "additions": 380, "deletions": 0, "changes": 380, "blob_url": "https://github.com/rust-lang/rust/blob/2a67e99d7d234f8f225d963114c85403fff8272c/tests%2Fui%2Ferrors%2Ftraits%2Fblame-trait-error-spans-on-exprs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a67e99d7d234f8f225d963114c85403fff8272c/tests%2Fui%2Ferrors%2Ftraits%2Fblame-trait-error-spans-on-exprs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferrors%2Ftraits%2Fblame-trait-error-spans-on-exprs.stderr?ref=2a67e99d7d234f8f225d963114c85403fff8272c", "patch": "@@ -0,0 +1,380 @@\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:79:60\n+   |\n+LL |     want(Wrapper { value: Burrito { spicy: false, filling: q } });\n+   |     ---- required by a bound introduced by this call       ^ the trait `T3` is not implemented for `Q`\n+   |\n+note: required for `Burrito<Q>` to implement `T2`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:22:13\n+   |\n+LL | impl<A: T3> T2 for Burrito<A> {}\n+   |         --  ^^     ^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required for `Wrapper<Burrito<Q>>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:16:13\n+   |\n+LL | impl<B: T2> T1 for Wrapper<B> {}\n+   |         --  ^^     ^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:83:84\n+   |\n+LL |     want(Wrapper { value: BurritoKinds::SmallBurrito { spicy: true, small_filling: q } });\n+   |     ---- required by a bound introduced by this call                               ^ the trait `T3` is not implemented for `Q`\n+   |\n+note: required for `BurritoKinds<Q>` to implement `T2`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:32:13\n+   |\n+LL | impl<D: T3> T2 for BurritoKinds<D> {}\n+   |         --  ^^     ^^^^^^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required for `Wrapper<BurritoKinds<Q>>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:16:13\n+   |\n+LL | impl<B: T2> T1 for Wrapper<B> {}\n+   |         --  ^^     ^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:87:39\n+   |\n+LL |     want(Wrapper { value: Taco(false, q) });\n+   |     ----                              ^ the trait `T3` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `Taco<Q>` to implement `T2`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:35:13\n+   |\n+LL | impl<E: T3> T2 for Taco<E> {}\n+   |         --  ^^     ^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required for `Wrapper<Taco<Q>>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:16:13\n+   |\n+LL | impl<B: T2> T1 for Wrapper<B> {}\n+   |         --  ^^     ^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:91:27\n+   |\n+LL |     want(Wrapper { value: TacoKinds::OneTaco(false, q) });\n+   |     ----                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `T3` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `TacoKinds<Q>` to implement `T2`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:41:13\n+   |\n+LL | impl<F: T3> T2 for TacoKinds<F> {}\n+   |         --  ^^     ^^^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required for `Wrapper<TacoKinds<Q>>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:16:13\n+   |\n+LL | impl<B: T2> T1 for Wrapper<B> {}\n+   |         --  ^^     ^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:95:74\n+   |\n+LL |     want(Wrapper { value: GenericBurrito { spiciness: NotSpicy, filling: q } });\n+   |     ---- required by a bound introduced by this call                     ^ the trait `T3` is not implemented for `Q`\n+   |\n+note: required for `GenericBurrito<NotSpicy, Q>` to implement `T2`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:47:16\n+   |\n+LL | impl<X, Y: T3> T2 for GenericBurrito<X, Y> {}\n+   |            --  ^^     ^^^^^^^^^^^^^^^^^^^^\n+   |            |\n+   |            unsatisfied trait bound introduced here\n+note: required for `Wrapper<GenericBurrito<NotSpicy, Q>>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:16:13\n+   |\n+LL | impl<B: T2> T1 for Wrapper<B> {}\n+   |         --  ^^     ^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T2` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:99:14\n+   |\n+LL |     want((3, q));\n+   |     ----     ^ the trait `T2` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `(i32, Q)` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:51:20\n+   |\n+LL | impl<A: T2, B: T2> T1 for (A, B) {}\n+   |                --  ^^     ^^^^^^\n+   |                |\n+   |                unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T2>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:103:31\n+   |\n+LL |     want(Wrapper { value: (3, q) });\n+   |     ----                      ^ the trait `T3` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `(i32, Q)` to implement `T2`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:50:20\n+   |\n+LL | impl<A: T3, B: T3> T2 for (A, B) {}\n+   |                --  ^^     ^^^^^^\n+   |                |\n+   |                unsatisfied trait bound introduced here\n+note: required for `Wrapper<(i32, Q)>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:16:13\n+   |\n+LL | impl<B: T2> T1 for Wrapper<B> {}\n+   |         --  ^^     ^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:107:15\n+   |\n+LL |     want(((3, q), 5));\n+   |     ----      ^ the trait `T3` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `(i32, Q)` to implement `T2`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:50:20\n+   |\n+LL | impl<A: T3, B: T3> T2 for (A, B) {}\n+   |                --  ^^     ^^^^^^\n+   |                |\n+   |                unsatisfied trait bound introduced here\n+note: required for `((i32, Q), i32)` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:51:20\n+   |\n+LL | impl<A: T2, B: T2> T1 for (A, B) {}\n+   |         --         ^^     ^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T1` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:110:49\n+   |\n+LL |     want(DoubleWrapper { item: Wrapper { value: q } });\n+   |     ----                                        ^ the trait `T1` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `DoubleWrapper<Q>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:72:13\n+   |\n+LL | impl<T: T1> T1 for DoubleWrapper<T> {}\n+   |         --  ^^     ^^^^^^^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T1>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T1` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:113:88\n+   |\n+LL |     want(DoubleWrapper { item: Wrapper { value: DoubleWrapper { item: Wrapper { value: q } } } });\n+   |     ---- required by a bound introduced by this call                                   ^ the trait `T1` is not implemented for `Q`\n+   |\n+note: required for `DoubleWrapper<Q>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:72:13\n+   |\n+LL | impl<T: T1> T1 for DoubleWrapper<T> {}\n+   |         --  ^^     ^^^^^^^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+   = note: 1 redundant requirement hidden\n+   = note: required for `DoubleWrapper<DoubleWrapper<Q>>` to implement `T1`\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T1>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:117:27\n+   |\n+LL |     want(Wrapper { value: AliasBurrito { spiciness: q, filling: q } });\n+   |     ----                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `T3` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `GenericBurrito<Q, Q>` to implement `T2`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:47:16\n+   |\n+LL | impl<X, Y: T3> T2 for GenericBurrito<X, Y> {}\n+   |            --  ^^     ^^^^^^^^^^^^^^^^^^^^\n+   |            |\n+   |            unsatisfied trait bound introduced here\n+note: required for `Wrapper<GenericBurrito<Q, Q>>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:16:13\n+   |\n+LL | impl<B: T2> T1 for Wrapper<B> {}\n+   |         --  ^^     ^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T1` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:120:35\n+   |\n+LL |     want(Two { a: Two { a: (), b: q }, b: () });\n+   |     ----                          ^ the trait `T1` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `Two<Two<(), Q>, ()>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:66:19\n+   |\n+LL | impl<X, Y: T1, Z> T1 for Two<Two<X, Y>, Z> {}\n+   |            --     ^^     ^^^^^^^^^^^^^^^^^\n+   |            |\n+   |            unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T1>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T1` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:126:59\n+   |\n+LL |     want(\n+   |     ---- required by a bound introduced by this call\n+LL |         Two { a: Two { a: (), b: Two { a: Two { a: (), b: q }, b: () } }, b: () },\n+   |                                                           ^ the trait `T1` is not implemented for `Q`\n+   |\n+note: required for `Two<Two<(), Q>, ()>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:66:19\n+   |\n+LL | impl<X, Y: T1, Z> T1 for Two<Two<X, Y>, Z> {}\n+   |            --     ^^     ^^^^^^^^^^^^^^^^^\n+   |            |\n+   |            unsatisfied trait bound introduced here\n+   = note: 1 redundant requirement hidden\n+   = note: required for `Two<Two<(), Two<Two<(), Q>, ()>>, ()>` to implement `T1`\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T1>(q: Q) {\n+   |             ++++\n+\n+error: aborting due to 13 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "6d3bb9bbb771533597efe5836c852030577de108", "filename": "tests/ui/higher-rank-trait-bounds/issue-62203-hrtb-ice.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2a67e99d7d234f8f225d963114c85403fff8272c/tests%2Fui%2Fhigher-rank-trait-bounds%2Fissue-62203-hrtb-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a67e99d7d234f8f225d963114c85403fff8272c/tests%2Fui%2Fhigher-rank-trait-bounds%2Fissue-62203-hrtb-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-rank-trait-bounds%2Fissue-62203-hrtb-ice.rs?ref=2a67e99d7d234f8f225d963114c85403fff8272c", "patch": "@@ -35,16 +35,14 @@ trait Ty<'a> {\n }\n \n fn main() {\n-    let v = Unit2.m(\n-        L {\n-            //~^ ERROR to be a closure that returns `Unit3`, but it returns `Unit4`\n-            //~| ERROR type mismatch\n-            f: |x| {\n-                drop(x);\n-                Unit4\n-            },\n+    let v = Unit2.m(L {\n+        //~^ ERROR type mismatch\n+        //~| ERROR to be a closure that returns `Unit3`, but it returns `Unit4`\n+        f: |x| {\n+            drop(x);\n+            Unit4\n         },\n-    );\n+    });\n }\n \n impl<'a> Ty<'a> for Unit2 {"}, {"sha": "9faea3a229bd61a75ec63df5019cf5c25fd0e767", "filename": "tests/ui/higher-rank-trait-bounds/issue-62203-hrtb-ice.stderr", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2a67e99d7d234f8f225d963114c85403fff8272c/tests%2Fui%2Fhigher-rank-trait-bounds%2Fissue-62203-hrtb-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a67e99d7d234f8f225d963114c85403fff8272c/tests%2Fui%2Fhigher-rank-trait-bounds%2Fissue-62203-hrtb-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-rank-trait-bounds%2Fissue-62203-hrtb-ice.stderr?ref=2a67e99d7d234f8f225d963114c85403fff8272c", "patch": "@@ -1,16 +1,17 @@\n-error[E0271]: type mismatch resolving `for<'r> <L<[closure@issue-62203-hrtb-ice.rs:42:16]> as T0<'r, (&'r u8,)>>::O == <_ as Ty<'r>>::V`\n-  --> $DIR/issue-62203-hrtb-ice.rs:39:9\n+error[E0271]: type mismatch resolving `for<'r> <L<[closure@issue-62203-hrtb-ice.rs:41:12]> as T0<'r, (&'r u8,)>>::O == <_ as Ty<'r>>::V`\n+  --> $DIR/issue-62203-hrtb-ice.rs:38:21\n    |\n-LL |       let v = Unit2.m(\n-   |                     - required by a bound introduced by this call\n-LL | /         L {\n+LL |       let v = Unit2.m(L {\n+   |  ___________________-_^\n+   | |                   |\n+   | |                   required by a bound introduced by this call\n LL | |\n LL | |\n-LL | |             f: |x| {\n+LL | |         f: |x| {\n ...  |\n-LL | |             },\n LL | |         },\n-   | |_________^ type mismatch resolving `for<'r> <L<[closure@issue-62203-hrtb-ice.rs:42:16]> as T0<'r, (&'r u8,)>>::O == <_ as Ty<'r>>::V`\n+LL | |     });\n+   | |_____^ type mismatch resolving `for<'r> <L<[closure@issue-62203-hrtb-ice.rs:41:12]> as T0<'r, (&'r u8,)>>::O == <_ as Ty<'r>>::V`\n    |\n note: expected this to be `<_ as Ty<'_>>::V`\n   --> $DIR/issue-62203-hrtb-ice.rs:21:14\n@@ -30,21 +31,22 @@ LL |     where\n LL |         F: for<'r> T0<'r, (<Self as Ty<'r>>::V,), O = <B as Ty<'r>>::V>,\n    |                                                   ^^^^^^^^^^^^^^^^^^^^ required by this bound in `T1::m`\n \n-error[E0271]: expected `[closure@issue-62203-hrtb-ice.rs:42:16]` to be a closure that returns `Unit3`, but it returns `Unit4`\n-  --> $DIR/issue-62203-hrtb-ice.rs:39:9\n+error[E0271]: expected `[closure@issue-62203-hrtb-ice.rs:41:12]` to be a closure that returns `Unit3`, but it returns `Unit4`\n+  --> $DIR/issue-62203-hrtb-ice.rs:38:21\n    |\n-LL |       let v = Unit2.m(\n-   |                     - required by a bound introduced by this call\n-LL | /         L {\n+LL |       let v = Unit2.m(L {\n+   |  ___________________-_^\n+   | |                   |\n+   | |                   required by a bound introduced by this call\n LL | |\n LL | |\n-LL | |             f: |x| {\n+LL | |         f: |x| {\n ...  |\n-LL | |             },\n LL | |         },\n-   | |_________^ expected struct `Unit3`, found struct `Unit4`\n+LL | |     });\n+   | |_____^ expected struct `Unit3`, found struct `Unit4`\n    |\n-note: required for `L<[closure@$DIR/issue-62203-hrtb-ice.rs:42:16: 42:19]>` to implement `for<'r> T0<'r, (&'r u8,)>`\n+note: required for `L<[closure@$DIR/issue-62203-hrtb-ice.rs:41:12: 41:15]>` to implement `for<'r> T0<'r, (&'r u8,)>`\n   --> $DIR/issue-62203-hrtb-ice.rs:17:16\n    |\n LL | impl<'a, A, T> T0<'a, A> for L<T>"}, {"sha": "b680ce7f99013d67848469be9943f8771331ee39", "filename": "tests/ui/traits/negative-impls/negated-auto-traits-error.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a67e99d7d234f8f225d963114c85403fff8272c/tests%2Fui%2Ftraits%2Fnegative-impls%2Fnegated-auto-traits-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a67e99d7d234f8f225d963114c85403fff8272c/tests%2Fui%2Ftraits%2Fnegative-impls%2Fnegated-auto-traits-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnegative-impls%2Fnegated-auto-traits-error.stderr?ref=2a67e99d7d234f8f225d963114c85403fff8272c", "patch": "@@ -101,10 +101,10 @@ LL | fn is_send<T: Send>(_: T) {}\n    |               ^^^^ required by this bound in `is_send`\n \n error[E0277]: `main::TestType` cannot be sent between threads safely\n-  --> $DIR/negated-auto-traits-error.rs:66:13\n+  --> $DIR/negated-auto-traits-error.rs:66:20\n    |\n LL |     is_sync(Outer2(TestType));\n-   |     ------- ^^^^^^^^^^^^^^^^ `main::TestType` cannot be sent between threads safely\n+   |     -------        ^^^^^^^^ `main::TestType` cannot be sent between threads safely\n    |     |\n    |     required by a bound introduced by this call\n    |"}]}