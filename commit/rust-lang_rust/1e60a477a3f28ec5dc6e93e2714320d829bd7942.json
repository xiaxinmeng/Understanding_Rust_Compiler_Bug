{"sha": "1e60a477a3f28ec5dc6e93e2714320d829bd7942", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlNjBhNDc3YTNmMjhlYzVkYzZlOTNlMjcxNDMyMGQ4MjliZDc5NDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-15T22:28:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-15T22:28:23Z"}, "message": "Auto merge of #43245 - Gankro:drain-filter, r=sfackler\n\nAdd Vec::drain_filter\n\nThis implements the API proposed in #43244.\n\nSo I spent like half a day figuring out how to implement this in some awesome super-optimized unsafe way, which had me very confident this was worth putting into the stdlib.\n\nThen I looked at the impl for `retain`, and was like \"oh dang\". I compared the two and they basically ended up being the same speed. And the `retain` impl probably translates to DoubleEndedIter a lot more cleanly if we ever want that.\n\nSo now I'm not totally confident this needs to go in the stdlib, but I've got two implementations and an amazingly robust test suite, so I figured I might as well toss it over the fence for discussion.", "tree": {"sha": "ae563ec808947783758a8222aaac2894cb294640", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae563ec808947783758a8222aaac2894cb294640"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e60a477a3f28ec5dc6e93e2714320d829bd7942", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e60a477a3f28ec5dc6e93e2714320d829bd7942", "html_url": "https://github.com/rust-lang/rust/commit/1e60a477a3f28ec5dc6e93e2714320d829bd7942", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e60a477a3f28ec5dc6e93e2714320d829bd7942/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f25c2283b3f8a7518b2f83a252b50d29d9bfbfda", "url": "https://api.github.com/repos/rust-lang/rust/commits/f25c2283b3f8a7518b2f83a252b50d29d9bfbfda", "html_url": "https://github.com/rust-lang/rust/commit/f25c2283b3f8a7518b2f83a252b50d29d9bfbfda"}, {"sha": "1af42261e142c20c1aed30732ad77bf3560318a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1af42261e142c20c1aed30732ad77bf3560318a1", "html_url": "https://github.com/rust-lang/rust/commit/1af42261e142c20c1aed30732ad77bf3560318a1"}], "stats": {"total": 281, "additions": 281, "deletions": 0}, "files": [{"sha": "86309dd87de9bc690456221956e6885927e37188", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1e60a477a3f28ec5dc6e93e2714320d829bd7942/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e60a477a3f28ec5dc6e93e2714320d829bd7942/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=1e60a477a3f28ec5dc6e93e2714320d829bd7942", "patch": "@@ -16,6 +16,7 @@\n #![feature(inclusive_range_syntax)]\n #![feature(collection_placement)]\n #![feature(const_fn)]\n+#![feature(drain_filter)]\n #![feature(exact_size_is_empty)]\n #![feature(iterator_step_by)]\n #![feature(pattern)]"}, {"sha": "670ea8089fc26904b43e3fd855e1d4088c1f4097", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/1e60a477a3f28ec5dc6e93e2714320d829bd7942/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e60a477a3f28ec5dc6e93e2714320d829bd7942/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=1e60a477a3f28ec5dc6e93e2714320d829bd7942", "patch": "@@ -801,3 +801,170 @@ fn overaligned_allocations() {\n         assert!(v.as_ptr() as usize & 0xff == 0);\n     }\n }\n+\n+#[test]\n+fn drain_filter_empty() {\n+    let mut vec: Vec<i32> = vec![];\n+\n+    {\n+        let mut iter = vec.drain_filter(|_| true);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+    }\n+    assert_eq!(vec.len(), 0);\n+    assert_eq!(vec, vec![]);\n+}\n+\n+#[test]\n+fn drain_filter_zst() {\n+    let mut vec = vec![(), (), (), (), ()];\n+    let initial_len = vec.len();\n+    let mut count = 0;\n+    {\n+        let mut iter = vec.drain_filter(|_| true);\n+        assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n+        while let Some(_) = iter.next() {\n+            count += 1;\n+            assert_eq!(iter.size_hint(), (0, Some(initial_len - count)));\n+        }\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+    }\n+\n+    assert_eq!(count, initial_len);\n+    assert_eq!(vec.len(), 0);\n+    assert_eq!(vec, vec![]);\n+}\n+\n+#[test]\n+fn drain_filter_false() {\n+    let mut vec = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+\n+    let initial_len = vec.len();\n+    let mut count = 0;\n+    {\n+        let mut iter = vec.drain_filter(|_| false);\n+        assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n+        for _ in iter.by_ref() {\n+            count += 1;\n+        }\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+    }\n+\n+    assert_eq!(count, 0);\n+    assert_eq!(vec.len(), initial_len);\n+    assert_eq!(vec, vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+}\n+\n+#[test]\n+fn drain_filter_true() {\n+    let mut vec = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+\n+    let initial_len = vec.len();\n+    let mut count = 0;\n+    {\n+        let mut iter = vec.drain_filter(|_| true);\n+        assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n+        while let Some(_) = iter.next() {\n+            count += 1;\n+            assert_eq!(iter.size_hint(), (0, Some(initial_len - count)));\n+        }\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+    }\n+\n+    assert_eq!(count, initial_len);\n+    assert_eq!(vec.len(), 0);\n+    assert_eq!(vec, vec![]);\n+}\n+\n+#[test]\n+fn drain_filter_complex() {\n+\n+    {   //                [+xxx++++++xxxxx++++x+x++]\n+        let mut vec = vec![1,\n+                           2, 4, 6,\n+                           7, 9, 11, 13, 15, 17,\n+                           18, 20, 22, 24, 26,\n+                           27, 29, 31, 33,\n+                           34,\n+                           35,\n+                           36,\n+                           37, 39];\n+\n+        let removed = vec.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n+\n+        assert_eq!(vec.len(), 14);\n+        assert_eq!(vec, vec![1, 7, 9, 11, 13, 15, 17, 27, 29, 31, 33, 35, 37, 39]);\n+    }\n+\n+    {   //                [xxx++++++xxxxx++++x+x++]\n+        let mut vec = vec![2, 4, 6,\n+                           7, 9, 11, 13, 15, 17,\n+                           18, 20, 22, 24, 26,\n+                           27, 29, 31, 33,\n+                           34,\n+                           35,\n+                           36,\n+                           37, 39];\n+\n+        let removed = vec.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n+\n+        assert_eq!(vec.len(), 13);\n+        assert_eq!(vec, vec![7, 9, 11, 13, 15, 17, 27, 29, 31, 33, 35, 37, 39]);\n+    }\n+\n+    {   //                [xxx++++++xxxxx++++x+x]\n+        let mut vec = vec![2, 4, 6,\n+                           7, 9, 11, 13, 15, 17,\n+                           18, 20, 22, 24, 26,\n+                           27, 29, 31, 33,\n+                           34,\n+                           35,\n+                           36];\n+\n+        let removed = vec.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n+\n+        assert_eq!(vec.len(), 11);\n+        assert_eq!(vec, vec![7, 9, 11, 13, 15, 17, 27, 29, 31, 33, 35]);\n+    }\n+\n+    {   //                [xxxxxxxxxx+++++++++++]\n+        let mut vec = vec![2, 4, 6, 8, 10, 12, 14, 16, 18, 20,\n+                           1, 3, 5, 7, 9, 11, 13, 15, 17, 19];\n+\n+        let removed = vec.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 8, 10, 12, 14, 16, 18, 20]);\n+\n+        assert_eq!(vec.len(), 10);\n+        assert_eq!(vec, vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19]);\n+    }\n+\n+    {   //                [+++++++++++xxxxxxxxxx]\n+        let mut vec = vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19,\n+                           2, 4, 6, 8, 10, 12, 14, 16, 18, 20];\n+\n+        let removed = vec.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 8, 10, 12, 14, 16, 18, 20]);\n+\n+        assert_eq!(vec.len(), 10);\n+        assert_eq!(vec, vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19]);\n+    }\n+}\n+\n+"}, {"sha": "9392ec3e6c5c67aee5b35a198dc882a58a078fcb", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/1e60a477a3f28ec5dc6e93e2714320d829bd7942/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e60a477a3f28ec5dc6e93e2714320d829bd7942/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=1e60a477a3f28ec5dc6e93e2714320d829bd7942", "patch": "@@ -1960,6 +1960,65 @@ impl<T> Vec<T> {\n         }\n     }\n \n+    /// Creates an iterator which uses a closure to determine if an element should be removed.\n+    ///\n+    /// If the closure returns true, then the element is removed and yielded.\n+    /// If the closure returns false, it will try again, and call the closure\n+    /// on the next element, seeing if it passes the test.\n+    ///\n+    /// Using this method is equivalent to the following code:\n+    ///\n+    /// ```\n+    /// # let some_predicate = |x: &mut i32| { *x == 2 };\n+    /// # let mut vec = vec![1, 2, 3, 4, 5];\n+    /// let mut i = 0;\n+    /// while i != vec.len() {\n+    ///     if some_predicate(&mut vec[i]) {\n+    ///         let val = vec.remove(i);\n+    ///         // your code here\n+    ///     }\n+    ///     i += 1;\n+    /// }\n+    /// ```\n+    ///\n+    /// But `drain_filter` is easier to use. `drain_filter` is also more efficient,\n+    /// because it can backshift the elements of the array in bulk.\n+    ///\n+    /// Note that `drain_filter` also lets you mutate every element in the filter closure,\n+    /// regardless of whether you choose to keep or remove it.\n+    ///\n+    ///\n+    /// # Examples\n+    ///\n+    /// Splitting an array into evens and odds, reusing the original allocation:\n+    ///\n+    /// ```\n+    /// #![feature(drain_filter)]\n+    /// let mut numbers = vec![1, 2, 3, 4, 5, 6, 8, 9, 11, 13, 14, 15];\n+    ///\n+    /// let evens = numbers.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+    /// let odds = numbers;\n+    ///\n+    /// assert_eq!(evens, vec![2, 4, 6, 8, 14]);\n+    /// assert_eq!(odds, vec![1, 3, 5, 9, 11, 13, 15]);\n+    /// ```\n+    #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+    pub fn drain_filter<F>(&mut self, filter: F) -> DrainFilter<T, F>\n+        where F: FnMut(&mut T) -> bool,\n+    {\n+        let old_len = self.len();\n+\n+        // Guard against us getting leaked (leak amplification)\n+        unsafe { self.set_len(0); }\n+\n+        DrainFilter {\n+            vec: self,\n+            idx: 0,\n+            del: 0,\n+            old_len,\n+            pred: filter,\n+        }\n+    }\n }\n \n /// Extend implementation that copies elements out of references before pushing them onto the Vec.\n@@ -2602,3 +2661,57 @@ impl<'a, T> Drain<'a, T> {\n         self.tail_start = new_tail_start;\n     }\n }\n+\n+/// An iterator produced by calling `drain_filter` on Vec.\n+#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+#[derive(Debug)]\n+pub struct DrainFilter<'a, T: 'a, F>\n+    where F: FnMut(&mut T) -> bool,\n+{\n+    vec: &'a mut Vec<T>,\n+    idx: usize,\n+    del: usize,\n+    old_len: usize,\n+    pred: F,\n+}\n+\n+#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+impl<'a, T, F> Iterator for DrainFilter<'a, T, F>\n+    where F: FnMut(&mut T) -> bool,\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        unsafe {\n+            while self.idx != self.old_len {\n+                let i = self.idx;\n+                self.idx += 1;\n+                let v = slice::from_raw_parts_mut(self.vec.as_mut_ptr(), self.old_len);\n+                if (self.pred)(&mut v[i]) {\n+                    self.del += 1;\n+                    return Some(ptr::read(&v[i]));\n+                } else if self.del > 0 {\n+                    v.swap(i - self.del, i);\n+                }\n+            }\n+            None\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (0, Some(self.old_len - self.idx))\n+    }\n+}\n+\n+#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+impl<'a, T, F> Drop for DrainFilter<'a, T, F>\n+    where F: FnMut(&mut T) -> bool,\n+{\n+    fn drop(&mut self) {\n+        for _ in self.by_ref() { }\n+\n+        unsafe {\n+            self.vec.set_len(self.old_len - self.del);\n+        }\n+    }\n+}"}]}