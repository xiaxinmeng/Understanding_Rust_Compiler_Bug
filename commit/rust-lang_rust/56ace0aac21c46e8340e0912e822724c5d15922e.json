{"sha": "56ace0aac21c46e8340e0912e822724c5d15922e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2YWNlMGFhYzIxYzQ2ZTgzNDBlMDkxMmU4MjI3MjRjNWQxNTkyMmU=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-04-20T00:27:31Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-04-20T04:26:24Z"}, "message": "Pass down NodeId to resolve_path", "tree": {"sha": "3a82f1fda063a20e2c79a7867069a9aeeaae127e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a82f1fda063a20e2c79a7867069a9aeeaae127e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56ace0aac21c46e8340e0912e822724c5d15922e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56ace0aac21c46e8340e0912e822724c5d15922e", "html_url": "https://github.com/rust-lang/rust/commit/56ace0aac21c46e8340e0912e822724c5d15922e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56ace0aac21c46e8340e0912e822724c5d15922e/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8830a0304327ba8c983555ac5d42cec0569c31bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/8830a0304327ba8c983555ac5d42cec0569c31bb", "html_url": "https://github.com/rust-lang/rust/commit/8830a0304327ba8c983555ac5d42cec0569c31bb"}], "stats": {"total": 32, "additions": 19, "deletions": 13}, "files": [{"sha": "1abf336ed73dca63e902f75d1df9aa578992baf7", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/56ace0aac21c46e8340e0912e822724c5d15922e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ace0aac21c46e8340e0912e822724c5d15922e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=56ace0aac21c46e8340e0912e822724c5d15922e", "patch": "@@ -1654,11 +1654,12 @@ impl<'a> Resolver<'a> {\n         let path: Vec<Ident> = segments.iter()\n             .map(|seg| Ident::new(seg.name, span))\n             .collect();\n-        match self.resolve_path(&path, Some(namespace), true, span) {\n+        // FIXME (Manishearth): Intra doc links won't get warned of epoch changes\n+        match self.resolve_path(&path, Some(namespace), true, span, None) {\n             PathResult::Module(module) => *def = module.def().unwrap(),\n             PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 =>\n                 *def = path_res.base_def(),\n-            PathResult::NonModule(..) => match self.resolve_path(&path, None, true, span) {\n+            PathResult::NonModule(..) => match self.resolve_path(&path, None, true, span, None) {\n                 PathResult::Failed(span, msg, _) => {\n                     error_callback(self, span, ResolutionError::FailedToResolve(&msg));\n                 }\n@@ -2360,7 +2361,8 @@ impl<'a> Resolver<'a> {\n             if def != Def::Err {\n                 new_id = Some(def.def_id());\n                 let span = trait_ref.path.span;\n-                if let PathResult::Module(module) = self.resolve_path(&path, None, false, span) {\n+                if let PathResult::Module(module) = self.resolve_path(&path, None, false, span,\n+                                                                      Some(trait_ref.ref_id)) {\n                     new_val = Some((module, trait_ref.clone()));\n                 }\n             }\n@@ -2819,7 +2821,8 @@ impl<'a> Resolver<'a> {\n                     (format!(\"\"), format!(\"the crate root\"))\n                 } else {\n                     let mod_path = &path[..path.len() - 1];\n-                    let mod_prefix = match this.resolve_path(mod_path, Some(TypeNS), false, span) {\n+                    let mod_prefix = match this.resolve_path(mod_path, Some(TypeNS),\n+                                                             false, span, None) {\n                         PathResult::Module(module) => module.def(),\n                         _ => None,\n                     }.map_or(format!(\"\"), |def| format!(\"{} \", def.kind_name()));\n@@ -3149,7 +3152,7 @@ impl<'a> Resolver<'a> {\n             ));\n         }\n \n-        let result = match self.resolve_path(&path, Some(ns), true, span) {\n+        let result = match self.resolve_path(&path, Some(ns), true, span, Some(id)) {\n             PathResult::NonModule(path_res) => path_res,\n             PathResult::Module(module) if !module.is_normal() => {\n                 PathResolution::new(module.def().unwrap())\n@@ -3186,7 +3189,7 @@ impl<'a> Resolver<'a> {\n            path[0].name != keywords::CrateRoot.name() &&\n            path[0].name != keywords::DollarCrate.name() {\n             let unqualified_result = {\n-                match self.resolve_path(&[*path.last().unwrap()], Some(ns), false, span) {\n+                match self.resolve_path(&[*path.last().unwrap()], Some(ns), false, span, Some(id)) {\n                     PathResult::NonModule(path_res) => path_res.base_def(),\n                     PathResult::Module(module) => module.def().unwrap(),\n                     _ => return Some(result),\n@@ -3205,7 +3208,8 @@ impl<'a> Resolver<'a> {\n                     path: &[Ident],\n                     opt_ns: Option<Namespace>, // `None` indicates a module path\n                     record_used: bool,\n-                    path_span: Span)\n+                    path_span: Span,\n+                    _node_id: Option<NodeId>)\n                     -> PathResult<'a> {\n         let mut module = None;\n         let mut allow_super = true;\n@@ -3571,7 +3575,7 @@ impl<'a> Resolver<'a> {\n             // Search in module.\n             let mod_path = &path[..path.len() - 1];\n             if let PathResult::Module(module) = self.resolve_path(mod_path, Some(TypeNS),\n-                                                                  false, span) {\n+                                                                  false, span, None) {\n                 add_module_candidates(module, &mut names);\n             }\n         }"}, {"sha": "922ffe771479190bcf9d583122b99a0bdd07d8ae", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56ace0aac21c46e8340e0912e822724c5d15922e/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ace0aac21c46e8340e0912e822724c5d15922e/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=56ace0aac21c46e8340e0912e822724c5d15922e", "patch": "@@ -426,7 +426,7 @@ impl<'a> Resolver<'a> {\n                 return Err(Determinacy::Determined);\n             }\n \n-            let def = match self.resolve_path(&path, Some(MacroNS), false, span) {\n+            let def = match self.resolve_path(&path, Some(MacroNS), false, span, None) {\n                 PathResult::NonModule(path_res) => match path_res.base_def() {\n                     Def::Err => Err(Determinacy::Determined),\n                     def @ _ => {\n@@ -604,7 +604,7 @@ impl<'a> Resolver<'a> {\n     pub fn finalize_current_module_macro_resolutions(&mut self) {\n         let module = self.current_module;\n         for &(ref path, span) in module.macro_resolutions.borrow().iter() {\n-            match self.resolve_path(&path, Some(MacroNS), true, span) {\n+            match self.resolve_path(&path, Some(MacroNS), true, span, None) {\n                 PathResult::NonModule(_) => {},\n                 PathResult::Failed(span, msg, _) => {\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&msg));"}, {"sha": "d6230cc4a67aeb111fa971e18f71e71e901b3557", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/56ace0aac21c46e8340e0912e822724c5d15922e/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ace0aac21c46e8340e0912e822724c5d15922e/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=56ace0aac21c46e8340e0912e822724c5d15922e", "patch": "@@ -535,7 +535,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             // For better failure detection, pretend that the import will not define any names\n             // while resolving its module path.\n             directive.vis.set(ty::Visibility::Invisible);\n-            let result = self.resolve_path(&directive.module_path[..], None, false, directive.span);\n+            let result = self.resolve_path(&directive.module_path[..], None, false,\n+                                           directive.span, Some(directive.id));\n             directive.vis.set(vis);\n \n             match result {\n@@ -663,7 +664,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             }\n         }\n \n-        let module_result = self.resolve_path(&module_path, None, true, span);\n+        let module_result = self.resolve_path(&module_path, None, true, span, Some(directive.id));\n         let module = match module_result {\n             PathResult::Module(module) => module,\n             PathResult::Failed(span, msg, false) => {\n@@ -677,7 +678,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 if !self_path.is_empty() && !is_special(self_path[0]) &&\n                    !(self_path.len() > 1 && is_special(self_path[1])) {\n                     self_path[0].name = keywords::SelfValue.name();\n-                    self_result = Some(self.resolve_path(&self_path, None, false, span));\n+                    self_result = Some(self.resolve_path(&self_path, None, false,\n+                                                         span, Some(directive.id)));\n                 }\n                 return if let Some(PathResult::Module(..)) = self_result {\n                     Some((span, format!(\"Did you mean `{}`?\", names_to_string(&self_path[..]))))"}]}