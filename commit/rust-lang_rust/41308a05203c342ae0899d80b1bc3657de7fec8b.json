{"sha": "41308a05203c342ae0899d80b1bc3657de7fec8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxMzA4YTA1MjAzYzM0MmFlMDg5OWQ4MGIxYmMzNjU3ZGU3ZmVjOGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-06T00:56:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-06T00:56:08Z"}, "message": "Auto merge of #29305 - alexcrichton:bad-getenv, r=brson\n\nAs discovered in #29298, `env::set_var(\"\", \"\")` will panic, but it turns out\nthat it *also* deadlocks on Unix systems. This happens because if a panic\nhappens while holding the environment lock, we then go try to read\nRUST_BACKTRACE, grabbing the environment lock, causing a deadlock.\n\nSpecifically, the changes made here are:\n\n* The environment lock is pushed into `std::sys` instead of `std::env`. This\n  also only puts it in the Unix implementation, not Windows where the functions\n  are already threadsafe.\n* The `std::sys` implementation now returns `io::Result` so panics are\n  explicitly at the `std::env` level.", "tree": {"sha": "d68ab0a72705855be5943a891e9b75c708110c8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d68ab0a72705855be5943a891e9b75c708110c8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41308a05203c342ae0899d80b1bc3657de7fec8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41308a05203c342ae0899d80b1bc3657de7fec8b", "html_url": "https://github.com/rust-lang/rust/commit/41308a05203c342ae0899d80b1bc3657de7fec8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41308a05203c342ae0899d80b1bc3657de7fec8b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1dac3adc34a85670d81f86345054ec58e658b68b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1dac3adc34a85670d81f86345054ec58e658b68b", "html_url": "https://github.com/rust-lang/rust/commit/1dac3adc34a85670d81f86345054ec58e658b68b"}, {"sha": "4b43e07af90558d7d3c0eafd08776909d542b7d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b43e07af90558d7d3c0eafd08776909d542b7d7", "html_url": "https://github.com/rust-lang/rust/commit/4b43e07af90558d7d3c0eafd08776909d542b7d7"}], "stats": {"total": 118, "additions": 62, "deletions": 56}, "files": [{"sha": "c572f9fb36b67a4b1af27cff57cde871ab21d561", "filename": "src/libstd/env.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/41308a05203c342ae0899d80b1bc3657de7fec8b/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41308a05203c342ae0899d80b1bc3657de7fec8b/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=41308a05203c342ae0899d80b1bc3657de7fec8b", "patch": "@@ -23,7 +23,6 @@ use ffi::{OsStr, OsString};\n use fmt;\n use io;\n use path::{Path, PathBuf};\n-use sync::StaticMutex;\n use sys::os as os_imp;\n \n /// Returns the current working directory as a `PathBuf`.\n@@ -68,8 +67,6 @@ pub fn set_current_dir<P: AsRef<Path>>(p: P) -> io::Result<()> {\n     os_imp::chdir(p.as_ref())\n }\n \n-static ENV_LOCK: StaticMutex = StaticMutex::new();\n-\n /// An iterator over a snapshot of the environment variables of this process.\n ///\n /// This iterator is created through `std::env::vars()` and yields `(String,\n@@ -133,7 +130,6 @@ pub fn vars() -> Vars {\n /// ```\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub fn vars_os() -> VarsOs {\n-    let _g = ENV_LOCK.lock();\n     VarsOs { inner: os_imp::env() }\n }\n \n@@ -204,8 +200,9 @@ pub fn var_os<K: AsRef<OsStr>>(key: K) -> Option<OsString> {\n }\n \n fn _var_os(key: &OsStr) -> Option<OsString> {\n-    let _g = ENV_LOCK.lock();\n-    os_imp::getenv(key)\n+    os_imp::getenv(key).unwrap_or_else(|e| {\n+        panic!(\"failed to get environment variable `{:?}`: {}\", key, e)\n+    })\n }\n \n /// Possible errors from the `env::var` method.\n@@ -281,8 +278,10 @@ pub fn set_var<K: AsRef<OsStr>, V: AsRef<OsStr>>(k: K, v: V) {\n }\n \n fn _set_var(k: &OsStr, v: &OsStr) {\n-    let _g = ENV_LOCK.lock();\n-    os_imp::setenv(k, v)\n+    os_imp::setenv(k, v).unwrap_or_else(|e| {\n+        panic!(\"failed to set environment variable `{:?}` to `{:?}`: {}\",\n+               k, v, e)\n+    })\n }\n \n /// Removes an environment variable from the environment of the currently running process.\n@@ -322,8 +321,9 @@ pub fn remove_var<K: AsRef<OsStr>>(k: K) {\n }\n \n fn _remove_var(k: &OsStr) {\n-    let _g = ENV_LOCK.lock();\n-    os_imp::unsetenv(k)\n+    os_imp::unsetenv(k).unwrap_or_else(|e| {\n+        panic!(\"failed to remove environment variable `{:?}`: {}\", k, e)\n+    })\n }\n \n /// An iterator over `Path` instances for parsing an environment variable"}, {"sha": "4e7058d06879ec2fa72f43200d6d4e3392537311", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/41308a05203c342ae0899d80b1bc3657de7fec8b/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41308a05203c342ae0899d80b1bc3657de7fec8b/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=41308a05203c342ae0899d80b1bc3657de7fec8b", "patch": "@@ -26,11 +26,14 @@ use path::{self, PathBuf};\n use ptr;\n use slice;\n use str;\n+use sync::StaticMutex;\n use sys::c;\n use sys::fd;\n+use sys::cvt;\n use vec;\n \n const TMPBUF_SZ: usize = 128;\n+static ENV_LOCK: StaticMutex = StaticMutex::new();\n \n /// Returns the platform-specific value of errno\n pub fn errno() -> i32 {\n@@ -378,6 +381,7 @@ pub unsafe fn environ() -> *mut *const *const c_char {\n /// Returns a vector of (variable, value) byte-vector pairs for all the\n /// environment variables of the current process.\n pub fn env() -> Env {\n+    let _g = ENV_LOCK.lock();\n     return unsafe {\n         let mut environ = *environ();\n         if environ as usize == 0 {\n@@ -401,35 +405,36 @@ pub fn env() -> Env {\n     }\n }\n \n-pub fn getenv(k: &OsStr) -> Option<OsString> {\n-    unsafe {\n-        let s = k.to_cstring().unwrap();\n-        let s = libc::getenv(s.as_ptr()) as *const _;\n+pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n+    // environment variables with a nul byte can't be set, so their value is\n+    // always None as well\n+    let k = try!(CString::new(k.as_bytes()));\n+    let _g = ENV_LOCK.lock();\n+    Ok(unsafe {\n+        let s = libc::getenv(k.as_ptr()) as *const _;\n         if s.is_null() {\n             None\n         } else {\n             Some(OsStringExt::from_vec(CStr::from_ptr(s).to_bytes().to_vec()))\n         }\n-    }\n+    })\n }\n \n-pub fn setenv(k: &OsStr, v: &OsStr) {\n-    unsafe {\n-        let k = k.to_cstring().unwrap();\n-        let v = v.to_cstring().unwrap();\n-        if libc::funcs::posix01::unistd::setenv(k.as_ptr(), v.as_ptr(), 1) != 0 {\n-            panic!(\"failed setenv: {}\", io::Error::last_os_error());\n-        }\n-    }\n+pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n+    let k = try!(CString::new(k.as_bytes()));\n+    let v = try!(CString::new(v.as_bytes()));\n+    let _g = ENV_LOCK.lock();\n+    cvt(unsafe {\n+        libc::funcs::posix01::unistd::setenv(k.as_ptr(), v.as_ptr(), 1)\n+    }).map(|_| ())\n }\n \n-pub fn unsetenv(n: &OsStr) {\n-    unsafe {\n-        let nbuf = n.to_cstring().unwrap();\n-        if libc::funcs::posix01::unistd::unsetenv(nbuf.as_ptr()) != 0 {\n-            panic!(\"failed unsetenv: {}\", io::Error::last_os_error());\n-        }\n-    }\n+pub fn unsetenv(n: &OsStr) -> io::Result<()> {\n+    let nbuf = try!(CString::new(n.as_bytes()));\n+    let _g = ENV_LOCK.lock();\n+    cvt(unsafe {\n+        libc::funcs::posix01::unistd::unsetenv(nbuf.as_ptr())\n+    }).map(|_| ())\n }\n \n pub fn page_size() -> usize {\n@@ -439,7 +444,7 @@ pub fn page_size() -> usize {\n }\n \n pub fn temp_dir() -> PathBuf {\n-    getenv(\"TMPDIR\".as_ref()).map(PathBuf::from).unwrap_or_else(|| {\n+    ::env::var_os(\"TMPDIR\").map(PathBuf::from).unwrap_or_else(|| {\n         if cfg!(target_os = \"android\") {\n             PathBuf::from(\"/data/local/tmp\")\n         } else {\n@@ -449,7 +454,7 @@ pub fn temp_dir() -> PathBuf {\n }\n \n pub fn home_dir() -> Option<PathBuf> {\n-    return getenv(\"HOME\".as_ref()).or_else(|| unsafe {\n+    return ::env::var_os(\"HOME\").or_else(|| unsafe {\n         fallback()\n     }).map(PathBuf::from);\n "}, {"sha": "270e260d504db91962e349c4cfede0bb05fb9717", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41308a05203c342ae0899d80b1bc3657de7fec8b/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41308a05203c342ae0899d80b1bc3657de7fec8b/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=41308a05203c342ae0899d80b1bc3657de7fec8b", "patch": "@@ -32,6 +32,7 @@ pub const WSASYS_STATUS_LEN: usize = 128;\n pub const FIONBIO: libc::c_long = 0x8004667e;\n pub const FD_SETSIZE: usize = 64;\n pub const MSG_DONTWAIT: libc::c_int = 0;\n+pub const ERROR_ENVVAR_NOT_FOUND: libc::c_int = 203;\n pub const ERROR_ILLEGAL_CHARACTER: libc::c_int = 582;\n pub const ENABLE_ECHO_INPUT: libc::DWORD = 0x4;\n pub const ENABLE_EXTENDED_FLAGS: libc::DWORD = 0x80;"}, {"sha": "ba4bce38014a49439e812c6be0dbb0597ffb5886", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/41308a05203c342ae0899d80b1bc3657de7fec8b/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41308a05203c342ae0899d80b1bc3657de7fec8b/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=41308a05203c342ae0899d80b1bc3657de7fec8b", "patch": "@@ -26,7 +26,7 @@ use os::windows::ffi::EncodeWide;\n use path::{self, PathBuf};\n use ptr;\n use slice;\n-use sys::c;\n+use sys::{c, cvt};\n use sys::handle::Handle;\n \n use libc::funcs::extra::kernel32::{\n@@ -248,41 +248,41 @@ pub fn chdir(p: &path::Path) -> io::Result<()> {\n     let mut p = p.encode_wide().collect::<Vec<_>>();\n     p.push(0);\n \n-    unsafe {\n-        match libc::SetCurrentDirectoryW(p.as_ptr()) != (0 as libc::BOOL) {\n-            true => Ok(()),\n-            false => Err(io::Error::last_os_error()),\n-        }\n-    }\n+    cvt(unsafe {\n+        libc::SetCurrentDirectoryW(p.as_ptr())\n+    }).map(|_| ())\n }\n \n-pub fn getenv(k: &OsStr) -> Option<OsString> {\n+pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n     let k = super::to_utf16_os(k);\n-    super::fill_utf16_buf(|buf, sz| unsafe {\n+    let res = super::fill_utf16_buf(|buf, sz| unsafe {\n         libc::GetEnvironmentVariableW(k.as_ptr(), buf, sz)\n     }, |buf| {\n         OsStringExt::from_wide(buf)\n-    }).ok()\n+    });\n+    match res {\n+        Ok(value) => Ok(Some(value)),\n+        Err(ref e) if e.raw_os_error() == Some(c::ERROR_ENVVAR_NOT_FOUND) => {\n+            Ok(None)\n+        }\n+        Err(e) => Err(e)\n+    }\n }\n \n-pub fn setenv(k: &OsStr, v: &OsStr) {\n+pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n     let k = super::to_utf16_os(k);\n     let v = super::to_utf16_os(v);\n \n-    unsafe {\n-        if libc::SetEnvironmentVariableW(k.as_ptr(), v.as_ptr()) == 0 {\n-            panic!(\"failed to set env: {}\", io::Error::last_os_error());\n-        }\n-    }\n+    cvt(unsafe {\n+        libc::SetEnvironmentVariableW(k.as_ptr(), v.as_ptr())\n+    }).map(|_| ())\n }\n \n-pub fn unsetenv(n: &OsStr) {\n+pub fn unsetenv(n: &OsStr) -> io::Result<()> {\n     let v = super::to_utf16_os(n);\n-    unsafe {\n-        if libc::SetEnvironmentVariableW(v.as_ptr(), ptr::null()) == 0 {\n-            panic!(\"failed to unset env: {}\", io::Error::last_os_error());\n-        }\n-    }\n+    cvt(unsafe {\n+        libc::SetEnvironmentVariableW(v.as_ptr(), ptr::null())\n+    }).map(|_| ())\n }\n \n pub struct Args {\n@@ -339,8 +339,8 @@ pub fn temp_dir() -> PathBuf {\n }\n \n pub fn home_dir() -> Option<PathBuf> {\n-    getenv(\"HOME\".as_ref()).or_else(|| {\n-        getenv(\"USERPROFILE\".as_ref())\n+    ::env::var_os(\"HOME\").or_else(|| {\n+        ::env::var_os(\"USERPROFILE\")\n     }).map(PathBuf::from).or_else(|| unsafe {\n         let me = c::GetCurrentProcess();\n         let mut token = ptr::null_mut();"}]}