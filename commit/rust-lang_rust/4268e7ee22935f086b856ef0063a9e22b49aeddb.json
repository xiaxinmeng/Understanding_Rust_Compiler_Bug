{"sha": "4268e7ee22935f086b856ef0063a9e22b49aeddb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyNjhlN2VlMjI5MzVmMDg2Yjg1NmVmMDA2M2E5ZTIyYjQ5YWVkZGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-26T02:18:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-26T02:18:12Z"}, "message": "Auto merge of #60260 - videolabs:rust_uwp2, r=alexcrichton\n\nAdd support for UWP targets\n\nHi,\n\nThis pull request aims at adding support for UWP (Universal Windows Apps) platform.\nA few notes:\n- This requires a very recent mingw-w64 version (containing this commit and the previous related ones: https://github.com/mirror/mingw-w64/commit/e8c433c871687a78408ae9b40ab7776577db908d#diff-eefdfbfe9cec5f4ebab88c9a64d423a9)\n- This was tested using LLVM/clang rather than gcc, and so far it assumes that LLVM/clang will be the native compiler. This is mostly due to the fact that the support for exceptions/stack unwinding for UWP got much more attention in libunwind\n- The \"uwp\" part of the target needs support for it in the `cc-rs` & `backtrace-rs` crates. I'll create the MR there right after I submit this one and will link everything together, but I'm not sure what's the correct way of dealing with external dependencies in the context of rust\n- Enabling import libraries and copying them across stages requires a change in cargo, for which I'll open a MR right after I submit this one as well\n- The i686 stack unwinding is unsupported for now, because LLVM assumes SjLj, while rust seems to assume SEH will be used. I'm unsure how to fix this\n\nAlso, this is my first encounter with rust, so please bear with my code, it might not feel so idiomatic or even correct :)\n\nI'm pretty sure there's a way of doing things in a cleaner way when it comes to win/c.rs, maybe having a UWP & desktop specific modules, and import those conditionally? It doesn't feel right to sprinkle `#[cfg(...)]` all over the place\n\nOff course, I'll gladly update anything you see fit (to the extent of my abilities/knowledge :) )!\n\nThanks,", "tree": {"sha": "ee5a7d496ea4488f1472ab2f6cbf105773fc762c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee5a7d496ea4488f1472ab2f6cbf105773fc762c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4268e7ee22935f086b856ef0063a9e22b49aeddb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4268e7ee22935f086b856ef0063a9e22b49aeddb", "html_url": "https://github.com/rust-lang/rust/commit/4268e7ee22935f086b856ef0063a9e22b49aeddb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4268e7ee22935f086b856ef0063a9e22b49aeddb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18630677cf6c7ac50e6786c504b35bc09501dbe2", "url": "https://api.github.com/repos/rust-lang/rust/commits/18630677cf6c7ac50e6786c504b35bc09501dbe2", "html_url": "https://github.com/rust-lang/rust/commit/18630677cf6c7ac50e6786c504b35bc09501dbe2"}, {"sha": "7ed5c36934c8023a0e55c8708dec87774212ca23", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ed5c36934c8023a0e55c8708dec87774212ca23", "html_url": "https://github.com/rust-lang/rust/commit/7ed5c36934c8023a0e55c8708dec87774212ca23"}], "stats": {"total": 646, "additions": 529, "deletions": 117}, "files": [{"sha": "4cd793adaf574d2588db110f3ef9b60e547e2bd5", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=4268e7ee22935f086b856ef0063a9e22b49aeddb", "patch": "@@ -325,7 +325,7 @@ impl Step for StartupObjects {\n     fn run(self, builder: &Builder<'_>) {\n         let for_compiler = self.compiler;\n         let target = self.target;\n-        if !target.contains(\"pc-windows-gnu\") {\n+        if !target.contains(\"windows-gnu\") {\n             return\n         }\n \n@@ -1126,6 +1126,7 @@ pub fn run_cargo(builder: &Builder<'_>,\n             // Skip files like executables\n             if !filename.ends_with(\".rlib\") &&\n                !filename.ends_with(\".lib\") &&\n+               !filename.ends_with(\".a\") &&\n                !is_dylib(&filename) &&\n                !(is_check && filename.ends_with(\".rmeta\")) {\n                 continue;"}, {"sha": "cb8870d0be90cb234d7ed53d3c75e41a04d8ca5c", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=4268e7ee22935f086b856ef0063a9e22b49aeddb", "patch": "@@ -368,6 +368,26 @@ impl<'a> Linker for GccLinker<'a> {\n             }\n         } else {\n             self.cmd.arg(\"-shared\");\n+            if self.sess.target.target.options.is_like_windows {\n+                // The output filename already contains `dll_suffix` so\n+                // the resulting import library will have a name in the\n+                // form of libfoo.dll.a\n+                let implib_name = out_filename\n+                    .file_name()\n+                    .and_then(|file| file.to_str())\n+                    .map(|file| format!(\"{}{}{}\",\n+                         self.sess.target.target.options.staticlib_prefix,\n+                         file,\n+                         self.sess.target.target.options.staticlib_suffix));\n+                if let Some(implib_name) = implib_name {\n+                    let implib = out_filename\n+                        .parent()\n+                        .map(|dir| dir.join(&implib_name));\n+                    if let Some(implib) = implib {\n+                        self.linker_arg(&format!(\"--out-implib,{}\", (*implib).to_str().unwrap()));\n+                    }\n+                }\n+            }\n         }\n     }\n "}, {"sha": "3ad77525eb37d4c88f514c04790e18c09fd6612c", "filename": "src/librustc_target/spec/i686_uwp_windows_gnu.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibrustc_target%2Fspec%2Fi686_uwp_windows_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibrustc_target%2Fspec%2Fi686_uwp_windows_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fi686_uwp_windows_gnu.rs?ref=4268e7ee22935f086b856ef0063a9e22b49aeddb", "patch": "@@ -0,0 +1,27 @@\n+use crate::spec::{LinkerFlavor, Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::windows_uwp_base::opts();\n+    base.cpu = \"pentium4\".to_string();\n+    base.max_atomic_width = Some(64);\n+    base.eliminate_frame_pointer = false; // Required for backtraces\n+\n+    // Mark all dynamic libraries and executables as compatible with the larger 4GiB address\n+    // space available to x86 Windows binaries on x86_64.\n+    base.pre_link_args\n+        .get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-Wl,--large-address-aware\".to_string());\n+\n+    Ok(Target {\n+        llvm_target: \"i686-pc-windows-gnu\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:x-p:32:32-i64:64-f80:32-n8:16:32-a:0:32-S32\".to_string(),\n+        arch: \"x86\".to_string(),\n+        target_os: \"windows\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        target_vendor: \"uwp\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: base,\n+    })\n+}"}, {"sha": "f80e58f9538990e6ba8ba1506013c808a11f810e", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=4268e7ee22935f086b856ef0063a9e22b49aeddb", "patch": "@@ -60,6 +60,7 @@ mod solaris_base;\n mod uefi_base;\n mod windows_base;\n mod windows_msvc_base;\n+mod windows_uwp_base;\n mod thumb_base;\n mod l4re_base;\n mod fuchsia_base;\n@@ -434,6 +435,8 @@ supported_targets! {\n \n     (\"x86_64-pc-windows-gnu\", x86_64_pc_windows_gnu),\n     (\"i686-pc-windows-gnu\", i686_pc_windows_gnu),\n+    (\"i686-uwp-windows-gnu\", i686_uwp_windows_gnu),\n+    (\"x86_64-uwp-windows-gnu\", x86_64_uwp_windows_gnu),\n \n     (\"aarch64-pc-windows-msvc\", aarch64_pc_windows_msvc),\n     (\"x86_64-pc-windows-msvc\", x86_64_pc_windows_msvc),"}, {"sha": "108dbc417cbb307ccc563993cc042b18790785e2", "filename": "src/librustc_target/spec/windows_uwp_base.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibrustc_target%2Fspec%2Fwindows_uwp_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibrustc_target%2Fspec%2Fwindows_uwp_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fwindows_uwp_base.rs?ref=4268e7ee22935f086b856ef0063a9e22b49aeddb", "patch": "@@ -0,0 +1,64 @@\n+use crate::spec::{LinkArgs, LinkerFlavor, TargetOptions};\n+use std::default::Default;\n+\n+pub fn opts() -> TargetOptions {\n+    let mut pre_link_args = LinkArgs::new();\n+    pre_link_args.insert(LinkerFlavor::Gcc, vec![\n+            // Tell GCC to avoid linker plugins, because we are not bundling\n+            // them with Windows installer, and Rust does its own LTO anyways.\n+            \"-fno-use-linker-plugin\".to_string(),\n+\n+            // Always enable DEP (NX bit) when it is available\n+            \"-Wl,--nxcompat\".to_string(),\n+        ]);\n+\n+    let mut late_link_args = LinkArgs::new();\n+    late_link_args.insert(LinkerFlavor::Gcc, vec![\n+        //\"-lwinstorecompat\".to_string(),\n+        //\"-lmingwex\".to_string(),\n+        //\"-lwinstorecompat\".to_string(),\n+        \"-lwinstorecompat\".to_string(),\n+        \"-lruntimeobject\".to_string(),\n+        \"-lsynchronization\".to_string(),\n+        \"-lvcruntime140_app\".to_string(),\n+        \"-lucrt\".to_string(),\n+        \"-lwindowsapp\".to_string(),\n+        \"-lmingwex\".to_string(),\n+        \"-lmingw32\".to_string(),\n+    ]);\n+\n+    TargetOptions {\n+        // FIXME(#13846) this should be enabled for windows\n+        function_sections: false,\n+        linker: Some(\"gcc\".to_string()),\n+        dynamic_linking: true,\n+        executables: false,\n+        dll_prefix: String::new(),\n+        dll_suffix: \".dll\".to_string(),\n+        exe_suffix: \".exe\".to_string(),\n+        staticlib_prefix: \"lib\".to_string(),\n+        staticlib_suffix: \".a\".to_string(),\n+        no_default_libraries: true,\n+        target_family: Some(\"windows\".to_string()),\n+        is_like_windows: true,\n+        allows_weak_linkage: false,\n+        pre_link_args,\n+        pre_link_objects_exe: vec![\n+            \"rsbegin.o\".to_string(), // Rust compiler runtime initialization, see rsbegin.rs\n+        ],\n+        pre_link_objects_dll: vec![\n+            \"rsbegin.o\".to_string(),\n+        ],\n+        late_link_args,\n+        post_link_objects: vec![\n+            \"rsend.o\".to_string(),\n+        ],\n+        custom_unwind_resume: true,\n+        abi_return_struct_as_int: true,\n+        emit_debug_gdb_scripts: false,\n+        requires_uwtable: true,\n+        limit_rdylib_exports: false,\n+\n+        .. Default::default()\n+    }\n+}"}, {"sha": "da0c324e4861873d1647a32e8abb2dbb964a9e5e", "filename": "src/librustc_target/spec/x86_64_uwp_windows_gnu.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibrustc_target%2Fspec%2Fx86_64_uwp_windows_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibrustc_target%2Fspec%2Fx86_64_uwp_windows_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fx86_64_uwp_windows_gnu.rs?ref=4268e7ee22935f086b856ef0063a9e22b49aeddb", "patch": "@@ -0,0 +1,22 @@\n+use crate::spec::{LinkerFlavor, Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::windows_uwp_base::opts();\n+    base.cpu = \"x86-64\".to_string();\n+    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m64\".to_string());\n+    base.max_atomic_width = Some(64);\n+\n+    Ok(Target {\n+        llvm_target: \"x86_64-pc-windows-gnu\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:w-i64:64-f80:128-n8:16:32:64-S128\".to_string(),\n+        arch: \"x86_64\".to_string(),\n+        target_os: \"windows\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        target_vendor: \"uwp\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: base,\n+    })\n+}"}, {"sha": "20397369387cb1ec040f19009565413c503afba9", "filename": "src/libstd/build.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=4268e7ee22935f086b856ef0063a9e22b49aeddb", "patch": "@@ -39,6 +39,10 @@ fn main() {\n         println!(\"cargo:rustc-link-lib=framework=Security\");\n         println!(\"cargo:rustc-link-lib=framework=Foundation\");\n         println!(\"cargo:rustc-link-lib=resolv\");\n+    } else if target.contains(\"uwp\") {\n+        println!(\"cargo:rustc-link-lib=ws2_32\");\n+        // For BCryptGenRandom\n+        println!(\"cargo:rustc-link-lib=bcrypt\");\n     } else if target.contains(\"windows\") {\n         println!(\"cargo:rustc-link-lib=advapi32\");\n         println!(\"cargo:rustc-link-lib=ws2_32\");"}, {"sha": "f706709c9ccf4be722ec1564580da37bc41cd9b3", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 131, "deletions": 90, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=4268e7ee22935f086b856ef0063a9e22b49aeddb", "patch": "@@ -34,9 +34,7 @@ pub type ULONG = c_ulong;\n \n pub type LPBOOL = *mut BOOL;\n pub type LPBYTE = *mut BYTE;\n-pub type LPBY_HANDLE_FILE_INFORMATION = *mut BY_HANDLE_FILE_INFORMATION;\n pub type LPCSTR = *const CHAR;\n-pub type LPCVOID = *const c_void;\n pub type LPCWSTR = *const WCHAR;\n pub type LPDWORD = *mut DWORD;\n pub type LPHANDLE = *mut HANDLE;\n@@ -121,6 +119,7 @@ impl Clone for WIN32_FIND_DATAW {\n }\n \n pub const WSA_FLAG_OVERLAPPED: DWORD = 0x01;\n+pub const WSA_FLAG_NO_HANDLE_INHERIT: DWORD = 0x80;\n \n pub const WSADESCRIPTION_LEN: usize = 256;\n pub const WSASYS_STATUS_LEN: usize = 128;\n@@ -130,6 +129,7 @@ pub const INVALID_SOCKET: SOCKET = !0;\n pub const WSAEACCES: c_int = 10013;\n pub const WSAEINVAL: c_int = 10022;\n pub const WSAEWOULDBLOCK: c_int = 10035;\n+pub const WSAEPROTOTYPE: c_int = 10041;\n pub const WSAEADDRINUSE: c_int = 10048;\n pub const WSAEADDRNOTAVAIL: c_int = 10049;\n pub const WSAECONNABORTED: c_int = 10053;\n@@ -141,7 +141,6 @@ pub const WSAECONNREFUSED: c_int = 10061;\n \n pub const MAX_PROTOCOL_CHAIN: DWORD = 7;\n \n-pub const TOKEN_READ: DWORD = 0x20008;\n pub const MAXIMUM_REPARSE_DATA_BUFFER_SIZE: usize = 16 * 1024;\n pub const FSCTL_GET_REPARSE_POINT: DWORD = 0x900a8;\n pub const IO_REPARSE_TAG_SYMLINK: DWORD = 0xa000000c;\n@@ -157,8 +156,6 @@ pub const STD_INPUT_HANDLE: DWORD = -10i32 as DWORD;\n pub const STD_OUTPUT_HANDLE: DWORD = -11i32 as DWORD;\n pub const STD_ERROR_HANDLE: DWORD = -12i32 as DWORD;\n \n-pub const HANDLE_FLAG_INHERIT: DWORD = 0x00000001;\n-\n pub const PROGRESS_CONTINUE: DWORD = 0;\n \n pub const ERROR_FILE_NOT_FOUND: DWORD = 2;\n@@ -259,10 +256,6 @@ pub const WAIT_OBJECT_0: DWORD = 0x00000000;\n pub const WAIT_TIMEOUT: DWORD = 258;\n pub const WAIT_FAILED: DWORD = 0xFFFFFFFF;\n \n-pub const EXCEPTION_CONTINUE_SEARCH: LONG = 0;\n-pub const EXCEPTION_STACK_OVERFLOW: DWORD = 0xc00000fd;\n-pub const EXCEPTION_MAXIMUM_PARAMETERS: usize = 15;\n-\n pub const PIPE_ACCESS_INBOUND: DWORD = 0x00000001;\n pub const PIPE_ACCESS_OUTBOUND: DWORD = 0x00000002;\n pub const FILE_FLAG_FIRST_PIPE_INSTANCE: DWORD = 0x00080000;\n@@ -342,20 +335,6 @@ pub struct WIN32_FILE_ATTRIBUTE_DATA {\n     pub nFileSizeLow: DWORD,\n }\n \n-#[repr(C)]\n-pub struct BY_HANDLE_FILE_INFORMATION {\n-    pub dwFileAttributes: DWORD,\n-    pub ftCreationTime: FILETIME,\n-    pub ftLastAccessTime: FILETIME,\n-    pub ftLastWriteTime: FILETIME,\n-    pub dwVolumeSerialNumber: DWORD,\n-    pub nFileSizeHigh: DWORD,\n-    pub nFileSizeLow: DWORD,\n-    pub nNumberOfLinks: DWORD,\n-    pub nFileIndexHigh: DWORD,\n-    pub nFileIndexLow: DWORD,\n-}\n-\n #[repr(C)]\n #[allow(dead_code)] // we only use some variants\n pub enum FILE_INFO_BY_HANDLE_CLASS {\n@@ -461,25 +440,6 @@ pub struct REPARSE_MOUNTPOINT_DATA_BUFFER {\n     pub ReparseTarget: WCHAR,\n }\n \n-#[repr(C)]\n-pub struct EXCEPTION_RECORD {\n-    pub ExceptionCode: DWORD,\n-    pub ExceptionFlags: DWORD,\n-    pub ExceptionRecord: *mut EXCEPTION_RECORD,\n-    pub ExceptionAddress: LPVOID,\n-    pub NumberParameters: DWORD,\n-    pub ExceptionInformation: [LPVOID; EXCEPTION_MAXIMUM_PARAMETERS]\n-}\n-\n-#[repr(C)]\n-pub struct EXCEPTION_POINTERS {\n-    pub ExceptionRecord: *mut EXCEPTION_RECORD,\n-    pub ContextRecord: *mut CONTEXT,\n-}\n-\n-pub type PVECTORED_EXCEPTION_HANDLER = extern \"system\"\n-        fn(ExceptionInfo: *mut EXCEPTION_POINTERS) -> LONG;\n-\n #[repr(C)]\n pub struct GUID {\n     pub Data1: DWORD,\n@@ -562,8 +522,6 @@ pub enum ADDRESS_MODE {\n     AddrModeFlat,\n }\n \n-pub enum CONTEXT {}\n-\n #[repr(C)]\n pub struct SOCKADDR_STORAGE_LH {\n     pub ss_family: ADDRESS_FAMILY,\n@@ -625,16 +583,6 @@ pub enum EXCEPTION_DISPOSITION {\n     ExceptionCollidedUnwind\n }\n \n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub struct CONSOLE_READCONSOLE_CONTROL {\n-    pub nLength: ULONG,\n-    pub nInitialChars: ULONG,\n-    pub dwCtrlWakeupMask: ULONG,\n-    pub dwControlKeyState: ULONG,\n-}\n-pub type PCONSOLE_READCONSOLE_CONTROL = *mut CONSOLE_READCONSOLE_CONTROL;\n-\n #[repr(C)]\n #[derive(Copy)]\n pub struct fd_set {\n@@ -655,6 +603,134 @@ pub struct timeval {\n     pub tv_usec: c_long,\n }\n \n+// Functions forbidden when targeting UWP\n+cfg_if::cfg_if! {\n+if #[cfg(not(target_vendor = \"uwp\"))] {\n+    pub const EXCEPTION_CONTINUE_SEARCH: LONG = 0;\n+    pub const EXCEPTION_STACK_OVERFLOW: DWORD = 0xc00000fd;\n+    pub const EXCEPTION_MAXIMUM_PARAMETERS: usize = 15;\n+\n+    #[repr(C)]\n+    pub struct EXCEPTION_RECORD {\n+        pub ExceptionCode: DWORD,\n+        pub ExceptionFlags: DWORD,\n+        pub ExceptionRecord: *mut EXCEPTION_RECORD,\n+        pub ExceptionAddress: LPVOID,\n+        pub NumberParameters: DWORD,\n+        pub ExceptionInformation: [LPVOID; EXCEPTION_MAXIMUM_PARAMETERS]\n+    }\n+\n+    pub enum CONTEXT {}\n+\n+    #[repr(C)]\n+    pub struct EXCEPTION_POINTERS {\n+        pub ExceptionRecord: *mut EXCEPTION_RECORD,\n+        pub ContextRecord: *mut CONTEXT,\n+    }\n+\n+    pub type PVECTORED_EXCEPTION_HANDLER = extern \"system\"\n+            fn(ExceptionInfo: *mut EXCEPTION_POINTERS) -> LONG;\n+\n+    #[repr(C)]\n+    #[derive(Copy, Clone)]\n+    pub struct CONSOLE_READCONSOLE_CONTROL {\n+        pub nLength: ULONG,\n+        pub nInitialChars: ULONG,\n+        pub dwCtrlWakeupMask: ULONG,\n+        pub dwControlKeyState: ULONG,\n+    }\n+\n+    pub type PCONSOLE_READCONSOLE_CONTROL = *mut CONSOLE_READCONSOLE_CONTROL;\n+\n+    #[repr(C)]\n+    pub struct BY_HANDLE_FILE_INFORMATION {\n+        pub dwFileAttributes: DWORD,\n+        pub ftCreationTime: FILETIME,\n+        pub ftLastAccessTime: FILETIME,\n+        pub ftLastWriteTime: FILETIME,\n+        pub dwVolumeSerialNumber: DWORD,\n+        pub nFileSizeHigh: DWORD,\n+        pub nFileSizeLow: DWORD,\n+        pub nNumberOfLinks: DWORD,\n+        pub nFileIndexHigh: DWORD,\n+        pub nFileIndexLow: DWORD,\n+    }\n+\n+    pub type LPBY_HANDLE_FILE_INFORMATION = *mut BY_HANDLE_FILE_INFORMATION;\n+    pub type LPCVOID = *const c_void;\n+\n+    pub const HANDLE_FLAG_INHERIT: DWORD = 0x00000001;\n+\n+    pub const TOKEN_READ: DWORD = 0x20008;\n+\n+    extern \"system\" {\n+        #[link_name = \"SystemFunction036\"]\n+        pub fn RtlGenRandom(RandomBuffer: *mut u8, RandomBufferLength: ULONG) -> BOOLEAN;\n+\n+        pub fn ReadConsoleW(hConsoleInput: HANDLE,\n+                            lpBuffer: LPVOID,\n+                            nNumberOfCharsToRead: DWORD,\n+                            lpNumberOfCharsRead: LPDWORD,\n+                            pInputControl: PCONSOLE_READCONSOLE_CONTROL) -> BOOL;\n+\n+        pub fn WriteConsoleW(hConsoleOutput: HANDLE,\n+                             lpBuffer: LPCVOID,\n+                             nNumberOfCharsToWrite: DWORD,\n+                             lpNumberOfCharsWritten: LPDWORD,\n+                             lpReserved: LPVOID) -> BOOL;\n+\n+        pub fn GetConsoleMode(hConsoleHandle: HANDLE,\n+                              lpMode: LPDWORD) -> BOOL;\n+        // Allowed but unused by UWP\n+        pub fn OpenProcessToken(ProcessHandle: HANDLE,\n+                                DesiredAccess: DWORD,\n+                                TokenHandle: *mut HANDLE) -> BOOL;\n+        pub fn GetUserProfileDirectoryW(hToken: HANDLE,\n+                                        lpProfileDir: LPWSTR,\n+                                        lpcchSize: *mut DWORD) -> BOOL;\n+        pub fn GetFileInformationByHandle(hFile: HANDLE,\n+                            lpFileInformation: LPBY_HANDLE_FILE_INFORMATION)\n+                            -> BOOL;\n+        pub fn SetHandleInformation(hObject: HANDLE,\n+                                    dwMask: DWORD,\n+                                    dwFlags: DWORD) -> BOOL;\n+        pub fn AddVectoredExceptionHandler(FirstHandler: ULONG,\n+                                           VectoredHandler: PVECTORED_EXCEPTION_HANDLER)\n+                                           -> LPVOID;\n+        pub fn CreateHardLinkW(lpSymlinkFileName: LPCWSTR,\n+                               lpTargetFileName: LPCWSTR,\n+                               lpSecurityAttributes: LPSECURITY_ATTRIBUTES)\n+                               -> BOOL;\n+    }\n+}\n+}\n+\n+// UWP specific functions & types\n+cfg_if::cfg_if! {\n+if #[cfg(target_vendor = \"uwp\")] {\n+    pub const BCRYPT_USE_SYSTEM_PREFERRED_RNG: DWORD = 0x00000002;\n+\n+    #[repr(C)]\n+    pub struct FILE_STANDARD_INFO {\n+        pub AllocationSize: LARGE_INTEGER,\n+        pub EndOfFile: LARGE_INTEGER,\n+        pub NumberOfLink: DWORD,\n+        pub DeletePending: BOOLEAN,\n+        pub Directory: BOOLEAN,\n+    }\n+\n+    extern \"system\" {\n+        pub fn GetFileInformationByHandleEx(hFile: HANDLE,\n+                                            fileInfoClass: FILE_INFO_BY_HANDLE_CLASS,\n+                                            lpFileInformation: LPVOID,\n+                                            dwBufferSize: DWORD) -> BOOL;\n+        pub fn BCryptGenRandom(hAlgorithm: LPVOID, pBuffer: *mut u8,\n+                               cbBuffer: ULONG, dwFlags: ULONG) -> LONG;\n+    }\n+}\n+}\n+\n+// Shared between Desktop & UWP\n extern \"system\" {\n     pub fn WSAStartup(wVersionRequested: WORD,\n                       lpWSAData: LPWSADATA) -> c_int;\n@@ -694,34 +770,13 @@ extern \"system\" {\n     pub fn LeaveCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n     pub fn DeleteCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n \n-    pub fn ReadConsoleW(hConsoleInput: HANDLE,\n-                        lpBuffer: LPVOID,\n-                        nNumberOfCharsToRead: DWORD,\n-                        lpNumberOfCharsRead: LPDWORD,\n-                        pInputControl: PCONSOLE_READCONSOLE_CONTROL) -> BOOL;\n-\n-    pub fn WriteConsoleW(hConsoleOutput: HANDLE,\n-                         lpBuffer: LPCVOID,\n-                         nNumberOfCharsToWrite: DWORD,\n-                         lpNumberOfCharsWritten: LPDWORD,\n-                         lpReserved: LPVOID) -> BOOL;\n-\n-    pub fn GetConsoleMode(hConsoleHandle: HANDLE,\n-                          lpMode: LPDWORD) -> BOOL;\n     pub fn RemoveDirectoryW(lpPathName: LPCWSTR) -> BOOL;\n     pub fn SetFileAttributesW(lpFileName: LPCWSTR,\n                               dwFileAttributes: DWORD) -> BOOL;\n-    pub fn GetFileInformationByHandle(hFile: HANDLE,\n-                            lpFileInformation: LPBY_HANDLE_FILE_INFORMATION)\n-                            -> BOOL;\n-\n     pub fn SetLastError(dwErrCode: DWORD);\n     pub fn GetCommandLineW() -> *mut LPCWSTR;\n     pub fn GetTempPathW(nBufferLength: DWORD,\n                         lpBuffer: LPCWSTR) -> DWORD;\n-    pub fn OpenProcessToken(ProcessHandle: HANDLE,\n-                            DesiredAccess: DWORD,\n-                            TokenHandle: *mut HANDLE) -> BOOL;\n     pub fn GetCurrentProcess() -> HANDLE;\n     pub fn GetCurrentThread() -> HANDLE;\n     pub fn GetStdHandle(which: DWORD) -> HANDLE;\n@@ -746,21 +801,12 @@ extern \"system\" {\n     pub fn SwitchToThread() -> BOOL;\n     pub fn Sleep(dwMilliseconds: DWORD);\n     pub fn GetProcessId(handle: HANDLE) -> DWORD;\n-    pub fn GetUserProfileDirectoryW(hToken: HANDLE,\n-                                    lpProfileDir: LPWSTR,\n-                                    lpcchSize: *mut DWORD) -> BOOL;\n-    pub fn SetHandleInformation(hObject: HANDLE,\n-                                dwMask: DWORD,\n-                                dwFlags: DWORD) -> BOOL;\n     pub fn CopyFileExW(lpExistingFileName: LPCWSTR,\n                        lpNewFileName: LPCWSTR,\n                        lpProgressRoutine: LPPROGRESS_ROUTINE,\n                        lpData: LPVOID,\n                        pbCancel: LPBOOL,\n                        dwCopyFlags: DWORD) -> BOOL;\n-    pub fn AddVectoredExceptionHandler(FirstHandler: ULONG,\n-                                       VectoredHandler: PVECTORED_EXCEPTION_HANDLER)\n-                                       -> LPVOID;\n     pub fn FormatMessageW(flags: DWORD,\n                           lpSrc: LPVOID,\n                           msgId: DWORD,\n@@ -857,10 +903,6 @@ extern \"system\" {\n                      lpOverlapped: LPOVERLAPPED)\n                      -> BOOL;\n     pub fn CloseHandle(hObject: HANDLE) -> BOOL;\n-    pub fn CreateHardLinkW(lpSymlinkFileName: LPCWSTR,\n-                           lpTargetFileName: LPCWSTR,\n-                           lpSecurityAttributes: LPSECURITY_ATTRIBUTES)\n-                           -> BOOL;\n     pub fn MoveFileExW(lpExistingFileName: LPCWSTR,\n                        lpNewFileName: LPCWSTR,\n                        dwFlags: DWORD)\n@@ -950,8 +992,6 @@ extern \"system\" {\n                   exceptfds: *mut fd_set,\n                   timeout: *const timeval) -> c_int;\n \n-    #[link_name = \"SystemFunction036\"]\n-    pub fn RtlGenRandom(RandomBuffer: *mut u8, RandomBufferLength: ULONG) -> BOOLEAN;\n \n     pub fn GetProcessHeap() -> HANDLE;\n     pub fn HeapAlloc(hHeap: HANDLE, dwFlags: DWORD, dwBytes: SIZE_T) -> LPVOID;\n@@ -975,6 +1015,7 @@ compat_fn! {\n                                      _dwFlags: DWORD) -> DWORD {\n         SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0\n     }\n+    #[cfg(not(target_vendor = \"uwp\"))]\n     pub fn SetThreadStackGuarantee(_size: *mut c_ulong) -> BOOL {\n         SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0\n     }"}, {"sha": "544b2087f92e0fb88b13e0e33ee8271105a74f1c", "filename": "src/libstd/sys/windows/compat.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibstd%2Fsys%2Fwindows%2Fcompat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibstd%2Fsys%2Fwindows%2Fcompat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fcompat.rs?ref=4268e7ee22935f086b856ef0063a9e22b49aeddb", "patch": "@@ -37,12 +37,14 @@ pub fn store_func(ptr: &AtomicUsize, module: &str, symbol: &str,\n \n macro_rules! compat_fn {\n     ($module:ident: $(\n+        $(#[$meta:meta])*\n         pub fn $symbol:ident($($argname:ident: $argtype:ty),*)\n                                   -> $rettype:ty {\n             $($body:expr);*\n         }\n     )*) => ($(\n         #[allow(unused_variables)]\n+        $(#[$meta])*\n         pub unsafe fn $symbol($($argname: $argtype),*) -> $rettype {\n             use crate::sync::atomic::{AtomicUsize, Ordering};\n             use crate::mem;"}, {"sha": "2f158c014060bd32689622c977ed2e8f7c8be65b", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=4268e7ee22935f086b856ef0063a9e22b49aeddb", "patch": "@@ -287,6 +287,7 @@ impl File {\n         Ok(())\n     }\n \n+    #[cfg(not(target_vendor = \"uwp\"))]\n     pub fn file_attr(&self) -> io::Result<FileAttr> {\n         unsafe {\n             let mut info: c::BY_HANDLE_FILE_INFORMATION = mem::zeroed();\n@@ -310,6 +311,49 @@ impl File {\n         }\n     }\n \n+    #[cfg(target_vendor = \"uwp\")]\n+    pub fn file_attr(&self) -> io::Result<FileAttr> {\n+        unsafe {\n+            let mut info: c::FILE_BASIC_INFO = mem::zeroed();\n+            let size = mem::size_of_val(&info);\n+            cvt(c::GetFileInformationByHandleEx(self.handle.raw(),\n+                                              c::FileBasicInfo,\n+                                              &mut info as *mut _ as *mut libc::c_void,\n+                                              size as c::DWORD))?;\n+            let mut attr = FileAttr {\n+                attributes: info.FileAttributes,\n+                creation_time: c::FILETIME {\n+                    dwLowDateTime: info.CreationTime as c::DWORD,\n+                    dwHighDateTime: (info.CreationTime >> 32) as c::DWORD,\n+                },\n+                last_access_time: c::FILETIME {\n+                    dwLowDateTime: info.LastAccessTime as c::DWORD,\n+                    dwHighDateTime: (info.LastAccessTime >> 32) as c::DWORD,\n+                },\n+                last_write_time: c::FILETIME {\n+                    dwLowDateTime: info.LastWriteTime as c::DWORD,\n+                    dwHighDateTime: (info.LastWriteTime >> 32) as c::DWORD,\n+                },\n+                file_size: 0,\n+                reparse_tag: 0,\n+            };\n+            let mut info: c::FILE_STANDARD_INFO = mem::zeroed();\n+            let size = mem::size_of_val(&info);\n+            cvt(c::GetFileInformationByHandleEx(self.handle.raw(),\n+                                                c::FileStandardInfo,\n+                                                &mut info as *mut _ as *mut libc::c_void,\n+                                                size as c::DWORD))?;\n+            attr.file_size = info.AllocationSize as u64;\n+            if attr.is_reparse_point() {\n+                let mut b = [0; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n+                if let Ok((_, buf)) = self.reparse_point(&mut b) {\n+                    attr.reparse_tag = buf.ReparseTag;\n+                }\n+            }\n+            Ok(attr)\n+        }\n+    }\n+\n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n         self.handle.read(buf)\n     }\n@@ -670,6 +714,7 @@ pub fn symlink_inner(src: &Path, dst: &Path, dir: bool) -> io::Result<()> {\n     Ok(())\n }\n \n+#[cfg(not(target_vendor = \"uwp\"))]\n pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n     let src = to_u16s(src)?;\n     let dst = to_u16s(dst)?;\n@@ -679,6 +724,12 @@ pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n     Ok(())\n }\n \n+#[cfg(target_vendor = \"uwp\")]\n+pub fn link(_src: &Path, _dst: &Path) -> io::Result<()> {\n+    return Err(io::Error::new(io::ErrorKind::Other,\n+                            \"hard link are not supported on UWP\"));\n+}\n+\n pub fn stat(path: &Path) -> io::Result<FileAttr> {\n     let mut opts = OpenOptions::new();\n     // No read or write permissions are necessary"}, {"sha": "d59ac5959a6788d1eadfe1111fda07f7d3635720", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=4268e7ee22935f086b856ef0063a9e22b49aeddb", "patch": "@@ -33,11 +33,20 @@ pub mod pipe;\n pub mod process;\n pub mod rand;\n pub mod rwlock;\n-pub mod stack_overflow;\n pub mod thread;\n pub mod thread_local;\n pub mod time;\n-pub mod stdio;\n+cfg_if::cfg_if! {\n+    if #[cfg(not(target_vendor = \"uwp\"))] {\n+        pub mod stdio;\n+        pub mod stack_overflow;\n+    } else {\n+        pub mod stdio_uwp;\n+        pub mod stack_overflow_uwp;\n+        pub use self::stdio_uwp as stdio;\n+        pub use self::stack_overflow_uwp as stack_overflow;\n+    }\n+}\n \n #[cfg(not(test))]\n pub fn init() {"}, {"sha": "32f4011fb321942496cadac1c238b6ec8c1fd7e1", "filename": "src/libstd/sys/windows/net.rs", "status": "modified", "additions": 44, "deletions": 7, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs?ref=4268e7ee22935f086b856ef0063a9e22b49aeddb", "patch": "@@ -97,12 +97,26 @@ impl Socket {\n         };\n         let socket = unsafe {\n             match c::WSASocketW(fam, ty, 0, ptr::null_mut(), 0,\n-                                c::WSA_FLAG_OVERLAPPED) {\n-                c::INVALID_SOCKET => Err(last_error()),\n+                                c::WSA_FLAG_OVERLAPPED | c::WSA_FLAG_NO_HANDLE_INHERIT) {\n+                c::INVALID_SOCKET => {\n+                    match c::WSAGetLastError() {\n+                        c::WSAEPROTOTYPE => {\n+                            match c::WSASocketW(fam, ty, 0, ptr::null_mut(), 0,\n+                                                c::WSA_FLAG_OVERLAPPED) {\n+                                c::INVALID_SOCKET => Err(last_error()),\n+                                n => {\n+                                    let s = Socket(n);\n+                                    s.set_no_inherit()?;\n+                                    Ok(s)\n+                                },\n+                            }\n+                        },\n+                        n => Err(io::Error::from_raw_os_error(n)),\n+                    }\n+                },\n                 n => Ok(Socket(n)),\n             }\n         }?;\n-        socket.set_no_inherit()?;\n         Ok(socket)\n     }\n \n@@ -168,7 +182,6 @@ impl Socket {\n                 n => Ok(Socket(n)),\n             }\n         }?;\n-        socket.set_no_inherit()?;\n         Ok(socket)\n     }\n \n@@ -178,16 +191,34 @@ impl Socket {\n             cvt(c::WSADuplicateSocketW(self.0,\n                                             c::GetCurrentProcessId(),\n                                             &mut info))?;\n+\n             match c::WSASocketW(info.iAddressFamily,\n                                 info.iSocketType,\n                                 info.iProtocol,\n                                 &mut info, 0,\n-                                c::WSA_FLAG_OVERLAPPED) {\n-                c::INVALID_SOCKET => Err(last_error()),\n+                                c::WSA_FLAG_OVERLAPPED | c::WSA_FLAG_NO_HANDLE_INHERIT) {\n+                c::INVALID_SOCKET => {\n+                    match c::WSAGetLastError() {\n+                        c::WSAEPROTOTYPE => {\n+                            match c::WSASocketW(info.iAddressFamily,\n+                                                info.iSocketType,\n+                                                info.iProtocol,\n+                                                &mut info, 0,\n+                                                c::WSA_FLAG_OVERLAPPED) {\n+                                c::INVALID_SOCKET => Err(last_error()),\n+                                n => {\n+                                    let s = Socket(n);\n+                                    s.set_no_inherit()?;\n+                                    Ok(s)\n+                                },\n+                            }\n+                        },\n+                        n => Err(io::Error::from_raw_os_error(n)),\n+                    }\n+                },\n                 n => Ok(Socket(n)),\n             }\n         }?;\n-        socket.set_no_inherit()?;\n         Ok(socket)\n     }\n \n@@ -312,13 +343,19 @@ impl Socket {\n         }\n     }\n \n+    #[cfg(not(target_vendor = \"uwp\"))]\n     fn set_no_inherit(&self) -> io::Result<()> {\n         sys::cvt(unsafe {\n             c::SetHandleInformation(self.0 as c::HANDLE,\n                                     c::HANDLE_FLAG_INHERIT, 0)\n         }).map(|_| ())\n     }\n \n+    #[cfg(target_vendor = \"uwp\")]\n+    fn set_no_inherit(&self) -> io::Result<()> {\n+        Err(io::Error::new(io::ErrorKind::Other, \"Unavailable on UWP\"))\n+    }\n+\n     pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n         let how = match how {\n             Shutdown::Write => c::SD_SEND,"}, {"sha": "7c400dce686f374a439138834b91284ddc4ae035", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=4268e7ee22935f086b856ef0063a9e22b49aeddb", "patch": "@@ -13,7 +13,6 @@ use crate::path::{self, PathBuf};\n use crate::ptr;\n use crate::slice;\n use crate::sys::{c, cvt};\n-use crate::sys::handle::Handle;\n \n use super::to_u16s;\n \n@@ -284,10 +283,11 @@ pub fn temp_dir() -> PathBuf {\n     }, super::os2path).unwrap()\n }\n \n-pub fn home_dir() -> Option<PathBuf> {\n-    crate::env::var_os(\"HOME\").or_else(|| {\n-        crate::env::var_os(\"USERPROFILE\")\n-    }).map(PathBuf::from).or_else(|| unsafe {\n+#[cfg(not(target_vendor = \"uwp\"))]\n+fn home_dir_crt() -> Option<PathBuf> {\n+    unsafe {\n+        use crate::sys::handle::Handle;\n+\n         let me = c::GetCurrentProcess();\n         let mut token = ptr::null_mut();\n         if c::OpenProcessToken(me, c::TOKEN_READ, &mut token) == 0 {\n@@ -301,7 +301,18 @@ pub fn home_dir() -> Option<PathBuf> {\n                 _ => sz - 1, // sz includes the null terminator\n             }\n         }, super::os2path).ok()\n-    })\n+    }\n+}\n+\n+#[cfg(target_vendor = \"uwp\")]\n+fn home_dir_crt() -> Option<PathBuf> {\n+    None\n+}\n+\n+pub fn home_dir() -> Option<PathBuf> {\n+    crate::env::var_os(\"HOME\").or_else(|| {\n+        crate::env::var_os(\"USERPROFILE\")\n+    }).map(PathBuf::from).or_else(|| home_dir_crt())\n }\n \n pub fn exit(code: i32) -> ! {"}, {"sha": "041d5385eb69b024b12c2902afaf0e63f5fb41d3", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=4268e7ee22935f086b856ef0063a9e22b49aeddb", "patch": "@@ -45,7 +45,7 @@ pub struct Pipes {\n /// mode. This means that technically speaking it should only ever be used\n /// with `OVERLAPPED` instances, but also works out ok if it's only ever used\n /// once at a time (which we do indeed guarantee).\n-pub fn anon_pipe(ours_readable: bool) -> io::Result<Pipes> {\n+pub fn anon_pipe(ours_readable: bool, their_handle_inheritable: bool) -> io::Result<Pipes> {\n     // Note that we specifically do *not* use `CreatePipe` here because\n     // unfortunately the anonymous pipes returned do not support overlapped\n     // operations. Instead, we create a \"hopefully unique\" name and create a\n@@ -137,6 +137,13 @@ pub fn anon_pipe(ours_readable: bool) -> io::Result<Pipes> {\n         opts.write(ours_readable);\n         opts.read(!ours_readable);\n         opts.share_mode(0);\n+        let size = mem::size_of::<c::SECURITY_ATTRIBUTES>();\n+        let mut sa = c::SECURITY_ATTRIBUTES {\n+            nLength: size as c::DWORD,\n+            lpSecurityDescriptor: ptr::null_mut(),\n+            bInheritHandle: their_handle_inheritable as i32,\n+        };\n+        opts.security_attributes(&mut sa);\n         let theirs = File::open(Path::new(&name), &opts)?;\n         let theirs = AnonPipe { inner: theirs.into_handle() };\n "}, {"sha": "05e0ca670645334940a9a9ee06698a17203bd626", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=4268e7ee22935f086b856ef0063a9e22b49aeddb", "patch": "@@ -267,13 +267,8 @@ impl Stdio {\n \n             Stdio::MakePipe => {\n                 let ours_readable = stdio_id != c::STD_INPUT_HANDLE;\n-                let pipes = pipe::anon_pipe(ours_readable)?;\n+                let pipes = pipe::anon_pipe(ours_readable, true)?;\n                 *pipe = Some(pipes.ours);\n-                cvt(unsafe {\n-                    c::SetHandleInformation(pipes.theirs.handle().raw(),\n-                                            c::HANDLE_FLAG_INHERIT,\n-                                            c::HANDLE_FLAG_INHERIT)\n-                })?;\n                 Ok(pipes.theirs.into_handle())\n             }\n "}, {"sha": "c9bcb5d74151429162110aa5ac410d0270bcd46d", "filename": "src/libstd/sys/windows/rand.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibstd%2Fsys%2Fwindows%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibstd%2Fsys%2Fwindows%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Frand.rs?ref=4268e7ee22935f086b856ef0063a9e22b49aeddb", "patch": "@@ -2,6 +2,7 @@ use crate::io;\n use crate::mem;\n use crate::sys::c;\n \n+#[cfg(not(target_vendor = \"uwp\"))]\n pub fn hashmap_random_keys() -> (u64, u64) {\n     let mut v = (0, 0);\n     let ret = unsafe {\n@@ -14,3 +15,20 @@ pub fn hashmap_random_keys() -> (u64, u64) {\n     }\n     return v\n }\n+\n+#[cfg(target_vendor = \"uwp\")]\n+pub fn hashmap_random_keys() -> (u64, u64) {\n+    use crate::ptr;\n+\n+    let mut v = (0, 0);\n+    let ret = unsafe {\n+        c::BCryptGenRandom(ptr::null_mut(), &mut v as *mut _ as *mut u8,\n+                           mem::size_of_val(&v) as c::ULONG,\n+                           c::BCRYPT_USE_SYSTEM_PREFERRED_RNG)\n+    };\n+    if ret != 0 {\n+        panic!(\"couldn't generate random bytes: {}\",\n+               io::Error::last_os_error());\n+    }\n+    return v\n+}"}, {"sha": "e7236cf359cd50b7b8ac791bd651585ad8002124", "filename": "src/libstd/sys/windows/stack_overflow_uwp.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow_uwp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow_uwp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow_uwp.rs?ref=4268e7ee22935f086b856ef0063a9e22b49aeddb", "patch": "@@ -0,0 +1,13 @@\n+#![cfg_attr(test, allow(dead_code))]\n+\n+pub struct Handler;\n+\n+impl Handler {\n+    pub fn new() -> Handler {\n+        Handler\n+    }\n+}\n+\n+pub unsafe fn init() {}\n+\n+pub unsafe fn cleanup() {}"}, {"sha": "489d3df28600b72b8690c788d8569450d60da69a", "filename": "src/libstd/sys/windows/stdio_uwp.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibstd%2Fsys%2Fwindows%2Fstdio_uwp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibstd%2Fsys%2Fwindows%2Fstdio_uwp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstdio_uwp.rs?ref=4268e7ee22935f086b856ef0063a9e22b49aeddb", "patch": "@@ -0,0 +1,85 @@\n+#![unstable(issue = \"0\", feature = \"windows_stdio\")]\n+\n+use crate::io;\n+use crate::sys::c;\n+use crate::sys::handle::Handle;\n+use crate::mem::ManuallyDrop;\n+\n+pub struct Stdin {\n+}\n+pub struct Stdout;\n+pub struct Stderr;\n+\n+const MAX_BUFFER_SIZE: usize = 8192;\n+pub const STDIN_BUF_SIZE: usize = MAX_BUFFER_SIZE / 2 * 3;\n+\n+pub fn get_handle(handle_id: c::DWORD) -> io::Result<c::HANDLE> {\n+    let handle = unsafe { c::GetStdHandle(handle_id) };\n+    if handle == c::INVALID_HANDLE_VALUE {\n+        Err(io::Error::last_os_error())\n+    } else if handle.is_null() {\n+        Err(io::Error::from_raw_os_error(c::ERROR_INVALID_HANDLE as i32))\n+    } else {\n+        Ok(handle)\n+    }\n+}\n+\n+fn write(handle_id: c::DWORD, data: &[u8]) -> io::Result<usize> {\n+    let handle = get_handle(handle_id)?;\n+    let handle = Handle::new(handle);\n+    ManuallyDrop::new(handle).write(data)\n+}\n+\n+impl Stdin {\n+    pub fn new() -> io::Result<Stdin> {\n+        Ok(Stdin { })\n+    }\n+}\n+\n+impl io::Read for Stdin {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        let handle = get_handle(c::STD_INPUT_HANDLE)?;\n+        let handle = Handle::new(handle);\n+        ManuallyDrop::new(handle).read(buf)\n+    }\n+}\n+\n+impl Stdout {\n+    pub fn new() -> io::Result<Stdout> {\n+        Ok(Stdout)\n+    }\n+}\n+\n+impl io::Write for Stdout {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        write(c::STD_OUTPUT_HANDLE, buf)\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+impl Stderr {\n+    pub fn new() -> io::Result<Stderr> {\n+        Ok(Stderr)\n+    }\n+}\n+\n+impl io::Write for Stderr {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        write(c::STD_ERROR_HANDLE, buf)\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+pub fn is_ebadf(err: &io::Error) -> bool {\n+    err.raw_os_error() == Some(c::ERROR_INVALID_HANDLE as i32)\n+}\n+\n+pub fn panic_output() -> Option<impl io::Write> {\n+    Stderr::new().ok()\n+}"}, {"sha": "3545a691a151547af257b8613afad46bd042c80a", "filename": "src/libunwind/build.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibunwind%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Flibunwind%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Fbuild.rs?ref=4268e7ee22935f086b856ef0063a9e22b49aeddb", "patch": "@@ -30,9 +30,11 @@ fn main() {\n         println!(\"cargo:rustc-link-lib=gcc_s\");\n     } else if target.contains(\"dragonfly\") {\n         println!(\"cargo:rustc-link-lib=gcc_pic\");\n-    } else if target.contains(\"windows-gnu\") {\n+    } else if target.contains(\"pc-windows-gnu\") {\n         println!(\"cargo:rustc-link-lib=static-nobundle=gcc_eh\");\n         println!(\"cargo:rustc-link-lib=static-nobundle=pthread\");\n+    } else if target.contains(\"uwp-windows-gnu\") {\n+        println!(\"cargo:rustc-link-lib=unwind\");\n     } else if target.contains(\"fuchsia\") {\n         println!(\"cargo:rustc-link-lib=unwind\");\n     } else if target.contains(\"haiku\") {"}, {"sha": "ffd3e6da25633a65bdea0cb0ec2dbdff6c685709", "filename": "src/test/run-make-fulldeps/output-type-permutations/Makefile", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Ftest%2Frun-make-fulldeps%2Foutput-type-permutations%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/4268e7ee22935f086b856ef0063a9e22b49aeddb/src%2Ftest%2Frun-make-fulldeps%2Foutput-type-permutations%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Foutput-type-permutations%2FMakefile?ref=4268e7ee22935f086b856ef0063a9e22b49aeddb", "patch": "@@ -5,7 +5,7 @@ all:\n \t$(call REMOVE_RLIBS,bar)\n \t$(call REMOVE_DYLIBS,bar)\n \trm $(call STATICLIB,bar)\n-\trm -f $(TMPDIR)/bar.{dll.exp,dll.lib,pdb}\n+\trm -f $(TMPDIR)/{lib,}bar.{dll.exp,dll.lib,pdb,dll.a}\n \t# Check that $(TMPDIR) is empty.\n \t[ \"$$(ls -1 $(TMPDIR) | wc -l)\" -eq \"0\" ]\n \n@@ -78,8 +78,8 @@ all:\n \trm $(TMPDIR)/$(call BIN,foo)\n \t$(RUSTC) foo.rs --crate-type=dylib --emit=link=$(TMPDIR)/$(call BIN,foo)\n \trm $(TMPDIR)/$(call BIN,foo)\n-\trm -f $(TMPDIR)/foo.{dll.exp,dll.lib,pdb}\n-\t[ \"$$(ls -1 $(TMPDIR) | wc -l)\" -eq \"0\" ]\n+\trm -f $(TMPDIR)/{lib,}foo.{dll.exp,dll.lib,pdb,dll.a,exe.lib}\n+\t[ \"$$(ls -1 $(TMPDIR) | wc -l)\" -eq \"0\" ] || (ls -1 $(TMPDIR) && exit 1)\n \n \t$(RUSTC) foo.rs --crate-type=staticlib -o $(TMPDIR)/foo\n \trm $(TMPDIR)/foo"}]}