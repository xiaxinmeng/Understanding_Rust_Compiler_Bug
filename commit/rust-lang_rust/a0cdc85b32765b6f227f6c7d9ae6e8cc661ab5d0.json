{"sha": "a0cdc85b32765b6f227f6c7d9ae6e8cc661ab5d0", "node_id": "C_kwDOAAsO6NoAKGEwY2RjODViMzI3NjViNmYyMjdmNmM3ZDlhZTZlOGNjNjYxYWI1ZDA", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-11-04T21:17:39Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-11-04T21:17:39Z"}, "message": "Remove in_tail_expr from FnCtxt", "tree": {"sha": "5a5bb724bdceb74c6f96a2602397abc3cd9b0d56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a5bb724bdceb74c6f96a2602397abc3cd9b0d56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0cdc85b32765b6f227f6c7d9ae6e8cc661ab5d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0cdc85b32765b6f227f6c7d9ae6e8cc661ab5d0", "html_url": "https://github.com/rust-lang/rust/commit/a0cdc85b32765b6f227f6c7d9ae6e8cc661ab5d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0cdc85b32765b6f227f6c7d9ae6e8cc661ab5d0/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47c008e440e59d793c2883f7dd712481dc965045", "url": "https://api.github.com/repos/rust-lang/rust/commits/47c008e440e59d793c2883f7dd712481dc965045", "html_url": "https://github.com/rust-lang/rust/commit/47c008e440e59d793c2883f7dd712481dc965045"}], "stats": {"total": 130, "additions": 73, "deletions": 57}, "files": [{"sha": "2290ac948f0036881cd4e5388c26778e00182c25", "filename": "compiler/rustc_hir_typeck/src/_match.rs", "status": "modified", "additions": 73, "deletions": 50, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/a0cdc85b32765b6f227f6c7d9ae6e8cc661ab5d0/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0cdc85b32765b6f227f6c7d9ae6e8cc661ab5d0/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs?ref=a0cdc85b32765b6f227f6c7d9ae6e8cc661ab5d0", "patch": "@@ -1,6 +1,6 @@\n use crate::coercion::{AsCoercionSite, CoerceMany};\n use crate::{Diverges, Expectation, FnCtxt, Needs};\n-use rustc_errors::{Applicability, MultiSpan};\n+use rustc_errors::{Applicability, Diagnostic, MultiSpan};\n use rustc_hir::{self as hir, ExprKind};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::traits::Obligation;\n@@ -137,55 +137,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Some(&arm.body),\n                 arm_ty,\n                 Some(&mut |err| {\n-                    let Some(ret) = self\n-                        .tcx\n-                        .hir()\n-                        .find_by_def_id(self.body_id.owner.def_id)\n-                        .and_then(|owner| owner.fn_decl())\n-                        .map(|decl| decl.output.span())\n-                    else { return; };\n-                    let Expectation::IsLast(stmt) = orig_expected else {\n-                        return\n-                    };\n-                    let can_coerce_to_return_ty = match self.ret_coercion.as_ref() {\n-                        Some(ret_coercion) if self.in_tail_expr => {\n-                            let ret_ty = ret_coercion.borrow().expected_ty();\n-                            let ret_ty = self.inh.infcx.shallow_resolve(ret_ty);\n-                            self.can_coerce(arm_ty, ret_ty)\n-                                && prior_arm.map_or(true, |(_, t, _)| self.can_coerce(t, ret_ty))\n-                                // The match arms need to unify for the case of `impl Trait`.\n-                                && !matches!(ret_ty.kind(), ty::Opaque(..))\n-                        }\n-                        _ => false,\n-                    };\n-                    if !can_coerce_to_return_ty {\n-                        return;\n-                    }\n-\n-                    let semi_span = expr.span.shrink_to_hi().with_hi(stmt.hi());\n-                    let mut ret_span: MultiSpan = semi_span.into();\n-                    ret_span.push_span_label(\n-                        expr.span,\n-                        \"this could be implicitly returned but it is a statement, not a \\\n-                            tail expression\",\n-                    );\n-                    ret_span\n-                        .push_span_label(ret, \"the `match` arms can conform to this return type\");\n-                    ret_span.push_span_label(\n-                        semi_span,\n-                        \"the `match` is a statement because of this semicolon, consider \\\n-                            removing it\",\n-                    );\n-                    err.span_note(\n-                        ret_span,\n-                        \"you might have meant to return the `match` expression\",\n-                    );\n-                    err.tool_only_span_suggestion(\n-                        semi_span,\n-                        \"remove this semicolon\",\n-                        \"\",\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                    self.suggest_removing_semicolon_for_coerce(\n+                        err,\n+                        expr,\n+                        orig_expected,\n+                        arm_ty,\n+                        prior_arm,\n+                    )\n                 }),\n                 false,\n             );\n@@ -219,6 +177,71 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         coercion.complete(self)\n     }\n \n+    fn suggest_removing_semicolon_for_coerce(\n+        &self,\n+        diag: &mut Diagnostic,\n+        expr: &hir::Expr<'tcx>,\n+        expectation: Expectation<'tcx>,\n+        arm_ty: Ty<'tcx>,\n+        prior_arm: Option<(Option<hir::HirId>, Ty<'tcx>, Span)>,\n+    ) {\n+        let hir = self.tcx.hir();\n+\n+        // First, check that we're actually in the tail of a function.\n+        let hir::Node::Expr(hir::Expr { kind: hir::ExprKind::Block(block, _), .. }) =\n+            hir.get(self.body_id) else { return; };\n+        let Some(hir::Stmt { kind: hir::StmtKind::Semi(last_expr), .. })\n+            = block.innermost_block().stmts.last() else {  return; };\n+        if last_expr.hir_id != expr.hir_id {\n+            return;\n+        }\n+\n+        // Next, make sure that we have no type expectation.\n+        let Some(ret) = hir\n+            .find_by_def_id(self.body_id.owner.def_id)\n+            .and_then(|owner| owner.fn_decl())\n+            .map(|decl| decl.output.span()) else { return; };\n+        let Expectation::IsLast(stmt) = expectation else {\n+            return;\n+        };\n+\n+        let can_coerce_to_return_ty = match self.ret_coercion.as_ref() {\n+            Some(ret_coercion) => {\n+                let ret_ty = ret_coercion.borrow().expected_ty();\n+                let ret_ty = self.inh.infcx.shallow_resolve(ret_ty);\n+                self.can_coerce(arm_ty, ret_ty)\n+                    && prior_arm.map_or(true, |(_, ty, _)| self.can_coerce(ty, ret_ty))\n+                    // The match arms need to unify for the case of `impl Trait`.\n+                    && !matches!(ret_ty.kind(), ty::Opaque(..))\n+            }\n+            _ => false,\n+        };\n+        if !can_coerce_to_return_ty {\n+            return;\n+        }\n+\n+        let semi_span = expr.span.shrink_to_hi().with_hi(stmt.hi());\n+        let mut ret_span: MultiSpan = semi_span.into();\n+        ret_span.push_span_label(\n+            expr.span,\n+            \"this could be implicitly returned but it is a statement, not a \\\n+                            tail expression\",\n+        );\n+        ret_span.push_span_label(ret, \"the `match` arms can conform to this return type\");\n+        ret_span.push_span_label(\n+            semi_span,\n+            \"the `match` is a statement because of this semicolon, consider \\\n+                            removing it\",\n+        );\n+        diag.span_note(ret_span, \"you might have meant to return the `match` expression\");\n+        diag.tool_only_span_suggestion(\n+            semi_span,\n+            \"remove this semicolon\",\n+            \"\",\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+\n     /// When the previously checked expression (the scrutinee) diverges,\n     /// warn the user about the match arms being unreachable.\n     fn warn_arms_when_scrutinee_diverges(&self, arms: &'tcx [hir::Arm<'tcx>]) {"}, {"sha": "3b0b00f2aba5b1a2a425d8a9b8d34cce2cbf23f1", "filename": "compiler/rustc_hir_typeck/src/check.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0cdc85b32765b6f227f6c7d9ae6e8cc661ab5d0/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0cdc85b32765b6f227f6c7d9ae6e8cc661ab5d0/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs?ref=a0cdc85b32765b6f227f6c7d9ae6e8cc661ab5d0", "patch": "@@ -142,7 +142,6 @@ pub(super) fn check_fn<'a, 'tcx>(\n \n     inherited.typeck_results.borrow_mut().liberated_fn_sigs_mut().insert(fn_id, fn_sig);\n \n-    fcx.in_tail_expr = true;\n     if let ty::Dynamic(..) = declared_ret_ty.kind() {\n         // FIXME: We need to verify that the return type is `Sized` after the return expression has\n         // been evaluated so that we have types available for all the nodes being returned, but that\n@@ -161,7 +160,6 @@ pub(super) fn check_fn<'a, 'tcx>(\n         fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n         fcx.check_return_expr(&body.value, false);\n     }\n-    fcx.in_tail_expr = false;\n \n     // We insert the deferred_generator_interiors entry after visiting the body.\n     // This ensures that all nested generators appear before the entry of this generator."}, {"sha": "02b3e06d9024dd7ebfcc53eef0f9ae5c8bbe0d4f", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a0cdc85b32765b6f227f6c7d9ae6e8cc661ab5d0/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0cdc85b32765b6f227f6c7d9ae6e8cc661ab5d0/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=a0cdc85b32765b6f227f6c7d9ae6e8cc661ab5d0", "patch": "@@ -68,10 +68,6 @@ pub struct FnCtxt<'a, 'tcx> {\n     /// any).\n     pub(super) ret_coercion: Option<RefCell<DynamicCoerceMany<'tcx>>>,\n \n-    /// Used exclusively to reduce cost of advanced evaluation used for\n-    /// more helpful diagnostics.\n-    pub(super) in_tail_expr: bool,\n-\n     /// First span of a return site that we find. Used in error messages.\n     pub(super) ret_coercion_span: Cell<Option<Span>>,\n \n@@ -140,7 +136,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             param_env,\n             err_count_on_creation: inh.tcx.sess.err_count(),\n             ret_coercion: None,\n-            in_tail_expr: false,\n             ret_coercion_span: Cell::new(None),\n             resume_yield_tys: None,\n             ps: Cell::new(UnsafetyState::function(hir::Unsafety::Normal, hir::CRATE_HIR_ID)),"}]}