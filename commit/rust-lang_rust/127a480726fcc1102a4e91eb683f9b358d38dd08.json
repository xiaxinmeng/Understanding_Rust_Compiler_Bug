{"sha": "127a480726fcc1102a4e91eb683f9b358d38dd08", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyN2E0ODA3MjZmY2MxMTAyYTRlOTFlYjY4M2Y5YjM1OGQzOGRkMDg=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2018-08-21T08:26:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-08-21T08:26:25Z"}, "message": "Merge pull request #2915 from Xanewok/file-lines-ser-json\n\nExpose FileLines JSON representation", "tree": {"sha": "25a7fbf47b347229fb0ac4e7c09f35e3c814ee10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25a7fbf47b347229fb0ac4e7c09f35e3c814ee10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/127a480726fcc1102a4e91eb683f9b358d38dd08", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbe8yxCRBK7hj4Ov3rIwAAdHIIAFUccW3LOowp3Wp5OvtySHBs\nTgbo/dGWlDWwWSgDtpi1NuALYReubJNmDB8pBm8NcsvLKWfaq/7JwYhMbO21mS7c\n2z2zgMKfGk2AOMyS51HIxAsXzhRJCXnzQGwR3Gf9nUB7QPl1idMhlOtbv0u/LMXJ\nR5XfJn+nFMi8LVnqbYwcX1Q8Ag95SZ+p/PrvsmbwXy03CKsMVCM5aitkXhTdqkn9\nwnMHyZ2HlbLOcrW1H5j+r9oXPSNEd5wEBqCqnCYXCQC120DhXHJLKqnxJ/vNfYIk\nGrhXA+4ZOMQVPjcgjckniqncgpF+vhE9ZgxFS7E/Pdsfxh9atMV89y+8p1RtsMQ=\n=I4+f\n-----END PGP SIGNATURE-----\n", "payload": "tree 25a7fbf47b347229fb0ac4e7c09f35e3c814ee10\nparent a275a059e74a07dd9f278f0413451f8845635b58\nparent 9d52940dbeb2a099675f2d66c2a8cc173ea00059\nauthor Nick Cameron <nrc@ncameron.org> 1534839985 +1200\ncommitter GitHub <noreply@github.com> 1534839985 +1200\n\nMerge pull request #2915 from Xanewok/file-lines-ser-json\n\nExpose FileLines JSON representation"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/127a480726fcc1102a4e91eb683f9b358d38dd08", "html_url": "https://github.com/rust-lang/rust/commit/127a480726fcc1102a4e91eb683f9b358d38dd08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/127a480726fcc1102a4e91eb683f9b358d38dd08/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a275a059e74a07dd9f278f0413451f8845635b58", "url": "https://api.github.com/repos/rust-lang/rust/commits/a275a059e74a07dd9f278f0413451f8845635b58", "html_url": "https://github.com/rust-lang/rust/commit/a275a059e74a07dd9f278f0413451f8845635b58"}, {"sha": "9d52940dbeb2a099675f2d66c2a8cc173ea00059", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d52940dbeb2a099675f2d66c2a8cc173ea00059", "html_url": "https://github.com/rust-lang/rust/commit/9d52940dbeb2a099675f2d66c2a8cc173ea00059"}], "stats": {"total": 93, "additions": 81, "deletions": 12}, "files": [{"sha": "58f65b3c1b6ea07c6a22b1a8f155381e4154dcd5", "filename": "src/config/file_lines.rs", "status": "modified", "additions": 81, "deletions": 12, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/127a480726fcc1102a4e91eb683f9b358d38dd08/src%2Fconfig%2Ffile_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/127a480726fcc1102a4e91eb683f9b358d38dd08/src%2Fconfig%2Ffile_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Ffile_lines.rs?ref=127a480726fcc1102a4e91eb683f9b358d38dd08", "patch": "@@ -16,6 +16,7 @@ use std::rc::Rc;\n use std::{cmp, fmt, iter, str};\n \n use serde::de::{Deserialize, Deserializer};\n+use serde::ser::{self, Serialize, Serializer};\n use serde_json as json;\n \n use syntax::codemap::{self, FileMap};\n@@ -53,6 +54,36 @@ impl fmt::Display for FileName {\n     }\n }\n \n+impl<'de> Deserialize<'de> for FileName {\n+    fn deserialize<D>(deserializer: D) -> Result<FileName, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        let s = String::deserialize(deserializer)?;\n+        if s == \"stdin\" {\n+            Ok(FileName::Stdin)\n+        } else {\n+            Ok(FileName::Real(s.into()))\n+        }\n+    }\n+}\n+\n+impl Serialize for FileName {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        let s = match self {\n+            FileName::Stdin => Ok(\"stdin\"),\n+            FileName::Real(path) => path\n+                .to_str()\n+                .ok_or_else(|| ser::Error::custom(\"path can't be serialized as UTF-8 string\")),\n+        };\n+\n+        s.and_then(|s| serializer.serialize_str(s))\n+    }\n+}\n+\n impl LineRange {\n     pub fn file_name(&self) -> FileName {\n         self.file.name.clone().into()\n@@ -175,6 +206,20 @@ impl FileLines {\n         Files(self.0.as_ref().map(|m| m.keys()))\n     }\n \n+    /// Returns JSON representation as accepted by the `--file-lines JSON` arg.\n+    pub fn to_json_spans(&self) -> Vec<JsonSpan> {\n+        match &self.0 {\n+            None => vec![],\n+            Some(file_ranges) => file_ranges\n+                .iter()\n+                .flat_map(|(file, ranges)| ranges.iter().map(move |r| (file, r)))\n+                .map(|(file, range)| JsonSpan {\n+                    file: file.to_owned(),\n+                    range: (range.lo, range.hi),\n+                }).collect(),\n+        }\n+    }\n+\n     /// Returns true if `self` includes all lines in all files. Otherwise runs `f` on all ranges in\n     /// the designated file (if any) and returns true if `f` ever does.\n     fn file_range_matches<F>(&self, file_name: &FileName, f: F) -> bool\n@@ -249,22 +294,12 @@ impl str::FromStr for FileLines {\n }\n \n // For JSON decoding.\n-#[derive(Clone, Debug, Deserialize)]\n-struct JsonSpan {\n-    #[serde(deserialize_with = \"deserialize_filename\")]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Deserialize, Serialize)]\n+pub struct JsonSpan {\n     file: FileName,\n     range: (usize, usize),\n }\n \n-fn deserialize_filename<'de, D: Deserializer<'de>>(d: D) -> Result<FileName, D::Error> {\n-    let s = String::deserialize(d)?;\n-    if s == \"stdin\" {\n-        Ok(FileName::Stdin)\n-    } else {\n-        Ok(FileName::Real(s.into()))\n-    }\n-}\n-\n impl JsonSpan {\n     fn into_tuple(self) -> Result<(FileName, Range), String> {\n         let (lo, hi) = self.range;\n@@ -350,4 +385,38 @@ mod test {\n             Range::new(3, 7).merge(Range::new(4, 5))\n         );\n     }\n+\n+    use super::json::{self, json, json_internal};\n+    use super::{FileLines, FileName};\n+    use std::{collections::HashMap, path::PathBuf};\n+\n+    #[test]\n+    fn file_lines_to_json() {\n+        let ranges: HashMap<FileName, Vec<Range>> = [\n+            (\n+                FileName::Real(PathBuf::from(\"src/main.rs\")),\n+                vec![Range::new(1, 3), Range::new(5, 7)],\n+            ),\n+            (\n+                FileName::Real(PathBuf::from(\"src/lib.rs\")),\n+                vec![Range::new(1, 7)],\n+            ),\n+        ]\n+            .iter()\n+            .cloned()\n+            .collect();\n+\n+        let file_lines = FileLines::from_ranges(ranges);\n+        let mut spans = file_lines.to_json_spans();\n+        spans.sort();\n+        let json = json::to_value(&spans).unwrap();\n+        assert_eq!(\n+            json,\n+            json! {[\n+                {\"file\": \"src/lib.rs\",  \"range\": [1, 7]},\n+                {\"file\": \"src/main.rs\", \"range\": [1, 3]},\n+                {\"file\": \"src/main.rs\", \"range\": [5, 7]},\n+            ]}\n+        );\n+    }\n }"}]}