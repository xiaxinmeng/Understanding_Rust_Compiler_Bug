{"sha": "03ca15e62d3a3386b824139a36597b4841e7d328", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzY2ExNWU2MmQzYTMzODZiODI0MTM5YTM2NTk3YjQ4NDFlN2QzMjg=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-07-24T09:31:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-07-24T09:31:25Z"}, "message": "Merge pull request #267 from RalfJung/cast\n\nFix ptr-int-casts", "tree": {"sha": "26d71a7362d957f19416c3961f1b4e59fe69ca19", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26d71a7362d957f19416c3961f1b4e59fe69ca19"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03ca15e62d3a3386b824139a36597b4841e7d328", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03ca15e62d3a3386b824139a36597b4841e7d328", "html_url": "https://github.com/rust-lang/rust/commit/03ca15e62d3a3386b824139a36597b4841e7d328", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03ca15e62d3a3386b824139a36597b4841e7d328/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e10752fef8a72090a4625b73dee926da2c95330", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e10752fef8a72090a4625b73dee926da2c95330", "html_url": "https://github.com/rust-lang/rust/commit/6e10752fef8a72090a4625b73dee926da2c95330"}, {"sha": "4a34a1b50e9a554ef6cca390d1c5f666f0f86e2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a34a1b50e9a554ef6cca390d1c5f666f0f86e2d", "html_url": "https://github.com/rust-lang/rust/commit/4a34a1b50e9a554ef6cca390d1c5f666f0f86e2d"}], "stats": {"total": 313, "additions": 184, "deletions": 129}, "files": [{"sha": "84de97488c51fc1beca11fe7878032b8280076ed", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/03ca15e62d3a3386b824139a36597b4841e7d328/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ca15e62d3a3386b824139a36597b4841e7d328/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=03ca15e62d3a3386b824139a36597b4841e7d328", "patch": "@@ -4,6 +4,7 @@ use syntax::ast::{FloatTy, IntTy, UintTy};\n use error::{EvalResult, EvalError};\n use eval_context::EvalContext;\n use value::PrimVal;\n+use memory::{MemoryPointer, PointerArithmetic};\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(super) fn cast_primval(\n@@ -12,38 +13,34 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         src_ty: Ty<'tcx>,\n         dest_ty: Ty<'tcx>\n     ) -> EvalResult<'tcx, PrimVal> {\n-        let kind = self.ty_to_primval_kind(src_ty)?;\n-\n-        use value::PrimValKind::*;\n-        match kind {\n-            F32 => self.cast_float(val.to_f32()? as f64, dest_ty),\n-            F64 => self.cast_float(val.to_f64()?, dest_ty),\n-\n-            I8 | I16 | I32 | I64 | I128 => {\n-                if val.is_ptr() {\n-                    self.cast_ptr(val, dest_ty)\n-                } else {\n-                    self.cast_signed_int(val.to_i128()?, dest_ty)\n+        let src_kind = self.ty_to_primval_kind(src_ty)?;\n+\n+        match val {\n+            PrimVal::Undef => Ok(PrimVal::Undef),\n+            PrimVal::Ptr(ptr) => self.cast_from_ptr(ptr, dest_ty),\n+            val @ PrimVal::Bytes(_) => {\n+                use value::PrimValKind::*;\n+                match src_kind {\n+                    F32 => self.cast_from_float(val.to_f32()? as f64, dest_ty),\n+                    F64 => self.cast_from_float(val.to_f64()?, dest_ty),\n+\n+                    I8 | I16 | I32 | I64 | I128 => {\n+                        self.cast_from_signed_int(val.to_i128()?, dest_ty)\n+                    },\n+\n+                    Bool | Char | U8 | U16 | U32 | U64 | U128 | FnPtr | Ptr => {\n+                        self.cast_from_int(val.to_u128()?, dest_ty, false)\n+                    },\n                 }\n-            },\n-\n-            Bool | Char | U8 | U16 | U32 | U64 | U128 => {\n-                if val.is_ptr() {\n-                    self.cast_ptr(val, dest_ty)\n-                } else {\n-                    self.cast_int(val.to_u128()?, dest_ty, false)\n-                }\n-            },\n-\n-            FnPtr | Ptr => self.cast_ptr(val, dest_ty),\n+            }\n         }\n     }\n \n-    fn cast_signed_int(&self, val: i128, ty: ty::Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n-        self.cast_int(val as u128, ty, val < 0)\n+    fn cast_from_signed_int(&self, val: i128, ty: ty::Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n+        self.cast_from_int(val as u128, ty, val < 0)\n     }\n \n-    fn cast_int(&self, v: u128, ty: ty::Ty<'tcx>, negative: bool) -> EvalResult<'tcx, PrimVal> {\n+    fn cast_from_int(&self, v: u128, ty: ty::Ty<'tcx>, negative: bool) -> EvalResult<'tcx, PrimVal> {\n         use rustc::ty::TypeVariants::*;\n         match ty.sty {\n             // Casts to bool are not permitted by rustc, no need to handle them here.\n@@ -63,13 +60,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             TyInt(IntTy::Is) => {\n                 let int_ty = self.tcx.sess.target.int_type;\n                 let ty = self.tcx.mk_mach_int(int_ty);\n-                self.cast_int(v, ty, negative)\n+                self.cast_from_int(v, ty, negative)\n             }\n \n             TyUint(UintTy::Us) => {\n                 let uint_ty = self.tcx.sess.target.uint_type;\n                 let ty = self.tcx.mk_mach_uint(uint_ty);\n-                self.cast_int(v, ty, negative)\n+                self.cast_from_int(v, ty, negative)\n             }\n \n             TyFloat(FloatTy::F64) if negative => Ok(PrimVal::from_f64(v as i128 as f64)),\n@@ -80,34 +77,34 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             TyChar if v as u8 as u128 == v => Ok(PrimVal::Bytes(v)),\n             TyChar => Err(EvalError::InvalidChar(v)),\n \n-            // No alignment check needed for raw pointers\n-            TyRawPtr(_) => Ok(PrimVal::Bytes(v % (1 << self.memory.pointer_size()))),\n+            // No alignment check needed for raw pointers.  But we have to truncate to target ptr size.\n+            TyRawPtr(_) => Ok(PrimVal::Bytes(self.memory.truncate_to_ptr(v).0 as u128)),\n \n             _ => Err(EvalError::Unimplemented(format!(\"int to {:?} cast\", ty))),\n         }\n     }\n \n-    fn cast_float(&self, val: f64, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n+    fn cast_from_float(&self, val: f64, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n         use rustc::ty::TypeVariants::*;\n         match ty.sty {\n             // Casting negative floats to unsigned integers yields zero.\n-            TyUint(_) if val < 0.0 => self.cast_int(0, ty, false),\n-            TyInt(_)  if val < 0.0 => self.cast_int(val as i128 as u128, ty, true),\n+            TyUint(_) if val < 0.0 => self.cast_from_int(0, ty, false),\n+            TyInt(_)  if val < 0.0 => self.cast_from_int(val as i128 as u128, ty, true),\n \n-            TyInt(_) | ty::TyUint(_) => self.cast_int(val as u128, ty, false),\n+            TyInt(_) | ty::TyUint(_) => self.cast_from_int(val as u128, ty, false),\n \n             TyFloat(FloatTy::F64) => Ok(PrimVal::from_f64(val)),\n             TyFloat(FloatTy::F32) => Ok(PrimVal::from_f32(val as f32)),\n             _ => Err(EvalError::Unimplemented(format!(\"float to {:?} cast\", ty))),\n         }\n     }\n \n-    fn cast_ptr(&self, ptr: PrimVal, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n+    fn cast_from_ptr(&self, ptr: MemoryPointer, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n         use rustc::ty::TypeVariants::*;\n         match ty.sty {\n             // Casting to a reference or fn pointer is not permitted by rustc, no need to support it here.\n             TyRawPtr(_) | TyInt(IntTy::Is) | TyUint(UintTy::Us) =>\n-                Ok(ptr),\n+                Ok(PrimVal::Ptr(ptr)),\n             TyInt(_) | TyUint(_) => Err(EvalError::ReadPointerAsBytes),\n             _ => Err(EvalError::Unimplemented(format!(\"ptr to {:?} cast\", ty))),\n         }"}, {"sha": "542cd5ae819bc3a83c2a8e4e29778a403df43f0d", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/03ca15e62d3a3386b824139a36597b4841e7d328/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ca15e62d3a3386b824139a36597b4841e7d328/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=03ca15e62d3a3386b824139a36597b4841e7d328", "patch": "@@ -439,7 +439,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         // FIXME(solson)\n         let dest_ptr = self.force_allocation(dest)?.to_ptr()?;\n \n-        let discr_dest = dest_ptr.offset(discr_offset, self.memory.layout)?;\n+        let discr_dest = dest_ptr.offset(discr_offset, &self)?;\n         self.memory.write_uint(discr_dest, discr_val, discr_size)?;\n \n         let dest = Lvalue::Ptr {\n@@ -585,7 +585,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                 // FIXME(solson)\n                                 let dest = self.force_allocation(dest)?.to_ptr()?;\n \n-                                let dest = dest.offset(offset.bytes(), self.memory.layout)?;\n+                                let dest = dest.offset(offset.bytes(), &self)?;\n                                 let dest_size = self.type_size(ty)?\n                                     .expect(\"bad StructWrappedNullablePointer discrfield\");\n                                 self.memory.write_int(dest, 0, dest_size)?;\n@@ -645,7 +645,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let dest = Pointer::from(self.force_allocation(dest)?.to_ptr()?);\n \n                 for i in 0..length {\n-                    let elem_dest = dest.offset(i * elem_size, self.memory.layout)?;\n+                    let elem_dest = dest.offset(i * elem_size, &self)?;\n                     self.write_value_to_ptr(value, elem_dest, elem_ty)?;\n                 }\n             }\n@@ -911,7 +911,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         // FIXME: assuming here that type size is < i64::max_value()\n         let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n         let offset = offset.overflowing_mul(pointee_size).0;\n-        ptr.wrapping_signed_offset(offset, self.memory.layout)\n+        ptr.wrapping_signed_offset(offset, self)\n     }\n \n     pub(super) fn pointer_offset(&self, ptr: Pointer, pointee_ty: Ty<'tcx>, offset: i64) -> EvalResult<'tcx, Pointer> {\n@@ -926,7 +926,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         // FIXME: assuming here that type size is < i64::max_value()\n         let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n         return if let Some(offset) = offset.checked_mul(pointee_size) {\n-            let ptr = ptr.signed_offset(offset, self.memory.layout)?;\n+            let ptr = ptr.signed_offset(offset, self)?;\n             // Do not do bounds-checking for integers; they can never alias a normal pointer anyway.\n             if let PrimVal::Ptr(ptr) = ptr.into_inner_primval() {\n                 self.memory.check_bounds(ptr, false)?;\n@@ -1217,8 +1217,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let field_1_ty = self.get_field_ty(ty, 1)?;\n         let field_0_size = self.type_size(field_0_ty)?.expect(\"pair element type must be sized\");\n         let field_1_size = self.type_size(field_1_ty)?.expect(\"pair element type must be sized\");\n-        self.memory.write_primval(ptr.offset(field_0, self.memory.layout)?.into(), a, field_0_size)?;\n-        self.memory.write_primval(ptr.offset(field_1, self.memory.layout)?.into(), b, field_1_size)?;\n+        let field_0_ptr = ptr.offset(field_0, &self)?.into();\n+        let field_1_ptr = ptr.offset(field_1, &self)?.into();\n+        self.memory.write_primval(field_0_ptr, a, field_0_size)?;\n+        self.memory.write_primval(field_1_ptr, b, field_1_size)?;\n         Ok(())\n     }\n \n@@ -1335,7 +1337,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Ok(p.to_value())\n         } else {\n             trace!(\"reading fat pointer extra of type {}\", pointee_ty);\n-            let extra = ptr.offset(self.memory.pointer_size(), self.memory.layout)?;\n+            let extra = ptr.offset(self.memory.pointer_size(), self)?;\n             match self.tcx.struct_tail(pointee_ty).sty {\n                 ty::TyDynamic(..) => Ok(p.to_value_with_vtable(self.memory.read_ptr(extra)?.to_ptr()?)),\n                 ty::TySlice(..) |\n@@ -1530,8 +1532,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n                     let src_field_offset = self.get_field_offset(src_ty, i)?.bytes();\n                     let dst_field_offset = self.get_field_offset(dest_ty, i)?.bytes();\n-                    let src_f_ptr = src_ptr.offset(src_field_offset, self.memory.layout)?;\n-                    let dst_f_ptr = dest.offset(dst_field_offset, self.memory.layout)?;\n+                    let src_f_ptr = src_ptr.offset(src_field_offset, &self)?;\n+                    let dst_f_ptr = dest.offset(dst_field_offset, &self)?;\n                     if src_fty == dst_fty {\n                         self.copy(src_f_ptr, dst_f_ptr.into(), src_fty)?;\n                     } else {"}, {"sha": "56e8c7f2b18ca6de467d2366a2a0fcd0e643022e", "filename": "src/librustc_mir/interpret/lvalue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/03ca15e62d3a3386b824139a36597b4841e7d328/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ca15e62d3a3386b824139a36597b4841e7d328/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs?ref=03ca15e62d3a3386b824139a36597b4841e7d328", "patch": "@@ -329,7 +329,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             _ => offset.bytes(),\n         };\n \n-        let ptr = base_ptr.offset(offset, self.memory.layout)?;\n+        let ptr = base_ptr.offset(offset, &self)?;\n \n         let field_ty = self.monomorphize(field_ty, self.substs());\n \n@@ -412,7 +412,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let usize = self.tcx.types.usize;\n                 let n = self.value_to_primval(n_ptr, usize)?.to_u64()?;\n                 assert!(n < len, \"Tried to access element {} of array/slice with length {}\", n, len);\n-                let ptr = base_ptr.offset(n * elem_size, self.memory.layout)?;\n+                let ptr = base_ptr.offset(n * elem_size, &self)?;\n                 (ptr, LvalueExtra::None, aligned)\n             }\n \n@@ -431,7 +431,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     u64::from(offset)\n                 };\n \n-                let ptr = base_ptr.offset(index * elem_size, self.memory.layout)?;\n+                let ptr = base_ptr.offset(index * elem_size, &self)?;\n                 (ptr, LvalueExtra::None, aligned)\n             }\n \n@@ -443,7 +443,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n                 let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n                 assert!(u64::from(from) <= n - u64::from(to));\n-                let ptr = base_ptr.offset(u64::from(from) * elem_size, self.memory.layout)?;\n+                let ptr = base_ptr.offset(u64::from(from) * elem_size, &self)?;\n                 let extra = LvalueExtra::Length(n - u64::from(to) - u64::from(from));\n                 (ptr, extra, aligned)\n             }"}, {"sha": "815d1e2e841c2ef1c2e27fdc209a8838393f94c8", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 102, "deletions": 14, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/03ca15e62d3a3386b824139a36597b4841e7d328/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ca15e62d3a3386b824139a36597b4841e7d328/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=03ca15e62d3a3386b824139a36597b4841e7d328", "patch": "@@ -3,11 +3,11 @@ use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque};\n use std::{fmt, iter, ptr, mem, io};\n \n use rustc::ty;\n-use rustc::ty::layout::{self, TargetDataLayout};\n+use rustc::ty::layout::{self, TargetDataLayout, HasDataLayout};\n use syntax::ast::Mutability;\n \n use error::{EvalError, EvalResult};\n-use value::{PrimVal, self, Pointer};\n+use value::{PrimVal, Pointer};\n use eval_context::EvalContext;\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -68,31 +68,31 @@ pub struct MemoryPointer {\n     pub offset: u64,\n }\n \n-impl MemoryPointer {\n+impl<'tcx> MemoryPointer {\n     pub fn new(alloc_id: AllocId, offset: u64) -> Self {\n         MemoryPointer { alloc_id, offset }\n     }\n \n-    pub fn wrapping_signed_offset<'tcx>(self, i: i64, layout: &TargetDataLayout) -> Self {\n-        MemoryPointer::new(self.alloc_id, value::wrapping_signed_offset(self.offset, i, layout))\n+    pub(crate) fn wrapping_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> Self {\n+        MemoryPointer::new(self.alloc_id, cx.data_layout().wrapping_signed_offset(self.offset, i))\n     }\n \n-    pub fn overflowing_signed_offset<'tcx>(self, i: i128, layout: &TargetDataLayout) -> (Self, bool) {\n-        let (res, over) = value::overflowing_signed_offset(self.offset, i, layout);\n+    pub(crate) fn overflowing_signed_offset<C: HasDataLayout>(self, i: i128, cx: C) -> (Self, bool) {\n+        let (res, over) = cx.data_layout().overflowing_signed_offset(self.offset, i);\n         (MemoryPointer::new(self.alloc_id, res), over)\n     }\n \n-    pub fn signed_offset<'tcx>(self, i: i64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n-        Ok(MemoryPointer::new(self.alloc_id, value::signed_offset(self.offset, i, layout)?))\n+    pub(crate) fn signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n+        Ok(MemoryPointer::new(self.alloc_id, cx.data_layout().signed_offset(self.offset, i)?))\n     }\n \n-    pub fn overflowing_offset<'tcx>(self, i: u64, layout: &TargetDataLayout) -> (Self, bool) {\n-        let (res, over) = value::overflowing_offset(self.offset, i, layout);\n+    pub(crate) fn overflowing_offset<C: HasDataLayout>(self, i: u64, cx: C) -> (Self, bool) {\n+        let (res, over) = cx.data_layout().overflowing_offset(self.offset, i);\n         (MemoryPointer::new(self.alloc_id, res), over)\n     }\n \n-    pub fn offset<'tcx>(self, i: u64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n-        Ok(MemoryPointer::new(self.alloc_id, value::offset(self.offset, i, layout)?))\n+    pub(crate) fn offset<C: HasDataLayout>(self, i: u64, cx: C) -> EvalResult<'tcx, Self> {\n+        Ok(MemoryPointer::new(self.alloc_id, cx.data_layout().offset(self.offset, i)?))\n     }\n }\n \n@@ -540,7 +540,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         if size == 0 {\n             return Ok(&[]);\n         }\n-        self.check_bounds(ptr.offset(size, self.layout)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n+        self.check_bounds(ptr.offset(size, self)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         let alloc = self.get(ptr.alloc_id)?;\n         assert_eq!(ptr.offset as usize as u64, ptr.offset);\n         assert_eq!(size as usize as u64, size);\n@@ -1131,6 +1131,7 @@ fn bit_index(bits: u64) -> (usize, usize) {\n \n pub(crate) trait HasMemory<'a, 'tcx> {\n     fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx>;\n+    fn memory(&self) -> &Memory<'a, 'tcx>;\n \n     // These are not supposed to be overriden.\n     fn read_maybe_aligned<F, T>(&mut self, aligned: bool, f: F) -> EvalResult<'tcx, T>\n@@ -1159,11 +1160,98 @@ impl<'a, 'tcx> HasMemory<'a, 'tcx> for Memory<'a, 'tcx> {\n     fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx> {\n         self\n     }\n+\n+    #[inline]\n+    fn memory(&self) -> &Memory<'a, 'tcx> {\n+        self\n+    }\n }\n \n impl<'a, 'tcx> HasMemory<'a, 'tcx> for EvalContext<'a, 'tcx> {\n     #[inline]\n     fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx> {\n         &mut self.memory\n     }\n+\n+    #[inline]\n+    fn memory(&self) -> &Memory<'a, 'tcx> {\n+        &self.memory\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Pointer arithmetic\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub trait PointerArithmetic : layout::HasDataLayout {\n+    // These are not supposed to be overriden.\n+\n+    //// Trunace the given value to the pointer size; also return whether there was an overflow\n+    fn truncate_to_ptr(self, val: u128) -> (u64, bool) {\n+        let max_ptr_plus_1 = 1u128 << self.data_layout().pointer_size.bits();\n+        ((val % max_ptr_plus_1) as u64, val >= max_ptr_plus_1)\n+    }\n+\n+    // Overflow checking only works properly on the range from -u64 to +u64.\n+    fn overflowing_signed_offset(self, val: u64, i: i128) -> (u64, bool) {\n+        // FIXME: is it possible to over/underflow here?\n+        if i < 0 {\n+            // trickery to ensure that i64::min_value() works fine\n+            // this formula only works for true negative values, it panics for zero!\n+            let n = u64::max_value() - (i as u64) + 1;\n+            val.overflowing_sub(n)\n+        } else {\n+            self.overflowing_offset(val, i as u64)\n+        }\n+    }\n+\n+    fn overflowing_offset(self, val: u64, i: u64) -> (u64, bool) {\n+        let (res, over1) = val.overflowing_add(i);\n+        let (res, over2) = self.truncate_to_ptr(res as u128);\n+        (res, over1 || over2)\n+    }\n+\n+    fn signed_offset<'tcx>(self, val: u64, i: i64) -> EvalResult<'tcx, u64> {\n+        let (res, over) = self.overflowing_signed_offset(val, i as i128);\n+        if over {\n+            Err(EvalError::OverflowingMath)\n+        } else {\n+            Ok(res)\n+        }\n+    }\n+\n+    fn offset<'tcx>(self, val: u64, i: u64) -> EvalResult<'tcx, u64> {\n+        let (res, over) = self.overflowing_offset(val, i);\n+        if over {\n+            Err(EvalError::OverflowingMath)\n+        } else {\n+            Ok(res)\n+        }\n+    }\n+\n+    fn wrapping_signed_offset(self, val: u64, i: i64) -> u64 {\n+        self.overflowing_signed_offset(val, i as i128).0\n+    }\n+}\n+\n+impl<T: layout::HasDataLayout> PointerArithmetic for T {}\n+\n+impl<'a, 'tcx> layout::HasDataLayout for &'a Memory<'a, 'tcx> {\n+    #[inline]\n+    fn data_layout(&self) -> &TargetDataLayout {\n+        self.layout\n+    }\n+}\n+impl<'a, 'tcx> layout::HasDataLayout for &'a EvalContext<'a, 'tcx> {\n+    #[inline]\n+    fn data_layout(&self) -> &TargetDataLayout {\n+        self.memory().layout\n+    }\n+}\n+\n+impl<'c, 'b, 'a, 'tcx> layout::HasDataLayout for &'c &'b mut EvalContext<'a, 'tcx> {\n+    #[inline]\n+    fn data_layout(&self) -> &TargetDataLayout {\n+        self.memory().layout\n+    }\n }"}, {"sha": "930fc5c4047dedd89992ed0b513e46aaeaaa1ef7", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/03ca15e62d3a3386b824139a36597b4841e7d328/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ca15e62d3a3386b824139a36597b4841e7d328/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=03ca15e62d3a3386b824139a36597b4841e7d328", "patch": "@@ -310,11 +310,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(match bin_op {\n             Sub =>\n                 // The only way this can overflow is by underflowing, so signdeness of the right operands does not matter\n-                map_to_primval(left.overflowing_signed_offset(-right, self.memory.layout)),\n+                map_to_primval(left.overflowing_signed_offset(-right, self)),\n             Add if signed =>\n-                map_to_primval(left.overflowing_signed_offset(right, self.memory.layout)),\n+                map_to_primval(left.overflowing_signed_offset(right, self)),\n             Add if !signed =>\n-                map_to_primval(left.overflowing_offset(right as u64, self.memory.layout)),\n+                map_to_primval(left.overflowing_offset(right as u64, self)),\n \n             BitAnd if !signed => {\n                 let base_mask : u64 = !(self.memory.get(left.alloc_id)?.align - 1);"}, {"sha": "6e54420e2ebef9ab9c7d1a00db8b0068c23dd43f", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03ca15e62d3a3386b824139a36597b4841e7d328/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ca15e62d3a3386b824139a36597b4841e7d328/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=03ca15e62d3a3386b824139a36597b4841e7d328", "patch": "@@ -101,7 +101,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Layout::StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n                         if variant_index as u64 != nndiscr {\n                             let (offset, ty) = self.nonnull_offset_and_ty(dest_ty, nndiscr, discrfield)?;\n-                            let nonnull = self.force_allocation(dest)?.to_ptr()?.offset(offset.bytes(), self.memory.layout)?;\n+                            let nonnull = self.force_allocation(dest)?.to_ptr()?.offset(offset.bytes(), &self)?;\n                             trace!(\"struct wrapped nullable pointer type: {}\", ty);\n                             // only the pointer part of a fat pointer is used for this space optimization\n                             let discr_size = self.type_size(ty)?.expect(\"bad StructWrappedNullablePointer discrfield\");"}, {"sha": "a44713f221f8c16388c98a4972610f646503ee1d", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/03ca15e62d3a3386b824139a36597b4841e7d328/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ca15e62d3a3386b824139a36597b4841e7d328/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=03ca15e62d3a3386b824139a36597b4841e7d328", "patch": "@@ -316,7 +316,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                     Value::ByRef(ptr, aligned) => {\n                                         assert!(aligned, \"Unaligned ByRef-values cannot occur as function arguments\");\n                                         for ((offset, ty), arg_local) in offsets.zip(fields).zip(arg_locals) {\n-                                            let arg = Value::ByRef(ptr.offset(offset, self.memory.layout)?, true);\n+                                            let arg = Value::ByRef(ptr.offset(offset, &self)?, true);\n                                             let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n                                             trace!(\"writing arg {:?} to {:?} (type: {})\", arg, dest, ty);\n                                             self.write_value(arg, dest, ty)?;\n@@ -398,7 +398,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             ty::InstanceDef::Virtual(_, idx) => {\n                 let ptr_size = self.memory.pointer_size();\n                 let (_, vtable) = self.eval_operand(&arg_operands[0])?.into_ptr_vtable_pair(&mut self.memory)?;\n-                let fn_ptr = self.memory.read_ptr(vtable.offset(ptr_size * (idx as u64 + 3), self.memory.layout)?)?;\n+                let fn_ptr = self.memory.read_ptr(vtable.offset(ptr_size * (idx as u64 + 3), &self)?)?;\n                 let instance = self.memory.get_fn(fn_ptr.to_ptr()?)?;\n                 let mut arg_operands = arg_operands.to_vec();\n                 let ty = self.operand_ty(&arg_operands[0]);\n@@ -488,7 +488,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n                 let (offset, ty) = self.nonnull_offset_and_ty(adt_ty, nndiscr, discrfield)?;\n-                let nonnull = adt_ptr.offset(offset.bytes(), self.memory.layout)?;\n+                let nonnull = adt_ptr.offset(offset.bytes(), self)?;\n                 trace!(\"struct wrapped nullable pointer type: {}\", ty);\n                 // only the pointer part of a fat pointer is used for this space optimization\n                 let discr_size = self.type_size(ty)?.expect(\"bad StructWrappedNullablePointer discrfield\");\n@@ -746,7 +746,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n                 let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().rev().position(|&c| c == val) {\n-                    let new_ptr = ptr.offset(num - idx as u64 - 1, self.memory.layout)?;\n+                    let new_ptr = ptr.offset(num - idx as u64 - 1, &self)?;\n                     self.write_ptr(dest, new_ptr, dest_ty)?;\n                 } else {\n                     self.write_null(dest, dest_ty)?;\n@@ -758,7 +758,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n                 let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().position(|&c| c == val) {\n-                    let new_ptr = ptr.offset(idx as u64, self.memory.layout)?;\n+                    let new_ptr = ptr.offset(idx as u64, &self)?;\n                     self.write_ptr(dest, new_ptr, dest_ty)?;\n                 } else {\n                     self.write_null(dest, dest_ty)?;\n@@ -815,7 +815,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     // +1 for the null terminator\n                     let value_copy = self.memory.allocate((value.len() + 1) as u64, 1, Kind::Env)?;\n                     self.memory.write_bytes(value_copy.into(), &value)?;\n-                    self.memory.write_bytes(value_copy.offset(value.len() as u64, self.memory.layout)?.into(), &[0])?;\n+                    let trailing_null = value_copy.offset(value.len() as u64, &self)?.into();\n+                    self.memory.write_bytes(trailing_null, &[0])?;\n                     if let Some(var) = self.env_vars.insert(name.to_owned(), value_copy) {\n                         self.memory.deallocate(var, None, Kind::Env)?;\n                     }"}, {"sha": "fa5e5da8592fb7854b26f0b8f678b01041e7ee0a", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/03ca15e62d3a3386b824139a36597b4841e7d328/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ca15e62d3a3386b824139a36597b4841e7d328/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=03ca15e62d3a3386b824139a36597b4841e7d328", "patch": "@@ -57,14 +57,17 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let drop = self.memory.create_fn_alloc(drop);\n         self.memory.write_ptr(vtable, drop)?;\n \n-        self.memory.write_usize(vtable.offset(ptr_size, self.memory.layout)?, size)?;\n-        self.memory.write_usize(vtable.offset(ptr_size * 2, self.memory.layout)?, align)?;\n+        let size_ptr = vtable.offset(ptr_size, &self)?;\n+        self.memory.write_usize(size_ptr, size)?;\n+        let align_ptr = vtable.offset(ptr_size * 2, &self)?;\n+        self.memory.write_usize(align_ptr, align)?;\n \n         for (i, method) in ::rustc::traits::get_vtable_methods(self.tcx, trait_ref).enumerate() {\n             if let Some((def_id, substs)) = method {\n                 let instance = eval_context::resolve(self.tcx, def_id, substs);\n                 let fn_ptr = self.memory.create_fn_alloc(instance);\n-                self.memory.write_ptr(vtable.offset(ptr_size * (3 + i as u64), self.memory.layout)?, fn_ptr)?;\n+                let method_ptr = vtable.offset(ptr_size * (3 + i as u64), &self)?;\n+                self.memory.write_ptr(method_ptr, fn_ptr)?;\n             }\n         }\n \n@@ -85,8 +88,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     pub fn read_size_and_align_from_vtable(&self, vtable: MemoryPointer) -> EvalResult<'tcx, (u64, u64)> {\n         let pointer_size = self.memory.pointer_size();\n-        let size = self.memory.read_usize(vtable.offset(pointer_size, self.memory.layout)?)?;\n-        let align = self.memory.read_usize(vtable.offset(pointer_size * 2, self.memory.layout)?)?;\n+        let size = self.memory.read_usize(vtable.offset(pointer_size, self)?)?;\n+        let align = self.memory.read_usize(vtable.offset(pointer_size * 2, self)?)?;\n         Ok((size, align))\n     }\n "}, {"sha": "a4115ddb5ccf426bdc341b5da7f80bdfa091dbd8", "filename": "src/librustc_mir/interpret/value.rs", "status": "modified", "additions": 11, "deletions": 50, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/03ca15e62d3a3386b824139a36597b4841e7d328/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ca15e62d3a3386b824139a36597b4841e7d328/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs?ref=03ca15e62d3a3386b824139a36597b4841e7d328", "patch": "@@ -1,10 +1,9 @@\n #![allow(unknown_lints)]\n #![allow(float_cmp)]\n \n-use rustc::ty::layout::TargetDataLayout;\n-\n use error::{EvalError, EvalResult};\n-use memory::{Memory, MemoryPointer, HasMemory};\n+use memory::{Memory, MemoryPointer, HasMemory, PointerArithmetic};\n+use rustc::ty::layout::HasDataLayout;\n \n pub(super) fn bytes_to_f32(bytes: u128) -> f32 {\n     f32::from_bits(bytes as u32)\n@@ -61,33 +60,36 @@ impl<'tcx> Pointer {\n         self.primval\n     }\n \n-    pub(crate) fn signed_offset(self, i: i64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n+    pub(crate) fn signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n+        let layout = cx.data_layout();\n         match self.primval {\n             PrimVal::Bytes(b) => {\n                 assert_eq!(b as u64 as u128, b);\n-                Ok(Pointer::from(PrimVal::Bytes(signed_offset(b as u64, i, layout)? as u128)))\n+                Ok(Pointer::from(PrimVal::Bytes(layout.signed_offset(b as u64, i)? as u128)))\n             },\n             PrimVal::Ptr(ptr) => ptr.signed_offset(i, layout).map(Pointer::from),\n             PrimVal::Undef => Err(EvalError::ReadUndefBytes),\n         }\n     }\n \n-    pub(crate) fn offset(self, i: u64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n+    pub(crate) fn offset<C: HasDataLayout>(self, i: u64, cx: C) -> EvalResult<'tcx, Self> {\n+        let layout = cx.data_layout();\n         match self.primval {\n             PrimVal::Bytes(b) => {\n                 assert_eq!(b as u64 as u128, b);\n-                Ok(Pointer::from(PrimVal::Bytes(offset(b as u64, i, layout)? as u128)))\n+                Ok(Pointer::from(PrimVal::Bytes(layout.offset(b as u64, i)? as u128)))\n             },\n             PrimVal::Ptr(ptr) => ptr.offset(i, layout).map(Pointer::from),\n             PrimVal::Undef => Err(EvalError::ReadUndefBytes),\n         }\n     }\n \n-    pub(crate) fn wrapping_signed_offset(self, i: i64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n+    pub(crate) fn wrapping_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n+        let layout = cx.data_layout();\n         match self.primval {\n             PrimVal::Bytes(b) => {\n                 assert_eq!(b as u64 as u128, b);\n-                Ok(Pointer::from(PrimVal::Bytes(wrapping_signed_offset(b as u64, i, layout) as u128)))\n+                Ok(Pointer::from(PrimVal::Bytes(layout.wrapping_signed_offset(b as u64, i) as u128)))\n             },\n             PrimVal::Ptr(ptr) => Ok(Pointer::from(ptr.wrapping_signed_offset(i, layout))),\n             PrimVal::Undef => Err(EvalError::ReadUndefBytes),\n@@ -323,47 +325,6 @@ impl<'tcx> PrimVal {\n     }\n }\n \n-// Overflow checking only works properly on the range from -u64 to +u64.\n-pub fn overflowing_signed_offset<'tcx>(val: u64, i: i128, layout: &TargetDataLayout) -> (u64, bool) {\n-    // FIXME: is it possible to over/underflow here?\n-    if i < 0 {\n-        // trickery to ensure that i64::min_value() works fine\n-        // this formula only works for true negative values, it panics for zero!\n-        let n = u64::max_value() - (i as u64) + 1;\n-        val.overflowing_sub(n)\n-    } else {\n-        overflowing_offset(val, i as u64, layout)\n-    }\n-}\n-\n-pub fn overflowing_offset<'tcx>(val: u64, i: u64, layout: &TargetDataLayout) -> (u64, bool) {\n-    let (res, over) = val.overflowing_add(i);\n-    ((res as u128 % (1u128 << layout.pointer_size.bits())) as u64,\n-     over || res as u128 >= (1u128 << layout.pointer_size.bits()))\n-}\n-\n-pub fn signed_offset<'tcx>(val: u64, i: i64, layout: &TargetDataLayout) -> EvalResult<'tcx, u64> {\n-    let (res, over) = overflowing_signed_offset(val, i as i128, layout);\n-    if over {\n-        Err(EvalError::OverflowingMath)\n-    } else {\n-        Ok(res)\n-    }\n-}\n-\n-pub fn offset<'tcx>(val: u64, i: u64, layout: &TargetDataLayout) -> EvalResult<'tcx, u64> {\n-    let (res, over) = overflowing_offset(val, i, layout);\n-    if over {\n-        Err(EvalError::OverflowingMath)\n-    } else {\n-        Ok(res)\n-    }\n-}\n-\n-pub fn wrapping_signed_offset<'tcx>(val: u64, i: i64, layout: &TargetDataLayout) -> u64 {\n-    overflowing_signed_offset(val, i as i128, layout).0\n-}\n-\n impl PrimValKind {\n     pub fn is_int(self) -> bool {\n         use self::PrimValKind::*;"}, {"sha": "b1b06263056d7da1c8c519b6b98bfb6ad93b2867", "filename": "tests/run-pass/ptr_int_casts.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/03ca15e62d3a3386b824139a36597b4841e7d328/tests%2Frun-pass%2Fptr_int_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ca15e62d3a3386b824139a36597b4841e7d328/tests%2Frun-pass%2Fptr_int_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fptr_int_casts.rs?ref=03ca15e62d3a3386b824139a36597b4841e7d328", "patch": "@@ -29,4 +29,7 @@ fn main() {\n         let x : fn() -> i32 = unsafe { mem::transmute(y as *mut u8) };\n         assert_eq!(x(), 42);\n     }\n+\n+    // involving types other than usize\n+    assert_eq!((-1i32) as usize as *const i32 as usize, (-1i32) as usize);\n }"}]}