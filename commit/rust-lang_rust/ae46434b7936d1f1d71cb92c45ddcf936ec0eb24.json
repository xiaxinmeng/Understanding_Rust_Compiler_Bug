{"sha": "ae46434b7936d1f1d71cb92c45ddcf936ec0eb24", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlNDY0MzRiNzkzNmQxZjFkNzFjYjkyYzQ1ZGRjZjkzNmVjMGViMjQ=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-02-03T20:15:00Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-02-09T23:29:11Z"}, "message": "Remove \"static item recursion checking\" in favor of relying on cycle checks in the query engine", "tree": {"sha": "7e47ee934f8bb760bd3ed3a114c70cdc29235d2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e47ee934f8bb760bd3ed3a114c70cdc29235d2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae46434b7936d1f1d71cb92c45ddcf936ec0eb24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae46434b7936d1f1d71cb92c45ddcf936ec0eb24", "html_url": "https://github.com/rust-lang/rust/commit/ae46434b7936d1f1d71cb92c45ddcf936ec0eb24", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae46434b7936d1f1d71cb92c45ddcf936ec0eb24/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bcda48a30b21e46b81a7989deb30a3ba85fb918", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bcda48a30b21e46b81a7989deb30a3ba85fb918", "html_url": "https://github.com/rust-lang/rust/commit/3bcda48a30b21e46b81a7989deb30a3ba85fb918"}], "stats": {"total": 458, "additions": 84, "deletions": 374}, "files": [{"sha": "0c0c946cd4c51465a82c7220f4d2f01954f9d02b", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae46434b7936d1f1d71cb92c45ddcf936ec0eb24/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae46434b7936d1f1d71cb92c45ddcf936ec0eb24/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=ae46434b7936d1f1d71cb92c45ddcf936ec0eb24", "patch": "@@ -36,7 +36,7 @@ use rustc_typeck as typeck;\n use rustc_privacy;\n use rustc_plugin::registry::Registry;\n use rustc_plugin as plugin;\n-use rustc_passes::{self, ast_validation, loops, consts, static_recursion, hir_stats};\n+use rustc_passes::{self, ast_validation, loops, consts, hir_stats};\n use rustc_const_eval::{self, check_match};\n use super::Compilation;\n \n@@ -972,10 +972,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(trans: &TransCrate,\n          \"loop checking\",\n          || loops::check_crate(sess, &hir_map));\n \n-    time(time_passes,\n-              \"static item recursion checking\",\n-              || static_recursion::check_crate(sess, &hir_map))?;\n-\n     let mut local_providers = ty::maps::Providers::default();\n     default_provide(&mut local_providers);\n     trans.provide(&mut local_providers);"}, {"sha": "8a19615c1adcb55a2510c4f07330b75abe0fe445", "filename": "src/librustc_passes/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ae46434b7936d1f1d71cb92c45ddcf936ec0eb24/src%2Flibrustc_passes%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae46434b7936d1f1d71cb92c45ddcf936ec0eb24/src%2Flibrustc_passes%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostics.rs?ref=ae46434b7936d1f1d71cb92c45ddcf936ec0eb24", "patch": "@@ -128,22 +128,6 @@ impl !Enterprise for Foo { }\n Please note that negative impls are only allowed for auto traits.\n \"##,\n \n-E0265: r##\"\n-This error indicates that a static or constant references itself.\n-All statics and constants need to resolve to a value in an acyclic manner.\n-\n-For example, neither of the following can be sensibly compiled:\n-\n-```compile_fail,E0265\n-const X: u32 = X;\n-```\n-\n-```compile_fail,E0265\n-const X: u32 = Y;\n-const Y: u32 = X;\n-```\n-\"##,\n-\n E0267: r##\"\n This error indicates the use of a loop keyword (`break` or `continue`) inside a\n closure but outside of any loop. Erroneous code example:"}, {"sha": "bfcf68908bc8c2544cf535358f1d94c4534ed3d1", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae46434b7936d1f1d71cb92c45ddcf936ec0eb24/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae46434b7936d1f1d71cb92c45ddcf936ec0eb24/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=ae46434b7936d1f1d71cb92c45ddcf936ec0eb24", "patch": "@@ -42,7 +42,6 @@ pub mod consts;\n pub mod hir_stats;\n pub mod loops;\n mod mir_stats;\n-pub mod static_recursion;\n \n #[cfg(not(stage0))] // remove after the next snapshot\n __build_diagnostic_array! { librustc_passes, DIAGNOSTICS }"}, {"sha": "987243b523473054a966f0efca0d3724389e56c5", "filename": "src/librustc_passes/static_recursion.rs", "status": "removed", "additions": 0, "deletions": 280, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/3bcda48a30b21e46b81a7989deb30a3ba85fb918/src%2Flibrustc_passes%2Fstatic_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bcda48a30b21e46b81a7989deb30a3ba85fb918/src%2Flibrustc_passes%2Fstatic_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstatic_recursion.rs?ref=3bcda48a30b21e46b81a7989deb30a3ba85fb918", "patch": "@@ -1,280 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// This compiler pass detects constants that refer to themselves\n-// recursively.\n-\n-use rustc::hir::map as hir_map;\n-use rustc::session::Session;\n-use rustc::hir::def::{Def, CtorKind};\n-use rustc::util::common::ErrorReported;\n-use rustc::util::nodemap::{NodeMap, NodeSet};\n-\n-use syntax::ast;\n-use syntax_pos::Span;\n-use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use rustc::hir;\n-\n-struct CheckCrateVisitor<'a, 'hir: 'a> {\n-    sess: &'a Session,\n-    hir_map: &'a hir_map::Map<'hir>,\n-    // `discriminant_map` is a cache that associates the `NodeId`s of local\n-    // variant definitions with the discriminant expression that applies to\n-    // each one. If the variant uses the default values (starting from `0`),\n-    // then `None` is stored.\n-    discriminant_map: NodeMap<Option<hir::BodyId>>,\n-    detected_recursive_ids: NodeSet,\n-}\n-\n-impl<'a, 'hir: 'a> Visitor<'hir> for CheckCrateVisitor<'a, 'hir> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'hir> {\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_item(&mut self, it: &'hir hir::Item) {\n-        match it.node {\n-            hir::ItemStatic(..) |\n-            hir::ItemConst(..) => {\n-                let mut recursion_visitor = CheckItemRecursionVisitor::new(self);\n-                recursion_visitor.visit_item(it);\n-            }\n-            hir::ItemEnum(ref enum_def, ref generics) => {\n-                // We could process the whole enum, but handling the variants\n-                // with discriminant expressions one by one gives more specific,\n-                // less redundant output.\n-                for variant in &enum_def.variants {\n-                    if let Some(_) = variant.node.disr_expr {\n-                        let mut recursion_visitor = CheckItemRecursionVisitor::new(self);\n-                        recursion_visitor.populate_enum_discriminants(enum_def);\n-                        recursion_visitor.visit_variant(variant, generics, it.id);\n-                    }\n-                }\n-            }\n-            _ => {}\n-        }\n-        intravisit::walk_item(self, it)\n-    }\n-\n-    fn visit_trait_item(&mut self, ti: &'hir hir::TraitItem) {\n-        match ti.node {\n-            hir::TraitItemKind::Const(_, ref default) => {\n-                if let Some(_) = *default {\n-                    let mut recursion_visitor = CheckItemRecursionVisitor::new(self);\n-                    recursion_visitor.visit_trait_item(ti);\n-                }\n-            }\n-            _ => {}\n-        }\n-        intravisit::walk_trait_item(self, ti)\n-    }\n-\n-    fn visit_impl_item(&mut self, ii: &'hir hir::ImplItem) {\n-        match ii.node {\n-            hir::ImplItemKind::Const(..) => {\n-                let mut recursion_visitor = CheckItemRecursionVisitor::new(self);\n-                recursion_visitor.visit_impl_item(ii);\n-            }\n-            _ => {}\n-        }\n-        intravisit::walk_impl_item(self, ii)\n-    }\n-}\n-\n-pub fn check_crate<'hir>(sess: &Session, hir_map: &hir_map::Map<'hir>)\n-                         -> Result<(), ErrorReported>\n-{\n-    let mut visitor = CheckCrateVisitor {\n-        sess,\n-        hir_map,\n-        discriminant_map: NodeMap(),\n-        detected_recursive_ids: NodeSet(),\n-    };\n-    sess.track_errors(|| {\n-        // FIXME(#37712) could use ItemLikeVisitor if trait items were item-like\n-        hir_map.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n-    })\n-}\n-\n-struct CheckItemRecursionVisitor<'a, 'b: 'a, 'hir: 'b> {\n-    sess: &'b Session,\n-    hir_map: &'b hir_map::Map<'hir>,\n-    discriminant_map: &'a mut NodeMap<Option<hir::BodyId>>,\n-    idstack: Vec<ast::NodeId>,\n-    detected_recursive_ids: &'a mut NodeSet,\n-}\n-\n-impl<'a, 'b: 'a, 'hir: 'b> CheckItemRecursionVisitor<'a, 'b, 'hir> {\n-    fn new(v: &'a mut CheckCrateVisitor<'b, 'hir>) -> Self {\n-        CheckItemRecursionVisitor {\n-            sess: v.sess,\n-            hir_map: v.hir_map,\n-            discriminant_map: &mut v.discriminant_map,\n-            idstack: Vec::new(),\n-            detected_recursive_ids: &mut v.detected_recursive_ids,\n-        }\n-    }\n-    fn with_item_id_pushed<F>(&mut self, id: ast::NodeId, f: F, span: Span)\n-        where F: Fn(&mut Self)\n-    {\n-        if self.idstack.iter().any(|&x| x == id) {\n-            if self.detected_recursive_ids.contains(&id) {\n-                return;\n-            }\n-            self.detected_recursive_ids.insert(id);\n-            let any_static = self.idstack.iter().any(|&x| {\n-                if let hir_map::NodeItem(item) = self.hir_map.get(x) {\n-                    if let hir::ItemStatic(..) = item.node {\n-                        true\n-                    } else {\n-                        false\n-                    }\n-                } else {\n-                    false\n-                }\n-            });\n-            if !any_static {\n-                struct_span_err!(self.sess, span, E0265, \"recursive constant\")\n-                    .span_label(span, \"recursion not allowed in constant\")\n-                    .emit();\n-            }\n-            return;\n-        }\n-        self.idstack.push(id);\n-        f(self);\n-        self.idstack.pop();\n-    }\n-    // If a variant has an expression specifying its discriminant, then it needs\n-    // to be checked just like a static or constant. However, if there are more\n-    // variants with no explicitly specified discriminant, those variants will\n-    // increment the same expression to get their values.\n-    //\n-    // So for every variant, we need to track whether there is an expression\n-    // somewhere in the enum definition that controls its discriminant. We do\n-    // this by starting from the end and searching backward.\n-    fn populate_enum_discriminants(&mut self, enum_definition: &'hir hir::EnumDef) {\n-        // Get the map, and return if we already processed this enum or if it\n-        // has no variants.\n-        match enum_definition.variants.first() {\n-            None => {\n-                return;\n-            }\n-            Some(variant) if self.discriminant_map.contains_key(&variant.node.data.id()) => {\n-                return;\n-            }\n-            _ => {}\n-        }\n-\n-        // Go through all the variants.\n-        let mut variant_stack: Vec<ast::NodeId> = Vec::new();\n-        for variant in enum_definition.variants.iter().rev() {\n-            variant_stack.push(variant.node.data.id());\n-            // When we find an expression, every variant currently on the stack\n-            // is affected by that expression.\n-            if let Some(expr) = variant.node.disr_expr {\n-                for id in &variant_stack {\n-                    self.discriminant_map.insert(*id, Some(expr));\n-                }\n-                variant_stack.clear()\n-            }\n-        }\n-        // If we are at the top, that always starts at 0, so any variant on the\n-        // stack has a default value and does not need to be checked.\n-        for id in &variant_stack {\n-            self.discriminant_map.insert(*id, None);\n-        }\n-    }\n-}\n-\n-impl<'a, 'b: 'a, 'hir: 'b> Visitor<'hir> for CheckItemRecursionVisitor<'a, 'b, 'hir> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'hir> {\n-        NestedVisitorMap::OnlyBodies(&self.hir_map)\n-    }\n-    fn visit_item(&mut self, it: &'hir hir::Item) {\n-        self.with_item_id_pushed(it.id, |v| intravisit::walk_item(v, it), it.span);\n-    }\n-\n-    fn visit_enum_def(&mut self,\n-                      enum_definition: &'hir hir::EnumDef,\n-                      generics: &'hir hir::Generics,\n-                      item_id: ast::NodeId,\n-                      _: Span) {\n-        self.populate_enum_discriminants(enum_definition);\n-        intravisit::walk_enum_def(self, enum_definition, generics, item_id);\n-    }\n-\n-    fn visit_variant(&mut self,\n-                     variant: &'hir hir::Variant,\n-                     _: &'hir hir::Generics,\n-                     _: ast::NodeId) {\n-        let variant_id = variant.node.data.id();\n-        let maybe_expr = *self.discriminant_map.get(&variant_id).unwrap_or_else(|| {\n-            span_bug!(variant.span,\n-                      \"`check_static_recursion` attempted to visit \\\n-                      variant with unknown discriminant\")\n-        });\n-        // If `maybe_expr` is `None`, that's because no discriminant is\n-        // specified that affects this variant. Thus, no risk of recursion.\n-        if let Some(expr) = maybe_expr {\n-            let expr = &self.hir_map.body(expr).value;\n-            self.with_item_id_pushed(expr.id, |v| intravisit::walk_expr(v, expr), expr.span);\n-        }\n-    }\n-\n-    fn visit_trait_item(&mut self, ti: &'hir hir::TraitItem) {\n-        self.with_item_id_pushed(ti.id, |v| intravisit::walk_trait_item(v, ti), ti.span);\n-    }\n-\n-    fn visit_impl_item(&mut self, ii: &'hir hir::ImplItem) {\n-        self.with_item_id_pushed(ii.id, |v| intravisit::walk_impl_item(v, ii), ii.span);\n-    }\n-\n-    fn visit_path(&mut self, path: &'hir hir::Path, _: ast::NodeId) {\n-        match path.def {\n-            Def::Static(def_id, _) |\n-            Def::AssociatedConst(def_id) |\n-            Def::Const(def_id) => {\n-                if let Some(node_id) = self.hir_map.as_local_node_id(def_id) {\n-                    match self.hir_map.get(node_id) {\n-                        hir_map::NodeItem(item) => self.visit_item(item),\n-                        hir_map::NodeTraitItem(item) => self.visit_trait_item(item),\n-                        hir_map::NodeImplItem(item) => self.visit_impl_item(item),\n-                        hir_map::NodeForeignItem(_) => {}\n-                        _ => {\n-                            span_bug!(path.span,\n-                                      \"expected item, found {}\",\n-                                      self.hir_map.node_to_string(node_id));\n-                        }\n-                    }\n-                }\n-            }\n-            // For variants, we only want to check expressions that\n-            // affect the specific variant used, but we need to check\n-            // the whole enum definition to see what expression that\n-            // might be (if any).\n-            Def::VariantCtor(variant_id, CtorKind::Const) => {\n-                if let Some(variant_id) = self.hir_map.as_local_node_id(variant_id) {\n-                    let variant = self.hir_map.expect_variant(variant_id);\n-                    let enum_id = self.hir_map.get_parent(variant_id);\n-                    let enum_item = self.hir_map.expect_item(enum_id);\n-                    if let hir::ItemEnum(ref enum_def, ref generics) = enum_item.node {\n-                        self.populate_enum_discriminants(enum_def);\n-                        self.visit_variant(variant, generics, enum_id);\n-                    } else {\n-                        span_bug!(path.span,\n-                                  \"`check_static_recursion` found \\\n-                                    non-enum in Def::VariantCtor\");\n-                    }\n-                }\n-            }\n-            _ => (),\n-        }\n-        intravisit::walk_path(self, path);\n-    }\n-}"}, {"sha": "1c3e6890c8e2e17ea112daa8dff4ea0f0be348fc", "filename": "src/test/compile-fail/issue-17252.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae46434b7936d1f1d71cb92c45ddcf936ec0eb24/src%2Ftest%2Fcompile-fail%2Fissue-17252.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae46434b7936d1f1d71cb92c45ddcf936ec0eb24/src%2Ftest%2Fcompile-fail%2Fissue-17252.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17252.rs?ref=ae46434b7936d1f1d71cb92c45ddcf936ec0eb24", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-const FOO: usize = FOO; //~ ERROR recursive constant\n+const FOO: usize = FOO; //~ ERROR E0391\n \n fn main() {\n     let _x: [u8; FOO]; // caused stack overflow prior to fix\n     let _y: usize = 1 + {\n-        const BAR: usize = BAR; //~ ERROR recursive constant\n+        const BAR: usize = BAR;\n         let _z: [u8; BAR]; // caused stack overflow prior to fix\n         1\n     };"}, {"sha": "10a538301162c688ce60c4041838606db2848d69", "filename": "src/test/ui/issue-23302-1.rs", "status": "renamed", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ae46434b7936d1f1d71cb92c45ddcf936ec0eb24/src%2Ftest%2Fui%2Fissue-23302-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae46434b7936d1f1d71cb92c45ddcf936ec0eb24/src%2Ftest%2Fui%2Fissue-23302-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-23302-1.rs?ref=ae46434b7936d1f1d71cb92c45ddcf936ec0eb24", "patch": "@@ -11,18 +11,7 @@\n // Check that an enum with recursion in the discriminant throws\n // the appropriate error (rather than, say, blowing the stack).\n enum X {\n-    A = X::A as isize, //~ ERROR E0265\n+    A = X::A as isize, //~ ERROR E0391\n }\n \n-// Since `Y::B` here defaults to `Y::A+1`, this is also a\n-// recursive definition.\n-enum Y {\n-    A = Y::B as isize, //~ ERROR E0265\n-    B,\n-}\n-\n-const A: i32 = B; //~ ERROR E0265\n-\n-const B: i32 = A; //~ ERROR E0265\n-\n fn main() { }", "previous_filename": "src/test/ui/issue-23302.rs"}, {"sha": "4fbd0e72bf2c83abdf957d5ce31bc3436d924289", "filename": "src/test/ui/issue-23302-1.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ae46434b7936d1f1d71cb92c45ddcf936ec0eb24/src%2Ftest%2Fui%2Fissue-23302-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ae46434b7936d1f1d71cb92c45ddcf936ec0eb24/src%2Ftest%2Fui%2Fissue-23302-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-23302-1.stderr?ref=ae46434b7936d1f1d71cb92c45ddcf936ec0eb24", "patch": "@@ -0,0 +1,15 @@\n+error[E0391]: unsupported cyclic reference between types/traits detected\n+  --> $DIR/issue-23302-1.rs:14:9\n+   |\n+14 |     A = X::A as isize, //~ ERROR E0391\n+   |         ^^^^^^^^^^^^^ cyclic reference\n+   |\n+note: the cycle begins when const-evaluating `X::A::{{initializer}}`...\n+  --> $DIR/issue-23302-1.rs:14:5\n+   |\n+14 |     A = X::A as isize, //~ ERROR E0391\n+   |     ^^^^^^^^^^^^^^^^^\n+   = note: ...which then again requires const-evaluating `X::A::{{initializer}}`, completing the cycle.\n+\n+error: aborting due to previous error\n+"}, {"sha": "d1af19eb579f524b6f42f2d98050ce5dcb718f47", "filename": "src/test/ui/issue-23302-2.rs", "status": "renamed", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ae46434b7936d1f1d71cb92c45ddcf936ec0eb24/src%2Ftest%2Fui%2Fissue-23302-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae46434b7936d1f1d71cb92c45ddcf936ec0eb24/src%2Ftest%2Fui%2Fissue-23302-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-23302-2.rs?ref=ae46434b7936d1f1d71cb92c45ddcf936ec0eb24", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,7 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-const A: usize = B; //~ ERROR: recursive constant\n-const B: usize = A; //~ ERROR: recursive constant\n+// Since `Y::B` here defaults to `Y::A+1`, this is also a\n+// recursive definition.\n+enum Y {\n+    A = Y::B as isize, //~ ERROR E0391\n+    B,\n+}\n \n-fn main() {}\n+fn main() { }", "previous_filename": "src/test/compile-fail/issue-17718-recursive.rs"}, {"sha": "90d828621e93784c2bcfb25a392a79636cea1cc1", "filename": "src/test/ui/issue-23302-2.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ae46434b7936d1f1d71cb92c45ddcf936ec0eb24/src%2Ftest%2Fui%2Fissue-23302-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ae46434b7936d1f1d71cb92c45ddcf936ec0eb24/src%2Ftest%2Fui%2Fissue-23302-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-23302-2.stderr?ref=ae46434b7936d1f1d71cb92c45ddcf936ec0eb24", "patch": "@@ -0,0 +1,15 @@\n+error[E0391]: unsupported cyclic reference between types/traits detected\n+  --> $DIR/issue-23302-2.rs:14:9\n+   |\n+14 |     A = Y::B as isize, //~ ERROR E0391\n+   |         ^^^^^^^^^^^^^ cyclic reference\n+   |\n+note: the cycle begins when const-evaluating `Y::A::{{initializer}}`...\n+  --> $DIR/issue-23302-2.rs:14:5\n+   |\n+14 |     A = Y::B as isize, //~ ERROR E0391\n+   |     ^^^^^^^^^^^^^^^^^\n+   = note: ...which then again requires const-evaluating `Y::A::{{initializer}}`, completing the cycle.\n+\n+error: aborting due to previous error\n+"}, {"sha": "1d750b09025b993b5d62bad43164b2129273ae4a", "filename": "src/test/ui/issue-23302-3.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ae46434b7936d1f1d71cb92c45ddcf936ec0eb24/src%2Ftest%2Fui%2Fissue-23302-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae46434b7936d1f1d71cb92c45ddcf936ec0eb24/src%2Ftest%2Fui%2Fissue-23302-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-23302-3.rs?ref=ae46434b7936d1f1d71cb92c45ddcf936ec0eb24", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-const a: isize = b; //~ ERROR recursive constant\n-const b: isize = a; //~ ERROR recursive constant\n+const A: i32 = B; //~ ERROR E0391\n \n-fn main() {\n-}\n+const B: i32 = A;\n+\n+fn main() { }", "previous_filename": "src/test/compile-fail/const-recursive.rs"}, {"sha": "a72010c2c797fd7b6a7c9f1ac979f0b581b1c989", "filename": "src/test/ui/issue-23302-3.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ae46434b7936d1f1d71cb92c45ddcf936ec0eb24/src%2Ftest%2Fui%2Fissue-23302-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ae46434b7936d1f1d71cb92c45ddcf936ec0eb24/src%2Ftest%2Fui%2Fissue-23302-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-23302-3.stderr?ref=ae46434b7936d1f1d71cb92c45ddcf936ec0eb24", "patch": "@@ -0,0 +1,20 @@\n+error[E0391]: unsupported cyclic reference between types/traits detected\n+  --> $DIR/issue-23302-3.rs:11:16\n+   |\n+11 | const A: i32 = B; //~ ERROR E0391\n+   |                ^ cyclic reference\n+   |\n+note: the cycle begins when processing `B`...\n+  --> $DIR/issue-23302-3.rs:13:1\n+   |\n+13 | const B: i32 = A;\n+   | ^^^^^^^^^^^^^^^^^\n+note: ...which then requires processing `A`...\n+  --> $DIR/issue-23302-3.rs:13:16\n+   |\n+13 | const B: i32 = A;\n+   |                ^\n+   = note: ...which then again requires processing `B`, completing the cycle.\n+\n+error: aborting due to previous error\n+"}, {"sha": "4e93809fac3741cc925a8d46c914a0f095aaca65", "filename": "src/test/ui/issue-23302.stderr", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3bcda48a30b21e46b81a7989deb30a3ba85fb918/src%2Ftest%2Fui%2Fissue-23302.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3bcda48a30b21e46b81a7989deb30a3ba85fb918/src%2Ftest%2Fui%2Fissue-23302.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-23302.stderr?ref=3bcda48a30b21e46b81a7989deb30a3ba85fb918", "patch": "@@ -1,26 +0,0 @@\n-error[E0265]: recursive constant\n-  --> $DIR/issue-23302.rs:14:9\n-   |\n-14 |     A = X::A as isize, //~ ERROR E0265\n-   |         ^^^^^^^^^^^^^ recursion not allowed in constant\n-\n-error[E0265]: recursive constant\n-  --> $DIR/issue-23302.rs:20:9\n-   |\n-20 |     A = Y::B as isize, //~ ERROR E0265\n-   |         ^^^^^^^^^^^^^ recursion not allowed in constant\n-\n-error[E0265]: recursive constant\n-  --> $DIR/issue-23302.rs:24:1\n-   |\n-24 | const A: i32 = B; //~ ERROR E0265\n-   | ^^^^^^^^^^^^^^^^^ recursion not allowed in constant\n-\n-error[E0265]: recursive constant\n-  --> $DIR/issue-23302.rs:26:1\n-   |\n-26 | const B: i32 = A; //~ ERROR E0265\n-   | ^^^^^^^^^^^^^^^^^ recursion not allowed in constant\n-\n-error: aborting due to 4 previous errors\n-"}, {"sha": "4c74d9d9173d8c3e5906f7c4f2f082768928e052", "filename": "src/test/ui/issue-36163.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ae46434b7936d1f1d71cb92c45ddcf936ec0eb24/src%2Ftest%2Fui%2Fissue-36163.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae46434b7936d1f1d71cb92c45ddcf936ec0eb24/src%2Ftest%2Fui%2Fissue-36163.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-36163.rs?ref=ae46434b7936d1f1d71cb92c45ddcf936ec0eb24", "patch": "@@ -8,16 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-const A: i32 = Foo::B; //~ ERROR E0265\n+const A: isize = Foo::B as isize;\n \n enum Foo {\n-    B = A, //~ ERROR E0265\n+    B = A, //~ ERROR E0391\n }\n \n-enum Bar {\n-    C = Bar::C, //~ ERROR E0265\n-}\n-\n-const D: i32 = A;\n-\n fn main() {}"}, {"sha": "3868d58e7f7ae86591fe2ddb389ef5e9891bb5ad", "filename": "src/test/ui/issue-36163.stderr", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ae46434b7936d1f1d71cb92c45ddcf936ec0eb24/src%2Ftest%2Fui%2Fissue-36163.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ae46434b7936d1f1d71cb92c45ddcf936ec0eb24/src%2Ftest%2Fui%2Fissue-36163.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-36163.stderr?ref=ae46434b7936d1f1d71cb92c45ddcf936ec0eb24", "patch": "@@ -1,20 +1,20 @@\n-error[E0265]: recursive constant\n-  --> $DIR/issue-36163.rs:11:1\n-   |\n-11 | const A: i32 = Foo::B; //~ ERROR E0265\n-   | ^^^^^^^^^^^^^^^^^^^^^^ recursion not allowed in constant\n-\n-error[E0265]: recursive constant\n+error[E0391]: unsupported cyclic reference between types/traits detected\n   --> $DIR/issue-36163.rs:14:9\n    |\n-14 |     B = A, //~ ERROR E0265\n-   |         ^ recursion not allowed in constant\n-\n-error[E0265]: recursive constant\n-  --> $DIR/issue-36163.rs:18:9\n+14 |     B = A, //~ ERROR E0391\n+   |         ^ cyclic reference\n+   |\n+note: the cycle begins when const-evaluating `Foo::B::{{initializer}}`...\n+  --> $DIR/issue-36163.rs:14:5\n+   |\n+14 |     B = A, //~ ERROR E0391\n+   |     ^^^^^\n+note: ...which then requires const-evaluating `A`...\n+  --> $DIR/issue-36163.rs:14:9\n    |\n-18 |     C = Bar::C, //~ ERROR E0265\n-   |         ^^^^^^ recursion not allowed in constant\n+14 |     B = A, //~ ERROR E0391\n+   |         ^\n+   = note: ...which then again requires const-evaluating `Foo::B::{{initializer}}`, completing the cycle.\n \n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n "}]}