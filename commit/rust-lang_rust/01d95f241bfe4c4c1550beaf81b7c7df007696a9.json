{"sha": "01d95f241bfe4c4c1550beaf81b7c7df007696a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxZDk1ZjI0MWJmZTRjNGMxNTUwYmVhZjgxYjdjN2RmMDA3Njk2YTk=", "commit": {"author": {"name": "Prabakaran Kumaresshan", "email": "4676330+nixphix@users.noreply.github.com", "date": "2020-08-27T03:15:07Z"}, "committer": {"name": "Prabakaran Kumaresshan", "email": "4676330+nixphix@users.noreply.github.com", "date": "2020-08-30T00:10:47Z"}, "message": "resolve comments", "tree": {"sha": "83cebca36654fad3731e088d79520f65da676c97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83cebca36654fad3731e088d79520f65da676c97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01d95f241bfe4c4c1550beaf81b7c7df007696a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01d95f241bfe4c4c1550beaf81b7c7df007696a9", "html_url": "https://github.com/rust-lang/rust/commit/01d95f241bfe4c4c1550beaf81b7c7df007696a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01d95f241bfe4c4c1550beaf81b7c7df007696a9/comments", "author": {"login": "nixphix", "id": 4676330, "node_id": "MDQ6VXNlcjQ2NzYzMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/4676330?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nixphix", "html_url": "https://github.com/nixphix", "followers_url": "https://api.github.com/users/nixphix/followers", "following_url": "https://api.github.com/users/nixphix/following{/other_user}", "gists_url": "https://api.github.com/users/nixphix/gists{/gist_id}", "starred_url": "https://api.github.com/users/nixphix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nixphix/subscriptions", "organizations_url": "https://api.github.com/users/nixphix/orgs", "repos_url": "https://api.github.com/users/nixphix/repos", "events_url": "https://api.github.com/users/nixphix/events{/privacy}", "received_events_url": "https://api.github.com/users/nixphix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nixphix", "id": 4676330, "node_id": "MDQ6VXNlcjQ2NzYzMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/4676330?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nixphix", "html_url": "https://github.com/nixphix", "followers_url": "https://api.github.com/users/nixphix/followers", "following_url": "https://api.github.com/users/nixphix/following{/other_user}", "gists_url": "https://api.github.com/users/nixphix/gists{/gist_id}", "starred_url": "https://api.github.com/users/nixphix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nixphix/subscriptions", "organizations_url": "https://api.github.com/users/nixphix/orgs", "repos_url": "https://api.github.com/users/nixphix/repos", "events_url": "https://api.github.com/users/nixphix/events{/privacy}", "received_events_url": "https://api.github.com/users/nixphix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a92718b64307236514a16c5f69cd5c02d40dd6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a92718b64307236514a16c5f69cd5c02d40dd6b", "html_url": "https://github.com/rust-lang/rust/commit/8a92718b64307236514a16c5f69cd5c02d40dd6b"}], "stats": {"total": 57, "additions": 35, "deletions": 22}, "files": [{"sha": "7849d267ccac0eb89299e6dd38ab602a87715f06", "filename": "library/core/src/convert/mod.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/01d95f241bfe4c4c1550beaf81b7c7df007696a9/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d95f241bfe4c4c1550beaf81b7c7df007696a9/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs?ref=01d95f241bfe4c4c1550beaf81b7c7df007696a9", "patch": "@@ -134,8 +134,8 @@ pub const fn identity<T>(x: T) -> T {\n /// want to accept all references that can be converted to [`&str`] as an argument.\n /// Since both [`String`] and [`&str`] implement `AsRef<str>` we can accept both as input argument.\n ///\n-/// [`Option<T>`]: crate::option::Option\n-/// [`Result<T, E>`]: crate::result::Result\n+/// [`Option<T>`]: Option\n+/// [`Result<T, E>`]: Result\n /// [`Borrow`]: crate::borrow::Borrow\n /// [`Eq`]: crate::cmp::Eq\n /// [`Ord`]: crate::cmp::Ord\n@@ -168,8 +168,8 @@ pub trait AsRef<T: ?Sized> {\n /// **Note: This trait must not fail**. If the conversion can fail, use a\n /// dedicated method which returns an [`Option<T>`] or a [`Result<T, E>`].\n ///\n-/// [`Option<T>`]: crate::option::Option\n-/// [`Result<T, E>`]: crate::result::Result\n+/// [`Option<T>`]: Option\n+/// [`Result<T, E>`]: Result\n ///\n /// # Generic Implementations\n ///\n@@ -195,7 +195,7 @@ pub trait AsRef<T: ?Sized> {\n /// assert_eq!(*boxed_num, 1);\n /// ```\n ///\n-/// [`Box<T>`]: crate::boxed::Box<T>\n+/// [`Box<T>`]: ../../std/boxed/struct.Box.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait AsMut<T: ?Sized> {\n     /// Performs the conversion.\n@@ -269,10 +269,10 @@ pub trait AsMut<T: ?Sized> {\n /// is_hello(s);\n /// ```\n ///\n-/// [`Option<T>`]: crate::option::Option\n-/// [`Result<T, E>`]: crate::result::Result\n+/// [`Option<T>`]: Option\n+/// [`Result<T, E>`]: Result\n /// [`String`]: ../../std/string/struct.String.html\n-/// [`Vec`]: crate::vec::Vec<T>\n+/// [`Vec`]: ../../std/vec/struct.Vec.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Into<T>: Sized {\n     /// Performs the conversion.\n@@ -358,9 +358,10 @@ pub trait Into<T>: Sized {\n /// }\n /// ```\n ///\n-/// [`Option<T>`]: crate::option::Option\n-/// [`Result<T, E>`]: crate::result::Result\n+/// [`Option<T>`]: Option\n+/// [`Result<T, E>`]: Result\n /// [`String`]: ../../std/string/struct.String.html\n+/// [`from`]: From::from\n /// [book]: ../../book/ch09-00-error-handling.html\n #[rustc_diagnostic_item = \"from_trait\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -418,7 +419,7 @@ pub trait TryInto<T>: Sized {\n /// # Generic Implementations\n ///\n /// - `TryFrom<T> for U` implies [`TryInto`]`<U> for T`\n-/// - [`TryFrom::try_from`] is reflexive, which means that `TryFrom<T> for T`\n+/// - [`try_from`] is reflexive, which means that `TryFrom<T> for T`\n /// is implemented and cannot fail -- the associated `Error` type for\n /// calling `T::try_from()` on a value of type `T` is [`Infallible`].\n /// When the [`!`] type is stabilized [`Infallible`] and [`!`] will be\n@@ -467,7 +468,7 @@ pub trait TryInto<T>: Sized {\n /// assert!(try_successful_smaller_number.is_ok());\n /// ```\n ///\n-/// [`i32::MAX`]: crate::i32::MAX\n+/// [`try_from`]: TryFrom::try_from\n /// [`!`]: ../../std/primitive.never.html\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n pub trait TryFrom<T>: Sized {\n@@ -670,8 +671,6 @@ impl AsRef<str> for str {\n /// the two `impl`s will start to overlap\n /// and therefore will be disallowed by the language\u2019s trait coherence rules.\n ///\n-/// [`Ok`]: super::result::Result::Ok\n-/// [`Result`]: super::result::Result\n /// [never]: ../../std/primitive.never.html\n #[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n #[derive(Copy)]"}, {"sha": "e482eab5b3de25aea3a2a1df05866602db995eeb", "filename": "library/core/src/iter/mod.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/01d95f241bfe4c4c1550beaf81b7c7df007696a9/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d95f241bfe4c4c1550beaf81b7c7df007696a9/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs?ref=01d95f241bfe4c4c1550beaf81b7c7df007696a9", "patch": "@@ -152,11 +152,13 @@\n //! produce an iterator. What gives?\n //!\n //! There's a trait in the standard library for converting something into an\n-//! iterator: [`IntoIterator`]. This trait has one method, [`IntoIterator::into_iter`],\n+//! iterator: [`IntoIterator`]. This trait has one method, [`into_iter`],\n //! which converts the thing implementing [`IntoIterator`] into an iterator.\n //! Let's take a look at that `for` loop again, and what the compiler converts\n //! it into:\n //!\n+//! [`into_iter`]: IntoIterator::into_iter\n+//!\n //! ```\n //! let values = vec![1, 2, 3, 4, 5];\n //!\n@@ -209,20 +211,24 @@\n //! often called 'iterator adapters', as they're a form of the 'adapter\n //! pattern'.\n //!\n-//! Common iterator adapters include [`Iterator::map`], [`Iterator::take`], and [`Iterator::filter`].\n+//! Common iterator adapters include [`map`], [`take`], and [`filter`].\n //! For more, see their documentation.\n //!\n //! If an iterator adapter panics, the iterator will be in an unspecified (but\n //! memory safe) state.  This state is also not guaranteed to stay the same\n //! across versions of Rust, so you should avoid relying on the exact values\n //! returned by an iterator which panicked.\n //!\n+//! [`map`]: Iterator::map\n+//! [`take`]: Iterator::take\n+//! [`filter`]: Iterator::filter\n+//!\n //! # Laziness\n //!\n //! Iterators (and iterator [adapters](#adapters)) are *lazy*. This means that\n //! just creating an iterator doesn't _do_ a whole lot. Nothing really happens\n //! until you call [`next`]. This is sometimes a source of confusion when\n-//! creating an iterator solely for its side effects. For example, the [`Iterator::map`]\n+//! creating an iterator solely for its side effects. For example, the [`map`]\n //! method calls a closure on each element it iterates over:\n //!\n //! ```\n@@ -239,8 +245,8 @@\n //! do nothing unless consumed\n //! ```\n //!\n-//! The idiomatic way to write a [`Iterator::map`] for its side effects is to use a\n-//! `for` loop or call the [`Iterator::for_each`] method:\n+//! The idiomatic way to write a [`map`] for its side effects is to use a\n+//! `for` loop or call the [`for_each`] method:\n //!\n //! ```\n //! let v = vec![1, 2, 3, 4, 5];\n@@ -252,9 +258,14 @@\n //! }\n //! ```\n //!\n-//! Another common way to evaluate an iterator is to use the [`Iterator::collect`]\n+//! [`map`]: Iterator::map\n+//! [`for_each`]: Iterator::for_each\n+//!\n+//! Another common way to evaluate an iterator is to use the [`collect`]\n //! method to produce a new collection.\n //!\n+//! [`collect`]: Iterator::collect\n+//!\n //! # Infinity\n //!\n //! Iterators do not have to be finite. As an example, an open-ended range is\n@@ -264,7 +275,7 @@\n //! let numbers = 0..;\n //! ```\n //!\n-//! It is common to use the [`Iterator::take`] iterator adapter to turn an infinite\n+//! It is common to use the [`take`] iterator adapter to turn an infinite\n //! iterator into a finite one:\n //!\n //! ```\n@@ -280,7 +291,7 @@\n //!\n //! Bear in mind that methods on infinite iterators, even those for which a\n //! result can be determined mathematically in finite time, may not terminate.\n-//! Specifically, methods such as [`Iterator::min`], which in the general case require\n+//! Specifically, methods such as [`min`], which in the general case require\n //! traversing every element in the iterator, are likely not to return\n //! successfully for any infinite iterators.\n //!\n@@ -290,6 +301,9 @@\n //! // `ones.min()` causes an infinite loop, so we won't reach this point!\n //! println!(\"The smallest number one is {}.\", least);\n //! ```\n+//!\n+//! [`take`]: Iterator::take\n+//! [`min`]: Iterator::min\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}]}