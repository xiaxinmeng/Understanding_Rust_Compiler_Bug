{"sha": "6cdf31b12f0e84b42f7b47c363f4c1b8aaafc318", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjZGYzMWIxMmYwZTg0YjQyZjdiNDdjMzYzZjRjMWI4YWFhZmMzMTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-15T21:21:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-15T21:21:27Z"}, "message": "Auto merge of #29031 - cristicbz:mtx_inner, r=alexcrichton\n\nThe implementation for `into_inner` was a bit more complex than I had hoped for---is there any simpler, less unsafe way of getting around the fact that one can't move out of a `Drop` struct?\r\n\r\nSee #28968 and rust-lang/rfcs#1269 .", "tree": {"sha": "4eb986fd121fab77b9bae5cfc68ca9c159dd7443", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4eb986fd121fab77b9bae5cfc68ca9c159dd7443"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6cdf31b12f0e84b42f7b47c363f4c1b8aaafc318", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6cdf31b12f0e84b42f7b47c363f4c1b8aaafc318", "html_url": "https://github.com/rust-lang/rust/commit/6cdf31b12f0e84b42f7b47c363f4c1b8aaafc318", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6cdf31b12f0e84b42f7b47c363f4c1b8aaafc318/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be3d390cf51545b880c5cd78585fa408c087f786", "url": "https://api.github.com/repos/rust-lang/rust/commits/be3d390cf51545b880c5cd78585fa408c087f786", "html_url": "https://github.com/rust-lang/rust/commit/be3d390cf51545b880c5cd78585fa408c087f786"}, {"sha": "90ccefd16e1eeec1a616aa3ba9aa710d954231ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/90ccefd16e1eeec1a616aa3ba9aa710d954231ef", "html_url": "https://github.com/rust-lang/rust/commit/90ccefd16e1eeec1a616aa3ba9aa710d954231ef"}], "stats": {"total": 233, "additions": 233, "deletions": 0}, "files": [{"sha": "aabc06b1986f5d1de6d822030f9f3d8c55528863", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/6cdf31b12f0e84b42f7b47c363f4c1b8aaafc318/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cdf31b12f0e84b42f7b47c363f4c1b8aaafc318/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=6cdf31b12f0e84b42f7b47c363f4c1b8aaafc318", "patch": "@@ -13,7 +13,9 @@ use prelude::v1::*;\n use cell::UnsafeCell;\n use fmt;\n use marker;\n+use mem;\n use ops::{Deref, DerefMut};\n+use ptr;\n use sys_common::mutex as sys;\n use sys_common::poison::{self, TryLockError, TryLockResult, LockResult};\n \n@@ -243,6 +245,50 @@ impl<T: ?Sized> Mutex<T> {\n     pub fn is_poisoned(&self) -> bool {\n         self.inner.poison.get()\n     }\n+\n+    /// Consumes this mutex, returning the underlying data.\n+    ///\n+    /// # Failure\n+    ///\n+    /// If another user of this mutex panicked while holding the mutex, then\n+    /// this call will return an error instead.\n+    #[unstable(feature = \"mutex_into_inner\", reason = \"recently added\", issue = \"28968\")]\n+    pub fn into_inner(self) -> LockResult<T> where T: Sized {\n+        // We know statically that there are no outstanding references to\n+        // `self` so there's no need to lock the inner StaticMutex.\n+        //\n+        // To get the inner value, we'd like to call `data.into_inner()`,\n+        // but because `Mutex` impl-s `Drop`, we can't move out of it, so\n+        // we'll have to destructure it manually instead.\n+        unsafe {\n+            // Like `let Mutex { inner, data } = self`.\n+            let (inner, data) = {\n+                let Mutex { ref inner, ref data } = self;\n+                (ptr::read(inner), ptr::read(data))\n+            };\n+            mem::forget(self);\n+            inner.lock.destroy();  // Keep in sync with the `Drop` impl.\n+\n+            poison::map_result(inner.poison.borrow(), |_| data.into_inner())\n+        }\n+    }\n+\n+    /// Returns a mutable reference to the underlying data.\n+    ///\n+    /// Since this call borrows the `Mutex` mutably, no actual locking needs to\n+    /// take place---the mutable borrow statically guarantees no locks exist.\n+    ///\n+    /// # Failure\n+    ///\n+    /// If another user of this mutex panicked while holding the mutex, then\n+    /// this call will return an error instead.\n+    #[unstable(feature = \"mutex_get_mut\", reason = \"recently added\", issue = \"28968\")]\n+    pub fn get_mut(&mut self) -> LockResult<&mut T> {\n+        // We know statically that there are no other references to `self`, so\n+        // there's no need to lock the inner StaticMutex.\n+        let data = unsafe { &mut *self.data.get() };\n+        poison::map_result(self.inner.poison.borrow(), |_| data )\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -251,6 +297,8 @@ impl<T: ?Sized> Drop for Mutex<T> {\n         // This is actually safe b/c we know that there is no further usage of\n         // this mutex (it's up to the user to arrange for a mutex to get\n         // dropped, that's not our job)\n+        //\n+        // IMPORTANT: This code must be kept in sync with `Mutex::into_inner`.\n         unsafe { self.inner.lock.destroy() }\n     }\n }\n@@ -371,10 +419,14 @@ mod tests {\n \n     use sync::mpsc::channel;\n     use sync::{Arc, Mutex, StaticMutex, Condvar};\n+    use sync::atomic::{AtomicUsize, Ordering};\n     use thread;\n \n     struct Packet<T>(Arc<(Mutex<T>, Condvar)>);\n \n+    #[derive(Eq, PartialEq, Debug)]\n+    struct NonCopy(i32);\n+\n     unsafe impl<T: Send> Send for Packet<T> {}\n     unsafe impl<T> Sync for Packet<T> {}\n \n@@ -435,6 +487,69 @@ mod tests {\n         *m.try_lock().unwrap() = ();\n     }\n \n+    #[test]\n+    fn test_into_inner() {\n+        let m = Mutex::new(NonCopy(10));\n+        assert_eq!(m.into_inner().unwrap(), NonCopy(10));\n+    }\n+\n+    #[test]\n+    fn test_into_inner_drop() {\n+        struct Foo(Arc<AtomicUsize>);\n+        impl Drop for Foo {\n+            fn drop(&mut self) {\n+                self.0.fetch_add(1, Ordering::SeqCst);\n+            }\n+        }\n+        let num_drops = Arc::new(AtomicUsize::new(0));\n+        let m = Mutex::new(Foo(num_drops.clone()));\n+        assert_eq!(num_drops.load(Ordering::SeqCst), 0);\n+        {\n+            let _inner = m.into_inner().unwrap();\n+            assert_eq!(num_drops.load(Ordering::SeqCst), 0);\n+        }\n+        assert_eq!(num_drops.load(Ordering::SeqCst), 1);\n+    }\n+\n+    #[test]\n+    fn test_into_inner_poison() {\n+        let m = Arc::new(Mutex::new(NonCopy(10)));\n+        let m2 = m.clone();\n+        let _ = thread::spawn(move || {\n+            let _lock = m2.lock().unwrap();\n+            panic!(\"test panic in inner thread to poison mutex\");\n+        }).join();\n+\n+        assert!(m.is_poisoned());\n+        match Arc::try_unwrap(m).unwrap().into_inner() {\n+            Err(e) => assert_eq!(e.into_inner(), NonCopy(10)),\n+            Ok(x) => panic!(\"into_inner of poisoned Mutex is Ok: {:?}\", x),\n+        }\n+    }\n+\n+    #[test]\n+    fn test_get_mut() {\n+        let mut m = Mutex::new(NonCopy(10));\n+        *m.get_mut().unwrap() = NonCopy(20);\n+        assert_eq!(m.into_inner().unwrap(), NonCopy(20));\n+    }\n+\n+    #[test]\n+    fn test_get_mut_poison() {\n+        let m = Arc::new(Mutex::new(NonCopy(10)));\n+        let m2 = m.clone();\n+        let _ = thread::spawn(move || {\n+            let _lock = m2.lock().unwrap();\n+            panic!(\"test panic in inner thread to poison mutex\");\n+        }).join();\n+\n+        assert!(m.is_poisoned());\n+        match Arc::try_unwrap(m).unwrap().get_mut() {\n+            Err(e) => assert_eq!(*e.into_inner(), NonCopy(10)),\n+            Ok(x) => panic!(\"get_mut of poisoned Mutex is Ok: {:?}\", x),\n+        }\n+    }\n+\n     #[test]\n     fn test_mutex_arc_condvar() {\n         let packet = Packet(Arc::new((Mutex::new(false), Condvar::new())));"}, {"sha": "9278481f2d62b194f715329b0b7164810a98e4f5", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/6cdf31b12f0e84b42f7b47c363f4c1b8aaafc318/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cdf31b12f0e84b42f7b47c363f4c1b8aaafc318/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=6cdf31b12f0e84b42f7b47c363f4c1b8aaafc318", "patch": "@@ -13,7 +13,9 @@ use prelude::v1::*;\n use cell::UnsafeCell;\n use fmt;\n use marker;\n+use mem;\n use ops::{Deref, DerefMut};\n+use ptr;\n use sys_common::poison::{self, LockResult, TryLockError, TryLockResult};\n use sys_common::rwlock as sys;\n \n@@ -260,11 +262,60 @@ impl<T: ?Sized> RwLock<T> {\n     pub fn is_poisoned(&self) -> bool {\n         self.inner.poison.get()\n     }\n+\n+    /// Consumes this `RwLock`, returning the underlying data.\n+    ///\n+    /// # Failure\n+    ///\n+    /// This function will return an error if the RwLock is poisoned. An RwLock\n+    /// is poisoned whenever a writer panics while holding an exclusive lock. An\n+    /// error will only be returned if the lock would have otherwise been\n+    /// acquired.\n+    #[unstable(feature = \"rwlock_into_inner\", reason = \"recently added\", issue = \"28968\")]\n+    pub fn into_inner(self) -> LockResult<T> where T: Sized {\n+        // We know statically that there are no outstanding references to\n+        // `self` so there's no need to lock the inner StaticRwLock.\n+        //\n+        // To get the inner value, we'd like to call `data.into_inner()`,\n+        // but because `RwLock` impl-s `Drop`, we can't move out of it, so\n+        // we'll have to destructure it manually instead.\n+        unsafe {\n+            // Like `let RwLock { inner, data } = self`.\n+            let (inner, data) = {\n+                let RwLock { ref inner, ref data } = self;\n+                (ptr::read(inner), ptr::read(data))\n+            };\n+            mem::forget(self);\n+            inner.lock.destroy();  // Keep in sync with the `Drop` impl.\n+\n+            poison::map_result(inner.poison.borrow(), |_| data.into_inner())\n+        }\n+    }\n+\n+    /// Returns a mutable reference to the underlying data.\n+    ///\n+    /// Since this call borrows the `RwLock` mutably, no actual locking needs to\n+    /// take place---the mutable borrow statically guarantees no locks exist.\n+    ///\n+    /// # Failure\n+    ///\n+    /// This function will return an error if the RwLock is poisoned. An RwLock\n+    /// is poisoned whenever a writer panics while holding an exclusive lock. An\n+    /// error will only be returned if the lock would have otherwise been\n+    /// acquired.\n+    #[unstable(feature = \"rwlock_get_mut\", reason = \"recently added\", issue = \"28968\")]\n+    pub fn get_mut(&mut self) -> LockResult<&mut T> {\n+        // We know statically that there are no other references to `self`, so\n+        // there's no need to lock the inner StaticRwLock.\n+        let data = unsafe { &mut *self.data.get() };\n+        poison::map_result(self.inner.poison.borrow(), |_| data )\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Drop for RwLock<T> {\n     fn drop(&mut self) {\n+        // IMPORTANT: This code needs to be kept in sync with `RwLock::into_inner`.\n         unsafe { self.inner.lock.destroy() }\n     }\n }\n@@ -426,6 +477,10 @@ mod tests {\n     use sync::mpsc::channel;\n     use thread;\n     use sync::{Arc, RwLock, StaticRwLock, TryLockError};\n+    use sync::atomic::{AtomicUsize, Ordering};\n+\n+    #[derive(Eq, PartialEq, Debug)]\n+    struct NonCopy(i32);\n \n     #[test]\n     fn smoke() {\n@@ -606,4 +661,67 @@ mod tests {\n \n         drop(read_guard);\n     }\n+\n+    #[test]\n+    fn test_into_inner() {\n+        let m = RwLock::new(NonCopy(10));\n+        assert_eq!(m.into_inner().unwrap(), NonCopy(10));\n+    }\n+\n+    #[test]\n+    fn test_into_inner_drop() {\n+        struct Foo(Arc<AtomicUsize>);\n+        impl Drop for Foo {\n+            fn drop(&mut self) {\n+                self.0.fetch_add(1, Ordering::SeqCst);\n+            }\n+        }\n+        let num_drops = Arc::new(AtomicUsize::new(0));\n+        let m = RwLock::new(Foo(num_drops.clone()));\n+        assert_eq!(num_drops.load(Ordering::SeqCst), 0);\n+        {\n+            let _inner = m.into_inner().unwrap();\n+            assert_eq!(num_drops.load(Ordering::SeqCst), 0);\n+        }\n+        assert_eq!(num_drops.load(Ordering::SeqCst), 1);\n+    }\n+\n+    #[test]\n+    fn test_into_inner_poison() {\n+        let m = Arc::new(RwLock::new(NonCopy(10)));\n+        let m2 = m.clone();\n+        let _ = thread::spawn(move || {\n+            let _lock = m2.write().unwrap();\n+            panic!(\"test panic in inner thread to poison RwLock\");\n+        }).join();\n+\n+        assert!(m.is_poisoned());\n+        match Arc::try_unwrap(m).unwrap().into_inner() {\n+            Err(e) => assert_eq!(e.into_inner(), NonCopy(10)),\n+            Ok(x) => panic!(\"into_inner of poisoned RwLock is Ok: {:?}\", x),\n+        }\n+    }\n+\n+    #[test]\n+    fn test_get_mut() {\n+        let mut m = RwLock::new(NonCopy(10));\n+        *m.get_mut().unwrap() = NonCopy(20);\n+        assert_eq!(m.into_inner().unwrap(), NonCopy(20));\n+    }\n+\n+    #[test]\n+    fn test_get_mut_poison() {\n+        let m = Arc::new(RwLock::new(NonCopy(10)));\n+        let m2 = m.clone();\n+        let _ = thread::spawn(move || {\n+            let _lock = m2.write().unwrap();\n+            panic!(\"test panic in inner thread to poison RwLock\");\n+        }).join();\n+\n+        assert!(m.is_poisoned());\n+        match Arc::try_unwrap(m).unwrap().get_mut() {\n+            Err(e) => assert_eq!(*e.into_inner(), NonCopy(10)),\n+            Ok(x) => panic!(\"get_mut of poisoned RwLock is Ok: {:?}\", x),\n+        }\n+    }\n }"}]}