{"sha": "fd625dda9a25c054d622e20822f2889f17b15aa6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkNjI1ZGRhOWEyNWMwNTRkNjIyZTIwODIyZjI4ODlmMTdiMTVhYTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-05T17:06:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-05T17:06:39Z"}, "message": "auto merge of #13271 : stepancheg/rust/align, r=pcwalton\n\nThis patch fixes issue #13186.\r\n\r\nWhen generating constant expression for enum, it is possible that\r\nalignment of expression may be not equal to alignment of type.  In that\r\ncase space after last struct field must be padded to match size of value\r\nand size of struct. This commit adds that padding.\r\n\r\nSee detailed explanation in src/test/run-pass/trans-tag-static-padding.rs", "tree": {"sha": "d2c6aed0d2214322f5ee55392c609e7d46ff2da6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2c6aed0d2214322f5ee55392c609e7d46ff2da6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd625dda9a25c054d622e20822f2889f17b15aa6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd625dda9a25c054d622e20822f2889f17b15aa6", "html_url": "https://github.com/rust-lang/rust/commit/fd625dda9a25c054d622e20822f2889f17b15aa6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd625dda9a25c054d622e20822f2889f17b15aa6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2be738ae36600e562fcfc9ed938e183875cd72ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/2be738ae36600e562fcfc9ed938e183875cd72ad", "html_url": "https://github.com/rust-lang/rust/commit/2be738ae36600e562fcfc9ed938e183875cd72ad"}, {"sha": "7fefc1c7f417a8445da85e57a9523508a2561ef3", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fefc1c7f417a8445da85e57a9523508a2561ef3", "html_url": "https://github.com/rust-lang/rust/commit/7fefc1c7f417a8445da85e57a9523508a2561ef3"}], "stats": {"total": 116, "additions": 104, "deletions": 12}, "files": [{"sha": "ca183e1401227e70bbcd721ff3a96e8219b6124f", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 38, "deletions": 12, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/fd625dda9a25c054d622e20822f2889f17b15aa6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd625dda9a25c054d622e20822f2889f17b15aa6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=fd625dda9a25c054d622e20822f2889f17b15aa6", "patch": "@@ -779,6 +779,26 @@ pub fn trans_const(ccx: &CrateContext, r: &Repr, discr: Disr,\n     }\n }\n \n+/**\n+ * Compute struct field offsets relative to struct begin.\n+ */\n+fn compute_struct_field_offsets(ccx: &CrateContext, st: &Struct) -> Vec<u64> {\n+    let mut offsets = vec!();\n+\n+    let mut offset = 0;\n+    for &ty in st.fields.iter() {\n+        let llty = type_of::sizing_type_of(ccx, ty);\n+        if !st.packed {\n+            let type_align = machine::llalign_of_min(ccx, llty) as u64;\n+            offset = roundup(offset, type_align);\n+        }\n+        offsets.push(offset);\n+        offset += machine::llsize_of_alloc(ccx, llty) as u64;\n+    }\n+    assert_eq!(st.fields.len(), offsets.len());\n+    offsets\n+}\n+\n /**\n  * Building structs is a little complicated, because we might need to\n  * insert padding if a field's value is less aligned than its type.\n@@ -793,26 +813,32 @@ fn build_const_struct(ccx: &CrateContext, st: &Struct, vals: &[ValueRef])\n     -> Vec<ValueRef> {\n     assert_eq!(vals.len(), st.fields.len());\n \n+    let target_offsets = compute_struct_field_offsets(ccx, st);\n+\n+    // offset of current value\n     let mut offset = 0;\n     let mut cfields = Vec::new();\n-    for (i, &ty) in st.fields.iter().enumerate() {\n-        let llty = type_of::sizing_type_of(ccx, ty);\n-        let type_align = machine::llalign_of_min(ccx, llty)\n-            /*bad*/as u64;\n-        let val_align = machine::llalign_of_min(ccx, val_ty(vals[i]))\n-            /*bad*/as u64;\n-        let target_offset = roundup(offset, type_align);\n-        offset = roundup(offset, val_align);\n+    for (&val, &target_offset) in vals.iter().zip(target_offsets.iter()) {\n+        if !st.packed {\n+            let val_align = machine::llalign_of_min(ccx, val_ty(val))\n+                /*bad*/as u64;\n+            offset = roundup(offset, val_align);\n+        }\n         if offset != target_offset {\n             cfields.push(padding(ccx, target_offset - offset));\n             offset = target_offset;\n         }\n-        assert!(!is_undef(vals[i]));\n-        cfields.push(vals[i]);\n-        offset += machine::llsize_of_alloc(ccx, llty) as u64\n+        assert!(!is_undef(val));\n+        cfields.push(val);\n+        offset += machine::llsize_of_alloc(ccx, val_ty(val)) as u64;\n+    }\n+\n+    assert!(offset <= st.size);\n+    if offset != st.size {\n+        cfields.push(padding(ccx, st.size - offset));\n     }\n \n-    return cfields;\n+    cfields\n }\n \n fn padding(ccx: &CrateContext, size: u64) -> ValueRef {"}, {"sha": "c6a3a0b0409aa76ff8b3bf259c8d584905e6f03f", "filename": "src/test/run-pass/trans-tag-static-padding.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/fd625dda9a25c054d622e20822f2889f17b15aa6/src%2Ftest%2Frun-pass%2Ftrans-tag-static-padding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd625dda9a25c054d622e20822f2889f17b15aa6/src%2Ftest%2Frun-pass%2Ftrans-tag-static-padding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrans-tag-static-padding.rs?ref=fd625dda9a25c054d622e20822f2889f17b15aa6", "patch": "@@ -0,0 +1,66 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// Issue #13186\n+\n+// For simplicity of explanations assuming code is compiled for x86_64\n+// Linux ABI.\n+\n+// Size of TestOption<u64> is 16, and alignment of TestOption<u64> is 8.\n+// Size of u8 is 1, and alignment of u8 is 1.\n+// So size of Request is 24, and alignment of Request must be 8:\n+// the maximum alignment of its fields.\n+// Last 7 bytes of Request struct are not occupied by any fields.\n+\n+\n+enum TestOption<T> {\n+    TestNone,\n+    TestSome(T),\n+}\n+\n+pub struct Request {\n+    foo: TestOption<u64>,\n+    bar: u8,\n+}\n+\n+fn default_instance() -> &'static Request {\n+    static instance: Request = Request {\n+        // LLVM does not allow to specify alignment of expressions, thus\n+        // alignment of `foo` in constant is 1, not 8.\n+        foo: TestNone,\n+        bar: 17,\n+        // Space after last field is not occupied by any data, but it is\n+        // reserved to make struct aligned properly. If compiler does\n+        // not insert padding after last field when emitting constant,\n+        // size of struct may be not equal to size of struct, and\n+        // compiler crashes in internal assertion check.\n+    };\n+    &'static instance\n+}\n+\n+fn non_default_instance() -> &'static Request {\n+    static instance: Request = Request {\n+        foo: TestSome(0x1020304050607080),\n+        bar: 19,\n+    };\n+    &'static instance\n+}\n+\n+pub fn main() {\n+    match default_instance() {\n+        &Request { foo: TestNone, bar: 17 } => {},\n+        _ => fail!(),\n+    };\n+    match non_default_instance() {\n+        &Request { foo: TestSome(0x1020304050607080), bar: 19 } => {},\n+        _ => fail!(),\n+    };\n+}"}]}