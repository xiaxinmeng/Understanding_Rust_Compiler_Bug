{"sha": "83c6a12a54f6f9690cb4e1776483d108f653d24a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzYzZhMTJhNTRmNmY5NjkwY2I0ZTE3NzY0ODNkMTA4ZjY1M2QyNGE=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-05-10T20:35:08Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-05-14T10:05:52Z"}, "message": "save-analysis: start factoring out an API", "tree": {"sha": "e3dc2d95e53a912325b1580375b212eed1f6283f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3dc2d95e53a912325b1580375b212eed1f6283f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83c6a12a54f6f9690cb4e1776483d108f653d24a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83c6a12a54f6f9690cb4e1776483d108f653d24a", "html_url": "https://github.com/rust-lang/rust/commit/83c6a12a54f6f9690cb4e1776483d108f653d24a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83c6a12a54f6f9690cb4e1776483d108f653d24a/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8ddb0f070db3bebfdc4f581cee1dc212a86bb80", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8ddb0f070db3bebfdc4f581cee1dc212a86bb80", "html_url": "https://github.com/rust-lang/rust/commit/c8ddb0f070db3bebfdc4f581cee1dc212a86bb80"}], "stats": {"total": 198, "additions": 129, "deletions": 69}, "files": [{"sha": "7f66d3a833fde3e8fa4b31646902116ad3c690f7", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 49, "deletions": 50, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/83c6a12a54f6f9690cb4e1776483d108f653d24a/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c6a12a54f6f9690cb4e1776483d108f653d24a/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=83c6a12a54f6f9690cb4e1776483d108f653d24a", "patch": "@@ -89,7 +89,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                                 sess: sess,\n                                 err_count: Cell::new(0)\n                             }),\n-            cur_scope: 0            \n+            cur_scope: 0\n         }\n     }\n \n@@ -108,7 +108,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n \n         // Dump info about all the external crates referenced from this crate.\n         for c in &self.save_ctxt.get_external_crates() {\n-            self.fmt.external_crate_str(krate.span, &c.name, c.number);            \n+            self.fmt.external_crate_str(krate.span, &c.name, c.number);\n         }\n         self.fmt.recorder.record(\"end_external_crates\\n\");\n     }\n@@ -496,58 +496,52 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                   decl: &ast::FnDecl,\n                   ty_params: &ast::Generics,\n                   body: &ast::Block) {\n-        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+        let fn_data = self.save_ctxt.get_item_data(item);\n+        if let super::Data::FunctionData(fn_data) = fn_data {\n+            self.fmt.fn_str(item.span,\n+                            Some(fn_data.span),\n+                            fn_data.id,\n+                            &fn_data.qualname,\n+                            fn_data.scope);\n \n-        let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Fn);\n-        self.fmt.fn_str(item.span,\n-                        sub_span,\n-                        item.id,\n-                        &qualname[..],\n-                        self.cur_scope);\n \n-        self.process_formals(&decl.inputs, &qualname[..]);\n+            self.process_formals(&decl.inputs, &fn_data.qualname);\n+            self.process_generic_params(ty_params, item.span, &fn_data.qualname, item.id);\n+        } else {\n+            unreachable!();\n+        }\n \n-        // walk arg and return types\n         for arg in &decl.inputs {\n-            self.visit_ty(&*arg.ty);\n+            self.visit_ty(&arg.ty);\n         }\n \n         if let ast::Return(ref ret_ty) = decl.output {\n-            self.visit_ty(&**ret_ty);\n+            self.visit_ty(&ret_ty);\n         }\n \n-        // walk the body\n-        self.nest(item.id, |v| v.visit_block(&*body));\n-\n-        self.process_generic_params(ty_params, item.span, &qualname[..], item.id);\n+        self.nest(item.id, |v| v.visit_block(&body));\n     }\n \n-    fn process_static(&mut self,\n-                      item: &ast::Item,\n-                      typ: &ast::Ty,\n-                      mt: ast::Mutability,\n-                      expr: &ast::Expr)\n+    fn process_static_or_const_item(&mut self,\n+                                    item: &ast::Item,\n+                                    typ: &ast::Ty,\n+                                    expr: &ast::Expr)\n     {\n-        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n-\n-        // If the variable is immutable, save the initialising expression.\n-        let (value, keyword) = match mt {\n-            ast::MutMutable => (String::from_str(\"<mutable>\"), keywords::Mut),\n-            ast::MutImmutable => (self.span.snippet(expr.span), keywords::Static),\n-        };\n-\n-        let sub_span = self.span.sub_span_after_keyword(item.span, keyword);\n-        self.fmt.static_str(item.span,\n-                            sub_span,\n-                            item.id,\n-                            &get_ident(item.ident),\n-                            &qualname[..],\n-                            &value[..],\n-                            &ty_to_string(&*typ),\n-                            self.cur_scope);\n+        let var_data = self.save_ctxt.get_item_data(item);\n+        if let super::Data::VariableData(var_data) = var_data {\n+            self.fmt.static_str(item.span,\n+                                Some(var_data.span),\n+                                var_data.id,\n+                                &var_data.name,\n+                                &var_data.qualname,\n+                                &var_data.value,\n+                                &var_data.type_value,\n+                                var_data.scope);\n+        } else {\n+            unreachable!();\n+        }\n \n-        // walk type and init value\n-        self.visit_ty(&*typ);\n+        self.visit_ty(&typ);\n         self.visit_expr(expr);\n     }\n \n@@ -562,12 +556,13 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n \n         let sub_span = self.span.sub_span_after_keyword(span,\n                                                         keywords::Const);\n+\n         self.fmt.static_str(span,\n                             sub_span,\n                             id,\n                             &get_ident((*ident).clone()),\n                             &qualname[..],\n-                            \"\",\n+                            &self.span.snippet(expr.span),\n                             &ty_to_string(&*typ),\n                             self.cur_scope);\n \n@@ -1174,10 +1169,10 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n             }\n             ast::ItemFn(ref decl, _, _, ref ty_params, ref body) =>\n                 self.process_fn(item, &**decl, ty_params, &**body),\n-            ast::ItemStatic(ref typ, mt, ref expr) =>\n-                self.process_static(item, &**typ, mt, &**expr),\n+            ast::ItemStatic(ref typ, _, ref expr) =>\n+                self.process_static_or_const_item(item, typ, expr),\n             ast::ItemConst(ref typ, ref expr) =>\n-                self.process_const(item.id, &item.ident, item.span, &*typ, &*expr),\n+                self.process_static_or_const_item(item, &typ, &expr),\n             ast::ItemStruct(ref def, ref ty_params) => self.process_struct(item, &**def, ty_params),\n             ast::ItemEnum(ref def, ref ty_params) => self.process_enum(item, def, ty_params),\n             ast::ItemImpl(_, _,\n@@ -1378,7 +1373,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n             },\n             _ => {\n                 visit::walk_expr(self, ex)\n-            },\n+            }\n         }\n     }\n \n@@ -1401,7 +1396,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n         // This is to get around borrow checking, because we need mut self to call process_path.\n         let mut paths_to_process = vec![];\n         // process collected paths\n-        for &(id, ref p, ref immut, ref_kind) in &collector.collected_paths {\n+        for &(id, ref p, immut, ref_kind) in &collector.collected_paths {\n             let def_map = self.analysis.ty_cx.def_map.borrow();\n             if !def_map.contains_key(&id) {\n                 self.sess.span_bug(p.span,\n@@ -1411,7 +1406,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n             let def = def_map.get(&id).unwrap().full_def();\n             match def {\n                 def::DefLocal(id)  => {\n-                    let value = if *immut {\n+                    let value = if immut == ast::MutImmutable {\n                         self.span.snippet(p.span).to_string()\n                     } else {\n                         \"<mutable>\".to_string()\n@@ -1464,8 +1459,12 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n \n         let value = self.span.snippet(l.span);\n \n-        for &(id, ref p, ref immut, _) in &collector.collected_paths {\n-            let value = if *immut { value.to_string() } else { \"<mutable>\".to_string() };\n+        for &(id, ref p, immut, _) in &collector.collected_paths {\n+            let value = if immut == ast::MutImmutable {\n+                value.to_string()\n+            } else {\n+                \"<mutable>\".to_string()\n+            };\n             let types = self.analysis.ty_cx.node_types();\n             let typ = ppaux::ty_to_string(&self.analysis.ty_cx, *types.get(&id).unwrap());\n             // Get the span only for the name of the variable (I hope the path"}, {"sha": "7e503c6819ba1e3ea9ebeca23773a4c0277e54ed", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 77, "deletions": 19, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/83c6a12a54f6f9690cb4e1776483d108f653d24a/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c6a12a54f6f9690cb4e1776483d108f653d24a/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=83c6a12a54f6f9690cb4e1776483d108f653d24a", "patch": "@@ -19,8 +19,10 @@ use syntax::{attr};\n use syntax::ast::{self, NodeId, DefId};\n use syntax::ast_util;\n use syntax::codemap::*;\n-use syntax::parse::token::keywords;\n+use syntax::parse::token::{self, get_ident, keywords};\n use syntax::visit::{self, Visitor};\n+use syntax::print::pprust::ty_to_string;\n+\n \n use self::span_utils::SpanUtils;\n \n@@ -40,18 +42,32 @@ pub struct CrateData {\n     pub number: u32,\n }\n \n+// Data for any entity in the Rust language. The actual data contained varied\n+// with the kind of entity being queried. See the nested structs for details.\n pub enum Data {\n     FunctionData(FunctionData),\n+    VariableData(VariableData),\n }\n \n pub struct FunctionData {\n     pub id: NodeId,\n+    pub name: String,\n     pub qualname: String,\n     pub declaration: Option<DefId>,\n     pub span: Span,\n     pub scope: NodeId,\n }\n \n+pub struct VariableData {\n+    pub id: NodeId,\n+    pub name: String,\n+    pub qualname: String,\n+    pub span: Span,\n+    pub scope: NodeId,\n+    pub value: String,\n+    pub type_value: String,\n+}\n+\n impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     pub fn new(sess: &'l Session,\n                analysis: &'l ty::CrateAnalysis<'tcx>,\n@@ -78,35 +94,71 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     pub fn get_item_data(&self, item: &ast::Item) -> Data {\n         match item.node {\n             ast::Item_::ItemFn(..) => {\n-                let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+                let name = self.analysis.ty_cx.map.path_to_string(item.id);\n+                let qualname = format!(\"::{}\", name);\n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Fn);\n \n                 Data::FunctionData(FunctionData {\n                     id: item.id,\n+                    name: name,\n                     qualname: qualname,\n                     declaration: None,\n                     span: sub_span.unwrap(),\n                     scope: self.analysis.ty_cx.map.get_parent(item.id),\n                 })\n             }\n+            ast::ItemStatic(ref typ, mt, ref expr) => {\n+                let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+\n+                // If the variable is immutable, save the initialising expression.\n+                let value = match mt {\n+                    ast::MutMutable => String::from_str(\"<mutable>\"),\n+                    ast::MutImmutable => self.span_utils.snippet(expr.span),\n+                };\n+\n+                let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Static);\n+\n+                Data::VariableData(VariableData {\n+                    id: item.id,\n+                    name: get_ident(item.ident).to_string(),\n+                    qualname: qualname,\n+                    span: sub_span.unwrap(),\n+                    scope: self.analysis.ty_cx.map.get_parent(item.id),\n+                    value: value,\n+                    type_value: ty_to_string(&typ),\n+                })\n+            }\n+            ast::ItemConst(ref typ, ref expr) => {\n+                let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+                let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Const);\n+\n+                Data::VariableData(VariableData {\n+                    id: item.id,\n+                    name: get_ident(item.ident).to_string(),\n+                    qualname: qualname,\n+                    span: sub_span.unwrap(),\n+                    scope: self.analysis.ty_cx.map.get_parent(item.id),\n+                    value: self.span_utils.snippet(expr.span),\n+                    type_value: ty_to_string(&typ),\n+                })\n+            }\n             _ => {\n+                // FIXME\n                 unimplemented!();\n             }\n         }\n     }\n \n-    pub fn get_data_for_id(&self, id: &NodeId) -> Data {\n-        // TODO\n-        unimplemented!();        \n+    pub fn get_data_for_id(&self, _id: &NodeId) -> Data {\n+        // FIXME\n+        unimplemented!();\n     }\n }\n \n // An AST visitor for collecting paths from patterns.\n struct PathCollector {\n-    // TODO bool -> ast::mutable\n-    // TODO recorder -> var kind new enum\n-    // The Row field identifies the kind of formal variable.\n-    collected_paths: Vec<(NodeId, ast::Path, bool, recorder::Row)>,\n+    // The Row field identifies the kind of pattern.\n+    collected_paths: Vec<(NodeId, ast::Path, ast::Mutability, recorder::Row)>,\n }\n \n impl PathCollector {\n@@ -119,29 +171,35 @@ impl PathCollector {\n \n impl<'v> Visitor<'v> for PathCollector {\n     fn visit_pat(&mut self, p: &ast::Pat) {\n+        if generated_code(p.span) {\n+            return;\n+        }\n+\n         match p.node {\n             ast::PatStruct(ref path, _, _) => {\n-                self.collected_paths.push((p.id, path.clone(), false, recorder::StructRef));\n+                self.collected_paths.push((p.id,\n+                                           path.clone(),\n+                                           ast::MutMutable,\n+                                           recorder::StructRef));\n             }\n             ast::PatEnum(ref path, _) |\n             ast::PatQPath(_, ref path) => {\n-                self.collected_paths.push((p.id, path.clone(), false, recorder::VarRef));\n+                self.collected_paths.push((p.id, path.clone(), ast::MutMutable, recorder::VarRef));\n             }\n             ast::PatIdent(bm, ref path1, _) => {\n+                debug!(\"PathCollector, visit ident in pat {}: {:?} {:?}\",\n+                       token::get_ident(path1.node),\n+                       p.span,\n+                       path1.span);\n                 let immut = match bm {\n                     // Even if the ref is mut, you can't change the ref, only\n                     // the data pointed at, so showing the initialising expression\n                     // is still worthwhile.\n-                    ast::BindByRef(_) => true,\n-                    ast::BindByValue(mt) => {\n-                        match mt {\n-                            ast::MutMutable => false,\n-                            ast::MutImmutable => true,\n-                        }\n-                    }\n+                    ast::BindByRef(_) => ast::MutImmutable,\n+                    ast::BindByValue(mt) => mt,\n                 };\n                 // collect path for either visit_local or visit_arm\n-                let path = ast_util::ident_to_path(path1.span,path1.node);\n+                let path = ast_util::ident_to_path(path1.span, path1.node);\n                 self.collected_paths.push((p.id, path, immut, recorder::VarRef));\n             }\n             _ => {}"}, {"sha": "193902d981d690b30cf3795d6f58af419818038e", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83c6a12a54f6f9690cb4e1776483d108f653d24a/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c6a12a54f6f9690cb4e1776483d108f653d24a/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=83c6a12a54f6f9690cb4e1776483d108f653d24a", "patch": "@@ -62,6 +62,9 @@ macro_rules! svec {\n     })\n }\n \n+// FIXME recorder should operate on super::Data, rather than lots of ad hoc\n+// data.\n+\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub enum Row {\n     Variable,"}]}