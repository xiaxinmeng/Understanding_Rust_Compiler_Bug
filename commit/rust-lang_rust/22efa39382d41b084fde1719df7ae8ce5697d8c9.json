{"sha": "22efa39382d41b084fde1719df7ae8ce5697d8c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyZWZhMzkzODJkNDFiMDg0ZmRlMTcxOWRmN2FlOGNlNTY5N2Q4Yzk=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-09T00:34:16Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-09T00:43:45Z"}, "message": "Revert \"Revert \"Remove old auto_serialize2 code (needs snapshot)\"\"\n\nThis reverts commit a33535e441dc5461fec0489069a1491367ad1c91.", "tree": {"sha": "04e7f182888aac09cdf43c3cf193a652012879f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04e7f182888aac09cdf43c3cf193a652012879f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22efa39382d41b084fde1719df7ae8ce5697d8c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22efa39382d41b084fde1719df7ae8ce5697d8c9", "html_url": "https://github.com/rust-lang/rust/commit/22efa39382d41b084fde1719df7ae8ce5697d8c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22efa39382d41b084fde1719df7ae8ce5697d8c9/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48495f9f7f1fb34bf0585d9d386592c95b5284d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/48495f9f7f1fb34bf0585d9d386592c95b5284d8", "html_url": "https://github.com/rust-lang/rust/commit/48495f9f7f1fb34bf0585d9d386592c95b5284d8"}], "stats": {"total": 1257, "additions": 2, "deletions": 1255}, "files": [{"sha": "a27336097d0c935a02a403c9c635dd319d1ae143", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 170, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/22efa39382d41b084fde1719df7ae8ce5697d8c9/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22efa39382d41b084fde1719df7ae8ce5697d8c9/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=22efa39382d41b084fde1719df7ae8ce5697d8c9", "patch": "@@ -20,8 +20,6 @@ impl span: Deserializable {\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type spanned<T> = {node: T, span: span};\n \n \n@@ -78,8 +76,6 @@ type fn_ident = Option<ident>;\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type path = {span: span,\n              global: bool,\n              idents: ~[ident],\n@@ -92,8 +88,6 @@ type node_id = int;\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type def_id = {crate: crate_num, node: node_id};\n \n impl def_id : cmp::Eq {\n@@ -108,8 +102,6 @@ const crate_node_id: node_id = 0;\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum ty_param_bound {\n     bound_copy,\n     bound_send,\n@@ -120,14 +112,10 @@ enum ty_param_bound {\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type ty_param = {ident: ident, id: node_id, bounds: @~[ty_param_bound]};\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum def {\n     def_fn(def_id, purity),\n     def_static_method(def_id, purity),\n@@ -308,8 +296,6 @@ type meta_item = spanned<meta_item_>;\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum meta_item_ {\n     meta_word(~str),\n     meta_list(~str, ~[@meta_item]),\n@@ -320,8 +306,6 @@ type blk = spanned<blk_>;\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type blk_ = {view_items: ~[@view_item],\n              stmts: ~[@stmt],\n              expr: Option<@expr>,\n@@ -330,20 +314,14 @@ type blk_ = {view_items: ~[@view_item],\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type pat = {id: node_id, node: pat_, span: span};\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type field_pat = {ident: ident, pat: @pat};\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum binding_mode {\n     bind_by_value,\n     bind_by_move,\n@@ -401,8 +379,6 @@ impl binding_mode : cmp::Eq {\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum pat_ {\n     pat_wild,\n     // A pat_ident may either be a new bound variable,\n@@ -427,8 +403,6 @@ enum pat_ {\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum mutability { m_mutbl, m_imm, m_const, }\n \n impl mutability : to_bytes::IterBytes {\n@@ -446,8 +420,6 @@ impl mutability : cmp::Eq {\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum proto {\n     proto_bare,    // foreign fn\n     proto_uniq,    // fn~\n@@ -464,8 +436,6 @@ impl proto : cmp::Eq {\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum vstore {\n     // FIXME (#2112): Change uint to @expr (actually only constant exprs)\n     vstore_fixed(Option<uint>),   // [1,2,3,4]/_ or 4\n@@ -476,8 +446,6 @@ enum vstore {\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum expr_vstore {\n     // FIXME (#2112): Change uint to @expr (actually only constant exprs)\n     expr_vstore_fixed(Option<uint>),   // [1,2,3,4]/_ or 4\n@@ -495,8 +463,6 @@ pure fn is_blockish(p: ast::proto) -> bool {\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum binop {\n     add,\n     subtract,\n@@ -527,8 +493,6 @@ impl binop : cmp::Eq {\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum unop {\n     box(mutability),\n     uniq(mutability),\n@@ -581,8 +545,6 @@ impl unop : cmp::Eq {\n // using ty::resolved_T(...).\n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum inferable<T> {\n     expl(T),\n     infer(node_id)\n@@ -623,8 +585,6 @@ impl<T:cmp::Eq> inferable<T> : cmp::Eq {\n // \"resolved\" mode: the real modes.\n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum rmode { by_ref, by_val, by_move, by_copy }\n \n impl rmode : to_bytes::IterBytes {\n@@ -648,8 +608,6 @@ type stmt = spanned<stmt_>;\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum stmt_ {\n     stmt_decl(@decl, node_id),\n \n@@ -662,8 +620,6 @@ enum stmt_ {\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum init_op { init_assign, init_move, }\n \n impl init_op : cmp::Eq {\n@@ -688,16 +644,12 @@ impl init_op : cmp::Eq {\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type initializer = {op: init_op, expr: @expr};\n \n // FIXME (pending discussion of #1697, #2178...): local should really be\n // a refinement on pat.\n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type local_ =  {is_mutbl: bool, ty: @ty, pat: @pat,\n                 init: Option<initializer>, id: node_id};\n \n@@ -707,28 +659,20 @@ type decl = spanned<decl_>;\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum decl_ { decl_local(~[@local]), decl_item(@item), }\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type arm = {pats: ~[@pat], guard: Option<@expr>, body: blk};\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type field_ = {mutbl: mutability, ident: ident, expr: @expr};\n \n type field = spanned<field_>;\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum blk_check_mode { default_blk, unsafe_blk, }\n \n impl blk_check_mode : cmp::Eq {\n@@ -745,28 +689,20 @@ impl blk_check_mode : cmp::Eq {\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type expr = {id: node_id, callee_id: node_id, node: expr_, span: span};\n // Extra node ID is only used for index, assign_op, unary, binary\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum log_level { error, debug, other }\n // 0 = error, 1 = debug, 2 = other\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum alt_mode { alt_check, alt_exhaustive, }\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum expr_ {\n     expr_vstore(@expr, expr_vstore),\n     expr_vec(~[@expr], mutability),\n@@ -824,8 +760,6 @@ enum expr_ {\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type capture_item_ = {\n     id: int,\n     is_move: bool,\n@@ -855,8 +789,6 @@ type capture_clause = @~[capture_item];\n //\n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n #[doc=\"For macro invocations; parsing is delegated to the macro\"]\n enum token_tree {\n     tt_tok(span, token::token),\n@@ -922,8 +854,6 @@ type matcher = spanned<matcher_>;\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum matcher_ {\n     // match one token\n     match_tok(token::token),\n@@ -940,16 +870,12 @@ type mac_arg = Option<@expr>;\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type mac_body_ = {span: span};\n \n type mac_body = Option<mac_body_>;\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum mac_ {\n     mac_invoc(@path, mac_arg, mac_body), // old macro-invocation\n     mac_invoc_tt(@path,~[token_tree]),   // new macro-invocation\n@@ -964,8 +890,6 @@ type lit = spanned<lit_>;\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum lit_ {\n     lit_str(@~str),\n     lit_int(i64, int_ty),\n@@ -1008,30 +932,22 @@ impl ast::lit_: cmp::Eq {\n // type structure in middle/ty.rs as well.\n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type mt = {ty: @ty, mutbl: mutability};\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type ty_field_ = {ident: ident, mt: mt};\n \n type ty_field = spanned<ty_field_>;\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type ty_method = {ident: ident, attrs: ~[attribute], purity: purity,\n                   decl: fn_decl, tps: ~[ty_param], self_ty: self_ty,\n                   id: node_id, span: span};\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n // A trait method is either required (meaning it doesn't have an\n // implementation, just a signature) or provided (meaning it has a default\n // implementation).\n@@ -1042,8 +958,6 @@ enum trait_method {\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum int_ty { ty_i, ty_char, ty_i8, ty_i16, ty_i32, ty_i64, }\n \n impl int_ty : to_bytes::IterBytes {\n@@ -1074,8 +988,6 @@ impl int_ty : cmp::Eq {\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum uint_ty { ty_u, ty_u8, ty_u16, ty_u32, ty_u64, }\n \n impl uint_ty : to_bytes::IterBytes {\n@@ -1104,8 +1016,6 @@ impl uint_ty : cmp::Eq {\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum float_ty { ty_f, ty_f32, ty_f64, }\n \n impl float_ty : to_bytes::IterBytes {\n@@ -1125,15 +1035,11 @@ impl float_ty : cmp::Eq {\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type ty = {id: node_id, node: ty_, span: span};\n \n // Not represented directly in the AST, referred to by name through a ty_path.\n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum prim_ty {\n     ty_int(int_ty),\n     ty_uint(uint_ty),\n@@ -1182,14 +1088,10 @@ impl prim_ty : cmp::Eq {\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type region = {id: node_id, node: region_};\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum region_ {\n     re_anon,\n     re_static,\n@@ -1199,8 +1101,6 @@ enum region_ {\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum ty_ {\n     ty_nil,\n     ty_bot, /* bottom type */\n@@ -1241,23 +1141,17 @@ impl ty : to_bytes::IterBytes {\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type arg = {mode: mode, ty: @ty, ident: ident, id: node_id};\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type fn_decl =\n     {inputs: ~[arg],\n      output: @ty,\n      cf: ret_style};\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum purity {\n     pure_fn, // declared with \"pure fn\"\n     unsafe_fn, // declared with \"unsafe fn\"\n@@ -1280,8 +1174,6 @@ impl purity : cmp::Eq {\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum ret_style {\n     noreturn, // functions with return type _|_ that always\n               // raise an error or exit (i.e. never return to the caller)\n@@ -1308,8 +1200,6 @@ impl ret_style : cmp::Eq {\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum self_ty_ {\n     sty_static,                         // no self: static method\n     sty_by_ref,                         // old by-reference self: ``\n@@ -1367,8 +1257,6 @@ type self_ty = spanned<self_ty_>;\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type method = {ident: ident, attrs: ~[attribute],\n                tps: ~[ty_param], self_ty: self_ty,\n                purity: purity, decl: fn_decl, body: blk,\n@@ -1377,14 +1265,10 @@ type method = {ident: ident, attrs: ~[attribute],\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type _mod = {view_items: ~[@view_item], items: ~[@item]};\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum foreign_abi {\n     foreign_abi_rust_intrinsic,\n     foreign_abi_cdecl,\n@@ -1394,8 +1278,6 @@ enum foreign_abi {\n // Foreign mods can be named or anonymous\n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum foreign_mod_sort { named, anonymous }\n \n impl foreign_mod_sort : cmp::Eq {\n@@ -1421,23 +1303,17 @@ impl foreign_abi : cmp::Eq {\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type foreign_mod =\n     {sort: foreign_mod_sort,\n      view_items: ~[@view_item],\n      items: ~[@foreign_item]};\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type variant_arg = {ty: @ty, id: node_id};\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum variant_kind {\n     tuple_variant_kind(~[variant_arg]),\n     struct_variant_kind(@struct_def),\n@@ -1446,37 +1322,27 @@ enum variant_kind {\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type enum_def_ = { variants: ~[variant], common: Option<@struct_def> };\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum enum_def = enum_def_;\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type variant_ = {name: ident, attrs: ~[attribute], kind: variant_kind,\n                  id: node_id, disr_expr: Option<@expr>, vis: visibility};\n \n type variant = spanned<variant_>;\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type path_list_ident_ = {name: ident, id: node_id};\n \n type path_list_ident = spanned<path_list_ident_>;\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum namespace { module_ns, type_value_ns }\n \n impl namespace : cmp::Eq {\n@@ -1490,8 +1356,6 @@ type view_path = spanned<view_path_>;\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum view_path_ {\n \n     // quux = foo::bar::baz\n@@ -1510,15 +1374,11 @@ enum view_path_ {\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type view_item = {node: view_item_, attrs: ~[attribute],\n                   vis: visibility, span: span};\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum view_item_ {\n     view_item_use(ident, ~[@meta_item], node_id),\n     view_item_import(~[@view_path]),\n@@ -1533,8 +1393,6 @@ type attribute = spanned<attribute_>;\n // distinguished for pretty-printing.\n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum attr_style { attr_outer, attr_inner, }\n \n impl attr_style : cmp::Eq {\n@@ -1547,8 +1405,6 @@ impl attr_style : cmp::Eq {\n // doc-comments are promoted to attributes that have is_sugared_doc = true\n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type attribute_ = {style: attr_style, value: meta_item, is_sugared_doc: bool};\n \n /*\n@@ -1562,14 +1418,10 @@ type attribute_ = {style: attr_style, value: meta_item, is_sugared_doc: bool};\n  */\n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type trait_ref = {path: @path, ref_id: node_id, impl_id: node_id};\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum visibility { public, private, inherited }\n \n impl visibility : cmp::Eq {\n@@ -1588,8 +1440,6 @@ impl visibility : cmp::Eq {\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type struct_field_ = {\n     kind: struct_field_kind,\n     id: node_id,\n@@ -1600,17 +1450,13 @@ type struct_field = spanned<struct_field_>;\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum struct_field_kind {\n     named_field(ident, class_mutability, visibility),\n     unnamed_field   // element of a tuple-like struct\n }\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type struct_def = {\n     traits: ~[@trait_ref],   /* traits this struct implements */\n     fields: ~[@struct_field], /* fields */\n@@ -1628,16 +1474,12 @@ type struct_def = {\n  */\n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type item = {ident: ident, attrs: ~[attribute],\n              id: node_id, node: item_,\n              vis: visibility, span: span};\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum item_ {\n     item_const(@ty, @expr),\n     item_fn(fn_decl, purity, ~[ty_param], blk),\n@@ -1656,8 +1498,6 @@ enum item_ {\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum class_mutability { class_mutable, class_immutable }\n \n impl class_mutability : to_bytes::IterBytes {\n@@ -1682,8 +1522,6 @@ type class_ctor = spanned<class_ctor_>;\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type class_ctor_ = {id: node_id,\n                     attrs: ~[attribute],\n                     self_id: node_id,\n@@ -1694,17 +1532,13 @@ type class_dtor = spanned<class_dtor_>;\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type class_dtor_ = {id: node_id,\n                     attrs: ~[attribute],\n                     self_id: node_id,\n                     body: blk};\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type foreign_item =\n     {ident: ident,\n      attrs: ~[attribute],\n@@ -1715,8 +1549,6 @@ type foreign_item =\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum foreign_item_ {\n     foreign_item_fn(fn_decl, purity, ~[ty_param]),\n     foreign_item_const(@ty)\n@@ -1727,8 +1559,6 @@ enum foreign_item_ {\n // that we trans.\n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum inlined_item {\n     ii_item(@item),\n     ii_method(def_id /* impl id */, @method),"}, {"sha": "ab24d7a53160e63b48298d2e03668fbe66e4b23e", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22efa39382d41b084fde1719df7ae8ce5697d8c9/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22efa39382d41b084fde1719df7ae8ce5697d8c9/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=22efa39382d41b084fde1719df7ae8ce5697d8c9", "patch": "@@ -408,8 +408,6 @@ fn dtor_dec() -> fn_decl {\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type id_range = {min: node_id, max: node_id};\n \n fn empty(range: id_range) -> bool {"}, {"sha": "b3102f8b4f72d57604ab5518c04ee16e56093ad6", "filename": "src/libsyntax/ext/auto_serialize2.rs", "status": "removed", "additions": 0, "deletions": 991, "changes": 991, "blob_url": "https://github.com/rust-lang/rust/blob/48495f9f7f1fb34bf0585d9d386592c95b5284d8/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48495f9f7f1fb34bf0585d9d386592c95b5284d8/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs?ref=48495f9f7f1fb34bf0585d9d386592c95b5284d8", "patch": "@@ -1,991 +0,0 @@\n-/*\n-\n-The compiler code necessary to implement the #[auto_serialize2] and\n-#[auto_deserialize2] extension.  The idea here is that type-defining items may\n-be tagged with #[auto_serialize2] and #[auto_deserialize2], which will cause\n-us to generate a little companion module with the same name as the item.\n-\n-For example, a type like:\n-\n-    #[auto_serialize2]\n-    #[auto_deserialize2]\n-    struct Node {id: uint}\n-\n-would generate two implementations like:\n-\n-    impl Node: Serializable {\n-        fn serialize<S: Serializer>(s: &S) {\n-            do s.emit_struct(\"Node\") {\n-                s.emit_field(\"id\", 0, || s.emit_uint(self))\n-            }\n-        }\n-    }\n-\n-    impl node_id: Deserializable {\n-        static fn deserialize<D: Deserializer>(d: &D) -> Node {\n-            do d.read_struct(\"Node\") {\n-                Node {\n-                    id: d.read_field(~\"x\", 0, || deserialize(d))\n-                }\n-            }\n-        }\n-    }\n-\n-Other interesting scenarios are whe the item has type parameters or\n-references other non-built-in types.  A type definition like:\n-\n-    #[auto_serialize2]\n-    #[auto_deserialize2]\n-    type spanned<T> = {node: T, span: span};\n-\n-would yield functions like:\n-\n-    impl<T: Serializable> spanned<T>: Serializable {\n-        fn serialize<S: Serializer>(s: &S) {\n-            do s.emit_rec {\n-                s.emit_field(\"node\", 0, || self.node.serialize(s));\n-                s.emit_field(\"span\", 1, || self.span.serialize(s));\n-            }\n-        }\n-    }\n-\n-    impl<T: Deserializable> spanned<T>: Deserializable {\n-        static fn deserialize<D: Deserializer>(d: &D) -> spanned<T> {\n-            do d.read_rec {\n-                {\n-                    node: d.read_field(~\"node\", 0, || deserialize(d)),\n-                    span: d.read_field(~\"span\", 1, || deserialize(d)),\n-                }\n-            }\n-        }\n-    }\n-\n-FIXME (#2810)--Hygiene. Search for \"__\" strings.  We also assume \"std\" is the\n-standard library.\n-\n-Misc notes:\n------------\n-\n-I use move mode arguments for ast nodes that will get inserted as is\n-into the tree.  This is intended to prevent us from inserting the same\n-node twice.\n-\n-*/\n-\n-use base::*;\n-use codemap::span;\n-use std::map;\n-use std::map::HashMap;\n-\n-export expand_auto_serialize;\n-export expand_auto_deserialize;\n-\n-// Transitional reexports so qquote can find the paths it is looking for\n-mod syntax {\n-    pub use ext;\n-    pub use parse;\n-}\n-\n-fn expand_auto_serialize(\n-    cx: ext_ctxt,\n-    span: span,\n-    _mitem: ast::meta_item,\n-    in_items: ~[@ast::item]\n-) -> ~[@ast::item] {\n-    fn is_auto_serialize2(a: &ast::attribute) -> bool {\n-        attr::get_attr_name(*a) == ~\"auto_serialize2\"\n-    }\n-\n-    fn filter_attrs(item: @ast::item) -> @ast::item {\n-        @{attrs: vec::filter(item.attrs, |a| !is_auto_serialize2(a)),\n-          .. *item}\n-    }\n-\n-    do vec::flat_map(in_items) |item| {\n-        if item.attrs.any(is_auto_serialize2) {\n-            match item.node {\n-                ast::item_ty(@{node: ast::ty_rec(fields), _}, tps) => {\n-                    let ser_impl = mk_rec_ser_impl(\n-                        cx,\n-                        item.span,\n-                        item.ident,\n-                        fields,\n-                        tps\n-                    );\n-\n-                    ~[filter_attrs(*item), ser_impl]\n-                },\n-                ast::item_class(@{ fields, _}, tps) => {\n-                    let ser_impl = mk_struct_ser_impl(\n-                        cx,\n-                        item.span,\n-                        item.ident,\n-                        fields,\n-                        tps\n-                    );\n-\n-                    ~[filter_attrs(*item), ser_impl]\n-                },\n-                ast::item_enum(enum_def, tps) => {\n-                    let ser_impl = mk_enum_ser_impl(\n-                        cx,\n-                        item.span,\n-                        item.ident,\n-                        enum_def,\n-                        tps\n-                    );\n-\n-                    ~[filter_attrs(*item), ser_impl]\n-                },\n-                _ => {\n-                    cx.span_err(span, ~\"#[auto_serialize2] can only be \\\n-                                        applied to structs, record types, \\\n-                                        and enum definitions\");\n-                    ~[*item]\n-                }\n-            }\n-        } else {\n-            ~[*item]\n-        }\n-    }\n-}\n-\n-fn expand_auto_deserialize(\n-    cx: ext_ctxt,\n-    span: span,\n-    _mitem: ast::meta_item,\n-    in_items: ~[@ast::item]\n-) -> ~[@ast::item] {\n-    fn is_auto_deserialize2(a: &ast::attribute) -> bool {\n-        attr::get_attr_name(*a) == ~\"auto_deserialize2\"\n-    }\n-\n-    fn filter_attrs(item: @ast::item) -> @ast::item {\n-        @{attrs: vec::filter(item.attrs, |a| !is_auto_deserialize2(a)),\n-          .. *item}\n-    }\n-\n-    do vec::flat_map(in_items) |item| {\n-        if item.attrs.any(is_auto_deserialize2) {\n-            match item.node {\n-                ast::item_ty(@{node: ast::ty_rec(fields), _}, tps) => {\n-                    let deser_impl = mk_rec_deser_impl(\n-                        cx,\n-                        item.span,\n-                        item.ident,\n-                        fields,\n-                        tps\n-                    );\n-\n-                    ~[filter_attrs(*item), deser_impl]\n-                },\n-                ast::item_class(@{ fields, _}, tps) => {\n-                    let deser_impl = mk_struct_deser_impl(\n-                        cx,\n-                        item.span,\n-                        item.ident,\n-                        fields,\n-                        tps\n-                    );\n-\n-                    ~[filter_attrs(*item), deser_impl]\n-                },\n-                ast::item_enum(enum_def, tps) => {\n-                    let deser_impl = mk_enum_deser_impl(\n-                        cx,\n-                        item.span,\n-                        item.ident,\n-                        enum_def,\n-                        tps\n-                    );\n-\n-                    ~[filter_attrs(*item), deser_impl]\n-                },\n-                _ => {\n-                    cx.span_err(span, ~\"#[auto_deserialize2] can only be \\\n-                                        applied to structs, record types, \\\n-                                        and enum definitions\");\n-                    ~[*item]\n-                }\n-            }\n-        } else {\n-            ~[*item]\n-        }\n-    }\n-}\n-\n-fn mk_impl(\n-    cx: ext_ctxt,\n-    span: span,\n-    ident: ast::ident,\n-    path: @ast::path,\n-    tps: ~[ast::ty_param],\n-    f: fn(@ast::ty) -> @ast::method\n-) -> @ast::item {\n-    // All the type parameters need to bound to the trait.\n-    let trait_tps = do tps.map |tp| {\n-        let t_bound = ast::bound_trait(@{\n-            id: cx.next_id(),\n-            node: ast::ty_path(path, cx.next_id()),\n-            span: span,\n-        });\n-\n-        {\n-            ident: tp.ident,\n-            id: cx.next_id(),\n-            bounds: @vec::append(~[t_bound], *tp.bounds)\n-        }\n-    };\n-\n-    let opt_trait = Some(@{\n-        path: path,\n-        ref_id: cx.next_id(),\n-        impl_id: cx.next_id(),\n-    });\n-\n-    let ty = cx.ty_path(\n-        span,\n-        ~[ident],\n-        tps.map(|tp| cx.ty_path(span, ~[tp.ident], ~[]))\n-    );\n-\n-    @{\n-        // This is a new-style impl declaration.\n-        // XXX: clownshoes\n-        ident: ast::token::special_idents::clownshoes_extensions,\n-        attrs: ~[],\n-        id: cx.next_id(),\n-        node: ast::item_impl(trait_tps, opt_trait, ty, ~[f(ty)]),\n-        vis: ast::public,\n-        span: span,\n-    }\n-}\n-\n-fn mk_ser_impl(\n-    cx: ext_ctxt,\n-    span: span,\n-    ident: ast::ident,\n-    tps: ~[ast::ty_param],\n-    body: @ast::expr\n-) -> @ast::item {\n-    // Make a path to the std::serialization2::Serializable trait.\n-    let path = cx.path(\n-        span,\n-        ~[\n-            cx.ident_of(~\"std\"),\n-            cx.ident_of(~\"serialization2\"),\n-            cx.ident_of(~\"Serializable\"),\n-        ]\n-    );\n-\n-    mk_impl(\n-        cx,\n-        span,\n-        ident,\n-        path,\n-        tps,\n-        |_ty| mk_ser_method(cx, span, cx.expr_blk(body))\n-    )\n-}\n-\n-fn mk_deser_impl(\n-    cx: ext_ctxt,\n-    span: span,\n-    ident: ast::ident,\n-    tps: ~[ast::ty_param],\n-    body: @ast::expr\n-) -> @ast::item {\n-    // Make a path to the std::serialization2::Deserializable trait.\n-    let path = cx.path(\n-        span,\n-        ~[\n-            cx.ident_of(~\"std\"),\n-            cx.ident_of(~\"serialization2\"),\n-            cx.ident_of(~\"Deserializable\"),\n-        ]\n-    );\n-\n-    mk_impl(\n-        cx,\n-        span,\n-        ident,\n-        path,\n-        tps,\n-        |ty| mk_deser_method(cx, span, ty, cx.expr_blk(body))\n-    )\n-}\n-\n-fn mk_ser_method(\n-    cx: ext_ctxt,\n-    span: span,\n-    ser_body: ast::blk\n-) -> @ast::method {\n-    let ser_bound = cx.ty_path(\n-        span,\n-        ~[\n-            cx.ident_of(~\"std\"),\n-            cx.ident_of(~\"serialization2\"),\n-            cx.ident_of(~\"Serializer\"),\n-        ],\n-        ~[]\n-    );\n-\n-    let ser_tps = ~[{\n-        ident: cx.ident_of(~\"__S\"),\n-        id: cx.next_id(),\n-        bounds: @~[ast::bound_trait(ser_bound)],\n-    }];\n-\n-    let ty_s = @{\n-        id: cx.next_id(),\n-        node: ast::ty_rptr(\n-            @{\n-                id: cx.next_id(),\n-                node: ast::re_anon,\n-            },\n-            {\n-                ty: cx.ty_path(span, ~[cx.ident_of(~\"__S\")], ~[]),\n-                mutbl: ast::m_imm\n-            }\n-        ),\n-        span: span,\n-    };\n-\n-    let ser_inputs = ~[{\n-        mode: ast::infer(cx.next_id()),\n-        ty: ty_s,\n-        ident: cx.ident_of(~\"__s\"),\n-        id: cx.next_id(),\n-    }];\n-\n-    let ser_output = @{\n-        id: cx.next_id(),\n-        node: ast::ty_nil,\n-        span: span,\n-    };\n-\n-    let ser_decl = {\n-        inputs: ser_inputs,\n-        output: ser_output,\n-        cf: ast::return_val,\n-    };\n-\n-    @{\n-        ident: cx.ident_of(~\"serialize\"),\n-        attrs: ~[],\n-        tps: ser_tps,\n-        self_ty: { node: ast::sty_region(ast::m_imm), span: span },\n-        purity: ast::impure_fn,\n-        decl: ser_decl,\n-        body: ser_body,\n-        id: cx.next_id(),\n-        span: span,\n-        self_id: cx.next_id(),\n-        vis: ast::public,\n-    }\n-}\n-\n-fn mk_deser_method(\n-    cx: ext_ctxt,\n-    span: span,\n-    ty: @ast::ty,\n-    deser_body: ast::blk\n-) -> @ast::method {\n-    let deser_bound = cx.ty_path(\n-        span,\n-        ~[\n-            cx.ident_of(~\"std\"),\n-            cx.ident_of(~\"serialization2\"),\n-            cx.ident_of(~\"Deserializer\"),\n-        ],\n-        ~[]\n-    );\n-\n-    let deser_tps = ~[{\n-        ident: cx.ident_of(~\"__D\"),\n-        id: cx.next_id(),\n-        bounds: @~[ast::bound_trait(deser_bound)],\n-    }];\n-\n-    let ty_d = @{\n-        id: cx.next_id(),\n-        node: ast::ty_rptr(\n-            @{\n-                id: cx.next_id(),\n-                node: ast::re_anon,\n-            },\n-            {\n-                ty: cx.ty_path(span, ~[cx.ident_of(~\"__D\")], ~[]),\n-                mutbl: ast::m_imm\n-            }\n-        ),\n-        span: span,\n-    };\n-\n-    let deser_inputs = ~[{\n-        mode: ast::infer(cx.next_id()),\n-        ty: ty_d,\n-        ident: cx.ident_of(~\"__d\"),\n-        id: cx.next_id(),\n-    }];\n-\n-    let deser_decl = {\n-        inputs: deser_inputs,\n-        output: ty,\n-        cf: ast::return_val,\n-    };\n-\n-    @{\n-        ident: cx.ident_of(~\"deserialize\"),\n-        attrs: ~[],\n-        tps: deser_tps,\n-        self_ty: { node: ast::sty_static, span: span },\n-        purity: ast::impure_fn,\n-        decl: deser_decl,\n-        body: deser_body,\n-        id: cx.next_id(),\n-        span: span,\n-        self_id: cx.next_id(),\n-        vis: ast::public,\n-    }\n-}\n-\n-fn mk_rec_ser_impl(\n-    cx: ext_ctxt,\n-    span: span,\n-    ident: ast::ident,\n-    fields: ~[ast::ty_field],\n-    tps: ~[ast::ty_param]\n-) -> @ast::item {\n-    let fields = mk_ser_fields(cx, span, mk_rec_fields(fields));\n-\n-    // ast for `__s.emit_rec(|| $(fields))`\n-    let body = cx.expr_call(\n-        span,\n-        cx.expr_field(\n-            span,\n-            cx.expr_var(span, ~\"__s\"),\n-            cx.ident_of(~\"emit_rec\")\n-        ),\n-        ~[cx.lambda_stmts(span, fields)]\n-    );\n-\n-    mk_ser_impl(cx, span, ident, tps, body)\n-}\n-\n-fn mk_rec_deser_impl(\n-    cx: ext_ctxt,\n-    span: span,\n-    ident: ast::ident,\n-    fields: ~[ast::ty_field],\n-    tps: ~[ast::ty_param]\n-) -> @ast::item {\n-    let fields = mk_deser_fields(cx, span, mk_rec_fields(fields));\n-\n-    // ast for `read_rec(|| $(fields))`\n-    let body = cx.expr_call(\n-        span,\n-        cx.expr_field(\n-            span,\n-            cx.expr_var(span, ~\"__d\"),\n-            cx.ident_of(~\"read_rec\")\n-        ),\n-        ~[\n-            cx.lambda_expr(\n-                cx.expr(\n-                    span,\n-                    ast::expr_rec(fields, None)\n-                )\n-            )\n-        ]\n-    );\n-\n-    mk_deser_impl(cx, span, ident, tps, body)\n-}\n-\n-fn mk_struct_ser_impl(\n-    cx: ext_ctxt,\n-    span: span,\n-    ident: ast::ident,\n-    fields: ~[@ast::struct_field],\n-    tps: ~[ast::ty_param]\n-) -> @ast::item {\n-    let fields = mk_ser_fields(cx, span, mk_struct_fields(fields));\n-\n-    // ast for `__s.emit_struct($(name), || $(fields))`\n-    let ser_body = cx.expr_call(\n-        span,\n-        cx.expr_field(\n-            span,\n-            cx.expr_var(span, ~\"__s\"),\n-            cx.ident_of(~\"emit_struct\")\n-        ),\n-        ~[\n-            cx.lit_str(span, @cx.str_of(ident)),\n-            cx.lambda_stmts(span, fields),\n-        ]\n-    );\n-\n-    mk_ser_impl(cx, span, ident, tps, ser_body)\n-}\n-\n-fn mk_struct_deser_impl(\n-    cx: ext_ctxt,\n-    span: span,\n-    ident: ast::ident,\n-    fields: ~[@ast::struct_field],\n-    tps: ~[ast::ty_param]\n-) -> @ast::item {\n-    let fields = mk_deser_fields(cx, span, mk_struct_fields(fields));\n-\n-    // ast for `read_struct($(name), || $(fields))`\n-    let body = cx.expr_call(\n-        span,\n-        cx.expr_field(\n-            span,\n-            cx.expr_var(span, ~\"__d\"),\n-            cx.ident_of(~\"read_struct\")\n-        ),\n-        ~[\n-            cx.lit_str(span, @cx.str_of(ident)),\n-            cx.lambda_expr(\n-                cx.expr(\n-                    span,\n-                    ast::expr_struct(\n-                        cx.path(span, ~[ident]),\n-                        fields,\n-                        None\n-                    )\n-                )\n-            ),\n-        ]\n-    );\n-\n-    mk_deser_impl(cx, span, ident, tps, body)\n-}\n-\n-// Records and structs don't have the same fields types, but they share enough\n-// that if we extract the right subfields out we can share the serialization\n-// generator code.\n-type field = { span: span, ident: ast::ident, mutbl: ast::mutability };\n-\n-fn mk_rec_fields(fields: ~[ast::ty_field]) -> ~[field] {\n-    do fields.map |field| {\n-        {\n-            span: field.span,\n-            ident: field.node.ident,\n-            mutbl: field.node.mt.mutbl,\n-        }\n-    }\n-}\n-\n-fn mk_struct_fields(fields: ~[@ast::struct_field]) -> ~[field] {\n-    do fields.map |field| {\n-        let (ident, mutbl) = match field.node.kind {\n-            ast::named_field(ident, mutbl, _) => (ident, mutbl),\n-            _ => fail ~\"[auto_serialize2] does not support \\\n-                        unnamed fields\",\n-        };\n-\n-        {\n-            span: field.span,\n-            ident: ident,\n-            mutbl: match mutbl {\n-                ast::class_mutable => ast::m_mutbl,\n-                ast::class_immutable => ast::m_imm,\n-            },\n-        }\n-    }\n-}\n-\n-fn mk_ser_fields(\n-    cx: ext_ctxt,\n-    span: span,\n-    fields: ~[field]\n-) -> ~[@ast::stmt] {\n-    do fields.mapi |idx, field| {\n-        // ast for `|| self.$(name).serialize(__s)`\n-        let expr_lambda = cx.lambda_expr(\n-            cx.expr_call(\n-                span,\n-                cx.expr_field(\n-                    span,\n-                    cx.expr_field(\n-                        span,\n-                        cx.expr_var(span, ~\"self\"),\n-                        field.ident\n-                    ),\n-                    cx.ident_of(~\"serialize\")\n-                ),\n-                ~[cx.expr_var(span, ~\"__s\")]\n-            )\n-        );\n-\n-        // ast for `__s.emit_field($(name), $(idx), $(expr_lambda))`\n-        cx.stmt(\n-            cx.expr_call(\n-                span,\n-                cx.expr_field(\n-                    span,\n-                    cx.expr_var(span, ~\"__s\"),\n-                    cx.ident_of(~\"emit_field\")\n-                ),\n-                ~[\n-                    cx.lit_str(span, @cx.str_of(field.ident)),\n-                    cx.lit_uint(span, idx),\n-                    expr_lambda,\n-                ]\n-            )\n-        )\n-    }\n-}\n-\n-fn mk_deser_fields(\n-    cx: ext_ctxt,\n-    span: span,\n-    fields: ~[{ span: span, ident: ast::ident, mutbl: ast::mutability }]\n-) -> ~[ast::field] {\n-    do fields.mapi |idx, field| {\n-        // ast for `|| std::serialization2::deserialize(__d)`\n-        let expr_lambda = cx.lambda(\n-            cx.expr_blk(\n-                cx.expr_call(\n-                    span,\n-                    cx.expr_path(span, ~[\n-                        cx.ident_of(~\"std\"),\n-                        cx.ident_of(~\"serialization2\"),\n-                        cx.ident_of(~\"deserialize\"),\n-                    ]),\n-                    ~[cx.expr_var(span, ~\"__d\")]\n-                )\n-            )\n-        );\n-\n-        // ast for `__d.read_field($(name), $(idx), $(expr_lambda))`\n-        let expr: @ast::expr = cx.expr_call(\n-            span,\n-            cx.expr_field(\n-                span,\n-                cx.expr_var(span, ~\"__d\"),\n-                cx.ident_of(~\"read_field\")\n-            ),\n-            ~[\n-                cx.lit_str(span, @cx.str_of(field.ident)),\n-                cx.lit_uint(span, idx),\n-                expr_lambda,\n-            ]\n-        );\n-\n-        {\n-            node: { mutbl: field.mutbl, ident: field.ident, expr: expr },\n-            span: span,\n-        }\n-    }\n-}\n-\n-fn mk_enum_ser_impl(\n-    cx: ext_ctxt,\n-    span: span,\n-    ident: ast::ident,\n-    enum_def: ast::enum_def,\n-    tps: ~[ast::ty_param]\n-) -> @ast::item {\n-    let body = mk_enum_ser_body(\n-        cx,\n-        span,\n-        ident,\n-        enum_def.variants\n-    );\n-\n-    mk_ser_impl(cx, span, ident, tps, body)\n-}\n-\n-fn mk_enum_deser_impl(\n-    cx: ext_ctxt,\n-    span: span,\n-    ident: ast::ident,\n-    enum_def: ast::enum_def,\n-    tps: ~[ast::ty_param]\n-) -> @ast::item {\n-    let body = mk_enum_deser_body(\n-        cx,\n-        span,\n-        ident,\n-        enum_def.variants\n-    );\n-\n-    mk_deser_impl(cx, span, ident, tps, body)\n-}\n-\n-fn ser_variant(\n-    cx: ext_ctxt,\n-    span: span,\n-    v_name: ast::ident,\n-    v_idx: uint,\n-    args: ~[ast::variant_arg]\n-) -> ast::arm {\n-    // Name the variant arguments.\n-    let names = args.mapi(|i, _arg| cx.ident_of(fmt!(\"__v%u\", i)));\n-\n-    // Bind the names to the variant argument type.\n-    let pats = args.mapi(|i, arg| cx.binder_pat(arg.ty.span, names[i]));\n-\n-    let pat_node = if pats.is_empty() {\n-        ast::pat_ident(\n-            ast::bind_by_implicit_ref,\n-            cx.path(span, ~[v_name]),\n-            None\n-        )\n-    } else {\n-        ast::pat_enum(\n-            cx.path(span, ~[v_name]),\n-            Some(pats)\n-        )\n-    };\n-\n-    let pat = @{\n-        id: cx.next_id(),\n-        node: pat_node,\n-        span: span,\n-    };\n-\n-    let stmts = do args.mapi |a_idx, _arg| {\n-        // ast for `__s.emit_enum_variant_arg`\n-        let expr_emit = cx.expr_field(\n-            span,\n-            cx.expr_var(span, ~\"__s\"),\n-            cx.ident_of(~\"emit_enum_variant_arg\")\n-        );\n-\n-        // ast for `|| $(v).serialize(__s)`\n-        let expr_serialize = cx.lambda_expr(\n-             cx.expr_call(\n-                span,\n-                cx.expr_field(\n-                    span,\n-                    cx.expr_path(span, ~[names[a_idx]]),\n-                    cx.ident_of(~\"serialize\")\n-                ),\n-                ~[cx.expr_var(span, ~\"__s\")]\n-            )\n-        );\n-\n-        // ast for `$(expr_emit)($(a_idx), $(expr_serialize))`\n-        cx.stmt(\n-            cx.expr_call(\n-                span,\n-                expr_emit,\n-                ~[cx.lit_uint(span, a_idx), expr_serialize]\n-            )\n-        )\n-    };\n-\n-    // ast for `__s.emit_enum_variant($(name), $(idx), $(sz), $(lambda))`\n-    let body = cx.expr_call(\n-        span,\n-        cx.expr_field(\n-            span,\n-            cx.expr_var(span, ~\"__s\"),\n-            cx.ident_of(~\"emit_enum_variant\")\n-        ),\n-        ~[\n-            cx.lit_str(span, @cx.str_of(v_name)),\n-            cx.lit_uint(span, v_idx),\n-            cx.lit_uint(span, stmts.len()),\n-            cx.lambda_stmts(span, stmts),\n-        ]\n-    );\n-\n-    { pats: ~[pat], guard: None, body: cx.expr_blk(body) }\n-}\n-\n-fn mk_enum_ser_body(\n-    cx: ext_ctxt,\n-    span: span,\n-    name: ast::ident,\n-    variants: ~[ast::variant]\n-) -> @ast::expr {\n-    let arms = do variants.mapi |v_idx, variant| {\n-        match variant.node.kind {\n-            ast::tuple_variant_kind(args) =>\n-                ser_variant(cx, span, variant.node.name, v_idx, args),\n-            ast::struct_variant_kind(*) =>\n-                fail ~\"struct variants unimplemented\",\n-            ast::enum_variant_kind(*) =>\n-                fail ~\"enum variants unimplemented\",\n-        }\n-    };\n-\n-    // ast for `match *self { $(arms) }`\n-    let match_expr = cx.expr(\n-        span,\n-        ast::expr_match(\n-            cx.expr(\n-                span,\n-                ast::expr_unary(ast::deref, cx.expr_var(span, ~\"self\"))\n-            ),\n-            arms\n-        )\n-    );\n-\n-    // ast for `__s.emit_enum($(name), || $(match_expr))`\n-    cx.expr_call(\n-        span,\n-        cx.expr_field(\n-            span,\n-            cx.expr_var(span, ~\"__s\"),\n-            cx.ident_of(~\"emit_enum\")\n-        ),\n-        ~[\n-            cx.lit_str(span, @cx.str_of(name)),\n-            cx.lambda_expr(match_expr),\n-        ]\n-    )\n-}\n-\n-fn mk_enum_deser_variant_nary(\n-    cx: ext_ctxt,\n-    span: span,\n-    name: ast::ident,\n-    args: ~[ast::variant_arg]\n-) -> @ast::expr {\n-    let args = do args.mapi |idx, _arg| {\n-        // ast for `|| std::serialization2::deserialize(__d)`\n-        let expr_lambda = cx.lambda_expr(\n-            cx.expr_call(\n-                span,\n-                cx.expr_path(span, ~[\n-                    cx.ident_of(~\"std\"),\n-                    cx.ident_of(~\"serialization2\"),\n-                    cx.ident_of(~\"deserialize\"),\n-                ]),\n-                ~[cx.expr_var(span, ~\"__d\")]\n-            )\n-        );\n-\n-        // ast for `__d.read_enum_variant_arg($(a_idx), $(expr_lambda))`\n-        cx.expr_call(\n-            span,\n-            cx.expr_field(\n-                span,\n-                cx.expr_var(span, ~\"__d\"),\n-                cx.ident_of(~\"read_enum_variant_arg\")\n-            ),\n-            ~[cx.lit_uint(span, idx), expr_lambda]\n-        )\n-    };\n-\n-    // ast for `$(name)($(args))`\n-    cx.expr_call(span, cx.expr_path(span, ~[name]), args)\n-}\n-\n-fn mk_enum_deser_body(\n-    cx: ext_ctxt,\n-    span: span,\n-    name: ast::ident,\n-    variants: ~[ast::variant]\n-) -> @ast::expr {\n-    let mut arms = do variants.mapi |v_idx, variant| {\n-        let body = match variant.node.kind {\n-            ast::tuple_variant_kind(args) => {\n-                if args.is_empty() {\n-                    // for a nullary variant v, do \"v\"\n-                    cx.expr_path(span, ~[variant.node.name])\n-                } else {\n-                    // for an n-ary variant v, do \"v(a_1, ..., a_n)\"\n-                    mk_enum_deser_variant_nary(\n-                        cx,\n-                        span,\n-                        variant.node.name,\n-                        args\n-                    )\n-                }\n-            },\n-            ast::struct_variant_kind(*) =>\n-                fail ~\"struct variants unimplemented\",\n-            ast::enum_variant_kind(*) =>\n-                fail ~\"enum variants unimplemented\",\n-        };\n-\n-        let pat = @{\n-            id: cx.next_id(),\n-            node: ast::pat_lit(cx.lit_uint(span, v_idx)),\n-            span: span,\n-        };\n-\n-        {\n-            pats: ~[pat],\n-            guard: None,\n-            body: cx.expr_blk(body),\n-        }\n-    };\n-\n-    let impossible_case = {\n-        pats: ~[@{ id: cx.next_id(), node: ast::pat_wild, span: span}],\n-        guard: None,\n-\n-        // FIXME(#3198): proper error message\n-        body: cx.expr_blk(cx.expr(span, ast::expr_fail(None))),\n-    };\n-\n-    arms.push(impossible_case);\n-\n-    // ast for `|i| { match i { $(arms) } }`\n-    let expr_lambda = cx.expr(\n-        span,\n-        ast::expr_fn_block(\n-            {\n-                inputs: ~[{\n-                    mode: ast::infer(cx.next_id()),\n-                    ty: @{\n-                        id: cx.next_id(),\n-                        node: ast::ty_infer,\n-                        span: span\n-                    },\n-                    ident: cx.ident_of(~\"i\"),\n-                    id: cx.next_id(),\n-                }],\n-                output: @{\n-                    id: cx.next_id(),\n-                    node: ast::ty_infer,\n-                    span: span,\n-                },\n-                cf: ast::return_val,\n-            },\n-            cx.expr_blk(\n-                cx.expr(\n-                    span,\n-                    ast::expr_match(cx.expr_var(span, ~\"i\"), arms)\n-                )\n-            ),\n-            @~[]\n-        )\n-    );\n-\n-    // ast for `__d.read_enum_variant($(expr_lambda))`\n-    let expr_lambda = cx.lambda_expr(\n-        cx.expr_call(\n-            span,\n-            cx.expr_field(\n-                span,\n-                cx.expr_var(span, ~\"__d\"),\n-                cx.ident_of(~\"read_enum_variant\")\n-            ),\n-            ~[expr_lambda]\n-        )\n-    );\n-\n-    // ast for `__d.read_enum($(e_name), $(expr_lambda))`\n-    cx.expr_call(\n-        span,\n-        cx.expr_field(\n-            span,\n-            cx.expr_var(span, ~\"__d\"),\n-            cx.ident_of(~\"read_enum\")\n-        ),\n-        ~[\n-            cx.lit_str(span, @cx.str_of(name)),\n-            expr_lambda\n-        ]\n-    )\n-}"}, {"sha": "c106042b9a3d00fee7c67c511cb07bd971d3eaab", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 60, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/22efa39382d41b084fde1719df7ae8ce5697d8c9/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22efa39382d41b084fde1719df7ae8ce5697d8c9/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=22efa39382d41b084fde1719df7ae8ce5697d8c9", "patch": "@@ -54,7 +54,7 @@ enum syntax_extension {\n     // macro_defining() is obsolete, remove when #old_macros go away.\n     macro_defining(macro_definer),\n \n-    // #[auto_serialize2] and such. will probably survive death of #old_macros\n+    // #[auto_serialize] and such. will probably survive death of #old_macros\n     item_decorator(item_decorator),\n \n     // Token-tree expanders\n@@ -64,65 +64,6 @@ enum syntax_extension {\n \n // A temporary hard-coded map of methods for expanding syntax extension\n // AST nodes into full ASTs\n-#[cfg(stage0)]\n-fn syntax_expander_table() -> HashMap<~str, syntax_extension> {\n-    fn builtin(f: syntax_expander_) -> syntax_extension\n-        {normal({expander: f, span: None})}\n-    fn builtin_expr_tt(f: syntax_expander_tt_) -> syntax_extension {\n-        expr_tt({expander: f, span: None})\n-    }\n-    fn builtin_item_tt(f: syntax_expander_tt_item_) -> syntax_extension {\n-        item_tt({expander: f, span: None})\n-    }\n-    let syntax_expanders = HashMap();\n-    syntax_expanders.insert(~\"macro\",\n-                            macro_defining(ext::simplext::add_new_extension));\n-    syntax_expanders.insert(~\"macro_rules\",\n-                            builtin_item_tt(\n-                                ext::tt::macro_rules::add_new_extension));\n-    syntax_expanders.insert(~\"fmt\", builtin(ext::fmt::expand_syntax_ext));\n-    syntax_expanders.insert(\n-        ~\"auto_serialize2\",\n-        item_decorator(ext::auto_serialize2::expand_auto_serialize));\n-    syntax_expanders.insert(\n-        ~\"auto_deserialize2\",\n-        item_decorator(ext::auto_serialize2::expand_auto_deserialize));\n-    syntax_expanders.insert(~\"env\", builtin(ext::env::expand_syntax_ext));\n-    syntax_expanders.insert(~\"concat_idents\",\n-                            builtin(ext::concat_idents::expand_syntax_ext));\n-    syntax_expanders.insert(~\"ident_to_str\",\n-                            builtin(ext::ident_to_str::expand_syntax_ext));\n-    syntax_expanders.insert(~\"log_syntax\",\n-                            builtin_expr_tt(\n-                                ext::log_syntax::expand_syntax_ext));\n-    syntax_expanders.insert(~\"ast\",\n-                            builtin(ext::qquote::expand_ast));\n-    syntax_expanders.insert(~\"line\",\n-                            builtin(ext::source_util::expand_line));\n-    syntax_expanders.insert(~\"col\",\n-                            builtin(ext::source_util::expand_col));\n-    syntax_expanders.insert(~\"file\",\n-                            builtin(ext::source_util::expand_file));\n-    syntax_expanders.insert(~\"stringify\",\n-                            builtin(ext::source_util::expand_stringify));\n-    syntax_expanders.insert(~\"include\",\n-                            builtin(ext::source_util::expand_include));\n-    syntax_expanders.insert(~\"include_str\",\n-                            builtin(ext::source_util::expand_include_str));\n-    syntax_expanders.insert(~\"include_bin\",\n-                            builtin(ext::source_util::expand_include_bin));\n-    syntax_expanders.insert(~\"module_path\",\n-                            builtin(ext::source_util::expand_mod));\n-    syntax_expanders.insert(~\"proto\",\n-                            builtin_item_tt(ext::pipes::expand_proto));\n-    syntax_expanders.insert(\n-        ~\"trace_macros\",\n-        builtin_expr_tt(ext::trace_macros::expand_trace_macros));\n-    return syntax_expanders;\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n fn syntax_expander_table() -> HashMap<~str, syntax_extension> {\n     fn builtin(f: syntax_expander_) -> syntax_extension\n         {normal({expander: f, span: None})}"}, {"sha": "22e2cfcde6b5113dba31df4fc23fe86c76e2cde6", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22efa39382d41b084fde1719df7ae8ce5697d8c9/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22efa39382d41b084fde1719df7ae8ce5697d8c9/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=22efa39382d41b084fde1719df7ae8ce5697d8c9", "patch": "@@ -124,7 +124,7 @@ fn expand_expr(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n }\n \n // This is a secondary mechanism for invoking syntax extensions on items:\n-// \"decorator\" attributes, such as #[auto_serialize2]. These are invoked by an\n+// \"decorator\" attributes, such as #[auto_serialize]. These are invoked by an\n // attribute prefixing an item, and are interpreted by feeding the item\n // through the named attribute _as a syntax extension_ and splicing in the\n // resulting item vec into place in favour of the decorator. Note that"}, {"sha": "dce4dc3bbc7b674e678317794ce5391e79d452d3", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/22efa39382d41b084fde1719df7ae8ce5697d8c9/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22efa39382d41b084fde1719df7ae8ce5697d8c9/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=22efa39382d41b084fde1719df7ae8ce5697d8c9", "patch": "@@ -4,8 +4,6 @@ use std::map::HashMap;\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum binop {\n     PLUS,\n     MINUS,\n@@ -21,8 +19,6 @@ enum binop {\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum token {\n     /* Expression-operator symbols. */\n     EQ,\n@@ -81,8 +77,6 @@ enum token {\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n /// For interpolation during macro expansion.\n enum nonterminal {\n     nt_item(@ast::item),"}, {"sha": "93ed5bd471bc059e4f141f0bddb0834bf8802db6", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/22efa39382d41b084fde1719df7ae8ce5697d8c9/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/22efa39382d41b084fde1719df7ae8ce5697d8c9/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=22efa39382d41b084fde1719df7ae8ce5697d8c9", "patch": "@@ -130,9 +130,6 @@ mod ext {\n     mod log_syntax;\n     #[legacy_exports]\n     mod auto_serialize;\n-    #[cfg(stage0)]\n-    #[legacy_exports]\n-    mod auto_serialize2;\n     #[legacy_exports]\n     mod source_util;\n "}, {"sha": "1b42c9bb4b67d6a19fc7a3f3dcab9be2ec878397", "filename": "src/rustc/middle/freevars.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22efa39382d41b084fde1719df7ae8ce5697d8c9/src%2Frustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22efa39382d41b084fde1719df7ae8ce5697d8c9/src%2Frustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ffreevars.rs?ref=22efa39382d41b084fde1719df7ae8ce5697d8c9", "patch": "@@ -18,8 +18,6 @@ export has_freevars;\n // (The def_upvar will already have been stripped).\n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type freevar_entry = {\n     def: ast::def, //< The variable being accessed free.\n     span: span     //< First span where it is accessed (there can be multiple)"}, {"sha": "ca41be6f9d0a59f1c649db019402712e10a94dc5", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/22efa39382d41b084fde1719df7ae8ce5697d8c9/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22efa39382d41b084fde1719df7ae8ce5697d8c9/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=22efa39382d41b084fde1719df7ae8ce5697d8c9", "patch": "@@ -213,8 +213,6 @@ type mt = {ty: t, mutbl: ast::mutability};\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum vstore {\n     vstore_fixed(uint),\n     vstore_uniq,\n@@ -275,8 +273,6 @@ type opt_region_variance = Option<region_variance>;\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum region_variance { rv_covariant, rv_invariant, rv_contravariant }\n \n impl region_variance : cmp::Eq {\n@@ -295,17 +291,13 @@ impl region_variance : cmp::Eq {\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type AutoAdjustment = {\n     autoderefs: uint,\n     autoref: Option<AutoRef>\n };\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type AutoRef = {\n     kind: AutoRefKind,\n     region: region,\n@@ -314,8 +306,6 @@ type AutoRef = {\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum AutoRefKind {\n     /// Convert from @[]/~[] to &[] (or str)\n     AutoSlice,\n@@ -521,8 +511,6 @@ impl param_ty : to_bytes::IterBytes {\n /// Representation of regions:\n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum region {\n     /// Bound regions are found (primarily) in function types.  They indicate\n     /// region parameters that have yet to be replaced with actual regions\n@@ -552,8 +540,6 @@ enum region {\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum bound_region {\n     /// The self region for classes, impls (&T in a type defn or &self/T)\n     br_self,\n@@ -685,8 +671,6 @@ enum IntVid = uint;\n enum FnVid = uint;\n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum RegionVid = uint;\n \n enum InferTy {"}, {"sha": "7cb04bc0ea3c15bd6f4b2197658e3f42fb9e9415", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22efa39382d41b084fde1719df7ae8ce5697d8c9/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22efa39382d41b084fde1719df7ae8ce5697d8c9/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=22efa39382d41b084fde1719df7ae8ce5697d8c9", "patch": "@@ -77,8 +77,6 @@ export provided_methods_map;\n \n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n enum method_origin {\n     // fully statically resolved method\n     method_static(ast::def_id),\n@@ -97,8 +95,6 @@ enum method_origin {\n // with a bounded trait.\n #[auto_serialize]\n #[auto_deserialize]\n-#[auto_serialize2]\n-#[auto_deserialize2]\n type method_param = {\n     // the trait containing the method to be invoked\n     trait_id: ast::def_id,"}]}