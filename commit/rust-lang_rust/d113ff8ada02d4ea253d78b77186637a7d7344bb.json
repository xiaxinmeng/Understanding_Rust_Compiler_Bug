{"sha": "d113ff8ada02d4ea253d78b77186637a7d7344bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxMTNmZjhhZGEwMmQ0ZWEyNTNkNzhiNzcxODY2MzdhN2Q3MzQ0YmI=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-03-08T01:20:33Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-05-01T22:10:57Z"}, "message": "Handle generic consts in relate and infer\n\nCo-Authored-By: Gabriel Smith <yodaldevoid@users.noreply.github.com>", "tree": {"sha": "a67ea81f22524dc29e0bf3d0b3878ceb47e29ba0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a67ea81f22524dc29e0bf3d0b3878ceb47e29ba0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d113ff8ada02d4ea253d78b77186637a7d7344bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d113ff8ada02d4ea253d78b77186637a7d7344bb", "html_url": "https://github.com/rust-lang/rust/commit/d113ff8ada02d4ea253d78b77186637a7d7344bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d113ff8ada02d4ea253d78b77186637a7d7344bb/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69423b334503c1f860f0dd7b8568dd99fa380e3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/69423b334503c1f860f0dd7b8568dd99fa380e3b", "html_url": "https://github.com/rust-lang/rust/commit/69423b334503c1f860f0dd7b8568dd99fa380e3b"}], "stats": {"total": 94, "additions": 78, "deletions": 16}, "files": [{"sha": "65c579aedf2f44953f836a59e3206fb4e3501553", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d113ff8ada02d4ea253d78b77186637a7d7344bb/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d113ff8ada02d4ea253d78b77186637a7d7344bb/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=d113ff8ada02d4ea253d78b77186637a7d7344bb", "patch": "@@ -16,6 +16,7 @@ use crate::infer::canonical::{\n use crate::infer::region_constraints::{Constraint, RegionConstraintData};\n use crate::infer::InferCtxtBuilder;\n use crate::infer::{InferCtxt, InferOk, InferResult};\n+use crate::mir::interpret::ConstValue;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::fmt::Debug;\n@@ -25,7 +26,7 @@ use crate::traits::TraitEngine;\n use crate::traits::{Obligation, ObligationCause, PredicateObligation};\n use crate::ty::fold::TypeFoldable;\n use crate::ty::subst::{Kind, UnpackedKind};\n-use crate::ty::{self, BoundVar, Lift, Ty, TyCtxt};\n+use crate::ty::{self, BoundVar, InferConst, Lift, Ty, TyCtxt};\n use crate::util::captures::Captures;\n \n impl<'cx, 'gcx, 'tcx> InferCtxtBuilder<'cx, 'gcx, 'tcx> {\n@@ -479,8 +480,17 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                         opt_values[br.assert_bound_var()] = Some(*original_value);\n                     }\n                 }\n-                UnpackedKind::Const(..) => {\n-                    unimplemented!() // FIXME(const_generics)\n+                UnpackedKind::Const(result_value) => {\n+                    if let ty::LazyConst::Evaluated(ty::Const {\n+                        val: ConstValue::Infer(InferConst::Canonical(debrujin, b)),\n+                        ..\n+                    }) = result_value {\n+                        // ...in which case we would set `canonical_vars[0]` to `Some(const X)`.\n+\n+                        // We only allow a `ty::INNERMOST` index in substitutions.\n+                        assert_eq!(*debrujin, ty::INNERMOST);\n+                        opt_values[*b] = Some(*original_value);\n+                    }\n                 }\n             }\n         }"}, {"sha": "30a398de19ae77715e1cc1e7c4866920223ef7ce", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d113ff8ada02d4ea253d78b77186637a7d7344bb/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d113ff8ada02d4ea253d78b77186637a7d7344bb/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=d113ff8ada02d4ea253d78b77186637a7d7344bb", "patch": "@@ -1,13 +1,14 @@\n use super::{InferCtxt, FixupError, FixupResult, Span, type_variable::TypeVariableOrigin};\n-use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use crate::mir::interpret::ConstValue;\n+use crate::ty::{self, Ty, TyCtxt, TypeFoldable, InferConst};\n use crate::ty::fold::{TypeFolder, TypeVisitor};\n \n ///////////////////////////////////////////////////////////////////////////\n // OPPORTUNISTIC TYPE RESOLVER\n \n /// The opportunistic type resolver can be used at any time. It simply replaces\n /// type variables that have been unified with the things they have\n-/// been unified with (similar to `shallow_resolve`, but deep). This is\n+/// been unified with (similar to `shallow_resolve_type`, but deep). This is\n /// useful for printing messages etc but also required at various\n /// points for correctness.\n pub struct OpportunisticTypeResolver<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n@@ -30,7 +31,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticTypeResolver<'a, 'g\n         if !t.has_infer_types() {\n             t // micro-optimize -- if there is nothing in this type that this fold affects...\n         } else {\n-            let t0 = self.infcx.shallow_resolve(t);\n+            let t0 = self.infcx.shallow_resolve_type(t);\n             t0.super_fold_with(self)\n         }\n     }\n@@ -58,7 +59,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticTypeAndRegionResolv\n         if !t.needs_infer() {\n             t // micro-optimize -- if there is nothing in this type that this fold affects...\n         } else {\n-            let t0 = self.infcx.shallow_resolve(t);\n+            let t0 = self.infcx.shallow_resolve_type(t);\n             t0.super_fold_with(self)\n         }\n     }\n@@ -72,6 +73,15 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticTypeAndRegionResolv\n                 r,\n         }\n     }\n+\n+    fn fold_const(&mut self, ct: &'tcx ty::LazyConst<'tcx>) -> &'tcx ty::LazyConst<'tcx> {\n+        if !ct.needs_infer() {\n+            ct // micro-optimize -- if there is nothing in this const that this fold affects...\n+        } else {\n+            let c0 = self.infcx.shallow_resolve_const(ct);\n+            c0.super_fold_with(self)\n+        }\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -96,7 +106,7 @@ impl<'a, 'gcx, 'tcx> UnresolvedTypeFinder<'a, 'gcx, 'tcx> {\n \n impl<'a, 'gcx, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeFinder<'a, 'gcx, 'tcx> {\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n-        let t = self.infcx.shallow_resolve(t);\n+        let t = self.infcx.shallow_resolve_type(t);\n         if t.has_infer_types() {\n             if let ty::Infer(infer_ty) = t.sty {\n                 // Since we called `shallow_resolve` above, this must\n@@ -136,7 +146,7 @@ impl<'a, 'gcx, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeFinder<'a, 'gcx, 'tcx>\n /// their concrete results. If any variable cannot be replaced (never unified, etc)\n /// then an `Err` result is returned.\n pub fn fully_resolve<'a, 'gcx, 'tcx, T>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                        value: &T) -> FixupResult<T>\n+                                        value: &T) -> FixupResult<'tcx, T>\n     where T : TypeFoldable<'tcx>\n {\n     let mut full_resolver = FullTypeResolver { infcx: infcx, err: None };\n@@ -151,7 +161,7 @@ pub fn fully_resolve<'a, 'gcx, 'tcx, T>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n // `err` field is not enforcable otherwise.\n struct FullTypeResolver<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    err: Option<FixupError>,\n+    err: Option<FixupError<'tcx>>,\n }\n \n impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for FullTypeResolver<'a, 'gcx, 'tcx> {\n@@ -165,7 +175,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for FullTypeResolver<'a, 'gcx, 'tcx>\n               // ^ we need to have the `keep_local` check to un-default\n               // defaulted tuples.\n         } else {\n-            let t = self.infcx.shallow_resolve(t);\n+            let t = self.infcx.shallow_resolve_type(t);\n             match t.sty {\n                 ty::Infer(ty::TyVar(vid)) => {\n                     self.err = Some(FixupError::UnresolvedTy(vid));\n@@ -199,4 +209,30 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for FullTypeResolver<'a, 'gcx, 'tcx>\n             _ => r,\n         }\n     }\n+\n+    fn fold_const(&mut self, c: &'tcx ty::LazyConst<'tcx>) -> &'tcx ty::LazyConst<'tcx> {\n+        if !c.needs_infer() && !ty::keep_local(&c) {\n+            c // micro-optimize -- if there is nothing in this const that this fold affects...\n+              // ^ we need to have the `keep_local` check to un-default\n+              // defaulted tuples.\n+        } else {\n+            let c = self.infcx.shallow_resolve_const(c);\n+            match c {\n+                ty::LazyConst::Evaluated(ty::Const { val, .. }) => {\n+                    match val {\n+                        ConstValue::Infer(InferConst::Var(vid)) => {\n+                            self.err = Some(FixupError::UnresolvedConst(*vid));\n+                            return self.tcx().types.ct_err;\n+                        }\n+                        ConstValue::Infer(InferConst::Fresh(_)) => {\n+                            bug!(\"Unexpected const in full const resolver: {:?}\", c);\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+                _ => {}\n+            }\n+            c.super_fold_with(self)\n+        }\n+    }\n }"}, {"sha": "5980192a5070f0860b75995d327a4b15e012a5b2", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d113ff8ada02d4ea253d78b77186637a7d7344bb/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d113ff8ada02d4ea253d78b77186637a7d7344bb/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=d113ff8ada02d4ea253d78b77186637a7d7344bb", "patch": "@@ -7,8 +7,8 @@\n use crate::hir::def_id::DefId;\n use crate::ty::subst::{Kind, UnpackedKind, SubstsRef};\n use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use crate::ty::error::{ExpectedFound, TypeError};\n-use crate::mir::interpret::{GlobalId, ConstValue};\n+use crate::ty::error::{ExpectedFound, TypeError, ConstError};\n+use crate::mir::interpret::{GlobalId, ConstValue, Scalar};\n use crate::util::common::ErrorReported;\n use syntax_pos::DUMMY_SP;\n use std::rc::Rc;\n@@ -476,6 +476,8 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             let t = relation.relate(&a_t, &b_t)?;\n             let to_u64 = |x: ty::Const<'tcx>| -> Result<u64, ErrorReported> {\n                 match x.val {\n+                    // FIXME(const_generics): this doesn't work right now,\n+                    // because it tries to relate an `Infer` to a `Param`.\n                     ConstValue::Unevaluated(def_id, substs) => {\n                         // FIXME(eddyb) get the right param_env.\n                         let param_env = ty::ParamEnv::empty();\n@@ -489,7 +491,7 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n                             if let Some(instance) = instance {\n                                 let cid = GlobalId {\n                                     instance,\n-                                    promoted: None\n+                                    promoted: None,\n                                 };\n                                 if let Some(s) = tcx.const_eval(param_env.and(cid))\n                                                     .ok()\n@@ -718,6 +720,17 @@ impl<'tcx> Relate<'tcx> for ty::Region<'tcx> {\n     }\n }\n \n+impl<'tcx> Relate<'tcx> for &'tcx ty::LazyConst<'tcx> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &&'tcx ty::LazyConst<'tcx>,\n+                           b: &&'tcx ty::LazyConst<'tcx>)\n+                           -> RelateResult<'tcx, &'tcx ty::LazyConst<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    {\n+        relation.consts(*a, *b)\n+    }\n+}\n+\n impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for ty::Binder<T> {\n     fn relate<'a, 'gcx, R>(relation: &mut R,\n                            a: &ty::Binder<T>,\n@@ -771,14 +784,17 @@ impl<'tcx> Relate<'tcx> for Kind<'tcx> {\n             (UnpackedKind::Type(a_ty), UnpackedKind::Type(b_ty)) => {\n                 Ok(relation.relate(&a_ty, &b_ty)?.into())\n             }\n+            (UnpackedKind::Const(a_ct), UnpackedKind::Const(b_ct)) => {\n+                Ok(relation.relate(&a_ct, &b_ct)?.into())\n+            }\n             (UnpackedKind::Lifetime(unpacked), x) => {\n                 bug!(\"impossible case reached: can't relate: {:?} with {:?}\", unpacked, x)\n             }\n             (UnpackedKind::Type(unpacked), x) => {\n                 bug!(\"impossible case reached: can't relate: {:?} with {:?}\", unpacked, x)\n             }\n-            (UnpackedKind::Const(_), _) => {\n-                unimplemented!() // FIXME(const_generics)\n+            (UnpackedKind::Const(unpacked), x) => {\n+                bug!(\"impossible case reached: can't relate: {:?} with {:?}\", unpacked, x)\n             }\n         }\n     }"}]}