{"sha": "9a063bc2ed892315c8317f08f263466af35e9279", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhMDYzYmMyZWQ4OTIzMTVjODMxN2YwOGYyNjM0NjZhZjM1ZTkyNzk=", "commit": {"author": {"name": "Jubilee", "email": "46493976+workingjubilee@users.noreply.github.com", "date": "2021-05-01T07:02:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-01T07:02:33Z"}, "message": "Merge pull request #99 from rust-lang/feature/simplify-masks\n\nFeature/simplify masks", "tree": {"sha": "a98d1282160da4bb96bbe3dd31aa7c0c676f18ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a98d1282160da4bb96bbe3dd31aa7c0c676f18ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a063bc2ed892315c8317f08f263466af35e9279", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgjP0JCRBK7hj4Ov3rIwAA+RsIAGLWJkJFJP6RZWKZ7ShpjhLD\nH4X66VrJXfaLE9cIG8cMTnTABG4DT9Uhw+KtD2gGusvEKuDNGUp9XMsxZAY7sxLE\nhn91/gKMuRgo2KslZ79j0vekdY4yl1uMcD9BD3IHhnYbUKq5IRqKMfg/vqUr3zbj\nctboZxW0wk/uJz9X+dh2epJhleBQDeaz/ubnTI98FHEGnKyNh8SwE5G7yE2KnEVt\nMZeC1PmOmbwBjNS7v7Asu4+Xvmz2uqlT0aB50mt2a97/1Ci0jhZ9FIjiLcPWo7Ud\nOc6iylDcIgAmaxL7uDGj2cc9jok0mvNWo1A0jBFVcUrYg6x+tThI/1VQ32T/su8=\n=oF7R\n-----END PGP SIGNATURE-----\n", "payload": "tree a98d1282160da4bb96bbe3dd31aa7c0c676f18ff\nparent 5751179dc636d53b0f2368e81f548c1c04a7b4f2\nparent 589fce03131225f9167b6b90c6382f40ea22edb6\nauthor Jubilee <46493976+workingjubilee@users.noreply.github.com> 1619852553 -0700\ncommitter GitHub <noreply@github.com> 1619852553 -0700\n\nMerge pull request #99 from rust-lang/feature/simplify-masks\n\nFeature/simplify masks"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a063bc2ed892315c8317f08f263466af35e9279", "html_url": "https://github.com/rust-lang/rust/commit/9a063bc2ed892315c8317f08f263466af35e9279", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a063bc2ed892315c8317f08f263466af35e9279/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5751179dc636d53b0f2368e81f548c1c04a7b4f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/5751179dc636d53b0f2368e81f548c1c04a7b4f2", "html_url": "https://github.com/rust-lang/rust/commit/5751179dc636d53b0f2368e81f548c1c04a7b4f2"}, {"sha": "589fce03131225f9167b6b90c6382f40ea22edb6", "url": "https://api.github.com/repos/rust-lang/rust/commits/589fce03131225f9167b6b90c6382f40ea22edb6", "html_url": "https://github.com/rust-lang/rust/commit/589fce03131225f9167b6b90c6382f40ea22edb6"}], "stats": {"total": 1034, "additions": 443, "deletions": 591}, "files": [{"sha": "e8d11406c0979ede20a2f43e3edbfae716d4ae37", "filename": "crates/core_simd/src/comparisons.rs", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9a063bc2ed892315c8317f08f263466af35e9279/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a063bc2ed892315c8317f08f263466af35e9279/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs?ref=9a063bc2ed892315c8317f08f263466af35e9279", "patch": "@@ -1,64 +1,59 @@\n use crate::LanesAtMost32;\n \n macro_rules! implement_mask_ops {\n-    { $($vector:ident => $mask:ident ($inner_mask_ty:ident, $inner_ty:ident),)* } => {\n+    { $($vector:ident => $mask:ident ($inner_ty:ident),)* } => {\n         $(\n             impl<const LANES: usize> crate::$vector<LANES>\n             where\n                 crate::$vector<LANES>: LanesAtMost32,\n                 crate::$inner_ty<LANES>: LanesAtMost32,\n+                crate::$mask<LANES>: crate::Mask,\n             {\n                 /// Test if each lane is equal to the corresponding lane in `other`.\n                 #[inline]\n                 pub fn lanes_eq(self, other: Self) -> crate::$mask<LANES> {\n                     unsafe {\n-                        crate::$inner_mask_ty::from_int_unchecked(crate::intrinsics::simd_eq(self, other))\n-                            .into()\n+                        crate::$mask::from_int_unchecked(crate::intrinsics::simd_eq(self, other))\n                     }\n                 }\n \n                 /// Test if each lane is not equal to the corresponding lane in `other`.\n                 #[inline]\n                 pub fn lanes_ne(self, other: Self) -> crate::$mask<LANES> {\n                     unsafe {\n-                        crate::$inner_mask_ty::from_int_unchecked(crate::intrinsics::simd_ne(self, other))\n-                            .into()\n+                        crate::$mask::from_int_unchecked(crate::intrinsics::simd_ne(self, other))\n                     }\n                 }\n \n                 /// Test if each lane is less than the corresponding lane in `other`.\n                 #[inline]\n                 pub fn lanes_lt(self, other: Self) -> crate::$mask<LANES> {\n                     unsafe {\n-                        crate::$inner_mask_ty::from_int_unchecked(crate::intrinsics::simd_lt(self, other))\n-                            .into()\n+                        crate::$mask::from_int_unchecked(crate::intrinsics::simd_lt(self, other))\n                     }\n                 }\n \n                 /// Test if each lane is greater than the corresponding lane in `other`.\n                 #[inline]\n                 pub fn lanes_gt(self, other: Self) -> crate::$mask<LANES> {\n                     unsafe {\n-                        crate::$inner_mask_ty::from_int_unchecked(crate::intrinsics::simd_gt(self, other))\n-                            .into()\n+                        crate::$mask::from_int_unchecked(crate::intrinsics::simd_gt(self, other))\n                     }\n                 }\n \n                 /// Test if each lane is less than or equal to the corresponding lane in `other`.\n                 #[inline]\n                 pub fn lanes_le(self, other: Self) -> crate::$mask<LANES> {\n                     unsafe {\n-                        crate::$inner_mask_ty::from_int_unchecked(crate::intrinsics::simd_le(self, other))\n-                            .into()\n+                        crate::$mask::from_int_unchecked(crate::intrinsics::simd_le(self, other))\n                     }\n                 }\n \n                 /// Test if each lane is greater than or equal to the corresponding lane in `other`.\n                 #[inline]\n                 pub fn lanes_ge(self, other: Self) -> crate::$mask<LANES> {\n                     unsafe {\n-                        crate::$inner_mask_ty::from_int_unchecked(crate::intrinsics::simd_ge(self, other))\n-                            .into()\n+                        crate::$mask::from_int_unchecked(crate::intrinsics::simd_ge(self, other))\n                     }\n                 }\n             }\n@@ -67,18 +62,18 @@ macro_rules! implement_mask_ops {\n }\n \n implement_mask_ops! {\n-    SimdI8 => Mask8 (SimdMask8, SimdI8),\n-    SimdI16 => Mask16 (SimdMask16, SimdI16),\n-    SimdI32 => Mask32 (SimdMask32, SimdI32),\n-    SimdI64 => Mask64 (SimdMask64, SimdI64),\n-    SimdIsize => MaskSize (SimdMaskSize, SimdIsize),\n+    SimdI8 => Mask8 (SimdI8),\n+    SimdI16 => Mask16 (SimdI16),\n+    SimdI32 => Mask32 (SimdI32),\n+    SimdI64 => Mask64 (SimdI64),\n+    SimdIsize => MaskSize (SimdIsize),\n \n-    SimdU8 => Mask8 (SimdMask8, SimdI8),\n-    SimdU16 => Mask16 (SimdMask16, SimdI16),\n-    SimdU32 => Mask32 (SimdMask32, SimdI32),\n-    SimdU64 => Mask64 (SimdMask64, SimdI64),\n-    SimdUsize => MaskSize (SimdMaskSize, SimdIsize),\n+    SimdU8 => Mask8 (SimdI8),\n+    SimdU16 => Mask16 (SimdI16),\n+    SimdU32 => Mask32 (SimdI32),\n+    SimdU64 => Mask64 (SimdI64),\n+    SimdUsize => MaskSize (SimdIsize),\n \n-    SimdF32 => Mask32 (SimdMask32, SimdI32),\n-    SimdF64 => Mask64 (SimdMask64, SimdI64),\n+    SimdF32 => Mask32 (SimdI32),\n+    SimdF64 => Mask64 (SimdI64),\n }"}, {"sha": "8cbb0cbccf7939b41b954457d333fdab09467334", "filename": "crates/core_simd/src/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a063bc2ed892315c8317f08f263466af35e9279/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a063bc2ed892315c8317f08f263466af35e9279/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs?ref=9a063bc2ed892315c8317f08f263466af35e9279", "patch": "@@ -76,6 +76,12 @@ extern \"platform-intrinsic\" {\n     pub(crate) fn simd_reduce_and<T, U>(x: T) -> U;\n     pub(crate) fn simd_reduce_or<T, U>(x: T) -> U;\n     pub(crate) fn simd_reduce_xor<T, U>(x: T) -> U;\n+\n+    // truncate integer vector to bitmask\n+    pub(crate) fn simd_bitmask<T, U>(x: T) -> U;\n+\n+    // select\n+    pub(crate) fn simd_select_bitmask<T, U>(m: T, a: U, b: U) -> U;\n }\n \n #[cfg(feature = \"std\")]"}, {"sha": "2d84b1306ea5a50f3b43f0644d4a00d8b3eed17f", "filename": "crates/core_simd/src/lanes_at_most_32.rs", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9a063bc2ed892315c8317f08f263466af35e9279/crates%2Fcore_simd%2Fsrc%2Flanes_at_most_32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a063bc2ed892315c8317f08f263466af35e9279/crates%2Fcore_simd%2Fsrc%2Flanes_at_most_32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Flanes_at_most_32.rs?ref=9a063bc2ed892315c8317f08f263466af35e9279", "patch": "@@ -1,14 +1,38 @@\n-/// Implemented for bitmask sizes that are supported by the implementation.\n-pub trait LanesAtMost32 {}\n+/// Implemented for vectors that are supported by the implementation.\n+pub trait LanesAtMost32: sealed::Sealed {\n+    #[doc(hidden)]\n+    type BitMask: Into<u64>;\n+}\n+\n+mod sealed {\n+    pub trait Sealed {}\n+}\n \n macro_rules! impl_for {\n     { $name:ident } => {\n-        impl LanesAtMost32 for $name<1> {}\n-        impl LanesAtMost32 for $name<2> {}\n-        impl LanesAtMost32 for $name<4> {}\n-        impl LanesAtMost32 for $name<8> {}\n-        impl LanesAtMost32 for $name<16> {}\n-        impl LanesAtMost32 for $name<32> {}\n+        impl<const LANES: usize> sealed::Sealed for $name<LANES>\n+        where\n+            $name<LANES>: LanesAtMost32,\n+        {}\n+\n+        impl LanesAtMost32 for $name<1> {\n+            type BitMask = u8;\n+        }\n+        impl LanesAtMost32 for $name<2> {\n+            type BitMask = u8;\n+        }\n+        impl LanesAtMost32 for $name<4> {\n+            type BitMask = u8;\n+        }\n+        impl LanesAtMost32 for $name<8> {\n+            type BitMask = u8;\n+        }\n+        impl LanesAtMost32 for $name<16> {\n+            type BitMask = u16;\n+        }\n+        impl LanesAtMost32 for $name<32> {\n+            type BitMask = u32;\n+        }\n     }\n }\n \n@@ -28,5 +52,3 @@ impl_for! { SimdIsize }\n \n impl_for! { SimdF32 }\n impl_for! { SimdF64 }\n-\n-impl_for! { BitMask }"}, {"sha": "6bcb08cf9dbb70d247af48c34a00d4ecb3eaa901", "filename": "crates/core_simd/src/masks/bitmask.rs", "status": "modified", "additions": 109, "deletions": 150, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/9a063bc2ed892315c8317f08f263466af35e9279/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a063bc2ed892315c8317f08f263466af35e9279/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs?ref=9a063bc2ed892315c8317f08f263466af35e9279", "patch": "@@ -1,212 +1,171 @@\n-use crate::LanesAtMost32;\n+use crate::Mask;\n+use core::marker::PhantomData;\n+\n+/// Helper trait for limiting int conversion types\n+pub trait ConvertToInt {}\n+impl<const LANES: usize> ConvertToInt for crate::SimdI8<LANES> where Self: crate::LanesAtMost32 {}\n+impl<const LANES: usize> ConvertToInt for crate::SimdI16<LANES> where Self: crate::LanesAtMost32 {}\n+impl<const LANES: usize> ConvertToInt for crate::SimdI32<LANES> where Self: crate::LanesAtMost32 {}\n+impl<const LANES: usize> ConvertToInt for crate::SimdI64<LANES> where Self: crate::LanesAtMost32 {}\n+impl<const LANES: usize> ConvertToInt for crate::SimdIsize<LANES> where Self: crate::LanesAtMost32 {}\n \n /// A mask where each lane is represented by a single bit.\n-#[derive(Copy, Clone, Debug, PartialOrd, PartialEq, Ord, Eq, Hash)]\n #[repr(transparent)]\n-pub struct BitMask<const LANES: usize>(u64)\n-where\n-    BitMask<LANES>: LanesAtMost32;\n+pub struct BitMask<T: Mask, const LANES: usize>(T::BitMask, PhantomData<[(); LANES]>);\n \n-impl<const LANES: usize> BitMask<LANES>\n-where\n-    Self: LanesAtMost32,\n-{\n-    /// Construct a mask by setting all lanes to the given value.\n-    pub fn splat(value: bool) -> Self {\n-        if value {\n-            Self(u64::MAX >> (64 - LANES))\n-        } else {\n-            Self(u64::MIN)\n-        }\n-    }\n+impl<T: Mask, const LANES: usize> Copy for BitMask<T, LANES> {}\n \n-    /// Tests the value of the specified lane.\n-    ///\n-    /// # Panics\n-    /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n-    #[inline]\n-    pub fn test(&self, lane: usize) -> bool {\n-        assert!(lane < LANES, \"lane index out of range\");\n-        (self.0 >> lane) & 0x1 > 0\n-    }\n-\n-    /// Sets the value of the specified lane.\n-    ///\n-    /// # Panics\n-    /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n-    #[inline]\n-    pub fn set(&mut self, lane: usize, value: bool) {\n-        assert!(lane < LANES, \"lane index out of range\");\n-        self.0 ^= ((value ^ self.test(lane)) as u64) << lane\n+impl<T: Mask, const LANES: usize> Clone for BitMask<T, LANES> {\n+    fn clone(&self) -> Self {\n+        *self\n     }\n }\n \n-impl<const LANES: usize> core::ops::BitAnd for BitMask<LANES>\n-where\n-    Self: LanesAtMost32,\n-{\n-    type Output = Self;\n-    #[inline]\n-    fn bitand(self, rhs: Self) -> Self {\n-        Self(self.0 & rhs.0)\n+impl<T: Mask, const LANES: usize> PartialEq for BitMask<T, LANES> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.0.as_ref() == other.0.as_ref()\n     }\n }\n \n-impl<const LANES: usize> core::ops::BitAnd<bool> for BitMask<LANES>\n-where\n-    Self: LanesAtMost32,\n-{\n-    type Output = Self;\n-    #[inline]\n-    fn bitand(self, rhs: bool) -> Self {\n-        self & Self::splat(rhs)\n+impl<T: Mask, const LANES: usize> PartialOrd for BitMask<T, LANES> {\n+    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n+        self.0.as_ref().partial_cmp(other.0.as_ref())\n     }\n }\n \n-impl<const LANES: usize> core::ops::BitAnd<BitMask<LANES>> for bool\n-where\n-    BitMask<LANES>: LanesAtMost32,\n-{\n-    type Output = BitMask<LANES>;\n-    #[inline]\n-    fn bitand(self, rhs: BitMask<LANES>) -> BitMask<LANES> {\n-        BitMask::<LANES>::splat(self) & rhs\n-    }\n-}\n+impl<T: Mask, const LANES: usize> Eq for BitMask<T, LANES> {}\n \n-impl<const LANES: usize> core::ops::BitOr for BitMask<LANES>\n-where\n-    Self: LanesAtMost32,\n-{\n-    type Output = Self;\n-    #[inline]\n-    fn bitor(self, rhs: Self) -> Self {\n-        Self(self.0 | rhs.0)\n+impl<T: Mask, const LANES: usize> Ord for BitMask<T, LANES> {\n+    fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n+        self.0.as_ref().cmp(other.0.as_ref())\n     }\n }\n \n-impl<const LANES: usize> core::ops::BitOr<bool> for BitMask<LANES>\n-where\n-    Self: LanesAtMost32,\n-{\n-    type Output = Self;\n+impl<T: Mask, const LANES: usize> BitMask<T, LANES> {\n     #[inline]\n-    fn bitor(self, rhs: bool) -> Self {\n-        self | Self::splat(rhs)\n+    pub fn splat(value: bool) -> Self {\n+        let mut mask = T::BitMask::default();\n+        if value {\n+            mask.as_mut().fill(u8::MAX)\n+        } else {\n+            mask.as_mut().fill(u8::MIN)\n+        }\n+        if LANES % 8 > 0 {\n+            *mask.as_mut().last_mut().unwrap() &= u8::MAX >> (8 - LANES % 8);\n+        }\n+        Self(mask, PhantomData)\n     }\n-}\n \n-impl<const LANES: usize> core::ops::BitOr<BitMask<LANES>> for bool\n-where\n-    BitMask<LANES>: LanesAtMost32,\n-{\n-    type Output = BitMask<LANES>;\n     #[inline]\n-    fn bitor(self, rhs: BitMask<LANES>) -> BitMask<LANES> {\n-        BitMask::<LANES>::splat(self) | rhs\n+    pub unsafe fn test_unchecked(&self, lane: usize) -> bool {\n+        (self.0.as_ref()[lane / 8] >> lane % 8) & 0x1 > 0\n     }\n-}\n \n-impl<const LANES: usize> core::ops::BitXor for BitMask<LANES>\n-where\n-    Self: LanesAtMost32,\n-{\n-    type Output = Self;\n     #[inline]\n-    fn bitxor(self, rhs: Self) -> Self::Output {\n-        Self(self.0 ^ rhs.0)\n+    pub unsafe fn set_unchecked(&mut self, lane: usize, value: bool) {\n+        self.0.as_mut()[lane / 8] ^= ((value ^ self.test_unchecked(lane)) as u8) << (lane % 8)\n     }\n-}\n \n-impl<const LANES: usize> core::ops::BitXor<bool> for BitMask<LANES>\n-where\n-    Self: LanesAtMost32,\n-{\n-    type Output = Self;\n     #[inline]\n-    fn bitxor(self, rhs: bool) -> Self::Output {\n-        self ^ Self::splat(rhs)\n+    pub fn to_int<V>(self) -> V\n+    where\n+        V: ConvertToInt + Default + core::ops::Not<Output = V>,\n+    {\n+        unsafe {\n+            let mask: T::IntBitMask = core::mem::transmute_copy(&self);\n+            crate::intrinsics::simd_select_bitmask(mask, !V::default(), V::default())\n+        }\n     }\n-}\n \n-impl<const LANES: usize> core::ops::BitXor<BitMask<LANES>> for bool\n-where\n-    BitMask<LANES>: LanesAtMost32,\n-{\n-    type Output = BitMask<LANES>;\n     #[inline]\n-    fn bitxor(self, rhs: BitMask<LANES>) -> Self::Output {\n-        BitMask::<LANES>::splat(self) ^ rhs\n+    pub unsafe fn from_int_unchecked<V>(value: V) -> Self\n+    where\n+        V: crate::LanesAtMost32,\n+    {\n+        // TODO remove the transmute when rustc is more flexible\n+        assert_eq!(\n+            core::mem::size_of::<T::IntBitMask>(),\n+            core::mem::size_of::<T::BitMask>()\n+        );\n+        let mask: T::IntBitMask = crate::intrinsics::simd_bitmask(value);\n+        Self(core::mem::transmute_copy(&mask), PhantomData)\n     }\n-}\n \n-impl<const LANES: usize> core::ops::Not for BitMask<LANES>\n-where\n-    Self: LanesAtMost32,\n-{\n-    type Output = BitMask<LANES>;\n     #[inline]\n-    fn not(self) -> Self::Output {\n-        Self(!self.0)\n+    pub fn to_bitmask<U: Mask>(self) -> U::BitMask {\n+        assert_eq!(\n+            core::mem::size_of::<T::BitMask>(),\n+            core::mem::size_of::<U::BitMask>()\n+        );\n+        unsafe { core::mem::transmute_copy(&self.0) }\n     }\n-}\n \n-impl<const LANES: usize> core::ops::BitAndAssign for BitMask<LANES>\n-where\n-    Self: LanesAtMost32,\n-{\n     #[inline]\n-    fn bitand_assign(&mut self, rhs: Self) {\n-        self.0 &= rhs.0;\n+    pub fn any(self) -> bool {\n+        self != Self::splat(false)\n     }\n-}\n \n-impl<const LANES: usize> core::ops::BitAndAssign<bool> for BitMask<LANES>\n-where\n-    Self: LanesAtMost32,\n-{\n     #[inline]\n-    fn bitand_assign(&mut self, rhs: bool) {\n-        *self &= Self::splat(rhs);\n+    pub fn all(self) -> bool {\n+        self == Self::splat(true)\n     }\n }\n \n-impl<const LANES: usize> core::ops::BitOrAssign for BitMask<LANES>\n+impl<T: Mask, const LANES: usize> core::ops::BitAnd for BitMask<T, LANES>\n where\n-    Self: LanesAtMost32,\n+    T::BitMask: Default + AsRef<[u8]> + AsMut<[u8]>,\n {\n+    type Output = Self;\n     #[inline]\n-    fn bitor_assign(&mut self, rhs: Self) {\n-        self.0 |= rhs.0;\n+    fn bitand(mut self, rhs: Self) -> Self {\n+        for (l, r) in self.0.as_mut().iter_mut().zip(rhs.0.as_ref().iter()) {\n+            *l &= r;\n+        }\n+        self\n     }\n }\n \n-impl<const LANES: usize> core::ops::BitOrAssign<bool> for BitMask<LANES>\n+impl<T: Mask, const LANES: usize> core::ops::BitOr for BitMask<T, LANES>\n where\n-    Self: LanesAtMost32,\n+    T::BitMask: Default + AsRef<[u8]> + AsMut<[u8]>,\n {\n+    type Output = Self;\n     #[inline]\n-    fn bitor_assign(&mut self, rhs: bool) {\n-        *self |= Self::splat(rhs);\n+    fn bitor(mut self, rhs: Self) -> Self {\n+        for (l, r) in self.0.as_mut().iter_mut().zip(rhs.0.as_ref().iter()) {\n+            *l |= r;\n+        }\n+        self\n     }\n }\n \n-impl<const LANES: usize> core::ops::BitXorAssign for BitMask<LANES>\n-where\n-    Self: LanesAtMost32,\n-{\n+impl<T: Mask, const LANES: usize> core::ops::BitXor for BitMask<T, LANES> {\n+    type Output = Self;\n     #[inline]\n-    fn bitxor_assign(&mut self, rhs: Self) {\n-        self.0 ^= rhs.0;\n+    fn bitxor(mut self, rhs: Self) -> Self::Output {\n+        for (l, r) in self.0.as_mut().iter_mut().zip(rhs.0.as_ref().iter()) {\n+            *l ^= r;\n+        }\n+        self\n     }\n }\n \n-impl<const LANES: usize> core::ops::BitXorAssign<bool> for BitMask<LANES>\n-where\n-    Self: LanesAtMost32,\n-{\n+impl<T: Mask, const LANES: usize> core::ops::Not for BitMask<T, LANES> {\n+    type Output = Self;\n     #[inline]\n-    fn bitxor_assign(&mut self, rhs: bool) {\n-        *self ^= Self::splat(rhs);\n+    fn not(mut self) -> Self::Output {\n+        for x in self.0.as_mut() {\n+            *x = !*x;\n+        }\n+        if LANES % 8 > 0 {\n+            *self.0.as_mut().last_mut().unwrap() &= u8::MAX >> (8 - LANES % 8);\n+        }\n+        self\n     }\n }\n+\n+pub type Mask8<T, const LANES: usize> = BitMask<T, LANES>;\n+pub type Mask16<T, const LANES: usize> = BitMask<T, LANES>;\n+pub type Mask32<T, const LANES: usize> = BitMask<T, LANES>;\n+pub type Mask64<T, const LANES: usize> = BitMask<T, LANES>;\n+pub type MaskSize<T, const LANES: usize> = BitMask<T, LANES>;"}, {"sha": "f89bbefba631c6c281ff69ad6b93646768f2cfbb", "filename": "crates/core_simd/src/masks/full_masks.rs", "status": "modified", "additions": 81, "deletions": 291, "changes": 372, "blob_url": "https://github.com/rust-lang/rust/blob/9a063bc2ed892315c8317f08f263466af35e9279/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a063bc2ed892315c8317f08f263466af35e9279/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs?ref=9a063bc2ed892315c8317f08f263466af35e9279", "patch": "@@ -1,17 +1,7 @@\n //! Masks that take up full SIMD vector registers.\n \n-/// The error type returned when converting an integer to a mask fails.\n-#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n-pub struct TryFromMaskError(());\n-\n-impl core::fmt::Display for TryFromMaskError {\n-    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-        write!(\n-            f,\n-            \"mask vector must have all bits set or unset in each lane\"\n-        )\n-    }\n-}\n+use crate::Mask;\n+use core::marker::PhantomData;\n \n macro_rules! define_mask {\n     {\n@@ -21,18 +11,19 @@ macro_rules! define_mask {\n         );\n     } => {\n         $(#[$attr])*\n-        #[derive(Default, PartialEq, PartialOrd, Eq, Ord, Hash)]\n         #[repr(transparent)]\n-        pub struct $name<const $lanes: usize>(crate::$type<$lanes2>)\n+        pub struct $name<T: Mask, const $lanes: usize>(crate::$type<$lanes2>, PhantomData<T>)\n         where\n             crate::$type<LANES>: crate::LanesAtMost32;\n \n-        impl<const LANES: usize> Copy for $name<LANES>\n+        impl_full_mask_reductions! { $name, $type }\n+\n+        impl<T: Mask, const LANES: usize> Copy for $name<T, LANES>\n         where\n             crate::$type<LANES>: crate::LanesAtMost32,\n         {}\n \n-        impl<const LANES: usize> Clone for $name<LANES>\n+        impl<T: Mask, const LANES: usize> Clone for $name<T, LANES>\n         where\n             crate::$type<LANES>: crate::LanesAtMost32,\n         {\n@@ -42,383 +33,182 @@ macro_rules! define_mask {\n             }\n         }\n \n-        impl<const LANES: usize> $name<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            /// Construct a mask by setting all lanes to the given value.\n-            pub fn splat(value: bool) -> Self {\n-                Self(<crate::$type<LANES>>::splat(\n-                    if value {\n-                        -1\n-                    } else {\n-                        0\n-                    }\n-                ))\n-            }\n-\n-            /// Tests the value of the specified lane.\n-            ///\n-            /// # Panics\n-            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n-            #[inline]\n-            pub fn test(&self, lane: usize) -> bool {\n-                assert!(lane < LANES, \"lane index out of range\");\n-                self.0[lane] == -1\n-            }\n-\n-            /// Sets the value of the specified lane.\n-            ///\n-            /// # Panics\n-            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n-            #[inline]\n-            pub fn set(&mut self, lane: usize, value: bool) {\n-                assert!(lane < LANES, \"lane index out of range\");\n-                self.0[lane] = if value {\n-                    -1\n-                } else {\n-                    0\n-                }\n-            }\n-\n-            /// Converts the mask to the equivalent integer representation, where -1 represents\n-            /// \"set\" and 0 represents \"unset\".\n-            #[inline]\n-            pub fn to_int(self) -> crate::$type<LANES> {\n-                self.0\n-            }\n-\n-            /// Creates a  mask from the equivalent integer representation, where -1 represents\n-            /// \"set\" and 0 represents \"unset\".\n-            ///\n-            /// Each provided lane must be either 0 or -1.\n-            #[inline]\n-            pub unsafe fn from_int_unchecked(value: crate::$type<LANES>) -> Self {\n-                Self(value)\n-            }\n-\n-            /// Creates a mask from the equivalent integer representation, where -1 represents\n-            /// \"set\" and 0 represents \"unset\".\n-            ///\n-            /// # Panics\n-            /// Panics if any lane is not 0 or -1.\n-            #[inline]\n-            pub fn from_int(value: crate::$type<LANES>) -> Self {\n-                use core::convert::TryInto;\n-                value.try_into().unwrap()\n-            }\n-        }\n-\n-        impl<const LANES: usize> core::convert::From<bool> for $name<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            fn from(value: bool) -> Self {\n-                Self::splat(value)\n-            }\n-        }\n-\n-        impl<const LANES: usize> core::convert::TryFrom<crate::$type<LANES>> for $name<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            type Error = TryFromMaskError;\n-            fn try_from(value: crate::$type<LANES>) -> Result<Self, Self::Error> {\n-                let valid = (value.lanes_eq(crate::$type::<LANES>::splat(0)) | value.lanes_eq(crate::$type::<LANES>::splat(-1))).all();\n-                if valid {\n-                    Ok(Self(value))\n-                } else {\n-                    Err(TryFromMaskError(()))\n-                }\n-            }\n-        }\n-\n-        impl<const LANES: usize> core::convert::From<$name<LANES>> for crate::$type<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            fn from(value: $name<LANES>) -> Self {\n-                value.0\n-            }\n-        }\n-\n-        impl<const LANES: usize> core::convert::From<crate::BitMask<LANES>> for $name<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-            crate::BitMask<LANES>: crate::LanesAtMost32,\n-        {\n-            fn from(value: crate::BitMask<LANES>) -> Self {\n-                // TODO use an intrinsic to do this efficiently (with LLVM's sext instruction)\n-                let mut mask = Self::splat(false);\n-                for lane in 0..LANES {\n-                    mask.set(lane, value.test(lane));\n-                }\n-                mask\n-            }\n-        }\n-\n-        impl<const LANES: usize> core::convert::From<$name<LANES>> for crate::BitMask<LANES>\n+        impl<T: Mask, const LANES: usize> PartialEq for $name<T, LANES>\n         where\n             crate::$type<LANES>: crate::LanesAtMost32,\n-            crate::BitMask<LANES>: crate::LanesAtMost32,\n         {\n-            fn from(value: $name<$lanes>) -> Self {\n-                // TODO use an intrinsic to do this efficiently (with LLVM's trunc instruction)\n-                let mut mask = Self::splat(false);\n-                for lane in 0..LANES {\n-                    mask.set(lane, value.test(lane));\n-                }\n-                mask\n+            fn eq(&self, other: &Self) -> bool {\n+                self.0 == other.0\n             }\n         }\n \n-        impl<const LANES: usize> core::fmt::Debug for $name<LANES>\n+        impl<T: Mask, const LANES: usize> PartialOrd for $name<T, LANES>\n         where\n             crate::$type<LANES>: crate::LanesAtMost32,\n         {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                f.debug_list()\n-                    .entries((0..LANES).map(|lane| self.test(lane)))\n-                    .finish()\n+            fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n+                self.0.partial_cmp(&other.0)\n             }\n         }\n \n-        impl<const LANES: usize> core::fmt::Binary for $name<LANES>\n+        impl<T: Mask, const LANES: usize> Eq for $name<T, LANES>\n         where\n             crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                core::fmt::Binary::fmt(&self.0, f)\n-            }\n-        }\n-\n-        impl<const LANES: usize> core::fmt::Octal for $name<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                core::fmt::Octal::fmt(&self.0, f)\n-            }\n-        }\n+        {}\n \n-        impl<const LANES: usize> core::fmt::LowerHex for $name<LANES>\n+        impl<T: Mask, const LANES: usize> Ord for $name<T, LANES>\n         where\n             crate::$type<LANES>: crate::LanesAtMost32,\n         {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                core::fmt::LowerHex::fmt(&self.0, f)\n+            fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n+                self.0.cmp(&other.0)\n             }\n         }\n \n-        impl<const LANES: usize> core::fmt::UpperHex for $name<LANES>\n+        impl<T: Mask, const LANES: usize> $name<T, LANES>\n         where\n             crate::$type<LANES>: crate::LanesAtMost32,\n         {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                core::fmt::UpperHex::fmt(&self.0, f)\n+            pub fn splat(value: bool) -> Self {\n+                Self(\n+                    <crate::$type<LANES>>::splat(\n+                        if value {\n+                            -1\n+                        } else {\n+                            0\n+                        }\n+                    ),\n+                    PhantomData,\n+                )\n             }\n-        }\n \n-        impl<const LANES: usize> core::ops::BitAnd for $name<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            type Output = Self;\n             #[inline]\n-            fn bitand(self, rhs: Self) -> Self {\n-                Self(self.0 & rhs.0)\n+            pub unsafe fn test_unchecked(&self, lane: usize) -> bool {\n+                self.0[lane] == -1\n             }\n-        }\n \n-        impl<const LANES: usize> core::ops::BitAnd<bool> for $name<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            type Output = Self;\n             #[inline]\n-            fn bitand(self, rhs: bool) -> Self {\n-                self & Self::splat(rhs)\n+            pub unsafe fn set_unchecked(&mut self, lane: usize, value: bool) {\n+                self.0[lane] = if value {\n+                    -1\n+                } else {\n+                    0\n+                }\n             }\n-        }\n \n-        impl<const LANES: usize> core::ops::BitAnd<$name<LANES>> for bool\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            type Output = $name<LANES>;\n             #[inline]\n-            fn bitand(self, rhs: $name<LANES>) -> $name<LANES> {\n-                $name::<LANES>::splat(self) & rhs\n+            pub fn to_int(self) -> crate::$type<LANES> {\n+                self.0\n             }\n-        }\n \n-        impl<const LANES: usize> core::ops::BitOr for $name<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            type Output = Self;\n             #[inline]\n-            fn bitor(self, rhs: Self) -> Self {\n-                Self(self.0 | rhs.0)\n+            pub unsafe fn from_int_unchecked(value: crate::$type<LANES>) -> Self {\n+                Self(value, PhantomData)\n             }\n-        }\n \n-        impl<const LANES: usize> core::ops::BitOr<bool> for $name<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            type Output = Self;\n             #[inline]\n-            fn bitor(self, rhs: bool) -> Self {\n-                self | Self::splat(rhs)\n+            pub fn to_bitmask<U: crate::Mask>(self) -> U::BitMask {\n+                unsafe {\n+                    // TODO remove the transmute when rustc is more flexible\n+                    assert_eq!(core::mem::size_of::<U::IntBitMask>(), core::mem::size_of::<U::BitMask>());\n+                    let mask: U::IntBitMask = crate::intrinsics::simd_bitmask(self.0);\n+                    let mut bitmask: U::BitMask = core::mem::transmute_copy(&mask);\n+\n+                    // There is a bug where LLVM appears to implement this operation with the wrong\n+                    // bit order.\n+                    // TODO fix this in a better way\n+                    if cfg!(any(target_arch = \"mips\", target_arch = \"mips64\")) {\n+                        for x in bitmask.as_mut() {\n+                            *x = x.reverse_bits();\n+                        }\n+                    }\n+\n+                    bitmask\n+                }\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitOr<$name<LANES>> for bool\n+        impl<T: Mask, const LANES: usize> core::convert::From<$name<T, LANES>> for crate::$type<LANES>\n         where\n             crate::$type<LANES>: crate::LanesAtMost32,\n         {\n-            type Output = $name<LANES>;\n-            #[inline]\n-            fn bitor(self, rhs: $name<LANES>) -> $name<LANES> {\n-                $name::<LANES>::splat(self) | rhs\n+            fn from(value: $name<T, LANES>) -> Self {\n+                value.0\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitXor for $name<LANES>\n+        impl<T: Mask, const LANES: usize> core::ops::BitAnd for $name<T, LANES>\n         where\n             crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n-            fn bitxor(self, rhs: Self) -> Self::Output {\n-                Self(self.0 ^ rhs.0)\n+            fn bitand(self, rhs: Self) -> Self {\n+                Self(self.0 & rhs.0, PhantomData)\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitXor<bool> for $name<LANES>\n+        impl<T: Mask, const LANES: usize> core::ops::BitOr for $name<T, LANES>\n         where\n             crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n-            fn bitxor(self, rhs: bool) -> Self::Output {\n-                self ^ Self::splat(rhs)\n+            fn bitor(self, rhs: Self) -> Self {\n+                Self(self.0 | rhs.0, PhantomData)\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitXor<$name<LANES>> for bool\n+        impl<T: Mask, const LANES: usize> core::ops::BitXor for $name<T, LANES>\n         where\n             crate::$type<LANES>: crate::LanesAtMost32,\n         {\n-            type Output = $name<LANES>;\n+            type Output = Self;\n             #[inline]\n-            fn bitxor(self, rhs: $name<LANES>) -> Self::Output {\n-                $name::<LANES>::splat(self) ^ rhs\n+            fn bitxor(self, rhs: Self) -> Self::Output {\n+                Self(self.0 ^ rhs.0, PhantomData)\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::Not for $name<LANES>\n+        impl<T: Mask, const LANES: usize> core::ops::Not for $name<T, LANES>\n         where\n             crate::$type<LANES>: crate::LanesAtMost32,\n         {\n-            type Output = $name<LANES>;\n+            type Output = Self;\n             #[inline]\n             fn not(self) -> Self::Output {\n-                Self(!self.0)\n-            }\n-        }\n-\n-        impl<const LANES: usize> core::ops::BitAndAssign for $name<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            #[inline]\n-            fn bitand_assign(&mut self, rhs: Self) {\n-                self.0 &= rhs.0;\n-            }\n-        }\n-\n-        impl<const LANES: usize> core::ops::BitAndAssign<bool> for $name<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            #[inline]\n-            fn bitand_assign(&mut self, rhs: bool) {\n-                *self &= Self::splat(rhs);\n-            }\n-        }\n-\n-        impl<const LANES: usize> core::ops::BitOrAssign for $name<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            #[inline]\n-            fn bitor_assign(&mut self, rhs: Self) {\n-                self.0 |= rhs.0;\n-            }\n-        }\n-\n-        impl<const LANES: usize> core::ops::BitOrAssign<bool> for $name<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            #[inline]\n-            fn bitor_assign(&mut self, rhs: bool) {\n-                *self |= Self::splat(rhs);\n+                Self(!self.0, PhantomData)\n             }\n         }\n-\n-        impl<const LANES: usize> core::ops::BitXorAssign for $name<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            #[inline]\n-            fn bitxor_assign(&mut self, rhs: Self) {\n-                self.0 ^= rhs.0;\n-            }\n-        }\n-\n-        impl<const LANES: usize> core::ops::BitXorAssign<bool> for $name<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            #[inline]\n-            fn bitxor_assign(&mut self, rhs: bool) {\n-                *self ^= Self::splat(rhs);\n-            }\n-        }\n-\n-        impl_full_mask_reductions! { $name, $type }\n     }\n }\n \n define_mask! {\n     /// A mask equivalent to [SimdI8](crate::SimdI8), where all bits in the lane must be either set\n     /// or unset.\n-    struct SimdMask8<const LANES: usize>(crate::SimdI8<LANES>);\n+    struct Mask8<const LANES: usize>(crate::SimdI8<LANES>);\n }\n \n define_mask! {\n     /// A mask equivalent to [SimdI16](crate::SimdI16), where all bits in the lane must be either set\n     /// or unset.\n-    struct SimdMask16<const LANES: usize>(crate::SimdI16<LANES>);\n+    struct Mask16<const LANES: usize>(crate::SimdI16<LANES>);\n }\n \n define_mask! {\n     /// A mask equivalent to [SimdI32](crate::SimdI32), where all bits in the lane must be either set\n     /// or unset.\n-    struct SimdMask32<const LANES: usize>(crate::SimdI32<LANES>);\n+    struct Mask32<const LANES: usize>(crate::SimdI32<LANES>);\n }\n \n define_mask! {\n     /// A mask equivalent to [SimdI64](crate::SimdI64), where all bits in the lane must be either set\n     /// or unset.\n-    struct SimdMask64<const LANES: usize>(crate::SimdI64<LANES>);\n+    struct Mask64<const LANES: usize>(crate::SimdI64<LANES>);\n }\n \n define_mask! {\n     /// A mask equivalent to [SimdIsize](crate::SimdIsize), where all bits in the lane must be either set\n     /// or unset.\n-    struct SimdMaskSize<const LANES: usize>(crate::SimdIsize<LANES>);\n+    struct MaskSize<const LANES: usize>(crate::SimdIsize<LANES>);\n }"}, {"sha": "deaf2be5dca4407e7c9ab9e23c768da9af5f4f9f", "filename": "crates/core_simd/src/masks/mod.rs", "status": "modified", "additions": 157, "deletions": 61, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/9a063bc2ed892315c8317f08f263466af35e9279/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a063bc2ed892315c8317f08f263466af35e9279/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs?ref=9a063bc2ed892315c8317f08f263466af35e9279", "patch": "@@ -1,33 +1,86 @@\n //! Types and traits associated with masking lanes of vectors.\n+//! Types representing\n #![allow(non_camel_case_types)]\n \n-mod full_masks;\n-pub use full_masks::*;\n-\n-mod bitmask;\n-pub use bitmask::*;\n+#[cfg_attr(\n+    not(all(target_arch = \"x86_64\", target_feature = \"avx512f\")),\n+    path = \"full_masks.rs\"\n+)]\n+#[cfg_attr(\n+    all(target_arch = \"x86_64\", target_feature = \"avx512f\"),\n+    path = \"bitmask.rs\"\n+)]\n+mod mask_impl;\n \n use crate::{LanesAtMost32, SimdI16, SimdI32, SimdI64, SimdI8, SimdIsize};\n \n+mod sealed {\n+    pub trait Sealed {}\n+}\n+\n+/// Helper trait for mask types.\n+pub trait Mask: sealed::Sealed {\n+    /// The bitmask representation of a mask.\n+    type BitMask: Copy + Default + AsRef<[u8]> + AsMut<[u8]>;\n+\n+    // TODO remove this when rustc intrinsics are more flexible\n+    #[doc(hidden)]\n+    type IntBitMask;\n+}\n+\n macro_rules! define_opaque_mask {\n     {\n         $(#[$attr:meta])*\n-        struct $name:ident<const $lanes:ident: usize>($inner_ty:ident<$lanes2:ident>);\n+        struct $name:ident<const $lanes:ident: usize>($inner_ty:ty);\n         @bits $bits_ty:ident\n     } => {\n         $(#[$attr])*\n         #[allow(non_camel_case_types)]\n-        pub struct $name<const LANES: usize>($inner_ty<LANES>) where $bits_ty<LANES>: LanesAtMost32;\n+        pub struct $name<const LANES: usize>($inner_ty)\n+        where\n+            $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask;\n+\n+        impl<const LANES: usize> sealed::Sealed for $name<LANES>\n+        where\n+            $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n+        {}\n+        impl Mask for $name<1> {\n+            type BitMask = [u8; 1];\n+            type IntBitMask = u8;\n+        }\n+        impl Mask for $name<2> {\n+            type BitMask = [u8; 1];\n+            type IntBitMask = u8;\n+        }\n+        impl Mask for $name<4> {\n+            type BitMask = [u8; 1];\n+            type IntBitMask = u8;\n+        }\n+        impl Mask for $name<8> {\n+            type BitMask = [u8; 1];\n+            type IntBitMask = u8;\n+        }\n+        impl Mask for $name<16> {\n+            type BitMask = [u8; 2];\n+            type IntBitMask = u16;\n+        }\n+        impl Mask for $name<32> {\n+            type BitMask = [u8; 4];\n+            type IntBitMask = u32;\n+        }\n \n-        impl_opaque_mask_reductions! { $name, $inner_ty, $bits_ty }\n+        impl_opaque_mask_reductions! { $name, $bits_ty }\n \n         impl<const LANES: usize> $name<LANES>\n         where\n-            $bits_ty<LANES>: LanesAtMost32\n+            $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             /// Construct a mask by setting all lanes to the given value.\n             pub fn splat(value: bool) -> Self {\n-                Self(<$inner_ty<LANES>>::splat(value))\n+                Self(<$inner_ty>::splat(value))\n             }\n \n             /// Converts an array to a SIMD vector.\n@@ -52,13 +105,63 @@ macro_rules! define_opaque_mask {\n                 array\n             }\n \n+            /// Converts a vector of integers to a mask, where 0 represents `false` and -1\n+            /// represents `true`.\n+            ///\n+            /// # Safety\n+            /// All lanes must be either 0 or -1.\n+            #[inline]\n+            pub unsafe fn from_int_unchecked(value: $bits_ty<LANES>) -> Self {\n+                Self(<$inner_ty>::from_int_unchecked(value))\n+            }\n+\n+            /// Converts a vector of integers to a mask, where 0 represents `false` and -1\n+            /// represents `true`.\n+            ///\n+            /// # Panics\n+            /// Panics if any lane is not 0 or -1.\n+            #[inline]\n+            pub fn from_int(value: $bits_ty<LANES>) -> Self {\n+                assert!(\n+                    (value.lanes_eq($bits_ty::splat(0)) | value.lanes_eq($bits_ty::splat(-1))).all(),\n+                    \"all values must be either 0 or -1\",\n+                );\n+                unsafe { Self::from_int_unchecked(value) }\n+            }\n+\n+            /// Converts the mask to a vector of integers, where 0 represents `false` and -1\n+            /// represents `true`.\n+            #[inline]\n+            pub fn to_int(self) -> $bits_ty<LANES> {\n+                self.0.to_int()\n+            }\n+\n+            /// Tests the value of the specified lane.\n+            ///\n+            /// # Safety\n+            /// `lane` must be less than `LANES`.\n+            #[inline]\n+            pub unsafe fn test_unchecked(&self, lane: usize) -> bool {\n+                self.0.test_unchecked(lane)\n+            }\n+\n             /// Tests the value of the specified lane.\n             ///\n             /// # Panics\n             /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n             #[inline]\n             pub fn test(&self, lane: usize) -> bool {\n-                self.0.test(lane)\n+                assert!(lane < LANES, \"lane index out of range\");\n+                unsafe { self.test_unchecked(lane) }\n+            }\n+\n+            /// Sets the value of the specified lane.\n+            ///\n+            /// # Safety\n+            /// `lane` must be less than `LANES`.\n+            #[inline]\n+            pub unsafe fn set_unchecked(&mut self, lane: usize, value: bool) {\n+                self.0.set_unchecked(lane, value);\n             }\n \n             /// Sets the value of the specified lane.\n@@ -67,52 +170,21 @@ macro_rules! define_opaque_mask {\n             /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n             #[inline]\n             pub fn set(&mut self, lane: usize, value: bool) {\n-                self.0.set(lane, value);\n-            }\n-        }\n-\n-        impl<const LANES: usize> From<BitMask<LANES>> for $name<LANES>\n-        where\n-            $bits_ty<LANES>: LanesAtMost32,\n-            BitMask<LANES>: LanesAtMost32,\n-        {\n-            fn from(value: BitMask<LANES>) -> Self {\n-                Self(value.into())\n-            }\n-        }\n-\n-        impl<const LANES: usize> From<$name<LANES>> for crate::BitMask<LANES>\n-        where\n-            $bits_ty<LANES>: LanesAtMost32,\n-            BitMask<LANES>: LanesAtMost32,\n-        {\n-            fn from(value: $name<LANES>) -> Self {\n-                value.0.into()\n-            }\n-        }\n-\n-        impl<const LANES: usize> From<$inner_ty<LANES>> for $name<LANES>\n-        where\n-            $bits_ty<LANES>: LanesAtMost32,\n-        {\n-            fn from(value: $inner_ty<LANES>) -> Self {\n-                Self(value)\n+                assert!(lane < LANES, \"lane index out of range\");\n+                unsafe { self.set_unchecked(lane, value); }\n             }\n-        }\n \n-        impl<const LANES: usize> From<$name<LANES>> for $inner_ty<LANES>\n-        where\n-            $bits_ty<LANES>: LanesAtMost32,\n-        {\n-            fn from(value: $name<LANES>) -> Self {\n-                value.0\n+            /// Convert this mask to a bitmask, with one bit set per lane.\n+            pub fn to_bitmask(self) -> <Self as Mask>::BitMask {\n+                self.0.to_bitmask::<Self>()\n             }\n         }\n \n         // vector/array conversion\n         impl<const LANES: usize> From<[bool; LANES]> for $name<LANES>\n         where\n-            $bits_ty<LANES>: crate::LanesAtMost32\n+            $bits_ty<LANES>: crate::LanesAtMost32,\n+            Self: Mask,\n         {\n             fn from(array: [bool; LANES]) -> Self {\n                 Self::from_array(array)\n@@ -121,7 +193,8 @@ macro_rules! define_opaque_mask {\n \n         impl <const LANES: usize> From<$name<LANES>> for [bool; LANES]\n         where\n-            $bits_ty<LANES>: crate::LanesAtMost32\n+            $bits_ty<LANES>: crate::LanesAtMost32,\n+            $name<LANES>: Mask,\n         {\n             fn from(vector: $name<LANES>) -> Self {\n                 vector.to_array()\n@@ -130,13 +203,14 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> Copy for $name<LANES>\n         where\n-            $inner_ty<LANES>: Copy,\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {}\n \n         impl<const LANES: usize> Clone for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             #[inline]\n             fn clone(&self) -> Self {\n@@ -147,6 +221,7 @@ macro_rules! define_opaque_mask {\n         impl<const LANES: usize> Default for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             #[inline]\n             fn default() -> Self {\n@@ -157,6 +232,7 @@ macro_rules! define_opaque_mask {\n         impl<const LANES: usize> PartialEq for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             #[inline]\n             fn eq(&self, other: &Self) -> bool {\n@@ -167,6 +243,7 @@ macro_rules! define_opaque_mask {\n         impl<const LANES: usize> PartialOrd for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             #[inline]\n             fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n@@ -176,16 +253,20 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::fmt::Debug for $name<LANES>\n         where\n-            $bits_ty<LANES>: LanesAtMost32,\n+            $bits_ty<LANES>: crate::LanesAtMost32,\n+            Self: Mask,\n         {\n             fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                core::fmt::Debug::fmt(&self.0, f)\n+                f.debug_list()\n+                    .entries((0..LANES).map(|lane| self.test(lane)))\n+                    .finish()\n             }\n         }\n \n         impl<const LANES: usize> core::ops::BitAnd for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             type Output = Self;\n             #[inline]\n@@ -197,6 +278,7 @@ macro_rules! define_opaque_mask {\n         impl<const LANES: usize> core::ops::BitAnd<bool> for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             type Output = Self;\n             #[inline]\n@@ -208,6 +290,7 @@ macro_rules! define_opaque_mask {\n         impl<const LANES: usize> core::ops::BitAnd<$name<LANES>> for bool\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            $name<LANES>: Mask,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -219,6 +302,7 @@ macro_rules! define_opaque_mask {\n         impl<const LANES: usize> core::ops::BitOr for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             type Output = Self;\n             #[inline]\n@@ -230,6 +314,7 @@ macro_rules! define_opaque_mask {\n         impl<const LANES: usize> core::ops::BitOr<bool> for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             type Output = Self;\n             #[inline]\n@@ -241,6 +326,7 @@ macro_rules! define_opaque_mask {\n         impl<const LANES: usize> core::ops::BitOr<$name<LANES>> for bool\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            $name<LANES>: Mask,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -252,6 +338,7 @@ macro_rules! define_opaque_mask {\n         impl<const LANES: usize> core::ops::BitXor for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             type Output = Self;\n             #[inline]\n@@ -263,6 +350,7 @@ macro_rules! define_opaque_mask {\n         impl<const LANES: usize> core::ops::BitXor<bool> for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             type Output = Self;\n             #[inline]\n@@ -274,6 +362,7 @@ macro_rules! define_opaque_mask {\n         impl<const LANES: usize> core::ops::BitXor<$name<LANES>> for bool\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            $name<LANES>: Mask,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -285,6 +374,7 @@ macro_rules! define_opaque_mask {\n         impl<const LANES: usize> core::ops::Not for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -296,16 +386,18 @@ macro_rules! define_opaque_mask {\n         impl<const LANES: usize> core::ops::BitAndAssign for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             #[inline]\n             fn bitand_assign(&mut self, rhs: Self) {\n-                self.0 &= rhs.0;\n+                self.0 = self.0 & rhs.0;\n             }\n         }\n \n         impl<const LANES: usize> core::ops::BitAndAssign<bool> for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             #[inline]\n             fn bitand_assign(&mut self, rhs: bool) {\n@@ -316,16 +408,18 @@ macro_rules! define_opaque_mask {\n         impl<const LANES: usize> core::ops::BitOrAssign for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             #[inline]\n             fn bitor_assign(&mut self, rhs: Self) {\n-                self.0 |= rhs.0;\n+                self.0 = self.0 | rhs.0;\n             }\n         }\n \n         impl<const LANES: usize> core::ops::BitOrAssign<bool> for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             #[inline]\n             fn bitor_assign(&mut self, rhs: bool) {\n@@ -336,16 +430,18 @@ macro_rules! define_opaque_mask {\n         impl<const LANES: usize> core::ops::BitXorAssign for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             #[inline]\n             fn bitxor_assign(&mut self, rhs: Self) {\n-                self.0 ^= rhs.0;\n+                self.0 = self.0 ^ rhs.0;\n             }\n         }\n \n         impl<const LANES: usize> core::ops::BitXorAssign<bool> for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             #[inline]\n             fn bitxor_assign(&mut self, rhs: bool) {\n@@ -359,39 +455,39 @@ define_opaque_mask! {\n     /// Mask for vectors with `LANES` 8-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct Mask8<const LANES: usize>(SimdMask8<LANES>);\n+    struct Mask8<const LANES: usize>(mask_impl::Mask8<Self, LANES>);\n     @bits SimdI8\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` 16-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct Mask16<const LANES: usize>(SimdMask16<LANES>);\n+    struct Mask16<const LANES: usize>(mask_impl::Mask16<Self, LANES>);\n     @bits SimdI16\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` 32-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct Mask32<const LANES: usize>(SimdMask32<LANES>);\n+    struct Mask32<const LANES: usize>(mask_impl::Mask32<Self, LANES>);\n     @bits SimdI32\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` 64-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct Mask64<const LANES: usize>(SimdMask64<LANES>);\n+    struct Mask64<const LANES: usize>(mask_impl::Mask64<Self, LANES>);\n     @bits SimdI64\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` pointer-width elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct MaskSize<const LANES: usize>(SimdMaskSize<LANES>);\n+    struct MaskSize<const LANES: usize>(mask_impl::MaskSize<Self, LANES>);\n     @bits SimdIsize\n }\n "}, {"sha": "8687d1af51674740bc4dc13b03578f03696626b6", "filename": "crates/core_simd/src/reduction.rs", "status": "modified", "additions": 6, "deletions": 24, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9a063bc2ed892315c8317f08f263466af35e9279/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a063bc2ed892315c8317f08f263466af35e9279/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Freduction.rs?ref=9a063bc2ed892315c8317f08f263466af35e9279", "patch": "@@ -103,18 +103,16 @@ macro_rules! impl_float_reductions {\n }\n \n macro_rules! impl_full_mask_reductions {\n-    { $name:ident, $inner:ident } => {\n-        impl<const LANES: usize> crate::$name<LANES>\n+    { $name:ident, $bits_ty:ident } => {\n+        impl<T: crate::Mask, const LANES: usize> $name<T, LANES>\n         where\n-            crate::$inner<LANES>: crate::LanesAtMost32\n+            crate::$bits_ty<LANES>: crate::LanesAtMost32\n         {\n-            /// Returns true if any lane is set, or false otherwise.\n             #[inline]\n             pub fn any(self) -> bool {\n                 unsafe { crate::intrinsics::simd_reduce_any(self.to_int()) }\n             }\n \n-            /// Returns true if all lanes are set, or false otherwise.\n             #[inline]\n             pub fn all(self) -> bool {\n                 unsafe { crate::intrinsics::simd_reduce_all(self.to_int()) }\n@@ -124,10 +122,11 @@ macro_rules! impl_full_mask_reductions {\n }\n \n macro_rules! impl_opaque_mask_reductions {\n-    { $name:ident, $inner:ident, $bits_ty:ident } => {\n+    { $name:ident, $bits_ty:ident } => {\n         impl<const LANES: usize> $name<LANES>\n         where\n-            $bits_ty<LANES>: crate::LanesAtMost32\n+            crate::$bits_ty<LANES>: crate::LanesAtMost32,\n+            $name<LANES>: crate::Mask,\n         {\n             /// Returns true if any lane is set, or false otherwise.\n             #[inline]\n@@ -143,20 +142,3 @@ macro_rules! impl_opaque_mask_reductions {\n         }\n     }\n }\n-\n-impl<const LANES: usize> crate::BitMask<LANES>\n-where\n-    crate::BitMask<LANES>: crate::LanesAtMost32,\n-{\n-    /// Returns true if any lane is set, or false otherwise.\n-    #[inline]\n-    pub fn any(self) -> bool {\n-        self != Self::splat(false)\n-    }\n-\n-    /// Returns true if all lanes are set, or false otherwise.\n-    #[inline]\n-    pub fn all(self) -> bool {\n-        self == Self::splat(true)\n-    }\n-}"}, {"sha": "6371f88a40a21deef428d16ea527a1360841ee56", "filename": "crates/core_simd/src/vector/float.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a063bc2ed892315c8317f08f263466af35e9279/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a063bc2ed892315c8317f08f263466af35e9279/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs?ref=9a063bc2ed892315c8317f08f263466af35e9279", "patch": "@@ -42,6 +42,7 @@ macro_rules! impl_float_vector {\n             Self: crate::LanesAtMost32,\n             crate::$bits_ty<LANES>: crate::LanesAtMost32,\n             crate::$mask_impl_ty<LANES>: crate::LanesAtMost32,\n+            crate::$mask_ty<LANES>: crate::Mask,\n         {\n             /// Returns true for each lane if it has a positive sign, including\n             /// `+0.0`, `NaN`s with positive sign bit and positive infinity."}, {"sha": "a535fad7bc1d5fb041ccaeb10d514562c8e4dcc3", "filename": "crates/core_simd/src/vector/int.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a063bc2ed892315c8317f08f263466af35e9279/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a063bc2ed892315c8317f08f263466af35e9279/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs?ref=9a063bc2ed892315c8317f08f263466af35e9279", "patch": "@@ -30,6 +30,7 @@ macro_rules! impl_integer_vector {\n         where\n             Self: crate::LanesAtMost32,\n             crate::$mask_impl_ty<LANES>: crate::LanesAtMost32,\n+            crate::$mask_ty<LANES>: crate::Mask,\n         {\n             /// Returns true for each positive lane and false if it is zero or negative.\n             pub fn is_positive(self) -> crate::$mask_ty<LANES> {"}, {"sha": "db027b0941f22e779180ff7d5c66d0dac0f5013d", "filename": "crates/core_simd/src/vector/uint.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a063bc2ed892315c8317f08f263466af35e9279/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a063bc2ed892315c8317f08f263466af35e9279/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs?ref=9a063bc2ed892315c8317f08f263466af35e9279", "patch": "@@ -1,6 +1,5 @@\n #![allow(non_camel_case_types)]\n \n-\n /// Implements additional integer traits (Eq, Ord, Hash) on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n macro_rules! impl_unsigned_vector {\n     { $name:ident, $type:ty } => {"}, {"sha": "7021d58aa543ad34f63e77f4a8cf26bac7a4152f", "filename": "crates/core_simd/tests/masks.rs", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9a063bc2ed892315c8317f08f263466af35e9279/crates%2Fcore_simd%2Ftests%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a063bc2ed892315c8317f08f263466af35e9279/crates%2Fcore_simd%2Ftests%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fmasks.rs?ref=9a063bc2ed892315c8317f08f263466af35e9279", "patch": "@@ -1,30 +1,9 @@\n-use core::convert::TryFrom;\n-use core_simd::{BitMask, Mask8, SimdI8, SimdMask8};\n-\n #[cfg(target_arch = \"wasm32\")]\n use wasm_bindgen_test::*;\n \n #[cfg(target_arch = \"wasm32\")]\n wasm_bindgen_test_configure!(run_in_browser);\n \n-#[test]\n-#[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-fn mask_format_round_trip() {\n-    let ints = SimdI8::from_array([-1, 0, 0, -1]);\n-\n-    let simd_mask = SimdMask8::try_from(ints).unwrap();\n-\n-    let bitmask = BitMask::from(simd_mask);\n-\n-    let opaque_mask = Mask8::from(bitmask);\n-\n-    let simd_mask_returned = SimdMask8::from(opaque_mask);\n-\n-    let ints_returned = SimdI8::from(simd_mask_returned);\n-\n-    assert_eq!(ints_returned, ints);\n-}\n-\n macro_rules! test_mask_api {\n     { $name:ident } => {\n         #[allow(non_snake_case)]\n@@ -77,12 +56,29 @@ macro_rules! test_mask_api {\n                 v.set(2, true);\n                 assert!(!v.all());\n             }\n+\n+            #[test]\n+            fn roundtrip_int_conversion() {\n+                let values = [true, false, false, true, false, false, true, false];\n+                let mask = core_simd::$name::<8>::from_array(values);\n+                let int = mask.to_int();\n+                assert_eq!(int.to_array(), [-1, 0, 0, -1, 0, 0, -1, 0]);\n+                assert_eq!(core_simd::$name::<8>::from_int(int), mask);\n+            }\n+\n+            #[test]\n+            fn to_bitmask() {\n+                let values = [\n+                    true, false, false, true, false, false, true, false,\n+                    true, true, false, false, false, false, false, true,\n+                ];\n+                let mask = core_simd::$name::<16>::from_array(values);\n+                assert_eq!(mask.to_bitmask(), [0b01001001, 0b10000011]);\n+            }\n         }\n     }\n }\n \n mod mask_api {\n     test_mask_api! { Mask8 }\n-    test_mask_api! { SimdMask8 }\n-    test_mask_api! { BitMask }\n }"}, {"sha": "5ffc922697694948e5d12649bbbce9eeba4da966", "filename": "crates/test_helpers/src/array.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a063bc2ed892315c8317f08f263466af35e9279/crates%2Ftest_helpers%2Fsrc%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a063bc2ed892315c8317f08f263466af35e9279/crates%2Ftest_helpers%2Fsrc%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_helpers%2Fsrc%2Farray.rs?ref=9a063bc2ed892315c8317f08f263466af35e9279", "patch": "@@ -3,14 +3,11 @@\n // Adapted from proptest's array code\n // Copyright 2017 Jason Lingle\n \n+use core::{marker::PhantomData, mem::MaybeUninit};\n use proptest::{\n     strategy::{NewTree, Strategy, ValueTree},\n     test_runner::TestRunner,\n };\n-use core::{\n-    marker::PhantomData,\n-    mem::MaybeUninit,\n-};\n \n #[must_use = \"strategies do nothing unless used\"]\n #[derive(Clone, Copy, Debug)]"}, {"sha": "fffd088f4da38d2ea4e8833e6a06ce4d043d6ea9", "filename": "crates/test_helpers/src/lib.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9a063bc2ed892315c8317f08f263466af35e9279/crates%2Ftest_helpers%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a063bc2ed892315c8317f08f263466af35e9279/crates%2Ftest_helpers%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_helpers%2Fsrc%2Flib.rs?ref=9a063bc2ed892315c8317f08f263466af35e9279", "patch": "@@ -281,7 +281,11 @@ macro_rules! test_lanes {\n                     core_simd::SimdIsize<$lanes>: core_simd::LanesAtMost32,\n                     core_simd::SimdF32<$lanes>: core_simd::LanesAtMost32,\n                     core_simd::SimdF64<$lanes>: core_simd::LanesAtMost32,\n-                    core_simd::BitMask<$lanes>: core_simd::LanesAtMost32,\n+                    core_simd::Mask8<$lanes>: core_simd::Mask,\n+                    core_simd::Mask16<$lanes>: core_simd::Mask,\n+                    core_simd::Mask32<$lanes>: core_simd::Mask,\n+                    core_simd::Mask64<$lanes>: core_simd::Mask,\n+                    core_simd::MaskSize<$lanes>: core_simd::Mask,\n                 $body\n \n                 #[cfg(target_arch = \"wasm32\")]\n@@ -351,7 +355,11 @@ macro_rules! test_lanes_panic {\n                     core_simd::SimdIsize<$lanes>: core_simd::LanesAtMost32,\n                     core_simd::SimdF32<$lanes>: core_simd::LanesAtMost32,\n                     core_simd::SimdF64<$lanes>: core_simd::LanesAtMost32,\n-                    core_simd::BitMask<$lanes>: core_simd::LanesAtMost32,\n+                    core_simd::Mask8<$lanes>: core_simd::Mask,\n+                    core_simd::Mask16<$lanes>: core_simd::Mask,\n+                    core_simd::Mask32<$lanes>: core_simd::Mask,\n+                    core_simd::Mask64<$lanes>: core_simd::Mask,\n+                    core_simd::MaskSize<$lanes>: core_simd::Mask,\n                 $body\n \n                 #[test]"}]}