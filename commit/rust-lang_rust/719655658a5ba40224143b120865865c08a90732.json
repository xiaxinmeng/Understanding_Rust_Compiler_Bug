{"sha": "719655658a5ba40224143b120865865c08a90732", "node_id": "C_kwDOAAsO6NoAKDcxOTY1NTY1OGE1YmE0MDIyNDE0M2IxMjA4NjU4NjVjMDhhOTA3MzI", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-04-19T18:12:21Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-05-10T11:32:20Z"}, "message": "tighten sanity checks around Scalar and ScalarPair", "tree": {"sha": "fe30c15233e8bf1b6314fa1939e71f1d2e3342fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe30c15233e8bf1b6314fa1939e71f1d2e3342fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/719655658a5ba40224143b120865865c08a90732", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/719655658a5ba40224143b120865865c08a90732", "html_url": "https://github.com/rust-lang/rust/commit/719655658a5ba40224143b120865865c08a90732", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/719655658a5ba40224143b120865865c08a90732/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d53f1e8fbf891cf84fcb11eb078a27e528df795a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d53f1e8fbf891cf84fcb11eb078a27e528df795a", "html_url": "https://github.com/rust-lang/rust/commit/d53f1e8fbf891cf84fcb11eb078a27e528df795a"}], "stats": {"total": 88, "additions": 44, "deletions": 44}, "files": [{"sha": "254c6dd64653ffad07ec10987b8659abb9e4ca76", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/719655658a5ba40224143b120865865c08a90732/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/719655658a5ba40224143b120865865c08a90732/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=719655658a5ba40224143b120865865c08a90732", "patch": "@@ -284,8 +284,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Abi::Scalar(s) if force => Some(s.primitive()),\n             _ => None,\n         };\n-        if let Some(_) = scalar_layout {\n-            let scalar = alloc.read_scalar(alloc_range(Size::ZERO, mplace.layout.size))?;\n+        if let Some(s) = scalar_layout {\n+            let size = s.size(self);\n+            assert_eq!(size, mplace.layout.size, \"abi::Scalar size does not match layout size\");\n+            let scalar = alloc.read_scalar(alloc_range(Size::ZERO, size))?;\n             return Ok(Some(ImmTy { imm: scalar.into(), layout: mplace.layout }));\n         }\n         let scalar_pair_layout = match mplace.layout.abi {\n@@ -302,7 +304,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // which `ptr.offset(b_offset)` cannot possibly fail to satisfy.\n             let (a_size, b_size) = (a.size(self), b.size(self));\n             let b_offset = a_size.align_to(b.align(self).abi);\n-            assert!(b_offset.bytes() > 0); // we later use the offset to tell apart the fields\n+            assert!(b_offset.bytes() > 0); // in `operand_field` we use the offset to tell apart the fields\n             let a_val = alloc.read_scalar(alloc_range(Size::ZERO, a_size))?;\n             let b_val = alloc.read_scalar(alloc_range(b_offset, b_size))?;\n             return Ok(Some(ImmTy {\n@@ -394,28 +396,41 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Err(value) => value,\n         };\n \n-        let field_layout = op.layout.field(self, field);\n+        let field_layout = base.layout.field(self, field);\n         if field_layout.is_zst() {\n             let immediate = Scalar::ZST.into();\n             return Ok(OpTy { op: Operand::Immediate(immediate), layout: field_layout });\n         }\n-        let offset = op.layout.fields.offset(field);\n-        let immediate = match *base {\n+\n+        let offset = base.layout.fields.offset(field);\n+        // This makes several assumptions about what layouts we will encounter; we match what\n+        // codegen does as good as we can (see `extract_field` in `rustc_codegen_ssa/src/mir/operand.rs`).\n+        let field_val = match (*base, base.layout.abi) {\n             // the field covers the entire type\n-            _ if offset.bytes() == 0 && field_layout.size == op.layout.size => *base,\n+            _ if field_layout.size == base.layout.size => {\n+                assert!(offset.bytes() == 0);\n+                *base\n+            }\n             // extract fields from types with `ScalarPair` ABI\n-            Immediate::ScalarPair(a, b) => {\n-                let val = if offset.bytes() == 0 { a } else { b };\n-                Immediate::from(val)\n+            (Immediate::ScalarPair(a_val, b_val), Abi::ScalarPair(a, b)) => {\n+                Immediate::from(if offset.bytes() == 0 {\n+                    assert_eq!(field_layout.size, a.size(self));\n+                    a_val\n+                } else {\n+                    assert_eq!(offset, a.size(self).align_to(b.align(self).abi));\n+                    assert_eq!(field_layout.size, b.size(self));\n+                    b_val\n+                })\n             }\n-            Immediate::Scalar(val) => span_bug!(\n+            _ => span_bug!(\n                 self.cur_span(),\n-                \"field access on non aggregate {:#?}, {:#?}\",\n-                val,\n-                op.layout\n+                \"invalid field access on immediate {}, layout {:#?}\",\n+                base,\n+                base.layout\n             ),\n         };\n-        Ok(OpTy { op: Operand::Immediate(immediate), layout: field_layout })\n+\n+        Ok(OpTy { op: Operand::Immediate(field_val), layout: field_layout })\n     }\n \n     pub fn operand_index("}, {"sha": "600316fcbc0f7a74301271577f04e39d26fbcdf9", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 9, "deletions": 25, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/719655658a5ba40224143b120865865c08a90732/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/719655658a5ba40224143b120865865c08a90732/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=719655658a5ba40224143b120865865c08a90732", "patch": "@@ -16,7 +16,7 @@ use rustc_target::abi::{HasDataLayout, Size, VariantIdx, Variants};\n use super::{\n     alloc_range, mir_assign_valid_types, AllocId, AllocRef, AllocRefMut, CheckInAllocMsg,\n     ConstAlloc, ImmTy, Immediate, InterpCx, InterpResult, LocalValue, Machine, MemoryKind, OpTy,\n-    Operand, Pointer, PointerArithmetic, Provenance, Scalar, ScalarMaybeUninit,\n+    Operand, Pointer, Provenance, Scalar, ScalarMaybeUninit,\n };\n \n #[derive(Copy, Clone, Hash, PartialEq, Eq, HashStable, Debug)]\n@@ -700,24 +700,7 @@ where\n         src: Immediate<M::PointerTag>,\n         dest: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n-        if cfg!(debug_assertions) {\n-            // This is a very common path, avoid some checks in release mode\n-            assert!(!dest.layout.is_unsized(), \"Cannot write unsized data\");\n-            match src {\n-                Immediate::Scalar(ScalarMaybeUninit::Scalar(Scalar::Ptr(..))) => assert_eq!(\n-                    self.pointer_size(),\n-                    dest.layout.size,\n-                    \"Size mismatch when writing pointer\"\n-                ),\n-                Immediate::Scalar(ScalarMaybeUninit::Scalar(Scalar::Int(int))) => {\n-                    assert_eq!(int.size(), dest.layout.size, \"Size mismatch when writing bits\")\n-                }\n-                Immediate::Scalar(ScalarMaybeUninit::Uninit) => {} // uninit can have any size\n-                Immediate::ScalarPair(_, _) => {\n-                    // FIXME: Can we check anything here?\n-                }\n-            }\n-        }\n+        assert!(!dest.layout.is_unsized(), \"Cannot write unsized data\");\n         trace!(\"write_immediate: {:?} <- {:?}: {}\", *dest, src, dest.layout.ty);\n \n         // See if we can avoid an allocation. This is the counterpart to `read_immediate_raw`,\n@@ -769,15 +752,15 @@ where\n         // cover all the bytes!\n         match value {\n             Immediate::Scalar(scalar) => {\n-                match dest.layout.abi {\n-                    Abi::Scalar(_) => {} // fine\n-                    _ => span_bug!(\n+                let Abi::Scalar(s) = dest.layout.abi else { span_bug!(\n                         self.cur_span(),\n                         \"write_immediate_to_mplace: invalid Scalar layout: {:#?}\",\n                         dest.layout\n-                    ),\n-                }\n-                alloc.write_scalar(alloc_range(Size::ZERO, dest.layout.size), scalar)\n+                    )\n+                };\n+                let size = s.size(&tcx);\n+                assert_eq!(dest.layout.size, size, \"abi::Scalar size does not match layout size\");\n+                alloc.write_scalar(alloc_range(Size::ZERO, size), scalar)\n             }\n             Immediate::ScalarPair(a_val, b_val) => {\n                 // We checked `ptr_align` above, so all fields will have the alignment they need.\n@@ -791,6 +774,7 @@ where\n                 };\n                 let (a_size, b_size) = (a.size(&tcx), b.size(&tcx));\n                 let b_offset = a_size.align_to(b.align(&tcx).abi);\n+                assert!(b_offset.bytes() > 0); // in `operand_field` we use the offset to tell apart the fields\n \n                 // It is tempting to verify `b_offset` against `layout.fields.offset(1)`,\n                 // but that does not work: We could be a newtype around a pair, then the"}, {"sha": "2dab9ff89868f9114399dad2088594c8f1c90fd5", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/719655658a5ba40224143b120865865c08a90732/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/719655658a5ba40224143b120865865c08a90732/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=719655658a5ba40224143b120865865c08a90732", "patch": "@@ -645,17 +645,18 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         // i.e. that we go over the `check_init` below.\n         let size = scalar_layout.size(self.ecx);\n         let is_full_range = match scalar_layout {\n-            ScalarAbi::Initialized { valid_range, .. } => {\n+            ScalarAbi::Initialized { .. } => {\n                 if M::enforce_number_validity(self.ecx) {\n                     false // not \"full\" since uninit is not accepted\n                 } else {\n-                    valid_range.is_full_for(size)\n+                    scalar_layout.is_always_valid(self.ecx)\n                 }\n             }\n             ScalarAbi::Union { .. } => true,\n         };\n         if is_full_range {\n-            // Nothing to check\n+            // Nothing to check. Cruciall we don't even `read_scalar` until here, since that would\n+            // fail for `Union` scalars!\n             return Ok(());\n         }\n         // We have something to check: it must at least be initialized.\n@@ -688,7 +689,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     } else {\n                         return Ok(());\n                     }\n-                } else if scalar_layout.valid_range(self.ecx).is_full_for(size) {\n+                } else if scalar_layout.is_always_valid(self.ecx) {\n                     // Easy. (This is reachable if `enforce_number_validity` is set.)\n                     return Ok(());\n                 } else {"}]}