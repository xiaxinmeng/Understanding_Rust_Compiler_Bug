{"sha": "06707ab30f06d189636cb219cc689f19eda9a2bb", "node_id": "C_kwDOAAsO6NoAKDA2NzA3YWIzMGYwNmQxODk2MzZjYjIxOWNjNjg5ZjE5ZWRhOWEyYmI", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2023-04-14T12:28:19Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2023-04-14T12:28:19Z"}, "message": "Merge from rustc", "tree": {"sha": "5017bdd02725ad3658357cb34f05dbdb257c6fe1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5017bdd02725ad3658357cb34f05dbdb257c6fe1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06707ab30f06d189636cb219cc689f19eda9a2bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06707ab30f06d189636cb219cc689f19eda9a2bb", "html_url": "https://github.com/rust-lang/rust/commit/06707ab30f06d189636cb219cc689f19eda9a2bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06707ab30f06d189636cb219cc689f19eda9a2bb/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2386cd7b22174f277d5bd9ad802bcffc3b902ab6", "url": "https://api.github.com/repos/rust-lang/rust/commits/2386cd7b22174f277d5bd9ad802bcffc3b902ab6", "html_url": "https://github.com/rust-lang/rust/commit/2386cd7b22174f277d5bd9ad802bcffc3b902ab6"}, {"sha": "e3de409aaa592a36548a9f453688c3e877b5caa1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3de409aaa592a36548a9f453688c3e877b5caa1", "html_url": "https://github.com/rust-lang/rust/commit/e3de409aaa592a36548a9f453688c3e877b5caa1"}], "stats": {"total": 21424, "additions": 13450, "deletions": 7974}, "files": [{"sha": "3f617af19b39a7300c0dc56941eed1554be9922b", "filename": "Cargo.lock", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -830,6 +830,7 @@ dependencies = [\n name = \"clippy_lints\"\n version = \"0.1.70\"\n dependencies = [\n+ \"arrayvec 0.7.0\",\n  \"cargo_metadata 0.15.3\",\n  \"clippy_utils\",\n  \"declare_clippy_lint\",\n@@ -1685,9 +1686,9 @@ dependencies = [\n \n [[package]]\n name = \"futures\"\n-version = \"0.3.19\"\n+version = \"0.3.28\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"28560757fe2bb34e79f907794bb6b22ae8b0e5c669b638a1132f2592b19035b4\"\n+checksum = \"23342abe12aba583913b2e62f22225ff9c950774065e4bfb61a19cd9770fec40\"\n dependencies = [\n  \"futures-channel\",\n  \"futures-core\",\n@@ -1700,25 +1701,25 @@ dependencies = [\n \n [[package]]\n name = \"futures-channel\"\n-version = \"0.3.19\"\n+version = \"0.3.28\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ba3dda0b6588335f360afc675d0564c17a77a2bda81ca178a4b6081bd86c7f0b\"\n+checksum = \"955518d47e09b25bbebc7a18df10b81f0c766eaf4c4f1cccef2fca5f2a4fb5f2\"\n dependencies = [\n  \"futures-core\",\n  \"futures-sink\",\n ]\n \n [[package]]\n name = \"futures-core\"\n-version = \"0.3.19\"\n+version = \"0.3.28\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d0c8ff0461b82559810cdccfde3215c3f373807f5e5232b71479bff7bb2583d7\"\n+checksum = \"4bca583b7e26f571124fe5b7561d49cb2868d79116cfa0eefce955557c6fee8c\"\n \n [[package]]\n name = \"futures-executor\"\n-version = \"0.3.19\"\n+version = \"0.3.28\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"29d6d2ff5bb10fb95c85b8ce46538a2e5f5e7fdc755623a7d4529ab8a4ed9d2a\"\n+checksum = \"ccecee823288125bd88b4d7f565c9e58e41858e47ab72e8ea2d64e93624386e0\"\n dependencies = [\n  \"futures-core\",\n  \"futures-task\",\n@@ -1727,38 +1728,38 @@ dependencies = [\n \n [[package]]\n name = \"futures-io\"\n-version = \"0.3.19\"\n+version = \"0.3.28\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b1f9d34af5a1aac6fb380f735fe510746c38067c5bf16c7fd250280503c971b2\"\n+checksum = \"4fff74096e71ed47f8e023204cfd0aa1289cd54ae5430a9523be060cdb849964\"\n \n [[package]]\n name = \"futures-macro\"\n-version = \"0.3.19\"\n+version = \"0.3.28\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6dbd947adfffb0efc70599b3ddcf7b5597bb5fa9e245eb99f62b3a5f7bb8bd3c\"\n+checksum = \"89ca545a94061b6365f2c7355b4b32bd20df3ff95f02da9329b34ccc3bd6ee72\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n- \"syn 1.0.102\",\n+ \"syn 2.0.8\",\n ]\n \n [[package]]\n name = \"futures-sink\"\n-version = \"0.3.19\"\n+version = \"0.3.28\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e3055baccb68d74ff6480350f8d6eb8fcfa3aa11bdc1a1ae3afdd0514617d508\"\n+checksum = \"f43be4fe21a13b9781a69afa4985b0f6ee0e1afab2c6f454a8cf30e2b2237b6e\"\n \n [[package]]\n name = \"futures-task\"\n-version = \"0.3.19\"\n+version = \"0.3.28\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6ee7c6485c30167ce4dfb83ac568a849fe53274c831081476ee13e0dce1aad72\"\n+checksum = \"76d3d132be6c0e6aa1534069c705a74a5997a356c0dc2f86a47765e5617c5b65\"\n \n [[package]]\n name = \"futures-util\"\n-version = \"0.3.19\"\n+version = \"0.3.28\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d9b5cf40b47a271f77a8b1bec03ca09044d99d2372c0de244e66430761127164\"\n+checksum = \"26b01e40b772d54cf6c6d721c1d1abd0647a0106a12ecaa1c186273392a69533\"\n dependencies = [\n  \"futures-channel\",\n  \"futures-core\",\n@@ -1841,9 +1842,9 @@ dependencies = [\n \n [[package]]\n name = \"git2\"\n-version = \"0.16.0\"\n+version = \"0.17.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"be36bc9e0546df253c0cc41fd0af34f5e92845ad8509462ec76672fac6997f5b\"\n+checksum = \"89511277159354bea13ae1e53e0c9ab85ba1b20d7e91618fa30e6bc5566857fb\"\n dependencies = [\n  \"bitflags\",\n  \"libc\",\n@@ -1856,9 +1857,9 @@ dependencies = [\n \n [[package]]\n name = \"git2-curl\"\n-version = \"0.17.0\"\n+version = \"0.18.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7577f4e6341ba7c90d883511130a45b956c274ba5f4d205d9f9da990f654cd33\"\n+checksum = \"f8f8b7432b72928cff76f69e59ed5327f94a52763731e71274960dee72fe5f8c\"\n dependencies = [\n  \"curl\",\n  \"git2\",\n@@ -2768,13 +2769,11 @@ dependencies = [\n  \"anyhow\",\n  \"clap 3.2.20\",\n  \"flate2\",\n- \"lazy_static\",\n  \"num_cpus\",\n  \"rayon\",\n  \"remove_dir_all\",\n  \"tar\",\n  \"walkdir\",\n- \"winapi\",\n  \"xz2\",\n ]\n \n@@ -2962,9 +2961,9 @@ dependencies = [\n \n [[package]]\n name = \"libgit2-sys\"\n-version = \"0.14.1+1.5.0\"\n+version = \"0.15.0+1.6.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4a07fb2692bc3593bda59de45a502bb3071659f2c515e28c71e728306b038e17\"\n+checksum = \"032e537ae4dd4e50c877f258dc55fcd0657b5021f454094a425bb6bcc9edea4c\"\n dependencies = [\n  \"cc\",\n  \"libc\",\n@@ -3002,9 +3001,9 @@ dependencies = [\n \n [[package]]\n name = \"libssh2-sys\"\n-version = \"0.2.23\"\n+version = \"0.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b094a36eb4b8b8c8a7b4b8ae43b2944502be3e59cd87687595cf6b0a71b3f4ca\"\n+checksum = \"2dc8a030b787e2119a731f1951d6a773e2280c660f8ec4b0f5e1505a386e71ee\"\n dependencies = [\n  \"cc\",\n  \"libc\",\n@@ -4575,6 +4574,7 @@ dependencies = [\n  \"elsa\",\n  \"ena\",\n  \"indexmap\",\n+ \"itertools\",\n  \"jobserver\",\n  \"libc\",\n  \"measureme\",\n@@ -5723,9 +5723,9 @@ dependencies = [\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.147\"\n+version = \"1.0.159\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d193d69bae983fc11a79df82342761dfbf28a99fc8d203dca4c3c1b590948965\"\n+checksum = \"3c04e8343c3daeec41f58990b9d77068df31209f2af111e059e9fe9646693065\"\n dependencies = [\n  \"serde_derive\",\n ]\n@@ -5742,13 +5742,13 @@ dependencies = [\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.147\"\n+version = \"1.0.159\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4f1d362ca8fc9c3e3a7484440752472d68a6caa98f1ab81d99b5dfe517cec852\"\n+checksum = \"4c614d17805b093df4b147b51339e7e44bf05ef59fba1e45d83500bcfb4d8585\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n- \"syn 1.0.102\",\n+ \"syn 2.0.8\",\n ]\n \n [[package]]"}, {"sha": "df1a716755b481f37fc1ef4190448a11449e4047", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -167,9 +167,6 @@ pub enum GenericArgs {\n     AngleBracketed(AngleBracketedArgs),\n     /// The `(A, B)` and `C` in `Foo(A, B) -> C`.\n     Parenthesized(ParenthesizedArgs),\n-    /// Associated return type bounds, like `T: Trait<method(..): Send>`\n-    /// which applies the `Send` bound to the return-type of `method`.\n-    ReturnTypeNotation(Span),\n }\n \n impl GenericArgs {\n@@ -181,7 +178,6 @@ impl GenericArgs {\n         match self {\n             AngleBracketed(data) => data.span,\n             Parenthesized(data) => data.span,\n-            ReturnTypeNotation(span) => *span,\n         }\n     }\n }"}, {"sha": "699946f307b50820e07ac545f50d16ca386df861", "filename": "compiler/rustc_ast/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_ast%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_ast%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fformat.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -94,7 +94,7 @@ impl FormatArguments {\n         }\n         if !matches!(arg.kind, FormatArgumentKind::Captured(..)) {\n             // This is an explicit argument.\n-            // Make sure that all arguments so far are explcit.\n+            // Make sure that all arguments so far are explicit.\n             assert_eq!(\n                 self.num_explicit_args,\n                 self.arguments.len(),"}, {"sha": "694d31d8f1fd4718f97448c7f209465e2475f877", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -561,7 +561,6 @@ pub fn noop_visit_generic_args<T: MutVisitor>(generic_args: &mut GenericArgs, vi\n     match generic_args {\n         GenericArgs::AngleBracketed(data) => vis.visit_angle_bracketed_parameter_data(data),\n         GenericArgs::Parenthesized(data) => vis.visit_parenthesized_parameter_data(data),\n-        GenericArgs::ReturnTypeNotation(_span) => {}\n     }\n }\n "}, {"sha": "ac9b321b71c6fe643223d74bc51fbf058ddd8eb8", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -482,7 +482,6 @@ where\n             walk_list!(visitor, visit_ty, &data.inputs);\n             walk_fn_ret_ty(visitor, &data.output);\n         }\n-        GenericArgs::ReturnTypeNotation(_span) => {}\n     }\n }\n "}, {"sha": "3e9f9b43623f8131ad4f44aaa7f398e9b64772af", "filename": "compiler/rustc_ast_lowering/src/errors.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -137,7 +137,7 @@ pub struct AsyncNonMoveClosureNotSupported {\n \n #[derive(Diagnostic, Clone, Copy)]\n #[diag(ast_lowering_functional_record_update_destructuring_assignment)]\n-pub struct FunctionalRecordUpdateDestructuringAssignemnt {\n+pub struct FunctionalRecordUpdateDestructuringAssignment {\n     #[primary_span]\n     #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n     pub span: Span,\n@@ -353,13 +353,7 @@ pub enum BadReturnTypeNotation {\n     #[diag(ast_lowering_bad_return_type_notation_inputs)]\n     Inputs {\n         #[primary_span]\n-        #[suggestion(code = \"(..)\", applicability = \"maybe-incorrect\")]\n-        span: Span,\n-    },\n-    #[diag(ast_lowering_bad_return_type_notation_needs_dots)]\n-    NeedsDots {\n-        #[primary_span]\n-        #[suggestion(code = \"(..)\", applicability = \"maybe-incorrect\")]\n+        #[suggestion(code = \"()\", applicability = \"maybe-incorrect\")]\n         span: Span,\n     },\n     #[diag(ast_lowering_bad_return_type_notation_output)]"}, {"sha": "1b1c4765bc07a705477d83079128943f2c8aebc4", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1,6 +1,6 @@\n use super::errors::{\n     AsyncGeneratorsNotSupported, AsyncNonMoveClosureNotSupported, AwaitOnlyInAsyncFnAndBlocks,\n-    BaseExpressionDoubleDot, ClosureCannotBeStatic, FunctionalRecordUpdateDestructuringAssignemnt,\n+    BaseExpressionDoubleDot, ClosureCannotBeStatic, FunctionalRecordUpdateDestructuringAssignment,\n     GeneratorTooManyParameters, InclusiveRangeWithNoEnd, NotSupportedForLifetimeBinderAsyncClosure,\n     UnderscoreExprLhsAssign,\n };\n@@ -434,7 +434,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // `if let pat = val` or `if foo && let pat = val`, as we _do_ want `val` to live beyond the\n         // condition in this case.\n         //\n-        // In order to mantain the drop behavior for the non `let` parts of the condition,\n+        // In order to maintain the drop behavior for the non `let` parts of the condition,\n         // we still wrap them in terminating scopes, e.g. `if foo && let pat = val` essentially\n         // gets transformed into `if { let _t = foo; _t } && let pat = val`\n         match &cond.kind {\n@@ -1232,7 +1232,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 );\n                 let fields_omitted = match &se.rest {\n                     StructRest::Base(e) => {\n-                        self.tcx.sess.emit_err(FunctionalRecordUpdateDestructuringAssignemnt {\n+                        self.tcx.sess.emit_err(FunctionalRecordUpdateDestructuringAssignment {\n                             span: e.span,\n                         });\n                         true"}, {"sha": "f7ae96b7c4a3dbedce95f5496c66ff0c79b70a69", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -987,15 +987,22 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 GenericArgs::AngleBracketed(data) => {\n                     self.lower_angle_bracketed_parameter_data(data, ParamMode::Explicit, itctx).0\n                 }\n-                &GenericArgs::ReturnTypeNotation(span) => GenericArgsCtor {\n-                    args: Default::default(),\n-                    bindings: &[],\n-                    parenthesized: hir::GenericArgsParentheses::ReturnTypeNotation,\n-                    span,\n-                },\n                 GenericArgs::Parenthesized(data) => {\n-                    if let Some(start_char) = constraint.ident.as_str().chars().next()\n-                        && start_char.is_ascii_lowercase()\n+                    if data.inputs.is_empty() && matches!(data.output, FnRetTy::Default(..)) {\n+                        let parenthesized = if self.tcx.features().return_type_notation {\n+                            hir::GenericArgsParentheses::ReturnTypeNotation\n+                        } else {\n+                            self.emit_bad_parenthesized_trait_in_assoc_ty(data);\n+                            hir::GenericArgsParentheses::No\n+                        };\n+                        GenericArgsCtor {\n+                            args: Default::default(),\n+                            bindings: &[],\n+                            parenthesized,\n+                            span: data.inputs_span,\n+                        }\n+                    } else if let Some(first_char) = constraint.ident.as_str().chars().next()\n+                        && first_char.is_ascii_lowercase()\n                     {\n                         let mut err = if !data.inputs.is_empty() {\n                             self.tcx.sess.create_err(errors::BadReturnTypeNotation::Inputs {\n@@ -1006,9 +1013,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                 span: data.inputs_span.shrink_to_hi().to(ty.span),\n                             })\n                         } else {\n-                            self.tcx.sess.create_err(errors::BadReturnTypeNotation::NeedsDots {\n-                                span: data.inputs_span,\n-                            })\n+                            unreachable!(\"inputs are empty and return type is not provided\")\n                         };\n                         if !self.tcx.features().return_type_notation\n                             && self.tcx.sess.is_nightly_build()"}, {"sha": "8eb84c036a0840d74cd2041d16f72fe70ba3ec6b", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -13,7 +13,6 @@ use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{BytePos, Span, DUMMY_SP};\n \n use smallvec::{smallvec, SmallVec};\n-use thin_vec::ThinVec;\n \n impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     #[instrument(level = \"trace\", skip(self))]\n@@ -219,18 +218,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         )\n                     }\n                 },\n-                &GenericArgs::ReturnTypeNotation(span) => {\n-                    self.tcx.sess.emit_err(GenericTypeWithParentheses { span, sub: None });\n-                    (\n-                        self.lower_angle_bracketed_parameter_data(\n-                            &AngleBracketedArgs { span, args: ThinVec::default() },\n-                            param_mode,\n-                            itctx,\n-                        )\n-                        .0,\n-                        false,\n-                    )\n-                }\n             }\n         } else {\n             ("}, {"sha": "a349fe6a3c44b4586d428d2484a5d49e6364de8d", "filename": "compiler/rustc_ast_passes/messages.ftl", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_ast_passes%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_ast_passes%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fmessages.ftl?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -17,9 +17,10 @@ ast_passes_keyword_lifetime =\n ast_passes_invalid_label =\n     invalid label name `{$name}`\n \n-ast_passes_invalid_visibility =\n-    unnecessary visibility qualifier\n-    .implied = `pub` not permitted here because it's implied\n+ast_passes_visibility_not_permitted =\n+    visibility qualifiers are not permitted here\n+    .enum_variant = enum variants and their fields always share the visibility of the enum they are in\n+    .trait_impl = trait items always share the visibility of their trait\n     .individual_impl_items = place qualifiers on individual impl items instead\n     .individual_foreign_items = place qualifiers on individual foreign items instead\n "}, {"sha": "c79626ccd76f0dc18249cffc15e09a30daaec8c2", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -240,16 +240,12 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n-    fn invalid_visibility(&self, vis: &Visibility, note: Option<errors::InvalidVisibilityNote>) {\n+    fn visibility_not_permitted(&self, vis: &Visibility, note: errors::VisibilityNotPermittedNote) {\n         if let VisibilityKind::Inherited = vis.kind {\n             return;\n         }\n \n-        self.session.emit_err(errors::InvalidVisibility {\n-            span: vis.span,\n-            implied: vis.kind.is_pub().then_some(vis.span),\n-            note,\n-        });\n+        self.session.emit_err(errors::VisibilityNotPermitted { span: vis.span, note });\n     }\n \n     fn check_decl_no_pat(decl: &FnDecl, mut report_err: impl FnMut(Span, Option<Ident>, bool)) {\n@@ -819,7 +815,10 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 items,\n             }) => {\n                 self.with_in_trait_impl(true, Some(*constness), |this| {\n-                    this.invalid_visibility(&item.vis, None);\n+                    this.visibility_not_permitted(\n+                        &item.vis,\n+                        errors::VisibilityNotPermittedNote::TraitImpl,\n+                    );\n                     if let TyKind::Err = self_ty.kind {\n                         this.err_handler().emit_err(errors::ObsoleteAuto { span: item.span });\n                     }\n@@ -866,9 +865,9 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                         only_trait: only_trait.then_some(()),\n                     };\n \n-                self.invalid_visibility(\n+                self.visibility_not_permitted(\n                     &item.vis,\n-                    Some(errors::InvalidVisibilityNote::IndividualImplItems),\n+                    errors::VisibilityNotPermittedNote::IndividualImplItems,\n                 );\n                 if let &Unsafe::Yes(span) = unsafety {\n                     self.err_handler().emit_err(errors::InherentImplCannotUnsafe {\n@@ -924,9 +923,9 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n             ItemKind::ForeignMod(ForeignMod { abi, unsafety, .. }) => {\n                 let old_item = mem::replace(&mut self.extern_mod, Some(item));\n-                self.invalid_visibility(\n+                self.visibility_not_permitted(\n                     &item.vis,\n-                    Some(errors::InvalidVisibilityNote::IndividualForeignItems),\n+                    errors::VisibilityNotPermittedNote::IndividualForeignItems,\n                 );\n                 if let &Unsafe::Yes(span) = unsafety {\n                     self.err_handler().emit_err(errors::UnsafeItem { span, kind: \"extern block\" });\n@@ -940,9 +939,15 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n             ItemKind::Enum(def, _) => {\n                 for variant in &def.variants {\n-                    self.invalid_visibility(&variant.vis, None);\n+                    self.visibility_not_permitted(\n+                        &variant.vis,\n+                        errors::VisibilityNotPermittedNote::EnumVariant,\n+                    );\n                     for field in variant.data.fields() {\n-                        self.invalid_visibility(&field.vis, None);\n+                        self.visibility_not_permitted(\n+                            &field.vis,\n+                            errors::VisibilityNotPermittedNote::EnumVariant,\n+                        );\n                     }\n                 }\n             }\n@@ -1075,7 +1080,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     self.with_impl_trait(None, |this| this.visit_ty(ty));\n                 }\n             }\n-            GenericArgs::ReturnTypeNotation(_span) => {}\n         }\n     }\n \n@@ -1301,7 +1305,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         }\n \n         if ctxt == AssocCtxt::Trait || self.in_trait_impl {\n-            self.invalid_visibility(&item.vis, None);\n+            self.visibility_not_permitted(&item.vis, errors::VisibilityNotPermittedNote::TraitImpl);\n             if let AssocItemKind::Fn(box Fn { sig, .. }) = &item.kind {\n                 self.check_trait_fn_not_const(sig.header.constness);\n             }\n@@ -1386,7 +1390,6 @@ fn deny_equality_constraints(\n                                     match &mut assoc_path.segments[len].args {\n                                         Some(args) => match args.deref_mut() {\n                                             GenericArgs::Parenthesized(_) => continue,\n-                                            GenericArgs::ReturnTypeNotation(_span) => continue,\n                                             GenericArgs::AngleBracketed(args) => {\n                                                 args.args.push(arg);\n                                             }"}, {"sha": "27bbd237961a932db7b3b5e7a8493cd0e9d21e99", "filename": "compiler/rustc_ast_passes/src/errors.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -42,18 +42,20 @@ pub struct InvalidLabel {\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes_invalid_visibility, code = \"E0449\")]\n-pub struct InvalidVisibility {\n+#[diag(ast_passes_visibility_not_permitted, code = \"E0449\")]\n+pub struct VisibilityNotPermitted {\n     #[primary_span]\n     pub span: Span,\n-    #[label(ast_passes_implied)]\n-    pub implied: Option<Span>,\n     #[subdiagnostic]\n-    pub note: Option<InvalidVisibilityNote>,\n+    pub note: VisibilityNotPermittedNote,\n }\n \n #[derive(Subdiagnostic)]\n-pub enum InvalidVisibilityNote {\n+pub enum VisibilityNotPermittedNote {\n+    #[note(ast_passes_enum_variant)]\n+    EnumVariant,\n+    #[note(ast_passes_trait_impl)]\n+    TraitImpl,\n     #[note(ast_passes_individual_impl_items)]\n     IndividualImplItems,\n     #[note(ast_passes_individual_foreign_items)]"}, {"sha": "17bcd24ee39fd48105cacfd08d0f222099e8be8a", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 31, "deletions": 18, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -121,24 +121,34 @@ impl<'a> PostExpansionVisitor<'a> {\n     }\n \n     /// Feature gate `impl Trait` inside `type Alias = $type_expr;`.\n-    fn check_impl_trait(&self, ty: &ast::Ty) {\n+    fn check_impl_trait(&self, ty: &ast::Ty, in_associated_ty: bool) {\n         struct ImplTraitVisitor<'a> {\n             vis: &'a PostExpansionVisitor<'a>,\n+            in_associated_ty: bool,\n         }\n         impl Visitor<'_> for ImplTraitVisitor<'_> {\n             fn visit_ty(&mut self, ty: &ast::Ty) {\n                 if let ast::TyKind::ImplTrait(..) = ty.kind {\n-                    gate_feature_post!(\n-                        &self.vis,\n-                        type_alias_impl_trait,\n-                        ty.span,\n-                        \"`impl Trait` in type aliases is unstable\"\n-                    );\n+                    if self.in_associated_ty {\n+                        gate_feature_post!(\n+                            &self.vis,\n+                            impl_trait_in_assoc_type,\n+                            ty.span,\n+                            \"`impl Trait` in associated types is unstable\"\n+                        );\n+                    } else {\n+                        gate_feature_post!(\n+                            &self.vis,\n+                            type_alias_impl_trait,\n+                            ty.span,\n+                            \"`impl Trait` in type aliases is unstable\"\n+                        );\n+                    }\n                 }\n                 visit::walk_ty(self, ty);\n             }\n         }\n-        ImplTraitVisitor { vis: self }.visit_ty(ty);\n+        ImplTraitVisitor { vis: self, in_associated_ty }.visit_ty(ty);\n     }\n \n     fn check_late_bound_lifetime_defs(&self, params: &[ast::GenericParam]) {\n@@ -294,7 +304,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             }\n \n             ast::ItemKind::TyAlias(box ast::TyAlias { ty: Some(ty), .. }) => {\n-                self.check_impl_trait(&ty)\n+                self.check_impl_trait(&ty, false)\n             }\n \n             _ => {}\n@@ -485,20 +495,23 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n \n     fn visit_assoc_constraint(&mut self, constraint: &'a AssocConstraint) {\n         if let AssocConstraintKind::Bound { .. } = constraint.kind {\n-            if let Some(args) = constraint.gen_args.as_ref()\n-                && matches!(\n-                    args,\n-                    ast::GenericArgs::ReturnTypeNotation(..)\n-                )\n+            if let Some(ast::GenericArgs::Parenthesized(args)) = constraint.gen_args.as_ref()\n+                && args.inputs.is_empty()\n+                && matches!(args.output, ast::FnRetTy::Default(..))\n             {\n-                // RTN is gated below with a `gate_all`.\n+                gate_feature_post!(\n+                    &self,\n+                    return_type_notation,\n+                    constraint.span,\n+                    \"return type notation is experimental\"\n+                );\n             } else {\n                 gate_feature_post!(\n                     &self,\n                     associated_type_bounds,\n                     constraint.span,\n                     \"associated type bounds are unstable\"\n-                )\n+                );\n             }\n         }\n         visit::walk_assoc_constraint(self, constraint)\n@@ -517,7 +530,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                     );\n                 }\n                 if let Some(ty) = ty {\n-                    self.check_impl_trait(ty);\n+                    self.check_impl_trait(ty, true);\n                 }\n                 false\n             }\n@@ -589,7 +602,6 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n     gate_all!(yeet_expr, \"`do yeet` expression is experimental\");\n     gate_all!(dyn_star, \"`dyn*` trait objects are experimental\");\n     gate_all!(const_closures, \"const closures are experimental\");\n-    gate_all!(return_type_notation, \"return type notation is experimental\");\n \n     // All uses of `gate_all!` below this point were added in #65742,\n     // and subsequently disabled (with the non-early gating readded).\n@@ -605,6 +617,7 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n \n     gate_all!(trait_alias, \"trait aliases are experimental\");\n     gate_all!(associated_type_bounds, \"associated type bounds are unstable\");\n+    gate_all!(return_type_notation, \"return type notation is experimental\");\n     gate_all!(decl_macro, \"`macro` is experimental\");\n     gate_all!(box_patterns, \"box pattern syntax is experimental\");\n     gate_all!(exclusive_range_pattern, \"exclusive range pattern syntax is experimental\");"}, {"sha": "849336c8669a1288fe20031bf54a7cf4a9c5452e", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -936,10 +936,6 @@ impl<'a> PrintState<'a> for State<'a> {\n                 self.word(\")\");\n                 self.print_fn_ret_ty(&data.output);\n             }\n-\n-            ast::GenericArgs::ReturnTypeNotation(_span) => {\n-                self.word(\"(..)\");\n-            }\n         }\n     }\n }"}, {"sha": "4824f6346d4c87b1b7474cda90c07e1fda572c4d", "filename": "compiler/rustc_borrowck/src/borrow_set.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1,6 +1,5 @@\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n-use crate::nll::ToRegionVid;\n use crate::path_utils::allow_two_phase_borrow;\n use crate::place_ext::PlaceExt;\n use crate::BorrowIndex;\n@@ -204,7 +203,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n                 return;\n             }\n \n-            let region = region.to_region_vid();\n+            let region = region.as_var();\n \n             let borrow = BorrowData {\n                 kind,\n@@ -279,7 +278,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n             let borrow_data = &self.location_map[&location];\n             assert_eq!(borrow_data.reserve_location, location);\n             assert_eq!(borrow_data.kind, kind);\n-            assert_eq!(borrow_data.region, region.to_region_vid());\n+            assert_eq!(borrow_data.region, region.as_var());\n             assert_eq!(borrow_data.borrowed_place, place);\n         }\n "}, {"sha": "2aa09a3f26c1758d6dc76f2d06f239a2efeada8c", "filename": "compiler/rustc_borrowck/src/constraint_generation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -12,8 +12,8 @@ use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{self, RegionVid, Ty, TyCtxt};\n \n use crate::{\n-    borrow_set::BorrowSet, facts::AllFacts, location::LocationTable, nll::ToRegionVid,\n-    places_conflict, region_infer::values::LivenessValues,\n+    borrow_set::BorrowSet, facts::AllFacts, location::LocationTable, places_conflict,\n+    region_infer::values::LivenessValues,\n };\n \n pub(super) fn generate_constraints<'tcx>(\n@@ -170,7 +170,7 @@ impl<'cx, 'tcx> ConstraintGeneration<'cx, 'tcx> {\n         debug!(\"add_regular_live_constraint(live_ty={:?}, location={:?})\", live_ty, location);\n \n         self.infcx.tcx.for_each_free_region(&live_ty, |live_region| {\n-            let vid = live_region.to_region_vid();\n+            let vid = live_region.as_var();\n             self.liveness_constraints.add_element(vid, location);\n         });\n     }"}, {"sha": "f5a34cb0561bb31ffa237865c664388c41ef85d6", "filename": "compiler/rustc_borrowck/src/constraints/graph.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fgraph.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -13,7 +13,7 @@ use crate::{\n /// The construct graph organizes the constraints by their end-points.\n /// It can be used to view a `R1: R2` constraint as either an edge `R1\n /// -> R2` or `R2 -> R1` depending on the direction type `D`.\n-pub(crate) struct ConstraintGraph<D: ConstraintGraphDirecton> {\n+pub(crate) struct ConstraintGraph<D: ConstraintGraphDirection> {\n     _direction: D,\n     first_constraints: IndexVec<RegionVid, Option<OutlivesConstraintIndex>>,\n     next_constraints: IndexVec<OutlivesConstraintIndex, Option<OutlivesConstraintIndex>>,\n@@ -25,7 +25,7 @@ pub(crate) type ReverseConstraintGraph = ConstraintGraph<Reverse>;\n \n /// Marker trait that controls whether a `R1: R2` constraint\n /// represents an edge `R1 -> R2` or `R2 -> R1`.\n-pub(crate) trait ConstraintGraphDirecton: Copy + 'static {\n+pub(crate) trait ConstraintGraphDirection: Copy + 'static {\n     fn start_region(c: &OutlivesConstraint<'_>) -> RegionVid;\n     fn end_region(c: &OutlivesConstraint<'_>) -> RegionVid;\n     fn is_normal() -> bool;\n@@ -38,7 +38,7 @@ pub(crate) trait ConstraintGraphDirecton: Copy + 'static {\n #[derive(Copy, Clone, Debug)]\n pub(crate) struct Normal;\n \n-impl ConstraintGraphDirecton for Normal {\n+impl ConstraintGraphDirection for Normal {\n     fn start_region(c: &OutlivesConstraint<'_>) -> RegionVid {\n         c.sup\n     }\n@@ -59,7 +59,7 @@ impl ConstraintGraphDirecton for Normal {\n #[derive(Copy, Clone, Debug)]\n pub(crate) struct Reverse;\n \n-impl ConstraintGraphDirecton for Reverse {\n+impl ConstraintGraphDirection for Reverse {\n     fn start_region(c: &OutlivesConstraint<'_>) -> RegionVid {\n         c.sub\n     }\n@@ -73,7 +73,7 @@ impl ConstraintGraphDirecton for Reverse {\n     }\n }\n \n-impl<D: ConstraintGraphDirecton> ConstraintGraph<D> {\n+impl<D: ConstraintGraphDirection> ConstraintGraph<D> {\n     /// Creates a \"dependency graph\" where each region constraint `R1:\n     /// R2` is treated as an edge `R1 -> R2`. We use this graph to\n     /// construct SCCs for region inference but also for error\n@@ -133,15 +133,15 @@ impl<D: ConstraintGraphDirecton> ConstraintGraph<D> {\n     }\n }\n \n-pub(crate) struct Edges<'s, 'tcx, D: ConstraintGraphDirecton> {\n+pub(crate) struct Edges<'s, 'tcx, D: ConstraintGraphDirection> {\n     graph: &'s ConstraintGraph<D>,\n     constraints: &'s OutlivesConstraintSet<'tcx>,\n     pointer: Option<OutlivesConstraintIndex>,\n     next_static_idx: Option<usize>,\n     static_region: RegionVid,\n }\n \n-impl<'s, 'tcx, D: ConstraintGraphDirecton> Iterator for Edges<'s, 'tcx, D> {\n+impl<'s, 'tcx, D: ConstraintGraphDirection> Iterator for Edges<'s, 'tcx, D> {\n     type Item = OutlivesConstraint<'tcx>;\n \n     fn next(&mut self) -> Option<Self::Item> {\n@@ -174,13 +174,13 @@ impl<'s, 'tcx, D: ConstraintGraphDirecton> Iterator for Edges<'s, 'tcx, D> {\n /// This struct brings together a constraint set and a (normal, not\n /// reverse) constraint graph. It implements the graph traits and is\n /// usd for doing the SCC computation.\n-pub(crate) struct RegionGraph<'s, 'tcx, D: ConstraintGraphDirecton> {\n+pub(crate) struct RegionGraph<'s, 'tcx, D: ConstraintGraphDirection> {\n     set: &'s OutlivesConstraintSet<'tcx>,\n     constraint_graph: &'s ConstraintGraph<D>,\n     static_region: RegionVid,\n }\n \n-impl<'s, 'tcx, D: ConstraintGraphDirecton> RegionGraph<'s, 'tcx, D> {\n+impl<'s, 'tcx, D: ConstraintGraphDirection> RegionGraph<'s, 'tcx, D> {\n     /// Creates a \"dependency graph\" where each region constraint `R1:\n     /// R2` is treated as an edge `R1 -> R2`. We use this graph to\n     /// construct SCCs for region inference but also for error\n@@ -202,35 +202,37 @@ impl<'s, 'tcx, D: ConstraintGraphDirecton> RegionGraph<'s, 'tcx, D> {\n     }\n }\n \n-pub(crate) struct Successors<'s, 'tcx, D: ConstraintGraphDirecton> {\n+pub(crate) struct Successors<'s, 'tcx, D: ConstraintGraphDirection> {\n     edges: Edges<'s, 'tcx, D>,\n }\n \n-impl<'s, 'tcx, D: ConstraintGraphDirecton> Iterator for Successors<'s, 'tcx, D> {\n+impl<'s, 'tcx, D: ConstraintGraphDirection> Iterator for Successors<'s, 'tcx, D> {\n     type Item = RegionVid;\n \n     fn next(&mut self) -> Option<Self::Item> {\n         self.edges.next().map(|c| D::end_region(&c))\n     }\n }\n \n-impl<'s, 'tcx, D: ConstraintGraphDirecton> graph::DirectedGraph for RegionGraph<'s, 'tcx, D> {\n+impl<'s, 'tcx, D: ConstraintGraphDirection> graph::DirectedGraph for RegionGraph<'s, 'tcx, D> {\n     type Node = RegionVid;\n }\n \n-impl<'s, 'tcx, D: ConstraintGraphDirecton> graph::WithNumNodes for RegionGraph<'s, 'tcx, D> {\n+impl<'s, 'tcx, D: ConstraintGraphDirection> graph::WithNumNodes for RegionGraph<'s, 'tcx, D> {\n     fn num_nodes(&self) -> usize {\n         self.constraint_graph.first_constraints.len()\n     }\n }\n \n-impl<'s, 'tcx, D: ConstraintGraphDirecton> graph::WithSuccessors for RegionGraph<'s, 'tcx, D> {\n+impl<'s, 'tcx, D: ConstraintGraphDirection> graph::WithSuccessors for RegionGraph<'s, 'tcx, D> {\n     fn successors(&self, node: Self::Node) -> <Self as graph::GraphSuccessors<'_>>::Iter {\n         self.outgoing_regions(node)\n     }\n }\n \n-impl<'s, 'tcx, D: ConstraintGraphDirecton> graph::GraphSuccessors<'_> for RegionGraph<'s, 'tcx, D> {\n+impl<'s, 'tcx, D: ConstraintGraphDirection> graph::GraphSuccessors<'_>\n+    for RegionGraph<'s, 'tcx, D>\n+{\n     type Item = RegionVid;\n     type Iter = Successors<'s, 'tcx, D>;\n }"}, {"sha": "94939c7e4cd72ea0824baf09b64670e9fe2cae99", "filename": "compiler/rustc_borrowck/src/dataflow.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -11,9 +11,7 @@ use rustc_mir_dataflow::{self, fmt::DebugWithContext, CallReturnPlaces, GenKill}\n use rustc_mir_dataflow::{Analysis, Direction, Results};\n use std::fmt;\n \n-use crate::{\n-    places_conflict, BorrowSet, PlaceConflictBias, PlaceExt, RegionInferenceContext, ToRegionVid,\n-};\n+use crate::{places_conflict, BorrowSet, PlaceConflictBias, PlaceExt, RegionInferenceContext};\n \n /// A tuple with named fields that can hold either the results or the transient state of the\n /// dataflow analyses used by the borrow checker.\n@@ -242,7 +240,7 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n     ) -> Self {\n         let mut prec = OutOfScopePrecomputer::new(body, nonlexical_regioncx);\n         for (borrow_index, borrow_data) in borrow_set.iter_enumerated() {\n-            let borrow_region = borrow_data.region.to_region_vid();\n+            let borrow_region = borrow_data.region;\n             let location = borrow_data.reserve_location;\n \n             prec.precompute_borrows_out_of_scope(borrow_index, borrow_region, location);"}, {"sha": "2495613fea1d2c9e6473f7a299c9199c6630f0cf", "filename": "compiler/rustc_borrowck/src/diagnostics/find_use.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -6,7 +6,6 @@ use std::rc::Rc;\n \n use crate::{\n     def_use::{self, DefUse},\n-    nll::ToRegionVid,\n     region_infer::{Cause, RegionInferenceContext},\n };\n use rustc_data_structures::fx::FxIndexSet;\n@@ -117,7 +116,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for DefUseVisitor<'cx, 'tcx> {\n \n         let mut found_it = false;\n         self.tcx.for_each_free_region(&local_ty, |r| {\n-            if r.to_region_vid() == self.region_vid {\n+            if r.as_var() == self.region_vid {\n                 found_it = true;\n             }\n         });"}, {"sha": "f69c4829ae2999ba9df9f39c02f8da69b86b10e4", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -10,7 +10,7 @@ use rustc_middle::ty::{self, RegionVid, Ty};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n \n-use crate::{nll::ToRegionVid, universal_regions::DefiningTy, MirBorrowckCtxt};\n+use crate::{universal_regions::DefiningTy, MirBorrowckCtxt};\n \n /// A name for a particular region used in emitting diagnostics. This name could be a generated\n /// name like `'1`, a name used by the user like `'a`, or a name like `'static`.\n@@ -497,7 +497,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                 //     &\n                 //     - let's call the lifetime of this reference `'1`\n                 (ty::Ref(region, referent_ty, _), hir::TyKind::Ref(_lifetime, referent_hir_ty)) => {\n-                    if region.to_region_vid() == needle_fr {\n+                    if region.as_var() == needle_fr {\n                         // Just grab the first character, the `&`.\n                         let source_map = self.infcx.tcx.sess.source_map();\n                         let ampersand_span = source_map.start_point(hir_ty.span);\n@@ -598,7 +598,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         for (kind, hir_arg) in iter::zip(substs, args.args) {\n             match (kind.unpack(), hir_arg) {\n                 (GenericArgKind::Lifetime(r), hir::GenericArg::Lifetime(lt)) => {\n-                    if r.to_region_vid() == needle_fr {\n+                    if r.as_var() == needle_fr {\n                         return Some(lt);\n                     }\n                 }\n@@ -666,7 +666,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n \n         let return_ty = self.regioncx.universal_regions().unnormalized_output_ty;\n         debug!(\"give_name_if_anonymous_region_appears_in_output: return_ty = {:?}\", return_ty);\n-        if !tcx.any_free_region_meets(&return_ty, |r| r.to_region_vid() == fr) {\n+        if !tcx.any_free_region_meets(&return_ty, |r| r.as_var() == fr) {\n             return None;\n         }\n \n@@ -803,7 +803,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n \n         let tcx = self.infcx.tcx;\n \n-        if !tcx.any_free_region_meets(&yield_ty, |r| r.to_region_vid() == fr) {\n+        if !tcx.any_free_region_meets(&yield_ty, |r| r.as_var() == fr) {\n             return None;\n         }\n "}, {"sha": "376415e3d3208466ca69af129d650beb154ae6e2", "filename": "compiler/rustc_borrowck/src/diagnostics/var_name.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1,8 +1,8 @@\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n \n+use crate::region_infer::RegionInferenceContext;\n use crate::Upvar;\n-use crate::{nll::ToRegionVid, region_infer::RegionInferenceContext};\n use rustc_index::vec::{Idx, IndexSlice};\n use rustc_middle::mir::{Body, Local};\n use rustc_middle::ty::{RegionVid, TyCtxt};\n@@ -46,7 +46,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             self.universal_regions().defining_ty.upvar_tys().position(|upvar_ty| {\n                 debug!(\"get_upvar_index_for_region: upvar_ty={upvar_ty:?}\");\n                 tcx.any_free_region_meets(&upvar_ty, |r| {\n-                    let r = r.to_region_vid();\n+                    let r = r.as_var();\n                     debug!(\"get_upvar_index_for_region: r={r:?} fr={fr:?}\");\n                     r == fr\n                 })\n@@ -96,7 +96,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             self.universal_regions().unnormalized_input_tys.iter().skip(implicit_inputs).position(\n                 |arg_ty| {\n                     debug!(\"get_argument_index_for_region: arg_ty = {arg_ty:?}\");\n-                    tcx.any_free_region_meets(arg_ty, |r| r.to_region_vid() == fr)\n+                    tcx.any_free_region_meets(arg_ty, |r| r.as_var() == fr)\n                 },\n             )?;\n "}, {"sha": "a4b285a34fa4654eac10e3934274415fe20f2ba3", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -94,7 +94,7 @@ pub mod consumers;\n \n use borrow_set::{BorrowData, BorrowSet};\n use dataflow::{BorrowIndex, BorrowckFlowState as Flows, BorrowckResults, Borrows};\n-use nll::{PoloniusOutput, ToRegionVid};\n+use nll::PoloniusOutput;\n use place_ext::PlaceExt;\n use places_conflict::{places_conflict, PlaceConflictBias};\n use region_infer::RegionInferenceContext;\n@@ -507,9 +507,7 @@ impl<'cx, 'tcx> BorrowckInferCtxt<'cx, 'tcx> {\n         F: Fn() -> RegionCtxt,\n     {\n         let next_region = self.infcx.next_region_var(origin);\n-        let vid = next_region\n-            .as_var()\n-            .unwrap_or_else(|| bug!(\"expected RegionKind::RegionVar on {:?}\", next_region));\n+        let vid = next_region.as_var();\n \n         if cfg!(debug_assertions) && !self.inside_canonicalization_ctxt() {\n             debug!(\"inserting vid {:?} with origin {:?} into var_to_origin\", vid, origin);\n@@ -531,9 +529,7 @@ impl<'cx, 'tcx> BorrowckInferCtxt<'cx, 'tcx> {\n         F: Fn() -> RegionCtxt,\n     {\n         let next_region = self.infcx.next_nll_region_var(origin.clone());\n-        let vid = next_region\n-            .as_var()\n-            .unwrap_or_else(|| bug!(\"expected RegionKind::RegionVar on {:?}\", next_region));\n+        let vid = next_region.as_var();\n \n         if cfg!(debug_assertions) && !self.inside_canonicalization_ctxt() {\n             debug!(\"inserting vid {:?} with origin {:?} into var_to_origin\", vid, origin);"}, {"sha": "59a3ab3189d75628e48a0849f882ab6b8fa6a686", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -10,7 +10,7 @@ use rustc_middle::mir::{\n     BasicBlock, Body, ClosureOutlivesSubject, ClosureRegionRequirements, LocalKind, Location,\n     Promoted,\n };\n-use rustc_middle::ty::{self, OpaqueHiddenType, Region, RegionVid, TyCtxt};\n+use rustc_middle::ty::{self, OpaqueHiddenType, TyCtxt};\n use rustc_span::symbol::sym;\n use std::env;\n use std::io;\n@@ -444,27 +444,6 @@ fn for_each_region_constraint<'tcx>(\n     Ok(())\n }\n \n-/// Right now, we piggy back on the `ReVar` to store our NLL inference\n-/// regions. These are indexed with `RegionVid`. This method will\n-/// assert that the region is a `ReVar` and extract its internal index.\n-/// This is reasonable because in our MIR we replace all universal regions\n-/// with inference variables.\n-pub trait ToRegionVid {\n-    fn to_region_vid(self) -> RegionVid;\n-}\n-\n-impl<'tcx> ToRegionVid for Region<'tcx> {\n-    fn to_region_vid(self) -> RegionVid {\n-        if let ty::ReVar(vid) = *self { vid } else { bug!(\"region is not an ReVar: {:?}\", self) }\n-    }\n-}\n-\n-impl ToRegionVid for RegionVid {\n-    fn to_region_vid(self) -> RegionVid {\n-        self\n-    }\n-}\n-\n pub(crate) trait ConstraintDescription {\n     fn description(&self) -> &'static str;\n }"}, {"sha": "729f3dbff3b46b1050128075f5c091cf86f8ba65", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -27,7 +27,7 @@ use crate::{\n     },\n     diagnostics::{RegionErrorKind, RegionErrors, UniverseInfo},\n     member_constraints::{MemberConstraintSet, NllMemberConstraintIndex},\n-    nll::{PoloniusOutput, ToRegionVid},\n+    nll::PoloniusOutput,\n     region_infer::reverse_sccs::ReverseSccGraph,\n     region_infer::values::{\n         LivenessValues, PlaceholderIndices, RegionElement, RegionValueElements, RegionValues,\n@@ -593,39 +593,36 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Returns `true` if the region `r` contains the point `p`.\n     ///\n     /// Panics if called before `solve()` executes,\n-    pub(crate) fn region_contains(&self, r: impl ToRegionVid, p: impl ToElementIndex) -> bool {\n-        let scc = self.constraint_sccs.scc(r.to_region_vid());\n+    pub(crate) fn region_contains(&self, r: RegionVid, p: impl ToElementIndex) -> bool {\n+        let scc = self.constraint_sccs.scc(r);\n         self.scc_values.contains(scc, p)\n     }\n \n     /// Returns access to the value of `r` for debugging purposes.\n     pub(crate) fn region_value_str(&self, r: RegionVid) -> String {\n-        let scc = self.constraint_sccs.scc(r.to_region_vid());\n+        let scc = self.constraint_sccs.scc(r);\n         self.scc_values.region_value_str(scc)\n     }\n \n     pub(crate) fn placeholders_contained_in<'a>(\n         &'a self,\n         r: RegionVid,\n     ) -> impl Iterator<Item = ty::PlaceholderRegion> + 'a {\n-        let scc = self.constraint_sccs.scc(r.to_region_vid());\n+        let scc = self.constraint_sccs.scc(r);\n         self.scc_values.placeholders_contained_in(scc)\n     }\n \n     /// Returns access to the value of `r` for debugging purposes.\n     pub(crate) fn region_universe(&self, r: RegionVid) -> ty::UniverseIndex {\n-        let scc = self.constraint_sccs.scc(r.to_region_vid());\n+        let scc = self.constraint_sccs.scc(r);\n         self.scc_universes[scc]\n     }\n \n     /// Once region solving has completed, this function will return\n     /// the member constraints that were applied to the value of a given\n     /// region `r`. See `AppliedMemberConstraint`.\n-    pub(crate) fn applied_member_constraints(\n-        &self,\n-        r: impl ToRegionVid,\n-    ) -> &[AppliedMemberConstraint] {\n-        let scc = self.constraint_sccs.scc(r.to_region_vid());\n+    pub(crate) fn applied_member_constraints(&self, r: RegionVid) -> &[AppliedMemberConstraint] {\n+        let scc = self.constraint_sccs.scc(r);\n         binary_search_util::binary_search_slice(\n             &self.member_constraints_applied,\n             |applied| applied.member_region_scc,\n@@ -1133,7 +1130,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             let r_vid = self.to_region_vid(r);\n             let r_scc = self.constraint_sccs.scc(r_vid);\n \n-            // The challenge if this. We have some region variable `r`\n+            // The challenge is this. We have some region variable `r`\n             // whose value is a set of CFG points and universal\n             // regions. We want to find if that set is *equivalent* to\n             // any of the named regions found in the closure.\n@@ -2234,7 +2231,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         r: RegionVid,\n         body: &Body<'_>,\n     ) -> Option<Location> {\n-        let scc = self.constraint_sccs.scc(r.to_region_vid());\n+        let scc = self.constraint_sccs.scc(r);\n         let locations = self.scc_values.locations_outlived_by(scc);\n         for location in locations {\n             let bb = &body[location.block];"}, {"sha": "94ce29dfe519790e968d67d7ab0980774fa9b2eb", "filename": "compiler/rustc_borrowck/src/renumber.rs", "status": "modified", "additions": 15, "deletions": 30, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -20,31 +20,13 @@ pub fn renumber_mir<'tcx>(\n ) {\n     debug!(?body.arg_count);\n \n-    let mut visitor = NllVisitor { infcx };\n+    let mut renumberer = RegionRenumberer { infcx };\n \n     for body in promoted.iter_mut() {\n-        visitor.visit_body(body);\n+        renumberer.visit_body(body);\n     }\n \n-    visitor.visit_body(body);\n-}\n-\n-/// Replaces all regions appearing in `value` with fresh inference\n-/// variables.\n-#[instrument(skip(infcx, get_ctxt_fn), level = \"debug\")]\n-pub(crate) fn renumber_regions<'tcx, T, F>(\n-    infcx: &BorrowckInferCtxt<'_, 'tcx>,\n-    value: T,\n-    get_ctxt_fn: F,\n-) -> T\n-where\n-    T: TypeFoldable<TyCtxt<'tcx>>,\n-    F: Fn() -> RegionCtxt,\n-{\n-    infcx.tcx.fold_regions(value, |_region, _depth| {\n-        let origin = NllRegionVariableOrigin::Existential { from_forall: false };\n-        infcx.next_nll_region_var(origin, || get_ctxt_fn())\n-    })\n+    renumberer.visit_body(body);\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]\n@@ -69,34 +51,37 @@ impl RegionCtxt {\n     /// Used to determine the representative of a component in the strongly connected\n     /// constraint graph\n     pub(crate) fn preference_value(self) -> usize {\n-        let _anon = Symbol::intern(\"anon\");\n-\n         match self {\n             RegionCtxt::Unknown => 1,\n             RegionCtxt::Existential(None) => 2,\n-            RegionCtxt::Existential(Some(_anon)) | RegionCtxt::Free(_anon) => 2,\n+            RegionCtxt::Existential(Some(_)) | RegionCtxt::Free(_) => 2,\n             RegionCtxt::Location(_) => 3,\n             RegionCtxt::TyContext(_) => 4,\n             _ => 5,\n         }\n     }\n }\n \n-struct NllVisitor<'a, 'tcx> {\n+struct RegionRenumberer<'a, 'tcx> {\n     infcx: &'a BorrowckInferCtxt<'a, 'tcx>,\n }\n \n-impl<'a, 'tcx> NllVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> RegionRenumberer<'a, 'tcx> {\n+    /// Replaces all regions appearing in `value` with fresh inference\n+    /// variables.\n     fn renumber_regions<T, F>(&mut self, value: T, region_ctxt_fn: F) -> T\n     where\n         T: TypeFoldable<TyCtxt<'tcx>>,\n         F: Fn() -> RegionCtxt,\n     {\n-        renumber_regions(self.infcx, value, region_ctxt_fn)\n+        let origin = NllRegionVariableOrigin::Existential { from_forall: false };\n+        self.infcx.tcx.fold_regions(value, |_region, _depth| {\n+            self.infcx.next_nll_region_var(origin, || region_ctxt_fn())\n+        })\n     }\n }\n \n-impl<'a, 'tcx> MutVisitor<'tcx> for NllVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> MutVisitor<'tcx> for RegionRenumberer<'a, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n@@ -124,9 +109,9 @@ impl<'a, 'tcx> MutVisitor<'tcx> for NllVisitor<'a, 'tcx> {\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n-    fn visit_constant(&mut self, constant: &mut Constant<'tcx>, _location: Location) {\n+    fn visit_constant(&mut self, constant: &mut Constant<'tcx>, location: Location) {\n         let literal = constant.literal;\n-        constant.literal = self.renumber_regions(literal, || RegionCtxt::Location(_location));\n+        constant.literal = self.renumber_regions(literal, || RegionCtxt::Location(location));\n         debug!(\"constant: {:#?}\", constant);\n     }\n }"}, {"sha": "71eae7b27d1db7835d8e4625781d9b6f3f9013ac", "filename": "compiler/rustc_borrowck/src/type_check/constraint_conversion.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -12,7 +12,6 @@ use rustc_span::{Span, DUMMY_SP};\n \n use crate::{\n     constraints::OutlivesConstraint,\n-    nll::ToRegionVid,\n     region_infer::TypeTest,\n     type_check::{Locations, MirTypeckRegionConstraints},\n     universal_regions::UniversalRegions,\n@@ -198,7 +197,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n \n     fn to_region_vid(&mut self, r: ty::Region<'tcx>) -> ty::RegionVid {\n         if let ty::RePlaceholder(placeholder) = *r {\n-            self.constraints.placeholder_region(self.infcx, placeholder).to_region_vid()\n+            self.constraints.placeholder_region(self.infcx, placeholder).as_var()\n         } else {\n             self.universal_regions.to_region_vid(r)\n         }"}, {"sha": "f1ad0ca55ccfd45b0a9dc8bdc11345dcbb286984", "filename": "compiler/rustc_borrowck/src/type_check/liveness/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -11,7 +11,6 @@ use crate::{\n     constraints::OutlivesConstraintSet,\n     facts::{AllFacts, AllFactsExt},\n     location::LocationTable,\n-    nll::ToRegionVid,\n     region_infer::values::RegionValueElements,\n     universal_regions::UniversalRegions,\n };\n@@ -80,9 +79,7 @@ fn compute_relevant_live_locals<'tcx>(\n ) -> (Vec<Local>, Vec<Local>) {\n     let (boring_locals, relevant_live_locals): (Vec<_>, Vec<_>) =\n         body.local_decls.iter_enumerated().partition_map(|(local, local_decl)| {\n-            if tcx.all_free_regions_meet(&local_decl.ty, |r| {\n-                free_regions.contains(&r.to_region_vid())\n-            }) {\n+            if tcx.all_free_regions_meet(&local_decl.ty, |r| free_regions.contains(&r.as_var())) {\n                 Either::Left(local)\n             } else {\n                 Either::Right(local)"}, {"sha": "375eca1b29d3daf841f5b0d184d2a0976276cde0", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -35,6 +35,7 @@ use rustc_middle::ty::{\n     OpaqueHiddenType, OpaqueTypeKey, RegionVid, Ty, TyCtxt, UserType, UserTypeAnnotationIndex,\n };\n use rustc_span::def_id::CRATE_DEF_ID;\n+use rustc_span::symbol::sym;\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::{FieldIdx, FIRST_VARIANT};\n use rustc_trait_selection::traits::query::type_op::custom::scrape_region_constraints;\n@@ -55,7 +56,6 @@ use crate::{\n     facts::AllFacts,\n     location::LocationTable,\n     member_constraints::MemberConstraintSet,\n-    nll::ToRegionVid,\n     path_utils,\n     region_infer::values::{\n         LivenessValues, PlaceholderIndex, PlaceholderIndices, RegionValueElements,\n@@ -1338,18 +1338,13 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 };\n                 let (sig, map) = tcx.replace_late_bound_regions(sig, |br| {\n                     use crate::renumber::{BoundRegionInfo, RegionCtxt};\n-                    use rustc_span::Symbol;\n \n                     let region_ctxt_fn = || {\n                         let reg_info = match br.kind {\n                             ty::BoundRegionKind::BrAnon(Some(span)) => BoundRegionInfo::Span(span),\n-                            ty::BoundRegionKind::BrAnon(..) => {\n-                                BoundRegionInfo::Name(Symbol::intern(\"anon\"))\n-                            }\n+                            ty::BoundRegionKind::BrAnon(..) => BoundRegionInfo::Name(sym::anon),\n                             ty::BoundRegionKind::BrNamed(_, name) => BoundRegionInfo::Name(name),\n-                            ty::BoundRegionKind::BrEnv => {\n-                                BoundRegionInfo::Name(Symbol::intern(\"env\"))\n-                            }\n+                            ty::BoundRegionKind::BrEnv => BoundRegionInfo::Name(sym::env),\n                         };\n \n                         RegionCtxt::LateBound(reg_info)\n@@ -2423,7 +2418,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         if let Some(all_facts) = all_facts {\n             let _prof_timer = self.infcx.tcx.prof.generic_activity(\"polonius_fact_generation\");\n             if let Some(borrow_index) = borrow_set.get_index_of(&location) {\n-                let region_vid = borrow_region.to_region_vid();\n+                let region_vid = borrow_region.as_var();\n                 all_facts.loan_issued_at.push((\n                     region_vid,\n                     borrow_index,\n@@ -2469,8 +2464,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     match base_ty.kind() {\n                         ty::Ref(ref_region, _, mutbl) => {\n                             constraints.outlives_constraints.push(OutlivesConstraint {\n-                                sup: ref_region.to_region_vid(),\n-                                sub: borrow_region.to_region_vid(),\n+                                sup: ref_region.as_var(),\n+                                sub: borrow_region.as_var(),\n                                 locations: location.to_locations(),\n                                 span: location.to_locations().span(body),\n                                 category,\n@@ -2600,7 +2595,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 self.implicit_region_bound,\n                 self.param_env,\n                 location.to_locations(),\n-                DUMMY_SP,                   // irrelevant; will be overrided.\n+                DUMMY_SP,                   // irrelevant; will be overridden.\n                 ConstraintCategory::Boring, // same as above.\n                 &mut self.borrowck_context.constraints,\n             )"}, {"sha": "7e6d17ec3437e7062680df9557b1843f80d27506", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -4,6 +4,7 @@ use rustc_infer::traits::PredicateObligations;\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::{self, Ty};\n+use rustc_span::symbol::sym;\n use rustc_span::{Span, Symbol};\n use rustc_trait_selection::traits::query::Fallible;\n \n@@ -125,18 +126,14 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n \n         let reg_info = match placeholder.bound.kind {\n             ty::BoundRegionKind::BrAnon(Some(span)) => BoundRegionInfo::Span(span),\n-            ty::BoundRegionKind::BrAnon(..) => BoundRegionInfo::Name(Symbol::intern(\"anon\")),\n+            ty::BoundRegionKind::BrAnon(..) => BoundRegionInfo::Name(sym::anon),\n             ty::BoundRegionKind::BrNamed(_, name) => BoundRegionInfo::Name(name),\n-            ty::BoundRegionKind::BrEnv => BoundRegionInfo::Name(Symbol::intern(\"env\")),\n+            ty::BoundRegionKind::BrEnv => BoundRegionInfo::Name(sym::env),\n         };\n \n-        let reg_var =\n-            reg.as_var().unwrap_or_else(|| bug!(\"expected region {:?} to be of kind ReVar\", reg));\n-\n         if cfg!(debug_assertions) && !self.type_checker.infcx.inside_canonicalization_ctxt() {\n             let mut var_to_origin = self.type_checker.infcx.reg_var_to_origin.borrow_mut();\n-            debug!(?reg_var);\n-            var_to_origin.insert(reg_var, RegionCtxt::Placeholder(reg_info));\n+            var_to_origin.insert(reg.as_var(), RegionCtxt::Placeholder(reg_info));\n         }\n \n         reg\n@@ -149,12 +146,9 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n             universe,\n         );\n \n-        let reg_var =\n-            reg.as_var().unwrap_or_else(|| bug!(\"expected region {:?} to be of kind ReVar\", reg));\n-\n         if cfg!(debug_assertions) && !self.type_checker.infcx.inside_canonicalization_ctxt() {\n             let mut var_to_origin = self.type_checker.infcx.reg_var_to_origin.borrow_mut();\n-            var_to_origin.insert(reg_var, RegionCtxt::Existential(None));\n+            var_to_origin.insert(reg.as_var(), RegionCtxt::Existential(None));\n         }\n \n         reg"}, {"sha": "70fddb1057c09c86f69a7f5f03c6773648b0b52d", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 20, "deletions": 43, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -24,10 +24,10 @@ use rustc_infer::infer::NllRegionVariableOrigin;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{self, InlineConstSubsts, InlineConstSubstsParts, RegionVid, Ty, TyCtxt};\n use rustc_middle::ty::{InternalSubsts, SubstsRef};\n+use rustc_span::symbol::{kw, sym};\n use rustc_span::Symbol;\n use std::iter;\n \n-use crate::nll::ToRegionVid;\n use crate::renumber::{BoundRegionInfo, RegionCtxt};\n use crate::BorrowckInferCtxt;\n \n@@ -404,10 +404,8 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         assert_eq!(FIRST_GLOBAL_INDEX, self.infcx.num_region_vars());\n \n         // Create the \"global\" region that is always free in all contexts: 'static.\n-        let fr_static = self\n-            .infcx\n-            .next_nll_region_var(FR, || RegionCtxt::Free(Symbol::intern(\"static\")))\n-            .to_region_vid();\n+        let fr_static =\n+            self.infcx.next_nll_region_var(FR, || RegionCtxt::Free(kw::Static)).as_var();\n \n         // We've now added all the global regions. The next ones we\n         // add will be external.\n@@ -440,18 +438,14 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                     debug!(?r);\n                     if !indices.indices.contains_key(&r) {\n                         let region_vid = {\n-                            let name = match r.get_name() {\n-                                Some(name) => name,\n-                                _ => Symbol::intern(\"anon\"),\n-                            };\n-\n+                            let name = r.get_name_or_anon();\n                             self.infcx.next_nll_region_var(FR, || {\n                                 RegionCtxt::LateBound(BoundRegionInfo::Name(name))\n                             })\n                         };\n \n                         debug!(?region_vid);\n-                        indices.insert_late_bound_region(r, region_vid.to_region_vid());\n+                        indices.insert_late_bound_region(r, region_vid.as_var());\n                     }\n                 },\n             );\n@@ -478,18 +472,14 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             debug!(?r);\n             if !indices.indices.contains_key(&r) {\n                 let region_vid = {\n-                    let name = match r.get_name() {\n-                        Some(name) => name,\n-                        _ => Symbol::intern(\"anon\"),\n-                    };\n-\n+                    let name = r.get_name_or_anon();\n                     self.infcx.next_nll_region_var(FR, || {\n                         RegionCtxt::LateBound(BoundRegionInfo::Name(name))\n                     })\n                 };\n \n                 debug!(?region_vid);\n-                indices.insert_late_bound_region(r, region_vid.to_region_vid());\n+                indices.insert_late_bound_region(r, region_vid.as_var());\n             }\n         });\n \n@@ -508,7 +498,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                 let reg_vid = self\n                     .infcx\n                     .next_nll_region_var(FR, || RegionCtxt::Free(Symbol::intern(\"c-variadic\")))\n-                    .to_region_vid();\n+                    .as_var();\n \n                 let region = self.infcx.tcx.mk_re_var(reg_vid);\n                 let va_list_ty =\n@@ -523,7 +513,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         let fr_fn_body = self\n             .infcx\n             .next_nll_region_var(FR, || RegionCtxt::Free(Symbol::intern(\"fn_body\")))\n-            .to_region_vid();\n+            .as_var();\n \n         let num_universals = self.infcx.num_region_vars();\n \n@@ -644,7 +634,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n \n         let global_mapping = iter::once((tcx.lifetimes.re_static, fr_static));\n         let subst_mapping =\n-            iter::zip(identity_substs.regions(), fr_substs.regions().map(|r| r.to_region_vid()));\n+            iter::zip(identity_substs.regions(), fr_substs.regions().map(|r| r.as_var()));\n \n         UniversalRegionIndices { indices: global_mapping.chain(subst_mapping).collect(), fr_static }\n     }\n@@ -768,15 +758,10 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for BorrowckInferCtxt<'cx, 'tcx> {\n         T: TypeFoldable<TyCtxt<'tcx>>,\n     {\n         self.infcx.tcx.fold_regions(value, |region, _depth| {\n-            let name = match region.get_name() {\n-                Some(name) => name,\n-                _ => Symbol::intern(\"anon\"),\n-            };\n+            let name = region.get_name_or_anon();\n             debug!(?region, ?name);\n \n-            let reg_var = self.next_nll_region_var(origin, || RegionCtxt::Free(name));\n-\n-            reg_var\n+            self.next_nll_region_var(origin, || RegionCtxt::Free(name))\n         })\n     }\n \n@@ -797,13 +782,13 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for BorrowckInferCtxt<'cx, 'tcx> {\n             let region_vid = {\n                 let name = match br.kind.get_name() {\n                     Some(name) => name,\n-                    _ => Symbol::intern(\"anon\"),\n+                    _ => sym::anon,\n                 };\n \n                 self.next_nll_region_var(origin, || RegionCtxt::Bound(BoundRegionInfo::Name(name)))\n             };\n \n-            indices.insert_late_bound_region(liberated_region, region_vid.to_region_vid());\n+            indices.insert_late_bound_region(liberated_region, region_vid.as_var());\n             debug!(?liberated_region, ?region_vid);\n             region_vid\n         });\n@@ -829,18 +814,14 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for BorrowckInferCtxt<'cx, 'tcx> {\n             debug!(?r);\n             if !indices.indices.contains_key(&r) {\n                 let region_vid = {\n-                    let name = match r.get_name() {\n-                        Some(name) => name,\n-                        _ => Symbol::intern(\"anon\"),\n-                    };\n-\n+                    let name = r.get_name_or_anon();\n                     self.next_nll_region_var(FR, || {\n                         RegionCtxt::LateBound(BoundRegionInfo::Name(name))\n                     })\n                 };\n \n                 debug!(?region_vid);\n-                indices.insert_late_bound_region(r, region_vid.to_region_vid());\n+                indices.insert_late_bound_region(r, region_vid.as_var());\n             }\n         });\n     }\n@@ -855,17 +836,13 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for BorrowckInferCtxt<'cx, 'tcx> {\n             debug!(?r);\n             if !indices.indices.contains_key(&r) {\n                 let region_vid = {\n-                    let name = match r.get_name() {\n-                        Some(name) => name,\n-                        _ => Symbol::intern(\"anon\"),\n-                    };\n-\n+                    let name = r.get_name_or_anon();\n                     self.next_nll_region_var(FR, || {\n                         RegionCtxt::LateBound(BoundRegionInfo::Name(name))\n                     })\n                 };\n \n-                indices.insert_late_bound_region(r, region_vid.to_region_vid());\n+                indices.insert_late_bound_region(r, region_vid.as_var());\n             }\n         });\n     }\n@@ -883,7 +860,7 @@ impl<'tcx> UniversalRegionIndices<'tcx> {\n     }\n \n     /// Converts `r` into a local inference variable: `r` can either\n-    /// by a `ReVar` (i.e., already a reference to an inference\n+    /// be a `ReVar` (i.e., already a reference to an inference\n     /// variable) or it can be `'static` or some early-bound\n     /// region. This is useful when taking the results from\n     /// type-checking and trait-matching, which may sometimes\n@@ -892,7 +869,7 @@ impl<'tcx> UniversalRegionIndices<'tcx> {\n     /// fully initialized.\n     pub fn to_region_vid(&self, r: ty::Region<'tcx>) -> RegionVid {\n         if let ty::ReVar(..) = *r {\n-            r.to_region_vid()\n+            r.as_var()\n         } else if r.is_error() {\n             // We use the `'static` `RegionVid` because `ReError` doesn't actually exist in the\n             // `UniversalRegionIndices`. This is fine because 1) it is a fallback only used if"}, {"sha": "83dc1ac50e55dff3ee6f9894f5c5ec6548f333ed", "filename": "compiler/rustc_builtin_macros/messages.ftl", "status": "modified", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fmessages.ftl?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -3,3 +3,149 @@ builtin_macros_requires_cfg_pattern =\n     .label = cfg-pattern required\n \n builtin_macros_expected_one_cfg_pattern = expected 1 cfg-pattern\n+\n+builtin_macros_alloc_error_must_be_fn = alloc_error_handler must be a function\n+\n+builtin_macros_assert_requires_boolean = macro requires a boolean expression as an argument\n+    .label = boolean expression required\n+\n+builtin_macros_assert_requires_expression = macro requires an expression as an argument\n+    .suggestion = try removing semicolon\n+\n+builtin_macros_assert_missing_comma = unexpected string literal\n+    .suggestion = try adding a comma\n+\n+builtin_macros_cfg_accessible_unspecified_path = `cfg_accessible` path is not specified\n+builtin_macros_cfg_accessible_multiple_paths = multiple `cfg_accessible` paths are specified\n+builtin_macros_cfg_accessible_literal_path = `cfg_accessible` path cannot be a literal\n+builtin_macros_cfg_accessible_has_args = `cfg_accessible` path cannot accept arguments\n+\n+builtin_macros_cfg_accessible_indeterminate = cannot determine whether the path is accessible or not\n+\n+builtin_macros_concat_bytestr = cannot concatenate a byte string literal\n+\n+builtin_macros_concat_missing_literal = expected a literal\n+    .note = only literals (like `\"foo\"`, `-42` and `3.14`) can be passed to `concat!()`\n+\n+builtin_macros_concat_bytes_missing_literal = expected a byte literal\n+    .note = only byte literals (like `b\"foo\"`, `b's'` and `[3, 4, 5]`) can be passed to `concat_bytes!()`\n+\n+builtin_macros_concat_bytes_invalid = cannot concatenate {$lit_kind} literals\n+    .byte_char = try using a byte character\n+    .byte_str = try using a byte string\n+    .number_array = try wrapping the number in an array\n+\n+builtin_macros_concat_bytes_oob = numeric literal is out of bounds\n+\n+builtin_macros_concat_bytes_non_u8 = numeric literal is not a `u8`\n+\n+builtin_macros_concat_bytes_array = cannot concatenate doubly nested array\n+    .note = byte strings are treated as arrays of bytes\n+    .help = try flattening the array\n+\n+builtin_macros_concat_bytes_bad_repeat = repeat count is not a positive number\n+\n+builtin_macros_concat_idents_missing_args = `concat_idents!()` takes 1 or more arguments\n+builtin_macros_concat_idents_missing_comma = `concat_idents!()` expecting comma\n+builtin_macros_concat_idents_ident_args = `concat_idents!()` requires ident args\n+\n+builtin_macros_bad_derive_target = `derive` may only be applied to `struct`s, `enum`s and `union`s\n+    .label = not applicable here\n+    .label2 = not a `struct`, `enum` or `union`\n+\n+builtin_macros_unexpected_lit = expected path to a trait, found literal\n+    .label = not a trait\n+    .str_lit = try using `#[derive({$sym})]`\n+    .other = for example, write `#[derive(Debug)]` for `Debug`\n+\n+builtin_macros_derive_path_args_list = traits in `#[derive(...)]` don't accept arguments\n+    .suggestion = remove the arguments\n+\n+builtin_macros_derive_path_args_value = traits in `#[derive(...)]` don't accept values\n+    .suggestion = remove the value\n+\n+builtin_macros_derive_macro_call = `derive` cannot be used on items with type macros\n+\n+builtin_macros_cannot_derive_union = this trait cannot be derived for unions\n+\n+builtin_macros_no_default_variant = no default declared\n+    .help = make a unit variant default by placing `#[default]` above it\n+    .suggestion = make `{$ident}` default\n+\n+builtin_macros_multiple_defaults = multiple declared defaults\n+    .label = first default\n+    .additional = additional default\n+    .note = only one variant can be default\n+    .suggestion = make `{$ident}` default\n+\n+builtin_macros_non_unit_default = the `#[default]` attribute may only be used on unit enum variants\n+    .help = consider a manual implementation of `Default`\n+\n+builtin_macros_non_exhaustive_default = default variant must be exhaustive\n+    .label = declared `#[non_exhaustive]` here\n+    .help = consider a manual implementation of `Default`\n+\n+builtin_macros_multiple_default_attrs = multiple `#[default]` attributes\n+    .note = only one `#[default]` attribute is needed\n+    .label = `#[default]` used here\n+    .label_again = `#[default]` used again here\n+    .help = try removing {$only_one ->\n+    [true] this\n+    *[false] these\n+    }\n+\n+builtin_macros_default_arg = `#[default]` attribute does not accept a value\n+    .suggestion = try using `#[default]`\n+\n+builtin_macros_env_takes_args = `env!()` takes 1 or 2 arguments\n+\n+builtin_macros_env_not_defined = environment variable `{$var}` not defined at compile time\n+    .cargo = Cargo sets build script variables at run time. Use `std::env::var(\"{$var}\")` instead\n+    .other = use `std::env::var(\"{$var}\")` to read the variable at run time\n+\n+builtin_macros_format_requires_string = requires at least a format string argument\n+\n+builtin_macros_format_duplicate_arg = duplicate argument named `{$ident}`\n+    .label1 = previously here\n+    .label2 = duplicate argument\n+\n+builtin_macros_format_positional_after_named = positional arguments cannot follow named arguments\n+    .label = positional arguments must be before named arguments\n+    .named_args = named argument\n+\n+builtin_macros_format_string_invalid = invalid format string: {$desc}\n+    .label = {$label1} in format string\n+    .note = {$note}\n+    .second_label = {$label}\n+\n+builtin_macros_sugg = consider using a positional formatting argument instead\n+\n+builtin_macros_format_no_arg_named = there is no argument named `{$name}`\n+    .note = did you intend to capture a variable `{$name}` from the surrounding scope?\n+    .note2 = to avoid ambiguity, `format_args!` cannot capture variables when the format string is expanded from a macro\n+\n+builtin_macros_format_unknown_trait = unknown format trait `{$ty}`\n+    .note = the only appropriate formatting traits are:\n+                                            - ``, which uses the `Display` trait\n+                                            - `?`, which uses the `Debug` trait\n+                                            - `e`, which uses the `LowerExp` trait\n+                                            - `E`, which uses the `UpperExp` trait\n+                                            - `o`, which uses the `Octal` trait\n+                                            - `p`, which uses the `Pointer` trait\n+                                            - `b`, which uses the `Binary` trait\n+                                            - `x`, which uses the `LowerHex` trait\n+                                            - `X`, which uses the `UpperHex` trait\n+    .suggestion = use the `{$trait_name}` trait\n+\n+builtin_macros_format_unused_arg = {$named ->\n+    [true] named argument\n+    *[false] argument\n+    } never used\n+\n+builtin_macros_format_unused_args = multiple unused formatting arguments\n+    .label = multiple missing formatting specifiers\n+\n+builtin_macros_format_pos_mismatch = {$n} positional {$n ->\n+    [one] argument\n+    *[more] arguments\n+    } in format string, but {$desc}"}, {"sha": "82bae9157e79d173e760a685968bafa4fa090a72", "filename": "compiler/rustc_builtin_macros/src/alloc_error_handler.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1,3 +1,4 @@\n+use crate::errors;\n use crate::util::check_builtin_macro_attribute;\n \n use rustc_ast::ptr::P;\n@@ -31,7 +32,7 @@ pub fn expand(\n         {\n             (item, true, ecx.with_def_site_ctxt(fn_kind.sig.span))\n         } else {\n-            ecx.sess.parse_sess.span_diagnostic.span_err(item.span(), \"alloc_error_handler must be a function\");\n+            ecx.sess.parse_sess.span_diagnostic.emit_err(errors::AllocErrorMustBeFn {span: item.span() });\n             return vec![orig_item];\n         };\n "}, {"sha": "0de424be2f161e24aae34d9391ef372feeb02cbb", "filename": "compiler/rustc_builtin_macros/src/assert.rs", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1,12 +1,13 @@\n mod context;\n \n use crate::edition_panic::use_panic_2021;\n+use crate::errors;\n use rustc_ast::ptr::P;\n use rustc_ast::token;\n use rustc_ast::tokenstream::{DelimSpan, TokenStream};\n use rustc_ast::{DelimArgs, Expr, ExprKind, MacCall, MacDelimiter, Path, PathSegment, UnOp};\n use rustc_ast_pretty::pprust;\n-use rustc_errors::{Applicability, PResult};\n+use rustc_errors::PResult;\n use rustc_expand::base::{DummyResult, ExtCtxt, MacEager, MacResult};\n use rustc_parse::parser::Parser;\n use rustc_span::symbol::{sym, Ident, Symbol};\n@@ -114,9 +115,7 @@ fn parse_assert<'a>(cx: &mut ExtCtxt<'a>, sp: Span, stream: TokenStream) -> PRes\n     let mut parser = cx.new_parser_from_tts(stream);\n \n     if parser.token == token::Eof {\n-        let mut err = cx.struct_span_err(sp, \"macro requires a boolean expression as an argument\");\n-        err.span_label(sp, \"boolean expression required\");\n-        return Err(err);\n+        return Err(cx.create_err(errors::AssertRequiresBoolean { span: sp }));\n     }\n \n     let cond_expr = parser.parse_expr()?;\n@@ -129,15 +128,7 @@ fn parse_assert<'a>(cx: &mut ExtCtxt<'a>, sp: Span, stream: TokenStream) -> PRes\n     //\n     // Emit an error about semicolon and suggest removing it.\n     if parser.token == token::Semi {\n-        let mut err = cx.struct_span_err(sp, \"macro requires an expression as an argument\");\n-        err.span_suggestion(\n-            parser.token.span,\n-            \"try removing semicolon\",\n-            \"\",\n-            Applicability::MaybeIncorrect,\n-        );\n-        err.emit();\n-\n+        cx.emit_err(errors::AssertRequiresExpression { span: sp, token: parser.token.span });\n         parser.bump();\n     }\n \n@@ -149,15 +140,8 @@ fn parse_assert<'a>(cx: &mut ExtCtxt<'a>, sp: Span, stream: TokenStream) -> PRes\n     // Emit an error and suggest inserting a comma.\n     let custom_message =\n         if let token::Literal(token::Lit { kind: token::Str, .. }) = parser.token.kind {\n-            let mut err = cx.struct_span_err(parser.token.span, \"unexpected string literal\");\n-            let comma_span = parser.prev_token.span.shrink_to_hi();\n-            err.span_suggestion_short(\n-                comma_span,\n-                \"try adding a comma\",\n-                \", \",\n-                Applicability::MaybeIncorrect,\n-            );\n-            err.emit();\n+            let comma = parser.prev_token.span.shrink_to_hi();\n+            cx.emit_err(errors::AssertMissingComma { span: parser.token.span, comma });\n \n             parse_custom_message(&mut parser)\n         } else if parser.eat(&token::Comma) {"}, {"sha": "1397cee7af83b93b43ca8216010f92a423a05855", "filename": "compiler/rustc_builtin_macros/src/cfg.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -2,13 +2,13 @@\n //! a literal `true` or `false` based on whether the given cfg matches the\n //! current compilation environment.\n \n+use crate::errors;\n use rustc_ast as ast;\n use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_attr as attr;\n use rustc_errors::PResult;\n use rustc_expand::base::{self, *};\n-use rustc_macros::Diagnostic;\n use rustc_span::Span;\n \n pub fn expand_cfg(\n@@ -35,34 +35,19 @@ pub fn expand_cfg(\n     }\n }\n \n-#[derive(Diagnostic)]\n-#[diag(builtin_macros_requires_cfg_pattern)]\n-struct RequiresCfgPattern {\n-    #[primary_span]\n-    #[label]\n-    span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(builtin_macros_expected_one_cfg_pattern)]\n-struct OneCfgPattern {\n-    #[primary_span]\n-    span: Span,\n-}\n-\n fn parse_cfg<'a>(cx: &mut ExtCtxt<'a>, span: Span, tts: TokenStream) -> PResult<'a, ast::MetaItem> {\n     let mut p = cx.new_parser_from_tts(tts);\n \n     if p.token == token::Eof {\n-        return Err(cx.create_err(RequiresCfgPattern { span }));\n+        return Err(cx.create_err(errors::RequiresCfgPattern { span }));\n     }\n \n     let cfg = p.parse_meta_item()?;\n \n     let _ = p.eat(&token::Comma);\n \n     if !p.eat(&token::Eof) {\n-        return Err(cx.create_err(OneCfgPattern { span }));\n+        return Err(cx.create_err(errors::OneCfgPattern { span }));\n     }\n \n     Ok(cfg)"}, {"sha": "37ac09ccdff4d4bf20843245a014562415e61944", "filename": "compiler/rustc_builtin_macros/src/cfg_accessible.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1,5 +1,6 @@\n //! Implementation of the `#[cfg_accessible(path)]` attribute macro.\n \n+use crate::errors;\n use rustc_ast as ast;\n use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, Indeterminate, MultiItemModifier};\n use rustc_feature::AttributeTemplate;\n@@ -10,15 +11,22 @@ use rustc_span::Span;\n pub(crate) struct Expander;\n \n fn validate_input<'a>(ecx: &mut ExtCtxt<'_>, mi: &'a ast::MetaItem) -> Option<&'a ast::Path> {\n+    use errors::CfgAccessibleInvalid::*;\n     match mi.meta_item_list() {\n         None => {}\n-        Some([]) => ecx.span_err(mi.span, \"`cfg_accessible` path is not specified\"),\n-        Some([_, .., l]) => ecx.span_err(l.span(), \"multiple `cfg_accessible` paths are specified\"),\n+        Some([]) => {\n+            ecx.emit_err(UnspecifiedPath(mi.span));\n+        }\n+        Some([_, .., l]) => {\n+            ecx.emit_err(MultiplePaths(l.span()));\n+        }\n         Some([nmi]) => match nmi.meta_item() {\n-            None => ecx.span_err(nmi.span(), \"`cfg_accessible` path cannot be a literal\"),\n+            None => {\n+                ecx.emit_err(LiteralPath(nmi.span()));\n+            }\n             Some(mi) => {\n                 if !mi.is_word() {\n-                    ecx.span_err(mi.span, \"`cfg_accessible` path cannot accept arguments\");\n+                    ecx.emit_err(HasArguments(mi.span));\n                 }\n                 return Some(&mi.path);\n             }\n@@ -53,7 +61,7 @@ impl MultiItemModifier for Expander {\n             Ok(true) => ExpandResult::Ready(vec![item]),\n             Ok(false) => ExpandResult::Ready(Vec::new()),\n             Err(Indeterminate) if ecx.force_mode => {\n-                ecx.span_err(span, \"cannot determine whether the path is accessible or not\");\n+                ecx.emit_err(errors::CfgAccessibleIndeterminate { span });\n                 ExpandResult::Ready(vec![item])\n             }\n             Err(Indeterminate) => ExpandResult::Retry(item),"}, {"sha": "aeb3bb80045bbfcb1d02365391cd694dcc727d98", "filename": "compiler/rustc_builtin_macros/src/compile_error.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fsrc%2Fcompile_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fsrc%2Fcompile_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcompile_error.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -13,6 +13,11 @@ pub fn expand_compile_error<'cx>(\n         return DummyResult::any(sp);\n     };\n \n+    #[expect(\n+        rustc::diagnostic_outside_of_impl,\n+        reason = \"diagnostic message is specified by user\"\n+    )]\n+    #[expect(rustc::untranslatable_diagnostic, reason = \"diagnostic message is specified by user\")]\n     cx.span_err(sp, var.as_str());\n \n     DummyResult::any(sp)"}, {"sha": "b92964d03e9f95c80876039c5107ab9418587313", "filename": "compiler/rustc_builtin_macros/src/concat.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -4,6 +4,8 @@ use rustc_expand::base::{self, DummyResult};\n use rustc_session::errors::report_lit_error;\n use rustc_span::symbol::Symbol;\n \n+use crate::errors;\n+\n pub fn expand_concat(\n     cx: &mut base::ExtCtxt<'_>,\n     sp: rustc_span::Span,\n@@ -31,7 +33,7 @@ pub fn expand_concat(\n                     accumulator.push_str(&b.to_string());\n                 }\n                 Ok(ast::LitKind::Byte(..) | ast::LitKind::ByteStr(..)) => {\n-                    cx.span_err(e.span, \"cannot concatenate a byte string literal\");\n+                    cx.emit_err(errors::ConcatBytestr { span: e.span });\n                     has_errors = true;\n                 }\n                 Ok(ast::LitKind::Err) => {\n@@ -55,7 +57,7 @@ pub fn expand_concat(\n                 }\n             }\n             ast::ExprKind::IncludedBytes(..) => {\n-                cx.span_err(e.span, \"cannot concatenate a byte string literal\")\n+                cx.emit_err(errors::ConcatBytestr { span: e.span });\n             }\n             ast::ExprKind::Err => {\n                 has_errors = true;\n@@ -67,9 +69,7 @@ pub fn expand_concat(\n     }\n \n     if !missing_literal.is_empty() {\n-        let mut err = cx.struct_span_err(missing_literal, \"expected a literal\");\n-        err.note(\"only literals (like `\\\"foo\\\"`, `-42` and `3.14`) can be passed to `concat!()`\");\n-        err.emit();\n+        cx.emit_err(errors::ConcatMissingLiteral { spans: missing_literal });\n         return DummyResult::any(sp);\n     } else if has_errors {\n         return DummyResult::any(sp);"}, {"sha": "ba639c0a9fe3ca117c9ae10dbc0817c3fd6405bb", "filename": "compiler/rustc_builtin_macros/src/concat_bytes.rs", "status": "modified", "additions": 27, "deletions": 50, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1,73 +1,58 @@\n use rustc_ast as ast;\n use rustc_ast::{ptr::P, tokenstream::TokenStream};\n-use rustc_errors::Applicability;\n use rustc_expand::base::{self, DummyResult};\n use rustc_session::errors::report_lit_error;\n use rustc_span::Span;\n \n+use crate::errors;\n+\n /// Emits errors for literal expressions that are invalid inside and outside of an array.\n fn invalid_type_err(\n     cx: &mut base::ExtCtxt<'_>,\n     token_lit: ast::token::Lit,\n     span: Span,\n     is_nested: bool,\n ) {\n+    use errors::{\n+        ConcatBytesInvalid, ConcatBytesInvalidSuggestion, ConcatBytesNonU8, ConcatBytesOob,\n+    };\n+    let snippet = cx.sess.source_map().span_to_snippet(span).ok();\n     match ast::LitKind::from_token_lit(token_lit) {\n         Ok(ast::LitKind::Char(_)) => {\n-            let mut err = cx.struct_span_err(span, \"cannot concatenate character literals\");\n-            if let Ok(snippet) = cx.sess.source_map().span_to_snippet(span) {\n-                err.span_suggestion(\n-                    span,\n-                    \"try using a byte character\",\n-                    format!(\"b{}\", snippet),\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n-            }\n+            let sugg =\n+                snippet.map(|snippet| ConcatBytesInvalidSuggestion::CharLit { span, snippet });\n+            cx.sess.emit_err(ConcatBytesInvalid { span, lit_kind: \"character\", sugg });\n         }\n         Ok(ast::LitKind::Str(_, _)) => {\n-            let mut err = cx.struct_span_err(span, \"cannot concatenate string literals\");\n             // suggestion would be invalid if we are nested\n-            if !is_nested {\n-                if let Ok(snippet) = cx.sess.source_map().span_to_snippet(span) {\n-                    err.span_suggestion(\n-                        span,\n-                        \"try using a byte string\",\n-                        format!(\"b{}\", snippet),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-            err.emit();\n+            let sugg = if !is_nested {\n+                snippet.map(|snippet| ConcatBytesInvalidSuggestion::StrLit { span, snippet })\n+            } else {\n+                None\n+            };\n+            cx.emit_err(ConcatBytesInvalid { span, lit_kind: \"string\", sugg });\n         }\n         Ok(ast::LitKind::Float(_, _)) => {\n-            cx.span_err(span, \"cannot concatenate float literals\");\n+            cx.emit_err(ConcatBytesInvalid { span, lit_kind: \"float\", sugg: None });\n         }\n         Ok(ast::LitKind::Bool(_)) => {\n-            cx.span_err(span, \"cannot concatenate boolean literals\");\n+            cx.emit_err(ConcatBytesInvalid { span, lit_kind: \"boolean\", sugg: None });\n         }\n         Ok(ast::LitKind::Err) => {}\n         Ok(ast::LitKind::Int(_, _)) if !is_nested => {\n-            let mut err = cx.struct_span_err(span, \"cannot concatenate numeric literals\");\n-            if let Ok(snippet) = cx.sess.source_map().span_to_snippet(span) {\n-                err.span_suggestion(\n-                    span,\n-                    \"try wrapping the number in an array\",\n-                    format!(\"[{}]\", snippet),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-            err.emit();\n+            let sugg =\n+                snippet.map(|snippet| ConcatBytesInvalidSuggestion::IntLit { span: span, snippet });\n+            cx.emit_err(ConcatBytesInvalid { span, lit_kind: \"numeric\", sugg });\n         }\n         Ok(ast::LitKind::Int(\n             val,\n             ast::LitIntType::Unsuffixed | ast::LitIntType::Unsigned(ast::UintTy::U8),\n         )) => {\n             assert!(val > u8::MAX.into()); // must be an error\n-            cx.span_err(span, \"numeric literal is out of bounds\");\n+            cx.emit_err(ConcatBytesOob { span });\n         }\n         Ok(ast::LitKind::Int(_, _)) => {\n-            cx.span_err(span, \"numeric literal is not a `u8`\");\n+            cx.emit_err(ConcatBytesNonU8 { span });\n         }\n         Ok(ast::LitKind::ByteStr(..) | ast::LitKind::Byte(_)) => unreachable!(),\n         Err(err) => {\n@@ -85,7 +70,7 @@ fn handle_array_element(\n     match expr.kind {\n         ast::ExprKind::Array(_) | ast::ExprKind::Repeat(_, _) => {\n             if !*has_errors {\n-                cx.span_err(expr.span, \"cannot concatenate doubly nested array\");\n+                cx.emit_err(errors::ConcatBytesArray { span: expr.span, bytestr: false });\n             }\n             *has_errors = true;\n             None\n@@ -99,10 +84,7 @@ fn handle_array_element(\n             Ok(ast::LitKind::Byte(val)) => Some(val),\n             Ok(ast::LitKind::ByteStr(..)) => {\n                 if !*has_errors {\n-                    cx.struct_span_err(expr.span, \"cannot concatenate doubly nested array\")\n-                        .note(\"byte strings are treated as arrays of bytes\")\n-                        .help(\"try flattening the array\")\n-                        .emit();\n+                    cx.emit_err(errors::ConcatBytesArray { span: expr.span, bytestr: true });\n                 }\n                 *has_errors = true;\n                 None\n@@ -117,10 +99,7 @@ fn handle_array_element(\n         },\n         ast::ExprKind::IncludedBytes(..) => {\n             if !*has_errors {\n-                cx.struct_span_err(expr.span, \"cannot concatenate doubly nested array\")\n-                    .note(\"byte strings are treated as arrays of bytes\")\n-                    .help(\"try flattening the array\")\n-                    .emit();\n+                cx.emit_err(errors::ConcatBytesArray { span: expr.span, bytestr: false });\n             }\n             *has_errors = true;\n             None\n@@ -167,7 +146,7 @@ pub fn expand_concat_bytes(\n                         }\n                     }\n                 } else {\n-                    cx.span_err(count.value.span, \"repeat count is not a positive number\");\n+                    cx.emit_err(errors::ConcatBytesBadRepeat {span: count.value.span });\n                 }\n             }\n             &ast::ExprKind::Lit(token_lit) => match ast::LitKind::from_token_lit(token_lit) {\n@@ -196,9 +175,7 @@ pub fn expand_concat_bytes(\n         }\n     }\n     if !missing_literals.is_empty() {\n-        let mut err = cx.struct_span_err(missing_literals, \"expected a byte literal\");\n-        err.note(\"only byte literals (like `b\\\"foo\\\"`, `b's'`, and `[3, 4, 5]`) can be passed to `concat_bytes!()`\");\n-        err.emit();\n+        cx.emit_err(errors::ConcatBytesMissingLiteral { spans: missing_literals });\n         return base::MacEager::expr(DummyResult::raw_expr(sp, true));\n     } else if has_errors {\n         return base::MacEager::expr(DummyResult::raw_expr(sp, true));"}, {"sha": "8c737f043237e4516e1607daee62f616ab07fbc0", "filename": "compiler/rustc_builtin_macros/src/concat_idents.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_idents.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -6,13 +6,15 @@ use rustc_expand::base::{self, *};\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::Span;\n \n+use crate::errors;\n+\n pub fn expand_concat_idents<'cx>(\n     cx: &'cx mut ExtCtxt<'_>,\n     sp: Span,\n     tts: TokenStream,\n ) -> Box<dyn base::MacResult + 'cx> {\n     if tts.is_empty() {\n-        cx.span_err(sp, \"concat_idents! takes 1 or more arguments\");\n+        cx.emit_err(errors::ConcatIdentsMissingArgs { span: sp });\n         return DummyResult::any(sp);\n     }\n \n@@ -22,7 +24,7 @@ pub fn expand_concat_idents<'cx>(\n             match e {\n                 TokenTree::Token(Token { kind: token::Comma, .. }, _) => {}\n                 _ => {\n-                    cx.span_err(sp, \"concat_idents! expecting comma\");\n+                    cx.emit_err(errors::ConcatIdentsMissingComma { span: sp });\n                     return DummyResult::any(sp);\n                 }\n             }\n@@ -34,7 +36,7 @@ pub fn expand_concat_idents<'cx>(\n                 }\n             }\n \n-            cx.span_err(sp, \"concat_idents! requires ident args\");\n+            cx.emit_err(errors::ConcatIdentsIdentArgs { span: sp });\n             return DummyResult::any(sp);\n         }\n     }"}, {"sha": "fe4483104eeb3d09dd0185c4f2be73b3ac879cec", "filename": "compiler/rustc_builtin_macros/src/derive.rs", "status": "modified", "additions": 12, "deletions": 28, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1,8 +1,8 @@\n use crate::cfg_eval::cfg_eval;\n+use crate::errors;\n \n use rustc_ast as ast;\n use rustc_ast::{GenericParamKind, ItemKind, MetaItemKind, NestedMetaItem, StmtKind};\n-use rustc_errors::{struct_span_err, Applicability};\n use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, Indeterminate, MultiItemModifier};\n use rustc_feature::AttributeTemplate;\n use rustc_parse::validate_attr;\n@@ -116,49 +116,33 @@ fn report_bad_target(sess: &Session, item: &Annotatable, span: Span) -> bool {\n     let bad_target =\n         !matches!(item_kind, Some(ItemKind::Struct(..) | ItemKind::Enum(..) | ItemKind::Union(..)));\n     if bad_target {\n-        struct_span_err!(\n-            sess,\n-            span,\n-            E0774,\n-            \"`derive` may only be applied to `struct`s, `enum`s and `union`s\",\n-        )\n-        .span_label(span, \"not applicable here\")\n-        .span_label(item.span(), \"not a `struct`, `enum` or `union`\")\n-        .emit();\n+        sess.emit_err(errors::BadDeriveTarget { span, item: item.span() });\n     }\n     bad_target\n }\n \n fn report_unexpected_meta_item_lit(sess: &Session, lit: &ast::MetaItemLit) {\n-    let help_msg = match lit.kind {\n+    let help = match lit.kind {\n         ast::LitKind::Str(_, ast::StrStyle::Cooked)\n             if rustc_lexer::is_ident(lit.symbol.as_str()) =>\n         {\n-            format!(\"try using `#[derive({})]`\", lit.symbol)\n+            errors::BadDeriveLitHelp::StrLit { sym: lit.symbol }\n         }\n-        _ => \"for example, write `#[derive(Debug)]` for `Debug`\".to_string(),\n+        _ => errors::BadDeriveLitHelp::Other,\n     };\n-    struct_span_err!(sess, lit.span, E0777, \"expected path to a trait, found literal\",)\n-        .span_label(lit.span, \"not a trait\")\n-        .help(&help_msg)\n-        .emit();\n+    sess.emit_err(errors::BadDeriveLit { span: lit.span, help });\n }\n \n fn report_path_args(sess: &Session, meta: &ast::MetaItem) {\n-    let report_error = |title, action| {\n-        let span = meta.span.with_lo(meta.path.span.hi());\n-        sess.struct_span_err(span, title)\n-            .span_suggestion(span, action, \"\", Applicability::MachineApplicable)\n-            .emit();\n-    };\n+    let span = meta.span.with_lo(meta.path.span.hi());\n+\n     match meta.kind {\n         MetaItemKind::Word => {}\n-        MetaItemKind::List(..) => report_error(\n-            \"traits in `#[derive(...)]` don't accept arguments\",\n-            \"remove the arguments\",\n-        ),\n+        MetaItemKind::List(..) => {\n+            sess.emit_err(errors::DerivePathArgsList { span });\n+        }\n         MetaItemKind::NameValue(..) => {\n-            report_error(\"traits in `#[derive(...)]` don't accept values\", \"remove the value\")\n+            sess.emit_err(errors::DerivePathArgsValue { span });\n         }\n     }\n }"}, {"sha": "33fe98b40e158f0e9a4f8ab6d601a727c7b7dfac", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 45, "deletions": 79, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1,8 +1,8 @@\n use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n+use crate::errors;\n use rustc_ast as ast;\n use rustc_ast::{attr, walk_list, EnumDef, VariantData};\n-use rustc_errors::Applicability;\n use rustc_expand::base::{Annotatable, DummyResult, ExtCtxt};\n use rustc_span::symbol::Ident;\n use rustc_span::symbol::{kw, sym};\n@@ -118,67 +118,50 @@ fn extract_default_variant<'a>(\n                 .filter(|variant| matches!(variant.data, VariantData::Unit(..)))\n                 .filter(|variant| !attr::contains_name(&variant.attrs, sym::non_exhaustive));\n \n-            let mut diag = cx.struct_span_err(trait_span, \"no default declared\");\n-            diag.help(\"make a unit variant default by placing `#[default]` above it\");\n-            for variant in possible_defaults {\n-                // Suggest making each unit variant default.\n-                diag.tool_only_span_suggestion(\n-                    variant.span,\n-                    &format!(\"make `{}` default\", variant.ident),\n-                    format!(\"#[default] {}\", variant.ident),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-            diag.emit();\n+            let suggs = possible_defaults\n+                .map(|v| errors::NoDefaultVariantSugg { span: v.span, ident: v.ident })\n+                .collect();\n+            cx.emit_err(errors::NoDefaultVariant { span: trait_span, suggs });\n \n             return Err(());\n         }\n         [first, rest @ ..] => {\n-            let mut diag = cx.struct_span_err(trait_span, \"multiple declared defaults\");\n-            diag.span_label(first.span, \"first default\");\n-            diag.span_labels(rest.iter().map(|variant| variant.span), \"additional default\");\n-            diag.note(\"only one variant can be default\");\n-            for variant in &default_variants {\n-                // Suggest making each variant already tagged default.\n-                let suggestion = default_variants\n-                    .iter()\n-                    .filter_map(|v| {\n-                        if v.span == variant.span {\n-                            None\n-                        } else {\n-                            Some((attr::find_by_name(&v.attrs, kw::Default)?.span, String::new()))\n-                        }\n-                    })\n-                    .collect();\n-\n-                diag.tool_only_multipart_suggestion(\n-                    &format!(\"make `{}` default\", variant.ident),\n-                    suggestion,\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-            diag.emit();\n-\n+            let suggs = default_variants\n+                .iter()\n+                .map(|variant| {\n+                    let spans = default_variants\n+                        .iter()\n+                        .filter_map(|v| {\n+                            if v.span == variant.span {\n+                                None\n+                            } else {\n+                                Some(attr::find_by_name(&v.attrs, kw::Default)?.span)\n+                            }\n+                        })\n+                        .collect();\n+                    errors::MultipleDefaultsSugg { spans, ident: variant.ident }\n+                })\n+                .collect();\n+            cx.emit_err(errors::MultipleDefaults {\n+                span: trait_span,\n+                first: first.span,\n+                additional: rest.iter().map(|v| v.span).collect(),\n+                suggs,\n+            });\n             return Err(());\n         }\n     };\n \n     if !matches!(variant.data, VariantData::Unit(..)) {\n-        cx.struct_span_err(\n-            variant.ident.span,\n-            \"the `#[default]` attribute may only be used on unit enum variants\",\n-        )\n-        .help(\"consider a manual implementation of `Default`\")\n-        .emit();\n-\n+        cx.emit_err(errors::NonUnitDefault { span: variant.ident.span });\n         return Err(());\n     }\n \n     if let Some(non_exhaustive_attr) = attr::find_by_name(&variant.attrs, sym::non_exhaustive) {\n-        cx.struct_span_err(variant.ident.span, \"default variant must be exhaustive\")\n-            .span_label(non_exhaustive_attr.span, \"declared `#[non_exhaustive]` here\")\n-            .help(\"consider a manual implementation of `Default`\")\n-            .emit();\n+        cx.emit_err(errors::NonExhaustiveDefault {\n+            span: variant.ident.span,\n+            non_exhaustive: non_exhaustive_attr.span,\n+        });\n \n         return Err(());\n     }\n@@ -199,35 +182,23 @@ fn validate_default_attribute(\n             \"this method must only be called with a variant that has a `#[default]` attribute\",\n         ),\n         [first, rest @ ..] => {\n-            let suggestion_text =\n-                if rest.len() == 1 { \"try removing this\" } else { \"try removing these\" };\n-\n-            cx.struct_span_err(default_variant.ident.span, \"multiple `#[default]` attributes\")\n-                .note(\"only one `#[default]` attribute is needed\")\n-                .span_label(first.span, \"`#[default]` used here\")\n-                .span_label(rest[0].span, \"`#[default]` used again here\")\n-                .span_help(rest.iter().map(|attr| attr.span).collect::<Vec<_>>(), suggestion_text)\n-                // This would otherwise display the empty replacement, hence the otherwise\n-                // repetitive `.span_help` call above.\n-                .tool_only_multipart_suggestion(\n-                    suggestion_text,\n-                    rest.iter().map(|attr| (attr.span, String::new())).collect(),\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n+            let sugg = errors::MultipleDefaultAttrsSugg {\n+                spans: rest.iter().map(|attr| attr.span).collect(),\n+            };\n+            cx.emit_err(errors::MultipleDefaultAttrs {\n+                span: default_variant.ident.span,\n+                first: first.span,\n+                first_rest: rest[0].span,\n+                rest: rest.iter().map(|attr| attr.span).collect::<Vec<_>>().into(),\n+                only_one: rest.len() == 1,\n+                sugg,\n+            });\n \n             return Err(());\n         }\n     };\n     if !attr.is_word() {\n-        cx.struct_span_err(attr.span, \"`#[default]` attribute does not accept a value\")\n-            .span_suggestion_hidden(\n-                attr.span,\n-                \"try using `#[default]`\",\n-                \"#[default]\",\n-                Applicability::MaybeIncorrect,\n-            )\n-            .emit();\n+        cx.emit_err(errors::DefaultHasArg { span: attr.span });\n \n         return Err(());\n     }\n@@ -241,12 +212,7 @@ struct DetectNonVariantDefaultAttr<'a, 'b> {\n impl<'a, 'b> rustc_ast::visit::Visitor<'a> for DetectNonVariantDefaultAttr<'a, 'b> {\n     fn visit_attribute(&mut self, attr: &'a rustc_ast::Attribute) {\n         if attr.has_name(kw::Default) {\n-            self.cx\n-                .struct_span_err(\n-                    attr.span,\n-                    \"the `#[default]` attribute may only be used on unit enum variants\",\n-                )\n-                .emit();\n+            self.cx.emit_err(errors::NonUnitDefault { span: attr.span });\n         }\n \n         rustc_ast::visit::walk_attribute(self, attr);"}, {"sha": "e5a0033158840d4a757fc9f93fdfe29edf3c7bb2", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -162,7 +162,7 @@\n pub use StaticFields::*;\n pub use SubstructureFields::*;\n \n-use crate::deriving;\n+use crate::{deriving, errors};\n use rustc_ast::ptr::P;\n use rustc_ast::{\n     self as ast, BindingAnnotation, ByRef, EnumDef, Expr, GenericArg, GenericParamKind, Generics,\n@@ -415,7 +415,7 @@ fn find_type_parameters(\n         }\n \n         fn visit_mac_call(&mut self, mac: &ast::MacCall) {\n-            self.cx.span_err(mac.span(), \"`derive` cannot be used on items with type macros\");\n+            self.cx.emit_err(errors::DeriveMacroCall { span: mac.span() });\n         }\n     }\n \n@@ -488,7 +488,7 @@ impl<'a> TraitDef<'a> {\n                                 is_packed,\n                             )\n                         } else {\n-                            cx.span_err(mitem.span, \"this trait cannot be derived for unions\");\n+                            cx.emit_err(errors::DeriveUnion { span: mitem.span });\n                             return;\n                         }\n                     }"}, {"sha": "58c972738c499fdcaf939584016ba2fde734506c", "filename": "compiler/rustc_builtin_macros/src/env.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -11,6 +11,8 @@ use rustc_span::Span;\n use std::env;\n use thin_vec::thin_vec;\n \n+use crate::errors;\n+\n pub fn expand_option_env<'cx>(\n     cx: &'cx mut ExtCtxt<'_>,\n     sp: Span,\n@@ -54,7 +56,7 @@ pub fn expand_env<'cx>(\n ) -> Box<dyn base::MacResult + 'cx> {\n     let mut exprs = match get_exprs_from_tts(cx, tts) {\n         Some(exprs) if exprs.is_empty() || exprs.len() > 2 => {\n-            cx.span_err(sp, \"env! takes 1 or 2 arguments\");\n+            cx.emit_err(errors::EnvTakesArgs { span: sp });\n             return DummyResult::any(sp);\n         }\n         None => return DummyResult::any(sp),\n@@ -78,34 +80,26 @@ pub fn expand_env<'cx>(\n     cx.sess.parse_sess.env_depinfo.borrow_mut().insert((var, value));\n     let e = match value {\n         None => {\n-            let (msg, help) = match custom_msg {\n-                None => (\n-                    format!(\"environment variable `{var}` not defined at compile time\"),\n-                    Some(help_for_missing_env_var(var.as_str())),\n-                ),\n-                Some(s) => (s.to_string(), None),\n-            };\n-            let mut diag = cx.struct_span_err(sp, &msg);\n-            if let Some(help) = help {\n-                diag.help(help);\n-            }\n-            diag.emit();\n+            cx.emit_err(errors::EnvNotDefined {\n+                span: sp,\n+                msg: custom_msg,\n+                var,\n+                help: custom_msg.is_none().then(|| help_for_missing_env_var(var.as_str())),\n+            });\n             return DummyResult::any(sp);\n         }\n         Some(value) => cx.expr_str(sp, value),\n     };\n     MacEager::expr(e)\n }\n \n-fn help_for_missing_env_var(var: &str) -> String {\n+fn help_for_missing_env_var(var: &str) -> errors::EnvNotDefinedHelp {\n     if var.starts_with(\"CARGO_\")\n         || var.starts_with(\"DEP_\")\n         || matches!(var, \"OUT_DIR\" | \"OPT_LEVEL\" | \"PROFILE\" | \"HOST\" | \"TARGET\")\n     {\n-        format!(\n-            \"Cargo sets build script variables at run time. Use `std::env::var(\\\"{var}\\\")` instead\"\n-        )\n+        errors::EnvNotDefinedHelp::CargoVar\n     } else {\n-        format!(\"Use `std::env::var(\\\"{var}\\\")` to read the variable at run time\")\n+        errors::EnvNotDefinedHelp::Other\n     }\n }"}, {"sha": "630f9b87bc3ea0bc37f79a488a2854e148619121", "filename": "compiler/rustc_builtin_macros/src/errors.rs", "status": "added", "additions": 553, "deletions": 0, "changes": 553, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ferrors.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -0,0 +1,553 @@\n+use rustc_errors::{\n+    AddToDiagnostic, EmissionGuarantee, IntoDiagnostic, MultiSpan, SingleLabelManySpans,\n+};\n+use rustc_macros::{Diagnostic, Subdiagnostic};\n+use rustc_span::{symbol::Ident, Span, Symbol};\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_requires_cfg_pattern)]\n+pub(crate) struct RequiresCfgPattern {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_expected_one_cfg_pattern)]\n+pub(crate) struct OneCfgPattern {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_alloc_error_must_be_fn)]\n+pub(crate) struct AllocErrorMustBeFn {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_assert_requires_boolean)]\n+pub(crate) struct AssertRequiresBoolean {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_assert_requires_expression)]\n+pub(crate) struct AssertRequiresExpression {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    #[suggestion(code = \"\", applicability = \"maybe-incorrect\")]\n+    pub(crate) token: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_assert_missing_comma)]\n+pub(crate) struct AssertMissingComma {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    #[suggestion(code = \", \", applicability = \"maybe-incorrect\", style = \"short\")]\n+    pub(crate) comma: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+pub(crate) enum CfgAccessibleInvalid {\n+    #[diag(builtin_macros_cfg_accessible_unspecified_path)]\n+    UnspecifiedPath(#[primary_span] Span),\n+    #[diag(builtin_macros_cfg_accessible_multiple_paths)]\n+    MultiplePaths(#[primary_span] Span),\n+    #[diag(builtin_macros_cfg_accessible_literal_path)]\n+    LiteralPath(#[primary_span] Span),\n+    #[diag(builtin_macros_cfg_accessible_has_args)]\n+    HasArguments(#[primary_span] Span),\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_cfg_accessible_indeterminate)]\n+pub(crate) struct CfgAccessibleIndeterminate {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_concat_missing_literal)]\n+#[note]\n+pub(crate) struct ConcatMissingLiteral {\n+    #[primary_span]\n+    pub(crate) spans: Vec<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_concat_bytestr)]\n+pub(crate) struct ConcatBytestr {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_concat_bytes_invalid)]\n+pub(crate) struct ConcatBytesInvalid {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    pub(crate) lit_kind: &'static str,\n+    #[subdiagnostic]\n+    pub(crate) sugg: Option<ConcatBytesInvalidSuggestion>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum ConcatBytesInvalidSuggestion {\n+    #[suggestion(\n+        builtin_macros_byte_char,\n+        code = \"b{snippet}\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    CharLit {\n+        #[primary_span]\n+        span: Span,\n+        snippet: String,\n+    },\n+    #[suggestion(\n+        builtin_macros_byte_str,\n+        code = \"b{snippet}\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    StrLit {\n+        #[primary_span]\n+        span: Span,\n+        snippet: String,\n+    },\n+    #[suggestion(\n+        builtin_macros_number_array,\n+        code = \"[{snippet}]\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    IntLit {\n+        #[primary_span]\n+        span: Span,\n+        snippet: String,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_concat_bytes_oob)]\n+pub(crate) struct ConcatBytesOob {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_concat_bytes_non_u8)]\n+pub(crate) struct ConcatBytesNonU8 {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_concat_bytes_missing_literal)]\n+#[note]\n+pub(crate) struct ConcatBytesMissingLiteral {\n+    #[primary_span]\n+    pub(crate) spans: Vec<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_concat_bytes_array)]\n+pub(crate) struct ConcatBytesArray {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    #[note]\n+    #[help]\n+    pub(crate) bytestr: bool,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_concat_bytes_bad_repeat)]\n+pub(crate) struct ConcatBytesBadRepeat {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_concat_idents_missing_args)]\n+pub(crate) struct ConcatIdentsMissingArgs {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_concat_idents_missing_comma)]\n+pub(crate) struct ConcatIdentsMissingComma {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_concat_idents_ident_args)]\n+pub(crate) struct ConcatIdentsIdentArgs {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_bad_derive_target, code = \"E0774\")]\n+pub(crate) struct BadDeriveTarget {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    #[label(builtin_macros_label2)]\n+    pub(crate) item: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_unexpected_lit, code = \"E0777\")]\n+pub(crate) struct BadDeriveLit {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    #[subdiagnostic]\n+    pub help: BadDeriveLitHelp,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum BadDeriveLitHelp {\n+    #[help(builtin_macros_str_lit)]\n+    StrLit { sym: Symbol },\n+    #[help(builtin_macros_other)]\n+    Other,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_derive_path_args_list)]\n+pub(crate) struct DerivePathArgsList {\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_derive_path_args_value)]\n+pub(crate) struct DerivePathArgsValue {\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_no_default_variant)]\n+#[help]\n+pub(crate) struct NoDefaultVariant {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    #[subdiagnostic]\n+    pub(crate) suggs: Vec<NoDefaultVariantSugg>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    builtin_macros_suggestion,\n+    code = \"#[default] {ident}\",\n+    applicability = \"maybe-incorrect\",\n+    style = \"tool-only\"\n+)]\n+pub(crate) struct NoDefaultVariantSugg {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    pub(crate) ident: Ident,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_multiple_defaults)]\n+#[note]\n+pub(crate) struct MultipleDefaults {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    #[label]\n+    pub(crate) first: Span,\n+    #[label(builtin_macros_additional)]\n+    pub additional: Vec<Span>,\n+    #[subdiagnostic]\n+    pub suggs: Vec<MultipleDefaultsSugg>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(\n+    builtin_macros_suggestion,\n+    applicability = \"maybe-incorrect\",\n+    style = \"tool-only\"\n+)]\n+pub(crate) struct MultipleDefaultsSugg {\n+    #[suggestion_part(code = \"\")]\n+    pub(crate) spans: Vec<Span>,\n+    pub(crate) ident: Ident,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_non_unit_default)]\n+#[help]\n+pub(crate) struct NonUnitDefault {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_non_exhaustive_default)]\n+#[help]\n+pub(crate) struct NonExhaustiveDefault {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    #[label]\n+    pub(crate) non_exhaustive: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_multiple_default_attrs)]\n+#[note]\n+pub(crate) struct MultipleDefaultAttrs {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    #[label]\n+    pub(crate) first: Span,\n+    #[label(builtin_macros_label_again)]\n+    pub(crate) first_rest: Span,\n+    #[help]\n+    pub(crate) rest: MultiSpan,\n+    pub(crate) only_one: bool,\n+    #[subdiagnostic]\n+    pub(crate) sugg: MultipleDefaultAttrsSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(\n+    builtin_macros_help,\n+    applicability = \"machine-applicable\",\n+    style = \"tool-only\"\n+)]\n+pub(crate) struct MultipleDefaultAttrsSugg {\n+    #[suggestion_part(code = \"\")]\n+    pub(crate) spans: Vec<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_default_arg)]\n+pub(crate) struct DefaultHasArg {\n+    #[primary_span]\n+    #[suggestion(code = \"#[default]\", style = \"hidden\", applicability = \"maybe-incorrect\")]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_derive_macro_call)]\n+pub(crate) struct DeriveMacroCall {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_cannot_derive_union)]\n+pub(crate) struct DeriveUnion {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_env_takes_args)]\n+pub(crate) struct EnvTakesArgs {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+//#[derive(Diagnostic)]\n+//#[diag(builtin_macros_env_not_defined)]\n+pub(crate) struct EnvNotDefined {\n+    pub(crate) span: Span,\n+    pub(crate) msg: Option<Symbol>,\n+    pub(crate) var: Symbol,\n+    pub(crate) help: Option<EnvNotDefinedHelp>,\n+}\n+\n+// Hand-written implementation to support custom user messages\n+impl<'a, G: EmissionGuarantee> IntoDiagnostic<'a, G> for EnvNotDefined {\n+    #[track_caller]\n+    fn into_diagnostic(\n+        self,\n+        handler: &'a rustc_errors::Handler,\n+    ) -> rustc_errors::DiagnosticBuilder<'a, G> {\n+        let mut diag = if let Some(msg) = self.msg {\n+            handler.struct_diagnostic(msg.as_str())\n+        } else {\n+            handler.struct_diagnostic(crate::fluent_generated::builtin_macros_env_not_defined)\n+        };\n+        diag.set_arg(\"var\", self.var);\n+        diag.set_span(self.span);\n+        if let Some(help) = self.help {\n+            diag.subdiagnostic(help);\n+        }\n+        diag\n+    }\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum EnvNotDefinedHelp {\n+    #[help(builtin_macros_cargo)]\n+    CargoVar,\n+    #[help(builtin_macros_other)]\n+    Other,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_format_requires_string)]\n+pub(crate) struct FormatRequiresString {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_format_duplicate_arg)]\n+pub(crate) struct FormatDuplicateArg {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    #[label(builtin_macros_label1)]\n+    pub(crate) prev: Span,\n+    #[label(builtin_macros_label2)]\n+    pub(crate) duplicate: Span,\n+    pub(crate) ident: Ident,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_format_positional_after_named)]\n+pub(crate) struct PositionalAfterNamed {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    #[label(builtin_macros_named_args)]\n+    pub(crate) args: Vec<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_format_string_invalid)]\n+pub(crate) struct InvalidFormatString {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    pub(crate) desc: String,\n+    pub(crate) label1: String,\n+    #[subdiagnostic]\n+    pub(crate) note_: Option<InvalidFormatStringNote>,\n+    #[subdiagnostic]\n+    pub(crate) label_: Option<InvalidFormatStringLabel>,\n+    #[subdiagnostic]\n+    pub(crate) sugg_: Option<InvalidFormatStringSuggestion>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[note(builtin_macros_note)]\n+pub(crate) struct InvalidFormatStringNote {\n+    pub(crate) note: String,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[label(builtin_macros_second_label)]\n+pub(crate) struct InvalidFormatStringLabel {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    pub(crate) label: String,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(\n+    builtin_macros_sugg,\n+    style = \"verbose\",\n+    applicability = \"machine-applicable\"\n+)]\n+pub(crate) struct InvalidFormatStringSuggestion {\n+    #[suggestion_part(code = \"{len}\")]\n+    pub(crate) captured: Span,\n+    pub(crate) len: String,\n+    #[suggestion_part(code = \", {arg}\")]\n+    pub(crate) span: Span,\n+    pub(crate) arg: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_format_no_arg_named)]\n+#[note]\n+#[note(builtin_macros_note2)]\n+pub(crate) struct FormatNoArgNamed {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    pub(crate) name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_format_unknown_trait)]\n+#[note]\n+pub(crate) struct FormatUnknownTrait<'a> {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    pub(crate) ty: &'a str,\n+    #[subdiagnostic]\n+    pub(crate) suggs: Vec<FormatUnknownTraitSugg>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    builtin_macros_suggestion,\n+    code = \"{fmt}\",\n+    style = \"tool-only\",\n+    applicability = \"maybe-incorrect\"\n+)]\n+pub struct FormatUnknownTraitSugg {\n+    #[primary_span]\n+    pub span: Span,\n+    pub fmt: &'static str,\n+    pub trait_name: &'static str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_format_unused_arg)]\n+pub(crate) struct FormatUnusedArg {\n+    #[primary_span]\n+    #[label(builtin_macros_format_unused_arg)]\n+    pub(crate) span: Span,\n+    pub(crate) named: bool,\n+}\n+\n+// Allow the singular form to be a subdiagnostic of the multiple-unused\n+// form of diagnostic.\n+impl AddToDiagnostic for FormatUnusedArg {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, f: F)\n+    where\n+        F: Fn(\n+            &mut rustc_errors::Diagnostic,\n+            rustc_errors::SubdiagnosticMessage,\n+        ) -> rustc_errors::SubdiagnosticMessage,\n+    {\n+        diag.set_arg(\"named\", self.named);\n+        let msg = f(diag, crate::fluent_generated::builtin_macros_format_unused_arg.into());\n+        diag.span_label(self.span, msg);\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_format_unused_args)]\n+pub(crate) struct FormatUnusedArgs {\n+    #[primary_span]\n+    pub(crate) unused: Vec<Span>,\n+    #[label]\n+    pub(crate) fmt: Span,\n+    #[subdiagnostic]\n+    pub(crate) unused_labels: Vec<FormatUnusedArg>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_format_pos_mismatch)]\n+pub(crate) struct FormatPositionalMismatch {\n+    #[primary_span]\n+    pub(crate) span: MultiSpan,\n+    pub(crate) n: usize,\n+    pub(crate) desc: String,\n+    #[subdiagnostic]\n+    pub(crate) highlight: SingleLabelManySpans,\n+}"}, {"sha": "f0fc61d7c4f21fd2d0f07c06ae5525c23fd4608b", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 79, "deletions": 98, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -7,7 +7,7 @@ use rustc_ast::{\n     FormatDebugHex, FormatOptions, FormatPlaceholder, FormatSign, FormatTrait,\n };\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{pluralize, Applicability, MultiSpan, PResult};\n+use rustc_errors::{Applicability, MultiSpan, PResult, SingleLabelManySpans};\n use rustc_expand::base::{self, *};\n use rustc_parse_format as parse;\n use rustc_span::symbol::{Ident, Symbol};\n@@ -36,11 +36,13 @@ enum PositionUsedAs {\n }\n use PositionUsedAs::*;\n \n+use crate::errors;\n+\n struct MacroInput {\n     fmtstr: P<Expr>,\n     args: FormatArguments,\n     /// Whether the first argument was a string literal or a result from eager macro expansion.\n-    /// If it's not a string literal, we disallow implicit arugment capturing.\n+    /// If it's not a string literal, we disallow implicit argument capturing.\n     ///\n     /// This does not correspond to whether we can treat spans to the literal normally, as the whole\n     /// invocation might be the result of another macro expansion, in which case this flag may still be true.\n@@ -66,7 +68,7 @@ fn parse_args<'a>(ecx: &mut ExtCtxt<'a>, sp: Span, tts: TokenStream) -> PResult<\n     let mut p = ecx.new_parser_from_tts(tts);\n \n     if p.token == token::Eof {\n-        return Err(ecx.struct_span_err(sp, \"requires at least a format string argument\"));\n+        return Err(ecx.create_err(errors::FormatRequiresString { span: sp }));\n     }\n \n     let first_token = &p.token;\n@@ -121,34 +123,34 @@ fn parse_args<'a>(ecx: &mut ExtCtxt<'a>, sp: Span, tts: TokenStream) -> PResult<\n                 p.expect(&token::Eq)?;\n                 let expr = p.parse_expr()?;\n                 if let Some((_, prev)) = args.by_name(ident.name) {\n-                    ecx.struct_span_err(\n-                        ident.span,\n-                        &format!(\"duplicate argument named `{}`\", ident),\n-                    )\n-                    .span_label(prev.kind.ident().unwrap().span, \"previously here\")\n-                    .span_label(ident.span, \"duplicate argument\")\n-                    .emit();\n+                    ecx.emit_err(errors::FormatDuplicateArg {\n+                        span: ident.span,\n+                        prev: prev.kind.ident().unwrap().span,\n+                        duplicate: ident.span,\n+                        ident,\n+                    });\n                     continue;\n                 }\n                 args.add(FormatArgument { kind: FormatArgumentKind::Named(ident), expr });\n             }\n             _ => {\n                 let expr = p.parse_expr()?;\n                 if !args.named_args().is_empty() {\n-                    let mut err = ecx.struct_span_err(\n-                        expr.span,\n-                        \"positional arguments cannot follow named arguments\",\n-                    );\n-                    err.span_label(\n-                        expr.span,\n-                        \"positional arguments must be before named arguments\",\n-                    );\n-                    for arg in args.named_args() {\n-                        if let Some(name) = arg.kind.ident() {\n-                            err.span_label(name.span.to(arg.expr.span), \"named argument\");\n-                        }\n-                    }\n-                    err.emit();\n+                    ecx.emit_err(errors::PositionalAfterNamed {\n+                        span: expr.span,\n+                        args: args\n+                            .named_args()\n+                            .iter()\n+                            .filter_map(|a| {\n+                                if let Some(ident) = a.kind.ident() {\n+                                    Some((a, ident))\n+                                } else {\n+                                    None\n+                                }\n+                            })\n+                            .map(|(arg, n)| n.span.to(arg.expr.span))\n+                            .collect(),\n+                    });\n                 }\n                 args.add(FormatArgument { kind: FormatArgumentKind::Normal, expr });\n             }\n@@ -234,13 +236,19 @@ fn make_format_args(\n             // argument span here.\n             fmt_span\n         };\n-        let mut e = ecx.struct_span_err(sp, &format!(\"invalid format string: {}\", err.description));\n-        e.span_label(sp, err.label + \" in format string\");\n+        let mut e = errors::InvalidFormatString {\n+            span: sp,\n+            note_: None,\n+            label_: None,\n+            sugg_: None,\n+            desc: err.description,\n+            label1: err.label,\n+        };\n         if let Some(note) = err.note {\n-            e.note(&note);\n+            e.note_ = Some(errors::InvalidFormatStringNote { note });\n         }\n         if let Some((label, span)) = err.secondary_label && is_source_literal {\n-            e.span_label(fmt_span.from_inner(InnerSpan::new(span.start, span.end)), label);\n+            e.label_ = Some(errors::InvalidFormatStringLabel { span: fmt_span.from_inner(InnerSpan::new(span.start, span.end)), label } );\n         }\n         if err.should_be_replaced_with_positional_argument {\n             let captured_arg_span =\n@@ -250,17 +258,15 @@ fn make_format_args(\n                     Some(arg) => arg.expr.span,\n                     None => fmt_span,\n                 };\n-                e.multipart_suggestion_verbose(\n-                    \"consider using a positional formatting argument instead\",\n-                    vec![\n-                        (captured_arg_span, args.unnamed_args().len().to_string()),\n-                        (span.shrink_to_hi(), format!(\", {}\", arg)),\n-                    ],\n-                    Applicability::MachineApplicable,\n-                );\n+                e.sugg_ = Some(errors::InvalidFormatStringSuggestion {\n+                    captured: captured_arg_span,\n+                    len: args.unnamed_args().len().to_string(),\n+                    span: span.shrink_to_hi(),\n+                    arg,\n+                });\n             }\n         }\n-        e.emit();\n+        ecx.emit_err(e);\n         return Err(());\n     }\n \n@@ -318,10 +324,7 @@ fn make_format_args(\n                     } else {\n                         // For the moment capturing variables from format strings expanded from macros is\n                         // disabled (see RFC #2795)\n-                        ecx.struct_span_err(span, &format!(\"there is no argument named `{name}`\"))\n-                            .note(format!(\"did you intend to capture a variable `{name}` from the surrounding scope?\"))\n-                            .note(\"to avoid ambiguity, `format_args!` cannot capture variables when the format string is expanded from a macro\")\n-                            .emit();\n+                        ecx.emit_err(errors::FormatNoArgNamed { span, name });\n                         DummyResult::raw_expr(span, true)\n                     };\n                     Ok(args.add(FormatArgument { kind: FormatArgumentKind::Captured(ident), expr }))\n@@ -475,12 +478,8 @@ fn make_format_args(\n         .enumerate()\n         .filter(|&(_, used)| !used)\n         .map(|(i, _)| {\n-            let msg = if let FormatArgumentKind::Named(_) = args.explicit_args()[i].kind {\n-                \"named argument never used\"\n-            } else {\n-                \"argument never used\"\n-            };\n-            (args.explicit_args()[i].expr.span, msg)\n+            let named = matches!(args.explicit_args()[i].kind, FormatArgumentKind::Named(_));\n+            (args.explicit_args()[i].expr.span, named)\n         })\n         .collect::<Vec<_>>();\n \n@@ -531,22 +530,8 @@ fn invalid_placeholder_type_error(\n     fmt_span: Span,\n ) {\n     let sp = ty_span.map(|sp| fmt_span.from_inner(InnerSpan::new(sp.start, sp.end)));\n-    let mut err =\n-        ecx.struct_span_err(sp.unwrap_or(fmt_span), &format!(\"unknown format trait `{}`\", ty));\n-    err.note(\n-        \"the only appropriate formatting traits are:\\n\\\n-                                - ``, which uses the `Display` trait\\n\\\n-                                - `?`, which uses the `Debug` trait\\n\\\n-                                - `e`, which uses the `LowerExp` trait\\n\\\n-                                - `E`, which uses the `UpperExp` trait\\n\\\n-                                - `o`, which uses the `Octal` trait\\n\\\n-                                - `p`, which uses the `Pointer` trait\\n\\\n-                                - `b`, which uses the `Binary` trait\\n\\\n-                                - `x`, which uses the `LowerHex` trait\\n\\\n-                                - `X`, which uses the `UpperHex` trait\",\n-    );\n-    if let Some(sp) = sp {\n-        for (fmt, name) in &[\n+    let suggs = if let Some(sp) = sp {\n+        [\n             (\"\", \"Display\"),\n             (\"?\", \"Debug\"),\n             (\"e\", \"LowerExp\"),\n@@ -556,40 +541,38 @@ fn invalid_placeholder_type_error(\n             (\"b\", \"Binary\"),\n             (\"x\", \"LowerHex\"),\n             (\"X\", \"UpperHex\"),\n-        ] {\n-            err.tool_only_span_suggestion(\n-                sp,\n-                &format!(\"use the `{}` trait\", name),\n-                *fmt,\n-                Applicability::MaybeIncorrect,\n-            );\n-        }\n-    }\n-    err.emit();\n+        ]\n+        .into_iter()\n+        .map(|(fmt, trait_name)| errors::FormatUnknownTraitSugg { span: sp, fmt, trait_name })\n+        .collect()\n+    } else {\n+        vec![]\n+    };\n+    ecx.emit_err(errors::FormatUnknownTrait { span: sp.unwrap_or(fmt_span), ty, suggs });\n }\n \n fn report_missing_placeholders(\n     ecx: &mut ExtCtxt<'_>,\n-    unused: Vec<(Span, &str)>,\n+    unused: Vec<(Span, bool)>,\n     detect_foreign_fmt: bool,\n     str_style: Option<usize>,\n     fmt_str: &str,\n     fmt_span: Span,\n ) {\n-    let mut diag = if let &[(span, msg)] = &unused[..] {\n-        let mut diag = ecx.struct_span_err(span, msg);\n-        diag.span_label(span, msg);\n-        diag\n+    let mut diag = if let &[(span, named)] = &unused[..] {\n+        //let mut diag = ecx.struct_span_err(span, msg);\n+        //diag.span_label(span, msg);\n+        //diag\n+        ecx.create_err(errors::FormatUnusedArg { span, named })\n     } else {\n-        let mut diag = ecx.struct_span_err(\n-            unused.iter().map(|&(sp, _)| sp).collect::<Vec<Span>>(),\n-            \"multiple unused formatting arguments\",\n-        );\n-        diag.span_label(fmt_span, \"multiple missing formatting specifiers\");\n-        for &(span, msg) in &unused {\n-            diag.span_label(span, msg);\n-        }\n-        diag\n+        let unused_labels =\n+            unused.iter().map(|&(span, named)| errors::FormatUnusedArg { span, named }).collect();\n+        let unused_spans = unused.iter().map(|&(span, _)| span).collect();\n+        ecx.create_err(errors::FormatUnusedArgs {\n+            fmt: fmt_span,\n+            unused: unused_spans,\n+            unused_labels,\n+        })\n     };\n \n     // Used to ensure we only report translations for *one* kind of foreign format.\n@@ -768,18 +751,16 @@ fn report_invalid_references(\n         } else {\n             MultiSpan::from_spans(spans)\n         };\n-        e = ecx.struct_span_err(\n+        e = ecx.create_err(errors::FormatPositionalMismatch {\n             span,\n-            &format!(\n-                \"{} positional argument{} in format string, but {}\",\n-                num_placeholders,\n-                pluralize!(num_placeholders),\n-                num_args_desc,\n-            ),\n-        );\n-        for arg in args.explicit_args() {\n-            e.span_label(arg.expr.span, \"\");\n-        }\n+            n: num_placeholders,\n+            desc: num_args_desc,\n+            highlight: SingleLabelManySpans {\n+                spans: args.explicit_args().iter().map(|arg| arg.expr.span).collect(),\n+                label: \"\",\n+                kind: rustc_errors::LabelKind::Label,\n+            },\n+        });\n         // Point out `{:.*}` placeholders: those take an extra argument.\n         let mut has_precision_star = false;\n         for piece in template {"}, {"sha": "37fbd03a6a2161375ed6189161bb5ebd3b935db8", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -9,6 +9,7 @@\n #![feature(if_let_guard)]\n #![feature(is_sorted)]\n #![feature(let_chains)]\n+#![feature(lint_reasons)]\n #![feature(proc_macro_internals)]\n #![feature(proc_macro_quote)]\n #![recursion_limit = \"256\"]\n@@ -39,6 +40,7 @@ mod derive;\n mod deriving;\n mod edition_panic;\n mod env;\n+mod errors;\n mod format;\n mod format_foreign;\n mod global_allocator;"}, {"sha": "79d8be2484b5978bf513e3037def717b70848d8d", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 40, "deletions": 22, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -118,34 +118,22 @@ pub fn expand_test_or_bench(\n             }\n         }\n         other => {\n-            cx.struct_span_err(\n-                other.span(),\n-                \"`#[test]` attribute is only allowed on non associated functions\",\n-            )\n-            .emit();\n+            not_testable_error(cx, attr_sp, None);\n             return vec![other];\n         }\n     };\n \n-    // Note: non-associated fn items are already handled by `expand_test_or_bench`\n     let ast::ItemKind::Fn(fn_) = &item.kind else {\n-        let diag = &cx.sess.parse_sess.span_diagnostic;\n-        let msg = \"the `#[test]` attribute may only be used on a non-associated function\";\n-        let mut err = match item.kind {\n-            // These were a warning before #92959 and need to continue being that to avoid breaking\n-            // stable user code (#94508).\n-            ast::ItemKind::MacCall(_) => diag.struct_span_warn(attr_sp, msg),\n-            // `.forget_guarantee()` needed to get these two arms to match types. Because of how\n-            // locally close the `.emit()` call is I'm comfortable with it, but if it can be\n-            // reworked in the future to not need it, it'd be nice.\n-            _ => diag.struct_span_err(attr_sp, msg).forget_guarantee(),\n+        not_testable_error(cx, attr_sp, Some(&item));\n+        return if is_stmt {\n+            vec![Annotatable::Stmt(P(ast::Stmt {\n+                id: ast::DUMMY_NODE_ID,\n+                span: item.span,\n+                kind: ast::StmtKind::Item(item),\n+            }))]\n+        } else {\n+            vec![Annotatable::Item(item)]\n         };\n-        err.span_label(attr_sp, \"the `#[test]` macro causes a function to be run on a test and has no effect on non-functions\")\n-            .span_label(item.span, format!(\"expected a non-associated function, found {} {}\", item.kind.article(), item.kind.descr()))\n-            .span_suggestion(attr_sp, \"replace with conditional compilation to make the item only exist when tests are being run\", \"#[cfg(test)]\", Applicability::MaybeIncorrect)\n-            .emit();\n-\n-        return vec![Annotatable::Item(item)];\n     };\n \n     // has_*_signature will report any errors in the type so compilation\n@@ -398,6 +386,36 @@ pub fn expand_test_or_bench(\n     }\n }\n \n+fn not_testable_error(cx: &ExtCtxt<'_>, attr_sp: Span, item: Option<&ast::Item>) {\n+    let diag = &cx.sess.parse_sess.span_diagnostic;\n+    let msg = \"the `#[test]` attribute may only be used on a non-associated function\";\n+    let mut err = match item.map(|i| &i.kind) {\n+        // These were a warning before #92959 and need to continue being that to avoid breaking\n+        // stable user code (#94508).\n+        Some(ast::ItemKind::MacCall(_)) => diag.struct_span_warn(attr_sp, msg),\n+        // `.forget_guarantee()` needed to get these two arms to match types. Because of how\n+        // locally close the `.emit()` call is I'm comfortable with it, but if it can be\n+        // reworked in the future to not need it, it'd be nice.\n+        _ => diag.struct_span_err(attr_sp, msg).forget_guarantee(),\n+    };\n+    if let Some(item) = item {\n+        err.span_label(\n+            item.span,\n+            format!(\n+                \"expected a non-associated function, found {} {}\",\n+                item.kind.article(),\n+                item.kind.descr()\n+            ),\n+        );\n+    }\n+    err.span_label(attr_sp, \"the `#[test]` macro causes a function to be run as a test and has no effect on non-functions\")\n+        .span_suggestion(attr_sp,\n+            \"replace with conditional compilation to make the item only exist when tests are being run\",\n+            \"#[cfg(test)]\",\n+            Applicability::MaybeIncorrect)\n+        .emit();\n+}\n+\n fn get_location_info(cx: &ExtCtxt<'_>, item: &ast::Item) -> (Symbol, usize, usize, usize, usize) {\n     let span = item.ident.span;\n     let (source_file, lo_line, lo_col, hi_line, hi_col) ="}, {"sha": "046903fe5aca4b045062377a3f6c670fc9c227c7", "filename": "compiler/rustc_codegen_gcc/example/alloc_system.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_system.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_system.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_system.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -15,6 +15,7 @@\n const MIN_ALIGN: usize = 8;\n #[cfg(any(target_arch = \"x86_64\",\n               target_arch = \"aarch64\",\n+              target_arch = \"loongarch64\",\n               target_arch = \"mips64\",\n               target_arch = \"s390x\",\n               target_arch = \"sparc64\"))]"}, {"sha": "65de02b35671251bd4f6b552b54924266e8451fa", "filename": "compiler/rustc_codegen_gcc/src/asm.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -593,6 +593,9 @@ fn reg_to_gcc(reg: InlineAsmRegOrRegClass) -> ConstraintOrRegister {\n             InlineAsmRegClass::Bpf(BpfInlineAsmRegClass::reg) => \"r\",\n             InlineAsmRegClass::Bpf(BpfInlineAsmRegClass::wreg) => \"w\",\n             InlineAsmRegClass::Hexagon(HexagonInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::M68k(M68kInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::M68k(M68kInlineAsmRegClass::reg_addr) => \"a\",\n+            InlineAsmRegClass::M68k(M68kInlineAsmRegClass::reg_data) => \"d\",\n             InlineAsmRegClass::Mips(MipsInlineAsmRegClass::reg) => \"d\", // more specific than \"r\"\n             InlineAsmRegClass::Mips(MipsInlineAsmRegClass::freg) => \"f\",\n             InlineAsmRegClass::Msp430(Msp430InlineAsmRegClass::reg) => \"r\",\n@@ -664,6 +667,9 @@ fn dummy_output_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, reg: InlineAsmRegCl\n         InlineAsmRegClass::Avr(_) => unimplemented!(),\n         InlineAsmRegClass::Bpf(_) => unimplemented!(),\n         InlineAsmRegClass::Hexagon(HexagonInlineAsmRegClass::reg) => cx.type_i32(),\n+        InlineAsmRegClass::M68k(M68kInlineAsmRegClass::reg) => cx.type_i32(),\n+        InlineAsmRegClass::M68k(M68kInlineAsmRegClass::reg_addr) => cx.type_i32(),\n+        InlineAsmRegClass::M68k(M68kInlineAsmRegClass::reg_data) => cx.type_i32(),\n         InlineAsmRegClass::Mips(MipsInlineAsmRegClass::reg) => cx.type_i32(),\n         InlineAsmRegClass::Mips(MipsInlineAsmRegClass::freg) => cx.type_f32(),\n         InlineAsmRegClass::Msp430(_) => unimplemented!(),\n@@ -849,6 +855,7 @@ fn modifier_to_gcc(arch: InlineAsmArch, reg: InlineAsmRegClass, modifier: Option\n         InlineAsmRegClass::Avr(_) => None,\n         InlineAsmRegClass::S390x(_) => None,\n         InlineAsmRegClass::Msp430(_) => None,\n+        InlineAsmRegClass::M68k(_) => None,\n         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n             bug!(\"LLVM backend does not support SPIR-V\")\n         }"}, {"sha": "1a3865360a3c6709161aab895dcf6198e4e94480", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -244,6 +244,9 @@ impl<'ll, 'tcx> AsmBuilderMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n                 InlineAsmArch::Msp430 => {\n                     constraints.push(\"~{sr}\".to_string());\n                 }\n+                InlineAsmArch::M68k => {\n+                    constraints.push(\"~{ccr}\".to_string());\n+                }\n             }\n         }\n         if !options.contains(InlineAsmOptions::NOMEM) {\n@@ -671,6 +674,9 @@ fn reg_to_llvm(reg: InlineAsmRegOrRegClass, layout: Option<&TyAndLayout<'_>>) ->\n             InlineAsmRegClass::S390x(S390xInlineAsmRegClass::reg) => \"r\",\n             InlineAsmRegClass::S390x(S390xInlineAsmRegClass::freg) => \"f\",\n             InlineAsmRegClass::Msp430(Msp430InlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::M68k(M68kInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::M68k(M68kInlineAsmRegClass::reg_addr) => \"a\",\n+            InlineAsmRegClass::M68k(M68kInlineAsmRegClass::reg_data) => \"d\",\n             InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n                 bug!(\"LLVM backend does not support SPIR-V\")\n             }\n@@ -768,6 +774,7 @@ fn modifier_to_llvm(\n         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n             bug!(\"LLVM backend does not support SPIR-V\")\n         }\n+        InlineAsmRegClass::M68k(_) => None,\n         InlineAsmRegClass::Err => unreachable!(),\n     }\n }\n@@ -839,6 +846,9 @@ fn dummy_output_type<'ll>(cx: &CodegenCx<'ll, '_>, reg: InlineAsmRegClass) -> &'\n         InlineAsmRegClass::S390x(S390xInlineAsmRegClass::reg) => cx.type_i32(),\n         InlineAsmRegClass::S390x(S390xInlineAsmRegClass::freg) => cx.type_f64(),\n         InlineAsmRegClass::Msp430(Msp430InlineAsmRegClass::reg) => cx.type_i16(),\n+        InlineAsmRegClass::M68k(M68kInlineAsmRegClass::reg) => cx.type_i32(),\n+        InlineAsmRegClass::M68k(M68kInlineAsmRegClass::reg_addr) => cx.type_i32(),\n+        InlineAsmRegClass::M68k(M68kInlineAsmRegClass::reg_data) => cx.type_i32(),\n         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n             bug!(\"LLVM backend does not support SPIR-V\")\n         }"}, {"sha": "243be0e1f70e70c6303e3834c3d26899de01a481", "filename": "compiler/rustc_codegen_ssa/messages.ftl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_codegen_ssa%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_codegen_ssa%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fmessages.ftl?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -141,7 +141,7 @@ codegen_ssa_msvc_missing_linker = the msvc targets depend on the msvc linker but\n \n codegen_ssa_check_installed_visual_studio = please ensure that Visual Studio 2017 or later, or Build Tools for Visual Studio were installed with the Visual C++ option.\n \n-codegen_ssa_unsufficient_vs_code_product = VS Code is a different product, and is not sufficient.\n+codegen_ssa_insufficient_vs_code_product = VS Code is a different product, and is not sufficient.\n \n codegen_ssa_processing_dymutil_failed = processing debug info with `dsymutil` failed: {$status}\n     .note = {$output}"}, {"sha": "02e21e74fadc828e08953d194c6b1c1dc10b517b", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -923,7 +923,7 @@ fn link_natively<'a>(\n             if sess.target.is_like_msvc && linker_not_found {\n                 sess.emit_note(errors::MsvcMissingLinker);\n                 sess.emit_note(errors::CheckInstalledVisualStudio);\n-                sess.emit_note(errors::UnsufficientVSCodeProduct);\n+                sess.emit_note(errors::InsufficientVSCodeProduct);\n             }\n             sess.abort_if_errors();\n         }"}, {"sha": "d5d843702c0031e086df18f16600840acee1a20f", "filename": "compiler/rustc_codegen_ssa/src/back/metadata.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -127,6 +127,7 @@ pub(crate) fn create_object_file(sess: &Session) -> Option<write::Object<'static\n         \"msp430\" => Architecture::Msp430,\n         \"hexagon\" => Architecture::Hexagon,\n         \"bpf\" => Architecture::Bpf,\n+        \"loongarch64\" => Architecture::LoongArch64,\n         // Unsupported architecture.\n         _ => return None,\n     };\n@@ -190,6 +191,10 @@ pub(crate) fn create_object_file(sess: &Session) -> Option<write::Object<'static\n             }\n             e_flags\n         }\n+        Architecture::LoongArch64 => {\n+            // Source: https://loongson.github.io/LoongArch-Documentation/LoongArch-ELF-ABI-EN.html#_e_flags_identifies_abi_type_and_version\n+            elf::EF_LARCH_OBJABI_V1 | elf::EF_LARCH_ABI_DOUBLE_FLOAT\n+        }\n         _ => 0,\n     };\n     // adapted from LLVM's `MCELFObjectTargetWriter::getOSABI`"}, {"sha": "66e7e314f79d860aff5fcb3d5cff267bb49b9fee", "filename": "compiler/rustc_codegen_ssa/src/errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -405,8 +405,8 @@ pub struct MsvcMissingLinker;\n pub struct CheckInstalledVisualStudio;\n \n #[derive(Diagnostic)]\n-#[diag(codegen_ssa_unsufficient_vs_code_product)]\n-pub struct UnsufficientVSCodeProduct;\n+#[diag(codegen_ssa_insufficient_vs_code_product)]\n+pub struct InsufficientVSCodeProduct;\n \n #[derive(Diagnostic)]\n #[diag(codegen_ssa_processing_dymutil_failed)]"}, {"sha": "d049bafb821bd4d24d412a69f255280caceab0fd", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -442,11 +442,10 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let (var_ty, var_kind) = match var.value {\n                     mir::VarDebugInfoContents::Place(place) => {\n                         let var_ty = self.monomorphized_place_ty(place.as_ref());\n-                        let var_kind = if self.mir.local_kind(place.local) == mir::LocalKind::Arg\n+                        let var_kind = if let Some(arg_index) = var.argument_index\n                             && place.projection.is_empty()\n-                            && var.source_info.scope == mir::OUTERMOST_SOURCE_SCOPE\n                         {\n-                            let arg_index = place.local.index() - 1;\n+                            let arg_index = arg_index as usize;\n                             if target_is_msvc {\n                                 // ScalarPair parameters are spilled to the stack so they need to\n                                 // be marked as a `LocalVariable` for MSVC debuggers to visualize\n@@ -455,13 +454,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                 if let Abi::ScalarPair(_, _) = var_ty_layout.abi {\n                                     VariableKind::LocalVariable\n                                 } else {\n-                                    VariableKind::ArgumentVariable(arg_index + 1)\n+                                    VariableKind::ArgumentVariable(arg_index)\n                                 }\n                             } else {\n                                 // FIXME(eddyb) shouldn't `ArgumentVariable` indices be\n                                 // offset in closures to account for the hidden environment?\n-                                // Also, is this `+ 1` needed at all?\n-                                VariableKind::ArgumentVariable(arg_index + 1)\n+                                VariableKind::ArgumentVariable(arg_index)\n                             }\n                         } else {\n                             VariableKind::LocalVariable"}, {"sha": "611dd3d1cd18a6a535b790a123c6861592828e71", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -251,6 +251,7 @@ const RISCV_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     (\"e\", Some(sym::riscv_target_feature)),\n     (\"f\", Some(sym::riscv_target_feature)),\n     (\"m\", Some(sym::riscv_target_feature)),\n+    (\"relax\", Some(sym::riscv_target_feature)),\n     (\"v\", Some(sym::riscv_target_feature)),\n     (\"zba\", Some(sym::riscv_target_feature)),\n     (\"zbb\", Some(sym::riscv_target_feature)),"}, {"sha": "4bd6fe19931e7c83ecf6d736162c7a9b21ac1d09", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -205,7 +205,7 @@ pub(crate) fn turn_into_const_value<'tcx>(\n     let cid = key.value;\n     let def_id = cid.instance.def.def_id();\n     let is_static = tcx.is_static(def_id);\n-    // This is just accessing an already computed constant, so no need to check alginment here.\n+    // This is just accessing an already computed constant, so no need to check alignment here.\n     let ecx = mk_eval_cx(\n         tcx,\n         tcx.def_span(key.value.instance.def_id()),"}, {"sha": "3701eb93ec834ae870fb5f00f83aa650cbf8644f", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -77,7 +77,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         line: u32,\n         col: u32,\n     ) -> MPlaceTy<'tcx, M::Provenance> {\n-        let loc_details = &self.tcx.sess.opts.unstable_opts.location_detail;\n+        let loc_details = self.tcx.sess.opts.unstable_opts.location_detail;\n         // This can fail if rustc runs out of memory right here. Trying to emit an error would be\n         // pointless, since that would require allocating more memory than these short strings.\n         let file = if loc_details.file {"}, {"sha": "d4bed97380ba18f703ff4212502acd8246b0ce3c", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -679,13 +679,21 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                             // Unlike `mem::transmute`, a MIR `Transmute` is well-formed\n                             // for any two `Sized` types, just potentially UB to run.\n \n-                            if !op_ty.is_sized(self.tcx, self.param_env) {\n+                            if !self\n+                                .tcx\n+                                .normalize_erasing_regions(self.param_env, op_ty)\n+                                .is_sized(self.tcx, self.param_env)\n+                            {\n                                 self.fail(\n                                     location,\n                                     format!(\"Cannot transmute from non-`Sized` type {op_ty:?}\"),\n                                 );\n                             }\n-                            if !target_type.is_sized(self.tcx, self.param_env) {\n+                            if !self\n+                                .tcx\n+                                .normalize_erasing_regions(self.param_env, *target_type)\n+                                .is_sized(self.tcx, self.param_env)\n+                            {\n                                 self.fail(\n                                     location,\n                                     format!(\"Cannot transmute to non-`Sized` type {target_type:?}\"),"}, {"sha": "2102f09c56a03f5b168930bbf5d099f6133909dd", "filename": "compiler/rustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2FCargo.toml?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -33,6 +33,7 @@ tempfile = \"3.2\"\n thin-vec = \"0.2.12\"\n tracing = \"0.1\"\n elsa = \"=1.7.1\"\n+itertools = \"0.10.1\"\n \n [dependencies.parking_lot]\n version = \"0.11\""}, {"sha": "bca6c0955b905f8732fb72b598fc75e62d924152", "filename": "compiler/rustc_data_structures/src/sso/either_iter.rs", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/2386cd7b22174f277d5bd9ad802bcffc3b902ab6/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Feither_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2386cd7b22174f277d5bd9ad802bcffc3b902ab6/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Feither_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Feither_iter.rs?ref=2386cd7b22174f277d5bd9ad802bcffc3b902ab6", "patch": "@@ -1,73 +0,0 @@\n-use std::fmt;\n-use std::iter::FusedIterator;\n-\n-/// Iterator which may contain instance of\n-/// one of two specific implementations.\n-///\n-/// Note: For most methods providing custom\n-///       implementation may marginally\n-///       improve performance by avoiding\n-///       doing Left/Right match on every step\n-///       and doing it only once instead.\n-#[derive(Clone)]\n-pub enum EitherIter<L, R> {\n-    Left(L),\n-    Right(R),\n-}\n-\n-impl<L, R> Iterator for EitherIter<L, R>\n-where\n-    L: Iterator,\n-    R: Iterator<Item = L::Item>,\n-{\n-    type Item = L::Item;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        match self {\n-            EitherIter::Left(l) => l.next(),\n-            EitherIter::Right(r) => r.next(),\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        match self {\n-            EitherIter::Left(l) => l.size_hint(),\n-            EitherIter::Right(r) => r.size_hint(),\n-        }\n-    }\n-}\n-\n-impl<L, R> ExactSizeIterator for EitherIter<L, R>\n-where\n-    L: ExactSizeIterator,\n-    R: ExactSizeIterator,\n-    EitherIter<L, R>: Iterator,\n-{\n-    fn len(&self) -> usize {\n-        match self {\n-            EitherIter::Left(l) => l.len(),\n-            EitherIter::Right(r) => r.len(),\n-        }\n-    }\n-}\n-\n-impl<L, R> FusedIterator for EitherIter<L, R>\n-where\n-    L: FusedIterator,\n-    R: FusedIterator,\n-    EitherIter<L, R>: Iterator,\n-{\n-}\n-\n-impl<L, R> fmt::Debug for EitherIter<L, R>\n-where\n-    L: fmt::Debug,\n-    R: fmt::Debug,\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            EitherIter::Left(l) => l.fmt(f),\n-            EitherIter::Right(r) => r.fmt(f),\n-        }\n-    }\n-}"}, {"sha": "89b8c852649691261b3e8080f926bd171c77eae9", "filename": "compiler/rustc_data_structures/src/sso/map.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1,24 +1,24 @@\n-use super::either_iter::EitherIter;\n use crate::fx::FxHashMap;\n use arrayvec::ArrayVec;\n+use itertools::Either;\n use std::fmt;\n use std::hash::Hash;\n use std::ops::Index;\n \n-// For pointer-sized arguments arrays\n-// are faster than set/map for up to 64\n-// arguments.\n-//\n-// On the other hand such a big array\n-// hurts cache performance, makes passing\n-// sso structures around very expensive.\n-//\n-// Biggest performance benefit is gained\n-// for reasonably small arrays that stay\n-// small in vast majority of cases.\n-//\n-// '8' is chosen as a sane default, to be\n-// reevaluated later.\n+/// For pointer-sized arguments arrays\n+/// are faster than set/map for up to 64\n+/// arguments.\n+///\n+/// On the other hand such a big array\n+/// hurts cache performance, makes passing\n+/// sso structures around very expensive.\n+///\n+/// Biggest performance benefit is gained\n+/// for reasonably small arrays that stay\n+/// small in vast majority of cases.\n+///\n+/// '8' is chosen as a sane default, to be\n+/// reevaluated later.\n const SSO_ARRAY_SIZE: usize = 8;\n \n /// Small-storage-optimized implementation of a map.\n@@ -138,35 +138,35 @@ impl<K, V> SsoHashMap<K, V> {\n     /// The iterator element type is `&'a K`.\n     pub fn keys(&self) -> impl Iterator<Item = &'_ K> {\n         match self {\n-            SsoHashMap::Array(array) => EitherIter::Left(array.iter().map(|(k, _v)| k)),\n-            SsoHashMap::Map(map) => EitherIter::Right(map.keys()),\n+            SsoHashMap::Array(array) => Either::Left(array.iter().map(|(k, _v)| k)),\n+            SsoHashMap::Map(map) => Either::Right(map.keys()),\n         }\n     }\n \n     /// An iterator visiting all values in arbitrary order.\n     /// The iterator element type is `&'a V`.\n     pub fn values(&self) -> impl Iterator<Item = &'_ V> {\n         match self {\n-            SsoHashMap::Array(array) => EitherIter::Left(array.iter().map(|(_k, v)| v)),\n-            SsoHashMap::Map(map) => EitherIter::Right(map.values()),\n+            SsoHashMap::Array(array) => Either::Left(array.iter().map(|(_k, v)| v)),\n+            SsoHashMap::Map(map) => Either::Right(map.values()),\n         }\n     }\n \n     /// An iterator visiting all values mutably in arbitrary order.\n     /// The iterator element type is `&'a mut V`.\n     pub fn values_mut(&mut self) -> impl Iterator<Item = &'_ mut V> {\n         match self {\n-            SsoHashMap::Array(array) => EitherIter::Left(array.iter_mut().map(|(_k, v)| v)),\n-            SsoHashMap::Map(map) => EitherIter::Right(map.values_mut()),\n+            SsoHashMap::Array(array) => Either::Left(array.iter_mut().map(|(_k, v)| v)),\n+            SsoHashMap::Map(map) => Either::Right(map.values_mut()),\n         }\n     }\n \n     /// Clears the map, returning all key-value pairs as an iterator. Keeps the\n     /// allocated memory for reuse.\n     pub fn drain(&mut self) -> impl Iterator<Item = (K, V)> + '_ {\n         match self {\n-            SsoHashMap::Array(array) => EitherIter::Left(array.drain(..)),\n-            SsoHashMap::Map(map) => EitherIter::Right(map.drain()),\n+            SsoHashMap::Array(array) => Either::Left(array.drain(..)),\n+            SsoHashMap::Map(map) => Either::Right(map.drain()),\n         }\n     }\n }\n@@ -406,16 +406,16 @@ where\n }\n \n impl<K, V> IntoIterator for SsoHashMap<K, V> {\n-    type IntoIter = EitherIter<\n-        <ArrayVec<(K, V), 8> as IntoIterator>::IntoIter,\n+    type IntoIter = Either<\n+        <ArrayVec<(K, V), SSO_ARRAY_SIZE> as IntoIterator>::IntoIter,\n         <FxHashMap<K, V> as IntoIterator>::IntoIter,\n     >;\n     type Item = <Self::IntoIter as Iterator>::Item;\n \n     fn into_iter(self) -> Self::IntoIter {\n         match self {\n-            SsoHashMap::Array(array) => EitherIter::Left(array.into_iter()),\n-            SsoHashMap::Map(map) => EitherIter::Right(map.into_iter()),\n+            SsoHashMap::Array(array) => Either::Left(array.into_iter()),\n+            SsoHashMap::Map(map) => Either::Right(map.into_iter()),\n         }\n     }\n }\n@@ -435,9 +435,9 @@ fn adapt_array_mut_it<K, V>(pair: &mut (K, V)) -> (&K, &mut V) {\n }\n \n impl<'a, K, V> IntoIterator for &'a SsoHashMap<K, V> {\n-    type IntoIter = EitherIter<\n+    type IntoIter = Either<\n         std::iter::Map<\n-            <&'a ArrayVec<(K, V), 8> as IntoIterator>::IntoIter,\n+            <&'a ArrayVec<(K, V), SSO_ARRAY_SIZE> as IntoIterator>::IntoIter,\n             fn(&'a (K, V)) -> (&'a K, &'a V),\n         >,\n         <&'a FxHashMap<K, V> as IntoIterator>::IntoIter,\n@@ -446,16 +446,16 @@ impl<'a, K, V> IntoIterator for &'a SsoHashMap<K, V> {\n \n     fn into_iter(self) -> Self::IntoIter {\n         match self {\n-            SsoHashMap::Array(array) => EitherIter::Left(array.into_iter().map(adapt_array_ref_it)),\n-            SsoHashMap::Map(map) => EitherIter::Right(map.iter()),\n+            SsoHashMap::Array(array) => Either::Left(array.into_iter().map(adapt_array_ref_it)),\n+            SsoHashMap::Map(map) => Either::Right(map.iter()),\n         }\n     }\n }\n \n impl<'a, K, V> IntoIterator for &'a mut SsoHashMap<K, V> {\n-    type IntoIter = EitherIter<\n+    type IntoIter = Either<\n         std::iter::Map<\n-            <&'a mut ArrayVec<(K, V), 8> as IntoIterator>::IntoIter,\n+            <&'a mut ArrayVec<(K, V), SSO_ARRAY_SIZE> as IntoIterator>::IntoIter,\n             fn(&'a mut (K, V)) -> (&'a K, &'a mut V),\n         >,\n         <&'a mut FxHashMap<K, V> as IntoIterator>::IntoIter,\n@@ -464,8 +464,8 @@ impl<'a, K, V> IntoIterator for &'a mut SsoHashMap<K, V> {\n \n     fn into_iter(self) -> Self::IntoIter {\n         match self {\n-            SsoHashMap::Array(array) => EitherIter::Left(array.into_iter().map(adapt_array_mut_it)),\n-            SsoHashMap::Map(map) => EitherIter::Right(map.iter_mut()),\n+            SsoHashMap::Array(array) => Either::Left(array.into_iter().map(adapt_array_mut_it)),\n+            SsoHashMap::Map(map) => Either::Right(map.iter_mut()),\n         }\n     }\n }"}, {"sha": "ef634b9adcec3fa25150eea8a8a844a6d243ec07", "filename": "compiler/rustc_data_structures/src/sso/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1,4 +1,3 @@\n-mod either_iter;\n mod map;\n mod set;\n "}, {"sha": "b9f0e756e65fee115492cff4e3c8ca3696d83a41", "filename": "compiler/rustc_driver_impl/src/lib.rs", "status": "modified", "additions": 43, "deletions": 34, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -5,7 +5,6 @@\n //! This API is completely unstable and subject to change.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n-#![feature(is_terminal)]\n #![feature(lazy_cell)]\n #![feature(decl_macro)]\n #![recursion_limit = \"256\"]\n@@ -37,7 +36,7 @@ use rustc_metadata::locator;\n use rustc_session::config::{nightly_options, CG_OPTIONS, Z_OPTIONS};\n use rustc_session::config::{ErrorOutputType, Input, OutputType, PrintRequest, TrimmedDefPaths};\n use rustc_session::cstore::MetadataLoader;\n-use rustc_session::getopts;\n+use rustc_session::getopts::{self, Matches};\n use rustc_session::lint::{Lint, LintId};\n use rustc_session::{config, Session};\n use rustc_session::{early_error, early_error_no_abort, early_warn};\n@@ -956,6 +955,46 @@ Available lint options:\n     }\n }\n \n+/// Show help for flag categories shared between rustdoc and rustc.\n+///\n+/// Returns whether a help option was printed.\n+pub fn describe_flag_categories(matches: &Matches) -> bool {\n+    // Handle the special case of -Wall.\n+    let wall = matches.opt_strs(\"W\");\n+    if wall.iter().any(|x| *x == \"all\") {\n+        print_wall_help();\n+        rustc_errors::FatalError.raise();\n+    }\n+\n+    // Don't handle -W help here, because we might first load plugins.\n+    let debug_flags = matches.opt_strs(\"Z\");\n+    if debug_flags.iter().any(|x| *x == \"help\") {\n+        describe_debug_flags();\n+        return true;\n+    }\n+\n+    let cg_flags = matches.opt_strs(\"C\");\n+    if cg_flags.iter().any(|x| *x == \"help\") {\n+        describe_codegen_flags();\n+        return true;\n+    }\n+\n+    if cg_flags.iter().any(|x| *x == \"no-stack-check\") {\n+        early_warn(\n+            ErrorOutputType::default(),\n+            \"the --no-stack-check flag is deprecated and does nothing\",\n+        );\n+    }\n+\n+    if cg_flags.iter().any(|x| *x == \"passes=list\") {\n+        let backend_name = debug_flags.iter().find_map(|x| x.strip_prefix(\"codegen-backend=\"));\n+        get_codegen_backend(&None, backend_name).print_passes();\n+        return true;\n+    }\n+\n+    false\n+}\n+\n fn describe_debug_flags() {\n     println!(\"\\nAvailable options:\\n\");\n     print_flag_list(\"-Z\", config::Z_OPTIONS);\n@@ -966,7 +1005,7 @@ fn describe_codegen_flags() {\n     print_flag_list(\"-C\", config::CG_OPTIONS);\n }\n \n-pub fn print_flag_list<T>(\n+fn print_flag_list<T>(\n     cmdline_opt: &str,\n     flag_list: &[(&'static str, T, &'static str, &'static str)],\n ) {\n@@ -1059,37 +1098,7 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n         return None;\n     }\n \n-    // Handle the special case of -Wall.\n-    let wall = matches.opt_strs(\"W\");\n-    if wall.iter().any(|x| *x == \"all\") {\n-        print_wall_help();\n-        rustc_errors::FatalError.raise();\n-    }\n-\n-    // Don't handle -W help here, because we might first load plugins.\n-    let debug_flags = matches.opt_strs(\"Z\");\n-    if debug_flags.iter().any(|x| *x == \"help\") {\n-        describe_debug_flags();\n-        return None;\n-    }\n-\n-    let cg_flags = matches.opt_strs(\"C\");\n-\n-    if cg_flags.iter().any(|x| *x == \"help\") {\n-        describe_codegen_flags();\n-        return None;\n-    }\n-\n-    if cg_flags.iter().any(|x| *x == \"no-stack-check\") {\n-        early_warn(\n-            ErrorOutputType::default(),\n-            \"the --no-stack-check flag is deprecated and does nothing\",\n-        );\n-    }\n-\n-    if cg_flags.iter().any(|x| *x == \"passes=list\") {\n-        let backend_name = debug_flags.iter().find_map(|x| x.strip_prefix(\"codegen-backend=\"));\n-        get_codegen_backend(&None, backend_name).print_passes();\n+    if describe_flag_categories(&matches) {\n         return None;\n     }\n "}, {"sha": "a5876e0752842715e8f7dc36266cd5df7200dbb8", "filename": "compiler/rustc_error_codes/src/error_codes/E0449.md", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0449.md", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0449.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0449.md?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1,4 +1,6 @@\n-A visibility qualifier was used when it was unnecessary.\n+A visibility qualifier was used where one is not permitted. Visibility\n+qualifiers are not permitted on enum variants, trait items, impl blocks, and\n+extern blocks, as they already share the visibility of the parent item.\n \n Erroneous code examples:\n \n@@ -9,15 +11,18 @@ trait Foo {\n     fn foo();\n }\n \n-pub impl Bar {} // error: unnecessary visibility qualifier\n+enum Baz {\n+    pub Qux, // error: visibility qualifiers are not permitted here\n+}\n+\n+pub impl Bar {} // error: visibility qualifiers are not permitted here\n \n-pub impl Foo for Bar { // error: unnecessary visibility qualifier\n-    pub fn foo() {} // error: unnecessary visibility qualifier\n+pub impl Foo for Bar { // error: visibility qualifiers are not permitted here\n+    pub fn foo() {} // error: visibility qualifiers are not permitted here\n }\n ```\n \n-To fix this error, please remove the visibility qualifier when it is not\n-required. Example:\n+To fix this error, simply remove the visibility qualifier. Example:\n \n ```\n struct Bar;\n@@ -26,12 +31,18 @@ trait Foo {\n     fn foo();\n }\n \n+enum Baz {\n+    // Enum variants share the visibility of the enum they are in, so\n+    // `pub` is not allowed here\n+    Qux,\n+}\n+\n // Directly implemented methods share the visibility of the type itself,\n-// so `pub` is unnecessary here\n+// so `pub` is not allowed here\n impl Bar {}\n \n-// Trait methods share the visibility of the trait, so `pub` is\n-// unnecessary in either case\n+// Trait methods share the visibility of the trait, so `pub` is not\n+// allowed in either case\n impl Foo for Bar {\n     fn foo() {}\n }"}, {"sha": "29c692128bcf98f3ee830f1f76d8f66e386cb2ba", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -880,6 +880,7 @@ impl Diagnostic {\n     ///\n     /// This is intended to be used for suggestions that are *very* obvious in what the changes\n     /// need to be from the message, but we still want other tools to be able to apply them.\n+    #[rustc_lint_diagnostics]\n     pub fn tool_only_span_suggestion(\n         &mut self,\n         sp: Span,"}, {"sha": "65f8a61a30a9a045c3d7d4f526f832d52867ea95", "filename": "compiler/rustc_errors/src/diagnostic_impls.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1,11 +1,12 @@\n-use crate::fluent_generated as fluent;\n+use crate::{fluent_generated as fluent, AddToDiagnostic};\n use crate::{DiagnosticArgValue, DiagnosticBuilder, Handler, IntoDiagnostic, IntoDiagnosticArg};\n use rustc_ast as ast;\n use rustc_ast_pretty::pprust;\n use rustc_hir as hir;\n use rustc_lint_defs::Level;\n use rustc_span::edition::Edition;\n use rustc_span::symbol::{Ident, MacroRulesNormalizedIdent, Symbol};\n+use rustc_span::Span;\n use rustc_target::abi::TargetDataLayoutErrors;\n use rustc_target::spec::{PanicStrategy, SplitDebuginfo, StackProtector, TargetTriple};\n use rustc_type_ir as type_ir;\n@@ -276,3 +277,26 @@ impl IntoDiagnostic<'_, !> for TargetDataLayoutErrors<'_> {\n         }\n     }\n }\n+\n+/// Utility struct used to apply a single label while highlighting multiple spans\n+pub struct SingleLabelManySpans {\n+    pub spans: Vec<Span>,\n+    pub label: &'static str,\n+    pub kind: LabelKind,\n+}\n+impl AddToDiagnostic for SingleLabelManySpans {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut crate::Diagnostic, _: F) {\n+        match self.kind {\n+            LabelKind::Note => diag.span_note(self.spans, self.label),\n+            LabelKind::Label => diag.span_labels(self.spans, self.label),\n+            LabelKind::Help => diag.span_help(self.spans, self.label),\n+        };\n+    }\n+}\n+\n+/// The kind of label to attach when using [`SingleLabelManySpans`]\n+pub enum LabelKind {\n+    Note,\n+    Label,\n+    Help,\n+}"}, {"sha": "fe44799efdb6a946b9daa54c714e58a55c1a3513", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1832,6 +1832,12 @@ impl EmitterWriter {\n             }\n             let show_code_change = if has_deletion && !is_multiline {\n                 DisplaySuggestion::Diff\n+            } else if let [part] = &parts[..]\n+                && part.snippet.ends_with('\\n')\n+                && part.snippet.trim() == complete.trim()\n+            {\n+                // We are adding a line(s) of code before code that was already there.\n+                DisplaySuggestion::Add\n             } else if (parts.len() != 1 || parts[0].snippet.trim() != complete.trim())\n                 && !is_multiline\n             {\n@@ -1879,14 +1885,23 @@ impl EmitterWriter {\n                 row_num += line_end - line_start;\n             }\n             let mut unhighlighted_lines = Vec::new();\n+            let mut last_pos = 0;\n+            let mut is_item_attribute = false;\n             for (line_pos, (line, highlight_parts)) in lines.by_ref().zip(highlights).enumerate() {\n+                last_pos = line_pos;\n                 debug!(%line_pos, %line, ?highlight_parts);\n \n                 // Remember lines that are not highlighted to hide them if needed\n                 if highlight_parts.is_empty() {\n                     unhighlighted_lines.push((line_pos, line));\n                     continue;\n                 }\n+                if highlight_parts.len() == 1\n+                    && line.trim().starts_with(\"#[\")\n+                    && line.trim().ends_with(']')\n+                {\n+                    is_item_attribute = true;\n+                }\n \n                 match unhighlighted_lines.len() {\n                     0 => (),\n@@ -1963,13 +1978,41 @@ impl EmitterWriter {\n                     is_multiline,\n                 )\n             }\n+            if let DisplaySuggestion::Add = show_code_change && is_item_attribute {\n+                // The suggestion adds an entire line of code, ending on a newline, so we'll also\n+                // print the *following* line, to provide context of what we're advicing people to\n+                // do. Otherwise you would only see contextless code that can be confused for\n+                // already existing code, despite the colors and UI elements.\n+                // We special case `#[derive(_)]\\n` and other attribute suggestions, because those\n+                // are the ones where context is most useful.\n+                let file_lines = sm\n+                    .span_to_lines(span.primary_span().unwrap().shrink_to_hi())\n+                    .expect(\"span_to_lines failed when emitting suggestion\");\n+                let line_num = sm.lookup_char_pos(parts[0].span.lo()).line;\n+                if let Some(line) = file_lines.file.get_line(line_num - 1) {\n+                    let line = normalize_whitespace(&line);\n+                    self.draw_code_line(\n+                        &mut buffer,\n+                        &mut row_num,\n+                        &[],\n+                        line_num + last_pos + 1,\n+                        &line,\n+                        DisplaySuggestion::None,\n+                        max_line_num_len,\n+                        &file_lines,\n+                        is_multiline,\n+                    )\n+                }\n+            }\n \n             // This offset and the ones below need to be signed to account for replacement code\n             // that is shorter than the original code.\n             let mut offsets: Vec<(usize, isize)> = Vec::new();\n             // Only show an underline in the suggestions if the suggestion is not the\n             // entirety of the code being shown and the displayed code is not multiline.\n-            if let DisplaySuggestion::Diff | DisplaySuggestion::Underline = show_code_change {\n+            if let DisplaySuggestion::Diff | DisplaySuggestion::Underline | DisplaySuggestion::Add =\n+                show_code_change\n+            {\n                 draw_col_separator_no_space(&mut buffer, row_num, max_line_num_len + 1);\n                 for part in parts {\n                     let span_start_pos = sm.lookup_char_pos(part.span.lo()).col_display;\n@@ -2247,6 +2290,10 @@ impl EmitterWriter {\n                 }\n             }\n             buffer.append(*row_num, &normalize_whitespace(line_to_add), Style::NoStyle);\n+        } else if let DisplaySuggestion::Add = show_code_change {\n+            buffer.puts(*row_num, 0, &self.maybe_anonymized(line_num), Style::LineNumber);\n+            buffer.puts(*row_num, max_line_num_len + 1, \"+ \", Style::Addition);\n+            buffer.append(*row_num, &normalize_whitespace(line_to_add), Style::NoStyle);\n         } else {\n             buffer.puts(*row_num, 0, &self.maybe_anonymized(line_num), Style::LineNumber);\n             draw_col_separator(buffer, *row_num, max_line_num_len + 1);\n@@ -2281,6 +2328,7 @@ enum DisplaySuggestion {\n     Underline,\n     Diff,\n     None,\n+    Add,\n }\n \n impl FileWithAnnotatedLines {"}, {"sha": "d20b168904d6f993330b84c11f1226a14b25c2f5", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -6,7 +6,6 @@\n #![feature(array_windows)]\n #![feature(drain_filter)]\n #![feature(if_let_guard)]\n-#![feature(is_terminal)]\n #![feature(adt_const_params)]\n #![feature(let_chains)]\n #![feature(never_type)]\n@@ -383,7 +382,9 @@ pub use diagnostic::{\n     DiagnosticStyledString, IntoDiagnosticArg, SubDiagnostic,\n };\n pub use diagnostic_builder::{DiagnosticBuilder, EmissionGuarantee, Noted};\n-pub use diagnostic_impls::{DiagnosticArgFromDisplay, DiagnosticSymbolList};\n+pub use diagnostic_impls::{\n+    DiagnosticArgFromDisplay, DiagnosticSymbolList, LabelKind, SingleLabelManySpans,\n+};\n use std::backtrace::Backtrace;\n \n /// A handler deals with errors and other compiler output.\n@@ -473,8 +474,6 @@ pub enum StashKey {\n     /// When an invalid lifetime e.g. `'2` should be reinterpreted\n     /// as a char literal in the parser\n     LifetimeIsChar,\n-    /// When an invalid lifetime e.g. `'\ud83d\udc31` contains emoji.\n-    LifetimeContainsEmoji,\n     /// Maybe there was a typo where a comma was forgotten before\n     /// FRU syntax\n     MaybeFruTypo,"}, {"sha": "5d999d0db5dbd5c76ceb5432cc4ccffd9dbb0cc9", "filename": "compiler/rustc_expand/messages.ftl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_expand%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_expand%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fmessages.ftl?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -135,4 +135,4 @@ expand_proc_macro_panicked =\n     .help = message: {$message}\n \n expand_proc_macro_derive_tokens =\n-    proc-macro derive produced unparseable tokens\n+    proc-macro derive produced unparsable tokens"}, {"sha": "35572292271c4997962cdc801f2edf678639eb40", "filename": "compiler/rustc_expand/src/mbe/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -66,7 +66,12 @@ pub(super) fn failed_to_match_macro<'cx>(\n         && (matches!(expected_token.kind, TokenKind::Interpolated(_))\n             || matches!(token.kind, TokenKind::Interpolated(_)))\n     {\n-        err.note(\"captured metavariables except for `$tt`, `$ident` and `$lifetime` cannot be compared to other tokens\");\n+        err.note(\"captured metavariables except for `:tt`, `:ident` and `:lifetime` cannot be compared to other tokens\");\n+        err.note(\"see <https://doc.rust-lang.org/nightly/reference/macros-by-example.html#forwarding-a-matched-fragment> for more information\");\n+\n+        if !def_span.is_dummy() && !cx.source_map().is_imported(def_span) {\n+            err.help(\"try using `:tt` instead in the macro definition\");\n+        }\n     }\n \n     // Check whether there's a missing comma in this macro call, like `println!(\"{}\" a);`"}, {"sha": "48f5bd1cb50488c4085ae32965ea4d0764699da4", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -309,7 +309,7 @@ declare_features! (\n     (active, associated_type_defaults, \"1.2.0\", Some(29661), None),\n     /// Allows `async || body` closures.\n     (active, async_closure, \"1.37.0\", Some(62290), None),\n-    /// Alows async functions to be declared, implemented, and used in traits.\n+    /// Allows async functions to be declared, implemented, and used in traits.\n     (incomplete, async_fn_in_trait, \"1.66.0\", Some(91611), None),\n     /// Allows `extern \"C-unwind\" fn` to enable unwinding across ABI boundaries.\n     (active, c_unwind, \"1.52.0\", Some(74990), None),\n@@ -416,6 +416,8 @@ declare_features! (\n     (active, half_open_range_patterns_in_slices, \"1.66.0\", Some(67264), None),\n     /// Allows `if let` guard in match arms.\n     (active, if_let_guard, \"1.47.0\", Some(51114), None),\n+    /// Allows `impl Trait` to be used inside associated types (RFC 2515).\n+    (active, impl_trait_in_assoc_type, \"CURRENT_RUSTC_VERSION\", Some(63063), None),\n     /// Allows `impl Trait` as output type in `Fn` traits in return position of functions.\n     (active, impl_trait_in_fn_trait_return, \"1.64.0\", Some(99697), None),\n     /// Allows referencing `Self` and projections in impl-trait."}, {"sha": "8d1156c1771e9cd4c3cce7851bc81e0d1c0ea9cc", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 44, "deletions": 46, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1663,39 +1663,45 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             })\n         });\n \n-        let existential_projections = projection_bounds.iter().map(|(bound, _)| {\n-            bound.map_bound(|mut b| {\n-                assert_eq!(b.projection_ty.self_ty(), dummy_self);\n-\n-                // Like for trait refs, verify that `dummy_self` did not leak inside default type\n-                // parameters.\n-                let references_self = b.projection_ty.substs.iter().skip(1).any(|arg| {\n-                    if arg.walk().any(|arg| arg == dummy_self.into()) {\n-                        return true;\n+        let existential_projections = projection_bounds\n+            .iter()\n+            // We filter out traits that don't have `Self` as their self type above,\n+            // we need to do the same for projections.\n+            .filter(|(bound, _)| bound.skip_binder().self_ty() == dummy_self)\n+            .map(|(bound, _)| {\n+                bound.map_bound(|mut b| {\n+                    assert_eq!(b.projection_ty.self_ty(), dummy_self);\n+\n+                    // Like for trait refs, verify that `dummy_self` did not leak inside default type\n+                    // parameters.\n+                    let references_self = b.projection_ty.substs.iter().skip(1).any(|arg| {\n+                        if arg.walk().any(|arg| arg == dummy_self.into()) {\n+                            return true;\n+                        }\n+                        false\n+                    });\n+                    if references_self {\n+                        let guar = tcx.sess.delay_span_bug(\n+                            span,\n+                            \"trait object projection bounds reference `Self`\",\n+                        );\n+                        let substs: Vec<_> = b\n+                            .projection_ty\n+                            .substs\n+                            .iter()\n+                            .map(|arg| {\n+                                if arg.walk().any(|arg| arg == dummy_self.into()) {\n+                                    return tcx.ty_error(guar).into();\n+                                }\n+                                arg\n+                            })\n+                            .collect();\n+                        b.projection_ty.substs = tcx.mk_substs(&substs);\n                     }\n-                    false\n-                });\n-                if references_self {\n-                    let guar = tcx\n-                        .sess\n-                        .delay_span_bug(span, \"trait object projection bounds reference `Self`\");\n-                    let substs: Vec<_> = b\n-                        .projection_ty\n-                        .substs\n-                        .iter()\n-                        .map(|arg| {\n-                            if arg.walk().any(|arg| arg == dummy_self.into()) {\n-                                return tcx.ty_error(guar).into();\n-                            }\n-                            arg\n-                        })\n-                        .collect();\n-                    b.projection_ty.substs = tcx.mk_substs(&substs);\n-                }\n \n-                ty::ExistentialProjection::erase_self_ty(tcx, b)\n-            })\n-        });\n+                    ty::ExistentialProjection::erase_self_ty(tcx, b)\n+                })\n+            });\n \n         let regular_trait_predicates = existential_trait_refs\n             .map(|trait_ref| trait_ref.map_bound(ty::ExistentialPredicate::Trait));\n@@ -2514,24 +2520,16 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                     tcx,\n                                     infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id),\n                                 );\n-                                // I guess we don't need to make a universe unless we need it,\n-                                // but also we're on the error path, so it doesn't matter here.\n-                                let universe = infcx.create_next_universe();\n+                                let value = tcx.fold_regions(qself_ty, |_, _| tcx.lifetimes.re_erased);\n+                                // FIXME: Don't bother dealing with non-lifetime binders here...\n+                                if value.has_escaping_bound_vars() {\n+                                    return false;\n+                                }\n                                 infcx\n                                     .can_eq(\n                                         ty::ParamEnv::empty(),\n                                         impl_.self_ty(),\n-                                        tcx.replace_escaping_bound_vars_uncached(qself_ty, ty::fold::FnMutDelegate {\n-                                            regions: &mut |_| tcx.lifetimes.re_erased,\n-                                            types: &mut |bv| tcx.mk_placeholder(ty::PlaceholderType {\n-                                                universe,\n-                                                bound: bv,\n-                                            }),\n-                                            consts: &mut |bv, ty| tcx.mk_const(ty::PlaceholderConst {\n-                                                universe,\n-                                                bound: bv,\n-                                            }, ty),\n-                                        })\n+                                        value,\n                                     )\n                             })\n                             && tcx.impl_polarity(impl_def_id) != ty::ImplPolarity::Negative\n@@ -2580,7 +2578,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 tcx.all_impls(trait_def_id)\n                     .filter(|impl_def_id| {\n                         // Consider only accessible traits\n-                        tcx.visibility(*impl_def_id).is_accessible_from(self.item_def_id(), tcx)\n+                        tcx.visibility(trait_def_id).is_accessible_from(self.item_def_id(), tcx)\n                             && tcx.impl_polarity(impl_def_id) != ty::ImplPolarity::Negative\n                     })\n                     .filter_map(|impl_def_id| tcx.impl_trait_ref(impl_def_id))"}, {"sha": "284b099e7bc71e2ec9297b29d6891cf6aebc6a5b", "filename": "compiler/rustc_hir_analysis/src/bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_analysis%2Fsrc%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_analysis%2Fsrc%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fbounds.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -58,7 +58,7 @@ impl<'tcx> Bounds<'tcx> {\n     pub fn push_sized(&mut self, tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span) {\n         let sized_def_id = tcx.require_lang_item(LangItem::Sized, Some(span));\n         let trait_ref = ty::Binder::dummy(tcx.mk_trait_ref(sized_def_id, [ty]));\n-        // Preferrable to put this obligation first, since we report better errors for sized ambiguity.\n+        // Preferable to put this obligation first, since we report better errors for sized ambiguity.\n         self.predicates.insert(0, (trait_ref.without_const().to_predicate(tcx), span));\n     }\n "}, {"sha": "0bb98fdf2a23e157068cc496dd304276ae9180e4", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -452,11 +452,8 @@ fn check_opaque_meets_bounds<'tcx>(\n         hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => {}\n         // Can have different predicates to their defining use\n         hir::OpaqueTyOrigin::TyAlias => {\n-            let outlives_environment = OutlivesEnvironment::new(param_env);\n-            let _ = infcx.err_ctxt().check_region_obligations_and_report_errors(\n-                defining_use_anchor,\n-                &outlives_environment,\n-            );\n+            let outlives_env = OutlivesEnvironment::new(param_env);\n+            let _ = ocx.resolve_regions_and_report_errors(defining_use_anchor, &outlives_env);\n         }\n     }\n     // Clean up after ourselves"}, {"sha": "5d119a7737a4cf4d740a34685300963ba6058cab", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 11, "deletions": 29, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -332,10 +332,6 @@ fn compare_method_predicate_entailment<'tcx>(\n         param_env,\n         infcx.implied_bounds_tys(param_env, impl_m_def_id, wf_tys.clone()),\n     );\n-    infcx.process_registered_region_obligations(\n-        outlives_env.region_bound_pairs(),\n-        outlives_env.param_env,\n-    );\n     let errors = infcx.resolve_regions(&outlives_env);\n     if !errors.is_empty() {\n         // FIXME(compiler-errors): This can be simplified when IMPLIED_BOUNDS_ENTAILMENT\n@@ -722,18 +718,18 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n         return Err(reported);\n     }\n \n+    let collected_types = collector.types;\n+\n     // Finally, resolve all regions. This catches wily misuses of\n     // lifetime parameters.\n-    let outlives_environment = OutlivesEnvironment::with_bounds(\n+    let outlives_env = OutlivesEnvironment::with_bounds(\n         param_env,\n         infcx.implied_bounds_tys(param_env, impl_m_def_id, wf_tys),\n     );\n-    infcx\n-        .err_ctxt()\n-        .check_region_obligations_and_report_errors(impl_m_def_id, &outlives_environment)?;\n+    ocx.resolve_regions_and_report_errors(impl_m_def_id, &outlives_env)?;\n \n     let mut collected_tys = FxHashMap::default();\n-    for (def_id, (ty, substs)) in collector.types {\n+    for (def_id, (ty, substs)) in collected_types {\n         match infcx.fully_resolve(ty) {\n             Ok(ty) => {\n                 // `ty` contains free regions that we created earlier while liberating the\n@@ -1742,11 +1738,8 @@ pub(super) fn compare_impl_const_raw(\n         return Err(infcx.err_ctxt().report_fulfillment_errors(&errors));\n     }\n \n-    let outlives_environment = OutlivesEnvironment::new(param_env);\n-    infcx\n-        .err_ctxt()\n-        .check_region_obligations_and_report_errors(impl_const_item_def, &outlives_environment)?;\n-    Ok(())\n+    let outlives_env = OutlivesEnvironment::new(param_env);\n+    ocx.resolve_regions_and_report_errors(impl_const_item_def, &outlives_env)\n }\n \n pub(super) fn compare_impl_ty<'tcx>(\n@@ -1845,13 +1838,8 @@ fn compare_type_predicate_entailment<'tcx>(\n \n     // Finally, resolve all regions. This catches wily misuses of\n     // lifetime parameters.\n-    let outlives_environment = OutlivesEnvironment::new(param_env);\n-    infcx.err_ctxt().check_region_obligations_and_report_errors(\n-        impl_ty.def_id.expect_local(),\n-        &outlives_environment,\n-    )?;\n-\n-    Ok(())\n+    let outlives_env = OutlivesEnvironment::new(param_env);\n+    ocx.resolve_regions_and_report_errors(impl_ty_def_id, &outlives_env)\n }\n \n /// Validate that `ProjectionCandidate`s created for this associated type will\n@@ -2063,14 +2051,8 @@ pub(super) fn check_type_bounds<'tcx>(\n     // Finally, resolve all regions. This catches wily misuses of\n     // lifetime parameters.\n     let implied_bounds = infcx.implied_bounds_tys(param_env, impl_ty_def_id, assumed_wf_types);\n-    let outlives_environment = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n-\n-    infcx.err_ctxt().check_region_obligations_and_report_errors(\n-        impl_ty.def_id.expect_local(),\n-        &outlives_environment,\n-    )?;\n-\n-    Ok(())\n+    let outlives_env = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n+    ocx.resolve_regions_and_report_errors(impl_ty_def_id, &outlives_env)\n }\n \n fn assoc_item_kind_str(impl_item: &ty::AssocItem) -> &'static str {"}, {"sha": "53197bc849106c44917b26b9a5c907634d5c9666", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -114,11 +114,9 @@ pub(super) fn enter_wf_checking_ctxt<'tcx, F>(\n         return;\n     }\n \n-    let outlives_environment = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n+    let outlives_env = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n \n-    let _ = infcx\n-        .err_ctxt()\n-        .check_region_obligations_and_report_errors(body_def_id, &outlives_environment);\n+    let _ = wfcx.ocx.resolve_regions_and_report_errors(body_def_id, &outlives_env);\n }\n \n fn check_well_formed(tcx: TyCtxt<'_>, def_id: hir::OwnerId) {\n@@ -680,12 +678,7 @@ fn resolve_regions_with_wf_tys<'tcx>(\n \n     add_constraints(&infcx, region_bound_pairs);\n \n-    infcx.process_registered_region_obligations(\n-        outlives_environment.region_bound_pairs(),\n-        param_env,\n-    );\n     let errors = infcx.resolve_regions(&outlives_environment);\n-\n     debug!(?errors, \"errors\");\n \n     // If we were able to prove that the type outlives the region without"}, {"sha": "0f40cca9427b4500c02a03a8c19bbb785a1798c9", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -354,9 +354,7 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDef\n \n                 // Finally, resolve all regions.\n                 let outlives_env = OutlivesEnvironment::new(param_env);\n-                let _ = infcx\n-                    .err_ctxt()\n-                    .check_region_obligations_and_report_errors(impl_did, &outlives_env);\n+                let _ = ocx.resolve_regions_and_report_errors(impl_did, &outlives_env);\n             }\n         }\n         _ => {\n@@ -592,7 +590,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: LocalDefId) -> Coe\n \n     // Finally, resolve all regions.\n     let outlives_env = OutlivesEnvironment::new(param_env);\n-    let _ = infcx.err_ctxt().check_region_obligations_and_report_errors(impl_did, &outlives_env);\n+    let _ = ocx.resolve_regions_and_report_errors(impl_did, &outlives_env);\n \n     CoerceUnsizedInfo { custom_kind: kind }\n }"}, {"sha": "cbbaf8f857dac3ef82b0250d81a933f5d1ba293e", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -64,6 +64,7 @@ pub fn provide(providers: &mut Providers) {\n         predicates_defined_on,\n         explicit_predicates_of: predicates_of::explicit_predicates_of,\n         super_predicates_of: predicates_of::super_predicates_of,\n+        implied_predicates_of: predicates_of::implied_predicates_of,\n         super_predicates_that_define_assoc_type:\n             predicates_of::super_predicates_that_define_assoc_type,\n         trait_explicit_predicates_and_bounds: predicates_of::trait_explicit_predicates_and_bounds,\n@@ -596,6 +597,7 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n         }\n         hir::ItemKind::TraitAlias(..) => {\n             tcx.ensure().generics_of(def_id);\n+            tcx.at(it.span).implied_predicates_of(def_id);\n             tcx.at(it.span).super_predicates_of(def_id);\n             tcx.ensure().predicates_of(def_id);\n         }"}, {"sha": "9358ed612921f5e76dce6c7d8df516ed93017e24", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 81, "deletions": 32, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -125,7 +125,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::Gen\n     // on a trait we need to add in the supertrait bounds and bounds found on\n     // associated types.\n     if let Some(_trait_ref) = is_trait {\n-        predicates.extend(tcx.super_predicates_of(def_id).predicates.iter().cloned());\n+        predicates.extend(tcx.implied_predicates_of(def_id).predicates.iter().cloned());\n     }\n \n     // In default impls, we can assume that the self type implements\n@@ -534,31 +534,62 @@ pub(super) fn explicit_predicates_of<'tcx>(\n     }\n }\n \n+#[derive(Copy, Clone, Debug)]\n+pub enum PredicateFilter {\n+    /// All predicates may be implied by the trait\n+    All,\n+\n+    /// Only traits that reference `Self: ..` are implied by the trait\n+    SelfOnly,\n+\n+    /// Only traits that reference `Self: ..` and define an associated type\n+    /// with the given ident are implied by the trait\n+    SelfThatDefines(Ident),\n+}\n+\n /// Ensures that the super-predicates of the trait with a `DefId`\n /// of `trait_def_id` are converted and stored. This also ensures that\n /// the transitive super-predicates are converted.\n pub(super) fn super_predicates_of(\n     tcx: TyCtxt<'_>,\n     trait_def_id: LocalDefId,\n ) -> ty::GenericPredicates<'_> {\n-    tcx.super_predicates_that_define_assoc_type((trait_def_id.to_def_id(), None))\n+    implied_predicates_with_filter(tcx, trait_def_id.to_def_id(), PredicateFilter::SelfOnly)\n+}\n+\n+pub(super) fn super_predicates_that_define_assoc_type(\n+    tcx: TyCtxt<'_>,\n+    (trait_def_id, assoc_name): (DefId, Ident),\n+) -> ty::GenericPredicates<'_> {\n+    implied_predicates_with_filter(tcx, trait_def_id, PredicateFilter::SelfThatDefines(assoc_name))\n+}\n+\n+pub(super) fn implied_predicates_of(\n+    tcx: TyCtxt<'_>,\n+    trait_def_id: LocalDefId,\n+) -> ty::GenericPredicates<'_> {\n+    if tcx.is_trait_alias(trait_def_id.to_def_id()) {\n+        implied_predicates_with_filter(tcx, trait_def_id.to_def_id(), PredicateFilter::All)\n+    } else {\n+        tcx.super_predicates_of(trait_def_id)\n+    }\n }\n \n /// Ensures that the super-predicates of the trait with a `DefId`\n /// of `trait_def_id` are converted and stored. This also ensures that\n /// the transitive super-predicates are converted.\n-pub(super) fn super_predicates_that_define_assoc_type(\n+pub(super) fn implied_predicates_with_filter(\n     tcx: TyCtxt<'_>,\n-    (trait_def_id, assoc_name): (DefId, Option<Ident>),\n+    trait_def_id: DefId,\n+    filter: PredicateFilter,\n ) -> ty::GenericPredicates<'_> {\n     let Some(trait_def_id) = trait_def_id.as_local() else {\n         // if `assoc_name` is None, then the query should've been redirected to an\n         // external provider\n-        assert!(assoc_name.is_some());\n+        assert!(matches!(filter, PredicateFilter::SelfThatDefines(_)));\n         return tcx.super_predicates_of(trait_def_id);\n     };\n \n-    debug!(\"local trait\");\n     let trait_hir_id = tcx.hir().local_def_id_to_hir_id(trait_def_id);\n \n     let Node::Item(item) = tcx.hir().get(trait_hir_id) else {\n@@ -573,48 +604,66 @@ pub(super) fn super_predicates_that_define_assoc_type(\n \n     let icx = ItemCtxt::new(tcx, trait_def_id);\n \n-    // Convert the bounds that follow the colon, e.g., `Bar + Zed` in `trait Foo: Bar + Zed`.\n     let self_param_ty = tcx.types.self_param;\n-    let superbounds1 = if let Some(assoc_name) = assoc_name {\n-        icx.astconv().compute_bounds_that_match_assoc_type(self_param_ty, bounds, assoc_name)\n-    } else {\n-        icx.astconv().compute_bounds(self_param_ty, bounds)\n+    let (superbounds, where_bounds_that_match) = match filter {\n+        PredicateFilter::All => (\n+            // Convert the bounds that follow the colon (or equal in trait aliases)\n+            icx.astconv().compute_bounds(self_param_ty, bounds),\n+            // Also include all where clause bounds\n+            icx.type_parameter_bounds_in_generics(\n+                generics,\n+                item.owner_id.def_id,\n+                self_param_ty,\n+                OnlySelfBounds(false),\n+                None,\n+            ),\n+        ),\n+        PredicateFilter::SelfOnly => (\n+            // Convert the bounds that follow the colon (or equal in trait aliases)\n+            icx.astconv().compute_bounds(self_param_ty, bounds),\n+            // Include where clause bounds for `Self`\n+            icx.type_parameter_bounds_in_generics(\n+                generics,\n+                item.owner_id.def_id,\n+                self_param_ty,\n+                OnlySelfBounds(true),\n+                None,\n+            ),\n+        ),\n+        PredicateFilter::SelfThatDefines(assoc_name) => (\n+            // Convert the bounds that follow the colon (or equal) that reference the associated name\n+            icx.astconv().compute_bounds_that_match_assoc_type(self_param_ty, bounds, assoc_name),\n+            // Include where clause bounds for `Self` that reference the associated name\n+            icx.type_parameter_bounds_in_generics(\n+                generics,\n+                item.owner_id.def_id,\n+                self_param_ty,\n+                OnlySelfBounds(true),\n+                Some(assoc_name),\n+            ),\n+        ),\n     };\n \n-    let superbounds1 = superbounds1.predicates();\n-\n-    // Convert any explicit superbounds in the where-clause,\n-    // e.g., `trait Foo where Self: Bar`.\n-    // In the case of trait aliases, however, we include all bounds in the where-clause,\n-    // so e.g., `trait Foo = where u32: PartialEq<Self>` would include `u32: PartialEq<Self>`\n-    // as one of its \"superpredicates\".\n-    let is_trait_alias = tcx.is_trait_alias(trait_def_id.to_def_id());\n-    let superbounds2 = icx.type_parameter_bounds_in_generics(\n-        generics,\n-        item.owner_id.def_id,\n-        self_param_ty,\n-        OnlySelfBounds(!is_trait_alias),\n-        assoc_name,\n-    );\n-\n     // Combine the two lists to form the complete set of superbounds:\n-    let superbounds = &*tcx.arena.alloc_from_iter(superbounds1.into_iter().chain(superbounds2));\n-    debug!(?superbounds);\n+    let implied_bounds = &*tcx\n+        .arena\n+        .alloc_from_iter(superbounds.predicates().into_iter().chain(where_bounds_that_match));\n+    debug!(?implied_bounds);\n \n     // Now require that immediate supertraits are converted,\n     // which will, in turn, reach indirect supertraits.\n-    if assoc_name.is_none() {\n+    if matches!(filter, PredicateFilter::SelfOnly) {\n         // Now require that immediate supertraits are converted,\n         // which will, in turn, reach indirect supertraits.\n-        for &(pred, span) in superbounds {\n+        for &(pred, span) in implied_bounds {\n             debug!(\"superbound: {:?}\", pred);\n             if let ty::PredicateKind::Clause(ty::Clause::Trait(bound)) = pred.kind().skip_binder() {\n                 tcx.at(span).super_predicates_of(bound.def_id());\n             }\n         }\n     }\n \n-    ty::GenericPredicates { parent: None, predicates: superbounds }\n+    ty::GenericPredicates { parent: None, predicates: implied_bounds }\n }\n \n /// Returns the predicates defined on `item_def_id` of the form"}, {"sha": "e758fe95d9c294248759d03c532858c539a47bbd", "filename": "compiler/rustc_hir_analysis/src/collect/resolve_bound_vars.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1749,8 +1749,7 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n             if trait_defines_associated_type_named(def_id) {\n                 break Some(bound_vars.into_iter().collect());\n             }\n-            let predicates =\n-                tcx.super_predicates_that_define_assoc_type((def_id, Some(assoc_name)));\n+            let predicates = tcx.super_predicates_that_define_assoc_type((def_id, assoc_name));\n             let obligations = predicates.predicates.iter().filter_map(|&(pred, _)| {\n                 let bound_predicate = pred.kind();\n                 match bound_predicate.skip_binder() {"}, {"sha": "c173bd913a84c416d807f6ac77f2ccee5d58786e", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -8,10 +8,7 @@ use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::print::with_forced_trimmed_paths;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::util::IntTypeExt;\n-use rustc_middle::ty::{\n-    self, ImplTraitInTraitData, IsSuggestable, Ty, TyCtxt, TypeFolder, TypeSuperFoldable,\n-    TypeVisitableExt,\n-};\n+use rustc_middle::ty::{self, ImplTraitInTraitData, IsSuggestable, Ty, TyCtxt, TypeVisitableExt};\n use rustc_span::symbol::Ident;\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -874,28 +871,6 @@ fn infer_placeholder_type<'a>(\n     item_ident: Ident,\n     kind: &'static str,\n ) -> Ty<'a> {\n-    // Attempts to make the type nameable by turning FnDefs into FnPtrs.\n-    struct MakeNameable<'tcx> {\n-        tcx: TyCtxt<'tcx>,\n-    }\n-\n-    impl<'tcx> TypeFolder<TyCtxt<'tcx>> for MakeNameable<'tcx> {\n-        fn interner(&self) -> TyCtxt<'tcx> {\n-            self.tcx\n-        }\n-\n-        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-            let ty = match *ty.kind() {\n-                ty::FnDef(def_id, substs) => {\n-                    self.tcx.mk_fn_ptr(self.tcx.fn_sig(def_id).subst(self.tcx, substs))\n-                }\n-                _ => ty,\n-            };\n-\n-            ty.super_fold_with(self)\n-        }\n-    }\n-\n     let ty = tcx.diagnostic_only_typeck(def_id).node_type(body_id.hir_id);\n \n     // If this came from a free `const` or `static mut?` item,"}, {"sha": "eb2fc395223ed5f4c28728d834eae654e722b95b", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -180,8 +180,7 @@ fn get_impl_substs(\n \n     let implied_bounds = infcx.implied_bounds_tys(param_env, impl1_def_id, assumed_wf_types);\n     let outlives_env = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n-    let _ =\n-        infcx.err_ctxt().check_region_obligations_and_report_errors(impl1_def_id, &outlives_env);\n+    let _ = ocx.resolve_regions_and_report_errors(impl1_def_id, &outlives_env);\n     let Ok(impl2_substs) = infcx.fully_resolve(impl2_substs) else {\n         let span = tcx.def_span(impl1_def_id);\n         tcx.sess.emit_err(SubstsOnOverriddenImpl { span });"}, {"sha": "8c2495e1dd8c51dc6da052d86071aac955f3c081", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -210,7 +210,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // and we want to keep inference generally in the same order of\n             // the registered obligations.\n             predicates.rev(),\n-        ) {\n+        )\n+        // We only care about self bounds\n+        .filter_only_self()\n+        {\n             debug!(?pred);\n             let bound_predicate = pred.kind();\n "}, {"sha": "a4c3be1d1774567d4b34a8e18affd0723ee9aa78", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -308,7 +308,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let rcvr_ty = self.node_ty(rcvr.hir_id);\n                 // Get the evaluated type *after* calling the method call, so that the influence\n                 // of the arguments can be reflected in the receiver type. The receiver\n-                // expression has the type *before* theis analysis is done.\n+                // expression has the type *before* this analysis is done.\n                 let ty = match self.lookup_probe_for_diagnostic(\n                     segment.ident,\n                     rcvr_ty,"}, {"sha": "6ffa0134f3d55f74a194321d12cd77dd90cf4572", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -120,7 +120,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ty\n     }\n \n-    pub(super) fn check_expr_coercable_to_type(\n+    pub(super) fn check_expr_coercible_to_type(\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n         expected: Ty<'tcx>,\n@@ -1128,7 +1128,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         };\n \n-        // This is (basically) inlined `check_expr_coercable_to_type`, but we want\n+        // This is (basically) inlined `check_expr_coercible_to_type`, but we want\n         // to suggest an additional fixup here in `suggest_deref_binop`.\n         let rhs_ty = self.check_expr_with_hint(&rhs, lhs_ty);\n         if let (_, Some(mut diag)) =\n@@ -1401,7 +1401,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let (element_ty, t) = match uty {\n             Some(uty) => {\n-                self.check_expr_coercable_to_type(&element, uty, None);\n+                self.check_expr_coercible_to_type(&element, uty, None);\n                 (uty, uty)\n             }\n             None => {\n@@ -1478,7 +1478,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let elt_ts_iter = elts.iter().enumerate().map(|(i, e)| match flds {\n             Some(fs) if i < fs.len() => {\n                 let ety = fs[i];\n-                self.check_expr_coercable_to_type(&e, ety, None);\n+                self.check_expr_coercible_to_type(&e, ety, None);\n                 ety\n             }\n             _ => self.check_expr_with_expectation(&e, NoExpectation),\n@@ -2869,7 +2869,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Ty<'tcx> {\n         match self.resume_yield_tys {\n             Some((resume_ty, yield_ty)) => {\n-                self.check_expr_coercable_to_type(&value, yield_ty, None);\n+                self.check_expr_coercible_to_type(&value, yield_ty, None);\n \n                 resume_ty\n             }\n@@ -2878,7 +2878,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // information. Hence, we check the source of the yield expression here and check its\n             // value's type against `()` (this check should always hold).\n             None if src.is_await() => {\n-                self.check_expr_coercable_to_type(&value, self.tcx.mk_unit(), None);\n+                self.check_expr_coercible_to_type(&value, self.tcx.mk_unit(), None);\n                 self.tcx.mk_unit()\n             }\n             _ => {"}, {"sha": "f736f7a96207e204dc72fccb77c459fe9e9e5a09", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -578,7 +578,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     #[instrument(skip(self), level = \"debug\")]\n     pub(in super::super) fn report_ambiguity_errors(&self) {\n-        let mut errors = self.fulfillment_cx.borrow_mut().collect_remaining_errors();\n+        let mut errors = self.fulfillment_cx.borrow_mut().collect_remaining_errors(self);\n \n         if !errors.is_empty() {\n             self.adjust_fulfillment_errors_for_expr_obligation(&mut errors);"}, {"sha": "f879ccbb3af1124b75c85ffce6fc78f65e971b47", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/adjust_fulfillment_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -78,7 +78,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Finally, for ambiguity-related errors, we actually want to look\n         // for a parameter that is the source of the inference type left\n         // over in this predicate.\n-        if let traits::FulfillmentErrorCode::CodeAmbiguity = error.code {\n+        if let traits::FulfillmentErrorCode::CodeAmbiguity { .. } = error.code {\n             fallback_param_to_point_at = None;\n             self_param_to_point_at = None;\n             param_to_point_at =\n@@ -466,7 +466,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// obligation. Hence we refine the `expr` \"outwards-in\" and bail at the first kind of expression/impl we don't recognize.\n     ///\n     /// This function returns a `Result<&Expr, &Expr>` - either way, it returns the `Expr` whose span should be\n-    /// reported as an error. If it is `Ok`, then it means it refined successfull. If it is `Err`, then it may be\n+    /// reported as an error. If it is `Ok`, then it means it refined successful. If it is `Err`, then it may be\n     /// only a partial success - but it cannot be refined even further.\n     fn blame_specific_expr_if_possible_for_derived_predicate_obligation(\n         &self,\n@@ -534,7 +534,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// - in_ty: `(Option<Vec<T>, bool)`\n     /// we would drill until we arrive at `vec![1, 2, 3]`.\n     ///\n-    /// If successful, we return `Ok(refined_expr)`. If unsuccesful, we return `Err(partially_refined_expr`),\n+    /// If successful, we return `Ok(refined_expr)`. If unsuccessful, we return `Err(partially_refined_expr`),\n     /// which will go as far as possible. For example, given `(foo(), false)` instead, we would drill to\n     /// `foo()` and then return `Err(\"foo()\")`.\n     ///"}, {"sha": "a009ae5d44eb16d71b53378c0da1653d9cda4df9", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -768,7 +768,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let (provided_ty, provided_span) = provided_arg_tys[*provided_idx];\n             let trace =\n                 mk_trace(provided_span, formal_and_expected_inputs[*expected_idx], provided_ty);\n-            if !matches!(trace.cause.as_failure_code(*e), FailureCode::Error0308(_)) {\n+            if !matches!(trace.cause.as_failure_code(*e), FailureCode::Error0308) {\n                 self.err_ctxt().report_and_explain_type_error(trace, *e).emit();\n                 return true;\n             }\n@@ -1191,11 +1191,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // index position where it *should have been*, which is *after* the previous one.\n             if let Some(provided_idx) = provided_idx {\n                 prev = provided_idx.index() as i64;\n+                continue;\n             }\n             let idx = ProvidedIdx::from_usize((prev + 1) as usize);\n-            if let None = provided_idx\n-                && let Some((_, arg_span)) = provided_arg_tys.get(idx)\n-            {\n+            if let Some((_, arg_span)) = provided_arg_tys.get(idx) {\n+                prev += 1;\n                 // There is a type that was *not* found anywhere, so it isn't a move, but a\n                 // replacement and we look at what type it should have been. This will allow us\n                 // To suggest a multipart suggestion when encountering `foo(1, \"\")` where the def\n@@ -1413,7 +1413,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.demand_eqtype(init.span, local_ty, init_ty);\n             init_ty\n         } else {\n-            self.check_expr_coercable_to_type(init, local_ty, None)\n+            self.check_expr_coercible_to_type(init, local_ty, None)\n         }\n     }\n "}, {"sha": "f3971080443332490a928ac749f293e8847f07a1", "filename": "compiler/rustc_hir_typeck/src/generator_interior/mod.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -239,8 +239,7 @@ pub fn resolve_interior<'a, 'tcx>(\n             // typeck had previously found constraints that would cause them to be related.\n \n             let mut counter = 0;\n-            let mut mk_bound_region = |span| {\n-                let kind = ty::BrAnon(span);\n+            let mut mk_bound_region = |kind| {\n                 let var = ty::BoundVar::from_u32(counter);\n                 counter += 1;\n                 ty::BoundRegion { var, kind }\n@@ -252,24 +251,23 @@ pub fn resolve_interior<'a, 'tcx>(\n                         let origin = fcx.region_var_origin(vid);\n                         match origin {\n                             RegionVariableOrigin::EarlyBoundRegion(span, _) => {\n-                                mk_bound_region(Some(span))\n+                                mk_bound_region(ty::BrAnon(Some(span)))\n                             }\n-                            _ => mk_bound_region(None),\n+                            _ => mk_bound_region(ty::BrAnon(None)),\n                         }\n                     }\n-                    // FIXME: these should use `BrNamed`\n                     ty::ReEarlyBound(region) => {\n-                        mk_bound_region(Some(fcx.tcx.def_span(region.def_id)))\n+                        mk_bound_region(ty::BrNamed(region.def_id, region.name))\n                     }\n                     ty::ReLateBound(_, ty::BoundRegion { kind, .. })\n                     | ty::ReFree(ty::FreeRegion { bound_region: kind, .. }) => match kind {\n-                        ty::BoundRegionKind::BrAnon(span) => mk_bound_region(span),\n-                        ty::BoundRegionKind::BrNamed(def_id, _) => {\n-                            mk_bound_region(Some(fcx.tcx.def_span(def_id)))\n+                        ty::BoundRegionKind::BrAnon(span) => mk_bound_region(ty::BrAnon(span)),\n+                        ty::BoundRegionKind::BrNamed(def_id, sym) => {\n+                            mk_bound_region(ty::BrNamed(def_id, sym))\n                         }\n-                        ty::BoundRegionKind::BrEnv => mk_bound_region(None),\n+                        ty::BoundRegionKind::BrEnv => mk_bound_region(ty::BrAnon(None)),\n                     },\n-                    _ => mk_bound_region(None),\n+                    _ => mk_bound_region(ty::BrAnon(None)),\n                 };\n                 let r = fcx.tcx.mk_re_late_bound(current_depth, br);\n                 r\n@@ -293,10 +291,7 @@ pub fn resolve_interior<'a, 'tcx>(\n             type_causes,\n             FnMutDelegate {\n                 regions: &mut |br| {\n-                    let kind = match br.kind {\n-                        ty::BrAnon(span) => ty::BrAnon(span),\n-                        _ => br.kind,\n-                    };\n+                    let kind = br.kind;\n                     let var = ty::BoundVar::from_usize(bound_vars.len());\n                     bound_vars.push(ty::BoundVariableKind::Region(kind));\n                     counter += 1;"}, {"sha": "45890abad92e39ce3549bfcd56adfb10836136da", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -280,7 +280,7 @@ fn typeck_with_fallback<'tcx>(\n         // Gather locals in statics (because of block expressions).\n         GatherLocalsVisitor::new(&fcx).visit_body(body);\n \n-        fcx.check_expr_coercable_to_type(&body.value, expected_type, None);\n+        fcx.check_expr_coercible_to_type(&body.value, expected_type, None);\n \n         fcx.write_ty(id, expected_type);\n     };"}, {"sha": "4fd778910bacbc53611eb21553cc7c8f6e1e3c11", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1531,23 +1531,18 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n                     // Convert the bounds into obligations.\n                     let impl_obligations = traits::predicates_for_generics(\n-                        |_idx, span| {\n-                            let misc = traits::ObligationCause::misc(span, self.body_id);\n-                            let parent_trait_pred = ty::Binder::dummy(ty::TraitPredicate {\n-                                trait_ref: ty::TraitRef::from_method(self.tcx, impl_def_id, substs),\n-                                constness: ty::BoundConstness::NotConst,\n-                                polarity: ty::ImplPolarity::Positive,\n-                            });\n-                            misc.derived_cause(parent_trait_pred, |derived| {\n-                                traits::ImplDerivedObligation(Box::new(\n-                                    traits::ImplDerivedObligationCause {\n-                                        derived,\n-                                        impl_or_alias_def_id: impl_def_id,\n-                                        impl_def_predicate_index: None,\n-                                        span,\n-                                    },\n-                                ))\n-                            })\n+                        |idx, span| {\n+                            let code = if span.is_dummy() {\n+                                traits::ExprItemObligation(impl_def_id, self.scope_expr_id, idx)\n+                            } else {\n+                                traits::ExprBindingObligation(\n+                                    impl_def_id,\n+                                    span,\n+                                    self.scope_expr_id,\n+                                    idx,\n+                                )\n+                            };\n+                            ObligationCause::new(self.span, self.body_id, code)\n                         },\n                         self.param_env,\n                         impl_bounds,"}, {"sha": "900a6fa0d8db324932385deb5aa7f9af528bf421", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -300,7 +300,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         // We could pass the file for long types into these two, but it isn't strictly necessary\n-        // given how targetted they are.\n+        // given how targeted they are.\n         if self.suggest_wrapping_range_with_parens(\n             tcx,\n             rcvr_ty,\n@@ -661,19 +661,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Find all the requirements that come from a local `impl` block.\n             let mut skip_list: FxHashSet<_> = Default::default();\n             let mut spanned_predicates = FxHashMap::default();\n-            for (p, parent_p, impl_def_id, cause) in unsatisfied_predicates\n-                .iter()\n-                .filter_map(|(p, parent, c)| c.as_ref().map(|c| (p, parent, c)))\n-                .filter_map(|(p, parent, c)| match c.code() {\n-                    ObligationCauseCode::ImplDerivedObligation(data)\n-                        if matches!(p.kind().skip_binder(), ty::PredicateKind::Clause(_)) =>\n-                    {\n-                        Some((p, parent, data.impl_or_alias_def_id, data))\n+            for (p, parent_p, cause) in unsatisfied_predicates {\n+                // Extract the predicate span and parent def id of the cause,\n+                // if we have one.\n+                let (item_def_id, cause_span) = match cause.as_ref().map(|cause| cause.code()) {\n+                    Some(ObligationCauseCode::ImplDerivedObligation(data)) => {\n+                        (data.impl_or_alias_def_id, data.span)\n                     }\n-                    _ => None,\n-                })\n-            {\n-                match self.tcx.hir().get_if_local(impl_def_id) {\n+                    Some(\n+                        ObligationCauseCode::ExprBindingObligation(def_id, span, _, _)\n+                        | ObligationCauseCode::BindingObligation(def_id, span),\n+                    ) => (*def_id, *span),\n+                    _ => continue,\n+                };\n+\n+                // Don't point out the span of `WellFormed` predicates.\n+                if !matches!(p.kind().skip_binder(), ty::PredicateKind::Clause(_)) {\n+                    continue;\n+                };\n+\n+                match self.tcx.hir().get_if_local(item_def_id) {\n                     // Unmet obligation comes from a `derive` macro, point at it once to\n                     // avoid multiple span labels pointing at the same place.\n                     Some(Node::Item(hir::Item {\n@@ -718,7 +725,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 }\n                             });\n                         for param in generics.params {\n-                            if param.span == cause.span && sized_pred {\n+                            if param.span == cause_span && sized_pred {\n                                 let (sp, sugg) = match param.colon_span {\n                                     Some(sp) => (sp.shrink_to_hi(), \" ?Sized +\"),\n                                     None => (param.span.shrink_to_hi(), \": ?Sized\"),\n@@ -741,9 +748,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             (FxHashSet::default(), FxHashSet::default(), Vec::new())\n                         });\n                         entry.2.push(p);\n-                        if cause.span != *item_span {\n-                            entry.0.insert(cause.span);\n-                            entry.1.insert((cause.span, \"unsatisfied trait bound introduced here\"));\n+                        if cause_span != *item_span {\n+                            entry.0.insert(cause_span);\n+                            entry.1.insert((cause_span, \"unsatisfied trait bound introduced here\"));\n                         } else {\n                             if let Some(trait_ref) = of_trait {\n                                 entry.0.insert(trait_ref.path.span);\n@@ -775,9 +782,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         let entry = entry.or_insert_with(|| {\n                             (FxHashSet::default(), FxHashSet::default(), Vec::new())\n                         });\n-                        entry.0.insert(cause.span);\n+                        entry.0.insert(cause_span);\n                         entry.1.insert((ident.span, \"\"));\n-                        entry.1.insert((cause.span, \"unsatisfied trait bound introduced here\"));\n+                        entry.1.insert((cause_span, \"unsatisfied trait bound introduced here\"));\n                         entry.2.push(p);\n                     }\n                     Some(node) => unreachable!(\"encountered `{node:?}`\"),"}, {"sha": "a52c94cb00c531621f9834b66a666d688a17bc5c", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -12,9 +12,7 @@ use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n };\n use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_middle::ty::{\n-    self, IsSuggestable, Ty, TyCtxt, TypeFolder, TypeSuperFoldable, TypeVisitableExt,\n-};\n+use rustc_middle::ty::{self, IsSuggestable, Ty, TyCtxt, TypeVisitableExt};\n use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Ident};\n@@ -103,9 +101,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match BinOpCategory::from(op) {\n             BinOpCategory::Shortcircuit => {\n                 // && and || are a simple case.\n-                self.check_expr_coercable_to_type(lhs_expr, tcx.types.bool, None);\n+                self.check_expr_coercible_to_type(lhs_expr, tcx.types.bool, None);\n                 let lhs_diverges = self.diverges.get();\n-                self.check_expr_coercable_to_type(rhs_expr, tcx.types.bool, None);\n+                self.check_expr_coercible_to_type(rhs_expr, tcx.types.bool, None);\n \n                 // Depending on the LHS' value, the RHS can never execute.\n                 self.diverges.set(lhs_diverges);\n@@ -255,7 +253,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n \n         // see `NB` above\n-        let rhs_ty = self.check_expr_coercable_to_type(rhs_expr, rhs_ty_var, Some(lhs_expr));\n+        let rhs_ty = self.check_expr_coercible_to_type(rhs_expr, rhs_ty_var, Some(lhs_expr));\n         let rhs_ty = self.resolve_vars_with_obligations(rhs_ty);\n \n         let return_ty = match result {\n@@ -965,21 +963,3 @@ fn is_builtin_binop<'tcx>(lhs: Ty<'tcx>, rhs: Ty<'tcx>, op: hir::BinOp) -> bool\n         }\n     }\n }\n-\n-struct TypeParamEraser<'a, 'tcx>(&'a FnCtxt<'a, 'tcx>, Span);\n-\n-impl<'tcx> TypeFolder<TyCtxt<'tcx>> for TypeParamEraser<'_, 'tcx> {\n-    fn interner(&self) -> TyCtxt<'tcx> {\n-        self.0.tcx\n-    }\n-\n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        match ty.kind() {\n-            ty::Param(_) => self.0.next_ty_var(TypeVariableOrigin {\n-                kind: TypeVariableOriginKind::MiscVariable,\n-                span: self.1,\n-            }),\n-            _ => ty.super_fold_with(self),\n-        }\n-    }\n-}"}, {"sha": "c8998ea91bfe1fdfe457e5ef7a9b54c31f12f956", "filename": "compiler/rustc_infer/messages.ftl", "status": "modified", "additions": 45, "deletions": 2, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_infer%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_infer%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fmessages.ftl?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -163,7 +163,6 @@ infer_region_explanation = {$pref_kind ->\n     [as_defined] the lifetime `{$desc_arg}` as defined here\n     [as_defined_anon] the anonymous lifetime as defined here\n     [defined_here] the anonymous lifetime defined here\n-    [anon_num_here] the anonymous lifetime #{$desc_num_arg} defined here\n     [defined_here_reg] the lifetime `{$desc_arg}` as defined here\n }{$suff_kind ->\n     *[should_not_happen] [{$suff_kind}]\n@@ -174,7 +173,7 @@ infer_region_explanation = {$pref_kind ->\n \n infer_outlives_content = lifetime of reference outlives lifetime of borrowed content...\n infer_outlives_bound = lifetime of the source pointer does not outlive lifetime bound of the object type\n-infer_fullfill_req_lifetime = the type `{$ty}` does not fulfill the required lifetime\n+infer_fulfill_req_lifetime = the type `{$ty}` does not fulfill the required lifetime\n infer_lf_bound_not_satisfied = lifetime bound not satisfied\n infer_borrowed_too_long = a value of type `{$ty}` is borrowed for too long\n infer_ref_longer_than_data = in type `{$ty}`, reference has a longer lifetime than the data it references\n@@ -348,3 +347,47 @@ infer_prlf_known_limitation = this is a known limitation that will be removed in\n \n infer_opaque_captures_lifetime = hidden type for `{$opaque_ty}` captures lifetime that does not appear in bounds\n     .label = opaque type defined here\n+\n+infer_fps_use_ref = consider using a reference\n+infer_fps_remove_ref = consider removing the reference\n+infer_fps_cast = consider casting to a fn pointer\n+infer_fps_items_are_distinct = fn items are distinct from fn pointers\n+infer_fps_cast_both = consider casting both fn items to fn pointers using `as {$expected_sig}`\n+\n+infer_fn_uniq_types = different fn items have unique types, even if their signatures are the same\n+infer_fn_consider_casting = consider casting the fn item to a fn pointer: `{$casting}`\n+\n+infer_sarwa_option = you can convert from `&Option<T>` to `Option<&T>` using `.as_ref()`\n+infer_sarwa_result = you can convert from `&Result<T, E>` to `Result<&T, &E>` using `.as_ref()`\n+\n+infer_suggest_accessing_field = you might have meant to use field `{$name}` whose type is `{$ty}`\n+\n+infer_sbfrit_change_return_type = you could change the return type to be a boxed trait object\n+infer_sbfrit_box_return_expr = if you change the return type to expect trait objects, box the returned expressions\n+\n+infer_stp_wrap_one = try wrapping the pattern in `{$variant}`\n+infer_stp_wrap_many = try wrapping the pattern in a variant of `{$path}`\n+\n+infer_tuple_trailing_comma = use a trailing comma to create a tuple with one element\n+\n+infer_oc_method_compat = method not compatible with trait\n+infer_oc_type_compat = type not compatible with trait\n+infer_oc_const_compat = const not compatible with trait\n+infer_oc_try_compat = `?` operator has incompatible types\n+infer_oc_match_compat = `match` arms have incompatible types\n+infer_oc_if_else_different = `if` and `else` have incompatible types\n+infer_oc_no_else = `if` may be missing an `else` clause\n+infer_oc_no_diverge = `else` clause of `let...else` does not diverge\n+infer_oc_fn_main_correct_type = `main` function has wrong type\n+infer_oc_fn_start_correct_type = `#[start]` function has wrong type\n+infer_oc_intristic_correct_type = intrinsic has wrong type\n+infer_oc_method_correct_type = mismatched `self` parameter type\n+infer_oc_closure_selfref = closure/generator type that references itself\n+infer_oc_cant_coerce = cannot coerce intrinsics to function pointers\n+infer_oc_generic = mismatched types\n+\n+infer_meant_byte_literal = if you meant to write a byte literal, prefix with `b`\n+infer_meant_char_literal = if you meant to write a `char` literal, use single quotes\n+infer_meant_str_literal = if you meant to write a `str` literal, use double quotes\n+infer_consider_specifying_length = consider specifying the actual array length\n+infer_try_cannot_convert = `?` operator cannot convert from `{$found}` to `{$expected}`"}, {"sha": "65b3dd1a892b8aa3d17a40c07564d8305eb03ff8", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "modified", "additions": 380, "deletions": 15, "changes": 395, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -53,7 +53,7 @@ pub struct AnnotationRequired<'a> {\n // Copy of `AnnotationRequired` for E0283\n #[derive(Diagnostic)]\n #[diag(infer_type_annotations_needed, code = \"E0283\")]\n-pub struct AmbigousImpl<'a> {\n+pub struct AmbiguousImpl<'a> {\n     #[primary_span]\n     pub span: Span,\n     pub source_kind: &'static str,\n@@ -184,18 +184,6 @@ pub enum SourceKindMultiSuggestion<'a> {\n     },\n }\n \n-#[derive(Subdiagnostic)]\n-#[suggestion(\n-    infer_suggest_add_let_for_letchains,\n-    style = \"verbose\",\n-    applicability = \"machine-applicable\",\n-    code = \"let \"\n-)]\n-pub(crate) struct SuggAddLetForLetChains {\n-    #[primary_span]\n-    pub span: Span,\n-}\n-\n impl<'a> SourceKindMultiSuggestion<'a> {\n     pub fn new_fully_qualified(\n         span: Span,\n@@ -954,8 +942,8 @@ pub struct OutlivesBound<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(infer_fullfill_req_lifetime, code = \"E0477\")]\n-pub struct FullfillReqLifetime<'a> {\n+#[diag(infer_fulfill_req_lifetime, code = \"E0477\")]\n+pub struct FulfillReqLifetime<'a> {\n     #[primary_span]\n     pub span: Span,\n     pub ty: Ty<'a>,\n@@ -1157,3 +1145,380 @@ pub struct OpaqueCapturesLifetime<'tcx> {\n     pub opaque_ty_span: Span,\n     pub opaque_ty: Ty<'tcx>,\n }\n+\n+#[derive(Subdiagnostic)]\n+pub enum FunctionPointerSuggestion<'a> {\n+    #[suggestion(\n+        infer_fps_use_ref,\n+        code = \"&{fn_name}\",\n+        style = \"verbose\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    UseRef {\n+        #[primary_span]\n+        span: Span,\n+        #[skip_arg]\n+        fn_name: String,\n+    },\n+    #[suggestion(\n+        infer_fps_remove_ref,\n+        code = \"{fn_name}\",\n+        style = \"verbose\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    RemoveRef {\n+        #[primary_span]\n+        span: Span,\n+        #[skip_arg]\n+        fn_name: String,\n+    },\n+    #[suggestion(\n+        infer_fps_cast,\n+        code = \"&({fn_name} as {sig})\",\n+        style = \"verbose\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    CastRef {\n+        #[primary_span]\n+        span: Span,\n+        #[skip_arg]\n+        fn_name: String,\n+        #[skip_arg]\n+        sig: Binder<'a, FnSig<'a>>,\n+    },\n+    #[suggestion(\n+        infer_fps_cast,\n+        code = \"{fn_name} as {sig}\",\n+        style = \"verbose\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    Cast {\n+        #[primary_span]\n+        span: Span,\n+        #[skip_arg]\n+        fn_name: String,\n+        #[skip_arg]\n+        sig: Binder<'a, FnSig<'a>>,\n+    },\n+    #[suggestion(\n+        infer_fps_cast_both,\n+        code = \"{fn_name} as {found_sig}\",\n+        style = \"hidden\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    CastBoth {\n+        #[primary_span]\n+        span: Span,\n+        #[skip_arg]\n+        fn_name: String,\n+        #[skip_arg]\n+        found_sig: Binder<'a, FnSig<'a>>,\n+        expected_sig: Binder<'a, FnSig<'a>>,\n+    },\n+    #[suggestion(\n+        infer_fps_cast_both,\n+        code = \"&({fn_name} as {found_sig})\",\n+        style = \"hidden\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    CastBothRef {\n+        #[primary_span]\n+        span: Span,\n+        #[skip_arg]\n+        fn_name: String,\n+        #[skip_arg]\n+        found_sig: Binder<'a, FnSig<'a>>,\n+        expected_sig: Binder<'a, FnSig<'a>>,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[note(infer_fps_items_are_distinct)]\n+pub struct FnItemsAreDistinct;\n+\n+#[derive(Subdiagnostic)]\n+#[note(infer_fn_uniq_types)]\n+pub struct FnUniqTypes;\n+\n+#[derive(Subdiagnostic)]\n+#[help(infer_fn_consider_casting)]\n+pub struct FnConsiderCasting {\n+    pub casting: String,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum SuggestAsRefWhereAppropriate<'a> {\n+    #[suggestion(\n+        infer_sarwa_option,\n+        code = \"{snippet}.as_ref()\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    Option {\n+        #[primary_span]\n+        span: Span,\n+        snippet: &'a str,\n+    },\n+    #[suggestion(\n+        infer_sarwa_result,\n+        code = \"{snippet}.as_ref()\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    Result {\n+        #[primary_span]\n+        span: Span,\n+        snippet: &'a str,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum SuggestAccessingField<'a> {\n+    #[suggestion(\n+        infer_suggest_accessing_field,\n+        code = \"{snippet}.{name}\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    Safe {\n+        #[primary_span]\n+        span: Span,\n+        snippet: String,\n+        name: Symbol,\n+        ty: Ty<'a>,\n+    },\n+    #[suggestion(\n+        infer_suggest_accessing_field,\n+        code = \"unsafe {{ {snippet}.{name} }}\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    Unsafe {\n+        #[primary_span]\n+        span: Span,\n+        snippet: String,\n+        name: Symbol,\n+        ty: Ty<'a>,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum SuggestBoxingForReturnImplTrait {\n+    #[multipart_suggestion(infer_sbfrit_change_return_type, applicability = \"maybe-incorrect\")]\n+    ChangeReturnType {\n+        #[suggestion_part(code = \"Box<dyn\")]\n+        start_sp: Span,\n+        #[suggestion_part(code = \">\")]\n+        end_sp: Span,\n+    },\n+    #[multipart_suggestion(infer_sbfrit_box_return_expr, applicability = \"maybe-incorrect\")]\n+    BoxReturnExpr {\n+        #[suggestion_part(code = \"Box::new(\")]\n+        starts: Vec<Span>,\n+        #[suggestion_part(code = \")\")]\n+        ends: Vec<Span>,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(infer_stp_wrap_one, applicability = \"maybe-incorrect\")]\n+pub struct SuggestTuplePatternOne {\n+    pub variant: String,\n+    #[suggestion_part(code = \"{variant}(\")]\n+    pub span_low: Span,\n+    #[suggestion_part(code = \")\")]\n+    pub span_high: Span,\n+}\n+\n+pub struct SuggestTuplePatternMany {\n+    pub path: String,\n+    pub cause_span: Span,\n+    pub compatible_variants: Vec<String>,\n+}\n+\n+impl AddToDiagnostic for SuggestTuplePatternMany {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, f: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n+        diag.set_arg(\"path\", self.path);\n+        let message = f(diag, crate::fluent_generated::infer_stp_wrap_many.into());\n+        diag.multipart_suggestions(\n+            message,\n+            self.compatible_variants.into_iter().map(|variant| {\n+                vec![\n+                    (self.cause_span.shrink_to_lo(), format!(\"{}(\", variant)),\n+                    (self.cause_span.shrink_to_hi(), \")\".to_string()),\n+                ]\n+            }),\n+            rustc_errors::Applicability::MaybeIncorrect,\n+        );\n+    }\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum TypeErrorAdditionalDiags {\n+    #[suggestion(\n+        infer_meant_byte_literal,\n+        code = \"b'{code}'\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    MeantByteLiteral {\n+        #[primary_span]\n+        span: Span,\n+        code: String,\n+    },\n+    #[suggestion(\n+        infer_meant_char_literal,\n+        code = \"'{code}'\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    MeantCharLiteral {\n+        #[primary_span]\n+        span: Span,\n+        code: String,\n+    },\n+    #[suggestion(\n+        infer_meant_str_literal,\n+        code = \"\\\"{code}\\\"\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    MeantStrLiteral {\n+        #[primary_span]\n+        span: Span,\n+        code: String,\n+    },\n+    #[suggestion(\n+        infer_consider_specifying_length,\n+        code = \"{length}\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    ConsiderSpecifyingLength {\n+        #[primary_span]\n+        span: Span,\n+        length: u64,\n+    },\n+    #[note(infer_try_cannot_convert)]\n+    TryCannotConvert { found: String, expected: String },\n+    #[suggestion(infer_tuple_trailing_comma, code = \",\", applicability = \"machine-applicable\")]\n+    TupleOnlyComma {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[multipart_suggestion(infer_tuple_trailing_comma, applicability = \"machine-applicable\")]\n+    TupleAlsoParentheses {\n+        #[suggestion_part(code = \"(\")]\n+        span_low: Span,\n+        #[suggestion_part(code = \",)\")]\n+        span_high: Span,\n+    },\n+    #[suggestion(\n+        infer_suggest_add_let_for_letchains,\n+        style = \"verbose\",\n+        applicability = \"machine-applicable\",\n+        code = \"let \"\n+    )]\n+    AddLetForLetChains {\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+pub enum ObligationCauseFailureCode {\n+    #[diag(infer_oc_method_compat, code = \"E0308\")]\n+    MethodCompat {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<TypeErrorAdditionalDiags>,\n+    },\n+    #[diag(infer_oc_type_compat, code = \"E0308\")]\n+    TypeCompat {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<TypeErrorAdditionalDiags>,\n+    },\n+    #[diag(infer_oc_const_compat, code = \"E0308\")]\n+    ConstCompat {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<TypeErrorAdditionalDiags>,\n+    },\n+    #[diag(infer_oc_try_compat, code = \"E0308\")]\n+    TryCompat {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<TypeErrorAdditionalDiags>,\n+    },\n+    #[diag(infer_oc_match_compat, code = \"E0308\")]\n+    MatchCompat {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<TypeErrorAdditionalDiags>,\n+    },\n+    #[diag(infer_oc_if_else_different, code = \"E0308\")]\n+    IfElseDifferent {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<TypeErrorAdditionalDiags>,\n+    },\n+    #[diag(infer_oc_no_else, code = \"E0317\")]\n+    NoElse {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[diag(infer_oc_no_diverge, code = \"E0308\")]\n+    NoDiverge {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<TypeErrorAdditionalDiags>,\n+    },\n+    #[diag(infer_oc_fn_main_correct_type, code = \"E0580\")]\n+    FnMainCorrectType {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[diag(infer_oc_fn_start_correct_type, code = \"E0308\")]\n+    FnStartCorrectType {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<TypeErrorAdditionalDiags>,\n+    },\n+    #[diag(infer_oc_intristic_correct_type, code = \"E0308\")]\n+    IntristicCorrectType {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<TypeErrorAdditionalDiags>,\n+    },\n+    #[diag(infer_oc_method_correct_type, code = \"E0308\")]\n+    MethodCorrectType {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<TypeErrorAdditionalDiags>,\n+    },\n+    #[diag(infer_oc_closure_selfref, code = \"E0644\")]\n+    ClosureSelfref {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[diag(infer_oc_cant_coerce, code = \"E0308\")]\n+    CantCoerce {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<TypeErrorAdditionalDiags>,\n+    },\n+    #[diag(infer_oc_generic, code = \"E0308\")]\n+    Generic {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<TypeErrorAdditionalDiags>,\n+    },\n+}"}, {"sha": "7328241dfbcaf3a48cdd2f05dd637cee16537c50", "filename": "compiler/rustc_infer/src/errors/note_and_explain.rs", "status": "modified", "additions": 47, "deletions": 76, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -4,12 +4,10 @@ use rustc_errors::{self, AddToDiagnostic, Diagnostic, IntoDiagnosticArg, Subdiag\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::{symbol::kw, Span};\n \n-#[derive(Default)]\n struct DescriptionCtx<'a> {\n     span: Option<Span>,\n     kind: &'a str,\n     arg: String,\n-    num_arg: u32,\n }\n \n impl<'a> DescriptionCtx<'a> {\n@@ -18,102 +16,74 @@ impl<'a> DescriptionCtx<'a> {\n         region: ty::Region<'tcx>,\n         alt_span: Option<Span>,\n     ) -> Option<Self> {\n-        let mut me = DescriptionCtx::default();\n-        me.span = alt_span;\n-        match *region {\n-            ty::ReEarlyBound(_) | ty::ReFree(_) => {\n-                return Self::from_early_bound_and_free_regions(tcx, region);\n-            }\n-            ty::ReStatic => {\n-                me.kind = \"restatic\";\n-            }\n-\n-            ty::RePlaceholder(_) => return None,\n-\n-            ty::ReError(_) => return None,\n-\n-            // FIXME(#13998) RePlaceholder should probably print like\n-            // ReFree rather than dumping Debug output on the user.\n-            //\n-            // We shouldn't really be having unification failures with ReVar\n-            // and ReLateBound though.\n-            ty::ReVar(_) | ty::ReLateBound(..) | ty::ReErased => {\n-                me.kind = \"revar\";\n-                me.arg = format!(\"{:?}\", region);\n-            }\n-        };\n-        Some(me)\n-    }\n-\n-    fn from_early_bound_and_free_regions<'tcx>(\n-        tcx: TyCtxt<'tcx>,\n-        region: ty::Region<'tcx>,\n-    ) -> Option<Self> {\n-        let mut me = DescriptionCtx::default();\n-        let scope = region.free_region_binding_scope(tcx).expect_local();\n-        match *region {\n+        let (span, kind, arg) = match *region {\n             ty::ReEarlyBound(ref br) => {\n-                let mut sp = tcx.def_span(scope);\n-                if let Some(param) =\n+                let scope = region.free_region_binding_scope(tcx).expect_local();\n+                let span = if let Some(param) =\n                     tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(br.name))\n                 {\n-                    sp = param.span;\n-                }\n-                if br.has_name() {\n-                    me.kind = \"as_defined\";\n-                    me.arg = br.name.to_string();\n+                    param.span\n                 } else {\n-                    me.kind = \"as_defined_anon\";\n+                    tcx.def_span(scope)\n                 };\n-                me.span = Some(sp)\n+                if br.has_name() {\n+                    (Some(span), \"as_defined\", br.name.to_string())\n+                } else {\n+                    (Some(span), \"as_defined_anon\", String::new())\n+                }\n             }\n             ty::ReFree(ref fr) => {\n                 if !fr.bound_region.is_named()\n                     && let Some((ty, _)) = find_anon_type(tcx, region, &fr.bound_region)\n                 {\n-                    me.kind = \"defined_here\";\n-                    me.span = Some(ty.span);\n+                    (Some(ty.span), \"defined_here\", String::new())\n                 } else {\n+                    let scope = region.free_region_binding_scope(tcx).expect_local();\n                     match fr.bound_region {\n                         ty::BoundRegionKind::BrNamed(_, name) => {\n-                            let mut sp = tcx.def_span(scope);\n-                            if let Some(param) =\n-                                tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(name))\n+                            let span = if let Some(param) = tcx\n+                                .hir()\n+                                .get_generics(scope)\n+                                .and_then(|generics| generics.get_named(name))\n                             {\n-                                sp = param.span;\n-                            }\n-                            if name == kw::UnderscoreLifetime {\n-                                me.kind = \"as_defined_anon\";\n+                                param.span\n                             } else {\n-                                me.kind = \"as_defined\";\n-                                me.arg = name.to_string();\n+                                tcx.def_span(scope)\n                             };\n-                            me.span = Some(sp);\n+                            if name == kw::UnderscoreLifetime {\n+                                (Some(span), \"as_defined_anon\", String::new())\n+                            } else {\n+                                (Some(span), \"as_defined\", name.to_string())\n+                            }\n                         }\n                         ty::BrAnon(span) => {\n-                            me.kind = \"defined_here\";\n-                            me.span = match span {\n+                            let span = match span {\n                                 Some(_) => span,\n                                 None => Some(tcx.def_span(scope)),\n-                            }\n-                        },\n+                            };\n+                            (span, \"defined_here\", String::new())\n+                        }\n                         _ => {\n-                            me.kind = \"defined_here_reg\";\n-                            me.arg = region.to_string();\n-                            me.span = Some(tcx.def_span(scope));\n-                        },\n+                            (Some(tcx.def_span(scope)), \"defined_here_reg\", region.to_string())\n+                        }\n                     }\n                 }\n             }\n-            _ => bug!(),\n-        }\n-        Some(me)\n-    }\n \n-    fn add_to(self, diag: &mut rustc_errors::Diagnostic) {\n-        diag.set_arg(\"desc_kind\", self.kind);\n-        diag.set_arg(\"desc_arg\", self.arg);\n-        diag.set_arg(\"desc_num_arg\", self.num_arg);\n+            ty::ReStatic => (alt_span, \"restatic\", String::new()),\n+\n+            ty::RePlaceholder(_) | ty::ReError(_) => return None,\n+\n+            // FIXME(#13998) RePlaceholder should probably print like\n+            // ReFree rather than dumping Debug output on the user.\n+            //\n+            // We shouldn't really be having unification failures with ReVar\n+            // and ReLateBound though.\n+            ty::ReVar(_) | ty::ReLateBound(..) | ty::ReErased => {\n+                (alt_span, \"revar\", format!(\"{:?}\", region))\n+            }\n+        };\n+        Some(DescriptionCtx { span, kind, arg })\n     }\n }\n \n@@ -198,10 +168,11 @@ impl AddToDiagnostic for RegionExplanation<'_> {\n     {\n         diag.set_arg(\"pref_kind\", self.prefix);\n         diag.set_arg(\"suff_kind\", self.suffix);\n-        let desc_span = self.desc.span;\n-        self.desc.add_to(diag);\n+        diag.set_arg(\"desc_kind\", self.desc.kind);\n+        diag.set_arg(\"desc_arg\", self.desc.arg);\n+\n         let msg = f(diag, fluent::infer_region_explanation.into());\n-        if let Some(span) = desc_span {\n+        if let Some(span) = self.desc.span {\n             diag.span_note(span, msg);\n         } else {\n             diag.note(msg);"}, {"sha": "9e5f6d107d132eef3b9ec4b0d4b2900f7621cfdd", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 287, "deletions": 267, "changes": 554, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -49,11 +49,10 @@ use super::lexical_region_resolve::RegionResolutionError;\n use super::region_constraints::GenericKind;\n use super::{InferCtxt, RegionVariableOrigin, SubregionOrigin, TypeTrace, ValuePairs};\n \n-use crate::errors;\n+use crate::errors::{self, ObligationCauseFailureCode, TypeErrorAdditionalDiags};\n use crate::infer;\n use crate::infer::error_reporting::nice_region_error::find_anon_type::find_anon_type;\n use crate::infer::ExpectedFound;\n-use crate::traits::error_reporting::report_object_safety_error;\n use crate::traits::{\n     IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n     PredicateObligation,\n@@ -75,6 +74,7 @@ use rustc_middle::ty::{\n     self, error::TypeError, List, Region, Ty, TyCtxt, TypeFoldable, TypeSuperVisitable,\n     TypeVisitable, TypeVisitableExt,\n };\n+use rustc_span::DUMMY_SP;\n use rustc_span::{sym, symbol::kw, BytePos, DesugaringKind, Pos, Span};\n use rustc_target::spec::abi;\n use std::ops::{ControlFlow, Deref};\n@@ -90,9 +90,35 @@ pub use need_type_info::TypeAnnotationNeeded;\n \n pub mod nice_region_error;\n \n+/// Makes a valid string literal from a string by escaping special characters (\" and \\),\n+/// unless they are already escaped.\n+fn escape_literal(s: &str) -> String {\n+    let mut escaped = String::with_capacity(s.len());\n+    let mut chrs = s.chars().peekable();\n+    while let Some(first) = chrs.next() {\n+        match (first, chrs.peek()) {\n+            ('\\\\', Some(&delim @ '\"') | Some(&delim @ '\\'')) => {\n+                escaped.push('\\\\');\n+                escaped.push(delim);\n+                chrs.next();\n+            }\n+            ('\"' | '\\'', _) => {\n+                escaped.push('\\\\');\n+                escaped.push(first)\n+            }\n+            (c, _) => escaped.push(c),\n+        };\n+    }\n+    escaped\n+}\n+\n /// A helper for building type related errors. The `typeck_results`\n /// field is only populated during an in-progress typeck.\n-/// Get an instance by calling `InferCtxt::err` or `FnCtxt::infer_err`.\n+/// Get an instance by calling `InferCtxt::err_ctxt` or `FnCtxt::err_ctxt`.\n+///\n+/// You must only create this if you intend to actually emit an error.\n+/// This provides a lot of utility methods which should not be used\n+/// during the happy path.\n pub struct TypeErrCtxt<'a, 'tcx> {\n     pub infcx: &'a InferCtxt<'tcx>,\n     pub typeck_results: Option<std::cell::Ref<'a, ty::TypeckResults<'tcx>>>,\n@@ -104,6 +130,19 @@ pub struct TypeErrCtxt<'a, 'tcx> {\n         Box<dyn Fn(Ty<'tcx>) -> Vec<(Ty<'tcx>, Vec<PredicateObligation<'tcx>>)> + 'a>,\n }\n \n+impl Drop for TypeErrCtxt<'_, '_> {\n+    fn drop(&mut self) {\n+        if let Some(_) = self.infcx.tcx.sess.has_errors_or_delayed_span_bugs() {\n+            // ok, emitted an error.\n+        } else {\n+            self.infcx\n+                .tcx\n+                .sess\n+                .delay_span_bug(DUMMY_SP, \"used a `TypeErrCtxt` without failing compilation\");\n+        }\n+    }\n+}\n+\n impl TypeErrCtxt<'_, '_> {\n     /// This is just to avoid a potential footgun of accidentally\n     /// dropping `typeck_results` by calling `InferCtxt::err_ctxt`\n@@ -163,84 +202,74 @@ fn msg_span_from_named_region<'tcx>(\n     region: ty::Region<'tcx>,\n     alt_span: Option<Span>,\n ) -> (String, Option<Span>) {\n-    match *region {\n-        ty::ReEarlyBound(_) | ty::ReFree(_) => {\n-            let (msg, span) = msg_span_from_early_bound_and_free_regions(tcx, region);\n-            (msg, Some(span))\n-        }\n-        ty::ReStatic => (\"the static lifetime\".to_owned(), alt_span),\n-        ty::RePlaceholder(ty::PlaceholderRegion {\n-            bound: ty::BoundRegion { kind: ty::BoundRegionKind::BrNamed(def_id, name), .. },\n-            ..\n-        }) => (format!(\"the lifetime `{name}` as defined here\"), Some(tcx.def_span(def_id))),\n-        ty::RePlaceholder(ty::PlaceholderRegion {\n-            bound: ty::BoundRegion { kind: ty::BoundRegionKind::BrAnon(Some(span)), .. },\n-            ..\n-        }) => (format!(\"the anonymous lifetime defined here\"), Some(span)),\n-        ty::RePlaceholder(ty::PlaceholderRegion {\n-            bound: ty::BoundRegion { kind: ty::BoundRegionKind::BrAnon(None), .. },\n-            ..\n-        }) => (format!(\"an anonymous lifetime\"), None),\n-        _ => bug!(\"{:?}\", region),\n-    }\n-}\n-\n-fn msg_span_from_early_bound_and_free_regions<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    region: ty::Region<'tcx>,\n-) -> (String, Span) {\n-    let scope = region.free_region_binding_scope(tcx).expect_local();\n     match *region {\n         ty::ReEarlyBound(ref br) => {\n-            let mut sp = tcx.def_span(scope);\n-            if let Some(param) =\n+            let scope = region.free_region_binding_scope(tcx).expect_local();\n+            let span = if let Some(param) =\n                 tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(br.name))\n             {\n-                sp = param.span;\n-            }\n+                param.span\n+            } else {\n+                tcx.def_span(scope)\n+            };\n             let text = if br.has_name() {\n                 format!(\"the lifetime `{}` as defined here\", br.name)\n             } else {\n                 \"the anonymous lifetime as defined here\".to_string()\n             };\n-            (text, sp)\n+            (text, Some(span))\n         }\n         ty::ReFree(ref fr) => {\n             if !fr.bound_region.is_named()\n                 && let Some((ty, _)) = find_anon_type(tcx, region, &fr.bound_region)\n             {\n-                (\"the anonymous lifetime defined here\".to_string(), ty.span)\n+                (\"the anonymous lifetime defined here\".to_string(), Some(ty.span))\n             } else {\n+                let scope = region.free_region_binding_scope(tcx).expect_local();\n                 match fr.bound_region {\n                     ty::BoundRegionKind::BrNamed(_, name) => {\n-                        let mut sp = tcx.def_span(scope);\n-                        if let Some(param) =\n+                        let span = if let Some(param) =\n                             tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(name))\n                         {\n-                            sp = param.span;\n-                        }\n+                            param.span\n+                        } else {\n+                            tcx.def_span(scope)\n+                        };\n                         let text = if name == kw::UnderscoreLifetime {\n                             \"the anonymous lifetime as defined here\".to_string()\n                         } else {\n                             format!(\"the lifetime `{}` as defined here\", name)\n                         };\n-                        (text, sp)\n+                        (text, Some(span))\n                     }\n                     ty::BrAnon(span) => (\n                         \"the anonymous lifetime as defined here\".to_string(),\n-                        match span {\n+                        Some(match span {\n                             Some(span) => span,\n                             None => tcx.def_span(scope)\n-                        }\n+                        })\n                     ),\n                     _ => (\n                         format!(\"the lifetime `{}` as defined here\", region),\n-                        tcx.def_span(scope),\n+                        Some(tcx.def_span(scope)),\n                     ),\n                 }\n             }\n         }\n-        _ => bug!(),\n+        ty::ReStatic => (\"the static lifetime\".to_owned(), alt_span),\n+        ty::RePlaceholder(ty::PlaceholderRegion {\n+            bound: ty::BoundRegion { kind: ty::BoundRegionKind::BrNamed(def_id, name), .. },\n+            ..\n+        }) => (format!(\"the lifetime `{name}` as defined here\"), Some(tcx.def_span(def_id))),\n+        ty::RePlaceholder(ty::PlaceholderRegion {\n+            bound: ty::BoundRegion { kind: ty::BoundRegionKind::BrAnon(Some(span)), .. },\n+            ..\n+        }) => (format!(\"the anonymous lifetime defined here\"), Some(span)),\n+        ty::RePlaceholder(ty::PlaceholderRegion {\n+            bound: ty::BoundRegion { kind: ty::BoundRegionKind::BrAnon(None), .. },\n+            ..\n+        }) => (format!(\"an anonymous lifetime\"), None),\n+        _ => bug!(\"{:?}\", region),\n     }\n }\n \n@@ -398,7 +427,11 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         &self,\n         generic_param_scope: LocalDefId,\n         errors: &[RegionResolutionError<'tcx>],\n-    ) {\n+    ) -> ErrorGuaranteed {\n+        if let Some(guaranteed) = self.infcx.tainted_by_errors() {\n+            return guaranteed;\n+        }\n+\n         debug!(\"report_region_errors(): {} errors to start\", errors.len());\n \n         // try to pre-process the errors, which will group some of them\n@@ -478,6 +511,10 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 }\n             }\n         }\n+\n+        self.tcx\n+            .sess\n+            .delay_span_bug(self.tcx.def_span(generic_param_scope), \"expected region errors\")\n     }\n \n     // This method goes through all the errors and try to group certain types\n@@ -1808,7 +1845,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                             // will try to hide in some case such as `async fn`, so\n                             // to make an error more use friendly we will\n                             // avoid to suggest a mismatch type with a\n-                            // type that the user usually are not usign\n+                            // type that the user usually are not using\n                             // directly such as `impl Future<Output = u8>`.\n                             if !self.tcx.ty_is_opaque_future(found_ty) {\n                                 diag.note_expected_found_extra(\n@@ -1899,233 +1936,182 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         debug!(?diag);\n     }\n \n-    pub fn report_and_explain_type_error(\n+    pub fn type_error_additional_suggestions(\n         &self,\n-        trace: TypeTrace<'tcx>,\n+        trace: &TypeTrace<'tcx>,\n         terr: TypeError<'tcx>,\n-    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n+    ) -> Vec<TypeErrorAdditionalDiags> {\n         use crate::traits::ObligationCauseCode::MatchExpressionArm;\n-\n-        debug!(\"report_and_explain_type_error(trace={:?}, terr={:?})\", trace, terr);\n-\n+        let mut suggestions = Vec::new();\n         let span = trace.cause.span();\n-        let failure_code = trace.cause.as_failure_code(terr);\n-        let mut diag = match failure_code {\n-            FailureCode::Error0038(did) => {\n-                let violations = self.tcx.object_safety_violations(did);\n-                report_object_safety_error(self.tcx, span, did, violations)\n-            }\n-            FailureCode::Error0317(failure_str) => {\n-                struct_span_err!(self.tcx.sess, span, E0317, \"{}\", failure_str)\n-            }\n-            FailureCode::Error0580(failure_str) => {\n-                struct_span_err!(self.tcx.sess, span, E0580, \"{}\", failure_str)\n-            }\n-            FailureCode::Error0308(failure_str) => {\n-                fn escape_literal(s: &str) -> String {\n-                    let mut escaped = String::with_capacity(s.len());\n-                    let mut chrs = s.chars().peekable();\n-                    while let Some(first) = chrs.next() {\n-                        match (first, chrs.peek()) {\n-                            ('\\\\', Some(&delim @ '\"') | Some(&delim @ '\\'')) => {\n-                                escaped.push('\\\\');\n-                                escaped.push(delim);\n-                                chrs.next();\n-                            }\n-                            ('\"' | '\\'', _) => {\n-                                escaped.push('\\\\');\n-                                escaped.push(first)\n-                            }\n-                            (c, _) => escaped.push(c),\n-                        };\n+        let values = self.resolve_vars_if_possible(trace.values);\n+        if let Some((expected, found)) = values.ty() {\n+            match (expected.kind(), found.kind()) {\n+                (ty::Tuple(_), ty::Tuple(_)) => {}\n+                // If a tuple of length one was expected and the found expression has\n+                // parentheses around it, perhaps the user meant to write `(expr,)` to\n+                // build a tuple (issue #86100)\n+                (ty::Tuple(fields), _) => {\n+                    suggestions.extend(self.suggest_wrap_to_build_a_tuple( span, found, fields))\n+                }\n+                // If a byte was expected and the found expression is a char literal\n+                // containing a single ASCII character, perhaps the user meant to write `b'c'` to\n+                // specify a byte literal\n+                (ty::Uint(ty::UintTy::U8), ty::Char) => {\n+                    if let Ok(code) = self.tcx.sess().source_map().span_to_snippet(span)\n+                        && let Some(code) = code.strip_prefix('\\'').and_then(|s| s.strip_suffix('\\''))\n+                        && !code.starts_with(\"\\\\u\") // forbid all Unicode escapes\n+                        && code.chars().next().map_or(false, |c| c.is_ascii()) // forbids literal Unicode characters beyond ASCII\n+                    {\n+                        suggestions.push(TypeErrorAdditionalDiags::MeantByteLiteral { span, code: escape_literal(code) })\n                     }\n-                    escaped\n                 }\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0308, \"{}\", failure_str);\n-                let values = self.resolve_vars_if_possible(trace.values);\n-                if let Some((expected, found)) = values.ty() {\n-                    match (expected.kind(), found.kind()) {\n-                        (ty::Tuple(_), ty::Tuple(_)) => {}\n-                        // If a tuple of length one was expected and the found expression has\n-                        // parentheses around it, perhaps the user meant to write `(expr,)` to\n-                        // build a tuple (issue #86100)\n-                        (ty::Tuple(fields), _) => {\n-                            self.emit_tuple_wrap_err(&mut err, span, found, fields)\n-                        }\n-                        // If a byte was expected and the found expression is a char literal\n-                        // containing a single ASCII character, perhaps the user meant to write `b'c'` to\n-                        // specify a byte literal\n-                        (ty::Uint(ty::UintTy::U8), ty::Char) => {\n-                            if let Ok(code) = self.tcx.sess().source_map().span_to_snippet(span)\n-                                && let Some(code) = code.strip_prefix('\\'').and_then(|s| s.strip_suffix('\\''))\n-                                && !code.starts_with(\"\\\\u\") // forbid all Unicode escapes\n-                                && code.chars().next().map_or(false, |c| c.is_ascii()) // forbids literal Unicode characters beyond ASCII\n-                            {\n-                                err.span_suggestion(\n-                                    span,\n-                                    \"if you meant to write a byte literal, prefix with `b`\",\n-                                    format!(\"b'{}'\", escape_literal(code)),\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            }\n-                        }\n-                        // If a character was expected and the found expression is a string literal\n-                        // containing a single character, perhaps the user meant to write `'c'` to\n-                        // specify a character literal (issue #92479)\n-                        (ty::Char, ty::Ref(_, r, _)) if r.is_str() => {\n-                            if let Ok(code) = self.tcx.sess().source_map().span_to_snippet(span)\n-                                && let Some(code) = code.strip_prefix('\"').and_then(|s| s.strip_suffix('\"'))\n-                                && code.chars().count() == 1\n-                            {\n-                                err.span_suggestion(\n-                                    span,\n-                                    \"if you meant to write a `char` literal, use single quotes\",\n-                                    format!(\"'{}'\", escape_literal(code)),\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            }\n-                        }\n-                        // If a string was expected and the found expression is a character literal,\n-                        // perhaps the user meant to write `\"s\"` to specify a string literal.\n-                        (ty::Ref(_, r, _), ty::Char) if r.is_str() => {\n-                            if let Ok(code) = self.tcx.sess().source_map().span_to_snippet(span) {\n-                                if let Some(code) =\n-                                    code.strip_prefix('\\'').and_then(|s| s.strip_suffix('\\''))\n-                                {\n-                                    err.span_suggestion(\n-                                        span,\n-                                        \"if you meant to write a `str` literal, use double quotes\",\n-                                        format!(\"\\\"{}\\\"\", escape_literal(code)),\n-                                        Applicability::MachineApplicable,\n-                                    );\n-                                }\n-                            }\n-                        }\n-                        // For code `if Some(..) = expr `, the type mismatch may be expected `bool` but found `()`,\n-                        // we try to suggest to add the missing `let` for `if let Some(..) = expr`\n-                        (ty::Bool, ty::Tuple(list)) => if list.len() == 0 {\n-                            self.suggest_let_for_letchains(&mut err, &trace.cause, span);\n-                        }\n-                        (ty::Array(_, _), ty::Array(_, _)) => 'block: {\n-                            let hir = self.tcx.hir();\n-                            let TypeError::FixedArraySize(sz) = terr else {\n-                                break 'block;\n-                            };\n-                            let tykind = match hir.find_by_def_id(trace.cause.body_id) {\n-                                Some(hir::Node::Item(hir::Item {\n-                                    kind: hir::ItemKind::Fn(_, _, body_id),\n-                                    ..\n-                                })) => {\n-                                    let body = hir.body(*body_id);\n-                                    struct LetVisitor<'v> {\n-                                        span: Span,\n-                                        result: Option<&'v hir::Ty<'v>>,\n-                                    }\n-                                    impl<'v> Visitor<'v> for LetVisitor<'v> {\n-                                        fn visit_stmt(&mut self, s: &'v hir::Stmt<'v>) {\n-                                            if self.result.is_some() {\n-                                                return;\n-                                            }\n-                                            // Find a local statement where the initializer has\n-                                            // the same span as the error and the type is specified.\n-                                            if let hir::Stmt {\n-                                                kind: hir::StmtKind::Local(hir::Local {\n-                                                    init: Some(hir::Expr {\n-                                                        span: init_span,\n-                                                        ..\n-                                                    }),\n-                                                    ty: Some(array_ty),\n-                                                    ..\n-                                                }),\n-                                                ..\n-                                            } = s\n-                                            && init_span == &self.span {\n-                                                self.result = Some(*array_ty);\n-                                            }\n-                                        }\n-                                    }\n-                                    let mut visitor = LetVisitor {span, result: None};\n-                                    visitor.visit_body(body);\n-                                    visitor.result.map(|r| &r.peel_refs().kind)\n-                                }\n-                                Some(hir::Node::Item(hir::Item {\n-                                    kind: hir::ItemKind::Const(ty, _),\n-                                    ..\n-                                })) => {\n-                                    Some(&ty.peel_refs().kind)\n-                                }\n-                                _ => None\n-                            };\n-\n-                            if let Some(tykind) = tykind\n-                                && let hir::TyKind::Array(_, length) = tykind\n-                                && let hir::ArrayLen::Body(hir::AnonConst { hir_id, .. }) = length\n-                                && let Some(span) = self.tcx.hir().opt_span(*hir_id)\n-                            {\n-                                err.span_suggestion(\n-                                    span,\n-                                    \"consider specifying the actual array length\",\n-                                    sz.found,\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                            }\n+                // If a character was expected and the found expression is a string literal\n+                // containing a single character, perhaps the user meant to write `'c'` to\n+                // specify a character literal (issue #92479)\n+                (ty::Char, ty::Ref(_, r, _)) if r.is_str() => {\n+                    if let Ok(code) = self.tcx.sess().source_map().span_to_snippet(span)\n+                        && let Some(code) = code.strip_prefix('\"').and_then(|s| s.strip_suffix('\"'))\n+                        && code.chars().count() == 1\n+                    {\n+                        suggestions.push(TypeErrorAdditionalDiags::MeantCharLiteral { span, code: escape_literal(code) })\n+                    }\n+                }\n+                // If a string was expected and the found expression is a character literal,\n+                // perhaps the user meant to write `\"s\"` to specify a string literal.\n+                (ty::Ref(_, r, _), ty::Char) if r.is_str() => {\n+                    if let Ok(code) = self.tcx.sess().source_map().span_to_snippet(span) {\n+                        if let Some(code) =\n+                            code.strip_prefix('\\'').and_then(|s| s.strip_suffix('\\''))\n+                        {\n+                            suggestions.push(TypeErrorAdditionalDiags::MeantStrLiteral { span, code: escape_literal(code) })\n                         }\n-                        _ => {}\n                     }\n                 }\n-                let code = trace.cause.code();\n-                if let &MatchExpressionArm(box MatchExpressionArmCause { source, .. }) = code\n+                // For code `if Some(..) = expr `, the type mismatch may be expected `bool` but found `()`,\n+                // we try to suggest to add the missing `let` for `if let Some(..) = expr`\n+                (ty::Bool, ty::Tuple(list)) => if list.len() == 0 {\n+                    suggestions.extend(self.suggest_let_for_letchains(&trace.cause, span));\n+                }\n+                (ty::Array(_, _), ty::Array(_, _)) => suggestions.extend(self.suggest_specify_actual_length(terr, trace, span)),\n+                _ => {}\n+            }\n+        }\n+        let code = trace.cause.code();\n+        if let &MatchExpressionArm(box MatchExpressionArmCause { source, .. }) = code\n                     && let hir::MatchSource::TryDesugar = source\n                     && let Some((expected_ty, found_ty, _, _)) = self.values_str(trace.values)\n                 {\n-                    err.note(&format!(\n-                        \"`?` operator cannot convert from `{}` to `{}`\",\n-                        found_ty.content(),\n-                        expected_ty.content(),\n-                    ));\n+                    suggestions.push(TypeErrorAdditionalDiags::TryCannotConvert { found: found_ty.content(), expected: expected_ty.content() });\n                 }\n-                err\n+        suggestions\n+    }\n+\n+    fn suggest_specify_actual_length(\n+        &self,\n+        terr: TypeError<'_>,\n+        trace: &TypeTrace<'_>,\n+        span: Span,\n+    ) -> Option<TypeErrorAdditionalDiags> {\n+        let hir = self.tcx.hir();\n+        let TypeError::FixedArraySize(sz) = terr else {\n+            return None;\n+        };\n+        let tykind = match hir.find_by_def_id(trace.cause.body_id) {\n+            Some(hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, _, body_id), .. })) => {\n+                let body = hir.body(*body_id);\n+                struct LetVisitor<'v> {\n+                    span: Span,\n+                    result: Option<&'v hir::Ty<'v>>,\n+                }\n+                impl<'v> Visitor<'v> for LetVisitor<'v> {\n+                    fn visit_stmt(&mut self, s: &'v hir::Stmt<'v>) {\n+                        if self.result.is_some() {\n+                            return;\n+                        }\n+                        // Find a local statement where the initializer has\n+                        // the same span as the error and the type is specified.\n+                        if let hir::Stmt {\n+                            kind: hir::StmtKind::Local(hir::Local {\n+                                init: Some(hir::Expr {\n+                                    span: init_span,\n+                                    ..\n+                                }),\n+                                ty: Some(array_ty),\n+                                ..\n+                            }),\n+                            ..\n+                        } = s\n+                        && init_span == &self.span {\n+                            self.result = Some(*array_ty);\n+                        }\n+                    }\n+                }\n+                let mut visitor = LetVisitor { span, result: None };\n+                visitor.visit_body(body);\n+                visitor.result.map(|r| &r.peel_refs().kind)\n             }\n-            FailureCode::Error0644(failure_str) => {\n-                struct_span_err!(self.tcx.sess, span, E0644, \"{}\", failure_str)\n+            Some(hir::Node::Item(hir::Item { kind: hir::ItemKind::Const(ty, _), .. })) => {\n+                Some(&ty.peel_refs().kind)\n             }\n+            _ => None,\n         };\n+        if let Some(tykind) = tykind\n+            && let hir::TyKind::Array(_, length) = tykind\n+            && let hir::ArrayLen::Body(hir::AnonConst { hir_id, .. }) = length\n+            && let Some(span) = self.tcx.hir().opt_span(*hir_id)\n+        {\n+            Some(TypeErrorAdditionalDiags::ConsiderSpecifyingLength { span, length: sz.found })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn report_and_explain_type_error(\n+        &self,\n+        trace: TypeTrace<'tcx>,\n+        terr: TypeError<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n+        debug!(\"report_and_explain_type_error(trace={:?}, terr={:?})\", trace, terr);\n+\n+        let span = trace.cause.span();\n+        let failure_code = trace.cause.as_failure_code_diag(\n+            terr,\n+            span,\n+            self.type_error_additional_suggestions(&trace, terr),\n+        );\n+        let mut diag = self.tcx.sess.create_err(failure_code);\n         self.note_type_err(&mut diag, &trace.cause, None, Some(trace.values), terr, false, false);\n         diag\n     }\n \n-    fn emit_tuple_wrap_err(\n+    fn suggest_wrap_to_build_a_tuple(\n         &self,\n-        err: &mut Diagnostic,\n         span: Span,\n         found: Ty<'tcx>,\n         expected_fields: &List<Ty<'tcx>>,\n-    ) {\n-        let [expected_tup_elem] = expected_fields[..] else { return };\n+    ) -> Option<TypeErrorAdditionalDiags> {\n+        let [expected_tup_elem] = expected_fields[..] else { return None};\n \n         if !self.same_type_modulo_infer(expected_tup_elem, found) {\n-            return;\n+            return None;\n         }\n \n         let Ok(code) = self.tcx.sess().source_map().span_to_snippet(span)\n-            else { return };\n+            else { return None };\n \n-        let msg = \"use a trailing comma to create a tuple with one element\";\n-        if code.starts_with('(') && code.ends_with(')') {\n+        let sugg = if code.starts_with('(') && code.ends_with(')') {\n             let before_close = span.hi() - BytePos::from_u32(1);\n-            err.span_suggestion(\n-                span.with_hi(before_close).shrink_to_hi(),\n-                msg,\n-                \",\",\n-                Applicability::MachineApplicable,\n-            );\n+            TypeErrorAdditionalDiags::TupleOnlyComma {\n+                span: span.with_hi(before_close).shrink_to_hi(),\n+            }\n         } else {\n-            err.multipart_suggestion(\n-                msg,\n-                vec![(span.shrink_to_lo(), \"(\".into()), (span.shrink_to_hi(), \",)\".into())],\n-                Applicability::MachineApplicable,\n-            );\n-        }\n+            TypeErrorAdditionalDiags::TupleAlsoParentheses {\n+                span_low: span.shrink_to_lo(),\n+                span_high: span.shrink_to_hi(),\n+            }\n+        };\n+        Some(sugg)\n     }\n \n     fn values_str(\n@@ -2828,57 +2814,91 @@ impl<'tcx> InferCtxt<'tcx> {\n }\n \n pub enum FailureCode {\n-    Error0038(DefId),\n-    Error0317(&'static str),\n-    Error0580(&'static str),\n-    Error0308(&'static str),\n-    Error0644(&'static str),\n+    Error0317,\n+    Error0580,\n+    Error0308,\n+    Error0644,\n }\n \n pub trait ObligationCauseExt<'tcx> {\n     fn as_failure_code(&self, terr: TypeError<'tcx>) -> FailureCode;\n+\n+    fn as_failure_code_diag(\n+        &self,\n+        terr: TypeError<'tcx>,\n+        span: Span,\n+        subdiags: Vec<TypeErrorAdditionalDiags>,\n+    ) -> ObligationCauseFailureCode;\n     fn as_requirement_str(&self) -> &'static str;\n }\n \n impl<'tcx> ObligationCauseExt<'tcx> for ObligationCause<'tcx> {\n     fn as_failure_code(&self, terr: TypeError<'tcx>) -> FailureCode {\n         use self::FailureCode::*;\n+        use crate::traits::ObligationCauseCode::*;\n+        match self.code() {\n+            IfExpressionWithNoElse => Error0317,\n+            MainFunctionType => Error0580,\n+            CompareImplItemObligation { .. }\n+            | MatchExpressionArm(_)\n+            | IfExpression { .. }\n+            | LetElse\n+            | StartFunctionType\n+            | IntrinsicType\n+            | MethodReceiver => Error0308,\n+\n+            // In the case where we have no more specific thing to\n+            // say, also take a look at the error code, maybe we can\n+            // tailor to that.\n+            _ => match terr {\n+                TypeError::CyclicTy(ty) if ty.is_closure() || ty.is_generator() => Error0644,\n+                TypeError::IntrinsicCast => Error0308,\n+                _ => Error0308,\n+            },\n+        }\n+    }\n+    fn as_failure_code_diag(\n+        &self,\n+        terr: TypeError<'tcx>,\n+        span: Span,\n+        subdiags: Vec<TypeErrorAdditionalDiags>,\n+    ) -> ObligationCauseFailureCode {\n         use crate::traits::ObligationCauseCode::*;\n         match self.code() {\n             CompareImplItemObligation { kind: ty::AssocKind::Fn, .. } => {\n-                Error0308(\"method not compatible with trait\")\n+                ObligationCauseFailureCode::MethodCompat { span, subdiags }\n             }\n             CompareImplItemObligation { kind: ty::AssocKind::Type, .. } => {\n-                Error0308(\"type not compatible with trait\")\n+                ObligationCauseFailureCode::TypeCompat { span, subdiags }\n             }\n             CompareImplItemObligation { kind: ty::AssocKind::Const, .. } => {\n-                Error0308(\"const not compatible with trait\")\n-            }\n-            MatchExpressionArm(box MatchExpressionArmCause { source, .. }) => {\n-                Error0308(match source {\n-                    hir::MatchSource::TryDesugar => \"`?` operator has incompatible types\",\n-                    _ => \"`match` arms have incompatible types\",\n-                })\n-            }\n-            IfExpression { .. } => Error0308(\"`if` and `else` have incompatible types\"),\n-            IfExpressionWithNoElse => Error0317(\"`if` may be missing an `else` clause\"),\n-            LetElse => Error0308(\"`else` clause of `let...else` does not diverge\"),\n-            MainFunctionType => Error0580(\"`main` function has wrong type\"),\n-            StartFunctionType => Error0308(\"`#[start]` function has wrong type\"),\n-            IntrinsicType => Error0308(\"intrinsic has wrong type\"),\n-            MethodReceiver => Error0308(\"mismatched `self` parameter type\"),\n+                ObligationCauseFailureCode::ConstCompat { span, subdiags }\n+            }\n+            MatchExpressionArm(box MatchExpressionArmCause { source, .. }) => match source {\n+                hir::MatchSource::TryDesugar => {\n+                    ObligationCauseFailureCode::TryCompat { span, subdiags }\n+                }\n+                _ => ObligationCauseFailureCode::MatchCompat { span, subdiags },\n+            },\n+            IfExpression { .. } => ObligationCauseFailureCode::IfElseDifferent { span, subdiags },\n+            IfExpressionWithNoElse => ObligationCauseFailureCode::NoElse { span },\n+            LetElse => ObligationCauseFailureCode::NoDiverge { span, subdiags },\n+            MainFunctionType => ObligationCauseFailureCode::FnMainCorrectType { span },\n+            StartFunctionType => ObligationCauseFailureCode::FnStartCorrectType { span, subdiags },\n+            IntrinsicType => ObligationCauseFailureCode::IntristicCorrectType { span, subdiags },\n+            MethodReceiver => ObligationCauseFailureCode::MethodCorrectType { span, subdiags },\n \n             // In the case where we have no more specific thing to\n             // say, also take a look at the error code, maybe we can\n             // tailor to that.\n             _ => match terr {\n                 TypeError::CyclicTy(ty) if ty.is_closure() || ty.is_generator() => {\n-                    Error0644(\"closure/generator type that references itself\")\n+                    ObligationCauseFailureCode::ClosureSelfref { span }\n                 }\n                 TypeError::IntrinsicCast => {\n-                    Error0308(\"cannot coerce intrinsics to function pointers\")\n+                    ObligationCauseFailureCode::CantCoerce { span, subdiags }\n                 }\n-                _ => Error0308(\"mismatched types\"),\n+                _ => ObligationCauseFailureCode::Generic { span, subdiags },\n             },\n         }\n     }"}, {"sha": "75cc4e257bd83283cf592851ffa992ec0a51d6a2", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1,5 +1,5 @@\n use crate::errors::{\n-    AmbigousImpl, AmbigousReturn, AnnotationRequired, InferenceBadError, NeedTypeInfoInGenerator,\n+    AmbigousReturn, AmbiguousImpl, AnnotationRequired, InferenceBadError, NeedTypeInfoInGenerator,\n     SourceKindMultiSuggestion, SourceKindSubdiag,\n };\n use crate::infer::error_reporting::TypeErrCtxt;\n@@ -358,7 +358,7 @@ impl<'tcx> InferCtxt<'tcx> {\n                 bad_label,\n             }\n             .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic),\n-            TypeAnnotationNeeded::E0283 => AmbigousImpl {\n+            TypeAnnotationNeeded::E0283 => AmbiguousImpl {\n                 span,\n                 source_kind,\n                 source_name,\n@@ -563,7 +563,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 bad_label: None,\n             }\n             .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic),\n-            TypeAnnotationNeeded::E0283 => AmbigousImpl {\n+            TypeAnnotationNeeded::E0283 => AmbiguousImpl {\n                 span,\n                 source_kind,\n                 source_name: &name,"}, {"sha": "07a9eff2dbefe485bd08f3dbaacc6124352f5c9c", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1,5 +1,5 @@\n use crate::errors::{\n-    note_and_explain, FullfillReqLifetime, LfBoundNotSatisfied, OutlivesBound, OutlivesContent,\n+    note_and_explain, FulfillReqLifetime, LfBoundNotSatisfied, OutlivesBound, OutlivesContent,\n     RefLongerThanData, RegionOriginNote, WhereClauseSuggestions,\n };\n use crate::fluent_generated as fluent;\n@@ -176,7 +176,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 let note = note_and_explain::RegionExplanation::new(\n                     self.tcx, sub, opt_span, prefix, suffix,\n                 );\n-                FullfillReqLifetime { span, ty: self.resolve_vars_if_possible(ty), note }\n+                FulfillReqLifetime { span, ty: self.resolve_vars_if_possible(ty), note }\n                     .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic)\n             }\n             infer::RelateRegionParamBound(span) => {"}, {"sha": "b5aeca12a1f0c67c24e070ab57df6f57d977c929", "filename": "compiler/rustc_infer/src/infer/error_reporting/suggest.rs", "status": "modified", "additions": 95, "deletions": 113, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1,7 +1,7 @@\n use hir::def::CtorKind;\n use hir::intravisit::{walk_expr, walk_stmt, Visitor};\n use rustc_data_structures::fx::FxIndexSet;\n-use rustc_errors::{Applicability, Diagnostic};\n+use rustc_errors::Diagnostic;\n use rustc_hir as hir;\n use rustc_middle::traits::{\n     IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n@@ -13,11 +13,20 @@ use rustc_span::{sym, BytePos, Span};\n use rustc_target::abi::FieldIdx;\n \n use crate::errors::{\n-    ConsiderAddingAwait, SuggAddLetForLetChains, SuggestRemoveSemiOrReturnBinding,\n+    ConsiderAddingAwait, FnConsiderCasting, FnItemsAreDistinct, FnUniqTypes,\n+    FunctionPointerSuggestion, SuggestAccessingField, SuggestAsRefWhereAppropriate,\n+    SuggestBoxingForReturnImplTrait, SuggestRemoveSemiOrReturnBinding, SuggestTuplePatternMany,\n+    SuggestTuplePatternOne, TypeErrorAdditionalDiags,\n };\n \n use super::TypeErrCtxt;\n \n+#[derive(Clone, Copy)]\n+pub enum SuggestAsRefKind {\n+    Option,\n+    Result,\n+}\n+\n impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     pub(super) fn suggest_remove_semi_or_return_binding(\n         &self,\n@@ -72,25 +81,20 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         return_sp: Span,\n         arm_spans: impl Iterator<Item = Span>,\n     ) {\n-        err.multipart_suggestion(\n-            \"you could change the return type to be a boxed trait object\",\n-            vec![\n-                (return_sp.with_hi(return_sp.lo() + BytePos(4)), \"Box<dyn\".to_string()),\n-                (return_sp.shrink_to_hi(), \">\".to_string()),\n-            ],\n-            Applicability::MaybeIncorrect,\n-        );\n-        let sugg = arm_spans\n-            .flat_map(|sp| {\n-                [(sp.shrink_to_lo(), \"Box::new(\".to_string()), (sp.shrink_to_hi(), \")\".to_string())]\n-                    .into_iter()\n-            })\n-            .collect::<Vec<_>>();\n-        err.multipart_suggestion(\n-            \"if you change the return type to expect trait objects, box the returned expressions\",\n-            sugg,\n-            Applicability::MaybeIncorrect,\n-        );\n+        let sugg = SuggestBoxingForReturnImplTrait::ChangeReturnType {\n+            start_sp: return_sp.with_hi(return_sp.lo() + BytePos(4)),\n+            end_sp: return_sp.shrink_to_hi(),\n+        };\n+        err.subdiagnostic(sugg);\n+\n+        let mut starts = Vec::new();\n+        let mut ends = Vec::new();\n+        for span in arm_spans {\n+            starts.push(span.shrink_to_lo());\n+            ends.push(span.shrink_to_hi());\n+        }\n+        let sugg = SuggestBoxingForReturnImplTrait::BoxReturnExpr { starts, ends };\n+        err.subdiagnostic(sugg);\n     }\n \n     pub(super) fn suggest_tuple_pattern(\n@@ -130,30 +134,21 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 match &compatible_variants[..] {\n                     [] => {}\n                     [variant] => {\n-                        diag.multipart_suggestion_verbose(\n-                            &format!(\"try wrapping the pattern in `{}`\", variant),\n-                            vec![\n-                                (cause.span.shrink_to_lo(), format!(\"{}(\", variant)),\n-                                (cause.span.shrink_to_hi(), \")\".to_string()),\n-                            ],\n-                            Applicability::MaybeIncorrect,\n-                        );\n+                        let sugg = SuggestTuplePatternOne {\n+                            variant: variant.to_owned(),\n+                            span_low: cause.span.shrink_to_lo(),\n+                            span_high: cause.span.shrink_to_hi(),\n+                        };\n+                        diag.subdiagnostic(sugg);\n                     }\n                     _ => {\n                         // More than one matching variant.\n-                        diag.multipart_suggestions(\n-                            &format!(\n-                                \"try wrapping the pattern in a variant of `{}`\",\n-                                self.tcx.def_path_str(expected_adt.did())\n-                            ),\n-                            compatible_variants.into_iter().map(|variant| {\n-                                vec![\n-                                    (cause.span.shrink_to_lo(), format!(\"{}(\", variant)),\n-                                    (cause.span.shrink_to_hi(), \")\".to_string()),\n-                                ]\n-                            }),\n-                            Applicability::MaybeIncorrect,\n-                        );\n+                        let sugg = SuggestTuplePatternMany {\n+                            path: self.tcx.def_path_str(expected_adt.did()),\n+                            cause_span: cause.span,\n+                            compatible_variants,\n+                        };\n+                        diag.subdiagnostic(sugg);\n                     }\n                 }\n             }\n@@ -256,15 +251,6 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         }\n     }\n \n-    pub fn suggest_await_on_future(&self, diag: &mut Diagnostic, sp: Span) {\n-        diag.span_suggestion_verbose(\n-            sp.shrink_to_hi(),\n-            \"consider `await`ing on the `Future`\",\n-            \".await\",\n-            Applicability::MaybeIncorrect,\n-        );\n-    }\n-\n     pub(super) fn suggest_accessing_field_where_appropriate(\n         &self,\n         cause: &ObligationCause<'tcx>,\n@@ -291,21 +277,13 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 if let ObligationCauseCode::Pattern { span: Some(span), .. } = *cause.code() {\n                     if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n                         let suggestion = if expected_def.is_struct() {\n-                            format!(\"{}.{}\", snippet, name)\n+                            SuggestAccessingField::Safe { span, snippet, name, ty }\n                         } else if expected_def.is_union() {\n-                            format!(\"unsafe {{ {}.{} }}\", snippet, name)\n+                            SuggestAccessingField::Unsafe { span, snippet, name, ty }\n                         } else {\n                             return;\n                         };\n-                        diag.span_suggestion(\n-                            span,\n-                            &format!(\n-                                \"you might have meant to use field `{}` whose type is `{}`\",\n-                                name, ty\n-                            ),\n-                            suggestion,\n-                            Applicability::MaybeIncorrect,\n-                        );\n+                        diag.subdiagnostic(suggestion);\n                     }\n                 }\n             }\n@@ -321,15 +299,15 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         diag: &mut Diagnostic,\n     ) {\n         if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span)\n-            && let Some(msg) = self.should_suggest_as_ref(exp_found.expected, exp_found.found)\n+            && let Some(msg) = self.should_suggest_as_ref_kind(exp_found.expected, exp_found.found)\n         {\n-            diag.span_suggestion(\n-                span,\n-                msg,\n-                // HACK: fix issue# 100605, suggesting convert from &Option<T> to Option<&T>, remove the extra `&`\n-                format!(\"{}.as_ref()\", snippet.trim_start_matches('&')),\n-                Applicability::MachineApplicable,\n-            );\n+            // HACK: fix issue# 100605, suggesting convert from &Option<T> to Option<&T>, remove the extra `&`\n+            let snippet = snippet.trim_start_matches('&');\n+            let subdiag = match msg {\n+                SuggestAsRefKind::Option => SuggestAsRefWhereAppropriate::Option { span, snippet },\n+                SuggestAsRefKind::Result => SuggestAsRefWhereAppropriate::Result { span, snippet },\n+            };\n+            diag.subdiagnostic(subdiag);\n         }\n     }\n \n@@ -362,31 +340,19 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     return;\n                 }\n \n-                let (msg, sug) = match (expected.is_ref(), found.is_ref()) {\n-                    (true, false) => {\n-                        let msg = \"consider using a reference\";\n-                        let sug = format!(\"&{fn_name}\");\n-                        (msg, sug)\n-                    }\n-                    (false, true) => {\n-                        let msg = \"consider removing the reference\";\n-                        let sug = format!(\"{fn_name}\");\n-                        (msg, sug)\n-                    }\n+                let sugg = match (expected.is_ref(), found.is_ref()) {\n+                    (true, false) => FunctionPointerSuggestion::UseRef { span, fn_name },\n+                    (false, true) => FunctionPointerSuggestion::RemoveRef { span, fn_name },\n                     (true, true) => {\n-                        diag.note(\"fn items are distinct from fn pointers\");\n-                        let msg = \"consider casting to a fn pointer\";\n-                        let sug = format!(\"&({fn_name} as {sig})\");\n-                        (msg, sug)\n+                        diag.subdiagnostic(FnItemsAreDistinct);\n+                        FunctionPointerSuggestion::CastRef { span, fn_name, sig: *sig }\n                     }\n                     (false, false) => {\n-                        diag.note(\"fn items are distinct from fn pointers\");\n-                        let msg = \"consider casting to a fn pointer\";\n-                        let sug = format!(\"{fn_name} as {sig}\");\n-                        (msg, sug)\n+                        diag.subdiagnostic(FnItemsAreDistinct);\n+                        FunctionPointerSuggestion::Cast { span, fn_name, sig: *sig }\n                     }\n                 };\n-                diag.span_suggestion_verbose(span, msg, sug, Applicability::MaybeIncorrect);\n+                diag.subdiagnostic(sugg);\n             }\n             (ty::FnDef(did1, substs1), ty::FnDef(did2, substs2)) => {\n                 let expected_sig =\n@@ -395,7 +361,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     &(self.normalize_fn_sig)(self.tcx.fn_sig(*did2).subst(self.tcx, substs2));\n \n                 if self.same_type_modulo_infer(*expected_sig, *found_sig) {\n-                    diag.note(\"different fn items have unique types, even if their signatures are the same\");\n+                    diag.subdiagnostic(FnUniqTypes);\n                 }\n \n                 if !self.same_type_modulo_infer(*found_sig, *expected_sig)\n@@ -409,16 +375,22 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n \n                 let fn_name = self.tcx.def_path_str_with_substs(*did2, substs2);\n                 let sug = if found.is_ref() {\n-                    format!(\"&({fn_name} as {found_sig})\")\n+                    FunctionPointerSuggestion::CastBothRef {\n+                        span,\n+                        fn_name,\n+                        found_sig: *found_sig,\n+                        expected_sig: *expected_sig,\n+                    }\n                 } else {\n-                    format!(\"{fn_name} as {found_sig}\")\n+                    FunctionPointerSuggestion::CastBoth {\n+                        span,\n+                        fn_name,\n+                        found_sig: *found_sig,\n+                        expected_sig: *expected_sig,\n+                    }\n                 };\n \n-                let msg = format!(\n-                    \"consider casting both fn items to fn pointers using `as {expected_sig}`\"\n-                );\n-\n-                diag.span_suggestion_hidden(span, msg, sug, Applicability::MaybeIncorrect);\n+                diag.subdiagnostic(sug);\n             }\n             (ty::FnDef(did, substs), ty::FnPtr(sig)) => {\n                 let expected_sig =\n@@ -437,31 +409,27 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     format!(\"{fn_name} as {found_sig}\")\n                 };\n \n-                diag.help(&format!(\"consider casting the fn item to a fn pointer: `{}`\", casting));\n+                diag.subdiagnostic(FnConsiderCasting { casting });\n             }\n             _ => {\n                 return;\n             }\n         };\n     }\n \n-    pub fn should_suggest_as_ref(&self, expected: Ty<'tcx>, found: Ty<'tcx>) -> Option<&str> {\n+    pub fn should_suggest_as_ref_kind(\n+        &self,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+    ) -> Option<SuggestAsRefKind> {\n         if let (ty::Adt(exp_def, exp_substs), ty::Ref(_, found_ty, _)) =\n             (expected.kind(), found.kind())\n         {\n             if let ty::Adt(found_def, found_substs) = *found_ty.kind() {\n                 if exp_def == &found_def {\n                     let have_as_ref = &[\n-                        (\n-                            sym::Option,\n-                            \"you can convert from `&Option<T>` to `Option<&T>` using \\\n-                        `.as_ref()`\",\n-                        ),\n-                        (\n-                            sym::Result,\n-                            \"you can convert from `&Result<T, E>` to \\\n-                        `Result<&T, &E>` using `.as_ref()`\",\n-                        ),\n+                        (sym::Option, SuggestAsRefKind::Option),\n+                        (sym::Result, SuggestAsRefKind::Result),\n                     ];\n                     if let Some(msg) = have_as_ref.iter().find_map(|(name, msg)| {\n                         self.tcx.is_diagnostic_item(*name, exp_def.did()).then_some(msg)\n@@ -495,15 +463,28 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         None\n     }\n \n+    // FIXME: Remove once `rustc_hir_typeck` is migrated to diagnostic structs\n+    pub fn should_suggest_as_ref(&self, expected: Ty<'tcx>, found: Ty<'tcx>) -> Option<&str> {\n+        match self.should_suggest_as_ref_kind(expected, found) {\n+            Some(SuggestAsRefKind::Option) => Some(\n+                \"you can convert from `&Option<T>` to `Option<&T>` using \\\n+            `.as_ref()`\",\n+            ),\n+            Some(SuggestAsRefKind::Result) => Some(\n+                \"you can convert from `&Result<T, E>` to \\\n+            `Result<&T, &E>` using `.as_ref()`\",\n+            ),\n+            None => None,\n+        }\n+    }\n     /// Try to find code with pattern `if Some(..) = expr`\n     /// use a `visitor` to mark the `if` which its span contains given error span,\n     /// and then try to find a assignment in the `cond` part, which span is equal with error span\n     pub(super) fn suggest_let_for_letchains(\n         &self,\n-        err: &mut Diagnostic,\n         cause: &ObligationCause<'_>,\n         span: Span,\n-    ) {\n+    ) -> Option<TypeErrorAdditionalDiags> {\n         let hir = self.tcx.hir();\n         if let Some(node) = self.tcx.hir().find_by_def_id(cause.body_id) &&\n             let hir::Node::Item(hir::Item {\n@@ -550,9 +531,10 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         let mut visitor = IfVisitor { err_span: span, found_if: false, result: false };\n         visitor.visit_body(&body);\n         if visitor.result {\n-                err.subdiagnostic(SuggAddLetForLetChains{span: span.shrink_to_lo()});\n+                return Some(TypeErrorAdditionalDiags::AddLetForLetChains{span: span.shrink_to_lo()});\n             }\n         }\n+        None\n     }\n }\n "}, {"sha": "66f51328bbe7ce9f0dba71643d90c5b4595584b5", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 141, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -45,8 +45,7 @@ use self::combine::CombineFields;\n use self::error_reporting::TypeErrCtxt;\n use self::free_regions::RegionRelations;\n use self::lexical_region_resolve::LexicalRegionResolutions;\n-use self::outlives::env::OutlivesEnvironment;\n-use self::region_constraints::{GenericKind, RegionConstraintData, VarInfos, VerifyBound};\n+use self::region_constraints::{GenericKind, VarInfos, VerifyBound};\n use self::region_constraints::{\n     RegionConstraintCollector, RegionConstraintStorage, RegionSnapshot,\n };\n@@ -1213,95 +1212,6 @@ impl<'tcx> InferCtxt<'tcx> {\n         self.tainted_by_errors.set(Some(e));\n     }\n \n-    pub fn skip_region_resolution(&self) {\n-        let (var_infos, _) = {\n-            let mut inner = self.inner.borrow_mut();\n-            let inner = &mut *inner;\n-            // Note: `inner.region_obligations` may not be empty, because we\n-            // didn't necessarily call `process_registered_region_obligations`.\n-            // This is okay, because that doesn't introduce new vars.\n-            inner\n-                .region_constraint_storage\n-                .take()\n-                .expect(\"regions already resolved\")\n-                .with_log(&mut inner.undo_log)\n-                .into_infos_and_data()\n-        };\n-\n-        let lexical_region_resolutions = LexicalRegionResolutions {\n-            values: rustc_index::vec::IndexVec::from_elem_n(\n-                crate::infer::lexical_region_resolve::VarValue::Value(self.tcx.lifetimes.re_erased),\n-                var_infos.len(),\n-            ),\n-        };\n-\n-        let old_value = self.lexical_region_resolutions.replace(Some(lexical_region_resolutions));\n-        assert!(old_value.is_none());\n-    }\n-\n-    /// Process the region constraints and return any errors that\n-    /// result. After this, no more unification operations should be\n-    /// done -- or the compiler will panic -- but it is legal to use\n-    /// `resolve_vars_if_possible` as well as `fully_resolve`.\n-    pub fn resolve_regions(\n-        &self,\n-        outlives_env: &OutlivesEnvironment<'tcx>,\n-    ) -> Vec<RegionResolutionError<'tcx>> {\n-        let (var_infos, data) = {\n-            let mut inner = self.inner.borrow_mut();\n-            let inner = &mut *inner;\n-            assert!(\n-                self.tainted_by_errors().is_some() || inner.region_obligations.is_empty(),\n-                \"region_obligations not empty: {:#?}\",\n-                inner.region_obligations\n-            );\n-            inner\n-                .region_constraint_storage\n-                .take()\n-                .expect(\"regions already resolved\")\n-                .with_log(&mut inner.undo_log)\n-                .into_infos_and_data()\n-        };\n-\n-        let region_rels = &RegionRelations::new(self.tcx, outlives_env.free_region_map());\n-\n-        let (lexical_region_resolutions, errors) =\n-            lexical_region_resolve::resolve(outlives_env.param_env, region_rels, var_infos, data);\n-\n-        let old_value = self.lexical_region_resolutions.replace(Some(lexical_region_resolutions));\n-        assert!(old_value.is_none());\n-\n-        errors\n-    }\n-    /// Obtains (and clears) the current set of region\n-    /// constraints. The inference context is still usable: further\n-    /// unifications will simply add new constraints.\n-    ///\n-    /// This method is not meant to be used with normal lexical region\n-    /// resolution. Rather, it is used in the NLL mode as a kind of\n-    /// interim hack: basically we run normal type-check and generate\n-    /// region constraints as normal, but then we take them and\n-    /// translate them into the form that the NLL solver\n-    /// understands. See the NLL module for mode details.\n-    pub fn take_and_reset_region_constraints(&self) -> RegionConstraintData<'tcx> {\n-        assert!(\n-            self.inner.borrow().region_obligations.is_empty(),\n-            \"region_obligations not empty: {:#?}\",\n-            self.inner.borrow().region_obligations\n-        );\n-\n-        self.inner.borrow_mut().unwrap_region_constraints().take_and_reset_data()\n-    }\n-\n-    /// Gives temporary access to the region constraint data.\n-    pub fn with_region_constraints<R>(\n-        &self,\n-        op: impl FnOnce(&RegionConstraintData<'tcx>) -> R,\n-    ) -> R {\n-        let mut inner = self.inner.borrow_mut();\n-        op(inner.unwrap_region_constraints().data())\n-    }\n-\n     pub fn region_var_origin(&self, vid: ty::RegionVid) -> RegionVariableOrigin {\n         let mut inner = self.inner.borrow_mut();\n         let inner = &mut *inner;\n@@ -1754,56 +1664,6 @@ impl<'cx, 'tcx> Drop for CanonicalizationCtxtGuard<'cx, 'tcx> {\n }\n \n impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n-    /// Processes registered region obliations and resolves regions, reporting\n-    /// any errors if any were raised. Prefer using this function over manually\n-    /// calling `resolve_regions_and_report_errors`.\n-    pub fn check_region_obligations_and_report_errors(\n-        &self,\n-        generic_param_scope: LocalDefId,\n-        outlives_env: &OutlivesEnvironment<'tcx>,\n-    ) -> Result<(), ErrorGuaranteed> {\n-        self.process_registered_region_obligations(\n-            outlives_env.region_bound_pairs(),\n-            outlives_env.param_env,\n-        );\n-\n-        self.resolve_regions_and_report_errors(generic_param_scope, outlives_env)\n-    }\n-\n-    /// Process the region constraints and report any errors that\n-    /// result. After this, no more unification operations should be\n-    /// done -- or the compiler will panic -- but it is legal to use\n-    /// `resolve_vars_if_possible` as well as `fully_resolve`.\n-    ///\n-    /// Make sure to call [`InferCtxt::process_registered_region_obligations`]\n-    /// first, or preferably use [`TypeErrCtxt::check_region_obligations_and_report_errors`]\n-    /// to do both of these operations together.\n-    pub fn resolve_regions_and_report_errors(\n-        &self,\n-        generic_param_scope: LocalDefId,\n-        outlives_env: &OutlivesEnvironment<'tcx>,\n-    ) -> Result<(), ErrorGuaranteed> {\n-        let errors = self.resolve_regions(outlives_env);\n-\n-        if let None = self.tainted_by_errors() {\n-            // As a heuristic, just skip reporting region errors\n-            // altogether if other errors have been reported while\n-            // this infcx was in use. This is totally hokey but\n-            // otherwise we have a hard time separating legit region\n-            // errors from silly ones.\n-            self.report_region_errors(generic_param_scope, &errors);\n-        }\n-\n-        if errors.is_empty() {\n-            Ok(())\n-        } else {\n-            Err(self\n-                .tcx\n-                .sess\n-                .delay_span_bug(rustc_span::DUMMY_SP, \"error should have been emitted\"))\n-        }\n-    }\n-\n     // [Note-Type-error-reporting]\n     // An invariant is that anytime the expected or actual type is Error (the special\n     // error type, meaning that an error occurred when typechecking this expression),"}, {"sha": "9a9a1696b0063532821fdd7e4d667f677d95cd48", "filename": "compiler/rustc_infer/src/infer/outlives/mod.rs", "status": "modified", "additions": 102, "deletions": 3, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1,14 +1,18 @@\n //! Various code related to computing outlives relations.\n+use self::env::OutlivesEnvironment;\n+use super::region_constraints::RegionConstraintData;\n+use super::{InferCtxt, RegionResolutionError};\n+use crate::infer::free_regions::RegionRelations;\n+use crate::infer::lexical_region_resolve::{self, LexicalRegionResolutions};\n+use rustc_middle::traits::query::OutlivesBound;\n+use rustc_middle::ty;\n \n pub mod components;\n pub mod env;\n pub mod obligations;\n pub mod test_type_match;\n pub mod verify;\n \n-use rustc_middle::traits::query::OutlivesBound;\n-use rustc_middle::ty;\n-\n #[instrument(level = \"debug\", skip(param_env), ret)]\n pub fn explicit_outlives_bounds<'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n@@ -39,3 +43,98 @@ pub fn explicit_outlives_bounds<'tcx>(\n             ))) => Some(OutlivesBound::RegionSubRegion(r_b, r_a)),\n         })\n }\n+\n+impl<'tcx> InferCtxt<'tcx> {\n+    pub fn skip_region_resolution(&self) {\n+        let (var_infos, _) = {\n+            let mut inner = self.inner.borrow_mut();\n+            let inner = &mut *inner;\n+            // Note: `inner.region_obligations` may not be empty, because we\n+            // didn't necessarily call `process_registered_region_obligations`.\n+            // This is okay, because that doesn't introduce new vars.\n+            inner\n+                .region_constraint_storage\n+                .take()\n+                .expect(\"regions already resolved\")\n+                .with_log(&mut inner.undo_log)\n+                .into_infos_and_data()\n+        };\n+\n+        let lexical_region_resolutions = LexicalRegionResolutions {\n+            values: rustc_index::vec::IndexVec::from_elem_n(\n+                crate::infer::lexical_region_resolve::VarValue::Value(self.tcx.lifetimes.re_erased),\n+                var_infos.len(),\n+            ),\n+        };\n+\n+        let old_value = self.lexical_region_resolutions.replace(Some(lexical_region_resolutions));\n+        assert!(old_value.is_none());\n+    }\n+\n+    /// Process the region constraints and return any errors that\n+    /// result. After this, no more unification operations should be\n+    /// done -- or the compiler will panic -- but it is legal to use\n+    /// `resolve_vars_if_possible` as well as `fully_resolve`.\n+    #[must_use]\n+    pub fn resolve_regions(\n+        &self,\n+        outlives_env: &OutlivesEnvironment<'tcx>,\n+    ) -> Vec<RegionResolutionError<'tcx>> {\n+        self.process_registered_region_obligations(outlives_env);\n+\n+        let (var_infos, data) = {\n+            let mut inner = self.inner.borrow_mut();\n+            let inner = &mut *inner;\n+            assert!(\n+                self.tainted_by_errors().is_some() || inner.region_obligations.is_empty(),\n+                \"region_obligations not empty: {:#?}\",\n+                inner.region_obligations\n+            );\n+            inner\n+                .region_constraint_storage\n+                .take()\n+                .expect(\"regions already resolved\")\n+                .with_log(&mut inner.undo_log)\n+                .into_infos_and_data()\n+        };\n+\n+        let region_rels = &RegionRelations::new(self.tcx, outlives_env.free_region_map());\n+\n+        let (lexical_region_resolutions, errors) =\n+            lexical_region_resolve::resolve(outlives_env.param_env, region_rels, var_infos, data);\n+\n+        let old_value = self.lexical_region_resolutions.replace(Some(lexical_region_resolutions));\n+        assert!(old_value.is_none());\n+\n+        errors\n+    }\n+\n+    /// Obtains (and clears) the current set of region\n+    /// constraints. The inference context is still usable: further\n+    /// unifications will simply add new constraints.\n+    ///\n+    /// This method is not meant to be used with normal lexical region\n+    /// resolution. Rather, it is used in the NLL mode as a kind of\n+    /// interim hack: basically we run normal type-check and generate\n+    /// region constraints as normal, but then we take them and\n+    /// translate them into the form that the NLL solver\n+    /// understands. See the NLL module for mode details.\n+    pub fn take_and_reset_region_constraints(&self) -> RegionConstraintData<'tcx> {\n+        assert!(\n+            self.inner.borrow().region_obligations.is_empty(),\n+            \"region_obligations not empty: {:#?}\",\n+            self.inner.borrow().region_obligations\n+        );\n+\n+        self.inner.borrow_mut().unwrap_region_constraints().take_and_reset_data()\n+    }\n+\n+    /// Gives temporary access to the region constraint data.\n+    pub fn with_region_constraints<R>(\n+        &self,\n+        op: impl FnOnce(&RegionConstraintData<'tcx>) -> R,\n+    ) -> R {\n+        let mut inner = self.inner.borrow_mut();\n+        op(inner.unwrap_region_constraints().data())\n+    }\n+}"}, {"sha": "ccf11c61b573bb6f88f027938d867ec6f6df6946", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 14, "deletions": 33, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -72,6 +72,8 @@ use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, Region, SubstsRef, Ty, TyCtxt, TypeVisitableExt};\n use smallvec::smallvec;\n \n+use super::env::OutlivesEnvironment;\n+\n impl<'tcx> InferCtxt<'tcx> {\n     /// Registers that the given region obligation must be resolved\n     /// from within the scope of `body_id`. These regions are enqueued\n@@ -112,39 +114,17 @@ impl<'tcx> InferCtxt<'tcx> {\n         std::mem::take(&mut self.inner.borrow_mut().region_obligations)\n     }\n \n-    /// NOTE: Prefer using `TypeErrCtxt::check_region_obligations_and_report_errors`\n-    /// instead of calling this directly.\n-    ///\n     /// Process the region obligations that must be proven (during\n     /// `regionck`) for the given `body_id`, given information about\n-    /// the region bounds in scope and so forth. This function must be\n-    /// invoked for all relevant body-ids before region inference is\n-    /// done (or else an assert will fire).\n+    /// the region bounds in scope and so forth.\n     ///\n     /// See the `region_obligations` field of `InferCtxt` for some\n     /// comments about how this function fits into the overall expected\n     /// flow of the inferencer. The key point is that it is\n     /// invoked after all type-inference variables have been bound --\n-    /// towards the end of regionck. This also ensures that the\n-    /// region-bound-pairs are available (see comments above regarding\n-    /// closures).\n-    ///\n-    /// # Parameters\n-    ///\n-    /// - `region_bound_pairs_map`: the set of region bounds implied by\n-    ///   the parameters and where-clauses. In particular, each pair\n-    ///   `('a, K)` in this list tells us that the bounds in scope\n-    ///   indicate that `K: 'a`, where `K` is either a generic\n-    ///   parameter like `T` or a projection like `T::Item`.\n-    /// - `param_env` is the parameter environment for the enclosing function.\n-    /// - `body_id` is the body-id whose region obligations are being\n-    ///   processed.\n-    #[instrument(level = \"debug\", skip(self, region_bound_pairs))]\n-    pub fn process_registered_region_obligations(\n-        &self,\n-        region_bound_pairs: &RegionBoundPairs<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) {\n+    /// right before lexical region resolution.\n+    #[instrument(level = \"debug\", skip(self, outlives_env))]\n+    pub fn process_registered_region_obligations(&self, outlives_env: &OutlivesEnvironment<'tcx>) {\n         assert!(\n             !self.in_snapshot.get(),\n             \"cannot process registered region obligations in a snapshot\"\n@@ -153,15 +133,16 @@ impl<'tcx> InferCtxt<'tcx> {\n         let my_region_obligations = self.take_registered_region_obligations();\n \n         for RegionObligation { sup_type, sub_region, origin } in my_region_obligations {\n-            debug!(\n-                \"process_registered_region_obligations: sup_type={:?} sub_region={:?} origin={:?}\",\n-                sup_type, sub_region, origin\n-            );\n-\n+            debug!(?sup_type, ?sub_region, ?origin);\n             let sup_type = self.resolve_vars_if_possible(sup_type);\n \n-            let outlives =\n-                &mut TypeOutlives::new(self, self.tcx, &region_bound_pairs, None, param_env);\n+            let outlives = &mut TypeOutlives::new(\n+                self,\n+                self.tcx,\n+                &outlives_env.region_bound_pairs(),\n+                None,\n+                outlives_env.param_env,\n+            );\n             let category = origin.to_constraint_category();\n             outlives.type_must_outlive(origin, sup_type, sub_region, category);\n         }"}, {"sha": "b8940e2f0456c60a13b0353d4c6d1998a185e9eb", "filename": "compiler/rustc_infer/src/traits/engine.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -36,9 +36,10 @@ pub trait TraitEngine<'tcx>: 'tcx {\n         obligation: PredicateObligation<'tcx>,\n     );\n \n+    #[must_use]\n     fn select_where_possible(&mut self, infcx: &InferCtxt<'tcx>) -> Vec<FulfillmentError<'tcx>>;\n \n-    fn collect_remaining_errors(&mut self) -> Vec<FulfillmentError<'tcx>>;\n+    fn collect_remaining_errors(&mut self, infcx: &InferCtxt<'tcx>) -> Vec<FulfillmentError<'tcx>>;\n \n     fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>>;\n \n@@ -58,6 +59,7 @@ pub trait TraitEngineExt<'tcx> {\n         obligations: impl IntoIterator<Item = PredicateObligation<'tcx>>,\n     );\n \n+    #[must_use]\n     fn select_all_or_error(&mut self, infcx: &InferCtxt<'tcx>) -> Vec<FulfillmentError<'tcx>>;\n }\n \n@@ -78,6 +80,6 @@ impl<'tcx, T: ?Sized + TraitEngine<'tcx>> TraitEngineExt<'tcx> for T {\n             return errors;\n         }\n \n-        self.collect_remaining_errors()\n+        self.collect_remaining_errors(infcx)\n     }\n }"}, {"sha": "e01b6caf43064caafa94051f9d29128d8ec0799e", "filename": "compiler/rustc_infer/src/traits/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -128,7 +128,11 @@ pub enum FulfillmentErrorCode<'tcx> {\n     CodeProjectionError(MismatchedProjectionTypes<'tcx>),\n     CodeSubtypeError(ExpectedFound<Ty<'tcx>>, TypeError<'tcx>), // always comes from a SubtypePredicate\n     CodeConstEquateError(ExpectedFound<Const<'tcx>>, TypeError<'tcx>),\n-    CodeAmbiguity,\n+    CodeAmbiguity {\n+        /// Overflow reported from the new solver `-Ztrait-solver=next`, which will\n+        /// be reported as an regular error as opposed to a fatal error.\n+        overflow: bool,\n+    },\n }\n \n impl<'tcx, O> Obligation<'tcx, O> {"}, {"sha": "1563d92af0ea771a259bb4bf9c00d3f1b96cf46c", "filename": "compiler/rustc_infer/src/traits/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fstructural_impls.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -46,7 +46,8 @@ impl<'tcx> fmt::Debug for traits::FulfillmentErrorCode<'tcx> {\n             super::CodeConstEquateError(ref a, ref b) => {\n                 write!(f, \"CodeConstEquateError({:?}, {:?})\", a, b)\n             }\n-            super::CodeAmbiguity => write!(f, \"Ambiguity\"),\n+            super::CodeAmbiguity { overflow: false } => write!(f, \"Ambiguity\"),\n+            super::CodeAmbiguity { overflow: true } => write!(f, \"Overflow\"),\n             super::CodeCycle(ref cycle) => write!(f, \"Cycle({:?})\", cycle),\n         }\n     }"}, {"sha": "ef01d5d513bbc456a95df15a7976d2adbb0b8af3", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -69,6 +69,7 @@ impl<'tcx> Extend<ty::Predicate<'tcx>> for PredicateSet<'tcx> {\n pub struct Elaborator<'tcx, O> {\n     stack: Vec<O>,\n     visited: PredicateSet<'tcx>,\n+    only_self: bool,\n }\n \n /// Describes how to elaborate an obligation into a sub-obligation.\n@@ -170,7 +171,8 @@ pub fn elaborate<'tcx, O: Elaboratable<'tcx>>(\n     tcx: TyCtxt<'tcx>,\n     obligations: impl IntoIterator<Item = O>,\n ) -> Elaborator<'tcx, O> {\n-    let mut elaborator = Elaborator { stack: Vec::new(), visited: PredicateSet::new(tcx) };\n+    let mut elaborator =\n+        Elaborator { stack: Vec::new(), visited: PredicateSet::new(tcx), only_self: false };\n     elaborator.extend_deduped(obligations);\n     elaborator\n }\n@@ -185,14 +187,25 @@ impl<'tcx, O: Elaboratable<'tcx>> Elaborator<'tcx, O> {\n         self.stack.extend(obligations.into_iter().filter(|o| self.visited.insert(o.predicate())));\n     }\n \n+    /// Filter to only the supertraits of trait predicates, i.e. only the predicates\n+    /// that have `Self` as their self type, instead of all implied predicates.\n+    pub fn filter_only_self(mut self) -> Self {\n+        self.only_self = true;\n+        self\n+    }\n+\n     fn elaborate(&mut self, elaboratable: &O) {\n         let tcx = self.visited.tcx;\n \n         let bound_predicate = elaboratable.predicate().kind();\n         match bound_predicate.skip_binder() {\n             ty::PredicateKind::Clause(ty::Clause::Trait(data)) => {\n-                // Get predicates declared on the trait.\n-                let predicates = tcx.super_predicates_of(data.def_id());\n+                // Get predicates implied by the trait, or only super predicates if we only care about self predicates.\n+                let predicates = if self.only_self {\n+                    tcx.super_predicates_of(data.def_id())\n+                } else {\n+                    tcx.implied_predicates_of(data.def_id())\n+                };\n \n                 let obligations =\n                     predicates.predicates.iter().enumerate().map(|(index, &(mut pred, span))| {\n@@ -350,18 +363,16 @@ pub fn supertraits<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>,\n ) -> impl Iterator<Item = ty::PolyTraitRef<'tcx>> {\n-    let pred: ty::Predicate<'tcx> = trait_ref.to_predicate(tcx);\n-    FilterToTraits::new(elaborate(tcx, [pred]))\n+    elaborate(tcx, [trait_ref.to_predicate(tcx)]).filter_only_self().filter_to_traits()\n }\n \n pub fn transitive_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n ) -> impl Iterator<Item = ty::PolyTraitRef<'tcx>> {\n-    FilterToTraits::new(elaborate(\n-        tcx,\n-        trait_refs.map(|trait_ref| -> ty::Predicate<'tcx> { trait_ref.to_predicate(tcx) }),\n-    ))\n+    elaborate(tcx, trait_refs.map(|trait_ref| trait_ref.to_predicate(tcx)))\n+        .filter_only_self()\n+        .filter_to_traits()\n }\n \n /// A specialized variant of `elaborate` that only elaborates trait references that may\n@@ -381,10 +392,8 @@ pub fn transitive_bounds_that_define_assoc_type<'tcx>(\n         while let Some(trait_ref) = stack.pop() {\n             let anon_trait_ref = tcx.anonymize_bound_vars(trait_ref);\n             if visited.insert(anon_trait_ref) {\n-                let super_predicates = tcx.super_predicates_that_define_assoc_type((\n-                    trait_ref.def_id(),\n-                    Some(assoc_name),\n-                ));\n+                let super_predicates =\n+                    tcx.super_predicates_that_define_assoc_type((trait_ref.def_id(), assoc_name));\n                 for (super_predicate, _) in super_predicates.predicates {\n                     let subst_predicate = super_predicate.subst_supertrait(tcx, &trait_ref);\n                     if let Some(binder) = subst_predicate.to_opt_poly_trait_pred() {\n@@ -404,18 +413,18 @@ pub fn transitive_bounds_that_define_assoc_type<'tcx>(\n // Other\n ///////////////////////////////////////////////////////////////////////////\n \n+impl<'tcx> Elaborator<'tcx, ty::Predicate<'tcx>> {\n+    fn filter_to_traits(self) -> FilterToTraits<Self> {\n+        FilterToTraits { base_iterator: self }\n+    }\n+}\n+\n /// A filter around an iterator of predicates that makes it yield up\n /// just trait references.\n pub struct FilterToTraits<I> {\n     base_iterator: I,\n }\n \n-impl<I> FilterToTraits<I> {\n-    fn new(base: I) -> FilterToTraits<I> {\n-        FilterToTraits { base_iterator: base }\n-    }\n-}\n-\n impl<'tcx, I: Iterator<Item = ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n     type Item = ty::PolyTraitRef<'tcx>;\n "}, {"sha": "b3f4b5cd5e5a0dda101ebfcb30d0a6dda3886e5c", "filename": "compiler/rustc_lexer/src/lib.rs", "status": "modified", "additions": 10, "deletions": 33, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Flib.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -95,7 +95,7 @@ pub enum TokenKind {\n     Literal { kind: LiteralKind, suffix_start: u32 },\n \n     /// \"'a\"\n-    Lifetime { starts_with_number: bool, contains_emoji: bool },\n+    Lifetime { starts_with_number: bool },\n \n     // One-char tokens:\n     /// \";\"\n@@ -632,13 +632,7 @@ impl Cursor<'_> {\n             // If the first symbol is valid for identifier, it can be a lifetime.\n             // Also check if it's a number for a better error reporting (so '0 will\n             // be reported as invalid lifetime and not as unterminated char literal).\n-            // We also have to account for potential `'\ud83d\udc31` emojis to avoid reporting\n-            // it as an unterminated char literal.\n-            is_id_start(self.first())\n-                || self.first().is_digit(10)\n-                // FIXME(#108019): `unic-emoji-char` seems to have data tables only up to Unicode\n-                // 5.0, but Unicode is already newer than this.\n-                || unic_emoji_char::is_emoji(self.first())\n+            is_id_start(self.first()) || self.first().is_digit(10)\n         };\n \n         if !can_be_a_lifetime {\n@@ -651,33 +645,16 @@ impl Cursor<'_> {\n             return Literal { kind, suffix_start };\n         }\n \n-        // Either a lifetime or a character literal.\n+        // Either a lifetime or a character literal with\n+        // length greater than 1.\n \n         let starts_with_number = self.first().is_digit(10);\n-        let mut contains_emoji = false;\n \n-        // FIXME(#108019): `unic-emoji-char` seems to have data tables only up to Unicode\n-        // 5.0, but Unicode is already newer than this.\n-        if unic_emoji_char::is_emoji(self.first()) {\n-            contains_emoji = true;\n-        } else {\n-            // Skip the literal contents.\n-            // First symbol can be a number (which isn't a valid identifier start),\n-            // so skip it without any checks.\n-            self.bump();\n-        }\n-        self.eat_while(|c| {\n-            if is_id_continue(c) {\n-                true\n-            // FIXME(#108019): `unic-emoji-char` seems to have data tables only up to Unicode\n-            // 5.0, but Unicode is already newer than this.\n-            } else if unic_emoji_char::is_emoji(c) {\n-                contains_emoji = true;\n-                true\n-            } else {\n-                false\n-            }\n-        });\n+        // Skip the literal contents.\n+        // First symbol can be a number (which isn't a valid identifier start),\n+        // so skip it without any checks.\n+        self.bump();\n+        self.eat_while(is_id_continue);\n \n         // Check if after skipping literal contents we've met a closing\n         // single quote (which means that user attempted to create a\n@@ -687,7 +664,7 @@ impl Cursor<'_> {\n             let kind = Char { terminated: true };\n             Literal { kind, suffix_start: self.pos_within_token() }\n         } else {\n-            Lifetime { starts_with_number, contains_emoji }\n+            Lifetime { starts_with_number }\n         }\n     }\n "}, {"sha": "e4c1787f2ccef043e002d228346c72b8a2958655", "filename": "compiler/rustc_lexer/src/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_lexer%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_lexer%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Ftests.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -235,7 +235,7 @@ fn lifetime() {\n     check_lexing(\n         \"'abc\",\n         expect![[r#\"\n-            Token { kind: Lifetime { starts_with_number: false, contains_emoji: false }, len: 4 }\n+            Token { kind: Lifetime { starts_with_number: false }, len: 4 }\n         \"#]],\n     );\n }"}, {"sha": "db15b176df001091558d3556a9ea2e1240341723", "filename": "compiler/rustc_lint/messages.ftl", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_lint%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_lint%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fmessages.ftl?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -91,7 +91,7 @@ lint_ty_qualified = usage of qualified `ty::{$ty}`\n lint_lintpass_by_hand = implementing `LintPass` by hand\n     .help = try using `declare_lint_pass!` or `impl_lint_pass!` instead\n \n-lint_non_existant_doc_keyword = found non-existing keyword `{$keyword}` used in `#[doc(keyword = \"...\")]`\n+lint_non_existent_doc_keyword = found non-existing keyword `{$keyword}` used in `#[doc(keyword = \"...\")]`\n     .help = only existing keywords are allowed in core/std\n \n lint_diag_out_of_impl =\n@@ -107,7 +107,7 @@ lint_cstring_ptr = getting the inner pointer of a temporary `CString`\n     .note = pointers do not have a lifetime; when calling `as_ptr` the `CString` will be deallocated at the end of the statement because nothing is referencing it as far as the type system is concerned\n     .help = for more information, see https://doc.rust-lang.org/reference/destructors.html\n \n-lint_multple_supertrait_upcastable = `{$ident}` is object-safe and has multiple supertraits\n+lint_multiple_supertrait_upcastable = `{$ident}` is object-safe and has multiple supertraits\n \n lint_identifier_non_ascii_char = identifier contains non-ASCII characters\n "}, {"sha": "4ac589c2e10f097ec8bafd62a068f965aa802849", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -2,7 +2,7 @@\n //! Clippy.\n \n use crate::lints::{\n-    BadOptAccessDiag, DefaultHashTypesDiag, DiagOutOfImpl, LintPassByHand, NonExistantDocKeyword,\n+    BadOptAccessDiag, DefaultHashTypesDiag, DiagOutOfImpl, LintPassByHand, NonExistentDocKeyword,\n     QueryInstability, TyQualified, TykindDiag, TykindKind, UntranslatableDiag,\n };\n use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n@@ -334,7 +334,7 @@ impl<'tcx> LateLintPass<'tcx> for ExistingDocKeyword {\n                         cx.emit_spanned_lint(\n                             EXISTING_DOC_KEYWORD,\n                             attr.span,\n-                            NonExistantDocKeyword { keyword },\n+                            NonExistentDocKeyword { keyword },\n                         );\n                     }\n                 }\n@@ -424,7 +424,7 @@ impl LateLintPass<'_> for Diagnostics {\n }\n \n declare_tool_lint! {\n-    /// The `bad_opt_access` lint detects accessing options by field instad of\n+    /// The `bad_opt_access` lint detects accessing options by field instead of\n     /// the wrapper function.\n     pub rustc::BAD_OPT_ACCESS,\n     Deny,"}, {"sha": "3eefd1b0e083316fd1903348dc12dd73d3732b91", "filename": "compiler/rustc_lint/src/let_underscore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_lint%2Fsrc%2Flet_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_lint%2Fsrc%2Flet_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flet_underscore.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -25,7 +25,7 @@ declare_lint! {\n     ///\n     /// fn main() {\n     ///    #[warn(let_underscore_drop)]\n-    ///     // SomeStuct is dropped immediately instead of at end of scope,\n+    ///     // SomeStruct is dropped immediately instead of at end of scope,\n     ///     // so \"Dropping SomeStruct\" is printed before \"end of main\".\n     ///     // The order of prints would be reversed if SomeStruct was bound to\n     ///     // a name (such as \"_foo\")."}, {"sha": "bb863f09516833ecae25d78a6b2d0a3c130dc03b", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -3,7 +3,7 @@ use crate::{\n     fluent_generated as fluent,\n     late::unerased_lint_store,\n     lints::{\n-        DeprecatedLintName, IgnoredUnlessCrateSpecified, OverruledAtributeLint,\n+        DeprecatedLintName, IgnoredUnlessCrateSpecified, OverruledAttributeLint,\n         RenamedOrRemovedLint, RenamedOrRemovedLintSuggestion, UnknownLint, UnknownLintSuggestion,\n     },\n };\n@@ -612,7 +612,7 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n                     self.emit_spanned_lint(\n                         FORBIDDEN_LINT_GROUPS,\n                         src.span().into(),\n-                        OverruledAtributeLint {\n+                        OverruledAttributeLint {\n                             overruled: src.span(),\n                             lint_level: level.as_str(),\n                             lint_source: src.name(),"}, {"sha": "1d5e02369f528b605ab3b0e45c5edd99e393d2f9", "filename": "compiler/rustc_lint/src/lints.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flints.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -806,9 +806,9 @@ pub struct TyQualified {\n pub struct LintPassByHand;\n \n #[derive(LintDiagnostic)]\n-#[diag(lint_non_existant_doc_keyword)]\n+#[diag(lint_non_existent_doc_keyword)]\n #[help]\n-pub struct NonExistantDocKeyword {\n+pub struct NonExistentDocKeyword {\n     pub keyword: Symbol,\n }\n \n@@ -875,7 +875,7 @@ impl AddToDiagnostic for NonBindingLetSub {\n // levels.rs\n #[derive(LintDiagnostic)]\n #[diag(lint_overruled_attribute)]\n-pub struct OverruledAtributeLint<'a> {\n+pub struct OverruledAttributeLint<'a> {\n     #[label]\n     pub overruled: Span,\n     pub lint_level: &'a str,\n@@ -947,7 +947,7 @@ pub struct CStringPtr {\n \n // multiple_supertrait_upcastable.rs\n #[derive(LintDiagnostic)]\n-#[diag(lint_multple_supertrait_upcastable)]\n+#[diag(lint_multiple_supertrait_upcastable)]\n pub struct MultipleSupertraitUpcastable {\n     pub ident: Ident,\n }\n@@ -1422,7 +1422,7 @@ pub struct UnusedResult<'a> {\n     pub ty: Ty<'a>,\n }\n \n-// FIXME(davidtwco): this isn't properly translatable becauses of the\n+// FIXME(davidtwco): this isn't properly translatable because of the\n // pre/post strings\n #[derive(LintDiagnostic)]\n #[diag(lint_unused_closure)]\n@@ -1433,7 +1433,7 @@ pub struct UnusedClosure<'a> {\n     pub post: &'a str,\n }\n \n-// FIXME(davidtwco): this isn't properly translatable becauses of the\n+// FIXME(davidtwco): this isn't properly translatable because of the\n // pre/post strings\n #[derive(LintDiagnostic)]\n #[diag(lint_unused_generator)]\n@@ -1444,7 +1444,7 @@ pub struct UnusedGenerator<'a> {\n     pub post: &'a str,\n }\n \n-// FIXME(davidtwco): this isn't properly translatable becauses of the pre/post\n+// FIXME(davidtwco): this isn't properly translatable because of the pre/post\n // strings\n pub struct UnusedDef<'a, 'b> {\n     pub pre: &'a str,"}, {"sha": "4af879b4e91284ed565ab1f01ae29dd9b12654ac", "filename": "compiler/rustc_lint/src/non_ascii_idents.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -250,7 +250,7 @@ impl EarlyLintPass for NonAsciiIdents {\n             let latin_augmented_script_set = AugmentedScriptSet::for_char('A');\n             script_states.insert(latin_augmented_script_set, ScriptSetUsage::Verified);\n \n-            let mut has_suspicous = false;\n+            let mut has_suspicious = false;\n             for (symbol, &sp) in symbols.iter() {\n                 let symbol_str = symbol.as_str();\n                 for ch in symbol_str.chars() {\n@@ -278,14 +278,14 @@ impl EarlyLintPass for NonAsciiIdents {\n                             if !is_potential_mixed_script_confusable_char(ch) {\n                                 ScriptSetUsage::Verified\n                             } else {\n-                                has_suspicous = true;\n+                                has_suspicious = true;\n                                 ScriptSetUsage::Suspicious(vec![ch], sp)\n                             }\n                         });\n                 }\n             }\n \n-            if has_suspicous {\n+            if has_suspicious {\n                 let verified_augmented_script_sets = script_states\n                     .iter()\n                     .flat_map(|(k, v)| match v {"}, {"sha": "1159d11e5c0c8411f7a8089fcaac4c43e9a448e0", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -255,6 +255,8 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                 ty::Adt(def, _) => is_def_must_use(cx, def.did(), span),\n                 ty::Alias(ty::Opaque, ty::AliasTy { def_id: def, .. }) => {\n                     elaborate(cx.tcx, cx.tcx.explicit_item_bounds(def).iter().cloned())\n+                        // We only care about self bounds for the impl-trait\n+                        .filter_only_self()\n                         .find_map(|(pred, _span)| {\n                             // We only look at the `DefId`, so it is safe to skip the binder here.\n                             if let ty::PredicateKind::Clause(ty::Clause::Trait("}, {"sha": "7ea472ed504a30ed0aac9c72533e7e451d72bb4a", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -532,7 +532,7 @@ pub enum BuiltinLintDiagnostics {\n     AmbiguousGlobReexports {\n         /// The name for which collision(s) have occurred.\n         name: String,\n-        /// The name space for whihc the collision(s) occurred in.\n+        /// The name space for which the collision(s) occurred in.\n         namespace: String,\n         /// Span where the name is first re-exported.\n         first_reexport_span: Span,"}, {"sha": "b0783d75d4756156696775ca2950742929aff0be", "filename": "compiler/rustc_llvm/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fbuild.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -10,6 +10,7 @@ const OPTIONAL_COMPONENTS: &[&str] = &[\n     \"aarch64\",\n     \"amdgpu\",\n     \"avr\",\n+    \"loongarch\",\n     \"m68k\",\n     \"mips\",\n     \"powerpc\","}, {"sha": "08e38b0c9d59e3ed505ad1e3982668ca9854ee13", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -146,6 +146,12 @@ extern \"C\" void LLVMTimeTraceProfilerFinish(const char* FileName) {\n #define SUBTARGET_HEXAGON\n #endif\n \n+#ifdef LLVM_COMPONENT_LOONGARCH\n+#define SUBTARGET_LOONGARCH SUBTARGET(LoongArch)\n+#else\n+#define SUBTARGET_LOONGARCH\n+#endif\n+\n #define GEN_SUBTARGETS                                                         \\\n   SUBTARGET_X86                                                                \\\n   SUBTARGET_ARM                                                                \\\n@@ -159,6 +165,7 @@ extern \"C\" void LLVMTimeTraceProfilerFinish(const char* FileName) {\n   SUBTARGET_SPARC                                                              \\\n   SUBTARGET_HEXAGON                                                            \\\n   SUBTARGET_RISCV                                                              \\\n+  SUBTARGET_LOONGARCH                                                          \\\n \n #define SUBTARGET(x)                                                           \\\n   namespace llvm {                                                             \\"}, {"sha": "a49ded4fd7baa53f23f2d4a54f16f44b6b6e27a1", "filename": "compiler/rustc_llvm/src/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fsrc%2Flib.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -102,6 +102,14 @@ pub fn initialize_available_targets() {\n         LLVMInitializeM68kAsmPrinter,\n         LLVMInitializeM68kAsmParser\n     );\n+    init_target!(\n+        llvm_component = \"loongarch\",\n+        LLVMInitializeLoongArchTargetInfo,\n+        LLVMInitializeLoongArchTarget,\n+        LLVMInitializeLoongArchTargetMC,\n+        LLVMInitializeLoongArchAsmPrinter,\n+        LLVMInitializeLoongArchAsmParser\n+    );\n     init_target!(\n         llvm_component = \"mips\",\n         LLVMInitializeMipsTargetInfo,"}, {"sha": "3cbb2c21e289e9c72c7f4cc7559dd0abc329f081", "filename": "compiler/rustc_log/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_log%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_log%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_log%2Fsrc%2Flib.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -40,7 +40,6 @@\n \n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n-#![feature(is_terminal)]\n \n use std::env::{self, VarError};\n use std::fmt::{self, Display};"}, {"sha": "427c82c410b91dd240b9cb42fcd4572bff047062", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -392,14 +392,16 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n             }\n             SubdiagnosticKind::Note | SubdiagnosticKind::Help | SubdiagnosticKind::Warn => {\n                 let inner = info.ty.inner_type();\n-                if type_matches_path(inner, &[\"rustc_span\", \"Span\"]) {\n+                if type_matches_path(inner, &[\"rustc_span\", \"Span\"])\n+                    || type_matches_path(inner, &[\"rustc_span\", \"MultiSpan\"])\n+                {\n                     Ok(self.add_spanned_subdiagnostic(binding, &fn_ident, slug))\n                 } else if type_is_unit(inner)\n                     || (matches!(info.ty, FieldInnerTy::Plain(_)) && type_is_bool(inner))\n                 {\n                     Ok(self.add_subdiagnostic(&fn_ident, slug))\n                 } else {\n-                    report_type_error(attr, \"`Span`, `bool` or `()`\")?\n+                    report_type_error(attr, \"`Span`, `MultiSpan`, `bool` or `()`\")?\n                 }\n             }\n             SubdiagnosticKind::Suggestion {"}, {"sha": "2930ce75028b739a6cc4316467775833be320a99", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1,6 +1,7 @@\n // Decoding metadata from a single crate's metadata\n \n use crate::creader::{CStore, CrateMetadataRef};\n+use crate::rmeta::table::IsDefault;\n use crate::rmeta::*;\n \n use rustc_ast as ast;\n@@ -749,6 +750,10 @@ impl CrateRoot {\n }\n \n impl<'a, 'tcx> CrateMetadataRef<'a> {\n+    fn missing(self, descr: &str, id: DefIndex) -> ! {\n+        bug!(\"missing `{descr}` for {:?}\", self.local_def_id(id))\n+    }\n+\n     fn raw_proc_macro(self, id: DefIndex) -> &'a ProcMacro {\n         // DefIndex's in root.proc_macro_data have a one-to-one correspondence\n         // with items in 'raw_proc_macros'.\n@@ -782,8 +787,13 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n     fn opt_item_ident(self, item_index: DefIndex, sess: &Session) -> Option<Ident> {\n         let name = self.opt_item_name(item_index)?;\n-        let span =\n-            self.root.tables.def_ident_span.get(self, item_index).unwrap().decode((self, sess));\n+        let span = self\n+            .root\n+            .tables\n+            .def_ident_span\n+            .get(self, item_index)\n+            .unwrap_or_else(|| self.missing(\"def_ident_span\", item_index))\n+            .decode((self, sess));\n         Some(Ident::new(name, span))\n     }\n \n@@ -812,7 +822,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .tables\n             .def_span\n             .get(self, index)\n-            .unwrap_or_else(|| panic!(\"Missing span for {index:?}\"))\n+            .unwrap_or_else(|| self.missing(\"def_span\", index))\n             .decode((self, sess))\n     }\n \n@@ -924,7 +934,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .tables\n             .visibility\n             .get(self, id)\n-            .unwrap()\n+            .unwrap_or_else(|| self.missing(\"visibility\", id))\n             .decode(self)\n             .map_id(|index| self.local_def_id(index))\n     }\n@@ -934,7 +944,12 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_expn_that_defined(self, id: DefIndex, sess: &Session) -> ExpnId {\n-        self.root.tables.expn_that_defined.get(self, id).unwrap().decode((self, sess))\n+        self.root\n+            .tables\n+            .expn_that_defined\n+            .get(self, id)\n+            .unwrap_or_else(|| self.missing(\"expn_that_defined\", id))\n+            .decode((self, sess))\n     }\n \n     fn get_debugger_visualizers(self) -> Vec<rustc_span::DebuggerVisualizerFile> {\n@@ -981,17 +996,11 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n     fn get_mod_child(self, id: DefIndex, sess: &Session) -> ModChild {\n         let ident = self.item_ident(id, sess);\n-        let kind = self.def_kind(id);\n-        let def_id = self.local_def_id(id);\n-        let res = Res::Def(kind, def_id);\n+        let res = Res::Def(self.def_kind(id), self.local_def_id(id));\n         let vis = self.get_visibility(id);\n         let span = self.get_span(id, sess);\n-        let macro_rules = match kind {\n-            DefKind::Macro(..) => self.root.tables.is_macro_rules.get(self, id),\n-            _ => false,\n-        };\n \n-        ModChild { ident, res, vis, span, macro_rules, reexport_chain: Default::default() }\n+        ModChild { ident, res, vis, span, reexport_chain: Default::default() }\n     }\n \n     /// Iterates over all named children of the given module,\n@@ -1015,12 +1024,14 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             } else {\n                 // Iterate over all children.\n                 for child_index in self.root.tables.children.get(self, id).unwrap().decode(self) {\n+                    // FIXME: Do not encode RPITITs as a part of this list.\n                     if self.root.tables.opt_rpitit_info.get(self, child_index).is_none() {\n                         yield self.get_mod_child(child_index, sess);\n                     }\n                 }\n \n-                if let Some(reexports) = self.root.tables.module_reexports.get(self, id) {\n+                let reexports = self.root.tables.module_children_reexports.get(self, id);\n+                if !reexports.is_default() {\n                     for reexport in reexports.decode((self, sess)) {\n                         yield reexport;\n                     }"}, {"sha": "31798afb852c5da3e26e791223b6ad13ebe3dc09", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -253,7 +253,19 @@ provide! { tcx, def_id, other, cdata,\n             .get(cdata, def_id.index)\n             .map(|lazy| lazy.decode((cdata, tcx)))\n             .process_decoded(tcx, || panic!(\"{def_id:?} does not have trait_impl_trait_tys\")))\n-     }\n+    }\n+    implied_predicates_of => {\n+        cdata\n+            .root\n+            .tables\n+            .implied_predicates_of\n+            .get(cdata, def_id.index)\n+            .map(|lazy| lazy.decode((cdata, tcx)))\n+            .unwrap_or_else(|| {\n+                debug_assert_eq!(tcx.def_kind(def_id), DefKind::Trait);\n+                tcx.super_predicates_of(def_id)\n+            })\n+    }\n \n     associated_types_for_impl_traits_in_associated_fn => { table_defaulted_array }\n "}, {"sha": "657b903e0a8affa6112e56fbde7098464f5620c2", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 179, "deletions": 119, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -43,7 +43,6 @@ use std::borrow::Borrow;\n use std::collections::hash_map::Entry;\n use std::hash::Hash;\n use std::io::{Read, Seek, Write};\n-use std::iter;\n use std::num::NonZeroUsize;\n use std::path::{Path, PathBuf};\n \n@@ -456,7 +455,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_info_for_items(&mut self) {\n-        self.encode_info_for_mod(CRATE_DEF_ID, self.tcx.hir().root_module());\n+        self.encode_info_for_mod(CRATE_DEF_ID);\n \n         // Proc-macro crates only export proc-macro items, which are looked\n         // up using `proc_macro_data`\n@@ -811,7 +810,7 @@ fn analyze_attr(attr: &Attribute, state: &mut AnalyzeAttrState) -> bool {\n     should_encode\n }\n \n-fn should_encode_visibility(def_kind: DefKind) -> bool {\n+fn should_encode_span(def_kind: DefKind) -> bool {\n     match def_kind {\n         DefKind::Mod\n         | DefKind::Struct\n@@ -823,25 +822,136 @@ fn should_encode_visibility(def_kind: DefKind) -> bool {\n         | DefKind::ForeignTy\n         | DefKind::TraitAlias\n         | DefKind::AssocTy\n+        | DefKind::TyParam\n         | DefKind::Fn\n         | DefKind::Const\n-        | DefKind::Static(..)\n+        | DefKind::Static(_)\n         | DefKind::Ctor(..)\n         | DefKind::AssocFn\n         | DefKind::AssocConst\n-        | DefKind::Macro(..)\n+        | DefKind::Macro(_)\n+        | DefKind::AnonConst\n+        | DefKind::InlineConst\n+        | DefKind::OpaqueTy\n+        | DefKind::Field\n+        | DefKind::Impl { .. }\n+        | DefKind::Closure\n+        | DefKind::Generator => true,\n+        DefKind::ConstParam\n+        | DefKind::ExternCrate\n+        | DefKind::Use\n+        | DefKind::ForeignMod\n+        | DefKind::ImplTraitPlaceholder\n+        | DefKind::LifetimeParam\n+        | DefKind::GlobalAsm => false,\n+    }\n+}\n+\n+fn should_encode_attrs(def_kind: DefKind) -> bool {\n+    match def_kind {\n+        DefKind::Mod\n+        | DefKind::Struct\n+        | DefKind::Union\n+        | DefKind::Enum\n+        | DefKind::Variant\n+        | DefKind::Trait\n+        | DefKind::TyAlias\n+        | DefKind::ForeignTy\n+        | DefKind::TraitAlias\n+        | DefKind::AssocTy\n+        | DefKind::Fn\n+        | DefKind::Const\n+        | DefKind::Static(_)\n+        | DefKind::AssocFn\n+        | DefKind::AssocConst\n+        | DefKind::Macro(_)\n+        | DefKind::Field\n+        | DefKind::Impl { .. } => true,\n+        DefKind::TyParam\n+        | DefKind::ConstParam\n+        | DefKind::Ctor(..)\n+        | DefKind::ExternCrate\n+        | DefKind::Use\n+        | DefKind::ForeignMod\n+        | DefKind::AnonConst\n+        | DefKind::InlineConst\n+        | DefKind::OpaqueTy\n+        | DefKind::ImplTraitPlaceholder\n+        | DefKind::LifetimeParam\n+        | DefKind::GlobalAsm\n+        | DefKind::Closure\n+        | DefKind::Generator => false,\n+    }\n+}\n+\n+fn should_encode_expn_that_defined(def_kind: DefKind) -> bool {\n+    match def_kind {\n+        DefKind::Mod\n+        | DefKind::Struct\n+        | DefKind::Union\n+        | DefKind::Enum\n+        | DefKind::Variant\n+        | DefKind::Trait\n+        | DefKind::Impl { .. } => true,\n+        DefKind::TyAlias\n+        | DefKind::ForeignTy\n+        | DefKind::TraitAlias\n+        | DefKind::AssocTy\n+        | DefKind::TyParam\n+        | DefKind::Fn\n+        | DefKind::Const\n+        | DefKind::ConstParam\n+        | DefKind::Static(_)\n+        | DefKind::Ctor(..)\n+        | DefKind::AssocFn\n+        | DefKind::AssocConst\n+        | DefKind::Macro(_)\n+        | DefKind::ExternCrate\n         | DefKind::Use\n         | DefKind::ForeignMod\n+        | DefKind::AnonConst\n+        | DefKind::InlineConst\n         | DefKind::OpaqueTy\n         | DefKind::ImplTraitPlaceholder\n-        | DefKind::Impl { .. }\n+        | DefKind::Field\n+        | DefKind::LifetimeParam\n+        | DefKind::GlobalAsm\n+        | DefKind::Closure\n+        | DefKind::Generator => false,\n+    }\n+}\n+\n+fn should_encode_visibility(def_kind: DefKind) -> bool {\n+    match def_kind {\n+        DefKind::Mod\n+        | DefKind::Struct\n+        | DefKind::Union\n+        | DefKind::Enum\n+        | DefKind::Variant\n+        | DefKind::Trait\n+        | DefKind::TyAlias\n+        | DefKind::ForeignTy\n+        | DefKind::TraitAlias\n+        | DefKind::AssocTy\n+        | DefKind::Fn\n+        | DefKind::Const\n+        | DefKind::Static(..)\n+        | DefKind::Ctor(..)\n+        | DefKind::AssocFn\n+        | DefKind::AssocConst\n+        | DefKind::Macro(..)\n         | DefKind::Field => true,\n-        DefKind::TyParam\n+        DefKind::Use\n+        | DefKind::ForeignMod\n+        | DefKind::TyParam\n         | DefKind::ConstParam\n         | DefKind::LifetimeParam\n         | DefKind::AnonConst\n         | DefKind::InlineConst\n+        | DefKind::OpaqueTy\n+        | DefKind::ImplTraitPlaceholder\n         | DefKind::GlobalAsm\n+        | DefKind::Impl { .. }\n         | DefKind::Closure\n         | DefKind::Generator\n         | DefKind::ExternCrate => false,\n@@ -1160,11 +1270,17 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             let def_kind = tcx.opt_def_kind(local_id);\n             let Some(def_kind) = def_kind else { continue };\n             self.tables.opt_def_kind.set_some(def_id.index, def_kind);\n-            let def_span = tcx.def_span(local_id);\n-            record!(self.tables.def_span[def_id] <- def_span);\n-            self.encode_attrs(local_id);\n-            record!(self.tables.expn_that_defined[def_id] <- self.tcx.expn_that_defined(def_id));\n-            if let Some(ident_span) = tcx.def_ident_span(def_id) {\n+            if should_encode_span(def_kind) {\n+                let def_span = tcx.def_span(local_id);\n+                record!(self.tables.def_span[def_id] <- def_span);\n+            }\n+            if should_encode_attrs(def_kind) {\n+                self.encode_attrs(local_id);\n+            }\n+            if should_encode_expn_that_defined(def_kind) {\n+                record!(self.tables.expn_that_defined[def_id] <- self.tcx.expn_that_defined(def_id));\n+            }\n+            if should_encode_span(def_kind) && let Some(ident_span) = tcx.def_ident_span(def_id) {\n                 record!(self.tables.def_ident_span[def_id] <- ident_span);\n             }\n             if def_kind.has_codegen_attrs() {\n@@ -1199,11 +1315,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 let default = self.tcx.object_lifetime_default(def_id);\n                 record!(self.tables.object_lifetime_default[def_id] <- default);\n             }\n-            if let DefKind::Trait | DefKind::TraitAlias = def_kind {\n+            if let DefKind::Trait = def_kind {\n                 record!(self.tables.super_predicates_of[def_id] <- self.tcx.super_predicates_of(def_id));\n             }\n+            if let DefKind::TraitAlias = def_kind {\n+                record!(self.tables.super_predicates_of[def_id] <- self.tcx.super_predicates_of(def_id));\n+                record!(self.tables.implied_predicates_of[def_id] <- self.tcx.implied_predicates_of(def_id));\n+            }\n             if let DefKind::Enum | DefKind::Struct | DefKind::Union = def_kind {\n-                self.encode_info_for_adt(def_id);\n+                self.encode_info_for_adt(local_id);\n             }\n             if tcx.impl_method_has_trait_impl_trait_tys(def_id)\n                 && let Ok(table) = self.tcx.collect_return_position_impl_trait_in_trait_tys(def_id)\n@@ -1236,7 +1356,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     #[instrument(level = \"trace\", skip(self))]\n-    fn encode_info_for_adt(&mut self, def_id: DefId) {\n+    fn encode_info_for_adt(&mut self, local_def_id: LocalDefId) {\n+        let def_id = local_def_id.to_def_id();\n         let tcx = self.tcx;\n         let adt_def = tcx.adt_def(def_id);\n         record!(self.tables.repr_options[def_id] <- adt_def.repr());\n@@ -1245,15 +1366,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         record!(self.tables.params_in_repr[def_id] <- params_in_repr);\n \n         if adt_def.is_enum() {\n-            record_array!(self.tables.children[def_id] <- iter::from_generator(||\n-                for variant in tcx.adt_def(def_id).variants() {\n-                    yield variant.def_id.index;\n-                    // Encode constructors which take a separate slot in value namespace.\n-                    if let Some(ctor_def_id) = variant.ctor_def_id() {\n-                        yield ctor_def_id.index;\n-                    }\n-                }\n-            ));\n+            let module_children = tcx.module_children_non_reexports(local_def_id);\n+            record_array!(self.tables.children[def_id] <-\n+                module_children.iter().map(|def_id| def_id.local_def_index));\n         } else {\n             // For non-enum, there is only one variant, and its def_id is the adt's.\n             debug_assert_eq!(adt_def.variants().len(), 1);\n@@ -1285,7 +1400,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn encode_info_for_mod(&mut self, local_def_id: LocalDefId, md: &hir::Mod<'_>) {\n+    fn encode_info_for_mod(&mut self, local_def_id: LocalDefId) {\n         let tcx = self.tcx;\n         let def_id = local_def_id.to_def_id();\n         debug!(\"EncodeContext::encode_info_for_mod({:?})\", def_id);\n@@ -1299,38 +1414,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             // Encode this here because we don't do it in encode_def_ids.\n             record!(self.tables.expn_that_defined[def_id] <- tcx.expn_that_defined(local_def_id));\n         } else {\n-            record_array!(self.tables.children[def_id] <- iter::from_generator(|| {\n-                for item_id in md.item_ids {\n-                    match tcx.hir().item(*item_id).kind {\n-                        // Foreign items are planted into their parent modules\n-                        // from name resolution point of view.\n-                        hir::ItemKind::ForeignMod { items, .. } => {\n-                            for foreign_item in items {\n-                                yield foreign_item.id.owner_id.def_id.local_def_index;\n-                            }\n-                        }\n-                        // Only encode named non-reexport children, reexports are encoded\n-                        // separately and unnamed items are not used by name resolution.\n-                        hir::ItemKind::ExternCrate(..) => continue,\n-                        hir::ItemKind::Struct(ref vdata, _) => {\n-                            yield item_id.owner_id.def_id.local_def_index;\n-                            // Encode constructors which take a separate slot in value namespace.\n-                            if let Some(ctor_def_id) = vdata.ctor_def_id() {\n-                                yield ctor_def_id.local_def_index;\n-                            }\n-                        }\n-                        _ if tcx.def_key(item_id.owner_id.to_def_id()).get_opt_name().is_some() => {\n-                            yield item_id.owner_id.def_id.local_def_index;\n-                        }\n-                        _ => continue,\n-                    }\n-                }\n-            }));\n+            let non_reexports = tcx.module_children_non_reexports(local_def_id);\n+            record_array!(self.tables.children[def_id] <-\n+                non_reexports.iter().map(|def_id| def_id.local_def_index));\n \n-            let reexports = tcx.module_reexports(local_def_id);\n-            if !reexports.is_empty() {\n-                record_array!(self.tables.module_reexports[def_id] <- reexports);\n-            }\n+            record_defaulted_array!(self.tables.module_children_reexports[def_id] <-\n+                tcx.module_children_reexports(local_def_id));\n         }\n     }\n \n@@ -1523,23 +1612,32 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         })\n     }\n \n-    fn encode_info_for_item(&mut self, def_id: DefId, item: &'tcx hir::Item<'tcx>) {\n+    fn encode_info_for_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         let tcx = self.tcx;\n-\n+        let def_id = item.owner_id.to_def_id();\n         debug!(\"EncodeContext::encode_info_for_item({:?})\", def_id);\n \n+        let record_associated_item_def_ids = |this: &mut Self, def_ids: &[DefId]| {\n+            record_array!(this.tables.children[def_id] <- def_ids.iter().map(|&def_id| {\n+                assert!(def_id.is_local());\n+                def_id.index\n+            }))\n+        };\n+\n         match item.kind {\n             hir::ItemKind::Fn(ref sig, .., body) => {\n                 self.tables.asyncness.set_some(def_id.index, sig.header.asyncness);\n                 record_array!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body));\n                 self.tables.constness.set_some(def_id.index, sig.header.constness);\n+                record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n+                self.tables.is_intrinsic.set(def_id.index, tcx.is_intrinsic(def_id));\n             }\n             hir::ItemKind::Macro(ref macro_def, _) => {\n                 self.tables.is_macro_rules.set(def_id.index, macro_def.macro_rules);\n                 record!(self.tables.macro_definition[def_id] <- &*macro_def.body);\n             }\n-            hir::ItemKind::Mod(ref m) => {\n-                return self.encode_info_for_mod(item.owner_id.def_id, m);\n+            hir::ItemKind::Mod(..) => {\n+                self.encode_info_for_mod(item.owner_id.def_id);\n             }\n             hir::ItemKind::OpaqueTy(ref opaque) => {\n                 self.encode_explicit_item_bounds(def_id);\n@@ -1550,9 +1648,11 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             hir::ItemKind::Impl(hir::Impl { defaultness, constness, .. }) => {\n                 self.tables.impl_defaultness.set_some(def_id.index, *defaultness);\n                 self.tables.constness.set_some(def_id.index, *constness);\n+                self.tables.impl_polarity.set_some(def_id.index, self.tcx.impl_polarity(def_id));\n+\n+                if let Some(trait_ref) = self.tcx.impl_trait_ref(def_id) {\n+                    record!(self.tables.impl_trait_ref[def_id] <- trait_ref);\n \n-                let trait_ref = self.tcx.impl_trait_ref(def_id);\n-                if let Some(trait_ref) = trait_ref {\n                     let trait_ref = trait_ref.skip_binder();\n                     let trait_def = self.tcx.trait_def(trait_ref.def_id);\n                     if let Ok(mut an) = trait_def.ancestors(self.tcx, def_id) {\n@@ -1570,71 +1670,34 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     }\n                 }\n \n-                let polarity = self.tcx.impl_polarity(def_id);\n-                self.tables.impl_polarity.set_some(def_id.index, polarity);\n+                let associated_item_def_ids = self.tcx.associated_item_def_ids(def_id);\n+                record_associated_item_def_ids(self, associated_item_def_ids);\n+                for &trait_item_def_id in associated_item_def_ids {\n+                    self.encode_info_for_impl_item(trait_item_def_id);\n+                }\n             }\n             hir::ItemKind::Trait(..) => {\n-                let trait_def = self.tcx.trait_def(def_id);\n-                record!(self.tables.trait_def[def_id] <- trait_def);\n+                record!(self.tables.trait_def[def_id] <- self.tcx.trait_def(def_id));\n+\n+                let associated_item_def_ids = self.tcx.associated_item_def_ids(def_id);\n+                record_associated_item_def_ids(self, associated_item_def_ids);\n+                for &item_def_id in associated_item_def_ids {\n+                    self.encode_info_for_trait_item(item_def_id);\n+                }\n             }\n             hir::ItemKind::TraitAlias(..) => {\n-                let trait_def = self.tcx.trait_def(def_id);\n-                record!(self.tables.trait_def[def_id] <- trait_def);\n-            }\n-            hir::ItemKind::ExternCrate(_) | hir::ItemKind::Use(..) => {\n-                bug!(\"cannot encode info for item {:?}\", item)\n+                record!(self.tables.trait_def[def_id] <- self.tcx.trait_def(def_id));\n             }\n-            hir::ItemKind::Static(..)\n+            hir::ItemKind::ExternCrate(_)\n+            | hir::ItemKind::Use(..)\n+            | hir::ItemKind::Static(..)\n             | hir::ItemKind::Const(..)\n             | hir::ItemKind::Enum(..)\n             | hir::ItemKind::Struct(..)\n             | hir::ItemKind::Union(..)\n             | hir::ItemKind::ForeignMod { .. }\n             | hir::ItemKind::GlobalAsm(..)\n             | hir::ItemKind::TyAlias(..) => {}\n-        };\n-        // FIXME(eddyb) there should be a nicer way to do this.\n-        match item.kind {\n-            hir::ItemKind::Impl { .. } | hir::ItemKind::Trait(..) => {\n-                let associated_item_def_ids = self.tcx.associated_item_def_ids(def_id);\n-                record_array!(self.tables.children[def_id] <-\n-                    associated_item_def_ids.iter().map(|&def_id| {\n-                        assert!(def_id.is_local());\n-                        def_id.index\n-                    })\n-                );\n-            }\n-            _ => {}\n-        }\n-        if let hir::ItemKind::Fn(..) = item.kind {\n-            record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n-            self.tables.is_intrinsic.set(def_id.index, tcx.is_intrinsic(def_id));\n-        }\n-        if let hir::ItemKind::Impl { .. } = item.kind {\n-            if let Some(trait_ref) = self.tcx.impl_trait_ref(def_id) {\n-                record!(self.tables.impl_trait_ref[def_id] <- trait_ref);\n-            }\n-        }\n-        // In some cases, along with the item itself, we also\n-        // encode some sub-items. Usually we want some info from the item\n-        // so it's easier to do that here then to wait until we would encounter\n-        // normally in the visitor walk.\n-        match item.kind {\n-            hir::ItemKind::Impl { .. } => {\n-                for &trait_item_def_id in\n-                    self.tcx.associated_item_def_ids(item.owner_id.to_def_id()).iter()\n-                {\n-                    self.encode_info_for_impl_item(trait_item_def_id);\n-                }\n-            }\n-            hir::ItemKind::Trait(..) => {\n-                for &item_def_id in\n-                    self.tcx.associated_item_def_ids(item.owner_id.to_def_id()).iter()\n-                {\n-                    self.encode_info_for_trait_item(item_def_id);\n-                }\n-            }\n-            _ => {}\n         }\n     }\n \n@@ -2020,10 +2083,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EncodeContext<'a, 'tcx> {\n     }\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         intravisit::walk_item(self, item);\n-        match item.kind {\n-            hir::ItemKind::ExternCrate(_) | hir::ItemKind::Use(..) => {} // ignore these\n-            _ => self.encode_info_for_item(item.owner_id.to_def_id(), item),\n-        }\n+        self.encode_info_for_item(item);\n     }\n     fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem<'tcx>) {\n         intravisit::walk_foreign_item(self, ni);"}, {"sha": "dc77a079b075d6a35f064d0447d44e4212cae2cd", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -357,6 +357,7 @@ define_tables! {\n     associated_types_for_impl_traits_in_associated_fn: Table<DefIndex, LazyArray<DefId>>,\n     opt_rpitit_info: Table<DefIndex, Option<LazyValue<ty::ImplTraitInTraitData>>>,\n     unused_generic_params: Table<DefIndex, UnusedGenericParams>,\n+    module_children_reexports: Table<DefIndex, LazyArray<ModChild>>,\n \n - optional:\n     attributes: Table<DefIndex, LazyArray<ast::Attribute>>,\n@@ -372,6 +373,9 @@ define_tables! {\n     explicit_predicates_of: Table<DefIndex, LazyValue<ty::GenericPredicates<'static>>>,\n     generics_of: Table<DefIndex, LazyValue<ty::Generics>>,\n     super_predicates_of: Table<DefIndex, LazyValue<ty::GenericPredicates<'static>>>,\n+    // As an optimization, we only store this for trait aliases,\n+    // since it's identical to super_predicates_of for traits.\n+    implied_predicates_of: Table<DefIndex, LazyValue<ty::GenericPredicates<'static>>>,\n     type_of: Table<DefIndex, LazyValue<ty::EarlyBinder<Ty<'static>>>>,\n     variances_of: Table<DefIndex, LazyArray<ty::Variance>>,\n     fn_sig: Table<DefIndex, LazyValue<ty::EarlyBinder<ty::PolyFnSig<'static>>>>,\n@@ -383,7 +387,6 @@ define_tables! {\n     mir_for_ctfe: Table<DefIndex, LazyValue<mir::Body<'static>>>,\n     mir_generator_witnesses: Table<DefIndex, LazyValue<mir::GeneratorLayout<'static>>>,\n     promoted_mir: Table<DefIndex, LazyValue<IndexVec<mir::Promoted, mir::Body<'static>>>>,\n-    // FIXME(compiler-errors): Why isn't this a LazyArray?\n     thir_abstract_const: Table<DefIndex, LazyValue<ty::Const<'static>>>,\n     impl_parent: Table<DefIndex, RawDefId>,\n     impl_polarity: Table<DefIndex, ty::ImplPolarity>,\n@@ -412,7 +415,6 @@ define_tables! {\n     assoc_container: Table<DefIndex, ty::AssocItemContainer>,\n     macro_definition: Table<DefIndex, LazyValue<ast::DelimArgs>>,\n     proc_macro: Table<DefIndex, MacroKind>,\n-    module_reexports: Table<DefIndex, LazyArray<ModChild>>,\n     deduced_param_attrs: Table<DefIndex, LazyArray<DeducedParamAttrs>>,\n     trait_impl_trait_tys: Table<DefIndex, LazyValue<FxHashMap<DefId, Ty<'static>>>>,\n     doc_link_resolutions: Table<DefIndex, LazyValue<DocLinkResMap>>,"}, {"sha": "e551c76f8db3868966fd64b67f52fc0ac6bea2b4", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -8,7 +8,7 @@ use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::{par_for_each_in, Send, Sync};\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n-use rustc_hir::definitions::{DefKey, DefPath, DefPathHash};\n+use rustc_hir::definitions::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::*;\n use rustc_index::vec::Idx;\n@@ -179,7 +179,19 @@ impl<'hir> Map<'hir> {\n     /// Do not call this function directly. The query should be called.\n     pub(super) fn opt_def_kind(self, local_def_id: LocalDefId) -> Option<DefKind> {\n         let hir_id = self.local_def_id_to_hir_id(local_def_id);\n-        let def_kind = match self.find(hir_id)? {\n+        let node = match self.find(hir_id) {\n+            Some(node) => node,\n+            None => match self.def_key(local_def_id).disambiguated_data.data {\n+                // FIXME: Some anonymous constants do not have corresponding HIR nodes,\n+                // so many local queries will panic on their def ids. `None` is currently\n+                // returned here instead of `DefKind::{Anon,Inline}Const` to avoid such panics.\n+                // Ideally all def ids should have `DefKind`s, we need to create the missing\n+                // HIR nodes or feed relevant query results to achieve that.\n+                DefPathData::AnonConst => return None,\n+                _ => bug!(\"no HIR node for def id {local_def_id:?}\"),\n+            },\n+        };\n+        let def_kind = match node {\n             Node::Item(item) => match item.kind {\n                 ItemKind::Static(_, mt, _) => DefKind::Static(mt),\n                 ItemKind::Const(..) => DefKind::Const,\n@@ -266,7 +278,10 @@ impl<'hir> Map<'hir> {\n             | Node::Param(_)\n             | Node::Arm(_)\n             | Node::Lifetime(_)\n-            | Node::Block(_) => return None,\n+            | Node::Block(_) => span_bug!(\n+                self.span(hir_id),\n+                \"unexpected node with def id {local_def_id:?}: {node:?}\"\n+            ),\n         };\n         Some(def_kind)\n     }"}, {"sha": "7770a5e47641886a23e8ade279984e8b2cd6f03e", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -7,7 +7,7 @@ pub mod nested_filter;\n pub mod place;\n \n use crate::ty::query::Providers;\n-use crate::ty::{ImplSubject, TyCtxt};\n+use crate::ty::{EarlyBinder, ImplSubject, TyCtxt};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::{par_for_each_in, Send, Sync};\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -104,11 +104,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.parent_module_from_def_id(id.owner.def_id)\n     }\n \n-    pub fn impl_subject(self, def_id: DefId) -> ImplSubject<'tcx> {\n-        self.impl_trait_ref(def_id)\n-            .map(|t| t.subst_identity())\n-            .map(ImplSubject::Trait)\n-            .unwrap_or_else(|| ImplSubject::Inherent(self.type_of(def_id).subst_identity()))\n+    pub fn impl_subject(self, def_id: DefId) -> EarlyBinder<ImplSubject<'tcx>> {\n+        match self.impl_trait_ref(def_id) {\n+            Some(t) => t.map_bound(ImplSubject::Trait),\n+            None => self.type_of(def_id).map_bound(ImplSubject::Inherent),\n+        }\n     }\n }\n "}, {"sha": "a873854f0686ac09b042fe137d742f60d09b17e6", "filename": "compiler/rustc_middle/src/infer/unify_key.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -58,7 +58,7 @@ impl<'tcx> UnifyValue for UnifiedRegion<'tcx> {\n \n     fn unify_values(value1: &Self, value2: &Self) -> Result<Self, NoError> {\n         // We pick the value of the least universe because it is compatible with more variables.\n-        // This is *not* neccessary for soundness, but it allows more region variables to be\n+        // This is *not* necessary for soundness, but it allows more region variables to be\n         // resolved to the said value.\n         #[cold]\n         fn min_universe<'tcx>(r1: Region<'tcx>, r2: Region<'tcx>) -> Region<'tcx> {"}, {"sha": "89014f62d4d69ff4ef05659f5ac07b8756117559", "filename": "compiler/rustc_middle/src/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1,6 +1,6 @@\n /// A macro for triggering an ICE.\n /// Calling `bug` instead of panicking will result in a nicer error message and should\n-/// therefore be prefered over `panic`/`unreachable` or others.\n+/// therefore be preferred over `panic`/`unreachable` or others.\n ///\n /// If you have a span available, you should use [`span_bug`] instead.\n ///"}, {"sha": "f3170e0ec0e1c7187e27e10eae23d9f584bb5d1e", "filename": "compiler/rustc_middle/src/metadata.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmetadata.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -43,8 +43,6 @@ pub struct ModChild {\n     pub vis: ty::Visibility<DefId>,\n     /// Span of the item.\n     pub span: Span,\n-    /// A proper `macro_rules` item (not a reexport).\n-    pub macro_rules: bool,\n     /// Reexport chain linking this module child to its original reexported item.\n     /// Empty if the module child is a proper item.\n     pub reexport_chain: SmallVec<[Reexport; 2]>,"}, {"sha": "dcb56a1755e45b6e2570ac782a7022dac721ec7c", "filename": "compiler/rustc_middle/src/mir/interpret/allocation/init_mask.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Finit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Finit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Finit_mask.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -63,7 +63,7 @@ impl InitMask {\n     }\n \n     /// Sets a specified range to a value. If the range is out-of-bounds, the mask will grow to\n-    /// accomodate it entirely.\n+    /// accommodate it entirely.\n     pub fn set_range(&mut self, range: AllocRange, new_state: bool) {\n         let start = range.start;\n         let end = range.end();"}, {"sha": "318f93e12b582d47650c24e8f47e957cf30f24de", "filename": "compiler/rustc_middle/src/mir/interpret/allocation/provenance_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Fprovenance_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Fprovenance_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Fprovenance_map.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -14,7 +14,7 @@ use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n #[derive(HashStable)]\n pub struct ProvenanceMap<Prov = AllocId> {\n     /// Provenance in this map applies from the given offset for an entire pointer-size worth of\n-    /// bytes. Two entires in this map are always at least a pointer size apart.\n+    /// bytes. Two entries in this map are always at least a pointer size apart.\n     ptrs: SortedMap<Size, Prov>,\n     /// Provenance in this map only applies to the given single byte.\n     /// This map is disjoint from the previous. It will always be empty when"}, {"sha": "2ea8602af12a1c0f17451823c91ccd8ffa70829e", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1115,6 +1115,11 @@ pub struct VarDebugInfo<'tcx> {\n \n     /// Where the data for this user variable is to be found.\n     pub value: VarDebugInfoContents<'tcx>,\n+\n+    /// When present, indicates what argument number this variable is in the function that it\n+    /// originated from (starting from 1). Note, if MIR inlining is enabled, then this is the\n+    /// argument number in the original function before it was inlined.\n+    pub argument_index: Option<u16>,\n }\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "0a9fcd898b93e691a9c880e73f44ca29ceb25393", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -832,6 +832,7 @@ macro_rules! make_mir_visitor {\n                     name: _,\n                     source_info,\n                     value,\n+                    argument_index: _,\n                 } = var_debug_info;\n \n                 self.visit_source_info(source_info);"}, {"sha": "7d9aea022898d3f3f4c06f2eb1d3e8e903ecba5f", "filename": "compiler/rustc_middle/src/query/erase.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fquery%2Ferase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fquery%2Ferase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Ferase.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -37,7 +37,7 @@ pub fn erase<T: EraseType>(src: T) -> Erase<T> {\n #[inline(always)]\n pub fn restore<T: EraseType>(value: Erase<T>) -> T {\n     let value: Erased<<T as EraseType>::Result> = value;\n-    // SAFETY: Due to the use of impl Trait in `Erase` the only way to safetly create an instance\n+    // SAFETY: Due to the use of impl Trait in `Erase` the only way to safely create an instance\n     // of `Erase` is to call `erase`, so we know that `value.data` is a valid instance of `T` of\n     // the right size.\n     unsafe { transmute_copy(&value.data) }"}, {"sha": "23b28ac5ca938971277394d31ace642d88b880a8", "filename": "compiler/rustc_middle/src/query/keys.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fkeys.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -26,7 +26,7 @@ pub trait Key: Sized {\n     //\n     //      ...But r-a doesn't support them yet and using a default here causes r-a to not infer\n     //      return types of queries which is very annoying. Thus, until r-a support associated\n-    //      type defaults, plese restrain from using them here <3\n+    //      type defaults, please restrain from using them here <3\n     //\n     //      r-a issue: <https://github.com/rust-lang/rust-analyzer/issues/13693>\n     type CacheSelector;\n@@ -230,7 +230,7 @@ impl Key for (LocalDefId, LocalDefId) {\n     }\n }\n \n-impl Key for (DefId, Option<Ident>) {\n+impl Key for (DefId, Ident) {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {"}, {"sha": "7a5a1603585b114cecebeeb1dab77e8dd50bd630", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -97,7 +97,7 @@ rustc_queries! {\n \n     /// Gives access to the HIR ID for the given `LocalDefId` owner `key` if any.\n     ///\n-    /// Definitions that were generated with no HIR, would be feeded to return `None`.\n+    /// Definitions that were generated with no HIR, would be fed to return `None`.\n     query opt_local_def_id_to_hir_id(key: LocalDefId) -> Option<hir::HirId>{\n         desc { |tcx| \"getting HIR ID of `{}`\", tcx.def_path_str(key.to_def_id()) }\n         feedable\n@@ -627,14 +627,20 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n+    query implied_predicates_of(key: DefId) -> ty::GenericPredicates<'tcx> {\n+        desc { |tcx| \"computing the implied predicates of `{}`\", tcx.def_path_str(key) }\n+        cache_on_disk_if { key.is_local() }\n+        separate_provide_extern\n+    }\n+\n     /// The `Option<Ident>` is the name of an associated type. If it is `None`, then this query\n     /// returns the full set of predicates. If `Some<Ident>`, then the query returns only the\n     /// subset of super-predicates that reference traits that define the given associated type.\n     /// This is used to avoid cycles in resolving types like `T::Item`.\n-    query super_predicates_that_define_assoc_type(key: (DefId, Option<rustc_span::symbol::Ident>)) -> ty::GenericPredicates<'tcx> {\n-        desc { |tcx| \"computing the super traits of `{}`{}\",\n+    query super_predicates_that_define_assoc_type(key: (DefId, rustc_span::symbol::Ident)) -> ty::GenericPredicates<'tcx> {\n+        desc { |tcx| \"computing the super traits of `{}` with associated type name `{}`\",\n             tcx.def_path_str(key.0),\n-            if let Some(assoc_name) = key.1 { format!(\" with associated type name `{}`\", assoc_name) } else { \"\".to_string() },\n+            key.1\n         }\n     }\n \n@@ -1510,10 +1516,6 @@ rustc_queries! {\n         desc { \"getting traits in scope at a block\" }\n     }\n \n-    query module_reexports(def_id: LocalDefId) -> &'tcx [ModChild] {\n-        desc { |tcx| \"looking up reexports of module `{}`\", tcx.def_path_str(def_id.to_def_id()) }\n-    }\n-\n     query impl_defaultness(def_id: DefId) -> hir::Defaultness {\n         desc { |tcx| \"looking up whether `{}` is a default impl\", tcx.def_path_str(def_id) }\n         cache_on_disk_if { def_id.is_local() }"}, {"sha": "63f7cc2ee7352ecd566a4ead2c21b204521020e5", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -8,6 +8,7 @@ use crate::arena::Arena;\n use crate::dep_graph::{DepGraph, DepKindStruct};\n use crate::infer::canonical::CanonicalVarInfo;\n use crate::lint::struct_lint_level;\n+use crate::metadata::ModChild;\n use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n use crate::middle::resolve_bound_vars;\n use crate::middle::stability;\n@@ -2459,6 +2460,28 @@ impl<'tcx> TyCtxt<'tcx> {\n             self.def_kind(def_id) == DefKind::ImplTraitPlaceholder\n         }\n     }\n+\n+    /// Named module children from all items except `use` and `extern crate` imports.\n+    ///\n+    /// In addition to regular items this list also includes struct or variant constructors, and\n+    /// items inside `extern {}` blocks because all of them introduce names into parent module.\n+    /// For non-reexported children every such name is associated with a separate `DefId`.\n+    ///\n+    /// Module here is understood in name resolution sense - it can be a `mod` item,\n+    /// or a crate root, or an enum, or a trait.\n+    pub fn module_children_non_reexports(self, def_id: LocalDefId) -> &'tcx [LocalDefId] {\n+        self.resolutions(()).module_children_non_reexports.get(&def_id).map_or(&[], |v| &v[..])\n+    }\n+\n+    /// Named module children from `use` and `extern crate` imports.\n+    ///\n+    /// Reexported names are not associated with individual `DefId`s,\n+    /// e.g. a glob import can introduce a lot of names, all with the same `DefId`.\n+    /// That's why the list needs to contain `ModChild` structures describing all the names\n+    /// individually instead of `DefId`s.\n+    pub fn module_children_reexports(self, def_id: LocalDefId) -> &'tcx [ModChild] {\n+        self.resolutions(()).module_children_reexports.get(&def_id).map_or(&[], |v| &v[..])\n+    }\n }\n \n impl<'tcx> TyCtxtAt<'tcx> {\n@@ -2501,8 +2524,6 @@ pub struct DeducedParamAttrs {\n }\n \n pub fn provide(providers: &mut ty::query::Providers) {\n-    providers.module_reexports =\n-        |tcx, id| tcx.resolutions(()).reexport_map.get(&id).map_or(&[], |v| &v[..]);\n     providers.maybe_unused_trait_imports =\n         |tcx, ()| &tcx.resolutions(()).maybe_unused_trait_imports;\n     providers.names_imported_by_glob_use = |tcx, id| {"}, {"sha": "195d951f9f366af83a45f198e182d692ab289829", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1226,10 +1226,11 @@ pub fn fn_can_unwind(tcx: TyCtxt<'_>, fn_def_id: Option<DefId>, abi: SpecAbi) ->\n         | AvrNonBlockingInterrupt\n         | CCmseNonSecureCall\n         | Wasm\n-        | RustIntrinsic\n         | PlatformIntrinsic\n         | Unadjusted => false,\n-        Rust | RustCall | RustCold => tcx.sess.panic_strategy() == PanicStrategy::Unwind,\n+        Rust | RustCall | RustCold | RustIntrinsic => {\n+            tcx.sess.panic_strategy() == PanicStrategy::Unwind\n+        }\n     }\n }\n "}, {"sha": "2e516f291bc0d5315e18fe8d379014f360d8e27e", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -166,7 +166,8 @@ pub struct ResolverGlobalCtxt {\n     pub effective_visibilities: EffectiveVisibilities,\n     pub extern_crate_map: FxHashMap<LocalDefId, CrateNum>,\n     pub maybe_unused_trait_imports: FxIndexSet<LocalDefId>,\n-    pub reexport_map: FxHashMap<LocalDefId, Vec<ModChild>>,\n+    pub module_children_non_reexports: LocalDefIdMap<Vec<LocalDefId>>,\n+    pub module_children_reexports: LocalDefIdMap<Vec<ModChild>>,\n     pub glob_map: FxHashMap<LocalDefId, FxHashSet<Symbol>>,\n     pub main_def: Option<MainDefinition>,\n     pub trait_impls: FxIndexMap<DefId, Vec<LocalDefId>>,"}, {"sha": "72caadaf66199e7957a9efc2744e9c9fceb7f953", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1347,7 +1347,7 @@ pub trait PrettyPrinter<'tcx>:\n                             p!(write(\"{}::{}\", self.tcx().crate_name(def.did.krate), self.tcx().def_path(def.did).to_string_no_crate_verbose()))\n                         }\n                     }\n-                    defkind => bug!(\"`{:?}` has unexpcted defkind {:?}\", ct, defkind),\n+                    defkind => bug!(\"`{:?}` has unexpected defkind {:?}\", ct, defkind),\n                 }\n             }\n             ty::ConstKind::Infer(infer_ct) => {"}, {"sha": "96c1577d52bcb42aa08646552cc8cca24fd0e068", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 36, "deletions": 90, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -7,14 +7,15 @@ use crate::ty::subst::{GenericArg, InternalSubsts, SubstsRef};\n use crate::ty::visit::ValidateBoundVars;\n use crate::ty::InferTy::*;\n use crate::ty::{\n-    self, AdtDef, Discr, FallibleTypeFolder, Term, Ty, TyCtxt, TypeFlags, TypeFoldable,\n-    TypeSuperFoldable, TypeSuperVisitable, TypeVisitable, TypeVisitableExt, TypeVisitor,\n+    self, AdtDef, Discr, Term, Ty, TyCtxt, TypeFlags, TypeSuperVisitable, TypeVisitable,\n+    TypeVisitableExt, TypeVisitor,\n };\n use crate::ty::{List, ParamEnv};\n use hir::def::DefKind;\n use polonius_engine::Atom;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::intern::Interned;\n+use rustc_errors::{DiagnosticArgValue, IntoDiagnosticArg};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::LangItem;\n@@ -864,8 +865,8 @@ impl<'tcx> PolyTraitRef<'tcx> {\n     }\n }\n \n-impl rustc_errors::IntoDiagnosticArg for PolyTraitRef<'_> {\n-    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+impl<'tcx> IntoDiagnosticArg for TraitRef<'tcx> {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n         self.to_string().into_diagnostic_arg()\n     }\n }\n@@ -910,6 +911,12 @@ impl<'tcx> ExistentialTraitRef<'tcx> {\n     }\n }\n \n+impl<'tcx> IntoDiagnosticArg for ExistentialTraitRef<'tcx> {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        self.to_string().into_diagnostic_arg()\n+    }\n+}\n+\n pub type PolyExistentialTraitRef<'tcx> = Binder<'tcx, ExistentialTraitRef<'tcx>>;\n \n impl<'tcx> PolyExistentialTraitRef<'tcx> {\n@@ -926,12 +933,6 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n     }\n }\n \n-impl rustc_errors::IntoDiagnosticArg for PolyExistentialTraitRef<'_> {\n-    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n-        self.to_string().into_diagnostic_arg()\n-    }\n-}\n-\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub enum BoundVariableKind {\n@@ -1146,78 +1147,12 @@ impl<'tcx, T: IntoIterator> Binder<'tcx, T> {\n     }\n }\n \n-struct SkipBindersAt<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    index: ty::DebruijnIndex,\n-}\n-\n-impl<'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for SkipBindersAt<'tcx> {\n-    type Error = ();\n-\n-    fn interner(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n-    }\n-\n-    fn try_fold_binder<T>(&mut self, t: Binder<'tcx, T>) -> Result<Binder<'tcx, T>, Self::Error>\n-    where\n-        T: ty::TypeFoldable<TyCtxt<'tcx>>,\n-    {\n-        self.index.shift_in(1);\n-        let value = t.try_map_bound(|t| t.try_fold_with(self));\n-        self.index.shift_out(1);\n-        value\n-    }\n-\n-    fn try_fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n-        if !ty.has_escaping_bound_vars() {\n-            Ok(ty)\n-        } else if let ty::Bound(index, bv) = *ty.kind() {\n-            if index == self.index {\n-                Err(())\n-            } else {\n-                Ok(self.interner().mk_bound(index.shifted_out(1), bv))\n-            }\n-        } else {\n-            ty.try_super_fold_with(self)\n-        }\n-    }\n-\n-    fn try_fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n-        if !r.has_escaping_bound_vars() {\n-            Ok(r)\n-        } else if let ty::ReLateBound(index, bv) = r.kind() {\n-            if index == self.index {\n-                Err(())\n-            } else {\n-                Ok(self.interner().mk_re_late_bound(index.shifted_out(1), bv))\n-            }\n-        } else {\n-            r.try_super_fold_with(self)\n-        }\n-    }\n-\n-    fn try_fold_const(&mut self, ct: ty::Const<'tcx>) -> Result<ty::Const<'tcx>, Self::Error> {\n-        if !ct.has_escaping_bound_vars() {\n-            Ok(ct)\n-        } else if let ty::ConstKind::Bound(index, bv) = ct.kind() {\n-            if index == self.index {\n-                Err(())\n-            } else {\n-                Ok(self.interner().mk_const(\n-                    ty::ConstKind::Bound(index.shifted_out(1), bv),\n-                    ct.ty().try_fold_with(self)?,\n-                ))\n-            }\n-        } else {\n-            ct.try_super_fold_with(self)\n-        }\n-    }\n-\n-    fn try_fold_predicate(\n-        &mut self,\n-        p: ty::Predicate<'tcx>,\n-    ) -> Result<ty::Predicate<'tcx>, Self::Error> {\n-        if !p.has_escaping_bound_vars() { Ok(p) } else { p.try_super_fold_with(self) }\n+impl<'tcx, T> IntoDiagnosticArg for Binder<'tcx, T>\n+where\n+    T: IntoDiagnosticArg,\n+{\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        self.0.into_diagnostic_arg()\n     }\n }\n \n@@ -1362,6 +1297,12 @@ impl<'tcx> FnSig<'tcx> {\n     }\n }\n \n+impl<'tcx> IntoDiagnosticArg for FnSig<'tcx> {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        self.to_string().into_diagnostic_arg()\n+    }\n+}\n+\n pub type PolyFnSig<'tcx> = Binder<'tcx, FnSig<'tcx>>;\n \n impl<'tcx> PolyFnSig<'tcx> {\n@@ -1605,19 +1546,24 @@ impl<'tcx> Region<'tcx> {\n \n     pub fn get_name(self) -> Option<Symbol> {\n         if self.has_name() {\n-            let name = match *self {\n+            match *self {\n                 ty::ReEarlyBound(ebr) => Some(ebr.name),\n                 ty::ReLateBound(_, br) => br.kind.get_name(),\n                 ty::ReFree(fr) => fr.bound_region.get_name(),\n                 ty::ReStatic => Some(kw::StaticLifetime),\n                 ty::RePlaceholder(placeholder) => placeholder.bound.kind.get_name(),\n                 _ => None,\n-            };\n-\n-            return name;\n+            }\n+        } else {\n+            None\n         }\n+    }\n \n-        None\n+    pub fn get_name_or_anon(self) -> Symbol {\n+        match self.get_name() {\n+            Some(name) => name,\n+            None => sym::anon,\n+        }\n     }\n \n     /// Is this region named by the user?\n@@ -1751,10 +1697,10 @@ impl<'tcx> Region<'tcx> {\n         matches!(self.kind(), ty::ReVar(_))\n     }\n \n-    pub fn as_var(self) -> Option<RegionVid> {\n+    pub fn as_var(self) -> RegionVid {\n         match self.kind() {\n-            ty::ReVar(vid) => Some(vid),\n-            _ => None,\n+            ty::ReVar(vid) => vid,\n+            _ => bug!(\"expected region {:?} to be of kind ReVar\", self),\n         }\n     }\n }"}, {"sha": "c8a78ec03d94777e8ce7611785a2c73a4c9a662c", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -708,10 +708,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         ty::EarlyBinder(self.explicit_item_bounds(def_id))\n     }\n \n-    pub fn bound_impl_subject(self, def_id: DefId) -> ty::EarlyBinder<ty::ImplSubject<'tcx>> {\n-        ty::EarlyBinder(self.impl_subject(def_id))\n-    }\n-\n     /// Returns names of captured upvars for closures and generators.\n     ///\n     /// Here are some examples:"}, {"sha": "08a62c900f972f00594c4a0c6952717c3e32e295", "filename": "compiler/rustc_middle/src/ty/visit.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -83,6 +83,9 @@ pub trait TypeVisitableExt<'tcx>: TypeVisitable<TyCtxt<'tcx>> {\n                 | TypeFlags::HAS_CT_PLACEHOLDER,\n         )\n     }\n+    fn has_non_region_placeholders(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_TY_PLACEHOLDER | TypeFlags::HAS_CT_PLACEHOLDER)\n+    }\n     fn needs_subst(&self) -> bool {\n         self.has_type_flags(TypeFlags::NEEDS_SUBST)\n     }"}, {"sha": "931fe1b2433a0cb56efc6bebe1609cbde205117e", "filename": "compiler/rustc_mir_build/src/build/custom/parse/instruction.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -148,6 +148,11 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n                     )),\n                 )\n             },\n+            @call(\"mir_offset\", args) => {\n+                let ptr = self.parse_operand(args[0])?;\n+                let offset = self.parse_operand(args[1])?;\n+                Ok(Rvalue::BinaryOp(BinOp::Offset, Box::new((ptr, offset))))\n+            },\n             @call(\"mir_len\", args) => Ok(Rvalue::Len(self.parse_place(args[0])?)),\n             ExprKind::Borrow { borrow_kind, arg } => Ok(\n                 Rvalue::Ref(self.tcx.lifetimes.re_erased, *borrow_kind, self.parse_place(*arg)?)"}, {"sha": "4926ff85de38d0beac9c65c17aa3c41195529366", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -2242,6 +2242,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             name,\n             source_info: debug_source_info,\n             value: VarDebugInfoContents::Place(for_arm_body.into()),\n+            argument_index: None,\n         });\n         let locals = if has_guard.0 {\n             let ref_for_guard = self.local_decls.push(LocalDecl::<'tcx> {\n@@ -2260,6 +2261,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 name,\n                 source_info: debug_source_info,\n                 value: VarDebugInfoContents::Place(ref_for_guard.into()),\n+                argument_index: None,\n             });\n             LocalsForNode::ForGuard { ref_for_guard, for_arm_body }\n         } else {"}, {"sha": "bc50bcbc3d07dcb3ab67eafd6724b313840c7537", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -811,6 +811,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     name,\n                     source_info: SourceInfo::outermost(captured_place.var_ident.span),\n                     value: VarDebugInfoContents::Place(use_place),\n+                    argument_index: None,\n                 });\n \n                 let capture = Capture { captured_place, use_place, mutability };\n@@ -827,7 +828,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         expr: &Expr<'tcx>,\n     ) -> BlockAnd<()> {\n         // Allocate locals for the function arguments\n-        for param in arguments.iter() {\n+        for (argument_index, param) in arguments.iter().enumerate() {\n             let source_info =\n                 SourceInfo::outermost(param.pat.as_ref().map_or(self.fn_span, |pat| pat.span));\n             let arg_local =\n@@ -839,6 +840,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     name,\n                     source_info,\n                     value: VarDebugInfoContents::Place(arg_local.into()),\n+                    argument_index: Some(argument_index as u16 + 1),\n                 });\n             }\n         }"}, {"sha": "43e787db41a8886f0c998ff256401b722a037757", "filename": "compiler/rustc_mir_build/src/errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -593,7 +593,7 @@ pub struct MultipleMutBorrows {\n     #[primary_span]\n     pub span: Span,\n     #[subdiagnostic]\n-    pub occurences: Vec<Conflict>,\n+    pub occurrences: Vec<Conflict>,\n }\n \n #[derive(Diagnostic)]\n@@ -602,7 +602,7 @@ pub struct AlreadyBorrowed {\n     #[primary_span]\n     pub span: Span,\n     #[subdiagnostic]\n-    pub occurences: Vec<Conflict>,\n+    pub occurrences: Vec<Conflict>,\n }\n \n #[derive(Diagnostic)]\n@@ -611,7 +611,7 @@ pub struct AlreadyMutBorrowed {\n     #[primary_span]\n     pub span: Span,\n     #[subdiagnostic]\n-    pub occurences: Vec<Conflict>,\n+    pub occurrences: Vec<Conflict>,\n }\n \n #[derive(Diagnostic)]\n@@ -620,7 +620,7 @@ pub struct MovedWhileBorrowed {\n     #[primary_span]\n     pub span: Span,\n     #[subdiagnostic]\n-    pub occurences: Vec<Conflict>,\n+    pub occurrences: Vec<Conflict>,\n }\n \n #[derive(Subdiagnostic)]"}, {"sha": "bac46db2b1e62bbeaefa1ad8cee7ae49974eab8f", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -966,30 +966,30 @@ fn check_borrow_conflicts_in_at_patterns<'tcx>(cx: &MatchVisitor<'_, '_, 'tcx>,\n     let report_mut_ref = !conflicts_mut_ref.is_empty();\n     let report_move_conflict = !conflicts_move.is_empty();\n \n-    let mut occurences = match mut_outer {\n+    let mut occurrences = match mut_outer {\n         Mutability::Mut => vec![Conflict::Mut { span: pat.span, name }],\n         Mutability::Not => vec![Conflict::Ref { span: pat.span, name }],\n     };\n-    occurences.extend(conflicts_mut_mut);\n-    occurences.extend(conflicts_mut_ref);\n-    occurences.extend(conflicts_move);\n+    occurrences.extend(conflicts_mut_mut);\n+    occurrences.extend(conflicts_mut_ref);\n+    occurrences.extend(conflicts_move);\n \n     // Report errors if any.\n     if report_mut_mut {\n         // Report mutability conflicts for e.g. `ref mut x @ Some(ref mut y)`.\n-        sess.emit_err(MultipleMutBorrows { span: pat.span, occurences });\n+        sess.emit_err(MultipleMutBorrows { span: pat.span, occurrences });\n     } else if report_mut_ref {\n         // Report mutability conflicts for e.g. `ref x @ Some(ref mut y)` or the converse.\n         match mut_outer {\n             Mutability::Mut => {\n-                sess.emit_err(AlreadyMutBorrowed { span: pat.span, occurences });\n+                sess.emit_err(AlreadyMutBorrowed { span: pat.span, occurrences });\n             }\n             Mutability::Not => {\n-                sess.emit_err(AlreadyBorrowed { span: pat.span, occurences });\n+                sess.emit_err(AlreadyBorrowed { span: pat.span, occurrences });\n             }\n         };\n     } else if report_move_conflict {\n         // Report by-ref and by-move conflicts, e.g. `ref x @ y`.\n-        sess.emit_err(MovedWhileBorrowed { span: pat.span, occurences });\n+        sess.emit_err(MovedWhileBorrowed { span: pat.span, occurrences });\n     }\n }"}, {"sha": "707729f8f21b71e2e3c581a9129c2e8b1dbc972e", "filename": "compiler/rustc_mir_dataflow/src/framework/graphviz.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fgraphviz.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -394,8 +394,8 @@ where\n     ) -> io::Result<()> {\n         let diffs = StateDiffCollector::run(body, block, self.results.results(), self.style);\n \n-        let mut befores = diffs.before.map(|v| v.into_iter());\n-        let mut afters = diffs.after.into_iter();\n+        let mut diffs_before = diffs.before.map(|v| v.into_iter());\n+        let mut diffs_after = diffs.after.into_iter();\n \n         let next_in_dataflow_order = |it: &mut std::vec::IntoIter<_>| {\n             if A::Direction::IS_FORWARD { it.next().unwrap() } else { it.next_back().unwrap() }\n@@ -405,8 +405,8 @@ where\n             let statement_str = format!(\"{statement:?}\");\n             let index_str = format!(\"{i}\");\n \n-            let after = next_in_dataflow_order(&mut afters);\n-            let before = befores.as_mut().map(next_in_dataflow_order);\n+            let after = next_in_dataflow_order(&mut diffs_after);\n+            let before = diffs_before.as_mut().map(next_in_dataflow_order);\n \n             self.write_row(w, &index_str, &statement_str, |_this, w, fmt| {\n                 if let Some(before) = before {\n@@ -417,11 +417,11 @@ where\n             })?;\n         }\n \n-        let after = next_in_dataflow_order(&mut afters);\n-        let before = befores.as_mut().map(next_in_dataflow_order);\n+        let after = next_in_dataflow_order(&mut diffs_after);\n+        let before = diffs_before.as_mut().map(next_in_dataflow_order);\n \n-        assert!(afters.is_empty());\n-        assert!(befores.as_ref().map_or(true, ExactSizeIterator::is_empty));\n+        assert!(diffs_after.is_empty());\n+        assert!(diffs_before.as_ref().map_or(true, ExactSizeIterator::is_empty));\n \n         let terminator = body[block].terminator();\n         let mut terminator_str = String::new();"}, {"sha": "c76dc56065c32763399a471bba06c48745e58b00", "filename": "compiler/rustc_mir_transform/src/check_alignment.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_alignment.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1,5 +1,6 @@\n use crate::MirPass;\n use rustc_hir::def_id::DefId;\n+use rustc_hir::lang_items::LangItem;\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::*;\n use rustc_middle::mir::{\n@@ -17,6 +18,12 @@ impl<'tcx> MirPass<'tcx> for CheckAlignment {\n     }\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        // This pass emits new panics. If for whatever reason we do not have a panic\n+        // implementation, running this pass may cause otherwise-valid code to not compile.\n+        if tcx.lang_items().get(LangItem::PanicImpl).is_none() {\n+            return;\n+        }\n+\n         let basic_blocks = body.basic_blocks.as_mut();\n         let local_decls = &mut body.local_decls;\n "}, {"sha": "39164917770886053202a2898e56cf44c5dc6112", "filename": "compiler/rustc_mir_transform/src/dest_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -83,7 +83,7 @@\n //!   that ever have their address taken. Of course that requires actually having alias analysis\n //!   (and a model to build it on), so this might be a bit of a ways off.\n //!\n-//! * Various perf improvents. There are a bunch of comments in here marked `PERF` with ideas for\n+//! * Various perf improvements. There are a bunch of comments in here marked `PERF` with ideas for\n //!   how to do things more efficiently. However, the complexity of the pass as a whole should be\n //!   kept in mind.\n //!"}, {"sha": "4c4423721fb8c9f7eb04f742b36baebfe528b680", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1556,6 +1556,13 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n         body.arg_count = 2; // self, resume arg\n         body.spread_arg = None;\n \n+        // The original arguments to the function are no longer arguments, mark them as such.\n+        // Otherwise they'll conflict with our new arguments, which although they don't have\n+        // argument_index set, will get emitted as unnamed arguments.\n+        for var in &mut body.var_debug_info {\n+            var.argument_index = None;\n+        }\n+\n         body.generator.as_mut().unwrap().yield_ty = None;\n         body.generator.as_mut().unwrap().generator_layout = Some(layout);\n "}, {"sha": "bd1724bf84241abc1fe8db09511a253862a2ae66", "filename": "compiler/rustc_mir_transform/src/unreachable_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_mir_transform%2Fsrc%2Funreachable_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_mir_transform%2Fsrc%2Funreachable_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Funreachable_prop.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -99,7 +99,7 @@ where\n                 //\n                 // This generates a `switchInt() -> [0: 0, 1: 1, otherwise: unreachable]`, which allows us or LLVM to\n                 // turn it into just `x` later. Without the unreachable, such a transformation would be illegal.\n-                // If the otherwise branch is unreachable, we can delete all other unreacahble targets, as they will\n+                // If the otherwise branch is unreachable, we can delete all other unreachable targets, as they will\n                 // still point to the unreachable and therefore not lose reachability information.\n                 let reachable_iter = targets.iter().filter(|(_, bb)| !is_unreachable(*bb));\n "}, {"sha": "18aa0742c099a02c94cab4845369e72c35943855", "filename": "compiler/rustc_monomorphize/src/partitioning/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -474,7 +474,7 @@ fn collect_and_partition_mono_items(tcx: TyCtxt<'_>, (): ()) -> (&DefIdSet, &[Co\n     (tcx.arena.alloc(mono_items), codegen_units)\n }\n \n-/// Outputs stats about instantation counts and estimated size, per `MonoItem`'s\n+/// Outputs stats about instantiation counts and estimated size, per `MonoItem`'s\n /// def, to a file in the given output directory.\n fn dump_mono_items_stats<'tcx>(\n     tcx: TyCtxt<'tcx>,"}, {"sha": "f11d0ed0f0109e20826fd0253b283c3334749595", "filename": "compiler/rustc_parse/messages.ftl", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_parse%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_parse%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fmessages.ftl?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -738,3 +738,7 @@ parse_box_syntax_removed = `box_syntax` has been removed\n parse_bad_return_type_notation_output =\n     return type not allowed with return type notation\n     .suggestion = remove the return type\n+\n+parse_bad_return_type_notation_dotdot =\n+    return type notation uses `()` instead of `(..)` for elided arguments\n+    .suggestion = remove the `..`"}, {"sha": "069217165fabe3c920630d707cc200ceba8bdbfc", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -2324,3 +2324,11 @@ pub(crate) struct BadReturnTypeNotationOutput {\n     #[suggestion(code = \"\", applicability = \"maybe-incorrect\")]\n     pub span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_bad_return_type_notation_dotdot)]\n+pub(crate) struct BadReturnTypeNotationDotDot {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"maybe-incorrect\")]\n+    pub span: Span,\n+}"}, {"sha": "9e6d27bf036fc819c4712ce4e8fd6e2e11ee0a7a", "filename": "compiler/rustc_parse/src/lexer/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fdiagnostics.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -21,7 +21,7 @@ pub struct TokenTreeDiagInfo {\n     pub matching_block_spans: Vec<(Span, Span)>,\n }\n \n-pub fn same_identation_level(sm: &SourceMap, open_sp: Span, close_sp: Span) -> bool {\n+pub fn same_indentation_level(sm: &SourceMap, open_sp: Span, close_sp: Span) -> bool {\n     match (sm.span_to_margin(open_sp), sm.span_to_margin(close_sp)) {\n         (Some(open_padding), Some(close_padding)) => open_padding == close_padding,\n         _ => false,\n@@ -67,13 +67,13 @@ pub fn report_suspicious_mismatch_block(\n     let mut matched_spans: Vec<(Span, bool)> = diag_info\n         .matching_block_spans\n         .iter()\n-        .map(|&(open, close)| (open.with_hi(close.lo()), same_identation_level(sm, open, close)))\n+        .map(|&(open, close)| (open.with_hi(close.lo()), same_indentation_level(sm, open, close)))\n         .collect();\n \n     // sort by `lo`, so the large block spans in the front\n     matched_spans.sort_by_key(|(span, _)| span.lo());\n \n-    // We use larger block whose identation is well to cover those inner mismatched blocks\n+    // We use larger block whose indentation is well to cover those inner mismatched blocks\n     // O(N^2) here, but we are on error reporting path, so it is fine\n     for i in 0..matched_spans.len() {\n         let (block_span, same_ident) = matched_spans[i];"}, {"sha": "9e856c9f2120c2363bb9b936f690cfa1b24c56af", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -223,21 +223,16 @@ impl<'a> StringReader<'a> {\n                     };\n                     token::Literal(token::Lit { kind, symbol, suffix })\n                 }\n-                rustc_lexer::TokenKind::Lifetime { starts_with_number, contains_emoji } => {\n+                rustc_lexer::TokenKind::Lifetime { starts_with_number } => {\n                     // Include the leading `'` in the real identifier, for macro\n                     // expansion purposes. See #12512 for the gory details of why\n                     // this is necessary.\n                     let lifetime_name = self.str_from(start);\n                     if starts_with_number {\n                         let span = self.mk_sp(start, self.pos);\n-                        let mut diag = self.sess.struct_err(\"lifetimes or labels cannot start with a number\");\n+                        let mut diag = self.sess.struct_err(\"lifetimes cannot start with a number\");\n                         diag.set_span(span);\n                         diag.stash(span, StashKey::LifetimeIsChar);\n-                    } else if contains_emoji {\n-                        let span = self.mk_sp(start, self.pos);\n-                        let mut diag = self.sess.struct_err(\"lifetimes or labels cannot contain emojis\");\n-                        diag.set_span(span);\n-                        diag.stash(span, StashKey::LifetimeContainsEmoji);\n                     }\n                     let ident = Symbol::intern(lifetime_name);\n                     token::Lifetime(ident)"}, {"sha": "7c2c0895193edf3f9371bba483d99305b3559b4c", "filename": "compiler/rustc_parse/src/lexer/tokentrees.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1,5 +1,5 @@\n use super::diagnostics::report_suspicious_mismatch_block;\n-use super::diagnostics::same_identation_level;\n+use super::diagnostics::same_indentation_level;\n use super::diagnostics::TokenTreeDiagInfo;\n use super::{StringReader, UnmatchedDelim};\n use rustc_ast::token::{self, Delimiter, Token};\n@@ -153,7 +153,7 @@ impl<'a> TokenTreesReader<'a> {\n                         unclosed_delimiter = Some(sp);\n                     };\n                     for (brace, brace_span) in &self.diag_info.open_braces {\n-                        if same_identation_level(&sm, self.token.span, *brace_span)\n+                        if same_indentation_level(&sm, self.token.span, *brace_span)\n                             && brace == &close_delim\n                         {\n                             // high likelihood of these two corresponding"}, {"sha": "03c82fbd329fc217e0a636198978017255b866c1", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -2767,7 +2767,7 @@ impl<'a> Parser<'a> {\n                     (token::DotDotEq, token::Gt)\n                 ) {\n                     // `error_inclusive_range_match_arrow` handles cases like `0..=> {}`,\n-                    // so we supress the error here\n+                    // so we suppress the error here\n                     err.delay_as_bug();\n                     this.bump();\n                 } else {"}, {"sha": "c25c23d849f04f56387061217c471395a35971ed", "filename": "compiler/rustc_parse/src/parser/path.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -290,16 +290,17 @@ impl<'a> Parser<'a> {\n                     })?;\n                     let span = lo.to(self.prev_token.span);\n                     AngleBracketedArgs { args, span }.into()\n-                } else if self.token.kind == token::OpenDelim(Delimiter::Parenthesis)\n+                } else if self.may_recover()\n+                    && self.token.kind == token::OpenDelim(Delimiter::Parenthesis)\n                     // FIXME(return_type_notation): Could also recover `...` here.\n                     && self.look_ahead(1, |tok| tok.kind == token::DotDot)\n                 {\n-                    let lo = self.token.span;\n                     self.bump();\n+                    self.sess\n+                        .emit_err(errors::BadReturnTypeNotationDotDot { span: self.token.span });\n                     self.bump();\n                     self.expect(&token::CloseDelim(Delimiter::Parenthesis))?;\n                     let span = lo.to(self.prev_token.span);\n-                    self.sess.gated_spans.gate(sym::return_type_notation, span);\n \n                     if self.eat_noexpect(&token::RArrow) {\n                         let lo = self.prev_token.span;\n@@ -308,7 +309,13 @@ impl<'a> Parser<'a> {\n                             .emit_err(errors::BadReturnTypeNotationOutput { span: lo.to(ty.span) });\n                     }\n \n-                    P(GenericArgs::ReturnTypeNotation(span))\n+                    ParenthesizedArgs {\n+                        span,\n+                        inputs: ThinVec::new(),\n+                        inputs_span: span,\n+                        output: ast::FnRetTy::Default(self.prev_token.span.shrink_to_hi()),\n+                    }\n+                    .into()\n                 } else {\n                     // `(T, U) -> R`\n                     let (inputs, _) = self.parse_paren_comma_seq(|p| p.parse_ty())?;\n@@ -566,13 +573,13 @@ impl<'a> Parser<'a> {\n                     };\n \n                     let span = lo.to(self.prev_token.span);\n-\n                     // Gate associated type bounds, e.g., `Iterator<Item: Ord>`.\n                     if let AssocConstraintKind::Bound { .. } = kind {\n-                        if gen_args.as_ref().map_or(false, |args| {\n-                            matches!(args, GenericArgs::ReturnTypeNotation(..))\n-                        }) {\n-                            // This is already gated in `parse_path_segment`\n+                        if let Some(ast::GenericArgs::Parenthesized(args)) = &gen_args\n+                            && args.inputs.is_empty()\n+                            && matches!(args.output, ast::FnRetTy::Default(..))\n+                        {\n+                            self.sess.gated_spans.gate(sym::return_type_notation, span);\n                         } else {\n                             self.sess.gated_spans.gate(sym::associated_type_bounds, span);\n                         }"}, {"sha": "7de84db211ed8ac0fdd1295a38ac6ea5c4f276e6", "filename": "compiler/rustc_parse_format/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -909,7 +909,7 @@ fn find_width_map_from_snippet(\n     // Strip quotes.\n     let snippet = &snippet[1..snippet.len() - 1];\n \n-    // Macros like `println` add a newline at the end. That technically doens't make them \"literals\" anymore, but it's fine\n+    // Macros like `println` add a newline at the end. That technically doesn't make them \"literals\" anymore, but it's fine\n     // since we will never need to point our spans there, so we lie about it here by ignoring it.\n     // Since there might actually be newlines in the source code, we need to normalize away all trailing newlines.\n     // If we only trimmed it off the input, `format!(\"\\n\")` would cause a mismatch as here we they actually match up."}, {"sha": "5cfe691df17a14882baf66f212694bc0e112207f", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 42, "deletions": 20, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -700,6 +700,13 @@ impl<'tcx> DeadVisitor<'tcx> {\n             .collect();\n \n         let descr = tcx.def_descr(first_id.to_def_id());\n+        // `impl` blocks are \"batched\" and (unlike other batching) might\n+        // contain different kinds of associated items.\n+        let descr = if dead_codes.iter().any(|did| tcx.def_descr(did.to_def_id()) != descr) {\n+            \"associated item\"\n+        } else {\n+            descr\n+        };\n         let num = dead_codes.len();\n         let multiple = num > 6;\n         let name_list = names.into();\n@@ -712,12 +719,12 @@ impl<'tcx> DeadVisitor<'tcx> {\n \n         let parent_info = if let Some(parent_item) = parent_item {\n             let parent_descr = tcx.def_descr(parent_item.to_def_id());\n-            Some(ParentInfo {\n-                num,\n-                descr,\n-                parent_descr,\n-                span: tcx.def_ident_span(parent_item).unwrap(),\n-            })\n+            let span = if let DefKind::Impl { .. } = tcx.def_kind(parent_item) {\n+                tcx.def_span(parent_item)\n+            } else {\n+                tcx.def_ident_span(parent_item).unwrap()\n+            };\n+            Some(ParentInfo { num, descr, parent_descr, span })\n         } else {\n             None\n         };\n@@ -800,16 +807,7 @@ impl<'tcx> DeadVisitor<'tcx> {\n     }\n \n     fn check_definition(&mut self, def_id: LocalDefId) {\n-        if self.live_symbols.contains(&def_id) {\n-            return;\n-        }\n-        if has_allow_dead_code_or_lang_attr(self.tcx, def_id) {\n-            return;\n-        }\n-        let Some(name) = self.tcx.opt_item_name(def_id.to_def_id()) else {\n-            return\n-        };\n-        if name.as_str().starts_with('_') {\n+        if self.is_live_code(def_id) {\n             return;\n         }\n         match self.tcx.def_kind(def_id) {\n@@ -827,6 +825,18 @@ impl<'tcx> DeadVisitor<'tcx> {\n             _ => {}\n         }\n     }\n+\n+    fn is_live_code(&self, def_id: LocalDefId) -> bool {\n+        // if we cannot get a name for the item, then we just assume that it is\n+        // live. I mean, we can't really emit a lint.\n+        let Some(name) = self.tcx.opt_item_name(def_id.to_def_id()) else {\n+            return true;\n+        };\n+\n+        self.live_symbols.contains(&def_id)\n+            || has_allow_dead_code_or_lang_attr(self.tcx, def_id)\n+            || name.as_str().starts_with('_')\n+    }\n }\n \n fn check_mod_deathness(tcx: TyCtxt<'_>, module: LocalDefId) {\n@@ -836,6 +846,22 @@ fn check_mod_deathness(tcx: TyCtxt<'_>, module: LocalDefId) {\n     let module_items = tcx.hir_module_items(module);\n \n     for item in module_items.items() {\n+        if let hir::ItemKind::Impl(impl_item) = tcx.hir().item(item).kind {\n+            let mut dead_items = Vec::new();\n+            for item in impl_item.items {\n+                let did = item.id.owner_id.def_id;\n+                if !visitor.is_live_code(did) {\n+                    dead_items.push(did)\n+                }\n+            }\n+            visitor.warn_multiple_dead_codes(\n+                &dead_items,\n+                \"used\",\n+                Some(item.owner_id.def_id),\n+                false,\n+            );\n+        }\n+\n         if !live_symbols.contains(&item.owner_id.def_id) {\n             let parent = tcx.local_parent(item.owner_id.def_id);\n             if parent != module && !live_symbols.contains(&parent) {\n@@ -900,10 +926,6 @@ fn check_mod_deathness(tcx: TyCtxt<'_>, module: LocalDefId) {\n         }\n     }\n \n-    for impl_item in module_items.impl_items() {\n-        visitor.check_definition(impl_item.owner_id.def_id);\n-    }\n-\n     for foreign_item in module_items.foreign_items() {\n         visitor.check_definition(foreign_item.owner_id.def_id);\n     }"}, {"sha": "3942a73befdcedad8e983e0d7f24619bfe63442e", "filename": "compiler/rustc_passes/src/hir_id_validator.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -8,8 +8,6 @@ use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::TyCtxt;\n \n pub fn check_crate(tcx: TyCtxt<'_>) {\n-    tcx.dep_graph.assert_ignored();\n-\n     if tcx.sess.opts.unstable_opts.hir_stats {\n         crate::hir_stats::print_hir_stats(tcx);\n     }"}, {"sha": "47e032758f23da1b90be4453357f8af649fd1246", "filename": "compiler/rustc_passes/src/hir_stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -666,7 +666,7 @@ impl<'v> ast_visit::Visitor<'v> for StatCollector<'v> {\n     fn visit_generic_args(&mut self, g: &'v ast::GenericArgs) {\n         record_variants!(\n             (self, g, g, Id::None, ast, GenericArgs, GenericArgs),\n-            [AngleBracketed, Parenthesized, ReturnTypeNotation]\n+            [AngleBracketed, Parenthesized]\n         );\n         ast_visit::walk_generic_args(self, g)\n     }"}, {"sha": "dcebfca08facf89d76c12f791e1f1e4a3a4c0e88", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -515,7 +515,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n             let vis = self.tcx.local_visibility(item_id.owner_id.def_id);\n             self.update_macro_reachable_def(item_id.owner_id.def_id, def_kind, vis, defining_mod);\n         }\n-        for export in self.tcx.module_reexports(module_def_id) {\n+        for export in self.tcx.module_children_reexports(module_def_id) {\n             if export.vis.is_accessible_from(defining_mod, self.tcx)\n                 && let Res::Def(def_kind, def_id) = export.res\n                 && let Some(def_id) = def_id.as_local() {"}, {"sha": "a9a2e6dd04c2d4ce27fef8ec2be3e9063bc8d008", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 33, "deletions": 11, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -143,16 +143,29 @@ impl<K: DepKind> DepGraph<K> {\n         assert_eq!(_green_node_index, DepNodeIndex::SINGLETON_DEPENDENCYLESS_ANON_NODE);\n \n         // Instantiate a dependy-less red node only once for anonymous queries.\n-        let (_red_node_index, _prev_and_index) = current.intern_node(\n+        let (red_node_index, red_node_prev_index_and_color) = current.intern_node(\n             profiler,\n             &prev_graph,\n             DepNode { kind: DepKind::RED, hash: Fingerprint::ZERO.into() },\n             smallvec![],\n             None,\n             false,\n         );\n-        assert_eq!(_red_node_index, DepNodeIndex::FOREVER_RED_NODE);\n-        assert!(matches!(_prev_and_index, None | Some((_, DepNodeColor::Red))));\n+        assert_eq!(red_node_index, DepNodeIndex::FOREVER_RED_NODE);\n+        match red_node_prev_index_and_color {\n+            None => {\n+                // This is expected when we have no previous compilation session.\n+                assert!(prev_graph_node_count == 0);\n+            }\n+            Some((prev_red_node_index, DepNodeColor::Red)) => {\n+                assert_eq!(prev_red_node_index.as_usize(), red_node_index.as_usize());\n+                colors.insert(prev_red_node_index, DepNodeColor::Red);\n+            }\n+            Some((_, DepNodeColor::Green(_))) => {\n+                // There must be a logic error somewhere if we hit this branch.\n+                panic!(\"DepNodeIndex::FOREVER_RED_NODE evaluated to DepNodeColor::Green\")\n+            }\n+        }\n \n         DepGraph {\n             data: Some(Lrc::new(DepGraphData {\n@@ -353,10 +366,8 @@ impl<K: DepKind> DepGraphData<K> {\n             }))\n         };\n \n-        let task_deps_ref = match &task_deps {\n-            Some(deps) => TaskDepsRef::Allow(deps),\n-            None => TaskDepsRef::Ignore,\n-        };\n+        let task_deps_ref =\n+            task_deps.as_ref().map(TaskDepsRef::Allow).unwrap_or(TaskDepsRef::EvalAlways);\n \n         let result = K::with_deps(task_deps_ref, || task(cx, arg));\n         let edges = task_deps.map_or_else(|| smallvec![], |lock| lock.into_inner().reads);\n@@ -461,6 +472,11 @@ impl<K: DepKind> DepGraph<K> {\n             K::read_deps(|task_deps| {\n                 let mut task_deps = match task_deps {\n                     TaskDepsRef::Allow(deps) => deps.lock(),\n+                    TaskDepsRef::EvalAlways => {\n+                        // We don't need to record dependencies of eval_always\n+                        // queries. They are re-evaluated unconditionally anyway.\n+                        return;\n+                    }\n                     TaskDepsRef::Ignore => return,\n                     TaskDepsRef::Forbid => {\n                         panic!(\"Illegal read of: {dep_node_index:?}\")\n@@ -563,7 +579,10 @@ impl<K: DepKind> DepGraph<K> {\n             let mut edges = SmallVec::new();\n             K::read_deps(|task_deps| match task_deps {\n                 TaskDepsRef::Allow(deps) => edges.extend(deps.lock().reads.iter().copied()),\n-                TaskDepsRef::Ignore => {} // During HIR lowering, we have no dependencies.\n+                TaskDepsRef::EvalAlways => {\n+                    edges.push(DepNodeIndex::FOREVER_RED_NODE);\n+                }\n+                TaskDepsRef::Ignore => {}\n                 TaskDepsRef::Forbid => {\n                     panic!(\"Cannot summarize when dependencies are not recorded.\")\n                 }\n@@ -1356,10 +1375,13 @@ pub enum TaskDepsRef<'a, K: DepKind> {\n     /// `TaskDeps`. This is used when executing a 'normal' query\n     /// (no `eval_always` modifier)\n     Allow(&'a Lock<TaskDeps<K>>),\n-    /// New dependencies are ignored. This is used when\n-    /// executing an `eval_always` query, since there's no\n+    /// This is used when executing an `eval_always` query. We don't\n     /// need to track dependencies for a query that's always\n-    /// re-executed. This is also used for `dep_graph.with_ignore`\n+    /// re-executed -- but we need to know that this is an `eval_always`\n+    /// query in order to emit dependencies to `DepNodeIndex::FOREVER_RED_NODE`\n+    /// when directly feeding other queries.\n+    EvalAlways,\n+    /// New dependencies are ignored. This is also used for `dep_graph.with_ignore`.\n     Ignore,\n     /// Any attempt to add new dependencies will cause a panic.\n     /// This is used when decoding a query result from disk,"}, {"sha": "01f002c940840e66e887081b81947be5800594b1", "filename": "compiler/rustc_resolve/messages.ftl", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_resolve%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_resolve%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fmessages.ftl?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -42,7 +42,7 @@ resolve_try_adding_local_generic_param_on_method =\n     try adding a local generic parameter in this method instead\n \n resolve_help_try_using_local_generic_param =\n-    try using a local generic paramter instead\n+    try using a local generic parameter instead\n \n resolve_name_is_already_used_as_generic_parameter =\n     the name `{$name}` is already used for a generic parameter in this item's generic parameters\n@@ -213,3 +213,13 @@ resolve_tool_module_imported =\n \n resolve_module_only =\n     visibility must resolve to a module\n+\n+resolve_macro_expected_found =\n+    expected {$expected}, found {$found} `{$macro_path}`\n+\n+resolve_remove_surrounding_derive =\n+    remove from the surrounding `derive()`\n+\n+resolve_add_as_non_derive =\n+    add as non-Derive macro\n+    `#[{$macro_path}]`"}, {"sha": "ff0f1f55975f37ffe17d982d13d8fbce62315c69", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -931,7 +931,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n     /// Builds the reduced graph for a single item in an external crate.\n     fn build_reduced_graph_for_external_crate_res(&mut self, child: ModChild) {\n         let parent = self.parent_scope.module;\n-        let ModChild { ident, res, vis, span, macro_rules, .. } = child;\n+        let ModChild { ident, res, vis, span, .. } = child;\n         let res = res.expect_non_local();\n         let expansion = self.parent_scope.expansion;\n         // Record primary definitions.\n@@ -964,9 +964,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                 _,\n             ) => self.r.define(parent, ident, ValueNS, (res, vis, span, expansion)),\n             Res::Def(DefKind::Macro(..), _) | Res::NonMacroAttr(..) => {\n-                if !macro_rules {\n-                    self.r.define(parent, ident, MacroNS, (res, vis, span, expansion))\n-                }\n+                self.r.define(parent, ident, MacroNS, (res, vis, span, expansion))\n             }\n             Res::Def(\n                 DefKind::TyParam"}, {"sha": "afa796cb6453bd818e4ae7342fda279c25c6e247", "filename": "compiler/rustc_resolve/src/errors.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_resolve%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_resolve%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Ferrors.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -481,3 +481,30 @@ pub(crate) struct ToolModuleImported {\n #[derive(Diagnostic)]\n #[diag(resolve_module_only)]\n pub(crate) struct ModuleOnly(#[primary_span] pub(crate) Span);\n+\n+#[derive(Diagnostic, Default)]\n+#[diag(resolve_macro_expected_found)]\n+pub(crate) struct MacroExpectedFound<'a> {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    pub(crate) found: &'a str,\n+    pub(crate) expected: &'a str,\n+    pub(crate) macro_path: &'a str,\n+    #[subdiagnostic]\n+    pub(crate) remove_surrounding_derive: Option<RemoveSurroundingDerive>,\n+    #[subdiagnostic]\n+    pub(crate) add_as_non_derive: Option<AddAsNonDerive<'a>>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[help(resolve_remove_surrounding_derive)]\n+pub(crate) struct RemoveSurroundingDerive {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[help(resolve_add_as_non_derive)]\n+pub(crate) struct AddAsNonDerive<'a> {\n+    pub(crate) macro_path: &'a str,\n+}"}, {"sha": "3c22d51c3d47886686cee391c5654ee3315bc63b", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1261,10 +1261,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         *module.globs.borrow_mut() = Vec::new();\n \n         if let Some(def_id) = module.opt_def_id() {\n+            let mut non_reexports = Vec::new();\n             let mut reexports = Vec::new();\n \n             module.for_each_child(self, |this, ident, _, binding| {\n-                if let Some(res) = this.is_reexport(binding) {\n+                let res = binding.res().expect_non_local();\n+                if !binding.is_import() {\n+                    non_reexports.push(res.def_id().expect_local());\n+                } else if res != def::Res::Err && !binding.is_ambiguity() {\n                     let mut reexport_chain = SmallVec::new();\n                     let mut next_binding = binding;\n                     while let NameBindingKind::Import { binding, import, .. } = next_binding.kind {\n@@ -1277,16 +1281,18 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         res,\n                         vis: binding.vis,\n                         span: binding.span,\n-                        macro_rules: false,\n                         reexport_chain,\n                     });\n                 }\n             });\n \n+            // Should be fine because this code is only called for local modules.\n+            let def_id = def_id.expect_local();\n+            if !non_reexports.is_empty() {\n+                self.module_children_non_reexports.insert(def_id, non_reexports);\n+            }\n             if !reexports.is_empty() {\n-                // Call to `expect_local` should be fine because current\n-                // code is only called for local modules.\n-                self.reexport_map.insert(def_id.expect_local(), reexports);\n+                self.module_children_reexports.insert(def_id, reexports);\n             }\n         }\n     }"}, {"sha": "90a2fa89cd2abdacf33c5e22c128cadb3dafd491", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -598,7 +598,7 @@ struct LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n     /// The current set of local scopes for types and values.\n     ribs: PerNS<Vec<Rib<'a>>>,\n \n-    /// Previous poped `rib`, only used for diagnostic.\n+    /// Previous popped `rib`, only used for diagnostic.\n     last_block_rib: Option<Rib<'a>>,\n \n     /// The current set of local scopes, for labels.\n@@ -1116,7 +1116,6 @@ impl<'a: 'ast, 'ast, 'tcx> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast,\n                         }\n                     }\n                 }\n-                GenericArgs::ReturnTypeNotation(_span) => {}\n             }\n         }\n     }"}, {"sha": "b820d56b8afb12bc1aa8cb376a803fffc17ab6d8", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -312,7 +312,6 @@ impl<'a> From<&'a ast::PathSegment> for Segment {\n                     (args.span, found_lifetimes)\n                 }\n                 GenericArgs::Parenthesized(args) => (args.span, true),\n-                GenericArgs::ReturnTypeNotation(span) => (*span, false),\n             }\n         } else {\n             (DUMMY_SP, false)\n@@ -910,7 +909,8 @@ pub struct Resolver<'a, 'tcx> {\n \n     /// `CrateNum` resolutions of `extern crate` items.\n     extern_crate_map: FxHashMap<LocalDefId, CrateNum>,\n-    reexport_map: FxHashMap<LocalDefId, Vec<ModChild>>,\n+    module_children_non_reexports: LocalDefIdMap<Vec<LocalDefId>>,\n+    module_children_reexports: LocalDefIdMap<Vec<ModChild>>,\n     trait_map: NodeMap<Vec<TraitCandidate>>,\n \n     /// A map from nodes to anonymous modules.\n@@ -1260,7 +1260,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             lifetimes_res_map: Default::default(),\n             extra_lifetime_params_map: Default::default(),\n             extern_crate_map: Default::default(),\n-            reexport_map: FxHashMap::default(),\n+            module_children_non_reexports: Default::default(),\n+            module_children_reexports: Default::default(),\n             trait_map: NodeMap::default(),\n             underscore_disambiguator: 0,\n             empty_module,\n@@ -1387,7 +1388,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let visibilities = self.visibilities;\n         let has_pub_restricted = self.has_pub_restricted;\n         let extern_crate_map = self.extern_crate_map;\n-        let reexport_map = self.reexport_map;\n         let maybe_unused_trait_imports = self.maybe_unused_trait_imports;\n         let glob_map = self.glob_map;\n         let main_def = self.main_def;\n@@ -1399,7 +1399,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             has_pub_restricted,\n             effective_visibilities,\n             extern_crate_map,\n-            reexport_map,\n+            module_children_non_reexports: self.module_children_non_reexports,\n+            module_children_reexports: self.module_children_reexports,\n             glob_map,\n             maybe_unused_trait_imports,\n             main_def,\n@@ -1652,7 +1653,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 misc2: AmbiguityErrorMisc::None,\n             };\n             if !self.matches_previous_ambiguity_error(&ambiguity_error) {\n-                // avoid dumplicated span information to be emitt out\n+                // avoid duplicated span information to be emitt out\n                 self.ambiguity_errors.push(ambiguity_error);\n             }\n         }\n@@ -1950,20 +1951,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n         self.main_def = Some(MainDefinition { res, is_import, span });\n     }\n-\n-    // Items that go to reexport table encoded to metadata and visible through it to other crates.\n-    fn is_reexport(&self, binding: &NameBinding<'a>) -> Option<def::Res<!>> {\n-        if binding.is_import() {\n-            let res = binding.res().expect_non_local();\n-            // Ambiguous imports are treated as errors at this point and are\n-            // not exposed to other crates (see #36837 for more details).\n-            if res != def::Res::Err && !binding.is_ambiguity() {\n-                return Some(res);\n-            }\n-        }\n-\n-        return None;\n-    }\n }\n \n fn names_to_string(names: &[Symbol]) -> String {"}, {"sha": "22b014c0651c2168afe16128b98b1c2496f6b67d", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1,6 +1,7 @@\n //! A bunch of methods and structures more or less related to resolving macros and\n //! interface provided by `Resolver` to macro expander.\n \n+use crate::errors::{AddAsNonDerive, MacroExpectedFound, RemoveSurroundingDerive};\n use crate::Namespace::*;\n use crate::{BuiltinMacroState, Determinacy};\n use crate::{DeriveData, Finalize, ParentScope, ResolutionError, Resolver, ScopeSet};\n@@ -543,12 +544,29 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         };\n         if let Some((article, expected)) = unexpected_res {\n             let path_str = pprust::path_to_string(path);\n-            let msg = format!(\"expected {}, found {} `{}`\", expected, res.descr(), path_str);\n-            self.tcx\n-                .sess\n-                .struct_span_err(path.span, &msg)\n-                .span_label(path.span, format!(\"not {} {}\", article, expected))\n-                .emit();\n+\n+            let mut err = MacroExpectedFound {\n+                span: path.span,\n+                expected,\n+                found: res.descr(),\n+                macro_path: &path_str,\n+                ..Default::default() // Subdiagnostics default to None\n+            };\n+\n+            // Suggest moving the macro out of the derive() if the macro isn't Derive\n+            if !path.span.from_expansion()\n+                && kind == MacroKind::Derive\n+                && ext.macro_kind() != MacroKind::Derive\n+            {\n+                err.remove_surrounding_derive = Some(RemoveSurroundingDerive { span: path.span });\n+                err.add_as_non_derive = Some(AddAsNonDerive { macro_path: &path_str });\n+            }\n+\n+            let mut err = self.tcx.sess.create_err(err);\n+            err.span_label(path.span, format!(\"not {} {}\", article, expected));\n+\n+            err.emit();\n+\n             return Ok((self.dummy_ext(kind), Res::Err));\n         }\n "}, {"sha": "79eb31bb1050e18dde6b355bd64cef3751fe1b3a", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -222,7 +222,7 @@ impl LinkerPluginLto {\n }\n \n /// The different settings that can be enabled via the `-Z location-detail` flag.\n-#[derive(Clone, PartialEq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Hash, Debug)]\n pub struct LocationDetail {\n     pub file: bool,\n     pub line: bool,"}, {"sha": "259f423865480cd1864b598837c59d8f78f38310", "filename": "compiler/rustc_span/src/edit_distance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_span%2Fsrc%2Fedit_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_span%2Fsrc%2Fedit_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fedit_distance.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -219,7 +219,7 @@ fn find_best_match_for_name_impl(\n     }\n \n     // We have a tie among several candidates, try to select the best among them ignoring substrings.\n-    // For example, the candidates list `force_capture`, `capture`, and user inputed `forced_capture`,\n+    // For example, the candidates list `force_capture`, `capture`, and user inputted `forced_capture`,\n     // we select `force_capture` with a extra round of edit distance calculation.\n     if next_candidates.len() > 1 {\n         debug_assert!(use_substring_score);"}, {"sha": "08c4414034a0acd3ea3f2e159f49215abbce6040", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1207,7 +1207,7 @@ impl HygieneEncodeContext {\n         // a `SyntaxContext` that we haven't seen before\n         while !self.latest_ctxts.lock().is_empty() || !self.latest_expns.lock().is_empty() {\n             debug!(\n-                \"encode_hygiene: Serializing a round of {:?} SyntaxContextDatas: {:?}\",\n+                \"encode_hygiene: Serializing a round of {:?} SyntaxContextData: {:?}\",\n                 self.latest_ctxts.lock().len(),\n                 self.latest_ctxts\n             );"}, {"sha": "6bfae3771521b1d7954e519a844253508918c125", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -357,6 +357,7 @@ symbols! {\n         always,\n         and,\n         and_then,\n+        anon,\n         anonymous_lifetime_in_impl_trait,\n         any,\n         append_const_msg,\n@@ -800,6 +801,7 @@ symbols! {\n         ignore,\n         impl_header_lifetime_elision,\n         impl_lint_pass,\n+        impl_trait_in_assoc_type,\n         impl_trait_in_bindings,\n         impl_trait_in_fn_trait_return,\n         impl_trait_projections,\n@@ -1173,7 +1175,9 @@ symbols! {\n         reg32,\n         reg64,\n         reg_abcd,\n+        reg_addr,\n         reg_byte,\n+        reg_data,\n         reg_iw,\n         reg_nonzero,\n         reg_pair,"}, {"sha": "57011aa8a14748b7d45af3641c2b7e2f7697400b", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -755,7 +755,7 @@ impl FromStr for Conv {\n             \"AmdGpuKernel\" => Ok(Conv::AmdGpuKernel),\n             \"AvrInterrupt\" => Ok(Conv::AvrInterrupt),\n             \"AvrNonBlockingInterrupt\" => Ok(Conv::AvrNonBlockingInterrupt),\n-            _ => Err(format!(\"'{s}' is not a valid value for entry function call convetion.\")),\n+            _ => Err(format!(\"'{s}' is not a valid value for entry function call convention.\")),\n         }\n     }\n }"}, {"sha": "8c857550cf21a135e007c4a5adb09c8335aa1f6a", "filename": "compiler/rustc_target/src/asm/m68k.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_target%2Fsrc%2Fasm%2Fm68k.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_target%2Fsrc%2Fasm%2Fm68k.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fm68k.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -0,0 +1,81 @@\n+use super::{InlineAsmArch, InlineAsmType};\n+use rustc_macros::HashStable_Generic;\n+use rustc_span::Symbol;\n+use std::fmt;\n+\n+def_reg_class! {\n+    M68k M68kInlineAsmRegClass {\n+        reg,\n+        reg_addr,\n+        reg_data,\n+    }\n+}\n+\n+impl M68kInlineAsmRegClass {\n+    pub fn valid_modifiers(self, _arch: super::InlineAsmArch) -> &'static [char] {\n+        &[]\n+    }\n+\n+    pub fn suggest_class(self, _arch: InlineAsmArch, _ty: InlineAsmType) -> Option<Self> {\n+        None\n+    }\n+\n+    pub fn suggest_modifier(\n+        self,\n+        _arch: InlineAsmArch,\n+        _ty: InlineAsmType,\n+    ) -> Option<(char, &'static str)> {\n+        None\n+    }\n+\n+    pub fn default_modifier(self, _arch: InlineAsmArch) -> Option<(char, &'static str)> {\n+        None\n+    }\n+\n+    pub fn supported_types(\n+        self,\n+        _arch: InlineAsmArch,\n+    ) -> &'static [(InlineAsmType, Option<Symbol>)] {\n+        match self {\n+            Self::reg => types! { _: I16, I32; },\n+            Self::reg_data => types! { _: I8, I16, I32; },\n+            Self::reg_addr => types! { _: I16, I32; },\n+        }\n+    }\n+}\n+\n+def_regs! {\n+    M68k M68kInlineAsmReg M68kInlineAsmRegClass {\n+        d0: reg, reg_data = [\"d0\"],\n+        d1: reg, reg_data = [\"d1\"],\n+        d2: reg, reg_data = [\"d2\"],\n+        d3: reg, reg_data = [\"d3\"],\n+        d4: reg, reg_data = [\"d4\"],\n+        d5: reg, reg_data = [\"d5\"],\n+        d6: reg, reg_data = [\"d6\"],\n+        d7: reg, reg_data = [\"d7\"],\n+        a0: reg, reg_addr = [\"a0\"],\n+        a1: reg, reg_addr = [\"a1\"],\n+        a2: reg, reg_addr = [\"a2\"],\n+        a3: reg, reg_addr = [\"a3\"],\n+        #error = [\"a4\"] =>\n+            \"a4 is used internally by LLVM and cannot be used as an operand for inline asm\",\n+        #error = [\"a5\", \"bp\"] =>\n+            \"a5 is used internally by LLVM and cannot be used as an operand for inline asm\",\n+        #error = [\"a6\", \"fp\"] =>\n+            \"a6 is used internally by LLVM and cannot be used as an operand for inline asm\",\n+        #error = [\"a7\", \"sp\", \"usp\", \"ssp\", \"isp\"] =>\n+            \"the stack pointer cannot be used as an operand for inline asm\",\n+    }\n+}\n+\n+impl M68kInlineAsmReg {\n+    pub fn emit(\n+        self,\n+        out: &mut dyn fmt::Write,\n+        _arch: InlineAsmArch,\n+        _modifier: Option<char>,\n+    ) -> fmt::Result {\n+        out.write_str(self.name())\n+    }\n+}"}, {"sha": "3f9c850b3524c45e4e4e7da4d0da9546f2b6f220", "filename": "compiler/rustc_target/src/asm/mod.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -168,6 +168,7 @@ mod arm;\n mod avr;\n mod bpf;\n mod hexagon;\n+mod m68k;\n mod mips;\n mod msp430;\n mod nvptx;\n@@ -183,6 +184,7 @@ pub use arm::{ArmInlineAsmReg, ArmInlineAsmRegClass};\n pub use avr::{AvrInlineAsmReg, AvrInlineAsmRegClass};\n pub use bpf::{BpfInlineAsmReg, BpfInlineAsmRegClass};\n pub use hexagon::{HexagonInlineAsmReg, HexagonInlineAsmRegClass};\n+pub use m68k::{M68kInlineAsmReg, M68kInlineAsmRegClass};\n pub use mips::{MipsInlineAsmReg, MipsInlineAsmRegClass};\n pub use msp430::{Msp430InlineAsmReg, Msp430InlineAsmRegClass};\n pub use nvptx::{NvptxInlineAsmReg, NvptxInlineAsmRegClass};\n@@ -214,6 +216,7 @@ pub enum InlineAsmArch {\n     Bpf,\n     Avr,\n     Msp430,\n+    M68k,\n }\n \n impl FromStr for InlineAsmArch {\n@@ -240,6 +243,7 @@ impl FromStr for InlineAsmArch {\n             \"bpf\" => Ok(Self::Bpf),\n             \"avr\" => Ok(Self::Avr),\n             \"msp430\" => Ok(Self::Msp430),\n+            \"m68k\" => Ok(Self::M68k),\n             _ => Err(()),\n         }\n     }\n@@ -262,6 +266,7 @@ pub enum InlineAsmReg {\n     Bpf(BpfInlineAsmReg),\n     Avr(AvrInlineAsmReg),\n     Msp430(Msp430InlineAsmReg),\n+    M68k(M68kInlineAsmReg),\n     // Placeholder for invalid register constraints for the current target\n     Err,\n }\n@@ -280,6 +285,7 @@ impl InlineAsmReg {\n             Self::Bpf(r) => r.name(),\n             Self::Avr(r) => r.name(),\n             Self::Msp430(r) => r.name(),\n+            Self::M68k(r) => r.name(),\n             Self::Err => \"<reg>\",\n         }\n     }\n@@ -297,6 +303,7 @@ impl InlineAsmReg {\n             Self::Bpf(r) => InlineAsmRegClass::Bpf(r.reg_class()),\n             Self::Avr(r) => InlineAsmRegClass::Avr(r.reg_class()),\n             Self::Msp430(r) => InlineAsmRegClass::Msp430(r.reg_class()),\n+            Self::M68k(r) => InlineAsmRegClass::M68k(r.reg_class()),\n             Self::Err => InlineAsmRegClass::Err,\n         }\n     }\n@@ -328,6 +335,7 @@ impl InlineAsmReg {\n             InlineAsmArch::Bpf => Self::Bpf(BpfInlineAsmReg::parse(name)?),\n             InlineAsmArch::Avr => Self::Avr(AvrInlineAsmReg::parse(name)?),\n             InlineAsmArch::Msp430 => Self::Msp430(Msp430InlineAsmReg::parse(name)?),\n+            InlineAsmArch::M68k => Self::M68k(M68kInlineAsmReg::parse(name)?),\n         })\n     }\n \n@@ -351,6 +359,7 @@ impl InlineAsmReg {\n             Self::Bpf(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n             Self::Avr(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n             Self::Msp430(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::M68k(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n             Self::Err => unreachable!(),\n         }\n     }\n@@ -375,6 +384,7 @@ impl InlineAsmReg {\n             Self::Bpf(r) => r.emit(out, arch, modifier),\n             Self::Avr(r) => r.emit(out, arch, modifier),\n             Self::Msp430(r) => r.emit(out, arch, modifier),\n+            Self::M68k(r) => r.emit(out, arch, modifier),\n             Self::Err => unreachable!(\"Use of InlineAsmReg::Err\"),\n         }\n     }\n@@ -392,6 +402,7 @@ impl InlineAsmReg {\n             Self::Bpf(r) => r.overlapping_regs(|r| cb(Self::Bpf(r))),\n             Self::Avr(r) => r.overlapping_regs(|r| cb(Self::Avr(r))),\n             Self::Msp430(_) => cb(self),\n+            Self::M68k(_) => cb(self),\n             Self::Err => unreachable!(\"Use of InlineAsmReg::Err\"),\n         }\n     }\n@@ -414,6 +425,7 @@ pub enum InlineAsmRegClass {\n     Bpf(BpfInlineAsmRegClass),\n     Avr(AvrInlineAsmRegClass),\n     Msp430(Msp430InlineAsmRegClass),\n+    M68k(M68kInlineAsmRegClass),\n     // Placeholder for invalid register constraints for the current target\n     Err,\n }\n@@ -435,6 +447,7 @@ impl InlineAsmRegClass {\n             Self::Bpf(r) => r.name(),\n             Self::Avr(r) => r.name(),\n             Self::Msp430(r) => r.name(),\n+            Self::M68k(r) => r.name(),\n             Self::Err => rustc_span::symbol::sym::reg,\n         }\n     }\n@@ -458,6 +471,7 @@ impl InlineAsmRegClass {\n             Self::Bpf(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Bpf),\n             Self::Avr(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Avr),\n             Self::Msp430(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Msp430),\n+            Self::M68k(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::M68k),\n             Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n@@ -488,6 +502,7 @@ impl InlineAsmRegClass {\n             Self::Bpf(r) => r.suggest_modifier(arch, ty),\n             Self::Avr(r) => r.suggest_modifier(arch, ty),\n             Self::Msp430(r) => r.suggest_modifier(arch, ty),\n+            Self::M68k(r) => r.suggest_modifier(arch, ty),\n             Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n@@ -514,6 +529,7 @@ impl InlineAsmRegClass {\n             Self::Bpf(r) => r.default_modifier(arch),\n             Self::Avr(r) => r.default_modifier(arch),\n             Self::Msp430(r) => r.default_modifier(arch),\n+            Self::M68k(r) => r.default_modifier(arch),\n             Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n@@ -539,6 +555,7 @@ impl InlineAsmRegClass {\n             Self::Bpf(r) => r.supported_types(arch),\n             Self::Avr(r) => r.supported_types(arch),\n             Self::Msp430(r) => r.supported_types(arch),\n+            Self::M68k(r) => r.supported_types(arch),\n             Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n@@ -569,6 +586,7 @@ impl InlineAsmRegClass {\n             InlineAsmArch::Bpf => Self::Bpf(BpfInlineAsmRegClass::parse(name)?),\n             InlineAsmArch::Avr => Self::Avr(AvrInlineAsmRegClass::parse(name)?),\n             InlineAsmArch::Msp430 => Self::Msp430(Msp430InlineAsmRegClass::parse(name)?),\n+            InlineAsmArch::M68k => Self::M68k(M68kInlineAsmRegClass::parse(name)?),\n         })\n     }\n \n@@ -590,6 +608,7 @@ impl InlineAsmRegClass {\n             Self::Bpf(r) => r.valid_modifiers(arch),\n             Self::Avr(r) => r.valid_modifiers(arch),\n             Self::Msp430(r) => r.valid_modifiers(arch),\n+            Self::M68k(r) => r.valid_modifiers(arch),\n             Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n@@ -776,6 +795,11 @@ pub fn allocatable_registers(\n             msp430::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n+        InlineAsmArch::M68k => {\n+            let mut map = m68k::regclass_map();\n+            m68k::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n+            map\n+        }\n     }\n }\n "}, {"sha": "db8b9c70e67023fdb2a2427e473e2ef144a14889", "filename": "compiler/rustc_target/src/spec/loongarch64_unknown_linux_gnu.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_target%2Fsrc%2Fspec%2Floongarch64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_target%2Fsrc%2Fspec%2Floongarch64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Floongarch64_unknown_linux_gnu.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -0,0 +1,17 @@\n+use crate::spec::{Target, TargetOptions};\n+\n+pub fn target() -> Target {\n+    Target {\n+        llvm_target: \"loongarch64-unknown-linux-gnu\".into(),\n+        pointer_width: 64,\n+        data_layout: \"e-m:e-p:64:64-i64:64-i128:128-n64-S128\".into(),\n+        arch: \"loongarch64\".into(),\n+        options: TargetOptions {\n+            cpu: \"generic\".into(),\n+            features: \"+f,+d\".into(),\n+            llvm_abiname: \"lp64d\".into(),\n+            max_atomic_width: Some(64),\n+            ..super::linux_gnu_base::opts()\n+        },\n+    }\n+}"}, {"sha": "4e5a821f0f6abe29357e73e5aa2ccc33222aa93a", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -123,7 +123,7 @@ pub enum Lld {\n /// target properties, in accordance with the first design goal.\n ///\n /// The first component of the flavor is tightly coupled with the compilation target,\n-/// while the `Cc` and `Lld` flags can vary withing the same target.\n+/// while the `Cc` and `Lld` flags can vary within the same target.\n #[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd)]\n pub enum LinkerFlavor {\n     /// Unix-like linker with GNU extensions (both naked and compiler-wrapped forms).\n@@ -1021,6 +1021,7 @@ supported_targets! {\n     (\"x86_64-unknown-linux-gnux32\", x86_64_unknown_linux_gnux32),\n     (\"i686-unknown-linux-gnu\", i686_unknown_linux_gnu),\n     (\"i586-unknown-linux-gnu\", i586_unknown_linux_gnu),\n+    (\"loongarch64-unknown-linux-gnu\", loongarch64_unknown_linux_gnu),\n     (\"m68k-unknown-linux-gnu\", m68k_unknown_linux_gnu),\n     (\"mips-unknown-linux-gnu\", mips_unknown_linux_gnu),\n     (\"mips64-unknown-linux-gnuabi64\", mips64_unknown_linux_gnuabi64),"}, {"sha": "10d817f75ac77e1ac6cc0fd616b53a807467fe42", "filename": "compiler/rustc_trait_selection/src/solve/assembly/mod.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -225,6 +225,11 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<TyCtxt<'tcx>> + Copy + Eq {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx>;\n+\n+    fn consider_builtin_transmute_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx>;\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n@@ -343,6 +348,14 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n     ) {\n         let lang_items = self.tcx().lang_items();\n         let trait_def_id = goal.predicate.trait_def_id(self.tcx());\n+\n+        // N.B. When assembling built-in candidates for lang items that are also\n+        // `auto` traits, then the auto trait candidate that is assembled in\n+        // `consider_auto_trait_candidate` MUST be disqualified to remain sound.\n+        //\n+        // Instead of adding the logic here, it's a better idea to add it in\n+        // `EvalCtxt::disqualify_auto_trait_candidate_due_to_possible_impl` in\n+        // `solve::trait_goals` instead.\n         let result = if self.tcx().trait_is_auto(trait_def_id) {\n             G::consider_auto_trait_candidate(self, goal)\n         } else if self.tcx().trait_is_alias(trait_def_id) {\n@@ -373,6 +386,8 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             G::consider_builtin_discriminant_kind_candidate(self, goal)\n         } else if lang_items.destruct_trait() == Some(trait_def_id) {\n             G::consider_builtin_destruct_candidate(self, goal)\n+        } else if lang_items.transmute_trait() == Some(trait_def_id) {\n+            G::consider_builtin_transmute_candidate(self, goal)\n         } else {\n             Err(NoSolution)\n         };\n@@ -498,7 +513,10 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         let tcx = self.tcx();\n         let own_bounds: FxIndexSet<_> =\n             bounds.iter().map(|bound| bound.with_self_ty(tcx, self_ty)).collect();\n-        for assumption in elaborate(tcx, own_bounds.iter().copied()) {\n+        for assumption in elaborate(tcx, own_bounds.iter().copied())\n+            // we only care about bounds that match the `Self` type\n+            .filter_only_self()\n+        {\n             // FIXME: Predicates are fully elaborated in the object type's existential bounds\n             // list. We want to only consider these pre-elaborated projections, and not other\n             // projection predicates that we reach by elaborating the principal trait ref,"}, {"sha": "1a566e87dc8e3fe34aa610fb87b8c15b1dc705e3", "filename": "compiler/rustc_trait_selection/src/solve/assembly/structural_traits.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fstructural_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fstructural_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fstructural_traits.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -24,21 +24,19 @@ pub(in crate::solve) fn instantiate_constituent_tys_for_auto_trait<'tcx>(\n         | ty::FnDef(..)\n         | ty::FnPtr(_)\n         | ty::Error(_)\n-        | ty::Infer(ty::IntVar(_) | ty::FloatVar(_))\n         | ty::Never\n         | ty::Char => Ok(vec![]),\n \n-        // Treat this like `struct str([u8]);`\n+        // Treat `str` like it's defined as `struct str([u8]);`\n         ty::Str => Ok(vec![tcx.mk_slice(tcx.types.u8)]),\n \n         ty::Dynamic(..)\n         | ty::Param(..)\n         | ty::Foreign(..)\n         | ty::Alias(ty::Projection, ..)\n-        | ty::Placeholder(..) => Err(NoSolution),\n-\n-        ty::Bound(..)\n-        | ty::Infer(ty::TyVar(_) | ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {\n+        | ty::Placeholder(..)\n+        | ty::Bound(..)\n+        | ty::Infer(_) => {\n             bug!(\"unexpected type `{ty}`\")\n         }\n "}, {"sha": "976849696e33a92b68b016e2759696c29822fc54", "filename": "compiler/rustc_trait_selection/src/solve/canonicalize.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonicalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonicalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonicalize.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -13,15 +13,15 @@ use rustc_middle::ty::TypeVisitableExt;\n use rustc_middle::ty::{self, Ty};\n use rustc_middle::ty::{TypeFoldable, TypeFolder, TypeSuperFoldable};\n \n-/// Whether we're canonicalizing a query input or the query reponse.\n+/// Whether we're canonicalizing a query input or the query response.\n ///\n /// When canonicalizing an input we're in the context of the caller\n /// while canonicalizing the response happens in the context of the\n /// query.\n #[derive(Debug, Clone, Copy)]\n pub enum CanonicalizeMode {\n     Input,\n-    /// FIXME: We currently return region constraints refering to\n+    /// FIXME: We currently return region constraints referring to\n     /// placeholders and inference variables from a binder instantiated\n     /// inside of the query.\n     ///\n@@ -125,8 +125,9 @@ impl<'a, 'tcx> Canonicalizer<'a, 'tcx> {\n         // - var_infos: [E0, U1, E1, U1, E1, E6, U6], curr_compressed_uv: 1, next_orig_uv: 6\n         // - var_infos: [E0, U1, E1, U1, E1, E2, U2], curr_compressed_uv: 2, next_orig_uv: -\n         //\n-        // This algorithm runs in `O(n\u00b2)` where `n` is the number of different universe\n-        // indices in the input. This should be fine as `n` is expected to be small.\n+        // This algorithm runs in `O(nm)` where `n` is the number of different universe\n+        // indices in the input and `m` is the number of canonical variables.\n+        // This should be fine as both `n` and `m` are expected to be small.\n         let mut curr_compressed_uv = ty::UniverseIndex::ROOT;\n         let mut existential_in_new_uv = false;\n         let mut next_orig_uv = Some(ty::UniverseIndex::ROOT);\n@@ -245,18 +246,14 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for Canonicalizer<'_, 'tcx> {\n             ty::ReError(_) => return r,\n         };\n \n-        let existing_bound_var = match self.canonicalize_mode {\n-            CanonicalizeMode::Input => None,\n-            CanonicalizeMode::Response { .. } => {\n-                self.variables.iter().position(|&v| v == r.into()).map(ty::BoundVar::from)\n-            }\n-        };\n-        let var = existing_bound_var.unwrap_or_else(|| {\n-            let var = ty::BoundVar::from(self.variables.len());\n-            self.variables.push(r.into());\n-            self.primitive_var_infos.push(CanonicalVarInfo { kind });\n-            var\n-        });\n+        let var = ty::BoundVar::from(\n+            self.variables.iter().position(|&v| v == r.into()).unwrap_or_else(|| {\n+                let var = self.variables.len();\n+                self.variables.push(r.into());\n+                self.primitive_var_infos.push(CanonicalVarInfo { kind });\n+                var\n+            }),\n+        );\n         let br = ty::BoundRegion { var, kind: BrAnon(None) };\n         self.interner().mk_re_late_bound(self.binder_index, br)\n     }"}, {"sha": "c29b5b04e000a5f10f266512fd035dec8054424a", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -639,4 +639,25 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         crate::traits::wf::unnormalized_obligations(self.infcx, param_env, arg)\n             .map(|obligations| obligations.into_iter().map(|obligation| obligation.into()))\n     }\n+\n+    pub(super) fn is_transmutable(\n+        &self,\n+        src_and_dst: rustc_transmute::Types<'tcx>,\n+        scope: Ty<'tcx>,\n+        assume: rustc_transmute::Assume,\n+    ) -> Result<Certainty, NoSolution> {\n+        // FIXME(transmutability): This really should be returning nested goals for `Answer::If*`\n+        match rustc_transmute::TransmuteTypeEnv::new(self.infcx).is_transmutable(\n+            ObligationCause::dummy(),\n+            ty::Binder::dummy(src_and_dst),\n+            scope,\n+            assume,\n+        ) {\n+            rustc_transmute::Answer::Yes => Ok(Certainty::Yes),\n+            rustc_transmute::Answer::No(_)\n+            | rustc_transmute::Answer::IfTransmutable { .. }\n+            | rustc_transmute::Answer::IfAll(_)\n+            | rustc_transmute::Answer::IfAny(_) => Err(NoSolution),\n+        }\n+    }\n }"}, {"sha": "ada868705c7c3514be59b0c1a869bfb590c684d6", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt/canonical.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -42,7 +42,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n     ///\n     /// - `var_values`: a map from bound variables in the canonical goal to\n     ///   the values inferred while solving the instantiated goal.\n-    /// - `external_constraints`: additional constraints which aren't expressable\n+    /// - `external_constraints`: additional constraints which aren't expressible\n     ///   using simple unification of inference variables.\n     #[instrument(level = \"debug\", skip(self))]\n     pub(in crate::solve) fn evaluate_added_goals_and_make_canonical_response(\n@@ -113,7 +113,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n     }\n \n     /// This returns the substitutions to instantiate the bound variables of\n-    /// the canonical reponse. This depends on the `original_values` for the\n+    /// the canonical response. This depends on the `original_values` for the\n     /// bound variables.\n     fn compute_query_response_substitution(\n         &self,"}, {"sha": "32bd10f0beba5101e9ba019bed28e3b72325f708", "filename": "compiler/rustc_trait_selection/src/solve/fulfill.rs", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1,6 +1,7 @@\n use std::mem;\n \n use rustc_infer::infer::InferCtxt;\n+use rustc_infer::traits::solve::MaybeCause;\n use rustc_infer::traits::Obligation;\n use rustc_infer::traits::{\n     query::NoSolution, FulfillmentError, FulfillmentErrorCode, MismatchedProjectionTypes,\n@@ -41,13 +42,31 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n         self.obligations.push(obligation);\n     }\n \n-    fn collect_remaining_errors(&mut self) -> Vec<FulfillmentError<'tcx>> {\n+    fn collect_remaining_errors(&mut self, infcx: &InferCtxt<'tcx>) -> Vec<FulfillmentError<'tcx>> {\n         self.obligations\n             .drain(..)\n-            .map(|obligation| FulfillmentError {\n-                obligation: obligation.clone(),\n-                code: FulfillmentErrorCode::CodeAmbiguity,\n-                root_obligation: obligation,\n+            .map(|obligation| {\n+                let code =\n+                    infcx.probe(|_| match infcx.evaluate_root_goal(obligation.clone().into()) {\n+                        Ok((_, Certainty::Maybe(MaybeCause::Ambiguity), _)) => {\n+                            FulfillmentErrorCode::CodeAmbiguity { overflow: false }\n+                        }\n+                        Ok((_, Certainty::Maybe(MaybeCause::Overflow), _)) => {\n+                            FulfillmentErrorCode::CodeAmbiguity { overflow: true }\n+                        }\n+                        Ok((_, Certainty::Yes, _)) => {\n+                            bug!(\"did not expect successful goal when collecting ambiguity errors\")\n+                        }\n+                        Err(_) => {\n+                            bug!(\"did not expect selection error when collecting ambiguity errors\")\n+                        }\n+                    });\n+\n+                FulfillmentError {\n+                    obligation: obligation.clone(),\n+                    code,\n+                    root_obligation: obligation,\n+                }\n             })\n             .collect()\n     }"}, {"sha": "14cb43b89c3aa66144042100e60755407a03302c", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -524,6 +524,13 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n     ) -> QueryResult<'tcx> {\n         bug!(\"`Destruct` does not have an associated type: {:?}\", goal);\n     }\n+\n+    fn consider_builtin_transmute_candidate(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        bug!(\"`BikeshedIntrinsicFrom` does not have an associated type: {:?}\", goal)\n+    }\n }\n \n /// This behavior is also implemented in `rustc_ty_utils` and in the old `project` code."}, {"sha": "050269fa973e99dde66ffb5bf55bbadf98f38b47", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -153,7 +153,7 @@ impl<'tcx> SearchGraph<'tcx> {\n     /// coinductive cycles.\n     ///\n     /// When we encounter a coinductive cycle, we have to prove the final result of that cycle\n-    /// while we are still computing that result. Because of this we continously recompute the\n+    /// while we are still computing that result. Because of this we continuously recompute the\n     /// cycle until the result of the previous iteration is equal to the final result, at which\n     /// point we are done.\n     ///"}, {"sha": "e0a2e0c5cc29b3f2ba1710094dd895d9cd665c2e", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/overflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Foverflow.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -45,7 +45,7 @@ impl OverflowData {\n     /// Updating the current limit when hitting overflow.\n     fn deal_with_overflow(&mut self) {\n         // When first hitting overflow we reduce the overflow limit\n-        // for all future goals to prevent hangs if there's an exponental\n+        // for all future goals to prevent hangs if there's an exponential\n         // blowup.\n         self.current_limit.0 = self.default_limit.0 / 8;\n     }"}, {"sha": "abd11a15ac23a4437fde18bc8822fa3ff357ac14", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 123, "deletions": 19, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -3,7 +3,7 @@\n use super::assembly::{self, structural_traits};\n use super::{EvalCtxt, SolverMode};\n use rustc_hir::def_id::DefId;\n-use rustc_hir::LangItem;\n+use rustc_hir::{LangItem, Movability};\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::util::supertraits;\n use rustc_middle::traits::solve::{CanonicalResponse, Certainty, Goal, QueryResult};\n@@ -147,24 +147,8 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n-        // This differs from the current stable behavior and\n-        // fixes #84857. Due to breakage found via crater, we\n-        // currently instead lint patterns which can be used to\n-        // exploit this unsoundness on stable, see #93367 for\n-        // more details.\n-        //\n-        // Using `TreatProjections::NextSolverLookup` is fine here because\n-        // `instantiate_constituent_tys_for_auto_trait` returns nothing for\n-        // projection types anyways. So it doesn't really matter what we do\n-        // here, and this is faster.\n-        if let Some(def_id) = ecx.tcx().find_map_relevant_impl(\n-            goal.predicate.def_id(),\n-            goal.predicate.self_ty(),\n-            TreatProjections::NextSolverLookup,\n-            Some,\n-        ) {\n-            debug!(?def_id, ?goal, \"disqualified auto-trait implementation\");\n-            return Err(NoSolution);\n+        if let Some(result) = ecx.disqualify_auto_trait_candidate_due_to_possible_impl(goal) {\n+            return result;\n         }\n \n         ecx.probe_and_evaluate_goal_for_constituent_tys(\n@@ -556,9 +540,129 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             Err(NoSolution)\n         }\n     }\n+\n+    fn consider_builtin_transmute_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        // `rustc_transmute` does not have support for type or const params\n+        if goal.has_non_region_placeholders() {\n+            return Err(NoSolution);\n+        }\n+\n+        // Erase regions because we compute layouts in `rustc_transmute`,\n+        // which will ICE for region vars.\n+        let substs = ecx.tcx().erase_regions(goal.predicate.trait_ref.substs);\n+\n+        let Some(assume) = rustc_transmute::Assume::from_const(\n+            ecx.tcx(),\n+            goal.param_env,\n+            substs.const_at(3),\n+        ) else {\n+            return Err(NoSolution);\n+        };\n+\n+        let certainty = ecx.is_transmutable(\n+            rustc_transmute::Types { dst: substs.type_at(0), src: substs.type_at(1) },\n+            substs.type_at(2),\n+            assume,\n+        )?;\n+        ecx.evaluate_added_goals_and_make_canonical_response(certainty)\n+    }\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n+    // Return `Some` if there is an impl (built-in or user provided) that may\n+    // hold for the self type of the goal, which for coherence and soundness\n+    // purposes must disqualify the built-in auto impl assembled by considering\n+    // the type's constituent types.\n+    fn disqualify_auto_trait_candidate_due_to_possible_impl(\n+        &mut self,\n+        goal: Goal<'tcx, TraitPredicate<'tcx>>,\n+    ) -> Option<QueryResult<'tcx>> {\n+        let self_ty = goal.predicate.self_ty();\n+        match *self_ty.kind() {\n+            // Stall int and float vars until they are resolved to a concrete\n+            // numerical type. That's because the check for impls below treats\n+            // int vars as matching any impl. Even if we filtered such impls,\n+            // we probably don't want to treat an `impl !AutoTrait for i32` as\n+            // disqualifying the built-in auto impl for `i64: AutoTrait` either.\n+            ty::Infer(ty::IntVar(_) | ty::FloatVar(_)) => {\n+                Some(self.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS))\n+            }\n+\n+            // These types cannot be structurally decomposed into constitutent\n+            // types, and therefore have no built-in auto impl.\n+            ty::Dynamic(..)\n+            | ty::Param(..)\n+            | ty::Foreign(..)\n+            | ty::Alias(ty::Projection, ..)\n+            | ty::Placeholder(..) => Some(Err(NoSolution)),\n+\n+            ty::Infer(_) | ty::Bound(_, _) => bug!(\"unexpected type `{self_ty}`\"),\n+\n+            // Generators have one special built-in candidate, `Unpin`, which\n+            // takes precedence over the structural auto trait candidate being\n+            // assembled.\n+            ty::Generator(_, _, movability)\n+                if Some(goal.predicate.def_id()) == self.tcx().lang_items().unpin_trait() =>\n+            {\n+                match movability {\n+                    Movability::Static => Some(Err(NoSolution)),\n+                    Movability::Movable => {\n+                        Some(self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes))\n+                    }\n+                }\n+            }\n+\n+            // For rigid types, any possible implementation that could apply to\n+            // the type (even if after unification and processing nested goals\n+            // it does not hold) will disqualify the built-in auto impl.\n+            //\n+            // This differs from the current stable behavior and fixes #84857.\n+            // Due to breakage found via crater, we currently instead lint\n+            // patterns which can be used to exploit this unsoundness on stable,\n+            // see #93367 for more details.\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(_)\n+            | ty::Uint(_)\n+            | ty::Float(_)\n+            | ty::Str\n+            | ty::Array(_, _)\n+            | ty::Slice(_)\n+            | ty::RawPtr(_)\n+            | ty::Ref(_, _, _)\n+            | ty::FnDef(_, _)\n+            | ty::FnPtr(_)\n+            | ty::Closure(_, _)\n+            | ty::Generator(_, _, _)\n+            | ty::GeneratorWitness(_)\n+            | ty::GeneratorWitnessMIR(_, _)\n+            | ty::Never\n+            | ty::Tuple(_)\n+            | ty::Adt(_, _)\n+            // FIXME: Handling opaques here is kinda sus. Especially because we\n+            // simplify them to PlaceholderSimplifiedType.\n+            | ty::Alias(ty::Opaque, _) => {\n+                if let Some(def_id) = self.tcx().find_map_relevant_impl(\n+                    goal.predicate.def_id(),\n+                    goal.predicate.self_ty(),\n+                    TreatProjections::NextSolverLookup,\n+                    Some,\n+                ) {\n+                    debug!(?def_id, ?goal, \"disqualified auto-trait implementation\");\n+                    // No need to actually consider the candidate here,\n+                    // since we do that in `consider_impl_candidate`.\n+                    return Some(Err(NoSolution));\n+                } else {\n+                    None\n+                }\n+            }\n+            ty::Error(_) => None,\n+        }\n+    }\n+\n     /// Convenience function for traits that are structural, i.e. that only\n     /// have nested subgoals that only change the self type. Unlike other\n     /// evaluate-like helpers, this does a probe, so it doesn't need to be"}, {"sha": "182d995c4eb067bf6557c61864b207f8829f47af", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -9,7 +9,6 @@ use crate::infer::InferCtxt;\n use crate::traits::project::ProjectAndUnifyResult;\n use rustc_infer::infer::DefineOpaqueTypes;\n use rustc_middle::mir::interpret::ErrorHandled;\n-use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::visit::TypeVisitableExt;\n use rustc_middle::ty::{ImplPolarity, Region, RegionVid};\n \n@@ -187,7 +186,8 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n             panic!(\"Unable to fulfill trait {:?} for '{:?}': {:?}\", trait_did, ty, errors);\n         }\n \n-        infcx.process_registered_region_obligations(&Default::default(), full_env);\n+        let outlives_env = OutlivesEnvironment::new(full_env);\n+        infcx.process_registered_region_obligations(&outlives_env);\n \n         let region_data =\n             infcx.inner.borrow_mut().unwrap_region_constraints().region_constraint_data().clone();\n@@ -851,23 +851,3 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n         infcx.freshen(p)\n     }\n }\n-\n-/// Replaces all ReVars in a type with ty::Region's, using the provided map\n-pub struct RegionReplacer<'a, 'tcx> {\n-    vid_to_region: &'a FxHashMap<ty::RegionVid, ty::Region<'tcx>>,\n-    tcx: TyCtxt<'tcx>,\n-}\n-\n-impl<'a, 'tcx> TypeFolder<TyCtxt<'tcx>> for RegionReplacer<'a, 'tcx> {\n-    fn interner(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n-    }\n-\n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        (match *r {\n-            ty::ReVar(vid) => self.vid_to_region.get(&vid).cloned(),\n-            _ => None,\n-        })\n-        .unwrap_or_else(|| r.super_fold_with(self))\n-    }\n-}"}, {"sha": "28967e1cc55b288ea8e22d3fa8e07f805ac05f3f", "filename": "compiler/rustc_trait_selection/src/traits/chalk_fulfill.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -40,13 +40,16 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         self.obligations.insert(obligation);\n     }\n \n-    fn collect_remaining_errors(&mut self) -> Vec<FulfillmentError<'tcx>> {\n+    fn collect_remaining_errors(\n+        &mut self,\n+        _infcx: &InferCtxt<'tcx>,\n+    ) -> Vec<FulfillmentError<'tcx>> {\n         // any remaining obligations are errors\n         self.obligations\n             .iter()\n             .map(|obligation| FulfillmentError {\n                 obligation: obligation.clone(),\n-                code: FulfillmentErrorCode::CodeAmbiguity,\n+                code: FulfillmentErrorCode::CodeAmbiguity { overflow: false },\n                 // FIXME - does Chalk have a notation of 'root obligation'?\n                 // This is just for diagnostics, so it's okay if this is wrong\n                 root_obligation: obligation.clone(),"}, {"sha": "20c2605f219a7b262b9319e0a806adf44a7d36b6", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -306,7 +306,7 @@ fn negative_impl(tcx: TyCtxt<'_>, impl1_def_id: DefId, impl2_def_id: DefId) -> b\n         &infcx,\n         ObligationCause::dummy(),\n         impl_env,\n-        tcx.impl_subject(impl1_def_id),\n+        tcx.impl_subject(impl1_def_id).subst_identity(),\n     ) {\n         Ok(s) => s,\n         Err(err) => {\n@@ -405,9 +405,6 @@ fn resolve_negative_obligation<'tcx>(\n         param_env,\n         infcx.implied_bounds_tys(param_env, body_def_id, wf_tys),\n     );\n-\n-    infcx.process_registered_region_obligations(outlives_env.region_bound_pairs(), param_env);\n-\n     infcx.resolve_regions(&outlives_env).is_empty()\n }\n "}, {"sha": "2beebe94b6d1d3e5b93da70cc90089da6a9cde72", "filename": "compiler/rustc_trait_selection/src/traits/engine.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -6,11 +6,13 @@ use super::{ChalkFulfillmentContext, FulfillmentContext};\n use crate::solve::FulfillmentCtxt as NextFulfillmentCtxt;\n use crate::traits::NormalizeExt;\n use rustc_data_structures::fx::FxIndexSet;\n+use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::canonical::{\n     Canonical, CanonicalQueryResponse, CanonicalVarValues, QueryResponse,\n };\n+use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::{DefineOpaqueTypes, InferCtxt, InferOk};\n use rustc_infer::traits::query::Fallible;\n use rustc_infer::traits::{\n@@ -173,14 +175,33 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n             .map(|infer_ok| self.register_infer_ok_obligations(infer_ok))\n     }\n \n+    #[must_use]\n     pub fn select_where_possible(&self) -> Vec<FulfillmentError<'tcx>> {\n         self.engine.borrow_mut().select_where_possible(self.infcx)\n     }\n \n+    #[must_use]\n     pub fn select_all_or_error(&self) -> Vec<FulfillmentError<'tcx>> {\n         self.engine.borrow_mut().select_all_or_error(self.infcx)\n     }\n \n+    /// Resolves regions and reports errors.\n+    ///\n+    /// Takes ownership of the context as doing trait solving afterwards\n+    /// will result in region constraints getting ignored.\n+    pub fn resolve_regions_and_report_errors(\n+        self,\n+        generic_param_scope: LocalDefId,\n+        outlives_env: &OutlivesEnvironment<'tcx>,\n+    ) -> Result<(), ErrorGuaranteed> {\n+        let errors = self.infcx.resolve_regions(&outlives_env);\n+        if errors.is_empty() {\n+            Ok(())\n+        } else {\n+            Err(self.infcx.err_ctxt().report_region_errors(generic_param_scope, &errors))\n+        }\n+    }\n+\n     pub fn assumed_wf_types(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,"}, {"sha": "1b741b7302b67f1a1b98c03e039f11362722832a", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 123, "deletions": 27, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -125,6 +125,8 @@ pub trait TypeErrCtxtExt<'tcx> {\n             + Print<'tcx, FmtPrinter<'tcx, 'tcx>, Output = FmtPrinter<'tcx, 'tcx>>,\n         <T as Print<'tcx, FmtPrinter<'tcx, 'tcx>>>::Error: std::fmt::Debug;\n \n+    fn report_overflow_no_abort(&self, obligation: PredicateObligation<'tcx>) -> ErrorGuaranteed;\n+\n     fn report_fulfillment_errors(&self, errors: &[FulfillmentError<'tcx>]) -> ErrorGuaranteed;\n \n     fn report_overflow_obligation<T>(\n@@ -602,6 +604,14 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         );\n     }\n \n+    fn report_overflow_no_abort(&self, obligation: PredicateObligation<'tcx>) -> ErrorGuaranteed {\n+        let obligation = self.resolve_vars_if_possible(obligation);\n+        let mut err = self.build_overflow_error(&obligation.predicate, obligation.cause.span, true);\n+        self.note_obligation_cause(&mut err, &obligation);\n+        self.point_at_returns_when_relevant(&mut err, &obligation);\n+        err.emit()\n+    }\n+\n     fn report_selection_error(\n         &self,\n         mut obligation: PredicateObligation<'tcx>,\n@@ -663,6 +673,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             return;\n                         }\n                         let trait_ref = trait_predicate.to_poly_trait_ref();\n+\n                         let (post_message, pre_message, type_def) = self\n                             .get_parent_trait_ref(obligation.cause.code())\n                             .map(|(t, s)| {\n@@ -702,33 +713,45 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             (message, note, append_const_msg)\n                         };\n \n-                        let mut err = struct_span_err!(\n-                            self.tcx.sess,\n-                            span,\n-                            E0277,\n-                            \"{}\",\n-                            message\n-                                .and_then(|cannot_do_this| {\n-                                    match (predicate_is_const, append_const_msg) {\n-                                        // do nothing if predicate is not const\n-                                        (false, _) => Some(cannot_do_this),\n-                                        // suggested using default post message\n-                                        (true, Some(None)) => {\n-                                            Some(format!(\"{cannot_do_this} in const contexts\"))\n-                                        }\n-                                        // overridden post message\n-                                        (true, Some(Some(post_message))) => {\n-                                            Some(format!(\"{cannot_do_this}{post_message}\"))\n-                                        }\n-                                        // fallback to generic message\n-                                        (true, None) => None,\n+                        let err_msg = message\n+                            .and_then(|cannot_do_this| {\n+                                match (predicate_is_const, append_const_msg) {\n+                                    // do nothing if predicate is not const\n+                                    (false, _) => Some(cannot_do_this),\n+                                    // suggested using default post message\n+                                    (true, Some(None)) => {\n+                                        Some(format!(\"{cannot_do_this} in const contexts\"))\n                                     }\n-                                })\n-                                .unwrap_or_else(|| format!(\n+                                    // overridden post message\n+                                    (true, Some(Some(post_message))) => {\n+                                        Some(format!(\"{cannot_do_this}{post_message}\"))\n+                                    }\n+                                    // fallback to generic message\n+                                    (true, None) => None,\n+                                }\n+                            })\n+                            .unwrap_or_else(|| {\n+                                format!(\n                                     \"the trait bound `{}` is not satisfied{}\",\n                                     trait_predicate, post_message,\n-                                ))\n-                        );\n+                                )\n+                            });\n+\n+                        let (err_msg, safe_transmute_explanation) = if Some(trait_ref.def_id())\n+                            == self.tcx.lang_items().transmute_trait()\n+                        {\n+                            // Recompute the safe transmute reason and use that for the error reporting\n+                            self.get_safe_transmute_error_and_reason(\n+                                trait_predicate,\n+                                obligation.clone(),\n+                                trait_ref,\n+                                span,\n+                            )\n+                        } else {\n+                            (err_msg, None)\n+                        };\n+\n+                        let mut err = struct_span_err!(self.tcx.sess, span, E0277, \"{}\", err_msg);\n \n                         if is_try_conversion && let Some(ret_span) = self.return_type_span(&obligation) {\n                             err.span_label(\n@@ -818,6 +841,8 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                 // at the type param with a label to suggest constraining it.\n                                 err.help(&explanation);\n                             }\n+                        } else if let Some(custom_explanation) = safe_transmute_explanation {\n+                            err.span_label(span, custom_explanation);\n                         } else {\n                             err.span_label(span, explanation);\n                         }\n@@ -1601,6 +1626,14 @@ trait InferCtxtPrivExt<'tcx> {\n         obligated_types: &mut Vec<Ty<'tcx>>,\n         cause_code: &ObligationCauseCode<'tcx>,\n     ) -> bool;\n+\n+    fn get_safe_transmute_error_and_reason(\n+        &self,\n+        trait_predicate: ty::Binder<'tcx, ty::TraitPredicate<'tcx>>,\n+        obligation: Obligation<'tcx, ty::Predicate<'tcx>>,\n+        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        span: Span,\n+    ) -> (String, Option<String>);\n }\n \n impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n@@ -1658,9 +1691,12 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             FulfillmentErrorCode::CodeProjectionError(ref e) => {\n                 self.report_projection_error(&error.obligation, e);\n             }\n-            FulfillmentErrorCode::CodeAmbiguity => {\n+            FulfillmentErrorCode::CodeAmbiguity { overflow: false } => {\n                 self.maybe_report_ambiguity(&error.obligation);\n             }\n+            FulfillmentErrorCode::CodeAmbiguity { overflow: true } => {\n+                self.report_overflow_no_abort(error.obligation.clone());\n+            }\n             FulfillmentErrorCode::CodeSubtypeError(ref expected_found, ref err) => {\n                 self.report_mismatched_types(\n                     &error.obligation.cause,\n@@ -1763,7 +1799,10 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n                 // constrain inference variables a bit more to nested obligations from normalize so\n                 // we can have more helpful errors.\n-                ocx.select_where_possible();\n+                //\n+                // we intentionally drop errors from normalization here,\n+                // since the normalization is just done to improve the error message.\n+                let _ = ocx.select_where_possible();\n \n                 if let Err(new_err) = ocx.eq_exp(\n                     &obligation.cause,\n@@ -2380,8 +2419,8 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 }\n \n                 if let Some(ty::subst::GenericArgKind::Type(_)) = subst.map(|subst| subst.unpack())\n+                    && let Some(body_id) = self.tcx.hir().maybe_body_owned_by(obligation.cause.body_id)\n                 {\n-                    let body_id = self.tcx.hir().body_owned_by(obligation.cause.body_id);\n                     let mut expr_finder = FindExprBySpan::new(span);\n                     expr_finder.visit_expr(&self.tcx.hir().body(body_id).value);\n \n@@ -2879,6 +2918,63 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         }\n         false\n     }\n+\n+    fn get_safe_transmute_error_and_reason(\n+        &self,\n+        trait_predicate: ty::Binder<'tcx, ty::TraitPredicate<'tcx>>,\n+        obligation: Obligation<'tcx, ty::Predicate<'tcx>>,\n+        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        span: Span,\n+    ) -> (String, Option<String>) {\n+        let src_and_dst = trait_predicate.map_bound(|p| rustc_transmute::Types {\n+            dst: p.trait_ref.substs.type_at(0),\n+            src: p.trait_ref.substs.type_at(1),\n+        });\n+        let scope = trait_ref.skip_binder().substs.type_at(2);\n+        let Some(assume) =\n+            rustc_transmute::Assume::from_const(self.infcx.tcx, obligation.param_env, trait_ref.skip_binder().substs.const_at(3)) else {\n+                span_bug!(span, \"Unable to construct rustc_transmute::Assume where it was previously possible\");\n+            };\n+        match rustc_transmute::TransmuteTypeEnv::new(self.infcx).is_transmutable(\n+            obligation.cause,\n+            src_and_dst,\n+            scope,\n+            assume,\n+        ) {\n+            rustc_transmute::Answer::No(reason) => {\n+                let dst = trait_ref.skip_binder().substs.type_at(0);\n+                let src = trait_ref.skip_binder().substs.type_at(1);\n+                let custom_err_msg = format!(\"`{src}` cannot be safely transmuted into `{dst}` in the defining scope of `{scope}`\").to_string();\n+                let reason_msg = match reason {\n+                    rustc_transmute::Reason::SrcIsUnspecified => {\n+                        format!(\"`{src}` does not have a well-specified layout\").to_string()\n+                    }\n+                    rustc_transmute::Reason::DstIsUnspecified => {\n+                        format!(\"`{dst}` does not have a well-specified layout\").to_string()\n+                    }\n+                    rustc_transmute::Reason::DstIsBitIncompatible => {\n+                        format!(\"At least one value of `{src}` isn't a bit-valid value of `{dst}`\")\n+                            .to_string()\n+                    }\n+                    rustc_transmute::Reason::DstIsPrivate => format!(\n+                        \"`{dst}` is or contains a type or field that is not visible in that scope\"\n+                    )\n+                    .to_string(),\n+                    // FIXME(bryangarza): Include the number of bytes of src and dst\n+                    rustc_transmute::Reason::DstIsTooBig => {\n+                        format!(\"The size of `{src}` is smaller than the size of `{dst}`\")\n+                    }\n+                };\n+                (custom_err_msg, Some(reason_msg))\n+            }\n+            // Should never get a Yes at this point! We already ran it before, and did not get a Yes.\n+            rustc_transmute::Answer::Yes => span_bug!(\n+                span,\n+                \"Inconsistent rustc_transmute::is_transmutable(...) result, got Yes\",\n+            ),\n+            _ => span_bug!(span, \"Unsupported rustc_transmute::Reason variant\"),\n+        }\n+    }\n }\n \n /// Crude way of getting back an `Expr` from a `Span`."}, {"sha": "26cadab3e9f1acd67c31395c389844f5ce31b4e8", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -133,8 +133,15 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n             .register_obligation(PendingPredicateObligation { obligation, stalled_on: vec![] });\n     }\n \n-    fn collect_remaining_errors(&mut self) -> Vec<FulfillmentError<'tcx>> {\n-        self.predicates.to_errors(CodeAmbiguity).into_iter().map(to_fulfillment_error).collect()\n+    fn collect_remaining_errors(\n+        &mut self,\n+        _infcx: &InferCtxt<'tcx>,\n+    ) -> Vec<FulfillmentError<'tcx>> {\n+        self.predicates\n+            .to_errors(CodeAmbiguity { overflow: false })\n+            .into_iter()\n+            .map(to_fulfillment_error)\n+            .collect()\n     }\n \n     fn select_where_possible(&mut self, infcx: &InferCtxt<'tcx>) -> Vec<FulfillmentError<'tcx>> {"}, {"sha": "af567c074384e8fefb4dbb8d267f0a1ad2d117c9", "filename": "compiler/rustc_trait_selection/src/traits/misc.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -117,10 +117,6 @@ pub fn type_allowed_to_implement_copy<'tcx>(\n                     FxIndexSet::from_iter([self_type]),\n                 ),\n             );\n-            infcx.process_registered_region_obligations(\n-                outlives_env.region_bound_pairs(),\n-                param_env,\n-            );\n             let errors = infcx.resolve_regions(&outlives_env);\n             if !errors.is_empty() {\n                 infringing.push((field, ty, InfringingFieldsReason::Regions(errors)));"}, {"sha": "1f5bbc178f7d712a130b775fb35902b3b1faec3b", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -294,7 +294,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return;\n         }\n \n-        // Keep this funtion in sync with extract_tupled_inputs_and_output_from_callable\n+        // Keep this function in sync with extract_tupled_inputs_and_output_from_callable\n         // until the old solver (and thus this function) is removed.\n \n         // Okay to skip binder because what we are inspecting doesn't involve bound regions.\n@@ -406,7 +406,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             match obligation.self_ty().skip_binder().kind() {\n-                // Fast path to avoid evaluating an obligation that trivally holds.\n+                // Fast path to avoid evaluating an obligation that trivially holds.\n                 // There may be more bounds, but these are checked by the regular path.\n                 ty::FnPtr(..) => return false,\n                 // These may potentially implement `FnPtr`"}, {"sha": "20357d4d2501a9795a66c10fa5d846c6d29d27e8", "filename": "compiler/rustc_trait_selection/src/traits/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -115,7 +115,7 @@ impl<'tcx> TraitAliasExpander<'tcx> {\n         }\n \n         // Get components of trait alias.\n-        let predicates = tcx.super_predicates_of(trait_ref.def_id());\n+        let predicates = tcx.implied_predicates_of(trait_ref.def_id());\n         debug!(?predicates);\n \n         let items = predicates.predicates.iter().rev().filter_map(|(pred, span)| {\n@@ -198,7 +198,7 @@ pub fn impl_subject_and_oblig<'a, 'tcx>(\n     impl_def_id: DefId,\n     impl_substs: SubstsRef<'tcx>,\n ) -> (ImplSubject<'tcx>, impl Iterator<Item = PredicateObligation<'tcx>>) {\n-    let subject = selcx.tcx().bound_impl_subject(impl_def_id);\n+    let subject = selcx.tcx().impl_subject(impl_def_id);\n     let subject = subject.subst(selcx.tcx(), impl_substs);\n \n     let InferOk { value: subject, obligations: normalization_obligations1 } ="}, {"sha": "2a89494c80b0415ab85762a109a7927207f222d1", "filename": "compiler/rustc_transmute/src/layout/tree.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Ftree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Ftree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Ftree.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -167,31 +167,31 @@ where\n     }\n }\n \n-#[derive(Debug, Copy, Clone)]\n-pub(crate) enum Err {\n-    /// The layout of the type is unspecified.\n-    Unspecified,\n-    /// This error will be surfaced elsewhere by rustc, so don't surface it.\n-    Unknown,\n-}\n-\n #[cfg(feature = \"rustc\")]\n pub(crate) mod rustc {\n-    use super::{Err, Tree};\n+    use super::Tree;\n     use crate::layout::rustc::{Def, Ref};\n \n-    use rustc_middle::ty;\n     use rustc_middle::ty::layout::LayoutError;\n     use rustc_middle::ty::util::Discr;\n     use rustc_middle::ty::AdtDef;\n     use rustc_middle::ty::ParamEnv;\n     use rustc_middle::ty::SubstsRef;\n-    use rustc_middle::ty::Ty;\n-    use rustc_middle::ty::TyCtxt;\n     use rustc_middle::ty::VariantDef;\n+    use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitableExt};\n+    use rustc_span::ErrorGuaranteed;\n     use rustc_target::abi::Align;\n     use std::alloc;\n \n+    #[derive(Debug, Copy, Clone)]\n+    pub(crate) enum Err {\n+        /// The layout of the type is unspecified.\n+        Unspecified,\n+        /// This error will be surfaced elsewhere by rustc, so don't surface it.\n+        Unknown,\n+        TypeError(ErrorGuaranteed),\n+    }\n+\n     impl<'tcx> From<LayoutError<'tcx>> for Err {\n         fn from(err: LayoutError<'tcx>) -> Self {\n             match err {\n@@ -261,6 +261,10 @@ pub(crate) mod rustc {\n             use rustc_middle::ty::UintTy::*;\n             use rustc_target::abi::HasDataLayout;\n \n+            if let Err(e) = ty.error_reported() {\n+                return Err(Err::TypeError(e));\n+            }\n+\n             let target = tcx.data_layout();\n \n             match ty.kind() {"}, {"sha": "2e2fb90e71c1a18838a2c06e87fbc32f03d071a0", "filename": "compiler/rustc_transmute/src/maybe_transmutable/mod.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -56,7 +56,7 @@ where\n #[cfg(feature = \"rustc\")]\n mod rustc {\n     use super::*;\n-    use crate::layout::tree::Err;\n+    use crate::layout::tree::rustc::Err;\n \n     use rustc_middle::ty::Ty;\n     use rustc_middle::ty::TyCtxt;\n@@ -71,19 +71,20 @@ mod rustc {\n                 // representations. If these conversions fail, conclude that the transmutation is\n                 // unacceptable; the layouts of both the source and destination types must be\n                 // well-defined.\n-                let src = Tree::from_ty(src, context).map_err(|err| match err {\n-                    // Answer `Yes` here, because \"Unknown Type\" will already be reported by\n-                    // rustc. No need to spam the user with more errors.\n-                    Err::Unknown => Answer::Yes,\n-                    Err::Unspecified => Answer::No(Reason::SrcIsUnspecified),\n-                })?;\n+                let src = Tree::from_ty(src, context);\n+                let dst = Tree::from_ty(dst, context);\n \n-                let dst = Tree::from_ty(dst, context).map_err(|err| match err {\n-                    Err::Unknown => Answer::Yes,\n-                    Err::Unspecified => Answer::No(Reason::DstIsUnspecified),\n-                })?;\n-\n-                Ok((src, dst))\n+                match (src, dst) {\n+                    // Answer `Yes` here, because 'unknown layout' and type errors will already\n+                    // be reported by rustc. No need to spam the user with more errors.\n+                    (Err(Err::TypeError(_)), _) => Err(Answer::Yes),\n+                    (_, Err(Err::TypeError(_))) => Err(Answer::Yes),\n+                    (Err(Err::Unknown), _) => Err(Answer::Yes),\n+                    (_, Err(Err::Unknown)) => Err(Answer::Yes),\n+                    (Err(Err::Unspecified), _) => Err(Answer::No(Reason::SrcIsUnspecified)),\n+                    (_, Err(Err::Unspecified)) => Err(Answer::No(Reason::DstIsUnspecified)),\n+                    (Ok(src), Ok(dst)) => Ok((src, dst)),\n+                }\n             });\n \n             match query_or_answer {"}, {"sha": "a8675f4ae37d8a2703dbf5ccd414af24c415ff4d", "filename": "compiler/rustc_transmute/src/maybe_transmutable/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Ftests.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1,6 +1,6 @@\n use super::query_context::test::{Def, UltraMinimal};\n use crate::maybe_transmutable::MaybeTransmutableQuery;\n-use crate::{layout, Answer, Reason, Set};\n+use crate::{layout, Answer, Reason};\n use itertools::Itertools;\n \n mod bool {\n@@ -48,9 +48,9 @@ mod bool {\n \n         let into_set = |alts: Vec<_>| {\n             #[cfg(feature = \"rustc\")]\n-            let mut set = Set::default();\n+            let mut set = crate::Set::default();\n             #[cfg(not(feature = \"rustc\"))]\n-            let mut set = Set::new();\n+            let mut set = std::collections::HashSet::new();\n             set.extend(alts);\n             set\n         };"}, {"sha": "15a14112f4a28fd0c14e48ceb0be146b73620421", "filename": "compiler/rustc_ty_utils/messages.ftl", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_ty_utils%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_ty_utils%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fmessages.ftl?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -12,7 +12,7 @@ ty_utils_array_not_supported = array construction is not supported in generic co\n \n ty_utils_block_not_supported = blocks are not supported in generic constants\n \n-ty_utils_never_to_any_not_supported = converting nevers to any is not supported in generic constants\n+ty_utils_never_to_any_not_supported = coercing the `never` type is not supported in generic constants\n \n ty_utils_tuple_not_supported = tuple construction is not supported in generic constants\n \n@@ -54,4 +54,4 @@ ty_utils_multiple_array_fields_simd_type = monomorphising SIMD type `{$ty}` with\n \n ty_utils_oversized_simd_type = monomorphising SIMD type `{$ty}` of length greater than {$max_lanes}\n \n-ty_utils_non_primative_simd_type = monomorphising SIMD type `{$ty}` with a non-primitive-scalar (integer/float/pointer) element type `{$e_ty}`\n+ty_utils_non_primitive_simd_type = monomorphising SIMD type `{$ty}` with a non-primitive-scalar (integer/float/pointer) element type `{$e_ty}`"}, {"sha": "3d3fc50e6e59fefb36d01a93e09dcc701f352155", "filename": "compiler/rustc_ty_utils/src/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_ty_utils%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_ty_utils%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Ferrors.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -95,7 +95,7 @@ pub struct OversizedSimdType<'tcx> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(ty_utils_non_primative_simd_type)]\n+#[diag(ty_utils_non_primitive_simd_type)]\n pub struct NonPrimitiveSimdType<'tcx> {\n     pub ty: Ty<'tcx>,\n     pub e_ty: Ty<'tcx>,"}, {"sha": "63ef1c72417fb2c52a571c2d84998e29e978b923", "filename": "compiler/rustc_ty_utils/src/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -322,7 +322,7 @@ fn layout_of_uncached<'tcx>(\n                 if fi.ty(tcx, substs) != f0_ty {\n                     tcx.sess.delay_span_bug(\n                         DUMMY_SP,\n-                        \"#[repr(simd)] was applied to an ADT with hetrogeneous field type\",\n+                        \"#[repr(simd)] was applied to an ADT with heterogeneous field type\",\n                     );\n                     return Err(LayoutError::Unknown(ty));\n                 }"}, {"sha": "a3c98ae007edeb2354a2f68a065b07b7208d3398", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -83,7 +83,7 @@ pub trait CollectAndApply<T, R>: Sized {\n     /// Produce a result of type `Self::Output` from `iter`. The result will\n     /// typically be produced by applying `f` on the elements produced by\n     /// `iter`, though this may not happen in some impls, e.g. if an error\n-    /// occured during iteration.\n+    /// occurred during iteration.\n     fn collect_and_apply<I, F>(iter: I, f: F) -> Self::Output\n     where\n         I: Iterator<Item = Self>,"}, {"sha": "6d9c762ceca1ef62d3fdef87dedcedd34f457103", "filename": "config.example.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/config.example.toml", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/config.example.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.example.toml?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -88,7 +88,7 @@ changelog-seen = 2\n # the resulting rustc being unable to compile for the disabled architectures.\n #\n # To add support for new targets, see https://rustc-dev-guide.rust-lang.org/building/new-target.html.\n-#targets = \"AArch64;ARM;BPF;Hexagon;MSP430;Mips;NVPTX;PowerPC;RISCV;Sparc;SystemZ;WebAssembly;X86\"\n+#targets = \"AArch64;ARM;BPF;Hexagon;LoongArch;MSP430;Mips;NVPTX;PowerPC;RISCV;Sparc;SystemZ;WebAssembly;X86\"\n \n # LLVM experimental targets to build support for. These targets are specified in\n # the same format as above, but since these targets are experimental, they are\n@@ -257,7 +257,7 @@ changelog-seen = 2\n #python = \"python\"\n \n # The path to the REUSE executable to use. Note that REUSE is not required in\n-# most cases, as our tooling relies on a cached (and shrinked) copy of the\n+# most cases, as our tooling relies on a cached (and shrunk) copy of the\n # REUSE output present in the git repository and in our source tarballs.\n #\n # REUSE is only needed if your changes caused the overall licensing of the"}, {"sha": "da675379cd58bfc0d70e8675cea0bae76e3160aa", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -3183,7 +3183,7 @@ impl<'a, K: Ord, V, A: Allocator + Clone> CursorMut<'a, K, V, A> {\n                 panic!(\"key must be ordered above the current element\");\n             }\n         }\n-        if let Some((next, _)) = self.peek_prev() {\n+        if let Some((next, _)) = self.peek_next() {\n             if &key >= next {\n                 panic!(\"key must be ordered below the next element\");\n             }"}, {"sha": "4311f21c925cda7a7ffdcab338ee78085cf4e92c", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -2385,3 +2385,67 @@ fn test_cursor_mut() {\n     assert_eq!(cur.key(), Some(&4));\n     assert_eq!(map, BTreeMap::from([(0, '?'), (1, 'a'), (3, 'c'), (4, 'd')]));\n }\n+\n+#[should_panic(expected = \"key must be ordered above the previous element\")]\n+#[test]\n+fn test_cursor_mut_insert_before_1() {\n+    let mut map = BTreeMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);\n+    let mut cur = map.upper_bound_mut(Bound::Included(&2));\n+    cur.insert_before(0, 'd');\n+}\n+\n+#[should_panic(expected = \"key must be ordered above the previous element\")]\n+#[test]\n+fn test_cursor_mut_insert_before_2() {\n+    let mut map = BTreeMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);\n+    let mut cur = map.upper_bound_mut(Bound::Included(&2));\n+    cur.insert_before(1, 'd');\n+}\n+\n+#[should_panic(expected = \"key must be ordered below the current element\")]\n+#[test]\n+fn test_cursor_mut_insert_before_3() {\n+    let mut map = BTreeMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);\n+    let mut cur = map.upper_bound_mut(Bound::Included(&2));\n+    cur.insert_before(2, 'd');\n+}\n+\n+#[should_panic(expected = \"key must be ordered below the current element\")]\n+#[test]\n+fn test_cursor_mut_insert_before_4() {\n+    let mut map = BTreeMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);\n+    let mut cur = map.upper_bound_mut(Bound::Included(&2));\n+    cur.insert_before(3, 'd');\n+}\n+\n+#[should_panic(expected = \"key must be ordered above the current element\")]\n+#[test]\n+fn test_cursor_mut_insert_after_1() {\n+    let mut map = BTreeMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);\n+    let mut cur = map.upper_bound_mut(Bound::Included(&2));\n+    cur.insert_after(1, 'd');\n+}\n+\n+#[should_panic(expected = \"key must be ordered above the current element\")]\n+#[test]\n+fn test_cursor_mut_insert_after_2() {\n+    let mut map = BTreeMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);\n+    let mut cur = map.upper_bound_mut(Bound::Included(&2));\n+    cur.insert_after(2, 'd');\n+}\n+\n+#[should_panic(expected = \"key must be ordered below the next element\")]\n+#[test]\n+fn test_cursor_mut_insert_after_3() {\n+    let mut map = BTreeMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);\n+    let mut cur = map.upper_bound_mut(Bound::Included(&2));\n+    cur.insert_after(3, 'd');\n+}\n+\n+#[should_panic(expected = \"key must be ordered below the next element\")]\n+#[test]\n+fn test_cursor_mut_insert_after_4() {\n+    let mut map = BTreeMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);\n+    let mut cur = map.upper_bound_mut(Bound::Included(&2));\n+    cur.insert_after(4, 'd');\n+}"}, {"sha": "c4f554c8c6bf99c57d2dfeeee6636975e37911a8", "filename": "library/core/src/ffi/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -615,12 +615,15 @@ impl<'f> Drop for VaListImpl<'f> {\n extern \"rust-intrinsic\" {\n     /// Destroy the arglist `ap` after initialization with `va_start` or\n     /// `va_copy`.\n+    #[rustc_nounwind]\n     fn va_end(ap: &mut VaListImpl<'_>);\n \n     /// Copies the current location of arglist `src` to the arglist `dst`.\n+    #[rustc_nounwind]\n     fn va_copy<'f>(dest: *mut VaListImpl<'f>, src: &VaListImpl<'f>);\n \n     /// Loads an argument of type `T` from the `va_list` `ap` and increment the\n     /// argument `ap` points to.\n+    #[rustc_nounwind]\n     fn va_arg<T: sealed_trait::VaArgSafe>(ap: &mut VaListImpl<'_>) -> T;\n }"}, {"sha": "a7c100e1b23ed6d87fd8c0bf00e48bf0c6a966c3", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 231, "deletions": 1, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -84,104 +84,119 @@ extern \"rust-intrinsic\" {\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Relaxed`] as both the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_relaxed_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Relaxed`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_relaxed_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Relaxed`] and [`Ordering::SeqCst`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_relaxed_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Acquire`] and [`Ordering::Relaxed`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_acquire_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Acquire`] as both the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_acquire_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Acquire`] and [`Ordering::SeqCst`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_acquire_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Release`] and [`Ordering::Relaxed`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_release_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Release`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_release_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Release`] and [`Ordering::SeqCst`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_release_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::AcqRel`] and [`Ordering::Relaxed`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_acqrel_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::AcqRel`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_acqrel_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::AcqRel`] and [`Ordering::SeqCst`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_acqrel_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::SeqCst`] and [`Ordering::Relaxed`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_seqcst_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::SeqCst`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_seqcst_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::SeqCst`] as both the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_seqcst_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n     /// Stores a value if the current value is the same as the `old` value.\n@@ -190,411 +205,477 @@ extern \"rust-intrinsic\" {\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Relaxed`] as both the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_relaxed_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Relaxed`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_relaxed_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Relaxed`] and [`Ordering::SeqCst`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_relaxed_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Acquire`] and [`Ordering::Relaxed`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_acquire_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Acquire`] as both the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_acquire_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Acquire`] and [`Ordering::SeqCst`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_acquire_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Release`] and [`Ordering::Relaxed`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_release_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Release`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_release_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Release`] and [`Ordering::SeqCst`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_release_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::AcqRel`] and [`Ordering::Relaxed`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_acqrel_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::AcqRel`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_acqrel_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::AcqRel`] and [`Ordering::SeqCst`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_acqrel_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::SeqCst`] and [`Ordering::Relaxed`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_seqcst_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::SeqCst`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_seqcst_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::SeqCst`] as both the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_seqcst_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n     /// Loads the current value of the pointer.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `load` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::load`].\n+    #[rustc_nounwind]\n     pub fn atomic_load_seqcst<T: Copy>(src: *const T) -> T;\n     /// Loads the current value of the pointer.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `load` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::load`].\n+    #[rustc_nounwind]\n     pub fn atomic_load_acquire<T: Copy>(src: *const T) -> T;\n     /// Loads the current value of the pointer.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `load` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::load`].\n+    #[rustc_nounwind]\n     pub fn atomic_load_relaxed<T: Copy>(src: *const T) -> T;\n+    #[rustc_nounwind]\n     pub fn atomic_load_unordered<T: Copy>(src: *const T) -> T;\n \n     /// Stores the value at the specified memory location.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `store` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::store`].\n+    #[rustc_nounwind]\n     pub fn atomic_store_seqcst<T: Copy>(dst: *mut T, val: T);\n     /// Stores the value at the specified memory location.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `store` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::store`].\n+    #[rustc_nounwind]\n     pub fn atomic_store_release<T: Copy>(dst: *mut T, val: T);\n     /// Stores the value at the specified memory location.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `store` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::store`].\n+    #[rustc_nounwind]\n     pub fn atomic_store_relaxed<T: Copy>(dst: *mut T, val: T);\n+    #[rustc_nounwind]\n     pub fn atomic_store_unordered<T: Copy>(dst: *mut T, val: T);\n \n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `swap` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::swap`].\n+    #[rustc_nounwind]\n     pub fn atomic_xchg_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `swap` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::swap`].\n+    #[rustc_nounwind]\n     pub fn atomic_xchg_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `swap` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::swap`].\n+    #[rustc_nounwind]\n     pub fn atomic_xchg_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `swap` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::swap`].\n+    #[rustc_nounwind]\n     pub fn atomic_xchg_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `swap` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::swap`].\n+    #[rustc_nounwind]\n     pub fn atomic_xchg_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_add` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n+    #[rustc_nounwind]\n     pub fn atomic_xadd_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_add` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n+    #[rustc_nounwind]\n     pub fn atomic_xadd_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_add` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n+    #[rustc_nounwind]\n     pub fn atomic_xadd_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_add` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n+    #[rustc_nounwind]\n     pub fn atomic_xadd_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_add` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n+    #[rustc_nounwind]\n     pub fn atomic_xadd_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_sub` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n+    #[rustc_nounwind]\n     pub fn atomic_xsub_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_sub` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n+    #[rustc_nounwind]\n     pub fn atomic_xsub_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_sub` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n+    #[rustc_nounwind]\n     pub fn atomic_xsub_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_sub` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n+    #[rustc_nounwind]\n     pub fn atomic_xsub_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_sub` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n+    #[rustc_nounwind]\n     pub fn atomic_xsub_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_and` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_and`].\n+    #[rustc_nounwind]\n     pub fn atomic_and_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_and` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_and`].\n+    #[rustc_nounwind]\n     pub fn atomic_and_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_and` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_and`].\n+    #[rustc_nounwind]\n     pub fn atomic_and_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_and` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::fetch_and`].\n+    #[rustc_nounwind]\n     pub fn atomic_and_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_and` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::fetch_and`].\n+    #[rustc_nounwind]\n     pub fn atomic_and_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`AtomicBool`] type via the `fetch_nand` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n+    #[rustc_nounwind]\n     pub fn atomic_nand_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`AtomicBool`] type via the `fetch_nand` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n+    #[rustc_nounwind]\n     pub fn atomic_nand_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`AtomicBool`] type via the `fetch_nand` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n+    #[rustc_nounwind]\n     pub fn atomic_nand_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`AtomicBool`] type via the `fetch_nand` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n+    #[rustc_nounwind]\n     pub fn atomic_nand_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`AtomicBool`] type via the `fetch_nand` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n+    #[rustc_nounwind]\n     pub fn atomic_nand_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_or` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_or`].\n+    #[rustc_nounwind]\n     pub fn atomic_or_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_or` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_or`].\n+    #[rustc_nounwind]\n     pub fn atomic_or_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_or` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_or`].\n+    #[rustc_nounwind]\n     pub fn atomic_or_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_or` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::fetch_or`].\n+    #[rustc_nounwind]\n     pub fn atomic_or_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_or` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::fetch_or`].\n+    #[rustc_nounwind]\n     pub fn atomic_or_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_xor` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n+    #[rustc_nounwind]\n     pub fn atomic_xor_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_xor` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n+    #[rustc_nounwind]\n     pub fn atomic_xor_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_xor` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n+    #[rustc_nounwind]\n     pub fn atomic_xor_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_xor` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n+    #[rustc_nounwind]\n     pub fn atomic_xor_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_xor` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n+    #[rustc_nounwind]\n     pub fn atomic_xor_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicI32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_max_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicI32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_max_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicI32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_max_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicI32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_max_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicI32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_max_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_min` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicI32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_min_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_min` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicI32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_min_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_min` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicI32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_min_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n@@ -607,93 +688,108 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_min` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicI32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_min_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicU32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_umin_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicU32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_umin_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicU32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_umin_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicU32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_umin_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicU32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_umin_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicU32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_umax_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicU32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_umax_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicU32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_umax_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicU32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_umax_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicU32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_umax_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::fence`] by passing [`Ordering::SeqCst`]\n     /// as the `order`.\n+    #[rustc_nounwind]\n     pub fn atomic_fence_seqcst();\n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::fence`] by passing [`Ordering::Acquire`]\n     /// as the `order`.\n+    #[rustc_nounwind]\n     pub fn atomic_fence_acquire();\n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::fence`] by passing [`Ordering::Release`]\n     /// as the `order`.\n+    #[rustc_nounwind]\n     pub fn atomic_fence_release();\n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::fence`] by passing [`Ordering::AcqRel`]\n     /// as the `order`.\n+    #[rustc_nounwind]\n     pub fn atomic_fence_acqrel();\n \n     /// A compiler-only memory barrier.\n@@ -706,6 +802,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::compiler_fence`] by passing [`Ordering::SeqCst`]\n     /// as the `order`.\n+    #[rustc_nounwind]\n     pub fn atomic_singlethreadfence_seqcst();\n     /// A compiler-only memory barrier.\n     ///\n@@ -717,6 +814,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::compiler_fence`] by passing [`Ordering::Acquire`]\n     /// as the `order`.\n+    #[rustc_nounwind]\n     pub fn atomic_singlethreadfence_acquire();\n     /// A compiler-only memory barrier.\n     ///\n@@ -728,6 +826,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::compiler_fence`] by passing [`Ordering::Release`]\n     /// as the `order`.\n+    #[rustc_nounwind]\n     pub fn atomic_singlethreadfence_release();\n     /// A compiler-only memory barrier.\n     ///\n@@ -739,6 +838,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::compiler_fence`] by passing [`Ordering::AcqRel`]\n     /// as the `order`.\n+    #[rustc_nounwind]\n     pub fn atomic_singlethreadfence_acqrel();\n \n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n@@ -750,6 +850,7 @@ extern \"rust-intrinsic\" {\n     /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn prefetch_read_data<T>(data: *const T, locality: i32);\n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n     /// if supported; otherwise, it is a no-op.\n@@ -760,6 +861,7 @@ extern \"rust-intrinsic\" {\n     /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn prefetch_write_data<T>(data: *const T, locality: i32);\n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n     /// if supported; otherwise, it is a no-op.\n@@ -770,6 +872,7 @@ extern \"rust-intrinsic\" {\n     /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn prefetch_read_instruction<T>(data: *const T, locality: i32);\n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n     /// if supported; otherwise, it is a no-op.\n@@ -780,6 +883,7 @@ extern \"rust-intrinsic\" {\n     /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn prefetch_write_instruction<T>(data: *const T, locality: i32);\n \n     /// Magic intrinsic that derives its meaning from attributes\n@@ -792,6 +896,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// This intrinsic should not be used outside of the compiler.\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn rustc_peek<T>(_: T) -> T;\n \n     /// Aborts the execution of the process.\n@@ -810,6 +915,7 @@ extern \"rust-intrinsic\" {\n     /// process will probably terminate with a signal like `SIGABRT`, `SIGILL`, `SIGTRAP`, `SIGSEGV` or\n     /// `SIGBUS`.  The precise behaviour is not guaranteed and not stable.\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn abort() -> !;\n \n     /// Informs the optimizer that this point in the code is not reachable,\n@@ -821,6 +927,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The stabilized version of this intrinsic is [`core::hint::unreachable_unchecked`].\n     #[rustc_const_stable(feature = \"const_unreachable_unchecked\", since = \"1.57.0\")]\n+    #[rustc_nounwind]\n     pub fn unreachable() -> !;\n \n     /// Informs the optimizer that a condition is always true.\n@@ -834,6 +941,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_assume\", issue = \"76972\")]\n+    #[rustc_nounwind]\n     pub fn assume(b: bool);\n \n     /// Hints to the compiler that branch condition is likely to be true.\n@@ -849,6 +957,7 @@ extern \"rust-intrinsic\" {\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_likely\", issue = \"none\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn likely(b: bool) -> bool;\n \n     /// Hints to the compiler that branch condition is likely to be false.\n@@ -864,11 +973,13 @@ extern \"rust-intrinsic\" {\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_likely\", issue = \"none\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn unlikely(b: bool) -> bool;\n \n     /// Executes a breakpoint trap, for inspection by a debugger.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn breakpoint();\n \n     /// The size of a type in bytes.\n@@ -884,6 +995,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is [`core::mem::size_of`].\n     #[rustc_const_stable(feature = \"const_size_of\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn size_of<T>() -> usize;\n \n     /// The minimum alignment of a type.\n@@ -896,23 +1008,27 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is [`core::mem::align_of`].\n     #[rustc_const_stable(feature = \"const_min_align_of\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn min_align_of<T>() -> usize;\n     /// The preferred alignment of a type.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     /// It's \"tracking issue\" is [#91971](https://github.com/rust-lang/rust/issues/91971).\n     #[rustc_const_unstable(feature = \"const_pref_align_of\", issue = \"91971\")]\n+    #[rustc_nounwind]\n     pub fn pref_align_of<T>() -> usize;\n \n     /// The size of the referenced value in bytes.\n     ///\n     /// The stabilized version of this intrinsic is [`mem::size_of_val`].\n     #[rustc_const_unstable(feature = \"const_size_of_val\", issue = \"46571\")]\n+    #[rustc_nounwind]\n     pub fn size_of_val<T: ?Sized>(_: *const T) -> usize;\n     /// The required alignment of the referenced value.\n     ///\n     /// The stabilized version of this intrinsic is [`core::mem::align_of_val`].\n     #[rustc_const_unstable(feature = \"const_align_of_val\", issue = \"46571\")]\n+    #[rustc_nounwind]\n     pub fn min_align_of_val<T: ?Sized>(_: *const T) -> usize;\n \n     /// Gets a static string slice containing the name of a type.\n@@ -925,6 +1041,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is [`core::any::type_name`].\n     #[rustc_const_unstable(feature = \"const_type_name\", issue = \"63084\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn type_name<T: ?Sized>() -> &'static str;\n \n     /// Gets an identifier which is globally unique to the specified type. This\n@@ -939,6 +1056,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is [`core::any::TypeId::of`].\n     #[rustc_const_unstable(feature = \"const_type_id\", issue = \"77125\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn type_id<T: ?Sized + 'static>() -> u64;\n \n     /// A guard for unsafe functions that cannot ever be executed if `T` is uninhabited:\n@@ -947,6 +1065,7 @@ extern \"rust-intrinsic\" {\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_stable(feature = \"const_assert_type\", since = \"1.59.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn assert_inhabited<T>();\n \n     /// A guard for unsafe functions that cannot ever be executed if `T` does not permit\n@@ -955,13 +1074,15 @@ extern \"rust-intrinsic\" {\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_assert_type2\", issue = \"none\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn assert_zero_valid<T>();\n \n     /// A guard for `std::mem::uninitialized`. This will statically either panic, or do nothing.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_assert_type2\", issue = \"none\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn assert_mem_uninitialized_valid<T>();\n \n     /// Gets a reference to a static `Location` indicating where it was called.\n@@ -974,6 +1095,7 @@ extern \"rust-intrinsic\" {\n     /// Consider using [`core::panic::Location::caller`] instead.\n     #[rustc_const_unstable(feature = \"const_caller_location\", issue = \"76156\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn caller_location() -> &'static crate::panic::Location<'static>;\n \n     /// Moves a value out of scope without running drop glue.\n@@ -987,6 +1109,7 @@ extern \"rust-intrinsic\" {\n     /// any safety invariants.\n     #[rustc_const_unstable(feature = \"const_intrinsic_forget\", issue = \"none\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn forget<T: ?Sized>(_: T);\n \n     /// Reinterprets the bits of a value of one type as another type.\n@@ -1250,6 +1373,7 @@ extern \"rust-intrinsic\" {\n     #[rustc_allowed_through_unstable_modules]\n     #[rustc_const_stable(feature = \"const_transmute\", since = \"1.56.0\")]\n     #[rustc_diagnostic_item = \"transmute\"]\n+    #[rustc_nounwind]\n     pub fn transmute<Src, Dst>(src: Src) -> Dst;\n \n     /// Returns `true` if the actual type given as `T` requires drop\n@@ -1267,6 +1391,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is [`mem::needs_drop`](crate::mem::needs_drop).\n     #[rustc_const_stable(feature = \"const_needs_drop\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn needs_drop<T: ?Sized>() -> bool;\n \n     /// Calculates the offset from a pointer.\n@@ -1284,6 +1409,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is [`pointer::offset`].\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n     #[rustc_const_stable(feature = \"const_ptr_offset\", since = \"1.61.0\")]\n+    #[rustc_nounwind]\n     pub fn offset<T>(dst: *const T, offset: isize) -> *const T;\n \n     /// Calculates the offset from a pointer, potentially wrapping.\n@@ -1301,6 +1427,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is [`pointer::wrapping_offset`].\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n     #[rustc_const_stable(feature = \"const_ptr_offset\", since = \"1.61.0\")]\n+    #[rustc_nounwind]\n     pub fn arith_offset<T>(dst: *const T, offset: isize) -> *const T;\n \n     /// Masks out bits of the pointer according to a mask.\n@@ -1312,6 +1439,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// Consider using [`pointer::mask`] instead.\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn ptr_mask<T>(ptr: *const T, mask: usize) -> *const T;\n \n     /// Equivalent to the appropriate `llvm.memcpy.p0i8.0i8.*` intrinsic, with\n@@ -1322,6 +1450,7 @@ extern \"rust-intrinsic\" {\n     /// unless size is equal to zero.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn volatile_copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: usize);\n     /// Equivalent to the appropriate `llvm.memmove.p0i8.0i8.*` intrinsic, with\n     /// a size of `count * size_of::<T>()` and an alignment of\n@@ -1331,6 +1460,7 @@ extern \"rust-intrinsic\" {\n     /// unless size is equal to zero.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn volatile_copy_memory<T>(dst: *mut T, src: *const T, count: usize);\n     /// Equivalent to the appropriate `llvm.memset.p0i8.*` intrinsic, with a\n     /// size of `count * size_of::<T>()` and an alignment of\n@@ -1340,158 +1470,187 @@ extern \"rust-intrinsic\" {\n     /// unless size is equal to zero.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn volatile_set_memory<T>(dst: *mut T, val: u8, count: usize);\n \n     /// Performs a volatile load from the `src` pointer.\n     ///\n     /// The stabilized version of this intrinsic is [`core::ptr::read_volatile`].\n+    #[rustc_nounwind]\n     pub fn volatile_load<T>(src: *const T) -> T;\n     /// Performs a volatile store to the `dst` pointer.\n     ///\n     /// The stabilized version of this intrinsic is [`core::ptr::write_volatile`].\n+    #[rustc_nounwind]\n     pub fn volatile_store<T>(dst: *mut T, val: T);\n \n     /// Performs a volatile load from the `src` pointer\n     /// The pointer is not required to be aligned.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn unaligned_volatile_load<T>(src: *const T) -> T;\n     /// Performs a volatile store to the `dst` pointer.\n     /// The pointer is not required to be aligned.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn unaligned_volatile_store<T>(dst: *mut T, val: T);\n \n     /// Returns the square root of an `f32`\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::sqrt`](../../std/primitive.f32.html#method.sqrt)\n+    #[rustc_nounwind]\n     pub fn sqrtf32(x: f32) -> f32;\n     /// Returns the square root of an `f64`\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::sqrt`](../../std/primitive.f64.html#method.sqrt)\n+    #[rustc_nounwind]\n     pub fn sqrtf64(x: f64) -> f64;\n \n     /// Raises an `f32` to an integer power.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::powi`](../../std/primitive.f32.html#method.powi)\n+    #[rustc_nounwind]\n     pub fn powif32(a: f32, x: i32) -> f32;\n     /// Raises an `f64` to an integer power.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::powi`](../../std/primitive.f64.html#method.powi)\n+    #[rustc_nounwind]\n     pub fn powif64(a: f64, x: i32) -> f64;\n \n     /// Returns the sine of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::sin`](../../std/primitive.f32.html#method.sin)\n+    #[rustc_nounwind]\n     pub fn sinf32(x: f32) -> f32;\n     /// Returns the sine of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::sin`](../../std/primitive.f64.html#method.sin)\n+    #[rustc_nounwind]\n     pub fn sinf64(x: f64) -> f64;\n \n     /// Returns the cosine of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::cos`](../../std/primitive.f32.html#method.cos)\n+    #[rustc_nounwind]\n     pub fn cosf32(x: f32) -> f32;\n     /// Returns the cosine of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::cos`](../../std/primitive.f64.html#method.cos)\n+    #[rustc_nounwind]\n     pub fn cosf64(x: f64) -> f64;\n \n     /// Raises an `f32` to an `f32` power.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::powf`](../../std/primitive.f32.html#method.powf)\n+    #[rustc_nounwind]\n     pub fn powf32(a: f32, x: f32) -> f32;\n     /// Raises an `f64` to an `f64` power.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::powf`](../../std/primitive.f64.html#method.powf)\n+    #[rustc_nounwind]\n     pub fn powf64(a: f64, x: f64) -> f64;\n \n     /// Returns the exponential of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::exp`](../../std/primitive.f32.html#method.exp)\n+    #[rustc_nounwind]\n     pub fn expf32(x: f32) -> f32;\n     /// Returns the exponential of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::exp`](../../std/primitive.f64.html#method.exp)\n+    #[rustc_nounwind]\n     pub fn expf64(x: f64) -> f64;\n \n     /// Returns 2 raised to the power of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::exp2`](../../std/primitive.f32.html#method.exp2)\n+    #[rustc_nounwind]\n     pub fn exp2f32(x: f32) -> f32;\n     /// Returns 2 raised to the power of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::exp2`](../../std/primitive.f64.html#method.exp2)\n+    #[rustc_nounwind]\n     pub fn exp2f64(x: f64) -> f64;\n \n     /// Returns the natural logarithm of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::ln`](../../std/primitive.f32.html#method.ln)\n+    #[rustc_nounwind]\n     pub fn logf32(x: f32) -> f32;\n     /// Returns the natural logarithm of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::ln`](../../std/primitive.f64.html#method.ln)\n+    #[rustc_nounwind]\n     pub fn logf64(x: f64) -> f64;\n \n     /// Returns the base 10 logarithm of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::log10`](../../std/primitive.f32.html#method.log10)\n+    #[rustc_nounwind]\n     pub fn log10f32(x: f32) -> f32;\n     /// Returns the base 10 logarithm of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::log10`](../../std/primitive.f64.html#method.log10)\n+    #[rustc_nounwind]\n     pub fn log10f64(x: f64) -> f64;\n \n     /// Returns the base 2 logarithm of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::log2`](../../std/primitive.f32.html#method.log2)\n+    #[rustc_nounwind]\n     pub fn log2f32(x: f32) -> f32;\n     /// Returns the base 2 logarithm of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::log2`](../../std/primitive.f64.html#method.log2)\n+    #[rustc_nounwind]\n     pub fn log2f64(x: f64) -> f64;\n \n     /// Returns `a * b + c` for `f32` values.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::mul_add`](../../std/primitive.f32.html#method.mul_add)\n+    #[rustc_nounwind]\n     pub fn fmaf32(a: f32, b: f32, c: f32) -> f32;\n     /// Returns `a * b + c` for `f64` values.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::mul_add`](../../std/primitive.f64.html#method.mul_add)\n+    #[rustc_nounwind]\n     pub fn fmaf64(a: f64, b: f64, c: f64) -> f64;\n \n     /// Returns the absolute value of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::abs`](../../std/primitive.f32.html#method.abs)\n+    #[rustc_nounwind]\n     pub fn fabsf32(x: f32) -> f32;\n     /// Returns the absolute value of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::abs`](../../std/primitive.f64.html#method.abs)\n+    #[rustc_nounwind]\n     pub fn fabsf64(x: f64) -> f64;\n \n     /// Returns the minimum of two `f32` values.\n@@ -1504,6 +1663,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is\n     /// [`f32::min`]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn minnumf32(x: f32, y: f32) -> f32;\n     /// Returns the minimum of two `f64` values.\n     ///\n@@ -1515,6 +1675,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is\n     /// [`f64::min`]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn minnumf64(x: f64, y: f64) -> f64;\n     /// Returns the maximum of two `f32` values.\n     ///\n@@ -1526,6 +1687,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is\n     /// [`f32::max`]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn maxnumf32(x: f32, y: f32) -> f32;\n     /// Returns the maximum of two `f64` values.\n     ///\n@@ -1537,132 +1699,155 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is\n     /// [`f64::max`]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn maxnumf64(x: f64, y: f64) -> f64;\n \n     /// Copies the sign from `y` to `x` for `f32` values.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::copysign`](../../std/primitive.f32.html#method.copysign)\n+    #[rustc_nounwind]\n     pub fn copysignf32(x: f32, y: f32) -> f32;\n     /// Copies the sign from `y` to `x` for `f64` values.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::copysign`](../../std/primitive.f64.html#method.copysign)\n+    #[rustc_nounwind]\n     pub fn copysignf64(x: f64, y: f64) -> f64;\n \n     /// Returns the largest integer less than or equal to an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::floor`](../../std/primitive.f32.html#method.floor)\n+    #[rustc_nounwind]\n     pub fn floorf32(x: f32) -> f32;\n     /// Returns the largest integer less than or equal to an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::floor`](../../std/primitive.f64.html#method.floor)\n+    #[rustc_nounwind]\n     pub fn floorf64(x: f64) -> f64;\n \n     /// Returns the smallest integer greater than or equal to an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::ceil`](../../std/primitive.f32.html#method.ceil)\n+    #[rustc_nounwind]\n     pub fn ceilf32(x: f32) -> f32;\n     /// Returns the smallest integer greater than or equal to an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::ceil`](../../std/primitive.f64.html#method.ceil)\n+    #[rustc_nounwind]\n     pub fn ceilf64(x: f64) -> f64;\n \n     /// Returns the integer part of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::trunc`](../../std/primitive.f32.html#method.trunc)\n+    #[rustc_nounwind]\n     pub fn truncf32(x: f32) -> f32;\n     /// Returns the integer part of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::trunc`](../../std/primitive.f64.html#method.trunc)\n+    #[rustc_nounwind]\n     pub fn truncf64(x: f64) -> f64;\n \n     /// Returns the nearest integer to an `f32`. May raise an inexact floating-point exception\n     /// if the argument is not an integer.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::round_ties_even`](../../std/primitive.f32.html#method.round_ties_even)\n+    #[rustc_nounwind]\n     pub fn rintf32(x: f32) -> f32;\n     /// Returns the nearest integer to an `f64`. May raise an inexact floating-point exception\n     /// if the argument is not an integer.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::round_ties_even`](../../std/primitive.f64.html#method.round_ties_even)\n+    #[rustc_nounwind]\n     pub fn rintf64(x: f64) -> f64;\n \n     /// Returns the nearest integer to an `f32`.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn nearbyintf32(x: f32) -> f32;\n     /// Returns the nearest integer to an `f64`.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn nearbyintf64(x: f64) -> f64;\n \n     /// Returns the nearest integer to an `f32`. Rounds half-way cases away from zero.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::round`](../../std/primitive.f32.html#method.round)\n+    #[rustc_nounwind]\n     pub fn roundf32(x: f32) -> f32;\n     /// Returns the nearest integer to an `f64`. Rounds half-way cases away from zero.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::round`](../../std/primitive.f64.html#method.round)\n+    #[rustc_nounwind]\n     pub fn roundf64(x: f64) -> f64;\n \n     /// Returns the nearest integer to an `f32`. Rounds half-way cases to the number\n     /// with an even least significant digit.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[cfg(not(bootstrap))]\n+    #[rustc_nounwind]\n     pub fn roundevenf32(x: f32) -> f32;\n     /// Returns the nearest integer to an `f64`. Rounds half-way cases to the number\n     /// with an even least significant digit.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[cfg(not(bootstrap))]\n+    #[rustc_nounwind]\n     pub fn roundevenf64(x: f64) -> f64;\n \n     /// Float addition that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn fadd_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Float subtraction that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn fsub_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Float multiplication that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn fmul_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Float division that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn fdiv_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Float remainder that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn frem_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Convert with LLVM\u2019s fptoui/fptosi, which may return undef for values out of range\n     /// (<https://github.com/rust-lang/rust/issues/10184>)\n     ///\n     /// Stabilized as [`f32::to_int_unchecked`] and [`f64::to_int_unchecked`].\n+    #[rustc_nounwind]\n     pub fn float_to_int_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n \n     /// Returns the number of bits set in an integer type `T`\n@@ -1677,6 +1862,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::count_ones`]\n     #[rustc_const_stable(feature = \"const_ctpop\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn ctpop<T: Copy>(x: T) -> T;\n \n     /// Returns the number of leading unset bits (zeroes) in an integer type `T`.\n@@ -1715,6 +1901,7 @@ extern \"rust-intrinsic\" {\n     /// ```\n     #[rustc_const_stable(feature = \"const_ctlz\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn ctlz<T: Copy>(x: T) -> T;\n \n     /// Like `ctlz`, but extra-unsafe as it returns `undef` when\n@@ -1734,6 +1921,7 @@ extern \"rust-intrinsic\" {\n     /// assert_eq!(num_leading, 3);\n     /// ```\n     #[rustc_const_stable(feature = \"constctlz\", since = \"1.50.0\")]\n+    #[rustc_nounwind]\n     pub fn ctlz_nonzero<T: Copy>(x: T) -> T;\n \n     /// Returns the number of trailing unset bits (zeroes) in an integer type `T`.\n@@ -1772,6 +1960,7 @@ extern \"rust-intrinsic\" {\n     /// ```\n     #[rustc_const_stable(feature = \"const_cttz\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn cttz<T: Copy>(x: T) -> T;\n \n     /// Like `cttz`, but extra-unsafe as it returns `undef` when\n@@ -1791,6 +1980,7 @@ extern \"rust-intrinsic\" {\n     /// assert_eq!(num_trailing, 3);\n     /// ```\n     #[rustc_const_stable(feature = \"const_cttz_nonzero\", since = \"1.53.0\")]\n+    #[rustc_nounwind]\n     pub fn cttz_nonzero<T: Copy>(x: T) -> T;\n \n     /// Reverses the bytes in an integer type `T`.\n@@ -1805,6 +1995,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::swap_bytes`]\n     #[rustc_const_stable(feature = \"const_bswap\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn bswap<T: Copy>(x: T) -> T;\n \n     /// Reverses the bits in an integer type `T`.\n@@ -1819,6 +2010,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::reverse_bits`]\n     #[rustc_const_stable(feature = \"const_bitreverse\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn bitreverse<T: Copy>(x: T) -> T;\n \n     /// Performs checked integer addition.\n@@ -1833,6 +2025,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::overflowing_add`]\n     #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn add_with_overflow<T: Copy>(x: T, y: T) -> (T, bool);\n \n     /// Performs checked integer subtraction\n@@ -1847,6 +2040,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::overflowing_sub`]\n     #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn sub_with_overflow<T: Copy>(x: T, y: T) -> (T, bool);\n \n     /// Performs checked integer multiplication\n@@ -1861,13 +2055,15 @@ extern \"rust-intrinsic\" {\n     /// [`u32::overflowing_mul`]\n     #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn mul_with_overflow<T: Copy>(x: T, y: T) -> (T, bool);\n \n     /// Performs an exact division, resulting in undefined behavior where\n     /// `x % y != 0` or `y == 0` or `x == T::MIN && y == -1`\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_exact_div\", issue = \"none\")]\n+    #[rustc_nounwind]\n     pub fn exact_div<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs an unchecked division, resulting in undefined behavior\n@@ -1877,6 +2073,7 @@ extern \"rust-intrinsic\" {\n     /// primitives via the `checked_div` method. For example,\n     /// [`u32::checked_div`]\n     #[rustc_const_stable(feature = \"const_int_unchecked_div\", since = \"1.52.0\")]\n+    #[rustc_nounwind]\n     pub fn unchecked_div<T: Copy>(x: T, y: T) -> T;\n     /// Returns the remainder of an unchecked division, resulting in\n     /// undefined behavior when `y == 0` or `x == T::MIN && y == -1`\n@@ -1885,6 +2082,7 @@ extern \"rust-intrinsic\" {\n     /// primitives via the `checked_rem` method. For example,\n     /// [`u32::checked_rem`]\n     #[rustc_const_stable(feature = \"const_int_unchecked_rem\", since = \"1.52.0\")]\n+    #[rustc_nounwind]\n     pub fn unchecked_rem<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs an unchecked left shift, resulting in undefined behavior when\n@@ -1894,6 +2092,7 @@ extern \"rust-intrinsic\" {\n     /// primitives via the `checked_shl` method. For example,\n     /// [`u32::checked_shl`]\n     #[rustc_const_stable(feature = \"const_int_unchecked\", since = \"1.40.0\")]\n+    #[rustc_nounwind]\n     pub fn unchecked_shl<T: Copy>(x: T, y: T) -> T;\n     /// Performs an unchecked right shift, resulting in undefined behavior when\n     /// `y < 0` or `y >= N`, where N is the width of T in bits.\n@@ -1902,27 +2101,31 @@ extern \"rust-intrinsic\" {\n     /// primitives via the `checked_shr` method. For example,\n     /// [`u32::checked_shr`]\n     #[rustc_const_stable(feature = \"const_int_unchecked\", since = \"1.40.0\")]\n+    #[rustc_nounwind]\n     pub fn unchecked_shr<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked addition, resulting in\n     /// undefined behavior when `x + y > T::MAX` or `x + y < T::MIN`.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n+    #[rustc_nounwind]\n     pub fn unchecked_add<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked subtraction, resulting in\n     /// undefined behavior when `x - y > T::MAX` or `x - y < T::MIN`.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n+    #[rustc_nounwind]\n     pub fn unchecked_sub<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked multiplication, resulting in\n     /// undefined behavior when `x * y > T::MAX` or `x * y < T::MIN`.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n+    #[rustc_nounwind]\n     pub fn unchecked_mul<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs rotate left.\n@@ -1937,6 +2140,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::rotate_left`]\n     #[rustc_const_stable(feature = \"const_int_rotate\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn rotate_left<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs rotate right.\n@@ -1951,6 +2155,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::rotate_right`]\n     #[rustc_const_stable(feature = \"const_int_rotate\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn rotate_right<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns (a + b) mod 2<sup>N</sup>, where N is the width of T in bits.\n@@ -1965,6 +2170,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::wrapping_add`]\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn wrapping_add<T: Copy>(a: T, b: T) -> T;\n     /// Returns (a - b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     ///\n@@ -1978,6 +2184,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::wrapping_sub`]\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn wrapping_sub<T: Copy>(a: T, b: T) -> T;\n     /// Returns (a * b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     ///\n@@ -1991,6 +2198,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::wrapping_mul`]\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn wrapping_mul<T: Copy>(a: T, b: T) -> T;\n \n     /// Computes `a + b`, saturating at numeric bounds.\n@@ -2005,6 +2213,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::saturating_add`]\n     #[rustc_const_stable(feature = \"const_int_saturating\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn saturating_add<T: Copy>(a: T, b: T) -> T;\n     /// Computes `a - b`, saturating at numeric bounds.\n     ///\n@@ -2018,6 +2227,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::saturating_sub`]\n     #[rustc_const_stable(feature = \"const_int_saturating\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn saturating_sub<T: Copy>(a: T, b: T) -> T;\n \n     /// This is an implementation detail of [`crate::ptr::read`] and should\n@@ -2028,6 +2238,7 @@ extern \"rust-intrinsic\" {\n     /// trivially obeys runtime-MIR rules about derefs in operands.\n     #[cfg(not(bootstrap))]\n     #[rustc_const_unstable(feature = \"const_ptr_read\", issue = \"80377\")]\n+    #[rustc_nounwind]\n     pub fn read_via_copy<T>(p: *const T) -> T;\n \n     /// Returns the value of the discriminant for the variant in 'v';\n@@ -2041,6 +2252,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is [`core::mem::discriminant`].\n     #[rustc_const_unstable(feature = \"const_discriminant\", issue = \"69821\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn discriminant_value<T>(v: &T) -> <T as DiscriminantKind>::Discriminant;\n \n     /// Returns the number of variants of the type `T` cast to a `usize`;\n@@ -2054,6 +2266,7 @@ extern \"rust-intrinsic\" {\n     /// The to-be-stabilized version of this intrinsic is [`mem::variant_count`].\n     #[rustc_const_unstable(feature = \"variant_count\", issue = \"73662\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn variant_count<T>() -> usize;\n \n     /// Rust's \"try catch\" construct which invokes the function pointer `try_fn`\n@@ -2063,18 +2276,24 @@ extern \"rust-intrinsic\" {\n     /// takes the data pointer and a pointer to the target-specific exception\n     /// object that was caught. For more information see the compiler's\n     /// source as well as std's catch implementation.\n+    ///\n+    /// `catch_fn` must not unwind.\n+    #[rustc_nounwind]\n     pub fn r#try(try_fn: fn(*mut u8), data: *mut u8, catch_fn: fn(*mut u8, *mut u8)) -> i32;\n \n     /// Emits a `!nontemporal` store according to LLVM (see their docs).\n     /// Probably will never become stable.\n+    #[rustc_nounwind]\n     pub fn nontemporal_store<T>(ptr: *mut T, val: T);\n \n     /// See documentation of `<*const T>::offset_from` for details.\n     #[rustc_const_stable(feature = \"const_ptr_offset_from\", since = \"1.65.0\")]\n+    #[rustc_nounwind]\n     pub fn ptr_offset_from<T>(ptr: *const T, base: *const T) -> isize;\n \n     /// See documentation of `<*const T>::sub_ptr` for details.\n     #[rustc_const_unstable(feature = \"const_ptr_sub_ptr\", issue = \"95892\")]\n+    #[rustc_nounwind]\n     pub fn ptr_offset_from_unsigned<T>(ptr: *const T, base: *const T) -> usize;\n \n     /// See documentation of `<*const T>::guaranteed_eq` for details.\n@@ -2088,6 +2307,7 @@ extern \"rust-intrinsic\" {\n     /// any safety invariants.\n     #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn ptr_guaranteed_cmp<T>(ptr: *const T, other: *const T) -> u8;\n \n     /// Allocates a block of memory at compile time.\n@@ -2099,6 +2319,7 @@ extern \"rust-intrinsic\" {\n     ///    - At compile time, a compile error occurs if this constraint is violated.\n     ///    - At runtime, it is not checked.\n     #[rustc_const_unstable(feature = \"const_heap\", issue = \"79597\")]\n+    #[rustc_nounwind]\n     pub fn const_allocate(size: usize, align: usize) -> *mut u8;\n \n     /// Deallocates a memory which allocated by `intrinsics::const_allocate` at compile time.\n@@ -2112,6 +2333,7 @@ extern \"rust-intrinsic\" {\n     /// - If the `ptr` is created in an another const, this intrinsic doesn't deallocate it.\n     /// - If the `ptr` is pointing to a local variable, this intrinsic doesn't deallocate it.\n     #[rustc_const_unstable(feature = \"const_heap\", issue = \"79597\")]\n+    #[rustc_nounwind]\n     pub fn const_deallocate(ptr: *mut u8, size: usize, align: usize);\n \n     /// Determines whether the raw bytes of the two values are equal.\n@@ -2136,21 +2358,25 @@ extern \"rust-intrinsic\" {\n     /// (The implementation is allowed to branch on the results of comparisons,\n     /// which is UB if any of their inputs are `undef`.)\n     #[rustc_const_unstable(feature = \"const_intrinsic_raw_eq\", issue = \"none\")]\n+    #[rustc_nounwind]\n     pub fn raw_eq<T>(a: &T, b: &T) -> bool;\n \n     /// See documentation of [`std::hint::black_box`] for details.\n     ///\n     /// [`std::hint::black_box`]: crate::hint::black_box\n     #[rustc_const_unstable(feature = \"const_black_box\", issue = \"none\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn black_box<T>(dummy: T) -> T;\n \n     /// `ptr` must point to a vtable.\n     /// The intrinsic will return the size stored in that vtable.\n+    #[rustc_nounwind]\n     pub fn vtable_size(ptr: *const ()) -> usize;\n \n     /// `ptr` must point to a vtable.\n     /// The intrinsic will return the alignment stored in that vtable.\n+    #[rustc_nounwind]\n     pub fn vtable_align(ptr: *const ()) -> usize;\n \n     /// Selects which function to call depending on the context.\n@@ -2215,10 +2441,11 @@ extern \"rust-intrinsic\" {\n         G: FnOnce<ARG, Output = RET>,\n         F: FnOnce<ARG, Output = RET>;\n \n-    #[cfg(not(bootstrap))]\n     /// This method creates a pointer to any `Some` value. If the argument is\n     /// `None`, an invalid within-bounds pointer (that is still acceptable for\n     /// constructing an empty slice) is returned.\n+    #[cfg(not(bootstrap))]\n+    #[rustc_nounwind]\n     pub fn option_payload_ptr<T>(arg: *const Option<T>) -> *const T;\n }\n \n@@ -2392,6 +2619,7 @@ pub(crate) fn is_nonoverlapping<T>(src: *const T, dst: *const T, count: usize) -\n pub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {\n     extern \"rust-intrinsic\" {\n         #[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.63.0\")]\n+        #[rustc_nounwind]\n         pub fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n     }\n \n@@ -2482,6 +2710,7 @@ pub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: us\n pub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n     extern \"rust-intrinsic\" {\n         #[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.63.0\")]\n+        #[rustc_nounwind]\n         fn copy<T>(src: *const T, dst: *mut T, count: usize);\n     }\n \n@@ -2554,6 +2783,7 @@ pub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n pub const unsafe fn write_bytes<T>(dst: *mut T, val: u8, count: usize) {\n     extern \"rust-intrinsic\" {\n         #[rustc_const_unstable(feature = \"const_ptr_write\", issue = \"86302\")]\n+        #[rustc_nounwind]\n         fn write_bytes<T>(dst: *mut T, val: u8, count: usize);\n     }\n "}, {"sha": "d9d62eb759e69ca984a384a4c10ee3d4f5a42f27", "filename": "library/core/src/intrinsics/mir.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -232,6 +232,7 @@\n //!  - `&`, `&mut`, `addr_of!`, and `addr_of_mut!` all work to create their associated rvalue.\n //!  - [`Discriminant`] and [`Len`] have associated functions.\n //!  - Unary and binary operations use their normal Rust syntax - `a * b`, `!c`, etc.\n+//!  - The binary operation `Offset` can be created via [`Offset`].\n //!  - Checked binary operations are represented by wrapping the associated binop in [`Checked`].\n //!  - Array repetition syntax (`[foo; 10]`) creates the associated rvalue.\n //!\n@@ -289,6 +290,7 @@ define!(\n     fn Discriminant<T>(place: T) -> <T as ::core::marker::DiscriminantKind>::Discriminant\n );\n define!(\"mir_set_discriminant\", fn SetDiscriminant<T>(place: T, index: u32));\n+define!(\"mir_offset\", fn Offset<T, U>(ptr: T, count: U) -> T);\n define!(\n     \"mir_field\",\n     /// Access the field with the given index of some place."}, {"sha": "7c93c93b4a0199de1473dc2ab6a7196e70fa0a60", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -712,8 +712,8 @@ macro_rules! unimplemented {\n \n /// Indicates unfinished code.\n ///\n-/// This can be useful if you are prototyping and are just looking to have your\n-/// code typecheck.\n+/// This can be useful if you are prototyping and just\n+/// want a placeholder to let your code pass type analysis.\n ///\n /// The difference between [`unimplemented!`] and `todo!` is that while `todo!` conveys\n /// an intent of implementing the functionality later and the message is \"not yet"}, {"sha": "3cd4f5104ce71ce5bdbdfedbe2b158d4410b2bbf", "filename": "library/core/src/marker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmarker.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -823,7 +823,7 @@ unsafe impl<T: ?Sized> Freeze for &mut T {}\n /// [`pin` module]: crate::pin\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n #[rustc_on_unimplemented(\n-    note = \"consider using `Box::pin`\",\n+    note = \"consider using the `pin!` macro\\nconsider using `Box::pin` if you need to access the pinned value outside of the current scope\",\n     message = \"`{Self}` cannot be unpinned\"\n )]\n #[lang = \"unpin\"]"}, {"sha": "b53a330fa560b4e77f3fe32212cbb3768a87c5a6", "filename": "library/core/src/mem/transmutability.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Fsrc%2Fmem%2Ftransmutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Fsrc%2Fmem%2Ftransmutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Ftransmutability.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -5,10 +5,6 @@\n /// notwithstanding whatever safety checks you have asked the compiler to [`Assume`] are satisfied.\n #[unstable(feature = \"transmutability\", issue = \"99571\")]\n #[lang = \"transmute_trait\"]\n-#[rustc_on_unimplemented(\n-    message = \"`{Src}` cannot be safely transmuted into `{Self}` in the defining scope of `{Context}`.\",\n-    label = \"`{Src}` cannot be safely transmuted into `{Self}` in the defining scope of `{Context}`.\"\n-)]\n pub unsafe trait BikeshedIntrinsicFrom<Src, Context, const ASSUME: Assume = { Assume::NOTHING }>\n where\n     Src: ?Sized,"}, {"sha": "11a626485191ca4198db9761a9603f0375e654fc", "filename": "library/core/src/num/dec2flt/common.rs", "status": "modified", "additions": 30, "deletions": 148, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fcommon.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1,165 +1,60 @@\n //! Common utilities, for internal use only.\n \n-use crate::ptr;\n-\n /// Helper methods to process immutable bytes.\n-pub(crate) trait ByteSlice: AsRef<[u8]> {\n-    unsafe fn first_unchecked(&self) -> u8 {\n-        debug_assert!(!self.is_empty());\n-        // SAFETY: safe as long as self is not empty\n-        unsafe { *self.as_ref().get_unchecked(0) }\n-    }\n-\n-    /// Get if the slice contains no elements.\n-    fn is_empty(&self) -> bool {\n-        self.as_ref().is_empty()\n-    }\n-\n-    /// Check if the slice at least `n` length.\n-    fn check_len(&self, n: usize) -> bool {\n-        n <= self.as_ref().len()\n-    }\n-\n-    /// Check if the first character in the slice is equal to c.\n-    fn first_is(&self, c: u8) -> bool {\n-        self.as_ref().first() == Some(&c)\n-    }\n-\n-    /// Check if the first character in the slice is equal to c1 or c2.\n-    fn first_is2(&self, c1: u8, c2: u8) -> bool {\n-        if let Some(&c) = self.as_ref().first() { c == c1 || c == c2 } else { false }\n-    }\n-\n-    /// Bounds-checked test if the first character in the slice is a digit.\n-    fn first_isdigit(&self) -> bool {\n-        if let Some(&c) = self.as_ref().first() { c.is_ascii_digit() } else { false }\n-    }\n-\n-    /// Check if self starts with u with a case-insensitive comparison.\n-    fn starts_with_ignore_case(&self, u: &[u8]) -> bool {\n-        debug_assert!(self.as_ref().len() >= u.len());\n-        let iter = self.as_ref().iter().zip(u.iter());\n-        let d = iter.fold(0, |i, (&x, &y)| i | (x ^ y));\n-        d == 0 || d == 32\n-    }\n-\n-    /// Get the remaining slice after the first N elements.\n-    fn advance(&self, n: usize) -> &[u8] {\n-        &self.as_ref()[n..]\n-    }\n-\n-    /// Get the slice after skipping all leading characters equal c.\n-    fn skip_chars(&self, c: u8) -> &[u8] {\n-        let mut s = self.as_ref();\n-        while s.first_is(c) {\n-            s = s.advance(1);\n-        }\n-        s\n-    }\n-\n-    /// Get the slice after skipping all leading characters equal c1 or c2.\n-    fn skip_chars2(&self, c1: u8, c2: u8) -> &[u8] {\n-        let mut s = self.as_ref();\n-        while s.first_is2(c1, c2) {\n-            s = s.advance(1);\n-        }\n-        s\n-    }\n-\n+pub(crate) trait ByteSlice {\n     /// Read 8 bytes as a 64-bit integer in little-endian order.\n-    unsafe fn read_u64_unchecked(&self) -> u64 {\n-        debug_assert!(self.check_len(8));\n-        let src = self.as_ref().as_ptr() as *const u64;\n-        // SAFETY: safe as long as self is at least 8 bytes\n-        u64::from_le(unsafe { ptr::read_unaligned(src) })\n-    }\n+    fn read_u64(&self) -> u64;\n \n-    /// Try to read the next 8 bytes from the slice.\n-    fn read_u64(&self) -> Option<u64> {\n-        if self.check_len(8) {\n-            // SAFETY: self must be at least 8 bytes.\n-            Some(unsafe { self.read_u64_unchecked() })\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Calculate the offset of slice from another.\n-    fn offset_from(&self, other: &Self) -> isize {\n-        other.as_ref().len() as isize - self.as_ref().len() as isize\n-    }\n-}\n-\n-impl ByteSlice for [u8] {}\n-\n-/// Helper methods to process mutable bytes.\n-pub(crate) trait ByteSliceMut: AsMut<[u8]> {\n     /// Write a 64-bit integer as 8 bytes in little-endian order.\n-    unsafe fn write_u64_unchecked(&mut self, value: u64) {\n-        debug_assert!(self.as_mut().len() >= 8);\n-        let dst = self.as_mut().as_mut_ptr() as *mut u64;\n-        // NOTE: we must use `write_unaligned`, since dst is not\n-        // guaranteed to be properly aligned. Miri will warn us\n-        // if we use `write` instead of `write_unaligned`, as expected.\n-        // SAFETY: safe as long as self is at least 8 bytes\n-        unsafe {\n-            ptr::write_unaligned(dst, u64::to_le(value));\n-        }\n-    }\n-}\n+    fn write_u64(&mut self, value: u64);\n \n-impl ByteSliceMut for [u8] {}\n+    /// Calculate the offset of a slice from another.\n+    fn offset_from(&self, other: &Self) -> isize;\n \n-/// Bytes wrapper with specialized methods for ASCII characters.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub(crate) struct AsciiStr<'a> {\n-    slc: &'a [u8],\n+    /// Iteratively parse and consume digits from bytes.\n+    /// Returns the same bytes with consumed digits being\n+    /// elided.\n+    fn parse_digits(&self, func: impl FnMut(u8)) -> &Self;\n }\n \n-impl<'a> AsciiStr<'a> {\n-    pub fn new(slc: &'a [u8]) -> Self {\n-        Self { slc }\n+impl ByteSlice for [u8] {\n+    #[inline(always)] // inlining this is crucial to remove bound checks\n+    fn read_u64(&self) -> u64 {\n+        let mut tmp = [0; 8];\n+        tmp.copy_from_slice(&self[..8]);\n+        u64::from_le_bytes(tmp)\n     }\n \n-    /// Advance the view by n, advancing it in-place to (n..).\n-    pub unsafe fn step_by(&mut self, n: usize) -> &mut Self {\n-        // SAFETY: safe as long n is less than the buffer length\n-        self.slc = unsafe { self.slc.get_unchecked(n..) };\n-        self\n+    #[inline(always)] // inlining this is crucial to remove bound checks\n+    fn write_u64(&mut self, value: u64) {\n+        self[..8].copy_from_slice(&value.to_le_bytes())\n     }\n \n-    /// Advance the view by n, advancing it in-place to (1..).\n-    pub unsafe fn step(&mut self) -> &mut Self {\n-        // SAFETY: safe as long as self is not empty\n-        unsafe { self.step_by(1) }\n+    #[inline]\n+    fn offset_from(&self, other: &Self) -> isize {\n+        other.len() as isize - self.len() as isize\n     }\n \n-    /// Iteratively parse and consume digits from bytes.\n-    pub fn parse_digits(&mut self, mut func: impl FnMut(u8)) {\n-        while let Some(&c) = self.as_ref().first() {\n+    #[inline]\n+    fn parse_digits(&self, mut func: impl FnMut(u8)) -> &Self {\n+        let mut s = self;\n+\n+        // FIXME: Can't use s.split_first() here yet,\n+        // see https://github.com/rust-lang/rust/issues/109328\n+        while let [c, s_next @ ..] = s {\n             let c = c.wrapping_sub(b'0');\n             if c < 10 {\n                 func(c);\n-                // SAFETY: self cannot be empty\n-                unsafe {\n-                    self.step();\n-                }\n+                s = s_next;\n             } else {\n                 break;\n             }\n         }\n-    }\n-}\n \n-impl<'a> AsRef<[u8]> for AsciiStr<'a> {\n-    #[inline]\n-    fn as_ref(&self) -> &[u8] {\n-        self.slc\n+        s\n     }\n }\n \n-impl<'a> ByteSlice for AsciiStr<'a> {}\n-\n /// Determine if 8 bytes are all decimal digits.\n /// This does not care about the order in which the bytes were loaded.\n pub(crate) fn is_8digits(v: u64) -> bool {\n@@ -168,19 +63,6 @@ pub(crate) fn is_8digits(v: u64) -> bool {\n     (a | b) & 0x8080_8080_8080_8080 == 0\n }\n \n-/// Iteratively parse and consume digits from bytes.\n-pub(crate) fn parse_digits(s: &mut &[u8], mut f: impl FnMut(u8)) {\n-    while let Some(&c) = s.get(0) {\n-        let c = c.wrapping_sub(b'0');\n-        if c < 10 {\n-            f(c);\n-            *s = s.advance(1);\n-        } else {\n-            break;\n-        }\n-    }\n-}\n-\n /// A custom 64-bit floating point type, representing `f * 2^e`.\n /// e is biased, so it be directly shifted into the exponent bits.\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Default)]"}, {"sha": "350f64bb4f7a3fb06912459f3d15b4a6e475acfa", "filename": "library/core/src/num/dec2flt/decimal.rs", "status": "modified", "additions": 36, "deletions": 29, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fdecimal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fdecimal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fdecimal.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -9,7 +9,7 @@\n //! algorithm can be found in \"ParseNumberF64 by Simple Decimal Conversion\",\n //! available online: <https://nigeltao.github.io/blog/2020/parse-number-f64-simple.html>.\n \n-use crate::num::dec2flt::common::{is_8digits, parse_digits, ByteSlice, ByteSliceMut};\n+use crate::num::dec2flt::common::{is_8digits, ByteSlice};\n \n #[derive(Clone)]\n pub struct Decimal {\n@@ -205,29 +205,32 @@ impl Decimal {\n pub fn parse_decimal(mut s: &[u8]) -> Decimal {\n     let mut d = Decimal::default();\n     let start = s;\n-    s = s.skip_chars(b'0');\n-    parse_digits(&mut s, |digit| d.try_add_digit(digit));\n-    if s.first_is(b'.') {\n-        s = s.advance(1);\n+\n+    while let Some((&b'0', s_next)) = s.split_first() {\n+        s = s_next;\n+    }\n+\n+    s = s.parse_digits(|digit| d.try_add_digit(digit));\n+\n+    if let Some((b'.', s_next)) = s.split_first() {\n+        s = s_next;\n         let first = s;\n         // Skip leading zeros.\n         if d.num_digits == 0 {\n-            s = s.skip_chars(b'0');\n+            while let Some((&b'0', s_next)) = s.split_first() {\n+                s = s_next;\n+            }\n         }\n         while s.len() >= 8 && d.num_digits + 8 < Decimal::MAX_DIGITS {\n-            // SAFETY: s is at least 8 bytes.\n-            let v = unsafe { s.read_u64_unchecked() };\n+            let v = s.read_u64();\n             if !is_8digits(v) {\n                 break;\n             }\n-            // SAFETY: d.num_digits + 8 is less than d.digits.len()\n-            unsafe {\n-                d.digits[d.num_digits..].write_u64_unchecked(v - 0x3030_3030_3030_3030);\n-            }\n+            d.digits[d.num_digits..].write_u64(v - 0x3030_3030_3030_3030);\n             d.num_digits += 8;\n-            s = s.advance(8);\n+            s = &s[8..];\n         }\n-        parse_digits(&mut s, |digit| d.try_add_digit(digit));\n+        s = s.parse_digits(|digit| d.try_add_digit(digit));\n         d.decimal_point = s.len() as i32 - first.len() as i32;\n     }\n     if d.num_digits != 0 {\n@@ -248,22 +251,26 @@ pub fn parse_decimal(mut s: &[u8]) -> Decimal {\n             d.num_digits = Decimal::MAX_DIGITS;\n         }\n     }\n-    if s.first_is2(b'e', b'E') {\n-        s = s.advance(1);\n-        let mut neg_exp = false;\n-        if s.first_is(b'-') {\n-            neg_exp = true;\n-            s = s.advance(1);\n-        } else if s.first_is(b'+') {\n-            s = s.advance(1);\n-        }\n-        let mut exp_num = 0_i32;\n-        parse_digits(&mut s, |digit| {\n-            if exp_num < 0x10000 {\n-                exp_num = 10 * exp_num + digit as i32;\n+    if let Some((&ch, s_next)) = s.split_first() {\n+        if ch == b'e' || ch == b'E' {\n+            s = s_next;\n+            let mut neg_exp = false;\n+            if let Some((&ch, s_next)) = s.split_first() {\n+                neg_exp = ch == b'-';\n+                if ch == b'-' || ch == b'+' {\n+                    s = s_next;\n+                }\n             }\n-        });\n-        d.decimal_point += if neg_exp { -exp_num } else { exp_num };\n+            let mut exp_num = 0_i32;\n+\n+            s.parse_digits(|digit| {\n+                if exp_num < 0x10000 {\n+                    exp_num = 10 * exp_num + digit as i32;\n+                }\n+            });\n+\n+            d.decimal_point += if neg_exp { -exp_num } else { exp_num };\n+        }\n     }\n     for i in d.num_digits..Decimal::MAX_DIGITS_WITHOUT_OVERFLOW {\n         d.digits[i] = 0;"}, {"sha": "a4bc8b1c9b0c31bbdd89164adda26c649ab93281", "filename": "library/core/src/num/dec2flt/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -79,7 +79,7 @@ use crate::error::Error;\n use crate::fmt;\n use crate::str::FromStr;\n \n-use self::common::{BiasedFp, ByteSlice};\n+use self::common::BiasedFp;\n use self::float::RawFloat;\n use self::lemire::compute_float;\n use self::parse::{parse_inf_nan, parse_number};\n@@ -238,17 +238,18 @@ pub fn dec2flt<F: RawFloat>(s: &str) -> Result<F, ParseFloatError> {\n     };\n     let negative = c == b'-';\n     if c == b'-' || c == b'+' {\n-        s = s.advance(1);\n+        s = &s[1..];\n     }\n     if s.is_empty() {\n         return Err(pfe_invalid());\n     }\n \n-    let num = match parse_number(s, negative) {\n+    let mut num = match parse_number(s) {\n         Some(r) => r,\n         None if let Some(value) = parse_inf_nan(s, negative) => return Ok(value),\n         None => return Err(pfe_invalid()),\n     };\n+    num.negative = negative;\n     if let Some(value) = num.try_fast_path::<F>() {\n         return Ok(value);\n     }"}, {"sha": "b0a23835c5bd47258ba3bc46ca6cc0d355e953bd", "filename": "library/core/src/num/dec2flt/parse.rs", "status": "modified", "additions": 117, "deletions": 107, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fparse.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1,6 +1,6 @@\n //! Functions to parse floating-point numbers.\n \n-use crate::num::dec2flt::common::{is_8digits, AsciiStr, ByteSlice};\n+use crate::num::dec2flt::common::{is_8digits, ByteSlice};\n use crate::num::dec2flt::float::RawFloat;\n use crate::num::dec2flt::number::Number;\n \n@@ -26,78 +26,74 @@ fn parse_8digits(mut v: u64) -> u64 {\n }\n \n /// Parse digits until a non-digit character is found.\n-fn try_parse_digits(s: &mut AsciiStr<'_>, x: &mut u64) {\n+fn try_parse_digits(mut s: &[u8], mut x: u64) -> (&[u8], u64) {\n     // may cause overflows, to be handled later\n-    s.parse_digits(|digit| {\n-        *x = x.wrapping_mul(10).wrapping_add(digit as _);\n+\n+    while s.len() >= 8 {\n+        let num = s.read_u64();\n+        if is_8digits(num) {\n+            x = x.wrapping_mul(1_0000_0000).wrapping_add(parse_8digits(num));\n+            s = &s[8..];\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    s = s.parse_digits(|digit| {\n+        x = x.wrapping_mul(10).wrapping_add(digit as _);\n     });\n+\n+    (s, x)\n }\n \n /// Parse up to 19 digits (the max that can be stored in a 64-bit integer).\n-fn try_parse_19digits(s: &mut AsciiStr<'_>, x: &mut u64) {\n+fn try_parse_19digits(s_ref: &mut &[u8], x: &mut u64) {\n+    let mut s = *s_ref;\n+\n     while *x < MIN_19DIGIT_INT {\n-        if let Some(&c) = s.as_ref().first() {\n+        // FIXME: Can't use s.split_first() here yet,\n+        // see https://github.com/rust-lang/rust/issues/109328\n+        if let [c, s_next @ ..] = s {\n             let digit = c.wrapping_sub(b'0');\n+\n             if digit < 10 {\n                 *x = (*x * 10) + digit as u64; // no overflows here\n-                // SAFETY: cannot be empty\n-                unsafe {\n-                    s.step();\n-                }\n+                s = s_next;\n             } else {\n                 break;\n             }\n         } else {\n             break;\n         }\n     }\n-}\n \n-/// Try to parse 8 digits at a time, using an optimized algorithm.\n-fn try_parse_8digits(s: &mut AsciiStr<'_>, x: &mut u64) {\n-    // may cause overflows, to be handled later\n-    if let Some(v) = s.read_u64() {\n-        if is_8digits(v) {\n-            *x = x.wrapping_mul(1_0000_0000).wrapping_add(parse_8digits(v));\n-            // SAFETY: already ensured the buffer was >= 8 bytes in read_u64.\n-            unsafe {\n-                s.step_by(8);\n-            }\n-            if let Some(v) = s.read_u64() {\n-                if is_8digits(v) {\n-                    *x = x.wrapping_mul(1_0000_0000).wrapping_add(parse_8digits(v));\n-                    // SAFETY: already ensured the buffer was >= 8 bytes in try_read_u64.\n-                    unsafe {\n-                        s.step_by(8);\n-                    }\n-                }\n-            }\n-        }\n-    }\n+    *s_ref = s;\n }\n \n /// Parse the scientific notation component of a float.\n-fn parse_scientific(s: &mut AsciiStr<'_>) -> Option<i64> {\n-    let mut exponent = 0_i64;\n+fn parse_scientific(s_ref: &mut &[u8]) -> Option<i64> {\n+    let mut exponent = 0i64;\n     let mut negative = false;\n-    if let Some(&c) = s.as_ref().get(0) {\n+\n+    let mut s = *s_ref;\n+\n+    if let Some((&c, s_next)) = s.split_first() {\n         negative = c == b'-';\n         if c == b'-' || c == b'+' {\n-            // SAFETY: s cannot be empty\n-            unsafe {\n-                s.step();\n-            }\n+            s = s_next;\n         }\n     }\n-    if s.first_isdigit() {\n-        s.parse_digits(|digit| {\n+\n+    if matches!(s.first(), Some(&x) if x.is_ascii_digit()) {\n+        *s_ref = s.parse_digits(|digit| {\n             // no overflows here, saturate well before overflow\n             if exponent < 0x10000 {\n                 exponent = 10 * exponent + digit as i64;\n             }\n         });\n         if negative { Some(-exponent) } else { Some(exponent) }\n     } else {\n+        *s_ref = s;\n         None\n     }\n }\n@@ -106,28 +102,29 @@ fn parse_scientific(s: &mut AsciiStr<'_>) -> Option<i64> {\n ///\n /// This creates a representation of the float as the\n /// significant digits and the decimal exponent.\n-fn parse_partial_number(s: &[u8], negative: bool) -> Option<(Number, usize)> {\n-    let mut s = AsciiStr::new(s);\n-    let start = s;\n+fn parse_partial_number(mut s: &[u8]) -> Option<(Number, usize)> {\n     debug_assert!(!s.is_empty());\n \n     // parse initial digits before dot\n     let mut mantissa = 0_u64;\n-    let digits_start = s;\n-    try_parse_digits(&mut s, &mut mantissa);\n-    let mut n_digits = s.offset_from(&digits_start);\n+    let start = s;\n+    let tmp = try_parse_digits(s, mantissa);\n+    s = tmp.0;\n+    mantissa = tmp.1;\n+    let mut n_digits = s.offset_from(start);\n \n     // handle dot with the following digits\n     let mut n_after_dot = 0;\n     let mut exponent = 0_i64;\n     let int_end = s;\n-    if s.first_is(b'.') {\n-        // SAFETY: s cannot be empty due to first_is\n-        unsafe { s.step() };\n+\n+    if let Some((&b'.', s_next)) = s.split_first() {\n+        s = s_next;\n         let before = s;\n-        try_parse_8digits(&mut s, &mut mantissa);\n-        try_parse_digits(&mut s, &mut mantissa);\n-        n_after_dot = s.offset_from(&before);\n+        let tmp = try_parse_digits(s, mantissa);\n+        s = tmp.0;\n+        mantissa = tmp.1;\n+        n_after_dot = s.offset_from(before);\n         exponent = -n_after_dot as i64;\n     }\n \n@@ -138,96 +135,109 @@ fn parse_partial_number(s: &[u8], negative: bool) -> Option<(Number, usize)> {\n \n     // handle scientific format\n     let mut exp_number = 0_i64;\n-    if s.first_is2(b'e', b'E') {\n-        // SAFETY: s cannot be empty\n-        unsafe {\n-            s.step();\n+    if let Some((&c, s_next)) = s.split_first() {\n+        if c == b'e' || c == b'E' {\n+            s = s_next;\n+            // If None, we have no trailing digits after exponent, or an invalid float.\n+            exp_number = parse_scientific(&mut s)?;\n+            exponent += exp_number;\n         }\n-        // If None, we have no trailing digits after exponent, or an invalid float.\n-        exp_number = parse_scientific(&mut s)?;\n-        exponent += exp_number;\n     }\n \n-    let len = s.offset_from(&start) as _;\n+    let len = s.offset_from(start) as _;\n \n     // handle uncommon case with many digits\n     if n_digits <= 19 {\n-        return Some((Number { exponent, mantissa, negative, many_digits: false }, len));\n+        return Some((Number { exponent, mantissa, negative: false, many_digits: false }, len));\n     }\n \n     n_digits -= 19;\n     let mut many_digits = false;\n-    let mut p = digits_start;\n-    while p.first_is2(b'0', b'.') {\n-        // SAFETY: p cannot be empty due to first_is2\n-        unsafe {\n-            // '0' = b'.' + 2\n-            n_digits -= p.first_unchecked().saturating_sub(b'0' - 1) as isize;\n-            p.step();\n+    let mut p = start;\n+    while let Some((&c, p_next)) = p.split_first() {\n+        if c == b'.' || c == b'0' {\n+            n_digits -= c.saturating_sub(b'0' - 1) as isize;\n+            p = p_next;\n+        } else {\n+            break;\n         }\n     }\n     if n_digits > 0 {\n         // at this point we have more than 19 significant digits, let's try again\n         many_digits = true;\n         mantissa = 0;\n-        let mut s = digits_start;\n+        let mut s = start;\n         try_parse_19digits(&mut s, &mut mantissa);\n         exponent = if mantissa >= MIN_19DIGIT_INT {\n             // big int\n-            int_end.offset_from(&s)\n+            int_end.offset_from(s)\n         } else {\n-            // SAFETY: the next byte must be present and be '.'\n-            // We know this is true because we had more than 19\n-            // digits previously, so we overflowed a 64-bit integer,\n-            // but parsing only the integral digits produced less\n-            // than 19 digits. That means we must have a decimal\n-            // point, and at least 1 fractional digit.\n-            unsafe { s.step() };\n+            s = &s[1..];\n             let before = s;\n             try_parse_19digits(&mut s, &mut mantissa);\n-            -s.offset_from(&before)\n+            -s.offset_from(before)\n         } as i64;\n         // add back the explicit part\n         exponent += exp_number;\n     }\n \n-    Some((Number { exponent, mantissa, negative, many_digits }, len))\n+    Some((Number { exponent, mantissa, negative: false, many_digits }, len))\n }\n \n-/// Try to parse a non-special floating point number.\n-pub fn parse_number(s: &[u8], negative: bool) -> Option<Number> {\n-    if let Some((float, rest)) = parse_partial_number(s, negative) {\n+/// Try to parse a non-special floating point number,\n+/// as well as two slices with integer and fractional parts\n+/// and the parsed exponent.\n+pub fn parse_number(s: &[u8]) -> Option<Number> {\n+    if let Some((float, rest)) = parse_partial_number(s) {\n         if rest == s.len() {\n             return Some(float);\n         }\n     }\n     None\n }\n \n-/// Parse a partial representation of a special, non-finite float.\n-fn parse_partial_inf_nan<F: RawFloat>(s: &[u8]) -> Option<(F, usize)> {\n-    fn parse_inf_rest(s: &[u8]) -> usize {\n-        if s.len() >= 8 && s[3..].as_ref().starts_with_ignore_case(b\"inity\") { 8 } else { 3 }\n-    }\n-    if s.len() >= 3 {\n-        if s.starts_with_ignore_case(b\"nan\") {\n-            return Some((F::NAN, 3));\n-        } else if s.starts_with_ignore_case(b\"inf\") {\n-            return Some((F::INFINITY, parse_inf_rest(s)));\n-        }\n-    }\n-    None\n-}\n-\n /// Try to parse a special, non-finite float.\n-pub fn parse_inf_nan<F: RawFloat>(s: &[u8], negative: bool) -> Option<F> {\n-    if let Some((mut float, rest)) = parse_partial_inf_nan::<F>(s) {\n-        if rest == s.len() {\n-            if negative {\n-                float = -float;\n-            }\n-            return Some(float);\n-        }\n+pub(crate) fn parse_inf_nan<F: RawFloat>(s: &[u8], negative: bool) -> Option<F> {\n+    // Since a valid string has at most the length 8, we can load\n+    // all relevant characters into a u64 and work from there.\n+    // This also generates much better code.\n+\n+    let mut register;\n+    let len: usize;\n+\n+    // All valid strings are either of length 8 or 3.\n+    if s.len() == 8 {\n+        register = s.read_u64();\n+        len = 8;\n+    } else if s.len() == 3 {\n+        let a = s[0] as u64;\n+        let b = s[1] as u64;\n+        let c = s[2] as u64;\n+        register = (c << 16) | (b << 8) | a;\n+        len = 3;\n+    } else {\n+        return None;\n     }\n-    None\n+\n+    // Clear out the bits which turn ASCII uppercase characters into\n+    // lowercase characters. The resulting string is all uppercase.\n+    // What happens to other characters is irrelevant.\n+    register &= 0xDFDFDFDFDFDFDFDF;\n+\n+    // u64 values corresponding to relevant cases\n+    const INF_3: u64 = 0x464E49; // \"INF\"\n+    const INF_8: u64 = 0x5954494E49464E49; // \"INFINITY\"\n+    const NAN: u64 = 0x4E414E; // \"NAN\"\n+\n+    // Match register value to constant to parse string.\n+    // Also match on the string length to catch edge cases\n+    // like \"inf\\0\\0\\0\\0\\0\".\n+    let float = match (register, len) {\n+        (INF_3, 3) => F::INFINITY,\n+        (INF_8, 8) => F::INFINITY,\n+        (NAN, 3) => F::NAN,\n+        _ => return None,\n+    };\n+\n+    if negative { Some(-float) } else { Some(float) }\n }"}, {"sha": "1c6819b547d27ae80b2e3144072fc1beee80423c", "filename": "library/core/src/num/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1391,7 +1391,7 @@ impl f32 {\n     #[stable(feature = \"clamp\", since = \"1.50.0\")]\n     #[inline]\n     pub fn clamp(mut self, min: f32, max: f32) -> f32 {\n-        assert!(min <= max);\n+        assert!(min <= max, \"min > max, or either was NaN. min = {min:?}, max = {max:?}\");\n         if self < min {\n             self = min;\n         }"}, {"sha": "1e7387217cbd927a9bad1548a6c63f96902c5ab5", "filename": "library/core/src/num/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1389,7 +1389,7 @@ impl f64 {\n     #[stable(feature = \"clamp\", since = \"1.50.0\")]\n     #[inline]\n     pub fn clamp(mut self, min: f64, max: f64) -> f64 {\n-        assert!(min <= max);\n+        assert!(min <= max, \"min > max, or either was NaN. min = {min:?}, max = {max:?}\");\n         if self < min {\n             self = min;\n         }"}, {"sha": "114deeea387677709d8062e382f6d339b2f37850", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1363,12 +1363,11 @@ macro_rules! uint_impl {\n         ///\n         /// Basic usage:\n         ///\n-        /// Please note that this example is shared between integer types.\n-        /// Which explains why `i8` is used here.\n-        ///\n         /// ```\n-        /// assert_eq!(100i8.wrapping_neg(), -100);\n-        /// assert_eq!((-128i8).wrapping_neg(), -128);\n+        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".wrapping_neg(), 0);\")]\n+        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_neg(), 1);\")]\n+        #[doc = concat!(\"assert_eq!(13_\", stringify!($SelfT), \".wrapping_neg(), (!13) + 1);\")]\n+        #[doc = concat!(\"assert_eq!(42_\", stringify!($SelfT), \".wrapping_neg(), !(42 - 1));\")]\n         /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]"}, {"sha": "7e7b6b4dbe9b1f1c7fea6c245adc81e51250c157", "filename": "library/core/src/panic/unwind_safe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Fsrc%2Fpanic%2Funwind_safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Fsrc%2Fpanic%2Funwind_safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanic%2Funwind_safe.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -28,7 +28,7 @@ use crate::task::{Context, Poll};\n /// 2. This broken invariant is then later observed.\n ///\n /// Typically in Rust, it is difficult to perform step (2) because catching a\n-/// panic involves either spawning a thread (which in turns makes it difficult\n+/// panic involves either spawning a thread (which in turn makes it difficult\n /// to later witness broken invariants) or using the `catch_unwind` function in this\n /// module. Additionally, even if an invariant is witnessed, it typically isn't a\n /// problem in Rust because there are no uninitialized values (like in C or C++)."}, {"sha": "818f1a919d0d5f2c3602dd7ccd7217680370a708", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1371,6 +1371,7 @@ pub const unsafe fn write<T>(dst: *mut T, src: T) {\n     // as `intrinsics::copy_nonoverlapping` is a wrapper function.\n     extern \"rust-intrinsic\" {\n         #[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.63.0\")]\n+        #[rustc_nounwind]\n         fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n     }\n "}, {"sha": "874e0ec7093c7542fa0f141c67b2ebe82b03bdf2", "filename": "library/core/tests/num/dec2flt/mod.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -127,14 +127,3 @@ fn massive_exponent() {\n     assert_eq!(format!(\"1e-{max}000\").parse(), Ok(0.0));\n     assert_eq!(format!(\"1e{max}000\").parse(), Ok(f64::INFINITY));\n }\n-\n-#[test]\n-fn borderline_overflow() {\n-    let mut s = \"0.\".to_string();\n-    for _ in 0..375 {\n-        s.push('3');\n-    }\n-    // At the time of this writing, this returns Err(..), but this is a bug that should be fixed.\n-    // It makes no sense to enshrine that in a test, the important part is that it doesn't panic.\n-    let _ = s.parse::<f64>();\n-}"}, {"sha": "4a5d24ba7d5fa5146cd4e21899a2444f03ea7fc3", "filename": "library/core/tests/num/dec2flt/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Ftests%2Fnum%2Fdec2flt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fcore%2Ftests%2Fnum%2Fdec2flt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fdec2flt%2Fparse.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -32,7 +32,7 @@ fn invalid_chars() {\n }\n \n fn parse_positive(s: &[u8]) -> Option<Number> {\n-    parse_number(s, false)\n+    parse_number(s)\n }\n \n #[test]"}, {"sha": "d372fa64065f5b4a62c8434f90cf6f9742a338fe", "filename": "library/std/src/env.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fenv.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -236,21 +236,14 @@ fn _var(key: &OsStr) -> Result<String, VarError> {\n }\n \n /// Fetches the environment variable `key` from the current process, returning\n-/// [`None`] if the variable isn't set or there's another error.\n+/// [`None`] if the variable isn't set or if there is another error.\n ///\n-/// Note that the method will not check if the environment variable\n-/// is valid Unicode. If you want to have an error on invalid UTF-8,\n-/// use the [`var`] function instead.\n-///\n-/// # Errors\n-///\n-/// This function returns an error if the environment variable isn't set.\n-///\n-/// This function may return an error if the environment variable's name contains\n+/// It may return `None` if the environment variable's name contains\n /// the equal sign character (`=`) or the NUL character.\n ///\n-/// This function may return an error if the environment variable's value contains\n-/// the NUL character.\n+/// Note that this function will not check if the environment variable\n+/// is valid Unicode. If you want to have an error on invalid UTF-8,\n+/// use the [`var`] function instead.\n ///\n /// # Examples\n ///\n@@ -895,6 +888,7 @@ pub mod consts {\n     /// - x86_64\n     /// - arm\n     /// - aarch64\n+    /// - loongarch64\n     /// - m68k\n     /// - mips\n     /// - mips64"}, {"sha": "408244b2ce9eb11262d507d450a0b1c1bb9a5159", "filename": "library/std/src/f32.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff32.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -581,8 +581,10 @@ impl f32 {\n         unsafe { cmath::cbrtf(self) }\n     }\n \n-    /// Calculates the length of the hypotenuse of a right-angle triangle given\n-    /// legs of length `x` and `y`.\n+    /// Compute the distance between the origin and a point (`x`, `y`) on the\n+    /// Euclidean plane. Equivalently, compute the length of the hypotenuse of a\n+    /// right-angle triangle with other sides having length `x.abs()` and\n+    /// `y.abs()`.\n     ///\n     /// # Examples\n     ///"}, {"sha": "6782b861f110b45b62e537334b66df61f7fdd056", "filename": "library/std/src/f64.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff64.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -583,8 +583,10 @@ impl f64 {\n         unsafe { cmath::cbrt(self) }\n     }\n \n-    /// Calculates the length of the hypotenuse of a right-angle triangle given\n-    /// legs of length `x` and `y`.\n+    /// Compute the distance between the origin and a point (`x`, `y`) on the\n+    /// Euclidean plane. Equivalently, compute the length of the hypotenuse of a\n+    /// right-angle triangle with other sides having length `x.abs()` and\n+    /// `y.abs()`.\n     ///\n     /// # Examples\n     ///"}, {"sha": "020c723925aebc412dc79328350ca7c2d8244fcc", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -268,7 +268,7 @@ pub(crate) use self::stdio::attempt_print_to_stderr;\n #[unstable(feature = \"internal_output_capture\", issue = \"none\")]\n #[doc(no_inline, hidden)]\n pub use self::stdio::set_output_capture;\n-#[unstable(feature = \"is_terminal\", issue = \"98070\")]\n+#[stable(feature = \"is_terminal\", since = \"CURRENT_RUSTC_VERSION\")]\n pub use self::stdio::IsTerminal;\n #[unstable(feature = \"print_internals\", issue = \"none\")]\n pub use self::stdio::{_eprint, _print};"}, {"sha": "b2c57b8ddc78e6bdda75a95a16d1488ef5318bd9", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1047,7 +1047,7 @@ pub(crate) fn attempt_print_to_stderr(args: fmt::Arguments<'_>) {\n }\n \n /// Trait to determine if a descriptor/handle refers to a terminal/tty.\n-#[unstable(feature = \"is_terminal\", issue = \"98070\")]\n+#[stable(feature = \"is_terminal\", since = \"CURRENT_RUSTC_VERSION\")]\n pub trait IsTerminal: crate::sealed::Sealed {\n     /// Returns `true` if the descriptor/handle refers to a terminal/tty.\n     ///\n@@ -1063,6 +1063,7 @@ pub trait IsTerminal: crate::sealed::Sealed {\n     /// Note that this [may change in the future][changes].\n     ///\n     /// [changes]: io#platform-specific-behavior\n+    #[stable(feature = \"is_terminal\", since = \"CURRENT_RUSTC_VERSION\")]\n     fn is_terminal(&self) -> bool;\n }\n \n@@ -1071,7 +1072,7 @@ macro_rules! impl_is_terminal {\n         #[unstable(feature = \"sealed\", issue = \"none\")]\n         impl crate::sealed::Sealed for $t {}\n \n-        #[unstable(feature = \"is_terminal\", issue = \"98070\")]\n+        #[stable(feature = \"is_terminal\", since = \"CURRENT_RUSTC_VERSION\")]\n         impl IsTerminal for $t {\n             #[inline]\n             fn is_terminal(&self) -> bool {"}, {"sha": "71f3576c93d4b440ec4b0f4100f49000b7862168", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -254,7 +254,6 @@\n #![feature(exhaustive_patterns)]\n #![feature(if_let_guard)]\n #![feature(intra_doc_pointers)]\n-#![feature(is_terminal)]\n #![feature(lang_items)]\n #![feature(let_chains)]\n #![feature(linkage)]"}, {"sha": "6a6e6f33158fc5c654ca4d250958a5a3c22cf64e", "filename": "library/std/src/os/fd/owned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -201,7 +201,7 @@ macro_rules! impl_is_terminal {\n         #[unstable(feature = \"sealed\", issue = \"none\")]\n         impl crate::sealed::Sealed for $t {}\n \n-        #[unstable(feature = \"is_terminal\", issue = \"98070\")]\n+        #[stable(feature = \"is_terminal\", since = \"CURRENT_RUSTC_VERSION\")]\n         impl crate::io::IsTerminal for $t {\n             #[inline]\n             fn is_terminal(&self) -> bool {"}, {"sha": "c55ca8ba26e2f21fe0709c6e9b2b2e4168e5b3fe", "filename": "library/std/src/os/linux/raw.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fraw.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -231,6 +231,7 @@ mod arch {\n }\n \n #[cfg(any(\n+    target_arch = \"loongarch64\",\n     target_arch = \"mips64\",\n     target_arch = \"s390x\",\n     target_arch = \"sparc64\","}, {"sha": "f6622874625fcfc8e15b3a5c2a6dd6d387104190", "filename": "library/std/src/os/windows/io/handle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -389,7 +389,7 @@ macro_rules! impl_is_terminal {\n         #[unstable(feature = \"sealed\", issue = \"none\")]\n         impl crate::sealed::Sealed for $t {}\n \n-        #[unstable(feature = \"is_terminal\", issue = \"98070\")]\n+        #[stable(feature = \"is_terminal\", since = \"CURRENT_RUSTC_VERSION\")]\n         impl crate::io::IsTerminal for $t {\n             #[inline]\n             fn is_terminal(&self) -> bool {"}, {"sha": "a46a29cbad6081400329485378ea87808bbc2512", "filename": "library/std/src/panicking.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanicking.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -498,6 +498,7 @@ pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>>\n     // This function cannot be marked as `unsafe` because `intrinsics::r#try`\n     // expects normal function pointers.\n     #[inline]\n+    #[rustc_nounwind] // `intrinsic::r#try` requires catch fn to be nounwind\n     fn do_catch<F: FnOnce() -> R, R>(data: *mut u8, payload: *mut u8) {\n         // SAFETY: this is the responsibility of the caller, see above.\n         //"}, {"sha": "0421b47be024e39b35eeace7aad34d30064d695c", "filename": "library/std/src/personality/gcc.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Fpersonality%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Fpersonality%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpersonality%2Fgcc.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -77,6 +77,9 @@ const UNWIND_DATA_REG: (i32, i32) = (0, 1); // R0, R1\n #[cfg(any(target_arch = \"riscv64\", target_arch = \"riscv32\"))]\n const UNWIND_DATA_REG: (i32, i32) = (10, 11); // x10, x11\n \n+#[cfg(target_arch = \"loongarch64\")]\n+const UNWIND_DATA_REG: (i32, i32) = (4, 5); // a0, a1\n+\n // The following code is based on GCC's C and C++ personality routines.  For reference, see:\n // https://github.com/gcc-mirror/gcc/blob/master/libstdc++-v3/libsupc++/eh_personality.cc\n // https://github.com/gcc-mirror/gcc/blob/trunk/libgcc/unwind-c.c"}, {"sha": "406a331a309614c35cde21ec6384bb0c0d1fda38", "filename": "library/std/src/sync/mpmc/list.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Flist.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -549,6 +549,18 @@ impl<T> Channel<T> {\n         let mut head = self.head.index.load(Ordering::Acquire);\n         let mut block = self.head.block.load(Ordering::Acquire);\n \n+        // If we're going to be dropping messages we need to synchronize with initialization\n+        if head >> SHIFT != tail >> SHIFT {\n+            // The block can be null here only if a sender is in the process of initializing the\n+            // channel while another sender managed to send a message by inserting it into the\n+            // semi-initialized channel and advanced the tail.\n+            // In that case, just wait until it gets initialized.\n+            while block.is_null() {\n+                backoff.spin_heavy();\n+                block = self.head.block.load(Ordering::Acquire);\n+            }\n+        }\n+\n         unsafe {\n             // Drop all messages between head and tail and deallocate the heap-allocated blocks.\n             while head >> SHIFT != tail >> SHIFT {"}, {"sha": "a5fcbdf39c6c685805841a93e9dbe862ed0e707f", "filename": "library/std/src/sys/common/alloc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Falloc.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -22,6 +22,7 @@ pub const MIN_ALIGN: usize = 8;\n #[cfg(any(\n     target_arch = \"x86_64\",\n     target_arch = \"aarch64\",\n+    target_arch = \"loongarch64\",\n     target_arch = \"mips64\",\n     target_arch = \"s390x\",\n     target_arch = \"sparc64\","}, {"sha": "7d7bfae14329a601d700810511dd635f8e11ebc4", "filename": "library/std/src/sys/solid/net.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fnet.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -2,7 +2,7 @@ use super::abi;\n use crate::{\n     cmp,\n     ffi::CStr,\n-    io::{self, ErrorKind, IoSlice, IoSliceMut},\n+    io::{self, BorrowedBuf, BorrowedCursor, ErrorKind, IoSlice, IoSliceMut},\n     mem,\n     net::{Shutdown, SocketAddr},\n     ptr, str,\n@@ -294,19 +294,30 @@ impl Socket {\n         self.0.duplicate().map(Socket)\n     }\n \n-    fn recv_with_flags(&self, buf: &mut [u8], flags: c_int) -> io::Result<usize> {\n+    fn recv_with_flags(&self, mut buf: BorrowedCursor<'_>, flags: c_int) -> io::Result<()> {\n         let ret = cvt(unsafe {\n-            netc::recv(self.0.raw(), buf.as_mut_ptr() as *mut c_void, buf.len(), flags)\n+            netc::recv(self.0.raw(), buf.as_mut().as_mut_ptr().cast(), buf.capacity(), flags)\n         })?;\n-        Ok(ret as usize)\n+        unsafe {\n+            buf.advance(ret as usize);\n+        }\n+        Ok(())\n     }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.recv_with_flags(buf, 0)\n+        let mut buf = BorrowedBuf::from(buf);\n+        self.recv_with_flags(buf.unfilled(), 0)?;\n+        Ok(buf.len())\n     }\n \n     pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.recv_with_flags(buf, MSG_PEEK)\n+        let mut buf = BorrowedBuf::from(buf);\n+        self.recv_with_flags(buf.unfilled(), MSG_PEEK)?;\n+        Ok(buf.len())\n+    }\n+\n+    pub fn read_buf(&self, buf: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.recv_with_flags(buf, 0)\n     }\n \n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {"}, {"sha": "21ec1b5133df3a48f64af03c508daf25f0090db1", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -34,7 +34,7 @@ use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n     target_os = \"watchos\",\n ))]\n use crate::sys::weak::syscall;\n-#[cfg(any(target_os = \"android\", target_os = \"macos\"))]\n+#[cfg(any(target_os = \"android\", target_os = \"macos\", target_os = \"solaris\"))]\n use crate::sys::weak::weak;\n \n use libc::{c_int, mode_t};\n@@ -43,6 +43,7 @@ use libc::{c_int, mode_t};\n     target_os = \"macos\",\n     target_os = \"ios\",\n     target_os = \"watchos\",\n+    target_os = \"solaris\",\n     all(target_os = \"linux\", target_env = \"gnu\")\n ))]\n use libc::c_char;\n@@ -1497,8 +1498,8 @@ pub fn link(original: &Path, link: &Path) -> io::Result<()> {\n                     // Android has `linkat` on newer versions, but we happen to know `link`\n                     // always has the correct behavior, so it's here as well.\n                     cvt(unsafe { libc::link(original.as_ptr(), link.as_ptr()) })?;\n-                } else if #[cfg(target_os = \"macos\")] {\n-                    // On MacOS, older versions (<=10.9) lack support for linkat while newer\n+                } else if #[cfg(any(target_os = \"macos\", target_os = \"solaris\"))] {\n+                    // MacOS (<=10.9) and Solaris 10 lack support for linkat while newer\n                     // versions have it. We want to use linkat if it is available, so we use weak!\n                     // to check. `linkat` is preferable to `link` because it gives us a flag to\n                     // specify how symlinks should be handled. We pass 0 as the flags argument,"}, {"sha": "16c8e0c0ebfc50f34aa4b1a12e5649b500f1a3d0", "filename": "library/std/src/sys/unix/kernel_copy.rs", "status": "modified", "additions": 46, "deletions": 16, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -17,11 +17,9 @@\n //! Once it has obtained all necessary pieces and brought any wrapper types into a state where they\n //! can be safely bypassed it will attempt to use the `copy_file_range(2)`,\n //! `sendfile(2)` or `splice(2)` syscalls to move data directly between file descriptors.\n-//! Since those syscalls have requirements that cannot be fully checked in advance and\n-//! gathering additional information about file descriptors would require additional syscalls\n-//! anyway it simply attempts to use them one after another (guided by inaccurate hints) to\n-//! figure out which one works and falls back to the generic read-write copy loop if none of them\n-//! does.\n+//! Since those syscalls have requirements that cannot be fully checked in advance it attempts\n+//! to use them one after another (guided by hints) to figure out which one works and\n+//! falls back to the generic read-write copy loop if none of them does.\n //! Once a working syscall is found for a pair of file descriptors it will be called in a loop\n //! until the copy operation is completed.\n //!\n@@ -84,14 +82,10 @@ pub(crate) fn copy_spec<R: Read + ?Sized, W: Write + ?Sized>(\n /// The methods on this type only provide hints, due to `AsRawFd` and `FromRawFd` the inferred\n /// type may be wrong.\n enum FdMeta {\n-    /// We obtained the FD from a type that can contain any type of `FileType` and queried the metadata\n-    /// because it is cheaper than probing all possible syscalls (reader side)\n     Metadata(Metadata),\n     Socket,\n     Pipe,\n-    /// We don't have any metadata, e.g. because the original type was `File` which can represent\n-    /// any `FileType` and we did not query the metadata either since it did not seem beneficial\n-    /// (writer side)\n+    /// We don't have any metadata because the stat syscall failed\n     NoneObtained,\n }\n \n@@ -131,6 +125,39 @@ impl FdMeta {\n     }\n }\n \n+/// Returns true either if changes made to the source after a sendfile/splice call won't become\n+/// visible in the sink or the source has explicitly opted into such behavior (e.g. by splicing\n+/// a file into a pipe, the pipe being the source in this case).\n+///\n+/// This will prevent File -> Pipe and File -> Socket splicing/sendfile optimizations to uphold\n+/// the Read/Write API semantics of io::copy.\n+///\n+/// Note: This is not 100% airtight, the caller can use the RawFd conversion methods to turn a\n+/// regular file into a TcpSocket which will be treated as a socket here without checking.\n+fn safe_kernel_copy(source: &FdMeta, sink: &FdMeta) -> bool {\n+    match (source, sink) {\n+        // Data arriving from a socket is safe because the sender can't modify the socket buffer.\n+        // Data arriving from a pipe is safe(-ish) because either the sender *copied*\n+        // the bytes into the pipe OR explicitly performed an operation that enables zero-copy,\n+        // thus promising not to modify the data later.\n+        (FdMeta::Socket, _) => true,\n+        (FdMeta::Pipe, _) => true,\n+        (FdMeta::Metadata(meta), _)\n+            if meta.file_type().is_fifo() || meta.file_type().is_socket() =>\n+        {\n+            true\n+        }\n+        // Data going into non-pipes/non-sockets is safe because the \"later changes may become visible\" issue\n+        // only happens for pages sitting in send buffers or pipes.\n+        (_, FdMeta::Metadata(meta))\n+            if !meta.file_type().is_fifo() && !meta.file_type().is_socket() =>\n+        {\n+            true\n+        }\n+        _ => false,\n+    }\n+}\n+\n struct CopyParams(FdMeta, Option<RawFd>);\n \n struct Copier<'a, 'b, R: Read + ?Sized, W: Write + ?Sized> {\n@@ -186,7 +213,8 @@ impl<R: CopyRead, W: CopyWrite> SpecCopy for Copier<'_, '_, R, W> {\n             // So we just try and fallback if needed.\n             // If current file offsets + write sizes overflow it may also fail, we do not try to fix that and instead\n             // fall back to the generic copy loop.\n-            if input_meta.potential_sendfile_source() {\n+            if input_meta.potential_sendfile_source() && safe_kernel_copy(&input_meta, &output_meta)\n+            {\n                 let result = sendfile_splice(SpliceMode::Sendfile, readfd, writefd, max_write);\n                 result.update_take(reader);\n \n@@ -197,7 +225,9 @@ impl<R: CopyRead, W: CopyWrite> SpecCopy for Copier<'_, '_, R, W> {\n                 }\n             }\n \n-            if input_meta.maybe_fifo() || output_meta.maybe_fifo() {\n+            if (input_meta.maybe_fifo() || output_meta.maybe_fifo())\n+                && safe_kernel_copy(&input_meta, &output_meta)\n+            {\n                 let result = sendfile_splice(SpliceMode::Splice, readfd, writefd, max_write);\n                 result.update_take(reader);\n \n@@ -298,13 +328,13 @@ impl CopyRead for &File {\n \n impl CopyWrite for File {\n     fn properties(&self) -> CopyParams {\n-        CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n+        CopyParams(fd_to_meta(self), Some(self.as_raw_fd()))\n     }\n }\n \n impl CopyWrite for &File {\n     fn properties(&self) -> CopyParams {\n-        CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n+        CopyParams(fd_to_meta(*self), Some(self.as_raw_fd()))\n     }\n }\n \n@@ -401,13 +431,13 @@ impl CopyRead for StdinLock<'_> {\n \n impl CopyWrite for StdoutLock<'_> {\n     fn properties(&self) -> CopyParams {\n-        CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n+        CopyParams(fd_to_meta(self), Some(self.as_raw_fd()))\n     }\n }\n \n impl CopyWrite for StderrLock<'_> {\n     fn properties(&self) -> CopyParams {\n-        CopyParams(FdMeta::NoneObtained, Some(self.as_raw_fd()))\n+        CopyParams(fd_to_meta(self), Some(self.as_raw_fd()))\n     }\n }\n "}, {"sha": "a524270e3fb85bccde2baf0baf82d0725fbf3be5", "filename": "library/std/src/sys/unix/kernel_copy/tests.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy%2Ftests.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -83,6 +83,48 @@ fn copies_append_mode_sink() -> Result<()> {\n     Ok(())\n }\n \n+#[test]\n+fn dont_splice_pipes_from_files() -> Result<()> {\n+    // splicing to a pipe and then modifying the source could lead to changes\n+    // becoming visible in an unexpected order.\n+\n+    use crate::io::SeekFrom;\n+    use crate::os::unix::fs::FileExt;\n+    use crate::process::{ChildStdin, ChildStdout};\n+    use crate::sys_common::FromInner;\n+\n+    let (read_end, write_end) = crate::sys::pipe::anon_pipe()?;\n+\n+    let mut read_end = ChildStdout::from_inner(read_end);\n+    let mut write_end = ChildStdin::from_inner(write_end);\n+\n+    let tmp_path = tmpdir();\n+    let file = tmp_path.join(\"to_be_modified\");\n+    let mut file =\n+        crate::fs::OpenOptions::new().create_new(true).read(true).write(true).open(file)?;\n+\n+    const SZ: usize = libc::PIPE_BUF as usize;\n+\n+    // put data in page cache\n+    let mut buf: [u8; SZ] = [0x01; SZ];\n+    file.write_all(&buf).unwrap();\n+\n+    // copy page into pipe\n+    file.seek(SeekFrom::Start(0)).unwrap();\n+    assert!(io::copy(&mut file, &mut write_end).unwrap() == SZ as u64);\n+\n+    // modify file\n+    buf[0] = 0x02;\n+    file.write_at(&buf, 0).unwrap();\n+\n+    // read from pipe\n+    read_end.read_exact(buf.as_mut_slice()).unwrap();\n+\n+    assert_eq!(buf[0], 0x01, \"data in pipe should reflect the original, not later modifications\");\n+\n+    Ok(())\n+}\n+\n #[bench]\n fn bench_file_to_file_copy(b: &mut test::Bencher) {\n     const BYTES: usize = 128 * 1024;"}, {"sha": "13b845b25c92d1c45afdd84e54957696e7e9c0e2", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -131,7 +131,8 @@\n //!\n //! * Build the thread with [`Builder`] and pass the desired stack size to [`Builder::stack_size`].\n //! * Set the `RUST_MIN_STACK` environment variable to an integer representing the desired stack\n-//!   size (in bytes). Note that setting [`Builder::stack_size`] will override this.\n+//!   size (in bytes). Note that setting [`Builder::stack_size`] will override this. Be aware that\n+//!   changes to `RUST_MIN_STACK` may be ignored after program start.\n //!\n //! Note that the stack size of the main thread is *not* determined by Rust.\n //!"}, {"sha": "9fb31ed7663d051722c6192a0f845a613012e9b2", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -17,7 +17,6 @@\n #![unstable(feature = \"test\", issue = \"50297\")]\n #![doc(test(attr(deny(warnings))))]\n #![feature(internal_output_capture)]\n-#![feature(is_terminal)]\n #![feature(staged_api)]\n #![feature(process_exitcode_internals)]\n #![feature(panic_can_unwind)]"}, {"sha": "f6a68073b2f7e60e002d787a276b37e0974f32dd", "filename": "library/unwind/src/libunwind.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Funwind%2Fsrc%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/library%2Funwind%2Fsrc%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Funwind%2Fsrc%2Flibunwind.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -75,6 +75,9 @@ pub const unwinder_private_data_size: usize = 20;\n #[cfg(all(target_arch = \"hexagon\", target_os = \"linux\"))]\n pub const unwinder_private_data_size: usize = 35;\n \n+#[cfg(target_arch = \"loongarch64\")]\n+pub const unwinder_private_data_size: usize = 2;\n+\n #[repr(C)]\n pub struct _Unwind_Exception {\n     pub exception_class: _Unwind_Exception_Class,"}, {"sha": "025145244c491bebd09e8db5de8362bdf18a76c5", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -304,6 +304,7 @@ def default_build_triple(verbose):\n         'i486': 'i686',\n         'i686': 'i686',\n         'i786': 'i686',\n+        'loongarch64': 'loongarch64',\n         'm68k': 'm68k',\n         'powerpc': 'powerpc',\n         'powerpc64': 'powerpc64',"}, {"sha": "c3e3fa009a677311ff129b95b0d5f8f680def0ba", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -139,7 +139,7 @@ pub fn read_commit_info_file(root: &Path) -> Option<Info> {\n                 sha: sha.to_owned(),\n                 short_sha: short_sha.to_owned(),\n             },\n-            _ => panic!(\"the `git-comit-info` file is malformed\"),\n+            _ => panic!(\"the `git-commit-info` file is malformed\"),\n         };\n         Some(info)\n     } else {"}, {"sha": "fcaa698317df0946eb60bd8f6572cda3e365f8b5", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -237,7 +237,7 @@ impl Step for Rustc {\n             target,\n             cargo_subcommand(builder.kind),\n         );\n-        rustc_cargo(builder, &mut cargo, target);\n+        rustc_cargo(builder, &mut cargo, target, compiler.stage);\n \n         // For ./x.py clippy, don't run with --all-targets because\n         // linting tests and benchmarks can produce very noisy results\n@@ -323,7 +323,7 @@ impl Step for CodegenBackend {\n         cargo\n             .arg(\"--manifest-path\")\n             .arg(builder.src.join(format!(\"compiler/rustc_codegen_{}/Cargo.toml\", backend)));\n-        rustc_cargo_env(builder, &mut cargo, target);\n+        rustc_cargo_env(builder, &mut cargo, target, compiler.stage);\n \n         let msg = if compiler.host == target {\n             format!(\"Checking stage{} {} artifacts ({target})\", builder.top_stage, backend)"}, {"sha": "d96e10485c29ea8d4e7534e37939c6315c5a320e", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 81, "deletions": 73, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -83,11 +83,11 @@ impl Step for Std {\n         let target = self.target;\n         let compiler = self.compiler;\n \n-        // These artifacts were already copied (in `impl Step for Sysroot`).\n-        // Don't recompile them.\n+        // When using `download-rustc`, we already have artifacts for the host available\n+        // (they were copied in `impl Step for Sysroot`). Don't recompile them.\n         // NOTE: the ABI of the beta compiler is different from the ABI of the downloaded compiler,\n         // so its artifacts can't be reused.\n-        if builder.download_rustc() && compiler.stage != 0 {\n+        if builder.download_rustc() && compiler.stage != 0 && target == builder.build.build {\n             return;\n         }\n \n@@ -696,7 +696,7 @@ impl Step for Rustc {\n         ));\n \n         let mut cargo = builder.cargo(compiler, Mode::Rustc, SourceType::InTree, target, \"build\");\n-        rustc_cargo(builder, &mut cargo, target);\n+        rustc_cargo(builder, &mut cargo, target, compiler.stage);\n \n         if builder.config.rust_profile_use.is_some()\n             && builder.config.rust_profile_generate.is_some()\n@@ -813,16 +813,21 @@ impl Step for Rustc {\n     }\n }\n \n-pub fn rustc_cargo(builder: &Builder<'_>, cargo: &mut Cargo, target: TargetSelection) {\n+pub fn rustc_cargo(builder: &Builder<'_>, cargo: &mut Cargo, target: TargetSelection, stage: u32) {\n     cargo\n         .arg(\"--features\")\n         .arg(builder.rustc_features(builder.kind))\n         .arg(\"--manifest-path\")\n         .arg(builder.src.join(\"compiler/rustc/Cargo.toml\"));\n-    rustc_cargo_env(builder, cargo, target);\n+    rustc_cargo_env(builder, cargo, target, stage);\n }\n \n-pub fn rustc_cargo_env(builder: &Builder<'_>, cargo: &mut Cargo, target: TargetSelection) {\n+pub fn rustc_cargo_env(\n+    builder: &Builder<'_>,\n+    cargo: &mut Cargo,\n+    target: TargetSelection,\n+    stage: u32,\n+) {\n     // Set some configuration variables picked up by build scripts and\n     // the compiler alike\n     cargo\n@@ -867,83 +872,86 @@ pub fn rustc_cargo_env(builder: &Builder<'_>, cargo: &mut Cargo, target: TargetS\n         cargo.env(\"RUSTC_VERIFY_LLVM_IR\", \"1\");\n     }\n \n-    // Pass down configuration from the LLVM build into the build of\n-    // rustc_llvm and rustc_codegen_llvm.\n-    //\n     // Note that this is disabled if LLVM itself is disabled or we're in a check\n     // build. If we are in a check build we still go ahead here presuming we've\n     // detected that LLVM is already built and good to go which helps prevent\n     // busting caches (e.g. like #71152).\n-    if builder.config.llvm_enabled()\n-        && (builder.kind != Kind::Check\n-            || crate::llvm::prebuilt_llvm_config(builder, target).is_ok())\n-    {\n-        if builder.is_rust_llvm(target) {\n-            cargo.env(\"LLVM_RUSTLLVM\", \"1\");\n-        }\n-        let llvm::LlvmResult { llvm_config, .. } = builder.ensure(llvm::Llvm { target });\n-        cargo.env(\"LLVM_CONFIG\", &llvm_config);\n-        if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n-            cargo.env(\"CFG_LLVM_ROOT\", s);\n+    if builder.config.llvm_enabled() {\n+        let building_is_expensive = crate::llvm::prebuilt_llvm_config(builder, target).is_err();\n+        // `top_stage == stage` might be false for `check --stage 1`, if we are building the stage 1 compiler\n+        let can_skip_build = builder.kind == Kind::Check && builder.top_stage == stage;\n+        let should_skip_build = building_is_expensive && can_skip_build;\n+        if !should_skip_build {\n+            rustc_llvm_env(builder, cargo, target)\n         }\n+    }\n+}\n \n-        // Some LLVM linker flags (-L and -l) may be needed to link `rustc_llvm`. Its build script\n-        // expects these to be passed via the `LLVM_LINKER_FLAGS` env variable, separated by\n-        // whitespace.\n-        //\n-        // For example:\n-        // - on windows, when `clang-cl` is used with instrumentation, we need to manually add\n-        // clang's runtime library resource directory so that the profiler runtime library can be\n-        // found. This is to avoid the linker errors about undefined references to\n-        // `__llvm_profile_instrument_memop` when linking `rustc_driver`.\n-        let mut llvm_linker_flags = String::new();\n-        if builder.config.llvm_profile_generate && target.contains(\"msvc\") {\n-            if let Some(ref clang_cl_path) = builder.config.llvm_clang_cl {\n-                // Add clang's runtime library directory to the search path\n-                let clang_rt_dir = get_clang_cl_resource_dir(clang_cl_path);\n-                llvm_linker_flags.push_str(&format!(\"-L{}\", clang_rt_dir.display()));\n-            }\n-        }\n+/// Pass down configuration from the LLVM build into the build of\n+/// rustc_llvm and rustc_codegen_llvm.\n+fn rustc_llvm_env(builder: &Builder<'_>, cargo: &mut Cargo, target: TargetSelection) {\n+    let target_config = builder.config.target_config.get(&target);\n \n-        // The config can also specify its own llvm linker flags.\n-        if let Some(ref s) = builder.config.llvm_ldflags {\n-            if !llvm_linker_flags.is_empty() {\n-                llvm_linker_flags.push_str(\" \");\n-            }\n-            llvm_linker_flags.push_str(s);\n+    if builder.is_rust_llvm(target) {\n+        cargo.env(\"LLVM_RUSTLLVM\", \"1\");\n+    }\n+    let llvm::LlvmResult { llvm_config, .. } = builder.ensure(llvm::Llvm { target });\n+    cargo.env(\"LLVM_CONFIG\", &llvm_config);\n+    if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n+        cargo.env(\"CFG_LLVM_ROOT\", s);\n+    }\n+\n+    // Some LLVM linker flags (-L and -l) may be needed to link `rustc_llvm`. Its build script\n+    // expects these to be passed via the `LLVM_LINKER_FLAGS` env variable, separated by\n+    // whitespace.\n+    //\n+    // For example:\n+    // - on windows, when `clang-cl` is used with instrumentation, we need to manually add\n+    // clang's runtime library resource directory so that the profiler runtime library can be\n+    // found. This is to avoid the linker errors about undefined references to\n+    // `__llvm_profile_instrument_memop` when linking `rustc_driver`.\n+    let mut llvm_linker_flags = String::new();\n+    if builder.config.llvm_profile_generate && target.contains(\"msvc\") {\n+        if let Some(ref clang_cl_path) = builder.config.llvm_clang_cl {\n+            // Add clang's runtime library directory to the search path\n+            let clang_rt_dir = get_clang_cl_resource_dir(clang_cl_path);\n+            llvm_linker_flags.push_str(&format!(\"-L{}\", clang_rt_dir.display()));\n         }\n+    }\n \n-        // Set the linker flags via the env var that `rustc_llvm`'s build script will read.\n+    // The config can also specify its own llvm linker flags.\n+    if let Some(ref s) = builder.config.llvm_ldflags {\n         if !llvm_linker_flags.is_empty() {\n-            cargo.env(\"LLVM_LINKER_FLAGS\", llvm_linker_flags);\n+            llvm_linker_flags.push_str(\" \");\n         }\n+        llvm_linker_flags.push_str(s);\n+    }\n \n-        // Building with a static libstdc++ is only supported on linux right now,\n-        // not for MSVC or macOS\n-        if builder.config.llvm_static_stdcpp\n-            && !target.contains(\"freebsd\")\n-            && !target.contains(\"msvc\")\n-            && !target.contains(\"apple\")\n-            && !target.contains(\"solaris\")\n-        {\n-            let file = compiler_file(\n-                builder,\n-                builder.cxx(target).unwrap(),\n-                target,\n-                CLang::Cxx,\n-                \"libstdc++.a\",\n-            );\n-            cargo.env(\"LLVM_STATIC_STDCPP\", file);\n-        }\n-        if builder.llvm_link_shared() {\n-            cargo.env(\"LLVM_LINK_SHARED\", \"1\");\n-        }\n-        if builder.config.llvm_use_libcxx {\n-            cargo.env(\"LLVM_USE_LIBCXX\", \"1\");\n-        }\n-        if builder.config.llvm_optimize && !builder.config.llvm_release_debuginfo {\n-            cargo.env(\"LLVM_NDEBUG\", \"1\");\n-        }\n+    // Set the linker flags via the env var that `rustc_llvm`'s build script will read.\n+    if !llvm_linker_flags.is_empty() {\n+        cargo.env(\"LLVM_LINKER_FLAGS\", llvm_linker_flags);\n+    }\n+\n+    // Building with a static libstdc++ is only supported on linux right now,\n+    // not for MSVC or macOS\n+    if builder.config.llvm_static_stdcpp\n+        && !target.contains(\"freebsd\")\n+        && !target.contains(\"msvc\")\n+        && !target.contains(\"apple\")\n+        && !target.contains(\"solaris\")\n+    {\n+        let file =\n+            compiler_file(builder, builder.cxx(target).unwrap(), target, CLang::Cxx, \"libstdc++.a\");\n+        cargo.env(\"LLVM_STATIC_STDCPP\", file);\n+    }\n+    if builder.llvm_link_shared() {\n+        cargo.env(\"LLVM_LINK_SHARED\", \"1\");\n+    }\n+    if builder.config.llvm_use_libcxx {\n+        cargo.env(\"LLVM_USE_LIBCXX\", \"1\");\n+    }\n+    if builder.config.llvm_optimize && !builder.config.llvm_release_debuginfo {\n+        cargo.env(\"LLVM_NDEBUG\", \"1\");\n     }\n }\n \n@@ -1090,7 +1098,7 @@ impl Step for CodegenBackend {\n         cargo\n             .arg(\"--manifest-path\")\n             .arg(builder.src.join(format!(\"compiler/rustc_codegen_{}/Cargo.toml\", backend)));\n-        rustc_cargo_env(builder, &mut cargo, target);\n+        rustc_cargo_env(builder, &mut cargo, target, compiler.stage);\n \n         let tmp_stamp = out_dir.join(\".tmp.stamp\");\n "}, {"sha": "94e71b89b5c86bed8324536c7baca427734670dd", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -895,6 +895,8 @@ impl Step for Src {\n \n     /// Creates the `rust-src` installer component\n     fn run(self, builder: &Builder<'_>) -> GeneratedTarball {\n+        builder.update_submodule(&Path::new(\"src/llvm-project\"));\n+\n         let tarball = Tarball::new_targetless(builder, \"rust-src\");\n \n         // A lot of tools expect the rust-src component to be entirely in this directory, so if you"}, {"sha": "9ad98eb57022c968565b54ca6fd12c6fcbdde68d", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -696,7 +696,7 @@ impl Step for Rustc {\n         cargo.rustdocflag(\"-Znormalize-docs\");\n         cargo.rustdocflag(\"--show-type-layout\");\n         cargo.rustdocflag(\"--generate-link-to-definition\");\n-        compile::rustc_cargo(builder, &mut cargo, target);\n+        compile::rustc_cargo(builder, &mut cargo, target, compiler.stage);\n         cargo.arg(\"-Zunstable-options\");\n         cargo.arg(\"-Zskip-rustdoc-fingerprint\");\n "}, {"sha": "eaa3afa4b7b2088e3d1279642baf52316480d581", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -129,7 +129,8 @@ const EXTRA_CHECK_CFGS: &[(Option<Mode>, &'static str, Option<&[&'static str]>)]\n     /* Extra values not defined in the built-in targets yet, but used in std */\n     (Some(Mode::Std), \"target_env\", Some(&[\"libnx\"])),\n     // (Some(Mode::Std), \"target_os\", Some(&[])),\n-    (Some(Mode::Std), \"target_arch\", Some(&[\"asmjs\", \"spirv\", \"nvptx\", \"xtensa\"])),\n+    // #[cfg(bootstrap)] loongarch64\n+    (Some(Mode::Std), \"target_arch\", Some(&[\"asmjs\", \"spirv\", \"nvptx\", \"xtensa\", \"loongarch64\"])),\n     /* Extra names used by dependencies */\n     // FIXME: Used by serde_json, but we should not be triggering on external dependencies.\n     (Some(Mode::Rustc), \"no_btreemap_remove_entry\", None),"}, {"sha": "a893c3a47c9fd2453dbcc7fc4557188c11d35c70", "filename": "src/bootstrap/llvm.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fbootstrap%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fbootstrap%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fllvm.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -291,7 +291,7 @@ impl Step for Llvm {\n         let llvm_targets = match &builder.config.llvm_targets {\n             Some(s) => s,\n             None => {\n-                \"AArch64;ARM;BPF;Hexagon;MSP430;Mips;NVPTX;PowerPC;RISCV;\\\n+                \"AArch64;ARM;BPF;Hexagon;LoongArch;MSP430;Mips;NVPTX;PowerPC;RISCV;\\\n                      Sparc;SystemZ;WebAssembly;X86\"\n             }\n         };\n@@ -1087,6 +1087,8 @@ impl Step for CrtBeginEnd {\n \n     /// Build crtbegin.o/crtend.o for musl target.\n     fn run(self, builder: &Builder<'_>) -> Self::Output {\n+        builder.update_submodule(&Path::new(\"src/llvm-project\"));\n+\n         let out_dir = builder.native_dir(self.target).join(\"crt\");\n \n         if builder.config.dry_run() {\n@@ -1153,6 +1155,8 @@ impl Step for Libunwind {\n \n     /// Build linunwind.a\n     fn run(self, builder: &Builder<'_>) -> Self::Output {\n+        builder.update_submodule(&Path::new(\"src/llvm-project\"));\n+\n         if builder.config.dry_run() {\n             return PathBuf::new();\n         }"}, {"sha": "cc0e34c6035fdb1f46401b79e861f0d50cf2821e", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1064,6 +1064,8 @@ impl Step for RustdocGUI {\n                     cargo.env(\"RUSTDOCFLAGS\", \"-Zunstable-options --generate-link-to-definition\");\n                 } else if entry.file_name() == \"scrape_examples\" {\n                     cargo.arg(\"-Zrustdoc-scrape-examples\");\n+                } else if entry.file_name() == \"extend_css\" {\n+                    cargo.env(\"RUSTDOCFLAGS\", &format!(\"--extend-css extra.css\"));\n                 }\n                 builder.run(&mut cargo);\n             }\n@@ -1535,7 +1537,10 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n         flags.extend(builder.config.cmd.rustc_args().iter().map(|s| s.to_string()));\n \n         if let Some(linker) = builder.linker(target) {\n-            cmd.arg(\"--linker\").arg(linker);\n+            cmd.arg(\"--target-linker\").arg(linker);\n+        }\n+        if let Some(linker) = builder.linker(compiler.host) {\n+            cmd.arg(\"--host-linker\").arg(linker);\n         }\n \n         let mut hostflags = flags.clone();\n@@ -2143,7 +2148,7 @@ impl Step for Crate {\n                 compile::std_cargo(builder, target, compiler.stage, &mut cargo);\n             }\n             Mode::Rustc => {\n-                compile::rustc_cargo(builder, &mut cargo, target);\n+                compile::rustc_cargo(builder, &mut cargo, target, compiler.stage);\n             }\n             _ => panic!(\"can only test libraries\"),\n         };"}, {"sha": "7092c7c46f861b506452f451f9d90597278243cb", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-tools/browser-ui-test.version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fbrowser-ui-test.version", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fbrowser-ui-test.version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fbrowser-ui-test.version?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1 +1 @@\n-0.14.6\n\\ No newline at end of file\n+0.15.0\n\\ No newline at end of file"}, {"sha": "c06006157b14b3d47b5c716fc392b77f3b2e21ce", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1 +1 @@\n-Subproject commit 0510ca84c2ce6bf93c4ccf9248756e9e4fd00b12\n+Subproject commit c06006157b14b3d47b5c716fc392b77f3b2e21ce"}, {"sha": "1f8dc727e94ae4ef92adf70df979521a1ea1143e", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1 +1 @@\n-Subproject commit 3c47807a3131b3c7cacb508f52632078d253cd0a\n+Subproject commit 1f8dc727e94ae4ef92adf70df979521a1ea1143e"}, {"sha": "31961fe22521a779070a44a8f30a2b00a20b6212", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1 +1 @@\n-Subproject commit ba84bf35d0f17d404003349309201654d25f61af\n+Subproject commit 31961fe22521a779070a44a8f30a2b00a20b6212"}, {"sha": "6337ed17fb8dcd918d78b7d97d213e923530337c", "filename": "src/doc/rustc-dev-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-dev-guide?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1 +1 @@\n-Subproject commit fca8af6c154c6cde2512f1331cf2704f214a818e\n+Subproject commit 6337ed17fb8dcd918d78b7d97d213e923530337c"}, {"sha": "8ded2ee59dd2033b20a8a6a4511bd3cc0e51838f", "filename": "src/doc/rustc/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -29,6 +29,7 @@\n     - [\\*-linux-ohos](platform-support/openharmony.md)\n     - [\\*-unknown-fuchsia](platform-support/fuchsia.md)\n     - [\\*-kmc-solid_\\*](platform-support/kmc-solid.md)\n+    - [loongarch\\*-unknown-linux-\\*](platform-support/loongarch-linux.md)\n     - [m68k-unknown-linux-gnu](platform-support/m68k-unknown-linux-gnu.md)\n     - [mips64-openwrt-linux-musl](platform-support/mips64-openwrt-linux-musl.md)\n     - [mipsel-sony-psx](platform-support/mipsel-sony-psx.md)"}, {"sha": "c378532dbf6c34953c246ea14de66a1e235596f8", "filename": "src/doc/rustc/src/platform-support.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -266,6 +266,7 @@ target | std | host | notes\n `i686-uwp-windows-gnu` | ? |  |\n `i686-uwp-windows-msvc` | ? |  |\n `i686-wrs-vxworks` | ? |  |\n+[`loongarch64-unknown-linux-gnu`](platform-support/loongarch-linux.md) | ? |  | LoongArch64 Linux (LP64D ABI)\n [`m68k-unknown-linux-gnu`](platform-support/m68k-unknown-linux-gnu.md) | ? |  | Motorola 680x0 Linux\n `mips-unknown-linux-uclibc` | \u2713 |  | MIPS Linux with uClibc\n [`mips64-openwrt-linux-musl`](platform-support/mips64-openwrt-linux-musl.md) | ? |  | MIPS64 for OpenWrt Linux MUSL"}, {"sha": "d7d31d8724c6da3641fa231a21486f6cad6ec0cd", "filename": "src/doc/rustc/src/platform-support/loongarch-linux.md", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Floongarch-linux.md", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Floongarch-linux.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Floongarch-linux.md?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -0,0 +1,92 @@\n+# loongarch\\*-unknown-linux-\\*\n+\n+**Tier: 3**\n+\n+[LoongArch] is a new RISC ISA developed by Loongson Technology Corporation Limited.\n+\n+[LoongArch]: https://loongson.github.io/LoongArch-Documentation/README-EN.html\n+\n+The target name follow this format: `<machine>-<vendor>-<os><fabi_suffix>`, where `<machine>` specifies the CPU family/model, `<vendor>` specifies the vendor and `<os>` the operating system name.\n+While the integer base ABI is\u00a0implied by the\u2002machine\u2002field, the floating point base ABI type is encoded into the os field of the specifier using the string suffix `<fabi-suffix>`.\n+\n+|    `<fabi-suffix>`     |                           `Description`                            |\n+|------------------------|--------------------------------------------------------------------|\n+|          f64           | The base ABI use 64-bits FPRs for parameter passing. (lp64d)|\n+|          f32           | The base ABI uses 32-bit FPRs for parameter passing. (lp64f)|\n+|          sf            | The base ABI uses no FPR for parameter passing. (lp64s)     |\n+\n+|`ABI type(Base ABI/ABI extension)`| `C library` | `kernel` |          `target tuple`          |\n+|----------------------------------|-------------|----------|----------------------------------|\n+|           lp64d/base             |   glibc     |  linux   | loongarch64-unknown-linux-gnu |\n+|           lp64f/base             |   glibc     |  linux   | loongarch64-unknown-linux-gnuf32 |\n+|           lp64s/base             |   glibc     |  linux   | loongarch64-unknown-linux-gnusf  |\n+|           lp64d/base             |  musl libc  |  linux   | loongarch64-unknown-linux-musl|\n+|           lp64f/base             |  musl libc  |  linux   | loongarch64-unknown-linux-muslf32|\n+|           lp64s/base             |  musl libc  |  linux   | loongarch64-unknown-linux-muslsf |\n+\n+## Target maintainers\n+\n+- [ZHAI Xiaojuan](https://github.com/zhaixiaojuan) `zhaixiaojuan@loongson.cn`\n+- [WANG Rui](https://github.com/heiher) `wangrui@loongson.cn`\n+- [ZHAI Xiang](https://github.com/xiangzhai) `zhaixiang@loongson.cn`\n+- [WANG Xuerui](https://github.com/xen0n) `git@xen0n.name`\n+\n+## Requirements\n+\n+This target is cross-compiled.\n+A GNU toolchain for LoongArch target is required.  It can be downloaded from https://github.com/loongson/build-tools/releases, or built from the source code of GCC (12.1.0 or later) and Binutils (2.40 or later).\n+\n+## Building the target\n+\n+The target can be built by enabling it for a `rustc` build.\n+\n+```toml\n+[build]\n+target = [\"loongarch64-unknown-linux-gnu\"]\n+```\n+\n+Make sure `loongarch64-unknown-linux-gnu-gcc` can be searched from the directories specified in`$PATH`. Alternatively, you can use GNU LoongArch Toolchain by adding the following to `config.toml`:\n+\n+```toml\n+[target.loongarch64-unknown-linux-gnu]\n+# ADJUST THIS PATH TO POINT AT YOUR TOOLCHAIN\n+cc = \"/TOOLCHAIN_PATH/bin/loongarch64-unknown-linux-gnu-gcc\"\n+cxx = \"/TOOLCHAIN_PATH/bin/loongarch64-unknown-linux-gnu-g++\"\n+ar = \"/TOOLCHAIN_PATH/bin/loongarch64-unknown-linux-gnu-ar\"\n+ranlib = \"/TOOLCHAIN_PATH/bin/loongarch64-unknown-linux-gnu-ranlib\"\n+linker = \"/TOOLCHAIN_PATH/bin/loongarch64-unknown-linux-gnu-gcc\"\n+```\n+\n+## Cross-compilation\n+\n+This target can be cross-compiled on a `x86_64-unknown-linux-gnu` host. Cross-compilation on other hosts may work but is not tested.\n+\n+## Testing\n+To test a cross-compiled binary on your build system, install the qemu binary that supports the LoongArch architecture and execute the following commands.\n+```text\n+CC_loongarch64_unknown_linux_gnu=/TOOLCHAIN_PATH/bin/loongarch64-unknown-linux-gnu-gcc \\\n+CXX_loongarch64_unknown_linux_gnu=/TOOLCHAIN_PATH/bin/loongarch64-unknown-linux-gnu-g++ \\\n+AR_loongarch64_unknown_linux_gnu=/TOOLCHAIN_PATH/bin/loongarch64-unknown-linux-gnu-gcc-ar \\\n+CARGO_TARGET_LOONGARCH64_UNKNOWN_LINUX_GNUN_LINKER=/TOOLCHAIN_PATH/bin/loongarch64-unknown-linux-gnu-gcc \\\n+# SET TARGET SYSTEM LIBRARY PATH\n+CARGO_TARGET_LOONGARCH64_UNKNOWN_LINUX_GNUN_RUNNER=\"qemu-loongarch64 -L /TOOLCHAIN_PATH/TARGET_LIBRAY_PATH\" \\\n+cargo run --target loongarch64-unknown-linux-gnu --release\n+```\n+Tested on x86 architecture, other architectures not tested.\n+\n+## Building Rust programs\n+\n+Rust does not yet ship pre-compiled artifacts for this target. To compile for this target, you will either need to build Rust with the target enabled (see \"Building the target\" above), or build your own copy of `std` by using `build-std` or similar.\n+\n+If `rustc` has support for that target and the library artifacts are available, then Rust static libraries can be built for that target:\n+\n+```shell\n+$ rustc --target loongarch64-unknown-linux-gnu your-code.rs --crate-type staticlib\n+$ ls libyour_code.a\n+```\n+\n+On Rust Nightly it's possible to build without the target artifacts available:\n+\n+```text\n+cargo build -Z build-std --target loongarch64-unknown-linux-gnu\n+```"}, {"sha": "dfc8042637232a924942f63d790b5cade3749cf7", "filename": "src/doc/rustdoc/src/command-line-arguments.md", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fdoc%2Frustdoc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fdoc%2Frustdoc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fcommand-line-arguments.md?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -320,10 +320,7 @@ $ rustdoc src/lib.rs --extend-css extra.css\n ```\n \n With this flag, the contents of the files you pass are included at the bottom\n-of Rustdoc's `theme.css` file.\n-\n-While this flag is stable, the contents of `theme.css` are not, so be careful!\n-Updates may break your theme extensions.\n+of the `theme.css` file.\n \n ## `--sysroot`: override the system root\n "}, {"sha": "96f66c89c259f69fd7bcd274c3d5c4274fe5c01c", "filename": "src/doc/style-guide/src/expressions.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fexpressions.md", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fexpressions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fexpressions.md?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -643,7 +643,7 @@ Examples:\n ```rust\n match foo {\n     foo => bar,\n-    a_very_long_patten | another_pattern if an_expression() => {\n+    a_very_long_pattern | another_pattern if an_expression() => {\n         no_room_for_this_expression()\n     }\n     foo => {"}, {"sha": "05ffdcf201c82d85e415aff89bd51e1473aa749f", "filename": "src/doc/unstable-book/src/compiler-flags/dump-mono-stats-format.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fdump-mono-stats-format.md", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fdump-mono-stats-format.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fdump-mono-stats-format.md?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -3,4 +3,4 @@\n --------------------\n \n The `-Z dump-mono-stats-format` compiler flag controls what file format to use for `-Z dump-mono-stats`.\n-The default is markdown; currently JSON is also supported. JSON can be useful for programatically manipulating the results (e.g. to find the item that took the longest to compile).\n+The default is markdown; currently JSON is also supported. JSON can be useful for programmatically manipulating the results (e.g. to find the item that took the longest to compile)."}, {"sha": "1f52ab75010e6f63a93cfde5f0cb0150838b2623", "filename": "src/doc/unstable-book/src/language-features/asm-experimental-arch.md", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fasm-experimental-arch.md", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fasm-experimental-arch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fasm-experimental-arch.md?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -16,6 +16,7 @@ This feature tracks `asm!` and `global_asm!` support for the following architect\n - SPIR-V\n - AVR\n - MSP430\n+- M68k\n \n ## Register classes\n \n@@ -41,6 +42,9 @@ This feature tracks `asm!` and `global_asm!` support for the following architect\n | AVR          | `reg_iw`       | `r25r24`, `X`, `Z`                 | `w`                  |\n | AVR          | `reg_ptr`      | `X`, `Z`                           | `e`                  |\n | MSP430       | `reg`          | `r[0-15]`                          | `r`                  |\n+| M68k         | `reg`          | `d[0-7]`, `a[0-7]`                 | `r`                  |\n+| M68k         | `reg_data`     | `d[0-7]`                           | `d`                  |\n+| M68k         | `reg_addr`     | `a[0-3]`                           | `a`                  |\n \n > **Notes**:\n > - NVPTX doesn't have a fixed register set, so named registers are not supported.\n@@ -70,6 +74,8 @@ This feature tracks `asm!` and `global_asm!` support for the following architect\n | AVR          | `reg`, `reg_upper`              | None           | `i8`                                    |\n | AVR          | `reg_pair`, `reg_iw`, `reg_ptr` | None           | `i16`                                   |\n | MSP430       | `reg`                           | None           | `i8`, `i16`                             |\n+| M68k         | `reg`, `reg_addr`               | None           | `i16`, `i32`                            |\n+| M68k         | `reg_data`                      | None           | `i8`, `i16`, `i32`                      |\n \n ## Register aliases\n \n@@ -88,6 +94,9 @@ This feature tracks `asm!` and `global_asm!` support for the following architect\n | MSP430       | `r2`          | `sr`      |\n | MSP430       | `r3`          | `cg`      |\n | MSP430       | `r4`          | `fp`      |\n+| M68k         | `a5`          | `bp`      |\n+| M68k         | `a6`          | `fp`      |\n+| M68k         | `a7`          | `sp`, `usp`, `ssp`, `isp` |\n \n > **Notes**:\n > - TI does not mandate a frame pointer for MSP430, but toolchains are allowed\n@@ -98,7 +107,7 @@ This feature tracks `asm!` and `global_asm!` support for the following architect\n | Architecture | Unsupported register                    | Reason                                                                                                                                                                              |\n | ------------ | --------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n | All          | `sp`                                    | The stack pointer must be restored to its original value at the end of an asm code block.                                                                                           |\n-| All          | `fr` (Hexagon), `$fp` (MIPS), `Y` (AVR), `r4` (MSP430) | The frame pointer cannot be used as an input or output.                                                                                                                             |\n+| All          | `fr` (Hexagon), `$fp` (MIPS), `Y` (AVR), `r4` (MSP430), `a6` (M68k) | The frame pointer cannot be used as an input or output.                                                                                                                             |\n | All          | `r19` (Hexagon)                         | This is used internally by LLVM as a \"base pointer\" for functions with complex stack frames.                                                                                        |\n | MIPS         | `$0` or `$zero`                         | This is a constant zero register which can't be modified.                                                                                                                           |\n | MIPS         | `$1` or `$at`                           | Reserved for assembler.                                                                                                                                                             |\n@@ -108,6 +117,7 @@ This feature tracks `asm!` and `global_asm!` support for the following architect\n | Hexagon      | `lr`                                    | This is the link register which cannot be used as an input or output.                                                                                                               |\n | AVR          | `r0`, `r1`, `r1r0`                      | Due to an issue in LLVM, the `r0` and `r1` registers cannot be used as inputs or outputs.  If modified, they must be restored to their original values before the end of the block. |\n |MSP430        | `r0`, `r2`, `r3`                        | These are the program counter, status register, and constant generator respectively. Neither the status register nor constant generator can be written to.                          |\n+| M68k         | `a4`, `a5`                              | Used internally by LLVM for the base pointer and global base pointer. |\n \n ## Template modifiers\n \n@@ -130,3 +140,5 @@ These flags registers must be restored upon exiting the asm block if the `preser\n   - The status register `SREG`.\n - MSP430\n   - The status register `r2`.\n+- M68k\n+  - The condition code register `ccr`."}, {"sha": "f29e1e4d27a27d284576b9c156fa897596ed6a6a", "filename": "src/etc/installer/msi/rust.wxs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fetc%2Finstaller%2Fmsi%2Frust.wxs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fetc%2Finstaller%2Fmsi%2Frust.wxs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Finstaller%2Fmsi%2Frust.wxs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -119,7 +119,7 @@\n         <SetProperty Sequence=\"ui\" Before=\"CostFinalize\"\n             Id=\"WixAppFolder\" Value=\"WixPerUserFolder\">NOT ALLUSERS</SetProperty>\n \n-        <!-- UI sets ALLUSERS per user selection; progagate this choice to MSIINSTALLPERUSER before executing installation actions -->\n+        <!-- UI sets ALLUSERS per user selection; propagate this choice to MSIINSTALLPERUSER before executing installation actions -->\n         <SetProperty Sequence=\"ui\" Before=\"ExecuteAction\"\n             Id=\"MSIINSTALLPERUSER\" Value=\"1\">NOT ALLUSERS</SetProperty>\n "}, {"sha": "d812f7a802b1c18da052ff2c284cde7cf8a5a792", "filename": "src/etc/rust-gdb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fetc%2Frust-gdb", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fetc%2Frust-gdb", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Frust-gdb?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -13,6 +13,8 @@ fi\n # Find out where the pretty printer Python module is\n RUSTC_SYSROOT=\"$(\"$RUSTC\" --print=sysroot)\"\n GDB_PYTHON_MODULE_DIRECTORY=\"$RUSTC_SYSROOT/lib/rustlib/etc\"\n+# Get the commit hash for path remapping\n+RUSTC_COMMIT_HASH=\"$(\"$RUSTC\" -vV | sed -n 's/commit-hash: \\(\\w*\\)/\\1/p')\"\n \n # Run GDB with the additional arguments that load the pretty printers\n # Set the environment variable `RUST_GDB` to overwrite the call to a\n@@ -21,4 +23,6 @@ RUST_GDB=\"${RUST_GDB:-gdb}\"\n PYTHONPATH=\"$PYTHONPATH:$GDB_PYTHON_MODULE_DIRECTORY\" exec ${RUST_GDB} \\\n   --directory=\"$GDB_PYTHON_MODULE_DIRECTORY\" \\\n   -iex \"add-auto-load-safe-path $GDB_PYTHON_MODULE_DIRECTORY\" \\\n+  -iex \"set substitute-path /rustc/$RUSTC_COMMIT_HASH $RUSTC_SYSROOT/lib/rustlib/src/rust\" \\\n   \"$@\"\n+ \n\\ No newline at end of file"}, {"sha": "e7bafcc99b81db73b6732f603f20047390f4613f", "filename": "src/etc/rust-gdbgui", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fetc%2Frust-gdbgui", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Fetc%2Frust-gdbgui", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Frust-gdbgui?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -42,6 +42,8 @@ fi\n # Find out where the pretty printer Python module is\n RUSTC_SYSROOT=\"$(\"$RUSTC\" --print=sysroot)\"\n GDB_PYTHON_MODULE_DIRECTORY=\"$RUSTC_SYSROOT/lib/rustlib/etc\"\n+# Get the commit hash for path remapping\n+RUSTC_COMMIT_HASH=\"$(\"$RUSTC\" -vV | sed -n 's/commit-hash: \\(\\w*\\)/\\1/p')\"\n \n # Set the environment variable `RUST_GDB` to overwrite the call to a\n # different/specific command (defaults to `gdb`).\n@@ -53,7 +55,9 @@ RUST_GDBGUI=\"${RUST_GDBGUI:-gdbgui}\"\n \n # These arguments get passed through to GDB and make it load the\n # Rust pretty printers.\n-GDB_ARGS=\"--directory=\\\"$GDB_PYTHON_MODULE_DIRECTORY\\\" -iex \\\"add-auto-load-safe-path $GDB_PYTHON_MODULE_DIRECTORY\\\"\"\n+GDB_ARGS=\"--directory=\\\"$GDB_PYTHON_MODULE_DIRECTORY\\\"\" \\\n+   \"-iex \\\"add-auto-load-safe-path $GDB_PYTHON_MODULE_DIRECTORY\\\"\" \\\n+   \"-iex \\\"set substitute-path /rustc/$RUSTC_COMMIT_HASH $RUSTC_SYSROOT/lib/rustlib/src/rust\\\"\"\n \n # Finally we execute gdbgui.\n PYTHONPATH=\"$PYTHONPATH:$GDB_PYTHON_MODULE_DIRECTORY\" \\"}, {"sha": "5177cffe6bae4ef8c52269dd0e6e6a8868d9d1ba", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -517,6 +517,7 @@ impl<'a> fmt::Display for Display<'a> {\n                         \"aarch64\" => \"AArch64\",\n                         \"arm\" => \"ARM\",\n                         \"asmjs\" => \"JavaScript\",\n+                        \"loongarch64\" => \"LoongArch LA64\",\n                         \"m68k\" => \"M68k\",\n                         \"mips\" => \"MIPS\",\n                         \"mips64\" => \"MIPS-64\","}, {"sha": "cc5d13808b2f5437905a90012fbeaaf95cf337c3", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -111,7 +111,7 @@ pub(crate) fn try_inline(\n             clean::ConstantItem(build_const(cx, did))\n         }\n         Res::Def(DefKind::Macro(kind), did) => {\n-            let mac = build_macro(cx, did, name, import_def_id);\n+            let mac = build_macro(cx, did, name, import_def_id, kind);\n \n             let type_kind = match kind {\n                 MacroKind::Bang => ItemType::Macro,\n@@ -152,7 +152,7 @@ pub(crate) fn try_inline_glob(\n             // reexported by the glob, e.g. because they are shadowed by something else.\n             let reexports = cx\n                 .tcx\n-                .module_reexports(current_mod)\n+                .module_children_reexports(current_mod)\n                 .iter()\n                 .filter_map(|child| child.res.opt_def_id())\n                 .collect();\n@@ -651,18 +651,24 @@ fn build_macro(\n     def_id: DefId,\n     name: Symbol,\n     import_def_id: Option<DefId>,\n+    macro_kind: MacroKind,\n ) -> clean::ItemKind {\n     match CStore::from_tcx(cx.tcx).load_macro_untracked(def_id, cx.sess()) {\n-        LoadedMacro::MacroDef(item_def, _) => {\n-            if let ast::ItemKind::MacroDef(ref def) = item_def.kind {\n-                let vis = cx.tcx.visibility(import_def_id.unwrap_or(def_id));\n-                clean::MacroItem(clean::Macro {\n-                    source: utils::display_macro_source(cx, name, def, def_id, vis),\n-                })\n-            } else {\n-                unreachable!()\n+        LoadedMacro::MacroDef(item_def, _) => match macro_kind {\n+            MacroKind::Bang => {\n+                if let ast::ItemKind::MacroDef(ref def) = item_def.kind {\n+                    let vis = cx.tcx.visibility(import_def_id.unwrap_or(def_id));\n+                    clean::MacroItem(clean::Macro {\n+                        source: utils::display_macro_source(cx, name, def, def_id, vis),\n+                    })\n+                } else {\n+                    unreachable!()\n+                }\n             }\n-        }\n+            MacroKind::Derive | MacroKind::Attr => {\n+                clean::ProcMacroItem(clean::ProcMacro { kind: macro_kind, helpers: Vec::new() })\n+            }\n+        },\n         LoadedMacro::ProcMacro(ext) => clean::ProcMacroItem(clean::ProcMacro {\n             kind: ext.macro_kind(),\n             helpers: ext.helper_attrs,"}, {"sha": "6ceba1b1f8e2224f10086c696d191e08d806a0f0", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 42, "deletions": 32, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -909,6 +909,38 @@ fn clean_ty_generics<'tcx>(\n     }\n }\n \n+fn clean_proc_macro<'tcx>(\n+    item: &hir::Item<'tcx>,\n+    name: &mut Symbol,\n+    kind: MacroKind,\n+    cx: &mut DocContext<'tcx>,\n+) -> ItemKind {\n+    let attrs = cx.tcx.hir().attrs(item.hir_id());\n+    if kind == MacroKind::Derive &&\n+        let Some(derive_name) = attrs\n+            .lists(sym::proc_macro_derive)\n+            .find_map(|mi| mi.ident())\n+    {\n+        *name = derive_name.name;\n+    }\n+\n+    let mut helpers = Vec::new();\n+    for mi in attrs.lists(sym::proc_macro_derive) {\n+        if !mi.has_name(sym::attributes) {\n+            continue;\n+        }\n+\n+        if let Some(list) = mi.meta_item_list() {\n+            for inner_mi in list {\n+                if let Some(ident) = inner_mi.ident() {\n+                    helpers.push(ident.name);\n+                }\n+            }\n+        }\n+    }\n+    ProcMacroItem(ProcMacro { kind, helpers })\n+}\n+\n fn clean_fn_or_proc_macro<'tcx>(\n     item: &hir::Item<'tcx>,\n     sig: &hir::FnSig<'tcx>,\n@@ -930,31 +962,7 @@ fn clean_fn_or_proc_macro<'tcx>(\n         }\n     });\n     match macro_kind {\n-        Some(kind) => {\n-            if kind == MacroKind::Derive {\n-                *name = attrs\n-                    .lists(sym::proc_macro_derive)\n-                    .find_map(|mi| mi.ident())\n-                    .expect(\"proc-macro derives require a name\")\n-                    .name;\n-            }\n-\n-            let mut helpers = Vec::new();\n-            for mi in attrs.lists(sym::proc_macro_derive) {\n-                if !mi.has_name(sym::attributes) {\n-                    continue;\n-                }\n-\n-                if let Some(list) = mi.meta_item_list() {\n-                    for inner_mi in list {\n-                        if let Some(ident) = inner_mi.ident() {\n-                            helpers.push(ident.name);\n-                        }\n-                    }\n-                }\n-            }\n-            ProcMacroItem(ProcMacro { kind, helpers })\n-        }\n+        Some(kind) => clean_proc_macro(item, name, kind, cx),\n         None => {\n             let mut func = clean_function(cx, sig, generics, FunctionArgs::Body(body_id));\n             clean_fn_decl_legacy_const_generics(&mut func, attrs);\n@@ -2062,7 +2070,7 @@ pub(crate) fn reexport_chain<'tcx>(\n     import_def_id: LocalDefId,\n     target_def_id: LocalDefId,\n ) -> &'tcx [Reexport] {\n-    for child in tcx.module_reexports(tcx.local_parent(import_def_id)) {\n+    for child in tcx.module_children_reexports(tcx.local_parent(import_def_id)) {\n         if child.res.opt_def_id() == Some(target_def_id.to_def_id())\n             && child.reexport_chain[0].id() == Some(import_def_id.to_def_id())\n         {\n@@ -2247,16 +2255,17 @@ fn clean_maybe_renamed_item<'tcx>(\n                 fields: variant_data.fields().iter().map(|x| clean_field(x, cx)).collect(),\n             }),\n             ItemKind::Impl(impl_) => return clean_impl(impl_, item.owner_id.def_id, cx),\n-            // proc macros can have a name set by attributes\n-            ItemKind::Fn(ref sig, generics, body_id) => {\n-                clean_fn_or_proc_macro(item, sig, generics, body_id, &mut name, cx)\n-            }\n-            ItemKind::Macro(ref macro_def, _) => {\n+            ItemKind::Macro(ref macro_def, MacroKind::Bang) => {\n                 let ty_vis = cx.tcx.visibility(def_id);\n                 MacroItem(Macro {\n                     source: display_macro_source(cx, name, macro_def, def_id, ty_vis),\n                 })\n             }\n+            ItemKind::Macro(_, macro_kind) => clean_proc_macro(item, &mut name, macro_kind, cx),\n+            // proc macros can have a name set by attributes\n+            ItemKind::Fn(ref sig, generics, body_id) => {\n+                clean_fn_or_proc_macro(item, sig, generics, body_id, &mut name, cx)\n+            }\n             ItemKind::Trait(_, _, generics, bounds, item_ids) => {\n                 let items = item_ids\n                     .iter()\n@@ -2381,7 +2390,8 @@ fn clean_extern_crate<'tcx>(\n                     Some(l) => attr::list_contains_name(&l, sym::inline),\n                     None => false,\n                 }\n-        });\n+        })\n+        && !cx.output_format.is_json();\n \n     let krate_owner_def_id = krate.owner_id.to_def_id();\n     if please_inline {"}, {"sha": "e34ece9264cfb9419e1e4d4f006eed7b0a929e21", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -687,7 +687,7 @@ impl Item {\n                 return None;\n             }\n             // Variants always inherit visibility\n-            VariantItem(..) => return None,\n+            VariantItem(..) | ImplItem(..) => return None,\n             // Trait items inherit the trait's visibility\n             AssocConstItem(..) | TyAssocConstItem(..) | AssocTypeItem(..) | TyAssocTypeItem(..)\n             | TyMethodItem(..) | MethodItem(..) => {\n@@ -2019,7 +2019,7 @@ impl Variant {\n \n #[derive(Clone, Debug)]\n pub(crate) struct Discriminant {\n-    // In the case of cross crate re-exports, we don't have the nessesary information\n+    // In the case of cross crate re-exports, we don't have the necessary information\n     // to reconstruct the expression of the discriminant, only the value.\n     pub(super) expr: Option<BodyId>,\n     pub(super) value: DefId,"}, {"sha": "512c5c85d6a493ab430b47d36cb0d18aeb36b3ad", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -6,7 +6,6 @@ use std::path::PathBuf;\n use std::str::FromStr;\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_driver::print_flag_list;\n use rustc_session::config::{\n     self, parse_crate_types_from_list, parse_externs, parse_target_triple, CrateType,\n };\n@@ -230,7 +229,7 @@ pub(crate) struct RenderOptions {\n     pub(crate) extension_css: Option<PathBuf>,\n     /// A map of crate names to the URL to use instead of querying the crate's `html_root_url`.\n     pub(crate) extern_html_root_urls: BTreeMap<String, String>,\n-    /// Whether to give precedence to `html_root_url` or `--exten-html-root-url`.\n+    /// Whether to give precedence to `html_root_url` or `--extern-html-root-url`.\n     pub(crate) extern_html_root_takes_precedence: bool,\n     /// A map of the default settings (values are as for DOM storage API). Keys should lack the\n     /// `rustdoc-` prefix.\n@@ -328,14 +327,7 @@ impl Options {\n             return Err(0);\n         }\n \n-        let z_flags = matches.opt_strs(\"Z\");\n-        if z_flags.iter().any(|x| *x == \"help\") {\n-            print_flag_list(\"-Z\", config::Z_OPTIONS);\n-            return Err(0);\n-        }\n-        let c_flags = matches.opt_strs(\"C\");\n-        if c_flags.iter().any(|x| *x == \"help\") {\n-            print_flag_list(\"-C\", config::CG_OPTIONS);\n+        if rustc_driver::describe_flag_categories(&matches) {\n             return Err(0);\n         }\n "}, {"sha": "daf10e5b88a835815c3225e6fab3b4c764bed910", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -398,6 +398,8 @@ fn run_test(\n     compiler.stdin(Stdio::piped());\n     compiler.stderr(Stdio::piped());\n \n+    debug!(\"compiler invocation for doctest: {:?}\", compiler);\n+\n     let mut child = compiler.spawn().expect(\"Failed to spawn rustc process\");\n     {\n         let stdin = child.stdin.as_mut().expect(\"Failed to open stdin\");"}, {"sha": "1b445b8981e1a7dbc8a9e7912e08cd311e290a3e", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -349,10 +349,10 @@ pub(crate) fn print_where_clause<'a, 'tcx: 'a>(\n             let mut br_with_padding = String::with_capacity(6 * indent + 28);\n             br_with_padding.push_str(\"\\n\");\n \n-            let padding_amout =\n+            let padding_amount =\n                 if ending == Ending::Newline { indent + 4 } else { indent + \"fn where \".len() };\n \n-            for _ in 0..padding_amout {\n+            for _ in 0..padding_amount {\n                 br_with_padding.push_str(\" \");\n             }\n             let where_preds = where_preds.to_string().replace('\\n', &br_with_padding);"}, {"sha": "9a968e48b272f69b94c925771d7c17f1aa34d21e", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1796,10 +1796,11 @@ fn render_struct(\n     }\n     match ty {\n         None => {\n-            let where_diplayed = g.map(|g| print_where_clause_and_check(w, g, cx)).unwrap_or(false);\n+            let where_displayed =\n+                g.map(|g| print_where_clause_and_check(w, g, cx)).unwrap_or(false);\n \n             // If there wasn't a `where` clause, we add a whitespace.\n-            if !where_diplayed {\n+            if !where_displayed {\n                 w.write_str(\" {\");\n             } else {\n                 w.write_str(\"{\");"}, {"sha": "6fbb4508662c7a1418492da0b5a904301371d77b", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -384,6 +384,7 @@ img {\n \tfont-size: 0.875rem;\n \tflex: 0 0 200px;\n \toverflow-y: scroll;\n+\toverscroll-behavior: contain;\n \tposition: sticky;\n \theight: 100vh;\n \ttop: 0;\n@@ -1531,7 +1532,7 @@ However, it's not needed with smaller screen width because the doc/code block is\n /*\n WARNING: RUSTDOC_MOBILE_BREAKPOINT MEDIA QUERY\n If you update this line, then you also need to update the line with the same warning\n-in main.js\n+in source-script.js\n */\n @media (max-width: 700px) {\n \t/* When linking to an item with an `id` (for instance, by clicking a link in the sidebar,"}, {"sha": "d13c783d2e4fbd93bb849a766df1c52a947a2a5c", "filename": "src/librustdoc/html/static/css/settings.css", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fsettings.css", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fsettings.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fsettings.css?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -8,7 +8,7 @@\n \theight: 1.2rem;\n \twidth: 1.2rem;\n \tcolor: inherit;\n-\tborder: 1px solid currentColor;\n+\tborder: 2px solid var(--settings-input-border-color);\n \toutline: none;\n \t-webkit-appearance: none;\n \tcursor: pointer;\n@@ -52,6 +52,7 @@\n }\n .setting-check input:checked {\n \tbackground-color: var(--settings-input-color);\n+\tborder-width: 1px;\n }\n .setting-radio input:focus, .setting-check input:focus {\n \tbox-shadow: 0 0 1px 1px var(--settings-input-color);"}, {"sha": "7145baad256732935282aa99f399b25ce1b48de4", "filename": "src/librustdoc/html/static/css/themes/ayu.css", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -7,6 +7,7 @@ Original by Dempfi (https://github.com/dempfi/ayu)\n \t--main-background-color: #0f1419;\n \t--main-color: #c5c5c5;\n \t--settings-input-color: #ffb454;\n+\t--settings-input-border-color: #999;\n \t--settings-button-color: #fff;\n \t--settings-button-border-focus: #e0e0e0;\n \t--sidebar-background-color: #14191f;"}, {"sha": "3c1186a5649f1cd6ae590632ddcb3c966531f73a", "filename": "src/librustdoc/html/static/css/themes/dark.css", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -2,6 +2,7 @@\n \t--main-background-color: #353535;\n \t--main-color: #ddd;\n \t--settings-input-color: #2196f3;\n+\t--settings-input-border-color: #999;\n \t--settings-button-color: #000;\n \t--settings-button-border-focus: #ffb900;\n \t--sidebar-background-color: #505050;"}, {"sha": "f8c287137deac18021219c3e30ca8859002919eb", "filename": "src/librustdoc/html/static/css/themes/light.css", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -2,6 +2,7 @@\n \t--main-background-color: white;\n \t--main-color: black;\n \t--settings-input-color: #2196f3;\n+\t--settings-input-border-color: #717171;\n \t--settings-button-color: #000;\n \t--settings-button-border-focus: #717171;\n \t--sidebar-background-color: #F5F5F5;"}, {"sha": "6f5987e68bf1c91654acbacf161257a56ec2c59f", "filename": "src/librustdoc/html/static/js/main.js", "status": "modified", "additions": 5, "deletions": 66, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -4,11 +4,6 @@\n \n \"use strict\";\n \n-// WARNING: RUSTDOC_MOBILE_BREAKPOINT MEDIA QUERY\n-// If you update this line, then you also need to update the media query with the same\n-// warning in rustdoc.css\n-window.RUSTDOC_MOBILE_BREAKPOINT = 700;\n-\n // Given a basename (e.g. \"storage\") and an extension (e.g. \".js\"), return a URL\n // for a resource under the root-path, with the resource-suffix.\n function resourcePath(basename, extension) {\n@@ -331,10 +326,6 @@ function preLoadCss(cssUrl) {\n         },\n     };\n \n-    function getPageId() {\n-        return window.location.hash.replace(/^#/, \"\");\n-    }\n-\n     const toggleAllDocsId = \"toggle-all-docs\";\n     let savedHash = \"\";\n \n@@ -355,12 +346,12 @@ function preLoadCss(cssUrl) {\n             }\n         }\n         // This part is used in case an element is not visible.\n-        if (savedHash !== window.location.hash) {\n-            savedHash = window.location.hash;\n-            if (savedHash.length === 0) {\n-                return;\n+        const pageId = window.location.hash.replace(/^#/, \"\");\n+        if (savedHash !== pageId) {\n+            savedHash = pageId;\n+            if (pageId !== \"\") {\n+                expandSection(pageId);\n             }\n-            expandSection(savedHash.slice(1)); // we remove the '#'\n         }\n     }\n \n@@ -699,11 +690,6 @@ function preLoadCss(cssUrl) {\n             }\n \n         });\n-\n-        const pageId = getPageId();\n-        if (pageId !== \"\") {\n-            expandSection(pageId);\n-        }\n     }());\n \n     window.rustdoc_add_line_numbers_to_examples = () => {\n@@ -739,65 +725,18 @@ function preLoadCss(cssUrl) {\n         window.rustdoc_add_line_numbers_to_examples();\n     }\n \n-    let oldSidebarScrollPosition = null;\n-\n-    // Scroll locking used both here and in source-script.js\n-\n-    window.rustdocMobileScrollLock = function() {\n-        const mobile_topbar = document.querySelector(\".mobile-topbar\");\n-        if (window.innerWidth <= window.RUSTDOC_MOBILE_BREAKPOINT) {\n-            // This is to keep the scroll position on mobile.\n-            oldSidebarScrollPosition = window.scrollY;\n-            document.body.style.width = `${document.body.offsetWidth}px`;\n-            document.body.style.position = \"fixed\";\n-            document.body.style.top = `-${oldSidebarScrollPosition}px`;\n-            if (mobile_topbar) {\n-                mobile_topbar.style.top = `${oldSidebarScrollPosition}px`;\n-                mobile_topbar.style.position = \"relative\";\n-            }\n-        } else {\n-            oldSidebarScrollPosition = null;\n-        }\n-    };\n-\n-    window.rustdocMobileScrollUnlock = function() {\n-        const mobile_topbar = document.querySelector(\".mobile-topbar\");\n-        if (oldSidebarScrollPosition !== null) {\n-            // This is to keep the scroll position on mobile.\n-            document.body.style.width = \"\";\n-            document.body.style.position = \"\";\n-            document.body.style.top = \"\";\n-            if (mobile_topbar) {\n-                mobile_topbar.style.top = \"\";\n-                mobile_topbar.style.position = \"\";\n-            }\n-            // The scroll position is lost when resetting the style, hence why we store it in\n-            // `oldSidebarScrollPosition`.\n-            window.scrollTo(0, oldSidebarScrollPosition);\n-            oldSidebarScrollPosition = null;\n-        }\n-    };\n-\n     function showSidebar() {\n         window.hideAllModals(false);\n-        window.rustdocMobileScrollLock();\n         const sidebar = document.getElementsByClassName(\"sidebar\")[0];\n         addClass(sidebar, \"shown\");\n     }\n \n     function hideSidebar() {\n-        window.rustdocMobileScrollUnlock();\n         const sidebar = document.getElementsByClassName(\"sidebar\")[0];\n         removeClass(sidebar, \"shown\");\n     }\n \n     window.addEventListener(\"resize\", () => {\n-        if (window.innerWidth > window.RUSTDOC_MOBILE_BREAKPOINT &&\n-            oldSidebarScrollPosition !== null) {\n-            // If the user opens the sidebar in \"mobile\" mode, and then grows the browser window,\n-            // we need to switch away from mobile mode and make the main content area scrollable.\n-            hideSidebar();\n-        }\n         if (window.CURRENT_TOOLTIP_ELEMENT) {\n             // As a workaround to the behavior of `contains: layout` used in doc togglers,\n             // tooltip popovers are positioned using javascript."}, {"sha": "9aa75517330cd5174c7c85ceba9b7793e1fbdaf8", "filename": "src/librustdoc/html/static/js/source-script.js", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsource-script.js", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsource-script.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsource-script.js?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -15,8 +15,13 @@ const NAME_OFFSET = 0;\n const DIRS_OFFSET = 1;\n const FILES_OFFSET = 2;\n \n+// WARNING: RUSTDOC_MOBILE_BREAKPOINT MEDIA QUERY\n+// If you update this line, then you also need to update the media query with the same\n+// warning in rustdoc.css\n+const RUSTDOC_MOBILE_BREAKPOINT = 700;\n+\n function closeSidebarIfMobile() {\n-    if (window.innerWidth < window.RUSTDOC_MOBILE_BREAKPOINT) {\n+    if (window.innerWidth < RUSTDOC_MOBILE_BREAKPOINT) {\n         updateLocalStorage(\"source-sidebar-show\", \"false\");\n     }\n }\n@@ -69,12 +74,10 @@ function createDirEntry(elem, parent, fullPath, hasFoundFile) {\n function toggleSidebar() {\n     const child = this.parentNode.children[0];\n     if (child.innerText === \">\") {\n-        window.rustdocMobileScrollLock();\n         addClass(document.documentElement, \"source-sidebar-expanded\");\n         child.innerText = \"<\";\n         updateLocalStorage(\"source-sidebar-show\", \"true\");\n     } else {\n-        window.rustdocMobileScrollUnlock();\n         removeClass(document.documentElement, \"source-sidebar-expanded\");\n         child.innerText = \">\";\n         updateLocalStorage(\"source-sidebar-show\", \"false\");"}, {"sha": "9133f899af60d79131c1c3969eb418ba53ff295d", "filename": "src/librustdoc/html/templates/page.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fpage.html", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fpage.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fpage.html?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -64,7 +64,7 @@\n     </noscript> {# #}\n     {% if layout.css_file_extension.is_some() %}\n         <link rel=\"stylesheet\" {#+ #}\n-            href=\"{{static_root_path|safe}}theme{{page.resource_suffix}}.css\"> {# #}\n+            href=\"{{page.root_path|safe}}theme{{page.resource_suffix}}.css\"> {# #}\n     {% endif %}\n     {% if !layout.favicon.is_empty() %}\n         <link rel=\"icon\" href=\"{{layout.favicon}}\"> {# #}"}, {"sha": "b3640eab95339e2445e2b3fb7c00811eb581333a", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -7,14 +7,14 @@\n #![feature(assert_matches)]\n #![feature(box_patterns)]\n #![feature(drain_filter)]\n-#![feature(is_terminal)]\n #![feature(let_chains)]\n #![feature(test)]\n #![feature(never_type)]\n #![feature(lazy_cell)]\n #![feature(type_ascription)]\n #![feature(iter_intersperse)]\n #![feature(type_alias_impl_trait)]\n+#![cfg_attr(not(bootstrap), feature(impl_trait_in_assoc_type))]\n #![recursion_limit = \"256\"]\n #![warn(rustc::internal)]\n #![allow(clippy::collapsible_if, clippy::collapsible_else_if)]"}, {"sha": "f54b70b417d77768db14c946af6acb532e58b6a6", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -133,7 +133,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         // is declared but also a reexport of itself producing two exports of the same\n         // macro in the same module.\n         let mut inserted = FxHashSet::default();\n-        for export in self.cx.tcx.module_reexports(CRATE_DEF_ID) {\n+        for export in self.cx.tcx.module_children_reexports(CRATE_DEF_ID) {\n             if let Res::Def(DefKind::Macro(_), def_id) = export.res &&\n                 let Some(local_def_id) = def_id.as_local() &&\n                 self.cx.tcx.has_attr(def_id, sym::macro_export) &&"}, {"sha": "3cf8ceed62036997246c072979ffc832a6be6f0e", "filename": "src/rustdoc-json-types/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Frustdoc-json-types%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Frustdoc-json-types%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc-json-types%2Flib.rs?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -550,7 +550,7 @@ pub enum Type {\n     DynTrait(DynTrait),\n     /// Parameterized types\n     Generic(String),\n-    /// Built in numberic (i*, u*, f*) types, bool, and char\n+    /// Built in numeric (i*, u*, f*) types, bool, and char\n     Primitive(String),\n     /// `extern \"ABI\" fn`\n     FunctionPointer(Box<FunctionPointer>),"}, {"sha": "84b7041fd2745ee6b3b4a150314f81aabb78e6b2", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -1 +1 @@\n-Subproject commit 0e474cfd7b16b018cf46e95da3f6a5b2f1f6a9e7\n+Subproject commit 84b7041fd2745ee6b3b4a150314f81aabb78e6b2"}, {"sha": "4d80d3ce63dac89aae6de38076d10a9feb89e047", "filename": "src/tools/clippy/.cargo/config.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Ftools%2Fclippy%2F.cargo%2Fconfig.toml", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Ftools%2Fclippy%2F.cargo%2Fconfig.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.cargo%2Fconfig.toml?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -11,3 +11,6 @@ target-dir = \"target\"\n \n [unstable]\n binary-dep-depinfo = true\n+\n+[profile.dev]\n+split-debuginfo = \"unpacked\""}, {"sha": "bc7642bf8c7c927999317658220a129c439c1f09", "filename": "src/tools/clippy/.editorconfig", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Ftools%2Fclippy%2F.editorconfig", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Ftools%2Fclippy%2F.editorconfig", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.editorconfig?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -11,6 +11,7 @@ trim_trailing_whitespace = true\n insert_final_newline = true\n indent_style = space\n indent_size = 4\n+max_line_length = 120\n \n [*.md]\n # double whitespace at end of line"}, {"sha": "93198aabdb5f5ae8f04369e580ee1ca54ce7f00f", "filename": "src/tools/clippy/.github/workflows/clippy_bors.yml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_bors.yml", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_bors.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_bors.yml?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -180,6 +180,8 @@ jobs:\n \n     # Run\n     - name: Build Integration Test\n+      env:\n+        CARGO_PROFILE_DEV_SPLIT_DEBUGINFO: off\n       run: cargo test --test integration --features integration --no-run\n \n     # Upload"}, {"sha": "116058b7c753843d68e4e0409f959bcb5f864129", "filename": "src/tools/clippy/.github/workflows/remark.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fremark.yml", "raw_url": "https://github.com/rust-lang/rust/raw/06707ab30f06d189636cb219cc689f19eda9a2bb/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fremark.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fremark.yml?ref=06707ab30f06d189636cb219cc689f19eda9a2bb", "patch": "@@ -29,7 +29,7 @@ jobs:\n     - name: Install mdbook\n       run: |\n         mkdir mdbook\n-        curl -Lf https://github.com/rust-lang/mdBook/releases/download/v0.4.18/mdbook-v0.4.18-x86_64-unknown-linux-gnu.tar.gz | tar -xz --directory=./mdbook\n+        curl -Lf https://github.com/rust-lang/mdBook/releases/download/v0.4.28/mdbook-v0.4.28-x86_64-unknown-linux-gnu.tar.gz | tar -xz --directory=./mdbook\n         echo `pwd`/mdbook >> $GITHUB_PATH\n \n     # Run"}]}