{"sha": "f8fbc6da3c467b27793c35c6e105053c9d092447", "node_id": "C_kwDOAAsO6NoAKGY4ZmJjNmRhM2M0NjdiMjc3OTNjMzVjNmUxMDUwNTNjOWQwOTI0NDc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-27T19:54:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-27T19:54:04Z"}, "message": "Auto merge of #2702 - RalfJung:rustup, r=RalfJung\n\nRustup\n\nNo changes happened on the rustc side, but I want to do a push next and would rather make josh's life easier by integrating some recent history first.", "tree": {"sha": "7dd601ec2ec68fea1cef829a5296be7c3b29a437", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7dd601ec2ec68fea1cef829a5296be7c3b29a437"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8fbc6da3c467b27793c35c6e105053c9d092447", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8fbc6da3c467b27793c35c6e105053c9d092447", "html_url": "https://github.com/rust-lang/rust/commit/f8fbc6da3c467b27793c35c6e105053c9d092447", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8fbc6da3c467b27793c35c6e105053c9d092447/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66354f00430eebb88d33de02326d7ca9196bd61a", "url": "https://api.github.com/repos/rust-lang/rust/commits/66354f00430eebb88d33de02326d7ca9196bd61a", "html_url": "https://github.com/rust-lang/rust/commit/66354f00430eebb88d33de02326d7ca9196bd61a"}, {"sha": "598c3da62735ec5bc8459ce3f0d718e44ac3e775", "url": "https://api.github.com/repos/rust-lang/rust/commits/598c3da62735ec5bc8459ce3f0d718e44ac3e775", "html_url": "https://github.com/rust-lang/rust/commit/598c3da62735ec5bc8459ce3f0d718e44ac3e775"}], "stats": {"total": 59286, "additions": 27668, "deletions": 31618}, "files": [{"sha": "ebbed11d04b8d775c98b0c020db6db8f3ee42172", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -96,6 +96,9 @@ jobs:\n       - name: install sccache\n         run: src/ci/scripts/install-sccache.sh\n         if: success() && !env.SKIP_JOB\n+      - name: select Xcode\n+        run: src/ci/scripts/select-xcode.sh\n+        if: success() && !env.SKIP_JOB\n       - name: install clang\n         run: src/ci/scripts/install-clang.sh\n         if: success() && !env.SKIP_JOB\n@@ -301,6 +304,7 @@ jobs:\n               RUST_CONFIGURE_ARGS: \"--enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc --set llvm.ninja=false\"\n               RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n               MACOSX_DEPLOYMENT_TARGET: 10.7\n+              SELECT_XCODE: /Applications/Xcode_13.4.1.app\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n@@ -312,6 +316,7 @@ jobs:\n               RUST_CONFIGURE_ARGS: \"--enable-sanitizers --enable-profiler --set rust.jemalloc --set llvm.ninja=false\"\n               RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n               MACOSX_DEPLOYMENT_TARGET: 10.7\n+              SELECT_XCODE: /Applications/Xcode_13.4.1.app\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n@@ -322,6 +327,7 @@ jobs:\n               RUST_CONFIGURE_ARGS: \"--enable-extended --enable-profiler --set rust.jemalloc --set llvm.ninja=false\"\n               RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n               MACOSX_DEPLOYMENT_TARGET: 10.7\n+              SELECT_XCODE: /Applications/Xcode_13.4.1.app\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n@@ -353,6 +359,7 @@ jobs:\n               SCRIPT: \"./x.py dist bootstrap --include-default-paths --stage 2\"\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-apple-darwin --host=aarch64-apple-darwin --target=aarch64-apple-darwin --enable-full-tools --enable-sanitizers --enable-profiler --disable-docs --set rust.jemalloc --set llvm.ninja=false\"\n               RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+              SELECT_XCODE: /Applications/Xcode_13.4.1.app\n               USE_XCODE_CLANG: 1\n               MACOSX_DEPLOYMENT_TARGET: 11.0\n               MACOSX_STD_DEPLOYMENT_TARGET: 11.0\n@@ -503,6 +510,9 @@ jobs:\n       - name: install sccache\n         run: src/ci/scripts/install-sccache.sh\n         if: success() && !env.SKIP_JOB\n+      - name: select Xcode\n+        run: src/ci/scripts/select-xcode.sh\n+        if: success() && !env.SKIP_JOB\n       - name: install clang\n         run: src/ci/scripts/install-clang.sh\n         if: success() && !env.SKIP_JOB\n@@ -615,6 +625,9 @@ jobs:\n       - name: install sccache\n         run: src/ci/scripts/install-sccache.sh\n         if: success() && !env.SKIP_JOB\n+      - name: select Xcode\n+        run: src/ci/scripts/select-xcode.sh\n+        if: success() && !env.SKIP_JOB\n       - name: install clang\n         run: src/ci/scripts/install-clang.sh\n         if: success() && !env.SKIP_JOB"}, {"sha": "d8612b3a2561b62989edaf3a72b6f8a580c1e2d7", "filename": "Cargo.lock", "status": "modified", "additions": 47, "deletions": 68, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -446,7 +446,7 @@ dependencies = [\n  \"jobserver\",\n  \"libc\",\n  \"log\",\n- \"miow 0.4.0\",\n+ \"miow 0.5.0\",\n  \"same-file\",\n  \"shell-escape\",\n  \"tempfile\",\n@@ -498,10 +498,6 @@ name = \"cfg-if\"\n version = \"0.1.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n-dependencies = [\n- \"compiler_builtins\",\n- \"rustc-std-workspace-core\",\n-]\n \n [[package]]\n name = \"cfg-if\"\n@@ -652,7 +648,7 @@ dependencies = [\n \n [[package]]\n name = \"clippy\"\n-version = \"0.1.66\"\n+version = \"0.1.67\"\n dependencies = [\n  \"clippy_lints\",\n  \"clippy_utils\",\n@@ -689,16 +685,16 @@ dependencies = [\n  \"itertools\",\n  \"opener\",\n  \"shell-escape\",\n- \"tempfile\",\n  \"walkdir\",\n ]\n \n [[package]]\n name = \"clippy_lints\"\n-version = \"0.1.66\"\n+version = \"0.1.67\"\n dependencies = [\n  \"cargo_metadata 0.14.0\",\n  \"clippy_utils\",\n+ \"declare_clippy_lint\",\n  \"if_chain\",\n  \"itertools\",\n  \"pulldown-cmark\",\n@@ -717,7 +713,7 @@ dependencies = [\n \n [[package]]\n name = \"clippy_utils\"\n-version = \"0.1.66\"\n+version = \"0.1.67\"\n dependencies = [\n  \"arrayvec\",\n  \"if_chain\",\n@@ -793,9 +789,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.82\"\n+version = \"0.1.84\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"18cd7635fea7bb481ea543b392789844c1ad581299da70184c7175ce3af76603\"\n+checksum = \"989b2c1ca6e90ad06fdc69d1d1862fa28d27a977be6d92ae2fa762cf61fe0b10\"\n dependencies = [\n  \"cc\",\n  \"rustc-std-workspace-core\",\n@@ -1044,6 +1040,15 @@ version = \"2.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"a0afaad2b26fa326569eb264b1363e8ae3357618c43982b3f285f0774ce76b69\"\n \n+[[package]]\n+name = \"declare_clippy_lint\"\n+version = \"0.1.67\"\n+dependencies = [\n+ \"itertools\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n [[package]]\n name = \"derive-new\"\n version = \"0.5.8\"\n@@ -2306,11 +2311,11 @@ dependencies = [\n \n [[package]]\n name = \"miow\"\n-version = \"0.4.0\"\n+version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a7377f7792b3afb6a3cba68daa54ca23c032137010460d667fda53a8d66be00e\"\n+checksum = \"52ffbca2f655e33c08be35d87278e5b18b89550a37dbd598c20db92f6a471123\"\n dependencies = [\n- \"windows-sys 0.28.0\",\n+ \"windows-sys\",\n ]\n \n [[package]]\n@@ -2587,7 +2592,7 @@ dependencies = [\n  \"libc\",\n  \"redox_syscall\",\n  \"smallvec\",\n- \"windows-sys 0.42.0\",\n+ \"windows-sys\",\n ]\n \n [[package]]\n@@ -2850,9 +2855,9 @@ checksum = \"07589615d719a60c8dd8a4622e7946465dfef20d1a428f969e3443e7386d5f45\"\n \n [[package]]\n name = \"quote\"\n-version = \"1.0.18\"\n+version = \"1.0.21\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a1feb54ed693b93a84e14094943b84b7c4eae204c512b7ccb95ab0c66d278ad1\"\n+checksum = \"bbe448f377a7d6961e30f5955f9b8d106c3f5e449d493ee1b125c1d43c2b5179\"\n dependencies = [\n  \"proc-macro2\",\n ]\n@@ -3197,6 +3202,20 @@ dependencies = [\n  \"winapi\",\n ]\n \n+[[package]]\n+name = \"rustc_abi\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"bitflags\",\n+ \"rand 0.8.5\",\n+ \"rand_xoshiro\",\n+ \"rustc_data_structures\",\n+ \"rustc_index\",\n+ \"rustc_macros\",\n+ \"rustc_serialize\",\n+ \"tracing\",\n+]\n+\n [[package]]\n name = \"rustc_apfloat\"\n version = \"0.0.0\"\n@@ -3433,6 +3452,7 @@ dependencies = [\n name = \"rustc_const_eval\"\n version = \"0.0.0\"\n dependencies = [\n+ \"either\",\n  \"rustc_apfloat\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n@@ -3927,6 +3947,7 @@ dependencies = [\n name = \"rustc_mir_build\"\n version = \"0.0.0\"\n dependencies = [\n+ \"either\",\n  \"rustc_apfloat\",\n  \"rustc_arena\",\n  \"rustc_ast\",\n@@ -3973,6 +3994,7 @@ name = \"rustc_mir_transform\"\n version = \"0.0.0\"\n dependencies = [\n  \"coverage_test_macros\",\n+ \"either\",\n  \"itertools\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n@@ -4273,6 +4295,7 @@ name = \"rustc_target\"\n version = \"0.0.0\"\n dependencies = [\n  \"bitflags\",\n+ \"rustc_abi\",\n  \"rustc_data_structures\",\n  \"rustc_feature\",\n  \"rustc_index\",\n@@ -4328,6 +4351,7 @@ dependencies = [\n  \"rustc_infer\",\n  \"rustc_middle\",\n  \"rustc_span\",\n+ \"rustc_target\",\n  \"rustc_trait_selection\",\n  \"smallvec\",\n  \"tracing\",\n@@ -4352,8 +4376,6 @@ dependencies = [\n name = \"rustc_ty_utils\"\n version = \"0.0.0\"\n dependencies = [\n- \"rand 0.8.5\",\n- \"rand_xoshiro\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_hir\",\n@@ -4931,7 +4953,7 @@ dependencies = [\n name = \"test\"\n version = \"0.0.0\"\n dependencies = [\n- \"cfg-if 0.1.10\",\n+ \"cfg-if 1.0.0\",\n  \"core\",\n  \"getopts\",\n  \"libc\",\n@@ -5553,32 +5575,19 @@ version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n \n-[[package]]\n-name = \"windows-sys\"\n-version = \"0.28.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"82ca39602d5cbfa692c4b67e3bcbb2751477355141c1ed434c94da4186836ff6\"\n-dependencies = [\n- \"windows_aarch64_msvc 0.28.0\",\n- \"windows_i686_gnu 0.28.0\",\n- \"windows_i686_msvc 0.28.0\",\n- \"windows_x86_64_gnu 0.28.0\",\n- \"windows_x86_64_msvc 0.28.0\",\n-]\n-\n [[package]]\n name = \"windows-sys\"\n version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"5a3e1820f08b8513f676f7ab6c1f99ff312fb97b553d30ff4dd86f9f15728aa7\"\n dependencies = [\n  \"windows_aarch64_gnullvm\",\n- \"windows_aarch64_msvc 0.42.0\",\n- \"windows_i686_gnu 0.42.0\",\n- \"windows_i686_msvc 0.42.0\",\n- \"windows_x86_64_gnu 0.42.0\",\n+ \"windows_aarch64_msvc\",\n+ \"windows_i686_gnu\",\n+ \"windows_i686_msvc\",\n+ \"windows_x86_64_gnu\",\n  \"windows_x86_64_gnullvm\",\n- \"windows_x86_64_msvc 0.42.0\",\n+ \"windows_x86_64_msvc\",\n ]\n \n [[package]]\n@@ -5587,48 +5596,24 @@ version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"41d2aa71f6f0cbe00ae5167d90ef3cfe66527d6f613ca78ac8024c3ccab9a19e\"\n \n-[[package]]\n-name = \"windows_aarch64_msvc\"\n-version = \"0.28.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"52695a41e536859d5308cc613b4a022261a274390b25bd29dfff4bf08505f3c2\"\n-\n [[package]]\n name = \"windows_aarch64_msvc\"\n version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"dd0f252f5a35cac83d6311b2e795981f5ee6e67eb1f9a7f64eb4500fbc4dcdb4\"\n \n-[[package]]\n-name = \"windows_i686_gnu\"\n-version = \"0.28.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f54725ac23affef038fecb177de6c9bf065787c2f432f79e3c373da92f3e1d8a\"\n-\n [[package]]\n name = \"windows_i686_gnu\"\n version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"fbeae19f6716841636c28d695375df17562ca208b2b7d0dc47635a50ae6c5de7\"\n \n-[[package]]\n-name = \"windows_i686_msvc\"\n-version = \"0.28.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"51d5158a43cc43623c0729d1ad6647e62fa384a3d135fd15108d37c683461f64\"\n-\n [[package]]\n name = \"windows_i686_msvc\"\n version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"84c12f65daa39dd2babe6e442988fc329d6243fdce47d7d2d155b8d874862246\"\n \n-[[package]]\n-name = \"windows_x86_64_gnu\"\n-version = \"0.28.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bc31f409f565611535130cfe7ee8e6655d3fa99c1c61013981e491921b5ce954\"\n-\n [[package]]\n name = \"windows_x86_64_gnu\"\n version = \"0.42.0\"\n@@ -5641,12 +5626,6 @@ version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"09d525d2ba30eeb3297665bd434a54297e4170c7f1a44cad4ef58095b4cd2028\"\n \n-[[package]]\n-name = \"windows_x86_64_msvc\"\n-version = \"0.28.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3f2b8c7cbd3bfdddd9ab98769f9746a7fad1bca236554cd032b78d768bc0e89f\"\n-\n [[package]]\n name = \"windows_x86_64_msvc\"\n version = \"0.42.0\""}, {"sha": "48b199cb8eed9dad92c33e20ffb6390b2062992b", "filename": "compiler/rustc_abi/Cargo.toml", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_abi%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_abi%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2FCargo.toml?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -0,0 +1,24 @@\n+[package]\n+name = \"rustc_abi\"\n+version = \"0.0.0\"\n+edition = \"2021\"\n+\n+[dependencies]\n+bitflags = \"1.2.1\"\n+tracing = \"0.1\"\n+rand = { version = \"0.8.4\", default-features = false, optional = true }\n+rand_xoshiro = { version = \"0.6.0\", optional = true }\n+rustc_data_structures = { path = \"../rustc_data_structures\", optional = true  }\n+rustc_index = { path = \"../rustc_index\", default-features = false }\n+rustc_macros = { path = \"../rustc_macros\", optional = true }\n+rustc_serialize = { path = \"../rustc_serialize\", optional = true  }\n+\n+[features]\n+default = [\"nightly\", \"randomize\"]\n+randomize = [\"rand\", \"rand_xoshiro\"]\n+nightly = [\n+    \"rustc_data_structures\",\n+    \"rustc_index/nightly\",\n+    \"rustc_macros\",\n+    \"rustc_serialize\",\n+]"}, {"sha": "11e7b80f85efd1a7a49c68c4220105de4589d41e", "filename": "compiler/rustc_abi/src/layout.rs", "status": "added", "additions": 945, "deletions": 0, "changes": 945, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flayout.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -0,0 +1,945 @@\n+use super::*;\n+use std::{\n+    borrow::Borrow,\n+    cmp,\n+    fmt::Debug,\n+    iter,\n+    ops::{Bound, Deref},\n+};\n+\n+#[cfg(feature = \"randomize\")]\n+use rand::{seq::SliceRandom, SeedableRng};\n+#[cfg(feature = \"randomize\")]\n+use rand_xoshiro::Xoshiro128StarStar;\n+\n+use tracing::debug;\n+\n+// Invert a bijective mapping, i.e. `invert(map)[y] = x` if `map[x] = y`.\n+// This is used to go between `memory_index` (source field order to memory order)\n+// and `inverse_memory_index` (memory order to source field order).\n+// See also `FieldsShape::Arbitrary::memory_index` for more details.\n+// FIXME(eddyb) build a better abstraction for permutations, if possible.\n+fn invert_mapping(map: &[u32]) -> Vec<u32> {\n+    let mut inverse = vec![0; map.len()];\n+    for i in 0..map.len() {\n+        inverse[map[i] as usize] = i as u32;\n+    }\n+    inverse\n+}\n+\n+pub trait LayoutCalculator {\n+    type TargetDataLayoutRef: Borrow<TargetDataLayout>;\n+\n+    fn delay_bug(&self, txt: &str);\n+    fn current_data_layout(&self) -> Self::TargetDataLayoutRef;\n+\n+    fn scalar_pair<V: Idx>(&self, a: Scalar, b: Scalar) -> LayoutS<V> {\n+        let dl = self.current_data_layout();\n+        let dl = dl.borrow();\n+        let b_align = b.align(dl);\n+        let align = a.align(dl).max(b_align).max(dl.aggregate_align);\n+        let b_offset = a.size(dl).align_to(b_align.abi);\n+        let size = (b_offset + b.size(dl)).align_to(align.abi);\n+\n+        // HACK(nox): We iter on `b` and then `a` because `max_by_key`\n+        // returns the last maximum.\n+        let largest_niche = Niche::from_scalar(dl, b_offset, b)\n+            .into_iter()\n+            .chain(Niche::from_scalar(dl, Size::ZERO, a))\n+            .max_by_key(|niche| niche.available(dl));\n+\n+        LayoutS {\n+            variants: Variants::Single { index: V::new(0) },\n+            fields: FieldsShape::Arbitrary {\n+                offsets: vec![Size::ZERO, b_offset],\n+                memory_index: vec![0, 1],\n+            },\n+            abi: Abi::ScalarPair(a, b),\n+            largest_niche,\n+            align,\n+            size,\n+        }\n+    }\n+\n+    fn univariant<'a, V: Idx, F: Deref<Target = &'a LayoutS<V>> + Debug>(\n+        &self,\n+        dl: &TargetDataLayout,\n+        fields: &[F],\n+        repr: &ReprOptions,\n+        kind: StructKind,\n+    ) -> Option<LayoutS<V>> {\n+        let pack = repr.pack;\n+        let mut align = if pack.is_some() { dl.i8_align } else { dl.aggregate_align };\n+        let mut inverse_memory_index: Vec<u32> = (0..fields.len() as u32).collect();\n+        let optimize = !repr.inhibit_struct_field_reordering_opt();\n+        if optimize {\n+            let end =\n+                if let StructKind::MaybeUnsized = kind { fields.len() - 1 } else { fields.len() };\n+            let optimizing = &mut inverse_memory_index[..end];\n+            let effective_field_align = |f: &F| {\n+                if let Some(pack) = pack {\n+                    // return the packed alignment in bytes\n+                    f.align.abi.min(pack).bytes()\n+                } else {\n+                    // returns log2(effective-align).\n+                    // This is ok since `pack` applies to all fields equally.\n+                    // The calculation assumes that size is an integer multiple of align, except for ZSTs.\n+                    //\n+                    // group [u8; 4] with align-4 or [u8; 6] with align-2 fields\n+                    f.align.abi.bytes().max(f.size.bytes()).trailing_zeros() as u64\n+                }\n+            };\n+\n+            // If `-Z randomize-layout` was enabled for the type definition we can shuffle\n+            // the field ordering to try and catch some code making assumptions about layouts\n+            // we don't guarantee\n+            if repr.can_randomize_type_layout() && cfg!(feature = \"randomize\") {\n+                #[cfg(feature = \"randomize\")]\n+                {\n+                    // `ReprOptions.layout_seed` is a deterministic seed that we can use to\n+                    // randomize field ordering with\n+                    let mut rng = Xoshiro128StarStar::seed_from_u64(repr.field_shuffle_seed);\n+\n+                    // Shuffle the ordering of the fields\n+                    optimizing.shuffle(&mut rng);\n+                }\n+                // Otherwise we just leave things alone and actually optimize the type's fields\n+            } else {\n+                match kind {\n+                    StructKind::AlwaysSized | StructKind::MaybeUnsized => {\n+                        optimizing.sort_by_key(|&x| {\n+                            // Place ZSTs first to avoid \"interesting offsets\",\n+                            // especially with only one or two non-ZST fields.\n+                            // Then place largest alignments first, largest niches within an alignment group last\n+                            let f = &fields[x as usize];\n+                            let niche_size = f.largest_niche.map_or(0, |n| n.available(dl));\n+                            (!f.is_zst(), cmp::Reverse(effective_field_align(f)), niche_size)\n+                        });\n+                    }\n+\n+                    StructKind::Prefixed(..) => {\n+                        // Sort in ascending alignment so that the layout stays optimal\n+                        // regardless of the prefix.\n+                        // And put the largest niche in an alignment group at the end\n+                        // so it can be used as discriminant in jagged enums\n+                        optimizing.sort_by_key(|&x| {\n+                            let f = &fields[x as usize];\n+                            let niche_size = f.largest_niche.map_or(0, |n| n.available(dl));\n+                            (effective_field_align(f), niche_size)\n+                        });\n+                    }\n+                }\n+\n+                // FIXME(Kixiron): We can always shuffle fields within a given alignment class\n+                //                 regardless of the status of `-Z randomize-layout`\n+            }\n+        }\n+        // inverse_memory_index holds field indices by increasing memory offset.\n+        // That is, if field 5 has offset 0, the first element of inverse_memory_index is 5.\n+        // We now write field offsets to the corresponding offset slot;\n+        // field 5 with offset 0 puts 0 in offsets[5].\n+        // At the bottom of this function, we invert `inverse_memory_index` to\n+        // produce `memory_index` (see `invert_mapping`).\n+        let mut sized = true;\n+        let mut offsets = vec![Size::ZERO; fields.len()];\n+        let mut offset = Size::ZERO;\n+        let mut largest_niche = None;\n+        let mut largest_niche_available = 0;\n+        if let StructKind::Prefixed(prefix_size, prefix_align) = kind {\n+            let prefix_align =\n+                if let Some(pack) = pack { prefix_align.min(pack) } else { prefix_align };\n+            align = align.max(AbiAndPrefAlign::new(prefix_align));\n+            offset = prefix_size.align_to(prefix_align);\n+        }\n+        for &i in &inverse_memory_index {\n+            let field = &fields[i as usize];\n+            if !sized {\n+                self.delay_bug(&format!(\n+                    \"univariant: field #{} comes after unsized field\",\n+                    offsets.len(),\n+                ));\n+            }\n+\n+            if field.is_unsized() {\n+                sized = false;\n+            }\n+\n+            // Invariant: offset < dl.obj_size_bound() <= 1<<61\n+            let field_align = if let Some(pack) = pack {\n+                field.align.min(AbiAndPrefAlign::new(pack))\n+            } else {\n+                field.align\n+            };\n+            offset = offset.align_to(field_align.abi);\n+            align = align.max(field_align);\n+\n+            debug!(\"univariant offset: {:?} field: {:#?}\", offset, field);\n+            offsets[i as usize] = offset;\n+\n+            if let Some(mut niche) = field.largest_niche {\n+                let available = niche.available(dl);\n+                if available > largest_niche_available {\n+                    largest_niche_available = available;\n+                    niche.offset += offset;\n+                    largest_niche = Some(niche);\n+                }\n+            }\n+\n+            offset = offset.checked_add(field.size, dl)?;\n+        }\n+        if let Some(repr_align) = repr.align {\n+            align = align.max(AbiAndPrefAlign::new(repr_align));\n+        }\n+        debug!(\"univariant min_size: {:?}\", offset);\n+        let min_size = offset;\n+        // As stated above, inverse_memory_index holds field indices by increasing offset.\n+        // This makes it an already-sorted view of the offsets vec.\n+        // To invert it, consider:\n+        // If field 5 has offset 0, offsets[0] is 5, and memory_index[5] should be 0.\n+        // Field 5 would be the first element, so memory_index is i:\n+        // Note: if we didn't optimize, it's already right.\n+        let memory_index =\n+            if optimize { invert_mapping(&inverse_memory_index) } else { inverse_memory_index };\n+        let size = min_size.align_to(align.abi);\n+        let mut abi = Abi::Aggregate { sized };\n+        // Unpack newtype ABIs and find scalar pairs.\n+        if sized && size.bytes() > 0 {\n+            // All other fields must be ZSTs.\n+            let mut non_zst_fields = fields.iter().enumerate().filter(|&(_, f)| !f.is_zst());\n+\n+            match (non_zst_fields.next(), non_zst_fields.next(), non_zst_fields.next()) {\n+                // We have exactly one non-ZST field.\n+                (Some((i, field)), None, None) => {\n+                    // Field fills the struct and it has a scalar or scalar pair ABI.\n+                    if offsets[i].bytes() == 0 && align.abi == field.align.abi && size == field.size\n+                    {\n+                        match field.abi {\n+                            // For plain scalars, or vectors of them, we can't unpack\n+                            // newtypes for `#[repr(C)]`, as that affects C ABIs.\n+                            Abi::Scalar(_) | Abi::Vector { .. } if optimize => {\n+                                abi = field.abi;\n+                            }\n+                            // But scalar pairs are Rust-specific and get\n+                            // treated as aggregates by C ABIs anyway.\n+                            Abi::ScalarPair(..) => {\n+                                abi = field.abi;\n+                            }\n+                            _ => {}\n+                        }\n+                    }\n+                }\n+\n+                // Two non-ZST fields, and they're both scalars.\n+                (Some((i, a)), Some((j, b)), None) => {\n+                    match (a.abi, b.abi) {\n+                        (Abi::Scalar(a), Abi::Scalar(b)) => {\n+                            // Order by the memory placement, not source order.\n+                            let ((i, a), (j, b)) = if offsets[i] < offsets[j] {\n+                                ((i, a), (j, b))\n+                            } else {\n+                                ((j, b), (i, a))\n+                            };\n+                            let pair = self.scalar_pair::<V>(a, b);\n+                            let pair_offsets = match pair.fields {\n+                                FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n+                                    assert_eq!(memory_index, &[0, 1]);\n+                                    offsets\n+                                }\n+                                _ => panic!(),\n+                            };\n+                            if offsets[i] == pair_offsets[0]\n+                                && offsets[j] == pair_offsets[1]\n+                                && align == pair.align\n+                                && size == pair.size\n+                            {\n+                                // We can use `ScalarPair` only when it matches our\n+                                // already computed layout (including `#[repr(C)]`).\n+                                abi = pair.abi;\n+                            }\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+\n+                _ => {}\n+            }\n+        }\n+        if fields.iter().any(|f| f.abi.is_uninhabited()) {\n+            abi = Abi::Uninhabited;\n+        }\n+        Some(LayoutS {\n+            variants: Variants::Single { index: V::new(0) },\n+            fields: FieldsShape::Arbitrary { offsets, memory_index },\n+            abi,\n+            largest_niche,\n+            align,\n+            size,\n+        })\n+    }\n+\n+    fn layout_of_never_type<V: Idx>(&self) -> LayoutS<V> {\n+        let dl = self.current_data_layout();\n+        let dl = dl.borrow();\n+        LayoutS {\n+            variants: Variants::Single { index: V::new(0) },\n+            fields: FieldsShape::Primitive,\n+            abi: Abi::Uninhabited,\n+            largest_niche: None,\n+            align: dl.i8_align,\n+            size: Size::ZERO,\n+        }\n+    }\n+\n+    fn layout_of_struct_or_enum<'a, V: Idx, F: Deref<Target = &'a LayoutS<V>> + Debug>(\n+        &self,\n+        repr: &ReprOptions,\n+        variants: &IndexVec<V, Vec<F>>,\n+        is_enum: bool,\n+        is_unsafe_cell: bool,\n+        scalar_valid_range: (Bound<u128>, Bound<u128>),\n+        discr_range_of_repr: impl Fn(i128, i128) -> (Integer, bool),\n+        discriminants: impl Iterator<Item = (V, i128)>,\n+        niche_optimize_enum: bool,\n+        always_sized: bool,\n+    ) -> Option<LayoutS<V>> {\n+        let dl = self.current_data_layout();\n+        let dl = dl.borrow();\n+\n+        let scalar_unit = |value: Primitive| {\n+            let size = value.size(dl);\n+            assert!(size.bits() <= 128);\n+            Scalar::Initialized { value, valid_range: WrappingRange::full(size) }\n+        };\n+\n+        // A variant is absent if it's uninhabited and only has ZST fields.\n+        // Present uninhabited variants only require space for their fields,\n+        // but *not* an encoding of the discriminant (e.g., a tag value).\n+        // See issue #49298 for more details on the need to leave space\n+        // for non-ZST uninhabited data (mostly partial initialization).\n+        let absent = |fields: &[F]| {\n+            let uninhabited = fields.iter().any(|f| f.abi.is_uninhabited());\n+            let is_zst = fields.iter().all(|f| f.is_zst());\n+            uninhabited && is_zst\n+        };\n+        let (present_first, present_second) = {\n+            let mut present_variants = variants\n+                .iter_enumerated()\n+                .filter_map(|(i, v)| if absent(v) { None } else { Some(i) });\n+            (present_variants.next(), present_variants.next())\n+        };\n+        let present_first = match present_first {\n+            Some(present_first) => present_first,\n+            // Uninhabited because it has no variants, or only absent ones.\n+            None if is_enum => {\n+                return Some(self.layout_of_never_type());\n+            }\n+            // If it's a struct, still compute a layout so that we can still compute the\n+            // field offsets.\n+            None => V::new(0),\n+        };\n+\n+        let is_struct = !is_enum ||\n+                    // Only one variant is present.\n+                    (present_second.is_none() &&\n+                        // Representation optimizations are allowed.\n+                        !repr.inhibit_enum_layout_opt());\n+        if is_struct {\n+            // Struct, or univariant enum equivalent to a struct.\n+            // (Typechecking will reject discriminant-sizing attrs.)\n+\n+            let v = present_first;\n+            let kind = if is_enum || variants[v].is_empty() {\n+                StructKind::AlwaysSized\n+            } else {\n+                if !always_sized { StructKind::MaybeUnsized } else { StructKind::AlwaysSized }\n+            };\n+\n+            let mut st = self.univariant(dl, &variants[v], &repr, kind)?;\n+            st.variants = Variants::Single { index: v };\n+\n+            if is_unsafe_cell {\n+                let hide_niches = |scalar: &mut _| match scalar {\n+                    Scalar::Initialized { value, valid_range } => {\n+                        *valid_range = WrappingRange::full(value.size(dl))\n+                    }\n+                    // Already doesn't have any niches\n+                    Scalar::Union { .. } => {}\n+                };\n+                match &mut st.abi {\n+                    Abi::Uninhabited => {}\n+                    Abi::Scalar(scalar) => hide_niches(scalar),\n+                    Abi::ScalarPair(a, b) => {\n+                        hide_niches(a);\n+                        hide_niches(b);\n+                    }\n+                    Abi::Vector { element, count: _ } => hide_niches(element),\n+                    Abi::Aggregate { sized: _ } => {}\n+                }\n+                st.largest_niche = None;\n+                return Some(st);\n+            }\n+\n+            let (start, end) = scalar_valid_range;\n+            match st.abi {\n+                Abi::Scalar(ref mut scalar) | Abi::ScalarPair(ref mut scalar, _) => {\n+                    // Enlarging validity ranges would result in missed\n+                    // optimizations, *not* wrongly assuming the inner\n+                    // value is valid. e.g. unions already enlarge validity ranges,\n+                    // because the values may be uninitialized.\n+                    //\n+                    // Because of that we only check that the start and end\n+                    // of the range is representable with this scalar type.\n+\n+                    let max_value = scalar.size(dl).unsigned_int_max();\n+                    if let Bound::Included(start) = start {\n+                        // FIXME(eddyb) this might be incorrect - it doesn't\n+                        // account for wrap-around (end < start) ranges.\n+                        assert!(start <= max_value, \"{start} > {max_value}\");\n+                        scalar.valid_range_mut().start = start;\n+                    }\n+                    if let Bound::Included(end) = end {\n+                        // FIXME(eddyb) this might be incorrect - it doesn't\n+                        // account for wrap-around (end < start) ranges.\n+                        assert!(end <= max_value, \"{end} > {max_value}\");\n+                        scalar.valid_range_mut().end = end;\n+                    }\n+\n+                    // Update `largest_niche` if we have introduced a larger niche.\n+                    let niche = Niche::from_scalar(dl, Size::ZERO, *scalar);\n+                    if let Some(niche) = niche {\n+                        match st.largest_niche {\n+                            Some(largest_niche) => {\n+                                // Replace the existing niche even if they're equal,\n+                                // because this one is at a lower offset.\n+                                if largest_niche.available(dl) <= niche.available(dl) {\n+                                    st.largest_niche = Some(niche);\n+                                }\n+                            }\n+                            None => st.largest_niche = Some(niche),\n+                        }\n+                    }\n+                }\n+                _ => assert!(\n+                    start == Bound::Unbounded && end == Bound::Unbounded,\n+                    \"nonscalar layout for layout_scalar_valid_range type: {:#?}\",\n+                    st,\n+                ),\n+            }\n+\n+            return Some(st);\n+        }\n+\n+        // At this point, we have handled all unions and\n+        // structs. (We have also handled univariant enums\n+        // that allow representation optimization.)\n+        assert!(is_enum);\n+\n+        // Until we've decided whether to use the tagged or\n+        // niche filling LayoutS, we don't want to intern the\n+        // variant layouts, so we can't store them in the\n+        // overall LayoutS. Store the overall LayoutS\n+        // and the variant LayoutSs here until then.\n+        struct TmpLayout<V: Idx> {\n+            layout: LayoutS<V>,\n+            variants: IndexVec<V, LayoutS<V>>,\n+        }\n+\n+        let calculate_niche_filling_layout = || -> Option<TmpLayout<V>> {\n+            if niche_optimize_enum {\n+                return None;\n+            }\n+\n+            if variants.len() < 2 {\n+                return None;\n+            }\n+\n+            let mut align = dl.aggregate_align;\n+            let mut variant_layouts = variants\n+                .iter_enumerated()\n+                .map(|(j, v)| {\n+                    let mut st = self.univariant(dl, v, &repr, StructKind::AlwaysSized)?;\n+                    st.variants = Variants::Single { index: j };\n+\n+                    align = align.max(st.align);\n+\n+                    Some(st)\n+                })\n+                .collect::<Option<IndexVec<V, _>>>()?;\n+\n+            let largest_variant_index = variant_layouts\n+                .iter_enumerated()\n+                .max_by_key(|(_i, layout)| layout.size.bytes())\n+                .map(|(i, _layout)| i)?;\n+\n+            let all_indices = (0..=variants.len() - 1).map(V::new);\n+            let needs_disc = |index: V| index != largest_variant_index && !absent(&variants[index]);\n+            let niche_variants = all_indices.clone().find(|v| needs_disc(*v)).unwrap().index()\n+                ..=all_indices.rev().find(|v| needs_disc(*v)).unwrap().index();\n+\n+            let count = niche_variants.size_hint().1.unwrap() as u128;\n+\n+            // Find the field with the largest niche\n+            let (field_index, niche, (niche_start, niche_scalar)) = variants[largest_variant_index]\n+                .iter()\n+                .enumerate()\n+                .filter_map(|(j, field)| Some((j, field.largest_niche?)))\n+                .max_by_key(|(_, niche)| niche.available(dl))\n+                .and_then(|(j, niche)| Some((j, niche, niche.reserve(dl, count)?)))?;\n+            let niche_offset =\n+                niche.offset + variant_layouts[largest_variant_index].fields.offset(field_index);\n+            let niche_size = niche.value.size(dl);\n+            let size = variant_layouts[largest_variant_index].size.align_to(align.abi);\n+\n+            let all_variants_fit = variant_layouts.iter_enumerated_mut().all(|(i, layout)| {\n+                if i == largest_variant_index {\n+                    return true;\n+                }\n+\n+                layout.largest_niche = None;\n+\n+                if layout.size <= niche_offset {\n+                    // This variant will fit before the niche.\n+                    return true;\n+                }\n+\n+                // Determine if it'll fit after the niche.\n+                let this_align = layout.align.abi;\n+                let this_offset = (niche_offset + niche_size).align_to(this_align);\n+\n+                if this_offset + layout.size > size {\n+                    return false;\n+                }\n+\n+                // It'll fit, but we need to make some adjustments.\n+                match layout.fields {\n+                    FieldsShape::Arbitrary { ref mut offsets, .. } => {\n+                        for (j, offset) in offsets.iter_mut().enumerate() {\n+                            if !variants[i][j].is_zst() {\n+                                *offset += this_offset;\n+                            }\n+                        }\n+                    }\n+                    _ => {\n+                        panic!(\"Layout of fields should be Arbitrary for variants\")\n+                    }\n+                }\n+\n+                // It can't be a Scalar or ScalarPair because the offset isn't 0.\n+                if !layout.abi.is_uninhabited() {\n+                    layout.abi = Abi::Aggregate { sized: true };\n+                }\n+                layout.size += this_offset;\n+\n+                true\n+            });\n+\n+            if !all_variants_fit {\n+                return None;\n+            }\n+\n+            let largest_niche = Niche::from_scalar(dl, niche_offset, niche_scalar);\n+\n+            let others_zst = variant_layouts\n+                .iter_enumerated()\n+                .all(|(i, layout)| i == largest_variant_index || layout.size == Size::ZERO);\n+            let same_size = size == variant_layouts[largest_variant_index].size;\n+            let same_align = align == variant_layouts[largest_variant_index].align;\n+\n+            let abi = if variant_layouts.iter().all(|v| v.abi.is_uninhabited()) {\n+                Abi::Uninhabited\n+            } else if same_size && same_align && others_zst {\n+                match variant_layouts[largest_variant_index].abi {\n+                    // When the total alignment and size match, we can use the\n+                    // same ABI as the scalar variant with the reserved niche.\n+                    Abi::Scalar(_) => Abi::Scalar(niche_scalar),\n+                    Abi::ScalarPair(first, second) => {\n+                        // Only the niche is guaranteed to be initialised,\n+                        // so use union layouts for the other primitive.\n+                        if niche_offset == Size::ZERO {\n+                            Abi::ScalarPair(niche_scalar, second.to_union())\n+                        } else {\n+                            Abi::ScalarPair(first.to_union(), niche_scalar)\n+                        }\n+                    }\n+                    _ => Abi::Aggregate { sized: true },\n+                }\n+            } else {\n+                Abi::Aggregate { sized: true }\n+            };\n+\n+            let layout = LayoutS {\n+                variants: Variants::Multiple {\n+                    tag: niche_scalar,\n+                    tag_encoding: TagEncoding::Niche {\n+                        untagged_variant: largest_variant_index,\n+                        niche_variants: (V::new(*niche_variants.start())\n+                            ..=V::new(*niche_variants.end())),\n+                        niche_start,\n+                    },\n+                    tag_field: 0,\n+                    variants: IndexVec::new(),\n+                },\n+                fields: FieldsShape::Arbitrary {\n+                    offsets: vec![niche_offset],\n+                    memory_index: vec![0],\n+                },\n+                abi,\n+                largest_niche,\n+                size,\n+                align,\n+            };\n+\n+            Some(TmpLayout { layout, variants: variant_layouts })\n+        };\n+\n+        let niche_filling_layout = calculate_niche_filling_layout();\n+\n+        let (mut min, mut max) = (i128::MAX, i128::MIN);\n+        let discr_type = repr.discr_type();\n+        let bits = Integer::from_attr(dl, discr_type).size().bits();\n+        for (i, mut val) in discriminants {\n+            if variants[i].iter().any(|f| f.abi.is_uninhabited()) {\n+                continue;\n+            }\n+            if discr_type.is_signed() {\n+                // sign extend the raw representation to be an i128\n+                val = (val << (128 - bits)) >> (128 - bits);\n+            }\n+            if val < min {\n+                min = val;\n+            }\n+            if val > max {\n+                max = val;\n+            }\n+        }\n+        // We might have no inhabited variants, so pretend there's at least one.\n+        if (min, max) == (i128::MAX, i128::MIN) {\n+            min = 0;\n+            max = 0;\n+        }\n+        assert!(min <= max, \"discriminant range is {}...{}\", min, max);\n+        let (min_ity, signed) = discr_range_of_repr(min, max); //Integer::repr_discr(tcx, ty, &repr, min, max);\n+\n+        let mut align = dl.aggregate_align;\n+        let mut size = Size::ZERO;\n+\n+        // We're interested in the smallest alignment, so start large.\n+        let mut start_align = Align::from_bytes(256).unwrap();\n+        assert_eq!(Integer::for_align(dl, start_align), None);\n+\n+        // repr(C) on an enum tells us to make a (tag, union) layout,\n+        // so we need to grow the prefix alignment to be at least\n+        // the alignment of the union. (This value is used both for\n+        // determining the alignment of the overall enum, and the\n+        // determining the alignment of the payload after the tag.)\n+        let mut prefix_align = min_ity.align(dl).abi;\n+        if repr.c() {\n+            for fields in variants {\n+                for field in fields {\n+                    prefix_align = prefix_align.max(field.align.abi);\n+                }\n+            }\n+        }\n+\n+        // Create the set of structs that represent each variant.\n+        let mut layout_variants = variants\n+            .iter_enumerated()\n+            .map(|(i, field_layouts)| {\n+                let mut st = self.univariant(\n+                    dl,\n+                    &field_layouts,\n+                    &repr,\n+                    StructKind::Prefixed(min_ity.size(), prefix_align),\n+                )?;\n+                st.variants = Variants::Single { index: i };\n+                // Find the first field we can't move later\n+                // to make room for a larger discriminant.\n+                for field in st.fields.index_by_increasing_offset().map(|j| &field_layouts[j]) {\n+                    if !field.is_zst() || field.align.abi.bytes() != 1 {\n+                        start_align = start_align.min(field.align.abi);\n+                        break;\n+                    }\n+                }\n+                size = cmp::max(size, st.size);\n+                align = align.max(st.align);\n+                Some(st)\n+            })\n+            .collect::<Option<IndexVec<V, _>>>()?;\n+\n+        // Align the maximum variant size to the largest alignment.\n+        size = size.align_to(align.abi);\n+\n+        if size.bytes() >= dl.obj_size_bound() {\n+            return None;\n+        }\n+\n+        let typeck_ity = Integer::from_attr(dl, repr.discr_type());\n+        if typeck_ity < min_ity {\n+            // It is a bug if Layout decided on a greater discriminant size than typeck for\n+            // some reason at this point (based on values discriminant can take on). Mostly\n+            // because this discriminant will be loaded, and then stored into variable of\n+            // type calculated by typeck. Consider such case (a bug): typeck decided on\n+            // byte-sized discriminant, but layout thinks we need a 16-bit to store all\n+            // discriminant values. That would be a bug, because then, in codegen, in order\n+            // to store this 16-bit discriminant into 8-bit sized temporary some of the\n+            // space necessary to represent would have to be discarded (or layout is wrong\n+            // on thinking it needs 16 bits)\n+            panic!(\n+                \"layout decided on a larger discriminant type ({:?}) than typeck ({:?})\",\n+                min_ity, typeck_ity\n+            );\n+            // However, it is fine to make discr type however large (as an optimisation)\n+            // after this point \u2013 we\u2019ll just truncate the value we load in codegen.\n+        }\n+\n+        // Check to see if we should use a different type for the\n+        // discriminant. We can safely use a type with the same size\n+        // as the alignment of the first field of each variant.\n+        // We increase the size of the discriminant to avoid LLVM copying\n+        // padding when it doesn't need to. This normally causes unaligned\n+        // load/stores and excessive memcpy/memset operations. By using a\n+        // bigger integer size, LLVM can be sure about its contents and\n+        // won't be so conservative.\n+\n+        // Use the initial field alignment\n+        let mut ity = if repr.c() || repr.int.is_some() {\n+            min_ity\n+        } else {\n+            Integer::for_align(dl, start_align).unwrap_or(min_ity)\n+        };\n+\n+        // If the alignment is not larger than the chosen discriminant size,\n+        // don't use the alignment as the final size.\n+        if ity <= min_ity {\n+            ity = min_ity;\n+        } else {\n+            // Patch up the variants' first few fields.\n+            let old_ity_size = min_ity.size();\n+            let new_ity_size = ity.size();\n+            for variant in &mut layout_variants {\n+                match variant.fields {\n+                    FieldsShape::Arbitrary { ref mut offsets, .. } => {\n+                        for i in offsets {\n+                            if *i <= old_ity_size {\n+                                assert_eq!(*i, old_ity_size);\n+                                *i = new_ity_size;\n+                            }\n+                        }\n+                        // We might be making the struct larger.\n+                        if variant.size <= old_ity_size {\n+                            variant.size = new_ity_size;\n+                        }\n+                    }\n+                    _ => panic!(),\n+                }\n+            }\n+        }\n+\n+        let tag_mask = ity.size().unsigned_int_max();\n+        let tag = Scalar::Initialized {\n+            value: Int(ity, signed),\n+            valid_range: WrappingRange {\n+                start: (min as u128 & tag_mask),\n+                end: (max as u128 & tag_mask),\n+            },\n+        };\n+        let mut abi = Abi::Aggregate { sized: true };\n+\n+        if layout_variants.iter().all(|v| v.abi.is_uninhabited()) {\n+            abi = Abi::Uninhabited;\n+        } else if tag.size(dl) == size {\n+            // Make sure we only use scalar layout when the enum is entirely its\n+            // own tag (i.e. it has no padding nor any non-ZST variant fields).\n+            abi = Abi::Scalar(tag);\n+        } else {\n+            // Try to use a ScalarPair for all tagged enums.\n+            let mut common_prim = None;\n+            let mut common_prim_initialized_in_all_variants = true;\n+            for (field_layouts, layout_variant) in iter::zip(&*variants, &layout_variants) {\n+                let FieldsShape::Arbitrary { ref offsets, .. } = layout_variant.fields else {\n+                    panic!();\n+                };\n+                let mut fields = iter::zip(field_layouts, offsets).filter(|p| !p.0.is_zst());\n+                let (field, offset) = match (fields.next(), fields.next()) {\n+                    (None, None) => {\n+                        common_prim_initialized_in_all_variants = false;\n+                        continue;\n+                    }\n+                    (Some(pair), None) => pair,\n+                    _ => {\n+                        common_prim = None;\n+                        break;\n+                    }\n+                };\n+                let prim = match field.abi {\n+                    Abi::Scalar(scalar) => {\n+                        common_prim_initialized_in_all_variants &=\n+                            matches!(scalar, Scalar::Initialized { .. });\n+                        scalar.primitive()\n+                    }\n+                    _ => {\n+                        common_prim = None;\n+                        break;\n+                    }\n+                };\n+                if let Some(pair) = common_prim {\n+                    // This is pretty conservative. We could go fancier\n+                    // by conflating things like i32 and u32, or even\n+                    // realising that (u8, u8) could just cohabit with\n+                    // u16 or even u32.\n+                    if pair != (prim, offset) {\n+                        common_prim = None;\n+                        break;\n+                    }\n+                } else {\n+                    common_prim = Some((prim, offset));\n+                }\n+            }\n+            if let Some((prim, offset)) = common_prim {\n+                let prim_scalar = if common_prim_initialized_in_all_variants {\n+                    scalar_unit(prim)\n+                } else {\n+                    // Common prim might be uninit.\n+                    Scalar::Union { value: prim }\n+                };\n+                let pair = self.scalar_pair::<V>(tag, prim_scalar);\n+                let pair_offsets = match pair.fields {\n+                    FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n+                        assert_eq!(memory_index, &[0, 1]);\n+                        offsets\n+                    }\n+                    _ => panic!(),\n+                };\n+                if pair_offsets[0] == Size::ZERO\n+                    && pair_offsets[1] == *offset\n+                    && align == pair.align\n+                    && size == pair.size\n+                {\n+                    // We can use `ScalarPair` only when it matches our\n+                    // already computed layout (including `#[repr(C)]`).\n+                    abi = pair.abi;\n+                }\n+            }\n+        }\n+\n+        // If we pick a \"clever\" (by-value) ABI, we might have to adjust the ABI of the\n+        // variants to ensure they are consistent. This is because a downcast is\n+        // semantically a NOP, and thus should not affect layout.\n+        if matches!(abi, Abi::Scalar(..) | Abi::ScalarPair(..)) {\n+            for variant in &mut layout_variants {\n+                // We only do this for variants with fields; the others are not accessed anyway.\n+                // Also do not overwrite any already existing \"clever\" ABIs.\n+                if variant.fields.count() > 0 && matches!(variant.abi, Abi::Aggregate { .. }) {\n+                    variant.abi = abi;\n+                    // Also need to bump up the size and alignment, so that the entire value fits in here.\n+                    variant.size = cmp::max(variant.size, size);\n+                    variant.align.abi = cmp::max(variant.align.abi, align.abi);\n+                }\n+            }\n+        }\n+\n+        let largest_niche = Niche::from_scalar(dl, Size::ZERO, tag);\n+\n+        let tagged_layout = LayoutS {\n+            variants: Variants::Multiple {\n+                tag,\n+                tag_encoding: TagEncoding::Direct,\n+                tag_field: 0,\n+                variants: IndexVec::new(),\n+            },\n+            fields: FieldsShape::Arbitrary { offsets: vec![Size::ZERO], memory_index: vec![0] },\n+            largest_niche,\n+            abi,\n+            align,\n+            size,\n+        };\n+\n+        let tagged_layout = TmpLayout { layout: tagged_layout, variants: layout_variants };\n+\n+        let mut best_layout = match (tagged_layout, niche_filling_layout) {\n+            (tl, Some(nl)) => {\n+                // Pick the smaller layout; otherwise,\n+                // pick the layout with the larger niche; otherwise,\n+                // pick tagged as it has simpler codegen.\n+                use cmp::Ordering::*;\n+                let niche_size = |tmp_l: &TmpLayout<V>| {\n+                    tmp_l.layout.largest_niche.map_or(0, |n| n.available(dl))\n+                };\n+                match (tl.layout.size.cmp(&nl.layout.size), niche_size(&tl).cmp(&niche_size(&nl))) {\n+                    (Greater, _) => nl,\n+                    (Equal, Less) => nl,\n+                    _ => tl,\n+                }\n+            }\n+            (tl, None) => tl,\n+        };\n+\n+        // Now we can intern the variant layouts and store them in the enum layout.\n+        best_layout.layout.variants = match best_layout.layout.variants {\n+            Variants::Multiple { tag, tag_encoding, tag_field, .. } => {\n+                Variants::Multiple { tag, tag_encoding, tag_field, variants: best_layout.variants }\n+            }\n+            _ => panic!(),\n+        };\n+        Some(best_layout.layout)\n+    }\n+\n+    fn layout_of_union<'a, V: Idx, F: Deref<Target = &'a LayoutS<V>> + Debug>(\n+        &self,\n+        repr: &ReprOptions,\n+        variants: &IndexVec<V, Vec<F>>,\n+    ) -> Option<LayoutS<V>> {\n+        let dl = self.current_data_layout();\n+        let dl = dl.borrow();\n+        let mut align = if repr.pack.is_some() { dl.i8_align } else { dl.aggregate_align };\n+\n+        if let Some(repr_align) = repr.align {\n+            align = align.max(AbiAndPrefAlign::new(repr_align));\n+        }\n+\n+        let optimize = !repr.inhibit_union_abi_opt();\n+        let mut size = Size::ZERO;\n+        let mut abi = Abi::Aggregate { sized: true };\n+        let index = V::new(0);\n+        for field in &variants[index] {\n+            assert!(field.is_sized());\n+            align = align.max(field.align);\n+\n+            // If all non-ZST fields have the same ABI, forward this ABI\n+            if optimize && !field.is_zst() {\n+                // Discard valid range information and allow undef\n+                let field_abi = match field.abi {\n+                    Abi::Scalar(x) => Abi::Scalar(x.to_union()),\n+                    Abi::ScalarPair(x, y) => Abi::ScalarPair(x.to_union(), y.to_union()),\n+                    Abi::Vector { element: x, count } => {\n+                        Abi::Vector { element: x.to_union(), count }\n+                    }\n+                    Abi::Uninhabited | Abi::Aggregate { .. } => Abi::Aggregate { sized: true },\n+                };\n+\n+                if size == Size::ZERO {\n+                    // first non ZST: initialize 'abi'\n+                    abi = field_abi;\n+                } else if abi != field_abi {\n+                    // different fields have different ABI: reset to Aggregate\n+                    abi = Abi::Aggregate { sized: true };\n+                }\n+            }\n+\n+            size = cmp::max(size, field.size);\n+        }\n+\n+        if let Some(pack) = repr.pack {\n+            align = align.min(AbiAndPrefAlign::new(pack));\n+        }\n+\n+        Some(LayoutS {\n+            variants: Variants::Single { index },\n+            fields: FieldsShape::Union(NonZeroUsize::new(variants[index].len())?),\n+            abi,\n+            largest_niche: None,\n+            align,\n+            size: size.align_to(align.abi),\n+        })\n+    }\n+}"}, {"sha": "4f4a4bf314f14f76fa5422dbe9e6baaa9c7c92a8", "filename": "compiler/rustc_abi/src/lib.rs", "status": "added", "additions": 1399, "deletions": 0, "changes": 1399, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -0,0 +1,1399 @@\n+#![cfg_attr(feature = \"nightly\", feature(step_trait, rustc_attrs, min_specialization))]\n+\n+use std::convert::{TryFrom, TryInto};\n+use std::fmt;\n+#[cfg(feature = \"nightly\")]\n+use std::iter::Step;\n+use std::num::{NonZeroUsize, ParseIntError};\n+use std::ops::{Add, AddAssign, Mul, RangeInclusive, Sub};\n+use std::str::FromStr;\n+\n+use bitflags::bitflags;\n+use rustc_index::vec::{Idx, IndexVec};\n+#[cfg(feature = \"nightly\")]\n+use rustc_macros::HashStable_Generic;\n+#[cfg(feature = \"nightly\")]\n+use rustc_macros::{Decodable, Encodable};\n+\n+mod layout;\n+\n+pub use layout::LayoutCalculator;\n+\n+/// Requirements for a `StableHashingContext` to be used in this crate.\n+/// This is a hack to allow using the `HashStable_Generic` derive macro\n+/// instead of implementing everything in `rustc_middle`.\n+pub trait HashStableContext {}\n+\n+use Integer::*;\n+use Primitive::*;\n+\n+bitflags! {\n+    #[derive(Default)]\n+    #[cfg_attr(feature = \"nightly\", derive(Encodable, Decodable, HashStable_Generic))]\n+    pub struct ReprFlags: u8 {\n+        const IS_C               = 1 << 0;\n+        const IS_SIMD            = 1 << 1;\n+        const IS_TRANSPARENT     = 1 << 2;\n+        // Internal only for now. If true, don't reorder fields.\n+        const IS_LINEAR          = 1 << 3;\n+        // If true, the type's layout can be randomized using\n+        // the seed stored in `ReprOptions.layout_seed`\n+        const RANDOMIZE_LAYOUT   = 1 << 4;\n+        // Any of these flags being set prevent field reordering optimisation.\n+        const IS_UNOPTIMISABLE   = ReprFlags::IS_C.bits\n+                                 | ReprFlags::IS_SIMD.bits\n+                                 | ReprFlags::IS_LINEAR.bits;\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+#[cfg_attr(feature = \"nightly\", derive(Encodable, Decodable, HashStable_Generic))]\n+pub enum IntegerType {\n+    /// Pointer sized integer type, i.e. isize and usize. The field shows signedness, that\n+    /// is, `Pointer(true)` is isize.\n+    Pointer(bool),\n+    /// Fix sized integer type, e.g. i8, u32, i128 The bool field shows signedness, `Fixed(I8, false)` means `u8`\n+    Fixed(Integer, bool),\n+}\n+\n+impl IntegerType {\n+    pub fn is_signed(&self) -> bool {\n+        match self {\n+            IntegerType::Pointer(b) => *b,\n+            IntegerType::Fixed(_, b) => *b,\n+        }\n+    }\n+}\n+\n+/// Represents the repr options provided by the user,\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Default)]\n+#[cfg_attr(feature = \"nightly\", derive(Encodable, Decodable, HashStable_Generic))]\n+pub struct ReprOptions {\n+    pub int: Option<IntegerType>,\n+    pub align: Option<Align>,\n+    pub pack: Option<Align>,\n+    pub flags: ReprFlags,\n+    /// The seed to be used for randomizing a type's layout\n+    ///\n+    /// Note: This could technically be a `[u8; 16]` (a `u128`) which would\n+    /// be the \"most accurate\" hash as it'd encompass the item and crate\n+    /// hash without loss, but it does pay the price of being larger.\n+    /// Everything's a tradeoff, a `u64` seed should be sufficient for our\n+    /// purposes (primarily `-Z randomize-layout`)\n+    pub field_shuffle_seed: u64,\n+}\n+\n+impl ReprOptions {\n+    #[inline]\n+    pub fn simd(&self) -> bool {\n+        self.flags.contains(ReprFlags::IS_SIMD)\n+    }\n+\n+    #[inline]\n+    pub fn c(&self) -> bool {\n+        self.flags.contains(ReprFlags::IS_C)\n+    }\n+\n+    #[inline]\n+    pub fn packed(&self) -> bool {\n+        self.pack.is_some()\n+    }\n+\n+    #[inline]\n+    pub fn transparent(&self) -> bool {\n+        self.flags.contains(ReprFlags::IS_TRANSPARENT)\n+    }\n+\n+    #[inline]\n+    pub fn linear(&self) -> bool {\n+        self.flags.contains(ReprFlags::IS_LINEAR)\n+    }\n+\n+    /// Returns the discriminant type, given these `repr` options.\n+    /// This must only be called on enums!\n+    pub fn discr_type(&self) -> IntegerType {\n+        self.int.unwrap_or(IntegerType::Pointer(true))\n+    }\n+\n+    /// Returns `true` if this `#[repr()]` should inhabit \"smart enum\n+    /// layout\" optimizations, such as representing `Foo<&T>` as a\n+    /// single pointer.\n+    pub fn inhibit_enum_layout_opt(&self) -> bool {\n+        self.c() || self.int.is_some()\n+    }\n+\n+    /// Returns `true` if this `#[repr()]` should inhibit struct field reordering\n+    /// optimizations, such as with `repr(C)`, `repr(packed(1))`, or `repr(<int>)`.\n+    pub fn inhibit_struct_field_reordering_opt(&self) -> bool {\n+        if let Some(pack) = self.pack {\n+            if pack.bytes() == 1 {\n+                return true;\n+            }\n+        }\n+\n+        self.flags.intersects(ReprFlags::IS_UNOPTIMISABLE) || self.int.is_some()\n+    }\n+\n+    /// Returns `true` if this type is valid for reordering and `-Z randomize-layout`\n+    /// was enabled for its declaration crate\n+    pub fn can_randomize_type_layout(&self) -> bool {\n+        !self.inhibit_struct_field_reordering_opt()\n+            && self.flags.contains(ReprFlags::RANDOMIZE_LAYOUT)\n+    }\n+\n+    /// Returns `true` if this `#[repr()]` should inhibit union ABI optimisations.\n+    pub fn inhibit_union_abi_opt(&self) -> bool {\n+        self.c()\n+    }\n+}\n+\n+/// Parsed [Data layout](https://llvm.org/docs/LangRef.html#data-layout)\n+/// for a target, which contains everything needed to compute layouts.\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct TargetDataLayout {\n+    pub endian: Endian,\n+    pub i1_align: AbiAndPrefAlign,\n+    pub i8_align: AbiAndPrefAlign,\n+    pub i16_align: AbiAndPrefAlign,\n+    pub i32_align: AbiAndPrefAlign,\n+    pub i64_align: AbiAndPrefAlign,\n+    pub i128_align: AbiAndPrefAlign,\n+    pub f32_align: AbiAndPrefAlign,\n+    pub f64_align: AbiAndPrefAlign,\n+    pub pointer_size: Size,\n+    pub pointer_align: AbiAndPrefAlign,\n+    pub aggregate_align: AbiAndPrefAlign,\n+\n+    /// Alignments for vector types.\n+    pub vector_align: Vec<(Size, AbiAndPrefAlign)>,\n+\n+    pub instruction_address_space: AddressSpace,\n+\n+    /// Minimum size of #[repr(C)] enums (default I32 bits)\n+    pub c_enum_min_size: Integer,\n+}\n+\n+impl Default for TargetDataLayout {\n+    /// Creates an instance of `TargetDataLayout`.\n+    fn default() -> TargetDataLayout {\n+        let align = |bits| Align::from_bits(bits).unwrap();\n+        TargetDataLayout {\n+            endian: Endian::Big,\n+            i1_align: AbiAndPrefAlign::new(align(8)),\n+            i8_align: AbiAndPrefAlign::new(align(8)),\n+            i16_align: AbiAndPrefAlign::new(align(16)),\n+            i32_align: AbiAndPrefAlign::new(align(32)),\n+            i64_align: AbiAndPrefAlign { abi: align(32), pref: align(64) },\n+            i128_align: AbiAndPrefAlign { abi: align(32), pref: align(64) },\n+            f32_align: AbiAndPrefAlign::new(align(32)),\n+            f64_align: AbiAndPrefAlign::new(align(64)),\n+            pointer_size: Size::from_bits(64),\n+            pointer_align: AbiAndPrefAlign::new(align(64)),\n+            aggregate_align: AbiAndPrefAlign { abi: align(0), pref: align(64) },\n+            vector_align: vec![\n+                (Size::from_bits(64), AbiAndPrefAlign::new(align(64))),\n+                (Size::from_bits(128), AbiAndPrefAlign::new(align(128))),\n+            ],\n+            instruction_address_space: AddressSpace::DATA,\n+            c_enum_min_size: Integer::I32,\n+        }\n+    }\n+}\n+\n+pub enum TargetDataLayoutErrors<'a> {\n+    InvalidAddressSpace { addr_space: &'a str, cause: &'a str, err: ParseIntError },\n+    InvalidBits { kind: &'a str, bit: &'a str, cause: &'a str, err: ParseIntError },\n+    MissingAlignment { cause: &'a str },\n+    InvalidAlignment { cause: &'a str, err: String },\n+    InconsistentTargetArchitecture { dl: &'a str, target: &'a str },\n+    InconsistentTargetPointerWidth { pointer_size: u64, target: u32 },\n+    InvalidBitsSize { err: String },\n+}\n+\n+impl TargetDataLayout {\n+    /// Returns exclusive upper bound on object size.\n+    ///\n+    /// The theoretical maximum object size is defined as the maximum positive `isize` value.\n+    /// This ensures that the `offset` semantics remain well-defined by allowing it to correctly\n+    /// index every address within an object along with one byte past the end, along with allowing\n+    /// `isize` to store the difference between any two pointers into an object.\n+    ///\n+    /// The upper bound on 64-bit currently needs to be lower because LLVM uses a 64-bit integer\n+    /// to represent object size in bits. It would need to be 1 << 61 to account for this, but is\n+    /// currently conservatively bounded to 1 << 47 as that is enough to cover the current usable\n+    /// address space on 64-bit ARMv8 and x86_64.\n+    #[inline]\n+    pub fn obj_size_bound(&self) -> u64 {\n+        match self.pointer_size.bits() {\n+            16 => 1 << 15,\n+            32 => 1 << 31,\n+            64 => 1 << 47,\n+            bits => panic!(\"obj_size_bound: unknown pointer bit size {}\", bits),\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn ptr_sized_integer(&self) -> Integer {\n+        match self.pointer_size.bits() {\n+            16 => I16,\n+            32 => I32,\n+            64 => I64,\n+            bits => panic!(\"ptr_sized_integer: unknown pointer bit size {}\", bits),\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn vector_align(&self, vec_size: Size) -> AbiAndPrefAlign {\n+        for &(size, align) in &self.vector_align {\n+            if size == vec_size {\n+                return align;\n+            }\n+        }\n+        // Default to natural alignment, which is what LLVM does.\n+        // That is, use the size, rounded up to a power of 2.\n+        AbiAndPrefAlign::new(Align::from_bytes(vec_size.bytes().next_power_of_two()).unwrap())\n+    }\n+}\n+\n+pub trait HasDataLayout {\n+    fn data_layout(&self) -> &TargetDataLayout;\n+}\n+\n+impl HasDataLayout for TargetDataLayout {\n+    #[inline]\n+    fn data_layout(&self) -> &TargetDataLayout {\n+        self\n+    }\n+}\n+\n+/// Endianness of the target, which must match cfg(target-endian).\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+pub enum Endian {\n+    Little,\n+    Big,\n+}\n+\n+impl Endian {\n+    pub fn as_str(&self) -> &'static str {\n+        match self {\n+            Self::Little => \"little\",\n+            Self::Big => \"big\",\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for Endian {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(self.as_str())\n+    }\n+}\n+\n+impl FromStr for Endian {\n+    type Err = String;\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        match s {\n+            \"little\" => Ok(Self::Little),\n+            \"big\" => Ok(Self::Big),\n+            _ => Err(format!(r#\"unknown endian: \"{}\"\"#, s)),\n+        }\n+    }\n+}\n+\n+/// Size of a type in bytes.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[cfg_attr(feature = \"nightly\", derive(Encodable, Decodable, HashStable_Generic))]\n+pub struct Size {\n+    raw: u64,\n+}\n+\n+// This is debug-printed a lot in larger structs, don't waste too much space there\n+impl fmt::Debug for Size {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"Size({} bytes)\", self.bytes())\n+    }\n+}\n+\n+impl Size {\n+    pub const ZERO: Size = Size { raw: 0 };\n+\n+    /// Rounds `bits` up to the next-higher byte boundary, if `bits` is\n+    /// not a multiple of 8.\n+    pub fn from_bits(bits: impl TryInto<u64>) -> Size {\n+        let bits = bits.try_into().ok().unwrap();\n+        // Avoid potential overflow from `bits + 7`.\n+        Size { raw: bits / 8 + ((bits % 8) + 7) / 8 }\n+    }\n+\n+    #[inline]\n+    pub fn from_bytes(bytes: impl TryInto<u64>) -> Size {\n+        let bytes: u64 = bytes.try_into().ok().unwrap();\n+        Size { raw: bytes }\n+    }\n+\n+    #[inline]\n+    pub fn bytes(self) -> u64 {\n+        self.raw\n+    }\n+\n+    #[inline]\n+    pub fn bytes_usize(self) -> usize {\n+        self.bytes().try_into().unwrap()\n+    }\n+\n+    #[inline]\n+    pub fn bits(self) -> u64 {\n+        #[cold]\n+        fn overflow(bytes: u64) -> ! {\n+            panic!(\"Size::bits: {} bytes in bits doesn't fit in u64\", bytes)\n+        }\n+\n+        self.bytes().checked_mul(8).unwrap_or_else(|| overflow(self.bytes()))\n+    }\n+\n+    #[inline]\n+    pub fn bits_usize(self) -> usize {\n+        self.bits().try_into().unwrap()\n+    }\n+\n+    #[inline]\n+    pub fn align_to(self, align: Align) -> Size {\n+        let mask = align.bytes() - 1;\n+        Size::from_bytes((self.bytes() + mask) & !mask)\n+    }\n+\n+    #[inline]\n+    pub fn is_aligned(self, align: Align) -> bool {\n+        let mask = align.bytes() - 1;\n+        self.bytes() & mask == 0\n+    }\n+\n+    #[inline]\n+    pub fn checked_add<C: HasDataLayout>(self, offset: Size, cx: &C) -> Option<Size> {\n+        let dl = cx.data_layout();\n+\n+        let bytes = self.bytes().checked_add(offset.bytes())?;\n+\n+        if bytes < dl.obj_size_bound() { Some(Size::from_bytes(bytes)) } else { None }\n+    }\n+\n+    #[inline]\n+    pub fn checked_mul<C: HasDataLayout>(self, count: u64, cx: &C) -> Option<Size> {\n+        let dl = cx.data_layout();\n+\n+        let bytes = self.bytes().checked_mul(count)?;\n+        if bytes < dl.obj_size_bound() { Some(Size::from_bytes(bytes)) } else { None }\n+    }\n+\n+    /// Truncates `value` to `self` bits and then sign-extends it to 128 bits\n+    /// (i.e., if it is negative, fill with 1's on the left).\n+    #[inline]\n+    pub fn sign_extend(self, value: u128) -> u128 {\n+        let size = self.bits();\n+        if size == 0 {\n+            // Truncated until nothing is left.\n+            return 0;\n+        }\n+        // Sign-extend it.\n+        let shift = 128 - size;\n+        // Shift the unsigned value to the left, then shift back to the right as signed\n+        // (essentially fills with sign bit on the left).\n+        (((value << shift) as i128) >> shift) as u128\n+    }\n+\n+    /// Truncates `value` to `self` bits.\n+    #[inline]\n+    pub fn truncate(self, value: u128) -> u128 {\n+        let size = self.bits();\n+        if size == 0 {\n+            // Truncated until nothing is left.\n+            return 0;\n+        }\n+        let shift = 128 - size;\n+        // Truncate (shift left to drop out leftover values, shift right to fill with zeroes).\n+        (value << shift) >> shift\n+    }\n+\n+    #[inline]\n+    pub fn signed_int_min(&self) -> i128 {\n+        self.sign_extend(1_u128 << (self.bits() - 1)) as i128\n+    }\n+\n+    #[inline]\n+    pub fn signed_int_max(&self) -> i128 {\n+        i128::MAX >> (128 - self.bits())\n+    }\n+\n+    #[inline]\n+    pub fn unsigned_int_max(&self) -> u128 {\n+        u128::MAX >> (128 - self.bits())\n+    }\n+}\n+\n+// Panicking addition, subtraction and multiplication for convenience.\n+// Avoid during layout computation, return `LayoutError` instead.\n+\n+impl Add for Size {\n+    type Output = Size;\n+    #[inline]\n+    fn add(self, other: Size) -> Size {\n+        Size::from_bytes(self.bytes().checked_add(other.bytes()).unwrap_or_else(|| {\n+            panic!(\"Size::add: {} + {} doesn't fit in u64\", self.bytes(), other.bytes())\n+        }))\n+    }\n+}\n+\n+impl Sub for Size {\n+    type Output = Size;\n+    #[inline]\n+    fn sub(self, other: Size) -> Size {\n+        Size::from_bytes(self.bytes().checked_sub(other.bytes()).unwrap_or_else(|| {\n+            panic!(\"Size::sub: {} - {} would result in negative size\", self.bytes(), other.bytes())\n+        }))\n+    }\n+}\n+\n+impl Mul<Size> for u64 {\n+    type Output = Size;\n+    #[inline]\n+    fn mul(self, size: Size) -> Size {\n+        size * self\n+    }\n+}\n+\n+impl Mul<u64> for Size {\n+    type Output = Size;\n+    #[inline]\n+    fn mul(self, count: u64) -> Size {\n+        match self.bytes().checked_mul(count) {\n+            Some(bytes) => Size::from_bytes(bytes),\n+            None => panic!(\"Size::mul: {} * {} doesn't fit in u64\", self.bytes(), count),\n+        }\n+    }\n+}\n+\n+impl AddAssign for Size {\n+    #[inline]\n+    fn add_assign(&mut self, other: Size) {\n+        *self = *self + other;\n+    }\n+}\n+\n+#[cfg(feature = \"nightly\")]\n+impl Step for Size {\n+    #[inline]\n+    fn steps_between(start: &Self, end: &Self) -> Option<usize> {\n+        u64::steps_between(&start.bytes(), &end.bytes())\n+    }\n+\n+    #[inline]\n+    fn forward_checked(start: Self, count: usize) -> Option<Self> {\n+        u64::forward_checked(start.bytes(), count).map(Self::from_bytes)\n+    }\n+\n+    #[inline]\n+    fn forward(start: Self, count: usize) -> Self {\n+        Self::from_bytes(u64::forward(start.bytes(), count))\n+    }\n+\n+    #[inline]\n+    unsafe fn forward_unchecked(start: Self, count: usize) -> Self {\n+        Self::from_bytes(u64::forward_unchecked(start.bytes(), count))\n+    }\n+\n+    #[inline]\n+    fn backward_checked(start: Self, count: usize) -> Option<Self> {\n+        u64::backward_checked(start.bytes(), count).map(Self::from_bytes)\n+    }\n+\n+    #[inline]\n+    fn backward(start: Self, count: usize) -> Self {\n+        Self::from_bytes(u64::backward(start.bytes(), count))\n+    }\n+\n+    #[inline]\n+    unsafe fn backward_unchecked(start: Self, count: usize) -> Self {\n+        Self::from_bytes(u64::backward_unchecked(start.bytes(), count))\n+    }\n+}\n+\n+/// Alignment of a type in bytes (always a power of two).\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[cfg_attr(feature = \"nightly\", derive(Encodable, Decodable, HashStable_Generic))]\n+pub struct Align {\n+    pow2: u8,\n+}\n+\n+// This is debug-printed a lot in larger structs, don't waste too much space there\n+impl fmt::Debug for Align {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"Align({} bytes)\", self.bytes())\n+    }\n+}\n+\n+impl Align {\n+    pub const ONE: Align = Align { pow2: 0 };\n+    pub const MAX: Align = Align { pow2: 29 };\n+\n+    #[inline]\n+    pub fn from_bits(bits: u64) -> Result<Align, String> {\n+        Align::from_bytes(Size::from_bits(bits).bytes())\n+    }\n+\n+    #[inline]\n+    pub fn from_bytes(align: u64) -> Result<Align, String> {\n+        // Treat an alignment of 0 bytes like 1-byte alignment.\n+        if align == 0 {\n+            return Ok(Align::ONE);\n+        }\n+\n+        #[cold]\n+        fn not_power_of_2(align: u64) -> String {\n+            format!(\"`{}` is not a power of 2\", align)\n+        }\n+\n+        #[cold]\n+        fn too_large(align: u64) -> String {\n+            format!(\"`{}` is too large\", align)\n+        }\n+\n+        let mut bytes = align;\n+        let mut pow2: u8 = 0;\n+        while (bytes & 1) == 0 {\n+            pow2 += 1;\n+            bytes >>= 1;\n+        }\n+        if bytes != 1 {\n+            return Err(not_power_of_2(align));\n+        }\n+        if pow2 > Self::MAX.pow2 {\n+            return Err(too_large(align));\n+        }\n+\n+        Ok(Align { pow2 })\n+    }\n+\n+    #[inline]\n+    pub fn bytes(self) -> u64 {\n+        1 << self.pow2\n+    }\n+\n+    #[inline]\n+    pub fn bits(self) -> u64 {\n+        self.bytes() * 8\n+    }\n+\n+    /// Computes the best alignment possible for the given offset\n+    /// (the largest power of two that the offset is a multiple of).\n+    ///\n+    /// N.B., for an offset of `0`, this happens to return `2^64`.\n+    #[inline]\n+    pub fn max_for_offset(offset: Size) -> Align {\n+        Align { pow2: offset.bytes().trailing_zeros() as u8 }\n+    }\n+\n+    /// Lower the alignment, if necessary, such that the given offset\n+    /// is aligned to it (the offset is a multiple of the alignment).\n+    #[inline]\n+    pub fn restrict_for_offset(self, offset: Size) -> Align {\n+        self.min(Align::max_for_offset(offset))\n+    }\n+}\n+\n+/// A pair of alignments, ABI-mandated and preferred.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n+\n+pub struct AbiAndPrefAlign {\n+    pub abi: Align,\n+    pub pref: Align,\n+}\n+\n+impl AbiAndPrefAlign {\n+    #[inline]\n+    pub fn new(align: Align) -> AbiAndPrefAlign {\n+        AbiAndPrefAlign { abi: align, pref: align }\n+    }\n+\n+    #[inline]\n+    pub fn min(self, other: AbiAndPrefAlign) -> AbiAndPrefAlign {\n+        AbiAndPrefAlign { abi: self.abi.min(other.abi), pref: self.pref.min(other.pref) }\n+    }\n+\n+    #[inline]\n+    pub fn max(self, other: AbiAndPrefAlign) -> AbiAndPrefAlign {\n+        AbiAndPrefAlign { abi: self.abi.max(other.abi), pref: self.pref.max(other.pref) }\n+    }\n+}\n+\n+/// Integers, also used for enum discriminants.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[cfg_attr(feature = \"nightly\", derive(Encodable, Decodable, HashStable_Generic))]\n+\n+pub enum Integer {\n+    I8,\n+    I16,\n+    I32,\n+    I64,\n+    I128,\n+}\n+\n+impl Integer {\n+    #[inline]\n+    pub fn size(self) -> Size {\n+        match self {\n+            I8 => Size::from_bytes(1),\n+            I16 => Size::from_bytes(2),\n+            I32 => Size::from_bytes(4),\n+            I64 => Size::from_bytes(8),\n+            I128 => Size::from_bytes(16),\n+        }\n+    }\n+\n+    /// Gets the Integer type from an IntegerType.\n+    pub fn from_attr<C: HasDataLayout>(cx: &C, ity: IntegerType) -> Integer {\n+        let dl = cx.data_layout();\n+\n+        match ity {\n+            IntegerType::Pointer(_) => dl.ptr_sized_integer(),\n+            IntegerType::Fixed(x, _) => x,\n+        }\n+    }\n+\n+    pub fn align<C: HasDataLayout>(self, cx: &C) -> AbiAndPrefAlign {\n+        let dl = cx.data_layout();\n+\n+        match self {\n+            I8 => dl.i8_align,\n+            I16 => dl.i16_align,\n+            I32 => dl.i32_align,\n+            I64 => dl.i64_align,\n+            I128 => dl.i128_align,\n+        }\n+    }\n+\n+    /// Finds the smallest Integer type which can represent the signed value.\n+    #[inline]\n+    pub fn fit_signed(x: i128) -> Integer {\n+        match x {\n+            -0x0000_0000_0000_0080..=0x0000_0000_0000_007f => I8,\n+            -0x0000_0000_0000_8000..=0x0000_0000_0000_7fff => I16,\n+            -0x0000_0000_8000_0000..=0x0000_0000_7fff_ffff => I32,\n+            -0x8000_0000_0000_0000..=0x7fff_ffff_ffff_ffff => I64,\n+            _ => I128,\n+        }\n+    }\n+\n+    /// Finds the smallest Integer type which can represent the unsigned value.\n+    #[inline]\n+    pub fn fit_unsigned(x: u128) -> Integer {\n+        match x {\n+            0..=0x0000_0000_0000_00ff => I8,\n+            0..=0x0000_0000_0000_ffff => I16,\n+            0..=0x0000_0000_ffff_ffff => I32,\n+            0..=0xffff_ffff_ffff_ffff => I64,\n+            _ => I128,\n+        }\n+    }\n+\n+    /// Finds the smallest integer with the given alignment.\n+    pub fn for_align<C: HasDataLayout>(cx: &C, wanted: Align) -> Option<Integer> {\n+        let dl = cx.data_layout();\n+\n+        for candidate in [I8, I16, I32, I64, I128] {\n+            if wanted == candidate.align(dl).abi && wanted.bytes() == candidate.size().bytes() {\n+                return Some(candidate);\n+            }\n+        }\n+        None\n+    }\n+\n+    /// Find the largest integer with the given alignment or less.\n+    pub fn approximate_align<C: HasDataLayout>(cx: &C, wanted: Align) -> Integer {\n+        let dl = cx.data_layout();\n+\n+        // FIXME(eddyb) maybe include I128 in the future, when it works everywhere.\n+        for candidate in [I64, I32, I16] {\n+            if wanted >= candidate.align(dl).abi && wanted.bytes() >= candidate.size().bytes() {\n+                return candidate;\n+            }\n+        }\n+        I8\n+    }\n+\n+    // FIXME(eddyb) consolidate this and other methods that find the appropriate\n+    // `Integer` given some requirements.\n+    #[inline]\n+    pub fn from_size(size: Size) -> Result<Self, String> {\n+        match size.bits() {\n+            8 => Ok(Integer::I8),\n+            16 => Ok(Integer::I16),\n+            32 => Ok(Integer::I32),\n+            64 => Ok(Integer::I64),\n+            128 => Ok(Integer::I128),\n+            _ => Err(format!(\"rust does not support integers with {} bits\", size.bits())),\n+        }\n+    }\n+}\n+\n+/// Fundamental unit of memory access and layout.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n+pub enum Primitive {\n+    /// The `bool` is the signedness of the `Integer` type.\n+    ///\n+    /// One would think we would not care about such details this low down,\n+    /// but some ABIs are described in terms of C types and ISAs where the\n+    /// integer arithmetic is done on {sign,zero}-extended registers, e.g.\n+    /// a negative integer passed by zero-extension will appear positive in\n+    /// the callee, and most operations on it will produce the wrong values.\n+    Int(Integer, bool),\n+    F32,\n+    F64,\n+    Pointer,\n+}\n+\n+impl Primitive {\n+    pub fn size<C: HasDataLayout>(self, cx: &C) -> Size {\n+        let dl = cx.data_layout();\n+\n+        match self {\n+            Int(i, _) => i.size(),\n+            F32 => Size::from_bits(32),\n+            F64 => Size::from_bits(64),\n+            Pointer => dl.pointer_size,\n+        }\n+    }\n+\n+    pub fn align<C: HasDataLayout>(self, cx: &C) -> AbiAndPrefAlign {\n+        let dl = cx.data_layout();\n+\n+        match self {\n+            Int(i, _) => i.align(dl),\n+            F32 => dl.f32_align,\n+            F64 => dl.f64_align,\n+            Pointer => dl.pointer_align,\n+        }\n+    }\n+\n+    // FIXME(eddyb) remove, it's trivial thanks to `matches!`.\n+    #[inline]\n+    pub fn is_float(self) -> bool {\n+        matches!(self, F32 | F64)\n+    }\n+\n+    // FIXME(eddyb) remove, it's completely unused.\n+    #[inline]\n+    pub fn is_int(self) -> bool {\n+        matches!(self, Int(..))\n+    }\n+\n+    #[inline]\n+    pub fn is_ptr(self) -> bool {\n+        matches!(self, Pointer)\n+    }\n+}\n+\n+/// Inclusive wrap-around range of valid values, that is, if\n+/// start > end, it represents `start..=MAX`,\n+/// followed by `0..=end`.\n+///\n+/// That is, for an i8 primitive, a range of `254..=2` means following\n+/// sequence:\n+///\n+///    254 (-2), 255 (-1), 0, 1, 2\n+///\n+/// This is intended specifically to mirror LLVM\u2019s `!range` metadata semantics.\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n+pub struct WrappingRange {\n+    pub start: u128,\n+    pub end: u128,\n+}\n+\n+impl WrappingRange {\n+    pub fn full(size: Size) -> Self {\n+        Self { start: 0, end: size.unsigned_int_max() }\n+    }\n+\n+    /// Returns `true` if `v` is contained in the range.\n+    #[inline(always)]\n+    pub fn contains(&self, v: u128) -> bool {\n+        if self.start <= self.end {\n+            self.start <= v && v <= self.end\n+        } else {\n+            self.start <= v || v <= self.end\n+        }\n+    }\n+\n+    /// Returns `self` with replaced `start`\n+    #[inline(always)]\n+    pub fn with_start(mut self, start: u128) -> Self {\n+        self.start = start;\n+        self\n+    }\n+\n+    /// Returns `self` with replaced `end`\n+    #[inline(always)]\n+    pub fn with_end(mut self, end: u128) -> Self {\n+        self.end = end;\n+        self\n+    }\n+\n+    /// Returns `true` if `size` completely fills the range.\n+    #[inline]\n+    pub fn is_full_for(&self, size: Size) -> bool {\n+        let max_value = size.unsigned_int_max();\n+        debug_assert!(self.start <= max_value && self.end <= max_value);\n+        self.start == (self.end.wrapping_add(1) & max_value)\n+    }\n+}\n+\n+impl fmt::Debug for WrappingRange {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if self.start > self.end {\n+            write!(fmt, \"(..={}) | ({}..)\", self.end, self.start)?;\n+        } else {\n+            write!(fmt, \"{}..={}\", self.start, self.end)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+/// Information about one scalar component of a Rust type.\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n+pub enum Scalar {\n+    Initialized {\n+        value: Primitive,\n+\n+        // FIXME(eddyb) always use the shortest range, e.g., by finding\n+        // the largest space between two consecutive valid values and\n+        // taking everything else as the (shortest) valid range.\n+        valid_range: WrappingRange,\n+    },\n+    Union {\n+        /// Even for unions, we need to use the correct registers for the kind of\n+        /// values inside the union, so we keep the `Primitive` type around. We\n+        /// also use it to compute the size of the scalar.\n+        /// However, unions never have niches and even allow undef,\n+        /// so there is no `valid_range`.\n+        value: Primitive,\n+    },\n+}\n+\n+impl Scalar {\n+    #[inline]\n+    pub fn is_bool(&self) -> bool {\n+        matches!(\n+            self,\n+            Scalar::Initialized {\n+                value: Int(I8, false),\n+                valid_range: WrappingRange { start: 0, end: 1 }\n+            }\n+        )\n+    }\n+\n+    /// Get the primitive representation of this type, ignoring the valid range and whether the\n+    /// value is allowed to be undefined (due to being a union).\n+    pub fn primitive(&self) -> Primitive {\n+        match *self {\n+            Scalar::Initialized { value, .. } | Scalar::Union { value } => value,\n+        }\n+    }\n+\n+    pub fn align(self, cx: &impl HasDataLayout) -> AbiAndPrefAlign {\n+        self.primitive().align(cx)\n+    }\n+\n+    pub fn size(self, cx: &impl HasDataLayout) -> Size {\n+        self.primitive().size(cx)\n+    }\n+\n+    #[inline]\n+    pub fn to_union(&self) -> Self {\n+        Self::Union { value: self.primitive() }\n+    }\n+\n+    #[inline]\n+    pub fn valid_range(&self, cx: &impl HasDataLayout) -> WrappingRange {\n+        match *self {\n+            Scalar::Initialized { valid_range, .. } => valid_range,\n+            Scalar::Union { value } => WrappingRange::full(value.size(cx)),\n+        }\n+    }\n+\n+    #[inline]\n+    /// Allows the caller to mutate the valid range. This operation will panic if attempted on a union.\n+    pub fn valid_range_mut(&mut self) -> &mut WrappingRange {\n+        match self {\n+            Scalar::Initialized { valid_range, .. } => valid_range,\n+            Scalar::Union { .. } => panic!(\"cannot change the valid range of a union\"),\n+        }\n+    }\n+\n+    /// Returns `true` if all possible numbers are valid, i.e `valid_range` covers the whole layout\n+    #[inline]\n+    pub fn is_always_valid<C: HasDataLayout>(&self, cx: &C) -> bool {\n+        match *self {\n+            Scalar::Initialized { valid_range, .. } => valid_range.is_full_for(self.size(cx)),\n+            Scalar::Union { .. } => true,\n+        }\n+    }\n+\n+    /// Returns `true` if this type can be left uninit.\n+    #[inline]\n+    pub fn is_uninit_valid(&self) -> bool {\n+        match *self {\n+            Scalar::Initialized { .. } => false,\n+            Scalar::Union { .. } => true,\n+        }\n+    }\n+}\n+\n+/// Describes how the fields of a type are located in memory.\n+#[derive(PartialEq, Eq, Hash, Clone, Debug)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n+pub enum FieldsShape {\n+    /// Scalar primitives and `!`, which never have fields.\n+    Primitive,\n+\n+    /// All fields start at no offset. The `usize` is the field count.\n+    Union(NonZeroUsize),\n+\n+    /// Array/vector-like placement, with all fields of identical types.\n+    Array { stride: Size, count: u64 },\n+\n+    /// Struct-like placement, with precomputed offsets.\n+    ///\n+    /// Fields are guaranteed to not overlap, but note that gaps\n+    /// before, between and after all the fields are NOT always\n+    /// padding, and as such their contents may not be discarded.\n+    /// For example, enum variants leave a gap at the start,\n+    /// where the discriminant field in the enum layout goes.\n+    Arbitrary {\n+        /// Offsets for the first byte of each field,\n+        /// ordered to match the source definition order.\n+        /// This vector does not go in increasing order.\n+        // FIXME(eddyb) use small vector optimization for the common case.\n+        offsets: Vec<Size>,\n+\n+        /// Maps source order field indices to memory order indices,\n+        /// depending on how the fields were reordered (if at all).\n+        /// This is a permutation, with both the source order and the\n+        /// memory order using the same (0..n) index ranges.\n+        ///\n+        /// Note that during computation of `memory_index`, sometimes\n+        /// it is easier to operate on the inverse mapping (that is,\n+        /// from memory order to source order), and that is usually\n+        /// named `inverse_memory_index`.\n+        ///\n+        // FIXME(eddyb) build a better abstraction for permutations, if possible.\n+        // FIXME(camlorn) also consider small vector  optimization here.\n+        memory_index: Vec<u32>,\n+    },\n+}\n+\n+impl FieldsShape {\n+    #[inline]\n+    pub fn count(&self) -> usize {\n+        match *self {\n+            FieldsShape::Primitive => 0,\n+            FieldsShape::Union(count) => count.get(),\n+            FieldsShape::Array { count, .. } => count.try_into().unwrap(),\n+            FieldsShape::Arbitrary { ref offsets, .. } => offsets.len(),\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn offset(&self, i: usize) -> Size {\n+        match *self {\n+            FieldsShape::Primitive => {\n+                unreachable!(\"FieldsShape::offset: `Primitive`s have no fields\")\n+            }\n+            FieldsShape::Union(count) => {\n+                assert!(\n+                    i < count.get(),\n+                    \"tried to access field {} of union with {} fields\",\n+                    i,\n+                    count\n+                );\n+                Size::ZERO\n+            }\n+            FieldsShape::Array { stride, count } => {\n+                let i = u64::try_from(i).unwrap();\n+                assert!(i < count);\n+                stride * i\n+            }\n+            FieldsShape::Arbitrary { ref offsets, .. } => offsets[i],\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn memory_index(&self, i: usize) -> usize {\n+        match *self {\n+            FieldsShape::Primitive => {\n+                unreachable!(\"FieldsShape::memory_index: `Primitive`s have no fields\")\n+            }\n+            FieldsShape::Union(_) | FieldsShape::Array { .. } => i,\n+            FieldsShape::Arbitrary { ref memory_index, .. } => memory_index[i].try_into().unwrap(),\n+        }\n+    }\n+\n+    /// Gets source indices of the fields by increasing offsets.\n+    #[inline]\n+    pub fn index_by_increasing_offset<'a>(&'a self) -> impl Iterator<Item = usize> + 'a {\n+        let mut inverse_small = [0u8; 64];\n+        let mut inverse_big = vec![];\n+        let use_small = self.count() <= inverse_small.len();\n+\n+        // We have to write this logic twice in order to keep the array small.\n+        if let FieldsShape::Arbitrary { ref memory_index, .. } = *self {\n+            if use_small {\n+                for i in 0..self.count() {\n+                    inverse_small[memory_index[i] as usize] = i as u8;\n+                }\n+            } else {\n+                inverse_big = vec![0; self.count()];\n+                for i in 0..self.count() {\n+                    inverse_big[memory_index[i] as usize] = i as u32;\n+                }\n+            }\n+        }\n+\n+        (0..self.count()).map(move |i| match *self {\n+            FieldsShape::Primitive | FieldsShape::Union(_) | FieldsShape::Array { .. } => i,\n+            FieldsShape::Arbitrary { .. } => {\n+                if use_small {\n+                    inverse_small[i] as usize\n+                } else {\n+                    inverse_big[i] as usize\n+                }\n+            }\n+        })\n+    }\n+}\n+\n+/// An identifier that specifies the address space that some operation\n+/// should operate on. Special address spaces have an effect on code generation,\n+/// depending on the target and the address spaces it implements.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct AddressSpace(pub u32);\n+\n+impl AddressSpace {\n+    /// The default address space, corresponding to data space.\n+    pub const DATA: Self = AddressSpace(0);\n+}\n+\n+/// Describes how values of the type are passed by target ABIs,\n+/// in terms of categories of C types there are ABI rules for.\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n+\n+pub enum Abi {\n+    Uninhabited,\n+    Scalar(Scalar),\n+    ScalarPair(Scalar, Scalar),\n+    Vector {\n+        element: Scalar,\n+        count: u64,\n+    },\n+    Aggregate {\n+        /// If true, the size is exact, otherwise it's only a lower bound.\n+        sized: bool,\n+    },\n+}\n+\n+impl Abi {\n+    /// Returns `true` if the layout corresponds to an unsized type.\n+    #[inline]\n+    pub fn is_unsized(&self) -> bool {\n+        match *self {\n+            Abi::Uninhabited | Abi::Scalar(_) | Abi::ScalarPair(..) | Abi::Vector { .. } => false,\n+            Abi::Aggregate { sized } => !sized,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn is_sized(&self) -> bool {\n+        !self.is_unsized()\n+    }\n+\n+    /// Returns `true` if this is a single signed integer scalar\n+    #[inline]\n+    pub fn is_signed(&self) -> bool {\n+        match self {\n+            Abi::Scalar(scal) => match scal.primitive() {\n+                Primitive::Int(_, signed) => signed,\n+                _ => false,\n+            },\n+            _ => panic!(\"`is_signed` on non-scalar ABI {:?}\", self),\n+        }\n+    }\n+\n+    /// Returns `true` if this is an uninhabited type\n+    #[inline]\n+    pub fn is_uninhabited(&self) -> bool {\n+        matches!(*self, Abi::Uninhabited)\n+    }\n+\n+    /// Returns `true` is this is a scalar type\n+    #[inline]\n+    pub fn is_scalar(&self) -> bool {\n+        matches!(*self, Abi::Scalar(_))\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Hash, Clone, Debug)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n+pub enum Variants<V: Idx> {\n+    /// Single enum variants, structs/tuples, unions, and all non-ADTs.\n+    Single { index: V },\n+\n+    /// Enum-likes with more than one inhabited variant: each variant comes with\n+    /// a *discriminant* (usually the same as the variant index but the user can\n+    /// assign explicit discriminant values).  That discriminant is encoded\n+    /// as a *tag* on the machine.  The layout of each variant is\n+    /// a struct, and they all have space reserved for the tag.\n+    /// For enums, the tag is the sole field of the layout.\n+    Multiple {\n+        tag: Scalar,\n+        tag_encoding: TagEncoding<V>,\n+        tag_field: usize,\n+        variants: IndexVec<V, LayoutS<V>>,\n+    },\n+}\n+\n+#[derive(PartialEq, Eq, Hash, Clone, Debug)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n+pub enum TagEncoding<V: Idx> {\n+    /// The tag directly stores the discriminant, but possibly with a smaller layout\n+    /// (so converting the tag to the discriminant can require sign extension).\n+    Direct,\n+\n+    /// Niche (values invalid for a type) encoding the discriminant:\n+    /// Discriminant and variant index coincide.\n+    /// The variant `untagged_variant` contains a niche at an arbitrary\n+    /// offset (field `tag_field` of the enum), which for a variant with\n+    /// discriminant `d` is set to\n+    /// `(d - niche_variants.start).wrapping_add(niche_start)`.\n+    ///\n+    /// For example, `Option<(usize, &T)>`  is represented such that\n+    /// `None` has a null pointer for the second tuple field, and\n+    /// `Some` is the identity function (with a non-null reference).\n+    Niche { untagged_variant: V, niche_variants: RangeInclusive<V>, niche_start: u128 },\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n+pub struct Niche {\n+    pub offset: Size,\n+    pub value: Primitive,\n+    pub valid_range: WrappingRange,\n+}\n+\n+impl Niche {\n+    pub fn from_scalar<C: HasDataLayout>(cx: &C, offset: Size, scalar: Scalar) -> Option<Self> {\n+        let Scalar::Initialized { value, valid_range } = scalar else { return None };\n+        let niche = Niche { offset, value, valid_range };\n+        if niche.available(cx) > 0 { Some(niche) } else { None }\n+    }\n+\n+    pub fn available<C: HasDataLayout>(&self, cx: &C) -> u128 {\n+        let Self { value, valid_range: v, .. } = *self;\n+        let size = value.size(cx);\n+        assert!(size.bits() <= 128);\n+        let max_value = size.unsigned_int_max();\n+\n+        // Find out how many values are outside the valid range.\n+        let niche = v.end.wrapping_add(1)..v.start;\n+        niche.end.wrapping_sub(niche.start) & max_value\n+    }\n+\n+    pub fn reserve<C: HasDataLayout>(&self, cx: &C, count: u128) -> Option<(u128, Scalar)> {\n+        assert!(count > 0);\n+\n+        let Self { value, valid_range: v, .. } = *self;\n+        let size = value.size(cx);\n+        assert!(size.bits() <= 128);\n+        let max_value = size.unsigned_int_max();\n+\n+        let niche = v.end.wrapping_add(1)..v.start;\n+        let available = niche.end.wrapping_sub(niche.start) & max_value;\n+        if count > available {\n+            return None;\n+        }\n+\n+        // Extend the range of valid values being reserved by moving either `v.start` or `v.end` bound.\n+        // Given an eventual `Option<T>`, we try to maximize the chance for `None` to occupy the niche of zero.\n+        // This is accomplished by preferring enums with 2 variants(`count==1`) and always taking the shortest path to niche zero.\n+        // Having `None` in niche zero can enable some special optimizations.\n+        //\n+        // Bound selection criteria:\n+        // 1. Select closest to zero given wrapping semantics.\n+        // 2. Avoid moving past zero if possible.\n+        //\n+        // In practice this means that enums with `count > 1` are unlikely to claim niche zero, since they have to fit perfectly.\n+        // If niche zero is already reserved, the selection of bounds are of little interest.\n+        let move_start = |v: WrappingRange| {\n+            let start = v.start.wrapping_sub(count) & max_value;\n+            Some((start, Scalar::Initialized { value, valid_range: v.with_start(start) }))\n+        };\n+        let move_end = |v: WrappingRange| {\n+            let start = v.end.wrapping_add(1) & max_value;\n+            let end = v.end.wrapping_add(count) & max_value;\n+            Some((start, Scalar::Initialized { value, valid_range: v.with_end(end) }))\n+        };\n+        let distance_end_zero = max_value - v.end;\n+        if v.start > v.end {\n+            // zero is unavailable because wrapping occurs\n+            move_end(v)\n+        } else if v.start <= distance_end_zero {\n+            if count <= v.start {\n+                move_start(v)\n+            } else {\n+                // moved past zero, use other bound\n+                move_end(v)\n+            }\n+        } else {\n+            let end = v.end.wrapping_add(count) & max_value;\n+            let overshot_zero = (1..=v.end).contains(&end);\n+            if overshot_zero {\n+                // moved past zero, use other bound\n+                move_start(v)\n+            } else {\n+                move_end(v)\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Hash, Clone)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n+pub struct LayoutS<V: Idx> {\n+    /// Says where the fields are located within the layout.\n+    pub fields: FieldsShape,\n+\n+    /// Encodes information about multi-variant layouts.\n+    /// Even with `Multiple` variants, a layout still has its own fields! Those are then\n+    /// shared between all variants. One of them will be the discriminant,\n+    /// but e.g. generators can have more.\n+    ///\n+    /// To access all fields of this layout, both `fields` and the fields of the active variant\n+    /// must be taken into account.\n+    pub variants: Variants<V>,\n+\n+    /// The `abi` defines how this data is passed between functions, and it defines\n+    /// value restrictions via `valid_range`.\n+    ///\n+    /// Note that this is entirely orthogonal to the recursive structure defined by\n+    /// `variants` and `fields`; for example, `ManuallyDrop<Result<isize, isize>>` has\n+    /// `Abi::ScalarPair`! So, even with non-`Aggregate` `abi`, `fields` and `variants`\n+    /// have to be taken into account to find all fields of this layout.\n+    pub abi: Abi,\n+\n+    /// The leaf scalar with the largest number of invalid values\n+    /// (i.e. outside of its `valid_range`), if it exists.\n+    pub largest_niche: Option<Niche>,\n+\n+    pub align: AbiAndPrefAlign,\n+    pub size: Size,\n+}\n+\n+impl<V: Idx> LayoutS<V> {\n+    pub fn scalar<C: HasDataLayout>(cx: &C, scalar: Scalar) -> Self {\n+        let largest_niche = Niche::from_scalar(cx, Size::ZERO, scalar);\n+        let size = scalar.size(cx);\n+        let align = scalar.align(cx);\n+        LayoutS {\n+            variants: Variants::Single { index: V::new(0) },\n+            fields: FieldsShape::Primitive,\n+            abi: Abi::Scalar(scalar),\n+            largest_niche,\n+            size,\n+            align,\n+        }\n+    }\n+}\n+\n+impl<V: Idx> fmt::Debug for LayoutS<V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // This is how `Layout` used to print before it become\n+        // `Interned<LayoutS>`. We print it like this to avoid having to update\n+        // expected output in a lot of tests.\n+        let LayoutS { size, align, abi, fields, largest_niche, variants } = self;\n+        f.debug_struct(\"Layout\")\n+            .field(\"size\", size)\n+            .field(\"align\", align)\n+            .field(\"abi\", abi)\n+            .field(\"fields\", fields)\n+            .field(\"largest_niche\", largest_niche)\n+            .field(\"variants\", variants)\n+            .finish()\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum PointerKind {\n+    /// Most general case, we know no restrictions to tell LLVM.\n+    SharedMutable,\n+\n+    /// `&T` where `T` contains no `UnsafeCell`, is `dereferenceable`, `noalias` and `readonly`.\n+    Frozen,\n+\n+    /// `&mut T` which is `dereferenceable` and `noalias` but not `readonly`.\n+    UniqueBorrowed,\n+\n+    /// `&mut !Unpin`, which is `dereferenceable` but neither `noalias` nor `readonly`.\n+    UniqueBorrowedPinned,\n+\n+    /// `Box<T>`, which is `noalias` (even on return types, unlike the above) but neither `readonly`\n+    /// nor `dereferenceable`.\n+    UniqueOwned,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub struct PointeeInfo {\n+    pub size: Size,\n+    pub align: Align,\n+    pub safe: Option<PointerKind>,\n+    pub address_space: AddressSpace,\n+}\n+\n+/// Used in `might_permit_raw_init` to indicate the kind of initialisation\n+/// that is checked to be valid\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum InitKind {\n+    Zero,\n+    UninitMitigated0x01Fill,\n+}\n+\n+impl<V: Idx> LayoutS<V> {\n+    /// Returns `true` if the layout corresponds to an unsized type.\n+    pub fn is_unsized(&self) -> bool {\n+        self.abi.is_unsized()\n+    }\n+\n+    pub fn is_sized(&self) -> bool {\n+        self.abi.is_sized()\n+    }\n+\n+    /// Returns `true` if the type is a ZST and not unsized.\n+    pub fn is_zst(&self) -> bool {\n+        match self.abi {\n+            Abi::Scalar(_) | Abi::ScalarPair(..) | Abi::Vector { .. } => false,\n+            Abi::Uninhabited => self.size.bytes() == 0,\n+            Abi::Aggregate { sized } => sized && self.size.bytes() == 0,\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum StructKind {\n+    /// A tuple, closure, or univariant which cannot be coerced to unsized.\n+    AlwaysSized,\n+    /// A univariant, the last field of which may be coerced to unsized.\n+    MaybeUnsized,\n+    /// A univariant, but with a prefix of an arbitrary size & alignment (e.g., enum tag).\n+    Prefixed(Size, Align),\n+}"}, {"sha": "49a070badc6de5c30c6cbd4b81b0407b970d9621", "filename": "compiler/rustc_arena/src/tests.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_arena%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_arena%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Ftests.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -52,19 +52,15 @@ fn test_arena_alloc_nested() {\n \n     impl<'a> Wrap<'a> {\n         fn alloc_inner<F: Fn() -> Inner>(&self, f: F) -> &Inner {\n-            let r: &EI<'_> = self.0.alloc(EI::I(f()));\n-            if let &EI::I(ref i) = r {\n-                i\n-            } else {\n-                panic!(\"mismatch\");\n+            match self.0.alloc(EI::I(f())) {\n+                EI::I(i) => i,\n+                _ => panic!(\"mismatch\"),\n             }\n         }\n         fn alloc_outer<F: Fn() -> Outer<'a>>(&self, f: F) -> &Outer<'_> {\n-            let r: &EI<'_> = self.0.alloc(EI::O(f()));\n-            if let &EI::O(ref o) = r {\n-                o\n-            } else {\n-                panic!(\"mismatch\");\n+            match self.0.alloc(EI::O(f())) {\n+                EI::O(o) => o,\n+                _ => panic!(\"mismatch\"),\n             }\n         }\n     }"}, {"sha": "b48a7d29f509723272a4dc77f887edf9cf610fbc", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 111, "deletions": 72, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -175,9 +175,9 @@ impl GenericArgs {\n     }\n \n     pub fn span(&self) -> Span {\n-        match *self {\n-            AngleBracketed(ref data) => data.span,\n-            Parenthesized(ref data) => data.span,\n+        match self {\n+            AngleBracketed(data) => data.span,\n+            Parenthesized(data) => data.span,\n         }\n     }\n }\n@@ -312,8 +312,8 @@ pub enum GenericBound {\n impl GenericBound {\n     pub fn span(&self) -> Span {\n         match self {\n-            GenericBound::Trait(ref t, ..) => t.span,\n-            GenericBound::Outlives(ref l) => l.ident.span,\n+            GenericBound::Trait(t, ..) => t.span,\n+            GenericBound::Outlives(l) => l.ident.span,\n         }\n     }\n }\n@@ -775,8 +775,9 @@ pub enum PatKind {\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Copy)]\n #[derive(HashStable_Generic, Encodable, Decodable)]\n pub enum Mutability {\n-    Mut,\n+    // N.B. Order is deliberate, so that Not < Mut\n     Not,\n+    Mut,\n }\n \n impl Mutability {\n@@ -787,12 +788,39 @@ impl Mutability {\n         }\n     }\n \n-    pub fn prefix_str(&self) -> &'static str {\n+    /// Returns `\"\"` (empty string) or `\"mut \"` depending on the mutability.\n+    pub fn prefix_str(self) -> &'static str {\n         match self {\n             Mutability::Mut => \"mut \",\n             Mutability::Not => \"\",\n         }\n     }\n+\n+    /// Returns `\"&\"` or `\"&mut \"` depending on the mutability.\n+    pub fn ref_prefix_str(self) -> &'static str {\n+        match self {\n+            Mutability::Not => \"&\",\n+            Mutability::Mut => \"&mut \",\n+        }\n+    }\n+\n+    /// Returns `\"\"` (empty string) or `\"mutably \"` depending on the mutability.\n+    pub fn mutably_str(self) -> &'static str {\n+        match self {\n+            Mutability::Not => \"\",\n+            Mutability::Mut => \"mutably \",\n+        }\n+    }\n+\n+    /// Return `true` if self is mutable\n+    pub fn is_mut(self) -> bool {\n+        matches!(self, Self::Mut)\n+    }\n+\n+    /// Return `true` if self is **not** mutable\n+    pub fn is_not(self) -> bool {\n+        matches!(self, Self::Not)\n+    }\n }\n \n /// The kind of borrow in an `AddrOf` expression,\n@@ -1115,23 +1143,23 @@ impl Expr {\n     /// If this is not the case, name resolution does not resolve `N` when using\n     /// `min_const_generics` as more complex expressions are not supported.\n     pub fn is_potential_trivial_const_param(&self) -> bool {\n-        let this = if let ExprKind::Block(ref block, None) = self.kind {\n-            if block.stmts.len() == 1 {\n-                if let StmtKind::Expr(ref expr) = block.stmts[0].kind { expr } else { self }\n-            } else {\n-                self\n-            }\n+        let this = if let ExprKind::Block(block, None) = &self.kind\n+            && block.stmts.len() == 1\n+            && let StmtKind::Expr(expr) = &block.stmts[0].kind\n+        {\n+            expr\n         } else {\n             self\n         };\n \n-        if let ExprKind::Path(None, ref path) = this.kind {\n-            if path.segments.len() == 1 && path.segments[0].args.is_none() {\n-                return true;\n-            }\n+        if let ExprKind::Path(None, path) = &this.kind\n+            && path.segments.len() == 1\n+            && path.segments[0].args.is_none()\n+        {\n+            true\n+        } else {\n+            false\n         }\n-\n-        false\n     }\n \n     pub fn to_bound(&self) -> Option<GenericBound> {\n@@ -1376,7 +1404,7 @@ pub enum ExprKind {\n     /// Conditionless loop (can be exited with `break`, `continue`, or `return`).\n     ///\n     /// `'label: loop { block }`\n-    Loop(P<Block>, Option<Label>),\n+    Loop(P<Block>, Option<Label>, Span),\n     /// A `match` block.\n     Match(P<Expr>, Vec<Arm>),\n     /// A closure (e.g., `move |a, b, c| a + b + c`).\n@@ -1544,55 +1572,48 @@ pub enum ClosureBinder {\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct MacCall {\n     pub path: Path,\n-    pub args: P<MacArgs>,\n+    pub args: P<DelimArgs>,\n     pub prior_type_ascription: Option<(Span, bool)>,\n }\n \n impl MacCall {\n     pub fn span(&self) -> Span {\n-        self.path.span.to(self.args.span().unwrap_or(self.path.span))\n+        self.path.span.to(self.args.dspan.entire())\n     }\n }\n \n-/// Arguments passed to an attribute or a function-like macro.\n+/// Arguments passed to an attribute macro.\n #[derive(Clone, Encodable, Decodable, Debug)]\n-pub enum MacArgs {\n-    /// No arguments - `#[attr]`.\n+pub enum AttrArgs {\n+    /// No arguments: `#[attr]`.\n     Empty,\n-    /// Delimited arguments - `#[attr()/[]/{}]` or `mac!()/[]/{}`.\n-    Delimited(DelimSpan, MacDelimiter, TokenStream),\n-    /// Arguments of a key-value attribute - `#[attr = \"value\"]`.\n+    /// Delimited arguments: `#[attr()/[]/{}]`.\n+    Delimited(DelimArgs),\n+    /// Arguments of a key-value attribute: `#[attr = \"value\"]`.\n     Eq(\n         /// Span of the `=` token.\n         Span,\n         /// The \"value\".\n-        MacArgsEq,\n+        AttrArgsEq,\n     ),\n }\n \n-// The RHS of a `MacArgs::Eq` starts out as an expression. Once macro expansion\n-// is completed, all cases end up either as a literal, which is the form used\n-// after lowering to HIR, or as an error.\n+// The RHS of an `AttrArgs::Eq` starts out as an expression. Once macro\n+// expansion is completed, all cases end up either as a literal, which is the\n+// form used after lowering to HIR, or as an error.\n #[derive(Clone, Encodable, Decodable, Debug)]\n-pub enum MacArgsEq {\n+pub enum AttrArgsEq {\n     Ast(P<Expr>),\n     Hir(Lit),\n }\n \n-impl MacArgs {\n-    pub fn delim(&self) -> Option<Delimiter> {\n-        match self {\n-            MacArgs::Delimited(_, delim, _) => Some(delim.to_token()),\n-            MacArgs::Empty | MacArgs::Eq(..) => None,\n-        }\n-    }\n-\n+impl AttrArgs {\n     pub fn span(&self) -> Option<Span> {\n         match self {\n-            MacArgs::Empty => None,\n-            MacArgs::Delimited(dspan, ..) => Some(dspan.entire()),\n-            MacArgs::Eq(eq_span, MacArgsEq::Ast(expr)) => Some(eq_span.to(expr.span)),\n-            MacArgs::Eq(_, MacArgsEq::Hir(lit)) => {\n+            AttrArgs::Empty => None,\n+            AttrArgs::Delimited(args) => Some(args.dspan.entire()),\n+            AttrArgs::Eq(eq_span, AttrArgsEq::Ast(expr)) => Some(eq_span.to(expr.span)),\n+            AttrArgs::Eq(_, AttrArgsEq::Hir(lit)) => {\n                 unreachable!(\"in literal form when getting span: {:?}\", lit);\n             }\n         }\n@@ -1602,46 +1623,64 @@ impl MacArgs {\n     /// Proc macros see these tokens, for example.\n     pub fn inner_tokens(&self) -> TokenStream {\n         match self {\n-            MacArgs::Empty => TokenStream::default(),\n-            MacArgs::Delimited(.., tokens) => tokens.clone(),\n-            MacArgs::Eq(_, MacArgsEq::Ast(expr)) => TokenStream::from_ast(expr),\n-            MacArgs::Eq(_, MacArgsEq::Hir(lit)) => {\n+            AttrArgs::Empty => TokenStream::default(),\n+            AttrArgs::Delimited(args) => args.tokens.clone(),\n+            AttrArgs::Eq(_, AttrArgsEq::Ast(expr)) => TokenStream::from_ast(expr),\n+            AttrArgs::Eq(_, AttrArgsEq::Hir(lit)) => {\n                 unreachable!(\"in literal form when getting inner tokens: {:?}\", lit)\n             }\n         }\n     }\n-\n-    /// Whether a macro with these arguments needs a semicolon\n-    /// when used as a standalone item or statement.\n-    pub fn need_semicolon(&self) -> bool {\n-        !matches!(self, MacArgs::Delimited(_, MacDelimiter::Brace, _))\n-    }\n }\n \n-impl<CTX> HashStable<CTX> for MacArgs\n+impl<CTX> HashStable<CTX> for AttrArgs\n where\n     CTX: crate::HashStableContext,\n {\n     fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(ctx, hasher);\n         match self {\n-            MacArgs::Empty => {}\n-            MacArgs::Delimited(dspan, delim, tokens) => {\n-                dspan.hash_stable(ctx, hasher);\n-                delim.hash_stable(ctx, hasher);\n-                tokens.hash_stable(ctx, hasher);\n-            }\n-            MacArgs::Eq(_eq_span, MacArgsEq::Ast(expr)) => {\n+            AttrArgs::Empty => {}\n+            AttrArgs::Delimited(args) => args.hash_stable(ctx, hasher),\n+            AttrArgs::Eq(_eq_span, AttrArgsEq::Ast(expr)) => {\n                 unreachable!(\"hash_stable {:?}\", expr);\n             }\n-            MacArgs::Eq(eq_span, MacArgsEq::Hir(lit)) => {\n+            AttrArgs::Eq(eq_span, AttrArgsEq::Hir(lit)) => {\n                 eq_span.hash_stable(ctx, hasher);\n                 lit.hash_stable(ctx, hasher);\n             }\n         }\n     }\n }\n \n+/// Delimited arguments, as used in `#[attr()/[]/{}]` or `mac!()/[]/{}`.\n+#[derive(Clone, Encodable, Decodable, Debug)]\n+pub struct DelimArgs {\n+    pub dspan: DelimSpan,\n+    pub delim: MacDelimiter,\n+    pub tokens: TokenStream,\n+}\n+\n+impl DelimArgs {\n+    /// Whether a macro with these arguments needs a semicolon\n+    /// when used as a standalone item or statement.\n+    pub fn need_semicolon(&self) -> bool {\n+        !matches!(self, DelimArgs { delim: MacDelimiter::Brace, .. })\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for DelimArgs\n+where\n+    CTX: crate::HashStableContext,\n+{\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n+        let DelimArgs { dspan, delim, tokens } = self;\n+        dspan.hash_stable(ctx, hasher);\n+        delim.hash_stable(ctx, hasher);\n+        tokens.hash_stable(ctx, hasher);\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum MacDelimiter {\n     Parenthesis,\n@@ -1671,7 +1710,7 @@ impl MacDelimiter {\n /// Represents a macro definition.\n #[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct MacroDef {\n-    pub body: P<MacArgs>,\n+    pub body: P<DelimArgs>,\n     /// `true` if macro was defined with `macro_rules`.\n     pub macro_rules: bool,\n }\n@@ -2393,9 +2432,9 @@ pub enum FnRetTy {\n \n impl FnRetTy {\n     pub fn span(&self) -> Span {\n-        match *self {\n-            FnRetTy::Default(span) => span,\n-            FnRetTy::Ty(ref ty) => ty.span,\n+        match self {\n+            &FnRetTy::Default(span) => span,\n+            FnRetTy::Ty(ty) => ty.span,\n         }\n     }\n }\n@@ -2534,7 +2573,7 @@ impl<D: Decoder> Decodable<D> for AttrId {\n #[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct AttrItem {\n     pub path: Path,\n-    pub args: MacArgs,\n+    pub args: AttrArgs,\n     pub tokens: Option<LazyAttrTokenStream>,\n }\n \n@@ -2657,14 +2696,14 @@ pub enum VariantData {\n impl VariantData {\n     /// Return the fields of this variant.\n     pub fn fields(&self) -> &[FieldDef] {\n-        match *self {\n-            VariantData::Struct(ref fields, ..) | VariantData::Tuple(ref fields, _) => fields,\n+        match self {\n+            VariantData::Struct(fields, ..) | VariantData::Tuple(fields, _) => fields,\n             _ => &[],\n         }\n     }\n \n     /// Return the `NodeId` of this variant's constructor, if it has one.\n-    pub fn ctor_id(&self) -> Option<NodeId> {\n+    pub fn ctor_node_id(&self) -> Option<NodeId> {\n         match *self {\n             VariantData::Struct(..) => None,\n             VariantData::Tuple(_, id) | VariantData::Unit(id) => Some(id),"}, {"sha": "3e0129531150c9f9bf651a92300aa0ded41c0e16", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 77, "deletions": 74, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -1,9 +1,9 @@\n //! Functions dealing with attributes and meta items.\n \n use crate::ast;\n-use crate::ast::{AttrId, AttrItem, AttrKind, AttrStyle, Attribute};\n-use crate::ast::{Lit, LitKind};\n-use crate::ast::{MacArgs, MacArgsEq, MacDelimiter, MetaItem, MetaItemKind, NestedMetaItem};\n+use crate::ast::{AttrArgs, AttrArgsEq, AttrId, AttrItem, AttrKind, AttrStyle, Attribute};\n+use crate::ast::{DelimArgs, Lit, LitKind};\n+use crate::ast::{MacDelimiter, MetaItem, MetaItemKind, NestedMetaItem};\n use crate::ast::{Path, PathSegment};\n use crate::ptr::P;\n use crate::token::{self, CommentKind, Delimiter, Token};\n@@ -44,16 +44,16 @@ impl MarkedAttrs {\n impl NestedMetaItem {\n     /// Returns the `MetaItem` if `self` is a `NestedMetaItem::MetaItem`.\n     pub fn meta_item(&self) -> Option<&MetaItem> {\n-        match *self {\n-            NestedMetaItem::MetaItem(ref item) => Some(item),\n+        match self {\n+            NestedMetaItem::MetaItem(item) => Some(item),\n             _ => None,\n         }\n     }\n \n     /// Returns the `Lit` if `self` is a `NestedMetaItem::Literal`s.\n     pub fn literal(&self) -> Option<&Lit> {\n-        match *self {\n-            NestedMetaItem::Literal(ref lit) => Some(lit),\n+        match self {\n+            NestedMetaItem::Literal(lit) => Some(lit),\n             _ => None,\n         }\n     }\n@@ -116,18 +116,18 @@ impl NestedMetaItem {\n impl Attribute {\n     #[inline]\n     pub fn has_name(&self, name: Symbol) -> bool {\n-        match self.kind {\n-            AttrKind::Normal(ref normal) => normal.item.path == name,\n+        match &self.kind {\n+            AttrKind::Normal(normal) => normal.item.path == name,\n             AttrKind::DocComment(..) => false,\n         }\n     }\n \n     /// For a single-segment attribute, returns its name; otherwise, returns `None`.\n     pub fn ident(&self) -> Option<Ident> {\n-        match self.kind {\n-            AttrKind::Normal(ref normal) => {\n-                if normal.item.path.segments.len() == 1 {\n-                    Some(normal.item.path.segments[0].ident)\n+        match &self.kind {\n+            AttrKind::Normal(normal) => {\n+                if let [ident] = &*normal.item.path.segments {\n+                    Some(ident.ident)\n                 } else {\n                     None\n                 }\n@@ -140,17 +140,15 @@ impl Attribute {\n     }\n \n     pub fn value_str(&self) -> Option<Symbol> {\n-        match self.kind {\n-            AttrKind::Normal(ref normal) => {\n-                normal.item.meta_kind().and_then(|kind| kind.value_str())\n-            }\n+        match &self.kind {\n+            AttrKind::Normal(normal) => normal.item.meta_kind().and_then(|kind| kind.value_str()),\n             AttrKind::DocComment(..) => None,\n         }\n     }\n \n     pub fn meta_item_list(&self) -> Option<Vec<NestedMetaItem>> {\n-        match self.kind {\n-            AttrKind::Normal(ref normal) => match normal.item.meta_kind() {\n+        match &self.kind {\n+            AttrKind::Normal(normal) => match normal.item.meta_kind() {\n                 Some(MetaItemKind::List(list)) => Some(list),\n                 _ => None,\n             },\n@@ -160,7 +158,7 @@ impl Attribute {\n \n     pub fn is_word(&self) -> bool {\n         if let AttrKind::Normal(normal) = &self.kind {\n-            matches!(normal.item.args, MacArgs::Empty)\n+            matches!(normal.item.args, AttrArgs::Empty)\n         } else {\n             false\n         }\n@@ -191,8 +189,8 @@ impl MetaItem {\n     }\n \n     pub fn meta_item_list(&self) -> Option<&[NestedMetaItem]> {\n-        match self.kind {\n-            MetaItemKind::List(ref l) => Some(&l[..]),\n+        match &self.kind {\n+            MetaItemKind::List(l) => Some(&**l),\n             _ => None,\n         }\n     }\n@@ -225,13 +223,13 @@ impl AttrItem {\n     pub fn meta(&self, span: Span) -> Option<MetaItem> {\n         Some(MetaItem {\n             path: self.path.clone(),\n-            kind: MetaItemKind::from_mac_args(&self.args)?,\n+            kind: MetaItemKind::from_attr_args(&self.args)?,\n             span,\n         })\n     }\n \n     pub fn meta_kind(&self) -> Option<MetaItemKind> {\n-        MetaItemKind::from_mac_args(&self.args)\n+        MetaItemKind::from_attr_args(&self.args)\n     }\n }\n \n@@ -268,9 +266,9 @@ impl Attribute {\n     /// * `#[doc = \"doc\"]` returns `Some(\"doc\")`.\n     /// * `#[doc(...)]` returns `None`.\n     pub fn doc_str(&self) -> Option<Symbol> {\n-        match self.kind {\n-            AttrKind::DocComment(.., data) => Some(data),\n-            AttrKind::Normal(ref normal) if normal.item.path == sym::doc => {\n+        match &self.kind {\n+            AttrKind::DocComment(.., data) => Some(*data),\n+            AttrKind::Normal(normal) if normal.item.path == sym::doc => {\n                 normal.item.meta_kind().and_then(|kind| kind.value_str())\n             }\n             _ => None,\n@@ -282,8 +280,8 @@ impl Attribute {\n     }\n \n     pub fn get_normal_item(&self) -> &AttrItem {\n-        match self.kind {\n-            AttrKind::Normal(ref normal) => &normal.item,\n+        match &self.kind {\n+            AttrKind::Normal(normal) => &normal.item,\n             AttrKind::DocComment(..) => panic!(\"unexpected doc comment\"),\n         }\n     }\n@@ -297,28 +295,28 @@ impl Attribute {\n \n     /// Extracts the MetaItem from inside this Attribute.\n     pub fn meta(&self) -> Option<MetaItem> {\n-        match self.kind {\n-            AttrKind::Normal(ref normal) => normal.item.meta(self.span),\n+        match &self.kind {\n+            AttrKind::Normal(normal) => normal.item.meta(self.span),\n             AttrKind::DocComment(..) => None,\n         }\n     }\n \n     pub fn meta_kind(&self) -> Option<MetaItemKind> {\n-        match self.kind {\n-            AttrKind::Normal(ref normal) => normal.item.meta_kind(),\n+        match &self.kind {\n+            AttrKind::Normal(normal) => normal.item.meta_kind(),\n             AttrKind::DocComment(..) => None,\n         }\n     }\n \n     pub fn tokens(&self) -> TokenStream {\n-        match self.kind {\n-            AttrKind::Normal(ref normal) => normal\n+        match &self.kind {\n+            AttrKind::Normal(normal) => normal\n                 .tokens\n                 .as_ref()\n                 .unwrap_or_else(|| panic!(\"attribute is missing tokens: {:?}\", self))\n                 .to_attr_token_stream()\n                 .to_tokenstream(),\n-            AttrKind::DocComment(comment_kind, data) => TokenStream::new(vec![TokenTree::Token(\n+            &AttrKind::DocComment(comment_kind, data) => TokenStream::new(vec![TokenTree::Token(\n                 Token::new(token::DocComment(comment_kind, self.style, data), self.span),\n                 Spacing::Alone,\n             )]),\n@@ -392,7 +390,7 @@ pub fn mk_attr(\n     g: &AttrIdGenerator,\n     style: AttrStyle,\n     path: Path,\n-    args: MacArgs,\n+    args: AttrArgs,\n     span: Span,\n ) -> Attribute {\n     mk_attr_from_item(g, AttrItem { path, args, tokens: None }, None, style, span)\n@@ -415,12 +413,12 @@ pub fn mk_attr_from_item(\n \n /// Returns an inner attribute with the given value and span.\n pub fn mk_attr_inner(g: &AttrIdGenerator, item: MetaItem) -> Attribute {\n-    mk_attr(g, AttrStyle::Inner, item.path, item.kind.mac_args(item.span), item.span)\n+    mk_attr(g, AttrStyle::Inner, item.path, item.kind.attr_args(item.span), item.span)\n }\n \n /// Returns an outer attribute with the given value and span.\n pub fn mk_attr_outer(g: &AttrIdGenerator, item: MetaItem) -> Attribute {\n-    mk_attr(g, AttrStyle::Outer, item.path, item.kind.mac_args(item.span), item.span)\n+    mk_attr(g, AttrStyle::Outer, item.path, item.kind.attr_args(item.span), item.span)\n }\n \n pub fn mk_doc_comment(\n@@ -496,17 +494,17 @@ impl MetaItem {\n                 let span = span.with_hi(segments.last().unwrap().ident.span.hi());\n                 Path { span, segments, tokens: None }\n             }\n-            Some(TokenTree::Token(Token { kind: token::Interpolated(nt), .. }, _)) => match *nt {\n-                token::Nonterminal::NtMeta(ref item) => return item.meta(item.path.span),\n-                token::Nonterminal::NtPath(ref path) => (**path).clone(),\n+            Some(TokenTree::Token(Token { kind: token::Interpolated(nt), .. }, _)) => match &*nt {\n+                token::Nonterminal::NtMeta(item) => return item.meta(item.path.span),\n+                token::Nonterminal::NtPath(path) => (**path).clone(),\n                 _ => return None,\n             },\n             _ => return None,\n         };\n         let list_closing_paren_pos = tokens.peek().map(|tt| tt.span().hi());\n         let kind = MetaItemKind::from_tokens(tokens)?;\n-        let hi = match kind {\n-            MetaItemKind::NameValue(ref lit) => lit.span.hi(),\n+        let hi = match &kind {\n+            MetaItemKind::NameValue(lit) => lit.span.hi(),\n             MetaItemKind::List(..) => list_closing_paren_pos.unwrap_or(path.span.hi()),\n             _ => path.span.hi(),\n         };\n@@ -518,17 +516,17 @@ impl MetaItem {\n impl MetaItemKind {\n     pub fn value_str(&self) -> Option<Symbol> {\n         match self {\n-            MetaItemKind::NameValue(ref v) => match v.kind {\n-                LitKind::Str(ref s, _) => Some(*s),\n+            MetaItemKind::NameValue(v) => match v.kind {\n+                LitKind::Str(s, _) => Some(s),\n                 _ => None,\n             },\n             _ => None,\n         }\n     }\n \n-    pub fn mac_args(&self, span: Span) -> MacArgs {\n+    pub fn attr_args(&self, span: Span) -> AttrArgs {\n         match self {\n-            MetaItemKind::Word => MacArgs::Empty,\n+            MetaItemKind::Word => AttrArgs::Empty,\n             MetaItemKind::NameValue(lit) => {\n                 let expr = P(ast::Expr {\n                     id: ast::DUMMY_NODE_ID,\n@@ -537,7 +535,7 @@ impl MetaItemKind {\n                     attrs: ast::AttrVec::new(),\n                     tokens: None,\n                 });\n-                MacArgs::Eq(span, MacArgsEq::Ast(expr))\n+                AttrArgs::Eq(span, AttrArgsEq::Ast(expr))\n             }\n             MetaItemKind::List(list) => {\n                 let mut tts = Vec::new();\n@@ -547,25 +545,25 @@ impl MetaItemKind {\n                     }\n                     tts.extend(item.token_trees())\n                 }\n-                MacArgs::Delimited(\n-                    DelimSpan::from_single(span),\n-                    MacDelimiter::Parenthesis,\n-                    TokenStream::new(tts),\n-                )\n+                AttrArgs::Delimited(DelimArgs {\n+                    dspan: DelimSpan::from_single(span),\n+                    delim: MacDelimiter::Parenthesis,\n+                    tokens: TokenStream::new(tts),\n+                })\n             }\n         }\n     }\n \n     fn token_trees(&self, span: Span) -> Vec<TokenTree> {\n-        match *self {\n+        match self {\n             MetaItemKind::Word => vec![],\n-            MetaItemKind::NameValue(ref lit) => {\n+            MetaItemKind::NameValue(lit) => {\n                 vec![\n                     TokenTree::token_alone(token::Eq, span),\n                     TokenTree::Token(lit.to_token(), Spacing::Alone),\n                 ]\n             }\n-            MetaItemKind::List(ref list) => {\n+            MetaItemKind::List(list) => {\n                 let mut tokens = Vec::new();\n                 for (i, item) in list.iter().enumerate() {\n                     if i > 0 {\n@@ -610,20 +608,25 @@ impl MetaItemKind {\n         }\n     }\n \n-    fn from_mac_args(args: &MacArgs) -> Option<MetaItemKind> {\n+    fn from_attr_args(args: &AttrArgs) -> Option<MetaItemKind> {\n         match args {\n-            MacArgs::Empty => Some(MetaItemKind::Word),\n-            MacArgs::Delimited(_, MacDelimiter::Parenthesis, tokens) => {\n-                MetaItemKind::list_from_tokens(tokens.clone())\n-            }\n-            MacArgs::Delimited(..) => None,\n-            MacArgs::Eq(_, MacArgsEq::Ast(expr)) => match expr.kind {\n-                ast::ExprKind::Lit(token_lit) => Some(MetaItemKind::NameValue(\n-                    Lit::from_token_lit(token_lit, expr.span).expect(\"token_lit in from_mac_args\"),\n-                )),\n+            AttrArgs::Empty => Some(MetaItemKind::Word),\n+            AttrArgs::Delimited(DelimArgs {\n+                dspan: _,\n+                delim: MacDelimiter::Parenthesis,\n+                tokens,\n+            }) => MetaItemKind::list_from_tokens(tokens.clone()),\n+            AttrArgs::Delimited(..) => None,\n+            AttrArgs::Eq(_, AttrArgsEq::Ast(expr)) => match expr.kind {\n+                ast::ExprKind::Lit(token_lit) => {\n+                    // Turn failures to `None`, we'll get parse errors elsewhere.\n+                    Lit::from_token_lit(token_lit, expr.span)\n+                        .ok()\n+                        .map(|lit| MetaItemKind::NameValue(lit))\n+                }\n                 _ => None,\n             },\n-            MacArgs::Eq(_, MacArgsEq::Hir(lit)) => Some(MetaItemKind::NameValue(lit.clone())),\n+            AttrArgs::Eq(_, AttrArgsEq::Hir(lit)) => Some(MetaItemKind::NameValue(lit.clone())),\n         }\n     }\n \n@@ -648,16 +651,16 @@ impl MetaItemKind {\n \n impl NestedMetaItem {\n     pub fn span(&self) -> Span {\n-        match *self {\n-            NestedMetaItem::MetaItem(ref item) => item.span,\n-            NestedMetaItem::Literal(ref lit) => lit.span,\n+        match self {\n+            NestedMetaItem::MetaItem(item) => item.span,\n+            NestedMetaItem::Literal(lit) => lit.span,\n         }\n     }\n \n     fn token_trees(&self) -> Vec<TokenTree> {\n-        match *self {\n-            NestedMetaItem::MetaItem(ref item) => item.token_trees(),\n-            NestedMetaItem::Literal(ref lit) => {\n+        match self {\n+            NestedMetaItem::MetaItem(item) => item.token_trees(),\n+            NestedMetaItem::Literal(lit) => {\n                 vec![TokenTree::Token(lit.to_token(), Spacing::Alone)]\n             }\n         }"}, {"sha": "a5b24c403dd376d10c75550310a53300d59201a7", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -367,23 +367,27 @@ pub fn visit_fn_sig<T: MutVisitor>(FnSig { header, decl, span }: &mut FnSig, vis\n }\n \n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n-pub fn visit_mac_args<T: MutVisitor>(args: &mut MacArgs, vis: &mut T) {\n+pub fn visit_attr_args<T: MutVisitor>(args: &mut AttrArgs, vis: &mut T) {\n     match args {\n-        MacArgs::Empty => {}\n-        MacArgs::Delimited(dspan, _delim, tokens) => {\n-            visit_delim_span(dspan, vis);\n-            visit_tts(tokens, vis);\n-        }\n-        MacArgs::Eq(eq_span, MacArgsEq::Ast(expr)) => {\n+        AttrArgs::Empty => {}\n+        AttrArgs::Delimited(args) => visit_delim_args(args, vis),\n+        AttrArgs::Eq(eq_span, AttrArgsEq::Ast(expr)) => {\n             vis.visit_span(eq_span);\n             vis.visit_expr(expr);\n         }\n-        MacArgs::Eq(_, MacArgsEq::Hir(lit)) => {\n+        AttrArgs::Eq(_, AttrArgsEq::Hir(lit)) => {\n             unreachable!(\"in literal form when visiting mac args eq: {:?}\", lit)\n         }\n     }\n }\n \n+// No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n+pub fn visit_delim_args<T: MutVisitor>(args: &mut DelimArgs, vis: &mut T) {\n+    let DelimArgs { dspan, delim: _, tokens } = args;\n+    visit_delim_span(dspan, vis);\n+    visit_tts(tokens, vis);\n+}\n+\n pub fn visit_delim_span<T: MutVisitor>(dspan: &mut DelimSpan, vis: &mut T) {\n     vis.visit_span(&mut dspan.open);\n     vis.visit_span(&mut dspan.close);\n@@ -439,15 +443,15 @@ pub fn noop_visit_constraint<T: MutVisitor>(\n ) {\n     vis.visit_id(id);\n     vis.visit_ident(ident);\n-    if let Some(ref mut gen_args) = gen_args {\n+    if let Some(gen_args) = gen_args {\n         vis.visit_generic_args(gen_args);\n     }\n     match kind {\n-        AssocConstraintKind::Equality { ref mut term } => match term {\n+        AssocConstraintKind::Equality { term } => match term {\n             Term::Ty(ty) => vis.visit_ty(ty),\n             Term::Const(c) => vis.visit_anon_const(c),\n         },\n-        AssocConstraintKind::Bound { ref mut bounds } => visit_bounds(bounds, vis),\n+        AssocConstraintKind::Bound { bounds } => visit_bounds(bounds, vis),\n     }\n     vis.visit_span(span);\n }\n@@ -601,7 +605,7 @@ pub fn noop_visit_attribute<T: MutVisitor>(attr: &mut Attribute, vis: &mut T) {\n             let NormalAttr { item: AttrItem { path, args, tokens }, tokens: attr_tokens } =\n                 &mut **normal;\n             vis.visit_path(path);\n-            visit_mac_args(args, vis);\n+            visit_attr_args(args, vis);\n             visit_lazy_tts(tokens, vis);\n             visit_lazy_tts(attr_tokens, vis);\n         }\n@@ -613,12 +617,12 @@ pub fn noop_visit_attribute<T: MutVisitor>(attr: &mut Attribute, vis: &mut T) {\n pub fn noop_visit_mac<T: MutVisitor>(mac: &mut MacCall, vis: &mut T) {\n     let MacCall { path, args, prior_type_ascription: _ } = mac;\n     vis.visit_path(path);\n-    visit_mac_args(args, vis);\n+    visit_delim_args(args, vis);\n }\n \n pub fn noop_visit_macro_def<T: MutVisitor>(macro_def: &mut MacroDef, vis: &mut T) {\n     let MacroDef { body, macro_rules: _ } = macro_def;\n-    visit_mac_args(body, vis);\n+    visit_delim_args(body, vis);\n }\n \n pub fn noop_visit_meta_list_item<T: MutVisitor>(li: &mut NestedMetaItem, vis: &mut T) {\n@@ -792,7 +796,7 @@ pub fn visit_nonterminal<T: MutVisitor>(nt: &mut token::Nonterminal, vis: &mut T\n         token::NtMeta(item) => {\n             let AttrItem { path, args, tokens } = item.deref_mut();\n             vis.visit_path(path);\n-            visit_mac_args(args, vis);\n+            visit_attr_args(args, vis);\n             visit_lazy_tts(tokens, vis);\n         }\n         token::NtPath(path) => vis.visit_path(path),\n@@ -880,7 +884,7 @@ pub fn noop_flat_map_generic_param<T: MutVisitor>(\n     let GenericParam { id, ident, attrs, bounds, kind, colon_span, is_placeholder: _ } = &mut param;\n     vis.visit_id(id);\n     vis.visit_ident(ident);\n-    if let Some(ref mut colon_span) = colon_span {\n+    if let Some(colon_span) = colon_span {\n         vis.visit_span(colon_span);\n     }\n     visit_attrs(attrs, vis);\n@@ -1351,9 +1355,10 @@ pub fn noop_visit_expr<T: MutVisitor>(\n             vis.visit_block(body);\n             visit_opt(label, |label| vis.visit_label(label));\n         }\n-        ExprKind::Loop(body, label) => {\n+        ExprKind::Loop(body, label, span) => {\n             vis.visit_block(body);\n             visit_opt(label, |label| vis.visit_label(label));\n+            vis.visit_span(span);\n         }\n         ExprKind::Match(expr, arms) => {\n             vis.visit_expr(expr);"}, {"sha": "cb32925584c58a20dcb191724765c7e0aa9ef84f", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -601,17 +601,18 @@ impl Token {\n \n     /// Returns `true` if the token is an interpolated path.\n     fn is_path(&self) -> bool {\n-        if let Interpolated(ref nt) = self.kind && let NtPath(..) = **nt {\n+        if let Interpolated(nt) = &self.kind && let NtPath(..) = **nt {\n             return true;\n         }\n+\n         false\n     }\n \n     /// Would `maybe_whole_expr` in `parser.rs` return `Ok(..)`?\n     /// That is, is this a pre-parsed expression dropped into the token stream\n     /// (which happens while parsing the result of macro expansion)?\n     pub fn is_whole_expr(&self) -> bool {\n-        if let Interpolated(ref nt) = self.kind\n+        if let Interpolated(nt) = &self.kind\n             && let NtExpr(_) | NtLiteral(_) | NtPath(_) | NtBlock(_) = **nt\n         {\n             return true;\n@@ -622,9 +623,10 @@ impl Token {\n \n     // Is the token an interpolated block (`$b:block`)?\n     pub fn is_whole_block(&self) -> bool {\n-        if let Interpolated(ref nt) = self.kind && let NtBlock(..) = **nt {\n+        if let Interpolated(nt) = &self.kind && let NtBlock(..) = **nt {\n             return true;\n         }\n+\n         false\n     }\n "}, {"sha": "f65f1f069cba230b790ac60ae97ecbcd3fe94070", "filename": "compiler/rustc_ast/src/util/parser.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -377,26 +377,26 @@ pub fn needs_par_as_let_scrutinee(order: i8) -> bool {\n /// parens or other delimiters, e.g., `X { y: 1 }`, `X { y: 1 }.method()`, `foo == X { y: 1 }` and\n /// `X { y: 1 } == foo` all do, but `(X { y: 1 }) == foo` does not.\n pub fn contains_exterior_struct_lit(value: &ast::Expr) -> bool {\n-    match value.kind {\n+    match &value.kind {\n         ast::ExprKind::Struct(..) => true,\n \n-        ast::ExprKind::Assign(ref lhs, ref rhs, _)\n-        | ast::ExprKind::AssignOp(_, ref lhs, ref rhs)\n-        | ast::ExprKind::Binary(_, ref lhs, ref rhs) => {\n+        ast::ExprKind::Assign(lhs, rhs, _)\n+        | ast::ExprKind::AssignOp(_, lhs, rhs)\n+        | ast::ExprKind::Binary(_, lhs, rhs) => {\n             // X { y: 1 } + X { y: 2 }\n             contains_exterior_struct_lit(&lhs) || contains_exterior_struct_lit(&rhs)\n         }\n-        ast::ExprKind::Await(ref x)\n-        | ast::ExprKind::Unary(_, ref x)\n-        | ast::ExprKind::Cast(ref x, _)\n-        | ast::ExprKind::Type(ref x, _)\n-        | ast::ExprKind::Field(ref x, _)\n-        | ast::ExprKind::Index(ref x, _) => {\n+        ast::ExprKind::Await(x)\n+        | ast::ExprKind::Unary(_, x)\n+        | ast::ExprKind::Cast(x, _)\n+        | ast::ExprKind::Type(x, _)\n+        | ast::ExprKind::Field(x, _)\n+        | ast::ExprKind::Index(x, _) => {\n             // &X { y: 1 }, X { y: 1 }.y\n             contains_exterior_struct_lit(&x)\n         }\n \n-        ast::ExprKind::MethodCall(box ast::MethodCall { ref receiver, .. }) => {\n+        ast::ExprKind::MethodCall(box ast::MethodCall { receiver, .. }) => {\n             // X { y: 1 }.bar(...)\n             contains_exterior_struct_lit(&receiver)\n         }"}, {"sha": "c528118be08085869bac97af434e5f37978784a8", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 133, "deletions": 143, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -299,74 +299,68 @@ pub fn walk_trait_ref<'a, V: Visitor<'a>>(visitor: &mut V, trait_ref: &'a TraitR\n pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n     visitor.visit_vis(&item.vis);\n     visitor.visit_ident(item.ident);\n-    match item.kind {\n+    match &item.kind {\n         ItemKind::ExternCrate(_) => {}\n-        ItemKind::Use(ref use_tree) => visitor.visit_use_tree(use_tree, item.id, false),\n-        ItemKind::Static(ref typ, _, ref expr) | ItemKind::Const(_, ref typ, ref expr) => {\n+        ItemKind::Use(use_tree) => visitor.visit_use_tree(use_tree, item.id, false),\n+        ItemKind::Static(typ, _, expr) | ItemKind::Const(_, typ, expr) => {\n             visitor.visit_ty(typ);\n             walk_list!(visitor, visit_expr, expr);\n         }\n-        ItemKind::Fn(box Fn { defaultness: _, ref generics, ref sig, ref body }) => {\n+        ItemKind::Fn(box Fn { defaultness: _, generics, sig, body }) => {\n             let kind =\n                 FnKind::Fn(FnCtxt::Free, item.ident, sig, &item.vis, generics, body.as_deref());\n             visitor.visit_fn(kind, item.span, item.id)\n         }\n-        ItemKind::Mod(_unsafety, ref mod_kind) => match mod_kind {\n+        ItemKind::Mod(_unsafety, mod_kind) => match mod_kind {\n             ModKind::Loaded(items, _inline, _inner_span) => {\n                 walk_list!(visitor, visit_item, items)\n             }\n             ModKind::Unloaded => {}\n         },\n-        ItemKind::ForeignMod(ref foreign_module) => {\n+        ItemKind::ForeignMod(foreign_module) => {\n             walk_list!(visitor, visit_foreign_item, &foreign_module.items);\n         }\n-        ItemKind::GlobalAsm(ref asm) => visitor.visit_inline_asm(asm),\n-        ItemKind::TyAlias(box TyAlias { ref generics, ref bounds, ref ty, .. }) => {\n+        ItemKind::GlobalAsm(asm) => visitor.visit_inline_asm(asm),\n+        ItemKind::TyAlias(box TyAlias { generics, bounds, ty, .. }) => {\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::Bound);\n             walk_list!(visitor, visit_ty, ty);\n         }\n-        ItemKind::Enum(ref enum_definition, ref generics) => {\n+        ItemKind::Enum(enum_definition, generics) => {\n             visitor.visit_generics(generics);\n             visitor.visit_enum_def(enum_definition)\n         }\n         ItemKind::Impl(box Impl {\n             defaultness: _,\n             unsafety: _,\n-            ref generics,\n+            generics,\n             constness: _,\n             polarity: _,\n-            ref of_trait,\n-            ref self_ty,\n-            ref items,\n+            of_trait,\n+            self_ty,\n+            items,\n         }) => {\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_trait_ref, of_trait);\n             visitor.visit_ty(self_ty);\n             walk_list!(visitor, visit_assoc_item, items, AssocCtxt::Impl);\n         }\n-        ItemKind::Struct(ref struct_definition, ref generics)\n-        | ItemKind::Union(ref struct_definition, ref generics) => {\n+        ItemKind::Struct(struct_definition, generics)\n+        | ItemKind::Union(struct_definition, generics) => {\n             visitor.visit_generics(generics);\n             visitor.visit_variant_data(struct_definition);\n         }\n-        ItemKind::Trait(box Trait {\n-            unsafety: _,\n-            is_auto: _,\n-            ref generics,\n-            ref bounds,\n-            ref items,\n-        }) => {\n+        ItemKind::Trait(box Trait { unsafety: _, is_auto: _, generics, bounds, items }) => {\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::SuperTraits);\n             walk_list!(visitor, visit_assoc_item, items, AssocCtxt::Trait);\n         }\n-        ItemKind::TraitAlias(ref generics, ref bounds) => {\n+        ItemKind::TraitAlias(generics, bounds) => {\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::Bound);\n         }\n-        ItemKind::MacCall(ref mac) => visitor.visit_mac_call(mac),\n-        ItemKind::MacroDef(ref ts) => visitor.visit_mac_def(ts, item.id),\n+        ItemKind::MacCall(mac) => visitor.visit_mac_call(mac),\n+        ItemKind::MacroDef(ts) => visitor.visit_mac_def(ts, item.id),\n     }\n     walk_list!(visitor, visit_attribute, &item.attrs);\n }\n@@ -399,39 +393,39 @@ pub fn walk_pat_field<'a, V: Visitor<'a>>(visitor: &mut V, fp: &'a PatField) {\n }\n \n pub fn walk_ty<'a, V: Visitor<'a>>(visitor: &mut V, typ: &'a Ty) {\n-    match typ.kind {\n-        TyKind::Slice(ref ty) | TyKind::Paren(ref ty) => visitor.visit_ty(ty),\n-        TyKind::Ptr(ref mutable_type) => visitor.visit_ty(&mutable_type.ty),\n-        TyKind::Rptr(ref opt_lifetime, ref mutable_type) => {\n+    match &typ.kind {\n+        TyKind::Slice(ty) | TyKind::Paren(ty) => visitor.visit_ty(ty),\n+        TyKind::Ptr(mutable_type) => visitor.visit_ty(&mutable_type.ty),\n+        TyKind::Rptr(opt_lifetime, mutable_type) => {\n             walk_list!(visitor, visit_lifetime, opt_lifetime, LifetimeCtxt::Rptr);\n             visitor.visit_ty(&mutable_type.ty)\n         }\n-        TyKind::Tup(ref tuple_element_types) => {\n+        TyKind::Tup(tuple_element_types) => {\n             walk_list!(visitor, visit_ty, tuple_element_types);\n         }\n-        TyKind::BareFn(ref function_declaration) => {\n+        TyKind::BareFn(function_declaration) => {\n             walk_list!(visitor, visit_generic_param, &function_declaration.generic_params);\n             walk_fn_decl(visitor, &function_declaration.decl);\n         }\n-        TyKind::Path(ref maybe_qself, ref path) => {\n-            if let Some(ref qself) = *maybe_qself {\n+        TyKind::Path(maybe_qself, path) => {\n+            if let Some(qself) = maybe_qself {\n                 visitor.visit_ty(&qself.ty);\n             }\n             visitor.visit_path(path, typ.id);\n         }\n-        TyKind::Array(ref ty, ref length) => {\n+        TyKind::Array(ty, length) => {\n             visitor.visit_ty(ty);\n             visitor.visit_anon_const(length)\n         }\n-        TyKind::TraitObject(ref bounds, ..) => {\n+        TyKind::TraitObject(bounds, ..) => {\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::TraitObject);\n         }\n-        TyKind::ImplTrait(_, ref bounds) => {\n+        TyKind::ImplTrait(_, bounds) => {\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::Impl);\n         }\n-        TyKind::Typeof(ref expression) => visitor.visit_anon_const(expression),\n+        TyKind::Typeof(expression) => visitor.visit_anon_const(expression),\n         TyKind::Infer | TyKind::ImplicitSelf | TyKind::Err => {}\n-        TyKind::MacCall(ref mac) => visitor.visit_mac_call(mac),\n+        TyKind::MacCall(mac) => visitor.visit_mac_call(mac),\n         TyKind::Never | TyKind::CVarArgs => {}\n     }\n }\n@@ -444,15 +438,15 @@ pub fn walk_path<'a, V: Visitor<'a>>(visitor: &mut V, path: &'a Path) {\n \n pub fn walk_use_tree<'a, V: Visitor<'a>>(visitor: &mut V, use_tree: &'a UseTree, id: NodeId) {\n     visitor.visit_path(&use_tree.prefix, id);\n-    match use_tree.kind {\n+    match &use_tree.kind {\n         UseTreeKind::Simple(rename, ..) => {\n             // The extra IDs are handled during HIR lowering.\n-            if let Some(rename) = rename {\n+            if let &Some(rename) = rename {\n                 visitor.visit_ident(rename);\n             }\n         }\n         UseTreeKind::Glob => {}\n-        UseTreeKind::Nested(ref use_trees) => {\n+        UseTreeKind::Nested(use_trees) => {\n             for &(ref nested_tree, nested_id) in use_trees {\n                 visitor.visit_use_tree(nested_tree, nested_id, true);\n             }\n@@ -462,7 +456,7 @@ pub fn walk_use_tree<'a, V: Visitor<'a>>(visitor: &mut V, use_tree: &'a UseTree,\n \n pub fn walk_path_segment<'a, V: Visitor<'a>>(visitor: &mut V, segment: &'a PathSegment) {\n     visitor.visit_ident(segment.ident);\n-    if let Some(ref args) = segment.args {\n+    if let Some(args) = &segment.args {\n         visitor.visit_generic_args(args);\n     }\n }\n@@ -471,16 +465,16 @@ pub fn walk_generic_args<'a, V>(visitor: &mut V, generic_args: &'a GenericArgs)\n where\n     V: Visitor<'a>,\n {\n-    match *generic_args {\n-        GenericArgs::AngleBracketed(ref data) => {\n+    match generic_args {\n+        GenericArgs::AngleBracketed(data) => {\n             for arg in &data.args {\n                 match arg {\n                     AngleBracketedArg::Arg(a) => visitor.visit_generic_arg(a),\n                     AngleBracketedArg::Constraint(c) => visitor.visit_assoc_constraint(c),\n                 }\n             }\n         }\n-        GenericArgs::Parenthesized(ref data) => {\n+        GenericArgs::Parenthesized(data) => {\n             walk_list!(visitor, visit_ty, &data.inputs);\n             walk_fn_ret_ty(visitor, &data.output);\n         }\n@@ -500,64 +494,64 @@ where\n \n pub fn walk_assoc_constraint<'a, V: Visitor<'a>>(visitor: &mut V, constraint: &'a AssocConstraint) {\n     visitor.visit_ident(constraint.ident);\n-    if let Some(ref gen_args) = constraint.gen_args {\n+    if let Some(gen_args) = &constraint.gen_args {\n         visitor.visit_generic_args(gen_args);\n     }\n-    match constraint.kind {\n-        AssocConstraintKind::Equality { ref term } => match term {\n+    match &constraint.kind {\n+        AssocConstraintKind::Equality { term } => match term {\n             Term::Ty(ty) => visitor.visit_ty(ty),\n             Term::Const(c) => visitor.visit_anon_const(c),\n         },\n-        AssocConstraintKind::Bound { ref bounds } => {\n+        AssocConstraintKind::Bound { bounds } => {\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::Bound);\n         }\n     }\n }\n \n pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n-    match pattern.kind {\n-        PatKind::TupleStruct(ref opt_qself, ref path, ref elems) => {\n-            if let Some(ref qself) = *opt_qself {\n+    match &pattern.kind {\n+        PatKind::TupleStruct(opt_qself, path, elems) => {\n+            if let Some(qself) = opt_qself {\n                 visitor.visit_ty(&qself.ty);\n             }\n             visitor.visit_path(path, pattern.id);\n             walk_list!(visitor, visit_pat, elems);\n         }\n-        PatKind::Path(ref opt_qself, ref path) => {\n-            if let Some(ref qself) = *opt_qself {\n+        PatKind::Path(opt_qself, path) => {\n+            if let Some(qself) = opt_qself {\n                 visitor.visit_ty(&qself.ty);\n             }\n             visitor.visit_path(path, pattern.id)\n         }\n-        PatKind::Struct(ref opt_qself, ref path, ref fields, _) => {\n-            if let Some(ref qself) = *opt_qself {\n+        PatKind::Struct(opt_qself, path, fields, _) => {\n+            if let Some(qself) = opt_qself {\n                 visitor.visit_ty(&qself.ty);\n             }\n             visitor.visit_path(path, pattern.id);\n             walk_list!(visitor, visit_pat_field, fields);\n         }\n-        PatKind::Box(ref subpattern)\n-        | PatKind::Ref(ref subpattern, _)\n-        | PatKind::Paren(ref subpattern) => visitor.visit_pat(subpattern),\n-        PatKind::Ident(_, ident, ref optional_subpattern) => {\n-            visitor.visit_ident(ident);\n+        PatKind::Box(subpattern) | PatKind::Ref(subpattern, _) | PatKind::Paren(subpattern) => {\n+            visitor.visit_pat(subpattern)\n+        }\n+        PatKind::Ident(_, ident, optional_subpattern) => {\n+            visitor.visit_ident(*ident);\n             walk_list!(visitor, visit_pat, optional_subpattern);\n         }\n-        PatKind::Lit(ref expression) => visitor.visit_expr(expression),\n-        PatKind::Range(ref lower_bound, ref upper_bound, _) => {\n+        PatKind::Lit(expression) => visitor.visit_expr(expression),\n+        PatKind::Range(lower_bound, upper_bound, _) => {\n             walk_list!(visitor, visit_expr, lower_bound);\n             walk_list!(visitor, visit_expr, upper_bound);\n         }\n         PatKind::Wild | PatKind::Rest => {}\n-        PatKind::Tuple(ref elems) | PatKind::Slice(ref elems) | PatKind::Or(ref elems) => {\n+        PatKind::Tuple(elems) | PatKind::Slice(elems) | PatKind::Or(elems) => {\n             walk_list!(visitor, visit_pat, elems);\n         }\n-        PatKind::MacCall(ref mac) => visitor.visit_mac_call(mac),\n+        PatKind::MacCall(mac) => visitor.visit_mac_call(mac),\n     }\n }\n \n pub fn walk_foreign_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a ForeignItem) {\n-    let Item { id, span, ident, ref vis, ref attrs, ref kind, tokens: _ } = *item;\n+    let &Item { id, span, ident, ref vis, ref attrs, ref kind, tokens: _ } = item;\n     visitor.visit_vis(vis);\n     visitor.visit_ident(ident);\n     walk_list!(visitor, visit_attribute, attrs);\n@@ -566,7 +560,7 @@ pub fn walk_foreign_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a ForeignI\n             visitor.visit_ty(ty);\n             walk_list!(visitor, visit_expr, expr);\n         }\n-        ForeignItemKind::Fn(box Fn { defaultness: _, ref generics, ref sig, ref body }) => {\n+        ForeignItemKind::Fn(box Fn { defaultness: _, generics, sig, body }) => {\n             let kind = FnKind::Fn(FnCtxt::Foreign, ident, sig, vis, generics, body.as_deref());\n             visitor.visit_fn(kind, span, id);\n         }\n@@ -582,22 +576,20 @@ pub fn walk_foreign_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a ForeignI\n }\n \n pub fn walk_param_bound<'a, V: Visitor<'a>>(visitor: &mut V, bound: &'a GenericBound) {\n-    match *bound {\n-        GenericBound::Trait(ref typ, ref _modifier) => visitor.visit_poly_trait_ref(typ),\n-        GenericBound::Outlives(ref lifetime) => {\n-            visitor.visit_lifetime(lifetime, LifetimeCtxt::Bound)\n-        }\n+    match bound {\n+        GenericBound::Trait(typ, _modifier) => visitor.visit_poly_trait_ref(typ),\n+        GenericBound::Outlives(lifetime) => visitor.visit_lifetime(lifetime, LifetimeCtxt::Bound),\n     }\n }\n \n pub fn walk_generic_param<'a, V: Visitor<'a>>(visitor: &mut V, param: &'a GenericParam) {\n     visitor.visit_ident(param.ident);\n     walk_list!(visitor, visit_attribute, param.attrs.iter());\n     walk_list!(visitor, visit_param_bound, &param.bounds, BoundKind::Bound);\n-    match param.kind {\n+    match &param.kind {\n         GenericParamKind::Lifetime => (),\n-        GenericParamKind::Type { ref default } => walk_list!(visitor, visit_ty, default),\n-        GenericParamKind::Const { ref ty, ref default, .. } => {\n+        GenericParamKind::Type { default } => walk_list!(visitor, visit_ty, default),\n+        GenericParamKind::Const { ty, default, .. } => {\n             visitor.visit_ty(ty);\n             if let Some(default) = default {\n                 visitor.visit_anon_const(default);\n@@ -621,32 +613,30 @@ pub fn walk_closure_binder<'a, V: Visitor<'a>>(visitor: &mut V, binder: &'a Clos\n }\n \n pub fn walk_where_predicate<'a, V: Visitor<'a>>(visitor: &mut V, predicate: &'a WherePredicate) {\n-    match *predicate {\n+    match predicate {\n         WherePredicate::BoundPredicate(WhereBoundPredicate {\n-            ref bounded_ty,\n-            ref bounds,\n-            ref bound_generic_params,\n+            bounded_ty,\n+            bounds,\n+            bound_generic_params,\n             ..\n         }) => {\n             visitor.visit_ty(bounded_ty);\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::Bound);\n             walk_list!(visitor, visit_generic_param, bound_generic_params);\n         }\n-        WherePredicate::RegionPredicate(WhereRegionPredicate {\n-            ref lifetime, ref bounds, ..\n-        }) => {\n+        WherePredicate::RegionPredicate(WhereRegionPredicate { lifetime, bounds, .. }) => {\n             visitor.visit_lifetime(lifetime, LifetimeCtxt::Bound);\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::Bound);\n         }\n-        WherePredicate::EqPredicate(WhereEqPredicate { ref lhs_ty, ref rhs_ty, .. }) => {\n+        WherePredicate::EqPredicate(WhereEqPredicate { lhs_ty, rhs_ty, .. }) => {\n             visitor.visit_ty(lhs_ty);\n             visitor.visit_ty(rhs_ty);\n         }\n     }\n }\n \n pub fn walk_fn_ret_ty<'a, V: Visitor<'a>>(visitor: &mut V, ret_ty: &'a FnRetTy) {\n-    if let FnRetTy::Ty(ref output_ty) = *ret_ty {\n+    if let FnRetTy::Ty(output_ty) = ret_ty {\n         visitor.visit_ty(output_ty)\n     }\n }\n@@ -675,7 +665,7 @@ pub fn walk_fn<'a, V: Visitor<'a>>(visitor: &mut V, kind: FnKind<'a>) {\n }\n \n pub fn walk_assoc_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a AssocItem, ctxt: AssocCtxt) {\n-    let Item { id, span, ident, ref vis, ref attrs, ref kind, tokens: _ } = *item;\n+    let &Item { id, span, ident, ref vis, ref attrs, ref kind, tokens: _ } = item;\n     visitor.visit_vis(vis);\n     visitor.visit_ident(ident);\n     walk_list!(visitor, visit_attribute, attrs);\n@@ -684,7 +674,7 @@ pub fn walk_assoc_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a AssocItem,\n             visitor.visit_ty(ty);\n             walk_list!(visitor, visit_expr, expr);\n         }\n-        AssocItemKind::Fn(box Fn { defaultness: _, ref generics, ref sig, ref body }) => {\n+        AssocItemKind::Fn(box Fn { defaultness: _, generics, sig, body }) => {\n             let kind = FnKind::Fn(FnCtxt::Assoc(ctxt), ident, sig, vis, generics, body.as_deref());\n             visitor.visit_fn(kind, span, id);\n         }\n@@ -717,13 +707,13 @@ pub fn walk_block<'a, V: Visitor<'a>>(visitor: &mut V, block: &'a Block) {\n }\n \n pub fn walk_stmt<'a, V: Visitor<'a>>(visitor: &mut V, statement: &'a Stmt) {\n-    match statement.kind {\n-        StmtKind::Local(ref local) => visitor.visit_local(local),\n-        StmtKind::Item(ref item) => visitor.visit_item(item),\n-        StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => visitor.visit_expr(expr),\n+    match &statement.kind {\n+        StmtKind::Local(local) => visitor.visit_local(local),\n+        StmtKind::Item(item) => visitor.visit_item(item),\n+        StmtKind::Expr(expr) | StmtKind::Semi(expr) => visitor.visit_expr(expr),\n         StmtKind::Empty => {}\n-        StmtKind::MacCall(ref mac) => {\n-            let MacCallStmt { ref mac, style: _, ref attrs, tokens: _ } = **mac;\n+        StmtKind::MacCall(mac) => {\n+            let MacCallStmt { mac, attrs, style: _, tokens: _ } = &**mac;\n             visitor.visit_mac_call(mac);\n             for attr in attrs.iter() {\n                 visitor.visit_attribute(attr);\n@@ -760,7 +750,7 @@ pub fn walk_inline_asm<'a, V: Visitor<'a>>(visitor: &mut V, asm: &'a InlineAsm)\n }\n \n pub fn walk_inline_asm_sym<'a, V: Visitor<'a>>(visitor: &mut V, sym: &'a InlineAsmSym) {\n-    if let Some(ref qself) = sym.qself {\n+    if let Some(qself) = &sym.qself {\n         visitor.visit_ty(&qself.ty);\n     }\n     visitor.visit_path(&sym.path, sym.id);\n@@ -769,18 +759,18 @@ pub fn walk_inline_asm_sym<'a, V: Visitor<'a>>(visitor: &mut V, sym: &'a InlineA\n pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n     walk_list!(visitor, visit_attribute, expression.attrs.iter());\n \n-    match expression.kind {\n-        ExprKind::Box(ref subexpression) => visitor.visit_expr(subexpression),\n-        ExprKind::Array(ref subexpressions) => {\n+    match &expression.kind {\n+        ExprKind::Box(subexpression) => visitor.visit_expr(subexpression),\n+        ExprKind::Array(subexpressions) => {\n             walk_list!(visitor, visit_expr, subexpressions);\n         }\n-        ExprKind::ConstBlock(ref anon_const) => visitor.visit_anon_const(anon_const),\n-        ExprKind::Repeat(ref element, ref count) => {\n+        ExprKind::ConstBlock(anon_const) => visitor.visit_anon_const(anon_const),\n+        ExprKind::Repeat(element, count) => {\n             visitor.visit_expr(element);\n             visitor.visit_anon_const(count)\n         }\n-        ExprKind::Struct(ref se) => {\n-            if let Some(ref qself) = se.qself {\n+        ExprKind::Struct(se) => {\n+            if let Some(qself) = &se.qself {\n                 visitor.visit_ty(&qself.ty);\n             }\n             visitor.visit_path(&se.path, expression.id);\n@@ -791,124 +781,124 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n                 StructRest::None => {}\n             }\n         }\n-        ExprKind::Tup(ref subexpressions) => {\n+        ExprKind::Tup(subexpressions) => {\n             walk_list!(visitor, visit_expr, subexpressions);\n         }\n-        ExprKind::Call(ref callee_expression, ref arguments) => {\n+        ExprKind::Call(callee_expression, arguments) => {\n             visitor.visit_expr(callee_expression);\n             walk_list!(visitor, visit_expr, arguments);\n         }\n-        ExprKind::MethodCall(box MethodCall { ref seg, ref receiver, ref args, span: _ }) => {\n+        ExprKind::MethodCall(box MethodCall { seg, receiver, args, span: _ }) => {\n             visitor.visit_path_segment(seg);\n             visitor.visit_expr(receiver);\n             walk_list!(visitor, visit_expr, args);\n         }\n-        ExprKind::Binary(_, ref left_expression, ref right_expression) => {\n+        ExprKind::Binary(_, left_expression, right_expression) => {\n             visitor.visit_expr(left_expression);\n             visitor.visit_expr(right_expression)\n         }\n-        ExprKind::AddrOf(_, _, ref subexpression) | ExprKind::Unary(_, ref subexpression) => {\n+        ExprKind::AddrOf(_, _, subexpression) | ExprKind::Unary(_, subexpression) => {\n             visitor.visit_expr(subexpression)\n         }\n-        ExprKind::Cast(ref subexpression, ref typ) | ExprKind::Type(ref subexpression, ref typ) => {\n+        ExprKind::Cast(subexpression, typ) | ExprKind::Type(subexpression, typ) => {\n             visitor.visit_expr(subexpression);\n             visitor.visit_ty(typ)\n         }\n-        ExprKind::Let(ref pat, ref expr, _) => {\n+        ExprKind::Let(pat, expr, _) => {\n             visitor.visit_pat(pat);\n             visitor.visit_expr(expr);\n         }\n-        ExprKind::If(ref head_expression, ref if_block, ref optional_else) => {\n+        ExprKind::If(head_expression, if_block, optional_else) => {\n             visitor.visit_expr(head_expression);\n             visitor.visit_block(if_block);\n             walk_list!(visitor, visit_expr, optional_else);\n         }\n-        ExprKind::While(ref subexpression, ref block, ref opt_label) => {\n+        ExprKind::While(subexpression, block, opt_label) => {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n         }\n-        ExprKind::ForLoop(ref pattern, ref subexpression, ref block, ref opt_label) => {\n+        ExprKind::ForLoop(pattern, subexpression, block, opt_label) => {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_pat(pattern);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n         }\n-        ExprKind::Loop(ref block, ref opt_label) => {\n+        ExprKind::Loop(block, opt_label, _) => {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_block(block);\n         }\n-        ExprKind::Match(ref subexpression, ref arms) => {\n+        ExprKind::Match(subexpression, arms) => {\n             visitor.visit_expr(subexpression);\n             walk_list!(visitor, visit_arm, arms);\n         }\n         ExprKind::Closure(box Closure {\n-            ref binder,\n+            binder,\n             capture_clause: _,\n             asyncness: _,\n             movability: _,\n-            ref fn_decl,\n-            ref body,\n+            fn_decl,\n+            body,\n             fn_decl_span: _,\n         }) => {\n             visitor.visit_fn(FnKind::Closure(binder, fn_decl, body), expression.span, expression.id)\n         }\n-        ExprKind::Block(ref block, ref opt_label) => {\n+        ExprKind::Block(block, opt_label) => {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_block(block);\n         }\n-        ExprKind::Async(_, _, ref body) => {\n+        ExprKind::Async(_, _, body) => {\n             visitor.visit_block(body);\n         }\n-        ExprKind::Await(ref expr) => visitor.visit_expr(expr),\n-        ExprKind::Assign(ref lhs, ref rhs, _) => {\n+        ExprKind::Await(expr) => visitor.visit_expr(expr),\n+        ExprKind::Assign(lhs, rhs, _) => {\n             visitor.visit_expr(lhs);\n             visitor.visit_expr(rhs);\n         }\n-        ExprKind::AssignOp(_, ref left_expression, ref right_expression) => {\n+        ExprKind::AssignOp(_, left_expression, right_expression) => {\n             visitor.visit_expr(left_expression);\n             visitor.visit_expr(right_expression);\n         }\n-        ExprKind::Field(ref subexpression, ident) => {\n+        ExprKind::Field(subexpression, ident) => {\n             visitor.visit_expr(subexpression);\n-            visitor.visit_ident(ident);\n+            visitor.visit_ident(*ident);\n         }\n-        ExprKind::Index(ref main_expression, ref index_expression) => {\n+        ExprKind::Index(main_expression, index_expression) => {\n             visitor.visit_expr(main_expression);\n             visitor.visit_expr(index_expression)\n         }\n-        ExprKind::Range(ref start, ref end, _) => {\n+        ExprKind::Range(start, end, _) => {\n             walk_list!(visitor, visit_expr, start);\n             walk_list!(visitor, visit_expr, end);\n         }\n         ExprKind::Underscore => {}\n-        ExprKind::Path(ref maybe_qself, ref path) => {\n-            if let Some(ref qself) = *maybe_qself {\n+        ExprKind::Path(maybe_qself, path) => {\n+            if let Some(qself) = maybe_qself {\n                 visitor.visit_ty(&qself.ty);\n             }\n             visitor.visit_path(path, expression.id)\n         }\n-        ExprKind::Break(ref opt_label, ref opt_expr) => {\n+        ExprKind::Break(opt_label, opt_expr) => {\n             walk_list!(visitor, visit_label, opt_label);\n             walk_list!(visitor, visit_expr, opt_expr);\n         }\n-        ExprKind::Continue(ref opt_label) => {\n+        ExprKind::Continue(opt_label) => {\n             walk_list!(visitor, visit_label, opt_label);\n         }\n-        ExprKind::Ret(ref optional_expression) => {\n+        ExprKind::Ret(optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);\n         }\n-        ExprKind::Yeet(ref optional_expression) => {\n+        ExprKind::Yeet(optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);\n         }\n-        ExprKind::MacCall(ref mac) => visitor.visit_mac_call(mac),\n-        ExprKind::Paren(ref subexpression) => visitor.visit_expr(subexpression),\n-        ExprKind::InlineAsm(ref asm) => visitor.visit_inline_asm(asm),\n-        ExprKind::Yield(ref optional_expression) => {\n+        ExprKind::MacCall(mac) => visitor.visit_mac_call(mac),\n+        ExprKind::Paren(subexpression) => visitor.visit_expr(subexpression),\n+        ExprKind::InlineAsm(asm) => visitor.visit_inline_asm(asm),\n+        ExprKind::Yield(optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);\n         }\n-        ExprKind::Try(ref subexpression) => visitor.visit_expr(subexpression),\n-        ExprKind::TryBlock(ref body) => visitor.visit_block(body),\n+        ExprKind::Try(subexpression) => visitor.visit_expr(subexpression),\n+        ExprKind::TryBlock(body) => visitor.visit_block(body),\n         ExprKind::Lit(_) | ExprKind::IncludedBytes(..) | ExprKind::Err => {}\n     }\n \n@@ -935,18 +925,18 @@ pub fn walk_vis<'a, V: Visitor<'a>>(visitor: &mut V, vis: &'a Visibility) {\n }\n \n pub fn walk_attribute<'a, V: Visitor<'a>>(visitor: &mut V, attr: &'a Attribute) {\n-    match attr.kind {\n-        AttrKind::Normal(ref normal) => walk_mac_args(visitor, &normal.item.args),\n+    match &attr.kind {\n+        AttrKind::Normal(normal) => walk_attr_args(visitor, &normal.item.args),\n         AttrKind::DocComment(..) => {}\n     }\n }\n \n-pub fn walk_mac_args<'a, V: Visitor<'a>>(visitor: &mut V, args: &'a MacArgs) {\n+pub fn walk_attr_args<'a, V: Visitor<'a>>(visitor: &mut V, args: &'a AttrArgs) {\n     match args {\n-        MacArgs::Empty => {}\n-        MacArgs::Delimited(_dspan, _delim, _tokens) => {}\n-        MacArgs::Eq(_eq_span, MacArgsEq::Ast(expr)) => visitor.visit_expr(expr),\n-        MacArgs::Eq(_, MacArgsEq::Hir(lit)) => {\n+        AttrArgs::Empty => {}\n+        AttrArgs::Delimited(_) => {}\n+        AttrArgs::Eq(_eq_span, AttrArgsEq::Ast(expr)) => visitor.visit_expr(expr),\n+        AttrArgs::Eq(_, AttrArgsEq::Hir(lit)) => {\n             unreachable!(\"in literal form when walking mac args eq: {:?}\", lit)\n         }\n     }"}, {"sha": "2a0338adc9ca4c51be01dd2aa41de1a2ea0ab054", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -123,7 +123,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             .operands\n             .iter()\n             .map(|(op, op_sp)| {\n-                let lower_reg = |reg| match reg {\n+                let lower_reg = |&reg: &_| match reg {\n                     InlineAsmRegOrRegClass::Reg(reg) => {\n                         asm::InlineAsmRegOrRegClass::Reg(if let Some(asm_arch) = asm_arch {\n                             asm::InlineAsmReg::parse(asm_arch, reg).unwrap_or_else(|error| {\n@@ -152,32 +152,30 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     }\n                 };\n \n-                let op = match *op {\n-                    InlineAsmOperand::In { reg, ref expr } => hir::InlineAsmOperand::In {\n+                let op = match op {\n+                    InlineAsmOperand::In { reg, expr } => hir::InlineAsmOperand::In {\n                         reg: lower_reg(reg),\n                         expr: self.lower_expr(expr),\n                     },\n-                    InlineAsmOperand::Out { reg, late, ref expr } => hir::InlineAsmOperand::Out {\n+                    InlineAsmOperand::Out { reg, late, expr } => hir::InlineAsmOperand::Out {\n                         reg: lower_reg(reg),\n-                        late,\n+                        late: *late,\n                         expr: expr.as_ref().map(|expr| self.lower_expr(expr)),\n                     },\n-                    InlineAsmOperand::InOut { reg, late, ref expr } => {\n-                        hir::InlineAsmOperand::InOut {\n-                            reg: lower_reg(reg),\n-                            late,\n-                            expr: self.lower_expr(expr),\n-                        }\n-                    }\n-                    InlineAsmOperand::SplitInOut { reg, late, ref in_expr, ref out_expr } => {\n+                    InlineAsmOperand::InOut { reg, late, expr } => hir::InlineAsmOperand::InOut {\n+                        reg: lower_reg(reg),\n+                        late: *late,\n+                        expr: self.lower_expr(expr),\n+                    },\n+                    InlineAsmOperand::SplitInOut { reg, late, in_expr, out_expr } => {\n                         hir::InlineAsmOperand::SplitInOut {\n                             reg: lower_reg(reg),\n-                            late,\n+                            late: *late,\n                             in_expr: self.lower_expr(in_expr),\n                             out_expr: out_expr.as_ref().map(|expr| self.lower_expr(expr)),\n                         }\n                     }\n-                    InlineAsmOperand::Const { ref anon_const } => {\n+                    InlineAsmOperand::Const { anon_const } => {\n                         if !self.tcx.features().asm_const {\n                             feature_err(\n                                 &sess.parse_sess,\n@@ -191,7 +189,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             anon_const: self.lower_anon_const(anon_const),\n                         }\n                     }\n-                    InlineAsmOperand::Sym { ref sym } => {\n+                    InlineAsmOperand::Sym { sym } => {\n                         let static_def_id = self\n                             .resolver\n                             .get_partial_res(sym.id)\n@@ -347,7 +345,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                     skip = true;\n \n                                     let idx2 = *o.get();\n-                                    let &(ref op2, op_sp2) = &operands[idx2];\n+                                    let (ref op2, op_sp2) = operands[idx2];\n                                     let Some(asm::InlineAsmRegOrRegClass::Reg(reg2)) = op2.reg() else {\n                                         unreachable!();\n                                     };"}, {"sha": "d310f72f7a3f8f8bdb3527ecf0fa3cc10c0474b9", "filename": "compiler/rustc_ast_lowering/src/block.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -31,16 +31,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let mut stmts = SmallVec::<[hir::Stmt<'hir>; 8]>::new();\n         let mut expr = None;\n         while let [s, tail @ ..] = ast_stmts {\n-            match s.kind {\n-                StmtKind::Local(ref local) => {\n+            match &s.kind {\n+                StmtKind::Local(local) => {\n                     let hir_id = self.lower_node_id(s.id);\n                     let local = self.lower_local(local);\n                     self.alias_attrs(hir_id, local.hir_id);\n                     let kind = hir::StmtKind::Local(local);\n                     let span = self.lower_span(s.span);\n                     stmts.push(hir::Stmt { hir_id, kind, span });\n                 }\n-                StmtKind::Item(ref it) => {\n+                StmtKind::Item(it) => {\n                     stmts.extend(self.lower_item_ref(it).into_iter().enumerate().map(\n                         |(i, item_id)| {\n                             let hir_id = match i {\n@@ -53,7 +53,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         },\n                     ));\n                 }\n-                StmtKind::Expr(ref e) => {\n+                StmtKind::Expr(e) => {\n                     let e = self.lower_expr(e);\n                     if tail.is_empty() {\n                         expr = Some(e);\n@@ -65,7 +65,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         stmts.push(hir::Stmt { hir_id, kind, span });\n                     }\n                 }\n-                StmtKind::Semi(ref e) => {\n+                StmtKind::Semi(e) => {\n                     let e = self.lower_expr(e);\n                     let hir_id = self.lower_node_id(s.id);\n                     self.alias_attrs(hir_id, e.hir_id);"}, {"sha": "c14c591d3875dc593df3f4b0dd2797bb05ad4bbd", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 114, "deletions": 109, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -31,20 +31,20 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     pub(super) fn lower_expr_mut(&mut self, e: &Expr) -> hir::Expr<'hir> {\n         ensure_sufficient_stack(|| {\n-            let kind = match e.kind {\n-                ExprKind::Box(ref inner) => hir::ExprKind::Box(self.lower_expr(inner)),\n-                ExprKind::Array(ref exprs) => hir::ExprKind::Array(self.lower_exprs(exprs)),\n-                ExprKind::ConstBlock(ref anon_const) => {\n+            let kind = match &e.kind {\n+                ExprKind::Box(inner) => hir::ExprKind::Box(self.lower_expr(inner)),\n+                ExprKind::Array(exprs) => hir::ExprKind::Array(self.lower_exprs(exprs)),\n+                ExprKind::ConstBlock(anon_const) => {\n                     let anon_const = self.lower_anon_const(anon_const);\n                     hir::ExprKind::ConstBlock(anon_const)\n                 }\n-                ExprKind::Repeat(ref expr, ref count) => {\n+                ExprKind::Repeat(expr, count) => {\n                     let expr = self.lower_expr(expr);\n                     let count = self.lower_array_length(count);\n                     hir::ExprKind::Repeat(expr, count)\n                 }\n-                ExprKind::Tup(ref elts) => hir::ExprKind::Tup(self.lower_exprs(elts)),\n-                ExprKind::Call(ref f, ref args) => {\n+                ExprKind::Tup(elts) => hir::ExprKind::Tup(self.lower_exprs(elts)),\n+                ExprKind::Call(f, args) => {\n                     if e.attrs.get(0).map_or(false, |a| a.has_name(sym::rustc_box)) {\n                         if let [inner] = &args[..] && e.attrs.len() == 1 {\n                             let kind = hir::ExprKind::Box(self.lower_expr(&inner));\n@@ -61,7 +61,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         hir::ExprKind::Call(f, self.lower_exprs(args))\n                     }\n                 }\n-                ExprKind::MethodCall(box MethodCall { ref seg, ref receiver, ref args, span }) => {\n+                ExprKind::MethodCall(box MethodCall { seg, receiver, args, span }) => {\n                     let hir_seg = self.arena.alloc(self.lower_path_segment(\n                         e.span,\n                         seg,\n@@ -72,92 +72,88 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let receiver = self.lower_expr(receiver);\n                     let args =\n                         self.arena.alloc_from_iter(args.iter().map(|x| self.lower_expr_mut(x)));\n-                    hir::ExprKind::MethodCall(hir_seg, receiver, args, self.lower_span(span))\n+                    hir::ExprKind::MethodCall(hir_seg, receiver, args, self.lower_span(*span))\n                 }\n-                ExprKind::Binary(binop, ref lhs, ref rhs) => {\n-                    let binop = self.lower_binop(binop);\n+                ExprKind::Binary(binop, lhs, rhs) => {\n+                    let binop = self.lower_binop(*binop);\n                     let lhs = self.lower_expr(lhs);\n                     let rhs = self.lower_expr(rhs);\n                     hir::ExprKind::Binary(binop, lhs, rhs)\n                 }\n-                ExprKind::Unary(op, ref ohs) => {\n-                    let op = self.lower_unop(op);\n+                ExprKind::Unary(op, ohs) => {\n+                    let op = self.lower_unop(*op);\n                     let ohs = self.lower_expr(ohs);\n                     hir::ExprKind::Unary(op, ohs)\n                 }\n                 ExprKind::Lit(token_lit) => {\n-                    let lit_kind = match LitKind::from_token_lit(token_lit) {\n+                    let lit_kind = match LitKind::from_token_lit(*token_lit) {\n                         Ok(lit_kind) => lit_kind,\n                         Err(err) => {\n-                            report_lit_error(&self.tcx.sess.parse_sess, err, token_lit, e.span);\n+                            report_lit_error(&self.tcx.sess.parse_sess, err, *token_lit, e.span);\n                             LitKind::Err\n                         }\n                     };\n                     hir::ExprKind::Lit(respan(self.lower_span(e.span), lit_kind))\n                 }\n-                ExprKind::IncludedBytes(ref bytes) => hir::ExprKind::Lit(respan(\n+                ExprKind::IncludedBytes(bytes) => hir::ExprKind::Lit(respan(\n                     self.lower_span(e.span),\n                     LitKind::ByteStr(bytes.clone()),\n                 )),\n-                ExprKind::Cast(ref expr, ref ty) => {\n+                ExprKind::Cast(expr, ty) => {\n                     let expr = self.lower_expr(expr);\n                     let ty =\n                         self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n                     hir::ExprKind::Cast(expr, ty)\n                 }\n-                ExprKind::Type(ref expr, ref ty) => {\n+                ExprKind::Type(expr, ty) => {\n                     let expr = self.lower_expr(expr);\n                     let ty =\n                         self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n                     hir::ExprKind::Type(expr, ty)\n                 }\n-                ExprKind::AddrOf(k, m, ref ohs) => {\n+                ExprKind::AddrOf(k, m, ohs) => {\n                     let ohs = self.lower_expr(ohs);\n-                    hir::ExprKind::AddrOf(k, m, ohs)\n+                    hir::ExprKind::AddrOf(*k, *m, ohs)\n                 }\n-                ExprKind::Let(ref pat, ref scrutinee, span) => {\n+                ExprKind::Let(pat, scrutinee, span) => {\n                     hir::ExprKind::Let(self.arena.alloc(hir::Let {\n                         hir_id: self.next_id(),\n-                        span: self.lower_span(span),\n+                        span: self.lower_span(*span),\n                         pat: self.lower_pat(pat),\n                         ty: None,\n                         init: self.lower_expr(scrutinee),\n                     }))\n                 }\n-                ExprKind::If(ref cond, ref then, ref else_opt) => {\n+                ExprKind::If(cond, then, else_opt) => {\n                     self.lower_expr_if(cond, then, else_opt.as_deref())\n                 }\n-                ExprKind::While(ref cond, ref body, opt_label) => {\n-                    self.with_loop_scope(e.id, |this| {\n-                        let span =\n-                            this.mark_span_with_reason(DesugaringKind::WhileLoop, e.span, None);\n-                        this.lower_expr_while_in_loop_scope(span, cond, body, opt_label)\n-                    })\n-                }\n-                ExprKind::Loop(ref body, opt_label) => self.with_loop_scope(e.id, |this| {\n+                ExprKind::While(cond, body, opt_label) => self.with_loop_scope(e.id, |this| {\n+                    let span = this.mark_span_with_reason(DesugaringKind::WhileLoop, e.span, None);\n+                    this.lower_expr_while_in_loop_scope(span, cond, body, *opt_label)\n+                }),\n+                ExprKind::Loop(body, opt_label, span) => self.with_loop_scope(e.id, |this| {\n                     hir::ExprKind::Loop(\n                         this.lower_block(body, false),\n-                        this.lower_label(opt_label),\n+                        this.lower_label(*opt_label),\n                         hir::LoopSource::Loop,\n-                        DUMMY_SP,\n+                        this.lower_span(*span),\n                     )\n                 }),\n-                ExprKind::TryBlock(ref body) => self.lower_expr_try_block(body),\n-                ExprKind::Match(ref expr, ref arms) => hir::ExprKind::Match(\n+                ExprKind::TryBlock(body) => self.lower_expr_try_block(body),\n+                ExprKind::Match(expr, arms) => hir::ExprKind::Match(\n                     self.lower_expr(expr),\n                     self.arena.alloc_from_iter(arms.iter().map(|x| self.lower_arm(x))),\n                     hir::MatchSource::Normal,\n                 ),\n-                ExprKind::Async(capture_clause, closure_node_id, ref block) => self\n-                    .make_async_expr(\n-                        capture_clause,\n-                        closure_node_id,\n-                        None,\n-                        block.span,\n-                        hir::AsyncGeneratorKind::Block,\n-                        |this| this.with_new_scopes(|this| this.lower_block_expr(block)),\n-                    ),\n-                ExprKind::Await(ref expr) => {\n+                ExprKind::Async(capture_clause, closure_node_id, block) => self.make_async_expr(\n+                    *capture_clause,\n+                    *closure_node_id,\n+                    None,\n+                    e.span,\n+                    hir::AsyncGeneratorKind::Block,\n+                    |this| this.with_new_scopes(|this| this.lower_block_expr(block)),\n+                ),\n+                ExprKind::Await(expr) => {\n                     let dot_await_span = if expr.span.hi() < e.span.hi() {\n                         let span_with_whitespace = self\n                             .tcx\n@@ -173,65 +169,63 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     self.lower_expr_await(dot_await_span, expr)\n                 }\n                 ExprKind::Closure(box Closure {\n-                    ref binder,\n+                    binder,\n                     capture_clause,\n                     asyncness,\n                     movability,\n-                    ref fn_decl,\n-                    ref body,\n+                    fn_decl,\n+                    body,\n                     fn_decl_span,\n                 }) => {\n                     if let Async::Yes { closure_id, .. } = asyncness {\n                         self.lower_expr_async_closure(\n                             binder,\n-                            capture_clause,\n+                            *capture_clause,\n                             e.id,\n-                            closure_id,\n+                            *closure_id,\n                             fn_decl,\n                             body,\n-                            fn_decl_span,\n+                            *fn_decl_span,\n                         )\n                     } else {\n                         self.lower_expr_closure(\n                             binder,\n-                            capture_clause,\n+                            *capture_clause,\n                             e.id,\n-                            movability,\n+                            *movability,\n                             fn_decl,\n                             body,\n-                            fn_decl_span,\n+                            *fn_decl_span,\n                         )\n                     }\n                 }\n-                ExprKind::Block(ref blk, opt_label) => {\n-                    let opt_label = self.lower_label(opt_label);\n+                ExprKind::Block(blk, opt_label) => {\n+                    let opt_label = self.lower_label(*opt_label);\n                     hir::ExprKind::Block(self.lower_block(blk, opt_label.is_some()), opt_label)\n                 }\n-                ExprKind::Assign(ref el, ref er, span) => {\n-                    self.lower_expr_assign(el, er, span, e.span)\n-                }\n-                ExprKind::AssignOp(op, ref el, ref er) => hir::ExprKind::AssignOp(\n-                    self.lower_binop(op),\n+                ExprKind::Assign(el, er, span) => self.lower_expr_assign(el, er, *span, e.span),\n+                ExprKind::AssignOp(op, el, er) => hir::ExprKind::AssignOp(\n+                    self.lower_binop(*op),\n                     self.lower_expr(el),\n                     self.lower_expr(er),\n                 ),\n-                ExprKind::Field(ref el, ident) => {\n-                    hir::ExprKind::Field(self.lower_expr(el), self.lower_ident(ident))\n+                ExprKind::Field(el, ident) => {\n+                    hir::ExprKind::Field(self.lower_expr(el), self.lower_ident(*ident))\n                 }\n-                ExprKind::Index(ref el, ref er) => {\n+                ExprKind::Index(el, er) => {\n                     hir::ExprKind::Index(self.lower_expr(el), self.lower_expr(er))\n                 }\n-                ExprKind::Range(Some(ref e1), Some(ref e2), RangeLimits::Closed) => {\n+                ExprKind::Range(Some(e1), Some(e2), RangeLimits::Closed) => {\n                     self.lower_expr_range_closed(e.span, e1, e2)\n                 }\n-                ExprKind::Range(ref e1, ref e2, lims) => {\n-                    self.lower_expr_range(e.span, e1.as_deref(), e2.as_deref(), lims)\n+                ExprKind::Range(e1, e2, lims) => {\n+                    self.lower_expr_range(e.span, e1.as_deref(), e2.as_deref(), *lims)\n                 }\n                 ExprKind::Underscore => {\n                     self.tcx.sess.emit_err(UnderscoreExprLhsAssign { span: e.span });\n                     hir::ExprKind::Err\n                 }\n-                ExprKind::Path(ref qself, ref path) => {\n+                ExprKind::Path(qself, path) => {\n                     let qpath = self.lower_qpath(\n                         e.id,\n                         qself,\n@@ -241,22 +235,22 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     );\n                     hir::ExprKind::Path(qpath)\n                 }\n-                ExprKind::Break(opt_label, ref opt_expr) => {\n+                ExprKind::Break(opt_label, opt_expr) => {\n                     let opt_expr = opt_expr.as_ref().map(|x| self.lower_expr(x));\n-                    hir::ExprKind::Break(self.lower_jump_destination(e.id, opt_label), opt_expr)\n+                    hir::ExprKind::Break(self.lower_jump_destination(e.id, *opt_label), opt_expr)\n                 }\n                 ExprKind::Continue(opt_label) => {\n-                    hir::ExprKind::Continue(self.lower_jump_destination(e.id, opt_label))\n+                    hir::ExprKind::Continue(self.lower_jump_destination(e.id, *opt_label))\n                 }\n-                ExprKind::Ret(ref e) => {\n+                ExprKind::Ret(e) => {\n                     let e = e.as_ref().map(|x| self.lower_expr(x));\n                     hir::ExprKind::Ret(e)\n                 }\n-                ExprKind::Yeet(ref sub_expr) => self.lower_expr_yeet(e.span, sub_expr.as_deref()),\n-                ExprKind::InlineAsm(ref asm) => {\n+                ExprKind::Yeet(sub_expr) => self.lower_expr_yeet(e.span, sub_expr.as_deref()),\n+                ExprKind::InlineAsm(asm) => {\n                     hir::ExprKind::InlineAsm(self.lower_inline_asm(e.span, asm))\n                 }\n-                ExprKind::Struct(ref se) => {\n+                ExprKind::Struct(se) => {\n                     let rest = match &se.rest {\n                         StructRest::Base(e) => Some(self.lower_expr(e)),\n                         StructRest::Rest(sp) => {\n@@ -278,10 +272,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         rest,\n                     )\n                 }\n-                ExprKind::Yield(ref opt_expr) => self.lower_expr_yield(e.span, opt_expr.as_deref()),\n+                ExprKind::Yield(opt_expr) => self.lower_expr_yield(e.span, opt_expr.as_deref()),\n                 ExprKind::Err => hir::ExprKind::Err,\n-                ExprKind::Try(ref sub_expr) => self.lower_expr_try(e.span, sub_expr),\n-                ExprKind::Paren(ref ex) => {\n+                ExprKind::Try(sub_expr) => self.lower_expr_try(e.span, sub_expr),\n+                ExprKind::Paren(ex) => {\n                     let mut ex = self.lower_expr_mut(ex);\n                     // Include parens in span, but only if it is a super-span.\n                     if e.span.contains(ex.span) {\n@@ -306,8 +300,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n                 // Desugar `ExprForLoop`\n                 // from: `[opt_ident]: for <pat> in <head> <body>`\n-                ExprKind::ForLoop(ref pat, ref head, ref body, opt_label) => {\n-                    return self.lower_expr_for(e, pat, head, body, opt_label);\n+                ExprKind::ForLoop(pat, head, body, opt_label) => {\n+                    return self.lower_expr_for(e, pat, head, body, *opt_label);\n                 }\n                 ExprKind::MacCall(_) => panic!(\"{:?} shouldn't exist here\", e.span),\n             };\n@@ -358,7 +352,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         args: Vec<AstP<Expr>>,\n         legacy_args_idx: &[usize],\n     ) -> hir::ExprKind<'hir> {\n-        let ExprKind::Path(None, ref mut path) = f.kind else {\n+        let ExprKind::Path(None, path) = &mut f.kind else {\n             unreachable!();\n         };\n \n@@ -552,10 +546,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_arm(&mut self, arm: &Arm) -> hir::Arm<'hir> {\n         let pat = self.lower_pat(&arm.pat);\n         let guard = arm.guard.as_ref().map(|cond| {\n-            if let ExprKind::Let(ref pat, ref scrutinee, span) = cond.kind {\n+            if let ExprKind::Let(pat, scrutinee, span) = &cond.kind {\n                 hir::Guard::IfLet(self.arena.alloc(hir::Let {\n                     hir_id: self.next_id(),\n-                    span: self.lower_span(span),\n+                    span: self.lower_span(*span),\n                     pat: self.lower_pat(pat),\n                     ty: None,\n                     init: self.lower_expr(scrutinee),\n@@ -575,37 +569,34 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n \n-    /// Lower an `async` construct to a generator that is then wrapped so it implements `Future`.\n+    /// Lower an `async` construct to a generator that implements `Future`.\n     ///\n     /// This results in:\n     ///\n     /// ```text\n-    /// std::future::from_generator(static move? |_task_context| -> <ret_ty> {\n+    /// std::future::identity_future(static move? |_task_context| -> <ret_ty> {\n     ///     <body>\n     /// })\n     /// ```\n     pub(super) fn make_async_expr(\n         &mut self,\n         capture_clause: CaptureBy,\n         closure_node_id: NodeId,\n-        ret_ty: Option<AstP<Ty>>,\n+        ret_ty: Option<hir::FnRetTy<'hir>>,\n         span: Span,\n         async_gen_kind: hir::AsyncGeneratorKind,\n         body: impl FnOnce(&mut Self) -> hir::Expr<'hir>,\n     ) -> hir::ExprKind<'hir> {\n-        let output = match ret_ty {\n-            Some(ty) => hir::FnRetTy::Return(\n-                self.lower_ty(&ty, &ImplTraitContext::Disallowed(ImplTraitPosition::AsyncBlock)),\n-            ),\n-            None => hir::FnRetTy::DefaultReturn(self.lower_span(span)),\n-        };\n+        let output = ret_ty.unwrap_or_else(|| hir::FnRetTy::DefaultReturn(self.lower_span(span)));\n \n-        // Resume argument type. We let the compiler infer this to simplify the lowering. It is\n-        // fully constrained by `future::from_generator`.\n+        // Resume argument type: `ResumeTy`\n+        let unstable_span =\n+            self.mark_span_with_reason(DesugaringKind::Async, span, self.allow_gen_future.clone());\n+        let resume_ty = hir::QPath::LangItem(hir::LangItem::ResumeTy, unstable_span, None);\n         let input_ty = hir::Ty {\n             hir_id: self.next_id(),\n-            kind: hir::TyKind::Infer,\n-            span: self.lower_span(span),\n+            kind: hir::TyKind::Path(resume_ty),\n+            span: unstable_span,\n         };\n \n         // The closure/generator `FnDecl` takes a single (resume) argument of type `input_ty`.\n@@ -614,6 +605,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             output,\n             c_variadic: false,\n             implicit_self: hir::ImplicitSelfKind::None,\n+            lifetime_elision_allowed: false,\n         });\n \n         // Lower the argument pattern/ident. The ident is used again in the `.await` lowering.\n@@ -671,7 +663,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     kind: AttrKind::Normal(ptr::P(NormalAttr {\n                         item: AttrItem {\n                             path: Path::from_ident(Ident::new(sym::track_caller, span)),\n-                            args: MacArgs::Empty,\n+                            args: AttrArgs::Empty,\n                             tokens: None,\n                         },\n                         tokens: None,\n@@ -688,16 +680,24 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         let generator = hir::Expr { hir_id, kind: generator_kind, span: self.lower_span(span) };\n \n-        // `future::from_generator`:\n-        let gen_future = self.expr_lang_item_path(\n+        // FIXME(swatinem):\n+        // For some reason, the async block needs to flow through *any*\n+        // call (like the identity function), as otherwise type and lifetime\n+        // inference have a hard time figuring things out.\n+        // Without this, we would get:\n+        // E0720 in src/test/ui/impl-trait/in-trait/default-body-with-rpit.rs\n+        // E0700 in src/test/ui/self/self_lifetime-async.rs\n+\n+        // `future::identity_future`:\n+        let identity_future = self.expr_lang_item_path(\n             unstable_span,\n-            hir::LangItem::FromGenerator,\n+            hir::LangItem::IdentityFuture,\n             AttrVec::new(),\n             None,\n         );\n \n-        // `future::from_generator(generator)`:\n-        hir::ExprKind::Call(self.arena.alloc(gen_future), arena_vec![self; generator])\n+        // `future::identity_future(generator)`:\n+        hir::ExprKind::Call(self.arena.alloc(identity_future), arena_vec![self; generator])\n     }\n \n     /// Desugar `<expr>.await` into:\n@@ -918,7 +918,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         let bound_generic_params = self.lower_lifetime_binder(closure_id, generic_params);\n         // Lower outside new scope to preserve `is_in_loop_condition`.\n-        let fn_decl = self.lower_fn_decl(decl, None, fn_decl_span, FnDeclKind::Closure, None);\n+        let fn_decl = self.lower_fn_decl(decl, closure_id, fn_decl_span, FnDeclKind::Closure, None);\n \n         let c = self.arena.alloc(hir::Closure {\n             def_id: self.local_def_id(closure_id),\n@@ -966,8 +966,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     ) -> (hir::ClosureBinder, &'c [GenericParam]) {\n         let (binder, params) = match binder {\n             ClosureBinder::NotPresent => (hir::ClosureBinder::Default, &[][..]),\n-            &ClosureBinder::For { span, ref generic_params } => {\n-                let span = self.lower_span(span);\n+            ClosureBinder::For { span, generic_params } => {\n+                let span = self.lower_span(*span);\n                 (hir::ClosureBinder::For { span }, &**generic_params)\n             }\n         };\n@@ -1001,10 +1001,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n \n             // Transform `async |x: u8| -> X { ... }` into\n-            // `|x: u8| future_from_generator(|| -> X { ... })`.\n+            // `|x: u8| identity_future(|| -> X { ... })`.\n             let body_id = this.lower_fn_body(&outer_decl, |this| {\n-                let async_ret_ty =\n-                    if let FnRetTy::Ty(ty) = &decl.output { Some(ty.clone()) } else { None };\n+                let async_ret_ty = if let FnRetTy::Ty(ty) = &decl.output {\n+                    let itctx = ImplTraitContext::Disallowed(ImplTraitPosition::AsyncBlock);\n+                    Some(hir::FnRetTy::Return(this.lower_ty(&ty, &itctx)))\n+                } else {\n+                    None\n+                };\n+\n                 let async_body = this.make_async_expr(\n                     capture_clause,\n                     inner_closure_id,\n@@ -1023,7 +1028,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // have to conserve the state of being inside a loop condition for the\n         // closure argument types.\n         let fn_decl =\n-            self.lower_fn_decl(&outer_decl, None, fn_decl_span, FnDeclKind::Closure, None);\n+            self.lower_fn_decl(&outer_decl, closure_id, fn_decl_span, FnDeclKind::Closure, None);\n \n         let c = self.arena.alloc(hir::Closure {\n             def_id: self.local_def_id(closure_id),"}, {"sha": "9def8536c824664fa4d3f00857848bfb74e7c002", "filename": "compiler/rustc_ast_lowering/src/index.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -145,7 +145,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     fn visit_item(&mut self, i: &'hir Item<'hir>) {\n         debug_assert_eq!(i.owner_id, self.owner);\n         self.with_parent(i.hir_id(), |this| {\n-            if let ItemKind::Struct(ref struct_def, _) = i.kind {\n+            if let ItemKind::Struct(struct_def, _) = &i.kind {\n                 // If this is a tuple or unit-like struct, register the constructor.\n                 if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n                     this.insert(i.span, ctor_hir_id, Node::Ctor(struct_def));\n@@ -303,7 +303,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_lifetime(&mut self, lifetime: &'hir Lifetime) {\n-        self.insert(lifetime.span, lifetime.hir_id, Node::Lifetime(lifetime));\n+        self.insert(lifetime.ident.span, lifetime.hir_id, Node::Lifetime(lifetime));\n     }\n \n     fn visit_variant(&mut self, v: &'hir Variant<'hir>) {"}, {"sha": "2b47e90891291094560afbf51acb84a8467213d7", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 83, "deletions": 107, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -142,7 +142,7 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n             // This is used to track which lifetimes have already been defined,\n             // and which need to be replicated when lowering an async fn.\n             match parent_hir.node().expect_item().kind {\n-                hir::ItemKind::Impl(hir::Impl { ref of_trait, .. }) => {\n+                hir::ItemKind::Impl(hir::Impl { of_trait, .. }) => {\n                     lctx.is_in_trait_impl = of_trait.is_some();\n                 }\n                 _ => {}\n@@ -178,7 +178,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     pub(super) fn lower_item_ref(&mut self, i: &Item) -> SmallVec<[hir::ItemId; 1]> {\n         let mut node_ids =\n             smallvec![hir::ItemId { owner_id: hir::OwnerId { def_id: self.local_def_id(i.id) } }];\n-        if let ItemKind::Use(ref use_tree) = &i.kind {\n+        if let ItemKind::Use(use_tree) = &i.kind {\n             self.lower_item_id_use_tree(use_tree, i.id, &mut node_ids);\n         }\n         node_ids\n@@ -190,8 +190,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         base_id: NodeId,\n         vec: &mut SmallVec<[hir::ItemId; 1]>,\n     ) {\n-        match tree.kind {\n-            UseTreeKind::Nested(ref nested_vec) => {\n+        match &tree.kind {\n+            UseTreeKind::Nested(nested_vec) => {\n                 for &(ref nested, id) in nested_vec {\n                     vec.push(hir::ItemId {\n                         owner_id: hir::OwnerId { def_id: self.local_def_id(id) },\n@@ -201,8 +201,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n             UseTreeKind::Glob => {}\n             UseTreeKind::Simple(_, id1, id2) => {\n-                for (_, &id) in\n-                    iter::zip(self.expect_full_res_from_use(base_id).skip(1), &[id1, id2])\n+                for (_, id) in\n+                    iter::zip(self.expect_full_res_from_use(base_id).skip(1), [*id1, *id2])\n                 {\n                     vec.push(hir::ItemId {\n                         owner_id: hir::OwnerId { def_id: self.local_def_id(id) },\n@@ -238,26 +238,26 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         vis_span: Span,\n         i: &ItemKind,\n     ) -> hir::ItemKind<'hir> {\n-        match *i {\n-            ItemKind::ExternCrate(orig_name) => hir::ItemKind::ExternCrate(orig_name),\n-            ItemKind::Use(ref use_tree) => {\n+        match i {\n+            ItemKind::ExternCrate(orig_name) => hir::ItemKind::ExternCrate(*orig_name),\n+            ItemKind::Use(use_tree) => {\n                 // Start with an empty prefix.\n                 let prefix = Path { segments: ThinVec::new(), span: use_tree.span, tokens: None };\n \n                 self.lower_use_tree(use_tree, &prefix, id, vis_span, ident, attrs)\n             }\n-            ItemKind::Static(ref t, m, ref e) => {\n+            ItemKind::Static(t, m, e) => {\n                 let (ty, body_id) = self.lower_const_item(t, span, e.as_deref());\n-                hir::ItemKind::Static(ty, m, body_id)\n+                hir::ItemKind::Static(ty, *m, body_id)\n             }\n-            ItemKind::Const(_, ref t, ref e) => {\n+            ItemKind::Const(_, t, e) => {\n                 let (ty, body_id) = self.lower_const_item(t, span, e.as_deref());\n                 hir::ItemKind::Const(ty, body_id)\n             }\n             ItemKind::Fn(box Fn {\n-                sig: FnSig { ref decl, header, span: fn_sig_span },\n-                ref generics,\n-                ref body,\n+                sig: FnSig { decl, header, span: fn_sig_span },\n+                generics,\n+                body,\n                 ..\n             }) => {\n                 self.with_new_scopes(|this| {\n@@ -274,37 +274,30 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let mut itctx = ImplTraitContext::Universal;\n                     let (generics, decl) = this.lower_generics(generics, id, &mut itctx, |this| {\n                         let ret_id = asyncness.opt_return_id();\n-                        this.lower_fn_decl(&decl, Some(id), fn_sig_span, FnDeclKind::Fn, ret_id)\n+                        this.lower_fn_decl(&decl, id, *fn_sig_span, FnDeclKind::Fn, ret_id)\n                     });\n                     let sig = hir::FnSig {\n                         decl,\n-                        header: this.lower_fn_header(header),\n-                        span: this.lower_span(fn_sig_span),\n+                        header: this.lower_fn_header(*header),\n+                        span: this.lower_span(*fn_sig_span),\n                     };\n                     hir::ItemKind::Fn(sig, generics, body_id)\n                 })\n             }\n-            ItemKind::Mod(_, ref mod_kind) => match mod_kind {\n+            ItemKind::Mod(_, mod_kind) => match mod_kind {\n                 ModKind::Loaded(items, _, spans) => {\n                     hir::ItemKind::Mod(self.lower_mod(items, spans))\n                 }\n                 ModKind::Unloaded => panic!(\"`mod` items should have been loaded by now\"),\n             },\n-            ItemKind::ForeignMod(ref fm) => hir::ItemKind::ForeignMod {\n+            ItemKind::ForeignMod(fm) => hir::ItemKind::ForeignMod {\n                 abi: fm.abi.map_or(abi::Abi::FALLBACK, |abi| self.lower_abi(abi)),\n                 items: self\n                     .arena\n                     .alloc_from_iter(fm.items.iter().map(|x| self.lower_foreign_item_ref(x))),\n             },\n-            ItemKind::GlobalAsm(ref asm) => {\n-                hir::ItemKind::GlobalAsm(self.lower_inline_asm(span, asm))\n-            }\n-            ItemKind::TyAlias(box TyAlias {\n-                ref generics,\n-                where_clauses,\n-                ty: Some(ref ty),\n-                ..\n-            }) => {\n+            ItemKind::GlobalAsm(asm) => hir::ItemKind::GlobalAsm(self.lower_inline_asm(span, asm)),\n+            ItemKind::TyAlias(box TyAlias { generics, where_clauses, ty: Some(ty), .. }) => {\n                 // We lower\n                 //\n                 // type Foo = impl Trait\n@@ -314,7 +307,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // type Foo = Foo1\n                 // opaque type Foo1: Trait\n                 let mut generics = generics.clone();\n-                add_ty_alias_where_clause(&mut generics, where_clauses, true);\n+                add_ty_alias_where_clause(&mut generics, *where_clauses, true);\n                 let (generics, ty) = self.lower_generics(\n                     &generics,\n                     id,\n@@ -323,9 +316,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 );\n                 hir::ItemKind::TyAlias(ty, generics)\n             }\n-            ItemKind::TyAlias(box TyAlias {\n-                ref generics, ref where_clauses, ty: None, ..\n-            }) => {\n+            ItemKind::TyAlias(box TyAlias { generics, where_clauses, ty: None, .. }) => {\n                 let mut generics = generics.clone();\n                 add_ty_alias_where_clause(&mut generics, *where_clauses, true);\n                 let (generics, ty) = self.lower_generics(\n@@ -336,7 +327,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 );\n                 hir::ItemKind::TyAlias(ty, generics)\n             }\n-            ItemKind::Enum(ref enum_definition, ref generics) => {\n+            ItemKind::Enum(enum_definition, generics) => {\n                 let (generics, variants) = self.lower_generics(\n                     generics,\n                     id,\n@@ -349,7 +340,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 );\n                 hir::ItemKind::Enum(hir::EnumDef { variants }, generics)\n             }\n-            ItemKind::Struct(ref struct_def, ref generics) => {\n+            ItemKind::Struct(struct_def, generics) => {\n                 let (generics, struct_def) = self.lower_generics(\n                     generics,\n                     id,\n@@ -358,7 +349,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 );\n                 hir::ItemKind::Struct(struct_def, generics)\n             }\n-            ItemKind::Union(ref vdata, ref generics) => {\n+            ItemKind::Union(vdata, generics) => {\n                 let (generics, vdata) = self.lower_generics(\n                     generics,\n                     id,\n@@ -372,10 +363,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 polarity,\n                 defaultness,\n                 constness,\n-                generics: ref ast_generics,\n-                of_trait: ref trait_ref,\n-                self_ty: ref ty,\n-                items: ref impl_items,\n+                generics: ast_generics,\n+                of_trait: trait_ref,\n+                self_ty: ty,\n+                items: impl_items,\n             }) => {\n                 // Lower the \"impl header\" first. This ordering is important\n                 // for in-band lifetimes! Consider `'a` here:\n@@ -413,30 +404,24 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // `defaultness.has_value()` is never called for an `impl`, always `true` in order\n                 // to not cause an assertion failure inside the `lower_defaultness` function.\n                 let has_val = true;\n-                let (defaultness, defaultness_span) = self.lower_defaultness(defaultness, has_val);\n+                let (defaultness, defaultness_span) = self.lower_defaultness(*defaultness, has_val);\n                 let polarity = match polarity {\n                     ImplPolarity::Positive => ImplPolarity::Positive,\n-                    ImplPolarity::Negative(s) => ImplPolarity::Negative(self.lower_span(s)),\n+                    ImplPolarity::Negative(s) => ImplPolarity::Negative(self.lower_span(*s)),\n                 };\n                 hir::ItemKind::Impl(self.arena.alloc(hir::Impl {\n-                    unsafety: self.lower_unsafety(unsafety),\n+                    unsafety: self.lower_unsafety(*unsafety),\n                     polarity,\n                     defaultness,\n                     defaultness_span,\n-                    constness: self.lower_constness(constness),\n+                    constness: self.lower_constness(*constness),\n                     generics,\n                     of_trait: trait_ref,\n                     self_ty: lowered_ty,\n                     items: new_impl_items,\n                 }))\n             }\n-            ItemKind::Trait(box Trait {\n-                is_auto,\n-                unsafety,\n-                ref generics,\n-                ref bounds,\n-                ref items,\n-            }) => {\n+            ItemKind::Trait(box Trait { is_auto, unsafety, generics, bounds, items }) => {\n                 let (generics, (unsafety, items, bounds)) = self.lower_generics(\n                     generics,\n                     id,\n@@ -449,13 +434,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         let items = this.arena.alloc_from_iter(\n                             items.iter().map(|item| this.lower_trait_item_ref(item)),\n                         );\n-                        let unsafety = this.lower_unsafety(unsafety);\n+                        let unsafety = this.lower_unsafety(*unsafety);\n                         (unsafety, items, bounds)\n                     },\n                 );\n-                hir::ItemKind::Trait(is_auto, unsafety, generics, bounds, items)\n+                hir::ItemKind::Trait(*is_auto, unsafety, generics, bounds, items)\n             }\n-            ItemKind::TraitAlias(ref generics, ref bounds) => {\n+            ItemKind::TraitAlias(generics, bounds) => {\n                 let (generics, bounds) = self.lower_generics(\n                     generics,\n                     id,\n@@ -469,10 +454,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 );\n                 hir::ItemKind::TraitAlias(generics, bounds)\n             }\n-            ItemKind::MacroDef(MacroDef { ref body, macro_rules }) => {\n-                let body = P(self.lower_mac_args(body));\n+            ItemKind::MacroDef(MacroDef { body, macro_rules }) => {\n+                let body = P(self.lower_delim_args(body));\n                 let macro_kind = self.resolver.decl_macro_kind(self.local_def_id(id));\n-                hir::ItemKind::Macro(ast::MacroDef { body, macro_rules }, macro_kind)\n+                hir::ItemKind::Macro(ast::MacroDef { body, macro_rules: *macro_rules }, macro_kind)\n             }\n             ItemKind::MacCall(..) => {\n                 panic!(\"`TyMac` should have been expanded by now\")\n@@ -664,8 +649,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let item = hir::ForeignItem {\n             owner_id,\n             ident: self.lower_ident(i.ident),\n-            kind: match i.kind {\n-                ForeignItemKind::Fn(box Fn { ref sig, ref generics, .. }) => {\n+            kind: match &i.kind {\n+                ForeignItemKind::Fn(box Fn { sig, generics, .. }) => {\n                     let fdec = &sig.decl;\n                     let mut itctx = ImplTraitContext::Universal;\n                     let (generics, (fn_dec, fn_args)) =\n@@ -674,7 +659,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                                 // Disallow `impl Trait` in foreign items.\n                                 this.lower_fn_decl(\n                                     fdec,\n-                                    None,\n+                                    i.id,\n                                     sig.span,\n                                     FnDeclKind::ExternFn,\n                                     None,\n@@ -685,10 +670,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n                     hir::ForeignItemKind::Fn(fn_dec, fn_args, generics)\n                 }\n-                ForeignItemKind::Static(ref t, m, _) => {\n+                ForeignItemKind::Static(t, m, _) => {\n                     let ty =\n                         self.lower_ty(t, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n-                    hir::ForeignItemKind::Static(ty, m)\n+                    hir::ForeignItemKind::Static(ty, *m)\n                 }\n                 ForeignItemKind::TyAlias(..) => hir::ForeignItemKind::Type,\n                 ForeignItemKind::MacCall(_) => panic!(\"macro shouldn't exist here\"),\n@@ -725,33 +710,33 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         parent_id: hir::HirId,\n         vdata: &VariantData,\n     ) -> hir::VariantData<'hir> {\n-        match *vdata {\n-            VariantData::Struct(ref fields, recovered) => hir::VariantData::Struct(\n+        match vdata {\n+            VariantData::Struct(fields, recovered) => hir::VariantData::Struct(\n                 self.arena\n                     .alloc_from_iter(fields.iter().enumerate().map(|f| self.lower_field_def(f))),\n-                recovered,\n+                *recovered,\n             ),\n-            VariantData::Tuple(ref fields, id) => {\n-                let ctor_id = self.lower_node_id(id);\n+            VariantData::Tuple(fields, id) => {\n+                let ctor_id = self.lower_node_id(*id);\n                 self.alias_attrs(ctor_id, parent_id);\n                 hir::VariantData::Tuple(\n                     self.arena.alloc_from_iter(\n                         fields.iter().enumerate().map(|f| self.lower_field_def(f)),\n                     ),\n                     ctor_id,\n-                    self.local_def_id(id),\n+                    self.local_def_id(*id),\n                 )\n             }\n             VariantData::Unit(id) => {\n-                let ctor_id = self.lower_node_id(id);\n+                let ctor_id = self.lower_node_id(*id);\n                 self.alias_attrs(ctor_id, parent_id);\n-                hir::VariantData::Unit(ctor_id, self.local_def_id(id))\n+                hir::VariantData::Unit(ctor_id, self.local_def_id(*id))\n             }\n         }\n     }\n \n     fn lower_field_def(&mut self, (index, f): (usize, &FieldDef)) -> hir::FieldDef<'hir> {\n-        let ty = if let TyKind::Path(ref qself, ref path) = f.ty.kind {\n+        let ty = if let TyKind::Path(qself, path) = &f.ty.kind {\n             let t = self.lower_path_ty(\n                 &f.ty,\n                 qself,\n@@ -783,13 +768,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let hir_id = self.lower_node_id(i.id);\n         let trait_item_def_id = hir_id.expect_owner();\n \n-        let (generics, kind, has_default) = match i.kind {\n-            AssocItemKind::Const(_, ref ty, ref default) => {\n+        let (generics, kind, has_default) = match &i.kind {\n+            AssocItemKind::Const(_, ty, default) => {\n                 let ty = self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n                 let body = default.as_ref().map(|x| self.lower_const_body(i.span, Some(x)));\n                 (hir::Generics::empty(), hir::TraitItemKind::Const(ty, body), body.is_some())\n             }\n-            AssocItemKind::Fn(box Fn { ref sig, ref generics, body: None, .. }) => {\n+            AssocItemKind::Fn(box Fn { sig, generics, body: None, .. }) => {\n                 let asyncness = sig.header.asyncness;\n                 let names = self.lower_fn_params_to_names(&sig.decl);\n                 let (generics, sig) = self.lower_method_sig(\n@@ -801,7 +786,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 );\n                 (generics, hir::TraitItemKind::Fn(sig, hir::TraitFn::Required(names)), false)\n             }\n-            AssocItemKind::Fn(box Fn { ref sig, ref generics, body: Some(ref body), .. }) => {\n+            AssocItemKind::Fn(box Fn { sig, generics, body: Some(body), .. }) => {\n                 let asyncness = sig.header.asyncness;\n                 let body_id =\n                     self.lower_maybe_async_body(i.span, &sig.decl, asyncness, Some(&body));\n@@ -814,15 +799,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 );\n                 (generics, hir::TraitItemKind::Fn(sig, hir::TraitFn::Provided(body_id)), true)\n             }\n-            AssocItemKind::Type(box TyAlias {\n-                ref generics,\n-                where_clauses,\n-                ref bounds,\n-                ref ty,\n-                ..\n-            }) => {\n+            AssocItemKind::Type(box TyAlias { generics, where_clauses, bounds, ty, .. }) => {\n                 let mut generics = generics.clone();\n-                add_ty_alias_where_clause(&mut generics, where_clauses, false);\n+                add_ty_alias_where_clause(&mut generics, *where_clauses, false);\n                 let (generics, kind) = self.lower_generics(\n                     &generics,\n                     i.id,\n@@ -1268,7 +1247,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let header = self.lower_fn_header(sig.header);\n         let mut itctx = ImplTraitContext::Universal;\n         let (generics, decl) = self.lower_generics(generics, id, &mut itctx, |this| {\n-            this.lower_fn_decl(&sig.decl, Some(id), sig.span, kind, is_async)\n+            this.lower_fn_decl(&sig.decl, id, sig.span, kind, is_async)\n         });\n         (generics, hir::FnSig { header, decl, span: self.lower_span(sig.span) })\n     }\n@@ -1354,7 +1333,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // keep track of the Span info. Now, `add_implicitly_sized` in `AstConv` checks both param bounds and\n         // where clauses for `?Sized`.\n         for pred in &generics.where_clause.predicates {\n-            let WherePredicate::BoundPredicate(ref bound_pred) = *pred else {\n+            let WherePredicate::BoundPredicate(bound_pred) = pred else {\n                 continue;\n             };\n             let compute_is_param = || {\n@@ -1500,10 +1479,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 }))\n             }\n             GenericParamKind::Lifetime => {\n-                let ident_span = self.lower_span(ident.span);\n                 let ident = self.lower_ident(ident);\n                 let lt_id = self.next_node_id();\n-                let lifetime = self.new_named_lifetime(id, lt_id, ident_span, ident);\n+                let lifetime = self.new_named_lifetime(id, lt_id, ident);\n                 Some(hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n                     lifetime,\n                     span,\n@@ -1515,11 +1493,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_where_predicate(&mut self, pred: &WherePredicate) -> hir::WherePredicate<'hir> {\n-        match *pred {\n+        match pred {\n             WherePredicate::BoundPredicate(WhereBoundPredicate {\n-                ref bound_generic_params,\n-                ref bounded_ty,\n-                ref bounds,\n+                bound_generic_params,\n+                bounded_ty,\n+                bounds,\n                 span,\n             }) => hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n                 hir_id: self.next_id(),\n@@ -1532,29 +1510,27 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         &ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n                     )\n                 })),\n-                span: self.lower_span(span),\n+                span: self.lower_span(*span),\n                 origin: PredicateOrigin::WhereClause,\n             }),\n-            WherePredicate::RegionPredicate(WhereRegionPredicate {\n-                ref lifetime,\n-                ref bounds,\n-                span,\n-            }) => hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n-                span: self.lower_span(span),\n-                lifetime: self.lower_lifetime(lifetime),\n-                bounds: self.lower_param_bounds(\n-                    bounds,\n-                    &ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n-                ),\n-                in_where_clause: true,\n-            }),\n-            WherePredicate::EqPredicate(WhereEqPredicate { ref lhs_ty, ref rhs_ty, span }) => {\n+            WherePredicate::RegionPredicate(WhereRegionPredicate { lifetime, bounds, span }) => {\n+                hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n+                    span: self.lower_span(*span),\n+                    lifetime: self.lower_lifetime(lifetime),\n+                    bounds: self.lower_param_bounds(\n+                        bounds,\n+                        &ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n+                    ),\n+                    in_where_clause: true,\n+                })\n+            }\n+            WherePredicate::EqPredicate(WhereEqPredicate { lhs_ty, rhs_ty, span }) => {\n                 hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n                     lhs_ty: self\n                         .lower_ty(lhs_ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type)),\n                     rhs_ty: self\n                         .lower_ty(rhs_ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type)),\n-                    span: self.lower_span(span),\n+                    span: self.lower_span(*span),\n                 })\n             }\n         }"}, {"sha": "a123a58a8fbfa957b4cdb667e5864bb333276df5", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 127, "deletions": 166, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -60,8 +60,8 @@ use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n use rustc_hir::definitions::DefPathData;\n use rustc_hir::{ConstArg, GenericArg, ItemLocalId, ParamName, TraitCandidate};\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_middle::span_bug;\n use rustc_middle::ty::{ResolverAstLowering, TyCtxt};\n-use rustc_middle::{bug, span_bug};\n use rustc_session::parse::feature_err;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::DesugaringKind;\n@@ -327,7 +327,14 @@ enum FnDeclKind {\n }\n \n impl FnDeclKind {\n-    fn impl_trait_allowed(&self, tcx: TyCtxt<'_>) -> bool {\n+    fn param_impl_trait_allowed(&self) -> bool {\n+        match self {\n+            FnDeclKind::Fn | FnDeclKind::Inherent | FnDeclKind::Impl | FnDeclKind::Trait => true,\n+            _ => false,\n+        }\n+    }\n+\n+    fn return_impl_trait_allowed(&self, tcx: TyCtxt<'_>) -> bool {\n         match self {\n             FnDeclKind::Fn | FnDeclKind::Inherent => true,\n             FnDeclKind::Impl if tcx.features().return_position_impl_trait_in_trait => true,\n@@ -911,7 +918,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             AttrKind::Normal(ref normal) => AttrKind::Normal(P(NormalAttr {\n                 item: AttrItem {\n                     path: normal.item.path.clone(),\n-                    args: self.lower_mac_args(&normal.item.args),\n+                    args: self.lower_attr_args(&normal.item.args),\n                     tokens: None,\n                 },\n                 tokens: None,\n@@ -931,32 +938,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n     }\n \n-    fn lower_mac_args(&self, args: &MacArgs) -> MacArgs {\n-        match *args {\n-            MacArgs::Empty => MacArgs::Empty,\n-            MacArgs::Delimited(dspan, delim, ref tokens) => {\n-                // This is either a non-key-value attribute, or a `macro_rules!` body.\n-                // We either not have any nonterminals present (in the case of an attribute),\n-                // or have tokens available for all nonterminals in the case of a nested\n-                // `macro_rules`: e.g:\n-                //\n-                // ```rust\n-                // macro_rules! outer {\n-                //     ($e:expr) => {\n-                //         macro_rules! inner {\n-                //             () => { $e }\n-                //         }\n-                //     }\n-                // }\n-                // ```\n-                //\n-                // In both cases, we don't want to synthesize any tokens\n-                MacArgs::Delimited(dspan, delim, tokens.flattened())\n-            }\n+    fn lower_attr_args(&self, args: &AttrArgs) -> AttrArgs {\n+        match args {\n+            AttrArgs::Empty => AttrArgs::Empty,\n+            AttrArgs::Delimited(args) => AttrArgs::Delimited(self.lower_delim_args(args)),\n             // This is an inert key-value attribute - it will never be visible to macros\n             // after it gets lowered to HIR. Therefore, we can extract literals to handle\n             // nonterminals in `#[doc]` (e.g. `#[doc = $e]`).\n-            MacArgs::Eq(eq_span, MacArgsEq::Ast(ref expr)) => {\n+            AttrArgs::Eq(eq_span, AttrArgsEq::Ast(expr)) => {\n                 // In valid code the value always ends up as a single literal. Otherwise, a dummy\n                 // literal suffices because the error is handled elsewhere.\n                 let lit = if let ExprKind::Lit(token_lit) = expr.kind {\n@@ -975,14 +964,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         span: DUMMY_SP,\n                     }\n                 };\n-                MacArgs::Eq(eq_span, MacArgsEq::Hir(lit))\n+                AttrArgs::Eq(*eq_span, AttrArgsEq::Hir(lit))\n             }\n-            MacArgs::Eq(_, MacArgsEq::Hir(ref lit)) => {\n+            AttrArgs::Eq(_, AttrArgsEq::Hir(lit)) => {\n                 unreachable!(\"in literal form when lowering mac args eq: {:?}\", lit)\n             }\n         }\n     }\n \n+    fn lower_delim_args(&self, args: &DelimArgs) -> DelimArgs {\n+        DelimArgs { dspan: args.dspan, delim: args.delim, tokens: args.tokens.flattened() }\n+    }\n+\n     /// Given an associated type constraint like one of these:\n     ///\n     /// ```ignore (illustrative)\n@@ -1001,12 +994,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     ) -> hir::TypeBinding<'hir> {\n         debug!(\"lower_assoc_ty_constraint(constraint={:?}, itctx={:?})\", constraint, itctx);\n         // lower generic arguments of identifier in constraint\n-        let gen_args = if let Some(ref gen_args) = constraint.gen_args {\n+        let gen_args = if let Some(gen_args) = &constraint.gen_args {\n             let gen_args_ctor = match gen_args {\n-                GenericArgs::AngleBracketed(ref data) => {\n+                GenericArgs::AngleBracketed(data) => {\n                     self.lower_angle_bracketed_parameter_data(data, ParamMode::Explicit, itctx).0\n                 }\n-                GenericArgs::Parenthesized(ref data) => {\n+                GenericArgs::Parenthesized(data) => {\n                     self.emit_bad_parenthesized_trait_in_assoc_ty(data);\n                     let aba = self.ast_arena.aba.alloc(data.as_angle_bracketed_args());\n                     self.lower_angle_bracketed_parameter_data(aba, ParamMode::Explicit, itctx).0\n@@ -1018,15 +1011,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         };\n         let itctx_tait = &ImplTraitContext::TypeAliasesOpaqueTy;\n \n-        let kind = match constraint.kind {\n-            AssocConstraintKind::Equality { ref term } => {\n+        let kind = match &constraint.kind {\n+            AssocConstraintKind::Equality { term } => {\n                 let term = match term {\n-                    Term::Ty(ref ty) => self.lower_ty(ty, itctx).into(),\n-                    Term::Const(ref c) => self.lower_anon_const(c).into(),\n+                    Term::Ty(ty) => self.lower_ty(ty, itctx).into(),\n+                    Term::Const(c) => self.lower_anon_const(c).into(),\n                 };\n                 hir::TypeBindingKind::Equality { term }\n             }\n-            AssocConstraintKind::Bound { ref bounds } => {\n+            AssocConstraintKind::Bound { bounds } => {\n                 // Piggy-back on the `impl Trait` context to figure out the correct behavior.\n                 let (desugar_to_impl_trait, itctx) = match itctx {\n                     // We are in the return position:\n@@ -1136,7 +1129,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         match arg {\n             ast::GenericArg::Lifetime(lt) => GenericArg::Lifetime(self.lower_lifetime(&lt)),\n             ast::GenericArg::Type(ty) => {\n-                match ty.kind {\n+                match &ty.kind {\n                     TyKind::Infer if self.tcx.features().generic_arg_infer => {\n                         return GenericArg::Infer(hir::InferArg {\n                             hir_id: self.lower_node_id(ty.id),\n@@ -1147,7 +1140,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // parsing. We try to resolve that ambiguity by attempting resolution in both the\n                     // type and value namespaces. If we resolved the path in the value namespace, we\n                     // transform it into a generic const argument.\n-                    TyKind::Path(ref qself, ref path) => {\n+                    TyKind::Path(qself, path) => {\n                         if let Some(res) = self\n                             .resolver\n                             .get_partial_res(ty.id)\n@@ -1254,12 +1247,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn lower_ty_direct(&mut self, t: &Ty, itctx: &ImplTraitContext) -> hir::Ty<'hir> {\n-        let kind = match t.kind {\n+        let kind = match &t.kind {\n             TyKind::Infer => hir::TyKind::Infer,\n             TyKind::Err => hir::TyKind::Err,\n-            TyKind::Slice(ref ty) => hir::TyKind::Slice(self.lower_ty(ty, itctx)),\n-            TyKind::Ptr(ref mt) => hir::TyKind::Ptr(self.lower_mt(mt, itctx)),\n-            TyKind::Rptr(ref region, ref mt) => {\n+            TyKind::Slice(ty) => hir::TyKind::Slice(self.lower_ty(ty, itctx)),\n+            TyKind::Ptr(mt) => hir::TyKind::Ptr(self.lower_mt(mt, itctx)),\n+            TyKind::Rptr(region, mt) => {\n                 let region = region.unwrap_or_else(|| {\n                     let id = if let Some(LifetimeRes::ElidedAnchor { start, end }) =\n                         self.resolver.get_lifetime_res(t.id)\n@@ -1269,30 +1262,30 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     } else {\n                         self.next_node_id()\n                     };\n-                    let span = self.tcx.sess.source_map().start_point(t.span);\n+                    let span = self.tcx.sess.source_map().start_point(t.span).shrink_to_hi();\n                     Lifetime { ident: Ident::new(kw::UnderscoreLifetime, span), id }\n                 });\n                 let lifetime = self.lower_lifetime(&region);\n                 hir::TyKind::Rptr(lifetime, self.lower_mt(mt, itctx))\n             }\n-            TyKind::BareFn(ref f) => {\n+            TyKind::BareFn(f) => {\n                 let generic_params = self.lower_lifetime_binder(t.id, &f.generic_params);\n                 hir::TyKind::BareFn(self.arena.alloc(hir::BareFnTy {\n                     generic_params,\n                     unsafety: self.lower_unsafety(f.unsafety),\n                     abi: self.lower_extern(f.ext),\n-                    decl: self.lower_fn_decl(&f.decl, None, t.span, FnDeclKind::Pointer, None),\n+                    decl: self.lower_fn_decl(&f.decl, t.id, t.span, FnDeclKind::Pointer, None),\n                     param_names: self.lower_fn_params_to_names(&f.decl),\n                 }))\n             }\n             TyKind::Never => hir::TyKind::Never,\n-            TyKind::Tup(ref tys) => hir::TyKind::Tup(\n+            TyKind::Tup(tys) => hir::TyKind::Tup(\n                 self.arena.alloc_from_iter(tys.iter().map(|ty| self.lower_ty_direct(ty, itctx))),\n             ),\n-            TyKind::Paren(ref ty) => {\n+            TyKind::Paren(ty) => {\n                 return self.lower_ty_direct(ty, itctx);\n             }\n-            TyKind::Path(ref qself, ref path) => {\n+            TyKind::Path(qself, path) => {\n                 return self.lower_path_ty(t, qself, path, ParamMode::Explicit, itctx);\n             }\n             TyKind::ImplicitSelf => {\n@@ -1312,70 +1305,68 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     }),\n                 ))\n             }\n-            TyKind::Array(ref ty, ref length) => {\n+            TyKind::Array(ty, length) => {\n                 hir::TyKind::Array(self.lower_ty(ty, itctx), self.lower_array_length(length))\n             }\n-            TyKind::Typeof(ref expr) => hir::TyKind::Typeof(self.lower_anon_const(expr)),\n-            TyKind::TraitObject(ref bounds, kind) => {\n+            TyKind::Typeof(expr) => hir::TyKind::Typeof(self.lower_anon_const(expr)),\n+            TyKind::TraitObject(bounds, kind) => {\n                 let mut lifetime_bound = None;\n                 let (bounds, lifetime_bound) = self.with_dyn_type_scope(true, |this| {\n                     let bounds =\n-                        this.arena.alloc_from_iter(bounds.iter().filter_map(\n-                            |bound| match *bound {\n-                                GenericBound::Trait(\n-                                    ref ty,\n-                                    TraitBoundModifier::None | TraitBoundModifier::MaybeConst,\n-                                ) => Some(this.lower_poly_trait_ref(ty, itctx)),\n-                                // `~const ?Bound` will cause an error during AST validation\n-                                // anyways, so treat it like `?Bound` as compilation proceeds.\n-                                GenericBound::Trait(\n-                                    _,\n-                                    TraitBoundModifier::Maybe | TraitBoundModifier::MaybeConstMaybe,\n-                                ) => None,\n-                                GenericBound::Outlives(ref lifetime) => {\n-                                    if lifetime_bound.is_none() {\n-                                        lifetime_bound = Some(this.lower_lifetime(lifetime));\n-                                    }\n-                                    None\n+                        this.arena.alloc_from_iter(bounds.iter().filter_map(|bound| match bound {\n+                            GenericBound::Trait(\n+                                ty,\n+                                TraitBoundModifier::None | TraitBoundModifier::MaybeConst,\n+                            ) => Some(this.lower_poly_trait_ref(ty, itctx)),\n+                            // `~const ?Bound` will cause an error during AST validation\n+                            // anyways, so treat it like `?Bound` as compilation proceeds.\n+                            GenericBound::Trait(\n+                                _,\n+                                TraitBoundModifier::Maybe | TraitBoundModifier::MaybeConstMaybe,\n+                            ) => None,\n+                            GenericBound::Outlives(lifetime) => {\n+                                if lifetime_bound.is_none() {\n+                                    lifetime_bound = Some(this.lower_lifetime(lifetime));\n                                 }\n-                            },\n-                        ));\n+                                None\n+                            }\n+                        }));\n                     let lifetime_bound =\n                         lifetime_bound.unwrap_or_else(|| this.elided_dyn_bound(t.span));\n                     (bounds, lifetime_bound)\n                 });\n-                hir::TyKind::TraitObject(bounds, lifetime_bound, kind)\n+                hir::TyKind::TraitObject(bounds, lifetime_bound, *kind)\n             }\n-            TyKind::ImplTrait(def_node_id, ref bounds) => {\n+            TyKind::ImplTrait(def_node_id, bounds) => {\n                 let span = t.span;\n                 match itctx {\n                     ImplTraitContext::ReturnPositionOpaqueTy { origin, in_trait } => self\n                         .lower_opaque_impl_trait(\n                             span,\n                             *origin,\n-                            def_node_id,\n+                            *def_node_id,\n                             bounds,\n                             *in_trait,\n                             itctx,\n                         ),\n                     ImplTraitContext::TypeAliasesOpaqueTy => self.lower_opaque_impl_trait(\n                         span,\n                         hir::OpaqueTyOrigin::TyAlias,\n-                        def_node_id,\n+                        *def_node_id,\n                         bounds,\n                         false,\n                         itctx,\n                     ),\n                     ImplTraitContext::Universal => {\n                         self.create_def(\n                             self.current_hir_id_owner.def_id,\n-                            def_node_id,\n+                            *def_node_id,\n                             DefPathData::ImplTrait,\n                         );\n                         let span = t.span;\n                         let ident = Ident::from_str_and_span(&pprust::ty_to_string(t), span);\n                         let (param, bounds, path) =\n-                            self.lower_generic_and_bounds(def_node_id, span, ident, bounds);\n+                            self.lower_generic_and_bounds(*def_node_id, span, ident, bounds);\n                         self.impl_trait_defs.push(param);\n                         if let Some(bounds) = bounds {\n                             self.impl_trait_bounds.push(bounds);\n@@ -1465,17 +1456,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // frequently opened issues show.\n         let opaque_ty_span = self.mark_span_with_reason(DesugaringKind::OpaqueTy, span, None);\n \n-        let opaque_ty_def_id = match origin {\n-            hir::OpaqueTyOrigin::TyAlias => self.create_def(\n-                self.current_hir_id_owner.def_id,\n-                opaque_ty_node_id,\n-                DefPathData::ImplTrait,\n-            ),\n-            hir::OpaqueTyOrigin::FnReturn(fn_def_id) => {\n-                self.create_def(fn_def_id, opaque_ty_node_id, DefPathData::ImplTrait)\n-            }\n-            hir::OpaqueTyOrigin::AsyncFn(..) => bug!(\"unreachable\"),\n-        };\n+        let opaque_ty_def_id = self.create_def(\n+            self.current_hir_id_owner.def_id,\n+            opaque_ty_node_id,\n+            DefPathData::ImplTrait,\n+        );\n         debug!(?opaque_ty_def_id);\n \n         // Contains the new lifetime definitions created for the TAIT (if any).\n@@ -1568,15 +1553,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let lifetimes =\n             self.arena.alloc_from_iter(collected_lifetimes.into_iter().map(|(_, lifetime)| {\n                 let id = self.next_node_id();\n-                let span = lifetime.ident.span;\n-\n-                let ident = if lifetime.ident.name == kw::UnderscoreLifetime {\n-                    Ident::with_dummy_span(kw::UnderscoreLifetime)\n-                } else {\n-                    lifetime.ident\n-                };\n-\n-                let l = self.new_named_lifetime(lifetime.id, id, span, ident);\n+                let l = self.new_named_lifetime(lifetime.id, id, lifetime.ident);\n                 hir::GenericArg::Lifetime(l)\n             }));\n         debug!(?lifetimes);\n@@ -1701,7 +1678,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_fn_decl(\n         &mut self,\n         decl: &FnDecl,\n-        fn_node_id: Option<NodeId>,\n+        fn_node_id: NodeId,\n         fn_span: Span,\n         kind: FnDeclKind,\n         make_ret_async: Option<(NodeId, Span)>,\n@@ -1716,23 +1693,21 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             inputs = &inputs[..inputs.len() - 1];\n         }\n         let inputs = self.arena.alloc_from_iter(inputs.iter().map(|param| {\n-            if fn_node_id.is_some() {\n-                self.lower_ty_direct(&param.ty, &ImplTraitContext::Universal)\n+            let itctx = if kind.param_impl_trait_allowed() {\n+                ImplTraitContext::Universal\n             } else {\n-                self.lower_ty_direct(\n-                    &param.ty,\n-                    &ImplTraitContext::Disallowed(match kind {\n-                        FnDeclKind::Fn | FnDeclKind::Inherent => {\n-                            unreachable!(\"fn should allow in-band lifetimes\")\n-                        }\n-                        FnDeclKind::ExternFn => ImplTraitPosition::ExternFnParam,\n-                        FnDeclKind::Closure => ImplTraitPosition::ClosureParam,\n-                        FnDeclKind::Pointer => ImplTraitPosition::PointerParam,\n-                        FnDeclKind::Trait => ImplTraitPosition::TraitParam,\n-                        FnDeclKind::Impl => ImplTraitPosition::ImplParam,\n-                    }),\n-                )\n-            }\n+                ImplTraitContext::Disallowed(match kind {\n+                    FnDeclKind::Fn | FnDeclKind::Inherent => {\n+                        unreachable!(\"fn should allow APIT\")\n+                    }\n+                    FnDeclKind::ExternFn => ImplTraitPosition::ExternFnParam,\n+                    FnDeclKind::Closure => ImplTraitPosition::ClosureParam,\n+                    FnDeclKind::Pointer => ImplTraitPosition::PointerParam,\n+                    FnDeclKind::Trait => ImplTraitPosition::TraitParam,\n+                    FnDeclKind::Impl => ImplTraitPosition::ImplParam,\n+                })\n+            };\n+            self.lower_ty_direct(&param.ty, &itctx)\n         }));\n \n         let output = if let Some((ret_id, span)) = make_ret_async {\n@@ -1755,22 +1730,21 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n             self.lower_async_fn_ret_ty(\n                 &decl.output,\n-                fn_node_id.expect(\"`make_ret_async` but no `fn_def_id`\"),\n+                fn_node_id,\n                 ret_id,\n                 matches!(kind, FnDeclKind::Trait),\n             )\n         } else {\n-            match decl.output {\n-                FnRetTy::Ty(ref ty) => {\n-                    let mut context = match fn_node_id {\n-                        Some(fn_node_id) if kind.impl_trait_allowed(self.tcx) => {\n-                            let fn_def_id = self.local_def_id(fn_node_id);\n-                            ImplTraitContext::ReturnPositionOpaqueTy {\n-                                origin: hir::OpaqueTyOrigin::FnReturn(fn_def_id),\n-                                in_trait: matches!(kind, FnDeclKind::Trait),\n-                            }\n+            match &decl.output {\n+                FnRetTy::Ty(ty) => {\n+                    let mut context = if kind.return_impl_trait_allowed(self.tcx) {\n+                        let fn_def_id = self.local_def_id(fn_node_id);\n+                        ImplTraitContext::ReturnPositionOpaqueTy {\n+                            origin: hir::OpaqueTyOrigin::FnReturn(fn_def_id),\n+                            in_trait: matches!(kind, FnDeclKind::Trait),\n                         }\n-                        _ => ImplTraitContext::Disallowed(match kind {\n+                    } else {\n+                        ImplTraitContext::Disallowed(match kind {\n                             FnDeclKind::Fn | FnDeclKind::Inherent => {\n                                 unreachable!(\"fn should allow in-band lifetimes\")\n                             }\n@@ -1779,38 +1753,35 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             FnDeclKind::Pointer => ImplTraitPosition::PointerReturn,\n                             FnDeclKind::Trait => ImplTraitPosition::TraitReturn,\n                             FnDeclKind::Impl => ImplTraitPosition::ImplReturn,\n-                        }),\n+                        })\n                     };\n                     hir::FnRetTy::Return(self.lower_ty(ty, &mut context))\n                 }\n-                FnRetTy::Default(span) => hir::FnRetTy::DefaultReturn(self.lower_span(span)),\n+                FnRetTy::Default(span) => hir::FnRetTy::DefaultReturn(self.lower_span(*span)),\n             }\n         };\n \n         self.arena.alloc(hir::FnDecl {\n             inputs,\n             output,\n             c_variadic,\n+            lifetime_elision_allowed: self.resolver.lifetime_elision_allowed.contains(&fn_node_id),\n             implicit_self: decl.inputs.get(0).map_or(hir::ImplicitSelfKind::None, |arg| {\n                 let is_mutable_pat = matches!(\n                     arg.pat.kind,\n                     PatKind::Ident(hir::BindingAnnotation(_, Mutability::Mut), ..)\n                 );\n \n-                match arg.ty.kind {\n+                match &arg.ty.kind {\n                     TyKind::ImplicitSelf if is_mutable_pat => hir::ImplicitSelfKind::Mut,\n                     TyKind::ImplicitSelf => hir::ImplicitSelfKind::Imm,\n                     // Given we are only considering `ImplicitSelf` types, we needn't consider\n                     // the case where we have a mutable pattern to a reference as that would\n                     // no longer be an `ImplicitSelf`.\n-                    TyKind::Rptr(_, ref mt)\n-                        if mt.ty.kind.is_implicit_self() && mt.mutbl == ast::Mutability::Mut =>\n-                    {\n-                        hir::ImplicitSelfKind::MutRef\n-                    }\n-                    TyKind::Rptr(_, ref mt) if mt.ty.kind.is_implicit_self() => {\n-                        hir::ImplicitSelfKind::ImmRef\n-                    }\n+                    TyKind::Rptr(_, mt) if mt.ty.kind.is_implicit_self() => match mt.mutbl {\n+                        hir::Mutability::Not => hir::ImplicitSelfKind::ImmRef,\n+                        hir::Mutability::Mut => hir::ImplicitSelfKind::MutRef,\n+                    },\n                     _ => hir::ImplicitSelfKind::None,\n                 }\n             }),\n@@ -1837,9 +1808,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         let opaque_ty_span = self.mark_span_with_reason(DesugaringKind::Async, span, None);\n \n-        let opaque_ty_def_id = self.local_def_id(opaque_ty_node_id);\n         let fn_def_id = self.local_def_id(fn_node_id);\n \n+        let opaque_ty_def_id =\n+            self.create_def(fn_def_id, opaque_ty_node_id, DefPathData::ImplTrait);\n+\n         // When we create the opaque type for this async fn, it is going to have\n         // to capture all the lifetimes involved in the signature (including in the\n         // return type). This is done by introducing lifetime parameters for:\n@@ -2034,18 +2007,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let generic_args = self.arena.alloc_from_iter(collected_lifetimes.into_iter().map(\n             |(_, lifetime, res)| {\n                 let id = self.next_node_id();\n-                let span = lifetime.ident.span;\n-\n-                let ident = if lifetime.ident.name == kw::UnderscoreLifetime {\n-                    Ident::with_dummy_span(kw::UnderscoreLifetime)\n-                } else {\n-                    lifetime.ident\n-                };\n-\n                 let res = res.unwrap_or(\n                     self.resolver.get_lifetime_res(lifetime.id).unwrap_or(LifetimeRes::Error),\n                 );\n-                hir::GenericArg::Lifetime(self.new_named_lifetime_with_res(id, span, ident, res))\n+                hir::GenericArg::Lifetime(self.new_named_lifetime_with_res(id, lifetime.ident, res))\n             },\n         ));\n \n@@ -2115,43 +2080,40 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn lower_lifetime(&mut self, l: &Lifetime) -> &'hir hir::Lifetime {\n-        let span = self.lower_span(l.ident.span);\n         let ident = self.lower_ident(l.ident);\n-        self.new_named_lifetime(l.id, l.id, span, ident)\n+        self.new_named_lifetime(l.id, l.id, ident)\n     }\n \n     #[instrument(level = \"debug\", skip(self))]\n     fn new_named_lifetime_with_res(\n         &mut self,\n         id: NodeId,\n-        span: Span,\n         ident: Ident,\n         res: LifetimeRes,\n     ) -> &'hir hir::Lifetime {\n-        let name = match res {\n+        let res = match res {\n             LifetimeRes::Param { param, .. } => {\n-                let p_name = ParamName::Plain(ident);\n                 let param = self.get_remapped_def_id(param);\n-\n-                hir::LifetimeName::Param(param, p_name)\n+                hir::LifetimeName::Param(param)\n             }\n             LifetimeRes::Fresh { param, .. } => {\n-                debug_assert_eq!(ident.name, kw::UnderscoreLifetime);\n                 let param = self.local_def_id(param);\n-\n-                hir::LifetimeName::Param(param, ParamName::Fresh)\n+                hir::LifetimeName::Param(param)\n             }\n             LifetimeRes::Infer => hir::LifetimeName::Infer,\n             LifetimeRes::Static => hir::LifetimeName::Static,\n             LifetimeRes::Error => hir::LifetimeName::Error,\n-            res => panic!(\"Unexpected lifetime resolution {:?} for {:?} at {:?}\", res, ident, span),\n+            res => panic!(\n+                \"Unexpected lifetime resolution {:?} for {:?} at {:?}\",\n+                res, ident, ident.span\n+            ),\n         };\n \n-        debug!(?name);\n+        debug!(?res);\n         self.arena.alloc(hir::Lifetime {\n             hir_id: self.lower_node_id(id),\n-            span: self.lower_span(span),\n-            name,\n+            ident: self.lower_ident(ident),\n+            res,\n         })\n     }\n \n@@ -2160,11 +2122,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         id: NodeId,\n         new_id: NodeId,\n-        span: Span,\n         ident: Ident,\n     ) -> &'hir hir::Lifetime {\n         let res = self.resolver.get_lifetime_res(id).unwrap_or(LifetimeRes::Error);\n-        self.new_named_lifetime_with_res(new_id, span, ident, res)\n+        self.new_named_lifetime_with_res(new_id, ident, res)\n     }\n \n     fn lower_generic_params_mut<'s>(\n@@ -2199,7 +2160,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         param: &GenericParam,\n     ) -> (hir::ParamName, hir::GenericParamKind<'hir>) {\n-        match param.kind {\n+        match &param.kind {\n             GenericParamKind::Lifetime => {\n                 // AST resolution emitted an error on those parameters, so we lower them using\n                 // `ParamName::Error`.\n@@ -2215,7 +2176,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                 (param_name, kind)\n             }\n-            GenericParamKind::Type { ref default, .. } => {\n+            GenericParamKind::Type { default, .. } => {\n                 let kind = hir::GenericParamKind::Type {\n                     default: default.as_ref().map(|x| {\n                         self.lower_ty(x, &ImplTraitContext::Disallowed(ImplTraitPosition::Type))\n@@ -2225,7 +2186,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                 (hir::ParamName::Plain(self.lower_ident(param.ident)), kind)\n             }\n-            GenericParamKind::Const { ref ty, kw_span: _, ref default } => {\n+            GenericParamKind::Const { ty, kw_span: _, default } => {\n                 let ty = self.lower_ty(&ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n                 let default = default.as_ref().map(|def| self.lower_anon_const(def));\n                 (\n@@ -2576,8 +2537,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn elided_dyn_bound(&mut self, span: Span) -> &'hir hir::Lifetime {\n         let r = hir::Lifetime {\n             hir_id: self.next_id(),\n-            span: self.lower_span(span),\n-            name: hir::LifetimeName::ImplicitObjectLifetimeDefault,\n+            ident: Ident::new(kw::Empty, self.lower_span(span)),\n+            res: hir::LifetimeName::ImplicitObjectLifetimeDefault,\n         };\n         debug!(\"elided_dyn_bound: r={:?}\", r);\n         self.arena.alloc(r)"}, {"sha": "16b012630da0e90d847c0961c019666420536230", "filename": "compiler/rustc_ast_lowering/src/pat.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -22,16 +22,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         ensure_sufficient_stack(|| {\n             // loop here to avoid recursion\n             let node = loop {\n-                match pattern.kind {\n+                match &pattern.kind {\n                     PatKind::Wild => break hir::PatKind::Wild,\n-                    PatKind::Ident(binding_mode, ident, ref sub) => {\n-                        let lower_sub = |this: &mut Self| sub.as_ref().map(|s| this.lower_pat(&*s));\n-                        break self.lower_pat_ident(pattern, binding_mode, ident, lower_sub);\n+                    PatKind::Ident(binding_mode, ident, sub) => {\n+                        let lower_sub = |this: &mut Self| sub.as_ref().map(|s| this.lower_pat(s));\n+                        break self.lower_pat_ident(pattern, *binding_mode, *ident, lower_sub);\n                     }\n-                    PatKind::Lit(ref e) => {\n+                    PatKind::Lit(e) => {\n                         break hir::PatKind::Lit(self.lower_expr_within_pat(e, false));\n                     }\n-                    PatKind::TupleStruct(ref qself, ref path, ref pats) => {\n+                    PatKind::TupleStruct(qself, path, pats) => {\n                         let qpath = self.lower_qpath(\n                             pattern.id,\n                             qself,\n@@ -42,12 +42,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple struct\");\n                         break hir::PatKind::TupleStruct(qpath, pats, ddpos);\n                     }\n-                    PatKind::Or(ref pats) => {\n+                    PatKind::Or(pats) => {\n                         break hir::PatKind::Or(\n                             self.arena.alloc_from_iter(pats.iter().map(|x| self.lower_pat_mut(x))),\n                         );\n                     }\n-                    PatKind::Path(ref qself, ref path) => {\n+                    PatKind::Path(qself, path) => {\n                         let qpath = self.lower_qpath(\n                             pattern.id,\n                             qself,\n@@ -57,7 +57,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         );\n                         break hir::PatKind::Path(qpath);\n                     }\n-                    PatKind::Struct(ref qself, ref path, ref fields, etc) => {\n+                    PatKind::Struct(qself, path, fields, etc) => {\n                         let qpath = self.lower_qpath(\n                             pattern.id,\n                             qself,\n@@ -78,32 +78,32 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                 span: self.lower_span(f.span),\n                             }\n                         }));\n-                        break hir::PatKind::Struct(qpath, fs, etc);\n+                        break hir::PatKind::Struct(qpath, fs, *etc);\n                     }\n-                    PatKind::Tuple(ref pats) => {\n+                    PatKind::Tuple(pats) => {\n                         let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple\");\n                         break hir::PatKind::Tuple(pats, ddpos);\n                     }\n-                    PatKind::Box(ref inner) => {\n+                    PatKind::Box(inner) => {\n                         break hir::PatKind::Box(self.lower_pat(inner));\n                     }\n-                    PatKind::Ref(ref inner, mutbl) => {\n-                        break hir::PatKind::Ref(self.lower_pat(inner), mutbl);\n+                    PatKind::Ref(inner, mutbl) => {\n+                        break hir::PatKind::Ref(self.lower_pat(inner), *mutbl);\n                     }\n-                    PatKind::Range(ref e1, ref e2, Spanned { node: ref end, .. }) => {\n+                    PatKind::Range(e1, e2, Spanned { node: end, .. }) => {\n                         break hir::PatKind::Range(\n                             e1.as_deref().map(|e| self.lower_expr_within_pat(e, true)),\n                             e2.as_deref().map(|e| self.lower_expr_within_pat(e, true)),\n                             self.lower_range_end(end, e2.is_some()),\n                         );\n                     }\n-                    PatKind::Slice(ref pats) => break self.lower_pat_slice(pats),\n+                    PatKind::Slice(pats) => break self.lower_pat_slice(pats),\n                     PatKind::Rest => {\n                         // If we reach here the `..` pattern is not semantically allowed.\n                         break self.ban_illegal_rest_pat(pattern.span);\n                     }\n                     // return inner to be processed in next loop\n-                    PatKind::Paren(ref inner) => pattern = inner,\n+                    PatKind::Paren(inner) => pattern = inner,\n                     PatKind::MacCall(_) => panic!(\"{:?} shouldn't exist here\", pattern.span),\n                 }\n             };\n@@ -126,20 +126,20 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             // Note that unlike for slice patterns,\n             // where `xs @ ..` is a legal sub-slice pattern,\n             // it is not a legal sub-tuple pattern.\n-            match pat.kind {\n+            match &pat.kind {\n                 // Found a sub-tuple rest pattern\n                 PatKind::Rest => {\n                     rest = Some((idx, pat.span));\n                     break;\n                 }\n                 // Found a sub-tuple pattern `$binding_mode $ident @ ..`.\n                 // This is not allowed as a sub-tuple pattern\n-                PatKind::Ident(ref _bm, ident, Some(ref sub)) if sub.is_rest() => {\n+                PatKind::Ident(_, ident, Some(sub)) if sub.is_rest() => {\n                     let sp = pat.span;\n                     self.tcx.sess.emit_err(SubTupleBinding {\n                         span: sp,\n                         ident_name: ident.name,\n-                        ident,\n+                        ident: *ident,\n                         ctx,\n                     });\n                 }\n@@ -176,7 +176,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let mut prev_rest_span = None;\n \n         // Lowers `$bm $ident @ ..` to `$bm $ident @ _`.\n-        let lower_rest_sub = |this: &mut Self, pat, ann, ident, sub| {\n+        let lower_rest_sub = |this: &mut Self, pat, &ann, &ident, sub| {\n             let lower_sub = |this: &mut Self| Some(this.pat_wild_with_node_id_of(sub));\n             let node = this.lower_pat_ident(pat, ann, ident, lower_sub);\n             this.pat_with_node_id_of(pat, node)\n@@ -185,7 +185,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let mut iter = pats.iter();\n         // Lower all the patterns until the first occurrence of a sub-slice pattern.\n         for pat in iter.by_ref() {\n-            match pat.kind {\n+            match &pat.kind {\n                 // Found a sub-slice pattern `..`. Record, lower it to `_`, and stop here.\n                 PatKind::Rest => {\n                     prev_rest_span = Some(pat.span);\n@@ -194,7 +194,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 }\n                 // Found a sub-slice pattern `$binding_mode $ident @ ..`.\n                 // Record, lower it to `$binding_mode $ident @ _`, and stop here.\n-                PatKind::Ident(ann, ident, Some(ref sub)) if sub.is_rest() => {\n+                PatKind::Ident(ann, ident, Some(sub)) if sub.is_rest() => {\n                     prev_rest_span = Some(sub.span);\n                     slice = Some(self.arena.alloc(lower_rest_sub(self, pat, ann, ident, sub)));\n                     break;\n@@ -207,9 +207,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // Lower all the patterns after the first sub-slice pattern.\n         for pat in iter {\n             // There was a previous subslice pattern; make sure we don't allow more.\n-            let rest_span = match pat.kind {\n+            let rest_span = match &pat.kind {\n                 PatKind::Rest => Some(pat.span),\n-                PatKind::Ident(ann, ident, Some(ref sub)) if sub.is_rest() => {\n+                PatKind::Ident(ann, ident, Some(sub)) if sub.is_rest() => {\n                     // #69103: Lower into `binding @ _` as above to avoid ICEs.\n                     after.push(lower_rest_sub(self, pat, ann, ident, sub));\n                     Some(sub.span)\n@@ -322,13 +322,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     // m!(S);\n     // ```\n     fn lower_expr_within_pat(&mut self, expr: &Expr, allow_paths: bool) -> &'hir hir::Expr<'hir> {\n-        match expr.kind {\n+        match &expr.kind {\n             ExprKind::Lit(..)\n             | ExprKind::ConstBlock(..)\n             | ExprKind::IncludedBytes(..)\n             | ExprKind::Err => {}\n             ExprKind::Path(..) if allow_paths => {}\n-            ExprKind::Unary(UnOp::Neg, ref inner) if matches!(inner.kind, ExprKind::Lit(_)) => {}\n+            ExprKind::Unary(UnOp::Neg, inner) if matches!(inner.kind, ExprKind::Lit(_)) => {}\n             _ => {\n                 self.tcx.sess.emit_err(ArbitraryExpressionInPattern { span: expr.span });\n                 return self.arena.alloc(self.expr_err(expr.span));"}, {"sha": "dc85b5e95ea86d75a73a63cd9e0eaa1d9fb5bd1b", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -185,12 +185,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         itctx: &ImplTraitContext,\n     ) -> hir::PathSegment<'hir> {\n         debug!(\"path_span: {:?}, lower_path_segment(segment: {:?})\", path_span, segment,);\n-        let (mut generic_args, infer_args) = if let Some(ref generic_args) = segment.args {\n-            match **generic_args {\n-                GenericArgs::AngleBracketed(ref data) => {\n+        let (mut generic_args, infer_args) = if let Some(generic_args) = segment.args.as_deref() {\n+            match generic_args {\n+                GenericArgs::AngleBracketed(data) => {\n                     self.lower_angle_bracketed_parameter_data(data, param_mode, itctx)\n                 }\n-                GenericArgs::Parenthesized(ref data) => match parenthesized_generic_args {\n+                GenericArgs::Parenthesized(data) => match parenthesized_generic_args {\n                     ParenthesizedGenericArgs::Ok => {\n                         self.lower_parenthesized_parameter_data(data, itctx)\n                     }\n@@ -309,7 +309,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 let id = NodeId::from_u32(i);\n                 let l = self.lower_lifetime(&Lifetime {\n                     id,\n-                    ident: Ident::new(kw::UnderscoreLifetime, elided_lifetime_span),\n+                    ident: Ident::new(kw::Empty, elided_lifetime_span),\n                 });\n                 GenericArg::Lifetime(l)\n             }),"}, {"sha": "acd7eb69ffc376f540f7ac879a0921af7e097364", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -1637,7 +1637,7 @@ fn deny_equality_constraints(\n                                     // Remove `Bar` from `Foo::Bar`.\n                                     assoc_path.segments.pop();\n                                     let len = assoc_path.segments.len() - 1;\n-                                    let gen_args = args.as_ref().map(|p| (**p).clone());\n+                                    let gen_args = args.as_deref().cloned();\n                                     // Build `<Bar = RhsTy>`.\n                                     let arg = AngleBracketedArg::Constraint(AssocConstraint {\n                                         id: rustc_ast::node_id::DUMMY_NODE_ID,"}, {"sha": "991f6e0ba224340024055395ae91454109117a40", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -11,10 +11,9 @@ use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_ast::util::classify;\n use rustc_ast::util::comments::{gather_comments, Comment, CommentStyle};\n use rustc_ast::util::parser;\n-use rustc_ast::{self as ast, BlockCheckMode, Mutability, PatKind, RangeEnd, RangeSyntax};\n-use rustc_ast::{attr, BindingAnnotation, ByRef, Term};\n-use rustc_ast::{GenericArg, MacArgs, MacArgsEq};\n-use rustc_ast::{GenericBound, SelfKind, TraitBoundModifier};\n+use rustc_ast::{self as ast, AttrArgs, AttrArgsEq, BlockCheckMode, Mutability, PatKind};\n+use rustc_ast::{attr, BindingAnnotation, ByRef, DelimArgs, RangeEnd, RangeSyntax, Term};\n+use rustc_ast::{GenericArg, GenericBound, SelfKind, TraitBoundModifier};\n use rustc_ast::{InlineAsmOperand, InlineAsmRegOrRegClass};\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_span::edition::Edition;\n@@ -466,26 +465,26 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n     fn print_attr_item(&mut self, item: &ast::AttrItem, span: Span) {\n         self.ibox(0);\n         match &item.args {\n-            MacArgs::Delimited(_, delim, tokens) => self.print_mac_common(\n+            AttrArgs::Delimited(DelimArgs { dspan: _, delim, tokens }) => self.print_mac_common(\n                 Some(MacHeader::Path(&item.path)),\n                 false,\n                 None,\n-                Some(delim.to_token()),\n+                delim.to_token(),\n                 tokens,\n                 true,\n                 span,\n             ),\n-            MacArgs::Empty => {\n+            AttrArgs::Empty => {\n                 self.print_path(&item.path, false, 0);\n             }\n-            MacArgs::Eq(_, MacArgsEq::Ast(expr)) => {\n+            AttrArgs::Eq(_, AttrArgsEq::Ast(expr)) => {\n                 self.print_path(&item.path, false, 0);\n                 self.space();\n                 self.word_space(\"=\");\n                 let token_str = self.expr_to_string(expr);\n                 self.word(token_str);\n             }\n-            MacArgs::Eq(_, MacArgsEq::Hir(lit)) => {\n+            AttrArgs::Eq(_, AttrArgsEq::Hir(lit)) => {\n                 self.print_path(&item.path, false, 0);\n                 self.space();\n                 self.word_space(\"=\");\n@@ -544,7 +543,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                     None,\n                     false,\n                     None,\n-                    Some(*delim),\n+                    *delim,\n                     tts,\n                     convert_dollar_crate,\n                     dspan.entire(),\n@@ -570,12 +569,12 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n         header: Option<MacHeader<'_>>,\n         has_bang: bool,\n         ident: Option<Ident>,\n-        delim: Option<Delimiter>,\n+        delim: Delimiter,\n         tts: &TokenStream,\n         convert_dollar_crate: bool,\n         span: Span,\n     ) {\n-        if delim == Some(Delimiter::Brace) {\n+        if delim == Delimiter::Brace {\n             self.cbox(INDENT_UNIT);\n         }\n         match header {\n@@ -591,7 +590,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n             self.print_ident(ident);\n         }\n         match delim {\n-            Some(Delimiter::Brace) => {\n+            Delimiter::Brace => {\n                 if header.is_some() || has_bang || ident.is_some() {\n                     self.nbsp();\n                 }\n@@ -605,7 +604,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                 let empty = tts.is_empty();\n                 self.bclose(span, empty);\n             }\n-            Some(delim) => {\n+            delim => {\n                 let token_str = self.token_kind_to_string(&token::OpenDelim(delim));\n                 self.word(token_str);\n                 self.ibox(0);\n@@ -614,11 +613,6 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                 let token_str = self.token_kind_to_string(&token::CloseDelim(delim));\n                 self.word(token_str);\n             }\n-            None => {\n-                self.ibox(0);\n-                self.print_tts(tts, convert_dollar_crate);\n-                self.end();\n-            }\n         }\n     }\n \n@@ -639,8 +633,8 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n             Some(MacHeader::Keyword(kw)),\n             has_bang,\n             Some(*ident),\n-            macro_def.body.delim(),\n-            &macro_def.body.inner_tokens(),\n+            macro_def.body.delim.to_token(),\n+            &macro_def.body.tokens.clone(),\n             true,\n             sp,\n         );\n@@ -1230,8 +1224,8 @@ impl<'a> State<'a> {\n             Some(MacHeader::Path(&m.path)),\n             true,\n             None,\n-            m.args.delim(),\n-            &m.args.inner_tokens(),\n+            m.args.delim.to_token(),\n+            &m.args.tokens.clone(),\n             true,\n             m.span(),\n         );"}, {"sha": "4b37fa027f53b75046029d2180ff43f8e9c5a00f", "filename": "compiler/rustc_ast_pretty/src/pprust/state/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -377,7 +377,7 @@ impl<'a> State<'a> {\n                 self.space();\n                 self.print_block_with_attrs(blk, attrs);\n             }\n-            ast::ExprKind::Loop(ref blk, opt_label) => {\n+            ast::ExprKind::Loop(ref blk, opt_label, _) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n                     self.word_space(\":\");"}, {"sha": "5ec9c5f5c1b5541ebab2610f9f4734cfecd0f393", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 218, "deletions": 63, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -7,7 +7,7 @@ use rustc_errors::{\n };\n use rustc_hir as hir;\n use rustc_hir::intravisit::{walk_block, walk_expr, Visitor};\n-use rustc_hir::{AsyncGeneratorKind, GeneratorKind};\n+use rustc_hir::{AsyncGeneratorKind, GeneratorKind, LangItem};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_infer::traits::ObligationCause;\n use rustc_middle::mir::tcx::PlaceTy;\n@@ -167,10 +167,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 );\n             }\n \n-            self.add_moved_or_invoked_closure_note(location, used_place, &mut err);\n+            let closure = self.add_moved_or_invoked_closure_note(location, used_place, &mut err);\n \n             let mut is_loop_move = false;\n             let mut in_pattern = false;\n+            let mut seen_spans = FxHashSet::default();\n \n             for move_site in &move_site_vec {\n                 let move_out = self.move_data.moves[(*move_site).moi];\n@@ -191,37 +192,25 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     is_loop_move = true;\n                 }\n \n-                self.explain_captures(\n-                    &mut err,\n-                    span,\n-                    move_span,\n-                    move_spans,\n-                    *moved_place,\n-                    partially_str,\n-                    loop_message,\n-                    move_msg,\n-                    is_loop_move,\n-                    maybe_reinitialized_locations.is_empty(),\n-                );\n-\n-                if let (UseSpans::PatUse(span), []) =\n-                    (move_spans, &maybe_reinitialized_locations[..])\n-                {\n-                    if maybe_reinitialized_locations.is_empty() {\n-                        err.span_suggestion_verbose(\n-                            span.shrink_to_lo(),\n-                            &format!(\n-                                \"borrow this field in the pattern to avoid moving {}\",\n-                                self.describe_place(moved_place.as_ref())\n-                                    .map(|n| format!(\"`{}`\", n))\n-                                    .unwrap_or_else(|| \"the value\".to_string())\n-                            ),\n-                            \"ref \",\n-                            Applicability::MachineApplicable,\n-                        );\n-                        in_pattern = true;\n+                if !seen_spans.contains(&move_span) {\n+                    if !closure {\n+                        self.suggest_ref_or_clone(mpi, move_span, &mut err, &mut in_pattern);\n                     }\n+\n+                    self.explain_captures(\n+                        &mut err,\n+                        span,\n+                        move_span,\n+                        move_spans,\n+                        *moved_place,\n+                        partially_str,\n+                        loop_message,\n+                        move_msg,\n+                        is_loop_move,\n+                        maybe_reinitialized_locations.is_empty(),\n+                    );\n                 }\n+                seen_spans.insert(move_span);\n             }\n \n             use_spans.var_path_only_subdiag(&mut err, desired_action);\n@@ -317,6 +306,160 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n+    fn suggest_ref_or_clone(\n+        &mut self,\n+        mpi: MovePathIndex,\n+        move_span: Span,\n+        err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n+        in_pattern: &mut bool,\n+    ) {\n+        struct ExpressionFinder<'hir> {\n+            expr_span: Span,\n+            expr: Option<&'hir hir::Expr<'hir>>,\n+            pat: Option<&'hir hir::Pat<'hir>>,\n+            parent_pat: Option<&'hir hir::Pat<'hir>>,\n+        }\n+        impl<'hir> Visitor<'hir> for ExpressionFinder<'hir> {\n+            fn visit_expr(&mut self, e: &'hir hir::Expr<'hir>) {\n+                if e.span == self.expr_span {\n+                    self.expr = Some(e);\n+                }\n+                hir::intravisit::walk_expr(self, e);\n+            }\n+            fn visit_pat(&mut self, p: &'hir hir::Pat<'hir>) {\n+                if p.span == self.expr_span {\n+                    self.pat = Some(p);\n+                }\n+                if let hir::PatKind::Binding(hir::BindingAnnotation::NONE, _, i, sub) = p.kind {\n+                    if i.span == self.expr_span || p.span == self.expr_span {\n+                        self.pat = Some(p);\n+                    }\n+                    // Check if we are in a situation of `ident @ ident` where we want to suggest\n+                    // `ref ident @ ref ident` or `ref ident @ Struct { ref ident }`.\n+                    if let Some(subpat) = sub && self.pat.is_none() {\n+                        self.visit_pat(subpat);\n+                        if self.pat.is_some() {\n+                            self.parent_pat = Some(p);\n+                        }\n+                        return;\n+                    }\n+                }\n+                hir::intravisit::walk_pat(self, p);\n+            }\n+        }\n+        let hir = self.infcx.tcx.hir();\n+        if let Some(hir::Node::Item(hir::Item {\n+            kind: hir::ItemKind::Fn(_, _, body_id),\n+            ..\n+        })) = hir.find(hir.local_def_id_to_hir_id(self.mir_def_id()))\n+            && let Some(hir::Node::Expr(expr)) = hir.find(body_id.hir_id)\n+        {\n+            let place = &self.move_data.move_paths[mpi].place;\n+            let span = place.as_local()\n+                .map(|local| self.body.local_decls[local].source_info.span);\n+            let mut finder = ExpressionFinder {\n+                expr_span: move_span,\n+                expr: None,\n+                pat: None,\n+                parent_pat: None,\n+            };\n+            finder.visit_expr(expr);\n+            if let Some(span) = span && let Some(expr) = finder.expr {\n+                for (_, expr) in hir.parent_iter(expr.hir_id) {\n+                    if let hir::Node::Expr(expr) = expr {\n+                        if expr.span.contains(span) {\n+                            // If the let binding occurs within the same loop, then that\n+                            // loop isn't relevant, like in the following, the outermost `loop`\n+                            // doesn't play into `x` being moved.\n+                            // ```\n+                            // loop {\n+                            //     let x = String::new();\n+                            //     loop {\n+                            //         foo(x);\n+                            //     }\n+                            // }\n+                            // ```\n+                            break;\n+                        }\n+                        if let hir::ExprKind::Loop(.., loop_span) = expr.kind {\n+                            err.span_label(loop_span, \"inside of this loop\");\n+                        }\n+                    }\n+                }\n+                let typeck = self.infcx.tcx.typeck(self.mir_def_id());\n+                let hir_id = hir.get_parent_node(expr.hir_id);\n+                if let Some(parent) = hir.find(hir_id) {\n+                    let (def_id, args, offset) = if let hir::Node::Expr(parent_expr) = parent\n+                        && let hir::ExprKind::MethodCall(_, _, args, _) = parent_expr.kind\n+                        && let Some(def_id) = typeck.type_dependent_def_id(parent_expr.hir_id)\n+                    {\n+                        (def_id.as_local(), args, 1)\n+                    } else if let hir::Node::Expr(parent_expr) = parent\n+                        && let hir::ExprKind::Call(call, args) = parent_expr.kind\n+                        && let ty::FnDef(def_id, _) = typeck.node_type(call.hir_id).kind()\n+                    {\n+                        (def_id.as_local(), args, 0)\n+                    } else {\n+                        (None, &[][..], 0)\n+                    };\n+                    if let Some(def_id) = def_id\n+                        && let Some(node) = hir.find(hir.local_def_id_to_hir_id(def_id))\n+                        && let Some(fn_sig) = node.fn_sig()\n+                        && let Some(ident) = node.ident()\n+                        && let Some(pos) = args.iter().position(|arg| arg.hir_id == expr.hir_id)\n+                        && let Some(arg) = fn_sig.decl.inputs.get(pos + offset)\n+                    {\n+                        let mut span: MultiSpan = arg.span.into();\n+                        span.push_span_label(\n+                            arg.span,\n+                            \"this parameter takes ownership of the value\".to_string(),\n+                        );\n+                        let descr = match node.fn_kind() {\n+                            Some(hir::intravisit::FnKind::ItemFn(..)) | None => \"function\",\n+                            Some(hir::intravisit::FnKind::Method(..)) => \"method\",\n+                            Some(hir::intravisit::FnKind::Closure) => \"closure\",\n+                        };\n+                        span.push_span_label(\n+                            ident.span,\n+                            format!(\"in this {descr}\"),\n+                        );\n+                        err.span_note(\n+                            span,\n+                            format!(\n+                                \"consider changing this parameter type in {descr} `{ident}` to \\\n+                                 borrow instead if owning the value isn't necessary\",\n+                            ),\n+                        );\n+                    }\n+                    let place = &self.move_data.move_paths[mpi].place;\n+                    let ty = place.ty(self.body, self.infcx.tcx).ty;\n+                    if let hir::Node::Expr(parent_expr) = parent\n+                        && let hir::ExprKind::Call(call_expr, _) = parent_expr.kind\n+                        && let hir::ExprKind::Path(\n+                            hir::QPath::LangItem(LangItem::IntoIterIntoIter, _, _)\n+                        ) = call_expr.kind\n+                    {\n+                        // Do not suggest `.clone()` in a `for` loop, we already suggest borrowing.\n+                    } else {\n+                        self.suggest_cloning(err, ty, move_span);\n+                    }\n+                }\n+            }\n+            if let Some(pat) = finder.pat {\n+                *in_pattern = true;\n+                let mut sugg = vec![(pat.span.shrink_to_lo(), \"ref \".to_string())];\n+                if let Some(pat) = finder.parent_pat {\n+                    sugg.insert(0, (pat.span.shrink_to_lo(), \"ref \".to_string()));\n+                }\n+                err.multipart_suggestion_verbose(\n+                    \"borrow this binding in the pattern to avoid moving the value\",\n+                    sugg,\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+    }\n+\n     fn report_use_of_uninitialized(\n         &self,\n         mpi: MovePathIndex,\n@@ -489,12 +632,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             // but the type has region variables, so erase those.\n             tcx.infer_ctxt()\n                 .build()\n-                .type_implements_trait(\n-                    default_trait,\n-                    tcx.erase_regions(ty),\n-                    ty::List::empty(),\n-                    param_env,\n-                )\n+                .type_implements_trait(default_trait, [tcx.erase_regions(ty)], param_env)\n                 .must_apply_modulo_regions()\n         };\n \n@@ -528,15 +666,17 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let tcx = self.infcx.tcx;\n \n         // Find out if the predicates show that the type is a Fn or FnMut\n-        let find_fn_kind_from_did =\n-            |predicates: ty::EarlyBinder<&[(ty::Predicate<'tcx>, Span)]>, substs| {\n-                predicates.0.iter().find_map(|(pred, _)| {\n+        let find_fn_kind_from_did = |predicates: ty::EarlyBinder<\n+            &[(ty::Predicate<'tcx>, Span)],\n+        >,\n+                                     substs| {\n+            predicates.0.iter().find_map(|(pred, _)| {\n                     let pred = if let Some(substs) = substs {\n                         predicates.rebind(*pred).subst(tcx, substs).kind().skip_binder()\n                     } else {\n                         pred.kind().skip_binder()\n                     };\n-                    if let ty::PredicateKind::Trait(pred) = pred && pred.self_ty() == ty {\n+                    if let ty::PredicateKind::Clause(ty::Clause::Trait(pred)) = pred && pred.self_ty() == ty {\n                     if Some(pred.def_id()) == tcx.lang_items().fn_trait() {\n                         return Some(hir::Mutability::Not);\n                     } else if Some(pred.def_id()) == tcx.lang_items().fn_mut_trait() {\n@@ -545,7 +685,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n                     None\n                 })\n-            };\n+        };\n \n         // If the type is opaque/param/closure, and it is Fn or FnMut, let's suggest (mutably)\n         // borrowing the type, since `&mut F: FnMut` iff `F: FnMut` and similarly for `Fn`.\n@@ -576,25 +716,39 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let moved_place = &self.move_data.move_paths[move_out.path].place;\n                 let move_spans = self.move_spans(moved_place.as_ref(), move_out.source);\n                 let move_span = move_spans.args_or_use();\n-                let suggestion = if borrow_level == hir::Mutability::Mut {\n-                    \"&mut \".to_string()\n-                } else {\n-                    \"&\".to_string()\n-                };\n+                let suggestion = borrow_level.ref_prefix_str().to_owned();\n                 (move_span.shrink_to_lo(), suggestion)\n             })\n             .collect();\n         err.multipart_suggestion_verbose(\n-            &format!(\n-                \"consider {}borrowing {value_name}\",\n-                if borrow_level == hir::Mutability::Mut { \"mutably \" } else { \"\" }\n-            ),\n+            format!(\"consider {}borrowing {value_name}\", borrow_level.mutably_str()),\n             sugg,\n             Applicability::MaybeIncorrect,\n         );\n         true\n     }\n \n+    fn suggest_cloning(&self, err: &mut Diagnostic, ty: Ty<'tcx>, span: Span) {\n+        let tcx = self.infcx.tcx;\n+        // Try to find predicates on *generic params* that would allow copying `ty`\n+        let infcx = tcx.infer_ctxt().build();\n+        if infcx\n+            .type_implements_trait(\n+                tcx.lang_items().clone_trait().unwrap(),\n+                [tcx.erase_regions(ty)],\n+                self.param_env,\n+            )\n+            .must_apply_modulo_regions()\n+        {\n+            err.span_suggestion_verbose(\n+                span.shrink_to_hi(),\n+                \"consider cloning the value if the performance cost is acceptable\",\n+                \".clone()\".to_string(),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+\n     fn suggest_adding_copy_bounds(&self, err: &mut Diagnostic, ty: Ty<'tcx>, span: Span) {\n         let tcx = self.infcx.tcx;\n         let generics = tcx.generics_of(self.mir_def_id());\n@@ -606,7 +760,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         else { return; };\n         // Try to find predicates on *generic params* that would allow copying `ty`\n         let infcx = tcx.infer_ctxt().build();\n-        let copy_did = infcx.tcx.lang_items().copy_trait().unwrap();\n+        let copy_did = infcx.tcx.require_lang_item(LangItem::Copy, Some(span));\n         let cause = ObligationCause::new(\n             span,\n             self.mir_hir_id(),\n@@ -625,13 +779,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let predicates: Result<Vec<_>, _> = errors\n             .into_iter()\n             .map(|err| match err.obligation.predicate.kind().skip_binder() {\n-                PredicateKind::Trait(predicate) => match predicate.self_ty().kind() {\n-                    ty::Param(param_ty) => Ok((\n-                        generics.type_param(param_ty, tcx),\n-                        predicate.trait_ref.print_only_trait_path().to_string(),\n-                    )),\n-                    _ => Err(()),\n-                },\n+                PredicateKind::Clause(ty::Clause::Trait(predicate)) => {\n+                    match predicate.self_ty().kind() {\n+                        ty::Param(param_ty) => Ok((\n+                            generics.type_param(param_ty, tcx),\n+                            predicate.trait_ref.print_only_trait_path().to_string(),\n+                        )),\n+                        _ => Err(()),\n+                    }\n+                }\n                 _ => Err(()),\n             })\n             .collect();\n@@ -1707,7 +1863,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             err.span_label(borrow_span, note);\n \n             let tcx = self.infcx.tcx;\n-            let ty_params = ty::List::empty();\n \n             let return_ty = self.regioncx.universal_regions().unnormalized_output_ty;\n             let return_ty = tcx.erase_regions(return_ty);\n@@ -1716,7 +1871,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             if let Some(iter_trait) = tcx.get_diagnostic_item(sym::Iterator)\n                 && self\n                     .infcx\n-                    .type_implements_trait(iter_trait, return_ty, ty_params, self.param_env)\n+                    .type_implements_trait(iter_trait, [return_ty], self.param_env)\n                     .must_apply_modulo_regions()\n             {\n                 err.span_suggestion_hidden(\n@@ -2515,7 +2670,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             if let hir::TyKind::Rptr(lifetime, _) = &fn_decl.inputs[index].kind {\n                                 // With access to the lifetime, we can get\n                                 // the span of it.\n-                                arguments.push((*argument, lifetime.span));\n+                                arguments.push((*argument, lifetime.ident.span));\n                             } else {\n                                 bug!(\"ty type is a ref but hir type is not\");\n                             }\n@@ -2534,7 +2689,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let mut return_span = fn_decl.output.span();\n                 if let hir::FnRetTy::Return(ty) = &fn_decl.output {\n                     if let hir::TyKind::Rptr(lifetime, _) = ty.kind {\n-                        return_span = lifetime.span;\n+                        return_span = lifetime.ident.span;\n                     }\n                 }\n "}, {"sha": "c500cbc49e4a3700e69b7421976d8708867bfb93", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -70,7 +70,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         location: Location,\n         place: PlaceRef<'tcx>,\n         diag: &mut Diagnostic,\n-    ) {\n+    ) -> bool {\n         debug!(\"add_moved_or_invoked_closure_note: location={:?} place={:?}\", location, place);\n         let mut target = place.local_or_deref_local();\n         for stmt in &self.body[location.block].statements[location.statement_index..] {\n@@ -106,7 +106,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         {\n                             place.local_or_deref_local().unwrap()\n                         }\n-                        _ => return,\n+                        _ => return false,\n                     };\n \n                     debug!(\"add_moved_or_invoked_closure_note: closure={:?}\", closure);\n@@ -125,7 +125,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     ty::place_to_string_for_capture(self.infcx.tcx, hir_place)\n                                 ),\n                             );\n-                            return;\n+                            return true;\n                         }\n                     }\n                 }\n@@ -149,9 +149,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             ty::place_to_string_for_capture(self.infcx.tcx, hir_place)\n                         ),\n                     );\n+                    return true;\n                 }\n             }\n         }\n+        false\n     }\n \n     /// End-user visible description of `place` if one can be found.\n@@ -350,7 +352,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     } else {\n                         def.non_enum_variant()\n                     };\n-                    if !including_tuple_field.0 && variant.ctor_kind == CtorKind::Fn {\n+                    if !including_tuple_field.0 && variant.ctor_kind() == Some(CtorKind::Fn) {\n                         return None;\n                     }\n                     Some(variant.fields[field.index()].name.to_string())"}, {"sha": "0cf66e41001f84eff9a14acc0a0cb6cce9c0d47f", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -389,13 +389,13 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // diagnostic: if the span starts with a mutable borrow of\n             // a local variable, then just suggest the user remove it.\n             PlaceRef { local: _, projection: [] }\n-                if {\n-                    if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n-                        snippet.starts_with(\"&mut \")\n-                    } else {\n-                        false\n-                    }\n-                } =>\n+                if self\n+                    .infcx\n+                    .tcx\n+                    .sess\n+                    .source_map()\n+                    .span_to_snippet(span)\n+                    .map_or(false, |snippet| snippet.starts_with(\"&mut \")) =>\n             {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n                 err.span_suggestion(\n@@ -1211,7 +1211,7 @@ fn get_mut_span_in_struct_field<'tcx>(\n         && let hir::Node::Field(field) = node\n         && let hir::TyKind::Rptr(lt, hir::MutTy { mutbl: hir::Mutability::Not, ty }) = field.ty.kind\n     {\n-        return Some(lt.span.between(ty.span));\n+        return Some(lt.ident.span.between(ty.span));\n     }\n \n     None"}, {"sha": "534675f1dc042c5bab0df36fdba6fc4b860d2a9c", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -21,7 +21,7 @@ use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::Region;\n use rustc_middle::ty::TypeVisitor;\n use rustc_middle::ty::{self, RegionVid, Ty};\n-use rustc_span::symbol::{kw, sym, Ident};\n+use rustc_span::symbol::{kw, Ident};\n use rustc_span::Span;\n \n use crate::borrowck_errors;\n@@ -514,8 +514,11 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             span: *span,\n             ty_err: match output_ty.kind() {\n                 ty::Closure(_, _) => FnMutReturnTypeErr::ReturnClosure { span: *span },\n-                ty::Adt(def, _)\n-                    if self.infcx.tcx.is_diagnostic_item(sym::gen_future, def.did()) =>\n+                ty::Generator(def, ..)\n+                    if matches!(\n+                        self.infcx.tcx.generator_kind(def),\n+                        Some(hir::GeneratorKind::Async(_))\n+                    ) =>\n                 {\n                     FnMutReturnTypeErr::ReturnAsyncBlock { span: *span }\n                 }\n@@ -927,10 +930,14 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     // only when the block is a closure\n                     if let hir::ExprKind::Closure(hir::Closure {\n                         capture_clause: hir::CaptureBy::Ref,\n+                        body,\n                         ..\n                     }) = expr.kind\n                     {\n-                        closure_span = Some(expr.span.shrink_to_lo());\n+                        let body = map.body(*body);\n+                        if !matches!(body.generator_kind, Some(hir::GeneratorKind::Async(..))) {\n+                            closure_span = Some(expr.span.shrink_to_lo());\n+                        }\n                     }\n                 }\n             }"}, {"sha": "39173e70acfe93ccab8e84fe763c7555a36de5b6", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 6, "deletions": 26, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -576,30 +576,10 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         let args = last_segment.args.as_ref()?;\n         let lifetime =\n             self.try_match_adt_and_generic_args(substs, needle_fr, args, search_stack)?;\n-        match lifetime.name {\n-            hir::LifetimeName::Param(_, hir::ParamName::Plain(_) | hir::ParamName::Error)\n-            | hir::LifetimeName::Error\n-            | hir::LifetimeName::Static => {\n-                let lifetime_span = lifetime.span;\n-                Some(RegionNameHighlight::MatchedAdtAndSegment(lifetime_span))\n-            }\n-\n-            hir::LifetimeName::Param(_, hir::ParamName::Fresh)\n-            | hir::LifetimeName::ImplicitObjectLifetimeDefault\n-            | hir::LifetimeName::Infer => {\n-                // In this case, the user left off the lifetime; so\n-                // they wrote something like:\n-                //\n-                // ```\n-                // x: Foo<T>\n-                // ```\n-                //\n-                // where the fully elaborated form is `Foo<'_, '1,\n-                // T>`. We don't consider this a match; instead we let\n-                // the \"fully elaborated\" type fallback above handle\n-                // it.\n-                None\n-            }\n+        if lifetime.is_anonymous() {\n+            None\n+        } else {\n+            Some(RegionNameHighlight::MatchedAdtAndSegment(lifetime.ident.span))\n         }\n     }\n \n@@ -959,8 +939,8 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             {\n                 predicates.iter().any(|pred| {\n                     match pred.kind().skip_binder() {\n-                        ty::PredicateKind::Trait(data) if data.self_ty() == ty => {}\n-                        ty::PredicateKind::Projection(data) if data.projection_ty.self_ty() == ty => {}\n+                        ty::PredicateKind::Clause(ty::Clause::Trait(data)) if data.self_ty() == ty => {}\n+                        ty::PredicateKind::Clause(ty::Clause::Projection(data)) if data.projection_ty.self_ty() == ty => {}\n                         _ => return false,\n                     }\n                     tcx.any_free_region_meets(pred, |r| {"}, {"sha": "b5e00f471d26a0d266e021e330cfeb78f56fef1f", "filename": "compiler/rustc_borrowck/src/member_constraints.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -11,6 +11,7 @@ use std::ops::Index;\n \n /// Compactly stores a set of `R0 member of [R1...Rn]` constraints,\n /// indexed by the region `R0`.\n+#[derive(Debug)]\n pub(crate) struct MemberConstraintSet<'tcx, R>\n where\n     R: Copy + Eq,\n@@ -31,6 +32,7 @@ where\n }\n \n /// Represents a `R0 member of [R1..Rn]` constraint\n+#[derive(Debug)]\n pub(crate) struct NllMemberConstraint<'tcx> {\n     next_constraint: Option<NllMemberConstraintIndex>,\n "}, {"sha": "89ac0dfa4d6f51c2e61225b7d27b8fda4895bb57", "filename": "compiler/rustc_borrowck/src/places_conflict.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -320,16 +320,10 @@ fn place_projection_conflict<'tcx>(\n             debug!(\"place_element_conflict: DISJOINT-OR-EQ-DEREF\");\n             Overlap::EqualOrDisjoint\n         }\n-        (ProjectionElem::OpaqueCast(v1), ProjectionElem::OpaqueCast(v2)) => {\n-            if v1 == v2 {\n-                // same type - recur.\n-                debug!(\"place_element_conflict: DISJOINT-OR-EQ-OPAQUE\");\n-                Overlap::EqualOrDisjoint\n-            } else {\n-                // Different types. Disjoint!\n-                debug!(\"place_element_conflict: DISJOINT-OPAQUE\");\n-                Overlap::Disjoint\n-            }\n+        (ProjectionElem::OpaqueCast(_), ProjectionElem::OpaqueCast(_)) => {\n+            // casts to other types may always conflict irrespective of the type being cast to.\n+            debug!(\"place_element_conflict: DISJOINT-OR-EQ-OPAQUE\");\n+            Overlap::EqualOrDisjoint\n         }\n         (ProjectionElem::Field(f1, _), ProjectionElem::Field(f2, _)) => {\n             if f1 == f2 {"}, {"sha": "b35abbd107b9ce7e148603f91207a64c513e1f84", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -128,6 +128,7 @@ pub struct RegionInferenceContext<'tcx> {\n /// adds a new lower bound to the SCC it is analyzing: so you wind up\n /// with `'R: 'O` where `'R` is the pick-region and `'O` is the\n /// minimal viable option.\n+#[derive(Debug)]\n pub(crate) struct AppliedMemberConstraint {\n     /// The SCC that was affected. (The \"member region\".)\n     ///"}, {"sha": "d82d4cc39fb1c4f141dc435efccde1d029a69a15", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 37, "deletions": 11, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -1,4 +1,4 @@\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n use rustc_data_structures::vec_map::VecMap;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::OpaqueTyOrigin;\n@@ -61,17 +61,21 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         opaque_ty_decls: VecMap<OpaqueTypeKey<'tcx>, (OpaqueHiddenType<'tcx>, OpaqueTyOrigin)>,\n     ) -> VecMap<LocalDefId, OpaqueHiddenType<'tcx>> {\n         let mut result: VecMap<LocalDefId, OpaqueHiddenType<'tcx>> = VecMap::new();\n+\n+        let member_constraints: FxHashMap<_, _> = self\n+            .member_constraints\n+            .all_indices()\n+            .map(|ci| (self.member_constraints[ci].key, ci))\n+            .collect();\n+        debug!(?member_constraints);\n+\n         for (opaque_type_key, (concrete_type, origin)) in opaque_ty_decls {\n             let substs = opaque_type_key.substs;\n             debug!(?concrete_type, ?substs);\n \n             let mut subst_regions = vec![self.universal_regions.fr_static];\n-            let universal_substs = infcx.tcx.fold_regions(substs, |region, _| {\n-                if let ty::RePlaceholder(..) = region.kind() {\n-                    // Higher kinded regions don't need remapping, they don't refer to anything outside of this the substs.\n-                    return region;\n-                }\n-                let vid = self.to_region_vid(region);\n+\n+            let to_universal_region = |vid, subst_regions: &mut Vec<_>| {\n                 trace!(?vid);\n                 let scc = self.constraint_sccs.scc(vid);\n                 trace!(?scc);\n@@ -92,10 +96,33 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         infcx.tcx.lifetimes.re_static\n                     }\n                 }\n+            };\n+\n+            // Start by inserting universal regions from the member_constraint choice regions.\n+            // This will ensure they get precedence when folding the regions in the concrete type.\n+            if let Some(&ci) = member_constraints.get(&opaque_type_key) {\n+                for &vid in self.member_constraints.choice_regions(ci) {\n+                    to_universal_region(vid, &mut subst_regions);\n+                }\n+            }\n+            debug!(?subst_regions);\n+\n+            // Next, insert universal regions from substs, so we can translate regions that appear\n+            // in them but are not subject to member constraints, for instance closure substs.\n+            let universal_substs = infcx.tcx.fold_regions(substs, |region, _| {\n+                if let ty::RePlaceholder(..) = region.kind() {\n+                    // Higher kinded regions don't need remapping, they don't refer to anything outside of this the substs.\n+                    return region;\n+                }\n+                let vid = self.to_region_vid(region);\n+                to_universal_region(vid, &mut subst_regions)\n             });\n+            debug!(?universal_substs);\n+            debug!(?subst_regions);\n \n-            subst_regions.sort();\n-            subst_regions.dedup();\n+            // Deduplicate the set of regions while keeping the chosen order.\n+            let subst_regions = subst_regions.into_iter().collect::<FxIndexSet<_>>();\n+            debug!(?subst_regions);\n \n             let universal_concrete_type =\n                 infcx.tcx.fold_regions(concrete_type, |region, _| match *region {\n@@ -106,8 +133,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         .unwrap_or(infcx.tcx.lifetimes.re_erased),\n                     _ => region,\n                 });\n-\n-            debug!(?universal_concrete_type, ?universal_substs);\n+            debug!(?universal_concrete_type);\n \n             let opaque_type_key =\n                 OpaqueTypeKey { def_id: opaque_type_key.def_id, substs: universal_substs };"}, {"sha": "1aad6738bba7a01b9081e14508b836bb324190d0", "filename": "compiler/rustc_borrowck/src/type_check/canonical.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -88,11 +88,11 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         category: ConstraintCategory<'tcx>,\n     ) {\n         self.prove_predicate(\n-            ty::Binder::dummy(ty::PredicateKind::Trait(ty::TraitPredicate {\n+            ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::Trait(ty::TraitPredicate {\n                 trait_ref,\n                 constness: ty::BoundConstness::NotConst,\n                 polarity: ty::ImplPolarity::Positive,\n-            })),\n+            }))),\n             locations,\n             category,\n         );"}, {"sha": "18e3cbbb86a0eace8d8cdd611012ed7b2b1d2041", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 13, "deletions": 33, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -547,10 +547,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n \n         if let PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) = context {\n             let tcx = self.tcx();\n-            let trait_ref = ty::TraitRef {\n-                def_id: tcx.require_lang_item(LangItem::Copy, Some(self.last_span)),\n-                substs: tcx.mk_substs_trait(place_ty.ty, &[]),\n-            };\n+            let trait_ref = tcx.at(self.last_span).mk_trait_ref(LangItem::Copy, [place_ty.ty]);\n \n             // To have a `Copy` operand, the type `T` of the\n             // value must be `Copy`. Note that we prove that `T: Copy`,\n@@ -1273,10 +1270,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n                 self.check_rvalue(body, rv, location);\n                 if !self.unsized_feature_enabled() {\n-                    let trait_ref = ty::TraitRef {\n-                        def_id: tcx.require_lang_item(LangItem::Sized, Some(self.last_span)),\n-                        substs: tcx.mk_substs_trait(place_ty, &[]),\n-                    };\n+                    let trait_ref =\n+                        tcx.at(self.last_span).mk_trait_ref(LangItem::Sized, [place_ty]);\n                     self.prove_trait_ref(\n                         trait_ref,\n                         location.to_locations(),\n@@ -1564,10 +1559,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 }\n             }\n             None => {\n-                if !self\n-                    .tcx()\n-                    .conservative_is_privately_uninhabited(self.param_env.and(sig.output()))\n-                {\n+                if !sig.output().is_privately_uninhabited(self.tcx(), self.param_env) {\n                     span_mirbug!(self, term, \"call to converging function {:?} w/o dest\", sig);\n                 }\n             }\n@@ -1843,6 +1835,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     #[instrument(skip(self, body), level = \"debug\")]\n     fn check_rvalue(&mut self, body: &Body<'tcx>, rvalue: &Rvalue<'tcx>, location: Location) {\n         let tcx = self.tcx();\n+        let span = body.source_info(location).span;\n \n         match rvalue {\n             Rvalue::Aggregate(ak, ops) => {\n@@ -1866,12 +1859,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         }\n                         Operand::Move(place) => {\n                             // Make sure that repeated elements implement `Copy`.\n-                            let span = body.source_info(location).span;\n                             let ty = place.ty(body, tcx).ty;\n-                            let trait_ref = ty::TraitRef::new(\n-                                tcx.require_lang_item(LangItem::Copy, Some(span)),\n-                                tcx.mk_substs_trait(ty, &[]),\n-                            );\n+                            let trait_ref = tcx.at(span).mk_trait_ref(LangItem::Copy, [ty]);\n \n                             self.prove_trait_ref(\n                                 trait_ref,\n@@ -1884,10 +1873,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             }\n \n             &Rvalue::NullaryOp(NullOp::SizeOf | NullOp::AlignOf, ty) => {\n-                let trait_ref = ty::TraitRef {\n-                    def_id: tcx.require_lang_item(LangItem::Sized, Some(self.last_span)),\n-                    substs: tcx.mk_substs_trait(ty, &[]),\n-                };\n+                let trait_ref = tcx.at(span).mk_trait_ref(LangItem::Sized, [ty]);\n \n                 self.prove_trait_ref(\n                     trait_ref,\n@@ -1899,10 +1885,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             Rvalue::ShallowInitBox(operand, ty) => {\n                 self.check_operand(operand, location);\n \n-                let trait_ref = ty::TraitRef {\n-                    def_id: tcx.require_lang_item(LangItem::Sized, Some(self.last_span)),\n-                    substs: tcx.mk_substs_trait(*ty, &[]),\n-                };\n+                let trait_ref = tcx.at(span).mk_trait_ref(LangItem::Sized, [*ty]);\n \n                 self.prove_trait_ref(\n                     trait_ref,\n@@ -1999,11 +1982,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n                     CastKind::Pointer(PointerCast::Unsize) => {\n                         let &ty = ty;\n-                        let trait_ref = ty::TraitRef {\n-                            def_id: tcx\n-                                .require_lang_item(LangItem::CoerceUnsized, Some(self.last_span)),\n-                            substs: tcx.mk_substs_trait(op.ty(body, tcx), &[ty.into()]),\n-                        };\n+                        let trait_ref = tcx\n+                            .at(span)\n+                            .mk_trait_ref(LangItem::CoerceUnsized, [op.ty(body, tcx), ty]);\n \n                         self.prove_trait_ref(\n                             trait_ref,\n@@ -2032,8 +2013,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         );\n \n                         let outlives_predicate =\n-                            tcx.mk_predicate(Binder::dummy(ty::PredicateKind::TypeOutlives(\n-                                ty::OutlivesPredicate(self_ty, *region),\n+                            tcx.mk_predicate(Binder::dummy(ty::PredicateKind::Clause(\n+                                ty::Clause::TypeOutlives(ty::OutlivesPredicate(self_ty, *region)),\n                             )));\n                         self.prove_predicate(\n                             outlives_predicate,\n@@ -2607,7 +2588,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             }\n \n             // For closures, we have some **extra requirements** we\n-            //\n             // have to check. In particular, in their upvars and\n             // signatures, closures often reference various regions\n             // from the surrounding function -- we call those the"}, {"sha": "b2702eafd33bd8cec66eca5c29241d2ea8417acd", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -2,9 +2,8 @@ use rustc_infer::infer::nll_relate::{NormalizationStrategy, TypeRelating, TypeRe\n use rustc_infer::infer::NllRegionVariableOrigin;\n use rustc_infer::traits::PredicateObligations;\n use rustc_middle::mir::ConstraintCategory;\n-use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::relate::TypeRelation;\n-use rustc_middle::ty::{self, Const, Ty};\n+use rustc_middle::ty::{self, Ty};\n use rustc_span::Span;\n use rustc_trait_selection::traits::query::Fallible;\n \n@@ -141,13 +140,6 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n         );\n     }\n \n-    // We don't have to worry about the equality of consts during borrow checking\n-    // as consts always have a static lifetime.\n-    // FIXME(oli-obk): is this really true? We can at least have HKL and with\n-    // inline consts we may have further lifetimes that may be unsound to treat as\n-    // 'static.\n-    fn const_equate(&mut self, _a: Const<'tcx>, _b: Const<'tcx>) {}\n-\n     fn normalization() -> NormalizationStrategy {\n         NormalizationStrategy::Eager\n     }\n@@ -156,10 +148,7 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n         true\n     }\n \n-    fn register_opaque_type_obligations(\n-        &mut self,\n-        obligations: PredicateObligations<'tcx>,\n-    ) -> Result<(), TypeError<'tcx>> {\n+    fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>) {\n         self.type_checker\n             .fully_perform_op(\n                 self.locations,\n@@ -172,6 +161,5 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n                 },\n             )\n             .unwrap();\n-        Ok(())\n     }\n }"}, {"sha": "900c4427424abc5be1b505c2eab34077c8facc72", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -564,7 +564,7 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, args: AsmArgs) -> Option<ast::Inl\n         let template_snippet = ecx.source_map().span_to_snippet(template_sp).ok();\n         template_strs.push((\n             template_str,\n-            template_snippet.as_ref().map(|s| Symbol::intern(s)),\n+            template_snippet.as_deref().map(Symbol::intern),\n             template_sp,\n         ));\n         let template_str = template_str.as_str();"}, {"sha": "8555c3593b3339f1d7a490d662de358d14b660e1", "filename": "compiler/rustc_builtin_macros/src/assert.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -4,7 +4,7 @@ use crate::edition_panic::use_panic_2021;\n use rustc_ast::ptr::P;\n use rustc_ast::token;\n use rustc_ast::tokenstream::{DelimSpan, TokenStream};\n-use rustc_ast::{Expr, ExprKind, MacArgs, MacCall, MacDelimiter, Path, PathSegment, UnOp};\n+use rustc_ast::{DelimArgs, Expr, ExprKind, MacCall, MacDelimiter, Path, PathSegment, UnOp};\n use rustc_ast_pretty::pprust;\n use rustc_errors::{Applicability, PResult};\n use rustc_expand::base::{DummyResult, ExtCtxt, MacEager, MacResult};\n@@ -54,11 +54,11 @@ pub fn expand_assert<'cx>(\n             call_site_span,\n             ExprKind::MacCall(P(MacCall {\n                 path: panic_path(),\n-                args: P(MacArgs::Delimited(\n-                    DelimSpan::from_single(call_site_span),\n-                    MacDelimiter::Parenthesis,\n+                args: P(DelimArgs {\n+                    dspan: DelimSpan::from_single(call_site_span),\n+                    delim: MacDelimiter::Parenthesis,\n                     tokens,\n-                )),\n+                }),\n                 prior_type_ascription: None,\n             })),\n         );"}, {"sha": "9f42a0c2d585cdef4270de56762ab529b45dc6ac", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -3,7 +3,7 @@ use rustc_ast::{\n     ptr::P,\n     token,\n     tokenstream::{DelimSpan, TokenStream, TokenTree},\n-    BinOpKind, BorrowKind, Expr, ExprKind, ItemKind, MacArgs, MacCall, MacDelimiter, MethodCall,\n+    BinOpKind, BorrowKind, DelimArgs, Expr, ExprKind, ItemKind, MacCall, MacDelimiter, MethodCall,\n     Mutability, Path, PathSegment, Stmt, StructRest, UnOp, UseTree, UseTreeKind, DUMMY_NODE_ID,\n };\n use rustc_ast_pretty::pprust;\n@@ -181,11 +181,11 @@ impl<'cx, 'a> Context<'cx, 'a> {\n             self.span,\n             ExprKind::MacCall(P(MacCall {\n                 path: panic_path,\n-                args: P(MacArgs::Delimited(\n-                    DelimSpan::from_single(self.span),\n-                    MacDelimiter::Parenthesis,\n-                    initial.into_iter().chain(captures).collect::<TokenStream>(),\n-                )),\n+                args: P(DelimArgs {\n+                    dspan: DelimSpan::from_single(self.span),\n+                    delim: MacDelimiter::Parenthesis,\n+                    tokens: initial.into_iter().chain(captures).collect::<TokenStream>(),\n+                }),\n                 prior_type_ascription: None,\n             })),\n         )\n@@ -307,7 +307,7 @@ impl<'cx, 'a> Context<'cx, 'a> {\n             | ExprKind::InlineAsm(_)\n             | ExprKind::Let(_, _, _)\n             | ExprKind::Lit(_)\n-            | ExprKind::Loop(_, _)\n+            | ExprKind::Loop(_, _, _)\n             | ExprKind::MacCall(_)\n             | ExprKind::Match(_, _)\n             | ExprKind::Path(_, _)"}, {"sha": "3309fab224fb71112fac7cb5c37225f2ab26d5e8", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 24, "deletions": 70, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -448,7 +448,8 @@ impl<'a> TraitDef<'a> {\n                     _ => unreachable!(),\n                 };\n                 let container_id = cx.current_expansion.id.expn_data().parent.expect_local();\n-                let always_copy = has_no_type_params && cx.resolver.has_derive_copy(container_id);\n+                let copy_fields =\n+                    is_packed && has_no_type_params && cx.resolver.has_derive_copy(container_id);\n \n                 let newitem = match item.kind {\n                     ast::ItemKind::Struct(ref struct_def, ref generics) => self.expand_struct_def(\n@@ -457,16 +458,14 @@ impl<'a> TraitDef<'a> {\n                         item.ident,\n                         generics,\n                         from_scratch,\n-                        is_packed,\n-                        always_copy,\n+                        copy_fields,\n                     ),\n                     ast::ItemKind::Enum(ref enum_def, ref generics) => {\n-                        // We ignore `is_packed`/`always_copy` here, because\n-                        // `repr(packed)` enums cause an error later on.\n+                        // We ignore `is_packed` here, because `repr(packed)`\n+                        // enums cause an error later on.\n                         //\n                         // This can only cause further compilation errors\n-                        // downstream in blatantly illegal code, so it\n-                        // is fine.\n+                        // downstream in blatantly illegal code, so it is fine.\n                         self.expand_enum_def(cx, enum_def, item.ident, generics, from_scratch)\n                     }\n                     ast::ItemKind::Union(ref struct_def, ref generics) => {\n@@ -477,8 +476,7 @@ impl<'a> TraitDef<'a> {\n                                 item.ident,\n                                 generics,\n                                 from_scratch,\n-                                is_packed,\n-                                always_copy,\n+                                copy_fields,\n                             )\n                         } else {\n                             cx.span_err(mitem.span, \"this trait cannot be derived for unions\");\n@@ -748,8 +746,7 @@ impl<'a> TraitDef<'a> {\n         type_ident: Ident,\n         generics: &Generics,\n         from_scratch: bool,\n-        is_packed: bool,\n-        always_copy: bool,\n+        copy_fields: bool,\n     ) -> P<ast::Item> {\n         let field_tys: Vec<P<ast::Ty>> =\n             struct_def.fields().iter().map(|field| field.ty.clone()).collect();\n@@ -777,8 +774,7 @@ impl<'a> TraitDef<'a> {\n                         type_ident,\n                         &selflike_args,\n                         &nonselflike_args,\n-                        is_packed,\n-                        always_copy,\n+                        copy_fields,\n                     )\n                 };\n \n@@ -1016,19 +1012,9 @@ impl<'a> MethodDef<'a> {\n     ///     }\n     /// }\n     /// ```\n-    /// If the struct doesn't impl `Copy`, we use let-destructuring with `ref`:\n-    /// ```\n-    /// # struct A { x: u8, y: u8 }\n-    /// impl PartialEq for A {\n-    ///     fn eq(&self, other: &A) -> bool {\n-    ///         let Self { x: ref __self_0_0, y: ref __self_0_1 } = *self;\n-    ///         let Self { x: ref __self_1_0, y: ref __self_1_1 } = *other;\n-    ///         *__self_0_0 == *__self_1_0 && *__self_0_1 == *__self_1_1\n-    ///     }\n-    /// }\n-    /// ```\n-    /// This latter case only works if the fields match the alignment required\n-    /// by the `packed(N)` attribute. (We'll get errors later on if not.)\n+    /// If the struct doesn't impl `Copy`, we use the normal `&self.x`. This\n+    /// only works if the fields match the alignment required by the\n+    /// `packed(N)` attribute. (We'll get errors later on if not.)\n     fn expand_struct_method_body<'b>(\n         &self,\n         cx: &mut ExtCtxt<'_>,\n@@ -1037,51 +1023,19 @@ impl<'a> MethodDef<'a> {\n         type_ident: Ident,\n         selflike_args: &[P<Expr>],\n         nonselflike_args: &[P<Expr>],\n-        is_packed: bool,\n-        always_copy: bool,\n+        copy_fields: bool,\n     ) -> BlockOrExpr {\n-        let span = trait_.span;\n         assert!(selflike_args.len() == 1 || selflike_args.len() == 2);\n \n-        let mk_body = |cx, selflike_fields| {\n-            self.call_substructure_method(\n-                cx,\n-                trait_,\n-                type_ident,\n-                nonselflike_args,\n-                &Struct(struct_def, selflike_fields),\n-            )\n-        };\n-\n-        if !is_packed {\n-            let selflike_fields =\n-                trait_.create_struct_field_access_fields(cx, selflike_args, struct_def, false);\n-            mk_body(cx, selflike_fields)\n-        } else if always_copy {\n-            let selflike_fields =\n-                trait_.create_struct_field_access_fields(cx, selflike_args, struct_def, true);\n-            mk_body(cx, selflike_fields)\n-        } else {\n-            // Packed and not copy. Need to use ref patterns.\n-            let prefixes: Vec<_> =\n-                (0..selflike_args.len()).map(|i| format!(\"__self_{}\", i)).collect();\n-            let selflike_fields = trait_.create_struct_pattern_fields(cx, struct_def, &prefixes);\n-            let mut body = mk_body(cx, selflike_fields);\n-\n-            let struct_path = cx.path(span, vec![Ident::new(kw::SelfUpper, type_ident.span)]);\n-            let patterns =\n-                trait_.create_struct_patterns(cx, struct_path, struct_def, &prefixes, ByRef::Yes);\n-\n-            // Do the let-destructuring.\n-            let mut stmts: Vec<_> = iter::zip(selflike_args, patterns)\n-                .map(|(selflike_arg_expr, pat)| {\n-                    let selflike_arg_expr = cx.expr_deref(span, selflike_arg_expr.clone());\n-                    cx.stmt_let_pat(span, pat, selflike_arg_expr)\n-                })\n-                .collect();\n-            stmts.extend(std::mem::take(&mut body.0));\n-            BlockOrExpr(stmts, body.1)\n-        }\n+        let selflike_fields =\n+            trait_.create_struct_field_access_fields(cx, selflike_args, struct_def, copy_fields);\n+        self.call_substructure_method(\n+            cx,\n+            trait_,\n+            type_ident,\n+            nonselflike_args,\n+            &Struct(struct_def, selflike_fields),\n+        )\n     }\n \n     fn expand_static_struct_method_body(\n@@ -1531,7 +1485,7 @@ impl<'a> TraitDef<'a> {\n         cx: &mut ExtCtxt<'_>,\n         selflike_args: &[P<Expr>],\n         struct_def: &'a VariantData,\n-        copy: bool,\n+        copy_fields: bool,\n     ) -> Vec<FieldInfo> {\n         self.create_fields(struct_def, |i, struct_field, sp| {\n             selflike_args\n@@ -1550,7 +1504,7 @@ impl<'a> TraitDef<'a> {\n                             }),\n                         ),\n                     );\n-                    if copy {\n+                    if copy_fields {\n                         field_expr = cx.expr_block(\n                             cx.block(struct_field.span, vec![cx.stmt_expr(field_expr)]),\n                         );"}, {"sha": "cae648cd11aff98dd8275acddb908459ff14c4a5", "filename": "compiler/rustc_builtin_macros/src/edition_panic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_builtin_macros%2Fsrc%2Fedition_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_builtin_macros%2Fsrc%2Fedition_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fedition_panic.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -58,11 +58,11 @@ fn expand<'cx>(\n                         .collect(),\n                     tokens: None,\n                 },\n-                args: P(MacArgs::Delimited(\n-                    DelimSpan::from_single(sp),\n-                    MacDelimiter::Parenthesis,\n-                    tts,\n-                )),\n+                args: P(DelimArgs {\n+                    dspan: DelimSpan::from_single(sp),\n+                    delim: MacDelimiter::Parenthesis,\n+                    tokens: tts,\n+                }),\n                 prior_type_ascription: None,\n             })),\n         ),"}, {"sha": "df773910dbc8fd7313f2ada1d89495c4646d9366", "filename": "compiler/rustc_builtin_macros/src/format_foreign/printf/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign%2Fprintf%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign%2Fprintf%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign%2Fprintf%2Ftests.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -100,7 +100,7 @@ fn test_iter() {\n     let s = \"The %d'th word %% is: `%.*s` %!\\n\";\n     let subs: Vec<_> = iter_subs(s, 0).map(|sub| sub.translate().ok()).collect();\n     assert_eq!(\n-        subs.iter().map(|ms| ms.as_ref().map(|s| &s[..])).collect::<Vec<_>>(),\n+        subs.iter().map(Option::as_deref).collect::<Vec<_>>(),\n         vec![Some(\"{}\"), None, Some(\"{:.*}\"), None]\n     );\n }"}, {"sha": "93a7afcd6e8b620fff102430c03c455ae8d5b490", "filename": "compiler/rustc_builtin_macros/src/format_foreign/shell/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign%2Fshell%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign%2Fshell%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign%2Fshell%2Ftests.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -39,7 +39,7 @@ fn test_iter() {\n     let s = \"The $0'th word $$ is: `$WORD` $!\\n\";\n     let subs: Vec<_> = iter_subs(s, 0).map(|sub| sub.translate().ok()).collect();\n     assert_eq!(\n-        subs.iter().map(|ms| ms.as_ref().map(|s| &s[..])).collect::<Vec<_>>(),\n+        subs.iter().map(Option::as_deref).collect::<Vec<_>>(),\n         vec![Some(\"{0}\"), None, Some(\"{WORD}\")]\n     );\n }"}, {"sha": "c627af4e62fe14073bc539d195cb5623afd7dabe", "filename": "compiler/rustc_codegen_cranelift/build_system/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Futils.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -104,5 +104,5 @@ pub(crate) fn copy_dir_recursively(from: &Path, to: &Path) {\n }\n \n pub(crate) fn is_ci() -> bool {\n-    env::var(\"CI\").as_ref().map(|val| &**val) == Ok(\"true\")\n+    env::var(\"CI\").as_deref() == Ok(\"true\")\n }"}, {"sha": "45522fb1a4cab422fc5713905fe8f45d23fb2b49", "filename": "compiler/rustc_codegen_cranelift/src/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconfig.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -2,7 +2,7 @@ use std::env;\n use std::str::FromStr;\n \n fn bool_env_var(key: &str) -> bool {\n-    env::var(key).as_ref().map(|val| &**val) == Ok(\"1\")\n+    env::var(key).as_deref() == Ok(\"1\")\n }\n \n /// The mode to use for compilation."}, {"sha": "a6bde88408497ed9d12a7cd28a82966d7fc52439", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 27, "deletions": 44, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -38,22 +38,8 @@ impl ConstantCx {\n pub(crate) fn check_constants(fx: &mut FunctionCx<'_, '_, '_>) -> bool {\n     let mut all_constants_ok = true;\n     for constant in &fx.mir.required_consts {\n-        let unevaluated = match fx.monomorphize(constant.literal) {\n-            ConstantKind::Ty(_) => unreachable!(),\n-            ConstantKind::Unevaluated(uv, _) => uv,\n-            ConstantKind::Val(..) => continue,\n-        };\n-\n-        if let Err(err) = fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), unevaluated, None) {\n+        if eval_mir_constant(fx, constant).is_none() {\n             all_constants_ok = false;\n-            match err {\n-                ErrorHandled::Reported(_) => {\n-                    fx.tcx.sess.span_err(constant.span, \"erroneous constant encountered\");\n-                }\n-                ErrorHandled::TooGeneric => {\n-                    span_bug!(constant.span, \"codegen encountered polymorphic constant: {:?}\", err);\n-                }\n-            }\n         }\n     }\n     all_constants_ok\n@@ -80,15 +66,15 @@ pub(crate) fn codegen_tls_ref<'tcx>(\n }\n \n pub(crate) fn eval_mir_constant<'tcx>(\n-    fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    fx: &FunctionCx<'_, '_, 'tcx>,\n     constant: &Constant<'tcx>,\n-) -> (ConstValue<'tcx>, Ty<'tcx>) {\n+) -> Option<(ConstValue<'tcx>, Ty<'tcx>)> {\n     let constant_kind = fx.monomorphize(constant.literal);\n     let uv = match constant_kind {\n         ConstantKind::Ty(const_) => match const_.kind() {\n             ty::ConstKind::Unevaluated(uv) => uv.expand(),\n             ty::ConstKind::Value(val) => {\n-                return (fx.tcx.valtree_to_const_val((const_.ty(), val)), const_.ty());\n+                return Some((fx.tcx.valtree_to_const_val((const_.ty(), val)), const_.ty()));\n             }\n             err => span_bug!(\n                 constant.span,\n@@ -102,22 +88,31 @@ pub(crate) fn eval_mir_constant<'tcx>(\n             span_bug!(constant.span, \"MIR constant refers to static\");\n         }\n         ConstantKind::Unevaluated(uv, _) => uv,\n-        ConstantKind::Val(val, _) => return (val, constant_kind.ty()),\n+        ConstantKind::Val(val, _) => return Some((val, constant_kind.ty())),\n     };\n \n-    (\n-        fx.tcx.const_eval_resolve(ty::ParamEnv::reveal_all(), uv, None).unwrap_or_else(|_err| {\n-            span_bug!(constant.span, \"erroneous constant not captured by required_consts\");\n-        }),\n-        constant_kind.ty(),\n-    )\n+    let val = fx\n+        .tcx\n+        .const_eval_resolve(ty::ParamEnv::reveal_all(), uv, None)\n+        .map_err(|err| match err {\n+            ErrorHandled::Reported(_) => {\n+                fx.tcx.sess.span_err(constant.span, \"erroneous constant encountered\");\n+            }\n+            ErrorHandled::TooGeneric => {\n+                span_bug!(constant.span, \"codegen encountered polymorphic constant: {:?}\", err);\n+            }\n+        })\n+        .ok();\n+    val.map(|val| (val, constant_kind.ty()))\n }\n \n pub(crate) fn codegen_constant_operand<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     constant: &Constant<'tcx>,\n ) -> CValue<'tcx> {\n-    let (const_val, ty) = eval_mir_constant(fx, constant);\n+    let (const_val, ty) = eval_mir_constant(fx, constant).unwrap_or_else(|| {\n+        span_bug!(constant.span, \"erroneous constant not captured by required_consts\")\n+    });\n \n     codegen_const_value(fx, const_val, ty)\n }\n@@ -262,9 +257,9 @@ pub(crate) fn data_id_for_alloc_id(\n     mutability: rustc_hir::Mutability,\n ) -> DataId {\n     cx.todo.push(TodoItem::Alloc(alloc_id));\n-    *cx.anon_allocs.entry(alloc_id).or_insert_with(|| {\n-        module.declare_anonymous_data(mutability == rustc_hir::Mutability::Mut, false).unwrap()\n-    })\n+    *cx.anon_allocs\n+        .entry(alloc_id)\n+        .or_insert_with(|| module.declare_anonymous_data(mutability.is_mut(), false).unwrap())\n }\n \n fn data_id_for_static(\n@@ -348,12 +343,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n                     }\n                 };\n                 let data_id = *cx.anon_allocs.entry(alloc_id).or_insert_with(|| {\n-                    module\n-                        .declare_anonymous_data(\n-                            alloc.inner().mutability == rustc_hir::Mutability::Mut,\n-                            false,\n-                        )\n-                        .unwrap()\n+                    module.declare_anonymous_data(alloc.inner().mutability.is_mut(), false).unwrap()\n                 });\n                 (data_id, alloc, None)\n             }\n@@ -453,20 +443,13 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n     assert!(cx.todo.is_empty(), \"{:?}\", cx.todo);\n }\n \n+/// Used only for intrinsic implementations that need a compile-time constant\n pub(crate) fn mir_operand_get_const_val<'tcx>(\n     fx: &FunctionCx<'_, '_, 'tcx>,\n     operand: &Operand<'tcx>,\n ) -> Option<ConstValue<'tcx>> {\n     match operand {\n-        Operand::Constant(const_) => match fx.monomorphize(const_.literal) {\n-            ConstantKind::Ty(const_) => Some(\n-                const_.eval_for_mir(fx.tcx, ParamEnv::reveal_all()).try_to_value(fx.tcx).unwrap(),\n-            ),\n-            ConstantKind::Val(val, _) => Some(val),\n-            ConstantKind::Unevaluated(uv, _) => {\n-                Some(fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), uv, None).unwrap())\n-            }\n-        },\n+        Operand::Constant(const_) => Some(eval_mir_constant(fx, const_).unwrap().0),\n         // FIXME(rust-lang/rust#85105): Casts like `IMM8 as u32` result in the const being stored\n         // inside a temporary before being passed to the intrinsic requiring the const argument.\n         // This code tries to find a single constant defining definition of the referenced local."}, {"sha": "70ff5c9617b7a8c7c3ecdf008467d18eb924fb0d", "filename": "compiler/rustc_codegen_llvm/src/callee.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -83,7 +83,20 @@ pub fn get_fn<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>) ->\n         let llfn = if tcx.sess.target.arch == \"x86\" &&\n             let Some(dllimport) = common::get_dllimport(tcx, instance_def_id, sym)\n         {\n-            cx.declare_fn(&common::i686_decorated_name(&dllimport, common::is_mingw_gnu_toolchain(&tcx.sess.target), true), fn_abi)\n+            // Fix for https://github.com/rust-lang/rust/issues/104453\n+            // On x86 Windows, LLVM uses 'L' as the prefix for any private\n+            // global symbols, so when we create an undecorated function symbol\n+            // that begins with an 'L' LLVM misinterprets that as a private\n+            // global symbol that it created and so fails the compilation at a\n+            // later stage since such a symbol must have a definition.\n+            //\n+            // To avoid this, we set the Storage Class to \"DllImport\" so that\n+            // LLVM will prefix the name with `__imp_`. Ideally, we'd like the\n+            // existing logic below to set the Storage Class, but it has an\n+            // exemption for MinGW for backwards compatability.\n+            let llfn = cx.declare_fn(&common::i686_decorated_name(&dllimport, common::is_mingw_gnu_toolchain(&tcx.sess.target), true), fn_abi);\n+            unsafe { llvm::LLVMSetDLLStorageClass(llfn, llvm::DLLStorageClass::DllImport); }\n+            llfn\n         } else {\n             cx.declare_fn(sym, fn_abi)\n         };"}, {"sha": "86580d05d4166a357c767ff8c281bf58887695cf", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -174,7 +174,7 @@ impl CoverageMapGenerator {\n         counter_regions.sort_unstable_by_key(|(_counter, region)| *region);\n         for (counter, region) in counter_regions {\n             let CodeRegion { file_name, start_line, start_col, end_line, end_col } = *region;\n-            let same_file = current_file_name.as_ref().map_or(false, |p| *p == file_name);\n+            let same_file = current_file_name.map_or(false, |p| p == file_name);\n             if !same_file {\n                 if current_file_name.is_some() {\n                     current_file_id += 1;"}, {"sha": "d87117dffdc60b41c33f6fc778a11ae719561864", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -998,7 +998,7 @@ fn build_struct_type_di_node<'ll, 'tcx>(\n                 .iter()\n                 .enumerate()\n                 .map(|(i, f)| {\n-                    let field_name = if variant_def.ctor_kind == CtorKind::Fn {\n+                    let field_name = if variant_def.ctor_kind() == Some(CtorKind::Fn) {\n                         // This is a tuple struct\n                         tuple_field_name(i)\n                     } else {"}, {"sha": "53e8a291d1e8aa4d9a4cd90530b27ed0ad04edfa", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/cpp_like.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -462,7 +462,7 @@ fn build_variant_names_type_di_node<'ll, 'tcx>(\n         cx,\n         \"VariantNames\",\n         variant_names_enum_base_type(cx),\n-        variants.map(|(variant_index, variant_name)| (variant_name, variant_index.as_u32() as u64)),\n+        variants.map(|(variant_index, variant_name)| (variant_name, variant_index.as_u32().into())),\n         containing_scope,\n     )\n }"}, {"sha": "564ab351bd41ffbd0d55ebc3e57f2072d1cda594", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/mod.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -91,9 +91,7 @@ fn build_c_style_enum_di_node<'ll, 'tcx>(\n             tag_base_type(cx, enum_type_and_layout),\n             enum_adt_def.discriminants(cx.tcx).map(|(variant_index, discr)| {\n                 let name = Cow::from(enum_adt_def.variant(variant_index).name.as_str());\n-                // Is there anything we can do to support 128-bit C-Style enums?\n-                let value = discr.val as u64;\n-                (name, value)\n+                (name, discr.val)\n             }),\n             containing_scope,\n         ),\n@@ -147,36 +145,34 @@ fn tag_base_type<'ll, 'tcx>(\n /// This is a helper function and does not register anything in the type map by itself.\n ///\n /// `variants` is an iterator of (discr-value, variant-name).\n-///\n-// NOTE: Handling of discriminant values is somewhat inconsistent. They can appear as u128,\n-//       u64, and i64. Here everything gets mapped to i64 because that's what LLVM's API expects.\n fn build_enumeration_type_di_node<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     type_name: &str,\n     base_type: Ty<'tcx>,\n-    enumerators: impl Iterator<Item = (Cow<'tcx, str>, u64)>,\n+    enumerators: impl Iterator<Item = (Cow<'tcx, str>, u128)>,\n     containing_scope: &'ll DIType,\n ) -> &'ll DIType {\n     let is_unsigned = match base_type.kind() {\n         ty::Int(_) => false,\n         ty::Uint(_) => true,\n         _ => bug!(\"build_enumeration_type_di_node() called with non-integer tag type.\"),\n     };\n+    let (size, align) = cx.size_and_align_of(base_type);\n \n     let enumerator_di_nodes: SmallVec<Option<&'ll DIType>> = enumerators\n         .map(|(name, value)| unsafe {\n+            let value = [value as u64, (value >> 64) as u64];\n             Some(llvm::LLVMRustDIBuilderCreateEnumerator(\n                 DIB(cx),\n                 name.as_ptr().cast(),\n                 name.len(),\n-                value as i64,\n+                value.as_ptr(),\n+                size.bits() as libc::c_uint,\n                 is_unsigned,\n             ))\n         })\n         .collect();\n \n-    let (size, align) = cx.size_and_align_of(base_type);\n-\n     unsafe {\n         llvm::LLVMRustDIBuilderCreateEnumerationType(\n             DIB(cx),\n@@ -273,7 +269,7 @@ fn build_enum_variant_struct_type_di_node<'ll, 'tcx>(\n         |cx, struct_type_di_node| {\n             (0..variant_layout.fields.count())\n                 .map(|field_index| {\n-                    let field_name = if variant_def.ctor_kind != CtorKind::Fn {\n+                    let field_name = if variant_def.ctor_kind() != Some(CtorKind::Fn) {\n                         // Fields have names\n                         Cow::from(variant_def.fields[field_index].name.as_str())\n                     } else {"}, {"sha": "2f5dd519b2600af5113b40afb83fb0c6ac04d376", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -1500,7 +1500,7 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n         let (_, element_ty1) = arg_tys[1].simd_size_and_type(bx.tcx());\n         let (_, element_ty2) = arg_tys[2].simd_size_and_type(bx.tcx());\n         let (pointer_count, underlying_ty) = match element_ty1.kind() {\n-            ty::RawPtr(p) if p.ty == in_elem && p.mutbl == hir::Mutability::Mut => {\n+            ty::RawPtr(p) if p.ty == in_elem && p.mutbl.is_mut() => {\n                 (ptr_count(element_ty1), non_ptr(element_ty1))\n             }\n             _ => {"}, {"sha": "f451984973048f0501ded0c2084bd1b98d7e5992", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -2127,7 +2127,8 @@ extern \"C\" {\n         Builder: &DIBuilder<'a>,\n         Name: *const c_char,\n         NameLen: size_t,\n-        Value: i64,\n+        Value: *const u64,\n+        SizeInBits: c_uint,\n         IsUnsigned: bool,\n     ) -> &'a DIEnumerator;\n "}, {"sha": "762430c6187216b8ff2b66ee8832eef2a9c921e4", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -676,17 +676,18 @@ fn link_dwarf_object<'a>(\n             thorin::MissingReferencedObjectBehaviour::Skip,\n         )?;\n \n-        let output = package.finish()?.write()?;\n-        let mut output_stream = BufWriter::new(\n+        let output_stream = BufWriter::new(\n             OpenOptions::new()\n                 .read(true)\n                 .write(true)\n                 .create(true)\n                 .truncate(true)\n                 .open(dwp_out_filename)?,\n         );\n-        output_stream.write_all(&output)?;\n-        output_stream.flush()?;\n+        let mut output_stream = object::write::StreamingBuffer::new(output_stream);\n+        package.finish()?.emit(&mut output_stream)?;\n+        output_stream.result()?;\n+        output_stream.into_inner().flush()?;\n \n         Ok(())\n     }) {"}, {"sha": "03d833fbba87cf4afbc49318c9fa55b52d8a57e3", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -938,7 +938,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         // that is understood elsewhere in the compiler as a method on\n                         // `dyn Trait`.\n                         // To get a `*mut RcBox<Self>`, we just keep unwrapping newtypes until\n-                        // we get a value of a built-in pointer type\n+                        // we get a value of a built-in pointer type.\n+                        //\n+                        // This is also relevant for `Pin<&mut Self>`, where we need to peel the `Pin`.\n                         'descend_newtypes: while !op.layout.ty.is_unsafe_ptr()\n                             && !op.layout.ty.is_region_ptr()\n                         {\n@@ -980,13 +982,29 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         continue;\n                     }\n                     Immediate(_) => {\n-                        let ty::Ref(_, ty, _) = op.layout.ty.kind() else {\n-                            span_bug!(span, \"can't codegen a virtual call on {:#?}\", op);\n-                        };\n-                        if !ty.is_dyn_star() {\n+                        // See comment above explaining why we peel these newtypes\n+                        'descend_newtypes: while !op.layout.ty.is_unsafe_ptr()\n+                            && !op.layout.ty.is_region_ptr()\n+                        {\n+                            for i in 0..op.layout.fields.count() {\n+                                let field = op.extract_field(bx, i);\n+                                if !field.layout.is_zst() {\n+                                    // we found the one non-zero-sized field that is allowed\n+                                    // now find *its* non-zero-sized field, or stop if it's a\n+                                    // pointer\n+                                    op = field;\n+                                    continue 'descend_newtypes;\n+                                }\n+                            }\n+\n+                            span_bug!(span, \"receiver has no non-zero-sized fields {:?}\", op);\n+                        }\n+\n+                        // Make sure that we've actually unwrapped the rcvr down\n+                        // to a pointer or ref to `dyn* Trait`.\n+                        if !op.layout.ty.builtin_deref(true).unwrap().ty.is_dyn_star() {\n                             span_bug!(span, \"can't codegen a virtual call on {:#?}\", op);\n                         }\n-                        // FIXME(dyn-star): Make sure this is done on a &dyn* receiver\n                         let place = op.deref(bx.cx());\n                         let data_ptr = place.project_field(bx, 0);\n                         let meta_ptr = place.project_field(bx, 1);"}, {"sha": "53ff3c24096262207ff95b19e35f1142ca2b2c71", "filename": "compiler/rustc_codegen_ssa/src/mir/constant.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -42,7 +42,14 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         };\n \n         self.cx.tcx().const_eval_resolve(ty::ParamEnv::reveal_all(), uv, None).map_err(|err| {\n-            self.cx.tcx().sess.span_err(constant.span, \"erroneous constant encountered\");\n+            match err {\n+                ErrorHandled::Reported(_) => {\n+                    self.cx.tcx().sess.span_err(constant.span, \"erroneous constant encountered\");\n+                }\n+                ErrorHandled::TooGeneric => {\n+                    span_bug!(constant.span, \"codegen encountered polymorphic constant: {:?}\", err);\n+                }\n+            }\n             err\n         })\n     }"}, {"sha": "301683e8e85449370652ce4825c666715b488e8d", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -215,6 +215,7 @@ const HEXAGON_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n const POWERPC_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     // tidy-alphabetical-start\n     (\"altivec\", Some(sym::powerpc_target_feature)),\n+    (\"power10-vector\", Some(sym::powerpc_target_feature)),\n     (\"power8-altivec\", Some(sym::powerpc_target_feature)),\n     (\"power8-vector\", Some(sym::powerpc_target_feature)),\n     (\"power9-altivec\", Some(sym::powerpc_target_feature)),"}, {"sha": "51489e2936068c8519ddae244ec0006912098e2e", "filename": "compiler/rustc_const_eval/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_const_eval%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_const_eval%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2FCargo.toml?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -7,6 +7,7 @@ edition = \"2021\"\n \n [dependencies]\n tracing = \"0.1\"\n+either = \"1\"\n rustc_apfloat = { path = \"../rustc_apfloat\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_attr = { path = \"../rustc_attr\" }"}, {"sha": "c777a840f3fb661cfd56c25a51b38d6d9c811606", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -1,10 +1,7 @@\n-use super::{CompileTimeEvalContext, CompileTimeInterpreter, ConstEvalErr};\n-use crate::interpret::eval_nullary_intrinsic;\n-use crate::interpret::{\n-    intern_const_alloc_recursive, Allocation, ConstAlloc, ConstValue, CtfeValidationMode, GlobalId,\n-    Immediate, InternKind, InterpCx, InterpError, InterpResult, MPlaceTy, MemoryKind, OpTy,\n-    RefTracking, StackPopCleanup,\n-};\n+use std::borrow::Cow;\n+use std::convert::TryInto;\n+\n+use either::{Left, Right};\n \n use rustc_hir::def::DefKind;\n use rustc_middle::mir;\n@@ -16,8 +13,14 @@ use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::source_map::Span;\n use rustc_target::abi::{self, Abi};\n-use std::borrow::Cow;\n-use std::convert::TryInto;\n+\n+use super::{CompileTimeEvalContext, CompileTimeInterpreter, ConstEvalErr};\n+use crate::interpret::eval_nullary_intrinsic;\n+use crate::interpret::{\n+    intern_const_alloc_recursive, Allocation, ConstAlloc, ConstValue, CtfeValidationMode, GlobalId,\n+    Immediate, InternKind, InterpCx, InterpError, InterpResult, MPlaceTy, MemoryKind, OpTy,\n+    RefTracking, StackPopCleanup,\n+};\n \n const NOTE_ON_UNDEFINED_BEHAVIOR_ERROR: &str = \"The rules on what exactly is undefined behavior aren't clear, \\\n      so this check might be overzealous. Please open an issue on the rustc \\\n@@ -135,14 +138,14 @@ pub(super) fn op_to_const<'tcx>(\n         _ => false,\n     };\n     let immediate = if try_as_immediate {\n-        Err(ecx.read_immediate(op).expect(\"normalization works on validated constants\"))\n+        Right(ecx.read_immediate(op).expect(\"normalization works on validated constants\"))\n     } else {\n         // It is guaranteed that any non-slice scalar pair is actually ByRef here.\n         // When we come back from raw const eval, we are always by-ref. The only way our op here is\n         // by-val is if we are in destructure_mir_constant, i.e., if this is (a field of) something that we\n         // \"tried to make immediate\" before. We wouldn't do that for non-slice scalar pairs or\n         // structs containing such.\n-        op.try_as_mplace()\n+        op.as_mplace_or_imm()\n     };\n \n     debug!(?immediate);\n@@ -168,9 +171,9 @@ pub(super) fn op_to_const<'tcx>(\n         }\n     };\n     match immediate {\n-        Ok(ref mplace) => to_const_value(mplace),\n+        Left(ref mplace) => to_const_value(mplace),\n         // see comment on `let try_as_immediate` above\n-        Err(imm) => match *imm {\n+        Right(imm) => match *imm {\n             _ if imm.layout.is_zst() => ConstValue::ZeroSized,\n             Immediate::Scalar(x) => ConstValue::Scalar(x),\n             Immediate::ScalarPair(a, b) => {"}, {"sha": "79450fccfc4d8567e377320463034e0ebef3f15d", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -2,6 +2,8 @@ use std::cell::Cell;\n use std::fmt;\n use std::mem;\n \n+use either::{Either, Left, Right};\n+\n use rustc_hir::{self as hir, def_id::DefId, definitions::DefPathData};\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir;\n@@ -121,13 +123,12 @@ pub struct Frame<'mir, 'tcx, Prov: Provenance = AllocId, Extra = ()> {\n     ////////////////////////////////////////////////////////////////////////////////\n     // Current position within the function\n     ////////////////////////////////////////////////////////////////////////////////\n-    /// If this is `Err`, we are not currently executing any particular statement in\n+    /// If this is `Right`, we are not currently executing any particular statement in\n     /// this frame (can happen e.g. during frame initialization, and during unwinding on\n     /// frames without cleanup code).\n-    /// We basically abuse `Result` as `Either`.\n     ///\n     /// Needs to be public because ConstProp does unspeakable things to it.\n-    pub loc: Result<mir::Location, Span>,\n+    pub loc: Either<mir::Location, Span>,\n }\n \n /// What we store about a frame in an interpreter backtrace.\n@@ -227,25 +228,24 @@ impl<'mir, 'tcx, Prov: Provenance> Frame<'mir, 'tcx, Prov> {\n impl<'mir, 'tcx, Prov: Provenance, Extra> Frame<'mir, 'tcx, Prov, Extra> {\n     /// Get the current location within the Frame.\n     ///\n-    /// If this is `Err`, we are not currently executing any particular statement in\n+    /// If this is `Left`, we are not currently executing any particular statement in\n     /// this frame (can happen e.g. during frame initialization, and during unwinding on\n     /// frames without cleanup code).\n-    /// We basically abuse `Result` as `Either`.\n     ///\n     /// Used by priroda.\n-    pub fn current_loc(&self) -> Result<mir::Location, Span> {\n+    pub fn current_loc(&self) -> Either<mir::Location, Span> {\n         self.loc\n     }\n \n     /// Return the `SourceInfo` of the current instruction.\n     pub fn current_source_info(&self) -> Option<&mir::SourceInfo> {\n-        self.loc.ok().map(|loc| self.body.source_info(loc))\n+        self.loc.left().map(|loc| self.body.source_info(loc))\n     }\n \n     pub fn current_span(&self) -> Span {\n         match self.loc {\n-            Ok(loc) => self.body.source_info(loc).span,\n-            Err(span) => span,\n+            Left(loc) => self.body.source_info(loc).span,\n+            Right(span) => span,\n         }\n     }\n }\n@@ -679,7 +679,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // first push a stack frame so we have access to the local substs\n         let pre_frame = Frame {\n             body,\n-            loc: Err(body.span), // Span used for errors caused during preamble.\n+            loc: Right(body.span), // Span used for errors caused during preamble.\n             return_to_block,\n             return_place: return_place.clone(),\n             // empty local array, we fill it in below, after we are inside the stack frame and\n@@ -713,7 +713,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // done\n         self.frame_mut().locals = locals;\n         M::after_stack_push(self)?;\n-        self.frame_mut().loc = Ok(mir::Location::START);\n+        self.frame_mut().loc = Left(mir::Location::START);\n \n         let span = info_span!(\"frame\", \"{}\", instance);\n         self.frame_mut().tracing_span.enter(span);\n@@ -724,7 +724,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Jump to the given block.\n     #[inline]\n     pub fn go_to_block(&mut self, target: mir::BasicBlock) {\n-        self.frame_mut().loc = Ok(mir::Location { block: target, statement_index: 0 });\n+        self.frame_mut().loc = Left(mir::Location { block: target, statement_index: 0 });\n     }\n \n     /// *Return* to the given `target` basic block.\n@@ -750,8 +750,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// unwinding, and doing so is UB.\n     pub fn unwind_to_block(&mut self, target: StackPopUnwind) -> InterpResult<'tcx> {\n         self.frame_mut().loc = match target {\n-            StackPopUnwind::Cleanup(block) => Ok(mir::Location { block, statement_index: 0 }),\n-            StackPopUnwind::Skip => Err(self.frame_mut().body.span),\n+            StackPopUnwind::Cleanup(block) => Left(mir::Location { block, statement_index: 0 }),\n+            StackPopUnwind::Skip => Right(self.frame_mut().body.span),\n             StackPopUnwind::NotAllowed => {\n                 throw_ub_format!(\"unwinding past a stack frame that does not allow unwinding\")\n             }\n@@ -783,8 +783,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         assert_eq!(\n             unwinding,\n             match self.frame().loc {\n-                Ok(loc) => self.body().basic_blocks[loc.block].is_cleanup,\n-                Err(_) => true,\n+                Left(loc) => self.body().basic_blocks[loc.block].is_cleanup,\n+                Right(_) => true,\n             }\n         );\n         if unwinding && self.frame_idx() == 0 {"}, {"sha": "7d94a22c43d71e467d3c8eeed2963ebc0dbcbff4", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -19,8 +19,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             debug!(\"find_closest_untracked_caller_location: checking frame {:?}\", frame.instance);\n \n             // Assert that the frame we look at is actually executing code currently\n-            // (`loc` is `Err` when we are unwinding and the frame does not require cleanup).\n-            let loc = frame.loc.unwrap();\n+            // (`loc` is `Right` when we are unwinding and the frame does not require cleanup).\n+            let loc = frame.loc.left().unwrap();\n \n             // This could be a non-`Call` terminator (such as `Drop`), or not a terminator at all\n             // (such as `box`). Use the normal span by default."}, {"sha": "221e359d24ab8d517a1d98ed60de780bdea9c468", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -1,6 +1,8 @@\n //! Functions concerning immediate values and operands, and reading from operands.\n //! All high-level functions to read from memory work on operands as sources.\n \n+use either::{Either, Left, Right};\n+\n use rustc_hir::def::Namespace;\n use rustc_middle::ty::layout::{LayoutOf, PrimitiveExt, TyAndLayout};\n use rustc_middle::ty::print::{FmtPrinter, PrettyPrinter};\n@@ -261,9 +263,9 @@ impl<'tcx, Prov: Provenance> OpTy<'tcx, Prov> {\n         layout: TyAndLayout<'tcx>,\n         cx: &impl HasDataLayout,\n     ) -> InterpResult<'tcx, Self> {\n-        match self.try_as_mplace() {\n-            Ok(mplace) => Ok(mplace.offset_with_meta(offset, meta, layout, cx)?.into()),\n-            Err(imm) => {\n+        match self.as_mplace_or_imm() {\n+            Left(mplace) => Ok(mplace.offset_with_meta(offset, meta, layout, cx)?.into()),\n+            Right(imm) => {\n                 assert!(\n                     matches!(*imm, Immediate::Uninit),\n                     \"Scalar/ScalarPair cannot be offset into\"\n@@ -353,25 +355,25 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     /// Try returning an immediate for the operand. If the layout does not permit loading this as an\n     /// immediate, return where in memory we can find the data.\n-    /// Note that for a given layout, this operation will either always fail or always\n-    /// succeed!  Whether it succeeds depends on whether the layout can be represented\n+    /// Note that for a given layout, this operation will either always return Left or Right!\n+    /// succeed!  Whether it returns Left depends on whether the layout can be represented\n     /// in an `Immediate`, not on which data is stored there currently.\n     ///\n     /// This is an internal function that should not usually be used; call `read_immediate` instead.\n     /// ConstProp needs it, though.\n     pub fn read_immediate_raw(\n         &self,\n         src: &OpTy<'tcx, M::Provenance>,\n-    ) -> InterpResult<'tcx, Result<ImmTy<'tcx, M::Provenance>, MPlaceTy<'tcx, M::Provenance>>> {\n-        Ok(match src.try_as_mplace() {\n-            Ok(ref mplace) => {\n+    ) -> InterpResult<'tcx, Either<MPlaceTy<'tcx, M::Provenance>, ImmTy<'tcx, M::Provenance>>> {\n+        Ok(match src.as_mplace_or_imm() {\n+            Left(ref mplace) => {\n                 if let Some(val) = self.read_immediate_from_mplace_raw(mplace)? {\n-                    Ok(val)\n+                    Right(val)\n                 } else {\n-                    Err(*mplace)\n+                    Left(*mplace)\n                 }\n             }\n-            Err(val) => Ok(val),\n+            Right(val) => Right(val),\n         })\n     }\n \n@@ -390,7 +392,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ) {\n             span_bug!(self.cur_span(), \"primitive read not possible for type: {:?}\", op.layout.ty);\n         }\n-        let imm = self.read_immediate_raw(op)?.unwrap();\n+        let imm = self.read_immediate_raw(op)?.right().unwrap();\n         if matches!(*imm, Immediate::Uninit) {\n             throw_ub!(InvalidUninitBytes(None));\n         }\n@@ -432,9 +434,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Basically we just transmute this place into an array following simd_size_and_type.\n         // This only works in memory, but repr(simd) types should never be immediates anyway.\n         assert!(op.layout.ty.is_simd());\n-        match op.try_as_mplace() {\n-            Ok(mplace) => self.mplace_to_simd(&mplace),\n-            Err(imm) => match *imm {\n+        match op.as_mplace_or_imm() {\n+            Left(mplace) => self.mplace_to_simd(&mplace),\n+            Right(imm) => match *imm {\n                 Immediate::Uninit => {\n                     throw_ub!(InvalidUninitBytes(None))\n                 }\n@@ -559,6 +561,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             ty::ConstKind::Param(_) | ty::ConstKind::Placeholder(..) => {\n                 throw_inval!(TooGeneric)\n             }\n+            // FIXME(generic_const_exprs): `ConstKind::Expr` should be able to be evaluated\n+            ty::ConstKind::Expr(_) => throw_inval!(TooGeneric),\n             ty::ConstKind::Error(reported) => {\n                 throw_inval!(AlreadyReported(reported))\n             }"}, {"sha": "c47cfe8bb69fd05831734e1f42cf16e3781d7049", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -2,6 +2,8 @@\n //! into a place.\n //! All high-level functions to write to memory work on places as destinations.\n \n+use either::{Either, Left, Right};\n+\n use rustc_ast::Mutability;\n use rustc_middle::mir;\n use rustc_middle::ty;\n@@ -252,36 +254,36 @@ impl<'tcx, Prov: Provenance> MPlaceTy<'tcx, Prov> {\n // These are defined here because they produce a place.\n impl<'tcx, Prov: Provenance> OpTy<'tcx, Prov> {\n     #[inline(always)]\n-    pub fn try_as_mplace(&self) -> Result<MPlaceTy<'tcx, Prov>, ImmTy<'tcx, Prov>> {\n+    pub fn as_mplace_or_imm(&self) -> Either<MPlaceTy<'tcx, Prov>, ImmTy<'tcx, Prov>> {\n         match **self {\n             Operand::Indirect(mplace) => {\n-                Ok(MPlaceTy { mplace, layout: self.layout, align: self.align.unwrap() })\n+                Left(MPlaceTy { mplace, layout: self.layout, align: self.align.unwrap() })\n             }\n-            Operand::Immediate(imm) => Err(ImmTy::from_immediate(imm, self.layout)),\n+            Operand::Immediate(imm) => Right(ImmTy::from_immediate(imm, self.layout)),\n         }\n     }\n \n     #[inline(always)]\n     #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n     pub fn assert_mem_place(&self) -> MPlaceTy<'tcx, Prov> {\n-        self.try_as_mplace().unwrap()\n+        self.as_mplace_or_imm().left().unwrap()\n     }\n }\n \n impl<'tcx, Prov: Provenance> PlaceTy<'tcx, Prov> {\n     /// A place is either an mplace or some local.\n     #[inline]\n-    pub fn try_as_mplace(&self) -> Result<MPlaceTy<'tcx, Prov>, (usize, mir::Local)> {\n+    pub fn as_mplace_or_local(&self) -> Either<MPlaceTy<'tcx, Prov>, (usize, mir::Local)> {\n         match **self {\n-            Place::Ptr(mplace) => Ok(MPlaceTy { mplace, layout: self.layout, align: self.align }),\n-            Place::Local { frame, local } => Err((frame, local)),\n+            Place::Ptr(mplace) => Left(MPlaceTy { mplace, layout: self.layout, align: self.align }),\n+            Place::Local { frame, local } => Right((frame, local)),\n         }\n     }\n \n     #[inline(always)]\n     #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n     pub fn assert_mem_place(&self) -> MPlaceTy<'tcx, Prov> {\n-        self.try_as_mplace().unwrap()\n+        self.as_mplace_or_local().left().unwrap()\n     }\n }\n \n@@ -569,9 +571,9 @@ where\n     }\n \n     pub fn write_uninit(&mut self, dest: &PlaceTy<'tcx, M::Provenance>) -> InterpResult<'tcx> {\n-        let mplace = match dest.try_as_mplace() {\n-            Ok(mplace) => mplace,\n-            Err((frame, local)) => {\n+        let mplace = match dest.as_mplace_or_local() {\n+            Left(mplace) => mplace,\n+            Right((frame, local)) => {\n                 match M::access_local_mut(self, frame, local)? {\n                     Operand::Immediate(local) => {\n                         *local = Immediate::Uninit;\n@@ -639,7 +641,7 @@ where\n         // Let us see if the layout is simple so we take a shortcut,\n         // avoid force_allocation.\n         let src = match self.read_immediate_raw(src)? {\n-            Ok(src_val) => {\n+            Right(src_val) => {\n                 // FIXME(const_prop): Const-prop can possibly evaluate an\n                 // unsized copy operation when it thinks that the type is\n                 // actually sized, due to a trivially false where-clause\n@@ -669,7 +671,7 @@ where\n                     )\n                 };\n             }\n-            Err(mplace) => mplace,\n+            Left(mplace) => mplace,\n         };\n         // Slow path, this does not fit into an immediate. Just memcpy.\n         trace!(\"copy_op: {:?} <- {:?}: {}\", *dest, src, dest.layout.ty);"}, {"sha": "4966fd6ea80c11ae2e1380ce2f701090c6ae2809", "filename": "compiler/rustc_const_eval/src/interpret/projection.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -7,6 +7,8 @@\n //! but we still need to do bounds checking and adjust the layout. To not duplicate that with MPlaceTy, we actually\n //! implement the logic on OpTy, and MPlaceTy calls that.\n \n+use either::{Left, Right};\n+\n use rustc_middle::mir;\n use rustc_middle::ty;\n use rustc_middle::ty::layout::LayoutOf;\n@@ -84,13 +86,13 @@ where\n         base: &OpTy<'tcx, M::Provenance>,\n         field: usize,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n-        let base = match base.try_as_mplace() {\n-            Ok(ref mplace) => {\n+        let base = match base.as_mplace_or_imm() {\n+            Left(ref mplace) => {\n                 // We can reuse the mplace field computation logic for indirect operands.\n                 let field = self.mplace_field(mplace, field)?;\n                 return Ok(field.into());\n             }\n-            Err(value) => value,\n+            Right(value) => value,\n         };\n \n         let field_layout = base.layout.field(self, field);"}, {"sha": "73f8bf4362e6086da6a1a3325e189c8dc8875850", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -2,6 +2,8 @@\n //!\n //! The main entry point is the `step` method.\n \n+use either::Either;\n+\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::{InterpResult, Scalar};\n use rustc_middle::ty::layout::LayoutOf;\n@@ -46,7 +48,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             return Ok(false);\n         }\n \n-        let Ok(loc) = self.frame().loc else {\n+        let Either::Left(loc) = self.frame().loc else {\n             // We are unwinding and this fn has no cleanup code.\n             // Just go on unwinding.\n             trace!(\"unwinding: skipping frame\");\n@@ -61,7 +63,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // Make sure we are not updating `statement_index` of the wrong frame.\n             assert_eq!(old_frames, self.frame_idx());\n             // Advance the program counter.\n-            self.frame_mut().loc.as_mut().unwrap().statement_index += 1;\n+            self.frame_mut().loc.as_mut().left().unwrap().statement_index += 1;\n             return Ok(true);\n         }\n \n@@ -305,7 +307,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         self.eval_terminator(terminator)?;\n         if !self.stack().is_empty() {\n-            if let Ok(loc) = self.frame().loc {\n+            if let Either::Left(loc) = self.frame().loc {\n                 info!(\"// executing {:?}\", loc.block);\n             }\n         }"}, {"sha": "0e85c7d11bce560b3af9d507a25f23b2e0aa0eaf", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -8,6 +8,8 @@ use std::convert::TryFrom;\n use std::fmt::{Display, Write};\n use std::num::NonZeroUsize;\n \n+use either::{Left, Right};\n+\n use rustc_ast::Mutability;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n@@ -783,18 +785,10 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 }\n             }\n             Abi::ScalarPair(a_layout, b_layout) => {\n-                // There is no `rustc_layout_scalar_valid_range_start` for pairs, so\n-                // we would validate these things as we descend into the fields,\n-                // but that can miss bugs in layout computation. Layout computation\n-                // is subtle due to enums having ScalarPair layout, where one field\n-                // is the discriminant.\n-                if cfg!(debug_assertions)\n-                    && !a_layout.is_uninit_valid()\n-                    && !b_layout.is_uninit_valid()\n-                {\n-                    // We can only proceed if *both* scalars need to be initialized.\n-                    // FIXME: find a way to also check ScalarPair when one side can be uninit but\n-                    // the other must be init.\n+                // We can only proceed if *both* scalars need to be initialized.\n+                // FIXME: find a way to also check ScalarPair when one side can be uninit but\n+                // the other must be init.\n+                if !a_layout.is_uninit_valid() && !b_layout.is_uninit_valid() {\n                     let (a, b) =\n                         self.read_immediate(op, \"initiailized scalar value\")?.to_scalar_pair();\n                     self.visit_scalar(a, a_layout)?;\n@@ -852,9 +846,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     return Ok(());\n                 }\n                 // Now that we definitely have a non-ZST array, we know it lives in memory.\n-                let mplace = match op.try_as_mplace() {\n-                    Ok(mplace) => mplace,\n-                    Err(imm) => match *imm {\n+                let mplace = match op.as_mplace_or_imm() {\n+                    Left(mplace) => mplace,\n+                    Right(imm) => match *imm {\n                         Immediate::Uninit =>\n                             throw_validation_failure!(self.path, { \"uninitialized bytes\" }),\n                         Immediate::Scalar(..) | Immediate::ScalarPair(..) =>"}, {"sha": "d4cee305387dc1207b9ac6cef4a36a0307f10433", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -10,7 +10,7 @@ use rustc_middle::mir::visit::{MutatingUseContext, NonMutatingUseContext, PlaceC\n use rustc_middle::mir::*;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts};\n use rustc_middle::ty::{self, adjustment::PointerCast, Instance, InstanceDef, Ty, TyCtxt};\n-use rustc_middle::ty::{Binder, TraitPredicate, TraitRef, TypeVisitable};\n+use rustc_middle::ty::{Binder, TraitRef, TypeVisitable};\n use rustc_mir_dataflow::{self, Analysis};\n use rustc_span::{sym, Span, Symbol};\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n@@ -449,8 +449,17 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n             | Rvalue::CopyForDeref(..)\n             | Rvalue::Repeat(..)\n             | Rvalue::Discriminant(..)\n-            | Rvalue::Len(_)\n-            | Rvalue::Aggregate(..) => {}\n+            | Rvalue::Len(_) => {}\n+\n+            Rvalue::Aggregate(ref kind, ..) => {\n+                if let AggregateKind::Generator(def_id, ..) = kind.as_ref() {\n+                    if let Some(generator_kind) = self.tcx.generator_kind(def_id.to_def_id()) {\n+                        if matches!(generator_kind, hir::GeneratorKind::Async(..)) {\n+                            self.check_op(ops::Generator(generator_kind));\n+                        }\n+                    }\n+                }\n+            }\n \n             Rvalue::Ref(_, kind @ BorrowKind::Mut { .. }, ref place)\n             | Rvalue::Ref(_, kind @ BorrowKind::Unique, ref place) => {\n@@ -726,11 +735,8 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                     }\n \n                     let trait_ref = TraitRef::from_method(tcx, trait_id, substs);\n-                    let poly_trait_pred = Binder::dummy(TraitPredicate {\n-                        trait_ref,\n-                        constness: ty::BoundConstness::ConstIfConst,\n-                        polarity: ty::ImplPolarity::Positive,\n-                    });\n+                    let poly_trait_pred =\n+                        Binder::dummy(trait_ref).with_constness(ty::BoundConstness::ConstIfConst);\n                     let obligation =\n                         Obligation::new(tcx, ObligationCause::dummy(), param_env, poly_trait_pred);\n \n@@ -819,9 +825,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                                     tcx,\n                                     ObligationCause::dummy_with_span(*fn_span),\n                                     param_env,\n-                                    tcx.mk_predicate(\n-                                        poly_trait_pred.map_bound(ty::PredicateKind::Trait),\n-                                    ),\n+                                    poly_trait_pred,\n                                 );\n \n                                 // improve diagnostics by showing what failed. Our requirements are stricter this time\n@@ -889,14 +893,6 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                     return;\n                 }\n \n-                // `async` blocks get lowered to `std::future::from_generator(/* a closure */)`.\n-                let is_async_block = Some(callee) == tcx.lang_items().from_generator_fn();\n-                if is_async_block {\n-                    let kind = hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Block);\n-                    self.check_op(ops::Generator(kind));\n-                    return;\n-                }\n-\n                 if !tcx.is_const_fn_raw(callee) {\n                     if !tcx.is_const_default_method(callee) {\n                         // To get to here we must have already found a const impl for the"}, {"sha": "bfc950eff5c061d37debf81a532b608a997df070", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -1,7 +1,7 @@\n //! Concrete error types for all operations which may be invalid in a certain const context.\n \n use hir::def_id::LocalDefId;\n-use hir::ConstContext;\n+use hir::{ConstContext, LangItem};\n use rustc_errors::{\n     error_code, struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed,\n };\n@@ -13,10 +13,9 @@ use rustc_middle::mir;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n use rustc_middle::ty::{\n-    suggest_constraining_type_param, Adt, Closure, DefIdTree, FnDef, FnPtr, Param, TraitPredicate,\n-    Ty,\n+    suggest_constraining_type_param, Adt, Closure, DefIdTree, FnDef, FnPtr, Param, Ty,\n };\n-use rustc_middle::ty::{Binder, BoundConstness, ImplPolarity, TraitRef};\n+use rustc_middle::ty::{Binder, TraitRef};\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::sym;\n use rustc_span::{BytePos, Pos, Span, Symbol};\n@@ -150,11 +149,7 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n                         tcx,\n                         ObligationCause::dummy(),\n                         param_env,\n-                        Binder::dummy(TraitPredicate {\n-                            trait_ref,\n-                            constness: BoundConstness::NotConst,\n-                            polarity: ImplPolarity::Positive,\n-                        }),\n+                        Binder::dummy(trait_ref),\n                     );\n \n                     let infcx = tcx.infer_ctxt().build();\n@@ -304,7 +299,7 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n                     err.span_note(deref_target, \"deref defined here\");\n                 }\n \n-                diag_trait(&mut err, self_ty, tcx.lang_items().deref_trait().unwrap());\n+                diag_trait(&mut err, self_ty, tcx.require_lang_item(LangItem::Deref, Some(span)));\n                 err\n             }\n             _ if tcx.opt_parent(callee) == tcx.get_diagnostic_item(sym::ArgumentV1Methods) => {"}, {"sha": "8ca3fdf400eb3ead2b7450b62ff2ca490e1e5cf8", "filename": "compiler/rustc_const_eval/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -153,20 +153,12 @@ impl Qualif for NeedsNonConstDrop {\n             return false;\n         }\n \n-        let destruct = cx.tcx.require_lang_item(LangItem::Destruct, None);\n-\n         let obligation = Obligation::new(\n             cx.tcx,\n-            ObligationCause::dummy(),\n+            ObligationCause::dummy_with_span(cx.body.span),\n             cx.param_env,\n-            ty::Binder::dummy(ty::TraitPredicate {\n-                trait_ref: ty::TraitRef {\n-                    def_id: destruct,\n-                    substs: cx.tcx.mk_substs_trait(ty, &[]),\n-                },\n-                constness: ty::BoundConstness::ConstIfConst,\n-                polarity: ty::ImplPolarity::Positive,\n-            }),\n+            ty::Binder::dummy(cx.tcx.at(cx.body.span).mk_trait_ref(LangItem::Destruct, [ty]))\n+                .with_constness(ty::BoundConstness::ConstIfConst),\n         );\n \n         let infcx = cx.tcx.infer_ctxt().build();"}, {"sha": "bf700d3122465c584b1d15efc54a71ffe1ab88e1", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -81,6 +81,7 @@ struct TypeChecker<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n+    #[track_caller]\n     fn fail(&self, location: Location, msg: impl AsRef<str>) {\n         let span = self.body.source_info(location).span;\n         // We use `delay_span_bug` as we might see broken MIR when other errors have already\n@@ -226,12 +227,12 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 let check_equal = |this: &Self, location, f_ty| {\n                     if !this.mir_assign_valid_types(ty, f_ty) {\n                         this.fail(\n-                        location,\n-                        format!(\n-                            \"Field projection `{:?}.{:?}` specified type `{:?}`, but actual type is `{:?}`\",\n-                            parent, f, ty, f_ty\n+                            location,\n+                            format!(\n+                                \"Field projection `{:?}.{:?}` specified type `{:?}`, but actual type is `{:?}`\",\n+                                parent, f, ty, f_ty\n+                            )\n                         )\n-                    )\n                     }\n                 };\n "}, {"sha": "b38a6c551388e473b7771d0e03f805f0db0b173b", "filename": "compiler/rustc_const_eval/src/util/call_kind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcall_kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcall_kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcall_kind.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -3,7 +3,7 @@\n //! context.\n \n use rustc_hir::def_id::DefId;\n-use rustc_hir::lang_items;\n+use rustc_hir::{lang_items, LangItem};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, AssocItemContainer, DefIdTree, Instance, ParamEnv, Ty, TyCtxt};\n use rustc_span::symbol::Ident;\n@@ -26,7 +26,7 @@ impl CallDesugaringKind {\n         match self {\n             Self::ForLoopIntoIter => tcx.get_diagnostic_item(sym::IntoIterator).unwrap(),\n             Self::QuestionBranch | Self::TryBlockFromOutput => {\n-                tcx.lang_items().try_trait().unwrap()\n+                tcx.require_lang_item(LangItem::Try, None)\n             }\n             Self::QuestionFromResidual => tcx.get_diagnostic_item(sym::FromResidual).unwrap(),\n         }"}, {"sha": "14c8c88028bdac0448ad5321272730a4842fcfe0", "filename": "compiler/rustc_const_eval/src/util/type_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Ftype_name.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -74,7 +74,7 @@ impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n \n     fn print_dyn_existential(\n         self,\n-        predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n+        predicates: &'tcx ty::List<ty::PolyExistentialPredicate<'tcx>>,\n     ) -> Result<Self::DynExistential, Self::Error> {\n         self.pretty_print_dyn_existential(predicates)\n     }"}, {"sha": "8e176efb2a9edf5f179221d6965debbecd2b5447", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -318,7 +318,7 @@ fn run_compiler(\n                             compiler.input(),\n                             &*expanded_crate,\n                             *ppm,\n-                            compiler.output_file().as_ref().map(|p| &**p),\n+                            compiler.output_file().as_deref(),\n                         );\n                         Ok(())\n                     })?;\n@@ -329,7 +329,7 @@ fn run_compiler(\n                         compiler.input(),\n                         &krate,\n                         *ppm,\n-                        compiler.output_file().as_ref().map(|p| &**p),\n+                        compiler.output_file().as_deref(),\n                     );\n                 }\n                 trace!(\"finished pretty-printing\");\n@@ -383,10 +383,7 @@ fn run_compiler(\n                             &crate_name,\n                             compiler.input(),\n                             None,\n-                            DumpHandler::new(\n-                                compiler.output_dir().as_ref().map(|p| &**p),\n-                                &crate_name,\n-                            ),\n+                            DumpHandler::new(compiler.output_dir().as_deref(), &crate_name),\n                         )\n                     });\n                 }"}, {"sha": "85e5faada224e4269622c711e59a4ff836bbcf17", "filename": "compiler/rustc_error_codes/src/error_codes/E0760.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0760.md", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0760.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0760.md?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -1,9 +1,11 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n `async fn`/`impl trait` return type cannot contain a projection\n or `Self` that references lifetimes from a parent scope.\n \n Erroneous code example:\n \n-```compile_fail,E0760,edition2018\n+```compile_fail,edition2018\n struct S<'a>(&'a i32);\n \n impl<'a> S<'a> {"}, {"sha": "2cd4733220e829ce4d68d0dc4bb3aee962277608", "filename": "compiler/rustc_error_messages/locales/en-US/borrowck.ftl", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -24,9 +24,6 @@ borrowck_var_does_not_need_mut =\n     variable does not need to be mutable\n     .suggestion = remove this `mut`\n \n-borrowck_const_not_used_in_type_alias =\n-    const parameter `{$ct}` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-\n borrowck_var_cannot_escape_closure =\n     captured variable cannot escape `FnMut` closure body\n     .note = `FnMut` closures only have access to their captured variables while they are executing..."}, {"sha": "0894bbcaad474b5b36f8712a068e188b283992c8", "filename": "compiler/rustc_error_messages/locales/en-US/hir_analysis.ftl", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -1,8 +1,3 @@\n-hir_analysis_field_multiply_specified_in_initializer =\n-    field `{$ident}` specified more than once\n-    .label = used more than once\n-    .previous_use_label = first use of `{$ident}`\n-\n hir_analysis_unrecognized_atomic_operation =\n     unrecognized atomic operation function: `{$op}`\n     .label = unrecognized atomic operation\n@@ -54,44 +49,16 @@ hir_analysis_assoc_type_binding_not_allowed =\n     associated type bindings are not allowed here\n     .label = associated type not allowed here\n \n-hir_analysis_functional_record_update_on_non_struct =\n-    functional record update syntax requires a struct\n-\n hir_analysis_typeof_reserved_keyword_used =\n     `typeof` is a reserved keyword but unimplemented\n     .suggestion = consider replacing `typeof(...)` with an actual type\n     .label = reserved keyword\n \n-hir_analysis_return_stmt_outside_of_fn_body =\n-    return statement outside of function body\n-    .encl_body_label = the return is part of this body...\n-    .encl_fn_label = ...not the enclosing function body\n-\n-hir_analysis_yield_expr_outside_of_generator =\n-    yield expression outside of generator literal\n-\n-hir_analysis_struct_expr_non_exhaustive =\n-    cannot create non-exhaustive {$what} using struct expression\n-\n-hir_analysis_method_call_on_unknown_type =\n-    the type of this value must be known to call a method on a raw pointer on it\n-\n hir_analysis_value_of_associated_struct_already_specified =\n     the value of the associated type `{$item_name}` (from trait `{$def_path}`) is already specified\n     .label = re-bound here\n     .previous_bound_label = `{$item_name}` bound here first\n \n-hir_analysis_address_of_temporary_taken = cannot take address of a temporary\n-    .label = temporary value\n-\n-hir_analysis_add_return_type_add = try adding a return type\n-\n-hir_analysis_add_return_type_missing_here = a return type might be missing here\n-\n-hir_analysis_expected_default_return_type = expected `()` because of default return type\n-\n-hir_analysis_expected_return_type = expected `{$expected}` because of return type\n-\n hir_analysis_unconstrained_opaque_type = unconstrained opaque type\n     .note = `{$name}` must be used in combination with a concrete type within the same {$what}\n \n@@ -134,10 +101,6 @@ hir_analysis_extern_crate_not_idiomatic =\n \n hir_analysis_expected_used_symbol = expected `used`, `used(compiler)` or `used(linker)`\n \n-hir_analysis_missing_parentheses_in_range = can't call method `{$method_name}` on type `{$ty_str}`\n-\n-hir_analysis_add_missing_parentheses_in_range = you must surround the range in parentheses to call its `{$func_name}` function\n-\n hir_analysis_const_impl_for_non_const_trait =\n     const `impl` for trait `{$trait_name}` which is not marked with `#[const_trait]`\n     .suggestion = mark `{$trait_name}` as const\n@@ -150,6 +113,3 @@ hir_analysis_const_bound_for_non_const_trait =\n hir_analysis_self_in_impl_self =\n     `Self` is not valid in the self type of an impl block\n     .note = replace `Self` with a different type\n-\n-hir_analysis_op_trait_generic_params =\n-    `{$method_name}` must not have any generic parameters"}, {"sha": "0612dbae0b63029c0a3fd75e8bba92d1872c6d92", "filename": "compiler/rustc_error_messages/locales/en-US/hir_typeck.ftl", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_typeck.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_typeck.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_typeck.ftl?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -0,0 +1,48 @@\n+hir_typeck_fru_note = this expression may have been misinterpreted as a `..` range expression\n+hir_typeck_fru_expr = this expression does not end in a comma...\n+hir_typeck_fru_expr2 = ... so this is interpreted as a `..` range expression, instead of functional record update syntax\n+hir_typeck_fru_suggestion =\n+    to set the remaining fields{$expr ->\n+        [NONE]{\"\"}\n+        *[other] {\" \"}from `{$expr}`\n+    }, separate the last named field with a comma\n+\n+hir_typeck_field_multiply_specified_in_initializer =\n+    field `{$ident}` specified more than once\n+    .label = used more than once\n+    .previous_use_label = first use of `{$ident}`\n+\n+hir_typeck_return_stmt_outside_of_fn_body =\n+    return statement outside of function body\n+    .encl_body_label = the return is part of this body...\n+    .encl_fn_label = ...not the enclosing function body\n+\n+hir_typeck_yield_expr_outside_of_generator =\n+    yield expression outside of generator literal\n+\n+hir_typeck_struct_expr_non_exhaustive =\n+    cannot create non-exhaustive {$what} using struct expression\n+\n+hir_typeck_method_call_on_unknown_type =\n+    the type of this value must be known to call a method on a raw pointer on it\n+\n+hir_typeck_functional_record_update_on_non_struct =\n+    functional record update syntax requires a struct\n+\n+hir_typeck_address_of_temporary_taken = cannot take address of a temporary\n+    .label = temporary value\n+\n+hir_typeck_add_return_type_add = try adding a return type\n+\n+hir_typeck_add_return_type_missing_here = a return type might be missing here\n+\n+hir_typeck_expected_default_return_type = expected `()` because of default return type\n+\n+hir_typeck_expected_return_type = expected `{$expected}` because of return type\n+\n+hir_typeck_missing_parentheses_in_range = can't call method `{$method_name}` on type `{$ty_str}`\n+\n+hir_typeck_add_missing_parentheses_in_range = you must surround the range in parentheses to call its `{$func_name}` function\n+\n+hir_typeck_op_trait_generic_params =\n+    `{$method_name}` must not have any generic parameters"}, {"sha": "d1e1fd54db9bf22bcacc11f105c8b56be3dc5c36", "filename": "compiler/rustc_error_messages/locales/en-US/metadata.ftl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -275,7 +275,7 @@ metadata_crate_location_unknown_type =\n     extern location for {$crate_name} is of an unknown type: {$path}\n \n metadata_lib_filename_form =\n-    file name should be lib*.rlib or {dll_prefix}*.{dll_suffix}\n+    file name should be lib*.rlib or {$dll_prefix}*{$dll_suffix}\n \n metadata_multiple_import_name_type =\n     multiple `import_name_type` arguments in a single `#[link]` attribute"}, {"sha": "4f4e5c6a2c9c2218bed43d2e41ec213e9b4aa2e0", "filename": "compiler/rustc_error_messages/locales/en-US/middle.ftl", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmiddle.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmiddle.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmiddle.ftl?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -31,3 +31,6 @@ middle_cannot_be_normalized =\n middle_strict_coherence_needs_negative_coherence =\n     to use `strict_coherence` on this trait, the `with_negative_coherence` feature must be enabled\n     .label = due to this attribute\n+\n+middle_const_not_used_in_type_alias =\n+    const parameter `{$ct}` is part of concrete type but not used in parameter list for the `impl Trait` type alias"}, {"sha": "114b7ec16288bb7b99f0abcb1ed89ba8559d68ad", "filename": "compiler/rustc_error_messages/locales/en-US/parse.ftl", "status": "added", "additions": 364, "deletions": 0, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -0,0 +1,364 @@\n+parse_struct_literal_body_without_path =\n+    struct literal body without path\n+    .suggestion = you might have forgotten to add the struct literal inside the block\n+\n+parse_maybe_report_ambiguous_plus =\n+    ambiguous `+` in a type\n+    .suggestion = use parentheses to disambiguate\n+\n+parse_maybe_recover_from_bad_type_plus =\n+    expected a path on the left-hand side of `+`, not `{$ty}`\n+\n+parse_add_paren = try adding parentheses\n+\n+parse_forgot_paren = perhaps you forgot parentheses?\n+\n+parse_expect_path = expected a path\n+\n+parse_maybe_recover_from_bad_qpath_stage_2 =\n+    missing angle brackets in associated item path\n+    .suggestion = try: `{$ty}`\n+\n+parse_incorrect_semicolon =\n+    expected item, found `;`\n+    .suggestion = remove this semicolon\n+    .help = {$name} declarations are not followed by a semicolon\n+\n+parse_incorrect_use_of_await =\n+    incorrect use of `await`\n+    .parentheses_suggestion = `await` is not a method call, remove the parentheses\n+    .postfix_suggestion = `await` is a postfix operation\n+\n+parse_in_in_typo =\n+    expected iterable, found keyword `in`\n+    .suggestion = remove the duplicated `in`\n+\n+parse_invalid_variable_declaration =\n+    invalid variable declaration\n+\n+parse_switch_mut_let_order =\n+    switch the order of `mut` and `let`\n+parse_missing_let_before_mut = missing keyword\n+parse_use_let_not_auto = write `let` instead of `auto` to introduce a new variable\n+parse_use_let_not_var = write `let` instead of `var` to introduce a new variable\n+\n+parse_invalid_comparison_operator = invalid comparison operator `{$invalid}`\n+    .use_instead = `{$invalid}` is not a valid comparison operator, use `{$correct}`\n+    .spaceship_operator_invalid = `<=>` is not a valid comparison operator, use `std::cmp::Ordering`\n+\n+parse_invalid_logical_operator = `{$incorrect}` is not a logical operator\n+    .note = unlike in e.g., Python and PHP, `&&` and `||` are used for logical operators\n+    .use_amp_amp_for_conjunction = use `&&` to perform logical conjunction\n+    .use_pipe_pipe_for_disjunction = use `||` to perform logical disjunction\n+\n+parse_tilde_is_not_unary_operator = `~` cannot be used as a unary operator\n+    .suggestion = use `!` to perform bitwise not\n+\n+parse_unexpected_if_with_if = unexpected `if` in the condition expression\n+    .suggestion = remove the `if`\n+\n+parse_unexpected_token_after_not = unexpected {$negated_desc} after identifier\n+parse_unexpected_token_after_not_bitwise = use `!` to perform bitwise not\n+parse_unexpected_token_after_not_logical = use `!` to perform logical negation\n+parse_unexpected_token_after_not_default = use `!` to perform logical negation or bitwise not\n+\n+parse_malformed_loop_label = malformed loop label\n+    .suggestion = use the correct loop label format\n+\n+parse_lifetime_in_borrow_expression = borrow expressions cannot be annotated with lifetimes\n+    .suggestion = remove the lifetime annotation\n+    .label = annotated with lifetime here\n+\n+parse_field_expression_with_generic = field expressions cannot have generic arguments\n+\n+parse_macro_invocation_with_qualified_path = macros cannot use qualified paths\n+\n+parse_unexpected_token_after_label = expected `while`, `for`, `loop` or `{\"{\"}` after a label\n+    .suggestion_remove_label = consider removing the label\n+    .suggestion_enclose_in_block = consider enclosing expression in a block\n+\n+parse_require_colon_after_labeled_expression = labeled expression must be followed by `:`\n+    .note = labels are used before loops and blocks, allowing e.g., `break 'label` to them\n+    .label = the label\n+    .suggestion = add `:` after the label\n+\n+parse_do_catch_syntax_removed = found removed `do catch` syntax\n+    .note = following RFC #2388, the new non-placeholder syntax is `try`\n+    .suggestion = replace with the new syntax\n+\n+parse_float_literal_requires_integer_part = float literals must have an integer part\n+    .suggestion = must have an integer part\n+\n+parse_missing_semicolon_before_array = expected `;`, found `[`\n+    .suggestion = consider adding `;` here\n+\n+parse_invalid_block_macro_segment = cannot use a `block` macro fragment here\n+    .label = the `block` fragment is within this context\n+\n+parse_expect_dotdot_not_dotdotdot = expected `..`, found `...`\n+    .suggestion = use `..` to fill in the rest of the fields\n+\n+parse_if_expression_missing_then_block = this `if` expression is missing a block after the condition\n+    .add_then_block = add a block here\n+    .condition_possibly_unfinished = this binary operation is possibly unfinished\n+\n+parse_if_expression_missing_condition = missing condition for `if` expression\n+    .condition_label = expected condition here\n+    .block_label = if this block is the condition of the `if` expression, then it must be followed by another block\n+\n+parse_expected_expression_found_let = expected expression, found `let` statement\n+\n+parse_expect_eq_instead_of_eqeq = expected `=`, found `==`\n+    .suggestion = consider using `=` here\n+\n+parse_expected_else_block = expected `{\"{\"}`, found {$first_tok}\n+    .label = expected an `if` or a block after this `else`\n+    .suggestion = add an `if` if this is the condition of a chained `else if` statement\n+\n+parse_outer_attribute_not_allowed_on_if_else = outer attributes are not allowed on `if` and `else` branches\n+    .branch_label = the attributes are attached to this branch\n+    .ctx_label = the branch belongs to this `{$ctx}`\n+    .suggestion = remove the attributes\n+\n+parse_missing_in_in_for_loop = missing `in` in `for` loop\n+    .use_in_not_of = try using `in` here instead\n+    .add_in = try adding `in` here\n+\n+parse_missing_comma_after_match_arm = expected `,` following `match` arm\n+    .suggestion = missing a comma here to end this `match` arm\n+\n+parse_catch_after_try = keyword `catch` cannot follow a `try` block\n+    .help = try using `match` on the result of the `try` block instead\n+\n+parse_comma_after_base_struct = cannot use a comma after the base struct\n+    .note = the base struct must always be the last field\n+    .suggestion = remove this comma\n+\n+parse_eq_field_init = expected `:`, found `=`\n+    .suggestion = replace equals symbol with a colon\n+\n+parse_dotdotdot = unexpected token: `...`\n+    .suggest_exclusive_range = use `..` for an exclusive range\n+    .suggest_inclusive_range = or `..=` for an inclusive range\n+\n+parse_left_arrow_operator = unexpected token: `<-`\n+    .suggestion = if you meant to write a comparison against a negative value, add a space in between `<` and `-`\n+\n+parse_remove_let = expected pattern, found `let`\n+    .suggestion = remove the unnecessary `let` keyword\n+\n+parse_use_eq_instead = unexpected `==`\n+    .suggestion = try using `=` instead\n+\n+parse_use_empty_block_not_semi = expected { \"`{}`\" }, found `;`\n+    .suggestion = try using { \"`{}`\" } instead\n+\n+parse_comparison_interpreted_as_generic =\n+    `<` is interpreted as a start of generic arguments for `{$type}`, not a comparison\n+    .label_args = interpreted as generic arguments\n+    .label_comparison = not interpreted as comparison\n+    .suggestion = try comparing the cast value\n+\n+parse_shift_interpreted_as_generic =\n+    `<<` is interpreted as a start of generic arguments for `{$type}`, not a shift\n+    .label_args = interpreted as generic arguments\n+    .label_comparison = not interpreted as shift\n+    .suggestion = try shifting the cast value\n+\n+parse_found_expr_would_be_stmt = expected expression, found `{$token}`\n+    .label = expected expression\n+\n+parse_leading_plus_not_supported = leading `+` is not supported\n+    .label = unexpected `+`\n+    .suggestion_remove_plus = try removing the `+`\n+\n+parse_parentheses_with_struct_fields = invalid `struct` delimiters or `fn` call arguments\n+    .suggestion_braces_for_struct = if `{$type}` is a struct, use braces as delimiters\n+    .suggestion_no_fields_for_fn = if `{$type}` is a function, use the arguments directly\n+\n+parse_labeled_loop_in_break = parentheses are required around this expression to avoid confusion with a labeled break expression\n+\n+parse_sugg_wrap_expression_in_parentheses = wrap the expression in parentheses\n+\n+parse_array_brackets_instead_of_braces = this is a block expression, not an array\n+    .suggestion = to make an array, use square brackets instead of curly braces\n+\n+parse_match_arm_body_without_braces = `match` arm body without braces\n+    .label_statements = {$num_statements ->\n+            [one] this statement is not surrounded by a body\n+           *[other] these statements are not surrounded by a body\n+        }\n+    .label_arrow = while parsing the `match` arm starting here\n+    .suggestion_add_braces = surround the {$num_statements ->\n+            [one] statement\n+           *[other] statements\n+        } with a body\n+    .suggestion_use_comma_not_semicolon = use a comma to end a `match` arm expression\n+\n+parse_struct_literal_not_allowed_here = struct literals are not allowed here\n+    .suggestion = surround the struct literal with parentheses\n+\n+parse_invalid_interpolated_expression = invalid interpolated expression\n+\n+parse_invalid_literal_suffix_on_tuple_index = suffixes on a tuple index are invalid\n+    .label = invalid suffix `{$suffix}`\n+    .tuple_exception_line_1 = `{$suffix}` is *temporarily* accepted on tuple index fields as it was incorrectly accepted on stable for a few releases\n+    .tuple_exception_line_2 = on proc macros, you'll want to use `syn::Index::from` or `proc_macro::Literal::*_unsuffixed` for code that will desugar to tuple field access\n+    .tuple_exception_line_3 = see issue #60210 <https://github.com/rust-lang/rust/issues/60210> for more information\n+\n+parse_non_string_abi_literal = non-string ABI literal\n+    .suggestion = specify the ABI with a string literal\n+\n+parse_mismatched_closing_delimiter = mismatched closing delimiter: `{$delimiter}`\n+    .label_unmatched = mismatched closing delimiter\n+    .label_opening_candidate = closing delimiter possibly meant for this\n+    .label_unclosed = unclosed delimiter\n+\n+parse_incorrect_visibility_restriction = incorrect visibility restriction\n+    .help = some possible visibility restrictions are:\n+            `pub(crate)`: visible only on the current crate\n+            `pub(super)`: visible only in the current module's parent\n+            `pub(in path::to::module)`: visible only on the specified path\n+    .suggestion = make this visible only to module `{$inner_str}` with `in`\n+\n+parse_assignment_else_not_allowed = <assignment> ... else {\"{\"} ... {\"}\"} is not allowed\n+\n+parse_expected_statement_after_outer_attr = expected statement after outer attribute\n+\n+parse_doc_comment_does_not_document_anything = found a documentation comment that doesn't document anything\n+    .help = doc comments must come before what they document, if a comment was intended use `//`\n+    .suggestion = missing comma here\n+\n+parse_const_let_mutually_exclusive = `const` and `let` are mutually exclusive\n+    .suggestion = remove `let`\n+\n+parse_invalid_expression_in_let_else = a `{$operator}` expression cannot be directly assigned in `let...else`\n+parse_invalid_curly_in_let_else = right curly brace `{\"}\"}` before `else` in a `let...else` statement not allowed\n+\n+parse_compound_assignment_expression_in_let = can't reassign to an uninitialized variable\n+    .suggestion = initialize the variable\n+    .help = if you meant to overwrite, remove the `let` binding\n+\n+parse_suffixed_literal_in_attribute = suffixed literals are not allowed in attributes\n+    .help = instead of using a suffixed literal (`1u8`, `1.0f32`, etc.), use an unsuffixed version (`1`, `1.0`, etc.)\n+\n+parse_invalid_meta_item = expected unsuffixed literal or identifier, found `{$token}`\n+\n+parse_label_inner_attr_does_not_annotate_this = the inner attribute doesn't annotate this {$item}\n+parse_sugg_change_inner_attr_to_outer = to annotate the {$item}, change the attribute from inner to outer style\n+\n+parse_inner_attr_not_permitted_after_outer_doc_comment = an inner attribute is not permitted following an outer doc comment\n+    .label_attr = not permitted following an outer doc comment\n+    .label_prev_doc_comment = previous doc comment\n+    .label_does_not_annotate_this = {parse_label_inner_attr_does_not_annotate_this}\n+    .sugg_change_inner_to_outer = {parse_sugg_change_inner_attr_to_outer}\n+\n+parse_inner_attr_not_permitted_after_outer_attr = an inner attribute is not permitted following an outer attribute\n+    .label_attr = not permitted following an outer attribute\n+    .label_prev_attr = previous outer attribute\n+    .label_does_not_annotate_this = {parse_label_inner_attr_does_not_annotate_this}\n+    .sugg_change_inner_to_outer = {parse_sugg_change_inner_attr_to_outer}\n+\n+parse_inner_attr_not_permitted = an inner attribute is not permitted in this context\n+    .label_does_not_annotate_this = {parse_label_inner_attr_does_not_annotate_this}\n+    .sugg_change_inner_to_outer = {parse_sugg_change_inner_attr_to_outer}\n+\n+parse_inner_attr_explanation = inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files\n+parse_outer_attr_explanation = outer attributes, like `#[test]`, annotate the item following them\n+\n+parse_inner_doc_comment_not_permitted = expected outer doc comment\n+    .note = inner doc comments like this (starting with `//!` or `/*!`) can only appear before items\n+    .suggestion = you might have meant to write a regular comment\n+    .label_does_not_annotate_this = the inner doc comment doesn't annotate this {$item}\n+    .sugg_change_inner_to_outer = to annotate the {$item}, change the doc comment from inner to outer style\n+\n+parse_expected_identifier_found_reserved_identifier_str = expected identifier, found reserved identifier `{$token}`\n+parse_expected_identifier_found_keyword_str = expected identifier, found keyword `{$token}`\n+parse_expected_identifier_found_reserved_keyword_str = expected identifier, found reserved keyword `{$token}`\n+parse_expected_identifier_found_doc_comment_str = expected identifier, found doc comment `{$token}`\n+parse_expected_identifier_found_str = expected identifier, found `{$token}`\n+\n+parse_expected_identifier_found_reserved_identifier = expected identifier, found reserved identifier\n+parse_expected_identifier_found_keyword = expected identifier, found keyword\n+parse_expected_identifier_found_reserved_keyword = expected identifier, found reserved keyword\n+parse_expected_identifier_found_doc_comment = expected identifier, found doc comment\n+parse_expected_identifier = expected identifier\n+\n+parse_sugg_escape_to_use_as_identifier = escape `{$ident_name}` to use it as an identifier\n+\n+parse_sugg_remove_comma = remove this comma\n+\n+parse_expected_semi_found_reserved_identifier_str = expected `;`, found reserved identifier `{$token}`\n+parse_expected_semi_found_keyword_str = expected `;`, found keyword `{$token}`\n+parse_expected_semi_found_reserved_keyword_str = expected `;`, found reserved keyword `{$token}`\n+parse_expected_semi_found_doc_comment_str = expected `;`, found doc comment `{$token}`\n+parse_expected_semi_found_str = expected `;`, found `{$token}`\n+\n+parse_sugg_change_this_to_semi = change this to `;`\n+parse_sugg_add_semi = add `;` here\n+parse_label_unexpected_token = unexpected token\n+\n+parse_unmatched_angle_brackets = {$num_extra_brackets ->\n+        [one] unmatched angle bracket\n+       *[other] unmatched angle brackets\n+    }\n+    .suggestion = {$num_extra_brackets ->\n+            [one] remove extra angle bracket\n+           *[other] remove extra angle brackets\n+        }\n+\n+parse_generic_parameters_without_angle_brackets = generic parameters without surrounding angle brackets\n+    .suggestion = surround the type parameters with angle brackets\n+\n+parse_comparison_operators_cannot_be_chained = comparison operators cannot be chained\n+    .sugg_parentheses_for_function_args = or use `(...)` if you meant to specify fn arguments\n+    .sugg_split_comparison = split the comparison into two\n+    .sugg_parenthesize = parenthesize the comparison\n+parse_sugg_turbofish_syntax = use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n+\n+parse_question_mark_in_type = invalid `?` in type\n+    .label = `?` is only allowed on expressions, not types\n+    .suggestion = if you meant to express that the type might not contain a value, use the `Option` wrapper type\n+\n+parse_unexpected_parentheses_in_for_head = unexpected parentheses surrounding `for` loop head\n+    .suggestion = remove parentheses in `for` loop\n+\n+parse_doc_comment_on_param_type = documentation comments cannot be applied to a function parameter's type\n+    .label = doc comments are not allowed here\n+\n+parse_attribute_on_param_type = attributes cannot be applied to a function parameter's type\n+    .label = attributes are not allowed here\n+\n+parse_pattern_method_param_without_body = patterns aren't allowed in methods without bodies\n+    .suggestion = give this argument a name or use an underscore to ignore it\n+\n+parse_self_param_not_first = unexpected `self` parameter in function\n+    .label = must be the first parameter of an associated function\n+\n+parse_const_generic_without_braces = expressions must be enclosed in braces to be used as const generic arguments\n+    .suggestion = enclose the `const` expression in braces\n+\n+parse_unexpected_const_param_declaration = unexpected `const` parameter declaration\n+    .label = expected a `const` expression, not a parameter declaration\n+    .suggestion = `const` parameters must be declared for the `impl`\n+\n+parse_unexpected_const_in_generic_param = expected lifetime, type, or constant, found keyword `const`\n+    .suggestion = the `const` keyword is only needed in the definition of the type\n+\n+parse_async_move_order_incorrect = the order of `move` and `async` is incorrect\n+    .suggestion = try switching the order\n+\n+parse_double_colon_in_bound = expected `:` followed by trait or lifetime\n+    .suggestion = use single colon\n+\n+parse_fn_ptr_with_generics = function pointer types may not have generic parameters\n+    .suggestion = consider moving the lifetime {$arity ->\n+        [one] parameter\n+        *[other] parameters\n+    } to {$for_param_list_exists ->\n+        [true] the\n+        *[false] a\n+    } `for` parameter list\n+\n+parse_invalid_identifier_with_leading_number = expected identifier, found number literal\n+    .label = identifiers cannot start with a number"}, {"sha": "1df5bf1a22037fef47d29a92a2b06d9df946b6d4", "filename": "compiler/rustc_error_messages/locales/en-US/parser.ftl", "status": "removed", "additions": 0, "deletions": 392, "changes": 392, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl?ref=66354f00430eebb88d33de02326d7ca9196bd61a", "patch": "@@ -1,392 +0,0 @@\n-parser_struct_literal_body_without_path =\n-    struct literal body without path\n-    .suggestion = you might have forgotten to add the struct literal inside the block\n-\n-parser_maybe_report_ambiguous_plus =\n-    ambiguous `+` in a type\n-    .suggestion = use parentheses to disambiguate\n-\n-parser_maybe_recover_from_bad_type_plus =\n-    expected a path on the left-hand side of `+`, not `{$ty}`\n-\n-parser_add_paren = try adding parentheses\n-\n-parser_forgot_paren = perhaps you forgot parentheses?\n-\n-parser_expect_path = expected a path\n-\n-parser_maybe_recover_from_bad_qpath_stage_2 =\n-    missing angle brackets in associated item path\n-    .suggestion = try: `{$ty}`\n-\n-parser_incorrect_semicolon =\n-    expected item, found `;`\n-    .suggestion = remove this semicolon\n-    .help = {$name} declarations are not followed by a semicolon\n-\n-parser_incorrect_use_of_await =\n-    incorrect use of `await`\n-    .parentheses_suggestion = `await` is not a method call, remove the parentheses\n-    .postfix_suggestion = `await` is a postfix operation\n-\n-parser_in_in_typo =\n-    expected iterable, found keyword `in`\n-    .suggestion = remove the duplicated `in`\n-\n-parser_invalid_variable_declaration =\n-    invalid variable declaration\n-\n-parser_switch_mut_let_order =\n-    switch the order of `mut` and `let`\n-parser_missing_let_before_mut = missing keyword\n-parser_use_let_not_auto = write `let` instead of `auto` to introduce a new variable\n-parser_use_let_not_var = write `let` instead of `var` to introduce a new variable\n-\n-parser_invalid_comparison_operator = invalid comparison operator `{$invalid}`\n-    .use_instead = `{$invalid}` is not a valid comparison operator, use `{$correct}`\n-    .spaceship_operator_invalid = `<=>` is not a valid comparison operator, use `std::cmp::Ordering`\n-\n-parser_invalid_logical_operator = `{$incorrect}` is not a logical operator\n-    .note = unlike in e.g., Python and PHP, `&&` and `||` are used for logical operators\n-    .use_amp_amp_for_conjunction = use `&&` to perform logical conjunction\n-    .use_pipe_pipe_for_disjunction = use `||` to perform logical disjunction\n-\n-parser_tilde_is_not_unary_operator = `~` cannot be used as a unary operator\n-    .suggestion = use `!` to perform bitwise not\n-\n-parser_unexpected_if_with_if = unexpected `if` in the condition expression\n-    .suggestion = remove the `if`\n-\n-parser_unexpected_token_after_not = unexpected {$negated_desc} after identifier\n-parser_unexpected_token_after_not_bitwise = use `!` to perform bitwise not\n-parser_unexpected_token_after_not_logical = use `!` to perform logical negation\n-parser_unexpected_token_after_not_default = use `!` to perform logical negation or bitwise not\n-\n-parser_malformed_loop_label = malformed loop label\n-    .suggestion = use the correct loop label format\n-\n-parser_lifetime_in_borrow_expression = borrow expressions cannot be annotated with lifetimes\n-    .suggestion = remove the lifetime annotation\n-    .label = annotated with lifetime here\n-\n-parser_field_expression_with_generic = field expressions cannot have generic arguments\n-\n-parser_macro_invocation_with_qualified_path = macros cannot use qualified paths\n-\n-parser_unexpected_token_after_label = expected `while`, `for`, `loop` or `{\"{\"}` after a label\n-    .suggestion_remove_label = consider removing the label\n-    .suggestion_enclose_in_block = consider enclosing expression in a block\n-\n-parser_require_colon_after_labeled_expression = labeled expression must be followed by `:`\n-    .note = labels are used before loops and blocks, allowing e.g., `break 'label` to them\n-    .label = the label\n-    .suggestion = add `:` after the label\n-\n-parser_do_catch_syntax_removed = found removed `do catch` syntax\n-    .note = following RFC #2388, the new non-placeholder syntax is `try`\n-    .suggestion = replace with the new syntax\n-\n-parser_float_literal_requires_integer_part = float literals must have an integer part\n-    .suggestion = must have an integer part\n-\n-parser_invalid_int_literal_width = invalid width `{$width}` for integer literal\n-    .help = valid widths are 8, 16, 32, 64 and 128\n-\n-parser_invalid_num_literal_base_prefix = invalid base prefix for number literal\n-    .note = base prefixes (`0xff`, `0b1010`, `0o755`) are lowercase\n-    .suggestion = try making the prefix lowercase\n-\n-parser_invalid_num_literal_suffix = invalid suffix `{$suffix}` for number literal\n-    .label = invalid suffix `{$suffix}`\n-    .help = the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n-\n-parser_invalid_float_literal_width = invalid width `{$width}` for float literal\n-    .help = valid widths are 32 and 64\n-\n-parser_invalid_float_literal_suffix = invalid suffix `{$suffix}` for float literal\n-    .label = invalid suffix `{$suffix}`\n-    .help = valid suffixes are `f32` and `f64`\n-\n-parser_int_literal_too_large = integer literal is too large\n-\n-parser_missing_semicolon_before_array = expected `;`, found `[`\n-    .suggestion = consider adding `;` here\n-\n-parser_invalid_block_macro_segment = cannot use a `block` macro fragment here\n-    .label = the `block` fragment is within this context\n-\n-parser_expect_dotdot_not_dotdotdot = expected `..`, found `...`\n-    .suggestion = use `..` to fill in the rest of the fields\n-\n-parser_if_expression_missing_then_block = this `if` expression is missing a block after the condition\n-    .add_then_block = add a block here\n-    .condition_possibly_unfinished = this binary operation is possibly unfinished\n-\n-parser_if_expression_missing_condition = missing condition for `if` expression\n-    .condition_label = expected condition here\n-    .block_label = if this block is the condition of the `if` expression, then it must be followed by another block\n-\n-parser_expected_expression_found_let = expected expression, found `let` statement\n-\n-parser_expect_eq_instead_of_eqeq = expected `=`, found `==`\n-    .suggestion = consider using `=` here\n-\n-parser_expected_else_block = expected `{\"{\"}`, found {$first_tok}\n-    .label = expected an `if` or a block after this `else`\n-    .suggestion = add an `if` if this is the condition of a chained `else if` statement\n-\n-parser_outer_attribute_not_allowed_on_if_else = outer attributes are not allowed on `if` and `else` branches\n-    .branch_label = the attributes are attached to this branch\n-    .ctx_label = the branch belongs to this `{$ctx}`\n-    .suggestion = remove the attributes\n-\n-parser_missing_in_in_for_loop = missing `in` in `for` loop\n-    .use_in_not_of = try using `in` here instead\n-    .add_in = try adding `in` here\n-\n-parser_missing_comma_after_match_arm = expected `,` following `match` arm\n-    .suggestion = missing a comma here to end this `match` arm\n-\n-parser_catch_after_try = keyword `catch` cannot follow a `try` block\n-    .help = try using `match` on the result of the `try` block instead\n-\n-parser_comma_after_base_struct = cannot use a comma after the base struct\n-    .note = the base struct must always be the last field\n-    .suggestion = remove this comma\n-\n-parser_eq_field_init = expected `:`, found `=`\n-    .suggestion = replace equals symbol with a colon\n-\n-parser_dotdotdot = unexpected token: `...`\n-    .suggest_exclusive_range = use `..` for an exclusive range\n-    .suggest_inclusive_range = or `..=` for an inclusive range\n-\n-parser_left_arrow_operator = unexpected token: `<-`\n-    .suggestion = if you meant to write a comparison against a negative value, add a space in between `<` and `-`\n-\n-parser_remove_let = expected pattern, found `let`\n-    .suggestion = remove the unnecessary `let` keyword\n-\n-parser_use_eq_instead = unexpected `==`\n-    .suggestion = try using `=` instead\n-\n-parser_use_empty_block_not_semi = expected { \"`{}`\" }, found `;`\n-    .suggestion = try using { \"`{}`\" } instead\n-\n-parser_comparison_interpreted_as_generic =\n-    `<` is interpreted as a start of generic arguments for `{$type}`, not a comparison\n-    .label_args = interpreted as generic arguments\n-    .label_comparison = not interpreted as comparison\n-    .suggestion = try comparing the cast value\n-\n-parser_shift_interpreted_as_generic =\n-    `<<` is interpreted as a start of generic arguments for `{$type}`, not a shift\n-    .label_args = interpreted as generic arguments\n-    .label_comparison = not interpreted as shift\n-    .suggestion = try shifting the cast value\n-\n-parser_found_expr_would_be_stmt = expected expression, found `{$token}`\n-    .label = expected expression\n-\n-parser_leading_plus_not_supported = leading `+` is not supported\n-    .label = unexpected `+`\n-    .suggestion_remove_plus = try removing the `+`\n-\n-parser_parentheses_with_struct_fields = invalid `struct` delimiters or `fn` call arguments\n-    .suggestion_braces_for_struct = if `{$type}` is a struct, use braces as delimiters\n-    .suggestion_no_fields_for_fn = if `{$type}` is a function, use the arguments directly\n-\n-parser_labeled_loop_in_break = parentheses are required around this expression to avoid confusion with a labeled break expression\n-\n-parser_sugg_wrap_expression_in_parentheses = wrap the expression in parentheses\n-\n-parser_array_brackets_instead_of_braces = this is a block expression, not an array\n-    .suggestion = to make an array, use square brackets instead of curly braces\n-\n-parser_match_arm_body_without_braces = `match` arm body without braces\n-    .label_statements = {$num_statements ->\n-            [one] this statement is not surrounded by a body\n-           *[other] these statements are not surrounded by a body\n-        }\n-    .label_arrow = while parsing the `match` arm starting here\n-    .suggestion_add_braces = surround the {$num_statements ->\n-            [one] statement\n-           *[other] statements\n-        } with a body\n-    .suggestion_use_comma_not_semicolon = use a comma to end a `match` arm expression\n-\n-parser_struct_literal_not_allowed_here = struct literals are not allowed here\n-    .suggestion = surround the struct literal with parentheses\n-\n-parser_invalid_interpolated_expression = invalid interpolated expression\n-\n-parser_hexadecimal_float_literal_not_supported = hexadecimal float literal is not supported\n-parser_octal_float_literal_not_supported = octal float literal is not supported\n-parser_binary_float_literal_not_supported = binary float literal is not supported\n-parser_not_supported = not supported\n-\n-parser_invalid_literal_suffix = suffixes on {$kind} literals are invalid\n-    .label = invalid suffix `{$suffix}`\n-\n-parser_invalid_literal_suffix_on_tuple_index = suffixes on a tuple index are invalid\n-    .label = invalid suffix `{$suffix}`\n-    .tuple_exception_line_1 = `{$suffix}` is *temporarily* accepted on tuple index fields as it was incorrectly accepted on stable for a few releases\n-    .tuple_exception_line_2 = on proc macros, you'll want to use `syn::Index::from` or `proc_macro::Literal::*_unsuffixed` for code that will desugar to tuple field access\n-    .tuple_exception_line_3 = see issue #60210 <https://github.com/rust-lang/rust/issues/60210> for more information\n-\n-parser_non_string_abi_literal = non-string ABI literal\n-    .suggestion = specify the ABI with a string literal\n-\n-parser_mismatched_closing_delimiter = mismatched closing delimiter: `{$delimiter}`\n-    .label_unmatched = mismatched closing delimiter\n-    .label_opening_candidate = closing delimiter possibly meant for this\n-    .label_unclosed = unclosed delimiter\n-\n-parser_incorrect_visibility_restriction = incorrect visibility restriction\n-    .help = some possible visibility restrictions are:\n-            `pub(crate)`: visible only on the current crate\n-            `pub(super)`: visible only in the current module's parent\n-            `pub(in path::to::module)`: visible only on the specified path\n-    .suggestion = make this visible only to module `{$inner_str}` with `in`\n-\n-parser_assignment_else_not_allowed = <assignment> ... else {\"{\"} ... {\"}\"} is not allowed\n-\n-parser_expected_statement_after_outer_attr = expected statement after outer attribute\n-\n-parser_doc_comment_does_not_document_anything = found a documentation comment that doesn't document anything\n-    .help = doc comments must come before what they document, if a comment was intended use `//`\n-    .suggestion = missing comma here\n-\n-parser_const_let_mutually_exclusive = `const` and `let` are mutually exclusive\n-    .suggestion = remove `let`\n-\n-parser_invalid_expression_in_let_else = a `{$operator}` expression cannot be directly assigned in `let...else`\n-parser_invalid_curly_in_let_else = right curly brace `{\"}\"}` before `else` in a `let...else` statement not allowed\n-\n-parser_compound_assignment_expression_in_let = can't reassign to an uninitialized variable\n-    .suggestion = initialize the variable\n-    .help = if you meant to overwrite, remove the `let` binding\n-\n-parser_suffixed_literal_in_attribute = suffixed literals are not allowed in attributes\n-    .help = instead of using a suffixed literal (`1u8`, `1.0f32`, etc.), use an unsuffixed version (`1`, `1.0`, etc.)\n-\n-parser_invalid_meta_item = expected unsuffixed literal or identifier, found `{$token}`\n-\n-parser_label_inner_attr_does_not_annotate_this = the inner attribute doesn't annotate this {$item}\n-parser_sugg_change_inner_attr_to_outer = to annotate the {$item}, change the attribute from inner to outer style\n-\n-parser_inner_attr_not_permitted_after_outer_doc_comment = an inner attribute is not permitted following an outer doc comment\n-    .label_attr = not permitted following an outer doc comment\n-    .label_prev_doc_comment = previous doc comment\n-    .label_does_not_annotate_this = {parser_label_inner_attr_does_not_annotate_this}\n-    .sugg_change_inner_to_outer = {parser_sugg_change_inner_attr_to_outer}\n-\n-parser_inner_attr_not_permitted_after_outer_attr = an inner attribute is not permitted following an outer attribute\n-    .label_attr = not permitted following an outer attribute\n-    .label_prev_attr = previous outer attribute\n-    .label_does_not_annotate_this = {parser_label_inner_attr_does_not_annotate_this}\n-    .sugg_change_inner_to_outer = {parser_sugg_change_inner_attr_to_outer}\n-\n-parser_inner_attr_not_permitted = an inner attribute is not permitted in this context\n-    .label_does_not_annotate_this = {parser_label_inner_attr_does_not_annotate_this}\n-    .sugg_change_inner_to_outer = {parser_sugg_change_inner_attr_to_outer}\n-\n-parser_inner_attr_explanation = inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files\n-parser_outer_attr_explanation = outer attributes, like `#[test]`, annotate the item following them\n-\n-parser_inner_doc_comment_not_permitted = expected outer doc comment\n-    .note = inner doc comments like this (starting with `//!` or `/*!`) can only appear before items\n-    .suggestion = you might have meant to write a regular comment\n-    .label_does_not_annotate_this = the inner doc comment doesn't annotate this {$item}\n-    .sugg_change_inner_to_outer = to annotate the {$item}, change the doc comment from inner to outer style\n-\n-parser_expected_identifier_found_reserved_identifier_str = expected identifier, found reserved identifier `{$token}`\n-parser_expected_identifier_found_keyword_str = expected identifier, found keyword `{$token}`\n-parser_expected_identifier_found_reserved_keyword_str = expected identifier, found reserved keyword `{$token}`\n-parser_expected_identifier_found_doc_comment_str = expected identifier, found doc comment `{$token}`\n-parser_expected_identifier_found_str = expected identifier, found `{$token}`\n-\n-parser_expected_identifier_found_reserved_identifier = expected identifier, found reserved identifier\n-parser_expected_identifier_found_keyword = expected identifier, found keyword\n-parser_expected_identifier_found_reserved_keyword = expected identifier, found reserved keyword\n-parser_expected_identifier_found_doc_comment = expected identifier, found doc comment\n-parser_expected_identifier = expected identifier\n-\n-parser_sugg_escape_to_use_as_identifier = escape `{$ident_name}` to use it as an identifier\n-\n-parser_sugg_remove_comma = remove this comma\n-\n-parser_expected_semi_found_reserved_identifier_str = expected `;`, found reserved identifier `{$token}`\n-parser_expected_semi_found_keyword_str = expected `;`, found keyword `{$token}`\n-parser_expected_semi_found_reserved_keyword_str = expected `;`, found reserved keyword `{$token}`\n-parser_expected_semi_found_doc_comment_str = expected `;`, found doc comment `{$token}`\n-parser_expected_semi_found_str = expected `;`, found `{$token}`\n-\n-parser_sugg_change_this_to_semi = change this to `;`\n-parser_sugg_add_semi = add `;` here\n-parser_label_unexpected_token = unexpected token\n-\n-parser_unmatched_angle_brackets = {$num_extra_brackets ->\n-        [one] unmatched angle bracket\n-       *[other] unmatched angle brackets\n-    }\n-    .suggestion = {$num_extra_brackets ->\n-            [one] remove extra angle bracket\n-           *[other] remove extra angle brackets\n-        }\n-\n-parser_generic_parameters_without_angle_brackets = generic parameters without surrounding angle brackets\n-    .suggestion = surround the type parameters with angle brackets\n-\n-parser_comparison_operators_cannot_be_chained = comparison operators cannot be chained\n-    .sugg_parentheses_for_function_args = or use `(...)` if you meant to specify fn arguments\n-    .sugg_split_comparison = split the comparison into two\n-    .sugg_parenthesize = parenthesize the comparison\n-parser_sugg_turbofish_syntax = use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n-\n-parser_question_mark_in_type = invalid `?` in type\n-    .label = `?` is only allowed on expressions, not types\n-    .suggestion = if you meant to express that the type might not contain a value, use the `Option` wrapper type\n-\n-parser_unexpected_parentheses_in_for_head = unexpected parentheses surrounding `for` loop head\n-    .suggestion = remove parentheses in `for` loop\n-\n-parser_doc_comment_on_param_type = documentation comments cannot be applied to a function parameter's type\n-    .label = doc comments are not allowed here\n-\n-parser_attribute_on_param_type = attributes cannot be applied to a function parameter's type\n-    .label = attributes are not allowed here\n-\n-parser_pattern_method_param_without_body = patterns aren't allowed in methods without bodies\n-    .suggestion = give this argument a name or use an underscore to ignore it\n-\n-parser_self_param_not_first = unexpected `self` parameter in function\n-    .label = must be the first parameter of an associated function\n-\n-parser_const_generic_without_braces = expressions must be enclosed in braces to be used as const generic arguments\n-    .suggestion = enclose the `const` expression in braces\n-\n-parser_unexpected_const_param_declaration = unexpected `const` parameter declaration\n-    .label = expected a `const` expression, not a parameter declaration\n-    .suggestion = `const` parameters must be declared for the `impl`\n-\n-parser_unexpected_const_in_generic_param = expected lifetime, type, or constant, found keyword `const`\n-    .suggestion = the `const` keyword is only needed in the definition of the type\n-\n-parser_async_move_order_incorrect = the order of `move` and `async` is incorrect\n-    .suggestion = try switching the order\n-\n-parser_double_colon_in_bound = expected `:` followed by trait or lifetime\n-    .suggestion = use single colon\n-\n-parser_fn_ptr_with_generics = function pointer types may not have generic parameters\n-    .suggestion = consider moving the lifetime {$arity ->\n-        [one] parameter\n-        *[other] parameters\n-    } to {$for_param_list_exists ->\n-        [true] the\n-        *[false] a\n-    } `for` parameter list\n-\n-parser_invalid_identifier_with_leading_number = expected identifier, found number literal\n-    .label = identifiers cannot start with a number"}, {"sha": "983eb926213ea587946629576a3c1b78fbf202e5", "filename": "compiler/rustc_error_messages/locales/en-US/session.ftl", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -58,3 +58,31 @@ session_expr_parentheses_needed = parentheses are required to parse this as an e\n session_skipping_const_checks = skipping const checks\n session_unleashed_feature_help_named = skipping check for `{$gate}` feature\n session_unleashed_feature_help_unnamed = skipping check that does not even have a feature gate\n+\n+session_hexadecimal_float_literal_not_supported = hexadecimal float literal is not supported\n+session_octal_float_literal_not_supported = octal float literal is not supported\n+session_binary_float_literal_not_supported = binary float literal is not supported\n+session_not_supported = not supported\n+\n+session_invalid_literal_suffix = suffixes on {$kind} literals are invalid\n+    .label = invalid suffix `{$suffix}`\n+\n+session_invalid_num_literal_base_prefix = invalid base prefix for number literal\n+    .note = base prefixes (`0xff`, `0b1010`, `0o755`) are lowercase\n+    .suggestion = try making the prefix lowercase\n+\n+session_invalid_num_literal_suffix = invalid suffix `{$suffix}` for number literal\n+    .label = invalid suffix `{$suffix}`\n+    .help = the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n+\n+session_invalid_float_literal_width = invalid width `{$width}` for float literal\n+    .help = valid widths are 32 and 64\n+\n+session_invalid_float_literal_suffix = invalid suffix `{$suffix}` for float literal\n+    .label = invalid suffix `{$suffix}`\n+    .help = valid suffixes are `f32` and `f64`\n+\n+session_int_literal_too_large = integer literal is too large\n+\n+session_invalid_int_literal_width = invalid width `{$width}` for integer literal\n+    .help = valid widths are 8, 16, 32, 64 and 128"}, {"sha": "418ba3c74d7761cb574d8ad0840fd0dd09c93249", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -51,14 +51,15 @@ fluent_messages! {\n     errors => \"../locales/en-US/errors.ftl\",\n     expand => \"../locales/en-US/expand.ftl\",\n     hir_analysis => \"../locales/en-US/hir_analysis.ftl\",\n+    hir_typeck => \"../locales/en-US/hir_typeck.ftl\",\n     infer => \"../locales/en-US/infer.ftl\",\n     interface => \"../locales/en-US/interface.ftl\",\n     lint => \"../locales/en-US/lint.ftl\",\n     metadata => \"../locales/en-US/metadata.ftl\",\n     middle => \"../locales/en-US/middle.ftl\",\n     mir_dataflow => \"../locales/en-US/mir_dataflow.ftl\",\n     monomorphize => \"../locales/en-US/monomorphize.ftl\",\n-    parser => \"../locales/en-US/parser.ftl\",\n+    parse => \"../locales/en-US/parse.ftl\",\n     passes => \"../locales/en-US/passes.ftl\",\n     plugin_impl => \"../locales/en-US/plugin_impl.ftl\",\n     privacy => \"../locales/en-US/privacy.ftl\","}, {"sha": "bf20c7431e4ebf3c9049fe18419013d83876563a", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -248,7 +248,7 @@ pub trait Emitter: Translate {\n         fluent_args: &FluentArgs<'_>,\n     ) -> (MultiSpan, &'a [CodeSuggestion]) {\n         let mut primary_span = diag.span.clone();\n-        let suggestions = diag.suggestions.as_ref().map_or(&[][..], |suggestions| &suggestions[..]);\n+        let suggestions = diag.suggestions.as_deref().unwrap_or(&[]);\n         if let Some((sugg, rest)) = suggestions.split_first() {\n             let msg = self.translate_message(&sugg.msg, fluent_args);\n             if rest.is_empty() &&"}, {"sha": "2be36a6eeb4a25c55f32174be78fb93f47a90d50", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -467,6 +467,9 @@ pub enum StashKey {\n     /// When an invalid lifetime e.g. `'2` should be reinterpreted\n     /// as a char literal in the parser\n     LifetimeIsChar,\n+    /// Maybe there was a typo where a comma was forgotten before\n+    /// FRU syntax\n+    MaybeFruTypo,\n }\n \n fn default_track_diagnostic(_: &Diagnostic) {}\n@@ -1041,13 +1044,24 @@ impl Handler {\n     }\n     pub fn has_errors_or_lint_errors(&self) -> Option<ErrorGuaranteed> {\n         if self.inner.borrow().has_errors_or_lint_errors() {\n-            Some(ErrorGuaranteed(()))\n+            Some(ErrorGuaranteed::unchecked_claim_error_was_emitted())\n+        } else {\n+            None\n+        }\n+    }\n+    pub fn has_errors_or_delayed_span_bugs(&self) -> Option<ErrorGuaranteed> {\n+        if self.inner.borrow().has_errors_or_delayed_span_bugs() {\n+            Some(ErrorGuaranteed::unchecked_claim_error_was_emitted())\n         } else {\n             None\n         }\n     }\n-    pub fn has_errors_or_delayed_span_bugs(&self) -> bool {\n-        self.inner.borrow().has_errors_or_delayed_span_bugs()\n+    pub fn is_compilation_going_to_fail(&self) -> Option<ErrorGuaranteed> {\n+        if self.inner.borrow().is_compilation_going_to_fail() {\n+            Some(ErrorGuaranteed::unchecked_claim_error_was_emitted())\n+        } else {\n+            None\n+        }\n     }\n \n     pub fn print_error_count(&self, registry: &Registry) {\n@@ -1481,6 +1495,10 @@ impl HandlerInner {\n         self.err_count() > 0 || self.lint_err_count > 0 || self.warn_count > 0\n     }\n \n+    fn is_compilation_going_to_fail(&self) -> bool {\n+        self.has_errors() || self.lint_err_count > 0 || !self.delayed_span_bugs.is_empty()\n+    }\n+\n     fn abort_if_errors(&mut self) {\n         self.emit_stashed_diagnostics();\n "}, {"sha": "8955abebf1e0f0d116d100e84ba1f0b1e9c12e3d", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -507,7 +507,7 @@ impl MacResult for MacEager {\n             return Some(p);\n         }\n         if let Some(e) = self.expr {\n-            if let ast::ExprKind::Lit(_) = e.kind {\n+            if matches!(e.kind, ast::ExprKind::Lit(_) | ast::ExprKind::IncludedBytes(_)) {\n                 return Some(P(ast::Pat {\n                     id: ast::DUMMY_NODE_ID,\n                     span: e.span,\n@@ -676,8 +676,13 @@ pub enum SyntaxExtensionKind {\n \n     /// A token-based derive macro.\n     Derive(\n-        /// An expander with signature TokenStream -> TokenStream (not yet).\n+        /// An expander with signature TokenStream -> TokenStream.\n         /// The produced TokenSteam is appended to the input TokenSteam.\n+        ///\n+        /// FIXME: The text above describes how this should work. Currently it\n+        /// is handled identically to `LegacyDerive`. It should be migrated to\n+        /// a token-based representation like `Bang` and `Attr`, instead of\n+        /// using `MultiItemModifier`.\n         Box<dyn MultiItemModifier + sync::Sync + sync::Send>,\n     ),\n "}, {"sha": "c2b1b96cd646533da285458ac3c6dd661cbfe0fc", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -1,7 +1,7 @@\n use crate::base::*;\n use crate::config::StripUnconfigured;\n use crate::hygiene::SyntaxContext;\n-use crate::mbe::macro_rules::annotate_err_with_kind;\n+use crate::mbe::diagnostics::annotate_err_with_kind;\n use crate::module::{mod_dir_path, parse_external_mod, DirOwnership, ParsedExternalMod};\n use crate::placeholders::{placeholder, PlaceholderExpander};\n \n@@ -11,9 +11,9 @@ use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter};\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n-use rustc_ast::{AssocItemKind, AstNodeWrapper, AttrStyle, AttrVec, ExprKind, ForeignItemKind};\n-use rustc_ast::{HasAttrs, HasNodeId};\n-use rustc_ast::{Inline, ItemKind, MacArgs, MacStmtStyle, MetaItemKind, ModKind};\n+use rustc_ast::{AssocItemKind, AstNodeWrapper, AttrArgs, AttrStyle, AttrVec, ExprKind};\n+use rustc_ast::{ForeignItemKind, HasAttrs, HasNodeId};\n+use rustc_ast::{Inline, ItemKind, MacStmtStyle, MetaItemKind, ModKind};\n use rustc_ast::{NestedMetaItem, NodeId, PatKind, StmtKind, TyKind};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::map_in_place::MapInPlace;\n@@ -654,15 +654,15 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         ExpandResult::Ready(match invoc.kind {\n             InvocationKind::Bang { mac, .. } => match ext {\n                 SyntaxExtensionKind::Bang(expander) => {\n-                    let Ok(tok_result) = expander.expand(self.cx, span, mac.args.inner_tokens()) else {\n+                    let Ok(tok_result) = expander.expand(self.cx, span, mac.args.tokens.clone()) else {\n                         return ExpandResult::Ready(fragment_kind.dummy(span));\n                     };\n                     self.parse_ast_fragment(tok_result, fragment_kind, &mac.path, span)\n                 }\n                 SyntaxExtensionKind::LegacyBang(expander) => {\n                     let prev = self.cx.current_expansion.prior_type_ascription;\n                     self.cx.current_expansion.prior_type_ascription = mac.prior_type_ascription;\n-                    let tok_result = expander.expand(self.cx, span, mac.args.inner_tokens());\n+                    let tok_result = expander.expand(self.cx, span, mac.args.tokens.clone());\n                     let result = if let Some(result) = fragment_kind.make_from(tok_result) {\n                         result\n                     } else {\n@@ -706,7 +706,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         _ => item.to_tokens(),\n                     };\n                     let attr_item = attr.unwrap_normal_item();\n-                    if let MacArgs::Eq(..) = attr_item.args {\n+                    if let AttrArgs::Eq(..) = attr_item.args {\n                         self.cx.span_err(span, \"key-value macro attributes are not supported\");\n                     }\n                     let inner_tokens = attr_item.args.inner_tokens();"}, {"sha": "a43b2a001883a38d2cd0ff230b44c7831e7497b8", "filename": "compiler/rustc_expand/src/mbe.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -3,6 +3,7 @@\n //! why we call this module `mbe`. For external documentation, prefer the\n //! official terminology: \"declarative macros\".\n \n+pub(crate) mod diagnostics;\n pub(crate) mod macro_check;\n pub(crate) mod macro_parser;\n pub(crate) mod macro_rules;"}, {"sha": "197f056917f5de75171e64c73c238b82559b7315", "filename": "compiler/rustc_expand/src/mbe/diagnostics.rs", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -0,0 +1,257 @@\n+use std::borrow::Cow;\n+\n+use crate::base::{DummyResult, ExtCtxt, MacResult};\n+use crate::expand::{parse_ast_fragment, AstFragmentKind};\n+use crate::mbe::{\n+    macro_parser::{MatcherLoc, NamedParseResult, ParseResult::*, TtParser},\n+    macro_rules::{try_match_macro, Tracker},\n+};\n+use rustc_ast::token::{self, Token};\n+use rustc_ast::tokenstream::TokenStream;\n+use rustc_ast_pretty::pprust;\n+use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, DiagnosticMessage};\n+use rustc_parse::parser::{Parser, Recovery};\n+use rustc_span::source_map::SourceMap;\n+use rustc_span::symbol::Ident;\n+use rustc_span::Span;\n+\n+use super::macro_rules::{parser_from_cx, NoopTracker};\n+\n+pub(super) fn failed_to_match_macro<'cx>(\n+    cx: &'cx mut ExtCtxt<'_>,\n+    sp: Span,\n+    def_span: Span,\n+    name: Ident,\n+    arg: TokenStream,\n+    lhses: &[Vec<MatcherLoc>],\n+) -> Box<dyn MacResult + 'cx> {\n+    let sess = &cx.sess.parse_sess;\n+\n+    // An error occurred, try the expansion again, tracking the expansion closely for better diagnostics.\n+    let mut tracker = CollectTrackerAndEmitter::new(cx, sp);\n+\n+    let try_success_result = try_match_macro(sess, name, &arg, lhses, &mut tracker);\n+\n+    if try_success_result.is_ok() {\n+        // Nonterminal parser recovery might turn failed matches into successful ones,\n+        // but for that it must have emitted an error already\n+        tracker.cx.sess.delay_span_bug(sp, \"Macro matching returned a success on the second try\");\n+    }\n+\n+    if let Some(result) = tracker.result {\n+        // An irrecoverable error occurred and has been emitted.\n+        return result;\n+    }\n+\n+    let Some((token, label, remaining_matcher)) = tracker.best_failure else {\n+        return DummyResult::any(sp);\n+    };\n+\n+    let span = token.span.substitute_dummy(sp);\n+\n+    let mut err = cx.struct_span_err(span, &parse_failure_msg(&token));\n+    err.span_label(span, label);\n+    if !def_span.is_dummy() && !cx.source_map().is_imported(def_span) {\n+        err.span_label(cx.source_map().guess_head_span(def_span), \"when calling this macro\");\n+    }\n+\n+    annotate_doc_comment(&mut err, sess.source_map(), span);\n+\n+    if let Some(span) = remaining_matcher.span() {\n+        err.span_note(span, format!(\"while trying to match {remaining_matcher}\"));\n+    } else {\n+        err.note(format!(\"while trying to match {remaining_matcher}\"));\n+    }\n+\n+    // Check whether there's a missing comma in this macro call, like `println!(\"{}\" a);`\n+    if let Some((arg, comma_span)) = arg.add_comma() {\n+        for lhs in lhses {\n+            let parser = parser_from_cx(sess, arg.clone(), Recovery::Allowed);\n+            let mut tt_parser = TtParser::new(name);\n+\n+            if let Success(_) =\n+                tt_parser.parse_tt(&mut Cow::Borrowed(&parser), lhs, &mut NoopTracker)\n+            {\n+                if comma_span.is_dummy() {\n+                    err.note(\"you might be missing a comma\");\n+                } else {\n+                    err.span_suggestion_short(\n+                        comma_span,\n+                        \"missing comma here\",\n+                        \", \",\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+    err.emit();\n+    cx.trace_macros_diag();\n+    DummyResult::any(sp)\n+}\n+\n+/// The tracker used for the slow error path that collects useful info for diagnostics.\n+struct CollectTrackerAndEmitter<'a, 'cx, 'matcher> {\n+    cx: &'a mut ExtCtxt<'cx>,\n+    remaining_matcher: Option<&'matcher MatcherLoc>,\n+    /// Which arm's failure should we report? (the one furthest along)\n+    best_failure: Option<(Token, &'static str, MatcherLoc)>,\n+    root_span: Span,\n+    result: Option<Box<dyn MacResult + 'cx>>,\n+}\n+\n+impl<'a, 'cx, 'matcher> Tracker<'matcher> for CollectTrackerAndEmitter<'a, 'cx, 'matcher> {\n+    fn before_match_loc(&mut self, parser: &TtParser, matcher: &'matcher MatcherLoc) {\n+        if self.remaining_matcher.is_none()\n+            || (parser.has_no_remaining_items_for_step() && *matcher != MatcherLoc::Eof)\n+        {\n+            self.remaining_matcher = Some(matcher);\n+        }\n+    }\n+\n+    fn after_arm(&mut self, result: &NamedParseResult) {\n+        match result {\n+            Success(_) => {\n+                // Nonterminal parser recovery might turn failed matches into successful ones,\n+                // but for that it must have emitted an error already\n+                self.cx.sess.delay_span_bug(\n+                    self.root_span,\n+                    \"should not collect detailed info for successful macro match\",\n+                );\n+            }\n+            Failure(token, msg) => match self.best_failure {\n+                Some((ref best_token, _, _)) if best_token.span.lo() >= token.span.lo() => {}\n+                _ => {\n+                    self.best_failure = Some((\n+                        token.clone(),\n+                        msg,\n+                        self.remaining_matcher\n+                            .expect(\"must have collected matcher already\")\n+                            .clone(),\n+                    ))\n+                }\n+            },\n+            Error(err_sp, msg) => {\n+                let span = err_sp.substitute_dummy(self.root_span);\n+                self.cx.struct_span_err(span, msg).emit();\n+                self.result = Some(DummyResult::any(span));\n+            }\n+            ErrorReported(_) => self.result = Some(DummyResult::any(self.root_span)),\n+        }\n+    }\n+\n+    fn description() -> &'static str {\n+        \"detailed\"\n+    }\n+\n+    fn recovery() -> Recovery {\n+        Recovery::Allowed\n+    }\n+}\n+\n+impl<'a, 'cx> CollectTrackerAndEmitter<'a, 'cx, '_> {\n+    fn new(cx: &'a mut ExtCtxt<'cx>, root_span: Span) -> Self {\n+        Self { cx, remaining_matcher: None, best_failure: None, root_span, result: None }\n+    }\n+}\n+\n+pub(super) fn emit_frag_parse_err(\n+    mut e: DiagnosticBuilder<'_, rustc_errors::ErrorGuaranteed>,\n+    parser: &Parser<'_>,\n+    orig_parser: &mut Parser<'_>,\n+    site_span: Span,\n+    arm_span: Span,\n+    kind: AstFragmentKind,\n+) {\n+    // FIXME(davidtwco): avoid depending on the error message text\n+    if parser.token == token::Eof\n+        && let DiagnosticMessage::Str(message) = &e.message[0].0\n+        && message.ends_with(\", found `<eof>`\")\n+    {\n+        let msg = &e.message[0];\n+        e.message[0] = (\n+            DiagnosticMessage::Str(format!(\n+                \"macro expansion ends with an incomplete expression: {}\",\n+                message.replace(\", found `<eof>`\", \"\"),\n+            )),\n+            msg.1,\n+        );\n+        if !e.span.is_dummy() {\n+            // early end of macro arm (#52866)\n+            e.replace_span_with(parser.token.span.shrink_to_hi());\n+        }\n+    }\n+    if e.span.is_dummy() {\n+        // Get around lack of span in error (#30128)\n+        e.replace_span_with(site_span);\n+        if !parser.sess.source_map().is_imported(arm_span) {\n+            e.span_label(arm_span, \"in this macro arm\");\n+        }\n+    } else if parser.sess.source_map().is_imported(parser.token.span) {\n+        e.span_label(site_span, \"in this macro invocation\");\n+    }\n+    match kind {\n+        // Try a statement if an expression is wanted but failed and suggest adding `;` to call.\n+        AstFragmentKind::Expr => match parse_ast_fragment(orig_parser, AstFragmentKind::Stmts) {\n+            Err(err) => err.cancel(),\n+            Ok(_) => {\n+                e.note(\n+                    \"the macro call doesn't expand to an expression, but it can expand to a statement\",\n+                );\n+                e.span_suggestion_verbose(\n+                    site_span.shrink_to_hi(),\n+                    \"add `;` to interpret the expansion as a statement\",\n+                    \";\",\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+        },\n+        _ => annotate_err_with_kind(&mut e, kind, site_span),\n+    };\n+    e.emit();\n+}\n+\n+pub(crate) fn annotate_err_with_kind(err: &mut Diagnostic, kind: AstFragmentKind, span: Span) {\n+    match kind {\n+        AstFragmentKind::Ty => {\n+            err.span_label(span, \"this macro call doesn't expand to a type\");\n+        }\n+        AstFragmentKind::Pat => {\n+            err.span_label(span, \"this macro call doesn't expand to a pattern\");\n+        }\n+        _ => {}\n+    };\n+}\n+\n+#[derive(Subdiagnostic)]\n+enum ExplainDocComment {\n+    #[label(expand_explain_doc_comment_inner)]\n+    Inner {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[label(expand_explain_doc_comment_outer)]\n+    Outer {\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+pub(super) fn annotate_doc_comment(err: &mut Diagnostic, sm: &SourceMap, span: Span) {\n+    if let Ok(src) = sm.span_to_snippet(span) {\n+        if src.starts_with(\"///\") || src.starts_with(\"/**\") {\n+            err.subdiagnostic(ExplainDocComment::Outer { span });\n+        } else if src.starts_with(\"//!\") || src.starts_with(\"/*!\") {\n+            err.subdiagnostic(ExplainDocComment::Inner { span });\n+        }\n+    }\n+}\n+\n+/// Generates an appropriate parsing failure message. For EOF, this is \"unexpected end...\". For\n+/// other tokens, this is \"unexpected token...\".\n+pub(super) fn parse_failure_msg(tok: &Token) -> String {\n+    match tok.kind {\n+        token::Eof => \"unexpected end of macro invocation\".to_string(),\n+        _ => format!(\"no rules expected the token `{}`\", pprust::token_to_string(tok),),\n+    }\n+}"}, {"sha": "2dbb90e2190f0db42004859a03b5455d9995f19a", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 10, "deletions": 238, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -2,6 +2,7 @@ use crate::base::{DummyResult, ExtCtxt, MacResult, TTMacroExpander};\n use crate::base::{SyntaxExtension, SyntaxExtensionKind};\n use crate::expand::{ensure_complete_parse, parse_ast_fragment, AstFragment, AstFragmentKind};\n use crate::mbe;\n+use crate::mbe::diagnostics::{annotate_doc_comment, parse_failure_msg};\n use crate::mbe::macro_check;\n use crate::mbe::macro_parser::{Error, ErrorReported, Failure, Success, TtParser};\n use crate::mbe::macro_parser::{MatchedSeq, MatchedTokenTree, MatcherLoc};\n@@ -14,9 +15,7 @@ use rustc_ast::{NodeId, DUMMY_NODE_ID};\n use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, TransparencyError};\n use rustc_data_structures::fx::{FxHashMap, FxIndexMap};\n-use rustc_errors::{\n-    Applicability, Diagnostic, DiagnosticBuilder, DiagnosticMessage, ErrorGuaranteed,\n-};\n+use rustc_errors::{Applicability, ErrorGuaranteed};\n use rustc_feature::Features;\n use rustc_lint_defs::builtin::{\n     RUST_2021_INCOMPATIBLE_OR_PATTERNS, SEMICOLON_IN_EXPRESSIONS_FROM_MACROS,\n@@ -27,14 +26,14 @@ use rustc_session::parse::ParseSess;\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::Transparency;\n-use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym, Ident, MacroRulesNormalizedIdent};\n use rustc_span::Span;\n \n use std::borrow::Cow;\n use std::collections::hash_map::Entry;\n use std::{mem, slice};\n \n+use super::diagnostics;\n use super::macro_parser::{NamedMatches, NamedParseResult};\n \n pub(crate) struct ParserAnyMacro<'a> {\n@@ -51,74 +50,6 @@ pub(crate) struct ParserAnyMacro<'a> {\n     is_local: bool,\n }\n \n-pub(crate) fn annotate_err_with_kind(err: &mut Diagnostic, kind: AstFragmentKind, span: Span) {\n-    match kind {\n-        AstFragmentKind::Ty => {\n-            err.span_label(span, \"this macro call doesn't expand to a type\");\n-        }\n-        AstFragmentKind::Pat => {\n-            err.span_label(span, \"this macro call doesn't expand to a pattern\");\n-        }\n-        _ => {}\n-    };\n-}\n-\n-fn emit_frag_parse_err(\n-    mut e: DiagnosticBuilder<'_, rustc_errors::ErrorGuaranteed>,\n-    parser: &Parser<'_>,\n-    orig_parser: &mut Parser<'_>,\n-    site_span: Span,\n-    arm_span: Span,\n-    kind: AstFragmentKind,\n-) {\n-    // FIXME(davidtwco): avoid depending on the error message text\n-    if parser.token == token::Eof\n-        && let DiagnosticMessage::Str(message) = &e.message[0].0\n-        && message.ends_with(\", found `<eof>`\")\n-    {\n-        let msg = &e.message[0];\n-        e.message[0] = (\n-            DiagnosticMessage::Str(format!(\n-                \"macro expansion ends with an incomplete expression: {}\",\n-                message.replace(\", found `<eof>`\", \"\"),\n-            )),\n-            msg.1,\n-        );\n-        if !e.span.is_dummy() {\n-            // early end of macro arm (#52866)\n-            e.replace_span_with(parser.token.span.shrink_to_hi());\n-        }\n-    }\n-    if e.span.is_dummy() {\n-        // Get around lack of span in error (#30128)\n-        e.replace_span_with(site_span);\n-        if !parser.sess.source_map().is_imported(arm_span) {\n-            e.span_label(arm_span, \"in this macro arm\");\n-        }\n-    } else if parser.sess.source_map().is_imported(parser.token.span) {\n-        e.span_label(site_span, \"in this macro invocation\");\n-    }\n-    match kind {\n-        // Try a statement if an expression is wanted but failed and suggest adding `;` to call.\n-        AstFragmentKind::Expr => match parse_ast_fragment(orig_parser, AstFragmentKind::Stmts) {\n-            Err(err) => err.cancel(),\n-            Ok(_) => {\n-                e.note(\n-                    \"the macro call doesn't expand to an expression, but it can expand to a statement\",\n-                );\n-                e.span_suggestion_verbose(\n-                    site_span.shrink_to_hi(),\n-                    \"add `;` to interpret the expansion as a statement\",\n-                    \";\",\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-        },\n-        _ => annotate_err_with_kind(&mut e, kind, site_span),\n-    };\n-    e.emit();\n-}\n-\n impl<'a> ParserAnyMacro<'a> {\n     pub(crate) fn make(mut self: Box<ParserAnyMacro<'a>>, kind: AstFragmentKind) -> AstFragment {\n         let ParserAnyMacro {\n@@ -134,7 +65,7 @@ impl<'a> ParserAnyMacro<'a> {\n         let fragment = match parse_ast_fragment(parser, kind) {\n             Ok(f) => f,\n             Err(err) => {\n-                emit_frag_parse_err(err, parser, snapshot, site_span, arm_span, kind);\n+                diagnostics::emit_frag_parse_err(err, parser, snapshot, site_span, arm_span, kind);\n                 return kind.dummy(site_span);\n             }\n         };\n@@ -224,7 +155,7 @@ pub(super) trait Tracker<'matcher> {\n }\n \n /// A noop tracker that is used in the hot path of the expansion, has zero overhead thanks to monomorphization.\n-struct NoopTracker;\n+pub(super) struct NoopTracker;\n \n impl<'matcher> Tracker<'matcher> for NoopTracker {\n     fn before_match_loc(&mut self, _: &TtParser, _: &'matcher MatcherLoc) {}\n@@ -331,135 +262,10 @@ fn expand_macro<'cx>(\n         }\n     }\n \n-    // An error occurred, try the expansion again, tracking the expansion closely for better diagnostics.\n-    let mut tracker = CollectTrackerAndEmitter::new(cx, sp);\n-\n-    let try_success_result = try_match_macro(sess, name, &arg, lhses, &mut tracker);\n-\n-    if try_success_result.is_ok() {\n-        // Nonterminal parser recovery might turn failed matches into successful ones,\n-        // but for that it must have emitted an error already\n-        tracker.cx.sess.delay_span_bug(sp, \"Macro matching returned a success on the second try\");\n-    }\n-\n-    if let Some(result) = tracker.result {\n-        // An irrecoverable error occurred and has been emitted.\n-        return result;\n-    }\n-\n-    let Some((token, label, remaining_matcher)) = tracker.best_failure else {\n-        return DummyResult::any(sp);\n-    };\n-\n-    let span = token.span.substitute_dummy(sp);\n-\n-    let mut err = cx.struct_span_err(span, &parse_failure_msg(&token));\n-    err.span_label(span, label);\n-    if !def_span.is_dummy() && !cx.source_map().is_imported(def_span) {\n-        err.span_label(cx.source_map().guess_head_span(def_span), \"when calling this macro\");\n-    }\n-\n-    annotate_doc_comment(&mut err, sess.source_map(), span);\n-\n-    if let Some(span) = remaining_matcher.span() {\n-        err.span_note(span, format!(\"while trying to match {remaining_matcher}\"));\n-    } else {\n-        err.note(format!(\"while trying to match {remaining_matcher}\"));\n-    }\n-\n-    // Check whether there's a missing comma in this macro call, like `println!(\"{}\" a);`\n-    if let Some((arg, comma_span)) = arg.add_comma() {\n-        for lhs in lhses {\n-            let parser = parser_from_cx(sess, arg.clone(), Recovery::Allowed);\n-            let mut tt_parser = TtParser::new(name);\n-\n-            if let Success(_) =\n-                tt_parser.parse_tt(&mut Cow::Borrowed(&parser), lhs, &mut NoopTracker)\n-            {\n-                if comma_span.is_dummy() {\n-                    err.note(\"you might be missing a comma\");\n-                } else {\n-                    err.span_suggestion_short(\n-                        comma_span,\n-                        \"missing comma here\",\n-                        \", \",\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-        }\n-    }\n-    err.emit();\n-    cx.trace_macros_diag();\n-    DummyResult::any(sp)\n+    diagnostics::failed_to_match_macro(cx, sp, def_span, name, arg, lhses)\n }\n \n-/// The tracker used for the slow error path that collects useful info for diagnostics.\n-struct CollectTrackerAndEmitter<'a, 'cx, 'matcher> {\n-    cx: &'a mut ExtCtxt<'cx>,\n-    remaining_matcher: Option<&'matcher MatcherLoc>,\n-    /// Which arm's failure should we report? (the one furthest along)\n-    best_failure: Option<(Token, &'static str, MatcherLoc)>,\n-    root_span: Span,\n-    result: Option<Box<dyn MacResult + 'cx>>,\n-}\n-\n-impl<'a, 'cx, 'matcher> Tracker<'matcher> for CollectTrackerAndEmitter<'a, 'cx, 'matcher> {\n-    fn before_match_loc(&mut self, parser: &TtParser, matcher: &'matcher MatcherLoc) {\n-        if self.remaining_matcher.is_none()\n-            || (parser.has_no_remaining_items_for_step() && *matcher != MatcherLoc::Eof)\n-        {\n-            self.remaining_matcher = Some(matcher);\n-        }\n-    }\n-\n-    fn after_arm(&mut self, result: &NamedParseResult) {\n-        match result {\n-            Success(_) => {\n-                // Nonterminal parser recovery might turn failed matches into successful ones,\n-                // but for that it must have emitted an error already\n-                self.cx.sess.delay_span_bug(\n-                    self.root_span,\n-                    \"should not collect detailed info for successful macro match\",\n-                );\n-            }\n-            Failure(token, msg) => match self.best_failure {\n-                Some((ref best_token, _, _)) if best_token.span.lo() >= token.span.lo() => {}\n-                _ => {\n-                    self.best_failure = Some((\n-                        token.clone(),\n-                        msg,\n-                        self.remaining_matcher\n-                            .expect(\"must have collected matcher already\")\n-                            .clone(),\n-                    ))\n-                }\n-            },\n-            Error(err_sp, msg) => {\n-                let span = err_sp.substitute_dummy(self.root_span);\n-                self.cx.struct_span_err(span, msg).emit();\n-                self.result = Some(DummyResult::any(span));\n-            }\n-            ErrorReported(_) => self.result = Some(DummyResult::any(self.root_span)),\n-        }\n-    }\n-\n-    fn description() -> &'static str {\n-        \"detailed\"\n-    }\n-\n-    fn recovery() -> Recovery {\n-        Recovery::Allowed\n-    }\n-}\n-\n-impl<'a, 'cx> CollectTrackerAndEmitter<'a, 'cx, '_> {\n-    fn new(cx: &'a mut ExtCtxt<'cx>, root_span: Span) -> Self {\n-        Self { cx, remaining_matcher: None, best_failure: None, root_span, result: None }\n-    }\n-}\n-\n-enum CanRetry {\n+pub(super) enum CanRetry {\n     Yes,\n     /// We are not allowed to retry macro expansion as a fatal error has been emitted already.\n     No(ErrorGuaranteed),\n@@ -469,7 +275,7 @@ enum CanRetry {\n /// and nothing if it failed. On failure, it's the callers job to use `track` accordingly to record all errors\n /// correctly.\n #[instrument(level = \"debug\", skip(sess, arg, lhses, track), fields(tracking = %T::description()))]\n-fn try_match_macro<'matcher, T: Tracker<'matcher>>(\n+pub(super) fn try_match_macro<'matcher, T: Tracker<'matcher>>(\n     sess: &ParseSess,\n     name: Ident,\n     arg: &TokenStream,\n@@ -495,7 +301,6 @@ fn try_match_macro<'matcher, T: Tracker<'matcher>>(\n     // hacky, but speeds up the `html5ever` benchmark significantly. (Issue\n     // 68836 suggests a more comprehensive but more complex change to deal with\n     // this situation.)\n-    // FIXME(Nilstrieb): Stop recovery from happening on this parser and retry later with recovery if the macro failed to match.\n     let parser = parser_from_cx(sess, arg.clone(), T::recovery());\n     // Try each arm's matchers.\n     let mut tt_parser = TtParser::new(name);\n@@ -578,7 +383,7 @@ pub fn compile_declarative_macro(\n \n     // Parse the macro_rules! invocation\n     let (macro_rules, body) = match &def.kind {\n-        ast::ItemKind::MacroDef(def) => (def.macro_rules, def.body.inner_tokens()),\n+        ast::ItemKind::MacroDef(def) => (def.macro_rules, def.body.tokens.clone()),\n         _ => unreachable!(),\n     };\n \n@@ -770,30 +575,6 @@ pub fn compile_declarative_macro(\n     (mk_syn_ext(expander), rule_spans)\n }\n \n-#[derive(Subdiagnostic)]\n-enum ExplainDocComment {\n-    #[label(expand_explain_doc_comment_inner)]\n-    Inner {\n-        #[primary_span]\n-        span: Span,\n-    },\n-    #[label(expand_explain_doc_comment_outer)]\n-    Outer {\n-        #[primary_span]\n-        span: Span,\n-    },\n-}\n-\n-fn annotate_doc_comment(err: &mut Diagnostic, sm: &SourceMap, span: Span) {\n-    if let Ok(src) = sm.span_to_snippet(span) {\n-        if src.starts_with(\"///\") || src.starts_with(\"/**\") {\n-            err.subdiagnostic(ExplainDocComment::Outer { span });\n-        } else if src.starts_with(\"//!\") || src.starts_with(\"/*!\") {\n-            err.subdiagnostic(ExplainDocComment::Inner { span });\n-        }\n-    }\n-}\n-\n fn check_lhs_nt_follows(sess: &ParseSess, def: &ast::Item, lhs: &mbe::TokenTree) -> bool {\n     // lhs is going to be like TokenTree::Delimited(...), where the\n     // entire lhs is those tts. Or, it can be a \"bare sequence\", not wrapped in parens.\n@@ -1578,15 +1359,6 @@ fn quoted_tt_to_string(tt: &mbe::TokenTree) -> String {\n     }\n }\n \n-fn parser_from_cx(sess: &ParseSess, tts: TokenStream, recovery: Recovery) -> Parser<'_> {\n+pub(super) fn parser_from_cx(sess: &ParseSess, tts: TokenStream, recovery: Recovery) -> Parser<'_> {\n     Parser::new(sess, tts, true, rustc_parse::MACRO_ARGUMENTS).recovery(recovery)\n }\n-\n-/// Generates an appropriate parsing failure message. For EOF, this is \"unexpected end...\". For\n-/// other tokens, this is \"unexpected token...\".\n-fn parse_failure_msg(tok: &Token) -> String {\n-    match tok.kind {\n-        token::Eof => \"unexpected end of macro invocation\".to_string(),\n-        _ => format!(\"no rules expected the token `{}`\", pprust::token_to_string(tok),),\n-    }\n-}"}, {"sha": "e49f112bf20a69a2ec01c6d29f346ae9504d3d47", "filename": "compiler/rustc_expand/src/parse/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -291,7 +291,7 @@ fn ttdelim_span() {\n         .unwrap();\n \n         let tts: Vec<_> = match expr.kind {\n-            ast::ExprKind::MacCall(ref mac) => mac.args.inner_tokens().into_trees().collect(),\n+            ast::ExprKind::MacCall(ref mac) => mac.args.tokens.clone().into_trees().collect(),\n             _ => panic!(\"not a macro\"),\n         };\n "}, {"sha": "03bb5c1dfe45fbe9b2bdba1317858280237a0783", "filename": "compiler/rustc_expand/src/placeholders.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -16,7 +16,11 @@ pub fn placeholder(\n     fn mac_placeholder() -> P<ast::MacCall> {\n         P(ast::MacCall {\n             path: ast::Path { span: DUMMY_SP, segments: ThinVec::new(), tokens: None },\n-            args: P(ast::MacArgs::Empty),\n+            args: P(ast::DelimArgs {\n+                dspan: ast::tokenstream::DelimSpan::dummy(),\n+                delim: ast::MacDelimiter::Parenthesis,\n+                tokens: ast::tokenstream::TokenStream::new(Vec::new()),\n+            }),\n             prior_type_ascription: None,\n         })\n     }"}, {"sha": "9ca63c393c623746524833e90ca58d1362c338a6", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -419,6 +419,8 @@ declare_features! (\n     (active, if_let_guard, \"1.47.0\", Some(51114), None),\n     /// Allows `impl Trait` as output type in `Fn` traits in return position of functions.\n     (active, impl_trait_in_fn_trait_return, \"1.64.0\", Some(99697), None),\n+    /// Allows referencing `Self` and projections in impl-trait.\n+    (active, impl_trait_projections, \"CURRENT_RUSTC_VERSION\", Some(103532), None),\n     /// Allows using imported `main` function\n     (active, imported_main, \"1.53.0\", Some(28937), None),\n     /// Allows associated types in inherent impls.\n@@ -506,6 +508,8 @@ declare_features! (\n     (active, stmt_expr_attributes, \"1.6.0\", Some(15701), None),\n     /// Allows lints part of the strict provenance effort.\n     (active, strict_provenance, \"1.61.0\", Some(95228), None),\n+    /// Allows string patterns to dereference values to match them.\n+    (active, string_deref_patterns, \"CURRENT_RUSTC_VERSION\", Some(87121), None),\n     /// Allows the use of `#[target_feature]` on safe functions.\n     (active, target_feature_11, \"1.45.0\", Some(69098), None),\n     /// Allows using `#[thread_local]` on `static` items."}, {"sha": "149cf4ece37d154613cd4bc44245ca60f2f73cd6", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -28,8 +28,6 @@ pub enum CtorKind {\n     Fn,\n     /// Constructor constant automatically created by a unit struct/variant.\n     Const,\n-    /// Unusable name in value namespace created by a struct variant.\n-    Fictive,\n }\n \n /// An attribute that is not a macro; e.g., `#[inline]` or `#[rustfmt::skip]`.\n@@ -132,13 +130,9 @@ impl DefKind {\n             DefKind::Variant => \"variant\",\n             DefKind::Ctor(CtorOf::Variant, CtorKind::Fn) => \"tuple variant\",\n             DefKind::Ctor(CtorOf::Variant, CtorKind::Const) => \"unit variant\",\n-            DefKind::Ctor(CtorOf::Variant, CtorKind::Fictive) => \"struct variant\",\n             DefKind::Struct => \"struct\",\n             DefKind::Ctor(CtorOf::Struct, CtorKind::Fn) => \"tuple struct\",\n             DefKind::Ctor(CtorOf::Struct, CtorKind::Const) => \"unit struct\",\n-            DefKind::Ctor(CtorOf::Struct, CtorKind::Fictive) => {\n-                panic!(\"impossible struct constructor\")\n-            }\n             DefKind::OpaqueTy => \"opaque type\",\n             DefKind::ImplTraitPlaceholder => \"opaque type in trait\",\n             DefKind::TyAlias => \"type alias\",\n@@ -562,19 +556,11 @@ impl<T> PerNS<Option<T>> {\n }\n \n impl CtorKind {\n-    pub fn from_ast(vdata: &ast::VariantData) -> CtorKind {\n-        match *vdata {\n-            ast::VariantData::Tuple(..) => CtorKind::Fn,\n-            ast::VariantData::Unit(..) => CtorKind::Const,\n-            ast::VariantData::Struct(..) => CtorKind::Fictive,\n-        }\n-    }\n-\n-    pub fn from_hir(vdata: &hir::VariantData<'_>) -> CtorKind {\n+    pub fn from_ast(vdata: &ast::VariantData) -> Option<(CtorKind, NodeId)> {\n         match *vdata {\n-            hir::VariantData::Tuple(..) => CtorKind::Fn,\n-            hir::VariantData::Unit(..) => CtorKind::Const,\n-            hir::VariantData::Struct(..) => CtorKind::Fictive,\n+            ast::VariantData::Tuple(_, node_id) => Some((CtorKind::Fn, node_id)),\n+            ast::VariantData::Unit(node_id) => Some((CtorKind::Const, node_id)),\n+            ast::VariantData::Struct(..) => None,\n         }\n     }\n }"}, {"sha": "208d2fb42e42d7690205560fd3a7e7ee7dbf5dd7", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 89, "deletions": 59, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -29,15 +29,16 @@ use std::fmt;\n #[derive(Debug, Copy, Clone, Encodable, HashStable_Generic)]\n pub struct Lifetime {\n     pub hir_id: HirId,\n-    pub span: Span,\n \n     /// Either \"`'a`\", referring to a named lifetime definition,\n-    /// or \"``\" (i.e., `kw::Empty`), for elision placeholders.\n+    /// `'_` referring to an anonymous lifetime (either explicitly `'_` or `&type`),\n+    /// or \"``\" (i.e., `kw::Empty`) when appearing in path.\n     ///\n-    /// HIR lowering inserts these placeholders in type paths that\n-    /// refer to type definitions needing lifetime parameters,\n-    /// `&T` and `&mut T`, and trait objects without `... + 'a`.\n-    pub name: LifetimeName,\n+    /// See `Lifetime::suggestion_position` for practical use.\n+    pub ident: Ident,\n+\n+    /// Semantics of this lifetime.\n+    pub res: LifetimeName,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Encodable, Hash, Copy)]\n@@ -88,7 +89,7 @@ impl ParamName {\n #[derive(HashStable_Generic)]\n pub enum LifetimeName {\n     /// User-given names or fresh (synthetic) names.\n-    Param(LocalDefId, ParamName),\n+    Param(LocalDefId),\n \n     /// Implicit lifetime in a context like `dyn Foo`. This is\n     /// distinguished from implicit lifetimes elsewhere because the\n@@ -116,25 +117,6 @@ pub enum LifetimeName {\n }\n \n impl LifetimeName {\n-    pub fn ident(&self) -> Ident {\n-        match *self {\n-            LifetimeName::ImplicitObjectLifetimeDefault | LifetimeName::Error => Ident::empty(),\n-            LifetimeName::Infer => Ident::with_dummy_span(kw::UnderscoreLifetime),\n-            LifetimeName::Static => Ident::with_dummy_span(kw::StaticLifetime),\n-            LifetimeName::Param(_, param_name) => param_name.ident(),\n-        }\n-    }\n-\n-    pub fn is_anonymous(&self) -> bool {\n-        match *self {\n-            LifetimeName::ImplicitObjectLifetimeDefault\n-            | LifetimeName::Infer\n-            | LifetimeName::Param(_, ParamName::Fresh)\n-            | LifetimeName::Error => true,\n-            LifetimeName::Static | LifetimeName::Param(..) => false,\n-        }\n-    }\n-\n     pub fn is_elided(&self) -> bool {\n         match self {\n             LifetimeName::ImplicitObjectLifetimeDefault | LifetimeName::Infer => true,\n@@ -146,34 +128,54 @@ impl LifetimeName {\n             LifetimeName::Error | LifetimeName::Param(..) | LifetimeName::Static => false,\n         }\n     }\n-\n-    fn is_static(&self) -> bool {\n-        self == &LifetimeName::Static\n-    }\n-\n-    pub fn normalize_to_macros_2_0(&self) -> LifetimeName {\n-        match *self {\n-            LifetimeName::Param(def_id, param_name) => {\n-                LifetimeName::Param(def_id, param_name.normalize_to_macros_2_0())\n-            }\n-            lifetime_name => lifetime_name,\n-        }\n-    }\n }\n \n impl fmt::Display for Lifetime {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.name.ident().fmt(f)\n+        if self.ident.name != kw::Empty { self.ident.name.fmt(f) } else { \"'_\".fmt(f) }\n     }\n }\n \n+pub enum LifetimeSuggestionPosition {\n+    /// The user wrote `'a` or `'_`.\n+    Normal,\n+    /// The user wrote `&type` or `&mut type`.\n+    Ampersand,\n+    /// The user wrote `Path` and omitted the `<'_>`.\n+    ElidedPath,\n+    /// The user wrote `Path<T>`, and omitted the `'_,`.\n+    ElidedPathArgument,\n+    /// The user wrote `dyn Trait` and omitted the `+ '_`.\n+    ObjectDefault,\n+}\n+\n impl Lifetime {\n     pub fn is_elided(&self) -> bool {\n-        self.name.is_elided()\n+        self.res.is_elided()\n+    }\n+\n+    pub fn is_anonymous(&self) -> bool {\n+        self.ident.name == kw::Empty || self.ident.name == kw::UnderscoreLifetime\n+    }\n+\n+    pub fn suggestion_position(&self) -> (LifetimeSuggestionPosition, Span) {\n+        if self.ident.name == kw::Empty {\n+            if self.ident.span.is_empty() {\n+                (LifetimeSuggestionPosition::ElidedPathArgument, self.ident.span)\n+            } else {\n+                (LifetimeSuggestionPosition::ElidedPath, self.ident.span.shrink_to_hi())\n+            }\n+        } else if self.res == LifetimeName::ImplicitObjectLifetimeDefault {\n+            (LifetimeSuggestionPosition::ObjectDefault, self.ident.span)\n+        } else if self.ident.span.is_empty() {\n+            (LifetimeSuggestionPosition::Ampersand, self.ident.span)\n+        } else {\n+            (LifetimeSuggestionPosition::Normal, self.ident.span)\n+        }\n     }\n \n     pub fn is_static(&self) -> bool {\n-        self.name.is_static()\n+        self.res == LifetimeName::Static\n     }\n }\n \n@@ -267,7 +269,7 @@ pub enum GenericArg<'hir> {\n impl GenericArg<'_> {\n     pub fn span(&self) -> Span {\n         match self {\n-            GenericArg::Lifetime(l) => l.span,\n+            GenericArg::Lifetime(l) => l.ident.span,\n             GenericArg::Type(t) => t.span,\n             GenericArg::Const(c) => c.span,\n             GenericArg::Infer(i) => i.span,\n@@ -284,7 +286,7 @@ impl GenericArg<'_> {\n     }\n \n     pub fn is_synthetic(&self) -> bool {\n-        matches!(self, GenericArg::Lifetime(lifetime) if lifetime.name.ident() == Ident::empty())\n+        matches!(self, GenericArg::Lifetime(lifetime) if lifetime.ident == Ident::empty())\n     }\n \n     pub fn descr(&self) -> &'static str {\n@@ -446,7 +448,7 @@ impl GenericBound<'_> {\n         match self {\n             GenericBound::Trait(t, ..) => t.span,\n             GenericBound::LangItemTrait(_, span, ..) => *span,\n-            GenericBound::Outlives(l) => l.span,\n+            GenericBound::Outlives(l) => l.ident.span,\n         }\n     }\n }\n@@ -559,6 +561,19 @@ impl<'hir> Generics<'hir> {\n         }\n     }\n \n+    /// If there are generic parameters, return where to introduce a new one.\n+    pub fn span_for_lifetime_suggestion(&self) -> Option<Span> {\n+        if let Some(first) = self.params.first()\n+            && self.span.contains(first.span)\n+        {\n+            // `fn foo<A>(t: impl Trait)`\n+            //         ^ suggest `'a, ` here\n+            Some(first.span.shrink_to_lo())\n+        } else {\n+            None\n+        }\n+    }\n+\n     /// If there are generic parameters, return where to introduce a new one.\n     pub fn span_for_param_suggestion(&self) -> Option<Span> {\n         if self.params.iter().any(|p| self.span.contains(p.span)) {\n@@ -765,10 +780,7 @@ pub struct WhereRegionPredicate<'hir> {\n impl<'hir> WhereRegionPredicate<'hir> {\n     /// Returns `true` if `param_def_id` matches the `lifetime` of this predicate.\n     pub fn is_param_bound(&self, param_def_id: LocalDefId) -> bool {\n-        match self.lifetime.name {\n-            LifetimeName::Param(id, _) => id == param_def_id,\n-            _ => false,\n-        }\n+        self.lifetime.res == LifetimeName::Param(param_def_id)\n     }\n }\n \n@@ -2688,6 +2700,8 @@ pub struct FnDecl<'hir> {\n     pub c_variadic: bool,\n     /// Does the function have an implicit self?\n     pub implicit_self: ImplicitSelfKind,\n+    /// Is lifetime elision allowed.\n+    pub lifetime_elision_allowed: bool,\n }\n \n /// Represents what type of implicit self a function has, if any.\n@@ -2913,20 +2927,29 @@ impl<'hir> VariantData<'hir> {\n         }\n     }\n \n-    /// Return the `LocalDefId` of this variant's constructor, if it has one.\n-    pub fn ctor_def_id(&self) -> Option<LocalDefId> {\n+    pub fn ctor(&self) -> Option<(CtorKind, HirId, LocalDefId)> {\n         match *self {\n-            VariantData::Struct(_, _) => None,\n-            VariantData::Tuple(_, _, def_id) | VariantData::Unit(_, def_id) => Some(def_id),\n+            VariantData::Tuple(_, hir_id, def_id) => Some((CtorKind::Fn, hir_id, def_id)),\n+            VariantData::Unit(hir_id, def_id) => Some((CtorKind::Const, hir_id, def_id)),\n+            VariantData::Struct(..) => None,\n         }\n     }\n \n+    #[inline]\n+    pub fn ctor_kind(&self) -> Option<CtorKind> {\n+        self.ctor().map(|(kind, ..)| kind)\n+    }\n+\n     /// Return the `HirId` of this variant's constructor, if it has one.\n+    #[inline]\n     pub fn ctor_hir_id(&self) -> Option<HirId> {\n-        match *self {\n-            VariantData::Struct(_, _) => None,\n-            VariantData::Tuple(_, hir_id, _) | VariantData::Unit(hir_id, _) => Some(hir_id),\n-        }\n+        self.ctor().map(|(_, hir_id, _)| hir_id)\n+    }\n+\n+    /// Return the `LocalDefId` of this variant's constructor, if it has one.\n+    #[inline]\n+    pub fn ctor_def_id(&self) -> Option<LocalDefId> {\n+        self.ctor().map(|(.., def_id)| def_id)\n     }\n }\n \n@@ -3444,7 +3467,7 @@ impl<'hir> Node<'hir> {\n             | Node::Variant(Variant { ident, .. })\n             | Node::Item(Item { ident, .. })\n             | Node::PathSegment(PathSegment { ident, .. }) => Some(*ident),\n-            Node::Lifetime(lt) => Some(lt.name.ident()),\n+            Node::Lifetime(lt) => Some(lt.ident),\n             Node::GenericParam(p) => Some(p.name.ident()),\n             Node::TypeBinding(b) => Some(b.ident),\n             Node::Param(..)\n@@ -3585,9 +3608,16 @@ mod size_asserts {\n     static_assert_size!(Res, 12);\n     static_assert_size!(Stmt<'_>, 32);\n     static_assert_size!(StmtKind<'_>, 16);\n+    // tidy-alphabetical-end\n+    // FIXME: move the tidy directive to the end after the next bootstrap bump\n+    #[cfg(bootstrap)]\n     static_assert_size!(TraitItem<'_>, 88);\n+    #[cfg(not(bootstrap))]\n+    static_assert_size!(TraitItem<'_>, 80);\n+    #[cfg(bootstrap)]\n     static_assert_size!(TraitItemKind<'_>, 48);\n+    #[cfg(not(bootstrap))]\n+    static_assert_size!(TraitItemKind<'_>, 40);\n     static_assert_size!(Ty<'_>, 48);\n     static_assert_size!(TyKind<'_>, 32);\n-    // tidy-alphabetical-end\n }"}, {"sha": "33f02a115ef38639019453ff23630ed239863ef3", "filename": "compiler/rustc_hir/src/hir_id.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -1,4 +1,4 @@\n-use crate::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n+use crate::def_id::{DefId, DefIndex, LocalDefId, CRATE_DEF_ID};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n use rustc_span::{def_id::DefPathHash, HashStableContext};\n use std::fmt;\n@@ -22,6 +22,18 @@ impl OwnerId {\n     }\n }\n \n+impl rustc_index::vec::Idx for OwnerId {\n+    #[inline]\n+    fn new(idx: usize) -> Self {\n+        OwnerId { def_id: LocalDefId { local_def_index: DefIndex::from_usize(idx) } }\n+    }\n+\n+    #[inline]\n+    fn index(self) -> usize {\n+        self.def_id.local_def_index.as_usize()\n+    }\n+}\n+\n impl<CTX: HashStableContext> HashStable<CTX> for OwnerId {\n     #[inline]\n     fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {"}, {"sha": "957f8c1058e9869a63561a8c0b776f50ac42facb", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -1109,17 +1109,7 @@ pub fn walk_generic_arg<'v, V: Visitor<'v>>(visitor: &mut V, generic_arg: &'v Ge\n \n pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime) {\n     visitor.visit_id(lifetime.hir_id);\n-    match lifetime.name {\n-        LifetimeName::Param(_, ParamName::Plain(ident)) => {\n-            visitor.visit_ident(ident);\n-        }\n-        LifetimeName::Param(_, ParamName::Fresh)\n-        | LifetimeName::Param(_, ParamName::Error)\n-        | LifetimeName::Static\n-        | LifetimeName::Error\n-        | LifetimeName::ImplicitObjectLifetimeDefault\n-        | LifetimeName::Infer => {}\n-    }\n+    visitor.visit_ident(lifetime.ident);\n }\n \n pub fn walk_qpath<'v, V: Visitor<'v>>(visitor: &mut V, qpath: &'v QPath<'v>, id: HirId) {"}, {"sha": "038509031b180a3cd42417a23846ff36c00ea7c0", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -280,10 +280,14 @@ language_item_table! {\n \n     PointerSized,            sym::pointer_sized,       pointer_sized,              Target::Trait,          GenericRequirement::Exact(0);\n \n+    Poll,                    sym::Poll,                poll,                       Target::Enum,           GenericRequirement::None;\n     PollReady,               sym::Ready,               poll_ready_variant,         Target::Variant,        GenericRequirement::None;\n     PollPending,             sym::Pending,             poll_pending_variant,       Target::Variant,        GenericRequirement::None;\n \n-    FromGenerator,           sym::from_generator,      from_generator_fn,          Target::Fn,             GenericRequirement::None;\n+    // FIXME(swatinem): the following lang items are used for async lowering and\n+    // should become obsolete eventually.\n+    ResumeTy,                sym::ResumeTy,            resume_ty,                  Target::Struct,         GenericRequirement::None;\n+    IdentityFuture,          sym::identity_future,     identity_future_fn,         Target::Fn,             GenericRequirement::None;\n     GetContext,              sym::get_context,         get_context_fn,             Target::Fn,             GenericRequirement::None;\n \n     FuturePoll,              sym::poll,                future_poll_fn,             Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n@@ -312,6 +316,8 @@ language_item_table! {\n     Range,                   sym::Range,               range_struct,               Target::Struct,         GenericRequirement::None;\n     RangeToInclusive,        sym::RangeToInclusive,    range_to_inclusive_struct,  Target::Struct,         GenericRequirement::None;\n     RangeTo,                 sym::RangeTo,             range_to_struct,            Target::Struct,         GenericRequirement::None;\n+\n+    String,                  sym::String,              string,                     Target::Struct,         GenericRequirement::None;\n }\n \n pub enum GenericRequirement {"}, {"sha": "98d967cc0b86e1446b3b1b469b580273c565a78f", "filename": "compiler/rustc_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flib.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -5,6 +5,7 @@\n #![feature(associated_type_defaults)]\n #![feature(closure_track_caller)]\n #![feature(const_btree_len)]\n+#![feature(let_chains)]\n #![feature(min_specialization)]\n #![feature(never_type)]\n #![feature(rustc_attrs)]"}, {"sha": "6e2fbf96cbfb3f26aabf1eb23901dffc687d68d8", "filename": "compiler/rustc_hir/src/pat_util.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -130,10 +130,7 @@ impl hir::Pat<'_> {\n     pub fn contains_explicit_ref_binding(&self) -> Option<hir::Mutability> {\n         let mut result = None;\n         self.each_binding(|annotation, _, _, _| match annotation {\n-            hir::BindingAnnotation::REF => match result {\n-                None | Some(hir::Mutability::Not) => result = Some(hir::Mutability::Not),\n-                _ => {}\n-            },\n+            hir::BindingAnnotation::REF if result.is_none() => result = Some(hir::Mutability::Not),\n             hir::BindingAnnotation::REF_MUT => result = Some(hir::Mutability::Mut),\n             _ => {}\n         });"}, {"sha": "90469227a26c8e7cc7117a82e3361688a3bc0d7f", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 14, "deletions": 36, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -241,14 +241,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n \n             None => {\n-                self.re_infer(def, lifetime.span).unwrap_or_else(|| {\n+                self.re_infer(def, lifetime.ident.span).unwrap_or_else(|| {\n                     debug!(?lifetime, \"unelided lifetime in signature\");\n \n                     // This indicates an illegal lifetime\n                     // elision. `resolve_lifetime` should have\n                     // reported an error in this case -- but if\n                     // not, let's error out.\n-                    tcx.sess.delay_span_bug(lifetime.span, \"unelided lifetime in signature\");\n+                    tcx.sess.delay_span_bug(lifetime.ident.span, \"unelided lifetime in signature\");\n \n                     // Supply some dummy value. We don't have an\n                     // `re_error`, annoyingly, so use `'static`.\n@@ -961,9 +961,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 }\n                 hir::GenericBound::Outlives(lifetime) => {\n                     let region = self.ast_region_to_region(lifetime, None);\n-                    bounds\n-                        .region_bounds\n-                        .push((ty::Binder::bind_with_vars(region, bound_vars), lifetime.span));\n+                    bounds.region_bounds.push((\n+                        ty::Binder::bind_with_vars(region, bound_vars),\n+                        lifetime.ident.span,\n+                    ));\n                 }\n             }\n         }\n@@ -1378,7 +1379,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n                 let bound_predicate = obligation.predicate.kind();\n                 match bound_predicate.skip_binder() {\n-                    ty::PredicateKind::Trait(pred) => {\n+                    ty::PredicateKind::Clause(ty::Clause::Trait(pred)) => {\n                         let pred = bound_predicate.rebind(pred);\n                         associated_types.entry(span).or_default().extend(\n                             tcx.associated_items(pred.def_id())\n@@ -1387,7 +1388,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                 .map(|item| item.def_id),\n                         );\n                     }\n-                    ty::PredicateKind::Projection(pred) => {\n+                    ty::PredicateKind::Clause(ty::Clause::Projection(pred)) => {\n                         let pred = bound_predicate.rebind(pred);\n                         // A `Self` within the original bound will be substituted with a\n                         // `trait_object_dummy_self`, so check for that.\n@@ -2777,35 +2778,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let substs = InternalSubsts::for_item(tcx, def_id, |param, _| {\n             if let Some(i) = (param.index as usize).checked_sub(generics.parent_count) {\n                 // Our own parameters are the resolved lifetimes.\n-                if let GenericParamDefKind::Lifetime = param.kind {\n-                    if let hir::GenericArg::Lifetime(lifetime) = &lifetimes[i] {\n-                        self.ast_region_to_region(lifetime, None).into()\n-                    } else {\n-                        bug!()\n-                    }\n-                } else {\n-                    bug!()\n-                }\n+                let GenericParamDefKind::Lifetime { .. } = param.kind else { bug!() };\n+                let hir::GenericArg::Lifetime(lifetime) = &lifetimes[i] else { bug!() };\n+                self.ast_region_to_region(lifetime, None).into()\n             } else {\n-                match param.kind {\n-                    // For RPIT (return position impl trait), only lifetimes\n-                    // mentioned in the impl Trait predicate are captured by\n-                    // the opaque type, so the lifetime parameters from the\n-                    // parent item need to be replaced with `'static`.\n-                    //\n-                    // For `impl Trait` in the types of statics, constants,\n-                    // locals and type aliases. These capture all parent\n-                    // lifetimes, so they can use their identity subst.\n-                    GenericParamDefKind::Lifetime\n-                        if matches!(\n-                            origin,\n-                            hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..)\n-                        ) =>\n-                    {\n-                        tcx.lifetimes.re_static.into()\n-                    }\n-                    _ => tcx.mk_param_from_def(param),\n-                }\n+                tcx.mk_param_from_def(param)\n             }\n         });\n         debug!(\"impl_trait_ty_to_ty: substs={:?}\", substs);\n@@ -2982,6 +2959,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         Some(tcx.liberate_late_bound_regions(fn_hir_id.expect_owner().to_def_id(), ty))\n     }\n \n+    #[instrument(level = \"trace\", skip(self, generate_err))]\n     fn validate_late_bound_regions(\n         &self,\n         constrained_regions: FxHashSet<ty::BoundRegionKind>,\n@@ -3023,7 +3001,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     fn compute_object_lifetime_bound(\n         &self,\n         span: Span,\n-        existential_predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n+        existential_predicates: &'tcx ty::List<ty::PolyExistentialPredicate<'tcx>>,\n     ) -> Option<ty::Region<'tcx>> // if None, use the default\n     {\n         let tcx = self.tcx();"}, {"sha": "3e3544ce666e39e6b296e4b8d9ad2ecc255288e2", "filename": "compiler/rustc_hir_analysis/src/bounds.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fbounds.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -60,13 +60,10 @@ impl<'tcx> Bounds<'tcx> {\n     {\n         // If it could be sized, and is, add the `Sized` predicate.\n         let sized_predicate = self.implicitly_sized.and_then(|span| {\n-            tcx.lang_items().sized_trait().map(move |sized| {\n-                let trait_ref = ty::Binder::dummy(ty::TraitRef {\n-                    def_id: sized,\n-                    substs: tcx.mk_substs_trait(param_ty, &[]),\n-                });\n-                (trait_ref.without_const().to_predicate(tcx), span)\n-            })\n+            // FIXME: use tcx.at(span).mk_trait_ref(LangItem::Sized) here? This may make no-core code harder to write.\n+            let sized = tcx.lang_items().sized_trait()?;\n+            let trait_ref = ty::Binder::dummy(tcx.mk_trait_ref(sized, [param_ty]));\n+            Some((trait_ref.without_const().to_predicate(tcx), span))\n         });\n \n         let region_preds = self.region_bounds.iter().map(move |&(region_bound, span)| {"}, {"sha": "069b405423c46b16aa023d60acb5be0419dcba7a", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 42, "deletions": 51, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -10,6 +10,7 @@ use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::{ItemKind, Node, PathSegment};\n+use rustc_infer::infer::opaque_types::ConstrainOpaqueTypeRegionVisitor;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::{DefiningAnchor, RegionVariableOrigin, TyCtxtInferExt};\n use rustc_infer::traits::Obligation;\n@@ -229,7 +230,9 @@ fn check_opaque<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n     let substs = InternalSubsts::identity_for_item(tcx, item.owner_id.to_def_id());\n     let span = tcx.def_span(item.owner_id.def_id);\n \n-    check_opaque_for_inheriting_lifetimes(tcx, item.owner_id.def_id, span);\n+    if !tcx.features().impl_trait_projections {\n+        check_opaque_for_inheriting_lifetimes(tcx, item.owner_id.def_id, span);\n+    }\n     if tcx.type_of(item.owner_id.def_id).references_error() {\n         return;\n     }\n@@ -238,6 +241,7 @@ fn check_opaque<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n     }\n     check_opaque_meets_bounds(tcx, item.owner_id.def_id, substs, span, &origin);\n }\n+\n /// Checks that an opaque type does not use `Self` or `T::Foo` projections that would result\n /// in \"inheriting lifetimes\".\n #[instrument(level = \"debug\", skip(tcx, span))]\n@@ -249,52 +253,37 @@ pub(super) fn check_opaque_for_inheriting_lifetimes<'tcx>(\n     let item = tcx.hir().expect_item(def_id);\n     debug!(?item, ?span);\n \n-    struct FoundParentLifetime;\n-    struct FindParentLifetimeVisitor<'tcx>(&'tcx ty::Generics);\n-    impl<'tcx> ty::visit::TypeVisitor<'tcx> for FindParentLifetimeVisitor<'tcx> {\n-        type BreakTy = FoundParentLifetime;\n-\n-        fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-            debug!(\"FindParentLifetimeVisitor: r={:?}\", r);\n-            if let ty::ReEarlyBound(ty::EarlyBoundRegion { index, .. }) = *r {\n-                if index < self.0.parent_count as u32 {\n-                    return ControlFlow::Break(FoundParentLifetime);\n-                } else {\n-                    return ControlFlow::CONTINUE;\n-                }\n-            }\n-\n-            r.super_visit_with(self)\n-        }\n-\n-        fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-            if let ty::ConstKind::Unevaluated(..) = c.kind() {\n-                // FIXME(#72219) We currently don't detect lifetimes within substs\n-                // which would violate this check. Even though the particular substitution is not used\n-                // within the const, this should still be fixed.\n-                return ControlFlow::CONTINUE;\n-            }\n-            c.super_visit_with(self)\n-        }\n-    }\n-\n     struct ProhibitOpaqueVisitor<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         opaque_identity_ty: Ty<'tcx>,\n-        generics: &'tcx ty::Generics,\n+        parent_count: u32,\n+        references_parent_regions: bool,\n         selftys: Vec<(Span, Option<String>)>,\n     }\n \n     impl<'tcx> ty::visit::TypeVisitor<'tcx> for ProhibitOpaqueVisitor<'tcx> {\n         type BreakTy = Ty<'tcx>;\n \n         fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-            debug!(\"check_opaque_for_inheriting_lifetimes: (visit_ty) t={:?}\", t);\n+            debug!(?t, \"root_visit_ty\");\n             if t == self.opaque_identity_ty {\n                 ControlFlow::CONTINUE\n             } else {\n-                t.super_visit_with(&mut FindParentLifetimeVisitor(self.generics))\n-                    .map_break(|FoundParentLifetime| t)\n+                t.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n+                    tcx: self.tcx,\n+                    op: |region| {\n+                        if let ty::ReEarlyBound(ty::EarlyBoundRegion { index, .. }) = *region\n+                            && index < self.parent_count\n+                        {\n+                            self.references_parent_regions= true;\n+                        }\n+                    },\n+                });\n+                if self.references_parent_regions {\n+                    ControlFlow::Break(t)\n+                } else {\n+                    ControlFlow::CONTINUE\n+                }\n             }\n         }\n     }\n@@ -327,26 +316,27 @@ pub(super) fn check_opaque_for_inheriting_lifetimes<'tcx>(\n \n     if let ItemKind::OpaqueTy(hir::OpaqueTy {\n         origin: hir::OpaqueTyOrigin::AsyncFn(..) | hir::OpaqueTyOrigin::FnReturn(..),\n+        in_trait,\n         ..\n     }) = item.kind\n     {\n+        let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n+        let opaque_identity_ty = if in_trait {\n+            tcx.mk_projection(def_id.to_def_id(), substs)\n+        } else {\n+            tcx.mk_opaque(def_id.to_def_id(), substs)\n+        };\n         let mut visitor = ProhibitOpaqueVisitor {\n-            opaque_identity_ty: tcx.mk_opaque(\n-                def_id.to_def_id(),\n-                InternalSubsts::identity_for_item(tcx, def_id.to_def_id()),\n-            ),\n-            generics: tcx.generics_of(def_id),\n+            opaque_identity_ty,\n+            parent_count: tcx.generics_of(def_id).parent_count as u32,\n+            references_parent_regions: false,\n             tcx,\n             selftys: vec![],\n         };\n         let prohibit_opaque = tcx\n             .explicit_item_bounds(def_id)\n             .iter()\n             .try_for_each(|(predicate, _)| predicate.visit_with(&mut visitor));\n-        debug!(\n-            \"check_opaque_for_inheriting_lifetimes: prohibit_opaque={:?}, visitor.opaque_identity_ty={:?}, visitor.generics={:?}\",\n-            prohibit_opaque, visitor.opaque_identity_ty, visitor.generics\n-        );\n \n         if let Some(ty) = prohibit_opaque.break_value() {\n             visitor.visit_item(&item);\n@@ -357,15 +347,16 @@ pub(super) fn check_opaque_for_inheriting_lifetimes<'tcx>(\n                 _ => unreachable!(),\n             };\n \n-            let mut err = struct_span_err!(\n-                tcx.sess,\n+            let mut err = feature_err(\n+                &tcx.sess.parse_sess,\n+                sym::impl_trait_projections,\n                 span,\n-                E0760,\n-                \"`{}` return type cannot contain a projection or `Self` that references lifetimes from \\\n-                 a parent scope\",\n-                if is_async { \"async fn\" } else { \"impl Trait\" },\n+                &format!(\n+                    \"`{}` return type cannot contain a projection or `Self` that references \\\n+                    lifetimes from a parent scope\",\n+                    if is_async { \"async fn\" } else { \"impl Trait\" },\n+                ),\n             );\n-\n             for (span, name) in visitor.selftys {\n                 err.span_suggestion(\n                     span,\n@@ -1174,7 +1165,7 @@ fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) {\n     }\n \n     if def.repr().int.is_none() {\n-        let is_unit = |var: &ty::VariantDef| matches!(var.ctor_kind, CtorKind::Const);\n+        let is_unit = |var: &ty::VariantDef| matches!(var.ctor_kind(), Some(CtorKind::Const));\n         let has_disr = |var: &ty::VariantDef| matches!(var.discr, ty::VariantDiscr::Explicit(_));\n \n         let has_non_units = def.variants().iter().any(|var| !is_unit(var));"}, {"sha": "de386e2d135568c0c5cdc3e784f060efdaf34752", "filename": "compiler/rustc_hir_analysis/src/check/compare_method.rs", "status": "modified", "additions": 41, "deletions": 60, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -14,10 +14,8 @@ use rustc_infer::traits::util;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::util::ExplicitSelf;\n use rustc_middle::ty::{\n-    self, AssocItem, DefIdTree, TraitRef, Ty, TypeFoldable, TypeFolder, TypeSuperFoldable,\n-    TypeVisitable,\n+    self, DefIdTree, InternalSubsts, Ty, TypeFoldable, TypeFolder, TypeSuperFoldable, TypeVisitable,\n };\n-use rustc_middle::ty::{FnSig, InternalSubsts};\n use rustc_middle::ty::{GenericParamDefKind, ToPredicate, TyCtxt};\n use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n@@ -51,11 +49,11 @@ pub(crate) fn compare_impl_method<'tcx>(\n         return;\n     }\n \n-    if let Err(_) = compare_number_of_generics(tcx, impl_m, impl_m_span, trait_m, trait_item_span) {\n+    if let Err(_) = compare_number_of_generics(tcx, impl_m, trait_m, trait_item_span, false) {\n         return;\n     }\n \n-    if let Err(_) = compare_generic_param_kinds(tcx, impl_m, trait_m) {\n+    if let Err(_) = compare_generic_param_kinds(tcx, impl_m, trait_m, false) {\n         return;\n     }\n \n@@ -144,9 +142,9 @@ pub(crate) fn compare_impl_method<'tcx>(\n #[instrument(level = \"debug\", skip(tcx, impl_m_span, impl_trait_ref))]\n fn compare_predicate_entailment<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    impl_m: &AssocItem,\n+    impl_m: &ty::AssocItem,\n     impl_m_span: Span,\n-    trait_m: &AssocItem,\n+    trait_m: &ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n ) -> Result<(), ErrorGuaranteed> {\n     let trait_to_impl_substs = impl_trait_ref.substs;\n@@ -157,8 +155,7 @@ fn compare_predicate_entailment<'tcx>(\n     // FIXME(@lcnr): remove that after removing `cause.body_id` from\n     // obligations.\n     let impl_m_hir_id = tcx.hir().local_def_id_to_hir_id(impl_m.def_id.expect_local());\n-    // We sometimes modify the span further down.\n-    let mut cause = ObligationCause::new(\n+    let cause = ObligationCause::new(\n         impl_m_span,\n         impl_m_hir_id,\n         ObligationCauseCode::CompareImplItemObligation {\n@@ -221,14 +218,11 @@ fn compare_predicate_entailment<'tcx>(\n \n     debug!(\"compare_impl_method: caller_bounds={:?}\", param_env.caller_bounds());\n \n-    let mut selcx = traits::SelectionContext::new(&infcx);\n     let impl_m_own_bounds = impl_m_predicates.instantiate_own(tcx, impl_to_placeholder_substs);\n     for (predicate, span) in iter::zip(impl_m_own_bounds.predicates, impl_m_own_bounds.spans) {\n         let normalize_cause = traits::ObligationCause::misc(span, impl_m_hir_id);\n-        let traits::Normalized { value: predicate, obligations } =\n-            traits::normalize(&mut selcx, param_env, normalize_cause, predicate);\n+        let predicate = ocx.normalize(normalize_cause, param_env, predicate);\n \n-        ocx.register_obligations(obligations);\n         let cause = ObligationCause::new(\n             span,\n             impl_m_hir_id,\n@@ -291,30 +285,19 @@ fn compare_predicate_entailment<'tcx>(\n     // type would be more appropriate. In other places we have a `Vec<Span>`\n     // corresponding to their `Vec<Predicate>`, but we don't have that here.\n     // Fixing this would improve the output of test `issue-83765.rs`.\n-    let mut result = ocx.sup(&cause, param_env, trait_fty, impl_fty);\n-\n-    // HACK(RPITIT): #101614. When we are trying to infer the hidden types for\n-    // RPITITs, we need to equate the output tys instead of just subtyping. If\n-    // we just use `sup` above, we'll end up `&'static str <: _#1t`, which causes\n-    // us to infer `_#1t = #'_#2r str`, where `'_#2r` is unconstrained, which gets\n-    // fixed up to `ReEmpty`, and which is certainly not what we want.\n-    if trait_fty.has_infer_types() {\n-        result =\n-            result.and_then(|()| ocx.eq(&cause, param_env, trait_sig.output(), impl_sig.output()));\n-    }\n+    let result = ocx.sup(&cause, param_env, trait_fty, impl_fty);\n \n     if let Err(terr) = result {\n         debug!(?terr, \"sub_types failed: impl ty {:?}, trait ty {:?}\", impl_fty, trait_fty);\n \n         let emitted = report_trait_method_mismatch(\n-            tcx,\n-            &mut cause,\n             &infcx,\n+            cause,\n             terr,\n             (trait_m, trait_fty),\n             (impl_m, impl_fty),\n-            &trait_sig,\n-            &impl_trait_ref,\n+            trait_sig,\n+            impl_trait_ref,\n         );\n         return Err(emitted);\n     }\n@@ -352,11 +335,15 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n     let impl_trait_ref = tcx.impl_trait_ref(impl_m.impl_container(tcx).unwrap()).unwrap();\n     let param_env = tcx.param_env(def_id);\n \n+    // First, check a few of the same thing as `compare_impl_method`, just so we don't ICE during substitutions later.\n+    compare_number_of_generics(tcx, impl_m, trait_m, tcx.hir().span_if_local(impl_m.def_id), true)?;\n+    compare_generic_param_kinds(tcx, impl_m, trait_m, true)?;\n+\n     let trait_to_impl_substs = impl_trait_ref.substs;\n \n     let impl_m_hir_id = tcx.hir().local_def_id_to_hir_id(impl_m.def_id.expect_local());\n     let return_span = tcx.hir().fn_decl_by_hir_id(impl_m_hir_id).unwrap().output.span();\n-    let mut cause = ObligationCause::new(\n+    let cause = ObligationCause::new(\n         return_span,\n         impl_m_hir_id,\n         ObligationCauseCode::CompareImplItemObligation {\n@@ -376,6 +363,7 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n     let infcx = &tcx.infer_ctxt().build();\n     let ocx = ObligationCtxt::new(infcx);\n \n+    // Normalize the impl signature with fresh variables for lifetime inference.\n     let norm_cause = ObligationCause::misc(return_span, impl_m_hir_id);\n     let impl_sig = ocx.normalize(\n         norm_cause.clone(),\n@@ -388,6 +376,10 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n     );\n     let impl_return_ty = impl_sig.output();\n \n+    // Normalize the trait signature with liberated bound vars, passing it through\n+    // the ImplTraitInTraitCollector, which gathers all of the RPITITs and replaces\n+    // them with inference variables.\n+    // We will use these inference variables to collect the hidden types of RPITITs.\n     let mut collector = ImplTraitInTraitCollector::new(&ocx, return_span, param_env, impl_m_hir_id);\n     let unnormalized_trait_sig = tcx\n         .liberate_late_bound_regions(\n@@ -448,14 +440,13 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n             // emit an error now because `compare_predicate_entailment` will not report the error\n             // when normalization fails.\n             let emitted = report_trait_method_mismatch(\n-                tcx,\n-                &mut cause,\n                 infcx,\n+                cause,\n                 terr,\n                 (trait_m, trait_fty),\n                 (impl_m, impl_fty),\n-                &trait_sig,\n-                &impl_trait_ref,\n+                trait_sig,\n+                impl_trait_ref,\n             );\n             return Err(emitted);\n         }\n@@ -625,23 +616,21 @@ impl<'tcx> TypeFolder<'tcx> for ImplTraitInTraitCollector<'_, 'tcx> {\n }\n \n fn report_trait_method_mismatch<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    cause: &mut ObligationCause<'tcx>,\n     infcx: &InferCtxt<'tcx>,\n+    mut cause: ObligationCause<'tcx>,\n     terr: TypeError<'tcx>,\n-    (trait_m, trait_fty): (&AssocItem, Ty<'tcx>),\n-    (impl_m, impl_fty): (&AssocItem, Ty<'tcx>),\n-    trait_sig: &FnSig<'tcx>,\n-    impl_trait_ref: &TraitRef<'tcx>,\n+    (trait_m, trait_fty): (&ty::AssocItem, Ty<'tcx>),\n+    (impl_m, impl_fty): (&ty::AssocItem, Ty<'tcx>),\n+    trait_sig: ty::FnSig<'tcx>,\n+    impl_trait_ref: ty::TraitRef<'tcx>,\n ) -> ErrorGuaranteed {\n+    let tcx = infcx.tcx;\n     let (impl_err_span, trait_err_span) =\n         extract_spans_for_error_reporting(&infcx, terr, &cause, impl_m, trait_m);\n \n-    cause.span = impl_err_span;\n-\n     let mut diag = struct_span_err!(\n         tcx.sess,\n-        cause.span(),\n+        impl_err_span,\n         E0053,\n         \"method `{}` has an incompatible type for trait\",\n         trait_m.name\n@@ -712,6 +701,7 @@ fn report_trait_method_mismatch<'tcx>(\n         _ => {}\n     }\n \n+    cause.span = impl_err_span;\n     infcx.err_ctxt().note_type_err(\n         &mut diag,\n         &cause,\n@@ -922,9 +912,9 @@ fn compare_self_type<'tcx>(\n fn compare_number_of_generics<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_: &ty::AssocItem,\n-    _impl_span: Span,\n     trait_: &ty::AssocItem,\n     trait_span: Option<Span>,\n+    delay: bool,\n ) -> Result<(), ErrorGuaranteed> {\n     let trait_own_counts = tcx.generics_of(trait_.def_id).own_counts();\n     let impl_own_counts = tcx.generics_of(impl_.def_id).own_counts();\n@@ -1054,7 +1044,7 @@ fn compare_number_of_generics<'tcx>(\n                 err.span_label(*span, \"`impl Trait` introduces an implicit type parameter\");\n             }\n \n-            let reported = err.emit();\n+            let reported = err.emit_unless(delay);\n             err_occurred = Some(reported);\n         }\n     }\n@@ -1306,6 +1296,7 @@ fn compare_generic_param_kinds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_item: &ty::AssocItem,\n     trait_item: &ty::AssocItem,\n+    delay: bool,\n ) -> Result<(), ErrorGuaranteed> {\n     assert_eq!(impl_item.kind, trait_item.kind);\n \n@@ -1363,7 +1354,7 @@ fn compare_generic_param_kinds<'tcx>(\n             err.span_label(impl_header_span, \"\");\n             err.span_label(param_impl_span, make_param_message(\"found\", param_impl));\n \n-            let reported = err.emit();\n+            let reported = err.emit_unless(delay);\n             return Err(reported);\n         }\n     }\n@@ -1489,9 +1480,9 @@ pub(crate) fn compare_ty_impl<'tcx>(\n     debug!(\"compare_impl_type(impl_trait_ref={:?})\", impl_trait_ref);\n \n     let _: Result<(), ErrorGuaranteed> = (|| {\n-        compare_number_of_generics(tcx, impl_ty, impl_ty_span, trait_ty, trait_item_span)?;\n+        compare_number_of_generics(tcx, impl_ty, trait_ty, trait_item_span, false)?;\n \n-        compare_generic_param_kinds(tcx, impl_ty, trait_ty)?;\n+        compare_generic_param_kinds(tcx, impl_ty, trait_ty, false)?;\n \n         let sp = tcx.def_span(impl_ty.def_id);\n         compare_type_predicate_entailment(tcx, impl_ty, sp, trait_ty, impl_trait_ref)?;\n@@ -1561,14 +1552,11 @@ fn compare_type_predicate_entailment<'tcx>(\n \n     debug!(\"compare_type_predicate_entailment: caller_bounds={:?}\", param_env.caller_bounds());\n \n-    let mut selcx = traits::SelectionContext::new(&infcx);\n-\n     assert_eq!(impl_ty_own_bounds.predicates.len(), impl_ty_own_bounds.spans.len());\n     for (span, predicate) in std::iter::zip(impl_ty_own_bounds.spans, impl_ty_own_bounds.predicates)\n     {\n         let cause = ObligationCause::misc(span, impl_ty_hir_id);\n-        let traits::Normalized { value: predicate, obligations } =\n-            traits::normalize(&mut selcx, param_env, cause, predicate);\n+        let predicate = ocx.normalize(cause, param_env, predicate);\n \n         let cause = ObligationCause::new(\n             span,\n@@ -1579,7 +1567,6 @@ fn compare_type_predicate_entailment<'tcx>(\n                 kind: impl_ty.kind,\n             },\n         );\n-        ocx.register_obligations(obligations);\n         ocx.register_obligation(traits::Obligation::new(tcx, cause, param_env, predicate));\n     }\n \n@@ -1762,7 +1749,6 @@ pub fn check_type_bounds<'tcx>(\n     let assumed_wf_types =\n         ocx.assumed_wf_types(param_env, impl_ty_span, impl_ty.def_id.expect_local());\n \n-    let mut selcx = traits::SelectionContext::new(&infcx);\n     let normalize_cause = ObligationCause::new(\n         impl_ty_span,\n         impl_ty_hir_id,\n@@ -1791,16 +1777,11 @@ pub fn check_type_bounds<'tcx>(\n     debug!(\"check_type_bounds: item_bounds={:?}\", obligations);\n \n     for mut obligation in util::elaborate_obligations(tcx, obligations) {\n-        let traits::Normalized { value: normalized_predicate, obligations } = traits::normalize(\n-            &mut selcx,\n-            normalize_param_env,\n-            normalize_cause.clone(),\n-            obligation.predicate,\n-        );\n+        let normalized_predicate =\n+            ocx.normalize(normalize_cause.clone(), normalize_param_env, obligation.predicate);\n         debug!(\"compare_projection_bounds: normalized predicate = {:?}\", normalized_predicate);\n         obligation.predicate = normalized_predicate;\n \n-        ocx.register_obligations(obligations);\n         ocx.register_obligation(obligation);\n     }\n     // Check that all obligations are satisfied by the implementation's"}, {"sha": "d04d8ca2c32740d85bb6af99a9394d4b3f3785e1", "filename": "compiler/rustc_hir_analysis/src/check/dropck.rs", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -183,19 +183,27 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n             let predicate = predicate.kind();\n             let p = p.kind();\n             match (predicate.skip_binder(), p.skip_binder()) {\n-                (ty::PredicateKind::Trait(a), ty::PredicateKind::Trait(b)) => {\n-                    relator.relate(predicate.rebind(a), p.rebind(b)).is_ok()\n-                }\n-                (ty::PredicateKind::Projection(a), ty::PredicateKind::Projection(b)) => {\n-                    relator.relate(predicate.rebind(a), p.rebind(b)).is_ok()\n-                }\n+                (\n+                    ty::PredicateKind::Clause(ty::Clause::Trait(a)),\n+                    ty::PredicateKind::Clause(ty::Clause::Trait(b)),\n+                ) => relator.relate(predicate.rebind(a), p.rebind(b)).is_ok(),\n+                (\n+                    ty::PredicateKind::Clause(ty::Clause::Projection(a)),\n+                    ty::PredicateKind::Clause(ty::Clause::Projection(b)),\n+                ) => relator.relate(predicate.rebind(a), p.rebind(b)).is_ok(),\n                 (\n                     ty::PredicateKind::ConstEvaluatable(a),\n                     ty::PredicateKind::ConstEvaluatable(b),\n                 ) => relator.relate(predicate.rebind(a), predicate.rebind(b)).is_ok(),\n                 (\n-                    ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty_a, lt_a)),\n-                    ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty_b, lt_b)),\n+                    ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n+                        ty_a,\n+                        lt_a,\n+                    ))),\n+                    ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n+                        ty_b,\n+                        lt_b,\n+                    ))),\n                 ) => {\n                     relator.relate(predicate.rebind(ty_a), p.rebind(ty_b)).is_ok()\n                         && relator.relate(predicate.rebind(lt_a), p.rebind(lt_b)).is_ok()\n@@ -244,6 +252,10 @@ impl<'tcx> TypeRelation<'tcx> for SimpleEqRelation<'tcx> {\n         self.tcx\n     }\n \n+    fn intercrate(&self) -> bool {\n+        false\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.param_env\n     }\n@@ -256,6 +268,10 @@ impl<'tcx> TypeRelation<'tcx> for SimpleEqRelation<'tcx> {\n         true\n     }\n \n+    fn mark_ambiguous(&mut self) {\n+        bug!()\n+    }\n+\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _: ty::Variance,"}, {"sha": "29255472a2516dd0917642ff3e83886320db7fd7", "filename": "compiler/rustc_hir_analysis/src/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -309,7 +309,7 @@ fn bounds_from_generic_predicates<'tcx>(\n         debug!(\"predicate {:?}\", predicate);\n         let bound_predicate = predicate.kind();\n         match bound_predicate.skip_binder() {\n-            ty::PredicateKind::Trait(trait_predicate) => {\n+            ty::PredicateKind::Clause(ty::Clause::Trait(trait_predicate)) => {\n                 let entry = types.entry(trait_predicate.self_ty()).or_default();\n                 let def_id = trait_predicate.def_id();\n                 if Some(def_id) != tcx.lang_items().sized_trait() {\n@@ -318,7 +318,7 @@ fn bounds_from_generic_predicates<'tcx>(\n                     entry.push(trait_predicate.def_id());\n                 }\n             }\n-            ty::PredicateKind::Projection(projection_pred) => {\n+            ty::PredicateKind::Clause(ty::Clause::Projection(projection_pred)) => {\n                 projections.push(bound_predicate.rebind(projection_pred));\n             }\n             _ => {}"}, {"sha": "8171a2ab270cdc12f0dec26af7949fe2380c0cee", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 32, "deletions": 28, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -462,12 +462,16 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n         let mut unsatisfied_bounds: Vec<_> = required_bounds\n             .into_iter()\n             .filter(|clause| match clause.kind().skip_binder() {\n-                ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(a, b)) => {\n+                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(ty::OutlivesPredicate(\n+                    a,\n+                    b,\n+                ))) => {\n                     !region_known_to_outlive(tcx, gat_hir, param_env, &FxIndexSet::default(), a, b)\n                 }\n-                ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(a, b)) => {\n-                    !ty_known_to_outlive(tcx, gat_hir, param_env, &FxIndexSet::default(), a, b)\n-                }\n+                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n+                    a,\n+                    b,\n+                ))) => !ty_known_to_outlive(tcx, gat_hir, param_env, &FxIndexSet::default(), a, b),\n                 _ => bug!(\"Unexpected PredicateKind\"),\n             })\n             .map(|clause| clause.to_string())\n@@ -599,8 +603,9 @@ fn gather_gat_bounds<'tcx, T: TypeFoldable<'tcx>>(\n                     }));\n                 // The predicate we expect to see. (In our example,\n                 // `Self: 'me`.)\n-                let clause =\n-                    ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty_param, region_param));\n+                let clause = ty::PredicateKind::Clause(ty::Clause::TypeOutlives(\n+                    ty::OutlivesPredicate(ty_param, region_param),\n+                ));\n                 let clause = tcx.mk_predicate(ty::Binder::dummy(clause));\n                 bounds.insert(clause);\n             }\n@@ -636,9 +641,8 @@ fn gather_gat_bounds<'tcx, T: TypeFoldable<'tcx>>(\n                         name: region_b_param.name,\n                     }));\n                 // The predicate we expect to see.\n-                let clause = ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(\n-                    region_a_param,\n-                    region_b_param,\n+                let clause = ty::PredicateKind::Clause(ty::Clause::RegionOutlives(\n+                    ty::OutlivesPredicate(region_a_param, region_b_param),\n                 ));\n                 let clause = tcx.mk_predicate(ty::Binder::dummy(clause));\n                 bounds.insert(clause);\n@@ -1539,7 +1543,6 @@ fn check_fn_or_method<'tcx>(\n \n     check_return_position_impl_trait_in_trait_bounds(\n         tcx,\n-        wfcx,\n         def_id,\n         sig.output(),\n         hir_decl.output.span(),\n@@ -1575,9 +1578,9 @@ fn check_fn_or_method<'tcx>(\n \n /// Basically `check_associated_type_bounds`, but separated for now and should be\n /// deduplicated when RPITITs get lowered into real associated items.\n+#[tracing::instrument(level = \"trace\", skip(tcx))]\n fn check_return_position_impl_trait_in_trait_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    wfcx: &WfCheckingCtxt<'_, 'tcx>,\n     fn_def_id: LocalDefId,\n     fn_output: Ty<'tcx>,\n     span: Span,\n@@ -1591,18 +1594,22 @@ fn check_return_position_impl_trait_in_trait_bounds<'tcx>(\n                 && tcx.def_kind(proj.item_def_id) == DefKind::ImplTraitPlaceholder\n                 && tcx.impl_trait_in_trait_parent(proj.item_def_id) == fn_def_id.to_def_id()\n             {\n-                let bounds = wfcx.tcx().explicit_item_bounds(proj.item_def_id);\n-                let wf_obligations = bounds.iter().flat_map(|&(bound, bound_span)| {\n-                    let normalized_bound = wfcx.normalize(span, None, bound);\n-                    traits::wf::predicate_obligations(\n-                        wfcx.infcx,\n-                        wfcx.param_env,\n-                        wfcx.body_id,\n-                        normalized_bound,\n-                        bound_span,\n-                    )\n+                // Create a new context, since we want the opaque's ParamEnv and not the parent's.\n+                let span = tcx.def_span(proj.item_def_id);\n+                enter_wf_checking_ctxt(tcx, span, proj.item_def_id.expect_local(), |wfcx| {\n+                    let bounds = wfcx.tcx().explicit_item_bounds(proj.item_def_id);\n+                    let wf_obligations = bounds.iter().flat_map(|&(bound, bound_span)| {\n+                        let normalized_bound = wfcx.normalize(span, None, bound);\n+                        traits::wf::predicate_obligations(\n+                            wfcx.infcx,\n+                            wfcx.param_env,\n+                            wfcx.body_id,\n+                            normalized_bound,\n+                            bound_span,\n+                        )\n+                    });\n+                    wfcx.register_obligations(wf_obligations);\n                 });\n-                wfcx.register_obligations(wf_obligations);\n             }\n         }\n     }\n@@ -1719,7 +1726,7 @@ fn receiver_is_valid<'tcx>(\n     // The first type is `receiver_ty`, which we know its not equal to `self_ty`; skip it.\n     autoderef.next();\n \n-    let receiver_trait_def_id = tcx.require_lang_item(LangItem::Receiver, None);\n+    let receiver_trait_def_id = tcx.require_lang_item(LangItem::Receiver, Some(span));\n \n     // Keep dereferencing `receiver_ty` until we get to `self_ty`.\n     loop {\n@@ -1779,12 +1786,9 @@ fn receiver_is_implemented<'tcx>(\n     receiver_ty: Ty<'tcx>,\n ) -> bool {\n     let tcx = wfcx.tcx();\n-    let trait_ref = ty::Binder::dummy(ty::TraitRef {\n-        def_id: receiver_trait_def_id,\n-        substs: tcx.mk_substs_trait(receiver_ty, &[]),\n-    });\n+    let trait_ref = ty::Binder::dummy(tcx.mk_trait_ref(receiver_trait_def_id, [receiver_ty]));\n \n-    let obligation = traits::Obligation::new(tcx, cause, wfcx.param_env, trait_ref.without_const());\n+    let obligation = traits::Obligation::new(tcx, cause, wfcx.param_env, trait_ref);\n \n     if wfcx.infcx.predicate_must_hold_modulo_regions(&obligation) {\n         true"}, {"sha": "193ecdb1678802b1e3a01371238ae1787a779cc2", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -114,7 +114,7 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n                     traits::ObligationCause::dummy_with_span(field_ty_span),\n                     param_env,\n                     ty,\n-                    tcx.lang_items().copy_trait().unwrap(),\n+                    tcx.require_lang_item(LangItem::Copy, Some(span)),\n                 ) {\n                     let error_predicate = error.obligation.predicate;\n                     // Only note if it's not the root obligation, otherwise it's trivial and\n@@ -128,11 +128,11 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n                             .or_default()\n                             .push(error.obligation.cause.span);\n                     }\n-                    if let ty::PredicateKind::Trait(ty::TraitPredicate {\n+                    if let ty::PredicateKind::Clause(ty::Clause::Trait(ty::TraitPredicate {\n                         trait_ref,\n                         polarity: ty::ImplPolarity::Positive,\n                         ..\n-                    }) = error_predicate.kind().skip_binder()\n+                    })) = error_predicate.kind().skip_binder()\n                     {\n                         let ty = trait_ref.self_ty();\n                         if let ty::Param(_) = ty.kind() {\n@@ -315,8 +315,7 @@ fn visit_implementation_of_dispatch_from_dyn<'tcx>(tcx: TyCtxt<'tcx>, impl_did:\n                             cause.clone(),\n                             dispatch_from_dyn_trait,\n                             0,\n-                            field.ty(tcx, substs_a),\n-                            &[field.ty(tcx, substs_b).into()],\n+                            [field.ty(tcx, substs_a), field.ty(tcx, substs_b)],\n                         )\n                     }),\n                 );\n@@ -371,7 +370,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n     let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>,\n                        mt_b: ty::TypeAndMut<'tcx>,\n                        mk_ptr: &dyn Fn(Ty<'tcx>) -> Ty<'tcx>| {\n-        if (mt_a.mutbl, mt_b.mutbl) == (hir::Mutability::Not, hir::Mutability::Mut) {\n+        if mt_a.mutbl < mt_b.mutbl {\n             infcx\n                 .err_ctxt()\n                 .report_mismatched_types(\n@@ -558,7 +557,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n     // Register an obligation for `A: Trait<B>`.\n     let cause = traits::ObligationCause::misc(span, impl_hir_id);\n     let predicate =\n-        predicate_for_trait_def(tcx, param_env, cause, trait_def_id, 0, source, &[target.into()]);\n+        predicate_for_trait_def(tcx, param_env, cause, trait_def_id, 0, [source, target]);\n     let errors = traits::fully_solve_obligation(&infcx, predicate);\n     if !errors.is_empty() {\n         infcx.err_ctxt().report_fulfillment_errors(&errors, None);"}, {"sha": "cc5114dba5efefbdb1283de86487177a701094e6", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 54, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -5,7 +5,6 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{struct_span_err, DelayDm};\n use rustc_errors::{Diagnostic, ErrorGuaranteed};\n use rustc_hir as hir;\n-use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::util::IgnoreRegions;\n use rustc_middle::ty::{\n@@ -47,58 +46,6 @@ fn do_orphan_check_impl<'tcx>(\n     let sp = tcx.def_span(def_id);\n     let tr = impl_.of_trait.as_ref().unwrap();\n \n-    // Ensure no opaque types are present in this impl header. See issues #76202 and #86411 for examples,\n-    // and #84660 where it would otherwise allow unsoundness.\n-    if trait_ref.has_opaque_types() {\n-        trace!(\"{:#?}\", item);\n-        // First we find the opaque type in question.\n-        for ty in trait_ref.substs {\n-            for ty in ty.walk() {\n-                let ty::subst::GenericArgKind::Type(ty) = ty.unpack() else { continue };\n-                let ty::Opaque(def_id, _) = *ty.kind() else { continue };\n-                trace!(?def_id);\n-\n-                // Then we search for mentions of the opaque type's type alias in the HIR\n-                struct SpanFinder<'tcx> {\n-                    sp: Span,\n-                    def_id: DefId,\n-                    tcx: TyCtxt<'tcx>,\n-                }\n-                impl<'v, 'tcx> hir::intravisit::Visitor<'v> for SpanFinder<'tcx> {\n-                    #[instrument(level = \"trace\", skip(self, _id))]\n-                    fn visit_path(&mut self, path: &'v hir::Path<'v>, _id: hir::HirId) {\n-                        // You can't mention an opaque type directly, so we look for type aliases\n-                        if let hir::def::Res::Def(hir::def::DefKind::TyAlias, def_id) = path.res {\n-                            // And check if that type alias's type contains the opaque type we're looking for\n-                            for arg in self.tcx.type_of(def_id).walk() {\n-                                if let GenericArgKind::Type(ty) = arg.unpack() {\n-                                    if let ty::Opaque(def_id, _) = *ty.kind() {\n-                                        if def_id == self.def_id {\n-                                            // Finally we update the span to the mention of the type alias\n-                                            self.sp = path.span;\n-                                            return;\n-                                        }\n-                                    }\n-                                }\n-                            }\n-                        }\n-                        hir::intravisit::walk_path(self, path)\n-                    }\n-                }\n-\n-                let mut visitor = SpanFinder { sp, def_id, tcx };\n-                hir::intravisit::walk_item(&mut visitor, item);\n-                let reported = tcx\n-                    .sess\n-                    .struct_span_err(visitor.sp, \"cannot implement trait on type alias impl trait\")\n-                    .span_note(tcx.def_span(def_id), \"type alias impl trait defined here\")\n-                    .emit();\n-                return Err(reported);\n-            }\n-        }\n-        span_bug!(sp, \"opaque type not found, but `has_opaque_types` is set\")\n-    }\n-\n     match traits::orphan_check(tcx, item.owner_id.to_def_id()) {\n         Ok(()) => {}\n         Err(err) => emit_orphan_check_error(\n@@ -345,7 +292,7 @@ fn emit_newtype_suggestion_for_raw_ptr(\n     diag: &mut Diagnostic,\n ) {\n     if !self_ty.needs_subst() {\n-        let mut_key = if ptr_ty.mutbl == rustc_middle::mir::Mutability::Mut { \"mut \" } else { \"\" };\n+        let mut_key = ptr_ty.mutbl.prefix_str();\n         let msg_sugg = \"consider introducing a new wrapper type\".to_owned();\n         let sugg = vec![\n             ("}, {"sha": "4c1d95a452d5e571c94229e4e11b064f56c4769c", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 12, "deletions": 29, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -24,7 +24,6 @@ use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, StashKey};\n use rustc_hir as hir;\n-use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::{DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::weak_lang_items::WEAK_LANG_ITEMS;\n@@ -34,7 +33,6 @@ use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs}\n use rustc_middle::mir::mono::Linkage;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::util::{Discr, IntTypeExt};\n-use rustc_middle::ty::ReprOptions;\n use rustc_middle::ty::{self, AdtKind, Const, DefIdTree, IsSuggestable, Ty, TyCtxt};\n use rustc_session::lint;\n use rustc_session::parse::feature_err;\n@@ -794,7 +792,7 @@ fn convert_enum_variant_types(tcx: TyCtxt<'_>, def_id: DefId) {\n \n         // Convert the ctor, if any. This also registers the variant as\n         // an item.\n-        if let Some(ctor_def_id) = variant.ctor_def_id {\n+        if let Some(ctor_def_id) = variant.ctor_def_id() {\n             convert_variant_ctor(tcx, ctor_def_id.expect_local());\n         }\n     }\n@@ -803,7 +801,6 @@ fn convert_enum_variant_types(tcx: TyCtxt<'_>, def_id: DefId) {\n fn convert_variant(\n     tcx: TyCtxt<'_>,\n     variant_did: Option<LocalDefId>,\n-    ctor_did: Option<LocalDefId>,\n     ident: Ident,\n     discr: ty::VariantDiscr,\n     def: &hir::VariantData<'_>,\n@@ -840,10 +837,9 @@ fn convert_variant(\n     ty::VariantDef::new(\n         ident.name,\n         variant_did.map(LocalDefId::to_def_id),\n-        ctor_did.map(LocalDefId::to_def_id),\n+        def.ctor().map(|(kind, _, def_id)| (kind, def_id.to_def_id())),\n         discr,\n         fields,\n-        CtorKind::from_hir(def),\n         adt_kind,\n         parent_did.to_def_id(),\n         recovered,\n@@ -863,7 +859,7 @@ fn adt_def<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> ty::AdtDef<'tcx> {\n         bug!();\n     };\n \n-    let repr = ReprOptions::new(tcx, def_id.to_def_id());\n+    let repr = tcx.repr_options_of_def(def_id.to_def_id());\n     let (kind, variants) = match item.kind {\n         ItemKind::Enum(ref def, _) => {\n             let mut distance_from_explicit = 0;\n@@ -882,7 +878,6 @@ fn adt_def<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> ty::AdtDef<'tcx> {\n                     convert_variant(\n                         tcx,\n                         Some(v.def_id),\n-                        v.data.ctor_def_id(),\n                         v.ident,\n                         discr,\n                         &v.data,\n@@ -894,35 +889,23 @@ fn adt_def<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> ty::AdtDef<'tcx> {\n \n             (AdtKind::Enum, variants)\n         }\n-        ItemKind::Struct(ref def, _) => {\n-            let variants = std::iter::once(convert_variant(\n-                tcx,\n-                None,\n-                def.ctor_def_id(),\n-                item.ident,\n-                ty::VariantDiscr::Relative(0),\n-                def,\n-                AdtKind::Struct,\n-                def_id,\n-            ))\n-            .collect();\n-\n-            (AdtKind::Struct, variants)\n-        }\n-        ItemKind::Union(ref def, _) => {\n+        ItemKind::Struct(ref def, _) | ItemKind::Union(ref def, _) => {\n+            let adt_kind = match item.kind {\n+                ItemKind::Struct(..) => AdtKind::Struct,\n+                _ => AdtKind::Union,\n+            };\n             let variants = std::iter::once(convert_variant(\n                 tcx,\n                 None,\n-                def.ctor_def_id(),\n                 item.ident,\n                 ty::VariantDiscr::Relative(0),\n                 def,\n-                AdtKind::Union,\n+                adt_kind,\n                 def_id,\n             ))\n             .collect();\n \n-            (AdtKind::Union, variants)\n+            (adt_kind, variants)\n         }\n         _ => bug!(),\n     };\n@@ -1171,7 +1154,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n             compute_sig_of_foreign_fn_decl(tcx, def_id.to_def_id(), fn_decl, abi)\n         }\n \n-        Ctor(data) | Variant(hir::Variant { data, .. }) if data.ctor_hir_id().is_some() => {\n+        Ctor(data) | Variant(hir::Variant { data, .. }) if data.ctor().is_some() => {\n             let ty = tcx.type_of(tcx.hir().get_parent_item(hir_id));\n             let inputs = data.fields().iter().map(|f| tcx.type_of(f.def_id));\n             ty::Binder::dummy(tcx.mk_fn_sig(\n@@ -2173,7 +2156,7 @@ fn check_link_ordinal(tcx: TyCtxt<'_>, attr: &ast::Attribute) -> Option<u16> {\n         .emit();\n     }\n     let meta_item_list = attr.meta_item_list();\n-    let meta_item_list: Option<&[ast::NestedMetaItem]> = meta_item_list.as_ref().map(Vec::as_ref);\n+    let meta_item_list = meta_item_list.as_deref();\n     let sole_meta_list = match meta_item_list {\n         Some([item]) => item.literal(),\n         Some(_) => {"}, {"sha": "639f81f20bfb9d2389ee19f73ae3cf2043e5087b", "filename": "compiler/rustc_hir_analysis/src/collect/generics_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -398,7 +398,7 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n                 Some(rl::Region::Static | rl::Region::EarlyBound(..)) => {}\n                 Some(rl::Region::LateBound(debruijn, _, _)) if debruijn < self.outer_index => {}\n                 Some(rl::Region::LateBound(..) | rl::Region::Free(..)) | None => {\n-                    self.has_late_bound_regions = Some(lt.span);\n+                    self.has_late_bound_regions = Some(lt.ident.span);\n                 }\n             }\n         }"}, {"sha": "0542e2c8f50818fe047d605ec164543e37785062", "filename": "compiler/rustc_hir_analysis/src/collect/item_bounds.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -35,9 +35,11 @@ fn associated_type_bounds<'tcx>(\n \n     let bounds_from_parent = trait_predicates.predicates.iter().copied().filter(|(pred, _)| {\n         match pred.kind().skip_binder() {\n-            ty::PredicateKind::Trait(tr) => tr.self_ty() == item_ty,\n-            ty::PredicateKind::Projection(proj) => proj.projection_ty.self_ty() == item_ty,\n-            ty::PredicateKind::TypeOutlives(outlives) => outlives.0 == item_ty,\n+            ty::PredicateKind::Clause(ty::Clause::Trait(tr)) => tr.self_ty() == item_ty,\n+            ty::PredicateKind::Clause(ty::Clause::Projection(proj)) => {\n+                proj.projection_ty.self_ty() == item_ty\n+            }\n+            ty::PredicateKind::Clause(ty::Clause::TypeOutlives(outlives)) => outlives.0 == item_ty,\n             _ => false,\n         }\n     });"}, {"sha": "c11eed7ad9e57cd315c94a0746d1d334198f272f", "filename": "compiler/rustc_hir_analysis/src/collect/lifetimes.rs", "status": "modified", "additions": 53, "deletions": 48, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -595,7 +595,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         this.visit_poly_trait_ref(bound);\n                     }\n                 });\n-                match lifetime.name {\n+                match lifetime.res {\n                     LifetimeName::ImplicitObjectLifetimeDefault => {\n                         // If the user does not write *anything*, we\n                         // use the object lifetime defaulting\n@@ -686,7 +686,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     if !parent_id.is_owner() {\n                         struct_span_err!(\n                             self.tcx.sess,\n-                            lifetime.span,\n+                            lifetime.ident.span,\n                             E0657,\n                             \"`impl Trait` can only capture lifetimes bound at the fn or impl level\"\n                         )\n@@ -698,7 +698,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     }) = self.tcx.hir().get(parent_id)\n                     {\n                         let mut err = self.tcx.sess.struct_span_err(\n-                            lifetime.span,\n+                            lifetime.ident.span,\n                             \"higher kinded lifetime bounds on nested opaque types are not supported yet\",\n                         );\n                         err.span_note(self.tcx.def_span(def_id), \"lifetime declared here\");\n@@ -802,9 +802,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     #[instrument(level = \"debug\", skip(self))]\n     fn visit_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n-        match lifetime_ref.name {\n+        match lifetime_ref.res {\n             hir::LifetimeName::Static => self.insert_lifetime(lifetime_ref, Region::Static),\n-            hir::LifetimeName::Param(param_def_id, _) => {\n+            hir::LifetimeName::Param(param_def_id) => {\n                 self.resolve_lifetime_ref(param_def_id, lifetime_ref)\n             }\n             // If we've already reported an error, just ignore `lifetime_ref`.\n@@ -912,27 +912,27 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         this.visit_lifetime(lifetime);\n                         walk_list!(this, visit_param_bound, bounds);\n \n-                        if lifetime.name != hir::LifetimeName::Static {\n+                        if lifetime.res != hir::LifetimeName::Static {\n                             for bound in bounds {\n                                 let hir::GenericBound::Outlives(ref lt) = bound else {\n                                     continue;\n                                 };\n-                                if lt.name != hir::LifetimeName::Static {\n+                                if lt.res != hir::LifetimeName::Static {\n                                     continue;\n                                 }\n                                 this.insert_lifetime(lt, Region::Static);\n                                 this.tcx\n                                     .sess\n                                     .struct_span_warn(\n-                                        lifetime.span,\n+                                        lifetime.ident.span,\n                                         &format!(\n                                             \"unnecessary lifetime parameter `{}`\",\n-                                            lifetime.name.ident(),\n+                                            lifetime.ident,\n                                         ),\n                                     )\n                                     .help(&format!(\n                                         \"you can use the `'static` lifetime directly, in place of `{}`\",\n-                                        lifetime.name.ident(),\n+                                        lifetime.ident,\n                                     ))\n                                     .emit();\n                             }\n@@ -1043,15 +1043,15 @@ fn object_lifetime_default<'tcx>(tcx: TyCtxt<'tcx>, param_def_id: DefId) -> Obje\n \n                 for bound in bound.bounds {\n                     if let hir::GenericBound::Outlives(ref lifetime) = *bound {\n-                        set.insert(lifetime.name.normalize_to_macros_2_0());\n+                        set.insert(lifetime.res);\n                     }\n                 }\n             }\n \n             match set {\n                 Set1::Empty => ObjectLifetimeDefault::Empty,\n                 Set1::One(hir::LifetimeName::Static) => ObjectLifetimeDefault::Static,\n-                Set1::One(hir::LifetimeName::Param(param_def_id, _)) => {\n+                Set1::One(hir::LifetimeName::Param(param_def_id)) => {\n                     ObjectLifetimeDefault::Param(param_def_id.to_def_id())\n                 }\n                 _ => ObjectLifetimeDefault::Ambiguous,\n@@ -1195,42 +1195,50 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     // Fresh lifetimes in APIT used to be allowed in async fns and forbidden in\n                     // regular fns.\n                     if let Some(hir::PredicateOrigin::ImplTrait) = where_bound_origin\n-                        && let hir::LifetimeName::Param(_, hir::ParamName::Fresh) = lifetime_ref.name\n+                        && let hir::LifetimeName::Param(_) = lifetime_ref.res\n+                        && lifetime_ref.is_anonymous()\n                         && let hir::IsAsync::NotAsync = self.tcx.asyncness(lifetime_ref.hir_id.owner.def_id)\n                         && !self.tcx.features().anonymous_lifetime_in_impl_trait\n                     {\n                         let mut diag =  rustc_session::parse::feature_err(\n                             &self.tcx.sess.parse_sess,\n                             sym::anonymous_lifetime_in_impl_trait,\n-                            lifetime_ref.span,\n+                            lifetime_ref.ident.span,\n                             \"anonymous lifetimes in `impl Trait` are unstable\",\n                         );\n \n-                        match self.tcx.hir().get_generics(lifetime_ref.hir_id.owner.def_id) {\n-                            Some(generics) => {\n-\n-                                let new_param_sugg_tuple;\n-\n-                                new_param_sugg_tuple = match generics.span_for_param_suggestion() {\n-                                    Some(_) => {\n-                                        Some((self.tcx.sess.source_map().span_through_char(generics.span, '<').shrink_to_hi(), \"'a, \".to_owned()))\n-                                    },\n-                                    None => Some((generics.span, \"<'a>\".to_owned()))\n-                                };\n-\n-                                let mut multi_sugg_vec = vec![(lifetime_ref.span.shrink_to_hi(), \"'a \".to_owned())];\n-\n-                                if let Some(new_tuple) =  new_param_sugg_tuple{\n-                                    multi_sugg_vec.push(new_tuple);\n-                                }\n-\n-                                diag.span_label(lifetime_ref.span, \"expected named lifetime parameter\");\n-                                diag.multipart_suggestion(\"consider introducing a named lifetime parameter\",\n-                                multi_sugg_vec,\n-                                rustc_errors::Applicability::MaybeIncorrect);\n-\n-                            },\n-                            None => { }\n+                        if let Some(generics) =\n+                            self.tcx.hir().get_generics(lifetime_ref.hir_id.owner.def_id)\n+                        {\n+                            let new_param_sugg = if let Some(span) =\n+                                generics.span_for_lifetime_suggestion()\n+                            {\n+                                (span, \"'a, \".to_owned())\n+                            } else {\n+                                (generics.span, \"<'a>\".to_owned())\n+                            };\n+\n+                            let lifetime_sugg = match lifetime_ref.suggestion_position() {\n+                                (hir::LifetimeSuggestionPosition::Normal, span) => (span, \"'a\".to_owned()),\n+                                (hir::LifetimeSuggestionPosition::Ampersand, span) => (span, \"'a \".to_owned()),\n+                                (hir::LifetimeSuggestionPosition::ElidedPath, span) => (span, \"<'a>\".to_owned()),\n+                                (hir::LifetimeSuggestionPosition::ElidedPathArgument, span) => (span, \"'a, \".to_owned()),\n+                                (hir::LifetimeSuggestionPosition::ObjectDefault, span) => (span, \"+ 'a\".to_owned()),\n+                            };\n+                            let suggestions = vec![\n+                                lifetime_sugg,\n+                                new_param_sugg,\n+                            ];\n+\n+                            diag.span_label(\n+                                lifetime_ref.ident.span,\n+                                \"expected named lifetime parameter\",\n+                            );\n+                            diag.multipart_suggestion(\n+                                \"consider introducing a named lifetime parameter\",\n+                                suggestions,\n+                                rustc_errors::Applicability::MaybeIncorrect,\n+                            );\n                         }\n \n                         diag.emit();\n@@ -1287,7 +1295,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     where_bound_origin: Some(hir::PredicateOrigin::ImplTrait), ..\n                 } => {\n                     let mut err = self.tcx.sess.struct_span_err(\n-                        lifetime_ref.span,\n+                        lifetime_ref.ident.span,\n                         \"`impl Trait` can only mention lifetimes bound at the fn or impl level\",\n                     );\n                     err.span_note(self.tcx.def_span(region_def_id), \"lifetime declared here\");\n@@ -1307,7 +1315,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }\n \n         self.tcx.sess.delay_span_bug(\n-            lifetime_ref.span,\n+            lifetime_ref.ident.span,\n             &format!(\"Could not resolve {:?} in scope {:#?}\", lifetime_ref, self.scope,),\n         );\n     }\n@@ -1558,7 +1566,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             let obligations = predicates.predicates.iter().filter_map(|&(pred, _)| {\n                 let bound_predicate = pred.kind();\n                 match bound_predicate.skip_binder() {\n-                    ty::PredicateKind::Trait(data) => {\n+                    ty::PredicateKind::Clause(ty::Clause::Trait(data)) => {\n                         // The order here needs to match what we would get from `subst_supertrait`\n                         let pred_bound_vars = bound_predicate.bound_vars();\n                         let mut all_bound_vars = bound_vars.clone();\n@@ -1625,10 +1633,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n     #[instrument(level = \"debug\", skip(self))]\n     fn insert_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime, def: Region) {\n-        debug!(\n-            node = ?self.tcx.hir().node_to_string(lifetime_ref.hir_id),\n-            span = ?self.tcx.sess.source_map().span_to_diagnostic_string(lifetime_ref.span)\n-        );\n+        debug!(span = ?lifetime_ref.ident.span);\n         self.map.defs.insert(lifetime_ref.hir_id, def);\n     }\n \n@@ -1839,7 +1844,7 @@ fn is_late_bound_map(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<&FxIndexSet<\n         }\n \n         fn visit_lifetime(&mut self, lifetime_ref: &'v hir::Lifetime) {\n-            if let hir::LifetimeName::Param(def_id, _) = lifetime_ref.name {\n+            if let hir::LifetimeName::Param(def_id) = lifetime_ref.res {\n                 self.regions.insert(def_id);\n             }\n         }\n@@ -1852,7 +1857,7 @@ fn is_late_bound_map(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<&FxIndexSet<\n \n     impl<'v> Visitor<'v> for AllCollector {\n         fn visit_lifetime(&mut self, lifetime_ref: &'v hir::Lifetime) {\n-            if let hir::LifetimeName::Param(def_id, _) = lifetime_ref.name {\n+            if let hir::LifetimeName::Param(def_id) = lifetime_ref.res {\n                 self.regions.insert(def_id);\n             }\n         }"}, {"sha": "45e241f4e093d523cf2d6e35f380dc2a961cf464", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 81, "deletions": 60, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -84,60 +84,30 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n \n         Node::ImplItem(item) => item.generics,\n \n-        Node::Item(item) => {\n-            match item.kind {\n-                ItemKind::Impl(ref impl_) => {\n-                    if impl_.defaultness.is_default() {\n-                        is_default_impl_trait = tcx.impl_trait_ref(def_id).map(ty::Binder::dummy);\n-                    }\n-                    &impl_.generics\n-                }\n-                ItemKind::Fn(.., ref generics, _)\n-                | ItemKind::TyAlias(_, ref generics)\n-                | ItemKind::Enum(_, ref generics)\n-                | ItemKind::Struct(_, ref generics)\n-                | ItemKind::Union(_, ref generics) => *generics,\n-\n-                ItemKind::Trait(_, _, ref generics, ..) => {\n-                    is_trait = Some(ty::TraitRef::identity(tcx, def_id));\n-                    *generics\n-                }\n-                ItemKind::TraitAlias(ref generics, _) => {\n-                    is_trait = Some(ty::TraitRef::identity(tcx, def_id));\n-                    *generics\n-                }\n-                ItemKind::OpaqueTy(OpaqueTy {\n-                    origin: hir::OpaqueTyOrigin::AsyncFn(..) | hir::OpaqueTyOrigin::FnReturn(..),\n-                    ..\n-                }) => {\n-                    // return-position impl trait\n-                    //\n-                    // We don't inherit predicates from the parent here:\n-                    // If we have, say `fn f<'a, T: 'a>() -> impl Sized {}`\n-                    // then the return type is `f::<'static, T>::{{opaque}}`.\n-                    //\n-                    // If we inherited the predicates of `f` then we would\n-                    // require that `T: 'static` to show that the return\n-                    // type is well-formed.\n-                    //\n-                    // The only way to have something with this opaque type\n-                    // is from the return type of the containing function,\n-                    // which will ensure that the function's predicates\n-                    // hold.\n-                    return ty::GenericPredicates { parent: None, predicates: &[] };\n-                }\n-                ItemKind::OpaqueTy(OpaqueTy {\n-                    ref generics,\n-                    origin: hir::OpaqueTyOrigin::TyAlias,\n-                    ..\n-                }) => {\n-                    // type-alias impl trait\n-                    generics\n+        Node::Item(item) => match item.kind {\n+            ItemKind::Impl(ref impl_) => {\n+                if impl_.defaultness.is_default() {\n+                    is_default_impl_trait = tcx.impl_trait_ref(def_id).map(ty::Binder::dummy);\n                 }\n-\n-                _ => NO_GENERICS,\n+                &impl_.generics\n             }\n-        }\n+            ItemKind::Fn(.., ref generics, _)\n+            | ItemKind::TyAlias(_, ref generics)\n+            | ItemKind::Enum(_, ref generics)\n+            | ItemKind::Struct(_, ref generics)\n+            | ItemKind::Union(_, ref generics) => *generics,\n+\n+            ItemKind::Trait(_, _, ref generics, ..) => {\n+                is_trait = Some(ty::TraitRef::identity(tcx, def_id));\n+                *generics\n+            }\n+            ItemKind::TraitAlias(ref generics, _) => {\n+                is_trait = Some(ty::TraitRef::identity(tcx, def_id));\n+                *generics\n+            }\n+            ItemKind::OpaqueTy(OpaqueTy { ref generics, .. }) => generics,\n+            _ => NO_GENERICS,\n+        },\n \n         Node::ForeignItem(item) => match item.kind {\n             ForeignItemKind::Static(..) => NO_GENERICS,\n@@ -181,6 +151,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n \n     trace!(?predicates);\n     trace!(?ast_generics);\n+    trace!(?generics);\n \n     // Collect the predicates that were written inline by the user on each\n     // type parameter (e.g., `<T: Foo>`).\n@@ -258,12 +229,12 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                 predicates.extend(region_pred.bounds.iter().map(|bound| {\n                     let (r2, span) = match bound {\n                         hir::GenericBound::Outlives(lt) => {\n-                            (<dyn AstConv<'_>>::ast_region_to_region(&icx, lt, None), lt.span)\n+                            (<dyn AstConv<'_>>::ast_region_to_region(&icx, lt, None), lt.ident.span)\n                         }\n                         _ => bug!(),\n                     };\n-                    let pred = ty::Binder::dummy(ty::PredicateKind::RegionOutlives(\n-                        ty::OutlivesPredicate(r1, r2),\n+                    let pred = ty::Binder::dummy(ty::PredicateKind::Clause(\n+                        ty::Clause::RegionOutlives(ty::OutlivesPredicate(r1, r2)),\n                     ))\n                     .to_predicate(icx.tcx);\n \n@@ -299,6 +270,52 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n         );\n     }\n \n+    // Opaque types duplicate some of their generic parameters.\n+    // We create bi-directional Outlives predicates between the original\n+    // and the duplicated parameter, to ensure that they do not get out of sync.\n+    if let Node::Item(&Item { kind: ItemKind::OpaqueTy(..), .. }) = node {\n+        let opaque_ty_id = tcx.hir().get_parent_node(hir_id);\n+        let opaque_ty_node = tcx.hir().get(opaque_ty_id);\n+        let Node::Ty(&Ty { kind: TyKind::OpaqueDef(_, lifetimes, _), .. }) = opaque_ty_node else {\n+            bug!(\"unexpected {opaque_ty_node:?}\")\n+        };\n+        debug!(?lifetimes);\n+        for (arg, duplicate) in std::iter::zip(lifetimes, ast_generics.params) {\n+            let hir::GenericArg::Lifetime(arg) = arg else { bug!() };\n+            let orig_region = <dyn AstConv<'_>>::ast_region_to_region(&icx, &arg, None);\n+            if !matches!(orig_region.kind(), ty::ReEarlyBound(..)) {\n+                // Only early-bound regions can point to the original generic parameter.\n+                continue;\n+            }\n+\n+            let hir::GenericParamKind::Lifetime { .. } = duplicate.kind else { continue };\n+            let dup_def = tcx.hir().local_def_id(duplicate.hir_id).to_def_id();\n+\n+            let Some(dup_index) = generics.param_def_id_to_index(tcx, dup_def) else { bug!() };\n+\n+            let dup_region = tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n+                def_id: dup_def,\n+                index: dup_index,\n+                name: duplicate.name.ident().name,\n+            }));\n+            predicates.push((\n+                ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::RegionOutlives(\n+                    ty::OutlivesPredicate(orig_region, dup_region),\n+                )))\n+                .to_predicate(icx.tcx),\n+                duplicate.span,\n+            ));\n+            predicates.push((\n+                ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::RegionOutlives(\n+                    ty::OutlivesPredicate(dup_region, orig_region),\n+                )))\n+                .to_predicate(icx.tcx),\n+                duplicate.span,\n+            ));\n+        }\n+        debug!(?predicates);\n+    }\n+\n     ty::GenericPredicates {\n         parent: generics.parent,\n         predicates: tcx.arena.alloc_from_iter(predicates),\n@@ -407,11 +424,13 @@ pub(super) fn explicit_predicates_of<'tcx>(\n             .iter()\n             .copied()\n             .filter(|(pred, _)| match pred.kind().skip_binder() {\n-                ty::PredicateKind::Trait(tr) => !is_assoc_item_ty(tr.self_ty()),\n-                ty::PredicateKind::Projection(proj) => {\n+                ty::PredicateKind::Clause(ty::Clause::Trait(tr)) => !is_assoc_item_ty(tr.self_ty()),\n+                ty::PredicateKind::Clause(ty::Clause::Projection(proj)) => {\n                     !is_assoc_item_ty(proj.projection_ty.self_ty())\n                 }\n-                ty::PredicateKind::TypeOutlives(outlives) => !is_assoc_item_ty(outlives.0),\n+                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(outlives)) => {\n+                    !is_assoc_item_ty(outlives.0)\n+                }\n                 _ => true,\n             })\n             .collect();\n@@ -547,7 +566,9 @@ pub(super) fn super_predicates_that_define_assoc_type(\n             // which will, in turn, reach indirect supertraits.\n             for &(pred, span) in superbounds {\n                 debug!(\"superbound: {:?}\", pred);\n-                if let ty::PredicateKind::Trait(bound) = pred.kind().skip_binder() {\n+                if let ty::PredicateKind::Clause(ty::Clause::Trait(bound)) =\n+                    pred.kind().skip_binder()\n+                {\n                     tcx.at(span).super_predicates_of(bound.def_id());\n                 }\n             }\n@@ -647,7 +668,7 @@ pub(super) fn type_param_predicates(\n         )\n         .into_iter()\n         .filter(|(predicate, _)| match predicate.kind().skip_binder() {\n-            ty::PredicateKind::Trait(data) => data.self_ty().is_param(index),\n+            ty::PredicateKind::Clause(ty::Clause::Trait(data)) => data.self_ty().is_param(index),\n             _ => false,\n         }),\n     );"}, {"sha": "b4057df7896f30fa331f932e1c838bf91a35527d", "filename": "compiler/rustc_hir_analysis/src/constrained_generic_params.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -187,7 +187,8 @@ pub fn setup_constraining_predicates<'tcx>(\n         for j in i..predicates.len() {\n             // Note that we don't have to care about binders here,\n             // as the impl trait ref never contains any late-bound regions.\n-            if let ty::PredicateKind::Projection(projection) = predicates[j].0.kind().skip_binder()\n+            if let ty::PredicateKind::Clause(ty::Clause::Projection(projection)) =\n+                predicates[j].0.kind().skip_binder()\n             {\n                 // Special case: watch out for some kind of sneaky attempt\n                 // to project out an associated type defined by this very"}, {"sha": "fd8e8ed7ba605d4add40f3e6b81c30ffaad45f19", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -214,7 +214,9 @@ fn unconstrained_parent_impl_substs<'tcx>(\n     // the functions in `cgp` add the constrained parameters to a list of\n     // unconstrained parameters.\n     for (predicate, _) in impl_generic_predicates.predicates.iter() {\n-        if let ty::PredicateKind::Projection(proj) = predicate.kind().skip_binder() {\n+        if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) =\n+            predicate.kind().skip_binder()\n+        {\n             let projection_ty = proj.projection_ty;\n             let projected_ty = proj.term;\n \n@@ -429,7 +431,10 @@ fn trait_predicates_eq<'tcx>(\n     let pred1_kind = predicate1.kind().skip_binder();\n     let pred2_kind = predicate2.kind().skip_binder();\n     let (trait_pred1, trait_pred2) = match (pred1_kind, pred2_kind) {\n-        (ty::PredicateKind::Trait(pred1), ty::PredicateKind::Trait(pred2)) => (pred1, pred2),\n+        (\n+            ty::PredicateKind::Clause(ty::Clause::Trait(pred1)),\n+            ty::PredicateKind::Clause(ty::Clause::Trait(pred2)),\n+        ) => (pred1, pred2),\n         // Just use plain syntactic equivalence if either of the predicates aren't\n         // trait predicates or have bound vars.\n         _ => return predicate1 == predicate2,\n@@ -467,7 +472,11 @@ fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: ty::Predicate<'tc\n         _ if predicate.is_global() => (),\n         // We allow specializing on explicitly marked traits with no associated\n         // items.\n-        ty::PredicateKind::Trait(ty::TraitPredicate { trait_ref, constness: _, polarity: _ }) => {\n+        ty::PredicateKind::Clause(ty::Clause::Trait(ty::TraitPredicate {\n+            trait_ref,\n+            constness: _,\n+            polarity: _,\n+        })) => {\n             if !matches!(\n                 trait_predicate_kind(tcx, predicate),\n                 Some(TraitSpecializationKind::Marker)\n@@ -483,7 +492,10 @@ fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: ty::Predicate<'tc\n                     .emit();\n             }\n         }\n-        ty::PredicateKind::Projection(ty::ProjectionPredicate { projection_ty, term }) => {\n+        ty::PredicateKind::Clause(ty::Clause::Projection(ty::ProjectionPredicate {\n+            projection_ty,\n+            term,\n+        })) => {\n             tcx.sess\n                 .struct_span_err(\n                     span,\n@@ -504,19 +516,22 @@ fn trait_predicate_kind<'tcx>(\n     predicate: ty::Predicate<'tcx>,\n ) -> Option<TraitSpecializationKind> {\n     match predicate.kind().skip_binder() {\n-        ty::PredicateKind::Trait(ty::TraitPredicate { trait_ref, constness: _, polarity: _ }) => {\n-            Some(tcx.trait_def(trait_ref.def_id).specialization_kind)\n-        }\n-        ty::PredicateKind::RegionOutlives(_)\n-        | ty::PredicateKind::TypeOutlives(_)\n-        | ty::PredicateKind::Projection(_)\n+        ty::PredicateKind::Clause(ty::Clause::Trait(ty::TraitPredicate {\n+            trait_ref,\n+            constness: _,\n+            polarity: _,\n+        })) => Some(tcx.trait_def(trait_ref.def_id).specialization_kind),\n+        ty::PredicateKind::Clause(ty::Clause::RegionOutlives(_))\n+        | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(_))\n+        | ty::PredicateKind::Clause(ty::Clause::Projection(_))\n         | ty::PredicateKind::WellFormed(_)\n         | ty::PredicateKind::Subtype(_)\n         | ty::PredicateKind::Coerce(_)\n         | ty::PredicateKind::ObjectSafe(_)\n         | ty::PredicateKind::ClosureKind(..)\n         | ty::PredicateKind::ConstEvaluatable(..)\n         | ty::PredicateKind::ConstEquate(..)\n+        | ty::PredicateKind::Ambiguous\n         | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n     }\n }"}, {"sha": "663f1c49db7db192927a0c77e6b64d0ca7f8e629", "filename": "compiler/rustc_hir_analysis/src/outlives/explicit.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -30,35 +30,38 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n             // process predicates and convert to `RequiredPredicates` entry, see below\n             for &(predicate, span) in predicates.predicates {\n                 match predicate.kind().skip_binder() {\n-                    ty::PredicateKind::TypeOutlives(OutlivesPredicate(ty, reg)) => {\n-                        insert_outlives_predicate(\n-                            tcx,\n-                            ty.into(),\n-                            reg,\n-                            span,\n-                            &mut required_predicates,\n-                        )\n-                    }\n+                    ty::PredicateKind::Clause(ty::Clause::TypeOutlives(OutlivesPredicate(\n+                        ty,\n+                        reg,\n+                    ))) => insert_outlives_predicate(\n+                        tcx,\n+                        ty.into(),\n+                        reg,\n+                        span,\n+                        &mut required_predicates,\n+                    ),\n \n-                    ty::PredicateKind::RegionOutlives(OutlivesPredicate(reg1, reg2)) => {\n-                        insert_outlives_predicate(\n-                            tcx,\n-                            reg1.into(),\n-                            reg2,\n-                            span,\n-                            &mut required_predicates,\n-                        )\n-                    }\n+                    ty::PredicateKind::Clause(ty::Clause::RegionOutlives(OutlivesPredicate(\n+                        reg1,\n+                        reg2,\n+                    ))) => insert_outlives_predicate(\n+                        tcx,\n+                        reg1.into(),\n+                        reg2,\n+                        span,\n+                        &mut required_predicates,\n+                    ),\n \n-                    ty::PredicateKind::Trait(..)\n-                    | ty::PredicateKind::Projection(..)\n+                    ty::PredicateKind::Clause(ty::Clause::Trait(..))\n+                    | ty::PredicateKind::Clause(ty::Clause::Projection(..))\n                     | ty::PredicateKind::WellFormed(..)\n                     | ty::PredicateKind::ObjectSafe(..)\n                     | ty::PredicateKind::ClosureKind(..)\n                     | ty::PredicateKind::Subtype(..)\n                     | ty::PredicateKind::Coerce(..)\n                     | ty::PredicateKind::ConstEvaluatable(..)\n                     | ty::PredicateKind::ConstEquate(..)\n+                    | ty::PredicateKind::Ambiguous\n                     | ty::PredicateKind::TypeWellFormedFromEnv(..) => (),\n                 }\n             }"}, {"sha": "c8f37176836c5220dc64be4590896d4760ae6ce9", "filename": "compiler/rustc_hir_analysis/src/outlives/mod.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fmod.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -51,8 +51,10 @@ fn inferred_outlives_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[(ty::Predicate\n                     let mut pred: Vec<String> = predicates\n                         .iter()\n                         .map(|(out_pred, _)| match out_pred.kind().skip_binder() {\n-                            ty::PredicateKind::RegionOutlives(p) => p.to_string(),\n-                            ty::PredicateKind::TypeOutlives(p) => p.to_string(),\n+                            ty::PredicateKind::Clause(ty::Clause::RegionOutlives(p)) => {\n+                                p.to_string()\n+                            }\n+                            ty::PredicateKind::Clause(ty::Clause::TypeOutlives(p)) => p.to_string(),\n                             err => bug!(\"unexpected predicate {:?}\", err),\n                         })\n                         .collect();\n@@ -101,15 +103,17 @@ fn inferred_outlives_crate(tcx: TyCtxt<'_>, (): ()) -> CratePredicatesMap<'_> {\n                 |(ty::OutlivesPredicate(kind1, region2), &span)| {\n                     match kind1.unpack() {\n                         GenericArgKind::Type(ty1) => Some((\n-                            ty::Binder::dummy(ty::PredicateKind::TypeOutlives(\n+                            ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::TypeOutlives(\n                                 ty::OutlivesPredicate(ty1, *region2),\n-                            ))\n+                            )))\n                             .to_predicate(tcx),\n                             span,\n                         )),\n                         GenericArgKind::Lifetime(region1) => Some((\n-                            ty::Binder::dummy(ty::PredicateKind::RegionOutlives(\n-                                ty::OutlivesPredicate(region1, *region2),\n+                            ty::Binder::dummy(ty::PredicateKind::Clause(\n+                                ty::Clause::RegionOutlives(ty::OutlivesPredicate(\n+                                    region1, *region2,\n+                                )),\n                             ))\n                             .to_predicate(tcx),\n                             span,"}, {"sha": "4451db19f5c1e16be69603c89b1821fe7e2e1632", "filename": "compiler/rustc_hir_analysis/src/structured_errors/wrong_number_of_generic_args.rs", "status": "modified", "additions": 50, "deletions": 21, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -296,25 +296,35 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n     ) -> String {\n         debug!(?path_hir_id);\n \n+        // If there was already a lifetime among the arguments, just replicate that one.\n+        if let Some(lt) = self.gen_args.args.iter().find_map(|arg| match arg {\n+            hir::GenericArg::Lifetime(lt) => Some(lt),\n+            _ => None,\n+        }) {\n+            return std::iter::repeat(lt.to_string())\n+                .take(num_params_to_take)\n+                .collect::<Vec<_>>()\n+                .join(\", \");\n+        }\n+\n         let mut ret = Vec::new();\n+        let mut ty_id = None;\n         for (id, node) in self.tcx.hir().parent_iter(path_hir_id) {\n             debug!(?id);\n-            let params = if let Some(generics) = node.generics() {\n-                generics.params\n-            } else if let hir::Node::Ty(ty) = node\n-                && let hir::TyKind::BareFn(bare_fn) = ty.kind\n-            {\n-                bare_fn.generic_params\n-            } else {\n-                &[]\n-            };\n-            ret.extend(params.iter().filter_map(|p| {\n-                let hir::GenericParamKind::Lifetime { kind: hir::LifetimeParamKind::Explicit }\n-                    = p.kind\n-                else { return None };\n-                let hir::ParamName::Plain(name) = p.name else { return None };\n-                Some(name.to_string())\n-            }));\n+            if let hir::Node::Ty(_) = node {\n+                ty_id = Some(id);\n+            }\n+\n+            // Suggest `'_` when in function parameter or elided function return.\n+            if let Some(fn_decl) = node.fn_decl() && let Some(ty_id) = ty_id {\n+                let in_arg = fn_decl.inputs.iter().any(|t| t.hir_id == ty_id);\n+                let in_ret = matches!(fn_decl.output, hir::FnRetTy::Return(ty) if ty.hir_id == ty_id);\n+\n+                if in_arg || (in_ret && fn_decl.lifetime_elision_allowed) {\n+                    return std::iter::repeat(\"'_\".to_owned()).take(num_params_to_take).collect::<Vec<_>>().join(\", \");\n+                }\n+            }\n+\n             // Suggest `'static` when in const/static item-like.\n             if let hir::Node::Item(hir::Item {\n                 kind: hir::ItemKind::Static { .. } | hir::ItemKind::Const { .. },\n@@ -334,11 +344,29 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n             })\n             | hir::Node::AnonConst(..) = node\n             {\n-                ret.extend(\n-                    std::iter::repeat(\"'static\".to_owned())\n-                        .take(num_params_to_take.saturating_sub(ret.len())),\n-                );\n+                return std::iter::repeat(\"'static\".to_owned())\n+                    .take(num_params_to_take.saturating_sub(ret.len()))\n+                    .collect::<Vec<_>>()\n+                    .join(\", \");\n             }\n+\n+            let params = if let Some(generics) = node.generics() {\n+                generics.params\n+            } else if let hir::Node::Ty(ty) = node\n+                && let hir::TyKind::BareFn(bare_fn) = ty.kind\n+            {\n+                bare_fn.generic_params\n+            } else {\n+                &[]\n+            };\n+            ret.extend(params.iter().filter_map(|p| {\n+                let hir::GenericParamKind::Lifetime { kind: hir::LifetimeParamKind::Explicit }\n+                    = p.kind\n+                else { return None };\n+                let hir::ParamName::Plain(name) = p.name else { return None };\n+                Some(name.to_string())\n+            }));\n+\n             if ret.len() >= num_params_to_take {\n                 return ret[..num_params_to_take].join(\", \");\n             }\n@@ -728,7 +756,8 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n         && let Some(trait_path_segment) = path.segments.get(0) {\n             let num_generic_args_supplied_to_trait = trait_path_segment.args().num_generic_params();\n \n-            if num_assoc_fn_excess_args == num_trait_generics_except_self - num_generic_args_supplied_to_trait {\n+            if num_generic_args_supplied_to_trait + num_assoc_fn_excess_args == num_trait_generics_except_self\n+            {\n                 if let Some(span) = self.gen_args.span_ext()\n                 && let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n                     let sugg = vec!["}, {"sha": "6ce0c18bf45f1368730d97a460aa0716eeca2900", "filename": "compiler/rustc_hir_analysis/src/variance/constraints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fconstraints.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -72,8 +72,8 @@ pub fn add_constraints_from_crate<'a, 'tcx>(\n \n                 let adt = tcx.adt_def(def_id);\n                 for variant in adt.variants() {\n-                    if let Some(ctor) = variant.ctor_def_id {\n-                        constraint_cx.build_constraints_for_item(ctor.expect_local());\n+                    if let Some(ctor_def_id) = variant.ctor_def_id() {\n+                        constraint_cx.build_constraints_for_item(ctor_def_id.expect_local());\n                     }\n                 }\n             }"}, {"sha": "9db05eedbde790e43c2e3c6fa081179424edc3f6", "filename": "compiler/rustc_hir_analysis/src/variance/mod.rs", "status": "modified", "additions": 95, "deletions": 2, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -5,9 +5,10 @@\n \n use rustc_arena::DroplessArena;\n use rustc_hir::def::DefKind;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, CrateVariancesMap, TyCtxt};\n+use rustc_middle::ty::{self, CrateVariancesMap, TyCtxt, TypeSuperVisitable, TypeVisitable};\n+use std::ops::ControlFlow;\n \n /// Defines the `TermsContext` basically houses an arena where we can\n /// allocate terms.\n@@ -50,6 +51,9 @@ fn variances_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[ty::Variance] {\n         | DefKind::Union\n         | DefKind::Variant\n         | DefKind::Ctor(..) => {}\n+        DefKind::OpaqueTy | DefKind::ImplTraitPlaceholder => {\n+            return variance_of_opaque(tcx, item_def_id.expect_local());\n+        }\n         _ => {\n             // Variance not relevant.\n             span_bug!(tcx.def_span(item_def_id), \"asked to compute variance for wrong kind of item\")\n@@ -61,3 +65,92 @@ fn variances_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[ty::Variance] {\n     let crate_map = tcx.crate_variances(());\n     crate_map.variances.get(&item_def_id).copied().unwrap_or(&[])\n }\n+\n+#[instrument(level = \"trace\", skip(tcx), ret)]\n+fn variance_of_opaque(tcx: TyCtxt<'_>, item_def_id: LocalDefId) -> &[ty::Variance] {\n+    let generics = tcx.generics_of(item_def_id);\n+\n+    // Opaque types may only use regions that are bound. So for\n+    // ```rust\n+    // type Foo<'a, 'b, 'c> = impl Trait<'a> + 'b;\n+    // ```\n+    // we may not use `'c` in the hidden type.\n+    struct OpaqueTypeLifetimeCollector {\n+        variances: Vec<ty::Variance>,\n+    }\n+\n+    impl<'tcx> ty::TypeVisitor<'tcx> for OpaqueTypeLifetimeCollector {\n+        #[instrument(level = \"trace\", skip(self), ret)]\n+        fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n+            if let ty::RegionKind::ReEarlyBound(ebr) = r.kind() {\n+                self.variances[ebr.index as usize] = ty::Invariant;\n+            }\n+            r.super_visit_with(self)\n+        }\n+    }\n+\n+    // By default, RPIT are invariant wrt type and const generics, but they are bivariant wrt\n+    // lifetime generics.\n+    let mut variances: Vec<_> = std::iter::repeat(ty::Invariant).take(generics.count()).collect();\n+\n+    // Mark all lifetimes from parent generics as unused (Bivariant).\n+    // This will be overridden later if required.\n+    {\n+        let mut generics = generics;\n+        while let Some(def_id) = generics.parent {\n+            generics = tcx.generics_of(def_id);\n+            for param in &generics.params {\n+                match param.kind {\n+                    ty::GenericParamDefKind::Lifetime => {\n+                        variances[param.index as usize] = ty::Bivariant;\n+                    }\n+                    ty::GenericParamDefKind::Type { .. }\n+                    | ty::GenericParamDefKind::Const { .. } => {}\n+                }\n+            }\n+        }\n+    }\n+\n+    let mut collector = OpaqueTypeLifetimeCollector { variances };\n+    let id_substs = ty::InternalSubsts::identity_for_item(tcx, item_def_id.to_def_id());\n+    for pred in tcx.bound_explicit_item_bounds(item_def_id.to_def_id()).transpose_iter() {\n+        let pred = pred.map_bound(|(pred, _)| *pred).subst(tcx, id_substs);\n+        debug!(?pred);\n+\n+        // We only ignore opaque type substs if the opaque type is the outermost type.\n+        // The opaque type may be nested within itself via recursion in e.g.\n+        // type Foo<'a> = impl PartialEq<Foo<'a>>;\n+        // which thus mentions `'a` and should thus accept hidden types that borrow 'a\n+        // instead of requiring an additional `+ 'a`.\n+        match pred.kind().skip_binder() {\n+            ty::PredicateKind::Clause(ty::Clause::Trait(ty::TraitPredicate {\n+                trait_ref: ty::TraitRef { def_id: _, substs },\n+                constness: _,\n+                polarity: _,\n+            })) => {\n+                for subst in &substs[1..] {\n+                    subst.visit_with(&mut collector);\n+                }\n+            }\n+            ty::PredicateKind::Clause(ty::Clause::Projection(ty::ProjectionPredicate {\n+                projection_ty: ty::ProjectionTy { substs, item_def_id: _ },\n+                term,\n+            })) => {\n+                for subst in &substs[1..] {\n+                    subst.visit_with(&mut collector);\n+                }\n+                term.visit_with(&mut collector);\n+            }\n+            ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n+                _,\n+                region,\n+            ))) => {\n+                region.visit_with(&mut collector);\n+            }\n+            _ => {\n+                pred.visit_with(&mut collector);\n+            }\n+        }\n+    }\n+    tcx.arena.alloc_from_iter(collector.variances.into_iter())\n+}"}, {"sha": "58e8f4747611af5c33bffca7e12477c4d5ff9437", "filename": "compiler/rustc_hir_analysis/src/variance/terms.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fterms.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -91,8 +91,8 @@ pub fn determine_parameters_to_be_inferred<'a, 'tcx>(\n \n                 let adt = tcx.adt_def(def_id);\n                 for variant in adt.variants() {\n-                    if let Some(ctor) = variant.ctor_def_id {\n-                        terms_cx.add_inferreds_for_item(ctor.expect_local());\n+                    if let Some(ctor_def_id) = variant.ctor_def_id() {\n+                        terms_cx.add_inferreds_for_item(ctor_def_id.expect_local());\n                     }\n                 }\n             }"}, {"sha": "95729822677bd32e85597913535ca7165cdec4a6", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -398,7 +398,7 @@ impl<'a> State<'a> {\n             }\n             hir::ForeignItemKind::Static(t, m) => {\n                 self.head(\"static\");\n-                if m == hir::Mutability::Mut {\n+                if m.is_mut() {\n                     self.word_space(\"mut\");\n                 }\n                 self.print_ident(item.ident);\n@@ -519,7 +519,7 @@ impl<'a> State<'a> {\n             }\n             hir::ItemKind::Static(ty, m, expr) => {\n                 self.head(\"static\");\n-                if m == hir::Mutability::Mut {\n+                if m.is_mut() {\n                     self.word_space(\"mut\");\n                 }\n                 self.print_ident(item.ident);\n@@ -2159,7 +2159,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_lifetime(&mut self, lifetime: &hir::Lifetime) {\n-        self.print_ident(lifetime.name.ident())\n+        self.print_ident(lifetime.ident)\n     }\n \n     pub fn print_where_clause(&mut self, generics: &hir::Generics<'_>) {"}, {"sha": "e25a9e9036a15607e6b2000aac8c03f8281eaa63", "filename": "compiler/rustc_hir_typeck/src/_match.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -539,18 +539,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .subst_iter_copied(self.tcx, substs)\n                     {\n                         let pred = pred.kind().rebind(match pred.kind().skip_binder() {\n-                            ty::PredicateKind::Trait(mut trait_pred) => {\n+                            ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) => {\n                                 assert_eq!(trait_pred.trait_ref.self_ty(), opaque_ty);\n-                                trait_pred.trait_ref.substs =\n-                                    self.tcx.mk_substs_trait(ty, &trait_pred.trait_ref.substs[1..]);\n-                                ty::PredicateKind::Trait(trait_pred)\n+                                ty::PredicateKind::Clause(ty::Clause::Trait(\n+                                    trait_pred.with_self_type(self.tcx, ty),\n+                                ))\n                             }\n-                            ty::PredicateKind::Projection(mut proj_pred) => {\n+                            ty::PredicateKind::Clause(ty::Clause::Projection(mut proj_pred)) => {\n                                 assert_eq!(proj_pred.projection_ty.self_ty(), opaque_ty);\n-                                proj_pred.projection_ty.substs = self\n-                                    .tcx\n-                                    .mk_substs_trait(ty, &proj_pred.projection_ty.substs[1..]);\n-                                ty::PredicateKind::Projection(proj_pred)\n+                                proj_pred.projection_ty.substs = self.tcx.mk_substs_trait(\n+                                    ty,\n+                                    proj_pred.projection_ty.substs.iter().skip(1),\n+                                );\n+                                ty::PredicateKind::Clause(ty::Clause::Projection(proj_pred))\n                             }\n                             _ => continue,\n                         });\n@@ -573,8 +574,5 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n }\n \n fn arms_contain_ref_bindings<'tcx>(arms: &'tcx [hir::Arm<'tcx>]) -> Option<hir::Mutability> {\n-    arms.iter().filter_map(|a| a.pat.contains_explicit_ref_binding()).max_by_key(|m| match *m {\n-        hir::Mutability::Mut => 1,\n-        hir::Mutability::Not => 0,\n-    })\n+    arms.iter().filter_map(|a| a.pat.contains_explicit_ref_binding()).max()\n }"}, {"sha": "1c14c1d35f7997ef026f08ed22134a100f6ae75f", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -6,7 +6,7 @@ use crate::type_error_struct;\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::{struct_span_err, Applicability, Diagnostic, StashKey};\n use rustc_hir as hir;\n-use rustc_hir::def::{self, Namespace, Res};\n+use rustc_hir::def::{self, CtorKind, Namespace, Res};\n use rustc_hir::def_id::DefId;\n use rustc_infer::{\n     infer,\n@@ -30,7 +30,7 @@ use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::DefIdOrName;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n \n-use std::iter;\n+use std::{iter, slice};\n \n /// Checks that it is legal to call methods of the trait corresponding\n /// to `trait_id` (this only cares about the trait, not the specific\n@@ -227,22 +227,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ] {\n             let Some(trait_def_id) = opt_trait_def_id else { continue };\n \n-            let opt_input_types = opt_arg_exprs.map(|arg_exprs| {\n-                [self.tcx.mk_tup(arg_exprs.iter().map(|e| {\n+            let opt_input_type = opt_arg_exprs.map(|arg_exprs| {\n+                self.tcx.mk_tup(arg_exprs.iter().map(|e| {\n                     self.next_ty_var(TypeVariableOrigin {\n                         kind: TypeVariableOriginKind::TypeInference,\n                         span: e.span,\n                     })\n-                }))]\n+                }))\n             });\n-            let opt_input_types = opt_input_types.as_ref().map(AsRef::as_ref);\n \n             if let Some(ok) = self.lookup_method_in_trait(\n                 call_expr.span,\n                 method_name,\n                 trait_def_id,\n                 adjusted_ty,\n-                opt_input_types,\n+                opt_input_type.as_ref().map(slice::from_ref),\n             ) {\n                 let method = self.register_infer_ok_obligations(ok);\n                 let mut autoref = None;\n@@ -258,15 +257,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         return None;\n                     };\n \n-                    let mutbl = match mutbl {\n-                        hir::Mutability::Not => AutoBorrowMutability::Not,\n-                        hir::Mutability::Mut => AutoBorrowMutability::Mut {\n-                            // For initial two-phase borrow\n-                            // deployment, conservatively omit\n-                            // overloaded function call ops.\n-                            allow_two_phase_borrow: AllowTwoPhase::No,\n-                        },\n-                    };\n+                    // For initial two-phase borrow\n+                    // deployment, conservatively omit\n+                    // overloaded function call ops.\n+                    let mutbl = AutoBorrowMutability::new(*mutbl, AllowTwoPhase::No);\n+\n                     autoref = Some(Adjustment {\n                         kind: Adjust::Borrow(AutoBorrow::Ref(*region, mutbl)),\n                         target: method.sig.inputs()[0],\n@@ -595,7 +590,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) {\n         let mut unit_variant = None;\n         if let hir::ExprKind::Path(qpath) = &callee_expr.kind\n-            && let Res::Def(def::DefKind::Ctor(kind, def::CtorKind::Const), _)\n+            && let Res::Def(def::DefKind::Ctor(kind, CtorKind::Const), _)\n                 = self.typeck_results.borrow().qpath_res(qpath, callee_expr.hir_id)\n             // Only suggest removing parens if there are no arguments\n             && arg_exprs.is_empty()"}, {"sha": "1cea8c9dadce3e32e9d51f478bb163871ecdef6f", "filename": "compiler/rustc_hir_typeck/src/cast.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -33,6 +33,7 @@ use super::FnCtxt;\n use crate::type_error_struct;\n use rustc_errors::{struct_span_err, Applicability, DelayDm, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n+use rustc_macros::{TypeFoldable, TypeVisitable};\n use rustc_middle::mir::Mutability;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::cast::{CastKind, CastTy};\n@@ -67,7 +68,7 @@ pub struct CastCheck<'tcx> {\n /// The kind of pointer and associated metadata (thin, length or vtable) - we\n /// only allow casts between fat pointers if their metadata have the same\n /// kind.\n-#[derive(Copy, Clone, PartialEq, Eq)]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, TypeVisitable, TypeFoldable)]\n enum PointerKind<'tcx> {\n     /// No metadata attached, ie pointer to sized type or foreign type\n     Thin,\n@@ -76,11 +77,11 @@ enum PointerKind<'tcx> {\n     /// Slice\n     Length,\n     /// The unsize info of this projection\n-    OfProjection(&'tcx ty::ProjectionTy<'tcx>),\n+    OfProjection(ty::ProjectionTy<'tcx>),\n     /// The unsize info of this opaque ty\n     OfOpaque(DefId, SubstsRef<'tcx>),\n     /// The unsize info of this parameter\n-    OfParam(&'tcx ty::ParamTy),\n+    OfParam(ty::ParamTy),\n }\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -118,9 +119,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Pointers to foreign types are thin, despite being unsized\n             ty::Foreign(..) => Some(PointerKind::Thin),\n             // We should really try to normalize here.\n-            ty::Projection(ref pi) => Some(PointerKind::OfProjection(pi)),\n+            ty::Projection(pi) => Some(PointerKind::OfProjection(pi)),\n             ty::Opaque(def_id, substs) => Some(PointerKind::OfOpaque(def_id, substs)),\n-            ty::Param(ref p) => Some(PointerKind::OfParam(p)),\n+            ty::Param(p) => Some(PointerKind::OfParam(p)),\n             // Insufficient type information.\n             ty::Placeholder(..) | ty::Bound(..) | ty::Infer(_) => None,\n \n@@ -497,10 +498,9 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                         let ty = fcx.tcx.erase_regions(ty);\n                         let expr_ty = fcx.resolve_vars_if_possible(self.expr_ty);\n                         let expr_ty = fcx.tcx.erase_regions(expr_ty);\n-                        let ty_params = fcx.tcx.mk_substs_trait(expr_ty, &[]);\n                         if fcx\n                             .infcx\n-                            .type_implements_trait(from_trait, ty, ty_params, fcx.param_env)\n+                            .type_implements_trait(from_trait, [ty, expr_ty], fcx.param_env)\n                             .must_apply_modulo_regions()\n                         {\n                             label = false;\n@@ -909,7 +909,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         }\n \n         // vtable kinds must match\n-        if cast_kind == expr_kind {\n+        if fcx.tcx.erase_regions(cast_kind) == fcx.tcx.erase_regions(expr_kind) {\n             Ok(CastKind::PtrPtrCast)\n         } else {\n             Err(CastError::DifferingKinds)\n@@ -951,7 +951,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         m_cast: ty::TypeAndMut<'tcx>,\n     ) -> Result<CastKind, CastError> {\n         // array-ptr-cast: allow mut-to-mut, mut-to-const, const-to-const\n-        if m_expr.mutbl == hir::Mutability::Mut || m_cast.mutbl == hir::Mutability::Not {\n+        if m_expr.mutbl >= m_cast.mutbl {\n             if let ty::Array(ety, _) = m_expr.ty.kind() {\n                 // Due to the limitations of LLVM global constants,\n                 // region pointers end up pointing at copies of"}, {"sha": "1ceb07def72e7f15f7091f90b558145803c8c7a1", "filename": "compiler/rustc_hir_typeck/src/check.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -56,10 +56,15 @@ pub(super) fn check_fn<'a, 'tcx>(\n \n     fn_maybe_err(tcx, span, fn_sig.abi);\n \n-    if body.generator_kind.is_some() && can_be_generator.is_some() {\n-        let yield_ty = fcx\n-            .next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span });\n-        fcx.require_type_is_sized(yield_ty, span, traits::SizedYieldType);\n+    if let Some(kind) = body.generator_kind && can_be_generator.is_some() {\n+        let yield_ty = if kind == hir::GeneratorKind::Gen {\n+            let yield_ty = fcx\n+                .next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span });\n+            fcx.require_type_is_sized(yield_ty, span, traits::SizedYieldType);\n+            yield_ty\n+        } else {\n+            tcx.mk_unit()\n+        };\n \n         // Resume type defaults to `()` if the generator has no argument.\n         let resume_ty = fn_sig.inputs().get(0).copied().unwrap_or_else(|| tcx.mk_unit());\n@@ -197,7 +202,7 @@ fn check_panic_info_fn(\n     let arg_is_panic_info = match *inputs[0].kind() {\n         ty::Ref(region, ty, mutbl) => match *ty.kind() {\n             ty::Adt(ref adt, _) => {\n-                adt.did() == panic_info_did && mutbl == hir::Mutability::Not && !region.is_static()\n+                adt.did() == panic_info_did && mutbl.is_not() && !region.is_static()\n             }\n             _ => false,\n         },"}, {"sha": "e2fefd2724f7e98683dfad1d9331c358cdebd219", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -212,7 +212,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Given a Projection predicate, we can potentially infer\n             // the complete signature.\n             if expected_sig.is_none()\n-                && let ty::PredicateKind::Projection(proj_predicate) = bound_predicate.skip_binder()\n+                && let ty::PredicateKind::Clause(ty::Clause::Projection(proj_predicate)) = bound_predicate.skip_binder()\n             {\n                 expected_sig = self.normalize_associated_types_in(\n                     obligation.cause.span,\n@@ -228,10 +228,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // like `F : Fn<A>`. Note that due to subtyping we could encounter\n             // many viable options, so pick the most restrictive.\n             let trait_def_id = match bound_predicate.skip_binder() {\n-                ty::PredicateKind::Projection(data) => {\n+                ty::PredicateKind::Clause(ty::Clause::Projection(data)) => {\n                     Some(data.projection_ty.trait_def_id(self.tcx))\n                 }\n-                ty::PredicateKind::Trait(data) => Some(data.def_id()),\n+                ty::PredicateKind::Clause(ty::Clause::Trait(data)) => Some(data.def_id()),\n                 _ => None,\n             };\n             if let Some(closure_kind) =\n@@ -658,7 +658,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // where R is the return type we are expecting. This type `T`\n             // will be our output.\n             let bound_predicate = predicate.kind();\n-            if let ty::PredicateKind::Projection(proj_predicate) = bound_predicate.skip_binder() {\n+            if let ty::PredicateKind::Clause(ty::Clause::Projection(proj_predicate)) =\n+                bound_predicate.skip_binder()\n+            {\n                 self.deduce_future_output_from_projection(\n                     span,\n                     bound_predicate.rebind(proj_predicate),"}, {"sha": "6b6d54db5062f0b3623fa02e338402231d25a59b", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 35, "deletions": 64, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -46,7 +46,7 @@ use rustc_hir::Expr;\n use rustc_hir_analysis::astconv::AstConv;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{Coercion, InferOk, InferResult};\n-use rustc_infer::traits::{Obligation, TraitEngine, TraitEngineExt};\n+use rustc_infer::traits::Obligation;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability, PointerCast,\n@@ -62,8 +62,7 @@ use rustc_span::{self, BytePos, DesugaringKind, Span};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n-use rustc_trait_selection::traits::TraitEngineExt as _;\n-use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode};\n+use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode, ObligationCtxt};\n \n use smallvec::{smallvec, SmallVec};\n use std::ops::Deref;\n@@ -109,11 +108,7 @@ fn coerce_mutbls<'tcx>(\n     from_mutbl: hir::Mutability,\n     to_mutbl: hir::Mutability,\n ) -> RelateResult<'tcx, ()> {\n-    match (from_mutbl, to_mutbl) {\n-        (hir::Mutability::Mut, hir::Mutability::Mut | hir::Mutability::Not)\n-        | (hir::Mutability::Not, hir::Mutability::Not) => Ok(()),\n-        (hir::Mutability::Not, hir::Mutability::Mut) => Err(TypeError::Mutability),\n-    }\n+    if from_mutbl >= to_mutbl { Ok(()) } else { Err(TypeError::Mutability) }\n }\n \n /// Do not require any adjustments, i.e. coerce `x -> x`.\n@@ -457,7 +452,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             return Err(err);\n         };\n \n-        if ty == a && mt_a.mutbl == hir::Mutability::Not && autoderef.step_count() == 1 {\n+        if ty == a && mt_a.mutbl.is_not() && autoderef.step_count() == 1 {\n             // As a special case, if we would produce `&'a *x`, that's\n             // a total no-op. We end up with the type `&'a T` just as\n             // we started with.  In that case, just skip it\n@@ -469,7 +464,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             // `self.x` both have `&mut `type would be a move of\n             // `self.x`, but we auto-coerce it to `foo(&mut *self.x)`,\n             // which is a borrow.\n-            assert_eq!(mutbl_b, hir::Mutability::Not); // can only coerce &T -> &U\n+            assert!(mutbl_b.is_not()); // can only coerce &T -> &U\n             return success(vec![], ty, obligations);\n         }\n \n@@ -483,12 +478,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         let ty::Ref(r_borrow, _, _) = ty.kind() else {\n             span_bug!(span, \"expected a ref type, got {:?}\", ty);\n         };\n-        let mutbl = match mutbl_b {\n-            hir::Mutability::Not => AutoBorrowMutability::Not,\n-            hir::Mutability::Mut => {\n-                AutoBorrowMutability::Mut { allow_two_phase_borrow: self.allow_two_phase }\n-            }\n-        };\n+        let mutbl = AutoBorrowMutability::new(mutbl_b, self.allow_two_phase);\n         adjustments.push(Adjustment {\n             kind: Adjust::Borrow(AutoBorrow::Ref(*r_borrow, mutbl)),\n             target: ty,\n@@ -557,15 +547,12 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n                 let coercion = Coercion(self.cause.span);\n                 let r_borrow = self.next_region_var(coercion);\n-                let mutbl = match mutbl_b {\n-                    hir::Mutability::Not => AutoBorrowMutability::Not,\n-                    hir::Mutability::Mut => AutoBorrowMutability::Mut {\n-                        // We don't allow two-phase borrows here, at least for initial\n-                        // implementation. If it happens that this coercion is a function argument,\n-                        // the reborrow in coerce_borrowed_ptr will pick it up.\n-                        allow_two_phase_borrow: AllowTwoPhase::No,\n-                    },\n-                };\n+\n+                // We don't allow two-phase borrows here, at least for initial\n+                // implementation. If it happens that this coercion is a function argument,\n+                // the reborrow in coerce_borrowed_ptr will pick it up.\n+                let mutbl = AutoBorrowMutability::new(mutbl_b, AllowTwoPhase::No);\n+\n                 Some((\n                     Adjustment { kind: Adjust::Deref(None), target: ty_a },\n                     Adjustment {\n@@ -589,7 +576,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             }\n             _ => None,\n         };\n-        let coerce_source = reborrow.as_ref().map_or(source, |&(_, ref r)| r.target);\n+        let coerce_source = reborrow.as_ref().map_or(source, |(_, r)| r.target);\n \n         // Setup either a subtyping or a LUB relationship between\n         // the `CoerceUnsized` target type and the expected type.\n@@ -630,8 +617,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             cause,\n             coerce_unsized_did,\n             0,\n-            coerce_source,\n-            &[coerce_target.into()]\n+            [coerce_source, coerce_target]\n         )];\n \n         let mut has_unsized_tuple_coercion = false;\n@@ -646,7 +632,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             debug!(\"coerce_unsized resolve step: {:?}\", obligation);\n             let bound_predicate = obligation.predicate.kind();\n             let trait_pred = match bound_predicate.skip_binder() {\n-                ty::PredicateKind::Trait(trait_pred) if traits.contains(&trait_pred.def_id()) => {\n+                ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred))\n+                    if traits.contains(&trait_pred.def_id()) =>\n+                {\n                     if unsize_did == trait_pred.def_id() {\n                         let self_ty = trait_pred.self_ty();\n                         let unsize_ty = trait_pred.trait_ref.substs[1].expect_ty();\n@@ -748,7 +736,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         &self,\n         a: Ty<'tcx>,\n         b: Ty<'tcx>,\n-        predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n+        predicates: &'tcx ty::List<ty::PolyExistentialPredicate<'tcx>>,\n         b_region: ty::Region<'tcx>,\n     ) -> CoerceResult<'tcx> {\n         if !self.tcx.features().dyn_star {\n@@ -757,20 +745,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         if let ty::Dynamic(a_data, _, _) = a.kind()\n             && let ty::Dynamic(b_data, _, _) = b.kind()\n+            && a_data.principal_def_id() == b_data.principal_def_id()\n         {\n-            if a_data.principal_def_id() == b_data.principal_def_id() {\n-                return self.unify_and(a, b, |_| vec![]);\n-            } else if !self.tcx().features().trait_upcasting {\n-                let mut err = feature_err(\n-                    &self.tcx.sess.parse_sess,\n-                    sym::trait_upcasting,\n-                    self.cause.span,\n-                    &format!(\n-                        \"cannot cast `{a}` to `{b}`, trait upcasting coercion is experimental\"\n-                    ),\n-                );\n-                err.emit();\n-            }\n+            return self.unify_and(a, b, |_| vec![]);\n         }\n \n         // Check the obligations of the cast -- for example, when casting\n@@ -791,27 +768,22 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                     self.tcx,\n                     self.cause.clone(),\n                     self.param_env,\n-                    ty::Binder::dummy(ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(\n-                        a, b_region,\n+                    ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::TypeOutlives(\n+                        ty::OutlivesPredicate(a, b_region),\n                     ))),\n                 ),\n             ])\n             .collect();\n \n-        // Enforce that the type is `usize`/pointer-sized. For now, only those\n-        // can be coerced to `dyn*`, except for `dyn* -> dyn*` upcasts.\n-        if !a.is_dyn_star() {\n-            obligations.push(Obligation::new(\n-                self.tcx,\n-                self.cause.clone(),\n-                self.param_env,\n-                ty::Binder::dummy(ty::TraitRef::new(\n-                    self.tcx.require_lang_item(hir::LangItem::PointerSized, Some(self.cause.span)),\n-                    self.tcx.mk_substs_trait(a, &[]),\n-                ))\n-                .to_poly_trait_predicate(),\n-            ));\n-        }\n+        // Enforce that the type is `usize`/pointer-sized.\n+        obligations.push(Obligation::new(\n+            self.tcx,\n+            self.cause.clone(),\n+            self.param_env,\n+            ty::Binder::dummy(\n+                self.tcx.at(self.cause.span).mk_trait_ref(hir::LangItem::PointerSized, [a]),\n+            ),\n+        ));\n \n         Ok(InferOk {\n             value: (vec![Adjustment { kind: Adjust::DynStar, target: b }], b),\n@@ -1057,9 +1029,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let Ok(ok) = coerce.coerce(source, target) else {\n                 return false;\n             };\n-            let mut fcx = <dyn TraitEngine<'tcx>>::new_in_snapshot(self.tcx);\n-            fcx.register_predicate_obligations(self, ok.obligations);\n-            fcx.select_where_possible(&self).is_empty()\n+            let ocx = ObligationCtxt::new_in_snapshot(self);\n+            ocx.register_obligations(ok.obligations);\n+            ocx.select_where_possible().is_empty()\n         })\n     }\n \n@@ -1086,8 +1058,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.infcx\n                 .type_implements_trait(\n                     self.tcx.lang_items().deref_mut_trait()?,\n-                    expr_ty,\n-                    ty::List::empty(),\n+                    [expr_ty],\n                     self.param_env,\n                 )\n                 .may_apply()"}, {"sha": "2106dce6f407ed2e03dd901732798e2e08e4a28b", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 37, "deletions": 75, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -2,6 +2,7 @@ use crate::FnCtxt;\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n+use rustc_hir::def::CtorKind;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{is_range_literal, Node};\n use rustc_infer::infer::InferOk;\n@@ -18,6 +19,7 @@ use rustc_trait_selection::traits::ObligationCause;\n \n use super::method::probe;\n \n+use std::cmp::min;\n use std::iter;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -404,27 +406,27 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         if let Some(path) = variant_path.strip_prefix(\"std::prelude::\")\n                             && let Some((_, path)) = path.split_once(\"::\")\n                         {\n-                            return Some((path.to_string(), variant.ctor_kind, sole_field.name, note_about_variant_field_privacy));\n+                            return Some((path.to_string(), variant.ctor_kind(), sole_field.name, note_about_variant_field_privacy));\n                         }\n-                        Some((variant_path, variant.ctor_kind, sole_field.name, note_about_variant_field_privacy))\n+                        Some((variant_path, variant.ctor_kind(), sole_field.name, note_about_variant_field_privacy))\n                     } else {\n                         None\n                     }\n                 })\n                 .collect();\n \n-            let suggestions_for = |variant: &_, ctor, field_name| {\n+            let suggestions_for = |variant: &_, ctor_kind, field_name| {\n                 let prefix = match self.maybe_get_struct_pattern_shorthand_field(expr) {\n                     Some(ident) => format!(\"{ident}: \"),\n                     None => String::new(),\n                 };\n \n-                let (open, close) = match ctor {\n-                    hir::def::CtorKind::Fn => (\"(\".to_owned(), \")\"),\n-                    hir::def::CtorKind::Fictive => (format!(\" {{ {field_name}: \"), \" }\"),\n+                let (open, close) = match ctor_kind {\n+                    Some(CtorKind::Fn) => (\"(\".to_owned(), \")\"),\n+                    None => (format!(\" {{ {field_name}: \"), \" }\"),\n \n                     // unit variants don't have fields\n-                    hir::def::CtorKind::Const => unreachable!(),\n+                    Some(CtorKind::Const) => unreachable!(),\n                 };\n \n                 // Suggest constructor as deep into the block tree as possible.\n@@ -854,31 +856,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             ..\n                         })) = self.tcx.hir().find(self.tcx.hir().get_parent_node(expr.hir_id))\n                         {\n-                            if mutability == hir::Mutability::Mut {\n+                            if mutability.is_mut() {\n                                 // Suppressing this diagnostic, we'll properly print it in `check_expr_assign`\n                                 return None;\n                             }\n                         }\n \n                         let sugg_expr = if needs_parens { format!(\"({src})\") } else { src };\n-                        return Some(match mutability {\n-                            hir::Mutability::Mut => (\n-                                sp,\n-                                \"consider mutably borrowing here\".to_string(),\n-                                format!(\"{prefix}&mut {sugg_expr}\"),\n-                                Applicability::MachineApplicable,\n-                                false,\n-                                false,\n-                            ),\n-                            hir::Mutability::Not => (\n-                                sp,\n-                                \"consider borrowing here\".to_string(),\n-                                format!(\"{prefix}&{sugg_expr}\"),\n-                                Applicability::MachineApplicable,\n-                                false,\n-                                false,\n-                            ),\n-                        });\n+                        return Some((\n+                            sp,\n+                            format!(\"consider {}borrowing here\", mutability.mutably_str()),\n+                            format!(\"{prefix}{}{sugg_expr}\", mutability.ref_prefix_str()),\n+                            Applicability::MachineApplicable,\n+                            false,\n+                            false,\n+                        ));\n                     }\n                 }\n             }\n@@ -936,51 +928,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     && let Ok(src) = sm.span_to_snippet(sp)\n                 {\n                     let derefs = \"*\".repeat(steps);\n-                    if let Some((span, src, applicability)) = match mutbl_b {\n-                        hir::Mutability::Mut => {\n-                            let new_prefix = \"&mut \".to_owned() + &derefs;\n-                            match mutbl_a {\n-                                hir::Mutability::Mut => {\n-                                    replace_prefix(&src, \"&mut \", &new_prefix).map(|_| {\n-                                        let pos = sp.lo() + BytePos(5);\n-                                        let sp = sp.with_lo(pos).with_hi(pos);\n-                                        (sp, derefs, Applicability::MachineApplicable)\n-                                    })\n-                                }\n-                                hir::Mutability::Not => {\n-                                    replace_prefix(&src, \"&\", &new_prefix).map(|_| {\n-                                        let pos = sp.lo() + BytePos(1);\n-                                        let sp = sp.with_lo(pos).with_hi(pos);\n-                                        (\n-                                            sp,\n-                                            format!(\"mut {derefs}\"),\n-                                            Applicability::Unspecified,\n-                                        )\n-                                    })\n-                                }\n-                            }\n-                        }\n-                        hir::Mutability::Not => {\n-                            let new_prefix = \"&\".to_owned() + &derefs;\n-                            match mutbl_a {\n-                                hir::Mutability::Mut => {\n-                                    replace_prefix(&src, \"&mut \", &new_prefix).map(|_| {\n-                                        let lo = sp.lo() + BytePos(1);\n-                                        let hi = sp.lo() + BytePos(5);\n-                                        let sp = sp.with_lo(lo).with_hi(hi);\n-                                        (sp, derefs, Applicability::MachineApplicable)\n-                                    })\n-                                }\n-                                hir::Mutability::Not => {\n-                                    replace_prefix(&src, \"&\", &new_prefix).map(|_| {\n-                                        let pos = sp.lo() + BytePos(1);\n-                                        let sp = sp.with_lo(pos).with_hi(pos);\n-                                        (sp, derefs, Applicability::MachineApplicable)\n-                                    })\n-                                }\n-                            }\n-                        }\n-                    } {\n+                    let old_prefix = mutbl_a.ref_prefix_str();\n+                    let new_prefix = mutbl_b.ref_prefix_str().to_owned() + &derefs;\n+\n+                    let suggestion = replace_prefix(&src, old_prefix, &new_prefix).map(|_| {\n+                        // skip `&` or `&mut ` if both mutabilities are mutable\n+                        let lo = sp.lo() + BytePos(min(old_prefix.len(), mutbl_b.ref_prefix_str().len()) as _);\n+                        // skip `&` or `&mut `\n+                        let hi = sp.lo() + BytePos(old_prefix.len() as _);\n+                        let sp = sp.with_lo(lo).with_hi(hi);\n+\n+                        (\n+                            sp,\n+                            format!(\"{}{derefs}\", if mutbl_a != mutbl_b { mutbl_b.prefix_str() } else { \"\" }),\n+                            if mutbl_b <= mutbl_a { Applicability::MachineApplicable } else { Applicability::MaybeIncorrect }\n+                        )\n+                    });\n+\n+                    if let Some((span, src, applicability)) = suggestion {\n                         return Some((\n                             span,\n                             \"consider dereferencing\".to_string(),\n@@ -1004,10 +969,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             // If the expression has `&`, removing it would fix the error\n                             prefix_span = prefix_span.with_hi(inner.span.lo());\n                             expr = inner;\n-                            remove += match mutbl {\n-                                hir::Mutability::Not => \"&\",\n-                                hir::Mutability::Mut => \"&mut \",\n-                            };\n+                            remove.push_str(mutbl.ref_prefix_str());\n                             steps -= 1;\n                         } else {\n                             break;"}, {"sha": "507272fdec5d71b334624b04d287820c7e19ecae", "filename": "compiler/rustc_hir_typeck/src/errors.rs", "status": "modified", "additions": 55, "deletions": 16, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -1,10 +1,11 @@\n-//! Errors emitted by `rustc_hir_analysis`.\n+//! Errors emitted by `rustc_hir_typeck`.\n+use rustc_errors::{AddToDiagnostic, Applicability, Diagnostic, MultiSpan, SubdiagnosticMessage};\n use rustc_macros::{Diagnostic, Subdiagnostic};\n use rustc_middle::ty::Ty;\n use rustc_span::{symbol::Ident, Span};\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis_field_multiply_specified_in_initializer, code = \"E0062\")]\n+#[diag(hir_typeck_field_multiply_specified_in_initializer, code = \"E0062\")]\n pub struct FieldMultiplySpecifiedInInitializer {\n     #[primary_span]\n     #[label]\n@@ -15,7 +16,7 @@ pub struct FieldMultiplySpecifiedInInitializer {\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis_return_stmt_outside_of_fn_body, code = \"E0572\")]\n+#[diag(hir_typeck_return_stmt_outside_of_fn_body, code = \"E0572\")]\n pub struct ReturnStmtOutsideOfFnBody {\n     #[primary_span]\n     pub span: Span,\n@@ -26,36 +27,36 @@ pub struct ReturnStmtOutsideOfFnBody {\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis_yield_expr_outside_of_generator, code = \"E0627\")]\n+#[diag(hir_typeck_yield_expr_outside_of_generator, code = \"E0627\")]\n pub struct YieldExprOutsideOfGenerator {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis_struct_expr_non_exhaustive, code = \"E0639\")]\n+#[diag(hir_typeck_struct_expr_non_exhaustive, code = \"E0639\")]\n pub struct StructExprNonExhaustive {\n     #[primary_span]\n     pub span: Span,\n     pub what: &'static str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis_method_call_on_unknown_type, code = \"E0699\")]\n+#[diag(hir_typeck_method_call_on_unknown_type, code = \"E0699\")]\n pub struct MethodCallOnUnknownType {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis_functional_record_update_on_non_struct, code = \"E0436\")]\n+#[diag(hir_typeck_functional_record_update_on_non_struct, code = \"E0436\")]\n pub struct FunctionalRecordUpdateOnNonStruct {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis_address_of_temporary_taken, code = \"E0745\")]\n+#[diag(hir_typeck_address_of_temporary_taken, code = \"E0745\")]\n pub struct AddressOfTemporaryTaken {\n     #[primary_span]\n     #[label]\n@@ -65,7 +66,7 @@ pub struct AddressOfTemporaryTaken {\n #[derive(Subdiagnostic)]\n pub enum AddReturnTypeSuggestion {\n     #[suggestion(\n-        hir_analysis_add_return_type_add,\n+        hir_typeck_add_return_type_add,\n         code = \"-> {found} \",\n         applicability = \"machine-applicable\"\n     )]\n@@ -75,7 +76,7 @@ pub enum AddReturnTypeSuggestion {\n         found: String,\n     },\n     #[suggestion(\n-        hir_analysis_add_return_type_missing_here,\n+        hir_typeck_add_return_type_missing_here,\n         code = \"-> _ \",\n         applicability = \"has-placeholders\"\n     )]\n@@ -87,12 +88,12 @@ pub enum AddReturnTypeSuggestion {\n \n #[derive(Subdiagnostic)]\n pub enum ExpectedReturnTypeLabel<'tcx> {\n-    #[label(hir_analysis_expected_default_return_type)]\n+    #[label(hir_typeck_expected_default_return_type)]\n     Unit {\n         #[primary_span]\n         span: Span,\n     },\n-    #[label(hir_analysis_expected_return_type)]\n+    #[label(hir_typeck_expected_return_type)]\n     Other {\n         #[primary_span]\n         span: Span,\n@@ -101,10 +102,10 @@ pub enum ExpectedReturnTypeLabel<'tcx> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis_missing_parentheses_in_range, code = \"E0689\")]\n+#[diag(hir_typeck_missing_parentheses_in_range, code = \"E0689\")]\n pub struct MissingParentheseInRange {\n     #[primary_span]\n-    #[label(hir_analysis_missing_parentheses_in_range)]\n+    #[label(hir_typeck_missing_parentheses_in_range)]\n     pub span: Span,\n     pub ty_str: String,\n     pub method_name: String,\n@@ -114,7 +115,7 @@ pub struct MissingParentheseInRange {\n \n #[derive(Subdiagnostic)]\n #[multipart_suggestion(\n-    hir_analysis_add_missing_parentheses_in_range,\n+    hir_typeck_add_missing_parentheses_in_range,\n     style = \"verbose\",\n     applicability = \"maybe-incorrect\"\n )]\n@@ -127,9 +128,47 @@ pub struct AddMissingParenthesesInRange {\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis_op_trait_generic_params)]\n+#[diag(hir_typeck_op_trait_generic_params)]\n pub struct OpMethodGenericParams {\n     #[primary_span]\n     pub span: Span,\n     pub method_name: String,\n }\n+\n+pub struct TypeMismatchFruTypo {\n+    /// Span of the LHS of the range\n+    pub expr_span: Span,\n+    /// Span of the `..RHS` part of the range\n+    pub fru_span: Span,\n+    /// Rendered expression of the RHS of the range\n+    pub expr: Option<String>,\n+}\n+\n+impl AddToDiagnostic for TypeMismatchFruTypo {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n+        diag.set_arg(\"expr\", self.expr.as_deref().unwrap_or(\"NONE\"));\n+\n+        // Only explain that `a ..b` is a range if it's split up\n+        if self.expr_span.between(self.fru_span).is_empty() {\n+            diag.span_note(\n+                self.expr_span.to(self.fru_span),\n+                rustc_errors::fluent::hir_typeck_fru_note,\n+            );\n+        } else {\n+            let mut multispan: MultiSpan = vec![self.expr_span, self.fru_span].into();\n+            multispan.push_span_label(self.expr_span, rustc_errors::fluent::hir_typeck_fru_expr);\n+            multispan.push_span_label(self.fru_span, rustc_errors::fluent::hir_typeck_fru_expr2);\n+            diag.span_note(multispan, rustc_errors::fluent::hir_typeck_fru_note);\n+        }\n+\n+        diag.span_suggestion(\n+            self.expr_span.shrink_to_hi(),\n+            rustc_errors::fluent::hir_typeck_fru_suggestion,\n+            \", \",\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+}"}, {"sha": "d7f875b2857752d228cdccff34bedcb41d9b9d81", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 48, "deletions": 25, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -5,6 +5,7 @@\n use crate::cast;\n use crate::coercion::CoerceMany;\n use crate::coercion::DynamicCoerceMany;\n+use crate::errors::TypeMismatchFruTypo;\n use crate::errors::{AddressOfTemporaryTaken, ReturnStmtOutsideOfFnBody, StructExprNonExhaustive};\n use crate::errors::{\n     FieldMultiplySpecifiedInInitializer, FunctionalRecordUpdateOnNonStruct,\n@@ -532,8 +533,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.set_tainted_by_errors(e);\n                 tcx.ty_error_with_guaranteed(e)\n             }\n-            Res::Def(DefKind::Ctor(_, CtorKind::Fictive), _) => {\n-                let e = report_unexpected_variant_res(tcx, res, qpath, expr.span);\n+            Res::Def(DefKind::Variant, _) => {\n+                let e = report_unexpected_variant_res(tcx, res, qpath, expr.span, \"E0533\", \"value\");\n                 tcx.ty_error_with_guaranteed(e)\n             }\n             _ => self.instantiate_value_path(segs, opt_ty, res, expr.span, expr.hir_id).0,\n@@ -1117,9 +1118,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let lhs_deref_ty_is_sized = self\n                     .infcx\n                     .type_implements_trait(\n-                        self.tcx.lang_items().sized_trait().unwrap(),\n-                        lhs_deref_ty,\n-                        ty::List::empty(),\n+                        self.tcx.require_lang_item(LangItem::Sized, None),\n+                        [lhs_deref_ty],\n                         self.param_env,\n                     )\n                     .may_apply();\n@@ -1616,10 +1616,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.demand_coerce_diag(&field.expr, ty, field_type, None, AllowTwoPhase::No);\n \n             if let Some(mut diag) = diag {\n-                if idx == ast_fields.len() - 1 && remaining_fields.is_empty() {\n-                    self.suggest_fru_from_range(field, variant, substs, &mut diag);\n+                if idx == ast_fields.len() - 1 {\n+                    if remaining_fields.is_empty() {\n+                        self.suggest_fru_from_range(field, variant, substs, &mut diag);\n+                        diag.emit();\n+                    } else {\n+                        diag.stash(field.span, StashKey::MaybeFruTypo);\n+                    }\n+                } else {\n+                    diag.emit();\n                 }\n-                diag.emit();\n             }\n         }\n \n@@ -1877,19 +1883,39 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 .map(|adt| adt.did())\n                 != range_def_id\n         {\n-            let instead = self\n+            // Suppress any range expr type mismatches\n+            if let Some(mut diag) = self\n+                .tcx\n+                .sess\n+                .diagnostic()\n+                .steal_diagnostic(last_expr_field.span, StashKey::MaybeFruTypo)\n+            {\n+                diag.delay_as_bug();\n+            }\n+\n+            // Use a (somewhat arbitrary) filtering heuristic to avoid printing\n+            // expressions that are either too long, or have control character\n+            //such as newlines in them.\n+            let expr = self\n                 .tcx\n                 .sess\n                 .source_map()\n                 .span_to_snippet(range_end.expr.span)\n-                .map(|s| format!(\" from `{s}`\"))\n-                .unwrap_or_default();\n-            err.span_suggestion(\n-                range_start.span.shrink_to_hi(),\n-                &format!(\"to set the remaining fields{instead}, separate the last named field with a comma\"),\n-                \",\",\n-                Applicability::MaybeIncorrect,\n-            );\n+                .ok()\n+                .filter(|s| s.len() < 25 && !s.contains(|c: char| c.is_control()));\n+\n+            let fru_span = self\n+                .tcx\n+                .sess\n+                .source_map()\n+                .span_extend_while(range_start.span, |c| c.is_whitespace())\n+                .unwrap_or(range_start.span).shrink_to_hi().to(range_end.span);\n+\n+            err.subdiagnostic(TypeMismatchFruTypo {\n+                expr_span: range_start.span,\n+                fru_span,\n+                expr,\n+            });\n         }\n     }\n \n@@ -1998,8 +2024,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n \n         let variant_ident_span = self.tcx.def_ident_span(variant.def_id).unwrap();\n-        match variant.ctor_kind {\n-            CtorKind::Fn => match ty.kind() {\n+        match variant.ctor_kind() {\n+            Some(CtorKind::Fn) => match ty.kind() {\n                 ty::Adt(adt, ..) if adt.is_enum() => {\n                     err.span_label(\n                         variant_ident_span,\n@@ -2307,12 +2333,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         base: &'tcx hir::Expr<'tcx>,\n         ty: Ty<'tcx>,\n     ) {\n-        let output_ty = match self.get_impl_future_output_ty(ty) {\n-            Some(output_ty) => self.resolve_vars_if_possible(output_ty),\n-            _ => return,\n-        };\n+        let Some(output_ty) = self.get_impl_future_output_ty(ty) else { return; };\n         let mut add_label = true;\n-        if let ty::Adt(def, _) = output_ty.skip_binder().kind() {\n+        if let ty::Adt(def, _) = output_ty.kind() {\n             // no field access on enum type\n             if !def.is_enum() {\n                 if def\n@@ -2798,7 +2821,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) {\n         for error in errors {\n             match error.obligation.predicate.kind().skip_binder() {\n-                ty::PredicateKind::Trait(predicate)\n+                ty::PredicateKind::Clause(ty::Clause::Trait(predicate))\n                     if self.tcx.is_diagnostic_item(sym::SliceIndex, predicate.trait_ref.def_id) => {\n                 }\n                 _ => continue,"}, {"sha": "994fe48c9fee0a21648f3fa28028e3c60f140a70", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -669,26 +669,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         self.fulfillment_cx.borrow().pending_obligations().into_iter().filter_map(\n             move |obligation| match &obligation.predicate.kind().skip_binder() {\n-                ty::PredicateKind::Projection(data)\n+                ty::PredicateKind::Clause(ty::Clause::Projection(data))\n                     if self.self_type_matches_expected_vid(\n                         data.projection_ty.self_ty(),\n                         ty_var_root,\n                     ) =>\n                 {\n                     Some(obligation)\n                 }\n-                ty::PredicateKind::Trait(data)\n+                ty::PredicateKind::Clause(ty::Clause::Trait(data))\n                     if self.self_type_matches_expected_vid(data.self_ty(), ty_var_root) =>\n                 {\n                     Some(obligation)\n                 }\n \n-                ty::PredicateKind::Trait(..)\n-                | ty::PredicateKind::Projection(..)\n+                ty::PredicateKind::Clause(ty::Clause::Trait(..))\n+                | ty::PredicateKind::Clause(ty::Clause::Projection(..))\n                 | ty::PredicateKind::Subtype(..)\n                 | ty::PredicateKind::Coerce(..)\n-                | ty::PredicateKind::RegionOutlives(..)\n-                | ty::PredicateKind::TypeOutlives(..)\n+                | ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..))\n+                | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(..))\n                 | ty::PredicateKind::WellFormed(..)\n                 | ty::PredicateKind::ObjectSafe(..)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n@@ -702,6 +702,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // code is looking for a self type of an unresolved\n                 // inference variable.\n                 | ty::PredicateKind::ClosureKind(..)\n+                | ty::PredicateKind::Ambiguous\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n             },\n         )\n@@ -711,7 +712,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let sized_did = self.tcx.lang_items().sized_trait();\n         self.obligations_for_self_ty(self_ty).any(|obligation| {\n             match obligation.predicate.kind().skip_binder() {\n-                ty::PredicateKind::Trait(data) => Some(data.def_id()) == sized_did,\n+                ty::PredicateKind::Clause(ty::Clause::Trait(data)) => {\n+                    Some(data.def_id()) == sized_did\n+                }\n                 _ => false,\n             }\n         })\n@@ -1164,11 +1167,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             match *ty.kind() {\n                 ty::Adt(adt_def, substs) if adt_def.has_ctor() => {\n                     let variant = adt_def.non_enum_variant();\n-                    let ctor_def_id = variant.ctor_def_id.unwrap();\n-                    (\n-                        Res::Def(DefKind::Ctor(CtorOf::Struct, variant.ctor_kind), ctor_def_id),\n-                        Some(substs),\n-                    )\n+                    let (ctor_kind, ctor_def_id) = variant.ctor.unwrap();\n+                    (Res::Def(DefKind::Ctor(CtorOf::Struct, ctor_kind), ctor_def_id), Some(substs))\n                 }\n                 _ => {\n                     let mut err = tcx.sess.struct_span_err("}, {"sha": "ecf6f458ca3f7723c84ddd1411ea4c1f2a9c2989", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -1734,22 +1734,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let hir = self.tcx.hir();\n         let hir::Node::Expr(expr) = hir.get(hir_id) else { return false; };\n \n-        // Skip over mentioning async lang item\n-        if Some(def_id) == self.tcx.lang_items().from_generator_fn()\n-            && error.obligation.cause.span.desugaring_kind()\n-                == Some(rustc_span::DesugaringKind::Async)\n-        {\n-            return false;\n-        }\n-\n         let Some(unsubstituted_pred) =\n             self.tcx.predicates_of(def_id).instantiate_identity(self.tcx).predicates.into_iter().nth(idx)\n             else { return false; };\n \n         let generics = self.tcx.generics_of(def_id);\n         let predicate_substs = match unsubstituted_pred.kind().skip_binder() {\n-            ty::PredicateKind::Trait(pred) => pred.trait_ref.substs,\n-            ty::PredicateKind::Projection(pred) => pred.projection_ty.substs,\n+            ty::PredicateKind::Clause(ty::Clause::Trait(pred)) => pred.trait_ref.substs,\n+            ty::PredicateKind::Clause(ty::Clause::Projection(pred)) => pred.projection_ty.substs,\n             _ => ty::List::empty(),\n         };\n \n@@ -2121,7 +2113,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         for (predicate, span) in\n                             std::iter::zip(instantiated.predicates, instantiated.spans)\n                         {\n-                            if let ty::PredicateKind::Trait(pred) = predicate.kind().skip_binder()\n+                            if let ty::PredicateKind::Clause(ty::Clause::Trait(pred)) = predicate.kind().skip_binder()\n                                 && pred.self_ty().peel_refs() == callee_ty\n                                 && ty::ClosureKind::from_def_id(self.tcx, pred.def_id()).is_some()\n                             {\n@@ -2157,11 +2149,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             self.tcx,\n                             traits::ObligationCause::dummy(),\n                             self.param_env,\n-                            ty::Binder::dummy(ty::TraitPredicate {\n-                                trait_ref,\n-                                constness: ty::BoundConstness::NotConst,\n-                                polarity: ty::ImplPolarity::Positive,\n-                            }),\n+                            ty::Binder::dummy(trait_ref),\n                         );\n                         match SelectionContext::new(&self).select(&obligation) {\n                             Ok(Some(traits::ImplSource::UserDefined(impl_source))) => {"}, {"sha": "ed5f7f31764fde1448af8301469880fef4da0f60", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -201,7 +201,9 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n             predicates: tcx.arena.alloc_from_iter(\n                 self.param_env.caller_bounds().iter().filter_map(|predicate| {\n                     match predicate.kind().skip_binder() {\n-                        ty::PredicateKind::Trait(data) if data.self_ty().is_param(index) => {\n+                        ty::PredicateKind::Clause(ty::Clause::Trait(data))\n+                            if data.self_ty().is_param(index) =>\n+                        {\n                             // HACK(eddyb) should get the original `Span`.\n                             let span = tcx.def_span(def_id);\n                             Some((predicate, span))"}, {"sha": "6c3526a71a3285955c12288b78aca34ff1d9a674", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -173,7 +173,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n                 ty::Opaque(def_id, substs) => {\n                     self.tcx.bound_item_bounds(def_id).subst(self.tcx, substs).iter().find_map(|pred| {\n-                        if let ty::PredicateKind::Projection(proj) = pred.kind().skip_binder()\n+                        if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = pred.kind().skip_binder()\n                         && Some(proj.projection_ty.item_def_id) == self.tcx.lang_items().fn_once_output()\n                         // args tuple will always be substs[1]\n                         && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n@@ -208,7 +208,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 ty::Param(param) => {\n                     let def_id = self.tcx.generics_of(self.body_id.owner).type_param(&param, self.tcx).def_id;\n                     self.tcx.predicates_of(self.body_id.owner).predicates.iter().find_map(|(pred, _)| {\n-                        if let ty::PredicateKind::Projection(proj) = pred.kind().skip_binder()\n+                        if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = pred.kind().skip_binder()\n                         && Some(proj.projection_ty.item_def_id) == self.tcx.lang_items().fn_once_output()\n                         && proj.projection_ty.self_ty() == found\n                         // args tuple will always be substs[1]\n@@ -345,8 +345,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             if annotation {\n                 let suggest_annotation = match expr.peel_drop_temps().kind {\n-                    hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Not, _) => \"&\",\n-                    hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Mut, _) => \"&mut \",\n+                    hir::ExprKind::AddrOf(hir::BorrowKind::Ref, mutbl, _) => mutbl.ref_prefix_str(),\n                     _ => return true,\n                 };\n                 let mut tuple_indexes = Vec::new();\n@@ -464,7 +463,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     ref_cnt += 1;\n                 }\n                 if let ty::Adt(adt, _) = peeled.kind()\n-                    && self.tcx.is_diagnostic_item(sym::String, adt.did())\n+                    && Some(adt.did()) == self.tcx.lang_items().string()\n                 {\n                     err.span_suggestion_verbose(\n                         expr.span.shrink_to_hi(),\n@@ -925,15 +924,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let ty = match self.tcx.asyncness(fn_id.owner) {\n                 hir::IsAsync::Async => {\n                     let infcx = self.tcx.infer_ctxt().build();\n-                    infcx\n-                        .get_impl_future_output_ty(ty)\n-                        .unwrap_or_else(|| {\n-                            span_bug!(\n-                                fn_decl.output.span(),\n-                                \"failed to get output type of async function\"\n-                            )\n-                        })\n-                        .skip_binder()\n+                    infcx.get_impl_future_output_ty(ty).unwrap_or_else(|| {\n+                        span_bug!(\n+                            fn_decl.output.span(),\n+                            \"failed to get output type of async function\"\n+                        )\n+                    })\n                 }\n                 hir::IsAsync::NotAsync => ty,\n             };\n@@ -1093,11 +1089,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.tcx,\n                 self.misc(expr.span),\n                 self.param_env,\n-                ty::Binder::dummy(ty::TraitRef {\n-                    def_id: into_def_id,\n-                    substs: self.tcx.mk_substs_trait(expr_ty, &[expected_ty.into()]),\n-                })\n-                .to_poly_trait_predicate(),\n+                ty::Binder::dummy(self.tcx.mk_trait_ref(\n+                    into_def_id,\n+                    [expr_ty, expected_ty]\n+                )),\n             ))\n         {\n             let sugg = if expr.precedence().order() >= PREC_POSTFIX {"}, {"sha": "fd8ea1ad7bff4c503d3e93203fe800a75601f995", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/cfg_build.rs", "status": "modified", "additions": 41, "deletions": 22, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -9,9 +9,10 @@ use hir::{\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_index::vec::IndexVec;\n+use rustc_infer::infer::InferCtxt;\n use rustc_middle::{\n     hir::map::Map,\n-    ty::{TyCtxt, TypeckResults},\n+    ty::{ParamEnv, TyCtxt, TypeVisitable, TypeckResults},\n };\n use std::mem::swap;\n \n@@ -21,20 +22,29 @@ use std::mem::swap;\n /// The resulting structure still needs to be iterated to a fixed point, which\n /// can be done with propagate_to_fixpoint in cfg_propagate.\n pub(super) fn build_control_flow_graph<'tcx>(\n-    hir: Map<'tcx>,\n-    tcx: TyCtxt<'tcx>,\n+    infcx: &InferCtxt<'tcx>,\n     typeck_results: &TypeckResults<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n     consumed_borrowed_places: ConsumedAndBorrowedPlaces,\n     body: &'tcx Body<'tcx>,\n     num_exprs: usize,\n ) -> (DropRangesBuilder, FxHashSet<HirId>) {\n-    let mut drop_range_visitor =\n-        DropRangeVisitor::new(hir, tcx, typeck_results, consumed_borrowed_places, num_exprs);\n+    let mut drop_range_visitor = DropRangeVisitor::new(\n+        infcx,\n+        typeck_results,\n+        param_env,\n+        consumed_borrowed_places,\n+        num_exprs,\n+    );\n     intravisit::walk_body(&mut drop_range_visitor, body);\n \n     drop_range_visitor.drop_ranges.process_deferred_edges();\n-    if let Some(filename) = &tcx.sess.opts.unstable_opts.dump_drop_tracking_cfg {\n-        super::cfg_visualize::write_graph_to_file(&drop_range_visitor.drop_ranges, filename, tcx);\n+    if let Some(filename) = &infcx.tcx.sess.opts.unstable_opts.dump_drop_tracking_cfg {\n+        super::cfg_visualize::write_graph_to_file(\n+            &drop_range_visitor.drop_ranges,\n+            filename,\n+            infcx.tcx,\n+        );\n     }\n \n     (drop_range_visitor.drop_ranges, drop_range_visitor.places.borrowed_temporaries)\n@@ -82,40 +92,44 @@ pub(super) fn build_control_flow_graph<'tcx>(\n /// ```\n \n struct DropRangeVisitor<'a, 'tcx> {\n-    hir: Map<'tcx>,\n+    typeck_results: &'a TypeckResults<'tcx>,\n+    infcx: &'a InferCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n     places: ConsumedAndBorrowedPlaces,\n     drop_ranges: DropRangesBuilder,\n     expr_index: PostOrderId,\n-    tcx: TyCtxt<'tcx>,\n-    typeck_results: &'a TypeckResults<'tcx>,\n     label_stack: Vec<(Option<rustc_ast::Label>, PostOrderId)>,\n }\n \n impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n     fn new(\n-        hir: Map<'tcx>,\n-        tcx: TyCtxt<'tcx>,\n+        infcx: &'a InferCtxt<'tcx>,\n         typeck_results: &'a TypeckResults<'tcx>,\n+        param_env: ParamEnv<'tcx>,\n         places: ConsumedAndBorrowedPlaces,\n         num_exprs: usize,\n     ) -> Self {\n         debug!(\"consumed_places: {:?}\", places.consumed);\n         let drop_ranges = DropRangesBuilder::new(\n             places.consumed.iter().flat_map(|(_, places)| places.iter().cloned()),\n-            hir,\n+            infcx.tcx.hir(),\n             num_exprs,\n         );\n         Self {\n-            hir,\n+            infcx,\n+            typeck_results,\n+            param_env,\n             places,\n             drop_ranges,\n             expr_index: PostOrderId::from_u32(0),\n-            typeck_results,\n-            tcx,\n             label_stack: vec![],\n         }\n     }\n \n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n     fn record_drop(&mut self, value: TrackedValue) {\n         if self.places.borrowed.contains(&value) {\n             debug!(\"not marking {:?} as dropped because it is borrowed at some point\", value);\n@@ -137,7 +151,7 @@ impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n             .map_or(vec![], |places| places.iter().cloned().collect());\n         for place in places {\n             trace!(?place, \"consuming place\");\n-            for_each_consumable(self.hir, place, |value| self.record_drop(value));\n+            for_each_consumable(self.tcx().hir(), place, |value| self.record_drop(value));\n         }\n     }\n \n@@ -214,10 +228,15 @@ impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n     /// return.\n     fn handle_uninhabited_return(&mut self, expr: &Expr<'tcx>) {\n         let ty = self.typeck_results.expr_ty(expr);\n-        let ty = self.tcx.erase_regions(ty);\n-        let m = self.tcx.parent_module(expr.hir_id).to_def_id();\n-        let param_env = self.tcx.param_env(m.expect_local());\n-        if self.tcx.is_ty_uninhabited_from(m, ty, param_env) {\n+        let ty = self.infcx.resolve_vars_if_possible(ty);\n+        if ty.has_non_region_infer() {\n+            self.tcx()\n+                .sess\n+                .delay_span_bug(expr.span, format!(\"could not resolve infer vars in `{ty}`\"));\n+        }\n+        let ty = self.tcx().erase_regions(ty);\n+        let m = self.tcx().parent_module(expr.hir_id).to_def_id();\n+        if !ty.is_inhabited_from(self.tcx(), m, self.param_env) {\n             // This function will not return. We model this fact as an infinite loop.\n             self.drop_ranges.add_control_edge(self.expr_index + 1, self.expr_index + 1);\n         }\n@@ -238,7 +257,7 @@ impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n         destination: hir::Destination,\n     ) -> Result<HirId, LoopIdError> {\n         destination.target_id.map(|target| {\n-            let node = self.hir.get(target);\n+            let node = self.tcx().hir().get(target);\n             match node {\n                 hir::Node::Expr(_) => target,\n                 hir::Node::Block(b) => find_last_block_expression(b),"}, {"sha": "2abcadcc9ce7de4f6335daf6c9febc0ca8d3a6c4", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fmod.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -43,9 +43,9 @@ pub fn compute_drop_ranges<'a, 'tcx>(\n         let typeck_results = &fcx.typeck_results.borrow();\n         let num_exprs = fcx.tcx.region_scope_tree(def_id).body_expr_count(body.id()).unwrap_or(0);\n         let (mut drop_ranges, borrowed_temporaries) = build_control_flow_graph(\n-            fcx.tcx.hir(),\n-            fcx.tcx,\n+            &fcx,\n             typeck_results,\n+            fcx.param_env,\n             consumed_borrowed_places,\n             body,\n             num_exprs,"}, {"sha": "50722c42a6c611ce7d96a8f64276468eb6932628", "filename": "compiler/rustc_hir_typeck/src/generator_interior/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -98,8 +98,8 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n                 expr, scope, ty, self.expr_count, yield_data.span\n             );\n \n-            if let Some((unresolved_type, unresolved_type_span)) =\n-                self.fcx.unresolved_type_vars(&ty)\n+            if let Some((unresolved_term, unresolved_type_span)) =\n+                self.fcx.first_unresolved_const_or_ty_var(&ty)\n             {\n                 // If unresolved type isn't a ty_var then unresolved_type_span is None\n                 let span = self\n@@ -108,21 +108,21 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n \n                 // If we encounter an int/float variable, then inference fallback didn't\n                 // finish due to some other error. Don't emit spurious additional errors.\n-                if let ty::Infer(ty::InferTy::IntVar(_) | ty::InferTy::FloatVar(_)) =\n-                    unresolved_type.kind()\n+                if let Some(unresolved_ty) = unresolved_term.ty()\n+                    && let ty::Infer(ty::InferTy::IntVar(_) | ty::InferTy::FloatVar(_)) = unresolved_ty.kind()\n                 {\n                     self.fcx\n                         .tcx\n                         .sess\n-                        .delay_span_bug(span, &format!(\"Encountered var {:?}\", unresolved_type));\n+                        .delay_span_bug(span, &format!(\"Encountered var {:?}\", unresolved_term));\n                 } else {\n                     let note = format!(\n                         \"the type is part of the {} because of this {}\",\n                         self.kind, yield_data.source\n                     );\n \n                     self.fcx\n-                        .need_type_info_err_in_generator(self.kind, span, unresolved_type)\n+                        .need_type_info_err_in_generator(self.kind, span, unresolved_term)\n                         .span_note(yield_data.span, &*note)\n                         .emit();\n                 }\n@@ -162,7 +162,7 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n                 expr.map(|e| e.span)\n             );\n             if let Some((unresolved_type, unresolved_type_span)) =\n-                self.fcx.unresolved_type_vars(&ty)\n+                self.fcx.first_unresolved_const_or_ty_var(&ty)\n             {\n                 debug!(\n                     \"remained unresolved_type = {:?}, unresolved_type_span: {:?}\",\n@@ -542,10 +542,10 @@ fn check_must_not_suspend_ty<'tcx>(\n     data: SuspendCheckData<'_, 'tcx>,\n ) -> bool {\n     if ty.is_unit()\n-    // FIXME: should this check `is_ty_uninhabited_from`. This query is not available in this stage\n+    // FIXME: should this check `Ty::is_inhabited_from`. This query is not available in this stage\n     // of typeck (before ReVar and RePlaceholder are removed), but may remove noise, like in\n     // `must_use`\n-    // || fcx.tcx.is_ty_uninhabited_from(fcx.tcx.parent_module(hir_id).to_def_id(), ty, fcx.param_env)\n+    // || !ty.is_inhabited_from(fcx.tcx, fcx.tcx.parent_module(hir_id).to_def_id(), fcx.param_env)\n     {\n         return false;\n     }\n@@ -566,7 +566,7 @@ fn check_must_not_suspend_ty<'tcx>(\n             let mut has_emitted = false;\n             for &(predicate, _) in fcx.tcx.explicit_item_bounds(def) {\n                 // We only look at the `DefId`, so it is safe to skip the binder here.\n-                if let ty::PredicateKind::Trait(ref poly_trait_predicate) =\n+                if let ty::PredicateKind::Clause(ty::Clause::Trait(ref poly_trait_predicate)) =\n                     predicate.kind().skip_binder()\n                 {\n                     let def_id = poly_trait_predicate.trait_ref.def_id;"}, {"sha": "c2dc14024655aeba39308b9efad08977356f5580", "filename": "compiler/rustc_hir_typeck/src/intrinsicck.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -3,7 +3,7 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_index::vec::Idx;\n use rustc_middle::ty::layout::{LayoutError, SizeSkeleton};\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitable};\n use rustc_target::abi::{Pointer, VariantIdx};\n \n use super::FnCtxt;\n@@ -46,7 +46,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let from = normalize(from);\n         let to = normalize(to);\n         trace!(?from, ?to);\n-\n+        if from.has_non_region_infer() || to.has_non_region_infer() {\n+            tcx.sess.delay_span_bug(span, \"argument to transmute has inference variables\");\n+            return;\n+        }\n         // Transmutes that are only changing lifetimes are always ok.\n         if from == to {\n             return;"}, {"sha": "5104b448023236628cbd331d9ef885033017b8b9", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -53,9 +53,9 @@ use crate::check::check_fn;\n use crate::coercion::DynamicCoerceMany;\n use crate::gather_locals::GatherLocalsVisitor;\n use rustc_data_structures::unord::UnordSet;\n-use rustc_errors::{struct_span_err, ErrorGuaranteed, MultiSpan};\n+use rustc_errors::{struct_span_err, DiagnosticId, ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n-use rustc_hir::def::Res;\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::{HirIdMap, Node};\n use rustc_hir_analysis::astconv::AstConv;\n@@ -433,15 +433,27 @@ fn report_unexpected_variant_res(\n     res: Res,\n     qpath: &hir::QPath<'_>,\n     span: Span,\n+    err_code: &str,\n+    expected: &str,\n ) -> ErrorGuaranteed {\n-    struct_span_err!(\n-        tcx.sess,\n+    let res_descr = match res {\n+        Res::Def(DefKind::Variant, _) => \"struct variant\",\n+        _ => res.descr(),\n+    };\n+    let path_str = rustc_hir_pretty::qpath_to_string(qpath);\n+    let mut err = tcx.sess.struct_span_err_with_code(\n         span,\n-        E0533,\n-        \"expected unit struct, unit variant or constant, found {} `{}`\",\n-        res.descr(),\n-        rustc_hir_pretty::qpath_to_string(qpath),\n-    )\n+        format!(\"expected {expected}, found {res_descr} `{path_str}`\"),\n+        DiagnosticId::Error(err_code.into()),\n+    );\n+    match res {\n+        Res::Def(DefKind::Fn | DefKind::AssocFn, _) if err_code == \"E0164\" => {\n+            let patterns_url = \"https://doc.rust-lang.org/book/ch18-00-patterns.html\";\n+            err.span_label(span, \"`fn` calls are not allowed in patterns\");\n+            err.help(format!(\"for more information, visit {patterns_url}\"))\n+        }\n+        _ => err.span_label(span, format!(\"not a {expected}\")),\n+    }\n     .emit()\n }\n "}, {"sha": "f50a16dcb236d58c640fd316a03d27090b1293ff", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -170,14 +170,11 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n                 let base_ty = target;\n \n                 target = self.tcx.mk_ref(region, ty::TypeAndMut { mutbl, ty: target });\n-                let mutbl = match mutbl {\n-                    hir::Mutability::Not => AutoBorrowMutability::Not,\n-                    hir::Mutability::Mut => AutoBorrowMutability::Mut {\n-                        // Method call receivers are the primary use case\n-                        // for two-phase borrows.\n-                        allow_two_phase_borrow: AllowTwoPhase::Yes,\n-                    },\n-                };\n+\n+                // Method call receivers are the primary use case\n+                // for two-phase borrows.\n+                let mutbl = AutoBorrowMutability::new(mutbl, AllowTwoPhase::Yes);\n+\n                 adjustments.push(Adjustment {\n                     kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n                     target,\n@@ -202,7 +199,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             Some(probe::AutorefOrPtrAdjustment::ToConstPtr) => {\n                 target = match target.kind() {\n                     &ty::RawPtr(ty::TypeAndMut { ty, mutbl }) => {\n-                        assert_eq!(mutbl, hir::Mutability::Mut);\n+                        assert!(mutbl.is_mut());\n                         self.tcx.mk_ptr(ty::TypeAndMut { mutbl: hir::Mutability::Not, ty })\n                     }\n                     other => panic!(\"Cannot adjust receiver type {:?} to const ptr\", other),\n@@ -531,7 +528,9 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         traits::elaborate_predicates(self.tcx, predicates.predicates.iter().copied())\n             // We don't care about regions here.\n             .filter_map(|obligation| match obligation.predicate.kind().skip_binder() {\n-                ty::PredicateKind::Trait(trait_pred) if trait_pred.def_id() == sized_def_id => {\n+                ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred))\n+                    if trait_pred.def_id() == sized_def_id =>\n+                {\n                     let span = iter::zip(&predicates.predicates, &predicates.spans)\n                         .find_map(\n                             |(p, span)| {"}, {"sha": "9c2de1763b080cf43859f8a9540a10a0c6366e03", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -348,7 +348,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     },\n                 ),\n                 self.param_env,\n-                poly_trait_ref.without_const(),\n+                poly_trait_ref,\n             ),\n             substs,\n         )\n@@ -566,23 +566,25 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let tcx = self.tcx;\n \n         // Check if we have an enum variant.\n+        let mut struct_variant = None;\n         if let ty::Adt(adt_def, _) = self_ty.kind() {\n             if adt_def.is_enum() {\n                 let variant_def = adt_def\n                     .variants()\n                     .iter()\n                     .find(|vd| tcx.hygienic_eq(method_name, vd.ident(tcx), adt_def.did()));\n                 if let Some(variant_def) = variant_def {\n-                    // Braced variants generate unusable names in value namespace (reserved for\n-                    // possible future use), so variants resolved as associated items may refer to\n-                    // them as well. It's ok to use the variant's id as a ctor id since an\n-                    // error will be reported on any use of such resolution anyway.\n-                    let ctor_def_id = variant_def.ctor_def_id.unwrap_or(variant_def.def_id);\n-                    tcx.check_stability(ctor_def_id, Some(expr_id), span, Some(method_name.span));\n-                    return Ok((\n-                        DefKind::Ctor(CtorOf::Variant, variant_def.ctor_kind),\n-                        ctor_def_id,\n-                    ));\n+                    if let Some((ctor_kind, ctor_def_id)) = variant_def.ctor {\n+                        tcx.check_stability(\n+                            ctor_def_id,\n+                            Some(expr_id),\n+                            span,\n+                            Some(method_name.span),\n+                        );\n+                        return Ok((DefKind::Ctor(CtorOf::Variant, ctor_kind), ctor_def_id));\n+                    } else {\n+                        struct_variant = Some((DefKind::Variant, variant_def.def_id));\n+                    }\n                 }\n             }\n         }\n@@ -594,7 +596,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self_ty,\n             expr_id,\n             ProbeScope::TraitsInScope,\n-        )?;\n+        );\n+        let pick = match (pick, struct_variant) {\n+            // Fall back to a resolution that will produce an error later.\n+            (Err(_), Some(res)) => return Ok(res),\n+            (pick, _) => pick?,\n+        };\n \n         pick.maybe_emit_unstable_name_collision_hint(self.tcx, span, expr_id);\n "}, {"sha": "dea14dd93d6acd15e0ec4199ad0f677b5461ce6b", "filename": "compiler/rustc_hir_typeck/src/method/prelude2021.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprelude2021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprelude2021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprelude2021.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -5,10 +5,9 @@ use crate::{\n use hir::def_id::DefId;\n use hir::HirId;\n use hir::ItemKind;\n-use rustc_ast::Mutability;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_middle::ty::subst::InternalSubsts;\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::ty::{Adt, Array, Ref, Ty};\n use rustc_session::lint::builtin::RUST_2021_PRELUDE_COLLISIONS;\n use rustc_span::symbol::kw::{Empty, Underscore};\n@@ -88,14 +87,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let derefs = \"*\".repeat(pick.autoderefs);\n \n                     let autoref = match pick.autoref_or_ptr_adjustment {\n-                        Some(probe::AutorefOrPtrAdjustment::Autoref {\n-                            mutbl: Mutability::Mut,\n-                            ..\n-                        }) => \"&mut \",\n-                        Some(probe::AutorefOrPtrAdjustment::Autoref {\n-                            mutbl: Mutability::Not,\n-                            ..\n-                        }) => \"&\",\n+                        Some(probe::AutorefOrPtrAdjustment::Autoref { mutbl, .. }) => {\n+                            mutbl.ref_prefix_str()\n+                        }\n                         Some(probe::AutorefOrPtrAdjustment::ToConstPtr) | None => \"\",\n                     };\n                     if let Ok(self_expr) = self.sess().source_map().span_to_snippet(self_expr.span)\n@@ -227,14 +221,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // If we know it does not, we don't need to warn.\n         if method_name.name == sym::from_iter {\n             if let Some(trait_def_id) = self.tcx.get_diagnostic_item(sym::FromIterator) {\n+                let any_type = self.infcx.next_ty_var(TypeVariableOrigin {\n+                    kind: TypeVariableOriginKind::MiscVariable,\n+                    span,\n+                });\n                 if !self\n                     .infcx\n-                    .type_implements_trait(\n-                        trait_def_id,\n-                        self_ty,\n-                        InternalSubsts::empty(),\n-                        self.param_env,\n-                    )\n+                    .type_implements_trait(trait_def_id, [self_ty, any_type], self.param_env)\n                     .may_apply()\n                 {\n                     return;\n@@ -387,8 +380,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let derefs = \"*\".repeat(pick.autoderefs);\n \n         let autoref = match pick.autoref_or_ptr_adjustment {\n-            Some(probe::AutorefOrPtrAdjustment::Autoref { mutbl: Mutability::Mut, .. }) => \"&mut \",\n-            Some(probe::AutorefOrPtrAdjustment::Autoref { mutbl: Mutability::Not, .. }) => \"&\",\n+            Some(probe::AutorefOrPtrAdjustment::Autoref { mutbl, .. }) => mutbl.ref_prefix_str(),\n             Some(probe::AutorefOrPtrAdjustment::ToConstPtr) | None => \"\",\n         };\n "}, {"sha": "6d858eacb45a38fc0cf1a307c7df01ae507cc998", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -31,6 +31,7 @@ use rustc_span::lev_distance::{\n use rustc_span::symbol::sym;\n use rustc_span::{symbol::Ident, Span, Symbol, DUMMY_SP};\n use rustc_trait_selection::autoderef::{self, Autoderef};\n+use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::query::method_autoderef::MethodAutoderefBadTy;\n use rustc_trait_selection::traits::query::method_autoderef::{\n@@ -716,9 +717,10 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             // maybe shouldn't include `Param`s, but rather fresh variables or be canonicalized,\n             // see issue #89650\n             let cause = traits::ObligationCause::misc(self.span, self.body_id);\n-            let selcx = &mut traits::SelectionContext::new(self.fcx);\n-            let traits::Normalized { value: xform_self_ty, obligations } =\n-                traits::normalize(selcx, self.param_env, cause, xform_self_ty);\n+            let InferOk { value: xform_self_ty, obligations } = self\n+                .fcx\n+                .partially_normalize_associated_types_in(cause, self.param_env, xform_self_ty);\n+\n             debug!(\n                 \"assemble_inherent_impl_probe after normalization: xform_self_ty = {:?}/{:?}\",\n                 xform_self_ty, xform_ret_ty\n@@ -785,7 +787,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         let bounds = self.param_env.caller_bounds().iter().filter_map(|predicate| {\n             let bound_predicate = predicate.kind();\n             match bound_predicate.skip_binder() {\n-                ty::PredicateKind::Trait(trait_predicate) => {\n+                ty::PredicateKind::Clause(ty::Clause::Trait(trait_predicate)) => {\n                     match *trait_predicate.trait_ref.self_ty().kind() {\n                         ty::Param(p) if p == param_ty => {\n                             Some(bound_predicate.rebind(trait_predicate.trait_ref))\n@@ -795,14 +797,15 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 }\n                 ty::PredicateKind::Subtype(..)\n                 | ty::PredicateKind::Coerce(..)\n-                | ty::PredicateKind::Projection(..)\n-                | ty::PredicateKind::RegionOutlives(..)\n+                | ty::PredicateKind::Clause(ty::Clause::Projection(..))\n+                | ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..))\n                 | ty::PredicateKind::WellFormed(..)\n                 | ty::PredicateKind::ObjectSafe(..)\n                 | ty::PredicateKind::ClosureKind(..)\n-                | ty::PredicateKind::TypeOutlives(..)\n+                | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(..))\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..)\n+                | ty::PredicateKind::Ambiguous\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n             }\n         });\n@@ -1429,7 +1432,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         trait_ref: ty::TraitRef<'tcx>,\n     ) -> traits::SelectionResult<'tcx, traits::Selection<'tcx>> {\n         let cause = traits::ObligationCause::misc(self.span, self.body_id);\n-        let predicate = ty::Binder::dummy(trait_ref).to_poly_trait_predicate();\n+        let predicate = ty::Binder::dummy(trait_ref);\n         let obligation = traits::Obligation::new(self.tcx, cause, self.param_env, predicate);\n         traits::SelectionContext::new(self).select(&obligation)\n     }\n@@ -1489,7 +1492,6 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             let mut xform_ret_ty = probe.xform_ret_ty;\n             debug!(?xform_ret_ty);\n \n-            let selcx = &mut traits::SelectionContext::new(self);\n             let cause = traits::ObligationCause::misc(self.span, self.body_id);\n \n             let mut parent_pred = None;\n@@ -1503,19 +1505,28 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     // `xform_ret_ty` hasn't been normalized yet, only `xform_self_ty`,\n                     // see the reasons mentioned in the comments in `assemble_inherent_impl_probe`\n                     // for why this is necessary\n-                    let traits::Normalized {\n+                    let InferOk {\n                         value: normalized_xform_ret_ty,\n                         obligations: normalization_obligations,\n-                    } = traits::normalize(selcx, self.param_env, cause.clone(), probe.xform_ret_ty);\n+                    } = self.fcx.partially_normalize_associated_types_in(\n+                        cause.clone(),\n+                        self.param_env,\n+                        probe.xform_ret_ty,\n+                    );\n                     xform_ret_ty = normalized_xform_ret_ty;\n                     debug!(\"xform_ret_ty after normalization: {:?}\", xform_ret_ty);\n \n                     // Check whether the impl imposes obligations we have to worry about.\n                     let impl_def_id = probe.item.container_id(self.tcx);\n                     let impl_bounds = self.tcx.predicates_of(impl_def_id);\n                     let impl_bounds = impl_bounds.instantiate(self.tcx, substs);\n-                    let traits::Normalized { value: impl_bounds, obligations: norm_obligations } =\n-                        traits::normalize(selcx, self.param_env, cause.clone(), impl_bounds);\n+\n+                    let InferOk { value: impl_bounds, obligations: norm_obligations } =\n+                        self.fcx.partially_normalize_associated_types_in(\n+                            cause.clone(),\n+                            self.param_env,\n+                            impl_bounds,\n+                        );\n \n                     // Convert the bounds into obligations.\n                     let impl_obligations = traits::predicates_for_generics("}, {"sha": "727fab9e7aa1e7df85b4d31bb27ce265d9423b3f", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 28, "deletions": 38, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -68,16 +68,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.autoderef(span, ty).any(|(ty, _)| {\n                     info!(\"check deref {:?} impl FnOnce\", ty);\n                     self.probe(|_| {\n-                        let fn_once_substs = tcx.mk_substs_trait(\n-                            ty,\n-                            &[self\n-                                .next_ty_var(TypeVariableOrigin {\n+                        let trait_ref = tcx.mk_trait_ref(\n+                            fn_once,\n+                            [\n+                                ty,\n+                                self.next_ty_var(TypeVariableOrigin {\n                                     kind: TypeVariableOriginKind::MiscVariable,\n                                     span,\n-                                })\n-                                .into()],\n+                                }),\n+                            ],\n                         );\n-                        let trait_ref = ty::TraitRef::new(fn_once, fn_once_substs);\n                         let poly_trait_ref = ty::Binder::dummy(trait_ref);\n                         let obligation = Obligation::misc(\n                             tcx,\n@@ -442,7 +442,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let mut unimplemented_traits = FxHashMap::default();\n                     let mut unimplemented_traits_only = true;\n                     for (predicate, _parent_pred, cause) in &unsatisfied_predicates {\n-                        if let (ty::PredicateKind::Trait(p), Some(cause)) =\n+                        if let (ty::PredicateKind::Clause(ty::Clause::Trait(p)), Some(cause)) =\n                             (predicate.kind().skip_binder(), cause.as_ref())\n                         {\n                             if p.trait_ref.self_ty() != rcvr_ty {\n@@ -469,7 +469,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // because of some non-Clone item being iterated over.\n                     for (predicate, _parent_pred, _cause) in &unsatisfied_predicates {\n                         match predicate.kind().skip_binder() {\n-                            ty::PredicateKind::Trait(p)\n+                            ty::PredicateKind::Clause(ty::Clause::Trait(p))\n                                 if unimplemented_traits.contains_key(&p.trait_ref.def_id) => {}\n                             _ => {\n                                 unimplemented_traits_only = false;\n@@ -481,7 +481,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let mut collect_type_param_suggestions =\n                         |self_ty: Ty<'tcx>, parent_pred: ty::Predicate<'tcx>, obligation: &str| {\n                             // We don't care about regions here, so it's fine to skip the binder here.\n-                            if let (ty::Param(_), ty::PredicateKind::Trait(p)) =\n+                            if let (ty::Param(_), ty::PredicateKind::Clause(ty::Clause::Trait(p))) =\n                                 (self_ty.kind(), parent_pred.kind().skip_binder())\n                             {\n                                 let hir = self.tcx.hir();\n@@ -544,7 +544,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let mut format_pred = |pred: ty::Predicate<'tcx>| {\n                         let bound_predicate = pred.kind();\n                         match bound_predicate.skip_binder() {\n-                            ty::PredicateKind::Projection(pred) => {\n+                            ty::PredicateKind::Clause(ty::Clause::Projection(pred)) => {\n                                 let pred = bound_predicate.rebind(pred);\n                                 // `<Foo as Iterator>::Item = String`.\n                                 let projection_ty = pred.skip_binder().projection_ty;\n@@ -567,7 +567,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 bound_span_label(projection_ty.self_ty(), &obligation, &quiet);\n                                 Some((obligation, projection_ty.self_ty()))\n                             }\n-                            ty::PredicateKind::Trait(poly_trait_ref) => {\n+                            ty::PredicateKind::Clause(ty::Clause::Trait(poly_trait_ref)) => {\n                                 let p = poly_trait_ref.trait_ref;\n                                 let self_ty = p.self_ty();\n                                 let path = p.print_only_trait_path();\n@@ -637,7 +637,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 let sized_pred =\n                                     unsatisfied_predicates.iter().any(|(pred, _, _)| {\n                                         match pred.kind().skip_binder() {\n-                                            ty::PredicateKind::Trait(pred) => {\n+                                            ty::PredicateKind::Clause(ty::Clause::Trait(pred)) => {\n                                                 Some(pred.def_id())\n                                                     == self.tcx.lang_items().sized_trait()\n                                                     && pred.polarity == ty::ImplPolarity::Positive\n@@ -821,10 +821,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 ty.is_str()\n                                     || matches!(\n                                         ty.kind(),\n-                                        ty::Adt(adt, _) if self.tcx.is_diagnostic_item(sym::String, adt.did())\n+                                        ty::Adt(adt, _) if Some(adt.did()) == self.tcx.lang_items().string()\n                                     )\n                             }\n-                            ty::Adt(adt, _) => self.tcx.is_diagnostic_item(sym::String, adt.did()),\n+                            ty::Adt(adt, _) => Some(adt.did()) == self.tcx.lang_items().string(),\n                             _ => false,\n                         };\n                         if is_string_or_ref_str && item_name.name == sym::iter {\n@@ -1147,19 +1147,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 && assoc.kind == ty::AssocKind::Fn\n             {\n                 let sig = self.tcx.fn_sig(assoc.def_id);\n-                if let Some(first) = sig.inputs().skip_binder().get(0) {\n-                    if first.peel_refs() == rcvr_ty.peel_refs() {\n-                        None\n-                    } else {\n-                        Some(if first.is_region_ptr() {\n-                            if first.is_mutable_ptr() { \"&mut \" } else { \"&\" }\n-                        } else {\n-                            \"\"\n-                        })\n-                    }\n-                } else {\n+                sig.inputs().skip_binder().get(0).and_then(|first| if first.peel_refs() == rcvr_ty.peel_refs() {\n                     None\n-                }\n+                } else {\n+                    Some(first.ref_mutability().map_or(\"\", |mutbl| mutbl.ref_prefix_str()))\n+                })\n             } else {\n                 None\n             };\n@@ -1722,7 +1714,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) {\n         let all_local_types_needing_impls =\n             errors.iter().all(|e| match e.obligation.predicate.kind().skip_binder() {\n-                ty::PredicateKind::Trait(pred) => match pred.self_ty().kind() {\n+                ty::PredicateKind::Clause(ty::Clause::Trait(pred)) => match pred.self_ty().kind() {\n                     ty::Adt(def, _) => def.did().is_local(),\n                     _ => false,\n                 },\n@@ -1731,7 +1723,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut preds: Vec<_> = errors\n             .iter()\n             .filter_map(|e| match e.obligation.predicate.kind().skip_binder() {\n-                ty::PredicateKind::Trait(pred) => Some(pred),\n+                ty::PredicateKind::Clause(ty::Clause::Trait(pred)) => Some(pred),\n                 _ => None,\n             })\n             .collect();\n@@ -1802,7 +1794,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut derives = Vec::<(String, Span, Symbol)>::new();\n         let mut traits = Vec::<Span>::new();\n         for (pred, _, _) in unsatisfied_predicates {\n-            let ty::PredicateKind::Trait(trait_pred) = pred.kind().skip_binder() else { continue };\n+            let ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) = pred.kind().skip_binder() else { continue };\n             let adt = match trait_pred.self_ty().ty_adt_def() {\n                 Some(adt) if adt.did().is_local() => adt,\n                 _ => continue,\n@@ -1960,7 +1952,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n     ) {\n         let output_ty = match self.get_impl_future_output_ty(ty) {\n-            Some(output_ty) => self.resolve_vars_if_possible(output_ty).skip_binder(),\n+            Some(output_ty) => self.resolve_vars_if_possible(output_ty),\n             _ => return,\n         };\n         let method_exists = self.method_exists(item_name, output_ty, call.hir_id, true);\n@@ -2212,8 +2204,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     match p.kind().skip_binder() {\n                         // Hide traits if they are present in predicates as they can be fixed without\n                         // having to implement them.\n-                        ty::PredicateKind::Trait(t) => t.def_id() == info.def_id,\n-                        ty::PredicateKind::Projection(p) => {\n+                        ty::PredicateKind::Clause(ty::Clause::Trait(t)) => {\n+                            t.def_id() == info.def_id\n+                        }\n+                        ty::PredicateKind::Clause(ty::Clause::Projection(p)) => {\n                             p.projection_ty.item_def_id == info.def_id\n                         }\n                         _ => false,\n@@ -2625,11 +2619,7 @@ fn print_disambiguation_help<'tcx>(\n     let (span, sugg) = if let (ty::AssocKind::Fn, Some((receiver, args))) = (kind, args) {\n         let args = format!(\n             \"({}{})\",\n-            if rcvr_ty.is_region_ptr() {\n-                if rcvr_ty.is_mutable_ptr() { \"&mut \" } else { \"&\" }\n-            } else {\n-                \"\"\n-            },\n+            rcvr_ty.ref_mutability().map_or(\"\", |mutbl| mutbl.ref_prefix_str()),\n             std::iter::once(receiver)\n                 .chain(args.iter())\n                 .map(|arg| source_map.span_to_snippet(arg.span).unwrap_or_else(|_| {"}, {"sha": "b12d84af4adbca81f0e04f1b7e36e092c70a872f", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -263,14 +263,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let by_ref_binop = !op.node.is_by_value();\n                 if is_assign == IsAssign::Yes || by_ref_binop {\n                     if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].kind() {\n-                        let mutbl = match mutbl {\n-                            hir::Mutability::Not => AutoBorrowMutability::Not,\n-                            hir::Mutability::Mut => AutoBorrowMutability::Mut {\n-                                // Allow two-phase borrows for binops in initial deployment\n-                                // since they desugar to methods\n-                                allow_two_phase_borrow: AllowTwoPhase::Yes,\n-                            },\n-                        };\n+                        let mutbl = AutoBorrowMutability::new(*mutbl, AllowTwoPhase::Yes);\n                         let autoref = Adjustment {\n                             kind: Adjust::Borrow(AutoBorrow::Ref(*region, mutbl)),\n                             target: method.sig.inputs()[0],\n@@ -280,14 +273,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n                 if by_ref_binop {\n                     if let ty::Ref(region, _, mutbl) = method.sig.inputs()[1].kind() {\n-                        let mutbl = match mutbl {\n-                            hir::Mutability::Not => AutoBorrowMutability::Not,\n-                            hir::Mutability::Mut => AutoBorrowMutability::Mut {\n-                                // Allow two-phase borrows for binops in initial deployment\n-                                // since they desugar to methods\n-                                allow_two_phase_borrow: AllowTwoPhase::Yes,\n-                            },\n-                        };\n+                        // Allow two-phase borrows for binops in initial deployment\n+                        // since they desugar to methods\n+                        let mutbl = AutoBorrowMutability::new(*mutbl, AllowTwoPhase::Yes);\n+\n                         let autoref = Adjustment {\n                             kind: Adjust::Borrow(AutoBorrow::Ref(*region, mutbl)),\n                             target: method.sig.inputs()[1],\n@@ -556,9 +545,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let rm_borrow_msg = \"remove the borrow to obtain an owned `String`\";\n         let to_owned_msg = \"create an owned `String` from a string reference\";\n \n+        let string_type = self.tcx.lang_items().string();\n         let is_std_string = |ty: Ty<'tcx>| {\n-            ty.ty_adt_def()\n-                .map_or(false, |ty_def| self.tcx.is_diagnostic_item(sym::String, ty_def.did()))\n+            ty.ty_adt_def().map_or(false, |ty_def| Some(ty_def.did()) == string_type)\n         };\n \n         match (lhs_ty.kind(), rhs_ty.kind()) {"}, {"sha": "decd317d9fc9b1e3a8943e9419bd0dedbb66e5eb", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 20, "deletions": 31, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -401,6 +401,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n+        if self.tcx.features().string_deref_patterns && let hir::ExprKind::Lit(Spanned { node: ast::LitKind::Str(..), .. }) = lt.kind {\n+            let tcx = self.tcx;\n+            let expected = self.resolve_vars_if_possible(expected);\n+            pat_ty = match expected.kind() {\n+                ty::Adt(def, _) if Some(def.did()) == tcx.lang_items().string() => expected,\n+                ty::Str => tcx.mk_static_str(),\n+                _ => pat_ty,\n+            };\n+        }\n+\n         // Somewhat surprising: in this case, the subtyping relation goes the\n         // opposite way as the other cases. Actually what we really want is not\n         // a subtyping relation at all but rather that there exists a LUB\n@@ -692,7 +702,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             };\n \n             let mut_var_suggestion = 'block: {\n-                if !matches!(mutbl, ast::Mutability::Mut) {\n+                if mutbl.is_not() {\n                     break 'block None;\n                 }\n \n@@ -739,7 +749,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         format!(\"to take parameter `{binding}` by reference, move `&{mutability}` to the type\"),\n                         vec![\n                             (pat.span.until(inner.span), \"\".to_owned()),\n-                            (ty_span.shrink_to_lo(), format!(\"&{}\", mutbl.prefix_str())),\n+                            (ty_span.shrink_to_lo(), mutbl.ref_prefix_str().to_owned()),\n                         ],\n                         Applicability::MachineApplicable\n                     );\n@@ -843,8 +853,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.set_tainted_by_errors(e);\n                 return tcx.ty_error_with_guaranteed(e);\n             }\n-            Res::Def(DefKind::AssocFn | DefKind::Ctor(_, CtorKind::Fictive | CtorKind::Fn), _) => {\n-                let e = report_unexpected_variant_res(tcx, res, qpath, pat.span);\n+            Res::Def(DefKind::AssocFn | DefKind::Ctor(_, CtorKind::Fn) | DefKind::Variant, _) => {\n+                let expected = \"unit struct, unit variant or constant\";\n+                let e = report_unexpected_variant_res(tcx, res, qpath, pat.span, \"E0533\", expected);\n                 return tcx.ty_error_with_guaranteed(e);\n             }\n             Res::SelfCtor(..)\n@@ -992,30 +1003,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         };\n         let report_unexpected_res = |res: Res| {\n-            let sm = tcx.sess.source_map();\n-            let path_str = sm\n-                .span_to_snippet(sm.span_until_char(pat.span, '('))\n-                .map_or_else(|_| String::new(), |s| format!(\" `{}`\", s.trim_end()));\n-            let msg = format!(\n-                \"expected tuple struct or tuple variant, found {}{}\",\n-                res.descr(),\n-                path_str\n-            );\n-\n-            let mut err = struct_span_err!(tcx.sess, pat.span, E0164, \"{msg}\");\n-            match res {\n-                Res::Def(DefKind::Fn | DefKind::AssocFn, _) => {\n-                    err.span_label(pat.span, \"`fn` calls are not allowed in patterns\");\n-                    err.help(\n-                        \"for more information, visit \\\n-                              https://doc.rust-lang.org/book/ch18-00-patterns.html\",\n-                    );\n-                }\n-                _ => {\n-                    err.span_label(pat.span, \"not a tuple variant or struct\");\n-                }\n-            }\n-            let e = err.emit();\n+            let expected = \"tuple struct or tuple variant\";\n+            let e = report_unexpected_variant_res(tcx, res, qpath, pat.span, \"E0164\", expected);\n             on_error(e);\n             e\n         };\n@@ -1471,8 +1460,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // if this is a tuple struct, then all field names will be numbers\n         // so if any fields in a struct pattern use shorthand syntax, they will\n         // be invalid identifiers (for example, Foo { 0, 1 }).\n-        if let (CtorKind::Fn, PatKind::Struct(qpath, field_patterns, ..)) =\n-            (variant.ctor_kind, &pat.kind)\n+        if let (Some(CtorKind::Fn), PatKind::Struct(qpath, field_patterns, ..)) =\n+            (variant.ctor_kind(), &pat.kind)\n         {\n             let has_shorthand_field_name = field_patterns.iter().any(|field| field.is_shorthand);\n             if has_shorthand_field_name {\n@@ -1649,7 +1638,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         fields: &'tcx [hir::PatField<'tcx>],\n         variant: &ty::VariantDef,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        if let (CtorKind::Fn, PatKind::Struct(qpath, ..)) = (variant.ctor_kind, &pat.kind) {\n+        if let (Some(CtorKind::Fn), PatKind::Struct(qpath, ..)) = (variant.ctor_kind(), &pat.kind) {\n             let path = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| {\n                 s.print_qpath(qpath, false)\n             });"}, {"sha": "68f119adc7a7cb6392a1164fcb7c087ed2dda8aa", "filename": "compiler/rustc_hir_typeck/src/upvar.rs", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -970,12 +970,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 check_trait\n                     .map(|check_trait| {\n                         self.infcx\n-                            .type_implements_trait(\n-                                check_trait,\n-                                ty,\n-                                self.tcx.mk_substs_trait(ty, &[]),\n-                                self.param_env,\n-                            )\n+                            .type_implements_trait(check_trait, [ty], self.param_env)\n                             .must_apply_modulo_regions()\n                     })\n                     .unwrap_or(false),\n@@ -999,12 +994,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     check_trait\n                         .map(|check_trait| {\n                             self.infcx\n-                                .type_implements_trait(\n-                                    check_trait,\n-                                    ty,\n-                                    self.tcx.mk_substs_trait(ty, &[]),\n-                                    self.param_env,\n-                                )\n+                                .type_implements_trait(check_trait, [ty], self.param_env)\n                                 .must_apply_modulo_regions()\n                         })\n                         .unwrap_or(false),\n@@ -1347,14 +1337,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let is_drop_defined_for_ty = |ty: Ty<'tcx>| {\n             let drop_trait = self.tcx.require_lang_item(hir::LangItem::Drop, Some(closure_span));\n-            let ty_params = self.tcx.mk_substs_trait(base_path_ty, &[]);\n             self.infcx\n-                .type_implements_trait(\n-                    drop_trait,\n-                    ty,\n-                    ty_params,\n-                    self.tcx.param_env(closure_def_id),\n-                )\n+                .type_implements_trait(drop_trait, [ty], self.tcx.param_env(closure_def_id))\n                 .must_apply_modulo_regions()\n         };\n "}, {"sha": "58ced6a1d3b4ffb90308cd91e64d1012b1c245df", "filename": "compiler/rustc_hir_typeck/src/writeback.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -361,9 +361,12 @@ impl<'cx, 'tcx> Visitor<'tcx> for WritebackCx<'cx, 'tcx> {\n \n     fn visit_ty(&mut self, hir_ty: &'tcx hir::Ty<'tcx>) {\n         intravisit::walk_ty(self, hir_ty);\n-        let ty = self.fcx.node_ty(hir_ty.hir_id);\n-        let ty = self.resolve(ty, &hir_ty.span);\n-        self.write_ty_to_typeck_results(hir_ty.hir_id, ty);\n+        // If there are type checking errors, Type privacy pass will stop,\n+        // so we may not get the type from hid_id, see #104513\n+        if let Some(ty) = self.fcx.node_ty_opt(hir_ty.hir_id) {\n+            let ty = self.resolve(ty, &hir_ty.span);\n+            self.write_ty_to_typeck_results(hir_ty.hir_id, ty);\n+        }\n     }\n \n     fn visit_infer(&mut self, inf: &'tcx hir::InferArg) {"}, {"sha": "58d6e6d7efd69c0d757ff903b4356a586904f7d9", "filename": "compiler/rustc_incremental/src/persist/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -322,7 +322,7 @@ pub fn finalize_session_directory(sess: &Session, svh: Svh) {\n \n     let incr_comp_session_dir: PathBuf = sess.incr_comp_session_dir().clone();\n \n-    if sess.has_errors_or_delayed_span_bugs() {\n+    if let Some(_) = sess.has_errors_or_delayed_span_bugs() {\n         // If there have been any errors during compilation, we don't want to\n         // publish this session directory. Rather, we'll just delete it.\n "}, {"sha": "6e9dcdd981ec4d87b265686aec3789e2a3c23868", "filename": "compiler/rustc_incremental/src/persist/save.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -28,7 +28,7 @@ pub fn save_dep_graph(tcx: TyCtxt<'_>) {\n             return;\n         }\n         // This is going to be deleted in finalize_session_directory, so let's not create it\n-        if sess.has_errors_or_delayed_span_bugs() {\n+        if let Some(_) = sess.has_errors_or_delayed_span_bugs() {\n             return;\n         }\n \n@@ -89,7 +89,7 @@ pub fn save_work_product_index(\n         return;\n     }\n     // This is going to be deleted in finalize_session_directory, so let's not create it\n-    if sess.has_errors_or_delayed_span_bugs() {\n+    if let Some(_) = sess.has_errors_or_delayed_span_bugs() {\n         return;\n     }\n "}, {"sha": "e1cda5a9edda30f8b8d4a3154bbe7b467650c66f", "filename": "compiler/rustc_index/Cargo.toml", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_index%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_index%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2FCargo.toml?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -7,6 +7,10 @@ edition = \"2021\"\n \n [dependencies]\n arrayvec = { version = \"0.7\", default-features = false }\n-rustc_serialize = { path = \"../rustc_serialize\" }\n-rustc_macros = { path = \"../rustc_macros\" }\n+rustc_serialize = { path = \"../rustc_serialize\", optional = true }\n+rustc_macros = { path = \"../rustc_macros\", optional = true }\n smallvec = \"1.8.1\"\n+\n+[features]\n+default = [\"nightly\"]\n+nightly = [\"rustc_serialize\", \"rustc_macros\"]"}, {"sha": "db2c791525645ba156e3e9b3eff440c5d0eacbcd", "filename": "compiler/rustc_index/src/lib.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_index%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_index%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Flib.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -1,17 +1,25 @@\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n-#![feature(allow_internal_unstable)]\n-#![feature(extend_one)]\n-#![feature(min_specialization)]\n-#![feature(new_uninit)]\n-#![feature(step_trait)]\n-#![feature(stmt_expr_attributes)]\n-#![feature(test)]\n+#![cfg_attr(\n+    feature = \"nightly\",\n+    feature(\n+        allow_internal_unstable,\n+        extend_one,\n+        min_specialization,\n+        new_uninit,\n+        step_trait,\n+        stmt_expr_attributes,\n+        test\n+    )\n+)]\n \n+#[cfg(feature = \"nightly\")]\n pub mod bit_set;\n+#[cfg(feature = \"nightly\")]\n pub mod interval;\n pub mod vec;\n \n+#[cfg(feature = \"rustc_macros\")]\n pub use rustc_macros::newtype_index;\n \n /// Type size assertion. The first argument is a type and the second argument is its expected size."}, {"sha": "39aa27a23c1d2ceeb62825d123893566f57729be", "filename": "compiler/rustc_index/src/vec.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fvec.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -1,3 +1,4 @@\n+#[cfg(feature = \"rustc_serialize\")]\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n \n use std::fmt;\n@@ -17,10 +18,12 @@ pub trait Idx: Copy + 'static + Eq + PartialEq + Debug + Hash {\n \n     fn index(self) -> usize;\n \n+    #[inline]\n     fn increment_by(&mut self, amount: usize) {\n         *self = self.plus(amount);\n     }\n \n+    #[inline]\n     fn plus(self, amount: usize) -> Self {\n         Self::new(self.index() + amount)\n     }\n@@ -59,12 +62,14 @@ pub struct IndexVec<I: Idx, T> {\n // not the phantom data.\n unsafe impl<I: Idx, T> Send for IndexVec<I, T> where T: Send {}\n \n+#[cfg(feature = \"rustc_serialize\")]\n impl<S: Encoder, I: Idx, T: Encodable<S>> Encodable<S> for IndexVec<I, T> {\n     fn encode(&self, s: &mut S) {\n         Encodable::encode(&self.raw, s);\n     }\n }\n \n+#[cfg(feature = \"rustc_serialize\")]\n impl<D: Decoder, I: Idx, T: Decodable<D>> Decodable<D> for IndexVec<I, T> {\n     fn decode(d: &mut D) -> Self {\n         IndexVec { raw: Decodable::decode(d), _marker: PhantomData }\n@@ -357,11 +362,13 @@ impl<I: Idx, T> Extend<T> for IndexVec<I, T> {\n     }\n \n     #[inline]\n+    #[cfg(feature = \"nightly\")]\n     fn extend_one(&mut self, item: T) {\n         self.raw.push(item);\n     }\n \n     #[inline]\n+    #[cfg(feature = \"nightly\")]\n     fn extend_reserve(&mut self, additional: usize) {\n         self.raw.reserve(additional);\n     }"}, {"sha": "74c4c65cc1729a981db0c42c44e4c57d355cf6cd", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -375,7 +375,7 @@ impl AddToDiagnostic for AddLifetimeParamsSuggestion<'_> {\n                 return false;\n             };\n \n-            if !lifetime_sub.name.is_anonymous() || !lifetime_sup.name.is_anonymous() {\n+            if !lifetime_sub.is_anonymous() || !lifetime_sup.is_anonymous() {\n                 return false;\n             };\n \n@@ -407,20 +407,20 @@ impl AddToDiagnostic for AddLifetimeParamsSuggestion<'_> {\n             let suggestion_param_name =\n                 suggestion_param_name.map(|n| n.to_string()).unwrap_or_else(|| \"'a\".to_owned());\n \n-            debug!(?lifetime_sup.span);\n-            debug!(?lifetime_sub.span);\n-            let make_suggestion = |span: rustc_span::Span| {\n-                if span.is_empty() {\n-                    (span, format!(\"{}, \", suggestion_param_name))\n-                } else if let Ok(\"&\") = self.tcx.sess.source_map().span_to_snippet(span).as_deref()\n-                {\n-                    (span.shrink_to_hi(), format!(\"{} \", suggestion_param_name))\n+            debug!(?lifetime_sup.ident.span);\n+            debug!(?lifetime_sub.ident.span);\n+            let make_suggestion = |ident: Ident| {\n+                let sugg = if ident.name == kw::Empty {\n+                    format!(\"{}, \", suggestion_param_name)\n+                } else if ident.name == kw::UnderscoreLifetime && ident.span.is_empty() {\n+                    format!(\"{} \", suggestion_param_name)\n                 } else {\n-                    (span, suggestion_param_name.clone())\n-                }\n+                    suggestion_param_name.clone()\n+                };\n+                (ident.span, sugg)\n             };\n             let mut suggestions =\n-                vec![make_suggestion(lifetime_sub.span), make_suggestion(lifetime_sup.span)];\n+                vec![make_suggestion(lifetime_sub.ident), make_suggestion(lifetime_sup.ident)];\n \n             if introduce_new {\n                 let new_param_suggestion = if let Some(first) ="}, {"sha": "2483ab724a4e32142a0e7078f1a277d22ba38131", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -81,6 +81,7 @@ impl<'tcx> InferCtxt<'tcx> {\n                 .normalize_fn_sig_for_diagnostic\n                 .as_ref()\n                 .map(|f| f.clone()),\n+            intercrate: self.intercrate,\n         }\n     }\n }"}, {"sha": "996b1c40e3fd6301438e538dff730135ad4b3348", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -23,11 +23,10 @@ use rustc_index::vec::Idx;\n use rustc_index::vec::IndexVec;\n use rustc_middle::arena::ArenaAllocatable;\n use rustc_middle::mir::ConstraintCategory;\n-use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, BoundVar, Const, ToPredicate, Ty, TyCtxt};\n+use rustc_middle::ty::{self, BoundVar, ToPredicate, Ty, TyCtxt};\n use rustc_span::Span;\n use std::fmt::Debug;\n use std::iter;\n@@ -570,10 +569,10 @@ impl<'tcx> InferCtxt<'tcx> {\n \n         let atom = match k1.unpack() {\n             GenericArgKind::Lifetime(r1) => {\n-                ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(r1, r2))\n+                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(ty::OutlivesPredicate(r1, r2)))\n             }\n             GenericArgKind::Type(t1) => {\n-                ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(t1, r2))\n+                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(t1, r2)))\n             }\n             GenericArgKind::Const(..) => {\n                 // Consts cannot outlive one another, so we don't expect to\n@@ -721,18 +720,14 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n         self.obligations.push(Obligation {\n             cause: self.cause.clone(),\n             param_env: self.param_env,\n-            predicate: ty::Binder::dummy(ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(\n-                sup, sub,\n+            predicate: ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::RegionOutlives(\n+                ty::OutlivesPredicate(sup, sub),\n             )))\n             .to_predicate(self.infcx.tcx),\n             recursion_depth: 0,\n         });\n     }\n \n-    fn const_equate(&mut self, _a: Const<'tcx>, _b: Const<'tcx>) {\n-        span_bug!(self.cause.span(), \"generic_const_exprs: unreachable `const_equate`\");\n-    }\n-\n     fn normalization() -> NormalizationStrategy {\n         NormalizationStrategy::Eager\n     }\n@@ -741,11 +736,7 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n         true\n     }\n \n-    fn register_opaque_type_obligations(\n-        &mut self,\n-        obligations: PredicateObligations<'tcx>,\n-    ) -> Result<(), TypeError<'tcx>> {\n+    fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>) {\n         self.obligations.extend(obligations);\n-        Ok(())\n     }\n }"}, {"sha": "eec938cefbb70a0494b1e0f000c3a3338c174236", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -450,6 +450,15 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             ty::Binder::dummy(predicate),\n         ));\n     }\n+\n+    pub fn mark_ambiguous(&mut self) {\n+        self.obligations.push(Obligation::new(\n+            self.tcx(),\n+            self.trace.cause.clone(),\n+            self.param_env,\n+            ty::Binder::dummy(ty::PredicateKind::Ambiguous),\n+        ));\n+    }\n }\n \n struct Generalizer<'cx, 'tcx> {\n@@ -521,6 +530,11 @@ impl<'tcx> TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n+\n+    fn intercrate(&self) -> bool {\n+        self.infcx.intercrate\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.param_env\n     }\n@@ -533,6 +547,10 @@ impl<'tcx> TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n         true\n     }\n \n+    fn mark_ambiguous(&mut self) {\n+        span_bug!(self.cause.span, \"opaque types are handled in `tys`\");\n+    }\n+\n     fn binders<T>(\n         &mut self,\n         a: ty::Binder<'tcx, T>,\n@@ -564,6 +582,7 @@ impl<'tcx> TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                 &opt_variances,\n                 a_subst,\n                 b_subst,\n+                true,\n             )\n         }\n     }\n@@ -656,6 +675,10 @@ impl<'tcx> TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                 // relatable.\n                 Ok(t)\n             }\n+            ty::Opaque(def_id, substs) => {\n+                let s = self.relate(substs, substs)?;\n+                Ok(if s == substs { t } else { self.infcx.tcx.mk_opaque(def_id, s) })\n+            }\n             _ => relate::super_relate_tys(self, t, t),\n         }?;\n \n@@ -798,6 +821,11 @@ impl<'tcx> TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n         self.infcx.tcx\n     }\n \n+    fn intercrate(&self) -> bool {\n+        assert!(!self.infcx.intercrate);\n+        false\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.param_env\n     }\n@@ -810,6 +838,10 @@ impl<'tcx> TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n         true\n     }\n \n+    fn mark_ambiguous(&mut self) {\n+        bug!()\n+    }\n+\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _variance: ty::Variance,"}, {"sha": "8682f4d3b7aed970783395d50e8ca09a8b648d64", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -32,6 +32,10 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n         self.fields.tcx()\n     }\n \n+    fn intercrate(&self) -> bool {\n+        self.fields.infcx.intercrate\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.fields.param_env\n     }\n@@ -40,6 +44,10 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n         self.a_is_expected\n     }\n \n+    fn mark_ambiguous(&mut self) {\n+        self.fields.mark_ambiguous();\n+    }\n+\n     fn relate_item_substs(\n         &mut self,\n         _item_def_id: DefId,"}, {"sha": "6b6be7359a599ef339de8665c1f280a2a3bdfa0c", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -65,7 +65,7 @@ use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n use rustc_errors::{pluralize, struct_span_err, Diagnostic, ErrorGuaranteed, IntoDiagnosticArg};\n use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString, MultiSpan};\n use rustc_hir as hir;\n-use rustc_hir::def::DefKind;\n+use rustc_hir::def::{CtorKind, DefKind};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n@@ -74,7 +74,7 @@ use rustc_middle::dep_graph::DepContext;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::relate::{self, RelateResult, TypeRelation};\n use rustc_middle::ty::{\n-    self, error::TypeError, Binder, List, Region, Ty, TyCtxt, TypeFoldable, TypeSuperVisitable,\n+    self, error::TypeError, List, Region, Ty, TyCtxt, TypeFoldable, TypeSuperVisitable,\n     TypeVisitable,\n };\n use rustc_span::{sym, symbol::kw, BytePos, DesugaringKind, Pos, Span};\n@@ -261,6 +261,7 @@ fn label_msg_span(\n     }\n }\n \n+#[instrument(level = \"trace\", skip(tcx))]\n pub fn unexpected_hidden_region_diagnostic<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     span: Span,\n@@ -338,33 +339,28 @@ pub fn unexpected_hidden_region_diagnostic<'tcx>(\n }\n \n impl<'tcx> InferCtxt<'tcx> {\n-    pub fn get_impl_future_output_ty(&self, ty: Ty<'tcx>) -> Option<Binder<'tcx, Ty<'tcx>>> {\n-        if let ty::Opaque(def_id, substs) = ty.kind() {\n-            let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n-            // Future::Output\n-            let item_def_id = self.tcx.associated_item_def_ids(future_trait)[0];\n+    pub fn get_impl_future_output_ty(&self, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n+        let ty::Opaque(def_id, substs) = *ty.kind() else { return None; };\n \n-            let bounds = self.tcx.bound_explicit_item_bounds(*def_id);\n+        let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n+        let item_def_id = self.tcx.associated_item_def_ids(future_trait)[0];\n \n-            for (predicate, _) in bounds.subst_iter_copied(self.tcx, substs) {\n-                let output = predicate\n+        self.tcx.bound_explicit_item_bounds(def_id).subst_iter_copied(self.tcx, substs).find_map(\n+            |(predicate, _)| {\n+                predicate\n                     .kind()\n                     .map_bound(|kind| match kind {\n-                        ty::PredicateKind::Projection(projection_predicate)\n+                        ty::PredicateKind::Clause(ty::Clause::Projection(projection_predicate))\n                             if projection_predicate.projection_ty.item_def_id == item_def_id =>\n                         {\n                             projection_predicate.term.ty()\n                         }\n                         _ => None,\n                     })\n-                    .transpose();\n-                if output.is_some() {\n-                    // We don't account for multiple `Future::Output = Ty` constraints.\n-                    return output;\n-                }\n-            }\n-        }\n-        None\n+                    .no_bound_vars()\n+                    .flatten()\n+            },\n+        )\n     }\n }\n \n@@ -542,7 +538,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n \n             fn print_dyn_existential(\n                 self,\n-                _predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n+                _predicates: &'tcx ty::List<ty::PolyExistentialPredicate<'tcx>>,\n             ) -> Result<Self::DynExistential, Self::Error> {\n                 Err(NonTrivialPath)\n             }\n@@ -1966,7 +1962,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     .variants()\n                     .iter()\n                     .filter(|variant| {\n-                        variant.fields.len() == 1 && variant.ctor_kind == hir::def::CtorKind::Fn\n+                        variant.fields.len() == 1 && variant.ctor_kind() == Some(CtorKind::Fn)\n                     })\n                     .filter_map(|variant| {\n                         let sole_field = &variant.fields[0];\n@@ -2054,8 +2050,8 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         }\n \n         match (\n-            self.get_impl_future_output_ty(exp_found.expected).map(Binder::skip_binder),\n-            self.get_impl_future_output_ty(exp_found.found).map(Binder::skip_binder),\n+            self.get_impl_future_output_ty(exp_found.expected),\n+            self.get_impl_future_output_ty(exp_found.found),\n         ) {\n             (Some(exp), Some(found)) if self.same_type_modulo_infer(exp, found) => match cause\n                 .code()\n@@ -2936,6 +2932,11 @@ impl<'tcx> TypeRelation<'tcx> for SameTypeModuloInfer<'_, 'tcx> {\n         self.0.tcx\n     }\n \n+    fn intercrate(&self) -> bool {\n+        assert!(!self.0.intercrate);\n+        false\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         // Unused, only for consts which we treat as always equal\n         ty::ParamEnv::empty()\n@@ -2949,6 +2950,10 @@ impl<'tcx> TypeRelation<'tcx> for SameTypeModuloInfer<'_, 'tcx> {\n         true\n     }\n \n+    fn mark_ambiguous(&mut self) {\n+        bug!()\n+    }\n+\n     fn relate_with_variance<T: relate::Relate<'tcx>>(\n         &mut self,\n         _variance: ty::Variance,"}, {"sha": "8ff1639a3a24b489e1f8ffc1d039e77a298fda4f", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -15,7 +15,7 @@ use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{Body, Closure, Expr, ExprKind, FnRetTy, HirId, Local, LocalSource};\n use rustc_middle::hir::nested_filter;\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n-use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n use rustc_middle::ty::print::{FmtPrinter, PrettyPrinter, Print, Printer};\n use rustc_middle::ty::{self, DefIdTree, InferConst};\n use rustc_middle::ty::{GenericArg, GenericArgKind, SubstsRef};\n@@ -508,10 +508,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     [\n                         ..,\n                         Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(_, mut_)), target: _ },\n-                    ] => match mut_ {\n-                        AutoBorrowMutability::Mut { .. } => \"&mut \",\n-                        AutoBorrowMutability::Not => \"&\",\n-                    },\n+                    ] => hir::Mutability::from(*mut_).ref_prefix_str(),\n                     _ => \"\",\n                 };\n \n@@ -571,7 +568,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         &self,\n         kind: hir::GeneratorKind,\n         span: Span,\n-        ty: Ty<'tcx>,\n+        ty: ty::Term<'tcx>,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let ty = self.resolve_vars_if_possible(ty);\n         let data = self.extract_inference_diagnostics_data(ty.into(), None);"}, {"sha": "09f9aa3c84220981537e7c5734dd90c0a4dbb5a8", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -314,10 +314,10 @@ pub fn suggest_new_region_bound(\n                     .iter()\n                     .filter_map(|arg| match arg {\n                         GenericBound::Outlives(Lifetime {\n-                            name: LifetimeName::Static,\n-                            span,\n+                            res: LifetimeName::Static,\n+                            ident,\n                             ..\n-                        }) => Some(*span),\n+                        }) => Some(ident.span),\n                         _ => None,\n                     })\n                     .next()\n@@ -342,10 +342,10 @@ pub fn suggest_new_region_bound(\n                     .bounds\n                     .iter()\n                     .filter_map(|arg| match arg {\n-                        GenericBound::Outlives(Lifetime { name, span, .. })\n-                            if name.ident().to_string() == lifetime_name =>\n+                        GenericBound::Outlives(Lifetime { ident, .. })\n+                            if ident.name.to_string() == lifetime_name =>\n                         {\n-                            Some(*span)\n+                            Some(ident.span)\n                         }\n                         _ => None,\n                     })\n@@ -361,8 +361,8 @@ pub fn suggest_new_region_bound(\n                     );\n                 }\n             }\n-            TyKind::TraitObject(_, lt, _) => match lt.name {\n-                LifetimeName::ImplicitObjectLifetimeDefault => {\n+            TyKind::TraitObject(_, lt, _) => {\n+                if let LifetimeName::ImplicitObjectLifetimeDefault = lt.res {\n                     err.span_suggestion_verbose(\n                         fn_return.span.shrink_to_hi(),\n                         &format!(\n@@ -374,15 +374,14 @@ pub fn suggest_new_region_bound(\n                         &plus_lt,\n                         Applicability::MaybeIncorrect,\n                     );\n-                }\n-                name if name.ident().to_string() != lifetime_name => {\n+                } else if lt.ident.name.to_string() != lifetime_name {\n                     // With this check we avoid suggesting redundant bounds. This\n                     // would happen if there are nested impl/dyn traits and only\n                     // one of them has the bound we'd suggest already there, like\n                     // in `impl Foo<X = dyn Bar> + '_`.\n                     if let Some(explicit_static) = &explicit_static {\n                         err.span_suggestion_verbose(\n-                            lt.span,\n+                            lt.ident.span,\n                             &format!(\"{} the trait object's {}\", consider, explicit_static),\n                             &lifetime_name,\n                             Applicability::MaybeIncorrect,\n@@ -397,8 +396,7 @@ pub fn suggest_new_region_bound(\n                         );\n                     }\n                 }\n-                _ => {}\n-            },\n+            }\n             _ => {}\n         }\n     }\n@@ -561,7 +559,7 @@ impl<'a, 'tcx> Visitor<'tcx> for HirTraitObjectVisitor<'a> {\n     fn visit_ty(&mut self, t: &'tcx hir::Ty<'tcx>) {\n         if let TyKind::TraitObject(\n             poly_trait_refs,\n-            Lifetime { name: LifetimeName::ImplicitObjectLifetimeDefault, .. },\n+            Lifetime { res: LifetimeName::ImplicitObjectLifetimeDefault, .. },\n             _,\n         ) = t.kind\n         {"}, {"sha": "27a94ec5e30e105cea6c5fe923344c0086d758e2", "filename": "compiler/rustc_infer/src/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -248,6 +248,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             ty::ConstKind::Param(_)\n             | ty::ConstKind::Value(_)\n             | ty::ConstKind::Unevaluated(..)\n+            | ty::ConstKind::Expr(..)\n             | ty::ConstKind::Error(_) => ct.super_fold_with(self),\n         }\n     }"}, {"sha": "7f27b35a54e4f8808c0350a30677abd61d77bed8", "filename": "compiler/rustc_infer/src/infer/glb.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -30,6 +30,11 @@ impl<'tcx> TypeRelation<'tcx> for Glb<'_, '_, 'tcx> {\n         \"Glb\"\n     }\n \n+    fn intercrate(&self) -> bool {\n+        assert!(!self.fields.infcx.intercrate);\n+        false\n+    }\n+\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.fields.tcx()\n     }\n@@ -42,6 +47,10 @@ impl<'tcx> TypeRelation<'tcx> for Glb<'_, '_, 'tcx> {\n         self.a_is_expected\n     }\n \n+    fn mark_ambiguous(&mut self) {\n+        bug!(\"mark_ambiguous used outside of coherence\");\n+    }\n+\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,"}, {"sha": "97ed4729bd0d9e67af8250645909cc3ba567950a", "filename": "compiler/rustc_infer/src/infer/lub.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -30,6 +30,11 @@ impl<'tcx> TypeRelation<'tcx> for Lub<'_, '_, 'tcx> {\n         \"Lub\"\n     }\n \n+    fn intercrate(&self) -> bool {\n+        assert!(!self.fields.infcx.intercrate);\n+        false\n+    }\n+\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.fields.tcx()\n     }\n@@ -42,6 +47,10 @@ impl<'tcx> TypeRelation<'tcx> for Lub<'_, '_, 'tcx> {\n         self.a_is_expected\n     }\n \n+    fn mark_ambiguous(&mut self) {\n+        bug!(\"mark_ambiguous used outside of coherence\");\n+    }\n+\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,"}, {"sha": "cda9299dcb6e795cdf0705f6a90ebe60c51976f7", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 51, "deletions": 50, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -23,7 +23,6 @@ use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKin\n use rustc_middle::mir::interpret::{ErrorHandled, EvalToValTreeResult};\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::traits::select;\n-use rustc_middle::ty::abstract_const::{AbstractConst, FailureKind};\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::fold::BoundVarReplacerDelegate;\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeSuperFoldable};\n@@ -337,6 +336,26 @@ pub struct InferCtxt<'tcx> {\n \n     normalize_fn_sig_for_diagnostic:\n         Option<Lrc<dyn Fn(&InferCtxt<'tcx>, ty::PolyFnSig<'tcx>) -> ty::PolyFnSig<'tcx>>>,\n+\n+    /// During coherence we have to assume that other crates may add\n+    /// additional impls which we currently don't know about.\n+    ///\n+    /// To deal with this evaluation should be conservative\n+    /// and consider the possibility of impls from outside this crate.\n+    /// This comes up primarily when resolving ambiguity. Imagine\n+    /// there is some trait reference `$0: Bar` where `$0` is an\n+    /// inference variable. If `intercrate` is true, then we can never\n+    /// say for sure that this reference is not implemented, even if\n+    /// there are *no impls at all for `Bar`*, because `$0` could be\n+    /// bound to some type that in a downstream crate that implements\n+    /// `Bar`.\n+    ///\n+    /// Outside of coherence we set this to false because we are only\n+    /// interested in types that the user could actually have written.\n+    /// In other words, we consider `$0: Bar` to be unimplemented if\n+    /// there is no type that the user could *actually name* that\n+    /// would satisfy it. This avoids crippling inference, basically.\n+    pub intercrate: bool,\n }\n \n /// See the `error_reporting` module for more details.\n@@ -552,6 +571,8 @@ pub struct InferCtxtBuilder<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     defining_use_anchor: DefiningAnchor,\n     considering_regions: bool,\n+    /// Whether we are in coherence mode.\n+    intercrate: bool,\n     normalize_fn_sig_for_diagnostic:\n         Option<Lrc<dyn Fn(&InferCtxt<'tcx>, ty::PolyFnSig<'tcx>) -> ty::PolyFnSig<'tcx>>>,\n }\n@@ -567,6 +588,7 @@ impl<'tcx> TyCtxtInferExt<'tcx> for TyCtxt<'tcx> {\n             defining_use_anchor: DefiningAnchor::Error,\n             considering_regions: true,\n             normalize_fn_sig_for_diagnostic: None,\n+            intercrate: false,\n         }\n     }\n }\n@@ -583,6 +605,11 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n         self\n     }\n \n+    pub fn intercrate(mut self) -> Self {\n+        self.intercrate = true;\n+        self\n+    }\n+\n     pub fn ignoring_regions(mut self) -> Self {\n         self.considering_regions = false;\n         self\n@@ -622,6 +649,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n             defining_use_anchor,\n             considering_regions,\n             ref normalize_fn_sig_for_diagnostic,\n+            intercrate,\n         } = *self;\n         InferCtxt {\n             tcx,\n@@ -641,6 +669,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n             normalize_fn_sig_for_diagnostic: normalize_fn_sig_for_diagnostic\n                 .as_ref()\n                 .map(|f| f.clone()),\n+            intercrate,\n         }\n     }\n }\n@@ -683,32 +712,6 @@ impl<'tcx> InferCtxt<'tcx> {\n         TypeErrCtxt { infcx: self, typeck_results: None, fallback_has_occurred: false }\n     }\n \n-    /// calls `tcx.try_unify_abstract_consts` after\n-    /// canonicalizing the consts.\n-    #[instrument(skip(self), level = \"debug\")]\n-    pub fn try_unify_abstract_consts(\n-        &self,\n-        a: ty::UnevaluatedConst<'tcx>,\n-        b: ty::UnevaluatedConst<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> bool {\n-        // Reject any attempt to unify two unevaluated constants that contain inference\n-        // variables, since inference variables in queries lead to ICEs.\n-        if a.substs.has_non_region_infer()\n-            || b.substs.has_non_region_infer()\n-            || param_env.has_non_region_infer()\n-        {\n-            debug!(\"a or b or param_env contain infer vars in its substs -> cannot unify\");\n-            return false;\n-        }\n-\n-        let param_env_and = param_env.and((a, b));\n-        let erased = self.tcx.erase_regions(param_env_and);\n-        debug!(\"after erase_regions: {:?}\", erased);\n-\n-        self.tcx.try_unify_abstract_consts(erased)\n-    }\n-\n     pub fn is_in_snapshot(&self) -> bool {\n         self.in_snapshot.get()\n     }\n@@ -1418,16 +1421,15 @@ impl<'tcx> InferCtxt<'tcx> {\n         value.fold_with(&mut r)\n     }\n \n-    /// Returns the first unresolved variable contained in `T`. In the\n-    /// process of visiting `T`, this will resolve (where possible)\n-    /// type variables in `T`, but it never constructs the final,\n-    /// resolved type, so it's more efficient than\n-    /// `resolve_vars_if_possible()`.\n-    pub fn unresolved_type_vars<T>(&self, value: &T) -> Option<(Ty<'tcx>, Option<Span>)>\n+    /// Returns the first unresolved type or const variable contained in `T`.\n+    pub fn first_unresolved_const_or_ty_var<T>(\n+        &self,\n+        value: &T,\n+    ) -> Option<(ty::Term<'tcx>, Option<Span>)>\n     where\n         T: TypeVisitable<'tcx>,\n     {\n-        value.visit_with(&mut resolve::UnresolvedTypeFinder::new(self)).break_value()\n+        value.visit_with(&mut resolve::UnresolvedTypeOrConstFinder::new(self)).break_value()\n     }\n \n     pub fn probe_const_var(\n@@ -1616,34 +1618,33 @@ impl<'tcx> InferCtxt<'tcx> {\n \n         // Postpone the evaluation of constants whose substs depend on inference\n         // variables\n+        let tcx = self.tcx;\n         if substs.has_non_region_infer() {\n-            let ac = AbstractConst::new(self.tcx, unevaluated);\n-            match ac {\n-                Ok(None) => {\n-                    substs = InternalSubsts::identity_for_item(self.tcx, unevaluated.def.did);\n-                    param_env = self.tcx.param_env(unevaluated.def.did);\n-                }\n-                Ok(Some(ct)) => {\n-                    if ct.unify_failure_kind(self.tcx) == FailureKind::Concrete {\n-                        substs = replace_param_and_infer_substs_with_placeholder(self.tcx, substs);\n-                    } else {\n-                        return Err(ErrorHandled::TooGeneric);\n-                    }\n+            if let Some(ct) = tcx.bound_abstract_const(unevaluated.def)? {\n+                let ct = tcx.expand_abstract_consts(ct.subst(tcx, substs));\n+                if let Err(e) = ct.error_reported() {\n+                    return Err(ErrorHandled::Reported(e));\n+                } else if ct.has_non_region_infer() || ct.has_non_region_param() {\n+                    return Err(ErrorHandled::TooGeneric);\n+                } else {\n+                    substs = replace_param_and_infer_substs_with_placeholder(tcx, substs);\n                 }\n-                Err(guar) => return Err(ErrorHandled::Reported(guar)),\n+            } else {\n+                substs = InternalSubsts::identity_for_item(tcx, unevaluated.def.did);\n+                param_env = tcx.param_env(unevaluated.def.did);\n             }\n         }\n \n-        let param_env_erased = self.tcx.erase_regions(param_env);\n-        let substs_erased = self.tcx.erase_regions(substs);\n+        let param_env_erased = tcx.erase_regions(param_env);\n+        let substs_erased = tcx.erase_regions(substs);\n         debug!(?param_env_erased);\n         debug!(?substs_erased);\n \n         let unevaluated = ty::UnevaluatedConst { def: unevaluated.def, substs: substs_erased };\n \n         // The return value is the evaluated value which doesn't contain any reference to inference\n         // variables, thus we don't need to substitute back the original values.\n-        self.tcx.const_eval_resolve_for_typeck(param_env_erased, unevaluated, span)\n+        tcx.const_eval_resolve_for_typeck(param_env_erased, unevaluated, span)\n     }\n \n     /// `ty_or_const_infer_var_changed` is equivalent to one of these two:"}, {"sha": "4f8460955c3de0d4098673c597666ecc09d52dbf", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 33, "deletions": 9, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -25,7 +25,7 @@ use crate::infer::combine::ConstEquateRelation;\n use crate::infer::InferCtxt;\n use crate::infer::{ConstVarValue, ConstVariableValue};\n use crate::infer::{TypeVariableOrigin, TypeVariableOriginKind};\n-use crate::traits::PredicateObligation;\n+use crate::traits::{Obligation, PredicateObligation};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::error::TypeError;\n@@ -92,11 +92,7 @@ pub trait TypeRelatingDelegate<'tcx> {\n         info: ty::VarianceDiagInfo<'tcx>,\n     );\n \n-    fn const_equate(&mut self, a: ty::Const<'tcx>, b: ty::Const<'tcx>);\n-    fn register_opaque_type_obligations(\n-        &mut self,\n-        obligations: Vec<PredicateObligation<'tcx>>,\n-    ) -> Result<(), TypeError<'tcx>>;\n+    fn register_obligations(&mut self, obligations: Vec<PredicateObligation<'tcx>>);\n \n     /// Creates a new universe index. Used when instantiating placeholders.\n     fn create_next_universe(&mut self) -> ty::UniverseIndex;\n@@ -419,7 +415,7 @@ where\n             .infcx\n             .handle_opaque_type(a, b, true, &cause, self.delegate.param_env())?\n             .obligations;\n-        self.delegate.register_opaque_type_obligations(obligations)?;\n+        self.delegate.register_obligations(obligations);\n         trace!(a = ?a.kind(), b = ?b.kind(), \"opaque type instantiated\");\n         Ok(a)\n     }\n@@ -531,6 +527,10 @@ where\n         self.infcx.tcx\n     }\n \n+    fn intercrate(&self) -> bool {\n+        self.infcx.intercrate\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.delegate.param_env()\n     }\n@@ -543,6 +543,17 @@ where\n         true\n     }\n \n+    fn mark_ambiguous(&mut self) {\n+        let cause = ObligationCause::dummy_with_span(self.delegate.span());\n+        let param_env = self.delegate.param_env();\n+        self.delegate.register_obligations(vec![Obligation::new(\n+            self.tcx(),\n+            cause,\n+            param_env,\n+            ty::Binder::dummy(ty::PredicateKind::Ambiguous),\n+        )]);\n+    }\n+\n     #[instrument(skip(self, info), level = \"trace\", ret)]\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n@@ -800,8 +811,12 @@ impl<'tcx, D> ConstEquateRelation<'tcx> for TypeRelating<'_, 'tcx, D>\n where\n     D: TypeRelatingDelegate<'tcx>,\n {\n-    fn const_equate_obligation(&mut self, a: ty::Const<'tcx>, b: ty::Const<'tcx>) {\n-        self.delegate.const_equate(a, b);\n+    fn const_equate_obligation(&mut self, _a: ty::Const<'tcx>, _b: ty::Const<'tcx>) {\n+        // We don't have to worry about the equality of consts during borrow checking\n+        // as consts always have a static lifetime.\n+        // FIXME(oli-obk): is this really true? We can at least have HKL and with\n+        // inline consts we may have further lifetimes that may be unsound to treat as\n+        // 'static.\n     }\n }\n \n@@ -898,6 +913,11 @@ where\n         self.infcx.tcx\n     }\n \n+    fn intercrate(&self) -> bool {\n+        assert!(!self.infcx.intercrate);\n+        false\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.delegate.param_env()\n     }\n@@ -910,6 +930,10 @@ where\n         true\n     }\n \n+    fn mark_ambiguous(&mut self) {\n+        bug!()\n+    }\n+\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,"}, {"sha": "26caf82ec6ae1ca4a1df5efa92709dce2edead6e", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 40, "deletions": 29, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -332,32 +332,11 @@ impl<'tcx> InferCtxt<'tcx> {\n         concrete_ty: Ty<'tcx>,\n         span: Span,\n     ) {\n-        let def_id = opaque_type_key.def_id;\n-\n-        let tcx = self.tcx;\n-\n         let concrete_ty = self.resolve_vars_if_possible(concrete_ty);\n-\n         debug!(?concrete_ty);\n \n-        let first_own_region = match self.opaque_ty_origin_unchecked(def_id, span) {\n-            hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => {\n-                // We lower\n-                //\n-                // fn foo<'l0..'ln>() -> impl Trait<'l0..'lm>\n-                //\n-                // into\n-                //\n-                // type foo::<'p0..'pn>::Foo<'q0..'qm>\n-                // fn foo<l0..'ln>() -> foo::<'static..'static>::Foo<'l0..'lm>.\n-                //\n-                // For these types we only iterate over `'l0..lm` below.\n-                tcx.generics_of(def_id).parent_count\n-            }\n-            // These opaque type inherit all lifetime parameters from their\n-            // parent, so we have to check them all.\n-            hir::OpaqueTyOrigin::TyAlias => 0,\n-        };\n+        let variances = self.tcx.variances_of(opaque_type_key.def_id);\n+        debug!(?variances);\n \n         // For a case like `impl Foo<'a, 'b>`, we would generate a constraint\n         // `'r in ['a, 'b, 'static]` for each region `'r` that appears in the\n@@ -370,9 +349,12 @@ impl<'tcx> InferCtxt<'tcx> {\n         // type can be equal to any of the region parameters of the\n         // opaque type definition.\n         let choice_regions: Lrc<Vec<ty::Region<'tcx>>> = Lrc::new(\n-            opaque_type_key.substs[first_own_region..]\n+            opaque_type_key\n+                .substs\n                 .iter()\n-                .filter_map(|arg| match arg.unpack() {\n+                .enumerate()\n+                .filter(|(i, _)| variances[*i] == ty::Variance::Invariant)\n+                .filter_map(|(_, arg)| match arg.unpack() {\n                     GenericArgKind::Lifetime(r) => Some(r),\n                     GenericArgKind::Type(_) | GenericArgKind::Const(_) => None,\n                 })\n@@ -381,6 +363,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         );\n \n         concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n+            tcx: self.tcx,\n             op: |r| self.member_constraint(opaque_type_key, span, concrete_ty, r, &choice_regions),\n         });\n     }\n@@ -440,11 +423,12 @@ impl<'tcx> InferCtxt<'tcx> {\n //\n // We ignore any type parameters because impl trait values are assumed to\n // capture all the in-scope type parameters.\n-struct ConstrainOpaqueTypeRegionVisitor<OP> {\n-    op: OP,\n+pub struct ConstrainOpaqueTypeRegionVisitor<'tcx, OP: FnMut(ty::Region<'tcx>)> {\n+    pub tcx: TyCtxt<'tcx>,\n+    pub op: OP,\n }\n \n-impl<'tcx, OP> TypeVisitor<'tcx> for ConstrainOpaqueTypeRegionVisitor<OP>\n+impl<'tcx, OP> TypeVisitor<'tcx> for ConstrainOpaqueTypeRegionVisitor<'tcx, OP>\n where\n     OP: FnMut(ty::Region<'tcx>),\n {\n@@ -490,6 +474,31 @@ where\n                 substs.as_generator().yield_ty().visit_with(self);\n                 substs.as_generator().resume_ty().visit_with(self);\n             }\n+\n+            ty::Opaque(def_id, ref substs) => {\n+                // Skip lifetime paramters that are not captures.\n+                let variances = self.tcx.variances_of(*def_id);\n+\n+                for (v, s) in std::iter::zip(variances, substs.iter()) {\n+                    if *v != ty::Variance::Bivariant {\n+                        s.visit_with(self);\n+                    }\n+                }\n+            }\n+\n+            ty::Projection(proj)\n+                if self.tcx.def_kind(proj.item_def_id) == DefKind::ImplTraitPlaceholder =>\n+            {\n+                // Skip lifetime paramters that are not captures.\n+                let variances = self.tcx.variances_of(proj.item_def_id);\n+\n+                for (v, s) in std::iter::zip(variances, proj.substs.iter()) {\n+                    if *v != ty::Variance::Bivariant {\n+                        s.visit_with(self);\n+                    }\n+                }\n+            }\n+\n             _ => {\n                 ty.super_visit_with(self);\n             }\n@@ -586,7 +595,9 @@ impl<'tcx> InferCtxt<'tcx> {\n                 ct_op: |ct| ct,\n             });\n \n-            if let ty::PredicateKind::Projection(projection) = predicate.kind().skip_binder() {\n+            if let ty::PredicateKind::Clause(ty::Clause::Projection(projection)) =\n+                predicate.kind().skip_binder()\n+            {\n                 if projection.term.references_error() {\n                     // No point on adding these obligations since there's a type error involved.\n                     return Ok(InferOk { value: (), obligations: vec![] });"}, {"sha": "4daa257672cfcd8c53e02e8ae6f933d60fdf9b52", "filename": "compiler/rustc_infer/src/infer/outlives/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -19,19 +19,21 @@ pub fn explicit_outlives_bounds<'tcx>(\n         .map(ty::Predicate::kind)\n         .filter_map(ty::Binder::no_bound_vars)\n         .filter_map(move |kind| match kind {\n-            ty::PredicateKind::Projection(..)\n-            | ty::PredicateKind::Trait(..)\n+            ty::PredicateKind::Clause(ty::Clause::Projection(..))\n+            | ty::PredicateKind::Clause(ty::Clause::Trait(..))\n             | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::Subtype(..)\n             | ty::PredicateKind::WellFormed(..)\n             | ty::PredicateKind::ObjectSafe(..)\n             | ty::PredicateKind::ClosureKind(..)\n-            | ty::PredicateKind::TypeOutlives(..)\n+            | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(..))\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::ConstEquate(..)\n+            | ty::PredicateKind::Ambiguous\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n-            ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(r_a, r_b)) => {\n-                Some(OutlivesBound::RegionSubRegion(r_b, r_a))\n-            }\n+            ty::PredicateKind::Clause(ty::Clause::RegionOutlives(ty::OutlivesPredicate(\n+                r_a,\n+                r_b,\n+            ))) => Some(OutlivesBound::RegionSubRegion(r_b, r_a)),\n         })\n }"}, {"sha": "5d204dd70ed0cb2c838aba7b53971cdd83d313ad", "filename": "compiler/rustc_infer/src/infer/outlives/test_type_match.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -136,6 +136,11 @@ impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n     fn tag(&self) -> &'static str {\n         \"Match\"\n     }\n+\n+    fn intercrate(&self) -> bool {\n+        false\n+    }\n+\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n@@ -146,6 +151,10 @@ impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n         true\n     } // irrelevant\n \n+    fn mark_ambiguous(&mut self) {\n+        bug!()\n+    }\n+\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _: ty::Variance,"}, {"sha": "8671f8d45a91721d597bb8aa72d514e4dd5027cf", "filename": "compiler/rustc_infer/src/infer/resolve.rs", "status": "modified", "additions": 58, "deletions": 28, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -1,5 +1,6 @@\n use super::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use super::{FixupError, FixupResult, InferCtxt, Span};\n+use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::ty::fold::{FallibleTypeFolder, TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::visit::{TypeSuperVisitable, TypeVisitor};\n use rustc_middle::ty::{self, Const, InferConst, Ty, TyCtxt, TypeFoldable, TypeVisitable};\n@@ -110,48 +111,77 @@ impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticRegionResolver<'a, 'tcx> {\n /// type variables that don't yet have a value. The first unresolved type is stored.\n /// It does not construct the fully resolved type (which might\n /// involve some hashing and so forth).\n-pub struct UnresolvedTypeFinder<'a, 'tcx> {\n+pub struct UnresolvedTypeOrConstFinder<'a, 'tcx> {\n     infcx: &'a InferCtxt<'tcx>,\n }\n \n-impl<'a, 'tcx> UnresolvedTypeFinder<'a, 'tcx> {\n+impl<'a, 'tcx> UnresolvedTypeOrConstFinder<'a, 'tcx> {\n     pub fn new(infcx: &'a InferCtxt<'tcx>) -> Self {\n-        UnresolvedTypeFinder { infcx }\n+        UnresolvedTypeOrConstFinder { infcx }\n     }\n }\n \n-impl<'a, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeFinder<'a, 'tcx> {\n-    type BreakTy = (Ty<'tcx>, Option<Span>);\n+impl<'a, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeOrConstFinder<'a, 'tcx> {\n+    type BreakTy = (ty::Term<'tcx>, Option<Span>);\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         let t = self.infcx.shallow_resolve(t);\n-        if t.has_infer_types() {\n-            if let ty::Infer(infer_ty) = *t.kind() {\n-                // Since we called `shallow_resolve` above, this must\n-                // be an (as yet...) unresolved inference variable.\n-                let ty_var_span = if let ty::TyVar(ty_vid) = infer_ty {\n-                    let mut inner = self.infcx.inner.borrow_mut();\n-                    let ty_vars = &inner.type_variables();\n-                    if let TypeVariableOrigin {\n-                        kind: TypeVariableOriginKind::TypeParameterDefinition(_, _),\n-                        span,\n-                    } = *ty_vars.var_origin(ty_vid)\n-                    {\n-                        Some(span)\n-                    } else {\n-                        None\n-                    }\n+        if let ty::Infer(infer_ty) = *t.kind() {\n+            // Since we called `shallow_resolve` above, this must\n+            // be an (as yet...) unresolved inference variable.\n+            let ty_var_span = if let ty::TyVar(ty_vid) = infer_ty {\n+                let mut inner = self.infcx.inner.borrow_mut();\n+                let ty_vars = &inner.type_variables();\n+                if let TypeVariableOrigin {\n+                    kind: TypeVariableOriginKind::TypeParameterDefinition(_, _),\n+                    span,\n+                } = *ty_vars.var_origin(ty_vid)\n+                {\n+                    Some(span)\n                 } else {\n                     None\n-                };\n-                ControlFlow::Break((t, ty_var_span))\n+                }\n             } else {\n-                // Otherwise, visit its contents.\n-                t.super_visit_with(self)\n-            }\n+                None\n+            };\n+            ControlFlow::Break((t.into(), ty_var_span))\n+        } else if !t.has_non_region_infer() {\n+            // All const/type variables in inference types must already be resolved,\n+            // no need to visit the contents.\n+            ControlFlow::CONTINUE\n         } else {\n-            // All type variables in inference types must already be resolved,\n-            // - no need to visit the contents, continue visiting.\n+            // Otherwise, keep visiting.\n+            t.super_visit_with(self)\n+        }\n+    }\n+\n+    fn visit_const(&mut self, ct: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        let ct = self.infcx.shallow_resolve(ct);\n+        if let ty::ConstKind::Infer(i) = ct.kind() {\n+            // Since we called `shallow_resolve` above, this must\n+            // be an (as yet...) unresolved inference variable.\n+            let ct_var_span = if let ty::InferConst::Var(vid) = i {\n+                let mut inner = self.infcx.inner.borrow_mut();\n+                let ct_vars = &mut inner.const_unification_table();\n+                if let ConstVariableOrigin {\n+                    span,\n+                    kind: ConstVariableOriginKind::ConstParameterDefinition(_, _),\n+                } = ct_vars.probe_value(vid).origin\n+                {\n+                    Some(span)\n+                } else {\n+                    None\n+                }\n+            } else {\n+                None\n+            };\n+            ControlFlow::Break((ct.into(), ct_var_span))\n+        } else if !ct.has_non_region_infer() {\n+            // All const/type variables in inference types must already be resolved,\n+            // no need to visit the contents.\n             ControlFlow::CONTINUE\n+        } else {\n+            // Otherwise, keep visiting.\n+            ct.super_visit_with(self)\n         }\n     }\n }"}, {"sha": "2c6987cc3f45670d5290b6ba8d04ecc9d3d0aae2", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -35,6 +35,11 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n     fn tag(&self) -> &'static str {\n         \"Sub\"\n     }\n+\n+    fn intercrate(&self) -> bool {\n+        self.fields.infcx.intercrate\n+    }\n+\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.fields.infcx.tcx\n     }\n@@ -47,6 +52,10 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n         self.a_is_expected\n     }\n \n+    fn mark_ambiguous(&mut self) {\n+        self.fields.mark_ambiguous()\n+    }\n+\n     fn with_cause<F, R>(&mut self, cause: Cause, f: F) -> R\n     where\n         F: FnOnce(&mut Self) -> R,"}, {"sha": "d3519f4b37b8287b254efd802ae4edeaa3b174e5", "filename": "compiler/rustc_infer/src/traits/engine.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -8,14 +8,6 @@ use super::FulfillmentError;\n use super::{ObligationCause, PredicateObligation};\n \n pub trait TraitEngine<'tcx>: 'tcx {\n-    fn normalize_projection_type(\n-        &mut self,\n-        infcx: &InferCtxt<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        projection_ty: ty::ProjectionTy<'tcx>,\n-        cause: ObligationCause<'tcx>,\n-    ) -> Ty<'tcx>;\n-\n     /// Requires that `ty` must implement the trait with `def_id` in\n     /// the given environment. This trait must not have any type\n     /// parameters (except for `Self`).\n@@ -27,7 +19,7 @@ pub trait TraitEngine<'tcx>: 'tcx {\n         def_id: DefId,\n         cause: ObligationCause<'tcx>,\n     ) {\n-        let trait_ref = ty::TraitRef { def_id, substs: infcx.tcx.mk_substs_trait(ty, &[]) };\n+        let trait_ref = infcx.tcx.mk_trait_ref(def_id, [ty]);\n         self.register_predicate_obligation(\n             infcx,\n             Obligation {"}, {"sha": "026713b6a28b8c539817d2362390f391f07533da", "filename": "compiler/rustc_infer/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -70,8 +70,8 @@ impl<'tcx> PredicateObligation<'tcx> {\n \n     pub fn without_const(mut self, tcx: TyCtxt<'tcx>) -> PredicateObligation<'tcx> {\n         self.param_env = self.param_env.without_const();\n-        if let ty::PredicateKind::Trait(trait_pred) = self.predicate.kind().skip_binder() && trait_pred.is_const_if_const() {\n-            self.predicate = tcx.mk_predicate(self.predicate.kind().map_bound(|_| ty::PredicateKind::Trait(trait_pred.without_const())));\n+        if let ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) = self.predicate.kind().skip_binder() && trait_pred.is_const_if_const() {\n+            self.predicate = tcx.mk_predicate(self.predicate.kind().map_bound(|_| ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred.without_const()))));\n         }\n         self\n     }"}, {"sha": "512e6079f43a02fa7ada619ec45164ccce254748", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -141,7 +141,7 @@ impl<'tcx> Elaborator<'tcx> {\n \n         let bound_predicate = obligation.predicate.kind();\n         match bound_predicate.skip_binder() {\n-            ty::PredicateKind::Trait(data) => {\n+            ty::PredicateKind::Clause(ty::Clause::Trait(data)) => {\n                 // Get predicates declared on the trait.\n                 let predicates = tcx.super_predicates_of(data.def_id());\n \n@@ -184,7 +184,7 @@ impl<'tcx> Elaborator<'tcx> {\n                 // Currently, we do not \"elaborate\" predicates like `X -> Y`,\n                 // though conceivably we might.\n             }\n-            ty::PredicateKind::Projection(..) => {\n+            ty::PredicateKind::Clause(ty::Clause::Projection(..)) => {\n                 // Nothing to elaborate in a projection predicate.\n             }\n             ty::PredicateKind::ClosureKind(..) => {\n@@ -198,10 +198,13 @@ impl<'tcx> Elaborator<'tcx> {\n                 // Currently, we do not elaborate const-equate\n                 // predicates.\n             }\n-            ty::PredicateKind::RegionOutlives(..) => {\n+            ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..)) => {\n                 // Nothing to elaborate from `'a: 'b`.\n             }\n-            ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty_max, r_min)) => {\n+            ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n+                ty_max,\n+                r_min,\n+            ))) => {\n                 // We know that `T: 'a` for some type `T`. We can\n                 // often elaborate this. For example, if we know that\n                 // `[U]: 'a`, that implies that `U: 'a`. Similarly, if\n@@ -231,25 +234,25 @@ impl<'tcx> Elaborator<'tcx> {\n                                 if r.is_late_bound() {\n                                     None\n                                 } else {\n-                                    Some(ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(\n-                                        r, r_min,\n+                                    Some(ty::PredicateKind::Clause(ty::Clause::RegionOutlives(\n+                                        ty::OutlivesPredicate(r, r_min),\n                                     )))\n                                 }\n                             }\n \n                             Component::Param(p) => {\n                                 let ty = tcx.mk_ty_param(p.index, p.name);\n-                                Some(ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(\n-                                    ty, r_min,\n+                                Some(ty::PredicateKind::Clause(ty::Clause::TypeOutlives(\n+                                    ty::OutlivesPredicate(ty, r_min),\n                                 )))\n                             }\n \n                             Component::UnresolvedInferenceVariable(_) => None,\n \n                             Component::Opaque(def_id, substs) => {\n                                 let ty = tcx.mk_opaque(def_id, substs);\n-                                Some(ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(\n-                                    ty, r_min,\n+                                Some(ty::PredicateKind::Clause(ty::Clause::TypeOutlives(\n+                                    ty::OutlivesPredicate(ty, r_min),\n                                 )))\n                             }\n \n@@ -258,8 +261,8 @@ impl<'tcx> Elaborator<'tcx> {\n                                 // With this, we can deduce that `<Bar as Baz>::Assoc: 'a`.\n                                 let ty =\n                                     tcx.mk_projection(projection.item_def_id, projection.substs);\n-                                Some(ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(\n-                                    ty, r_min,\n+                                Some(ty::PredicateKind::Clause(ty::Clause::TypeOutlives(\n+                                    ty::OutlivesPredicate(ty, r_min),\n                                 )))\n                             }\n \n@@ -285,6 +288,7 @@ impl<'tcx> Elaborator<'tcx> {\n             ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                 // Nothing to elaborate\n             }\n+            ty::PredicateKind::Ambiguous => {}\n         }\n     }\n }"}, {"sha": "99c934862c4803e4af8e9a6c45d003d04c93824b", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -304,7 +304,7 @@ pub fn run_compiler<R: Send>(config: Config, f: impl FnOnce(&Compiler) -> R + Se\n                 parse_sess_created(&mut sess.parse_sess);\n             }\n \n-            let temps_dir = sess.opts.unstable_opts.temps_dir.as_ref().map(|o| PathBuf::from(&o));\n+            let temps_dir = sess.opts.unstable_opts.temps_dir.as_deref().map(PathBuf::from);\n \n             let compiler = Compiler {\n                 sess: Lrc::new(sess),"}, {"sha": "fc0b11183f7bf250105b2f65ae9a131f4e26b876", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -33,11 +33,7 @@ pub struct Query<T> {\n \n impl<T> Query<T> {\n     fn compute<F: FnOnce() -> Result<T>>(&self, f: F) -> Result<&Query<T>> {\n-        let mut result = self.result.borrow_mut();\n-        if result.is_none() {\n-            *result = Some(f());\n-        }\n-        result.as_ref().unwrap().as_ref().map(|_| self).map_err(|err| *err)\n+        self.result.borrow_mut().get_or_insert_with(f).as_ref().map(|_| self).map_err(|&err| err)\n     }\n \n     /// Takes ownership of the query result. Further attempts to take or peek the query"}, {"sha": "4142964a0dabbcd6905ed08c9e828ce9e7d3b7f7", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -68,10 +68,7 @@ pub fn create_session(\n     let codegen_backend = if let Some(make_codegen_backend) = make_codegen_backend {\n         make_codegen_backend(&sopts)\n     } else {\n-        get_codegen_backend(\n-            &sopts.maybe_sysroot,\n-            sopts.unstable_opts.codegen_backend.as_ref().map(|name| &name[..]),\n-        )\n+        get_codegen_backend(&sopts.maybe_sysroot, sopts.unstable_opts.codegen_backend.as_deref())\n     };\n \n     // target_override is documented to be called before init(), so this is okay\n@@ -260,7 +257,7 @@ pub fn rustc_path<'a>() -> Option<&'a Path> {\n \n     const BIN_PATH: &str = env!(\"RUSTC_INSTALL_BINDIR\");\n \n-    RUSTC_PATH.get_or_init(|| get_rustc_path_inner(BIN_PATH)).as_ref().map(|v| &**v)\n+    RUSTC_PATH.get_or_init(|| get_rustc_path_inner(BIN_PATH)).as_deref()\n }\n \n fn get_rustc_path_inner(bin_path: &str) -> Option<PathBuf> {"}, {"sha": "1c25b03fdb22ed8ab67ba405dc6409347eca5a5b", "filename": "compiler/rustc_lexer/src/unescape/tests.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_lexer%2Fsrc%2Funescape%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_lexer%2Fsrc%2Funescape%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Funescape%2Ftests.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -132,8 +132,7 @@ fn test_unescape_str_good() {\n                 }\n             }\n         });\n-        let buf = buf.as_ref().map(|it| it.as_ref());\n-        assert_eq!(buf, Ok(expected))\n+        assert_eq!(buf.as_deref(), Ok(expected))\n     }\n \n     check(\"foo\", \"foo\");\n@@ -250,8 +249,7 @@ fn test_unescape_byte_str_good() {\n                 }\n             }\n         });\n-        let buf = buf.as_ref().map(|it| it.as_ref());\n-        assert_eq!(buf, Ok(expected))\n+        assert_eq!(buf.as_deref(), Ok(expected))\n     }\n \n     check(\"foo\", b\"foo\");"}, {"sha": "93d81125f48855e6d88be848941aa17b9e4877d0", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 115, "deletions": 75, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -52,7 +52,7 @@ use rustc_span::edition::Edition;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, InnerSpan, Span};\n-use rustc_target::abi::VariantIdx;\n+use rustc_target::abi::{Abi, VariantIdx};\n use rustc_trait_selection::traits::{self, misc::can_type_implement_copy};\n \n use crate::nonstandard_style::{method_context, MethodLateContext};\n@@ -1268,10 +1268,10 @@ declare_lint_pass!(MutableTransmutes => [MUTABLE_TRANSMUTES]);\n \n impl<'tcx> LateLintPass<'tcx> for MutableTransmutes {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &hir::Expr<'_>) {\n-        if let Some((&ty::Ref(_, _, from_mt), &ty::Ref(_, _, to_mt))) =\n+        if let Some((&ty::Ref(_, _, from_mutbl), &ty::Ref(_, _, to_mutbl))) =\n             get_transmute_from_to(cx, expr).map(|(ty1, ty2)| (ty1.kind(), ty2.kind()))\n         {\n-            if to_mt == hir::Mutability::Mut && from_mt == hir::Mutability::Not {\n+            if from_mutbl < to_mutbl {\n                 cx.struct_span_lint(\n                     MUTABLE_TRANSMUTES,\n                     expr.span,\n@@ -1638,19 +1638,20 @@ declare_lint_pass!(\n impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         use rustc_middle::ty::visit::TypeVisitable;\n+        use rustc_middle::ty::Clause;\n         use rustc_middle::ty::PredicateKind::*;\n \n         if cx.tcx.features().trivial_bounds {\n             let predicates = cx.tcx.predicates_of(item.owner_id);\n             for &(predicate, span) in predicates.predicates {\n                 let predicate_kind_name = match predicate.kind().skip_binder() {\n-                    Trait(..) => \"trait\",\n-                    TypeOutlives(..) |\n-                    RegionOutlives(..) => \"lifetime\",\n+                    Clause(Clause::Trait(..)) => \"trait\",\n+                    Clause(Clause::TypeOutlives(..)) |\n+                    Clause(Clause::RegionOutlives(..)) => \"lifetime\",\n \n                     // Ignore projections, as they can only be global\n                     // if the trait bound is global\n-                    Projection(..) |\n+                    Clause(Clause::Projection(..)) |\n                     // Ignore bounds that a user can't type\n                     WellFormed(..) |\n                     ObjectSafe(..) |\n@@ -1659,6 +1660,7 @@ impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n                     Coerce(..) |\n                     ConstEvaluatable(..) |\n                     ConstEquate(..) |\n+                    Ambiguous |\n                     TypeWellFormedFromEnv(..) => continue,\n                 };\n                 if predicate.is_global() {\n@@ -2030,10 +2032,10 @@ impl KeywordIdents {\n \n impl EarlyLintPass for KeywordIdents {\n     fn check_mac_def(&mut self, cx: &EarlyContext<'_>, mac_def: &ast::MacroDef) {\n-        self.check_tokens(cx, mac_def.body.inner_tokens());\n+        self.check_tokens(cx, mac_def.body.tokens.clone());\n     }\n     fn check_mac(&mut self, cx: &EarlyContext<'_>, mac: &ast::MacCall) {\n-        self.check_tokens(cx, mac.args.inner_tokens());\n+        self.check_tokens(cx, mac.args.tokens.clone());\n     }\n     fn check_ident(&mut self, cx: &EarlyContext<'_>, ident: Ident) {\n         self.check_ident_token(cx, UnderMacro(false), ident);\n@@ -2050,7 +2052,10 @@ impl ExplicitOutlivesRequirements {\n         inferred_outlives\n             .iter()\n             .filter_map(|(pred, _)| match pred.kind().skip_binder() {\n-                ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(a, b)) => match *a {\n+                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(ty::OutlivesPredicate(\n+                    a,\n+                    b,\n+                ))) => match *a {\n                     ty::ReEarlyBound(ebr) if ebr.def_id == def_id => Some(b),\n                     _ => None,\n                 },\n@@ -2066,9 +2071,10 @@ impl ExplicitOutlivesRequirements {\n         inferred_outlives\n             .iter()\n             .filter_map(|(pred, _)| match pred.kind().skip_binder() {\n-                ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(a, b)) => {\n-                    a.is_param(index).then_some(b)\n-                }\n+                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n+                    a,\n+                    b,\n+                ))) => a.is_param(index).then_some(b),\n                 _ => None,\n             })\n             .collect()\n@@ -2407,8 +2413,34 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n         }\n \n         /// Information about why a type cannot be initialized this way.\n-        /// Contains an error message and optionally a span to point at.\n-        type InitError = (String, Option<Span>);\n+        struct InitError {\n+            message: String,\n+            /// Spans from struct fields and similar that can be obtained from just the type.\n+            span: Option<Span>,\n+            /// Used to report a trace through adts.\n+            nested: Option<Box<InitError>>,\n+        }\n+        impl InitError {\n+            fn spanned(self, span: Span) -> InitError {\n+                Self { span: Some(span), ..self }\n+            }\n+\n+            fn nested(self, nested: impl Into<Option<InitError>>) -> InitError {\n+                assert!(self.nested.is_none());\n+                Self { nested: nested.into().map(Box::new), ..self }\n+            }\n+        }\n+\n+        impl<'a> From<&'a str> for InitError {\n+            fn from(s: &'a str) -> Self {\n+                s.to_owned().into()\n+            }\n+        }\n+        impl From<String> for InitError {\n+            fn from(message: String) -> Self {\n+                Self { message, span: None, nested: None }\n+            }\n+        }\n \n         /// Test if this constant is all-0.\n         fn is_zero(expr: &hir::Expr<'_>) -> bool {\n@@ -2464,25 +2496,54 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n \n         fn variant_find_init_error<'tcx>(\n             cx: &LateContext<'tcx>,\n+            ty: Ty<'tcx>,\n             variant: &VariantDef,\n             substs: ty::SubstsRef<'tcx>,\n             descr: &str,\n             init: InitKind,\n         ) -> Option<InitError> {\n-            variant.fields.iter().find_map(|field| {\n-                ty_find_init_error(cx, field.ty(cx.tcx, substs), init).map(|(mut msg, span)| {\n-                    if span.is_none() {\n-                        // Point to this field, should be helpful for figuring\n-                        // out where the source of the error is.\n-                        let span = cx.tcx.def_span(field.did);\n-                        write!(&mut msg, \" (in this {descr})\").unwrap();\n-                        (msg, Some(span))\n+            let mut field_err = variant.fields.iter().find_map(|field| {\n+                ty_find_init_error(cx, field.ty(cx.tcx, substs), init).map(|mut err| {\n+                    if !field.did.is_local() {\n+                        err\n+                    } else if err.span.is_none() {\n+                        err.span = Some(cx.tcx.def_span(field.did));\n+                        write!(&mut err.message, \" (in this {descr})\").unwrap();\n+                        err\n                     } else {\n-                        // Just forward.\n-                        (msg, span)\n+                        InitError::from(format!(\"in this {descr}\"))\n+                            .spanned(cx.tcx.def_span(field.did))\n+                            .nested(err)\n                     }\n                 })\n-            })\n+            });\n+\n+            // Check if this ADT has a constrained layout (like `NonNull` and friends).\n+            if let Ok(layout) = cx.tcx.layout_of(cx.param_env.and(ty)) {\n+                if let Abi::Scalar(scalar) | Abi::ScalarPair(scalar, _) = &layout.abi {\n+                    let range = scalar.valid_range(cx);\n+                    let msg = if !range.contains(0) {\n+                        \"must be non-null\"\n+                    } else if init == InitKind::Uninit && !scalar.is_always_valid(cx) {\n+                        // Prefer reporting on the fields over the entire struct for uninit,\n+                        // as the information bubbles out and it may be unclear why the type can't\n+                        // be null from just its outside signature.\n+\n+                        \"must be initialized inside its custom valid range\"\n+                    } else {\n+                        return field_err;\n+                    };\n+                    if let Some(field_err) = &mut field_err {\n+                        // Most of the time, if the field error is the same as the struct error,\n+                        // the struct error only happens because of the field error.\n+                        if field_err.message.contains(msg) {\n+                            field_err.message = format!(\"because {}\", field_err.message);\n+                        }\n+                    }\n+                    return Some(InitError::from(format!(\"`{ty}` {msg}\")).nested(field_err));\n+                }\n+            }\n+            field_err\n         }\n \n         /// Return `Some` only if we are sure this type does *not*\n@@ -2495,63 +2556,36 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n             use rustc_type_ir::sty::TyKind::*;\n             match ty.kind() {\n                 // Primitive types that don't like 0 as a value.\n-                Ref(..) => Some((\"references must be non-null\".to_string(), None)),\n-                Adt(..) if ty.is_box() => Some((\"`Box` must be non-null\".to_string(), None)),\n-                FnPtr(..) => Some((\"function pointers must be non-null\".to_string(), None)),\n-                Never => Some((\"the `!` type has no valid value\".to_string(), None)),\n+                Ref(..) => Some(\"references must be non-null\".into()),\n+                Adt(..) if ty.is_box() => Some(\"`Box` must be non-null\".into()),\n+                FnPtr(..) => Some(\"function pointers must be non-null\".into()),\n+                Never => Some(\"the `!` type has no valid value\".into()),\n                 RawPtr(tm) if matches!(tm.ty.kind(), Dynamic(..)) =>\n                 // raw ptr to dyn Trait\n                 {\n-                    Some((\"the vtable of a wide raw pointer must be non-null\".to_string(), None))\n+                    Some(\"the vtable of a wide raw pointer must be non-null\".into())\n                 }\n                 // Primitive types with other constraints.\n                 Bool if init == InitKind::Uninit => {\n-                    Some((\"booleans must be either `true` or `false`\".to_string(), None))\n+                    Some(\"booleans must be either `true` or `false`\".into())\n                 }\n                 Char if init == InitKind::Uninit => {\n-                    Some((\"characters must be a valid Unicode codepoint\".to_string(), None))\n+                    Some(\"characters must be a valid Unicode codepoint\".into())\n                 }\n                 Int(_) | Uint(_) if init == InitKind::Uninit => {\n-                    Some((\"integers must not be uninitialized\".to_string(), None))\n-                }\n-                Float(_) if init == InitKind::Uninit => {\n-                    Some((\"floats must not be uninitialized\".to_string(), None))\n+                    Some(\"integers must be initialized\".into())\n                 }\n+                Float(_) if init == InitKind::Uninit => Some(\"floats must be initialized\".into()),\n                 RawPtr(_) if init == InitKind::Uninit => {\n-                    Some((\"raw pointers must not be uninitialized\".to_string(), None))\n+                    Some(\"raw pointers must be initialized\".into())\n                 }\n                 // Recurse and checks for some compound types. (but not unions)\n                 Adt(adt_def, substs) if !adt_def.is_union() => {\n-                    // First check if this ADT has a layout attribute (like `NonNull` and friends).\n-                    use std::ops::Bound;\n-                    match cx.tcx.layout_scalar_valid_range(adt_def.did()) {\n-                        // We exploit here that `layout_scalar_valid_range` will never\n-                        // return `Bound::Excluded`.  (And we have tests checking that we\n-                        // handle the attribute correctly.)\n-                        // We don't add a span since users cannot declare such types anyway.\n-                        (Bound::Included(lo), Bound::Included(hi)) if 0 < lo && lo < hi => {\n-                            return Some((format!(\"`{}` must be non-null\", ty), None));\n-                        }\n-                        (Bound::Included(lo), Bound::Unbounded) if 0 < lo => {\n-                            return Some((format!(\"`{}` must be non-null\", ty), None));\n-                        }\n-                        (Bound::Included(_), _) | (_, Bound::Included(_))\n-                            if init == InitKind::Uninit =>\n-                        {\n-                            return Some((\n-                                format!(\n-                                    \"`{}` must be initialized inside its custom valid range\",\n-                                    ty,\n-                                ),\n-                                None,\n-                            ));\n-                        }\n-                        _ => {}\n-                    }\n                     // Handle structs.\n                     if adt_def.is_struct() {\n                         return variant_find_init_error(\n                             cx,\n+                            ty,\n                             adt_def.non_enum_variant(),\n                             substs,\n                             \"struct field\",\n@@ -2575,13 +2609,14 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                         Some((variant, definitely_inhabited))\n                     });\n                     let Some(first_variant) = potential_variants.next() else {\n-                        return Some((\"enums with no inhabited variants have no valid value\".to_string(), Some(span)));\n+                        return Some(InitError::from(\"enums with no inhabited variants have no valid value\").spanned(span));\n                     };\n                     // So we have at least one potentially inhabited variant. Might we have two?\n                     let Some(second_variant) = potential_variants.next() else {\n                         // There is only one potentially inhabited variant. So we can recursively check that variant!\n                         return variant_find_init_error(\n                             cx,\n+                            ty,\n                             &first_variant.0,\n                             substs,\n                             \"field of the only potentially inhabited enum variant\",\n@@ -2599,10 +2634,9 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                                 .filter(|(_variant, definitely_inhabited)| *definitely_inhabited)\n                                 .count();\n                         if definitely_inhabited > 1 {\n-                            return Some((\n-                                \"enums with multiple inhabited variants have to be initialized to a variant\".to_string(),\n-                                Some(span),\n-                            ));\n+                            return Some(InitError::from(\n+                                \"enums with multiple inhabited variants have to be initialized to a variant\",\n+                            ).spanned(span));\n                         }\n                     }\n                     // We couldn't find anything wrong here.\n@@ -2631,8 +2665,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n             // using zeroed or uninitialized memory.\n             // We are extremely conservative with what we warn about.\n             let conjured_ty = cx.typeck_results().expr_ty(expr);\n-            if let Some((msg, span)) =\n-                with_no_trimmed_paths!(ty_find_init_error(cx, conjured_ty, init))\n+            if let Some(mut err) = with_no_trimmed_paths!(ty_find_init_error(cx, conjured_ty, init))\n             {\n                 // FIXME(davidtwco): make translatable\n                 cx.struct_span_lint(\n@@ -2658,10 +2691,17 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                             \"help: use `MaybeUninit<T>` instead, \\\n                             and only call `assume_init` after initialization is done\",\n                         );\n-                        if let Some(span) = span {\n-                            lint.span_note(span, &msg);\n-                        } else {\n-                            lint.note(&msg);\n+                        loop {\n+                            if let Some(span) = err.span {\n+                                lint.span_note(span, &err.message);\n+                            } else {\n+                                lint.note(&err.message);\n+                            }\n+                            if let Some(e) = err.nested {\n+                                err = *e;\n+                            } else {\n+                                break;\n+                            }\n                         }\n                         lint\n                     },"}, {"sha": "67cf66f470829d8f20f56bd999bac7461db566e2", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -1159,7 +1159,7 @@ impl<'tcx> LateContext<'tcx> {\n \n             fn print_dyn_existential(\n                 self,\n-                _predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n+                _predicates: &'tcx ty::List<ty::PolyExistentialPredicate<'tcx>>,\n             ) -> Result<Self::DynExistential, Self::Error> {\n                 Ok(())\n             }\n@@ -1245,6 +1245,23 @@ impl<'tcx> LateContext<'tcx> {\n \n         AbsolutePathPrinter { tcx: self.tcx }.print_def_path(def_id, &[]).unwrap()\n     }\n+\n+    /// Returns the associated type `name` for `self_ty` as an implementation of `trait_id`.\n+    /// Do not invoke without first verifying that the type implements the trait.\n+    pub fn get_associated_type(\n+        &self,\n+        self_ty: Ty<'tcx>,\n+        trait_id: DefId,\n+        name: &str,\n+    ) -> Option<Ty<'tcx>> {\n+        let tcx = self.tcx;\n+        tcx.associated_items(trait_id)\n+            .find_by_name_and_kind(tcx, Ident::from_str(name), ty::AssocKind::Type, trait_id)\n+            .and_then(|assoc| {\n+                let proj = tcx.mk_projection(assoc.def_id, tcx.mk_substs_trait(self_ty, []));\n+                tcx.try_normalize_erasing_regions(self.param_env, proj).ok()\n+            })\n+    }\n }\n \n impl<'tcx> abi::HasDataLayout for LateContext<'tcx> {"}, {"sha": "1d29a234a3c882192c31cf9b81aabca6a8db9022", "filename": "compiler/rustc_lint/src/deref_into_dyn_supertrait.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_lint%2Fsrc%2Fderef_into_dyn_supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_lint%2Fsrc%2Fderef_into_dyn_supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fderef_into_dyn_supertrait.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -0,0 +1,92 @@\n+use crate::{LateContext, LateLintPass, LintContext};\n+\n+use rustc_errors::DelayDm;\n+use rustc_hir as hir;\n+use rustc_middle::{traits::util::supertraits, ty};\n+use rustc_span::sym;\n+\n+declare_lint! {\n+    /// The `deref_into_dyn_supertrait` lint is output whenever there is a use of the\n+    /// `Deref` implementation with a `dyn SuperTrait` type as `Output`.\n+    ///\n+    /// These implementations will become shadowed when the `trait_upcasting` feature is stabilized.\n+    /// The `deref` functions will no longer be called implicitly, so there might be behavior change.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(deref_into_dyn_supertrait)]\n+    /// #![allow(dead_code)]\n+    ///\n+    /// use core::ops::Deref;\n+    ///\n+    /// trait A {}\n+    /// trait B: A {}\n+    /// impl<'a> Deref for dyn 'a + B {\n+    ///     type Target = dyn A;\n+    ///     fn deref(&self) -> &Self::Target {\n+    ///         todo!()\n+    ///     }\n+    /// }\n+    ///\n+    /// fn take_a(_: &dyn A) { }\n+    ///\n+    /// fn take_b(b: &dyn B) {\n+    ///     take_a(b);\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The dyn upcasting coercion feature adds new coercion rules, taking priority\n+    /// over certain other coercion rules, which will cause some behavior change.\n+    pub DEREF_INTO_DYN_SUPERTRAIT,\n+    Warn,\n+    \"`Deref` implementation usage with a supertrait trait object for output might be shadowed in the future\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #89460 <https://github.com/rust-lang/rust/issues/89460>\",\n+    };\n+}\n+\n+declare_lint_pass!(DerefIntoDynSupertrait => [DEREF_INTO_DYN_SUPERTRAIT]);\n+\n+impl<'tcx> LateLintPass<'tcx> for DerefIntoDynSupertrait {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n+        // `Deref` is being implemented for `t`\n+        if let hir::ItemKind::Impl(impl_) = item.kind\n+            && let Some(trait_) = &impl_.of_trait\n+            && let t = cx.tcx.type_of(item.owner_id)\n+            && let opt_did @ Some(did) = trait_.trait_def_id()\n+            && opt_did == cx.tcx.lang_items().deref_trait()\n+            // `t` is `dyn t_principal`\n+            && let ty::Dynamic(data, _, ty::Dyn) = t.kind()\n+            && let Some(t_principal) = data.principal()\n+            // `<T as Deref>::Target` is `dyn target_principal`\n+            && let Some(target) = cx.get_associated_type(t, did, \"Target\")\n+            && let ty::Dynamic(data, _, ty::Dyn) = target.kind()\n+            && let Some(target_principal) = data.principal()\n+            // `target_principal` is a supertrait of `t_principal`\n+            && supertraits(cx.tcx, t_principal.with_self_ty(cx.tcx, cx.tcx.types.trait_object_dummy_self))\n+                .any(|sup| sup.map_bound(|x| ty::ExistentialTraitRef::erase_self_ty(cx.tcx, x)) == target_principal)\n+        {\n+            cx.struct_span_lint(\n+                DEREF_INTO_DYN_SUPERTRAIT,\n+                cx.tcx.def_span(item.owner_id.def_id),\n+                DelayDm(|| {\n+                    format!(\n+                        \"`{t}` implements `Deref` with supertrait `{target_principal}` as target\"\n+                    )\n+                }),\n+                |lint| {\n+                    if let Some(target_span) = impl_.items.iter().find_map(|i| (i.ident.name == sym::Target).then_some(i.span)) {\n+                        lint.span_label(target_span, \"target type is set here\");\n+                    }\n+\n+                    lint\n+                },\n+            )\n+        }\n+    }\n+}"}, {"sha": "a7a4d0ca52772a7b15c754b22aef35cfb9512dad", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -159,8 +159,8 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n     }\n \n     fn visit_variant_data(&mut self, s: &'a ast::VariantData) {\n-        if let Some(ctor_hir_id) = s.ctor_id() {\n-            self.check_id(ctor_hir_id);\n+        if let Some(ctor_node_id) = s.ctor_node_id() {\n+            self.check_id(ctor_node_id);\n         }\n         ast_visit::walk_struct_def(self, s);\n     }"}, {"sha": "293f1c5c471a2c9cd6e3920eefb2b2f1407f3246", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -272,11 +272,7 @@ fn gen_args(segment: &PathSegment<'_>) -> String {\n             .args\n             .iter()\n             .filter_map(|arg| {\n-                if let GenericArg::Lifetime(lt) = arg {\n-                    Some(lt.name.ident().to_string())\n-                } else {\n-                    None\n-                }\n+                if let GenericArg::Lifetime(lt) = arg { Some(lt.ident.to_string()) } else { None }\n             })\n             .collect::<Vec<_>>();\n "}, {"sha": "b6027476adfd97f3d2f8c05062fc1d652d44d890", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -49,6 +49,7 @@ extern crate tracing;\n mod array_into_iter;\n pub mod builtin;\n mod context;\n+mod deref_into_dyn_supertrait;\n mod early;\n mod enum_intrinsics_non_enums;\n mod errors;\n@@ -87,6 +88,7 @@ use rustc_span::Span;\n \n use array_into_iter::ArrayIntoIter;\n use builtin::*;\n+use deref_into_dyn_supertrait::*;\n use enum_intrinsics_non_enums::EnumIntrinsicsNonEnums;\n use for_loops_over_fallibles::*;\n use hidden_unicode_codepoints::*;\n@@ -192,6 +194,7 @@ macro_rules! late_lint_mod_passes {\n             $args,\n             [\n                 ForLoopsOverFallibles: ForLoopsOverFallibles,\n+                DerefIntoDynSupertrait: DerefIntoDynSupertrait,\n                 HardwiredLints: HardwiredLints,\n                 ImproperCTypesDeclarations: ImproperCTypesDeclarations,\n                 ImproperCTypesDefinitions: ImproperCTypesDefinitions,"}, {"sha": "c1820ac4d1eab61ff9ac3eb759a556cd32f4a192", "filename": "compiler/rustc_lint/src/non_fmt_panic.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -5,7 +5,6 @@ use rustc_hir as hir;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty;\n-use rustc_middle::ty::subst::InternalSubsts;\n use rustc_parse_format::{ParseMode, Parser, Piece};\n use rustc_session::lint::FutureIncompatibilityReason;\n use rustc_span::edition::Edition;\n@@ -148,22 +147,22 @@ fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tc\n                 ty::Ref(_, r, _) if *r.kind() == ty::Str,\n             ) || matches!(\n                 ty.ty_adt_def(),\n-                Some(ty_def) if cx.tcx.is_diagnostic_item(sym::String, ty_def.did()),\n+                Some(ty_def) if Some(ty_def.did()) == cx.tcx.lang_items().string(),\n             );\n \n             let infcx = cx.tcx.infer_ctxt().build();\n             let suggest_display = is_str\n-                || cx.tcx.get_diagnostic_item(sym::Display).map(|t| {\n-                    infcx\n-                        .type_implements_trait(t, ty, InternalSubsts::empty(), cx.param_env)\n-                        .may_apply()\n-                }) == Some(true);\n+                || cx\n+                    .tcx\n+                    .get_diagnostic_item(sym::Display)\n+                    .map(|t| infcx.type_implements_trait(t, [ty], cx.param_env).may_apply())\n+                    == Some(true);\n             let suggest_debug = !suggest_display\n-                && cx.tcx.get_diagnostic_item(sym::Debug).map(|t| {\n-                    infcx\n-                        .type_implements_trait(t, ty, InternalSubsts::empty(), cx.param_env)\n-                        .may_apply()\n-                }) == Some(true);\n+                && cx\n+                    .tcx\n+                    .get_diagnostic_item(sym::Debug)\n+                    .map(|t| infcx.type_implements_trait(t, [ty], cx.param_env).may_apply())\n+                    == Some(true);\n \n             let suggest_panic_any = !is_str && panic == sym::std_panic_macro;\n "}, {"sha": "03d6f4fd92687f192ac40cbf540209b057bdfeae", "filename": "compiler/rustc_lint/src/opaque_hidden_inferred_bound.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -74,7 +74,7 @@ impl<'tcx> LateLintPass<'tcx> for OpaqueHiddenInferredBound {\n             // Liberate bound regions in the predicate since we\n             // don't actually care about lifetimes in this check.\n             let predicate = cx.tcx.liberate_late_bound_regions(def_id, pred.kind());\n-            let ty::PredicateKind::Projection(proj) = predicate else {\n+            let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = predicate else {\n                 continue;\n             };\n             // Only check types, since those are the only things that may\n@@ -116,12 +116,13 @@ impl<'tcx> LateLintPass<'tcx> for OpaqueHiddenInferredBound {\n                     // If it's a trait bound and an opaque that doesn't satisfy it,\n                     // then we can emit a suggestion to add the bound.\n                     let add_bound = match (proj_term.kind(), assoc_pred.kind().skip_binder()) {\n-                        (ty::Opaque(def_id, _), ty::PredicateKind::Trait(trait_pred)) => {\n-                            Some(AddBound {\n-                                suggest_span: cx.tcx.def_span(*def_id).shrink_to_hi(),\n-                                trait_ref: trait_pred.print_modifiers_and_trait_path(),\n-                            })\n-                        }\n+                        (\n+                            ty::Opaque(def_id, _),\n+                            ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)),\n+                        ) => Some(AddBound {\n+                            suggest_span: cx.tcx.def_span(*def_id).shrink_to_hi(),\n+                            trait_ref: trait_pred.print_modifiers_and_trait_path(),\n+                        }),\n                         _ => None,\n                     };\n                     cx.emit_spanned_lint("}, {"sha": "cf1d82f4c06e1077250baf0d70b4d53d7c7382cd", "filename": "compiler/rustc_lint/src/pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -78,7 +78,7 @@ fn gen_args(cx: &LateContext<'_>, segment: &PathSegment<'_>) -> String {\n             .args\n             .iter()\n             .map(|arg| match arg {\n-                GenericArg::Lifetime(lt) => lt.name.ident().to_string(),\n+                GenericArg::Lifetime(lt) => lt.to_string(),\n                 GenericArg::Type(ty) => {\n                     cx.tcx.sess.source_map().span_to_snippet(ty.span).unwrap_or_else(|_| \"_\".into())\n                 }"}, {"sha": "1b21c2dac37887ab548d04826e62b5ec96e6ffde", "filename": "compiler/rustc_lint/src/traits.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -87,11 +87,12 @@ declare_lint_pass!(\n \n impl<'tcx> LateLintPass<'tcx> for DropTraitConstraints {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n+        use rustc_middle::ty::Clause;\n         use rustc_middle::ty::PredicateKind::*;\n \n         let predicates = cx.tcx.explicit_predicates_of(item.owner_id);\n         for &(predicate, span) in predicates.predicates {\n-            let Trait(trait_predicate) = predicate.kind().skip_binder() else {\n+            let Clause(Clause::Trait(trait_predicate)) = predicate.kind().skip_binder() else {\n                 continue\n             };\n             let def_id = trait_predicate.trait_ref.def_id;"}, {"sha": "297b509d4023d40138c47233316a38c2e41270e6", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -12,7 +12,7 @@ use rustc_middle::ty::{self, AdtKind, DefIdTree, Ty, TyCtxt, TypeSuperVisitable,\n use rustc_span::source_map;\n use rustc_span::symbol::sym;\n use rustc_span::{Span, Symbol};\n-use rustc_target::abi::{Abi, WrappingRange};\n+use rustc_target::abi::{Abi, Size, WrappingRange};\n use rustc_target::abi::{Integer, TagEncoding, Variants};\n use rustc_target::spec::abi::Abi as SpecAbi;\n \n@@ -225,11 +225,11 @@ fn report_bin_hex_error(\n     cx: &LateContext<'_>,\n     expr: &hir::Expr<'_>,\n     ty: attr::IntType,\n+    size: Size,\n     repr_str: String,\n     val: u128,\n     negative: bool,\n ) {\n-    let size = Integer::from_attr(&cx.tcx, ty).size();\n     cx.struct_span_lint(\n         OVERFLOWING_LITERALS,\n         expr.span,\n@@ -352,6 +352,7 @@ fn lint_int_literal<'tcx>(\n                 cx,\n                 e,\n                 attr::IntType::SignedInt(ty::ast_int_ty(t)),\n+                Integer::from_int_ty(cx, t).size(),\n                 repr_str,\n                 v,\n                 negative,\n@@ -437,6 +438,7 @@ fn lint_uint_literal<'tcx>(\n                 cx,\n                 e,\n                 attr::IntType::UnsignedInt(ty::ast_uint_ty(t)),\n+                Integer::from_uint_ty(cx, t).size(),\n                 repr_str,\n                 lit_val,\n                 false,\n@@ -1376,7 +1378,7 @@ impl<'tcx> LateLintPass<'tcx> for VariantSizeDifferences {\n             let (largest, slargest, largest_index) = iter::zip(enum_definition.variants, variants)\n                 .map(|(variant, variant_layout)| {\n                     // Subtract the size of the enum tag.\n-                    let bytes = variant_layout.size().bytes().saturating_sub(tag_size);\n+                    let bytes = variant_layout.size.bytes().saturating_sub(tag_size);\n \n                     debug!(\"- variant `{}` is {} bytes large\", variant.ident, bytes);\n                     bytes"}, {"sha": "43864ed45fae224c5ac60339e84e1eb4399c4557", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 222, "deletions": 117, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -13,6 +13,7 @@ use rustc_middle::ty::{self, DefIdTree, Ty};\n use rustc_span::symbol::Symbol;\n use rustc_span::symbol::{kw, sym};\n use rustc_span::{BytePos, Span};\n+use std::iter;\n \n declare_lint! {\n     /// The `unused_must_use` lint detects unused result of a type flagged as\n@@ -113,30 +114,19 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n         }\n \n         let ty = cx.typeck_results().expr_ty(&expr);\n-        let type_permits_lack_of_use = check_must_use_ty(cx, ty, &expr, expr.span, \"\", \"\", 1);\n \n-        let mut fn_warned = false;\n-        let mut op_warned = false;\n-        let maybe_def_id = match expr.kind {\n-            hir::ExprKind::Call(ref callee, _) => {\n-                match callee.kind {\n-                    hir::ExprKind::Path(ref qpath) => {\n-                        match cx.qpath_res(qpath, callee.hir_id) {\n-                            Res::Def(DefKind::Fn | DefKind::AssocFn, def_id) => Some(def_id),\n-                            // `Res::Local` if it was a closure, for which we\n-                            // do not currently support must-use linting\n-                            _ => None,\n-                        }\n-                    }\n-                    _ => None,\n-                }\n+        let must_use_result = is_ty_must_use(cx, ty, &expr, expr.span);\n+        let type_lint_emitted_or_suppressed = match must_use_result {\n+            Some(path) => {\n+                emit_must_use_untranslated(cx, &path, \"\", \"\", 1);\n+                true\n             }\n-            hir::ExprKind::MethodCall(..) => cx.typeck_results().type_dependent_def_id(expr.hir_id),\n-            _ => None,\n+            None => false,\n         };\n-        if let Some(def_id) = maybe_def_id {\n-            fn_warned = check_must_use_def(cx, def_id, expr.span, \"return value of \", \"\");\n-        } else if type_permits_lack_of_use {\n+\n+        let fn_warned = check_fn_must_use(cx, expr);\n+\n+        if !fn_warned && type_lint_emitted_or_suppressed {\n             // We don't warn about unused unit or uninhabited types.\n             // (See https://github.com/rust-lang/rust/issues/43806 for details.)\n             return;\n@@ -170,6 +160,8 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n             _ => None,\n         };\n \n+        let mut op_warned = false;\n+\n         if let Some(must_use_op) = must_use_op {\n             cx.struct_span_lint(UNUSED_MUST_USE, expr.span, fluent::lint_unused_op, |lint| {\n                 lint.set_arg(\"op\", must_use_op)\n@@ -184,110 +176,243 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n             op_warned = true;\n         }\n \n-        if !(type_permits_lack_of_use || fn_warned || op_warned) {\n+        if !(type_lint_emitted_or_suppressed || fn_warned || op_warned) {\n             cx.struct_span_lint(UNUSED_RESULTS, s.span, fluent::lint_unused_result, |lint| {\n                 lint.set_arg(\"ty\", ty)\n             });\n         }\n \n-        // Returns whether an error has been emitted (and thus another does not need to be later).\n-        fn check_must_use_ty<'tcx>(\n+        fn check_fn_must_use(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> bool {\n+            let maybe_def_id = match expr.kind {\n+                hir::ExprKind::Call(ref callee, _) => {\n+                    match callee.kind {\n+                        hir::ExprKind::Path(ref qpath) => {\n+                            match cx.qpath_res(qpath, callee.hir_id) {\n+                                Res::Def(DefKind::Fn | DefKind::AssocFn, def_id) => Some(def_id),\n+                                // `Res::Local` if it was a closure, for which we\n+                                // do not currently support must-use linting\n+                                _ => None,\n+                            }\n+                        }\n+                        _ => None,\n+                    }\n+                }\n+                hir::ExprKind::MethodCall(..) => {\n+                    cx.typeck_results().type_dependent_def_id(expr.hir_id)\n+                }\n+                _ => None,\n+            };\n+            if let Some(def_id) = maybe_def_id {\n+                check_must_use_def(cx, def_id, expr.span, \"return value of \", \"\")\n+            } else {\n+                false\n+            }\n+        }\n+\n+        /// A path through a type to a must_use source. Contains useful info for the lint.\n+        #[derive(Debug)]\n+        enum MustUsePath {\n+            /// Suppress must_use checking.\n+            Suppressed,\n+            /// The root of the normal must_use lint with an optional message.\n+            Def(Span, DefId, Option<Symbol>),\n+            Boxed(Box<Self>),\n+            Opaque(Box<Self>),\n+            TraitObject(Box<Self>),\n+            TupleElement(Vec<(usize, Self)>),\n+            Array(Box<Self>, u64),\n+            /// The root of the unused_closures lint.\n+            Closure(Span),\n+            /// The root of the unused_generators lint.\n+            Generator(Span),\n+        }\n+\n+        #[instrument(skip(cx, expr), level = \"debug\", ret)]\n+        fn is_ty_must_use<'tcx>(\n             cx: &LateContext<'tcx>,\n             ty: Ty<'tcx>,\n             expr: &hir::Expr<'_>,\n             span: Span,\n-            descr_pre: &str,\n-            descr_post: &str,\n-            plural_len: usize,\n-        ) -> bool {\n+        ) -> Option<MustUsePath> {\n             if ty.is_unit()\n-                || cx.tcx.is_ty_uninhabited_from(\n+                || !ty.is_inhabited_from(\n+                    cx.tcx,\n                     cx.tcx.parent_module(expr.hir_id).to_def_id(),\n-                    ty,\n                     cx.param_env,\n                 )\n             {\n-                return true;\n+                return Some(MustUsePath::Suppressed);\n             }\n \n-            let plural_suffix = pluralize!(plural_len);\n-\n             match *ty.kind() {\n                 ty::Adt(..) if ty.is_box() => {\n                     let boxed_ty = ty.boxed_ty();\n-                    let descr_pre = &format!(\"{}boxed \", descr_pre);\n-                    check_must_use_ty(cx, boxed_ty, expr, span, descr_pre, descr_post, plural_len)\n+                    is_ty_must_use(cx, boxed_ty, expr, span)\n+                        .map(|inner| MustUsePath::Boxed(Box::new(inner)))\n                 }\n-                ty::Adt(def, _) => check_must_use_def(cx, def.did(), span, descr_pre, descr_post),\n+                ty::Adt(def, _) => is_def_must_use(cx, def.did(), span),\n                 ty::Opaque(def, _) => {\n-                    let mut has_emitted = false;\n-                    for obligation in elaborate_predicates_with_span(\n+                    elaborate_predicates_with_span(\n                         cx.tcx,\n                         cx.tcx.explicit_item_bounds(def).iter().cloned(),\n-                    ) {\n+                    )\n+                    .filter_map(|obligation| {\n                         // We only look at the `DefId`, so it is safe to skip the binder here.\n-                        if let ty::PredicateKind::Trait(ref poly_trait_predicate) =\n-                            obligation.predicate.kind().skip_binder()\n+                        if let ty::PredicateKind::Clause(ty::Clause::Trait(\n+                            ref poly_trait_predicate,\n+                        )) = obligation.predicate.kind().skip_binder()\n                         {\n                             let def_id = poly_trait_predicate.trait_ref.def_id;\n-                            let descr_pre =\n-                                &format!(\"{}implementer{} of \", descr_pre, plural_suffix,);\n-                            if check_must_use_def(cx, def_id, span, descr_pre, descr_post) {\n-                                has_emitted = true;\n-                                break;\n-                            }\n+\n+                            is_def_must_use(cx, def_id, span)\n+                        } else {\n+                            None\n                         }\n-                    }\n-                    has_emitted\n+                    })\n+                    .map(|inner| MustUsePath::Opaque(Box::new(inner)))\n+                    .next()\n                 }\n-                ty::Dynamic(binder, _, _) => {\n-                    let mut has_emitted = false;\n-                    for predicate in binder.iter() {\n+                ty::Dynamic(binders, _, _) => binders\n+                    .iter()\n+                    .filter_map(|predicate| {\n                         if let ty::ExistentialPredicate::Trait(ref trait_ref) =\n                             predicate.skip_binder()\n                         {\n                             let def_id = trait_ref.def_id;\n-                            let descr_post =\n-                                &format!(\" trait object{}{}\", plural_suffix, descr_post,);\n-                            if check_must_use_def(cx, def_id, span, descr_pre, descr_post) {\n-                                has_emitted = true;\n-                                break;\n-                            }\n+                            is_def_must_use(cx, def_id, span)\n+                        } else {\n+                            None\n                         }\n-                    }\n-                    has_emitted\n-                }\n-                ty::Tuple(ref tys) => {\n-                    let mut has_emitted = false;\n-                    let comps = if let hir::ExprKind::Tup(comps) = expr.kind {\n-                        debug_assert_eq!(comps.len(), tys.len());\n-                        comps\n+                        .map(|inner| MustUsePath::TraitObject(Box::new(inner)))\n+                    })\n+                    .next(),\n+                ty::Tuple(tys) => {\n+                    let elem_exprs = if let hir::ExprKind::Tup(elem_exprs) = expr.kind {\n+                        debug_assert_eq!(elem_exprs.len(), tys.len());\n+                        elem_exprs\n                     } else {\n                         &[]\n                     };\n-                    for (i, ty) in tys.iter().enumerate() {\n-                        let descr_post = &format!(\" in tuple element {}\", i);\n-                        let e = comps.get(i).unwrap_or(expr);\n-                        let span = e.span;\n-                        if check_must_use_ty(cx, ty, e, span, descr_pre, descr_post, plural_len) {\n-                            has_emitted = true;\n-                        }\n+\n+                    // Default to `expr`.\n+                    let elem_exprs = elem_exprs.iter().chain(iter::repeat(expr));\n+\n+                    let nested_must_use = tys\n+                        .iter()\n+                        .zip(elem_exprs)\n+                        .enumerate()\n+                        .filter_map(|(i, (ty, expr))| {\n+                            is_ty_must_use(cx, ty, expr, expr.span).map(|path| (i, path))\n+                        })\n+                        .collect::<Vec<_>>();\n+\n+                    if !nested_must_use.is_empty() {\n+                        Some(MustUsePath::TupleElement(nested_must_use))\n+                    } else {\n+                        None\n                     }\n-                    has_emitted\n                 }\n                 ty::Array(ty, len) => match len.try_eval_usize(cx.tcx, cx.param_env) {\n                     // If the array is empty we don't lint, to avoid false positives\n-                    Some(0) | None => false,\n+                    Some(0) | None => None,\n                     // If the array is definitely non-empty, we can do `#[must_use]` checking.\n-                    Some(n) => {\n-                        let descr_pre = &format!(\"{}array{} of \", descr_pre, plural_suffix,);\n-                        check_must_use_ty(cx, ty, expr, span, descr_pre, descr_post, n as usize + 1)\n-                    }\n+                    Some(len) => is_ty_must_use(cx, ty, expr, span)\n+                        .map(|inner| MustUsePath::Array(Box::new(inner), len)),\n                 },\n-                ty::Closure(..) => {\n+                ty::Closure(..) => Some(MustUsePath::Closure(span)),\n+                ty::Generator(def_id, ..) => {\n+                    // async fn should be treated as \"implementor of `Future`\"\n+                    let must_use = if matches!(\n+                        cx.tcx.generator_kind(def_id),\n+                        Some(hir::GeneratorKind::Async(..))\n+                    ) {\n+                        let def_id = cx.tcx.lang_items().future_trait().unwrap();\n+                        is_def_must_use(cx, def_id, span)\n+                            .map(|inner| MustUsePath::Opaque(Box::new(inner)))\n+                    } else {\n+                        None\n+                    };\n+                    must_use.or(Some(MustUsePath::Generator(span)))\n+                }\n+                _ => None,\n+            }\n+        }\n+\n+        fn is_def_must_use(cx: &LateContext<'_>, def_id: DefId, span: Span) -> Option<MustUsePath> {\n+            if let Some(attr) = cx.tcx.get_attr(def_id, sym::must_use) {\n+                // check for #[must_use = \"...\"]\n+                let reason = attr.value_str();\n+                Some(MustUsePath::Def(span, def_id, reason))\n+            } else {\n+                None\n+            }\n+        }\n+\n+        // Returns whether further errors should be suppressed because either a lint has been emitted or the type should be ignored.\n+        fn check_must_use_def(\n+            cx: &LateContext<'_>,\n+            def_id: DefId,\n+            span: Span,\n+            descr_pre_path: &str,\n+            descr_post_path: &str,\n+        ) -> bool {\n+            is_def_must_use(cx, def_id, span)\n+                .map(|must_use_path| {\n+                    emit_must_use_untranslated(\n+                        cx,\n+                        &must_use_path,\n+                        descr_pre_path,\n+                        descr_post_path,\n+                        1,\n+                    )\n+                })\n+                .is_some()\n+        }\n+\n+        #[instrument(skip(cx), level = \"debug\")]\n+        fn emit_must_use_untranslated(\n+            cx: &LateContext<'_>,\n+            path: &MustUsePath,\n+            descr_pre: &str,\n+            descr_post: &str,\n+            plural_len: usize,\n+        ) {\n+            let plural_suffix = pluralize!(plural_len);\n+\n+            match path {\n+                MustUsePath::Suppressed => {}\n+                MustUsePath::Boxed(path) => {\n+                    let descr_pre = &format!(\"{}boxed \", descr_pre);\n+                    emit_must_use_untranslated(cx, path, descr_pre, descr_post, plural_len);\n+                }\n+                MustUsePath::Opaque(path) => {\n+                    let descr_pre = &format!(\"{}implementer{} of \", descr_pre, plural_suffix);\n+                    emit_must_use_untranslated(cx, path, descr_pre, descr_post, plural_len);\n+                }\n+                MustUsePath::TraitObject(path) => {\n+                    let descr_post = &format!(\" trait object{}{}\", plural_suffix, descr_post);\n+                    emit_must_use_untranslated(cx, path, descr_pre, descr_post, plural_len);\n+                }\n+                MustUsePath::TupleElement(elems) => {\n+                    for (index, path) in elems {\n+                        let descr_post = &format!(\" in tuple element {}\", index);\n+                        emit_must_use_untranslated(cx, path, descr_pre, descr_post, plural_len);\n+                    }\n+                }\n+                MustUsePath::Array(path, len) => {\n+                    let descr_pre = &format!(\"{}array{} of \", descr_pre, plural_suffix);\n+                    emit_must_use_untranslated(\n+                        cx,\n+                        path,\n+                        descr_pre,\n+                        descr_post,\n+                        plural_len.saturating_add(usize::try_from(*len).unwrap_or(usize::MAX)),\n+                    );\n+                }\n+                MustUsePath::Closure(span) => {\n                     cx.struct_span_lint(\n                         UNUSED_MUST_USE,\n-                        span,\n+                        *span,\n                         fluent::lint_unused_closure,\n                         |lint| {\n                             // FIXME(davidtwco): this isn't properly translatable because of the\n@@ -298,12 +423,11 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                                 .note(fluent::note)\n                         },\n                     );\n-                    true\n                 }\n-                ty::Generator(..) => {\n+                MustUsePath::Generator(span) => {\n                     cx.struct_span_lint(\n                         UNUSED_MUST_USE,\n-                        span,\n+                        *span,\n                         fluent::lint_unused_generator,\n                         |lint| {\n                             // FIXME(davidtwco): this isn't properly translatable because of the\n@@ -314,40 +438,20 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                                 .note(fluent::note)\n                         },\n                     );\n-                    true\n                 }\n-                _ => false,\n-            }\n-        }\n-\n-        // Returns whether an error has been emitted (and thus another does not need to be later).\n-        // FIXME: Args desc_{pre,post}_path could be made lazy by taking Fn() -> &str, but this\n-        // would make calling it a big awkward. Could also take String (so args are moved), but\n-        // this would still require a copy into the format string, which would only be executed\n-        // when needed.\n-        fn check_must_use_def(\n-            cx: &LateContext<'_>,\n-            def_id: DefId,\n-            span: Span,\n-            descr_pre_path: &str,\n-            descr_post_path: &str,\n-        ) -> bool {\n-            if let Some(attr) = cx.tcx.get_attr(def_id, sym::must_use) {\n-                cx.struct_span_lint(UNUSED_MUST_USE, span, fluent::lint_unused_def, |lint| {\n-                    // FIXME(davidtwco): this isn't properly translatable because of the pre/post\n-                    // strings\n-                    lint.set_arg(\"pre\", descr_pre_path);\n-                    lint.set_arg(\"post\", descr_post_path);\n-                    lint.set_arg(\"def\", cx.tcx.def_path_str(def_id));\n-                    // check for #[must_use = \"...\"]\n-                    if let Some(note) = attr.value_str() {\n-                        lint.note(note.as_str());\n-                    }\n-                    lint\n-                });\n-                true\n-            } else {\n-                false\n+                MustUsePath::Def(span, def_id, reason) => {\n+                    cx.struct_span_lint(UNUSED_MUST_USE, *span, fluent::lint_unused_def, |lint| {\n+                        // FIXME(davidtwco): this isn't properly translatable because of the pre/post\n+                        // strings\n+                        lint.set_arg(\"pre\", descr_pre);\n+                        lint.set_arg(\"post\", descr_post);\n+                        lint.set_arg(\"def\", cx.tcx.def_path_str(*def_id));\n+                        if let Some(note) = reason {\n+                            lint.note(note.as_str());\n+                        }\n+                        lint\n+                    });\n+                }\n             }\n         }\n     }\n@@ -912,6 +1016,7 @@ impl EarlyLintPass for UnusedParens {\n         if let ast::TyKind::Paren(r) = &ty.kind {\n             match &r.kind {\n                 ast::TyKind::TraitObject(..) => {}\n+                ast::TyKind::BareFn(b) if b.generic_params.len() > 0 => {}\n                 ast::TyKind::ImplTrait(_, bounds) if bounds.len() > 1 => {}\n                 ast::TyKind::Array(_, len) => {\n                     self.check_unused_delims_expr("}, {"sha": "df0e17dea3c051495593062c68485307b168bf01", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -3262,7 +3262,6 @@ declare_lint_pass! {\n         UNUSED_TUPLE_STRUCT_FIELDS,\n         NON_EXHAUSTIVE_OMITTED_PATTERNS,\n         TEXT_DIRECTION_CODEPOINT_IN_COMMENT,\n-        DEREF_INTO_DYN_SUPERTRAIT,\n         DEPRECATED_CFG_ATTR_CRATE_TYPE_NAME,\n         DUPLICATE_MACRO_ATTRIBUTES,\n         SUSPICIOUS_AUTO_TRAIT_IMPLS,\n@@ -3764,51 +3763,6 @@ declare_lint! {\n     \"invisible directionality-changing codepoints in comment\"\n }\n \n-declare_lint! {\n-    /// The `deref_into_dyn_supertrait` lint is output whenever there is a use of the\n-    /// `Deref` implementation with a `dyn SuperTrait` type as `Output`.\n-    ///\n-    /// These implementations will become shadowed when the `trait_upcasting` feature is stabilized.\n-    /// The `deref` functions will no longer be called implicitly, so there might be behavior change.\n-    ///\n-    /// ### Example\n-    ///\n-    /// ```rust,compile_fail\n-    /// #![deny(deref_into_dyn_supertrait)]\n-    /// #![allow(dead_code)]\n-    ///\n-    /// use core::ops::Deref;\n-    ///\n-    /// trait A {}\n-    /// trait B: A {}\n-    /// impl<'a> Deref for dyn 'a + B {\n-    ///     type Target = dyn A;\n-    ///     fn deref(&self) -> &Self::Target {\n-    ///         todo!()\n-    ///     }\n-    /// }\n-    ///\n-    /// fn take_a(_: &dyn A) { }\n-    ///\n-    /// fn take_b(b: &dyn B) {\n-    ///     take_a(b);\n-    /// }\n-    /// ```\n-    ///\n-    /// {{produces}}\n-    ///\n-    /// ### Explanation\n-    ///\n-    /// The dyn upcasting coercion feature adds new coercion rules, taking priority\n-    /// over certain other coercion rules, which will cause some behavior change.\n-    pub DEREF_INTO_DYN_SUPERTRAIT,\n-    Warn,\n-    \"`Deref` implementation usage with a supertrait trait object for output might be shadowed in the future\",\n-    @future_incompatible = FutureIncompatibleInfo {\n-        reference: \"issue #89460 <https://github.com/rust-lang/rust/issues/89460>\",\n-    };\n-}\n-\n declare_lint! {\n     /// The `duplicate_macro_attributes` lint detects when a `#[test]`-like built-in macro\n     /// attribute is duplicated on an item. This lint may trigger on `bench`, `cfg_eval`, `test`"}, {"sha": "7f4d63eed8bdf225c8e3ea7ea7d3a17a80f790ed", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -627,7 +627,11 @@ LLVMRustOptimize(\n   bool DebugPassManager = false;\n \n   PassInstrumentationCallbacks PIC;\n+#if LLVM_VERSION_LT(16, 0)\n   StandardInstrumentations SI(DebugPassManager);\n+#else\n+  StandardInstrumentations SI(TheModule->getContext(), DebugPassManager);\n+#endif\n   SI.registerCallbacks(PIC);\n \n   if (LlvmSelfProfiler){\n@@ -800,7 +804,7 @@ LLVMRustOptimize(\n       auto Plugin = PassPlugin::Load(PluginPath.str());\n       if (!Plugin) {\n         LLVMRustSetLastError((\"Failed to load pass plugin\" + PluginPath.str()).c_str());\n-        continue;\n+        return LLVMRustResult::Failure;\n       }\n       Plugin->registerPassBuilderCallbacks(PB);\n     }"}, {"sha": "216c35d6da078fb629c6bba3b02333bd6807dc3f", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -1036,8 +1036,9 @@ extern \"C\" LLVMValueRef LLVMRustDIBuilderInsertDeclareAtEnd(\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateEnumerator(\n     LLVMRustDIBuilderRef Builder, const char *Name, size_t NameLen,\n-    int64_t Value, bool IsUnsigned) {\n-  return wrap(Builder->createEnumerator(StringRef(Name, NameLen), Value, IsUnsigned));\n+    const uint64_t Value[2], unsigned SizeInBits, bool IsUnsigned) {\n+  return wrap(Builder->createEnumerator(StringRef(Name, NameLen),\n+      APSInt(APInt(SizeInBits, makeArrayRef(Value, 2)), IsUnsigned)));\n }\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateEnumerationType("}, {"sha": "be9821c00f507abd5f96bc349ac8f8c27ccb3657", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic.rs", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -5,6 +5,7 @@ use crate::diagnostics::error::{span_err, DiagnosticDeriveError};\n use crate::diagnostics::utils::SetOnce;\n use proc_macro2::TokenStream;\n use quote::quote;\n+use syn::spanned::Spanned;\n use synstructure::Structure;\n \n /// The central struct for constructing the `into_diagnostic` method from an annotated struct.\n@@ -45,6 +46,17 @@ impl<'a> DiagnosticDerive<'a> {\n                         .emit();\n                     return DiagnosticDeriveError::ErrorHandled.to_compile_error();\n                 }\n+                Some(slug) if let Some( Mismatch { slug_name, crate_name, slug_prefix }) = Mismatch::check(slug) => {\n+                    span_err(slug.span().unwrap(), \"diagnostic slug and crate name do not match\")\n+                        .note(&format!(\n+                            \"slug is `{slug_name}` but the crate name is `{crate_name}`\"\n+                        ))\n+                        .help(&format!(\n+                            \"expected a slug starting with `{slug_prefix}_...`\"\n+                        ))\n+                        .emit();\n+                    return DiagnosticDeriveError::ErrorHandled.to_compile_error();\n+                }\n                 Some(slug) => {\n                     quote! {\n                         let mut #diag = #handler.struct_diagnostic(rustc_errors::fluent::#slug);\n@@ -128,7 +140,22 @@ impl<'a> LintDiagnosticDerive<'a> {\n                         .emit();\n                     return DiagnosticDeriveError::ErrorHandled.to_compile_error();\n                 }\n-                Some(slug) => quote! { rustc_errors::fluent::#slug.into() },\n+                Some(slug) if let Some( Mismatch { slug_name, crate_name, slug_prefix }) = Mismatch::check(slug) => {\n+                    span_err(slug.span().unwrap(), \"diagnostic slug and crate name do not match\")\n+                        .note(&format!(\n+                            \"slug is `{slug_name}` but the crate name is `{crate_name}`\"\n+                        ))\n+                        .help(&format!(\n+                            \"expected a slug starting with `{slug_prefix}_...`\"\n+                        ))\n+                        .emit();\n+                    return DiagnosticDeriveError::ErrorHandled.to_compile_error();\n+                }\n+                Some(slug) => {\n+                    quote! {\n+                        rustc_errors::fluent::#slug.into()\n+                    }\n+                }\n             }\n         });\n \n@@ -151,3 +178,27 @@ impl<'a> LintDiagnosticDerive<'a> {\n         })\n     }\n }\n+\n+struct Mismatch {\n+    slug_name: String,\n+    crate_name: String,\n+    slug_prefix: String,\n+}\n+\n+impl Mismatch {\n+    /// Checks whether the slug starts with the crate name it's in.\n+    fn check(slug: &syn::Path) -> Option<Mismatch> {\n+        // If this is missing we're probably in a test, so bail.\n+        let crate_name = std::env::var(\"CARGO_CRATE_NAME\").ok()?;\n+\n+        // If we're not in a \"rustc_\" crate, bail.\n+        let Some((\"rustc\", slug_prefix)) = crate_name.split_once(\"_\") else { return None };\n+\n+        let slug_name = slug.segments.first()?.ident.to_string();\n+        if !slug_name.starts_with(slug_prefix) {\n+            Some(Mismatch { slug_name, slug_prefix: slug_prefix.to_string(), crate_name })\n+        } else {\n+            None\n+        }\n+    }\n+}"}, {"sha": "ac916bb60689ee96a4c8af306dba542aef9be54c", "filename": "compiler/rustc_macros/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Flib.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -1,4 +1,5 @@\n #![feature(allow_internal_unstable)]\n+#![feature(if_let_guard)]\n #![feature(never_type)]\n #![feature(proc_macro_diagnostic)]\n #![feature(proc_macro_span)]\n@@ -47,7 +48,7 @@ pub fn symbols(input: TokenStream) -> TokenStream {\n /// `u32::MAX`. You can also customize things like the `Debug` impl,\n /// what traits are derived, and so forth via the macro.\n #[proc_macro]\n-#[allow_internal_unstable(step_trait, rustc_attrs, trusted_step)]\n+#[allow_internal_unstable(step_trait, rustc_attrs, trusted_step, spec_option_partial_eq)]\n pub fn newtype_index(input: TokenStream) -> TokenStream {\n     newtype::newtype(input)\n }"}, {"sha": "fd3f5225155508d23f7d184bd93210fc863b709a", "filename": "compiler/rustc_macros/src/newtype.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_macros%2Fsrc%2Fnewtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_macros%2Fsrc%2Fnewtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fnewtype.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -192,6 +192,30 @@ impl Parse for Newtype {\n                 }\n             }\n         };\n+        let spec_partial_eq_impl = if let Lit::Int(max) = &max {\n+            if let Ok(max_val) = max.base10_parse::<u32>() {\n+                quote! {\n+                    impl core::option::SpecOptionPartialEq for #name {\n+                        #[inline]\n+                        fn eq(l: &Option<Self>, r: &Option<Self>) -> bool {\n+                            if #max_val < u32::MAX {\n+                                l.map(|i| i.private).unwrap_or(#max_val+1) == r.map(|i| i.private).unwrap_or(#max_val+1)\n+                            } else {\n+                                match (l, r) {\n+                                    (Some(l), Some(r)) => r == l,\n+                                    (None, None) => true,\n+                                    _ => false\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            } else {\n+                quote! {}\n+            }\n+        } else {\n+            quote! {}\n+        };\n \n         Ok(Self(quote! {\n             #(#attrs)*\n@@ -293,6 +317,8 @@ impl Parse for Newtype {\n \n             #step\n \n+            #spec_partial_eq_impl\n+\n             impl From<#name> for u32 {\n                 #[inline]\n                 fn from(v: #name) -> u32 {"}, {"sha": "1a2389c7a8448878b28c406dbe0d247a6b3a1a61", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -162,7 +162,7 @@ impl CStore {\n     pub(crate) fn iter_crate_data(&self) -> impl Iterator<Item = (CrateNum, &CrateMetadata)> {\n         self.metas\n             .iter_enumerated()\n-            .filter_map(|(cnum, data)| data.as_ref().map(|data| (cnum, &**data)))\n+            .filter_map(|(cnum, data)| data.as_deref().map(|data| (cnum, data)))\n     }\n \n     fn push_dependencies_in_postorder(&self, deps: &mut Vec<CrateNum>, cnum: CrateNum) {"}, {"sha": "6f7e6e09ca5eddfabcf7ff0c908c7ce2a9de72d9", "filename": "compiler/rustc_metadata/src/errors.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -692,6 +692,7 @@ pub struct CrateLocationUnknownType<'a> {\n     #[primary_span]\n     pub span: Span,\n     pub path: &'a Path,\n+    pub crate_name: Symbol,\n }\n \n #[derive(Diagnostic)]"}, {"sha": "15546092e41a2bb37a80663b2b222963252bcb3a", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -707,6 +707,12 @@ impl<'a> CrateLocator<'a> {\n                     loc.original().clone(),\n                 ));\n             }\n+            if !loc.original().is_file() {\n+                return Err(CrateError::ExternLocationNotFile(\n+                    self.crate_name,\n+                    loc.original().clone(),\n+                ));\n+            }\n             let Some(file) = loc.original().file_name().and_then(|s| s.to_str()) else {\n                 return Err(CrateError::ExternLocationNotFile(\n                     self.crate_name,\n@@ -1020,11 +1026,10 @@ impl CrateError {\n                     None => String::new(),\n                     Some(r) => format!(\" which `{}` depends on\", r.name),\n                 };\n-                // FIXME: There are no tests for CrateLocationUnknownType or LibFilenameForm\n                 if !locator.crate_rejections.via_filename.is_empty() {\n                     let mismatches = locator.crate_rejections.via_filename.iter();\n                     for CrateMismatch { path, .. } in mismatches {\n-                        sess.emit_err(CrateLocationUnknownType { span, path: &path });\n+                        sess.emit_err(CrateLocationUnknownType { span, path: &path, crate_name });\n                         sess.emit_err(LibFilenameForm {\n                             span,\n                             dll_prefix: &locator.dll_prefix,"}, {"sha": "08d377646d5433016595e9573f7300fa554c06c7", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 43, "deletions": 96, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -11,7 +11,7 @@ use rustc_data_structures::sync::{Lock, LockGuard, Lrc, OnceCell};\n use rustc_data_structures::unhash::UnhashMap;\n use rustc_expand::base::{SyntaxExtension, SyntaxExtensionKind};\n use rustc_expand::proc_macro::{AttrProcMacro, BangProcMacro, DeriveProcMacro};\n-use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n+use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc_hir::diagnostic_items::DiagnosticItems;\n@@ -29,17 +29,16 @@ use rustc_session::cstore::{\n     CrateSource, ExternCrate, ForeignModule, LinkagePreference, NativeLib,\n };\n use rustc_session::Session;\n-use rustc_span::hygiene::{ExpnIndex, MacroKind};\n+use rustc_span::hygiene::ExpnIndex;\n use rustc_span::source_map::{respan, Spanned};\n-use rustc_span::symbol::{kw, sym, Ident, Symbol};\n+use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::{self, BytePos, ExpnId, Pos, Span, SyntaxContext, DUMMY_SP};\n \n use proc_macro::bridge::client::ProcMacro;\n-use std::io;\n use std::iter::TrustedLen;\n-use std::mem;\n use std::num::NonZeroUsize;\n use std::path::Path;\n+use std::{io, iter, mem};\n \n pub(super) use cstore_impl::provide;\n pub use cstore_impl::provide_extern;\n@@ -644,12 +643,6 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for Symbol {\n     }\n }\n \n-impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for &'tcx [ty::abstract_const::Node<'tcx>] {\n-    fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Self {\n-        ty::codec::RefDecodable::decode(d)\n-    }\n-}\n-\n impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for &'tcx [(ty::Predicate<'tcx>, Span)] {\n     fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Self {\n         ty::codec::RefDecodable::decode(d)\n@@ -866,12 +859,12 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n         let variant_did =\n             if adt_kind == ty::AdtKind::Enum { Some(self.local_def_id(index)) } else { None };\n-        let ctor_did = data.ctor.map(|index| self.local_def_id(index));\n+        let ctor = data.ctor.map(|(kind, index)| (kind, self.local_def_id(index)));\n \n         ty::VariantDef::new(\n             self.item_name(index),\n             variant_did,\n-            ctor_did,\n+            ctor,\n             data.discr,\n             self.root\n                 .tables\n@@ -885,7 +878,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                     vis: self.get_visibility(index),\n                 })\n                 .collect(),\n-            data.ctor_kind,\n             adt_kind,\n             parent_did,\n             false,\n@@ -991,87 +983,52 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         DiagnosticItems { id_to_name, name_to_id }\n     }\n \n+    fn get_mod_child(self, id: DefIndex, sess: &Session) -> ModChild {\n+        let ident = self.item_ident(id, sess);\n+        let kind = self.def_kind(id);\n+        let def_id = self.local_def_id(id);\n+        let res = Res::Def(kind, def_id);\n+        let vis = self.get_visibility(id);\n+        let span = self.get_span(id, sess);\n+        let macro_rules = match kind {\n+            DefKind::Macro(..) => self.root.tables.macro_rules.get(self, id).is_some(),\n+            _ => false,\n+        };\n+\n+        ModChild { ident, res, vis, span, macro_rules }\n+    }\n+\n     /// Iterates over all named children of the given module,\n     /// including both proper items and reexports.\n     /// Module here is understood in name resolution sense - it can be a `mod` item,\n     /// or a crate root, or an enum, or a trait.\n-    fn for_each_module_child(\n+    fn get_module_children(\n         self,\n         id: DefIndex,\n-        mut callback: impl FnMut(ModChild),\n-        sess: &Session,\n-    ) {\n-        if let Some(data) = &self.root.proc_macro_data {\n-            // If we are loading as a proc macro, we want to return\n-            // the view of this crate as a proc macro crate.\n-            if id == CRATE_DEF_INDEX {\n-                for def_index in data.macros.decode(self) {\n-                    let raw_macro = self.raw_proc_macro(def_index);\n-                    let res = Res::Def(\n-                        DefKind::Macro(macro_kind(raw_macro)),\n-                        self.local_def_id(def_index),\n-                    );\n-                    let ident = self.item_ident(def_index, sess);\n-                    callback(ModChild {\n-                        ident,\n-                        res,\n-                        vis: ty::Visibility::Public,\n-                        span: ident.span,\n-                        macro_rules: false,\n-                    });\n-                }\n-            }\n-            return;\n-        }\n-\n-        // Iterate over all children.\n-        if let Some(children) = self.root.tables.children.get(self, id) {\n-            for child_index in children.decode((self, sess)) {\n-                let ident = self.item_ident(child_index, sess);\n-                let kind = self.def_kind(child_index);\n-                let def_id = self.local_def_id(child_index);\n-                let res = Res::Def(kind, def_id);\n-                let vis = self.get_visibility(child_index);\n-                let span = self.get_span(child_index, sess);\n-                let macro_rules = match kind {\n-                    DefKind::Macro(..) => {\n-                        self.root.tables.macro_rules.get(self, child_index).is_some()\n+        sess: &'a Session,\n+    ) -> impl Iterator<Item = ModChild> + 'a {\n+        iter::from_generator(move || {\n+            if let Some(data) = &self.root.proc_macro_data {\n+                // If we are loading as a proc macro, we want to return\n+                // the view of this crate as a proc macro crate.\n+                if id == CRATE_DEF_INDEX {\n+                    for child_index in data.macros.decode(self) {\n+                        yield self.get_mod_child(child_index, sess);\n                     }\n-                    _ => false,\n-                };\n-\n-                callback(ModChild { ident, res, vis, span, macro_rules });\n+                }\n+            } else {\n+                // Iterate over all children.\n+                for child_index in self.root.tables.children.get(self, id).unwrap().decode(self) {\n+                    yield self.get_mod_child(child_index, sess);\n+                }\n \n-                // For non-reexport variants add their fictive constructors to children.\n-                // Braced variants, unlike structs, generate unusable names in value namespace,\n-                // they are reserved for possible future use. It's ok to use the variant's id as\n-                // a ctor id since an error will be reported on any use of such resolution anyway.\n-                // Reexport lists automatically contain such constructors when necessary.\n-                if kind == DefKind::Variant && self.get_ctor_def_id_and_kind(child_index).is_none()\n-                {\n-                    let ctor_res =\n-                        Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fictive), def_id);\n-                    let mut vis = vis;\n-                    if vis.is_public() {\n-                        // For non-exhaustive variants lower the constructor visibility to\n-                        // within the crate. We only need this for fictive constructors,\n-                        // for other constructors correct visibilities\n-                        // were already encoded in metadata.\n-                        let mut attrs = self.get_item_attrs(def_id.index, sess);\n-                        if attrs.any(|item| item.has_name(sym::non_exhaustive)) {\n-                            vis = ty::Visibility::Restricted(self.local_def_id(CRATE_DEF_INDEX));\n-                        }\n+                if let Some(reexports) = self.root.tables.module_reexports.get(self, id) {\n+                    for reexport in reexports.decode((self, sess)) {\n+                        yield reexport;\n                     }\n-                    callback(ModChild { ident, res: ctor_res, vis, span, macro_rules: false });\n                 }\n             }\n-        }\n-\n-        if let Some(exports) = self.root.tables.module_reexports.get(self, id) {\n-            for exp in exports.decode((self, sess)) {\n-                callback(exp);\n-            }\n-        }\n+        })\n     }\n \n     fn is_ctfe_mir_available(self, id: DefIndex) -> bool {\n@@ -1136,11 +1093,11 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_ctor_def_id_and_kind(self, node_id: DefIndex) -> Option<(DefId, CtorKind)> {\n+    fn get_ctor(self, node_id: DefIndex) -> Option<(CtorKind, DefId)> {\n         match self.def_kind(node_id) {\n             DefKind::Struct | DefKind::Variant => {\n                 let vdata = self.root.tables.variant_data.get(self, node_id).unwrap().decode(self);\n-                vdata.ctor.map(|index| (self.local_def_id(index), vdata.ctor_kind))\n+                vdata.ctor.map(|(kind, index)| (kind, self.local_def_id(index)))\n             }\n             _ => None,\n         }\n@@ -1808,13 +1765,3 @@ impl CrateMetadata {\n         None\n     }\n }\n-\n-// Cannot be implemented on 'ProcMacro', as libproc_macro\n-// does not depend on librustc_ast\n-fn macro_kind(raw: &ProcMacro) -> MacroKind {\n-    match raw {\n-        ProcMacro::CustomDerive { .. } => MacroKind::Derive,\n-        ProcMacro::Attr { .. } => MacroKind::Attr,\n-        ProcMacro::Bang { .. } => MacroKind::Bang,\n-    }\n-}"}, {"sha": "33cce0a411e81babf281a72e64061927c0eb1968", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -21,7 +21,6 @@ use rustc_span::source_map::{Span, Spanned};\n use rustc_span::symbol::{kw, Symbol};\n \n use rustc_data_structures::sync::Lrc;\n-use smallvec::SmallVec;\n use std::any::Any;\n \n use super::{Decodable, DecodeContext, DecodeIterator};\n@@ -298,9 +297,7 @@ provide! { tcx, def_id, other, cdata,\n         r\n     }\n     module_children => {\n-        let mut result = SmallVec::<[_; 8]>::new();\n-        cdata.for_each_module_child(def_id.index, |child| result.push(child), tcx.sess);\n-        tcx.arena.alloc_slice(&result)\n+        tcx.arena.alloc_from_iter(cdata.get_module_children(def_id.index, tcx.sess))\n     }\n     defined_lib_features => { cdata.get_lib_features(tcx) }\n     stability_implications => {\n@@ -495,22 +492,20 @@ impl CStore {\n         self.get_crate_data(def.krate).get_struct_field_visibilities(def.index)\n     }\n \n-    pub fn ctor_def_id_and_kind_untracked(&self, def: DefId) -> Option<(DefId, CtorKind)> {\n-        self.get_crate_data(def.krate).get_ctor_def_id_and_kind(def.index)\n+    pub fn ctor_untracked(&self, def: DefId) -> Option<(CtorKind, DefId)> {\n+        self.get_crate_data(def.krate).get_ctor(def.index)\n     }\n \n     pub fn visibility_untracked(&self, def: DefId) -> Visibility<DefId> {\n         self.get_crate_data(def.krate).get_visibility(def.index)\n     }\n \n-    pub fn module_children_untracked(&self, def_id: DefId, sess: &Session) -> Vec<ModChild> {\n-        let mut result = vec![];\n-        self.get_crate_data(def_id.krate).for_each_module_child(\n-            def_id.index,\n-            |child| result.push(child),\n-            sess,\n-        );\n-        result\n+    pub fn module_children_untracked<'a>(\n+        &'a self,\n+        def_id: DefId,\n+        sess: &'a Session,\n+    ) -> impl Iterator<Item = ModChild> + 'a {\n+        self.get_crate_data(def_id.krate).get_module_children(def_id.index, sess)\n     }\n \n     pub fn load_macro_untracked(&self, id: DefId, sess: &Session) -> LoadedMacro {"}, {"sha": "8b4c4bb2675cb62309fe840c2c5efc1303b1ca72", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 29, "deletions": 50, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -928,6 +928,8 @@ fn should_encode_variances(def_kind: DefKind) -> bool {\n         | DefKind::Union\n         | DefKind::Enum\n         | DefKind::Variant\n+        | DefKind::OpaqueTy\n+        | DefKind::ImplTraitPlaceholder\n         | DefKind::Fn\n         | DefKind::Ctor(..)\n         | DefKind::AssocFn => true,\n@@ -941,8 +943,6 @@ fn should_encode_variances(def_kind: DefKind) -> bool {\n         | DefKind::Const\n         | DefKind::ForeignMod\n         | DefKind::TyAlias\n-        | DefKind::OpaqueTy\n-        | DefKind::ImplTraitPlaceholder\n         | DefKind::Impl\n         | DefKind::Trait\n         | DefKind::TraitAlias\n@@ -1221,9 +1221,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         debug!(\"EncodeContext::encode_enum_variant_info({:?})\", def_id);\n \n         let data = VariantData {\n-            ctor_kind: variant.ctor_kind,\n             discr: variant.discr,\n-            ctor: variant.ctor_def_id.map(|did| did.index),\n+            ctor: variant.ctor.map(|(kind, def_id)| (kind, def_id.index)),\n             is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n         };\n \n@@ -1233,32 +1232,28 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             assert!(f.did.is_local());\n             f.did.index\n         }));\n-        if variant.ctor_kind == CtorKind::Fn {\n+        if let Some((CtorKind::Fn, ctor_def_id)) = variant.ctor {\n             // FIXME(eddyb) encode signature only in `encode_enum_variant_ctor`.\n-            if let Some(ctor_def_id) = variant.ctor_def_id {\n-                record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(ctor_def_id));\n-            }\n+            record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(ctor_def_id));\n         }\n     }\n \n     fn encode_enum_variant_ctor(&mut self, def: ty::AdtDef<'tcx>, index: VariantIdx) {\n-        let tcx = self.tcx;\n         let variant = &def.variant(index);\n-        let def_id = variant.ctor_def_id.unwrap();\n+        let Some((ctor_kind, def_id)) = variant.ctor else { return };\n         debug!(\"EncodeContext::encode_enum_variant_ctor({:?})\", def_id);\n \n         // FIXME(eddyb) encode only the `CtorKind` for constructors.\n         let data = VariantData {\n-            ctor_kind: variant.ctor_kind,\n             discr: variant.discr,\n-            ctor: Some(def_id.index),\n+            ctor: Some((ctor_kind, def_id.index)),\n             is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n         };\n \n         record!(self.tables.variant_data[def_id] <- data);\n         self.tables.constness.set(def_id.index, hir::Constness::Const);\n-        if variant.ctor_kind == CtorKind::Fn {\n-            record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n+        if ctor_kind == CtorKind::Fn {\n+            record!(self.tables.fn_sig[def_id] <- self.tcx.fn_sig(def_id));\n         }\n     }\n \n@@ -1272,13 +1267,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         // the crate root for consistency with other crates (some of the resolver\n         // code uses it). However, we skip encoding anything relating to child\n         // items - we encode information about proc-macros later on.\n-        let reexports = if !self.is_proc_macro {\n-            tcx.module_reexports(local_def_id).unwrap_or(&[])\n-        } else {\n-            &[]\n-        };\n-\n-        record_array!(self.tables.module_reexports[def_id] <- reexports);\n         if self.is_proc_macro {\n             // Encode this here because we don't do it in encode_def_ids.\n             record!(self.tables.expn_that_defined[def_id] <- tcx.expn_that_defined(local_def_id));\n@@ -1310,26 +1298,30 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     }\n                 }\n             }));\n+\n+            if let Some(reexports) = tcx.module_reexports(local_def_id) {\n+                assert!(!reexports.is_empty());\n+                record_array!(self.tables.module_reexports[def_id] <- reexports);\n+            }\n         }\n     }\n \n-    fn encode_struct_ctor(&mut self, adt_def: ty::AdtDef<'tcx>, def_id: DefId) {\n-        debug!(\"EncodeContext::encode_struct_ctor({:?})\", def_id);\n-        let tcx = self.tcx;\n+    fn encode_struct_ctor(&mut self, adt_def: ty::AdtDef<'tcx>) {\n         let variant = adt_def.non_enum_variant();\n+        let Some((ctor_kind, def_id)) = variant.ctor else { return };\n+        debug!(\"EncodeContext::encode_struct_ctor({:?})\", def_id);\n \n         let data = VariantData {\n-            ctor_kind: variant.ctor_kind,\n             discr: variant.discr,\n-            ctor: Some(def_id.index),\n+            ctor: Some((ctor_kind, def_id.index)),\n             is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n         };\n \n         record!(self.tables.repr_options[def_id] <- adt_def.repr());\n         record!(self.tables.variant_data[def_id] <- data);\n         self.tables.constness.set(def_id.index, hir::Constness::Const);\n-        if variant.ctor_kind == CtorKind::Fn {\n-            record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n+        if ctor_kind == CtorKind::Fn {\n+            record!(self.tables.fn_sig[def_id] <- self.tcx.fn_sig(def_id));\n         }\n     }\n \n@@ -1550,21 +1542,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 let adt_def = self.tcx.adt_def(def_id);\n                 record!(self.tables.repr_options[def_id] <- adt_def.repr());\n             }\n-            hir::ItemKind::Struct(ref struct_def, _) => {\n+            hir::ItemKind::Struct(..) => {\n                 let adt_def = self.tcx.adt_def(def_id);\n                 record!(self.tables.repr_options[def_id] <- adt_def.repr());\n                 self.tables.constness.set(def_id.index, hir::Constness::Const);\n \n-                // Encode def_ids for each field and method\n-                // for methods, write all the stuff get_trait_method\n-                // needs to know\n-                let ctor = struct_def.ctor_def_id().map(|ctor_def_id| ctor_def_id.local_def_index);\n-\n                 let variant = adt_def.non_enum_variant();\n                 record!(self.tables.variant_data[def_id] <- VariantData {\n-                    ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n-                    ctor,\n+                    ctor: variant.ctor.map(|(kind, def_id)| (kind, def_id.index)),\n                     is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n                 });\n             }\n@@ -1574,9 +1560,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n                 let variant = adt_def.non_enum_variant();\n                 record!(self.tables.variant_data[def_id] <- VariantData {\n-                    ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n-                    ctor: None,\n+                    ctor: variant.ctor.map(|(kind, def_id)| (kind, def_id.index)),\n                     is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n                 });\n             }\n@@ -1629,7 +1614,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     for variant in tcx.adt_def(def_id).variants() {\n                         yield variant.def_id.index;\n                         // Encode constructors which take a separate slot in value namespace.\n-                        if let Some(ctor_def_id) = variant.ctor_def_id {\n+                        if let Some(ctor_def_id) = variant.ctor_def_id() {\n                             yield ctor_def_id.index;\n                         }\n                     }\n@@ -1672,20 +1657,14 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         match item.kind {\n             hir::ItemKind::Enum(..) => {\n                 let def = self.tcx.adt_def(item.owner_id.to_def_id());\n-                for (i, variant) in def.variants().iter_enumerated() {\n+                for (i, _) in def.variants().iter_enumerated() {\n                     self.encode_enum_variant_info(def, i);\n-\n-                    if let Some(_ctor_def_id) = variant.ctor_def_id {\n-                        self.encode_enum_variant_ctor(def, i);\n-                    }\n+                    self.encode_enum_variant_ctor(def, i);\n                 }\n             }\n-            hir::ItemKind::Struct(ref struct_def, _) => {\n+            hir::ItemKind::Struct(..) => {\n                 let def = self.tcx.adt_def(item.owner_id.to_def_id());\n-                // If the struct has a constructor, encode it.\n-                if let Some(ctor_def_id) = struct_def.ctor_def_id() {\n-                    self.encode_struct_ctor(def, ctor_def_id.to_def_id());\n-                }\n+                self.encode_struct_ctor(def);\n             }\n             hir::ItemKind::Impl { .. } => {\n                 for &trait_item_def_id in\n@@ -2185,7 +2164,7 @@ impl EncodedMetadata {\n \n     #[inline]\n     pub fn raw_data(&self) -> &[u8] {\n-        self.mmap.as_ref().map(|mmap| mmap.as_ref()).unwrap_or_default()\n+        self.mmap.as_deref().unwrap_or_default()\n     }\n }\n "}, {"sha": "c51b8f96c715191cd96d648c267d88b0793995dd", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -366,7 +366,7 @@ define_tables! {\n     mir_for_ctfe: Table<DefIndex, LazyValue<mir::Body<'static>>>,\n     promoted_mir: Table<DefIndex, LazyValue<IndexVec<mir::Promoted, mir::Body<'static>>>>,\n     // FIXME(compiler-errors): Why isn't this a LazyArray?\n-    thir_abstract_const: Table<DefIndex, LazyValue<&'static [ty::abstract_const::Node<'static>]>>,\n+    thir_abstract_const: Table<DefIndex, LazyValue<ty::Const<'static>>>,\n     impl_parent: Table<DefIndex, RawDefId>,\n     impl_polarity: Table<DefIndex, ty::ImplPolarity>,\n     constness: Table<DefIndex, hir::Constness>,\n@@ -400,7 +400,7 @@ define_tables! {\n     assoc_container: Table<DefIndex, ty::AssocItemContainer>,\n     // Slot is full when macro is macro_rules.\n     macro_rules: Table<DefIndex, ()>,\n-    macro_definition: Table<DefIndex, LazyValue<ast::MacArgs>>,\n+    macro_definition: Table<DefIndex, LazyValue<ast::DelimArgs>>,\n     proc_macro: Table<DefIndex, MacroKind>,\n     module_reexports: Table<DefIndex, LazyArray<ModChild>>,\n     deduced_param_attrs: Table<DefIndex, LazyArray<DeducedParamAttrs>>,\n@@ -410,10 +410,9 @@ define_tables! {\n \n #[derive(TyEncodable, TyDecodable)]\n struct VariantData {\n-    ctor_kind: CtorKind,\n     discr: ty::VariantDiscr,\n     /// If this is unit or tuple-variant/struct, then this is the index of the ctor id.\n-    ctor: Option<DefIndex>,\n+    ctor: Option<(CtorKind, DefIndex)>,\n     is_non_exhaustive: bool,\n }\n "}, {"sha": "29fe6110797e3885947169dcbdccaa83432479b7", "filename": "compiler/rustc_metadata/src/rmeta/table.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -101,10 +101,8 @@ fixed_size_enum! {\n         ( Static(ast::Mutability::Mut)             )\n         ( Ctor(CtorOf::Struct, CtorKind::Fn)       )\n         ( Ctor(CtorOf::Struct, CtorKind::Const)    )\n-        ( Ctor(CtorOf::Struct, CtorKind::Fictive)  )\n         ( Ctor(CtorOf::Variant, CtorKind::Fn)      )\n         ( Ctor(CtorOf::Variant, CtorKind::Const)   )\n-        ( Ctor(CtorOf::Variant, CtorKind::Fictive) )\n         ( Macro(MacroKind::Bang)                   )\n         ( Macro(MacroKind::Attr)                   )\n         ( Macro(MacroKind::Derive)                 )"}, {"sha": "fc1167c105ae89c57faad7e5639fb4b738ab3a3e", "filename": "compiler/rustc_middle/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2FCargo.toml?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -4,7 +4,6 @@ version = \"0.0.0\"\n edition = \"2021\"\n \n [lib]\n-doctest = false\n \n [dependencies]\n bitflags = \"1.2.1\""}, {"sha": "7bd4b6c0c2767b88da187bceef23f07bc02fe241", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -6,7 +6,7 @@\n macro_rules! arena_types {\n     ($macro:path) => (\n         $macro!([\n-            [] layout: rustc_target::abi::LayoutS<'tcx>,\n+            [] layout: rustc_target::abi::LayoutS<rustc_target::abi::VariantIdx>,\n             [] fn_abi: rustc_target::abi::call::FnAbi<'tcx, rustc_middle::ty::Ty<'tcx>>,\n             // AdtDef are interned and compared by address\n             [decode] adt_def: rustc_middle::ty::AdtDefData,"}, {"sha": "5e94da8cb4d36ed4179dcaf43ab0ea4e3c668abd", "filename": "compiler/rustc_middle/src/error.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ferror.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -64,3 +64,11 @@ pub(crate) struct StrictCoherenceNeedsNegativeCoherence {\n     #[label]\n     pub attr_span: Option<Span>,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(middle_const_not_used_in_type_alias)]\n+pub(super) struct ConstNotUsedTraitAlias {\n+    pub ct: String,\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "4617c17b1537ea67ee32d99430b1f3f5335e7db3", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -245,15 +245,15 @@ impl<'hir> Map<'hir> {\n             },\n             Node::Variant(_) => DefKind::Variant,\n             Node::Ctor(variant_data) => {\n-                // FIXME(eddyb) is this even possible, if we have a `Node::Ctor`?\n-                assert_ne!(variant_data.ctor_hir_id(), None);\n-\n                 let ctor_of = match self.find(self.get_parent_node(hir_id)) {\n                     Some(Node::Item(..)) => def::CtorOf::Struct,\n                     Some(Node::Variant(..)) => def::CtorOf::Variant,\n                     _ => unreachable!(),\n                 };\n-                DefKind::Ctor(ctor_of, def::CtorKind::from_hir(variant_data))\n+                match variant_data.ctor_kind() {\n+                    Some(kind) => DefKind::Ctor(ctor_of, kind),\n+                    None => bug!(\"constructor node without a constructor\"),\n+                }\n             }\n             Node::AnonConst(_) => {\n                 let inline = match self.find(self.get_parent_node(hir_id)) {\n@@ -1058,7 +1058,7 @@ impl<'hir> Map<'hir> {\n             Node::Arm(arm) => arm.span,\n             Node::Block(block) => block.span,\n             Node::Ctor(..) => self.span_with_body(self.get_parent_node(hir_id)),\n-            Node::Lifetime(lifetime) => lifetime.span,\n+            Node::Lifetime(lifetime) => lifetime.ident.span,\n             Node::GenericParam(param) => param.span,\n             Node::Infer(i) => i.span,\n             Node::Local(local) => local.span,"}, {"sha": "12aef66bcf947d21c4383a28dd9ad8f7a61fdcd8", "filename": "compiler/rustc_middle/src/middle/limits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Flimits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Flimits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Flimits.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -38,7 +38,7 @@ pub fn provide(providers: &mut ty::query::Providers) {\n             tcx.hir().krate_attrs(),\n             tcx.sess,\n             sym::const_eval_limit,\n-            1_000_000,\n+            2_000_000,\n         ),\n     }\n }"}, {"sha": "fc08d58cc40687765dbf33fa580b95a17dcbe1fc", "filename": "compiler/rustc_middle/src/middle/privacy.rs", "status": "modified", "additions": 57, "deletions": 50, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -4,7 +4,6 @@\n use crate::ty::{DefIdTree, TyCtxt, Visibility};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_hir::def::DefKind;\n use rustc_macros::HashStable;\n use rustc_query_system::ich::StableHashingContext;\n use rustc_span::def_id::LocalDefId;\n@@ -142,13 +141,13 @@ impl EffectiveVisibilities {\n     pub fn set_public_at_level(\n         &mut self,\n         id: LocalDefId,\n-        default_vis: impl FnOnce() -> Visibility,\n+        lazy_private_vis: impl FnOnce() -> Visibility,\n         level: Level,\n     ) {\n         let mut effective_vis = self\n             .effective_vis(id)\n             .copied()\n-            .unwrap_or_else(|| EffectiveVisibility::from_vis(default_vis()));\n+            .unwrap_or_else(|| EffectiveVisibility::from_vis(lazy_private_vis()));\n         for l in Level::all_levels() {\n             if l <= level {\n                 *effective_vis.at_level_mut(l) = Visibility::Public;\n@@ -185,7 +184,6 @@ impl EffectiveVisibilities {\n                 );\n             }\n             let nominal_vis = tcx.visibility(def_id);\n-            let def_kind = tcx.opt_def_kind(def_id);\n             // FIXME: `rustc_privacy` is not yet updated for the new logic and can set\n             // effective visibilities that are larger than the nominal one.\n             if !nominal_vis.is_at_least(ev.reachable_through_impl_trait, tcx) && early {\n@@ -197,15 +195,15 @@ impl EffectiveVisibilities {\n                     nominal_vis\n                 );\n             }\n-            // Fully private items are never put into the table, this is important for performance.\n-            // FIXME: Fully private `mod` items are currently put into the table.\n-            if ev.reachable_through_impl_trait == private_vis && def_kind != Some(DefKind::Mod) {\n-                span_bug!(span, \"fully private item in the table {:?}: {:?}\", def_id, ev.direct);\n-            }\n         }\n     }\n }\n \n+pub trait IntoDefIdTree {\n+    type Tree: DefIdTree;\n+    fn tree(self) -> Self::Tree;\n+}\n+\n impl<Id: Eq + Hash> EffectiveVisibilities<Id> {\n     pub fn iter(&self) -> impl Iterator<Item = (&Id, &EffectiveVisibility)> {\n         self.map.iter()\n@@ -215,56 +213,65 @@ impl<Id: Eq + Hash> EffectiveVisibilities<Id> {\n         self.map.get(&id)\n     }\n \n-    // `parent_id` is not necessarily a parent in source code tree,\n-    // it is the node from which the maximum effective visibility is inherited.\n-    pub fn update(\n+    // FIXME: Share code with `fn update`.\n+    pub fn effective_vis_or_private(\n+        &mut self,\n+        id: Id,\n+        lazy_private_vis: impl FnOnce() -> Visibility,\n+    ) -> &EffectiveVisibility {\n+        self.map.entry(id).or_insert_with(|| EffectiveVisibility::from_vis(lazy_private_vis()))\n+    }\n+\n+    pub fn update<T: IntoDefIdTree>(\n         &mut self,\n         id: Id,\n         nominal_vis: Visibility,\n-        default_vis: Visibility,\n-        inherited_eff_vis: Option<EffectiveVisibility>,\n+        lazy_private_vis: impl FnOnce(T) -> (Visibility, T),\n+        inherited_effective_vis: EffectiveVisibility,\n         level: Level,\n-        tree: impl DefIdTree,\n+        mut into_tree: T,\n     ) -> bool {\n         let mut changed = false;\n-        let mut current_effective_vis = self\n-            .map\n-            .get(&id)\n-            .copied()\n-            .unwrap_or_else(|| EffectiveVisibility::from_vis(default_vis));\n-        if let Some(inherited_effective_vis) = inherited_eff_vis {\n-            let mut inherited_effective_vis_at_prev_level =\n-                *inherited_effective_vis.at_level(level);\n-            let mut calculated_effective_vis = inherited_effective_vis_at_prev_level;\n-            for l in Level::all_levels() {\n-                if level >= l {\n-                    let inherited_effective_vis_at_level = *inherited_effective_vis.at_level(l);\n-                    let current_effective_vis_at_level = current_effective_vis.at_level_mut(l);\n-                    // effective visibility for id shouldn't be recalculated if\n-                    // inherited from parent_id effective visibility isn't changed at next level\n-                    if !(inherited_effective_vis_at_prev_level == inherited_effective_vis_at_level\n-                        && level != l)\n-                    {\n-                        calculated_effective_vis =\n-                            if nominal_vis.is_at_least(inherited_effective_vis_at_level, tree) {\n-                                inherited_effective_vis_at_level\n-                            } else {\n-                                nominal_vis\n-                            };\n-                    }\n-                    // effective visibility can't be decreased at next update call for the\n-                    // same id\n-                    if *current_effective_vis_at_level != calculated_effective_vis\n-                        && calculated_effective_vis\n-                            .is_at_least(*current_effective_vis_at_level, tree)\n-                    {\n-                        changed = true;\n-                        *current_effective_vis_at_level = calculated_effective_vis;\n-                    }\n-                    inherited_effective_vis_at_prev_level = inherited_effective_vis_at_level;\n+        let mut current_effective_vis = match self.map.get(&id).copied() {\n+            Some(eff_vis) => eff_vis,\n+            None => {\n+                let private_vis;\n+                (private_vis, into_tree) = lazy_private_vis(into_tree);\n+                EffectiveVisibility::from_vis(private_vis)\n+            }\n+        };\n+        let tree = into_tree.tree();\n+\n+        let mut inherited_effective_vis_at_prev_level = *inherited_effective_vis.at_level(level);\n+        let mut calculated_effective_vis = inherited_effective_vis_at_prev_level;\n+        for l in Level::all_levels() {\n+            if level >= l {\n+                let inherited_effective_vis_at_level = *inherited_effective_vis.at_level(l);\n+                let current_effective_vis_at_level = current_effective_vis.at_level_mut(l);\n+                // effective visibility for id shouldn't be recalculated if\n+                // inherited from parent_id effective visibility isn't changed at next level\n+                if !(inherited_effective_vis_at_prev_level == inherited_effective_vis_at_level\n+                    && level != l)\n+                {\n+                    calculated_effective_vis =\n+                        if nominal_vis.is_at_least(inherited_effective_vis_at_level, tree) {\n+                            inherited_effective_vis_at_level\n+                        } else {\n+                            nominal_vis\n+                        };\n                 }\n+                // effective visibility can't be decreased at next update call for the\n+                // same id\n+                if *current_effective_vis_at_level != calculated_effective_vis\n+                    && calculated_effective_vis.is_at_least(*current_effective_vis_at_level, tree)\n+                {\n+                    changed = true;\n+                    *current_effective_vis_at_level = calculated_effective_vis;\n+                }\n+                inherited_effective_vis_at_prev_level = inherited_effective_vis_at_level;\n             }\n         }\n+\n         self.map.insert(id, current_effective_vis);\n         changed\n     }"}, {"sha": "f8a69f3c7d53f7b6a11de06c47f625eb3120ee70", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -11,6 +11,8 @@ use std::hash;\n use std::ops::Range;\n use std::ptr;\n \n+use either::{Left, Right};\n+\n use rustc_ast::Mutability;\n use rustc_data_structures::intern::Interned;\n use rustc_span::DUMMY_SP;\n@@ -503,11 +505,11 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n         // `to_bits_or_ptr_internal` is the right method because we just want to store this data\n         // as-is into memory.\n         let (bytes, provenance) = match val.to_bits_or_ptr_internal(range.size)? {\n-            Err(val) => {\n-                let (provenance, offset) = val.into_parts();\n+            Right(ptr) => {\n+                let (provenance, offset) = ptr.into_parts();\n                 (u128::from(offset.bytes()), Some(provenance))\n             }\n-            Ok(data) => (data, None),\n+            Left(data) => (data, None),\n         };\n \n         let endian = cx.data_layout().endian;"}, {"sha": "770c3ed05e8d2650557c62735f054a870aa7f432", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -1,6 +1,8 @@\n use std::convert::{TryFrom, TryInto};\n use std::fmt;\n \n+use either::{Either, Left, Right};\n+\n use rustc_apfloat::{\n     ieee::{Double, Single},\n     Float,\n@@ -293,10 +295,10 @@ impl<Prov> Scalar<Prov> {\n     pub fn to_bits_or_ptr_internal(\n         self,\n         target_size: Size,\n-    ) -> Result<Result<u128, Pointer<Prov>>, ScalarSizeMismatch> {\n+    ) -> Result<Either<u128, Pointer<Prov>>, ScalarSizeMismatch> {\n         assert_ne!(target_size.bytes(), 0, \"you should never look at the bits of a ZST\");\n         Ok(match self {\n-            Scalar::Int(int) => Ok(int.to_bits(target_size).map_err(|size| {\n+            Scalar::Int(int) => Left(int.to_bits(target_size).map_err(|size| {\n                 ScalarSizeMismatch { target_size: target_size.bytes(), data_size: size.bytes() }\n             })?),\n             Scalar::Ptr(ptr, sz) => {\n@@ -306,7 +308,7 @@ impl<Prov> Scalar<Prov> {\n                         data_size: sz.into(),\n                     });\n                 }\n-                Err(ptr)\n+                Right(ptr)\n             }\n         })\n     }\n@@ -318,8 +320,8 @@ impl<'tcx, Prov: Provenance> Scalar<Prov> {\n             .to_bits_or_ptr_internal(cx.pointer_size())\n             .map_err(|s| err_ub!(ScalarSizeMismatch(s)))?\n         {\n-            Err(ptr) => Ok(ptr.into()),\n-            Ok(bits) => {\n+            Right(ptr) => Ok(ptr.into()),\n+            Left(bits) => {\n                 let addr = u64::try_from(bits).unwrap();\n                 Ok(Pointer::from_addr(addr))\n             }"}, {"sha": "364c1b375ae5dc70e7e22781d027db577ba46509", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -1884,7 +1884,7 @@ impl<'tcx> Operand<'tcx> {\n         substs: SubstsRef<'tcx>,\n         span: Span,\n     ) -> Self {\n-        let ty = tcx.bound_type_of(def_id).subst(tcx, substs);\n+        let ty = tcx.mk_fn_def(def_id, substs);\n         Operand::Constant(Box::new(Constant {\n             span,\n             user_ty: None,\n@@ -2115,10 +2115,10 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                                 .print_def_path(variant_def.def_id, substs)?\n                                 .into_buffer();\n \n-                            match variant_def.ctor_kind {\n-                                CtorKind::Const => fmt.write_str(&name),\n-                                CtorKind::Fn => fmt_tuple(fmt, &name),\n-                                CtorKind::Fictive => {\n+                            match variant_def.ctor_kind() {\n+                                Some(CtorKind::Const) => fmt.write_str(&name),\n+                                Some(CtorKind::Fn) => fmt_tuple(fmt, &name),\n+                                None => {\n                                     let mut struct_fmt = fmt.debug_struct(&name);\n                                     for (field, place) in iter::zip(&variant_def.fields, places) {\n                                         struct_fmt.field(field.name.as_str(), place);\n@@ -2955,14 +2955,14 @@ fn pretty_print_const_value<'tcx>(\n                             let cx = cx.print_value_path(variant_def.def_id, substs)?;\n                             fmt.write_str(&cx.into_buffer())?;\n \n-                            match variant_def.ctor_kind {\n-                                CtorKind::Const => {}\n-                                CtorKind::Fn => {\n+                            match variant_def.ctor_kind() {\n+                                Some(CtorKind::Const) => {}\n+                                Some(CtorKind::Fn) => {\n                                     fmt.write_str(\"(\")?;\n                                     comma_sep(fmt, fields)?;\n                                     fmt.write_str(\")\")?;\n                                 }\n-                                CtorKind::Fictive => {\n+                                None => {\n                                     fmt.write_str(\" {{ \")?;\n                                     let mut first = true;\n                                     for (field_def, field) in iter::zip(&variant_def.fields, fields)"}, {"sha": "1cac656674d697a407dcb858cfe7967338c533e1", "filename": "compiler/rustc_middle/src/mir/pretty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -476,6 +476,7 @@ impl<'tcx> Visitor<'tcx> for ExtraComments<'tcx> {\n                     // These variants shouldn't exist in the MIR.\n                     ty::ConstKind::Placeholder(_)\n                     | ty::ConstKind::Infer(_)\n+                    | ty::ConstKind::Expr(_)\n                     | ty::ConstKind::Bound(..) => bug!(\"unexpected MIR constant: {:?}\", literal),\n                 },\n                 ConstantKind::Unevaluated(uv, _) => {"}, {"sha": "f2030b91b9b65e679cfe1b12d16b5d888c00381b", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -1185,15 +1185,17 @@ pub enum NullOp {\n     AlignOf,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, Hash, HashStable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[derive(HashStable, TyEncodable, TyDecodable, TypeFoldable, TypeVisitable)]\n pub enum UnOp {\n     /// The `!` operator for logical inversion\n     Not,\n     /// The `-` operator for negation\n     Neg,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, PartialOrd, Eq, TyEncodable, TyDecodable, Hash, HashStable)]\n+#[derive(Copy, Clone, Debug, PartialEq, PartialOrd, Ord, Eq, Hash)]\n+#[derive(TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable)]\n pub enum BinOp {\n     /// The `+` operator (addition)\n     Add,"}, {"sha": "0705b4cff53ad788c76c95a8654eac8bfbc8575a", "filename": "compiler/rustc_middle/src/mir/type_foldable.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -16,9 +16,7 @@ TrivialTypeTraversalAndLiftImpls! {\n     UserTypeAnnotationIndex,\n     BorrowKind,\n     CastKind,\n-    BinOp,\n     NullOp,\n-    UnOp,\n     hir::Movability,\n     BasicBlock,\n     SwitchTargets,"}, {"sha": "880632561b9e8e2ba75ee46aac677f9932f879f2", "filename": "compiler/rustc_middle/src/query/keys.rs", "status": "renamed", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fkeys.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -1,19 +1,22 @@\n //! Defines the set of legal keys that can be used in queries.\n \n+use crate::infer::canonical::Canonical;\n+use crate::mir;\n+use crate::traits;\n+use crate::ty::fast_reject::SimplifiedType;\n+use crate::ty::subst::{GenericArg, SubstsRef};\n+use crate::ty::{self, layout::TyAndLayout, Ty, TyCtxt};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::hir_id::{HirId, OwnerId};\n-use rustc_middle::infer::canonical::Canonical;\n-use rustc_middle::mir;\n-use rustc_middle::traits;\n-use rustc_middle::ty::fast_reject::SimplifiedType;\n-use rustc_middle::ty::subst::{GenericArg, SubstsRef};\n-use rustc_middle::ty::{self, layout::TyAndLayout, Ty, TyCtxt};\n+use rustc_query_system::query::{DefaultCacheSelector, VecCacheSelector};\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n \n /// The `Key` trait controls what types can legally be used as the key\n /// for a query.\n-pub trait Key {\n+pub trait Key: Sized {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     /// Given an instance of this key, what crate is it referring to?\n     /// This is used to find the provider.\n     fn query_crate_is_local(&self) -> bool;\n@@ -100,6 +103,8 @@ impl<'tcx> Key for mir::interpret::LitToConstInput<'tcx> {\n }\n \n impl Key for CrateNum {\n+    type CacheSelector = VecCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         *self == LOCAL_CRATE\n@@ -110,6 +115,8 @@ impl Key for CrateNum {\n }\n \n impl Key for OwnerId {\n+    type CacheSelector = VecCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -123,6 +130,8 @@ impl Key for OwnerId {\n }\n \n impl Key for LocalDefId {\n+    type CacheSelector = VecCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true", "previous_filename": "compiler/rustc_query_impl/src/keys.rs"}, {"sha": "38b72ec923193a4e0420d9e49df39bae51a2a29b", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 9, "deletions": 24, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -7,6 +7,9 @@\n use crate::ty::{self, print::describe_as_module, TyCtxt};\n use rustc_span::def_id::LOCAL_CRATE;\n \n+mod keys;\n+pub use keys::Key;\n+\n // Each of these queries corresponds to a function pointer field in the\n // `Providers` struct for requesting a value of that type, and a method\n // on `tcx: TyCtxt` (and `tcx.at(span)`) for doing that request in a way\n@@ -397,7 +400,7 @@ rustc_queries! {\n     /// Try to build an abstract representation of the given constant.\n     query thir_abstract_const(\n         key: DefId\n-    ) -> Result<Option<&'tcx [ty::abstract_const::Node<'tcx>]>, ErrorGuaranteed> {\n+    ) -> Result<Option<ty::Const<'tcx>>, ErrorGuaranteed> {\n         desc {\n             |tcx| \"building an abstract representation for `{}`\", tcx.def_path_str(key),\n         }\n@@ -406,23 +409,14 @@ rustc_queries! {\n     /// Try to build an abstract representation of the given constant.\n     query thir_abstract_const_of_const_arg(\n         key: (LocalDefId, DefId)\n-    ) -> Result<Option<&'tcx [ty::abstract_const::Node<'tcx>]>, ErrorGuaranteed> {\n+    ) -> Result<Option<ty::Const<'tcx>>, ErrorGuaranteed> {\n         desc {\n             |tcx|\n             \"building an abstract representation for the const argument `{}`\",\n             tcx.def_path_str(key.0.to_def_id()),\n         }\n     }\n \n-    query try_unify_abstract_consts(key:\n-        ty::ParamEnvAnd<'tcx, (ty::UnevaluatedConst<'tcx>, ty::UnevaluatedConst<'tcx>\n-    )>) -> bool {\n-        desc {\n-            |tcx| \"trying to unify the generic constants `{}` and `{}`\",\n-            tcx.def_path_str(key.value.0.def.did), tcx.def_path_str(key.value.1.def.did)\n-        }\n-    }\n-\n     query mir_drops_elaborated_and_const_checked(\n         key: ty::WithOptConstParam<LocalDefId>\n     ) -> &'tcx Steal<mir::Body<'tcx>> {\n@@ -1648,6 +1642,8 @@ rustc_queries! {\n     /// a generic type parameter will panic if you call this method on it:\n     ///\n     /// ```\n+    /// use std::fmt::Debug;\n+    ///\n     /// pub trait Foo<T: Debug> {}\n     /// ```\n     ///\n@@ -2072,19 +2068,8 @@ rustc_queries! {\n         remap_env_constness\n     }\n \n-    query normalize_opaque_types(key: &'tcx ty::List<ty::Predicate<'tcx>>) -> &'tcx ty::List<ty::Predicate<'tcx>> {\n-        desc { \"normalizing opaque types in `{:?}`\", key }\n-    }\n-\n-    /// Checks whether a type is definitely uninhabited. This is\n-    /// conservative: for some types that are uninhabited we return `false`,\n-    /// but we only return `true` for types that are definitely uninhabited.\n-    /// `ty.conservative_is_privately_uninhabited` implies that any value of type `ty`\n-    /// will be `Abi::Uninhabited`. (Note that uninhabited types may have nonzero\n-    /// size, to account for partial initialisation. See #49298 for details.)\n-    query conservative_is_privately_uninhabited(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-        desc { \"conservatively checking if `{}` is privately uninhabited\", key.value }\n-        remap_env_constness\n+    query reveal_opaque_types_in_bounds(key: &'tcx ty::List<ty::Predicate<'tcx>>) -> &'tcx ty::List<ty::Predicate<'tcx>> {\n+        desc { \"revealing opaque types in `{:?}`\", key }\n     }\n \n     query limits(key: ()) -> Limits {"}, {"sha": "8bef9dfe099b9e2a5838a2a7339395723a2c51c7", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -10,7 +10,6 @@\n \n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_hir as hir;\n-use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::RangeEnd;\n use rustc_index::newtype_index;\n@@ -751,7 +750,7 @@ impl<'tcx> fmt::Display for Pat<'tcx> {\n \n                     // Only for Adt we can have `S {...}`,\n                     // which we handle separately here.\n-                    if variant.ctor_kind == CtorKind::Fictive {\n+                    if variant.ctor.is_none() {\n                         write!(f, \" {{ \")?;\n \n                         let mut printed = 0;"}, {"sha": "26f3052b642b27d6af86b56a5d87a14b420347d6", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -651,15 +651,12 @@ pub enum ImplSource<'tcx, N> {\n     /// Same as above, but for a function pointer type with the given signature.\n     FnPointer(ImplSourceFnPointerData<'tcx, N>),\n \n-    /// ImplSource for a builtin `DeterminantKind` trait implementation.\n-    DiscriminantKind(ImplSourceDiscriminantKindData),\n-\n-    /// ImplSource for a builtin `Pointee` trait implementation.\n-    Pointee(ImplSourcePointeeData),\n-\n     /// ImplSource automatically generated for a generator.\n     Generator(ImplSourceGeneratorData<'tcx, N>),\n \n+    /// ImplSource automatically generated for a generator backing an async future.\n+    Future(ImplSourceFutureData<'tcx, N>),\n+\n     /// ImplSource for a trait alias.\n     TraitAlias(ImplSourceTraitAliasData<'tcx, N>),\n \n@@ -676,10 +673,9 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n             ImplSource::AutoImpl(d) => d.nested,\n             ImplSource::Closure(c) => c.nested,\n             ImplSource::Generator(c) => c.nested,\n+            ImplSource::Future(c) => c.nested,\n             ImplSource::Object(d) => d.nested,\n             ImplSource::FnPointer(d) => d.nested,\n-            ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData)\n-            | ImplSource::Pointee(ImplSourcePointeeData) => vec![],\n             ImplSource::TraitAlias(d) => d.nested,\n             ImplSource::TraitUpcasting(d) => d.nested,\n             ImplSource::ConstDestruct(i) => i.nested,\n@@ -694,10 +690,9 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n             ImplSource::AutoImpl(d) => &d.nested,\n             ImplSource::Closure(c) => &c.nested,\n             ImplSource::Generator(c) => &c.nested,\n+            ImplSource::Future(c) => &c.nested,\n             ImplSource::Object(d) => &d.nested,\n             ImplSource::FnPointer(d) => &d.nested,\n-            ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData)\n-            | ImplSource::Pointee(ImplSourcePointeeData) => &[],\n             ImplSource::TraitAlias(d) => &d.nested,\n             ImplSource::TraitUpcasting(d) => &d.nested,\n             ImplSource::ConstDestruct(i) => &i.nested,\n@@ -737,16 +732,15 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n                 substs: c.substs,\n                 nested: c.nested.into_iter().map(f).collect(),\n             }),\n+            ImplSource::Future(c) => ImplSource::Future(ImplSourceFutureData {\n+                generator_def_id: c.generator_def_id,\n+                substs: c.substs,\n+                nested: c.nested.into_iter().map(f).collect(),\n+            }),\n             ImplSource::FnPointer(p) => ImplSource::FnPointer(ImplSourceFnPointerData {\n                 fn_ty: p.fn_ty,\n                 nested: p.nested.into_iter().map(f).collect(),\n             }),\n-            ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData) => {\n-                ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData)\n-            }\n-            ImplSource::Pointee(ImplSourcePointeeData) => {\n-                ImplSource::Pointee(ImplSourcePointeeData)\n-            }\n             ImplSource::TraitAlias(d) => ImplSource::TraitAlias(ImplSourceTraitAliasData {\n                 alias_def_id: d.alias_def_id,\n                 substs: d.substs,\n@@ -796,6 +790,16 @@ pub struct ImplSourceGeneratorData<'tcx, N> {\n     pub nested: Vec<N>,\n }\n \n+#[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, Lift)]\n+#[derive(TypeFoldable, TypeVisitable)]\n+pub struct ImplSourceFutureData<'tcx, N> {\n+    pub generator_def_id: DefId,\n+    pub substs: SubstsRef<'tcx>,\n+    /// Nested obligations. This can be non-empty if the generator\n+    /// signature contains associated types.\n+    pub nested: Vec<N>,\n+}\n+\n #[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, Lift)]\n #[derive(TypeFoldable, TypeVisitable)]\n pub struct ImplSourceClosureData<'tcx, N> {\n@@ -856,13 +860,6 @@ pub struct ImplSourceFnPointerData<'tcx, N> {\n     pub nested: Vec<N>,\n }\n \n-// FIXME(@lcnr): This should be  refactored and merged with other builtin vtables.\n-#[derive(Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, HashStable)]\n-pub struct ImplSourceDiscriminantKindData;\n-\n-#[derive(Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, HashStable)]\n-pub struct ImplSourcePointeeData;\n-\n #[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, Lift)]\n #[derive(TypeFoldable, TypeVisitable)]\n pub struct ImplSourceConstDestructData<N> {"}, {"sha": "ec69864c951d4df347bb0befaf12df9587561fae", "filename": "compiler/rustc_middle/src/traits/select.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -105,6 +105,12 @@ pub type EvaluationCache<'tcx> = Cache<\n /// parameter environment.\n #[derive(PartialEq, Eq, Debug, Clone, TypeFoldable, TypeVisitable)]\n pub enum SelectionCandidate<'tcx> {\n+    /// A builtin implementation for some specific traits, used in cases\n+    /// where we cannot rely an ordinary library implementations.\n+    ///\n+    /// The most notable examples are `sized`, `Copy` and `Clone`. This is also\n+    /// used for the `DiscriminantKind` and `Pointee` trait, both of which have\n+    /// an associated type.\n     BuiltinCandidate {\n         /// `false` if there are no *further* obligations.\n         has_nested: bool,\n@@ -131,18 +137,16 @@ pub enum SelectionCandidate<'tcx> {\n     /// generated for a generator.\n     GeneratorCandidate,\n \n+    /// Implementation of a `Future` trait by one of the generator types\n+    /// generated for an async construct.\n+    FutureCandidate,\n+\n     /// Implementation of a `Fn`-family trait by one of the anonymous\n     /// types generated for a fn pointer type (e.g., `fn(int) -> int`)\n     FnPointerCandidate {\n         is_const: bool,\n     },\n \n-    /// Builtin implementation of `DiscriminantKind`.\n-    DiscriminantKindCandidate,\n-\n-    /// Builtin implementation of `Pointee`.\n-    PointeeCandidate,\n-\n     TraitAliasCandidate,\n \n     /// Matching `dyn Trait` with a supertrait of `Trait`. The index is the"}, {"sha": "6acb7745d654e9552b8adc86c4a61418957c40d0", "filename": "compiler/rustc_middle/src/traits/structural_impls.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -15,11 +15,9 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSource<'tcx, N> {\n \n             super::ImplSource::Generator(ref d) => write!(f, \"{:?}\", d),\n \n-            super::ImplSource::FnPointer(ref d) => write!(f, \"({:?})\", d),\n-\n-            super::ImplSource::DiscriminantKind(ref d) => write!(f, \"{:?}\", d),\n+            super::ImplSource::Future(ref d) => write!(f, \"{:?}\", d),\n \n-            super::ImplSource::Pointee(ref d) => write!(f, \"{:?}\", d),\n+            super::ImplSource::FnPointer(ref d) => write!(f, \"({:?})\", d),\n \n             super::ImplSource::Object(ref d) => write!(f, \"{:?}\", d),\n \n@@ -58,6 +56,16 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceGeneratorData<'tcx, N\n     }\n }\n \n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceFutureData<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(\n+            f,\n+            \"ImplSourceFutureData(generator_def_id={:?}, substs={:?}, nested={:?})\",\n+            self.generator_def_id, self.substs, self.nested\n+        )\n+    }\n+}\n+\n impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceClosureData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n@@ -125,11 +133,3 @@ impl<N: fmt::Debug> fmt::Debug for traits::ImplSourceConstDestructData<N> {\n         write!(f, \"ImplSourceConstDestructData(nested={:?})\", self.nested)\n     }\n }\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Lift implementations\n-\n-TrivialTypeTraversalAndLiftImpls! {\n-    super::ImplSourceDiscriminantKindData,\n-    super::ImplSourcePointeeData,\n-}"}, {"sha": "cd147d7e55813d5b4aaec1ab09461a4fd6405abd", "filename": "compiler/rustc_middle/src/ty/_match.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -36,13 +36,22 @@ impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n+\n+    fn intercrate(&self) -> bool {\n+        false\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.param_env\n     }\n     fn a_is_expected(&self) -> bool {\n         true\n     } // irrelevant\n \n+    fn mark_ambiguous(&mut self) {\n+        bug!()\n+    }\n+\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _: ty::Variance,"}, {"sha": "5de758ad9babd04d53a6da306b0bfbf001f01492", "filename": "compiler/rustc_middle/src/ty/abstract_const.rs", "status": "modified", "additions": 45, "deletions": 155, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -1,115 +1,20 @@\n //! A subset of a mir body used for const evaluatability checking.\n-use crate::mir;\n-use crate::ty::visit::TypeVisitable;\n-use crate::ty::{self, EarlyBinder, SubstsRef, Ty, TyCtxt};\n+use crate::ty::{\n+    self, Const, EarlyBinder, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable,\n+    TypeVisitable,\n+};\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::DefId;\n-use std::cmp;\n-use std::ops::ControlFlow;\n \n-rustc_index::newtype_index! {\n-    /// An index into an `AbstractConst`.\n-    pub struct NodeId {\n-        derive [HashStable]\n-        DEBUG_FORMAT = \"n{}\",\n-    }\n-}\n-\n-/// A tree representing an anonymous constant.\n-///\n-/// This is only able to represent a subset of `MIR`,\n-/// and should not leak any information about desugarings.\n-#[derive(Debug, Clone, Copy)]\n-pub struct AbstractConst<'tcx> {\n-    // FIXME: Consider adding something like `IndexSlice`\n-    // and use this here.\n-    inner: &'tcx [Node<'tcx>],\n-    substs: SubstsRef<'tcx>,\n-}\n-\n-impl<'tcx> AbstractConst<'tcx> {\n-    pub fn new(\n-        tcx: TyCtxt<'tcx>,\n-        uv: ty::UnevaluatedConst<'tcx>,\n-    ) -> Result<Option<AbstractConst<'tcx>>, ErrorGuaranteed> {\n-        let inner = tcx.thir_abstract_const_opt_const_arg(uv.def)?;\n-        debug!(\"AbstractConst::new({:?}) = {:?}\", uv, inner);\n-        Ok(inner.map(|inner| AbstractConst { inner, substs: tcx.erase_regions(uv.substs) }))\n-    }\n-\n-    pub fn from_const(\n-        tcx: TyCtxt<'tcx>,\n-        ct: ty::Const<'tcx>,\n-    ) -> Result<Option<AbstractConst<'tcx>>, ErrorGuaranteed> {\n-        match ct.kind() {\n-            ty::ConstKind::Unevaluated(uv) => AbstractConst::new(tcx, uv),\n-            ty::ConstKind::Error(reported) => Err(reported),\n-            _ => Ok(None),\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn subtree(self, node: NodeId) -> AbstractConst<'tcx> {\n-        AbstractConst { inner: &self.inner[..=node.index()], substs: self.substs }\n-    }\n-\n-    #[inline]\n-    pub fn root(self, tcx: TyCtxt<'tcx>) -> Node<'tcx> {\n-        let node = self.inner.last().copied().unwrap();\n-        match node {\n-            Node::Leaf(leaf) => Node::Leaf(EarlyBinder(leaf).subst(tcx, self.substs)),\n-            Node::Cast(kind, operand, ty) => {\n-                Node::Cast(kind, operand, EarlyBinder(ty).subst(tcx, self.substs))\n-            }\n-            // Don't perform substitution on the following as they can't directly contain generic params\n-            Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => node,\n-        }\n-    }\n-\n-    pub fn unify_failure_kind(self, tcx: TyCtxt<'tcx>) -> FailureKind {\n-        let mut failure_kind = FailureKind::Concrete;\n-        walk_abstract_const::<!, _>(tcx, self, |node| {\n-            match node.root(tcx) {\n-                Node::Leaf(leaf) => {\n-                    if leaf.has_non_region_infer() {\n-                        failure_kind = FailureKind::MentionsInfer;\n-                    } else if leaf.has_non_region_param() {\n-                        failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n-                    }\n-                }\n-                Node::Cast(_, _, ty) => {\n-                    if ty.has_non_region_infer() {\n-                        failure_kind = FailureKind::MentionsInfer;\n-                    } else if ty.has_non_region_param() {\n-                        failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n-                    }\n-                }\n-                Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => {}\n-            }\n-            ControlFlow::CONTINUE\n-        });\n-        failure_kind\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n+#[derive(Hash, Debug, Clone, Copy, Ord, PartialOrd, PartialEq, Eq)]\n+#[derive(TyDecodable, TyEncodable, HashStable, TypeVisitable, TypeFoldable)]\n pub enum CastKind {\n     /// thir::ExprKind::As\n     As,\n     /// thir::ExprKind::Use\n     Use,\n }\n \n-/// A node of an `AbstractConst`.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n-pub enum Node<'tcx> {\n-    Leaf(ty::Const<'tcx>),\n-    Binop(mir::BinOp, NodeId, NodeId),\n-    UnaryOp(mir::UnOp, NodeId),\n-    FunctionCall(NodeId, &'tcx [NodeId]),\n-    Cast(CastKind, NodeId, Ty<'tcx>),\n-}\n-\n #[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n pub enum NotConstEvaluatable {\n     Error(ErrorGuaranteed),\n@@ -127,68 +32,53 @@ TrivialTypeTraversalAndLiftImpls! {\n     NotConstEvaluatable,\n }\n \n+pub type BoundAbstractConst<'tcx> = Result<Option<EarlyBinder<ty::Const<'tcx>>>, ErrorGuaranteed>;\n+\n impl<'tcx> TyCtxt<'tcx> {\n-    #[inline]\n-    pub fn thir_abstract_const_opt_const_arg(\n+    /// Returns a const without substs applied\n+    pub fn bound_abstract_const(\n         self,\n-        def: ty::WithOptConstParam<DefId>,\n-    ) -> Result<Option<&'tcx [Node<'tcx>]>, ErrorGuaranteed> {\n-        if let Some((did, param_did)) = def.as_const_arg() {\n+        uv: ty::WithOptConstParam<DefId>,\n+    ) -> BoundAbstractConst<'tcx> {\n+        let ac = if let Some((did, param_did)) = uv.as_const_arg() {\n             self.thir_abstract_const_of_const_arg((did, param_did))\n         } else {\n-            self.thir_abstract_const(def.did)\n-        }\n+            self.thir_abstract_const(uv.did)\n+        };\n+        Ok(ac?.map(|ac| EarlyBinder(ac)))\n     }\n-}\n \n-#[instrument(skip(tcx, f), level = \"debug\")]\n-pub fn walk_abstract_const<'tcx, R, F>(\n-    tcx: TyCtxt<'tcx>,\n-    ct: AbstractConst<'tcx>,\n-    mut f: F,\n-) -> ControlFlow<R>\n-where\n-    F: FnMut(AbstractConst<'tcx>) -> ControlFlow<R>,\n-{\n-    #[instrument(skip(tcx, f), level = \"debug\")]\n-    fn recurse<'tcx, R>(\n-        tcx: TyCtxt<'tcx>,\n-        ct: AbstractConst<'tcx>,\n-        f: &mut dyn FnMut(AbstractConst<'tcx>) -> ControlFlow<R>,\n-    ) -> ControlFlow<R> {\n-        f(ct)?;\n-        let root = ct.root(tcx);\n-        debug!(?root);\n-        match root {\n-            Node::Leaf(_) => ControlFlow::CONTINUE,\n-            Node::Binop(_, l, r) => {\n-                recurse(tcx, ct.subtree(l), f)?;\n-                recurse(tcx, ct.subtree(r), f)\n+    pub fn expand_abstract_consts<T: TypeFoldable<'tcx>>(self, ac: T) -> T {\n+        struct Expander<'tcx> {\n+            tcx: TyCtxt<'tcx>,\n+        }\n+\n+        impl<'tcx> TypeFolder<'tcx> for Expander<'tcx> {\n+            fn tcx(&self) -> TyCtxt<'tcx> {\n+                self.tcx\n             }\n-            Node::UnaryOp(_, v) => recurse(tcx, ct.subtree(v), f),\n-            Node::FunctionCall(func, args) => {\n-                recurse(tcx, ct.subtree(func), f)?;\n-                args.iter().try_for_each(|&arg| recurse(tcx, ct.subtree(arg), f))\n+            fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+                if ty.has_type_flags(ty::TypeFlags::HAS_CT_PROJECTION) {\n+                    ty.super_fold_with(self)\n+                } else {\n+                    ty\n+                }\n+            }\n+            fn fold_const(&mut self, c: Const<'tcx>) -> Const<'tcx> {\n+                let ct = match c.kind() {\n+                    ty::ConstKind::Unevaluated(uv) => match self.tcx.bound_abstract_const(uv.def) {\n+                        Err(e) => self.tcx.const_error_with_guaranteed(c.ty(), e),\n+                        Ok(Some(bac)) => {\n+                            let substs = self.tcx.erase_regions(uv.substs);\n+                            bac.subst(self.tcx, substs)\n+                        }\n+                        Ok(None) => c,\n+                    },\n+                    _ => c,\n+                };\n+                ct.super_fold_with(self)\n             }\n-            Node::Cast(_, operand, _) => recurse(tcx, ct.subtree(operand), f),\n         }\n+        ac.fold_with(&mut Expander { tcx: self })\n     }\n-\n-    recurse(tcx, ct, &mut f)\n-}\n-\n-// We were unable to unify the abstract constant with\n-// a constant found in the caller bounds, there are\n-// now three possible cases here.\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n-pub enum FailureKind {\n-    /// The abstract const still references an inference\n-    /// variable, in this case we return `TooGeneric`.\n-    MentionsInfer,\n-    /// The abstract const references a generic parameter,\n-    /// this means that we emit an error here.\n-    MentionsParam,\n-    /// The substs are concrete enough that we can simply\n-    /// try and evaluate the given constant.\n-    Concrete,\n }"}, {"sha": "7036c4a7b27d60b8da7772a1e575c33297736d4d", "filename": "compiler/rustc_middle/src/ty/adjustment.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -1,7 +1,5 @@\n-use crate::ty::subst::SubstsRef;\n use crate::ty::{self, Ty, TyCtxt};\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_macros::HashStable;\n use rustc_span::Span;\n@@ -121,7 +119,8 @@ pub struct OverloadedDeref<'tcx> {\n }\n \n impl<'tcx> OverloadedDeref<'tcx> {\n-    pub fn method_call(&self, tcx: TyCtxt<'tcx>, source: Ty<'tcx>) -> (DefId, SubstsRef<'tcx>) {\n+    /// Get the zst function item type for this method call.\n+    pub fn method_call(&self, tcx: TyCtxt<'tcx>, source: Ty<'tcx>) -> Ty<'tcx> {\n         let trait_def_id = match self.mutbl {\n             hir::Mutability::Not => tcx.require_lang_item(LangItem::Deref, None),\n             hir::Mutability::Mut => tcx.require_lang_item(LangItem::DerefMut, None),\n@@ -132,7 +131,7 @@ impl<'tcx> OverloadedDeref<'tcx> {\n             .find(|m| m.kind == ty::AssocKind::Fn)\n             .unwrap()\n             .def_id;\n-        (method_def_id, tcx.mk_substs_trait(source, &[]))\n+        tcx.mk_fn_def(method_def_id, tcx.mk_substs_trait(source, []))\n     }\n }\n \n@@ -160,6 +159,18 @@ pub enum AutoBorrowMutability {\n     Not,\n }\n \n+impl AutoBorrowMutability {\n+    /// Creates an `AutoBorrowMutability` from a mutability and allowance of two phase borrows.\n+    ///\n+    /// Note that when `mutbl.is_not()`, `allow_two_phase_borrow` is ignored\n+    pub fn new(mutbl: hir::Mutability, allow_two_phase_borrow: AllowTwoPhase) -> Self {\n+        match mutbl {\n+            hir::Mutability::Not => Self::Not,\n+            hir::Mutability::Mut => Self::Mut { allow_two_phase_borrow },\n+        }\n+    }\n+}\n+\n impl From<AutoBorrowMutability> for hir::Mutability {\n     fn from(m: AutoBorrowMutability) -> Self {\n         match m {"}, {"sha": "d3d667f68407fde123e0407e22ba4caa1d0a1095", "filename": "compiler/rustc_middle/src/ty/adt.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -14,17 +14,15 @@ use rustc_index::vec::{Idx, IndexVec};\n use rustc_query_system::ich::StableHashingContext;\n use rustc_session::DataTypeKind;\n use rustc_span::symbol::sym;\n-use rustc_target::abi::VariantIdx;\n+use rustc_target::abi::{ReprOptions, VariantIdx};\n \n use std::cell::RefCell;\n use std::cmp::Ordering;\n use std::hash::{Hash, Hasher};\n use std::ops::Range;\n use std::str;\n \n-use super::{\n-    Destructor, FieldDef, GenericPredicates, ReprOptions, Ty, TyCtxt, VariantDef, VariantDiscr,\n-};\n+use super::{Destructor, FieldDef, GenericPredicates, Ty, TyCtxt, VariantDef, VariantDiscr};\n \n bitflags! {\n     #[derive(HashStable, TyEncodable, TyDecodable)]\n@@ -230,7 +228,7 @@ impl AdtDefData {\n             AdtKind::Struct => AdtFlags::IS_STRUCT,\n         };\n \n-        if kind == AdtKind::Struct && variants[VariantIdx::new(0)].ctor_def_id.is_some() {\n+        if kind == AdtKind::Struct && variants[VariantIdx::new(0)].ctor.is_some() {\n             flags |= AdtFlags::HAS_CTOR;\n         }\n \n@@ -386,11 +384,9 @@ impl<'tcx> AdtDef<'tcx> {\n         //    Baz = 3,\n         // }\n         // ```\n-        if self\n-            .variants()\n-            .iter()\n-            .any(|v| matches!(v.discr, VariantDiscr::Explicit(_)) && v.ctor_kind != CtorKind::Const)\n-        {\n+        if self.variants().iter().any(|v| {\n+            matches!(v.discr, VariantDiscr::Explicit(_)) && v.ctor_kind() != Some(CtorKind::Const)\n+        }) {\n             return false;\n         }\n         self.variants().iter().all(|v| v.fields.is_empty())\n@@ -405,7 +401,7 @@ impl<'tcx> AdtDef<'tcx> {\n     pub fn variant_with_ctor_id(self, cid: DefId) -> &'tcx VariantDef {\n         self.variants()\n             .iter()\n-            .find(|v| v.ctor_def_id == Some(cid))\n+            .find(|v| v.ctor_def_id() == Some(cid))\n             .expect(\"variant_with_ctor_id: unknown variant\")\n     }\n \n@@ -422,7 +418,7 @@ impl<'tcx> AdtDef<'tcx> {\n     pub fn variant_index_with_ctor_id(self, cid: DefId) -> VariantIdx {\n         self.variants()\n             .iter_enumerated()\n-            .find(|(_, v)| v.ctor_def_id == Some(cid))\n+            .find(|(_, v)| v.ctor_def_id() == Some(cid))\n             .expect(\"variant_index_with_ctor_id: unknown variant\")\n             .0\n     }"}, {"sha": "273a61c966c72c08edd4e7842b33bbb81b997002", "filename": "compiler/rustc_middle/src/ty/closure.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -5,6 +5,7 @@ use crate::{mir, ty};\n \n use std::fmt::Write;\n \n+use hir::LangItem;\n use rustc_data_structures::fx::{FxHashMap, FxIndexMap};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -130,11 +131,14 @@ impl<'tcx> ClosureKind {\n     }\n \n     pub fn to_def_id(&self, tcx: TyCtxt<'_>) -> DefId {\n-        match self {\n-            ClosureKind::Fn => tcx.lang_items().fn_once_trait().unwrap(),\n-            ClosureKind::FnMut => tcx.lang_items().fn_mut_trait().unwrap(),\n-            ClosureKind::FnOnce => tcx.lang_items().fn_trait().unwrap(),\n-        }\n+        tcx.require_lang_item(\n+            match self {\n+                ClosureKind::Fn => LangItem::Fn,\n+                ClosureKind::FnMut => LangItem::FnMut,\n+                ClosureKind::FnOnce => LangItem::FnOnce,\n+            },\n+            None,\n+        )\n     }\n }\n "}, {"sha": "b22b3961f34ea9a93aa61a0831e88b1089beabcf", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -298,7 +298,7 @@ impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D> for ty::List<Ty\n }\n \n impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n-    for ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>\n+    for ty::List<ty::PolyExistentialPredicate<'tcx>>\n {\n     fn decode(decoder: &mut D) -> &'tcx Self {\n         let len = decoder.read_usize();\n@@ -346,40 +346,29 @@ impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n }\n \n impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n-    for [ty::abstract_const::Node<'tcx>]\n-{\n-    fn decode(decoder: &mut D) -> &'tcx Self {\n-        decoder.interner().arena.alloc_from_iter(\n-            (0..decoder.read_usize()).map(|_| Decodable::decode(decoder)).collect::<Vec<_>>(),\n-        )\n-    }\n-}\n-\n-impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n-    for [ty::abstract_const::NodeId]\n+    for ty::List<ty::BoundVariableKind>\n {\n     fn decode(decoder: &mut D) -> &'tcx Self {\n-        decoder.interner().arena.alloc_from_iter(\n-            (0..decoder.read_usize()).map(|_| Decodable::decode(decoder)).collect::<Vec<_>>(),\n+        let len = decoder.read_usize();\n+        decoder.interner().mk_bound_variable_kinds(\n+            (0..len).map::<ty::BoundVariableKind, _>(|_| Decodable::decode(decoder)),\n         )\n     }\n }\n \n-impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n-    for ty::List<ty::BoundVariableKind>\n-{\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D> for ty::List<ty::Const<'tcx>> {\n     fn decode(decoder: &mut D) -> &'tcx Self {\n         let len = decoder.read_usize();\n-        decoder.interner().mk_bound_variable_kinds(\n-            (0..len).map::<ty::BoundVariableKind, _>(|_| Decodable::decode(decoder)),\n-        )\n+        decoder\n+            .interner()\n+            .mk_const_list((0..len).map::<ty::Const<'tcx>, _>(|_| Decodable::decode(decoder)))\n     }\n }\n \n impl_decodable_via_ref! {\n     &'tcx ty::TypeckResults<'tcx>,\n     &'tcx ty::List<Ty<'tcx>>,\n-    &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n+    &'tcx ty::List<ty::PolyExistentialPredicate<'tcx>>,\n     &'tcx traits::ImplSource<'tcx, ()>,\n     &'tcx mir::Body<'tcx>,\n     &'tcx mir::UnsafetyCheckResult,"}, {"sha": "9a58a196ed721cd6369794c02849de99a10d13f9", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -1,5 +1,4 @@\n use crate::mir::interpret::LitToConstInput;\n-use crate::mir::ConstantKind;\n use crate::ty::{self, DefIdTree, InternalSubsts, ParamEnv, ParamEnvAnd, Ty, TyCtxt};\n use rustc_data_structures::intern::Interned;\n use rustc_hir as hir;\n@@ -230,20 +229,6 @@ impl<'tcx> Const<'tcx> {\n         }\n     }\n \n-    #[inline]\n-    /// Tries to evaluate the constant if it is `Unevaluated` and creates a ConstValue if the\n-    /// evaluation succeeds. If it doesn't succeed, returns the unevaluated constant.\n-    pub fn eval_for_mir(self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> ConstantKind<'tcx> {\n-        if let Some(val) = self.kind().try_eval_for_mir(tcx, param_env) {\n-            match val {\n-                Ok(const_val) => ConstantKind::from_value(const_val, self.ty()),\n-                Err(guar) => ConstantKind::Ty(tcx.const_error_with_guaranteed(self.ty(), guar)),\n-            }\n-        } else {\n-            ConstantKind::Ty(self)\n-        }\n-    }\n-\n     #[inline]\n     /// Panics if the value cannot be evaluated or doesn't contain a valid integer of the given type.\n     pub fn eval_bits(self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>, ty: Ty<'tcx>) -> u128 {"}, {"sha": "f3186e1c30c3dc4b4229f8501ac5e91d33131edd", "filename": "compiler/rustc_middle/src/ty/consts/int.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -245,6 +245,18 @@ impl ScalarInt {\n         self.to_bits(size)\n     }\n \n+    // Tries to convert the `ScalarInt` to `bool`. Fails if the `size` of the `ScalarInt`\n+    // in not equal to `Size { raw: 1 }` or if the value is not 0 or 1 and returns the `size`\n+    // value of the `ScalarInt` in that case.\n+    #[inline]\n+    pub fn try_to_bool(self) -> Result<bool, Size> {\n+        match self.try_to_u8()? {\n+            0 => Ok(false),\n+            1 => Ok(true),\n+            _ => Err(self.size()),\n+        }\n+    }\n+\n     // Tries to convert the `ScalarInt` to `u8`. Fails if the `size` of the `ScalarInt`\n     // in not equal to `Size { raw: 1 }` and returns the `size` value of the `ScalarInt` in\n     // that case."}, {"sha": "de63dae8a3df6455eb311d18c3eef5b717535591", "filename": "compiler/rustc_middle/src/ty/consts/kind.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -1,10 +1,12 @@\n use std::convert::TryInto;\n \n+use super::Const;\n use crate::mir;\n use crate::mir::interpret::{AllocId, ConstValue, Scalar};\n+use crate::ty::abstract_const::CastKind;\n use crate::ty::subst::{InternalSubsts, SubstsRef};\n use crate::ty::ParamEnv;\n-use crate::ty::{self, TyCtxt, TypeVisitable};\n+use crate::ty::{self, List, Ty, TyCtxt, TypeVisitable};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::DefId;\n@@ -70,8 +72,23 @@ pub enum ConstKind<'tcx> {\n     /// A placeholder for a const which could not be computed; this is\n     /// propagated to avoid useless error messages.\n     Error(ErrorGuaranteed),\n+\n+    /// Expr which contains an expression which has partially evaluated items.\n+    Expr(Expr<'tcx>),\n+}\n+\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash)]\n+#[derive(HashStable, TyEncodable, TyDecodable, TypeVisitable, TypeFoldable)]\n+pub enum Expr<'tcx> {\n+    Binop(mir::BinOp, Const<'tcx>, Const<'tcx>),\n+    UnOp(mir::UnOp, Const<'tcx>),\n+    FunctionCall(Const<'tcx>, &'tcx List<Const<'tcx>>),\n+    Cast(CastKind, Const<'tcx>, Ty<'tcx>),\n }\n \n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+static_assert_size!(Expr<'_>, 24);\n+\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n static_assert_size!(ConstKind<'_>, 32);\n "}, {"sha": "fbbf3f312e791e0e9925b3b4a2354fd0ecb92732", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 83, "deletions": 31, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -17,11 +17,11 @@ use crate::traits;\n use crate::ty::query::{self, TyCtxtAt};\n use crate::ty::{\n     self, AdtDef, AdtDefData, AdtKind, Binder, BindingMode, BoundVar, CanonicalPolyFnSig,\n-    ClosureSizeProfileData, Const, ConstS, ConstVid, DefIdTree, ExistentialPredicate, FloatTy,\n-    FloatVar, FloatVid, GenericParamDefKind, InferConst, InferTy, IntTy, IntVar, IntVid, List,\n-    ParamConst, ParamTy, PolyFnSig, Predicate, PredicateKind, PredicateS, ProjectionTy, Region,\n-    RegionKind, ReprOptions, TraitObjectVisitor, Ty, TyKind, TyS, TyVar, TyVid, TypeAndMut, UintTy,\n-    Visibility,\n+    ClosureSizeProfileData, Const, ConstS, ConstVid, DefIdTree, FloatTy, FloatVar, FloatVid,\n+    GenericParamDefKind, InferConst, InferTy, IntTy, IntVar, IntVid, List, ParamConst, ParamTy,\n+    PolyExistentialPredicate, PolyFnSig, Predicate, PredicateKind, PredicateS, ProjectionTy,\n+    Region, RegionKind, ReprOptions, TraitObjectVisitor, Ty, TyKind, TyS, TyVar, TyVid, TypeAndMut,\n+    UintTy, Visibility,\n };\n use crate::ty::{GenericArg, GenericArgKind, InternalSubsts, SubstsRef, UserSubsts};\n use rustc_ast as ast;\n@@ -109,7 +109,7 @@ impl<'tcx> Interner for TyCtxt<'tcx> {\n     type Mutability = hir::Mutability;\n     type Movability = hir::Movability;\n     type PolyFnSig = PolyFnSig<'tcx>;\n-    type ListBinderExistentialPredicate = &'tcx List<Binder<'tcx, ExistentialPredicate<'tcx>>>;\n+    type ListBinderExistentialPredicate = &'tcx List<PolyExistentialPredicate<'tcx>>;\n     type BinderListTy = Binder<'tcx, &'tcx List<Ty<'tcx>>>;\n     type ListTy = &'tcx List<Ty<'tcx>>;\n     type ProjectionTy = ty::ProjectionTy<'tcx>;\n@@ -137,19 +137,19 @@ pub struct CtxtInterners<'tcx> {\n     // Specifically use a speedy hash algorithm for these hash sets, since\n     // they're accessed quite often.\n     type_: InternedSet<'tcx, WithStableHash<TyS<'tcx>>>,\n+    const_lists: InternedSet<'tcx, List<ty::Const<'tcx>>>,\n     substs: InternedSet<'tcx, InternalSubsts<'tcx>>,\n     canonical_var_infos: InternedSet<'tcx, List<CanonicalVarInfo<'tcx>>>,\n     region: InternedSet<'tcx, RegionKind<'tcx>>,\n-    poly_existential_predicates:\n-        InternedSet<'tcx, List<ty::Binder<'tcx, ExistentialPredicate<'tcx>>>>,\n+    poly_existential_predicates: InternedSet<'tcx, List<PolyExistentialPredicate<'tcx>>>,\n     predicate: InternedSet<'tcx, PredicateS<'tcx>>,\n     predicates: InternedSet<'tcx, List<Predicate<'tcx>>>,\n     projs: InternedSet<'tcx, List<ProjectionKind>>,\n     place_elems: InternedSet<'tcx, List<PlaceElem<'tcx>>>,\n     const_: InternedSet<'tcx, ConstS<'tcx>>,\n     const_allocation: InternedSet<'tcx, Allocation>,\n     bound_variable_kinds: InternedSet<'tcx, List<ty::BoundVariableKind>>,\n-    layout: InternedSet<'tcx, LayoutS<'tcx>>,\n+    layout: InternedSet<'tcx, LayoutS<VariantIdx>>,\n     adt_def: InternedSet<'tcx, AdtDefData>,\n }\n \n@@ -158,6 +158,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n         CtxtInterners {\n             arena,\n             type_: Default::default(),\n+            const_lists: Default::default(),\n             substs: Default::default(),\n             region: Default::default(),\n             poly_existential_predicates: Default::default(),\n@@ -1234,7 +1235,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             global_ctxt: untracked_resolutions,\n             ast_lowering: untracked_resolver_for_lowering,\n         } = resolver_outputs;\n-        let data_layout = TargetDataLayout::parse(&s.target).unwrap_or_else(|err| {\n+        let data_layout = s.target.parse_data_layout().unwrap_or_else(|err| {\n             s.emit_fatal(err);\n         });\n         let interners = CtxtInterners::new(arena);\n@@ -1810,7 +1811,7 @@ nop_lift! {const_; Const<'a> => Const<'tcx>}\n nop_lift! {const_allocation; ConstAllocation<'a> => ConstAllocation<'tcx>}\n nop_lift! {predicate; Predicate<'a> => Predicate<'tcx>}\n \n-nop_list_lift! {poly_existential_predicates; ty::Binder<'a, ExistentialPredicate<'a>> => ty::Binder<'tcx, ExistentialPredicate<'tcx>>}\n+nop_list_lift! {poly_existential_predicates; PolyExistentialPredicate<'a> => PolyExistentialPredicate<'tcx>}\n nop_list_lift! {predicates; Predicate<'a> => Predicate<'tcx>}\n nop_list_lift! {canonical_var_infos; CanonicalVarInfo<'a> => CanonicalVarInfo<'tcx>}\n nop_list_lift! {projs; ProjectionKind => ProjectionKind}\n@@ -2245,7 +2246,7 @@ direct_interners! {\n     region: mk_region(RegionKind<'tcx>): Region -> Region<'tcx>,\n     const_: mk_const_internal(ConstS<'tcx>): Const -> Const<'tcx>,\n     const_allocation: intern_const_alloc(Allocation): ConstAllocation -> ConstAllocation<'tcx>,\n-    layout: intern_layout(LayoutS<'tcx>): Layout -> Layout<'tcx>,\n+    layout: intern_layout(LayoutS<VariantIdx>): Layout -> Layout<'tcx>,\n     adt_def: intern_adt_def(AdtDefData): AdtDef -> AdtDef<'tcx>,\n }\n \n@@ -2262,10 +2263,11 @@ macro_rules! slice_interners {\n }\n \n slice_interners!(\n+    const_lists: _intern_const_list(Const<'tcx>),\n     substs: _intern_substs(GenericArg<'tcx>),\n     canonical_var_infos: _intern_canonical_var_infos(CanonicalVarInfo<'tcx>),\n     poly_existential_predicates:\n-        _intern_poly_existential_predicates(ty::Binder<'tcx, ExistentialPredicate<'tcx>>),\n+        _intern_poly_existential_predicates(PolyExistentialPredicate<'tcx>),\n     predicates: _intern_predicates(Predicate<'tcx>),\n     projs: _intern_projs(ProjectionKind),\n     place_elems: _intern_place_elems(PlaceElem<'tcx>),\n@@ -2294,10 +2296,10 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Given a `ty`, return whether it's an `impl Future<...>`.\n     pub fn ty_is_opaque_future(self, ty: Ty<'_>) -> bool {\n         let ty::Opaque(def_id, _) = ty.kind() else { return false };\n-        let future_trait = self.lang_items().future_trait().unwrap();\n+        let future_trait = self.require_lang_item(LangItem::Future, None);\n \n         self.explicit_item_bounds(def_id).iter().any(|(predicate, _)| {\n-            let ty::PredicateKind::Trait(trait_predicate) = predicate.kind().skip_binder() else {\n+            let ty::PredicateKind::Clause(ty::Clause::Trait(trait_predicate)) = predicate.kind().skip_binder() else {\n                 return false;\n             };\n             trait_predicate.trait_ref.def_id == future_trait\n@@ -2320,7 +2322,9 @@ impl<'tcx> TyCtxt<'tcx> {\n             let generic_predicates = self.super_predicates_of(trait_did);\n \n             for (predicate, _) in generic_predicates.predicates {\n-                if let ty::PredicateKind::Trait(data) = predicate.kind().skip_binder() {\n+                if let ty::PredicateKind::Clause(ty::Clause::Trait(data)) =\n+                    predicate.kind().skip_binder()\n+                {\n                     if set.insert(data.def_id()) {\n                         stack.push(data.def_id());\n                     }\n@@ -2517,7 +2521,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_ty(Tuple(self.intern_type_list(&ts)))\n     }\n \n-    pub fn mk_tup<I: InternAs<[Ty<'tcx>], Ty<'tcx>>>(self, iter: I) -> I::Output {\n+    pub fn mk_tup<I: InternAs<Ty<'tcx>, Ty<'tcx>>>(self, iter: I) -> I::Output {\n         iter.intern_with(|ts| self.mk_ty(Tuple(self.intern_type_list(&ts))))\n     }\n \n@@ -2533,6 +2537,11 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_fn_def(self, def_id: DefId, substs: SubstsRef<'tcx>) -> Ty<'tcx> {\n+        debug_assert_eq!(\n+            self.generics_of(def_id).count(),\n+            substs.len(),\n+            \"wrong number of generic parameters for {def_id:?}: {substs:?}\",\n+        );\n         self.mk_ty(FnDef(def_id, substs))\n     }\n \n@@ -2544,7 +2553,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     #[inline]\n     pub fn mk_dynamic(\n         self,\n-        obj: &'tcx List<ty::Binder<'tcx, ExistentialPredicate<'tcx>>>,\n+        obj: &'tcx List<PolyExistentialPredicate<'tcx>>,\n         reg: ty::Region<'tcx>,\n         repr: DynKind,\n     ) -> Ty<'tcx> {\n@@ -2553,6 +2562,11 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_projection(self, item_def_id: DefId, substs: SubstsRef<'tcx>) -> Ty<'tcx> {\n+        debug_assert_eq!(\n+            self.generics_of(item_def_id).count(),\n+            substs.len(),\n+            \"wrong number of generic parameters for {item_def_id:?}: {substs:?}\",\n+        );\n         self.mk_ty(Projection(ProjectionTy { item_def_id, substs }))\n     }\n \n@@ -2682,8 +2696,8 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     pub fn intern_poly_existential_predicates(\n         self,\n-        eps: &[ty::Binder<'tcx, ExistentialPredicate<'tcx>>],\n-    ) -> &'tcx List<ty::Binder<'tcx, ExistentialPredicate<'tcx>>> {\n+        eps: &[PolyExistentialPredicate<'tcx>],\n+    ) -> &'tcx List<PolyExistentialPredicate<'tcx>> {\n         assert!(!eps.is_empty());\n         assert!(\n             eps.array_windows()\n@@ -2705,6 +2719,17 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n+    pub fn mk_const_list<I: InternAs<ty::Const<'tcx>, &'tcx List<ty::Const<'tcx>>>>(\n+        self,\n+        iter: I,\n+    ) -> I::Output {\n+        iter.intern_with(|xs| self.intern_const_list(xs))\n+    }\n+\n+    pub fn intern_const_list(self, cs: &[ty::Const<'tcx>]) -> &'tcx List<ty::Const<'tcx>> {\n+        if cs.is_empty() { List::empty() } else { self._intern_const_list(cs) }\n+    }\n+\n     pub fn intern_type_list(self, ts: &[Ty<'tcx>]) -> &'tcx List<Ty<'tcx>> {\n         if ts.is_empty() {\n             List::empty()\n@@ -2767,48 +2792,66 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn mk_poly_existential_predicates<\n-        I: InternAs<\n-            [ty::Binder<'tcx, ExistentialPredicate<'tcx>>],\n-            &'tcx List<ty::Binder<'tcx, ExistentialPredicate<'tcx>>>,\n-        >,\n+        I: InternAs<PolyExistentialPredicate<'tcx>, &'tcx List<PolyExistentialPredicate<'tcx>>>,\n     >(\n         self,\n         iter: I,\n     ) -> I::Output {\n         iter.intern_with(|xs| self.intern_poly_existential_predicates(xs))\n     }\n \n-    pub fn mk_predicates<I: InternAs<[Predicate<'tcx>], &'tcx List<Predicate<'tcx>>>>(\n+    pub fn mk_predicates<I: InternAs<Predicate<'tcx>, &'tcx List<Predicate<'tcx>>>>(\n         self,\n         iter: I,\n     ) -> I::Output {\n         iter.intern_with(|xs| self.intern_predicates(xs))\n     }\n \n-    pub fn mk_type_list<I: InternAs<[Ty<'tcx>], &'tcx List<Ty<'tcx>>>>(self, iter: I) -> I::Output {\n+    pub fn mk_type_list<I: InternAs<Ty<'tcx>, &'tcx List<Ty<'tcx>>>>(self, iter: I) -> I::Output {\n         iter.intern_with(|xs| self.intern_type_list(xs))\n     }\n \n-    pub fn mk_substs<I: InternAs<[GenericArg<'tcx>], &'tcx List<GenericArg<'tcx>>>>(\n+    pub fn mk_substs<I: InternAs<GenericArg<'tcx>, &'tcx List<GenericArg<'tcx>>>>(\n         self,\n         iter: I,\n     ) -> I::Output {\n         iter.intern_with(|xs| self.intern_substs(xs))\n     }\n \n-    pub fn mk_place_elems<I: InternAs<[PlaceElem<'tcx>], &'tcx List<PlaceElem<'tcx>>>>(\n+    pub fn mk_place_elems<I: InternAs<PlaceElem<'tcx>, &'tcx List<PlaceElem<'tcx>>>>(\n         self,\n         iter: I,\n     ) -> I::Output {\n         iter.intern_with(|xs| self.intern_place_elems(xs))\n     }\n \n-    pub fn mk_substs_trait(self, self_ty: Ty<'tcx>, rest: &[GenericArg<'tcx>]) -> SubstsRef<'tcx> {\n-        self.mk_substs(iter::once(self_ty.into()).chain(rest.iter().cloned()))\n+    pub fn mk_substs_trait(\n+        self,\n+        self_ty: Ty<'tcx>,\n+        rest: impl IntoIterator<Item = GenericArg<'tcx>>,\n+    ) -> SubstsRef<'tcx> {\n+        self.mk_substs(iter::once(self_ty.into()).chain(rest))\n+    }\n+\n+    pub fn mk_trait_ref(\n+        self,\n+        trait_def_id: DefId,\n+        substs: impl IntoIterator<Item = impl Into<GenericArg<'tcx>>>,\n+    ) -> ty::TraitRef<'tcx> {\n+        let substs = substs.into_iter().map(Into::into);\n+        let n = self.generics_of(trait_def_id).count();\n+        debug_assert_eq!(\n+            (n, Some(n)),\n+            substs.size_hint(),\n+            \"wrong number of generic parameters for {trait_def_id:?}: {:?} \\nDid you accidentally include the self-type in the params list?\",\n+            substs.collect::<Vec<_>>(),\n+        );\n+        let substs = self.mk_substs(substs);\n+        ty::TraitRef::new(trait_def_id, substs)\n     }\n \n     pub fn mk_bound_variable_kinds<\n-        I: InternAs<[ty::BoundVariableKind], &'tcx List<ty::BoundVariableKind>>,\n+        I: InternAs<ty::BoundVariableKind, &'tcx List<ty::BoundVariableKind>>,\n     >(\n         self,\n         iter: I,\n@@ -2963,6 +3006,15 @@ impl<'tcx> TyCtxtAt<'tcx> {\n     pub fn ty_error_with_message(self, msg: &str) -> Ty<'tcx> {\n         self.tcx.ty_error_with_message(self.span, msg)\n     }\n+\n+    pub fn mk_trait_ref(\n+        self,\n+        trait_lang_item: LangItem,\n+        substs: impl IntoIterator<Item = impl Into<ty::GenericArg<'tcx>>>,\n+    ) -> ty::TraitRef<'tcx> {\n+        let trait_def_id = self.require_lang_item(trait_lang_item, Some(self.span));\n+        self.tcx.mk_trait_ref(trait_def_id, substs)\n+    }\n }\n \n /// Parameter attributes that can only be determined by examining the body of a function instead"}, {"sha": "b087ff4bf53c4d23aaa5b11d76980bd9ebdd368f", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -397,7 +397,7 @@ impl<'v> hir::intravisit::Visitor<'v> for TraitObjectVisitor<'v> {\n             hir::TyKind::TraitObject(\n                 _,\n                 hir::Lifetime {\n-                    name:\n+                    res:\n                         hir::LifetimeName::ImplicitObjectLifetimeDefault | hir::LifetimeName::Static,\n                     ..\n                 },\n@@ -421,10 +421,9 @@ pub struct StaticLifetimeVisitor<'tcx>(pub Vec<Span>, pub crate::hir::map::Map<'\n \n impl<'v> hir::intravisit::Visitor<'v> for StaticLifetimeVisitor<'v> {\n     fn visit_lifetime(&mut self, lt: &'v hir::Lifetime) {\n-        if let hir::LifetimeName::ImplicitObjectLifetimeDefault | hir::LifetimeName::Static =\n-            lt.name\n+        if let hir::LifetimeName::ImplicitObjectLifetimeDefault | hir::LifetimeName::Static = lt.res\n         {\n-            self.0.push(lt.span);\n+            self.0.push(lt.ident.span);\n         }\n     }\n }\n@@ -508,11 +507,3 @@ impl<'tcx> TypeVisitor<'tcx> for IsSuggestableVisitor<'tcx> {\n         c.super_visit_with(self)\n     }\n }\n-\n-#[derive(Diagnostic)]\n-#[diag(borrowck_const_not_used_in_type_alias)]\n-pub(super) struct ConstNotUsedTraitAlias {\n-    pub ct: String,\n-    #[primary_span]\n-    pub span: Span,\n-}"}, {"sha": "a61f41b9c580f02086e36a283f1e9eabada4eac4", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -69,9 +69,7 @@ pub enum TypeError<'tcx> {\n     CyclicTy(Ty<'tcx>),\n     CyclicConst(ty::Const<'tcx>),\n     ProjectionMismatched(ExpectedFound<DefId>),\n-    ExistentialMismatch(\n-        ExpectedFound<&'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>>,\n-    ),\n+    ExistentialMismatch(ExpectedFound<&'tcx ty::List<ty::PolyExistentialPredicate<'tcx>>>),\n     ObjectUnsafeCoercion(DefId),\n     ConstMismatch(ExpectedFound<ty::Const<'tcx>>),\n "}, {"sha": "c9c09c93a3e1c470a9e94b68d6e8d2c7086f575c", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -42,7 +42,6 @@ where\n     ClosureSimplifiedType(D),\n     GeneratorSimplifiedType(D),\n     GeneratorWitnessSimplifiedType(usize),\n-    OpaqueSimplifiedType(D),\n     FunctionSimplifiedType(usize),\n     PlaceholderSimplifiedType,\n }\n@@ -127,7 +126,7 @@ pub fn simplify_type<'tcx>(\n             TreatParams::AsPlaceholder => Some(PlaceholderSimplifiedType),\n             TreatParams::AsInfer => None,\n         },\n-        ty::Projection(_) => match treat_params {\n+        ty::Opaque(..) | ty::Projection(_) => match treat_params {\n             // When treating `ty::Param` as a placeholder, projections also\n             // don't unify with anything else as long as they are fully normalized.\n             //\n@@ -138,7 +137,6 @@ pub fn simplify_type<'tcx>(\n             }\n             TreatParams::AsPlaceholder | TreatParams::AsInfer => None,\n         },\n-        ty::Opaque(def_id, _) => Some(OpaqueSimplifiedType(def_id)),\n         ty::Foreign(def_id) => Some(ForeignSimplifiedType(def_id)),\n         ty::Bound(..) | ty::Infer(_) | ty::Error(_) => None,\n     }\n@@ -151,8 +149,7 @@ impl<D: Copy + Debug + Eq> SimplifiedTypeGen<D> {\n             | ForeignSimplifiedType(d)\n             | TraitSimplifiedType(d)\n             | ClosureSimplifiedType(d)\n-            | GeneratorSimplifiedType(d)\n-            | OpaqueSimplifiedType(d) => Some(d),\n+            | GeneratorSimplifiedType(d) => Some(d),\n             _ => None,\n         }\n     }\n@@ -182,7 +179,6 @@ impl<D: Copy + Debug + Eq> SimplifiedTypeGen<D> {\n             ClosureSimplifiedType(d) => ClosureSimplifiedType(map(d)),\n             GeneratorSimplifiedType(d) => GeneratorSimplifiedType(map(d)),\n             GeneratorWitnessSimplifiedType(n) => GeneratorWitnessSimplifiedType(n),\n-            OpaqueSimplifiedType(d) => OpaqueSimplifiedType(map(d)),\n             FunctionSimplifiedType(n) => FunctionSimplifiedType(n),\n             PlaceholderSimplifiedType => PlaceholderSimplifiedType,\n         }\n@@ -229,7 +225,7 @@ impl DeepRejectCtxt {\n         match impl_ty.kind() {\n             // Start by checking whether the type in the impl may unify with\n             // pretty much everything. Just return `true` in that case.\n-            ty::Param(_) | ty::Projection(_) | ty::Error(_) => return true,\n+            ty::Param(_) | ty::Projection(_) | ty::Error(_) | ty::Opaque(..) => return true,\n             // These types only unify with inference variables or their own\n             // variant.\n             ty::Bool\n@@ -247,8 +243,7 @@ impl DeepRejectCtxt {\n             | ty::Never\n             | ty::Tuple(..)\n             | ty::FnPtr(..)\n-            | ty::Foreign(..)\n-            | ty::Opaque(..) => {}\n+            | ty::Foreign(..) => {}\n             ty::FnDef(..)\n             | ty::Closure(..)\n             | ty::Generator(..)\n@@ -328,10 +323,7 @@ impl DeepRejectCtxt {\n                 _ => false,\n             },\n \n-            // Opaque types in impls should be forbidden, but that doesn't\n-            // stop compilation. So this match arm should never return true\n-            // if compilation succeeds.\n-            ty::Opaque(..) => matches!(k, ty::Opaque(..)),\n+            ty::Opaque(..) => true,\n \n             // Impls cannot contain these types as these cannot be named directly.\n             ty::FnDef(..) | ty::Closure(..) | ty::Generator(..) => false,\n@@ -364,7 +356,10 @@ impl DeepRejectCtxt {\n \n     pub fn consts_may_unify(self, obligation_ct: ty::Const<'_>, impl_ct: ty::Const<'_>) -> bool {\n         match impl_ct.kind() {\n-            ty::ConstKind::Param(_) | ty::ConstKind::Unevaluated(_) | ty::ConstKind::Error(_) => {\n+            ty::ConstKind::Expr(_)\n+            | ty::ConstKind::Param(_)\n+            | ty::ConstKind::Unevaluated(_)\n+            | ty::ConstKind::Error(_) => {\n                 return true;\n             }\n             ty::ConstKind::Value(_) => {}\n@@ -382,7 +377,9 @@ impl DeepRejectCtxt {\n \n             // As we don't necessarily eagerly evaluate constants,\n             // they might unify with any value.\n-            ty::ConstKind::Unevaluated(_) | ty::ConstKind::Error(_) => true,\n+            ty::ConstKind::Expr(_) | ty::ConstKind::Unevaluated(_) | ty::ConstKind::Error(_) => {\n+                true\n+            }\n             ty::ConstKind::Value(obl) => match k {\n                 ty::ConstKind::Value(imp) => obl == imp,\n                 _ => true,"}, {"sha": "1e9fe779b76464c4afcf00ae19b71aad1cc0ec6a", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -216,14 +216,17 @@ impl FlagComputation {\n \n     fn add_predicate_atom(&mut self, atom: ty::PredicateKind<'_>) {\n         match atom {\n-            ty::PredicateKind::Trait(trait_pred) => {\n+            ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) => {\n                 self.add_substs(trait_pred.trait_ref.substs);\n             }\n-            ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(a, b)) => {\n+            ty::PredicateKind::Clause(ty::Clause::RegionOutlives(ty::OutlivesPredicate(a, b))) => {\n                 self.add_region(a);\n                 self.add_region(b);\n             }\n-            ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty, region)) => {\n+            ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n+                ty,\n+                region,\n+            ))) => {\n                 self.add_ty(ty);\n                 self.add_region(region);\n             }\n@@ -235,7 +238,10 @@ impl FlagComputation {\n                 self.add_ty(a);\n                 self.add_ty(b);\n             }\n-            ty::PredicateKind::Projection(ty::ProjectionPredicate { projection_ty, term }) => {\n+            ty::PredicateKind::Clause(ty::Clause::Projection(ty::ProjectionPredicate {\n+                projection_ty,\n+                term,\n+            })) => {\n                 self.add_projection_ty(projection_ty);\n                 match term.unpack() {\n                     ty::TermKind::Ty(ty) => self.add_ty(ty),\n@@ -259,6 +265,7 @@ impl FlagComputation {\n             ty::PredicateKind::TypeWellFormedFromEnv(ty) => {\n                 self.add_ty(ty);\n             }\n+            ty::PredicateKind::Ambiguous => {}\n         }\n     }\n \n@@ -306,6 +313,26 @@ impl FlagComputation {\n                 self.add_flags(TypeFlags::STILL_FURTHER_SPECIALIZABLE);\n             }\n             ty::ConstKind::Value(_) => {}\n+            ty::ConstKind::Expr(e) => {\n+                use ty::Expr;\n+                match e {\n+                    Expr::Binop(_, l, r) => {\n+                        self.add_const(l);\n+                        self.add_const(r);\n+                    }\n+                    Expr::UnOp(_, v) => self.add_const(v),\n+                    Expr::FunctionCall(f, args) => {\n+                        self.add_const(f);\n+                        for arg in args {\n+                            self.add_const(arg);\n+                        }\n+                    }\n+                    Expr::Cast(_, c, t) => {\n+                        self.add_ty(t);\n+                        self.add_const(c);\n+                    }\n+                }\n+            }\n             ty::ConstKind::Error(_) => self.add_flags(TypeFlags::HAS_ERROR),\n         }\n     }"}, {"sha": "a8da93e4c69b0d54303c31917dd4a22a02082021", "filename": "compiler/rustc_middle/src/ty/generics.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -3,7 +3,7 @@ use crate::ty::{EarlyBinder, SubstsRef};\n use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::DefId;\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{kw, Symbol};\n use rustc_span::Span;\n \n use super::{EarlyBoundRegion, InstantiatedPredicates, ParamConst, ParamTy, Predicate, TyCtxt};\n@@ -78,6 +78,15 @@ impl GenericParamDef {\n         }\n     }\n \n+    pub fn is_anonymous_lifetime(&self) -> bool {\n+        match self.kind {\n+            GenericParamDefKind::Lifetime => {\n+                self.name == kw::UnderscoreLifetime || self.name == kw::Empty\n+            }\n+            _ => false,\n+        }\n+    }\n+\n     pub fn default_value<'tcx>(\n         &self,\n         tcx: TyCtxt<'tcx>,"}, {"sha": "33f72729798dca93e38753e6332892c5cf835cf9", "filename": "compiler/rustc_middle/src/ty/inhabitedness/inhabited_predicate.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Finhabited_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Finhabited_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Finhabited_predicate.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -41,6 +41,13 @@ impl<'tcx> InhabitedPredicate<'tcx> {\n         self.apply_inner(tcx, param_env, &|_| Err(())).ok()\n     }\n \n+    /// Same as `apply`, but `NotInModule(_)` predicates yield `false`. That is,\n+    /// privately uninhabited types are considered always uninhabited.\n+    pub fn apply_ignore_module(self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> bool {\n+        let Ok(result) = self.apply_inner::<!>(tcx, param_env, &|_| Ok(true));\n+        result\n+    }\n+\n     fn apply_inner<E>(\n         self,\n         tcx: TyCtxt<'tcx>,"}, {"sha": "ace81bc4f8352e155330d5178968f369eed30054", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 62, "deletions": 54, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -5,7 +5,7 @@\n //!\n //! # Example\n //! ```rust\n-//! enum Void {}\n+//! #![feature(never_type)]\n //! mod a {\n //!     pub mod b {\n //!         pub struct SecretlyUninhabited {\n@@ -15,6 +15,7 @@\n //! }\n //!\n //! mod c {\n+//!     enum Void {}\n //!     pub struct AlsoSecretlyUninhabited {\n //!         _priv: Void,\n //!     }\n@@ -28,14 +29,14 @@\n //! }\n //! ```\n //! In this code, the type `Foo` will only be visibly uninhabited inside the\n-//! modules `b`, `c` and `d`. Calling `uninhabited_predicate` on `Foo` will\n+//! modules `b`, `c` and `d`. Calling `inhabited_predicate` on `Foo` will\n //! return `NotInModule(b) AND NotInModule(c)`.\n //!\n //! We need this information for pattern-matching on `Foo` or types that contain\n //! `Foo`.\n //!\n //! # Example\n-//! ```rust\n+//! ```ignore(illustrative)\n //! let foo_result: Result<T, Foo> = ... ;\n //! let Ok(t) = foo_result;\n //! ```\n@@ -56,57 +57,6 @@ pub(crate) fn provide(providers: &mut ty::query::Providers) {\n         ty::query::Providers { inhabited_predicate_adt, inhabited_predicate_type, ..*providers };\n }\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    /// Checks whether a type is visibly uninhabited from a particular module.\n-    ///\n-    /// # Example\n-    /// ```\n-    /// #![feature(never_type)]\n-    /// # fn main() {}\n-    /// enum Void {}\n-    /// mod a {\n-    ///     pub mod b {\n-    ///         pub struct SecretlyUninhabited {\n-    ///             _priv: !,\n-    ///         }\n-    ///     }\n-    /// }\n-    ///\n-    /// mod c {\n-    ///     use super::Void;\n-    ///     pub struct AlsoSecretlyUninhabited {\n-    ///         _priv: Void,\n-    ///     }\n-    ///     mod d {\n-    ///     }\n-    /// }\n-    ///\n-    /// struct Foo {\n-    ///     x: a::b::SecretlyUninhabited,\n-    ///     y: c::AlsoSecretlyUninhabited,\n-    /// }\n-    /// ```\n-    /// In this code, the type `Foo` will only be visibly uninhabited inside the\n-    /// modules b, c and d. This effects pattern-matching on `Foo` or types that\n-    /// contain `Foo`.\n-    ///\n-    /// # Example\n-    /// ```ignore (illustrative)\n-    /// let foo_result: Result<T, Foo> = ... ;\n-    /// let Ok(t) = foo_result;\n-    /// ```\n-    /// This code should only compile in modules where the uninhabitedness of Foo is\n-    /// visible.\n-    pub fn is_ty_uninhabited_from(\n-        self,\n-        module: DefId,\n-        ty: Ty<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> bool {\n-        !ty.inhabited_predicate(self).apply(self, param_env, module)\n-    }\n-}\n-\n /// Returns an `InhabitedPredicate` that is generic over type parameters and\n /// requires calling [`InhabitedPredicate::subst`]\n fn inhabited_predicate_adt(tcx: TyCtxt<'_>, def_id: DefId) -> InhabitedPredicate<'_> {\n@@ -170,6 +120,64 @@ impl<'tcx> Ty<'tcx> {\n             _ => InhabitedPredicate::True,\n         }\n     }\n+\n+    /// Checks whether a type is visibly uninhabited from a particular module.\n+    ///\n+    /// # Example\n+    /// ```\n+    /// #![feature(never_type)]\n+    /// # fn main() {}\n+    /// enum Void {}\n+    /// mod a {\n+    ///     pub mod b {\n+    ///         pub struct SecretlyUninhabited {\n+    ///             _priv: !,\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// mod c {\n+    ///     use super::Void;\n+    ///     pub struct AlsoSecretlyUninhabited {\n+    ///         _priv: Void,\n+    ///     }\n+    ///     mod d {\n+    ///     }\n+    /// }\n+    ///\n+    /// struct Foo {\n+    ///     x: a::b::SecretlyUninhabited,\n+    ///     y: c::AlsoSecretlyUninhabited,\n+    /// }\n+    /// ```\n+    /// In this code, the type `Foo` will only be visibly uninhabited inside the\n+    /// modules b, c and d. This effects pattern-matching on `Foo` or types that\n+    /// contain `Foo`.\n+    ///\n+    /// # Example\n+    /// ```ignore (illustrative)\n+    /// let foo_result: Result<T, Foo> = ... ;\n+    /// let Ok(t) = foo_result;\n+    /// ```\n+    /// This code should only compile in modules where the uninhabitedness of Foo is\n+    /// visible.\n+    pub fn is_inhabited_from(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        module: DefId,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> bool {\n+        self.inhabited_predicate(tcx).apply(tcx, param_env, module)\n+    }\n+\n+    /// Returns true if the type is uninhabited without regard to visibility\n+    pub fn is_privately_uninhabited(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> bool {\n+        !self.inhabited_predicate(tcx).apply_ignore_module(tcx, param_env)\n+    }\n }\n \n /// N.B. this query should only be called through `Ty::inhabited_predicate`"}, {"sha": "586460986dd73cbad18633ee4f318a8be72e3c57", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -551,7 +551,7 @@ impl<'tcx> Instance<'tcx> {\n         let sig =\n             tcx.try_normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), sig).ok()?;\n         assert_eq!(sig.inputs().len(), 1);\n-        let substs = tcx.mk_substs_trait(self_ty, &[sig.inputs()[0].into()]);\n+        let substs = tcx.mk_substs_trait(self_ty, [sig.inputs()[0].into()]);\n \n         debug!(?self_ty, ?sig);\n         Some(Instance { def, substs })"}, {"sha": "488fd567846a3a850f973c7a7f3328ae21f28694", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447", "patch": "@@ -1,8 +1,6 @@\n use crate::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use crate::ty::normalize_erasing_regions::NormalizationError;\n use crate::ty::{self, ReprOptions, Ty, TyCtxt, TypeVisitable};\n-use rustc_ast as ast;\n-use rustc_attr as attr;\n use rustc_errors::{DiagnosticBuilder, Handler, IntoDiagnostic};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -20,7 +18,6 @@ use std::ops::Bound;\n \n pub trait IntegerExt {\n     fn to_ty<'tcx>(&self, tcx: TyCtxt<'tcx>, signed: bool) -> Ty<'tcx>;\n-    fn from_attr<C: HasDataLayout>(cx: &C, ity: attr::IntType) -> Integer;\n     fn from_int_ty<C: HasDataLayout>(cx: &C, ity: ty::IntTy) -> Integer;\n     fn from_uint_ty<C: HasDataLayout>(cx: &C, uty: ty::UintTy) -> Integer;\n     fn repr_discr<'tcx>(\n@@ -49,22 +46,6 @@ impl IntegerExt for Integer {\n         }\n     }\n \n-    /// Gets the Integer type from an attr::IntType.\n-    fn from_attr<C: HasDataLayout>(cx: &C, ity: attr::IntType) -> Integer {\n-        let dl = cx.data_layout();\n-\n-        match ity {\n-            attr::SignedInt(ast::IntTy::I8) | attr::UnsignedInt(ast::UintTy::U8) => I8,\n-            attr::SignedInt(ast::IntTy::I16) | attr::UnsignedInt(ast::UintTy::U16) => I16,\n-            attr::SignedInt(ast::IntTy::I32) | attr::UnsignedInt(ast::UintTy::U32) => I32,\n-            attr::SignedInt(ast::IntTy::I64) | attr::UnsignedInt(ast::UintTy::U64) => I64,\n-            attr::SignedInt(ast::IntTy::I128) | attr::UnsignedInt(ast::UintTy::U128) => I128,\n-            attr::SignedInt(ast::IntTy::Isize) | attr::UnsignedInt(ast::UintTy::Usize) => {\n-                dl.ptr_sized_integer()\n-            }\n-        }\n-    }\n-\n     fn from_int_ty<C: HasDataLayout>(cx: &C, ity: ty::IntTy) -> Integer {\n         match ity {\n             ty::IntTy::I8 => I8,\n@@ -237,6 +218,18 @@ pub struct LayoutCx<'tcx, C> {\n     pub param_env: ty::ParamEnv<'tcx>,\n }\n \n+impl<'tcx> LayoutCalculator for LayoutCx<'tcx, TyCtxt<'tcx>> {\n+    type TargetDataLayoutRef = &'tcx TargetDataLayout;\n+\n+    fn delay_bug(&self, txt: &str) {\n+        self.tcx.sess.delay_span_bug(DUMMY_SP, txt);\n+    }\n+\n+    fn current_data_layout(&self) -> Self::TargetDataLayoutRef {\n+        &self.tcx.data_layout\n+    }\n+}\n+\n /// Type size \"skeleton\", i.e., the only information determining a type's size.\n /// While this is conservative, (aside from constant sizes, only pointers,\n /// newtypes thereof and null pointer optimized enums are allowed), it is\n@@ -610,7 +603,7 @@ where\n                 })\n             }\n \n-            Variants::Multiple { ref variants, .. } => variants[variant_index],\n+            Variants::Multiple { ref variants, .. } => cx.tcx().intern_layout(variants[variant_index].clone()),\n         };\n \n         assert_eq!(*layout.variants(), Variants::Single { index: variant_index });"}, {"sha": "d49f45744aee3aa3610f1b5a337ce120e270c670", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "98cd92007c2b22ace29115b466ce3f7fe0a75933", "filename": "compiler/rustc_middle/src/ty/opaque_types.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fopaque_types.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "b2bcf0e29cd9d7578219c412eb249e2f9359e3bc", "filename": "compiler/rustc_middle/src/ty/parameterized.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "667298b9b5b1316ff2738e5c08b1ceab2502be75", "filename": "compiler/rustc_middle/src/ty/print/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "f93dc15068ef2a3a3aefbb2538ae571f33256519", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 39, "deletions": 29, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "afbc9eb0512beb11b387d53908ad0076bb54c49b", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "e6340040e9c196f024131024d3b257c1ca290e85", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 82, "deletions": 14, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "9f70b4f1ffd25291592894531cab301143c473bb", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "ac648152a4217d5cdc892f06e236be795f93c16b", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 18, "deletions": 26, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "141c8354c183d65ace6d553f10172f6ccbf2982b", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "717e5136e96d95625eb50aead137d3f2559d0f1f", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "b04afe549ac551d4bc1e516dcc40cb39e378d38f", "filename": "compiler/rustc_middle/src/ty/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "4fab5abe909d40c39042aee829a86bff88e51f7b", "filename": "compiler/rustc_middle/src/ty/walk.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "2baa3bfcb6401f3570ee79012cab627d0a6b11f9", "filename": "compiler/rustc_mir_build/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2FCargo.toml?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "49d7136a2f1ffd26faff815c99bfbf1467149acd", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "edd527286264a135e019394fc9019646d32f3e88", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 85, "deletions": 83, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "0814793f27790159dd3aa6400fe3a6e28b6b3b4f", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "218a26e62797dc97b0fe5f559ead5374613506de", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "691cbee2c731911acf2997bea4754b5d54c9ee16", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 32, "deletions": 42, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "f6b1955fdec4d89814844bbedf3845de14616f83", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "58513bde2aa2a09fdcff2d16b02ec26bd2af02e4", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 42, "deletions": 10, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "bd435f9ab0095a4b86e10703a3127c31bbd068b5", "filename": "compiler/rustc_mir_build/src/build/matches/util.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "0b76122913ebe35899cc52004e3afa55193e60b9", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "8797529459534610bc479c57a9f8dc75cb023059", "filename": "compiler/rustc_mir_build/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "5fa41ebeb6e5966f9acf748e5ea7aa3ef1588251", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "e369dba55242c8f1703b38120a99489ca2c80e0f", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "a21f6cd39f01442aa6b45b1d86c528571dd1d113", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "d60e8722cb61d5c443e20ef22d8c061d100781e0", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "4c2a80e523f3537593bec024938dc2d35b246f15", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "3e370a053766574d110cefebb855cfed25ff81fc", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "ce87a1916b4658034ba7941ab6149b7713375ad0", "filename": "compiler/rustc_mir_dataflow/src/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "83ce4c44b7144e5cfa97c5d5c67feb5f55364396", "filename": "compiler/rustc_mir_dataflow/src/impls/init_locals.rs", "status": "removed", "additions": 0, "deletions": 122, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/66354f00430eebb88d33de02326d7ca9196bd61a/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Finit_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66354f00430eebb88d33de02326d7ca9196bd61a/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Finit_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Finit_locals.rs?ref=66354f00430eebb88d33de02326d7ca9196bd61a"}, {"sha": "bc31ec42b8b6e3af8e6b3dc4f2c13e9b646a8d37", "filename": "compiler/rustc_mir_dataflow/src/impls/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "962536669e0db41301c4eb337f91d1896204c65a", "filename": "compiler/rustc_mir_transform/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_transform%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_transform%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2FCargo.toml?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "b0514e033566c9a65ebe8f5484a41d74ddb39898", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "0ab67228f3f400fae076b6a06e5898320b7f1856", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "42c580c63f06046e56d9b81290c7bf8fb0ee4c75", "filename": "compiler/rustc_mir_transform/src/dead_store_elimination.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_transform%2Fsrc%2Fdead_store_elimination.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_transform%2Fsrc%2Fdead_store_elimination.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdead_store_elimination.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "92f1fff6beb950f7d1b72bef8d8ce775bc4fcf55", "filename": "compiler/rustc_mir_transform/src/deduce_param_attrs.rs", "status": "modified", "additions": 10, "deletions": 38, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "8cd44ab82ccc4cb35d392840d90ee7b8a24cf2d6", "filename": "compiler/rustc_mir_transform/src/dest_prop.rs", "status": "modified", "additions": 602, "deletions": 697, "changes": 1299, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "b708d780b70050d648557d04f34bf82a1338d60b", "filename": "compiler/rustc_mir_transform/src/function_item_references.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_transform%2Fsrc%2Ffunction_item_references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_transform%2Fsrc%2Ffunction_item_references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Ffunction_item_references.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "ffe4d43bc88e88970ddf6d36aa24ccda53f7f4f6", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 69, "deletions": 28, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "9174f04887e4229aa9f7596b7c101df5298148d8", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "68703eb0a232e781613cea056be79b8a258b5049", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "be0aa0fc4c1d05fcf9f3b5e9751c41e2bb254322", "filename": "compiler/rustc_mir_transform/src/uninhabited_enum_branching.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_transform%2Fsrc%2Funinhabited_enum_branching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_mir_transform%2Fsrc%2Funinhabited_enum_branching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Funinhabited_enum_branching.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "559ce227454de49684588149fc39baa0f033b62a", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "b616ed35d99d7f11c983d0ecebb02f2223e4b08d", "filename": "compiler/rustc_monomorphize/src/lib.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_monomorphize%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_monomorphize%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Flib.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "9875cde4a05ebe9354ef1ed5b83b6ba59e29aa5d", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 114, "deletions": 120, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "b49a01d75ed547fa6fde8ef302336fe7b844b2aa", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "0ed24fe849c079ba0b0d186bb652ab258583363d", "filename": "compiler/rustc_parse/src/parser/attr.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "3f5baf343c9b77040926a61da2eb88b7834ca9cc", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "9f2267efb82872569ea399de4c47ea569cf98c66", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "767fb9378bef1795c386db908821b7f20e9cdf7d", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 34, "deletions": 25, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "4d8bff28b05aa300a4ed81e7505536914837e8fd", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 38, "deletions": 37, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "239ed79ce2ffb825682f1fd3db0d26661cd8cf5e", "filename": "compiler/rustc_parse/src/parser/nonterminal.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "cbeec951e2dfe8dd0c037ae7f44a966ce11905d7", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "1b56cd72db079b872f3fea8678b4d7b640743b2a", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "b7206b57642fcfaca4bc55feb3fafe2ae727f438", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}, {"sha": "e2f95d74a3d2293c6cb7dba3e3c917798655a8ea", "filename": "compiler/rustc_parse/src/validate_attr.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fbc6da3c467b27793c35c6e105053c9d092447/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs?ref=f8fbc6da3c467b27793c35c6e105053c9d092447"}]}