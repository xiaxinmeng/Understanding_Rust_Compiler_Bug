{"sha": "e73f96abe7cc3a76223e5d0b50592c287c517750", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3M2Y5NmFiZTdjYzNhNzYyMjNlNWQwYjUwNTkyYzI4N2M1MTc3NTA=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-02-08T11:20:55Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-02-13T09:14:56Z"}, "message": "make OpTy.op private, and ImmTy.imm public instead", "tree": {"sha": "23710af560999806730be1ade359707d79db972c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23710af560999806730be1ade359707d79db972c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e73f96abe7cc3a76223e5d0b50592c287c517750", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e73f96abe7cc3a76223e5d0b50592c287c517750", "html_url": "https://github.com/rust-lang/rust/commit/e73f96abe7cc3a76223e5d0b50592c287c517750", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e73f96abe7cc3a76223e5d0b50592c287c517750/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "827a141466e7bb85eb3c030600878a2c606019e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/827a141466e7bb85eb3c030600878a2c606019e9", "html_url": "https://github.com/rust-lang/rust/commit/827a141466e7bb85eb3c030600878a2c606019e9"}], "stats": {"total": 145, "additions": 80, "deletions": 65}, "files": [{"sha": "5d6e9d64aeb58ab9134b5f670478e979ab14d519", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e73f96abe7cc3a76223e5d0b50592c287c517750/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e73f96abe7cc3a76223e5d0b50592c287c517750/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=e73f96abe7cc3a76223e5d0b50592c287c517750", "patch": "@@ -77,7 +77,7 @@ pub fn op_to_const<'tcx>(\n     let normalized_op = if normalize {\n         ecx.try_read_immediate(op)?\n     } else {\n-        match op.op {\n+        match *op {\n             Operand::Indirect(mplace) => Err(mplace),\n             Operand::Immediate(val) => Ok(val)\n         }\n@@ -105,15 +105,6 @@ pub fn op_to_const<'tcx>(\n     Ok(ty::Const { val, ty: op.layout.ty })\n }\n \n-pub fn lazy_const_to_op<'tcx>(\n-    ecx: &CompileTimeEvalContext<'_, '_, 'tcx>,\n-    cnst: ty::LazyConst<'tcx>,\n-    ty: ty::Ty<'tcx>,\n-) -> EvalResult<'tcx, OpTy<'tcx>> {\n-    let op = ecx.const_value_to_op(cnst)?;\n-    Ok(OpTy { op, layout: ecx.layout_of(ty)? })\n-}\n-\n fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     cid: GlobalId<'tcx>,\n@@ -486,7 +477,7 @@ pub fn const_field<'a, 'tcx>(\n     let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env);\n     let result = (|| {\n         // get the operand again\n-        let op = lazy_const_to_op(&ecx, ty::LazyConst::Evaluated(value), value.ty)?;\n+        let op = ecx.lazy_const_to_op(ty::LazyConst::Evaluated(value), value.ty)?;\n         // downcast\n         let down = match variant {\n             None => op,\n@@ -512,7 +503,7 @@ pub fn const_variant_index<'a, 'tcx>(\n ) -> EvalResult<'tcx, VariantIdx> {\n     trace!(\"const_variant_index: {:?}\", val);\n     let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env);\n-    let op = lazy_const_to_op(&ecx, ty::LazyConst::Evaluated(val), val.ty)?;\n+    let op = ecx.lazy_const_to_op(ty::LazyConst::Evaluated(val), val.ty)?;\n     Ok(ecx.read_discriminant(op)?.1)\n }\n "}, {"sha": "ce62d79e585a8bbf32d5695216950f18f73424e0", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e73f96abe7cc3a76223e5d0b50592c287c517750/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e73f96abe7cc3a76223e5d0b50592c287c517750/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=e73f96abe7cc3a76223e5d0b50592c287c517750", "patch": "@@ -9,7 +9,7 @@ use rustc::mir::interpret::{\n use rustc::mir::CastKind;\n use rustc_apfloat::Float;\n \n-use super::{EvalContext, Machine, PlaceTy, OpTy, Immediate};\n+use super::{EvalContext, Machine, PlaceTy, OpTy, ImmTy, Immediate};\n \n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     fn type_is_fat_ptr(&self, ty: Ty<'tcx>) -> bool {\n@@ -372,7 +372,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                             assert_eq!(src.layout.fields.offset(i).bytes(), 0);\n                             assert_eq!(src_field_layout.size, src.layout.size);\n                             // just sawp out the layout\n-                            OpTy { op: src.op, layout: src_field_layout }\n+                            OpTy::from(ImmTy { imm: src.to_immediate(), layout: src_field_layout })\n                         }\n                     };\n                     if src_field.layout.ty == dst_field.layout.ty {"}, {"sha": "4d0da5e6ecefb0f1d725e64e3911bdb87eb79b36", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 46, "deletions": 11, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e73f96abe7cc3a76223e5d0b50592c287c517750/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e73f96abe7cc3a76223e5d0b50592c287c517750/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=e73f96abe7cc3a76223e5d0b50592c287c517750", "patch": "@@ -11,7 +11,10 @@ use rustc::mir::interpret::{\n     ConstValue, Pointer, Scalar,\n     EvalResult, EvalErrorKind,\n };\n-use super::{EvalContext, Machine, MemPlace, MPlaceTy, MemoryKind};\n+use super::{\n+    EvalContext, Machine, AllocMap, Allocation, AllocationExtra,\n+    MemPlace, MPlaceTy, PlaceTy, Place, MemoryKind,\n+};\n pub use rustc::mir::interpret::ScalarMaybeUndef;\n \n /// A `Value` represents a single immediate self-contained Rust value.\n@@ -112,15 +115,15 @@ impl<'tcx, Tag> Immediate<Tag> {\n // as input for binary and cast operations.\n #[derive(Copy, Clone, Debug)]\n pub struct ImmTy<'tcx, Tag=()> {\n-    immediate: Immediate<Tag>,\n+    crate imm: Immediate<Tag>, // ideally we'd make this private, but const_prop needs this\n     pub layout: TyLayout<'tcx>,\n }\n \n impl<'tcx, Tag> ::std::ops::Deref for ImmTy<'tcx, Tag> {\n     type Target = Immediate<Tag>;\n     #[inline(always)]\n     fn deref(&self) -> &Immediate<Tag> {\n-        &self.immediate\n+        &self.imm\n     }\n }\n \n@@ -180,7 +183,7 @@ impl<Tag> Operand<Tag> {\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub struct OpTy<'tcx, Tag=()> {\n-    crate op: Operand<Tag>, // ideally we'd make this private, but const_prop needs this\n+    op: Operand<Tag>,\n     pub layout: TyLayout<'tcx>,\n }\n \n@@ -206,7 +209,7 @@ impl<'tcx, Tag> From<ImmTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n     #[inline(always)]\n     fn from(val: ImmTy<'tcx, Tag>) -> Self {\n         OpTy {\n-            op: Operand::Immediate(val.immediate),\n+            op: Operand::Immediate(val.imm),\n             layout: val.layout\n         }\n     }\n@@ -324,8 +327,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         &self,\n         op: OpTy<'tcx, M::PointerTag>\n     ) -> EvalResult<'tcx, ImmTy<'tcx, M::PointerTag>> {\n-        if let Ok(immediate) = self.try_read_immediate(op)? {\n-            Ok(ImmTy { immediate, layout: op.layout })\n+        if let Ok(imm) = self.try_read_immediate(op)? {\n+            Ok(ImmTy { imm, layout: op.layout })\n         } else {\n             bug!(\"primitive read failed for type: {:?}\", op.layout.ty);\n         }\n@@ -469,6 +472,22 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         Ok(OpTy { op, layout })\n     }\n \n+    /// Every place can be read from, so we can turm them into an operand\n+    #[inline(always)]\n+    pub fn place_to_op(\n+        &self,\n+        place: PlaceTy<'tcx, M::PointerTag>\n+    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+        let op = match *place {\n+            Place::Ptr(mplace) => {\n+                Operand::Indirect(mplace)\n+            }\n+            Place::Local { frame, local } =>\n+                *self.stack[frame].locals[local].access()?\n+        };\n+        Ok(OpTy { op, layout: place.layout })\n+    }\n+\n     // Evaluate a place with the goal of reading from it.  This lets us sometimes\n     // avoid allocations.\n     fn eval_place_to_op(\n@@ -531,10 +550,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             .collect()\n     }\n \n-    // Used when miri runs into a constant, and by CTFE.\n-    // FIXME: CTFE should use allocations, then we can make this private (embed it into\n-    // `eval_operand`, ideally).\n-    pub(crate) fn const_value_to_op(\n+    // Used when Miri runs into a constant, and (indirectly through lazy_const_to_op) by CTFE.\n+    fn const_value_to_op(\n         &self,\n         val: ty::LazyConst<'tcx>,\n     ) -> EvalResult<'tcx, Operand<M::PointerTag>> {\n@@ -666,3 +683,21 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     }\n \n }\n+\n+impl<'a, 'mir, 'tcx, M> EvalContext<'a, 'mir, 'tcx, M>\n+where\n+    M: Machine<'a, 'mir, 'tcx, PointerTag=()>,\n+    // FIXME: Working around https://github.com/rust-lang/rust/issues/24159\n+    M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation<(), M::AllocExtra>)>,\n+    M::AllocExtra: AllocationExtra<(), M::MemoryExtra>,\n+{\n+    // FIXME: CTFE should use allocations, then we can remove this.\n+    pub(crate) fn lazy_const_to_op(\n+        &self,\n+        cnst: ty::LazyConst<'tcx>,\n+        ty: ty::Ty<'tcx>,\n+    ) -> EvalResult<'tcx, OpTy<'tcx>> {\n+        let op = self.const_value_to_op(cnst)?;\n+        Ok(OpTy { op, layout: self.layout_of(ty)? })\n+    }\n+}"}, {"sha": "c1d0f0a8bd15baf489843d6b62ddbb45dc753ac8", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e73f96abe7cc3a76223e5d0b50592c287c517750/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e73f96abe7cc3a76223e5d0b50592c287c517750/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=e73f96abe7cc3a76223e5d0b50592c287c517750", "patch": "@@ -244,10 +244,10 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n     }\n }\n \n-impl<'tcx, Tag: ::std::fmt::Debug> OpTy<'tcx, Tag> {\n+impl<'tcx, Tag: ::std::fmt::Debug + Copy> OpTy<'tcx, Tag> {\n     #[inline(always)]\n     pub fn try_as_mplace(self) -> Result<MPlaceTy<'tcx, Tag>, Immediate<Tag>> {\n-        match self.op {\n+        match *self {\n             Operand::Indirect(mplace) => Ok(MPlaceTy { mplace, layout: self.layout }),\n             Operand::Immediate(imm) => Err(imm),\n         }\n@@ -487,9 +487,9 @@ where\n             Deref => self.deref_operand(base.into())?,\n \n             Index(local) => {\n-                let n = *self.frame().locals[local].access()?;\n-                let n_layout = self.layout_of(self.tcx.types.usize)?;\n-                let n = self.read_scalar(OpTy { op: n, layout: n_layout })?;\n+                let layout =  self.layout_of(self.tcx.types.usize)?;\n+                let n = self.access_local(self.frame(), local, Some(layout))?;\n+                let n = self.read_scalar(n)?;\n                 let n = n.to_bits(self.tcx.data_layout.pointer_size)?;\n                 self.mplace_field(base, u64::try_from(n).unwrap())?\n             }\n@@ -991,22 +991,6 @@ where\n         Ok(())\n     }\n \n-    /// Every place can be read from, so we can turm them into an operand\n-    #[inline(always)]\n-    pub fn place_to_op(\n-        &self,\n-        place: PlaceTy<'tcx, M::PointerTag>\n-    ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        let op = match place.place {\n-            Place::Ptr(mplace) => {\n-                Operand::Indirect(mplace)\n-            }\n-            Place::Local { frame, local } =>\n-                *self.stack[frame].locals[local].access()?\n-        };\n-        Ok(OpTy { op, layout: place.layout })\n-    }\n-\n     pub fn raw_const_to_mplace(\n         &self,\n         raw: RawConst<'tcx>,"}, {"sha": "72d60f259e727504c882b32cbfec1583d87d1f28", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e73f96abe7cc3a76223e5d0b50592c287c517750/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e73f96abe7cc3a76223e5d0b50592c287c517750/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=e73f96abe7cc3a76223e5d0b50592c287c517750", "patch": "@@ -7,7 +7,7 @@ use rustc_target::spec::abi::Abi;\n \n use rustc::mir::interpret::{EvalResult, PointerArithmetic, EvalErrorKind, Scalar};\n use super::{\n-    EvalContext, Machine, Immediate, OpTy, PlaceTy, MPlaceTy, Operand, StackPopCleanup\n+    EvalContext, Machine, Immediate, OpTy, ImmTy, PlaceTy, MPlaceTy, StackPopCleanup\n };\n \n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n@@ -418,8 +418,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 let mut args = args.to_vec();\n                 let pointee = args[0].layout.ty.builtin_deref(true).unwrap().ty;\n                 let fake_fat_ptr_ty = self.tcx.mk_mut_ptr(pointee);\n-                args[0].layout = self.layout_of(fake_fat_ptr_ty)?.field(self, 0)?;\n-                args[0].op = Operand::Immediate(Immediate::Scalar(ptr.ptr.into())); // strip vtable\n+                args[0] = OpTy::from(ImmTy { // strip vtable\n+                    layout: self.layout_of(fake_fat_ptr_ty)?.field(self, 0)?,\n+                    imm: Immediate::Scalar(ptr.ptr.into())\n+                });\n                 trace!(\"Patched self operand to {:#?}\", args[0]);\n                 // recurse with concrete function\n                 self.eval_fn_call(instance, span, caller_abi, &args, dest, ret)\n@@ -448,8 +450,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             _ => (instance, place),\n         };\n \n-        let arg = OpTy {\n-            op: Operand::Immediate(place.to_ref()),\n+        let arg = ImmTy {\n+            imm: place.to_ref(),\n             layout: self.layout_of(self.tcx.mk_mut_ptr(place.layout.ty))?,\n         };\n \n@@ -460,7 +462,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             instance,\n             span,\n             Abi::Rust,\n-            &[arg],\n+            &[arg.into()],\n             Some(dest.into()),\n             Some(target),\n         )"}, {"sha": "1b0a9b17d3686cab83e21d001292b571fa1a859a", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e73f96abe7cc3a76223e5d0b50592c287c517750/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e73f96abe7cc3a76223e5d0b50592c287c517750/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=e73f96abe7cc3a76223e5d0b50592c287c517750", "patch": "@@ -22,6 +22,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         let (ty, poly_trait_ref) = self.tcx.erase_regions(&(ty, poly_trait_ref));\n \n         if let Some(&vtable) = self.vtables.get(&(ty, poly_trait_ref)) {\n+            // This means we guarantee that there are no duplicate vtables, we will\n+            // always use the same vtable for the same (Type, Trait) combination.\n+            // That's not what happens in rustc, but emulating per-crate deduplication\n+            // does not sound like it actually makes anything any better.\n             return Ok(Pointer::from(vtable).with_default_tag());\n         }\n "}, {"sha": "d8d24c06f5a8b4d4062cc0cd8086211579f8543f", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e73f96abe7cc3a76223e5d0b50592c287c517750/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e73f96abe7cc3a76223e5d0b50592c287c517750/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=e73f96abe7cc3a76223e5d0b50592c287c517750", "patch": "@@ -18,10 +18,9 @@ use rustc::ty::layout::{\n     HasTyCtxt, TargetDataLayout, HasDataLayout,\n };\n \n-use crate::interpret::{self, EvalContext, ScalarMaybeUndef, Immediate, OpTy, MemoryKind};\n+use crate::interpret::{EvalContext, ScalarMaybeUndef, Immediate, OpTy, ImmTy, MemoryKind};\n use crate::const_eval::{\n     CompileTimeInterpreter, error_to_const_error, eval_promoted, mk_eval_cx,\n-    lazy_const_to_op,\n };\n use crate::transform::{MirPass, MirSource};\n \n@@ -254,7 +253,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n         source_info: SourceInfo,\n     ) -> Option<Const<'tcx>> {\n         self.ecx.tcx.span = source_info.span;\n-        match lazy_const_to_op(&self.ecx, *c.literal, c.ty) {\n+        match self.ecx.lazy_const_to_op(*c.literal, c.ty) {\n             Ok(op) => {\n                 Some((op, c.span))\n             },\n@@ -345,15 +344,15 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n             Rvalue::Len(_) => None,\n             Rvalue::NullaryOp(NullOp::SizeOf, ty) => {\n                 type_size_of(self.tcx, self.param_env, ty).and_then(|n| Some((\n-                    OpTy {\n-                        op: interpret::Operand::Immediate(Immediate::Scalar(\n+                    ImmTy {\n+                        imm: Immediate::Scalar(\n                             Scalar::Bits {\n                                 bits: n as u128,\n                                 size: self.tcx.data_layout.pointer_size.bytes() as u8,\n                             }.into()\n-                        )),\n+                        ),\n                         layout: self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n-                    },\n+                    }.into(),\n                     span,\n                 )))\n             }\n@@ -388,11 +387,11 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                     // Now run the actual operation.\n                     this.ecx.unary_op(op, prim, arg.layout)\n                 })?;\n-                let res = OpTy {\n-                    op: interpret::Operand::Immediate(Immediate::Scalar(val.into())),\n+                let res = ImmTy {\n+                    imm: Immediate::Scalar(val.into()),\n                     layout: place_layout,\n                 };\n-                Some((res, span))\n+                Some((res.into(), span))\n             }\n             Rvalue::CheckedBinaryOp(op, ref left, ref right) |\n             Rvalue::BinaryOp(op, ref left, ref right) => {\n@@ -462,11 +461,11 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                     }\n                     Immediate::Scalar(val.into())\n                 };\n-                let res = OpTy {\n-                    op: interpret::Operand::Immediate(val),\n+                let res = ImmTy {\n+                    imm: val,\n                     layout: place_layout,\n                 };\n-                Some((res, span))\n+                Some((res.into(), span))\n             },\n         }\n     }"}]}