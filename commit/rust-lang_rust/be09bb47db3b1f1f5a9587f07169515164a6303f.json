{"sha": "be09bb47db3b1f1f5a9587f07169515164a6303f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlMDliYjQ3ZGIzYjFmMWY1YTk1ODdmMDcxNjk1MTUxNjRhNjMwM2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-15T21:17:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-15T21:17:21Z"}, "message": "Auto merge of #5034 - ThibsG:MatchWildErrArmImprove5024, r=flip1995\n\nMatch wild err arm improvements\n\nThis lint should trigger on other identifiers which have `_` prefix (such as `_e`) and only if they are unused in the panic block.\n\n_Note_: the `is_unused` function is greatly inspired from `pat_is_wild` function in [loops lints](https://github.com/rust-lang/rust-clippy/blob/43ac9416d935942d6c7d2b2e0c876c551652c4ec/clippy_lints/src/loops.rs#L1689).\nI've been considering doing some refactoring, maybe in utils. Maybe this PR or a new one. What do you think ?\n\nfixes #5024\n\nchangelog: none", "tree": {"sha": "8a4be6d5f0647a24b40378101180cc80e3c5615c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a4be6d5f0647a24b40378101180cc80e3c5615c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be09bb47db3b1f1f5a9587f07169515164a6303f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be09bb47db3b1f1f5a9587f07169515164a6303f", "html_url": "https://github.com/rust-lang/rust/commit/be09bb47db3b1f1f5a9587f07169515164a6303f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be09bb47db3b1f1f5a9587f07169515164a6303f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d13b678e37113900b98cadad947f482aa2d49343", "url": "https://api.github.com/repos/rust-lang/rust/commits/d13b678e37113900b98cadad947f482aa2d49343", "html_url": "https://github.com/rust-lang/rust/commit/d13b678e37113900b98cadad947f482aa2d49343"}, {"sha": "44fb8b5e8834a89e0d9f925b8ff235eec10526e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/44fb8b5e8834a89e0d9f925b8ff235eec10526e3", "html_url": "https://github.com/rust-lang/rust/commit/44fb8b5e8834a89e0d9f925b8ff235eec10526e3"}], "stats": {"total": 254, "additions": 166, "deletions": 88}, "files": [{"sha": "b2d6c178b54ab76e96947e5f1f0eabd0217073f4", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 15, "deletions": 45, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/be09bb47db3b1f1f5a9587f07169515164a6303f/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be09bb47db3b1f1f5a9587f07169515164a6303f/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=be09bb47db3b1f1f5a9587f07169515164a6303f", "patch": "@@ -1,37 +1,35 @@\n+use crate::consts::{constant, Constant};\n use crate::reexport::*;\n+use crate::utils::paths;\n+use crate::utils::usage::{is_unused, mutated_variables};\n+use crate::utils::{\n+    get_enclosing_block, get_parent_expr, get_trait_def_id, has_iter_method, higher, implements_trait,\n+    is_integer_const, is_refutable, last_path_segment, match_trait_method, match_type, match_var, multispan_sugg,\n+    snippet, snippet_opt, snippet_with_applicability, span_help_and_lint, span_lint, span_lint_and_sugg,\n+    span_lint_and_then, SpanlessEq,\n+};\n+use crate::utils::{is_type_diagnostic_item, qpath_res, same_tys, sext, sugg};\n use if_chain::if_chain;\n use itertools::Itertools;\n+use rustc::hir::map::Map;\n use rustc::lint::in_external_macro;\n use rustc::middle::region;\n+use rustc::ty::{self, Ty};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_errors::Applicability;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id;\n use rustc_hir::intravisit::{walk_block, walk_expr, walk_pat, walk_stmt, NestedVisitorMap, Visitor};\n use rustc_hir::*;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-// use rustc::middle::region::CodeExtent;\n-use crate::consts::{constant, Constant};\n-use crate::utils::usage::mutated_variables;\n-use crate::utils::{is_type_diagnostic_item, qpath_res, same_tys, sext, sugg};\n-use rustc::hir::map::Map;\n-use rustc::ty::{self, Ty};\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::Applicability;\n use rustc_span::source_map::Span;\n use rustc_span::{BytePos, Symbol};\n use rustc_typeck::expr_use_visitor::*;\n use std::iter::{once, Iterator};\n use std::mem;\n use syntax::ast;\n \n-use crate::utils::paths;\n-use crate::utils::{\n-    get_enclosing_block, get_parent_expr, get_trait_def_id, has_iter_method, higher, implements_trait,\n-    is_integer_const, is_refutable, last_path_segment, match_trait_method, match_type, match_var, multispan_sugg,\n-    snippet, snippet_opt, snippet_with_applicability, span_help_and_lint, span_lint, span_lint_and_sugg,\n-    span_lint_and_then, SpanlessEq,\n-};\n-\n declare_clippy_lint! {\n     /// **What it does:** Checks for for-loops that manually copy items between\n     /// slices that could be optimized by having a memcpy.\n@@ -1689,39 +1687,11 @@ fn check_for_mutation(\n fn pat_is_wild<'tcx>(pat: &'tcx PatKind<'_>, body: &'tcx Expr<'_>) -> bool {\n     match *pat {\n         PatKind::Wild => true,\n-        PatKind::Binding(.., ident, None) if ident.as_str().starts_with('_') => {\n-            let mut visitor = UsedVisitor {\n-                var: ident.name,\n-                used: false,\n-            };\n-            walk_expr(&mut visitor, body);\n-            !visitor.used\n-        },\n+        PatKind::Binding(.., ident, None) if ident.as_str().starts_with('_') => is_unused(&ident, body),\n         _ => false,\n     }\n }\n \n-struct UsedVisitor {\n-    var: ast::Name, // var to look for\n-    used: bool,     // has the var been used otherwise?\n-}\n-\n-impl<'tcx> Visitor<'tcx> for UsedVisitor {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if match_var(expr, self.var) {\n-            self.used = true;\n-        } else {\n-            walk_expr(self, expr);\n-        }\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<'_, Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}\n-\n struct LocalUsedVisitor<'a, 'tcx> {\n     cx: &'a LateContext<'a, 'tcx>,\n     local: HirId,"}, {"sha": "cddd479d7b7280b855a3b3c805c9a34aeecdcabf", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 30, "deletions": 22, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/be09bb47db3b1f1f5a9587f07169515164a6303f/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be09bb47db3b1f1f5a9587f07169515164a6303f/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=be09bb47db3b1f1f5a9587f07169515164a6303f", "patch": "@@ -1,8 +1,9 @@\n use crate::consts::{constant, miri_to_const, Constant};\n use crate::utils::paths;\n use crate::utils::sugg::Sugg;\n+use crate::utils::usage::is_unused;\n use crate::utils::{\n-    expr_block, is_allowed, is_expn_of, match_qpath, match_type, multispan_sugg, remove_blocks, snippet,\n+    expr_block, is_allowed, is_expn_of, is_wild, match_qpath, match_type, multispan_sugg, remove_blocks, snippet,\n     snippet_with_applicability, span_help_and_lint, span_lint_and_sugg, span_lint_and_then, span_note_and_lint,\n     walk_ptrs_ty,\n };\n@@ -461,33 +462,40 @@ fn check_overlapping_arms<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ex: &'tcx Expr<'\n     }\n }\n \n-fn is_wild<'tcx>(pat: &impl std::ops::Deref<Target = Pat<'tcx>>) -> bool {\n-    match pat.kind {\n-        PatKind::Wild => true,\n-        _ => false,\n-    }\n-}\n-\n fn check_wild_err_arm(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n     let ex_ty = walk_ptrs_ty(cx.tables.expr_ty(ex));\n     if match_type(cx, ex_ty, &paths::RESULT) {\n         for arm in arms {\n             if let PatKind::TupleStruct(ref path, ref inner, _) = arm.pat.kind {\n                 let path_str = print::to_string(print::NO_ANN, |s| s.print_qpath(path, false));\n-                if_chain! {\n-                    if path_str == \"Err\";\n-                    if inner.iter().any(is_wild);\n-                    if let ExprKind::Block(ref block, _) = arm.body.kind;\n-                    if is_panic_block(block);\n-                    then {\n-                        // `Err(_)` arm with `panic!` found\n-                        span_note_and_lint(cx,\n-                                           MATCH_WILD_ERR_ARM,\n-                                           arm.pat.span,\n-                                           \"`Err(_)` will match all errors, maybe not a good idea\",\n-                                           arm.pat.span,\n-                                           \"to remove this warning, match each error separately \\\n-                                            or use `unreachable!` macro\");\n+                if path_str == \"Err\" {\n+                    let mut matching_wild = inner.iter().any(is_wild);\n+                    let mut ident_bind_name = String::from(\"_\");\n+                    if !matching_wild {\n+                        // Looking for unused bindings (i.e.: `_e`)\n+                        inner.iter().for_each(|pat| {\n+                            if let PatKind::Binding(.., ident, None) = &pat.kind {\n+                                if ident.as_str().starts_with('_') && is_unused(ident, arm.body) {\n+                                    ident_bind_name = (&ident.name.as_str()).to_string();\n+                                    matching_wild = true;\n+                                }\n+                            }\n+                        });\n+                    }\n+                    if_chain! {\n+                        if matching_wild;\n+                        if let ExprKind::Block(ref block, _) = arm.body.kind;\n+                        if is_panic_block(block);\n+                        then {\n+                            // `Err(_)` or `Err(_e)` arm with `panic!` found\n+                            span_note_and_lint(cx,\n+                                MATCH_WILD_ERR_ARM,\n+                                arm.pat.span,\n+                                &format!(\"`Err({})` matches all errors\", &ident_bind_name),\n+                                arm.pat.span,\n+                                \"match each error separately or use the error output\",\n+                            );\n+                        }\n                     }\n                 }\n             }"}, {"sha": "eca2baa8c8098a97786b5034f744d41cd98412fa", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/be09bb47db3b1f1f5a9587f07169515164a6303f/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be09bb47db3b1f1f5a9587f07169515164a6303f/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=be09bb47db3b1f1f5a9587f07169515164a6303f", "patch": "@@ -127,6 +127,14 @@ pub fn is_present_in_source<T: LintContext>(cx: &T, span: Span) -> bool {\n     true\n }\n \n+/// Checks if given pattern is a wildcard (`_`)\n+pub fn is_wild<'tcx>(pat: &impl std::ops::Deref<Target = Pat<'tcx>>) -> bool {\n+    match pat.kind {\n+        PatKind::Wild => true,\n+        _ => false,\n+    }\n+}\n+\n /// Checks if type is struct, enum or union type with the given def path.\n pub fn match_type(cx: &LateContext<'_, '_>, ty: Ty<'_>, path: &[&str]) -> bool {\n     match ty.kind {"}, {"sha": "7939d7d0863c6a7cd6cd11427d2a3c0570d438f8", "filename": "clippy_lints/src/utils/usage.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/be09bb47db3b1f1f5a9587f07169515164a6303f/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be09bb47db3b1f1f5a9587f07169515164a6303f/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=be09bb47db3b1f1f5a9587f07169515164a6303f", "patch": "@@ -1,9 +1,14 @@\n+use crate::utils::match_var;\n+use rustc::hir::map::Map;\n use rustc::ty;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def::Res;\n+use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc_hir::*;\n use rustc_lint::LateContext;\n+use rustc_span::symbol::Ident;\n use rustc_typeck::expr_use_visitor::*;\n+use syntax::ast;\n \n /// Returns a set of mutated local variable IDs, or `None` if mutations could not be determined.\n pub fn mutated_variables<'a, 'tcx>(expr: &'tcx Expr<'_>, cx: &'a LateContext<'a, 'tcx>) -> Option<FxHashSet<HirId>> {\n@@ -70,3 +75,33 @@ impl<'tcx> Delegate<'tcx> for MutVarsDelegate {\n         self.update(&cmt)\n     }\n }\n+\n+pub struct UsedVisitor {\n+    pub var: ast::Name, // var to look for\n+    pub used: bool,     // has the var been used otherwise?\n+}\n+\n+impl<'tcx> Visitor<'tcx> for UsedVisitor {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if match_var(expr, self.var) {\n+            self.used = true;\n+        } else {\n+            walk_expr(self, expr);\n+        }\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<'_, Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+pub fn is_unused<'tcx>(ident: &'tcx Ident, body: &'tcx Expr<'_>) -> bool {\n+    let mut visitor = UsedVisitor {\n+        var: ident.name,\n+        used: false,\n+    };\n+    walk_expr(&mut visitor, body);\n+    !visitor.used\n+}"}, {"sha": "2ce0b574929e3c924360dd6b9ab89fcc097c70a9", "filename": "tests/ui/matches.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/be09bb47db3b1f1f5a9587f07169515164a6303f/tests%2Fui%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be09bb47db3b1f1f5a9587f07169515164a6303f/tests%2Fui%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatches.rs?ref=be09bb47db3b1f1f5a9587f07169515164a6303f", "patch": "@@ -28,6 +28,19 @@ fn match_wild_err_arm() {\n         },\n     }\n \n+    match x {\n+        Ok(3) => println!(\"ok\"),\n+        Ok(_) => println!(\"ok\"),\n+        Err(_e) => panic!(),\n+    }\n+\n+    // Allowed when used in `panic!`.\n+    match x {\n+        Ok(3) => println!(\"ok\"),\n+        Ok(_) => println!(\"ok\"),\n+        Err(_e) => panic!(\"{}\", _e),\n+    }\n+\n     // Allowed when not with `panic!` block.\n     match x {\n         Ok(3) => println!(\"ok\"),"}, {"sha": "1c5c636fee61e461360453a55af24e2fb8faba26", "filename": "tests/ui/matches.stderr", "status": "modified", "additions": 65, "deletions": 21, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/be09bb47db3b1f1f5a9587f07169515164a6303f/tests%2Fui%2Fmatches.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/be09bb47db3b1f1f5a9587f07169515164a6303f/tests%2Fui%2Fmatches.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatches.stderr?ref=be09bb47db3b1f1f5a9587f07169515164a6303f", "patch": "@@ -1,11 +1,11 @@\n-error: `Err(_)` will match all errors, maybe not a good idea\n+error: `Err(_)` matches all errors\n   --> $DIR/matches.rs:14:9\n    |\n LL |         Err(_) => panic!(\"err\"),\n    |         ^^^^^^\n    |\n    = note: `-D clippy::match-wild-err-arm` implied by `-D warnings`\n-   = note: to remove this warning, match each error separately or use `unreachable!` macro\n+   = note: match each error separately or use the error output\n \n error: this `match` has identical arm bodies\n   --> $DIR/matches.rs:13:18\n@@ -26,13 +26,13 @@ LL |         Ok(3) => println!(\"ok\"),\n    |         ^^^^^\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n-error: `Err(_)` will match all errors, maybe not a good idea\n+error: `Err(_)` matches all errors\n   --> $DIR/matches.rs:20:9\n    |\n LL |         Err(_) => panic!(),\n    |         ^^^^^^\n    |\n-   = note: to remove this warning, match each error separately or use `unreachable!` macro\n+   = note: match each error separately or use the error output\n \n error: this `match` has identical arm bodies\n   --> $DIR/matches.rs:19:18\n@@ -52,13 +52,13 @@ LL |         Ok(3) => println!(\"ok\"),\n    |         ^^^^^\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n-error: `Err(_)` will match all errors, maybe not a good idea\n+error: `Err(_)` matches all errors\n   --> $DIR/matches.rs:26:9\n    |\n LL |         Err(_) => {\n    |         ^^^^^^\n    |\n-   = note: to remove this warning, match each error separately or use `unreachable!` macro\n+   = note: match each error separately or use the error output\n \n error: this `match` has identical arm bodies\n   --> $DIR/matches.rs:25:18\n@@ -78,37 +78,45 @@ LL |         Ok(3) => println!(\"ok\"),\n    |         ^^^^^\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n+error: `Err(_e)` matches all errors\n+  --> $DIR/matches.rs:34:9\n+   |\n+LL |         Err(_e) => panic!(),\n+   |         ^^^^^^^\n+   |\n+   = note: match each error separately or use the error output\n+\n error: this `match` has identical arm bodies\n-  --> $DIR/matches.rs:34:18\n+  --> $DIR/matches.rs:33:18\n    |\n LL |         Ok(_) => println!(\"ok\"),\n    |                  ^^^^^^^^^^^^^^\n    |\n note: same as this\n-  --> $DIR/matches.rs:33:18\n+  --> $DIR/matches.rs:32:18\n    |\n LL |         Ok(3) => println!(\"ok\"),\n    |                  ^^^^^^^^^^^^^^\n help: consider refactoring into `Ok(3) | Ok(_)`\n-  --> $DIR/matches.rs:33:9\n+  --> $DIR/matches.rs:32:9\n    |\n LL |         Ok(3) => println!(\"ok\"),\n    |         ^^^^^\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n error: this `match` has identical arm bodies\n-  --> $DIR/matches.rs:41:18\n+  --> $DIR/matches.rs:40:18\n    |\n LL |         Ok(_) => println!(\"ok\"),\n    |                  ^^^^^^^^^^^^^^\n    |\n note: same as this\n-  --> $DIR/matches.rs:40:18\n+  --> $DIR/matches.rs:39:18\n    |\n LL |         Ok(3) => println!(\"ok\"),\n    |                  ^^^^^^^^^^^^^^\n help: consider refactoring into `Ok(3) | Ok(_)`\n-  --> $DIR/matches.rs:40:9\n+  --> $DIR/matches.rs:39:9\n    |\n LL |         Ok(3) => println!(\"ok\"),\n    |         ^^^^^\n@@ -133,58 +141,94 @@ LL |         Ok(3) => println!(\"ok\"),\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n error: this `match` has identical arm bodies\n+  --> $DIR/matches.rs:54:18\n+   |\n+LL |         Ok(_) => println!(\"ok\"),\n+   |                  ^^^^^^^^^^^^^^\n+   |\n+note: same as this\n   --> $DIR/matches.rs:53:18\n    |\n+LL |         Ok(3) => println!(\"ok\"),\n+   |                  ^^^^^^^^^^^^^^\n+help: consider refactoring into `Ok(3) | Ok(_)`\n+  --> $DIR/matches.rs:53:9\n+   |\n+LL |         Ok(3) => println!(\"ok\"),\n+   |         ^^^^^\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+error: this `match` has identical arm bodies\n+  --> $DIR/matches.rs:60:18\n+   |\n+LL |         Ok(_) => println!(\"ok\"),\n+   |                  ^^^^^^^^^^^^^^\n+   |\n+note: same as this\n+  --> $DIR/matches.rs:59:18\n+   |\n+LL |         Ok(3) => println!(\"ok\"),\n+   |                  ^^^^^^^^^^^^^^\n+help: consider refactoring into `Ok(3) | Ok(_)`\n+  --> $DIR/matches.rs:59:9\n+   |\n+LL |         Ok(3) => println!(\"ok\"),\n+   |         ^^^^^\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+error: this `match` has identical arm bodies\n+  --> $DIR/matches.rs:66:18\n+   |\n LL |         Ok(_) => println!(\"ok\"),\n    |                  ^^^^^^^^^^^^^^\n    |\n note: same as this\n-  --> $DIR/matches.rs:52:18\n+  --> $DIR/matches.rs:65:18\n    |\n LL |         Ok(3) => println!(\"ok\"),\n    |                  ^^^^^^^^^^^^^^\n help: consider refactoring into `Ok(3) | Ok(_)`\n-  --> $DIR/matches.rs:52:9\n+  --> $DIR/matches.rs:65:9\n    |\n LL |         Ok(3) => println!(\"ok\"),\n    |         ^^^^^\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n error: this `match` has identical arm bodies\n-  --> $DIR/matches.rs:76:29\n+  --> $DIR/matches.rs:89:29\n    |\n LL |         (Ok(_), Some(x)) => println!(\"ok {}\", x),\n    |                             ^^^^^^^^^^^^^^^^^^^^\n    |\n note: same as this\n-  --> $DIR/matches.rs:75:29\n+  --> $DIR/matches.rs:88:29\n    |\n LL |         (Ok(x), Some(_)) => println!(\"ok {}\", x),\n    |                             ^^^^^^^^^^^^^^^^^^^^\n help: consider refactoring into `(Ok(x), Some(_)) | (Ok(_), Some(x))`\n-  --> $DIR/matches.rs:75:9\n+  --> $DIR/matches.rs:88:9\n    |\n LL |         (Ok(x), Some(_)) => println!(\"ok {}\", x),\n    |         ^^^^^^^^^^^^^^^^\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n error: this `match` has identical arm bodies\n-  --> $DIR/matches.rs:91:18\n+  --> $DIR/matches.rs:104:18\n    |\n LL |         Ok(_) => println!(\"ok\"),\n    |                  ^^^^^^^^^^^^^^\n    |\n note: same as this\n-  --> $DIR/matches.rs:90:18\n+  --> $DIR/matches.rs:103:18\n    |\n LL |         Ok(3) => println!(\"ok\"),\n    |                  ^^^^^^^^^^^^^^\n help: consider refactoring into `Ok(3) | Ok(_)`\n-  --> $DIR/matches.rs:90:9\n+  --> $DIR/matches.rs:103:9\n    |\n LL |         Ok(3) => println!(\"ok\"),\n    |         ^^^^^\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n-error: aborting due to 12 previous errors\n+error: aborting due to 15 previous errors\n "}]}