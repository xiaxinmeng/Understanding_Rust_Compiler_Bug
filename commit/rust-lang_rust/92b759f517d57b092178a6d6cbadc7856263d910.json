{"sha": "92b759f517d57b092178a6d6cbadc7856263d910", "node_id": "C_kwDOAAsO6NoAKDkyYjc1OWY1MTdkNTdiMDkyMTc4YTZkNmNiYWRjNzg1NjI2M2Q5MTA", "commit": {"author": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2022-09-16T13:47:07Z"}, "committer": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2022-09-16T13:47:07Z"}, "message": "Revert \"Better errors for implied static bound\"\n\nThis reverts commit c75817b0a75d4b6b01ee10900ba5d01d4915e6a8.", "tree": {"sha": "e403f572b3216f50759d60781859705e5f50ea1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e403f572b3216f50759d60781859705e5f50ea1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92b759f517d57b092178a6d6cbadc7856263d910", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92b759f517d57b092178a6d6cbadc7856263d910", "html_url": "https://github.com/rust-lang/rust/commit/92b759f517d57b092178a6d6cbadc7856263d910", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92b759f517d57b092178a6d6cbadc7856263d910/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bba514b7b4f3062139d17ce1e4ab26b396c8ad49", "url": "https://api.github.com/repos/rust-lang/rust/commits/bba514b7b4f3062139d17ce1e4ab26b396c8ad49", "html_url": "https://github.com/rust-lang/rust/commit/bba514b7b4f3062139d17ce1e4ab26b396c8ad49"}], "stats": {"total": 428, "additions": 98, "deletions": 330}, "files": [{"sha": "3b58da11e84a0edf7c20143c4f34714aacfd2c38", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=92b759f517d57b092178a6d6cbadc7856263d910", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::ty::{self, RegionVid, TyCtxt};\n use rustc_span::symbol::{kw, Symbol};\n use rustc_span::{sym, DesugaringKind, Span};\n \n-use crate::region_infer::{BlameConstraint, ExtraConstraintInfo};\n+use crate::region_infer::BlameConstraint;\n use crate::{\n     borrow_set::BorrowData, nll::ConstraintDescription, region_infer::Cause, MirBorrowckCtxt,\n     WriteKind,\n@@ -38,7 +38,6 @@ pub(crate) enum BorrowExplanation<'tcx> {\n         span: Span,\n         region_name: RegionName,\n         opt_place_desc: Option<String>,\n-        extra_info: Vec<ExtraConstraintInfo>,\n     },\n     Unexplained,\n }\n@@ -244,7 +243,6 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                 ref region_name,\n                 ref opt_place_desc,\n                 from_closure: _,\n-                ref extra_info,\n             } => {\n                 region_name.highlight_region_name(err);\n \n@@ -270,14 +268,6 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                     );\n                 };\n \n-                for extra in extra_info {\n-                    match extra {\n-                        ExtraConstraintInfo::PlaceholderFromPredicate(span) => {\n-                            err.span_note(*span, format!(\"due to current limitations in the borrow checker, this implies a `'static` lifetime\"));\n-                        }\n-                    }\n-                }\n-\n                 self.add_lifetime_bound_suggestion_to_diagnostic(err, &category, span, region_name);\n             }\n             _ => {}\n@@ -319,17 +309,16 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &self,\n         borrow_region: RegionVid,\n         outlived_region: RegionVid,\n-    ) -> (ConstraintCategory<'tcx>, bool, Span, Option<RegionName>, Vec<ExtraConstraintInfo>) {\n-        let (blame_constraint, extra_info) = self.regioncx.best_blame_constraint(\n-            borrow_region,\n-            NllRegionVariableOrigin::FreeRegion,\n-            |r| self.regioncx.provides_universal_region(r, borrow_region, outlived_region),\n-        );\n-        let BlameConstraint { category, from_closure, cause, .. } = blame_constraint;\n+    ) -> (ConstraintCategory<'tcx>, bool, Span, Option<RegionName>) {\n+        let BlameConstraint { category, from_closure, cause, variance_info: _ } = self\n+            .regioncx\n+            .best_blame_constraint(borrow_region, NllRegionVariableOrigin::FreeRegion, |r| {\n+                self.regioncx.provides_universal_region(r, borrow_region, outlived_region)\n+            });\n \n         let outlived_fr_name = self.give_region_a_name(outlived_region);\n \n-        (category, from_closure, cause.span, outlived_fr_name, extra_info)\n+        (category, from_closure, cause.span, outlived_fr_name)\n     }\n \n     /// Returns structured explanation for *why* the borrow contains the\n@@ -401,7 +390,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n             None => {\n                 if let Some(region) = self.to_error_region_vid(borrow_region_vid) {\n-                    let (category, from_closure, span, region_name, extra_info) =\n+                    let (category, from_closure, span, region_name) =\n                         self.free_region_constraint_info(borrow_region_vid, region);\n                     if let Some(region_name) = region_name {\n                         let opt_place_desc = self.describe_place(borrow.borrowed_place.as_ref());\n@@ -411,7 +400,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             span,\n                             region_name,\n                             opt_place_desc,\n-                            extra_info,\n                         }\n                     } else {\n                         debug!(\"Could not generate a region name\");"}, {"sha": "e7681222fc1f0d0e40528787e30fc587d589f676", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=92b759f517d57b092178a6d6cbadc7856263d910", "patch": "@@ -354,12 +354,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     ) {\n         debug!(\"report_region_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n \n-        let BlameConstraint { category, cause, variance_info, .. } = self\n-            .regioncx\n-            .best_blame_constraint(fr, fr_origin, |r| {\n+        let BlameConstraint { category, cause, variance_info, from_closure: _ } =\n+            self.regioncx.best_blame_constraint(fr, fr_origin, |r| {\n                 self.regioncx.provides_universal_region(r, fr, outlived_fr)\n-            })\n-            .0;\n+            });\n \n         debug!(\"report_region_error: category={:?} {:?} {:?}\", category, cause, variance_info);\n "}, {"sha": "79a3a247c48a5c207cdf7af2d5ff711abc4b9739", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 11, "deletions": 38, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=92b759f517d57b092178a6d6cbadc7856263d910", "patch": "@@ -245,11 +245,6 @@ enum Trace<'tcx> {\n     NotVisited,\n }\n \n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub enum ExtraConstraintInfo {\n-    PlaceholderFromPredicate(Span),\n-}\n-\n impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Creates a new region inference context with a total of\n     /// `num_region_variables` valid inference variables; the first N\n@@ -1823,9 +1818,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         fr1_origin: NllRegionVariableOrigin,\n         fr2: RegionVid,\n     ) -> (ConstraintCategory<'tcx>, ObligationCause<'tcx>) {\n-        let BlameConstraint { category, cause, .. } = self\n-            .best_blame_constraint(fr1, fr1_origin, |r| self.provides_universal_region(r, fr1, fr2))\n-            .0;\n+        let BlameConstraint { category, cause, .. } =\n+            self.best_blame_constraint(fr1, fr1_origin, |r| {\n+                self.provides_universal_region(r, fr1, fr2)\n+            });\n         (category, cause)\n     }\n \n@@ -2014,7 +2010,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         from_region: RegionVid,\n         from_region_origin: NllRegionVariableOrigin,\n         target_test: impl Fn(RegionVid) -> bool,\n-    ) -> (BlameConstraint<'tcx>, Vec<ExtraConstraintInfo>) {\n+    ) -> BlameConstraint<'tcx> {\n         // Find all paths\n         let (path, target_region) =\n             self.find_constraint_paths_between_regions(from_region, target_test).unwrap();\n@@ -2030,18 +2026,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 .collect::<Vec<_>>()\n         );\n \n-        let mut extra_info = vec![];\n-        for constraint in path.iter() {\n-            let outlived = constraint.sub;\n-            let Some(origin) = self.var_infos.get(outlived) else { continue; };\n-            let RegionVariableOrigin::Nll(NllRegionVariableOrigin::Placeholder(p)) = origin.origin else { continue; };\n-            debug!(?constraint, ?p);\n-            let ConstraintCategory::Predicate(span) = constraint.category else { continue; };\n-            extra_info.push(ExtraConstraintInfo::PlaceholderFromPredicate(span));\n-            // We only want to point to one\n-            break;\n-        }\n-\n         // We try to avoid reporting a `ConstraintCategory::Predicate` as our best constraint.\n         // Instead, we use it to produce an improved `ObligationCauseCode`.\n         // FIXME - determine what we should do if we encounter multiple `ConstraintCategory::Predicate`\n@@ -2089,7 +2073,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     from_closure,\n                     cause: ObligationCause::new(span, CRATE_HIR_ID, cause_code),\n                     variance_info: constraint.variance_info,\n-                    outlives_constraint: *constraint,\n                 }\n             })\n             .collect();\n@@ -2191,7 +2174,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let best_choice =\n             if blame_source { range.rev().find(find_region) } else { range.find(find_region) };\n \n-        debug!(?best_choice, ?blame_source, ?extra_info);\n+        debug!(?best_choice, ?blame_source);\n \n         if let Some(i) = best_choice {\n             if let Some(next) = categorized_path.get(i + 1) {\n@@ -2200,7 +2183,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 {\n                     // The return expression is being influenced by the return type being\n                     // impl Trait, point at the return type and not the return expr.\n-                    return (next.clone(), extra_info);\n+                    return next.clone();\n                 }\n             }\n \n@@ -2220,7 +2203,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 }\n             }\n \n-            return (categorized_path[i].clone(), extra_info);\n+            return categorized_path[i].clone();\n         }\n \n         // If that search fails, that is.. unusual. Maybe everything\n@@ -2230,7 +2213,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         categorized_path.sort_by(|p0, p1| p0.category.cmp(&p1.category));\n         debug!(\"sorted_path={:#?}\", categorized_path);\n \n-        (categorized_path.remove(0), extra_info)\n+        categorized_path.remove(0)\n     }\n \n     pub(crate) fn universe_info(&self, universe: ty::UniverseIndex) -> UniverseInfo<'tcx> {\n@@ -2312,13 +2295,7 @@ impl<'tcx> ClosureRegionRequirementsExt<'tcx> for ClosureRegionRequirements<'tcx\n                              outlives_requirement={:?}\",\n                             region, outlived_region, outlives_requirement,\n                         );\n-                        (\n-                            ty::Binder::dummy(ty::OutlivesPredicate(\n-                                region.into(),\n-                                outlived_region,\n-                            )),\n-                            ConstraintCategory::BoringNoLocation,\n-                        )\n+                        ty::Binder::dummy(ty::OutlivesPredicate(region.into(), outlived_region))\n                     }\n \n                     ClosureOutlivesSubject::Ty(ty) => {\n@@ -2328,10 +2305,7 @@ impl<'tcx> ClosureRegionRequirementsExt<'tcx> for ClosureRegionRequirements<'tcx\n                              outlives_requirement={:?}\",\n                             ty, outlived_region, outlives_requirement,\n                         );\n-                        (\n-                            ty::Binder::dummy(ty::OutlivesPredicate(ty.into(), outlived_region)),\n-                            ConstraintCategory::BoringNoLocation,\n-                        )\n+                        ty::Binder::dummy(ty::OutlivesPredicate(ty.into(), outlived_region))\n                     }\n                 }\n             })\n@@ -2345,5 +2319,4 @@ pub struct BlameConstraint<'tcx> {\n     pub from_closure: bool,\n     pub cause: ObligationCause<'tcx>,\n     pub variance_info: ty::VarianceDiagInfo<'tcx>,\n-    pub outlives_constraint: OutlivesConstraint<'tcx>,\n }"}, {"sha": "29195b3922fcdb24dc8734caa8f03dcb5f9ce230", "filename": "compiler/rustc_borrowck/src/type_check/canonical.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs?ref=92b759f517d57b092178a6d6cbadc7856263d910", "patch": "@@ -25,7 +25,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     /// constraints should occur within this method so that those\n     /// constraints can be properly localized!**\n     #[instrument(skip(self, op), level = \"trace\")]\n-    pub(super) fn fully_perform_op<R: fmt::Debug, Op>(\n+    pub(super) fn fully_perform_op<R, Op>(\n         &mut self,\n         locations: Locations,\n         category: ConstraintCategory<'tcx>,\n@@ -39,8 +39,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n         let TypeOpOutput { output, constraints, error_info } = op.fully_perform(self.infcx)?;\n \n-        debug!(?output, ?constraints);\n-\n         if let Some(data) = constraints {\n             self.push_region_constraints(locations, category, data);\n         }"}, {"sha": "9fab7ad914a847118c4d0a4abf067707141d4f06", "filename": "compiler/rustc_borrowck/src/type_check/constraint_conversion.rs", "status": "modified", "additions": 9, "deletions": 22, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs?ref=92b759f517d57b092178a6d6cbadc7856263d910", "patch": "@@ -86,7 +86,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         }\n     }\n \n-    fn convert(&mut self, query_constraint: &QueryOutlivesConstraint<'tcx>) {\n+    pub(super) fn convert(&mut self, query_constraint: &QueryOutlivesConstraint<'tcx>) {\n         debug!(\"generate: constraints at: {:#?}\", self.locations);\n \n         // Extract out various useful fields we'll need below.\n@@ -98,18 +98,15 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         // region constraints like `for<'a> 'a: 'b`. At some point\n         // when we move to universes, we will, and this assertion\n         // will start to fail.\n-        let ty::OutlivesPredicate(k1, r2) =\n-            query_constraint.0.no_bound_vars().unwrap_or_else(|| {\n-                bug!(\"query_constraint {:?} contained bound vars\", query_constraint,);\n-            });\n-\n-        let constraint_category = query_constraint.1;\n+        let ty::OutlivesPredicate(k1, r2) = query_constraint.no_bound_vars().unwrap_or_else(|| {\n+            bug!(\"query_constraint {:?} contained bound vars\", query_constraint,);\n+        });\n \n         match k1.unpack() {\n             GenericArgKind::Lifetime(r1) => {\n                 let r1_vid = self.to_region_vid(r1);\n                 let r2_vid = self.to_region_vid(r2);\n-                self.add_outlives(r1_vid, r2_vid, constraint_category);\n+                self.add_outlives(r1_vid, r2_vid);\n             }\n \n             GenericArgKind::Type(t1) => {\n@@ -124,7 +121,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n                     Some(implicit_region_bound),\n                     param_env,\n                 )\n-                .type_must_outlive(origin, t1, r2, constraint_category);\n+                .type_must_outlive(origin, t1, r2);\n             }\n \n             GenericArgKind::Const(_) => {\n@@ -171,19 +168,10 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         }\n     }\n \n-    fn add_outlives(\n-        &mut self,\n-        sup: ty::RegionVid,\n-        sub: ty::RegionVid,\n-        category: ConstraintCategory<'tcx>,\n-    ) {\n-        let category = match self.category {\n-            ConstraintCategory::Boring | ConstraintCategory::BoringNoLocation => category,\n-            _ => self.category,\n-        };\n+    fn add_outlives(&mut self, sup: ty::RegionVid, sub: ty::RegionVid) {\n         self.constraints.outlives_constraints.push(OutlivesConstraint {\n             locations: self.locations,\n-            category,\n+            category: self.category,\n             span: self.span,\n             sub,\n             sup,\n@@ -203,11 +191,10 @@ impl<'a, 'b, 'tcx> TypeOutlivesDelegate<'tcx> for &'a mut ConstraintConversion<'\n         _origin: SubregionOrigin<'tcx>,\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n-        constraint_category: ConstraintCategory<'tcx>,\n     ) {\n         let b = self.to_region_vid(b);\n         let a = self.to_region_vid(a);\n-        self.add_outlives(b, a, constraint_category);\n+        self.add_outlives(b, a);\n     }\n \n     fn push_verify("}, {"sha": "d2a54df10b5714d5dbff65714f90dffe805c7286", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=92b759f517d57b092178a6d6cbadc7856263d910", "patch": "@@ -2591,7 +2591,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 .enumerate()\n                 .filter_map(|(idx, constraint)| {\n                     let ty::OutlivesPredicate(k1, r2) =\n-                        constraint.0.no_bound_vars().unwrap_or_else(|| {\n+                        constraint.no_bound_vars().unwrap_or_else(|| {\n                             bug!(\"query_constraint {:?} contained bound vars\", constraint,);\n                         });\n "}, {"sha": "2899b8304bc14884338564a480a2ffc54cdaec05", "filename": "compiler/rustc_error_messages/locales/en-US/infer.ftl", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl?ref=92b759f517d57b092178a6d6cbadc7856263d910", "patch": "@@ -110,7 +110,6 @@ infer_relate_param_bound = ...so that the type `{$name}` will meet its required\n infer_relate_param_bound_2 = ...that is required by this bound\n infer_relate_region_param_bound = ...so that the declared lifetime parameter bounds are satisfied\n infer_compare_impl_item_obligation = ...so that the definition in impl matches the definition from the trait\n-infer_ascribe_user_type_prove_predicate = ...so that the where clause holds\n \n infer_nothing = {\"\"}\n "}, {"sha": "64c759f73d410323cc08d6eeb8c688c5b5d7942f", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 28, "deletions": 40, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=92b759f517d57b092178a6d6cbadc7856263d910", "patch": "@@ -22,7 +22,6 @@ use rustc_data_structures::captures::Captures;\n use rustc_index::vec::Idx;\n use rustc_index::vec::IndexVec;\n use rustc_middle::arena::ArenaAllocatable;\n-use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::relate::TypeRelation;\n@@ -130,9 +129,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         let region_constraints = self.with_region_constraints(|region_constraints| {\n             make_query_region_constraints(\n                 tcx,\n-                region_obligations\n-                    .iter()\n-                    .map(|r_o| (r_o.sup_type, r_o.sub_region, r_o.origin.to_constraint_category())),\n+                region_obligations.iter().map(|r_o| (r_o.sup_type, r_o.sub_region)),\n                 region_constraints,\n             )\n         });\n@@ -251,8 +248,6 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         // the original values `v_o` that was canonicalized into a\n         // variable...\n \n-        let constraint_category = cause.to_constraint_category();\n-\n         for (index, original_value) in original_values.var_values.iter().enumerate() {\n             // ...with the value `v_r` of that variable from the query.\n             let result_value = query_response.substitute_projected(self.tcx, &result_subst, |v| {\n@@ -268,14 +263,12 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 (GenericArgKind::Lifetime(v_o), GenericArgKind::Lifetime(v_r)) => {\n                     // To make `v_o = v_r`, we emit `v_o: v_r` and `v_r: v_o`.\n                     if v_o != v_r {\n-                        output_query_region_constraints.outlives.push((\n-                            ty::Binder::dummy(ty::OutlivesPredicate(v_o.into(), v_r)),\n-                            constraint_category,\n-                        ));\n-                        output_query_region_constraints.outlives.push((\n-                            ty::Binder::dummy(ty::OutlivesPredicate(v_r.into(), v_o)),\n-                            constraint_category,\n-                        ));\n+                        output_query_region_constraints\n+                            .outlives\n+                            .push(ty::Binder::dummy(ty::OutlivesPredicate(v_o.into(), v_r)));\n+                        output_query_region_constraints\n+                            .outlives\n+                            .push(ty::Binder::dummy(ty::OutlivesPredicate(v_r.into(), v_o)));\n                     }\n                 }\n \n@@ -321,7 +314,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 // Screen out `'a: 'a` cases -- we skip the binder here but\n                 // only compare the inner values to one another, so they are still at\n                 // consistent binding levels.\n-                let ty::OutlivesPredicate(k1, r2) = r_c.0.skip_binder();\n+                let ty::OutlivesPredicate(k1, r2) = r_c.skip_binder();\n                 if k1 != r2.into() { Some(r_c) } else { None }\n             }),\n         );\n@@ -566,7 +559,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         cause: ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Obligation<'tcx, ty::Predicate<'tcx>> {\n-        let ty::OutlivesPredicate(k1, r2) = predicate.0.skip_binder();\n+        let ty::OutlivesPredicate(k1, r2) = predicate.skip_binder();\n \n         let atom = match k1.unpack() {\n             GenericArgKind::Lifetime(r1) => {\n@@ -581,7 +574,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 span_bug!(cause.span, \"unexpected const outlives {:?}\", predicate);\n             }\n         };\n-        let predicate = predicate.0.rebind(atom).to_predicate(self.tcx);\n+        let predicate = predicate.rebind(atom).to_predicate(self.tcx);\n \n         Obligation::new(cause, param_env, predicate)\n     }\n@@ -632,7 +625,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n /// creates query region constraints.\n pub fn make_query_region_constraints<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    outlives_obligations: impl Iterator<Item = (Ty<'tcx>, ty::Region<'tcx>, ConstraintCategory<'tcx>)>,\n+    outlives_obligations: impl Iterator<Item = (Ty<'tcx>, ty::Region<'tcx>)>,\n     region_constraints: &RegionConstraintData<'tcx>,\n ) -> QueryRegionConstraints<'tcx> {\n     let RegionConstraintData { constraints, verifys, givens, member_constraints } =\n@@ -645,31 +638,26 @@ pub fn make_query_region_constraints<'tcx>(\n \n     let outlives: Vec<_> = constraints\n         .iter()\n-        .map(|(k, origin)| {\n-            // no bound vars in the code above\n-            let constraint = ty::Binder::dummy(match *k {\n-                // Swap regions because we are going from sub (<=) to outlives\n-                // (>=).\n-                Constraint::VarSubVar(v1, v2) => ty::OutlivesPredicate(\n-                    tcx.mk_region(ty::ReVar(v2)).into(),\n-                    tcx.mk_region(ty::ReVar(v1)),\n-                ),\n-                Constraint::VarSubReg(v1, r2) => {\n-                    ty::OutlivesPredicate(r2.into(), tcx.mk_region(ty::ReVar(v1)))\n-                }\n-                Constraint::RegSubVar(r1, v2) => {\n-                    ty::OutlivesPredicate(tcx.mk_region(ty::ReVar(v2)).into(), r1)\n-                }\n-                Constraint::RegSubReg(r1, r2) => ty::OutlivesPredicate(r2.into(), r1),\n-            });\n-            (constraint, origin.to_constraint_category())\n+        .map(|(k, _)| match *k {\n+            // Swap regions because we are going from sub (<=) to outlives\n+            // (>=).\n+            Constraint::VarSubVar(v1, v2) => ty::OutlivesPredicate(\n+                tcx.mk_region(ty::ReVar(v2)).into(),\n+                tcx.mk_region(ty::ReVar(v1)),\n+            ),\n+            Constraint::VarSubReg(v1, r2) => {\n+                ty::OutlivesPredicate(r2.into(), tcx.mk_region(ty::ReVar(v1)))\n+            }\n+            Constraint::RegSubVar(r1, v2) => {\n+                ty::OutlivesPredicate(tcx.mk_region(ty::ReVar(v2)).into(), r1)\n+            }\n+            Constraint::RegSubReg(r1, r2) => ty::OutlivesPredicate(r2.into(), r1),\n         })\n+        .map(ty::Binder::dummy) // no bound vars in the code above\n         .chain(\n             outlives_obligations\n-                // no bound vars in the code above\n-                .map(|(ty, r, constraint_category)| {\n-                    (ty::Binder::dummy(ty::OutlivesPredicate(ty.into(), r)), constraint_category)\n-                }),\n+                .map(|(ty, r)| ty::OutlivesPredicate(ty.into(), r))\n+                .map(ty::Binder::dummy), // no bound vars in the code above\n         )\n         .collect();\n "}, {"sha": "cffdf56bb6d48f78a28eb2856b4a9816e3386a39", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=92b759f517d57b092178a6d6cbadc7856263d910", "patch": "@@ -77,13 +77,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             infer::CheckAssociatedTypeBounds { ref parent, .. } => {\n                 self.note_region_origin(err, &parent);\n             }\n-            infer::AscribeUserTypeProvePredicate(span) => {\n-                RegionOriginNote::Plain {\n-                    span,\n-                    msg: fluent::infer::ascribe_user_type_prove_predicate,\n-                }\n-                .add_to_diagnostic(err);\n-            }\n         }\n     }\n \n@@ -363,27 +356,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n                 err\n             }\n-            infer::AscribeUserTypeProvePredicate(span) => {\n-                let mut err =\n-                    struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"lifetime instantiated with \",\n-                    sup,\n-                    \"\",\n-                    None,\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"but lifetime must outlive \",\n-                    sub,\n-                    \"\",\n-                    None,\n-                );\n-                err\n-            }\n         }\n     }\n "}, {"sha": "bbbc044b85a48e7f17a899116691a99e36e816d4", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=92b759f517d57b092178a6d6cbadc7856263d910", "patch": "@@ -20,7 +20,6 @@ use rustc_middle::infer::canonical::{Canonical, CanonicalVarValues};\n use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind, ToType};\n use rustc_middle::mir::interpret::{ErrorHandled, EvalToValTreeResult};\n-use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::traits::select;\n use rustc_middle::ty::abstract_const::{AbstractConst, FailureKind};\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n@@ -409,36 +408,20 @@ pub enum SubregionOrigin<'tcx> {\n \n     /// Comparing the signature and requirements of an impl method against\n     /// the containing trait.\n-    CompareImplItemObligation {\n-        span: Span,\n-        impl_item_def_id: LocalDefId,\n-        trait_item_def_id: DefId,\n-    },\n+    CompareImplItemObligation { span: Span, impl_item_def_id: LocalDefId, trait_item_def_id: DefId },\n \n     /// Checking that the bounds of a trait's associated type hold for a given impl\n     CheckAssociatedTypeBounds {\n         parent: Box<SubregionOrigin<'tcx>>,\n         impl_item_def_id: LocalDefId,\n         trait_item_def_id: DefId,\n     },\n-\n-    AscribeUserTypeProvePredicate(Span),\n }\n \n // `SubregionOrigin` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n static_assert_size!(SubregionOrigin<'_>, 32);\n \n-impl<'tcx> SubregionOrigin<'tcx> {\n-    pub fn to_constraint_category(&self) -> ConstraintCategory<'tcx> {\n-        match self {\n-            Self::Subtype(type_trace) => type_trace.cause.to_constraint_category(),\n-            Self::AscribeUserTypeProvePredicate(span) => ConstraintCategory::Predicate(*span),\n-            _ => ConstraintCategory::BoringNoLocation,\n-        }\n-    }\n-}\n-\n /// Times when we replace late-bound regions with variables:\n #[derive(Clone, Copy, Debug)]\n pub enum LateBoundRegionConversionTime {\n@@ -2008,7 +1991,6 @@ impl<'tcx> SubregionOrigin<'tcx> {\n             DataBorrowed(_, a) => a,\n             ReferenceOutlivesReferent(_, a) => a,\n             CompareImplItemObligation { span, .. } => span,\n-            AscribeUserTypeProvePredicate(span) => span,\n             CheckAssociatedTypeBounds { ref parent, .. } => parent.span(),\n         }\n     }\n@@ -2041,10 +2023,6 @@ impl<'tcx> SubregionOrigin<'tcx> {\n                 parent: Box::new(default()),\n             },\n \n-            traits::ObligationCauseCode::AscribeUserTypeProvePredicate(span) => {\n-                SubregionOrigin::AscribeUserTypeProvePredicate(span)\n-            }\n-\n             _ => default(),\n         }\n     }"}, {"sha": "74c8bd88d275dbfb79589c41d21eab3bd91d169b", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 7, "deletions": 24, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=92b759f517d57b092178a6d6cbadc7856263d910", "patch": "@@ -69,7 +69,6 @@ use crate::infer::{\n use crate::traits::{ObligationCause, ObligationCauseCode};\n use rustc_data_structures::undo_log::UndoLogs;\n use rustc_hir::def_id::LocalDefId;\n-use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, Region, Ty, TyCtxt, TypeVisitable};\n use smallvec::smallvec;\n@@ -164,8 +163,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n \n             let outlives =\n                 &mut TypeOutlives::new(self, self.tcx, &region_bound_pairs, None, param_env);\n-            let category = origin.to_constraint_category();\n-            outlives.type_must_outlive(origin, sup_type, sub_region, category);\n+            outlives.type_must_outlive(origin, sup_type, sub_region);\n         }\n     }\n \n@@ -209,7 +207,6 @@ pub trait TypeOutlivesDelegate<'tcx> {\n         origin: SubregionOrigin<'tcx>,\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n-        constraint_category: ConstraintCategory<'tcx>,\n     );\n \n     fn push_verify(\n@@ -258,27 +255,25 @@ where\n         origin: infer::SubregionOrigin<'tcx>,\n         ty: Ty<'tcx>,\n         region: ty::Region<'tcx>,\n-        category: ConstraintCategory<'tcx>,\n     ) {\n         assert!(!ty.has_escaping_bound_vars());\n \n         let mut components = smallvec![];\n         push_outlives_components(self.tcx, ty, &mut components);\n-        self.components_must_outlive(origin, &components, region, category);\n+        self.components_must_outlive(origin, &components, region);\n     }\n \n     fn components_must_outlive(\n         &mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n         components: &[Component<'tcx>],\n         region: ty::Region<'tcx>,\n-        category: ConstraintCategory<'tcx>,\n     ) {\n         for component in components.iter() {\n             let origin = origin.clone();\n             match component {\n                 Component::Region(region1) => {\n-                    self.delegate.push_sub_region_constraint(origin, region, *region1, category);\n+                    self.delegate.push_sub_region_constraint(origin, region, *region1);\n                 }\n                 Component::Param(param_ty) => {\n                     self.param_ty_must_outlive(origin, region, *param_ty);\n@@ -287,7 +282,7 @@ where\n                     self.projection_must_outlive(origin, region, *projection_ty);\n                 }\n                 Component::EscapingProjection(subcomponents) => {\n-                    self.components_must_outlive(origin, &subcomponents, region, category);\n+                    self.components_must_outlive(origin, &subcomponents, region);\n                 }\n                 Component::UnresolvedInferenceVariable(v) => {\n                     // ignore this, we presume it will yield an error\n@@ -397,20 +392,10 @@ where\n             for k in projection_ty.substs {\n                 match k.unpack() {\n                     GenericArgKind::Lifetime(lt) => {\n-                        self.delegate.push_sub_region_constraint(\n-                            origin.clone(),\n-                            region,\n-                            lt,\n-                            origin.to_constraint_category(),\n-                        );\n+                        self.delegate.push_sub_region_constraint(origin.clone(), region, lt);\n                     }\n                     GenericArgKind::Type(ty) => {\n-                        self.type_must_outlive(\n-                            origin.clone(),\n-                            ty,\n-                            region,\n-                            origin.to_constraint_category(),\n-                        );\n+                        self.type_must_outlive(origin.clone(), ty, region);\n                     }\n                     GenericArgKind::Const(_) => {\n                         // Const parameters don't impose constraints.\n@@ -448,8 +433,7 @@ where\n             let unique_bound = trait_bounds[0];\n             debug!(\"projection_must_outlive: unique trait bound = {:?}\", unique_bound);\n             debug!(\"projection_must_outlive: unique declared bound appears in trait ref\");\n-            let category = origin.to_constraint_category();\n-            self.delegate.push_sub_region_constraint(origin, region, unique_bound, category);\n+            self.delegate.push_sub_region_constraint(origin, region, unique_bound);\n             return;\n         }\n \n@@ -471,7 +455,6 @@ impl<'cx, 'tcx> TypeOutlivesDelegate<'tcx> for &'cx InferCtxt<'cx, 'tcx> {\n         origin: SubregionOrigin<'tcx>,\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n-        _constraint_category: ConstraintCategory<'tcx>,\n     ) {\n         self.sub_regions(origin, a, b)\n     }"}, {"sha": "6873785ace739c0130c4272662e9a71d5d4b1db9", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=92b759f517d57b092178a6d6cbadc7856263d910", "patch": "@@ -22,7 +22,6 @@\n //! [c]: https://rust-lang.github.io/chalk/book/canonical_queries/canonicalization.html\n \n use crate::infer::MemberConstraint;\n-use crate::mir::ConstraintCategory;\n use crate::ty::subst::GenericArg;\n use crate::ty::{self, BoundVar, List, Region, Ty, TyCtxt};\n use rustc_index::vec::IndexVec;\n@@ -302,10 +301,8 @@ impl<'tcx, V> Canonical<'tcx, V> {\n     }\n }\n \n-pub type QueryOutlivesConstraint<'tcx> = (\n-    ty::Binder<'tcx, ty::OutlivesPredicate<GenericArg<'tcx>, Region<'tcx>>>,\n-    ConstraintCategory<'tcx>,\n-);\n+pub type QueryOutlivesConstraint<'tcx> =\n+    ty::Binder<'tcx, ty::OutlivesPredicate<GenericArg<'tcx>, Region<'tcx>>>;\n \n TrivialTypeTraversalAndLiftImpls! {\n     for <'tcx> {"}, {"sha": "594c14a642ded51def3afe5ee4ae60cee3d3e345", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=92b759f517d57b092178a6d6cbadc7856263d910", "patch": "@@ -327,7 +327,7 @@ rustc_data_structures::static_assert_size!(ConstraintCategory<'_>, 16);\n ///\n /// See also `rustc_const_eval::borrow_check::constraints`.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash)]\n-#[derive(TyEncodable, TyDecodable, HashStable, Lift, TypeVisitable, TypeFoldable)]\n+#[derive(TyEncodable, TyDecodable, HashStable)]\n pub enum ConstraintCategory<'tcx> {\n     Return(ReturnConstraint),\n     Yield,\n@@ -369,7 +369,7 @@ pub enum ConstraintCategory<'tcx> {\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash)]\n-#[derive(TyEncodable, TyDecodable, HashStable, TypeVisitable, TypeFoldable)]\n+#[derive(TyEncodable, TyDecodable, HashStable)]\n pub enum ReturnConstraint {\n     Normal,\n     ClosureUpvar(Field),"}, {"sha": "a95e6a61854cf62757c58445809ac672aaee7aa2", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=92b759f517d57b092178a6d6cbadc7856263d910", "patch": "@@ -10,7 +10,6 @@ mod structural_impls;\n pub mod util;\n \n use crate::infer::canonical::Canonical;\n-use crate::mir::ConstraintCategory;\n use crate::ty::abstract_const::NotConstEvaluatable;\n use crate::ty::subst::SubstsRef;\n use crate::ty::{self, AdtKind, Ty, TyCtxt};\n@@ -184,16 +183,6 @@ impl<'tcx> ObligationCause<'tcx> {\n             variant(DerivedObligationCause { parent_trait_pred, parent_code: self.code }).into();\n         self\n     }\n-\n-    pub fn to_constraint_category(&self) -> ConstraintCategory<'tcx> {\n-        match self.code() {\n-            MatchImpl(cause, _) => cause.to_constraint_category(),\n-            AscribeUserTypeProvePredicate(predicate_span) => {\n-                ConstraintCategory::Predicate(*predicate_span)\n-            }\n-            _ => ConstraintCategory::BoringNoLocation,\n-        }\n-    }\n }\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n@@ -429,8 +418,6 @@ pub enum ObligationCauseCode<'tcx> {\n         is_lit: bool,\n         output_ty: Option<Ty<'tcx>>,\n     },\n-\n-    AscribeUserTypeProvePredicate(Span),\n }\n \n /// The 'location' at which we try to perform HIR-based wf checking."}, {"sha": "973cddbd179aa6f52ab689bc9a7227b9512b7751", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=92b759f517d57b092178a6d6cbadc7856263d910", "patch": "@@ -2256,8 +2256,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             | ObligationCauseCode::QuestionMark\n             | ObligationCauseCode::CheckAssociatedTypeBounds { .. }\n             | ObligationCauseCode::LetElse\n-            | ObligationCauseCode::BinOp { .. }\n-            | ObligationCauseCode::AscribeUserTypeProvePredicate(..) => {}\n+            | ObligationCauseCode::BinOp { .. } => {}\n             ObligationCauseCode::SliceOrArrayElem => {\n                 err.note(\"slice and array elements must have `Sized` type\");\n             }"}, {"sha": "f6e196e31414ccc64f54044256fcc90e64108328", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/custom.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=92b759f517d57b092178a6d6cbadc7856263d910", "patch": "@@ -23,7 +23,7 @@ impl<F, G> CustomTypeOp<F, G> {\n     }\n }\n \n-impl<'tcx, F, R: fmt::Debug, G> super::TypeOp<'tcx> for CustomTypeOp<F, G>\n+impl<'tcx, F, R, G> super::TypeOp<'tcx> for CustomTypeOp<F, G>\n where\n     F: for<'a, 'cx> FnOnce(&'a InferCtxt<'cx, 'tcx>) -> Fallible<InferOk<'tcx, R>>,\n     G: Fn() -> String,\n@@ -89,8 +89,8 @@ pub fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n         infcx.tcx,\n         region_obligations\n             .iter()\n-            .map(|r_o| (r_o.sup_type, r_o.sub_region, r_o.origin.to_constraint_category()))\n-            .map(|(ty, r, cc)| (infcx.resolve_vars_if_possible(ty), r, cc)),\n+            .map(|r_o| (r_o.sup_type, r_o.sub_region))\n+            .map(|(ty, r)| (infcx.resolve_vars_if_possible(ty), r)),\n         &region_constraint_data,\n     );\n "}, {"sha": "578e1d00cf9ef406ec4520f20555aa8f7a0c7297", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=92b759f517d57b092178a6d6cbadc7856263d910", "patch": "@@ -26,7 +26,7 @@ pub use rustc_middle::traits::query::type_op::*;\n /// extract out the resulting region constraints (or an error if it\n /// cannot be completed).\n pub trait TypeOp<'tcx>: Sized + fmt::Debug {\n-    type Output: fmt::Debug;\n+    type Output;\n     type ErrorInfo;\n \n     /// Processes the operation and all resulting obligations,"}, {"sha": "60e9b88107dd698a258c044d6042436bbdb9c74a", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=92b759f517d57b092178a6d6cbadc7856263d910", "patch": "@@ -3,7 +3,7 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::{DefiningAnchor, InferCtxt, TyCtxtInferExt};\n-use rustc_infer::traits::{ObligationCauseCode, TraitEngineExt as _};\n+use rustc_infer::traits::TraitEngineExt as _;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::{GenericArg, Subst, UserSelfTy, UserSubsts};\n use rustc_middle::ty::{\n@@ -22,7 +22,6 @@ use rustc_trait_selection::traits::query::type_op::subtype::Subtype;\n use rustc_trait_selection::traits::query::{Fallible, NoSolution};\n use rustc_trait_selection::traits::{Normalized, Obligation, ObligationCause, TraitEngine};\n use std::fmt;\n-use std::iter::zip;\n \n pub(crate) fn provide(p: &mut Providers) {\n     *p = Providers {\n@@ -62,15 +61,14 @@ pub fn type_op_ascribe_user_type_with_span<'a, 'tcx: 'a>(\n         mir_ty, def_id, user_substs\n     );\n \n-    let mut cx = AscribeUserTypeCx { infcx, param_env, span: span.unwrap_or(DUMMY_SP), fulfill_cx };\n-    cx.relate_mir_and_user_ty(mir_ty, def_id, user_substs)?;\n+    let mut cx = AscribeUserTypeCx { infcx, param_env, fulfill_cx };\n+    cx.relate_mir_and_user_ty(mir_ty, def_id, user_substs, span)?;\n     Ok(())\n }\n \n struct AscribeUserTypeCx<'me, 'tcx> {\n     infcx: &'me InferCtxt<'me, 'tcx>,\n     param_env: ParamEnv<'tcx>,\n-    span: Span,\n     fulfill_cx: &'me mut dyn TraitEngine<'tcx>,\n }\n \n@@ -81,7 +79,7 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n     {\n         self.infcx\n             .partially_normalize_associated_types_in(\n-                ObligationCause::misc(self.span, hir::CRATE_HIR_ID),\n+                ObligationCause::misc(DUMMY_SP, hir::CRATE_HIR_ID),\n                 self.param_env,\n                 value,\n             )\n@@ -93,13 +91,18 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n         T: ToTrace<'tcx>,\n     {\n         self.infcx\n-            .at(&ObligationCause::dummy_with_span(self.span), self.param_env)\n+            .at(&ObligationCause::dummy(), self.param_env)\n             .relate(a, variance, b)?\n             .into_value_registering_obligations(self.infcx, self.fulfill_cx);\n         Ok(())\n     }\n \n-    fn prove_predicate(&mut self, predicate: Predicate<'tcx>, cause: ObligationCause<'tcx>) {\n+    fn prove_predicate(&mut self, predicate: Predicate<'tcx>, span: Option<Span>) {\n+        let cause = if let Some(span) = span {\n+            ObligationCause::dummy_with_span(span)\n+        } else {\n+            ObligationCause::dummy()\n+        };\n         self.fulfill_cx.register_predicate_obligation(\n             self.infcx,\n             Obligation::new(cause, self.param_env, predicate),\n@@ -123,6 +126,7 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n         mir_ty: Ty<'tcx>,\n         def_id: DefId,\n         user_substs: UserSubsts<'tcx>,\n+        span: Option<Span>,\n     ) -> Result<(), NoSolution> {\n         let UserSubsts { user_self_ty, substs } = user_substs;\n         let tcx = self.tcx();\n@@ -141,20 +145,10 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n         // outlives\" error messages.\n         let instantiated_predicates =\n             self.tcx().predicates_of(def_id).instantiate(self.tcx(), substs);\n-\n-        let cause = ObligationCause::dummy_with_span(self.span);\n-\n         debug!(?instantiated_predicates);\n-        for (instantiated_predicate, predicate_span) in\n-            zip(instantiated_predicates.predicates, instantiated_predicates.spans)\n-        {\n-            let span = if self.span == DUMMY_SP { predicate_span } else { self.span };\n-            let cause = ObligationCause::new(\n-                span,\n-                hir::CRATE_HIR_ID,\n-                ObligationCauseCode::AscribeUserTypeProvePredicate(predicate_span),\n-            );\n-            self.prove_predicate(instantiated_predicate, cause);\n+        for instantiated_predicate in instantiated_predicates.predicates {\n+            let instantiated_predicate = self.normalize(instantiated_predicate);\n+            self.prove_predicate(instantiated_predicate, span);\n         }\n \n         if let Some(UserSelfTy { impl_def_id, self_ty }) = user_self_ty {\n@@ -167,7 +161,7 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n             self.prove_predicate(\n                 ty::Binder::dummy(ty::PredicateKind::WellFormed(impl_self_ty.into()))\n                     .to_predicate(self.tcx()),\n-                cause.clone(),\n+                span,\n             );\n         }\n \n@@ -184,7 +178,7 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n         // which...could happen with normalization...\n         self.prove_predicate(\n             ty::Binder::dummy(ty::PredicateKind::WellFormed(ty.into())).to_predicate(self.tcx()),\n-            cause,\n+            span,\n         );\n         Ok(())\n     }"}, {"sha": "bc644c694a078c0869ca3e72fdef48a1b1c9d0a0", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b759f517d57b092178a6d6cbadc7856263d910/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=92b759f517d57b092178a6d6cbadc7856263d910", "patch": "@@ -10,7 +10,6 @@ use rustc_hir::ItemKind;\n use rustc_infer::infer::outlives::env::{OutlivesEnvironment, RegionBoundPairs};\n use rustc_infer::infer::outlives::obligations::TypeOutlives;\n use rustc_infer::infer::{self, InferCtxt, TyCtxtInferExt};\n-use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts, Subst};\n use rustc_middle::ty::trait_def::TraitSpecializationKind;\n@@ -664,7 +663,7 @@ fn ty_known_to_outlive<'tcx>(\n     resolve_regions_with_wf_tys(tcx, id, param_env, &wf_tys, |infcx, region_bound_pairs| {\n         let origin = infer::RelateParamBound(DUMMY_SP, ty, None);\n         let outlives = &mut TypeOutlives::new(infcx, tcx, region_bound_pairs, None, param_env);\n-        outlives.type_must_outlive(origin, ty, region, ConstraintCategory::BoringNoLocation);\n+        outlives.type_must_outlive(origin, ty, region);\n     })\n }\n \n@@ -682,12 +681,7 @@ fn region_known_to_outlive<'tcx>(\n         use rustc_infer::infer::outlives::obligations::TypeOutlivesDelegate;\n         let origin = infer::RelateRegionParamBound(DUMMY_SP);\n         // `region_a: region_b` -> `region_b <= region_a`\n-        infcx.push_sub_region_constraint(\n-            origin,\n-            region_b,\n-            region_a,\n-            ConstraintCategory::BoringNoLocation,\n-        );\n+        infcx.push_sub_region_constraint(origin, region_b, region_a);\n     })\n }\n "}, {"sha": "719d1bd5a4c7dabf518cdb41e5718b511632d482", "filename": "src/test/ui/generic-associated-types/bugs/hrtb-implied-1.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bba514b7b4f3062139d17ce1e4ab26b396c8ad49/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba514b7b4f3062139d17ce1e4ab26b396c8ad49/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-1.rs?ref=bba514b7b4f3062139d17ce1e4ab26b396c8ad49", "patch": "@@ -1,35 +0,0 @@\n-// check-fail\n-// known-bug\n-\n-// This gives us problems because `for<'a> I::Item<'a>: Debug` should mean \"for\n-// all 'a where I::Item<'a> is WF\", but really means \"for all 'a possible\"\n-\n-use std::fmt::Debug;\n-\n-pub trait LendingIterator {\n-    type Item<'this>\n-    where\n-        Self: 'this;\n-}\n-\n-pub struct WindowsMut<'x> {\n-    slice: &'x (),\n-}\n-\n-impl<'y> LendingIterator for WindowsMut<'y> {\n-    type Item<'this> = &'this mut () where 'y: 'this;\n-}\n-\n-fn print_items<I>(_iter: I)\n-where\n-    I: LendingIterator,\n-    for<'a> I::Item<'a>: Debug,\n-{\n-}\n-\n-fn main() {\n-    let slice = &mut ();\n-    //~^ temporary value dropped while borrowed\n-    let windows = WindowsMut { slice };\n-    print_items::<WindowsMut<'_>>(windows);\n-}"}, {"sha": "414999881d4701cb5ab2a7e72b72e86ad1e7934a", "filename": "src/test/ui/generic-associated-types/bugs/hrtb-implied-1.stderr", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bba514b7b4f3062139d17ce1e4ab26b396c8ad49/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bba514b7b4f3062139d17ce1e4ab26b396c8ad49/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-1.stderr?ref=bba514b7b4f3062139d17ce1e4ab26b396c8ad49", "patch": "@@ -1,20 +0,0 @@\n-error[E0716]: temporary value dropped while borrowed\n-  --> $DIR/hrtb-implied-1.rs:31:22\n-   |\n-LL |     let slice = &mut ();\n-   |                      ^^ creates a temporary which is freed while still in use\n-...\n-LL |     print_items::<WindowsMut<'_>>(windows);\n-   |     -------------------------------------- argument requires that borrow lasts for `'static`\n-LL | }\n-   | - temporary value is freed at the end of this statement\n-   |\n-note: due to current limitations in the borrow checker, this implies a `'static` lifetime\n-  --> $DIR/hrtb-implied-1.rs:26:26\n-   |\n-LL |     for<'a> I::Item<'a>: Debug,\n-   |                          ^^^^^\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0716`."}, {"sha": "61009da49ffed8d5b5f0019b6f45c7865913a715", "filename": "src/test/ui/nll/local-outlives-static-via-hrtb.stderr", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/92b759f517d57b092178a6d6cbadc7856263d910/src%2Ftest%2Fui%2Fnll%2Flocal-outlives-static-via-hrtb.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/92b759f517d57b092178a6d6cbadc7856263d910/src%2Ftest%2Fui%2Fnll%2Flocal-outlives-static-via-hrtb.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Flocal-outlives-static-via-hrtb.stderr?ref=92b759f517d57b092178a6d6cbadc7856263d910", "patch": "@@ -9,12 +9,6 @@ LL |     assert_static_via_hrtb(&local);\n LL |     assert_static_via_hrtb_with_assoc_type(&&local);\n LL | }\n    | - `local` dropped here while still borrowed\n-   |\n-note: due to current limitations in the borrow checker, this implies a `'static` lifetime\n-  --> $DIR/local-outlives-static-via-hrtb.rs:15:53\n-   |\n-LL | fn assert_static_via_hrtb<G>(_: G) where for<'a> G: Outlives<'a> {}\n-   |                                                     ^^^^^^^^^^^^\n \n error[E0597]: `local` does not live long enough\n   --> $DIR/local-outlives-static-via-hrtb.rs:25:45\n@@ -26,12 +20,6 @@ LL |     assert_static_via_hrtb_with_assoc_type(&&local);\n    |     argument requires that `local` is borrowed for `'static`\n LL | }\n    | - `local` dropped here while still borrowed\n-   |\n-note: due to current limitations in the borrow checker, this implies a `'static` lifetime\n-  --> $DIR/local-outlives-static-via-hrtb.rs:19:20\n-   |\n-LL |     for<'a> &'a T: Reference<AssociatedType = &'a ()>,\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}]}