{"sha": "ff4ab9e147b0be4126b8b70ca6ab27173a46077a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmNGFiOWUxNDdiMGJlNDEyNmI4YjcwY2E2YWIyNzE3M2E0NjA3N2E=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-06-22T00:08:35Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-06-29T08:39:34Z"}, "message": "'Borrow' stack closures rather than copying them (e.g., \"|x|f(x)\"), in prep for making them noncopyable.", "tree": {"sha": "f028c640cd8a3efd7f8ec5661ba255d269250dbe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f028c640cd8a3efd7f8ec5661ba255d269250dbe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff4ab9e147b0be4126b8b70ca6ab27173a46077a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff4ab9e147b0be4126b8b70ca6ab27173a46077a", "html_url": "https://github.com/rust-lang/rust/commit/ff4ab9e147b0be4126b8b70ca6ab27173a46077a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89110fdf55c000096fc24a78d35256544c7b523f", "url": "https://api.github.com/repos/rust-lang/rust/commits/89110fdf55c000096fc24a78d35256544c7b523f", "html_url": "https://github.com/rust-lang/rust/commit/89110fdf55c000096fc24a78d35256544c7b523f"}], "stats": {"total": 219, "additions": 118, "deletions": 101}, "files": [{"sha": "5906e809c98561dc936d397f7b99248609704f0a", "filename": "src/libextra/fun_treemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibextra%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibextra%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffun_treemap.rs?ref=ff4ab9e147b0be4126b8b70ca6ab27173a46077a", "patch": "@@ -66,9 +66,9 @@ pub fn traverse<K, V: Copy>(m: Treemap<K, V>, f: &fn(&K, &V)) {\n         // matches to me, so I changed it. but that may be a\n         // de-optimization -- tjc\n         Node(@ref k, @ref v, left, right) => {\n-            traverse(left, f);\n+            traverse(left, |k,v| f(k,v));\n             f(k, v);\n-            traverse(right, f);\n+            traverse(right, |k,v| f(k,v));\n         }\n     }\n }"}, {"sha": "71393ff9fae20116358dec064bb67795b8e38805", "filename": "src/libextra/rope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibextra%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibextra%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frope.rs?ref=ff4ab9e147b0be4126b8b70ca6ab27173a46077a", "patch": "@@ -1078,7 +1078,7 @@ pub mod node {\n \n     pub fn loop_chars(node: @Node, it: &fn(c: char) -> bool) -> bool {\n         return loop_leaves(node,|leaf| {\n-            leaf.content.slice(leaf.byte_offset, leaf.byte_len).iter().all(it)\n+            leaf.content.slice(leaf.byte_offset, leaf.byte_len).iter().all(|c| it(c))\n         });\n     }\n \n@@ -1101,7 +1101,7 @@ pub mod node {\n         loop {\n             match (*current) {\n               Leaf(x) => return it(x),\n-              Concat(ref x) => if loop_leaves(x.left, it) { //non tail call\n+              Concat(ref x) => if loop_leaves(x.left, |l| it(l)) { //non tail call\n                 current = x.right;       //tail call\n               } else {\n                 return false;"}, {"sha": "10dbe2326d76236441cbca0283884a1627e949e5", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=ff4ab9e147b0be4126b8b70ca6ab27173a46077a", "patch": "@@ -42,7 +42,8 @@ pub fn merge_sort<T:Copy>(v: &[T], le: Le<T>) -> ~[T] {\n         let mid = v_len / 2 + begin;\n         let a = (begin, mid);\n         let b = (mid, end);\n-        return merge(le, merge_sort_(v, a, le), merge_sort_(v, b, le));\n+        return merge(|x,y| le(x,y), merge_sort_(v, a, |x,y| le(x,y)),\n+                                    merge_sort_(v, b, |x,y| le(x,y)));\n     }\n \n     fn merge<T:Copy>(le: Le<T>, a: &[T], b: &[T]) -> ~[T] {\n@@ -83,10 +84,10 @@ fn qsort<T>(arr: &mut [T], left: uint,\n             right: uint, compare_func: Le<T>) {\n     if right > left {\n         let pivot = (left + right) / 2u;\n-        let new_pivot = part::<T>(arr, left, right, pivot, compare_func);\n+        let new_pivot = part::<T>(arr, left, right, pivot, |x,y| compare_func(x,y));\n         if new_pivot != 0u {\n             // Need to do this check before recursing due to overflow\n-            qsort::<T>(arr, left, new_pivot - 1u, compare_func);\n+            qsort::<T>(arr, left, new_pivot - 1u, |x,y| compare_func(x,y));\n         }\n         qsort::<T>(arr, new_pivot + 1u, right, compare_func);\n     }"}, {"sha": "9c6be901d980a87e051d52e0d4065f50e2c41b67", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=ff4ab9e147b0be4126b8b70ca6ab27173a46077a", "patch": "@@ -563,7 +563,9 @@ impl RWlock {\n                 (&self.order_lock).acquire();\n                 do (&self.access_lock).access_waitqueue {\n                     (&self.order_lock).release();\n-                    task::rekillable(blk)\n+                    do task::rekillable {\n+                        blk()\n+                    }\n                 }\n             }\n         }\n@@ -1182,12 +1184,12 @@ mod tests {\n             Write => x.write(blk),\n             Downgrade =>\n                 do x.write_downgrade |mode| {\n-                    (&mode).write(blk);\n+                    do mode.write { blk() };\n                 },\n             DowngradeRead =>\n                 do x.write_downgrade |mode| {\n                     let mode = x.downgrade(mode);\n-                    (&mode).read(blk);\n+                    do mode.read { blk() };\n                 },\n         }\n     }\n@@ -1340,10 +1342,10 @@ mod tests {\n         fn lock_cond(x: &RWlock, downgrade: bool, blk: &fn(c: &Condvar)) {\n             if downgrade {\n                 do x.write_downgrade |mode| {\n-                    (&mode).write_cond(blk)\n+                    do mode.write_cond |c| { blk(c) }\n                 }\n             } else {\n-                x.write_cond(blk)\n+                do x.write_cond |c| { blk(c) }\n             }\n         }\n         let x = ~RWlock();"}, {"sha": "50ca96e6e21df12d77a8b6bd8685b7356d6ee4e1", "filename": "src/libextra/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=ff4ab9e147b0be4126b8b70ca6ab27173a46077a", "patch": "@@ -678,7 +678,7 @@ impl BenchHarness {\n \n         // Initial bench run to get ballpark figure.\n         let mut n = 1_u64;\n-        self.bench_n(n, f);\n+        self.bench_n(n, |x| f(x));\n \n         while n < 1_000_000_000 &&\n             self.ns_elapsed() < 1_000_000_000 {\n@@ -694,7 +694,7 @@ impl BenchHarness {\n \n             n = u64::max(u64::min(n+n/2, 100*last), last+1);\n             n = round_up(n);\n-            self.bench_n(n, f);\n+            self.bench_n(n, |x| f(x));\n         }\n     }\n \n@@ -714,7 +714,7 @@ impl BenchHarness {\n                                             magnitude * 2);\n \n             let samples = do vec::from_fn(n_samples) |_| {\n-                self.bench_n(n_iter as u64, f);\n+                self.bench_n(n_iter as u64, |x| f(x));\n                 self.ns_per_iter() as f64\n             };\n "}, {"sha": "d546b48f81751de633212096e320690c376d9b8a", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=ff4ab9e147b0be4126b8b70ca6ab27173a46077a", "patch": "@@ -511,14 +511,14 @@ impl<K: TotalOrd, V> TreeNode<K, V> {\n \n fn each<'r, K: TotalOrd, V>(node: &'r Option<~TreeNode<K, V>>,\n                             f: &fn(&'r K, &'r V) -> bool) -> bool {\n-    node.iter().advance(|x| each(&x.left, f) && f(&x.key, &x.value) &&\n-                            each(&x.right, f))\n+    node.iter().advance(|x| each(&x.left,  |k,v| f(k,v)) && f(&x.key, &x.value) &&\n+                            each(&x.right, |k,v| f(k,v)))\n }\n \n fn each_reverse<'r, K: TotalOrd, V>(node: &'r Option<~TreeNode<K, V>>,\n                                     f: &fn(&'r K, &'r V) -> bool) -> bool {\n-    node.iter().advance(|x| each_reverse(&x.right, f) && f(&x.key, &x.value) &&\n-                            each_reverse(&x.left, f))\n+    node.iter().advance(|x| each_reverse(&x.right, |k,v| f(k,v)) && f(&x.key, &x.value) &&\n+                            each_reverse(&x.left,  |k,v| f(k,v)))\n }\n \n fn mutate_values<'r, K: TotalOrd, V>(node: &'r mut Option<~TreeNode<K, V>>,\n@@ -527,9 +527,9 @@ fn mutate_values<'r, K: TotalOrd, V>(node: &'r mut Option<~TreeNode<K, V>>,\n     match *node {\n       Some(~TreeNode{key: ref key, value: ref mut value, left: ref mut left,\n                      right: ref mut right, _}) => {\n-        if !mutate_values(left, f) { return false }\n+        if !mutate_values(left,  |k,v| f(k,v)) { return false }\n         if !f(key, value) { return false }\n-        if !mutate_values(right, f) { return false }\n+        if !mutate_values(right, |k,v| f(k,v)) { return false }\n       }\n       None => return false\n     }"}, {"sha": "4d4f3c3a49b0141bf6e15b71662be6ffdefa6de7", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=ff4ab9e147b0be4126b8b70ca6ab27173a46077a", "patch": "@@ -107,7 +107,7 @@ struct WorkKey {\n impl to_bytes::IterBytes for WorkKey {\n     #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.kind.iter_bytes(lsb0, f) && self.name.iter_bytes(lsb0, f)\n+        self.kind.iter_bytes(lsb0, |b| f(b)) && self.name.iter_bytes(lsb0, |b| f(b))\n     }\n }\n "}, {"sha": "abfb5f7d4d4bf5369abf37f88616133bb9997715", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=ff4ab9e147b0be4126b8b70ca6ab27173a46077a", "patch": "@@ -48,7 +48,7 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n             debug!(\"filesearch: searching additional lib search paths [%?]\",\n                    self.addl_lib_search_paths.len());\n             // a little weird\n-            self.addl_lib_search_paths.iter().advance(f);\n+            self.addl_lib_search_paths.iter().advance(|path| f(path));\n \n             debug!(\"filesearch: searching target lib path\");\n             if !f(&make_target_lib_path(self.sysroot,"}, {"sha": "22786581073443b1bd7503dd197000a1dd16e861", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=ff4ab9e147b0be4126b8b70ca6ab27173a46077a", "patch": "@@ -189,11 +189,11 @@ fn parse_trait_store(st: &mut PState) -> ty::TraitStore {\n fn parse_substs(st: &mut PState, conv: conv_did) -> ty::substs {\n     let self_r = parse_opt(st, |st| parse_region(st) );\n \n-    let self_ty = parse_opt(st, |st| parse_ty(st, conv) );\n+    let self_ty = parse_opt(st, |st| parse_ty(st, |x,y| conv(x,y)) );\n \n     assert_eq!(next(st), '[');\n     let mut params: ~[ty::t] = ~[];\n-    while peek(st) != ']' { params.push(parse_ty(st, conv)); }\n+    while peek(st) != ']' { params.push(parse_ty(st, |x,y| conv(x,y))); }\n     st.pos = st.pos + 1u;\n \n     return ty::substs {\n@@ -270,8 +270,8 @@ fn parse_str(st: &mut PState, term: char) -> ~str {\n }\n \n fn parse_trait_ref(st: &mut PState, conv: conv_did) -> ty::TraitRef {\n-    let def = parse_def(st, NominalType, conv);\n-    let substs = parse_substs(st, conv);\n+    let def = parse_def(st, NominalType, |x,y| conv(x,y));\n+    let substs = parse_substs(st, |x,y| conv(x,y));\n     ty::TraitRef {def_id: def, substs: substs}\n }\n \n@@ -301,18 +301,18 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n       'c' => return ty::mk_char(),\n       't' => {\n         assert_eq!(next(st), '[');\n-        let def = parse_def(st, NominalType, conv);\n-        let substs = parse_substs(st, conv);\n+        let def = parse_def(st, NominalType, |x,y| conv(x,y));\n+        let substs = parse_substs(st, |x,y| conv(x,y));\n         assert_eq!(next(st), ']');\n         return ty::mk_enum(st.tcx, def, substs);\n       }\n       'x' => {\n         assert_eq!(next(st), '[');\n-        let def = parse_def(st, NominalType, conv);\n-        let substs = parse_substs(st, conv);\n+        let def = parse_def(st, NominalType, |x,y| conv(x,y));\n+        let substs = parse_substs(st, |x,y| conv(x,y));\n         let store = parse_trait_store(st);\n         let mt = parse_mutability(st);\n-        let bounds = parse_bounds(st, conv);\n+        let bounds = parse_bounds(st, |x,y| conv(x,y));\n         assert_eq!(next(st), ']');\n         return ty::mk_trait(st.tcx, def, substs, store, mt, bounds.builtin_bounds);\n       }\n@@ -346,7 +346,7 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n       'T' => {\n         assert_eq!(next(st), '[');\n         let mut params = ~[];\n-        while peek(st) != ']' { params.push(parse_ty(st, conv)); }\n+        while peek(st) != ']' { params.push(parse_ty(st, |x,y| conv(x,y))); }\n         st.pos = st.pos + 1u;\n         return ty::mk_tup(st.tcx, params);\n       }\n@@ -380,15 +380,15 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n         }\n       }\n       '\"' => {\n-        let _ = parse_def(st, TypeWithId, conv);\n-        let inner = parse_ty(st, conv);\n+        let _ = parse_def(st, TypeWithId, |x,y| conv(x,y));\n+        let inner = parse_ty(st, |x,y| conv(x,y));\n         inner\n       }\n       'B' => ty::mk_opaque_box(st.tcx),\n       'a' => {\n           assert_eq!(next(st), '[');\n-          let did = parse_def(st, NominalType, conv);\n-          let substs = parse_substs(st, conv);\n+          let did = parse_def(st, NominalType, |x,y| conv(x,y));\n+          let substs = parse_substs(st, |x,y| conv(x,y));\n           assert_eq!(next(st), ']');\n           return ty::mk_struct(st.tcx, did, substs);\n       }\n@@ -473,8 +473,8 @@ fn parse_closure_ty(st: &mut PState, conv: conv_did) -> ty::ClosureTy {\n     let purity = parse_purity(next(st));\n     let onceness = parse_onceness(next(st));\n     let region = parse_region(st);\n-    let bounds = parse_bounds(st, conv);\n-    let sig = parse_sig(st, conv);\n+    let bounds = parse_bounds(st, |x,y| conv(x,y));\n+    let sig = parse_sig(st, |x,y| conv(x,y));\n     ty::ClosureTy {\n         purity: purity,\n         sigil: sigil,\n@@ -500,7 +500,7 @@ fn parse_sig(st: &mut PState, conv: conv_did) -> ty::FnSig {\n     assert_eq!(next(st), '[');\n     let mut inputs = ~[];\n     while peek(st) != ']' {\n-        inputs.push(parse_ty(st, conv));\n+        inputs.push(parse_ty(st, |x,y| conv(x,y)));\n     }\n     st.pos += 1u; // eat the ']'\n     let ret_ty = parse_ty(st, conv);\n@@ -544,8 +544,8 @@ pub fn parse_type_param_def_data(data: &[u8], start: uint,\n }\n \n fn parse_type_param_def(st: &mut PState, conv: conv_did) -> ty::TypeParameterDef {\n-    ty::TypeParameterDef {def_id: parse_def(st, NominalType, conv),\n-                          bounds: @parse_bounds(st, conv)}\n+    ty::TypeParameterDef {def_id: parse_def(st, NominalType, |x,y| conv(x,y)),\n+                          bounds: @parse_bounds(st, |x,y| conv(x,y))}\n }\n \n fn parse_bounds(st: &mut PState, conv: conv_did) -> ty::ParamBounds {\n@@ -571,7 +571,7 @@ fn parse_bounds(st: &mut PState, conv: conv_did) -> ty::ParamBounds {\n                 param_bounds.builtin_bounds.add(ty::BoundSized);\n             }\n             'I' => {\n-                param_bounds.trait_bounds.push(@parse_trait_ref(st, conv));\n+                param_bounds.trait_bounds.push(@parse_trait_ref(st, |x,y| conv(x,y)));\n             }\n             '.' => {\n                 return param_bounds;"}, {"sha": "623dbbd61b244cf1971fa4984fb95e3dca3f3d88", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=ff4ab9e147b0be4126b8b70ca6ab27173a46077a", "patch": "@@ -411,7 +411,7 @@ impl MoveData {\n \n         let mut p = self.path(index).first_child;\n         while p != InvalidMovePathIndex {\n-            if !self.each_extending_path(p, f) {\n+            if !self.each_extending_path(p, |x| f(x)) {\n                 return false;\n             }\n             p = self.path(p).next_sibling;"}, {"sha": "a2907e9912092ff8a2ac53463d6a6d67ca0e3bb3", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=ff4ab9e147b0be4126b8b70ca6ab27173a46077a", "patch": "@@ -890,7 +890,7 @@ impl mem_categorization_ctxt {\n                                 pat, downcast_cmt, subpat_ty,\n                                 InteriorField(PositionalField(i)));\n \n-                        self.cat_pattern(subcmt, subpat, op);\n+                        self.cat_pattern(subcmt, subpat, |x,y| op(x,y));\n                     }\n                 }\n                 Some(&ast::def_fn(*)) |\n@@ -901,12 +901,12 @@ impl mem_categorization_ctxt {\n                             self.cat_imm_interior(\n                                 pat, cmt, subpat_ty,\n                                 InteriorField(PositionalField(i)));\n-                        self.cat_pattern(cmt_field, subpat, op);\n+                        self.cat_pattern(cmt_field, subpat, |x,y| op(x,y));\n                     }\n                 }\n                 Some(&ast::def_static(*)) => {\n                     for subpats.iter().advance |&subpat| {\n-                        self.cat_pattern(cmt, subpat, op);\n+                        self.cat_pattern(cmt, subpat, |x,y| op(x,y));\n                     }\n                 }\n                 _ => {\n@@ -930,7 +930,7 @@ impl mem_categorization_ctxt {\n             for field_pats.iter().advance |fp| {\n                 let field_ty = self.pat_ty(fp.pat); // see (*)\n                 let cmt_field = self.cat_field(pat, cmt, fp.ident, field_ty);\n-                self.cat_pattern(cmt_field, fp.pat, op);\n+                self.cat_pattern(cmt_field, fp.pat, |x,y| op(x,y));\n             }\n           }\n \n@@ -942,7 +942,7 @@ impl mem_categorization_ctxt {\n                     self.cat_imm_interior(\n                         pat, cmt, subpat_ty,\n                         InteriorField(PositionalField(i)));\n-                self.cat_pattern(subcmt, subpat, op);\n+                self.cat_pattern(subcmt, subpat, |x,y| op(x,y));\n             }\n           }\n \n@@ -956,15 +956,15 @@ impl mem_categorization_ctxt {\n           ast::pat_vec(ref before, slice, ref after) => {\n               let elt_cmt = self.cat_index(pat, cmt, 0);\n               for before.iter().advance |&before_pat| {\n-                  self.cat_pattern(elt_cmt, before_pat, op);\n+                  self.cat_pattern(elt_cmt, before_pat, |x,y| op(x,y));\n               }\n               for slice.iter().advance |&slice_pat| {\n                   let slice_ty = self.pat_ty(slice_pat);\n                   let slice_cmt = self.cat_rvalue(pat, slice_ty);\n-                  self.cat_pattern(slice_cmt, slice_pat, op);\n+                  self.cat_pattern(slice_cmt, slice_pat, |x,y| op(x,y));\n               }\n               for after.iter().advance |&after_pat| {\n-                  self.cat_pattern(elt_cmt, after_pat, op);\n+                  self.cat_pattern(elt_cmt, after_pat, |x,y| op(x,y));\n               }\n           }\n "}, {"sha": "d9fea12134684b98b135cf3b4d0e88c6bde1298d", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=ff4ab9e147b0be4126b8b70ca6ab27173a46077a", "patch": "@@ -674,7 +674,7 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n                                     int::to_str(variant.disr_val));\n                       let variant_cx =\n                           iter_variant(variant_cx, repr, av, *variant,\n-                                       substs.tps, f);\n+                                       substs.tps, |x,y,z| f(x,y,z));\n                       match adt::trans_case(cx, repr, variant.disr_val) {\n                           _match::single_result(r) => {\n                               AddCase(llswitch, r.val, variant_cx.llbb)"}, {"sha": "9f9127663af78dab2037713d695de129e1147360", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=ff4ab9e147b0be4126b8b70ca6ab27173a46077a", "patch": "@@ -1241,15 +1241,15 @@ pub fn maybe_walk_ty(ty: t, f: &fn(t) -> bool) {\n       }\n       ty_enum(_, ref substs) | ty_struct(_, ref substs) |\n       ty_trait(_, ref substs, _, _, _) => {\n-        for (*substs).tps.iter().advance |subty| { maybe_walk_ty(*subty, f); }\n+        for (*substs).tps.iter().advance |subty| { maybe_walk_ty(*subty, |x| f(x)); }\n       }\n-      ty_tup(ref ts) => { for ts.iter().advance |tt| { maybe_walk_ty(*tt, f); } }\n+      ty_tup(ref ts) => { for ts.iter().advance |tt| { maybe_walk_ty(*tt, |x| f(x)); } }\n       ty_bare_fn(ref ft) => {\n-        for ft.sig.inputs.iter().advance |a| { maybe_walk_ty(*a, f); }\n+        for ft.sig.inputs.iter().advance |a| { maybe_walk_ty(*a, |x| f(x)); }\n         maybe_walk_ty(ft.sig.output, f);\n       }\n       ty_closure(ref ft) => {\n-        for ft.sig.inputs.iter().advance |a| { maybe_walk_ty(*a, f); }\n+        for ft.sig.inputs.iter().advance |a| { maybe_walk_ty(*a, |x| f(x)); }\n         maybe_walk_ty(ft.sig.output, f);\n       }\n     }\n@@ -1331,7 +1331,7 @@ fn fold_sty(sty: &sty, fldop: &fn(t) -> t) -> sty {\n \n // Folds types from the bottom up.\n pub fn fold_ty(cx: ctxt, t0: t, fldop: &fn(t) -> t) -> t {\n-    let sty = fold_sty(&get(t0).sty, |t| fold_ty(cx, fldop(t), fldop));\n+    let sty = fold_sty(&get(t0).sty, |t| fold_ty(cx, fldop(t), |t| fldop(t)));\n     fldop(mk_t(cx, sty))\n }\n \n@@ -1345,8 +1345,8 @@ pub fn walk_regions_and_ty(\n         fold_regions_and_ty(\n             cx, ty,\n             |r| { walkr(r); r },\n-            |t| { walk_regions_and_ty(cx, t, walkr, walkt); t },\n-            |t| { walk_regions_and_ty(cx, t, walkr, walkt); t });\n+            |t| { walk_regions_and_ty(cx, t, |r| walkr(r), |t| walkt(t)); t },\n+            |t| { walk_regions_and_ty(cx, t, |r| walkr(r), |t| walkt(t)); t });\n     }\n }\n \n@@ -1426,8 +1426,8 @@ pub fn fold_regions(\n         fold_regions_and_ty(\n             cx, ty,\n             |r| fldr(r, in_fn),\n-            |t| do_fold(cx, t, true, fldr),\n-            |t| do_fold(cx, t, in_fn, fldr))\n+            |t| do_fold(cx, t, true,  |r,b| fldr(r,b)),\n+            |t| do_fold(cx, t, in_fn, |r,b| fldr(r,b)))\n     }\n     do_fold(cx, ty, false, fldr)\n }\n@@ -2374,7 +2374,7 @@ pub fn type_structurally_contains(cx: ctxt,\n         for (*enum_variants(cx, did)).iter().advance |variant| {\n             for variant.args.iter().advance |aty| {\n                 let sty = subst(cx, substs, *aty);\n-                if type_structurally_contains(cx, sty, test) { return true; }\n+                if type_structurally_contains(cx, sty, |x| test(x)) { return true; }\n             }\n         }\n         return false;\n@@ -2383,14 +2383,14 @@ pub fn type_structurally_contains(cx: ctxt,\n         let r = lookup_struct_fields(cx, did);\n         for r.iter().advance |field| {\n             let ft = lookup_field_type(cx, did, field.id, substs);\n-            if type_structurally_contains(cx, ft, test) { return true; }\n+            if type_structurally_contains(cx, ft, |x| test(x)) { return true; }\n         }\n         return false;\n       }\n \n       ty_tup(ref ts) => {\n         for ts.iter().advance |tt| {\n-            if type_structurally_contains(cx, *tt, test) { return true; }\n+            if type_structurally_contains(cx, *tt, |x| test(x)) { return true; }\n         }\n         return false;\n       }"}, {"sha": "fb79a7c3c994e1f978a5596528cad68c65e10214", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=ff4ab9e147b0be4126b8b70ca6ab27173a46077a", "patch": "@@ -112,7 +112,7 @@ pub fn replace_bound_regions_in_fn_sig(\n             // kinds of types.  This had already caused me several\n             // bugs so I decided to switch over.\n             do ty::fold_regions(tcx, *ty) |r, in_fn| {\n-                if !in_fn { isr = append_isr(isr, to_r, r); }\n+                if !in_fn { isr = append_isr(isr, |br| to_r(br), r); }\n                 r\n             };\n \n@@ -211,18 +211,18 @@ pub fn relate_nested_regions(\n         match ty::get(ty).sty {\n             ty::ty_rptr(r, ref mt) |\n             ty::ty_evec(ref mt, ty::vstore_slice(r)) => {\n-                relate(*the_stack, r, relate_op);\n+                relate(*the_stack, r, |x,y| relate_op(x,y));\n                 the_stack.push(r);\n-                walk_ty(tcx, the_stack, mt.ty, relate_op);\n+                walk_ty(tcx, the_stack, mt.ty, |x,y| relate_op(x,y));\n                 the_stack.pop();\n             }\n             _ => {\n                 ty::fold_regions_and_ty(\n                     tcx,\n                     ty,\n-                    |r| { relate(*the_stack, r, relate_op); r },\n-                    |t| { walk_ty(tcx, the_stack, t, relate_op); t },\n-                    |t| { walk_ty(tcx, the_stack, t, relate_op); t });\n+                    |r| { relate(     *the_stack, r, |x,y| relate_op(x,y)); r },\n+                    |t| { walk_ty(tcx, the_stack, t, |x,y| relate_op(x,y)); t },\n+                    |t| { walk_ty(tcx, the_stack, t, |x,y| relate_op(x,y)); t });\n             }\n         }\n     }"}, {"sha": "3e2d4a71dfbe9a430fd4dd3d57c2a4689025a8dc", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=ff4ab9e147b0be4126b8b70ca6ab27173a46077a", "patch": "@@ -582,7 +582,7 @@ impl InferCtxt {\n \n         debug!(\"commit()\");\n         do indent {\n-            let r = self.try(f);\n+            let r = self.try(|| f());\n \n             self.ty_var_bindings.bindings.truncate(0);\n             self.int_var_bindings.bindings.truncate(0);\n@@ -836,6 +836,6 @@ pub fn fold_regions_in_sig(\n     fldr: &fn(r: ty::Region, in_fn: bool) -> ty::Region) -> ty::FnSig\n {\n     do ty::fold_sig(fn_sig) |t| {\n-        ty::fold_regions(tcx, t, fldr)\n+        ty::fold_regions(tcx, t, |r, in_fn| fldr(r, in_fn))\n     }\n }"}, {"sha": "7f9fb6ad9380f71e31ab52e440d48e9041ef1f03", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=ff4ab9e147b0be4126b8b70ca6ab27173a46077a", "patch": "@@ -671,7 +671,7 @@ impl<T:Hash + Eq> Set<T> for HashSet<T> {\n     fn symmetric_difference(&self,\n                             other: &HashSet<T>,\n                             f: &fn(&T) -> bool) -> bool {\n-        self.difference(other, f) && other.difference(self, f)\n+        self.difference(other, |t| f(t)) && other.difference(self, |t| f(t))\n     }\n \n     /// Visit the values representing the intersection\n@@ -681,7 +681,8 @@ impl<T:Hash + Eq> Set<T> for HashSet<T> {\n \n     /// Visit the values representing the union\n     fn union(&self, other: &HashSet<T>, f: &fn(&T) -> bool) -> bool {\n-        self.iter().advance(f) && other.iter().advance(|v| self.contains(v) || f(v))\n+        self.iter().advance(|t| f(t)) &&\n+            other.iter().advance(|v| self.contains(v) || f(v))\n     }\n }\n "}, {"sha": "976ca8bae7a87ca681a897d5cd67a980dc83d6b1", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=ff4ab9e147b0be4126b8b70ca6ab27173a46077a", "patch": "@@ -964,7 +964,7 @@ impl<'self, A, T: Iterator<A>, B, U: Iterator<B>> Iterator<B> for\n                     return Some(x)\n                 }\n             }\n-            match self.iter.next().map_consume(self.f) {\n+            match self.iter.next().map_consume(|x| (self.f)(x)) {\n                 None => return None,\n                 next => self.subiter = next,\n             }"}, {"sha": "1fbcda12dce14ba98e47ceaa02b03e8e6288b33f", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=ff4ab9e147b0be4126b8b70ca6ab27173a46077a", "patch": "@@ -595,7 +595,7 @@ pub fn walk_dir(p: &Path, f: &fn(&Path) -> bool) -> bool {\n     let r = list_dir(p);\n     r.iter().advance(|q| {\n         let path = &p.push(*q);\n-        f(path) && (!path_is_dir(path) || walk_dir(path, f))\n+        f(path) && (!path_is_dir(path) || walk_dir(path, |p| f(p)))\n     })\n }\n "}, {"sha": "e47800d70c6b56953558dd88662d5d1916802960", "filename": "src/libstd/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=ff4ab9e147b0be4126b8b70ca6ab27173a46077a", "patch": "@@ -463,7 +463,7 @@ pub fn each_split_within<'a>(ss: &'a str,\n         cont\n     };\n \n-    ss.iter().enumerate().advance(machine);\n+    ss.iter().enumerate().advance(|x| machine(x));\n \n     // Let the automaton 'run out' by supplying trailing whitespace\n     let mut fake_i = ss.len();\n@@ -761,7 +761,7 @@ impl<'self> StrUtil for &'self str {\n             // NB: len includes the trailing null.\n             assert!(len > 0);\n             if unsafe { *(ptr::offset(buf,len-1)) != 0 } {\n-                to_owned(self).as_c_str(f)\n+                to_owned(self).as_c_str(|s| f(s))\n             } else {\n                 f(buf as *libc::c_char)\n             }"}, {"sha": "c932a9660c2fd0f7f36933e79a0820890161851f", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=ff4ab9e147b0be4126b8b70ca6ab27173a46077a", "patch": "@@ -230,11 +230,15 @@ fn each_ancestor(list:        &mut AncestorList,\n         // 'do_continue'  - Did the forward_blk succeed at this point? (i.e.,\n         //                  should we recurse? or should our callers unwind?)\n \n+        let forward_blk = Cell::new(forward_blk);\n+\n         // The map defaults to None, because if ancestors is None, we're at\n         // the end of the list, which doesn't make sense to coalesce.\n         return do (**ancestors).map_default((None,false)) |ancestor_arc| {\n             // NB: Takes a lock! (this ancestor node)\n             do access_ancestors(ancestor_arc) |nobe| {\n+                // Argh, but we couldn't give it to coalesce() otherwise.\n+                let forward_blk = forward_blk.take();\n                 // Check monotonicity\n                 assert!(last_generation > nobe.generation);\n                 /*##########################################################*"}, {"sha": "d6e92dd679ea17b27f84f095087da72d5b0f8f52", "filename": "src/libstd/to_bytes.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibstd%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibstd%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_bytes.rs?ref=ff4ab9e147b0be4126b8b70ca6ab27173a46077a", "patch": "@@ -232,7 +232,8 @@ impl<A:IterBytes,B:IterBytes> IterBytes for (A,B) {\n   #[inline]\n   fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n     match *self {\n-      (ref a, ref b) => { a.iter_bytes(lsb0, f) && b.iter_bytes(lsb0, f) }\n+      (ref a, ref b) => { a.iter_bytes(lsb0, |b| f(b)) &&\n+                          b.iter_bytes(lsb0, |b| f(b)) }\n     }\n   }\n }\n@@ -242,7 +243,9 @@ impl<A:IterBytes,B:IterBytes,C:IterBytes> IterBytes for (A,B,C) {\n   fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n     match *self {\n       (ref a, ref b, ref c) => {\n-        a.iter_bytes(lsb0, f) && b.iter_bytes(lsb0, f) && c.iter_bytes(lsb0, f)\n+        a.iter_bytes(lsb0, |b| f(b)) &&\n+        b.iter_bytes(lsb0, |b| f(b)) &&\n+        c.iter_bytes(lsb0, |b| f(b))\n       }\n     }\n   }\n@@ -296,7 +299,7 @@ impl<A:IterBytes> IterBytes for Option<A> {\n     #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         match *self {\n-          Some(ref a) => 0u8.iter_bytes(lsb0, f) && a.iter_bytes(lsb0, f),\n+          Some(ref a) => 0u8.iter_bytes(lsb0, |b| f(b)) && a.iter_bytes(lsb0, |b| f(b)),\n           None => 1u8.iter_bytes(lsb0, f)\n         }\n     }"}, {"sha": "b9b03ea56619e523f4ab49926a24c5c0f75a0be7", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=ff4ab9e147b0be4126b8b70ca6ab27173a46077a", "patch": "@@ -251,7 +251,7 @@ impl<T> TrieNode<T> {\n     fn each<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n         for uint::range(0, self.children.len()) |idx| {\n             match self.children[idx] {\n-                Internal(ref x) => if !x.each(f) { return false },\n+                Internal(ref x) => if !x.each(|i,t| f(i,t)) { return false },\n                 External(k, ref v) => if !f(&k, v) { return false },\n                 Nothing => ()\n             }\n@@ -262,7 +262,7 @@ impl<T> TrieNode<T> {\n     fn each_reverse<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n         for uint::range_rev(self.children.len(), 0) |idx| {\n             match self.children[idx - 1] {\n-                Internal(ref x) => if !x.each_reverse(f) { return false },\n+                Internal(ref x) => if !x.each_reverse(|i,t| f(i,t)) { return false },\n                 External(k, ref v) => if !f(&k, v) { return false },\n                 Nothing => ()\n             }\n@@ -273,7 +273,7 @@ impl<T> TrieNode<T> {\n     fn mutate_values<'a>(&'a mut self, f: &fn(&uint, &mut T) -> bool) -> bool {\n         for self.children.mut_iter().advance |child| {\n             match *child {\n-                Internal(ref mut x) => if !x.mutate_values(f) {\n+                Internal(ref mut x) => if !x.mutate_values(|i,t| f(i,t)) {\n                     return false\n                 },\n                 External(k, ref mut v) => if !f(&k, v) { return false },"}, {"sha": "4e7943f7cfd2b72b9402701b99f7b8cc947c861c", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=ff4ab9e147b0be4126b8b70ca6ab27173a46077a", "patch": "@@ -191,7 +191,7 @@ pub fn split<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[~[T]] {\n     let mut start = 0u;\n     let mut result = ~[];\n     while start < ln {\n-        match position_between(v, start, ln, f) {\n+        match position_between(v, start, ln, |t| f(t)) {\n             None => break,\n             Some(i) => {\n                 result.push(v.slice(start, i).to_owned());\n@@ -215,7 +215,7 @@ pub fn splitn<T:Copy>(v: &[T], n: uint, f: &fn(t: &T) -> bool) -> ~[~[T]] {\n     let mut count = n;\n     let mut result = ~[];\n     while start < ln && count > 0u {\n-        match position_between(v, start, ln, f) {\n+        match position_between(v, start, ln, |t| f(t)) {\n             None => break,\n             Some(i) => {\n                 result.push(v.slice(start, i).to_owned());\n@@ -240,7 +240,7 @@ pub fn rsplit<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[~[T]] {\n     let mut end = ln;\n     let mut result = ~[];\n     while end > 0 {\n-        match rposition_between(v, 0, end, f) {\n+        match rposition_between(v, 0, end, |t| f(t)) {\n             None => break,\n             Some(i) => {\n                 result.push(v.slice(i + 1, end).to_owned());\n@@ -265,7 +265,7 @@ pub fn rsplitn<T:Copy>(v: &[T], n: uint, f: &fn(t: &T) -> bool) -> ~[~[T]] {\n     let mut count = n;\n     let mut result = ~[];\n     while end > 0u && count > 0u {\n-        match rposition_between(v, 0u, end, f) {\n+        match rposition_between(v, 0u, end, |t| f(t)) {\n             None => break,\n             Some(i) => {\n                 result.push(v.slice(i + 1u, end).to_owned());"}, {"sha": "9439f45be21bf3d96dad70ec1035d54cc1ae3aa1", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=ff4ab9e147b0be4126b8b70ca6ab27173a46077a", "patch": "@@ -535,18 +535,18 @@ pub fn walk_pat(pat: @pat, it: &fn(@pat) -> bool) -> bool {\n     match pat.node {\n         pat_ident(_, _, Some(p)) => walk_pat(p, it),\n         pat_struct(_, ref fields, _) => {\n-            fields.iter().advance(|f| walk_pat(f.pat, it))\n+            fields.iter().advance(|f| walk_pat(f.pat, |p| it(p)))\n         }\n         pat_enum(_, Some(ref s)) | pat_tup(ref s) => {\n-            s.iter().advance(|&p| walk_pat(p, it))\n+            s.iter().advance(|&p| walk_pat(p, |p| it(p)))\n         }\n         pat_box(s) | pat_uniq(s) | pat_region(s) => {\n             walk_pat(s, it)\n         }\n         pat_vec(ref before, ref slice, ref after) => {\n-            before.iter().advance(|&p| walk_pat(p, it)) &&\n-                slice.iter().advance(|&p| walk_pat(p, it)) &&\n-                after.iter().advance(|&p| walk_pat(p, it))\n+            before.iter().advance(|&p| walk_pat(p, |p| it(p))) &&\n+                slice.iter().advance(|&p| walk_pat(p, |p| it(p))) &&\n+                after.iter().advance(|&p| walk_pat(p, |p| it(p)))\n         }\n         pat_wild | pat_lit(_) | pat_range(_, _) | pat_ident(_, _, _) |\n         pat_enum(_, _) => {"}, {"sha": "78fdb99753d40bda9eb801cb24f9db8cf040485b", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=ff4ab9e147b0be4126b8b70ca6ab27173a46077a", "patch": "@@ -509,7 +509,7 @@ impl <K: Eq + Hash + IterBytes ,V: Copy> MapChain<K,V>{\n                 }\n             },\n             ConsMapChain (~ref mut map, rest) => {\n-                if satisfies_pred(map,&n,pred) {\n+                if satisfies_pred(map,&n,|v|pred(v)) {\n                     map.insert(key,ext);\n                 } else {\n                     rest.insert_into_frame(key,ext,n,pred)"}, {"sha": "15fb6ee9ff77aa5f2ee9513ec968447b027bcfc3", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=ff4ab9e147b0be4126b8b70ca6ab27173a46077a", "patch": "@@ -43,15 +43,21 @@ pub fn expand_deriving_iter_bytes(cx: @ExtCtxt,\n }\n \n fn iter_bytes_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n-    let lsb0_f = match substr.nonself_args {\n-        [l, f] => ~[l, f],\n+    let (lsb0, f)= match substr.nonself_args {\n+        [l, f] => (l, f),\n         _ => cx.span_bug(span, \"Incorrect number of arguments in `deriving(IterBytes)`\")\n     };\n+    // Build the \"explicitly borrowed\" stack closure, \"|_buf| f(_buf)\".\n+    let blk_arg = cx.ident_of(\"_buf\");\n+    let borrowed_f =\n+        cx.lambda_expr_1(span, cx.expr_call(span, f, ~[cx.expr_ident(span, blk_arg)]),\n+                         blk_arg);\n+\n     let iter_bytes_ident = substr.method_ident;\n     let call_iterbytes = |thing_expr| {\n         cx.expr_method_call(span,\n                               thing_expr, iter_bytes_ident,\n-                              copy lsb0_f)\n+                              ~[lsb0, borrowed_f])\n     };\n     let mut exprs = ~[];\n     let fields;"}, {"sha": "19aa29a62a9c02510c653d14184e19f52a76a194", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=ff4ab9e147b0be4126b8b70ca6ab27173a46077a", "patch": "@@ -99,7 +99,7 @@ fn rand_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n                     (ident, ref summary) => {\n                         cx.arm(span,\n                                ~[ pat ],\n-                               rand_thing(cx, span, ident, summary, rand_call))\n+                               rand_thing(cx, span, ident, summary, || rand_call()))\n                     }\n                 }\n             };"}, {"sha": "c2d8427d5eb39fed8fa1b238f745238723039bc5", "filename": "src/test/compile-fail/regions-creating-enums.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4ab9e147b0be4126b8b70ca6ab27173a46077a/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs?ref=ff4ab9e147b0be4126b8b70ca6ab27173a46077a", "patch": "@@ -33,8 +33,8 @@ fn map_nums(x: &ast, f: &fn(uint) -> uint) -> &ast {\n         return &num(f(x)); //~ ERROR borrowed value does not live long enough\n       }\n       add(x, y) => {\n-        let m_x = map_nums(x, f);\n-        let m_y = map_nums(y, f);\n+        let m_x = map_nums(x, |z| f(z));\n+        let m_y = map_nums(y, |z| f(z));\n         return &add(m_x, m_y);  //~ ERROR borrowed value does not live long enough\n       }\n     }"}]}