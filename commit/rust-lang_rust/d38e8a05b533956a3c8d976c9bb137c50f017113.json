{"sha": "d38e8a05b533956a3c8d976c9bb137c50f017113", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzOGU4YTA1YjUzMzk1NmEzYzhkOTc2YzliYjEzN2M1MGYwMTcxMTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-25T01:01:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-25T01:01:32Z"}, "message": "Auto merge of #26963 - Manishearth:improve-diag, r=steveklabnik\n\nI'll be adding more commits to this PR as the weekend progresses. Was hoping to make this a mega-PR, but getting some eyes on this early would be nice too.\r\n\r\nr? @steveklabnik\r\n\r\nr? @eddyb on the object safety bits\r\n\r\ncc @michaelsproul\r\n\r\nPart of #24407", "tree": {"sha": "c531fae1b4768155d88f280a5275f92eacce6d53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c531fae1b4768155d88f280a5275f92eacce6d53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d38e8a05b533956a3c8d976c9bb137c50f017113", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d38e8a05b533956a3c8d976c9bb137c50f017113", "html_url": "https://github.com/rust-lang/rust/commit/d38e8a05b533956a3c8d976c9bb137c50f017113", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d38e8a05b533956a3c8d976c9bb137c50f017113/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82d40cb2ba44a27b7db8ec185b5c532237db4b3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/82d40cb2ba44a27b7db8ec185b5c532237db4b3e", "html_url": "https://github.com/rust-lang/rust/commit/82d40cb2ba44a27b7db8ec185b5c532237db4b3e"}, {"sha": "c5889358f285aac3bc94aa856d15af682f420e69", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5889358f285aac3bc94aa856d15af682f420e69", "html_url": "https://github.com/rust-lang/rust/commit/c5889358f285aac3bc94aa856d15af682f420e69"}], "stats": {"total": 743, "additions": 712, "deletions": 31}, "files": [{"sha": "879a2d740cb0b2b5a928095c664531646a30d62b", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 711, "deletions": 30, "changes": 741, "blob_url": "https://github.com/rust-lang/rust/blob/d38e8a05b533956a3c8d976c9bb137c50f017113/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38e8a05b533956a3c8d976c9bb137c50f017113/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=d38e8a05b533956a3c8d976c9bb137c50f017113", "patch": "@@ -22,6 +22,22 @@ matched, one of the preceding patterns will match.\n \n This means that perhaps some of the preceding patterns are too general, this one\n is too specific or the ordering is incorrect.\n+\n+For example, the following `match` block has too many arms:\n+\n+```\n+match foo {\n+    Some(bar) => {/* ... */}\n+    None => {/* ... */}\n+    _ => {/* ... */} // All possible cases have already been handled\n+}\n+```\n+\n+`match` blocks have their patterns matched in order, so, for example, putting\n+a wildcard arm above a more specific arm will make the latter arm irrelevant.\n+\n+Ensure the ordering of the match arm is correct and remove any superfluous\n+arms.\n \"##,\n \n E0002: r##\"\n@@ -31,13 +47,50 @@ it is impossible to create an instance of an empty type, so empty match\n expressions are almost never desired.  This error is typically fixed by adding\n one or more cases to the match expression.\n \n-An example of an empty type is `enum Empty { }`.\n+An example of an empty type is `enum Empty { }`. So, the following will work:\n+\n+```\n+fn foo(x: Empty) {\n+    match x {\n+        // empty\n+    }\n+}\n+```\n+\n+However, this won't:\n+\n+```\n+fn foo(x: Option<String>) {\n+    match x {\n+        // empty\n+    }\n+}\n+```\n \"##,\n \n E0003: r##\"\n Not-a-Number (NaN) values cannot be compared for equality and hence can never\n-match the input to a match expression. To match against NaN values, you should\n-instead use the `is_nan` method in a guard, as in: `x if x.is_nan() => ...`\n+match the input to a match expression. So, the following will not compile:\n+\n+```\n+const NAN: f32 = 0.0 / 0.0;\n+\n+match number {\n+    NAN => { /* ... */ },\n+    // ...\n+}\n+```\n+\n+To match against NaN values, you should instead use the `is_nan()` method in a\n+guard, like so:\n+\n+```\n+match number {\n+    // ...\n+    x if x.is_nan() => { /* ... */ }\n+    // ...\n+}\n+```\n \"##,\n \n E0004: r##\"\n@@ -53,21 +106,13 @@ underscore `_` wildcard pattern can be added after all other patterns to match\n \"anything else\".\n \"##,\n \n-// FIXME: Remove duplication here?\n E0005: r##\"\n Patterns used to bind names must be irrefutable, that is, they must guarantee\n that a name will be extracted in all cases. If you encounter this error you\n probably need to use a `match` or `if let` to deal with the possibility of\n failure.\n \"##,\n \n-E0006: r##\"\n-Patterns used to bind names must be irrefutable, that is, they must guarantee\n-that a name will be extracted in all cases. If you encounter this error you\n-probably need to use a `match` or `if let` to deal with the possibility of\n-failure.\n-\"##,\n-\n E0007: r##\"\n This error indicates that the bindings in a match arm would require a value to\n be moved into more than one location, thus violating unique ownership. Code like\n@@ -271,6 +316,28 @@ const FOO: i32 = { const X : i32 = 0; X };\n ```\n \"##,\n \n+E0017: r##\"\n+References in statics and constants may only refer to immutable values. Example:\n+\n+```\n+static X: i32 = 1;\n+const C: i32 = 2;\n+\n+// these three are not allowed:\n+const CR: &'static mut i32 = &mut C;\n+static STATIC_REF: &'static mut i32 = &mut X;\n+static CONST_REF: &'static mut i32 = &mut C;\n+```\n+\n+Statics are shared everywhere, and if they refer to mutable data one might\n+violate memory safety since holding multiple mutable references to shared data\n+is not allowed.\n+\n+If you really want global mutable state, try using `static mut` or a global\n+`UnsafeCell`.\n+\n+\"##,\n+\n E0018: r##\"\n The value of static and const variables must be known at compile time. You\n can't cast a pointer as an integer because we can't know what value the\n@@ -318,7 +385,7 @@ fn main() {\n ```\n \n Remember: you can't use a function call inside a const's initialization\n-expression! However, you can totally use it elsewhere you want:\n+expression! However, you can totally use it anywhere else:\n \n ```\n fn main() {\n@@ -335,6 +402,24 @@ This error indicates that an attempt was made to divide by zero (or take the\n remainder of a zero divisor) in a static or constant expression.\n \"##,\n \n+E0022: r##\"\n+Constant functions are not allowed to mutate anything. Thus, binding to an\n+argument with a mutable pattern is not allowed. For example,\n+\n+```\n+const fn foo(mut x: u8) {\n+    // do stuff\n+}\n+```\n+\n+is bad because the function body may not mutate `x`.\n+\n+Remove any mutable bindings from the argument list to fix this error. In case\n+you need to mutate the argument, try lazily initializing a global variable\n+instead of using a `const fn`, or refactoring the code to a functional style to\n+avoid mutation if possible.\n+\"##,\n+\n E0030: r##\"\n When matching against a range, the compiler verifies that the range is\n non-empty.  Range patterns include both end-points, so this is equivalent to\n@@ -353,10 +438,297 @@ match 5u32 {\n ```\n \"##,\n \n+E0038: r####\"\n+Trait objects like `Box<Trait>` can only be constructed when certain\n+requirements are satisfied by the trait in question.\n+\n+Trait objects are a form of dynamic dispatch and use a dynamically sized type\n+for the inner type. So, for a given trait `Trait`, when `Trait` is treated as a\n+type, as in `Box<Trait>`, the inner type is 'unsized'. In such cases the boxed\n+pointer is a 'fat pointer' that contains an extra pointer to a table of methods\n+(among other things) for dynamic dispatch. This design mandates some\n+restrictions on the types of traits that are allowed to be used in trait\n+objects, which are collectively termed as 'object safety' rules.\n+\n+Attempting to create a trait object for a non object-safe trait will trigger\n+this error.\n+\n+There are various rules:\n+\n+### The trait cannot require `Self: Sized`\n+\n+When `Trait` is treated as a type, the type does not implement the special\n+`Sized` trait, because the type does not have a known size at compile time and\n+can only be accessed behind a pointer. Thus, if we have a trait like the\n+following:\n+\n+```\n+trait Foo where Self: Sized {\n+\n+}\n+```\n+\n+we cannot create an object of type `Box<Foo>` or `&Foo` since in this case\n+`Self` would not be `Sized`.\n+\n+Generally, `Self : Sized` is used to indicate that the trait should not be used\n+as a trait object. If the trait comes from your own crate, consider removing\n+this restriction.\n+\n+### Method references the `Self` type in its arguments or return type\n+\n+This happens when a trait has a method like the following:\n+\n+```\n+trait Trait {\n+    fn foo(&self) -> Self;\n+}\n+\n+impl Trait for String {\n+    fn foo(&self) -> Self {\n+        \"hi\".to_owned()\n+    }\n+}\n+\n+impl Trait for u8 {\n+    fn foo(&self) -> Self {\n+        1\n+    }\n+}\n+```\n+\n+(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\n+cause this problem)\n+\n+In such a case, the compiler cannot predict the return type of `foo()` in a\n+situation like the following:\n+\n+```\n+fn call_foo(x: Box<Trait>) {\n+    let y = x.foo(); // What type is y?\n+    // ...\n+}\n+```\n+\n+If only some methods aren't object-safe, you can add a `where Self: Sized` bound\n+on them to mark them as explicitly unavailable to trait objects. The\n+functionality will still be available to all other implementers, including\n+`Box<Trait>` which is itself sized (assuming you `impl Trait for Box<Trait>`).\n+\n+```\n+trait Trait {\n+    fn foo(&self) -> Self where Self: Sized;\n+    // more functions\n+}\n+```\n+\n+Now, `foo()` can no longer be called on a trait object, but you will now be\n+allowed to make a trait object, and that will be able to call any object-safe\n+methods\". With such a bound, one can still call `foo()` on types implementing\n+that trait that aren't behind trait objects.\n+\n+### Method has generic type parameters\n+\n+As mentioned before, trait objects contain pointers to method tables. So, if we\n+have:\n+\n+```\n+trait Trait {\n+    fn foo(&self);\n+}\n+impl Trait for String {\n+    fn foo(&self) {\n+        // implementation 1\n+    }\n+}\n+impl Trait for u8 {\n+    fn foo(&self) {\n+        // implementation 2\n+    }\n+}\n+// ...\n+```\n+\n+At compile time each implementation of `Trait` will produce a table containing\n+the various methods (and other items) related to the implementation.\n+\n+This works fine, but when the method gains generic parameters, we can have a\n+problem.\n+\n+Usually, generic parameters get _monomorphized_. For example, if I have\n+\n+```\n+fn foo<T>(x: T) {\n+    // ...\n+}\n+```\n+\n+the machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\n+other type substitution is different. Hence the compiler generates the\n+implementation on-demand. If you call `foo()` with a `bool` parameter, the\n+compiler will only generate code for `foo::<bool>()`. When we have additional\n+type parameters, the number of monomorphized implementations the compiler\n+generates does not grow drastically, since the compiler will only generate an\n+implementation if the function is called with unparametrized substitutions\n+(i.e., substitutions where none of the substituted types are themselves\n+parametrized).\n+\n+However, with trait objects we have to make a table containing _every_ object\n+that implements the trait. Now, if it has type parameters, we need to add\n+implementations for every type that implements the trait, and there could\n+theoretically be an infinite number of types.\n+\n+For example, with:\n+\n+```\n+trait Trait {\n+    fn foo<T>(&self, on: T);\n+    // more methods\n+}\n+impl Trait for String {\n+    fn foo<T>(&self, on: T) {\n+        // implementation 1\n+    }\n+}\n+impl Trait for u8 {\n+    fn foo<T>(&self, on: T) {\n+        // implementation 2\n+    }\n+}\n+// 8 more implementations\n+```\n+\n+Now, if we have the following code:\n+\n+```\n+fn call_foo(thing: Box<Trait>) {\n+    thing.foo(true); // this could be any one of the 8 types above\n+    thing.foo(1);\n+    thing.foo(\"hello\");\n+}\n+```\n+\n+we don't just need to create a table of all implementations of all methods of\n+`Trait`, we need to create such a table, for each different type fed to\n+`foo()`. In this case this turns out to be (10 types implementing `Trait`)*(3\n+types being fed to `foo()`) = 30 implementations!\n+\n+With real world traits these numbers can grow drastically.\n+\n+To fix this, it is suggested to use a `where Self: Sized` bound similar to the\n+fix for the sub-error above if you do not intend to call the method with type\n+parameters:\n+\n+```\n+trait Trait {\n+    fn foo<T>(&self, on: T) where Self: Sized;\n+    // more methods\n+}\n+```\n+\n+If this is not an option, consider replacing the type parameter with another\n+trait object (e.g. if `T: OtherTrait`, use `on: Box<OtherTrait>`). If the number\n+of types you intend to feed to this method is limited, consider manually listing\n+out the methods of different types.\n+\n+### Method has no receiver\n+\n+Methods that do not take a `self` parameter can't be called since there won't be\n+a way to get a pointer to the method table for them\n+\n+```\n+trait Foo {\n+    fn foo() -> u8;\n+}\n+```\n+\n+This could be called as `<Foo as Foo>::foo()`, which would not be able to pick\n+an implementation.\n+\n+Adding a `Self: Sized` bound to these methods will generally make this compile.\n+\n+```\n+trait Foo {\n+    fn foo() -> u8 where Self: Sized;\n+}\n+```\n+\n+### The trait cannot use `Self` as a type parameter in the supertrait listing\n+\n+This is similar to the second sub-error, but subtler. It happens in situations\n+like the following:\n+\n+```\n+trait Super<A> {}\n+\n+trait Trait: Super<Self> {\n+}\n+\n+struct Foo;\n+\n+impl Super<Foo> for Foo{}\n+\n+impl Trait for Foo {}\n+```\n+\n+Here, the supertrait might have methods as follows:\n+\n+```\n+trait Super<A> {\n+    fn get_a(&self) -> A; // note that this is object safe!\n+}\n+```\n+\n+If the trait `Foo` was deriving from something like `Super<String>` or\n+`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n+`get_a()` will definitely return an object of that type.\n+\n+However, if it derives from `Super<Self>`, even though `Super` is object safe,\n+the method `get_a()` would return an object of unknown type when called on the\n+function. `Self` type parameters let us make object safe traits no longer safe,\n+so they are forbidden when specifying supertraits.\n+\n+There's no easy fix for this, generally code will need to be refactored so that\n+you no longer need to derive from `Super<Self>`.\n+\"####,\n+\n E0079: r##\"\n Enum variants which contain no data can be given a custom integer\n-representation. This error indicates that the value provided is not an\n-integer literal and is therefore invalid.\n+representation. This error indicates that the value provided is not an integer\n+literal and is therefore invalid.\n+\n+For example, in the following code,\n+\n+```\n+enum Foo {\n+    Q = \"32\"\n+}\n+```\n+\n+we try to set the representation to a string.\n+\n+There's no general fix for this; if you can work with an integer then just set\n+it to one:\n+\n+```\n+enum Foo {\n+    Q = 32\n+}\n+```\n+\n+however if you actually wanted a mapping between variants and non-integer\n+objects, it may be preferable to use a method with a match instead:\n+\n+```\n+enum Foo { Q }\n+impl Foo {\n+    fn get_str(&self) -> &'static str {\n+        match *self {\n+            Foo::Q => \"32\",\n+        }\n+    }\n+}\n+```\n \"##,\n \n E0080: r##\"\n@@ -388,10 +760,11 @@ type X = u32<i32>; // error: type parameters are not allowed on this type\n \n Please check that you used the correct type and recheck its definition. Perhaps\n it doesn't need the type parameter.\n+\n Example:\n \n ```\n-type X = u32; // ok!\n+type X = u32; // this compiles\n ```\n \"##,\n \n@@ -404,8 +777,8 @@ type X = u32<'static>; // error: lifetime parameters are not allowed on\n                        //        this type\n ```\n \n-Please check that you used the correct type and recheck its definition,\n-perhaps it doesn't need the lifetime parameter. Example:\n+Please check that the correct type was used and recheck its definition; perhaps\n+it doesn't need the lifetime parameter. Example:\n \n ```\n type X = u32; // ok!\n@@ -429,12 +802,96 @@ fn main() {\n See also https://doc.rust-lang.org/book/unsafe.html\n \"##,\n \n+// This shouldn't really ever trigger since the repeated value error comes first\n+E0136: r##\"\n+A binary can only have one entry point, and by default that entry point is the\n+function `main()`. If there are multiple such functions, please rename one.\n+\"##,\n+\n E0137: r##\"\n This error indicates that the compiler found multiple functions with the\n `#[main]` attribute. This is an error because there must be a unique entry\n point into a Rust program.\n \"##,\n \n+E0138: r##\"\n+This error indicates that the compiler found multiple functions with the\n+`#[start]` attribute. This is an error because there must be a unique entry\n+point into a Rust program.\n+\"##,\n+\n+// FIXME link this to the relevant turpl chapters for instilling fear of the\n+//       transmute gods in the user\n+E0139: r##\"\n+There are various restrictions on transmuting between types in Rust; for example\n+types being transmuted must have the same size. To apply all these restrictions,\n+the compiler must know the exact types that may be transmuted. When type\n+parameters are involved, this cannot always be done.\n+\n+So, for example, the following is not allowed:\n+\n+```\n+struct Foo<T>(Vec<T>)\n+\n+fn foo<T>(x: Vec<T>) {\n+    // we are transmuting between Vec<T> and Foo<T> here\n+    let y: Foo<T> = unsafe { transmute(x) };\n+    // do something with y\n+}\n+```\n+\n+In this specific case there's a good chance that the transmute is harmless (but\n+this is not guaranteed by Rust). However, when alignment and enum optimizations\n+come into the picture, it's quite likely that the sizes may or may not match\n+with different type parameter substitutions. It's not possible to check this for\n+_all_ possible types, so `transmute()` simply only accepts types without any\n+unsubstituted type parameters.\n+\n+If you need this, there's a good chance you're doing something wrong. Keep in\n+mind that Rust doesn't guarantee much about the layout of different structs\n+(even two structs with identical declarations may have different layouts). If\n+there is a solution that avoids the transmute entirely, try it instead.\n+\n+If it's possible, hand-monomorphize the code by writing the function for each\n+possible type substitution. It's possible to use traits to do this cleanly,\n+for example:\n+\n+```\n+trait MyTransmutableType {\n+    fn transmute(Vec<Self>) -> Foo<Self>\n+}\n+\n+impl MyTransmutableType for u8 {\n+    fn transmute(x: Foo<u8>) -> Vec<u8> {\n+        transmute(x)\n+    }\n+}\n+impl MyTransmutableType for String {\n+    fn transmute(x: Foo<String>) -> Vec<String> {\n+        transmute(x)\n+    }\n+}\n+// ... more impls for the types you intend to transmute\n+\n+fn foo<T: MyTransmutableType>(x: Vec<T>) {\n+    let y: Foo<T> = <T as MyTransmutableType>::transmute(x);\n+    // do something with y\n+}\n+```\n+\n+Each impl will be checked for a size match in the transmute as usual, and since\n+there are no unbound type parameters involved, this should compile unless there\n+is a size mismatch in one of the impls.\n+\n+It is also possible to manually transmute:\n+\n+```\n+let result: SomeType = mem::uninitialized();\n+unsafe { copy_nonoverlapping(&v, &result) };\n+result // `v` transmuted to type `SomeType`\n+```\n+\"##,\n+\n E0152: r##\"\n Lang items are already implemented in the standard library. Unless you are\n writing a free-standing application (e.g. a kernel), you do not need to provide\n@@ -552,6 +1009,14 @@ you prefer them unqualified, you can import the variants into scope:\n use Method::*;\n enum Method { GET, POST }\n ```\n+\n+If you want others to be able to import variants from your module directly, use\n+`pub use`:\n+\n+```\n+pub use Method::*;\n+enum Method { GET, POST }\n+```\n \"##,\n \n E0261: r##\"\n@@ -663,6 +1128,108 @@ fn some_func() {\n ```\n \"##,\n \n+E0269: r##\"\n+Functions must eventually return a value of their return type. For example, in\n+the following function\n+\n+```\n+fn foo(x: u8) -> u8 {\n+    if x > 0 {\n+        x // alternatively, `return x`\n+    }\n+    // nothing here\n+}\n+```\n+\n+if the condition is true, the value `x` is returned, but if the condition is\n+false, control exits the `if` block and reaches a place where nothing is being\n+returned. All possible control paths must eventually return a `u8`, which is not\n+happening here.\n+\n+An easy fix for this in a complicated function is to specify a default return\n+value, if possible:\n+\n+```\n+fn foo(x: u8) -> u8 {\n+    if x > 0 {\n+        x // alternatively, `return x`\n+    }\n+    // lots of other if branches\n+    0 // return 0 if all else fails\n+}\n+```\n+\n+It is advisable to find out what the unhandled cases are and check for them,\n+returning an appropriate value or panicking if necessary.\n+\"##,\n+\n+E0270: r##\"\n+Rust lets you define functions which are known to never return, i.e. are\n+'diverging', by marking its return type as `!`.\n+\n+For example, the following functions never return:\n+\n+```\n+fn foo() -> ! {\n+    loop {}\n+}\n+\n+fn bar() -> ! {\n+    foo() // foo() is diverging, so this will diverge too\n+}\n+\n+fn baz() -> ! {\n+    panic!(); // this macro internally expands to a call to a diverging function\n+}\n+\n+```\n+\n+Such functions can be used in a place where a value is expected without\n+returning a value of that type,  for instance:\n+\n+```\n+let y = match x {\n+    1 => 1,\n+    2 => 4,\n+    _ => foo() // diverging function called here\n+};\n+println!(\"{}\", y)\n+```\n+\n+If the third arm of the match block is reached, since `foo()` doesn't ever\n+return control to the match block, it is fine to use it in a place where an\n+integer was expected. The `match` block will never finish executing, and any\n+point where `y` (like the print statement) is needed will not be reached.\n+\n+However, if we had a diverging function that actually does finish execution\n+\n+```\n+fn foo() -> {\n+    loop {break;}\n+}\n+```\n+\n+then we would have an unknown value for `y` in the following code:\n+\n+```\n+let y = match x {\n+    1 => 1,\n+    2 => 4,\n+    _ => foo()\n+};\n+println!(\"{}\", y);\n+```\n+\n+In the previous example, the print statement was never reached when the wildcard\n+match arm was hit, so we were okay with `foo()` not returning an integer that we\n+could set to `y`. But in this example, `foo()` actually does return control, so\n+the print statement will be executed with an uninitialized value.\n+\n+Obviously we cannot have functions which are allowed to be used in such\n+positions and yet can return control. So, if you are defining a function that\n+returns `!`, make sure that there is no way for it to actually finish executing.\n+\"##,\n+\n E0271: r##\"\n This is because of a type mismatch between the associated type of some\n trait (e.g. `T::Bar`, where `T` implements `trait Quux { type Bar; }`)\n@@ -799,6 +1366,132 @@ for v in &vs {\n ```\n \"##,\n \n+E0272: r##\"\n+The `#[rustc_on_unimplemented]` attribute lets you specify a custom error\n+message for when a particular trait isn't implemented on a type placed in a\n+position that needs that trait. For example, when the following code is\n+compiled:\n+\n+```\n+fn foo<T: Index<u8>>(x: T){}\n+\n+#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n+trait Index<Idx> { ... }\n+\n+foo(true); // `bool` does not implement `Index<u8>`\n+```\n+\n+there will be an error about `bool` not implementing `Index<u8>`, followed by a\n+note saying \"the type `bool` cannot be indexed by `u8`\".\n+\n+As you can see, you can specify type parameters in curly braces for substitution\n+with the actual types (using the regular format string syntax) in a given\n+situation. Furthermore, `{Self}` will substitute to the type (in this case,\n+`bool`) that we tried to use.\n+\n+This error appears when the curly braces contain an identifier which doesn't\n+match with any of the type parameters or the string `Self`. This might happen if\n+you misspelled a type parameter, or if you intended to use literal curly braces.\n+If it is the latter, escape the curly braces with a second curly brace of the\n+same type; e.g. a literal `{` is `{{`\n+\"##,\n+\n+E0273: r##\"\n+The `#[rustc_on_unimplemented]` attribute lets you specify a custom error\n+message for when a particular trait isn't implemented on a type placed in a\n+position that needs that trait. For example, when the following code is\n+compiled:\n+\n+```\n+fn foo<T: Index<u8>>(x: T){}\n+\n+#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n+trait Index<Idx> { ... }\n+\n+foo(true); // `bool` does not implement `Index<u8>`\n+```\n+\n+there will be an error about `bool` not implementing `Index<u8>`, followed by a\n+note saying \"the type `bool` cannot be indexed by `u8`\".\n+\n+As you can see, you can specify type parameters in curly braces for substitution\n+with the actual types (using the regular format string syntax) in a given\n+situation. Furthermore, `{Self}` will substitute to the type (in this case,\n+`bool`) that we tried to use.\n+\n+This error appears when the curly braces do not contain an identifier. Please\n+add one of the same name as a type parameter. If you intended to use literal\n+braces, use `{{` and `}}` to escape them.\n+\"##,\n+\n+E0274: r##\"\n+The `#[rustc_on_unimplemented]` attribute lets you specify a custom error\n+message for when a particular trait isn't implemented on a type placed in a\n+position that needs that trait. For example, when the following code is\n+compiled:\n+\n+```\n+fn foo<T: Index<u8>>(x: T){}\n+\n+#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n+trait Index<Idx> { ... }\n+\n+foo(true); // `bool` does not implement `Index<u8>`\n+```\n+\n+there will be an error about `bool` not implementing `Index<u8>`, followed by a\n+note saying \"the type `bool` cannot be indexed by `u8`\".\n+\n+For this to work, some note must be specified. An empty attribute will not do\n+anything, please remove the attribute or add some helpful note for users of the\n+trait.\n+\"##,\n+\n+E0275: r##\"\n+This error occurs when there was a recursive trait requirement that overflowed\n+before it could be evaluated. Often this means that there is unbounded recursion\n+in resolving some type bounds.\n+\n+For example, in the following code\n+\n+```\n+trait Foo {}\n+\n+struct Bar<T>(T);\n+\n+impl<T> Foo for T where Bar<T>: Foo {}\n+```\n+\n+to determine if a `T` is `Foo`, we need to check if `Bar<T>` is `Foo`. However,\n+to do this check, we need to determine that `Bar<Bar<T>>` is `Foo`. To determine\n+this, we check if `Bar<Bar<Bar<T>>>` is `Foo`, and so on. This is clearly a\n+recursive requirement that can't be resolved directly.\n+\n+Consider changing your trait bounds so that they're less self-referential.\n+\"##,\n+\n+E0276: r##\"\n+This error occurs when a bound in an implementation of a trait does not match\n+the bounds specified in the original trait. For example:\n+\n+```\n+trait Foo {\n+ fn foo<T>(x: T);\n+}\n+\n+impl Foo for bool {\n+ fn foo<T>(x: T) where T: Copy {}\n+}\n+```\n+\n+Here, all types implementing `Foo` must have a method `foo<T>(x: T)` which can\n+take any type `T`. However, in the `impl` for `bool`, we have added an extra\n+bound that `T` is `Copy`, which isn't compatible with the original trait.\n+\n+Consider removing the bound from the method or adding the bound to the original\n+method definition in the trait.\n+\"##,\n+\n E0277: r##\"\n You tried to use a type which doesn't implement some trait in a place which\n expected that trait. Erroneous code example:\n@@ -1219,22 +1912,10 @@ contain references (with a maximum lifetime of `'a`).\n \n \n register_diagnostics! {\n-    E0017,\n-    E0022,\n-    E0038,\n+    // E0006 // merged with E0005\n //  E0134,\n //  E0135,\n-    E0136,\n-    E0138,\n-    E0139,\n     E0264, // unknown external lang item\n-    E0269, // not all control paths return a value\n-    E0270, // computation may converge in a function marked as diverging\n-    E0272, // rustc_on_unimplemented attribute refers to non-existent type parameter\n-    E0273, // rustc_on_unimplemented must have named format arguments\n-    E0274, // rustc_on_unimplemented must have a value\n-    E0275, // overflow evaluating requirement\n-    E0276, // requirement appears on impl method but not on corresponding trait method\n     E0278, // requirement is not satisfied\n     E0279, // requirement is not satisfied\n     E0280, // requirement is not satisfied"}, {"sha": "ea86fa318b45dd900dab06a12d23c93d1db05efa", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d38e8a05b533956a3c8d976c9bb137c50f017113/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38e8a05b533956a3c8d976c9bb137c50f017113/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=d38e8a05b533956a3c8d976c9bb137c50f017113", "patch": "@@ -1049,7 +1049,7 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n \n     for input in &decl.inputs {\n         is_refutable(cx, &*input.pat, |pat| {\n-            span_err!(cx.tcx.sess, input.pat.span, E0006,\n+            span_err!(cx.tcx.sess, input.pat.span, E0005,\n                 \"refutable pattern in function argument: `{}` not covered\",\n                 pat_to_string(pat)\n             );"}]}