{"sha": "5ab67bff1e2230217ce133165605f8dc0d588178", "node_id": "C_kwDOAAsO6NoAKDVhYjY3YmZmMWUyMjMwMjE3Y2UxMzMxNjU2MDVmOGRjMGQ1ODgxNzg", "commit": {"author": {"name": "Chris Denton", "email": "christophersdenton@gmail.com", "date": "2022-01-06T02:47:36Z"}, "committer": {"name": "Pietro Albini", "email": "pietro.albini@ferrous-systems.com", "date": "2022-01-19T14:59:21Z"}, "message": "Fix CVE-2022-21658 for Windows", "tree": {"sha": "19ed44bcc83c25a8b7d42629558ec866c6d4bf61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19ed44bcc83c25a8b7d42629558ec866c6d4bf61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ab67bff1e2230217ce133165605f8dc0d588178", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEMycKYjxLY0eb13b7zXazX3c0dp4FAmHoJ0kACgkQzXazX3c0\ndp5kdRAAgSMPI4XySsQh+bXcB3Z60CI43INu9rqhnIwCDg2lmGSjLfGHJtYCQ8/2\nt66USq9+kLtTBvSm+PTp/hXV0QrGPQqsBcVj1vrEhQ9ThS8lKlovTSYWpgEVEC4O\n5LfR7yLLxFZfgXj2s01GWSD8IdBNwcmAIRz2a9bfgftkvd65m5vnR+gXiHLUzcFR\nK7uqAL/yg9FYpoxmf6vWZ8kwgO4rvIwntx8GpY1fTJfqMKgCKUIJkCyYNfruouZ0\nNGg/ojORlMZGzaLti6lxmKxN60p+Xv9vC49RUf64Q8Zy/Q+Ujuo6AcyurunyHv4P\nCltyfnBE/ZxSBPb3DGOkrns0ocIAv/SfnEVBqaRBc4ESHf2nh3Gcv7iSaN6iBJv2\nCIK+AyxbzeX7XIXRHO+UpqeniSyZtKFykm/pzeIkE37k3JNduAZRt26sD+U3ZZR+\nIOuKF6xNG3loqwpBRYZLxOzKF9kOhhk99S9Kp3k9ez+xFtqWrs+bQRxMyARYofl5\nj3JXjfzKUG3ssdps7nLJrZm56ykLL4rM8KyIRh7xTw8EMc2tdr3T+kN3QyJwN5Tm\nd8U8Mrsh0dX5BOW5N4Wa9iEqoWu3NTpU2/vhoaOM1wMsTukM9BzUKxJ0GHKQyEYz\n5DdPwmU4RD/tOUxhgTbWB1Km4nNiKwzFNcR0s2G5n2QuudlDPvU=\n=uQ++\n-----END PGP SIGNATURE-----", "payload": "tree 19ed44bcc83c25a8b7d42629558ec866c6d4bf61\nparent 86f7f78f05ff8295aad2ad2a31770ce4408cc849\nauthor Chris Denton <christophersdenton@gmail.com> 1641437256 +0000\ncommitter Pietro Albini <pietro.albini@ferrous-systems.com> 1642604361 +0100\n\nFix CVE-2022-21658 for Windows\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ab67bff1e2230217ce133165605f8dc0d588178", "html_url": "https://github.com/rust-lang/rust/commit/5ab67bff1e2230217ce133165605f8dc0d588178", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ab67bff1e2230217ce133165605f8dc0d588178/comments", "author": {"login": "ChrisDenton", "id": 4459874, "node_id": "MDQ6VXNlcjQ0NTk4NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4459874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisDenton", "html_url": "https://github.com/ChrisDenton", "followers_url": "https://api.github.com/users/ChrisDenton/followers", "following_url": "https://api.github.com/users/ChrisDenton/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisDenton/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisDenton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisDenton/subscriptions", "organizations_url": "https://api.github.com/users/ChrisDenton/orgs", "repos_url": "https://api.github.com/users/ChrisDenton/repos", "events_url": "https://api.github.com/users/ChrisDenton/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisDenton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86f7f78f05ff8295aad2ad2a31770ce4408cc849", "url": "https://api.github.com/repos/rust-lang/rust/commits/86f7f78f05ff8295aad2ad2a31770ce4408cc849", "html_url": "https://github.com/rust-lang/rust/commit/86f7f78f05ff8295aad2ad2a31770ce4408cc849"}], "stats": {"total": 446, "additions": 419, "deletions": 27}, "files": [{"sha": "09d3661e4fd52d0b961f5e8fcaf898a3fe21ef71", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 114, "deletions": 10, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/5ab67bff1e2230217ce133165605f8dc0d588178/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab67bff1e2230217ce133165605f8dc0d588178/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=5ab67bff1e2230217ce133165605f8dc0d588178", "patch": "@@ -4,6 +4,7 @@\n #![cfg_attr(test, allow(dead_code))]\n #![unstable(issue = \"none\", feature = \"windows_c\")]\n \n+use crate::mem;\n use crate::os::raw::NonZero_c_ulong;\n use crate::os::raw::{c_char, c_int, c_long, c_longlong, c_uint, c_ulong, c_ushort};\n use crate::ptr;\n@@ -36,6 +37,7 @@ pub type USHORT = c_ushort;\n pub type SIZE_T = usize;\n pub type WORD = u16;\n pub type CHAR = c_char;\n+pub type CCHAR = c_char;\n pub type ULONG_PTR = usize;\n pub type ULONG = c_ulong;\n pub type NTSTATUS = LONG;\n@@ -86,16 +88,21 @@ pub const FILE_SHARE_DELETE: DWORD = 0x4;\n pub const FILE_SHARE_READ: DWORD = 0x1;\n pub const FILE_SHARE_WRITE: DWORD = 0x2;\n \n+pub const FILE_OPEN_REPARSE_POINT: ULONG = 0x200000;\n+pub const OBJ_DONT_REPARSE: ULONG = 0x1000;\n+\n pub const CREATE_ALWAYS: DWORD = 2;\n pub const CREATE_NEW: DWORD = 1;\n pub const OPEN_ALWAYS: DWORD = 4;\n pub const OPEN_EXISTING: DWORD = 3;\n pub const TRUNCATE_EXISTING: DWORD = 5;\n \n+pub const FILE_LIST_DIRECTORY: DWORD = 0x1;\n pub const FILE_WRITE_DATA: DWORD = 0x00000002;\n pub const FILE_APPEND_DATA: DWORD = 0x00000004;\n pub const FILE_WRITE_EA: DWORD = 0x00000010;\n pub const FILE_WRITE_ATTRIBUTES: DWORD = 0x00000100;\n+pub const DELETE: DWORD = 0x10000;\n pub const READ_CONTROL: DWORD = 0x00020000;\n pub const SYNCHRONIZE: DWORD = 0x00100000;\n pub const GENERIC_READ: DWORD = 0x80000000;\n@@ -261,9 +268,61 @@ pub const FD_SETSIZE: usize = 64;\n pub const STACK_SIZE_PARAM_IS_A_RESERVATION: DWORD = 0x00010000;\n \n pub const STATUS_SUCCESS: NTSTATUS = 0x00000000;\n+pub const STATUS_DELETE_PENDING: NTSTATUS = 0xc0000056_u32 as _;\n+pub const STATUS_INVALID_PARAMETER: NTSTATUS = 0xc000000d_u32 as _;\n+\n+// Equivalent to the `NT_SUCCESS` C preprocessor macro.\n+// See: https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/using-ntstatus-values\n+pub fn nt_success(status: NTSTATUS) -> bool {\n+    status >= 0\n+}\n \n pub const BCRYPT_USE_SYSTEM_PREFERRED_RNG: DWORD = 0x00000002;\n \n+#[repr(C)]\n+pub struct UNICODE_STRING {\n+    pub Length: u16,\n+    pub MaximumLength: u16,\n+    pub Buffer: *mut u16,\n+}\n+impl UNICODE_STRING {\n+    pub fn from_ref(slice: &[u16]) -> Self {\n+        let len = slice.len() * mem::size_of::<u16>();\n+        Self { Length: len as _, MaximumLength: len as _, Buffer: slice.as_ptr() as _ }\n+    }\n+}\n+#[repr(C)]\n+pub struct OBJECT_ATTRIBUTES {\n+    pub Length: ULONG,\n+    pub RootDirectory: HANDLE,\n+    pub ObjectName: *const UNICODE_STRING,\n+    pub Attributes: ULONG,\n+    pub SecurityDescriptor: *mut c_void,\n+    pub SecurityQualityOfService: *mut c_void,\n+}\n+impl Default for OBJECT_ATTRIBUTES {\n+    fn default() -> Self {\n+        Self {\n+            Length: mem::size_of::<Self>() as _,\n+            RootDirectory: ptr::null_mut(),\n+            ObjectName: ptr::null_mut(),\n+            Attributes: 0,\n+            SecurityDescriptor: ptr::null_mut(),\n+            SecurityQualityOfService: ptr::null_mut(),\n+        }\n+    }\n+}\n+#[repr(C)]\n+pub struct IO_STATUS_BLOCK {\n+    pub Pointer: *mut c_void,\n+    pub Information: usize,\n+}\n+impl Default for IO_STATUS_BLOCK {\n+    fn default() -> Self {\n+        Self { Pointer: ptr::null_mut(), Information: 0 }\n+    }\n+}\n+\n #[repr(C)]\n #[cfg(not(target_pointer_width = \"64\"))]\n pub struct WSADATA {\n@@ -353,9 +412,43 @@ pub enum FILE_INFO_BY_HANDLE_CLASS {\n     FileIdInfo = 18,                     // 0x12\n     FileIdExtdDirectoryInfo = 19,        // 0x13\n     FileIdExtdDirectoryRestartInfo = 20, // 0x14\n+    FileDispositionInfoEx = 21,          // 0x15, Windows 10 version 1607\n     MaximumFileInfoByHandlesClass,\n }\n \n+#[repr(C)]\n+pub struct FILE_DISPOSITION_INFO {\n+    pub DeleteFile: BOOLEAN,\n+}\n+\n+pub const FILE_DISPOSITION_DELETE: DWORD = 0x1;\n+pub const FILE_DISPOSITION_POSIX_SEMANTICS: DWORD = 0x2;\n+pub const FILE_DISPOSITION_IGNORE_READONLY_ATTRIBUTE: DWORD = 0x10;\n+\n+#[repr(C)]\n+pub struct FILE_DISPOSITION_INFO_EX {\n+    pub Flags: DWORD,\n+}\n+\n+#[repr(C)]\n+#[derive(Default)]\n+pub struct FILE_ID_BOTH_DIR_INFO {\n+    pub NextEntryOffset: DWORD,\n+    pub FileIndex: DWORD,\n+    pub CreationTime: LARGE_INTEGER,\n+    pub LastAccessTime: LARGE_INTEGER,\n+    pub LastWriteTime: LARGE_INTEGER,\n+    pub ChangeTime: LARGE_INTEGER,\n+    pub EndOfFile: LARGE_INTEGER,\n+    pub AllocationSize: LARGE_INTEGER,\n+    pub FileAttributes: DWORD,\n+    pub FileNameLength: DWORD,\n+    pub EaSize: DWORD,\n+    pub ShortNameLength: CCHAR,\n+    pub ShortName: [WCHAR; 12],\n+    pub FileId: LARGE_INTEGER,\n+    pub FileName: [WCHAR; 1],\n+}\n #[repr(C)]\n pub struct FILE_BASIC_INFO {\n     pub CreationTime: LARGE_INTEGER,\n@@ -750,16 +843,6 @@ if #[cfg(target_vendor = \"uwp\")] {\n         pub DeletePending: BOOLEAN,\n         pub Directory: BOOLEAN,\n     }\n-\n-    #[link(name = \"kernel32\")]\n-    extern \"system\" {\n-        pub fn GetFileInformationByHandleEx(\n-            hFile: HANDLE,\n-            fileInfoClass: FILE_INFO_BY_HANDLE_CLASS,\n-            lpFileInformation: LPVOID,\n-            dwBufferSize: DWORD,\n-        ) -> BOOL;\n-    }\n }\n }\n \n@@ -949,6 +1032,12 @@ extern \"system\" {\n         cchFilePath: DWORD,\n         dwFlags: DWORD,\n     ) -> DWORD;\n+    pub fn GetFileInformationByHandleEx(\n+        hFile: HANDLE,\n+        fileInfoClass: FILE_INFO_BY_HANDLE_CLASS,\n+        lpFileInformation: LPVOID,\n+        dwBufferSize: DWORD,\n+    ) -> BOOL;\n     pub fn SetFileInformationByHandle(\n         hFile: HANDLE,\n         FileInformationClass: FILE_INFO_BY_HANDLE_CLASS,\n@@ -1139,6 +1228,21 @@ compat_fn! {\n \n compat_fn! {\n     \"ntdll\":\n+    pub fn NtOpenFile(\n+        FileHandle: *mut HANDLE,\n+        DesiredAccess: ACCESS_MASK,\n+        ObjectAttributes: *const OBJECT_ATTRIBUTES,\n+        IoStatusBlock: *mut IO_STATUS_BLOCK,\n+        ShareAccess: ULONG,\n+        OpenOptions: ULONG\n+    ) -> NTSTATUS {\n+        panic!(\"`NtOpenFile` not available\");\n+    }\n+    pub fn RtlNtStatusToDosError(\n+        Status: NTSTATUS\n+    ) -> ULONG {\n+        panic!(\"`RtlNtStatusToDosError` not available\");\n+    }\n     pub fn NtCreateKeyedEvent(\n         KeyedEventHandle: LPHANDLE,\n         DesiredAccess: ACCESS_MASK,"}, {"sha": "dd21c6b43891f137d3b70e3800e9152c4795c394", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 305, "deletions": 17, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/5ab67bff1e2230217ce133165605f8dc0d588178/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab67bff1e2230217ce133165605f8dc0d588178/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=5ab67bff1e2230217ce133165605f8dc0d588178", "patch": "@@ -547,6 +547,218 @@ impl File {\n         })?;\n         Ok(())\n     }\n+    /// Get only basic file information such as attributes and file times.\n+    fn basic_info(&self) -> io::Result<c::FILE_BASIC_INFO> {\n+        unsafe {\n+            let mut info: c::FILE_BASIC_INFO = mem::zeroed();\n+            let size = mem::size_of_val(&info);\n+            cvt(c::GetFileInformationByHandleEx(\n+                self.handle.as_raw_handle(),\n+                c::FileBasicInfo,\n+                &mut info as *mut _ as *mut libc::c_void,\n+                size as c::DWORD,\n+            ))?;\n+            Ok(info)\n+        }\n+    }\n+    /// Delete using POSIX semantics.\n+    ///\n+    /// Files will be deleted as soon as the handle is closed. This is supported\n+    /// for Windows 10 1607 (aka RS1) and later. However some filesystem\n+    /// drivers will not support it even then, e.g. FAT32.\n+    ///\n+    /// If the operation is not supported for this filesystem or OS version\n+    /// then errors will be `ERROR_NOT_SUPPORTED` or `ERROR_INVALID_PARAMETER`.\n+    fn posix_delete(&self) -> io::Result<()> {\n+        let mut info = c::FILE_DISPOSITION_INFO_EX {\n+            Flags: c::FILE_DISPOSITION_DELETE\n+                | c::FILE_DISPOSITION_POSIX_SEMANTICS\n+                | c::FILE_DISPOSITION_IGNORE_READONLY_ATTRIBUTE,\n+        };\n+        let size = mem::size_of_val(&info);\n+        cvt(unsafe {\n+            c::SetFileInformationByHandle(\n+                self.handle.as_raw_handle(),\n+                c::FileDispositionInfoEx,\n+                &mut info as *mut _ as *mut _,\n+                size as c::DWORD,\n+            )\n+        })?;\n+        Ok(())\n+    }\n+\n+    /// Delete a file using win32 semantics. The file won't actually be deleted\n+    /// until all file handles are closed. However, marking a file for deletion\n+    /// will prevent anyone from opening a new handle to the file.\n+    fn win32_delete(&self) -> io::Result<()> {\n+        let mut info = c::FILE_DISPOSITION_INFO { DeleteFile: c::TRUE as _ };\n+        let size = mem::size_of_val(&info);\n+        cvt(unsafe {\n+            c::SetFileInformationByHandle(\n+                self.handle.as_raw_handle(),\n+                c::FileDispositionInfo,\n+                &mut info as *mut _ as *mut _,\n+                size as c::DWORD,\n+            )\n+        })?;\n+        Ok(())\n+    }\n+\n+    /// Fill the given buffer with as many directory entries as will fit.\n+    /// This will remember its position and continue from the last call unless\n+    /// `restart` is set to `true`.\n+    ///\n+    /// The returned bool indicates if there are more entries or not.\n+    /// It is an error if `self` is not a directory.\n+    ///\n+    /// # Symlinks and other reparse points\n+    ///\n+    /// On Windows a file is either a directory or a non-directory.\n+    /// A symlink directory is simply an empty directory with some \"reparse\" metadata attached.\n+    /// So if you open a link (not its target) and iterate the directory,\n+    /// you will always iterate an empty directory regardless of the target.\n+    fn fill_dir_buff(&self, buffer: &mut DirBuff, restart: bool) -> io::Result<bool> {\n+        let class =\n+            if restart { c::FileIdBothDirectoryRestartInfo } else { c::FileIdBothDirectoryInfo };\n+\n+        unsafe {\n+            let result = cvt(c::GetFileInformationByHandleEx(\n+                self.handle.as_raw_handle(),\n+                class,\n+                buffer.as_mut_ptr().cast(),\n+                buffer.capacity() as _,\n+            ));\n+            match result {\n+                Ok(_) => Ok(true),\n+                Err(e) if e.raw_os_error() == Some(c::ERROR_NO_MORE_FILES as _) => Ok(false),\n+                Err(e) => Err(e),\n+            }\n+        }\n+    }\n+}\n+\n+/// A buffer for holding directory entries.\n+struct DirBuff {\n+    buffer: Vec<u8>,\n+}\n+impl DirBuff {\n+    fn new() -> Self {\n+        const BUFFER_SIZE: usize = 1024;\n+        Self { buffer: vec![0_u8; BUFFER_SIZE] }\n+    }\n+    fn capacity(&self) -> usize {\n+        self.buffer.len()\n+    }\n+    fn as_mut_ptr(&mut self) -> *mut u8 {\n+        self.buffer.as_mut_ptr().cast()\n+    }\n+    /// Returns a `DirBuffIter`.\n+    fn iter(&self) -> DirBuffIter<'_> {\n+        DirBuffIter::new(self)\n+    }\n+}\n+impl AsRef<[u8]> for DirBuff {\n+    fn as_ref(&self) -> &[u8] {\n+        &self.buffer\n+    }\n+}\n+\n+/// An iterator over entries stored in a `DirBuff`.\n+///\n+/// Currently only returns file names (UTF-16 encoded).\n+struct DirBuffIter<'a> {\n+    buffer: Option<&'a [u8]>,\n+    cursor: usize,\n+}\n+impl<'a> DirBuffIter<'a> {\n+    fn new(buffer: &'a DirBuff) -> Self {\n+        Self { buffer: Some(buffer.as_ref()), cursor: 0 }\n+    }\n+}\n+impl<'a> Iterator for DirBuffIter<'a> {\n+    type Item = &'a [u16];\n+    fn next(&mut self) -> Option<Self::Item> {\n+        use crate::mem::size_of;\n+        let buffer = &self.buffer?[self.cursor..];\n+\n+        // Get the name and next entry from the buffer.\n+        // SAFETY: The buffer contains a `FILE_ID_BOTH_DIR_INFO` struct but the\n+        // last field (the file name) is unsized. So an offset has to be\n+        // used to get the file name slice.\n+        let (name, next_entry) = unsafe {\n+            let info = buffer.as_ptr().cast::<c::FILE_ID_BOTH_DIR_INFO>();\n+            let next_entry = (*info).NextEntryOffset as usize;\n+            let name = crate::slice::from_raw_parts(\n+                (*info).FileName.as_ptr().cast::<u16>(),\n+                (*info).FileNameLength as usize / size_of::<u16>(),\n+            );\n+            (name, next_entry)\n+        };\n+\n+        if next_entry == 0 {\n+            self.buffer = None\n+        } else {\n+            self.cursor += next_entry\n+        }\n+\n+        // Skip `.` and `..` pseudo entries.\n+        const DOT: u16 = b'.' as u16;\n+        match name {\n+            [DOT] | [DOT, DOT] => self.next(),\n+            _ => Some(name),\n+        }\n+    }\n+}\n+\n+/// Open a link relative to the parent directory, ensure no symlinks are followed.\n+fn open_link_no_reparse(parent: &File, name: &[u16], access: u32) -> io::Result<File> {\n+    // This is implemented using the lower level `NtOpenFile` function as\n+    // unfortunately opening a file relative to a parent is not supported by\n+    // win32 functions. It is however a fundamental feature of the NT kernel.\n+    //\n+    // See https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntopenfile\n+    unsafe {\n+        let mut handle = ptr::null_mut();\n+        let mut io_status = c::IO_STATUS_BLOCK::default();\n+        let name_str = c::UNICODE_STRING::from_ref(name);\n+        use crate::sync::atomic::{AtomicU32, Ordering};\n+        // The `OBJ_DONT_REPARSE` attribute ensures that we haven't been\n+        // tricked into following a symlink. However, it may not be available in\n+        // earlier versions of Windows.\n+        static ATTRIBUTES: AtomicU32 = AtomicU32::new(c::OBJ_DONT_REPARSE);\n+        let object = c::OBJECT_ATTRIBUTES {\n+            ObjectName: &name_str,\n+            RootDirectory: parent.as_raw_handle(),\n+            Attributes: ATTRIBUTES.load(Ordering::Relaxed),\n+            ..c::OBJECT_ATTRIBUTES::default()\n+        };\n+        let status = c::NtOpenFile(\n+            &mut handle,\n+            access,\n+            &object,\n+            &mut io_status,\n+            c::FILE_SHARE_DELETE | c::FILE_SHARE_READ | c::FILE_SHARE_WRITE,\n+            // If `name` is a symlink then open the link rather than the target.\n+            c::FILE_OPEN_REPARSE_POINT,\n+        );\n+        // Convert an NTSTATUS to the more familiar Win32 error codes (aka \"DosError\")\n+        if c::nt_success(status) {\n+            Ok(File::from_raw_handle(handle))\n+        } else if status == c::STATUS_DELETE_PENDING {\n+            // We make a special exception for `STATUS_DELETE_PENDING` because\n+            // otherwise this will be mapped to `ERROR_ACCESS_DENIED` which is\n+            // very unhelpful.\n+            Err(io::Error::from_raw_os_error(c::ERROR_DELETE_PENDING as _))\n+        } else if status == c::STATUS_INVALID_PARAMETER\n+            && ATTRIBUTES.load(Ordering::Relaxed) == c::OBJ_DONT_REPARSE\n+        {\n+            // Try without `OBJ_DONT_REPARSE`. See above.\n+            ATTRIBUTES.store(0, Ordering::Relaxed);\n+            open_link_no_reparse(parent, name, access)\n+        } else {\n+            Err(io::Error::from_raw_os_error(c::RtlNtStatusToDosError(status) as _))\n+        }\n+    }\n }\n \n impl AsInner<Handle> for File {\n@@ -756,30 +968,106 @@ pub fn rmdir(p: &Path) -> io::Result<()> {\n     Ok(())\n }\n \n+/// Open a file or directory without following symlinks.\n+fn open_link(path: &Path, access_mode: u32) -> io::Result<File> {\n+    let mut opts = OpenOptions::new();\n+    opts.access_mode(access_mode);\n+    // `FILE_FLAG_BACKUP_SEMANTICS` allows opening directories.\n+    // `FILE_FLAG_OPEN_REPARSE_POINT` opens a link instead of its target.\n+    opts.custom_flags(c::FILE_FLAG_BACKUP_SEMANTICS | c::FILE_FLAG_OPEN_REPARSE_POINT);\n+    File::open(path, &opts)\n+}\n+\n pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n-    let filetype = lstat(path)?.file_type();\n-    if filetype.is_symlink() {\n-        // On Windows symlinks to files and directories are removed differently.\n-        // rmdir only deletes dir symlinks and junctions, not file symlinks.\n-        rmdir(path)\n+    let file = open_link(path, c::DELETE | c::FILE_LIST_DIRECTORY)?;\n+\n+    // Test if the file is not a directory or a symlink to a directory.\n+    if (file.basic_info()?.FileAttributes & c::FILE_ATTRIBUTE_DIRECTORY) == 0 {\n+        return Err(io::Error::from_raw_os_error(c::ERROR_DIRECTORY as _));\n+    }\n+    let mut delete: fn(&File) -> io::Result<()> = File::posix_delete;\n+    let result = match delete(&file) {\n+        Err(e) if e.kind() == io::ErrorKind::DirectoryNotEmpty => {\n+            match remove_dir_all_recursive(&file, delete) {\n+                // Return unexpected errors.\n+                Err(e) if e.kind() != io::ErrorKind::DirectoryNotEmpty => return Err(e),\n+                result => result,\n+            }\n+        }\n+        // If POSIX delete is not supported for this filesystem then fallback to win32 delete.\n+        Err(e)\n+            if e.raw_os_error() == Some(c::ERROR_NOT_SUPPORTED as i32)\n+                || e.raw_os_error() == Some(c::ERROR_INVALID_PARAMETER as i32) =>\n+        {\n+            delete = File::win32_delete;\n+            Err(e)\n+        }\n+        result => result,\n+    };\n+    if result.is_ok() {\n+        Ok(())\n     } else {\n-        remove_dir_all_recursive(path)\n+        // This is a fallback to make sure the directory is actually deleted.\n+        // Otherwise this function is prone to failing with `DirectoryNotEmpty`\n+        // due to possible delays between marking a file for deletion and the\n+        // file actually being deleted from the filesystem.\n+        //\n+        // So we retry a few times before giving up.\n+        for _ in 0..5 {\n+            match remove_dir_all_recursive(&file, delete) {\n+                Err(e) if e.kind() == io::ErrorKind::DirectoryNotEmpty => {}\n+                result => return result,\n+            }\n+        }\n+        // Try one last time.\n+        delete(&file)\n     }\n }\n \n-fn remove_dir_all_recursive(path: &Path) -> io::Result<()> {\n-    for child in readdir(path)? {\n-        let child = child?;\n-        let child_type = child.file_type()?;\n-        if child_type.is_dir() {\n-            remove_dir_all_recursive(&child.path())?;\n-        } else if child_type.is_symlink_dir() {\n-            rmdir(&child.path())?;\n-        } else {\n-            unlink(&child.path())?;\n+fn remove_dir_all_recursive(f: &File, delete: fn(&File) -> io::Result<()>) -> io::Result<()> {\n+    let mut buffer = DirBuff::new();\n+    let mut restart = true;\n+    // Fill the buffer and iterate the entries.\n+    while f.fill_dir_buff(&mut buffer, restart)? {\n+        for name in buffer.iter() {\n+            // Open the file without following symlinks and try deleting it.\n+            // We try opening will all needed permissions and if that is denied\n+            // fallback to opening without `FILE_LIST_DIRECTORY` permission.\n+            // Note `SYNCHRONIZE` permission is needed for synchronous access.\n+            let mut result =\n+                open_link_no_reparse(&f, name, c::SYNCHRONIZE | c::DELETE | c::FILE_LIST_DIRECTORY);\n+            if matches!(&result, Err(e) if e.kind() == io::ErrorKind::PermissionDenied) {\n+                result = open_link_no_reparse(&f, name, c::SYNCHRONIZE | c::DELETE);\n+            }\n+            match result {\n+                Ok(file) => match delete(&file) {\n+                    Err(e) if e.kind() == io::ErrorKind::DirectoryNotEmpty => {\n+                        // Iterate the directory's files.\n+                        // Ignore `DirectoryNotEmpty` errors here. They will be\n+                        // caught when `remove_dir_all` tries to delete the top\n+                        // level directory. It can then decide if to retry or not.\n+                        match remove_dir_all_recursive(&file, delete) {\n+                            Err(e) if e.kind() == io::ErrorKind::DirectoryNotEmpty => {}\n+                            result => result?,\n+                        }\n+                    }\n+                    result => result?,\n+                },\n+                // Ignore error if a delete is already in progress or the file\n+                // has already been deleted. It also ignores sharing violations\n+                // (where a file is locked by another process) as these are\n+                // usually temporary.\n+                Err(e)\n+                    if e.raw_os_error() == Some(c::ERROR_DELETE_PENDING as _)\n+                        || e.kind() == io::ErrorKind::NotFound\n+                        || e.raw_os_error() == Some(c::ERROR_SHARING_VIOLATION as _) => {}\n+                Err(e) => return Err(e),\n+            }\n         }\n+        // Continue reading directory entries without restarting from the beginning,\n+        restart = false;\n     }\n-    rmdir(path)\n+    delete(&f)\n }\n \n pub fn readlink(path: &Path) -> io::Result<PathBuf> {"}]}