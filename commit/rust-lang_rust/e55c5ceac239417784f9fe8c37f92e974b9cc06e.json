{"sha": "e55c5ceac239417784f9fe8c37f92e974b9cc06e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1NWM1Y2VhYzIzOTQxNzc4NGY5ZmU4YzM3ZjkyZTk3NGI5Y2MwNmU=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-08-24T21:01:08Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-08-24T21:21:27Z"}, "message": "Infer purity for || style closures. Closes #3023.", "tree": {"sha": "f7f867e744360f4d3539467ebe6f429469280318", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7f867e744360f4d3539467ebe6f429469280318"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e55c5ceac239417784f9fe8c37f92e974b9cc06e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e55c5ceac239417784f9fe8c37f92e974b9cc06e", "html_url": "https://github.com/rust-lang/rust/commit/e55c5ceac239417784f9fe8c37f92e974b9cc06e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e55c5ceac239417784f9fe8c37f92e974b9cc06e/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5dd01eb2a641d51f0b3135671a0e674d18f27f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5dd01eb2a641d51f0b3135671a0e674d18f27f7", "html_url": "https://github.com/rust-lang/rust/commit/b5dd01eb2a641d51f0b3135671a0e674d18f27f7"}], "stats": {"total": 123, "additions": 72, "deletions": 51}, "files": [{"sha": "6d9713dcd068f501b713f95175c8e32cb6eb7140", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e55c5ceac239417784f9fe8c37f92e974b9cc06e/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e55c5ceac239417784f9fe8c37f92e974b9cc06e/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=e55c5ceac239417784f9fe8c37f92e974b9cc06e", "patch": "@@ -521,8 +521,11 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n         do save_and_restore(self.declared_purity) {\n             do save_and_restore(self.fn_args) {\n                 let is_stack_closure = self.is_stack_closure(id);\n-                let purity =\n-                    ty::ty_fn_purity(ty::node_id_to_type(self.tcx(), id));\n+                let fty = ty::node_id_to_type(self.tcx(), id);\n+                self.declared_purity = ty::determine_inherited_purity(\n+                    copy self.declared_purity,\n+                    ty::ty_fn_purity(fty),\n+                    ty::ty_fn_proto(fty));\n \n                 // In principle, we could consider fk_anon(*) or\n                 // fk_fn_block(*) to be in a ctor, I suppose, but the\n@@ -533,19 +536,17 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n                 match fk {\n                   visit::fk_ctor(*) => {\n                     self.in_ctor = true;\n-                    self.declared_purity = purity;\n                     self.fn_args = @decl.inputs.map(|i| i.id );\n                   }\n                   visit::fk_anon(*) |\n                   visit::fk_fn_block(*) if is_stack_closure => {\n                     self.in_ctor = false;\n-                    // inherits the purity/fn_args from enclosing ctxt\n+                    // inherits the fn_args from enclosing ctxt\n                   }\n                   visit::fk_anon(*) | visit::fk_fn_block(*) |\n                   visit::fk_method(*) | visit::fk_item_fn(*) |\n                   visit::fk_dtor(*) => {\n                     self.in_ctor = false;\n-                    self.declared_purity = purity;\n                     self.fn_args = @decl.inputs.map(|i| i.id );\n                   }\n                 }"}, {"sha": "9bdf2074ba1e8f9541b9a5fc984c8b448aa71965", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e55c5ceac239417784f9fe8c37f92e974b9cc06e/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e55c5ceac239417784f9fe8c37f92e974b9cc06e/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=e55c5ceac239417784f9fe8c37f92e974b9cc06e", "patch": "@@ -187,6 +187,7 @@ export region_variance, rv_covariant, rv_invariant, rv_contravariant;\n export serialize_region_variance, deserialize_region_variance;\n export opt_region_variance;\n export serialize_opt_region_variance, deserialize_opt_region_variance;\n+export determine_inherited_purity;\n \n // Data types\n \n@@ -3406,6 +3407,19 @@ pure fn is_blockish(proto: fn_proto) -> bool {\n     }\n }\n \n+// Determine what purity to check a nested function under\n+pure fn determine_inherited_purity(parent_purity: ast::purity,\n+                                   child_purity: ast::purity,\n+                                   child_proto: ty::fn_proto) -> ast::purity {\n+    // If the closure is a stack closure and hasn't had some non-standard\n+    // purity inferred for it, then check it under its parent's purity.\n+    // Otherwise, use its own\n+    if ty::is_blockish(child_proto) && child_purity == ast::impure_fn {\n+        parent_purity\n+    } else { child_purity }\n+}\n+\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "b8ee661b1b0de1f70861f59f6e49aabddaaea624", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 41, "deletions": 46, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/e55c5ceac239417784f9fe8c37f92e974b9cc06e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e55c5ceac239417784f9fe8c37f92e974b9cc06e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=e55c5ceac239417784f9fe8c37f92e974b9cc06e", "patch": "@@ -228,10 +228,10 @@ fn check_fn(ccx: @crate_ctxt,\n              node_type_substs: map::int_hash()}\n           }\n           some(fcx) => {\n-            assert fn_ty.purity == ast::impure_fn;\n             {infcx: fcx.infcx,\n              locals: fcx.locals,\n-             purity: fcx.purity,\n+             purity: ty::determine_inherited_purity(fcx.purity, fn_ty.purity,\n+                                                    fn_ty.proto),\n              node_types: fcx.node_types,\n              node_type_substs: fcx.node_type_substs}\n           }\n@@ -1187,14 +1187,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         }\n     }\n \n-    enum fn_or_ast_proto {\n-        foap_fn_proto(ty::fn_proto),\n-        foap_ast_proto(ast::proto)\n-    }\n-\n     fn check_expr_fn(fcx: @fn_ctxt,\n                      expr: @ast::expr,\n-                     fn_or_ast_proto: fn_or_ast_proto,\n+                     ast_proto_opt: option<ast::proto>,\n                      decl: ast::fn_decl,\n                      body: ast::blk,\n                      is_loop_body: bool,\n@@ -1205,44 +1200,48 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // avoid capture of bound regions in the expected type.  See\n         // def'n of br_cap_avoid() for a more lengthy explanation of\n         // what's going on here.\n-        let expected_tys = do unpack_expected(fcx, expected) |sty| {\n-            match sty {\n-              ty::ty_fn(ref fn_ty) => {\n+        // Also try to pick up inferred purity and proto, defaulting\n+        // to impure and block. Note that we only will use those for\n+        // block syntax lambdas; that is, lambdas without explicit\n+        // protos.\n+        let expected_sty = unpack_expected(fcx, expected, |x| some(x));\n+        let (expected_tys, expected_purity, expected_proto) =\n+            match expected_sty {\n+              some(ty::ty_fn(ref fn_ty)) => {\n                 let {fn_ty, _} =\n                     replace_bound_regions_in_fn_ty(\n                         tcx, @nil, none, fn_ty,\n                         |br| ty::re_bound(ty::br_cap_avoid(expr.id, @br)));\n-                some({inputs:fn_ty.inputs,\n-                      output:fn_ty.output})\n+                (some({inputs:fn_ty.inputs,\n+                       output:fn_ty.output}),\n+                 fn_ty.purity,\n+                 fn_ty.proto)\n               }\n-              _ => {none}\n-            }\n-        };\n+              _ => {\n+                (none, ast::impure_fn, ty::proto_vstore(ty::vstore_box))\n+              }\n+            };\n \n-        let ast_proto;\n-        match fn_or_ast_proto {\n-            foap_fn_proto(fn_proto) => {\n-                // Generate a fake AST prototype. We'll fill in the type with\n-                // the real one later.\n-                // XXX: This is a hack.\n-                ast_proto = ast::proto_box;\n-            }\n-            foap_ast_proto(existing_ast_proto) => {\n-                ast_proto = existing_ast_proto;\n-            }\n-        }\n \n-        let purity = ast::impure_fn;\n+        // Generate AST prototypes and purity.\n+        // If this is a block lambda (ast_proto == none), these values\n+        // are bogus. We'll fill in the type with the real one later.\n+        // XXX: This is a hack.\n+        let ast_proto = ast_proto_opt.get_default(ast::proto_box);\n+        let ast_purity = ast::impure_fn;\n \n         // construct the function type\n-        let mut fn_ty = astconv::ty_of_fn_decl(fcx, fcx, ast_proto, purity,\n-                                               @~[],\n+        let mut fn_ty = astconv::ty_of_fn_decl(fcx, fcx,\n+                                               ast_proto, ast_purity, @~[],\n                                                decl, expected_tys, expr.span);\n \n         // Patch up the function declaration, if necessary.\n-        match fn_or_ast_proto {\n-            foap_fn_proto(fn_proto) => fn_ty.proto = fn_proto,\n-            foap_ast_proto(_) => {}\n+        match ast_proto_opt {\n+          none => {\n+            fn_ty.purity = expected_purity;\n+            fn_ty.proto = expected_proto;\n+          }\n+          some(_) => { }\n         }\n \n         let fty = ty::mk_fn(tcx, fn_ty);\n@@ -1602,17 +1601,13 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         bot = alt::check_alt(fcx, expr, discrim, arms);\n       }\n       ast::expr_fn(proto, decl, body, cap_clause) => {\n-        check_expr_fn(fcx, expr, foap_ast_proto(proto),\n+        check_expr_fn(fcx, expr, some(proto),\n                       decl, body, false,\n                       expected);\n         capture::check_capture_clause(tcx, expr.id, cap_clause);\n       }\n       ast::expr_fn_block(decl, body, cap_clause) => {\n-        // Take the prototype from the expected type, but default to block:\n-        let proto = do unpack_expected(fcx, expected) |sty| {\n-            match sty { ty::ty_fn({proto, _}) => some(proto), _ => none }\n-        }.get_default(ty::proto_vstore(ty::vstore_box));\n-        check_expr_fn(fcx, expr, foap_fn_proto(proto),\n+        check_expr_fn(fcx, expr, none,\n                       decl, body, false,\n                       expected);\n         capture::check_capture_clause(tcx, expr.id, cap_clause);\n@@ -1625,7 +1620,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // 1. a closure that returns a bool is expected\n         // 2. the cloure that was given returns unit\n         let expected_sty = unpack_expected(fcx, expected, |x| some(x));\n-        let (inner_ty, proto) = match expected_sty {\n+        let inner_ty = match expected_sty {\n           some(ty::ty_fn(fty)) => {\n             match fcx.mk_subty(false, expr.span,\n                                fty.output, ty::mk_bool(tcx)) {\n@@ -1637,7 +1632,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                                     fcx.infcx.ty_to_str(fty.output)));\n               }\n             }\n-            (ty::mk_fn(tcx, {output: ty::mk_nil(tcx) with fty}), fty.proto)\n+            ty::mk_fn(tcx, {output: ty::mk_nil(tcx) with fty})\n           }\n           _ => {\n             tcx.sess.span_fatal(expr.span, ~\"a `loop` function's last \\\n@@ -1647,7 +1642,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         };\n         match check b.node {\n           ast::expr_fn_block(decl, body, cap_clause) => {\n-            check_expr_fn(fcx, b, foap_fn_proto(proto),\n+            check_expr_fn(fcx, b, none,\n                           decl, body, true,\n                           some(inner_ty));\n             demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n@@ -1665,9 +1660,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       }\n       ast::expr_do_body(b) => {\n         let expected_sty = unpack_expected(fcx, expected, |x| some(x));\n-        let (inner_ty, proto) = match expected_sty {\n+        let inner_ty = match expected_sty {\n           some(ty::ty_fn(fty)) => {\n-            (ty::mk_fn(tcx, fty), fty.proto)\n+            ty::mk_fn(tcx, fty)\n           }\n           _ => {\n             tcx.sess.span_fatal(expr.span, ~\"Non-function passed to a `do` \\\n@@ -1677,7 +1672,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         };\n         match check b.node {\n           ast::expr_fn_block(decl, body, cap_clause) => {\n-            check_expr_fn(fcx, b, foap_fn_proto(proto),\n+            check_expr_fn(fcx, b, none,\n                           decl, body, true,\n                           some(inner_ty));\n             demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));"}, {"sha": "691829edf597b7c0a8932ce5b1e4a2bc1888a2c4", "filename": "src/test/compile-fail/purity-infer-fail.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e55c5ceac239417784f9fe8c37f92e974b9cc06e/src%2Ftest%2Fcompile-fail%2Fpurity-infer-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e55c5ceac239417784f9fe8c37f92e974b9cc06e/src%2Ftest%2Fcompile-fail%2Fpurity-infer-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpurity-infer-fail.rs?ref=e55c5ceac239417784f9fe8c37f92e974b9cc06e", "patch": "@@ -0,0 +1,6 @@\n+fn something(f: pure fn()) { f(); }\n+\n+fn main() {\n+    let mut x = ~[];\n+    something(|| vec::push(x, 0) ); //~ ERROR access to impure function prohibited in pure context\n+}"}, {"sha": "4d031be616fcbf76ffe0cb3c8a87b1bd9f9ee3fe", "filename": "src/test/run-pass/purity-infer.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e55c5ceac239417784f9fe8c37f92e974b9cc06e/src%2Ftest%2Frun-pass%2Fpurity-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e55c5ceac239417784f9fe8c37f92e974b9cc06e/src%2Ftest%2Frun-pass%2Fpurity-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpurity-infer.rs?ref=e55c5ceac239417784f9fe8c37f92e974b9cc06e", "patch": "@@ -0,0 +1,5 @@\n+\n+fn something(f: pure fn()) { f(); }\n+fn main() {\n+    something(|| log(error, \"hi!\") );\n+}"}]}