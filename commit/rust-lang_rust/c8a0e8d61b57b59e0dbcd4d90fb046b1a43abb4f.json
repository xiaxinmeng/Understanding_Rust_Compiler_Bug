{"sha": "c8a0e8d61b57b59e0dbcd4d90fb046b1a43abb4f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4YTBlOGQ2MWI1N2I1OWUwZGJjZDRkOTBmYjA0NmIxYTQzYWJiNGY=", "commit": {"author": {"name": "\u00d6mer Sinan A\u011facan", "email": "omeragacan@gmail.com", "date": "2021-03-04T10:36:48Z"}, "committer": {"name": "\u00d6mer Sinan A\u011facan", "email": "omeragacan@gmail.com", "date": "2021-03-04T10:39:41Z"}, "message": "Refactor confirm_builtin_call, remove partial if\n\nPass callee expr to `confirm_builtin_call`. This removes a partial\npattern match in `confirm_builtin_call` and the `panic` in the `else`\nbranch. The diff is large because of indentation changes caused by\nremoving the if-let.", "tree": {"sha": "c270078c0e201e9d601dc4e940f4b9e4561955b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c270078c0e201e9d601dc4e940f4b9e4561955b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8a0e8d61b57b59e0dbcd4d90fb046b1a43abb4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8a0e8d61b57b59e0dbcd4d90fb046b1a43abb4f", "html_url": "https://github.com/rust-lang/rust/commit/c8a0e8d61b57b59e0dbcd4d90fb046b1a43abb4f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8a0e8d61b57b59e0dbcd4d90fb046b1a43abb4f/comments", "author": {"login": "osa1", "id": 448274, "node_id": "MDQ6VXNlcjQ0ODI3NA==", "avatar_url": "https://avatars.githubusercontent.com/u/448274?v=4", "gravatar_id": "", "url": "https://api.github.com/users/osa1", "html_url": "https://github.com/osa1", "followers_url": "https://api.github.com/users/osa1/followers", "following_url": "https://api.github.com/users/osa1/following{/other_user}", "gists_url": "https://api.github.com/users/osa1/gists{/gist_id}", "starred_url": "https://api.github.com/users/osa1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/osa1/subscriptions", "organizations_url": "https://api.github.com/users/osa1/orgs", "repos_url": "https://api.github.com/users/osa1/repos", "events_url": "https://api.github.com/users/osa1/events{/privacy}", "received_events_url": "https://api.github.com/users/osa1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "osa1", "id": 448274, "node_id": "MDQ6VXNlcjQ0ODI3NA==", "avatar_url": "https://avatars.githubusercontent.com/u/448274?v=4", "gravatar_id": "", "url": "https://api.github.com/users/osa1", "html_url": "https://github.com/osa1", "followers_url": "https://api.github.com/users/osa1/followers", "following_url": "https://api.github.com/users/osa1/following{/other_user}", "gists_url": "https://api.github.com/users/osa1/gists{/gist_id}", "starred_url": "https://api.github.com/users/osa1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/osa1/subscriptions", "organizations_url": "https://api.github.com/users/osa1/orgs", "repos_url": "https://api.github.com/users/osa1/repos", "events_url": "https://api.github.com/users/osa1/events{/privacy}", "received_events_url": "https://api.github.com/users/osa1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f7673d077add6b9a066e988b1b8b132a8193d6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f7673d077add6b9a066e988b1b8b132a8193d6c", "html_url": "https://github.com/rust-lang/rust/commit/6f7673d077add6b9a066e988b1b8b132a8193d6c"}], "stats": {"total": 191, "additions": 96, "deletions": 95}, "files": [{"sha": "66f6ac510d592f2017f82eec0b7d8fdb06692b15", "filename": "compiler/rustc_typeck/src/check/callee.rs", "status": "modified", "additions": 96, "deletions": 95, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/c8a0e8d61b57b59e0dbcd4d90fb046b1a43abb4f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8a0e8d61b57b59e0dbcd4d90fb046b1a43abb4f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs?ref=c8a0e8d61b57b59e0dbcd4d90fb046b1a43abb4f", "patch": "@@ -77,11 +77,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let output = match result {\n             None => {\n                 // this will report an error since original_callee_ty is not a fn\n-                self.confirm_builtin_call(call_expr, original_callee_ty, arg_exprs, expected)\n+                self.confirm_builtin_call(\n+                    call_expr,\n+                    callee_expr,\n+                    original_callee_ty,\n+                    arg_exprs,\n+                    expected,\n+                )\n             }\n \n             Some(CallStep::Builtin(callee_ty)) => {\n-                self.confirm_builtin_call(call_expr, callee_ty, arg_exprs, expected)\n+                self.confirm_builtin_call(call_expr, callee_expr, callee_ty, arg_exprs, expected)\n             }\n \n             Some(CallStep::DeferredClosure(fn_sig)) => {\n@@ -281,6 +287,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn confirm_builtin_call(\n         &self,\n         call_expr: &'tcx hir::Expr<'tcx>,\n+        callee_expr: &'tcx hir::Expr<'tcx>,\n         callee_ty: Ty<'tcx>,\n         arg_exprs: &'tcx [hir::Expr<'tcx>],\n         expected: Expectation<'tcx>,\n@@ -299,110 +306,104 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n \n-                if let hir::ExprKind::Call(callee, _) = call_expr.kind {\n-                    let mut err = type_error_struct!(\n-                        self.tcx.sess,\n-                        callee.span,\n-                        callee_ty,\n-                        E0618,\n-                        \"expected function, found {}\",\n-                        match unit_variant {\n-                            Some(ref path) => format!(\"enum variant `{}`\", path),\n-                            None => format!(\"`{}`\", callee_ty),\n-                        }\n-                    );\n+                let mut err = type_error_struct!(\n+                    self.tcx.sess,\n+                    callee_expr.span,\n+                    callee_ty,\n+                    E0618,\n+                    \"expected function, found {}\",\n+                    match unit_variant {\n+                        Some(ref path) => format!(\"enum variant `{}`\", path),\n+                        None => format!(\"`{}`\", callee_ty),\n+                    }\n+                );\n \n-                    self.identify_bad_closure_def_and_call(\n-                        &mut err,\n-                        call_expr.hir_id,\n-                        &callee.kind,\n-                        callee.span,\n-                    );\n+                self.identify_bad_closure_def_and_call(\n+                    &mut err,\n+                    call_expr.hir_id,\n+                    &callee_expr.kind,\n+                    callee_expr.span,\n+                );\n \n-                    if let Some(ref path) = unit_variant {\n-                        err.span_suggestion(\n-                            call_expr.span,\n-                            &format!(\n-                                \"`{}` is a unit variant, you need to write it \\\n+                if let Some(ref path) = unit_variant {\n+                    err.span_suggestion(\n+                        call_expr.span,\n+                        &format!(\n+                            \"`{}` is a unit variant, you need to write it \\\n                                  without the parenthesis\",\n-                                path\n-                            ),\n-                            path.to_string(),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n+                            path\n+                        ),\n+                        path.to_string(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n \n-                    let mut inner_callee_path = None;\n-                    let def = match callee.kind {\n-                        hir::ExprKind::Path(ref qpath) => {\n-                            self.typeck_results.borrow().qpath_res(qpath, callee.hir_id)\n+                let mut inner_callee_path = None;\n+                let def = match callee_expr.kind {\n+                    hir::ExprKind::Path(ref qpath) => {\n+                        self.typeck_results.borrow().qpath_res(qpath, callee_expr.hir_id)\n+                    }\n+                    hir::ExprKind::Call(ref inner_callee, _) => {\n+                        // If the call spans more than one line and the callee kind is\n+                        // itself another `ExprCall`, that's a clue that we might just be\n+                        // missing a semicolon (Issue #51055)\n+                        let call_is_multiline =\n+                            self.tcx.sess.source_map().is_multiline(call_expr.span);\n+                        if call_is_multiline {\n+                            err.span_suggestion(\n+                                callee_expr.span.shrink_to_hi(),\n+                                \"consider using a semicolon here\",\n+                                \";\".to_owned(),\n+                                Applicability::MaybeIncorrect,\n+                            );\n                         }\n-                        hir::ExprKind::Call(ref inner_callee, _) => {\n-                            // If the call spans more than one line and the callee kind is\n-                            // itself another `ExprCall`, that's a clue that we might just be\n-                            // missing a semicolon (Issue #51055)\n-                            let call_is_multiline =\n-                                self.tcx.sess.source_map().is_multiline(call_expr.span);\n-                            if call_is_multiline {\n-                                err.span_suggestion(\n-                                    callee.span.shrink_to_hi(),\n-                                    \"consider using a semicolon here\",\n-                                    \";\".to_owned(),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                            }\n-                            if let hir::ExprKind::Path(ref inner_qpath) = inner_callee.kind {\n-                                inner_callee_path = Some(inner_qpath);\n-                                self.typeck_results\n-                                    .borrow()\n-                                    .qpath_res(inner_qpath, inner_callee.hir_id)\n-                            } else {\n-                                Res::Err\n-                            }\n+                        if let hir::ExprKind::Path(ref inner_qpath) = inner_callee.kind {\n+                            inner_callee_path = Some(inner_qpath);\n+                            self.typeck_results.borrow().qpath_res(inner_qpath, inner_callee.hir_id)\n+                        } else {\n+                            Res::Err\n                         }\n-                        _ => Res::Err,\n-                    };\n-\n-                    err.span_label(call_expr.span, \"call expression requires function\");\n-\n-                    if let Some(span) = self.tcx.hir().res_span(def) {\n-                        let callee_ty = callee_ty.to_string();\n-                        let label = match (unit_variant, inner_callee_path) {\n-                            (Some(path), _) => Some(format!(\"`{}` defined here\", path)),\n-                            (_, Some(hir::QPath::Resolved(_, path))) => {\n-                                self.tcx.sess.source_map().span_to_snippet(path.span).ok().map(\n-                                    |p| format!(\"`{}` defined here returns `{}`\", p, callee_ty),\n-                                )\n-                            }\n-                            _ => {\n-                                match def {\n-                                    // Emit a different diagnostic for local variables, as they are not\n-                                    // type definitions themselves, but rather variables *of* that type.\n-                                    Res::Local(hir_id) => Some(format!(\n-                                        \"`{}` has type `{}`\",\n-                                        self.tcx.hir().name(hir_id),\n-                                        callee_ty\n-                                    )),\n-                                    Res::Def(kind, def_id)\n-                                        if kind.ns() == Some(Namespace::ValueNS) =>\n-                                    {\n-                                        Some(format!(\n-                                            \"`{}` defined here\",\n-                                            self.tcx.def_path_str(def_id),\n-                                        ))\n-                                    }\n-                                    _ => Some(format!(\"`{}` defined here\", callee_ty)),\n+                    }\n+                    _ => Res::Err,\n+                };\n+\n+                err.span_label(call_expr.span, \"call expression requires function\");\n+\n+                if let Some(span) = self.tcx.hir().res_span(def) {\n+                    let callee_ty = callee_ty.to_string();\n+                    let label = match (unit_variant, inner_callee_path) {\n+                        (Some(path), _) => Some(format!(\"`{}` defined here\", path)),\n+                        (_, Some(hir::QPath::Resolved(_, path))) => self\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .span_to_snippet(path.span)\n+                            .ok()\n+                            .map(|p| format!(\"`{}` defined here returns `{}`\", p, callee_ty)),\n+                        _ => {\n+                            match def {\n+                                // Emit a different diagnostic for local variables, as they are not\n+                                // type definitions themselves, but rather variables *of* that type.\n+                                Res::Local(hir_id) => Some(format!(\n+                                    \"`{}` has type `{}`\",\n+                                    self.tcx.hir().name(hir_id),\n+                                    callee_ty\n+                                )),\n+                                Res::Def(kind, def_id) if kind.ns() == Some(Namespace::ValueNS) => {\n+                                    Some(format!(\n+                                        \"`{}` defined here\",\n+                                        self.tcx.def_path_str(def_id),\n+                                    ))\n                                 }\n+                                _ => Some(format!(\"`{}` defined here\", callee_ty)),\n                             }\n-                        };\n-                        if let Some(label) = label {\n-                            err.span_label(span, label);\n                         }\n+                    };\n+                    if let Some(label) = label {\n+                        err.span_label(span, label);\n                     }\n-                    err.emit();\n-                } else {\n-                    bug!(\"call_expr.kind should be an ExprKind::Call, got {:?}\", call_expr.kind);\n                 }\n+                err.emit();\n \n                 // This is the \"default\" function signature, used in case of error.\n                 // In that case, we check each argument against \"error\" in order to"}]}