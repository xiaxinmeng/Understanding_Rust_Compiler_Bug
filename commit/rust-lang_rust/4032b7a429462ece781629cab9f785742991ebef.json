{"sha": "4032b7a429462ece781629cab9f785742991ebef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwMzJiN2E0Mjk0NjJlY2U3ODE2MjljYWI5Zjc4NTc0Mjk5MWViZWY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-11-13T22:57:10Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-11-14T20:46:57Z"}, "message": "std: Synchronize access to global env during `exec`\n\nThis commit, after reverting #55359, applies a different fix for #46775\nwhile also fixing #55775. The basic idea was to go back to pre-#55359\nlibstd, and then fix #46775 in a way that doesn't expose #55775.\n\nThe issue described in #46775 boils down to two problems:\n\n* First, the global environment is reset during `exec` but, but if the\n  `exec` call fails then the global environment was a dangling pointer\n  into free'd memory as the block of memory was deallocated when\n  `Command` is dropped. This is fixed in this commit by installing a\n  `Drop` stack object which ensures that the `environ` pointer is\n  preserved on a failing `exec`.\n\n* Second, the global environment was accessed in an unsynchronized\n  fashion during `exec`. This was fixed by ensuring that the\n  Rust-specific environment lock is acquired for these system-level\n  operations.\n\nThanks to Alex Gaynor for pioneering the solution here!\n\nCloses #55775\n\nCo-authored-by: Alex Gaynor <alex.gaynor@gmail.com>", "tree": {"sha": "b6c33b77b3c46908ddcf75280fac788598a5de86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6c33b77b3c46908ddcf75280fac788598a5de86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4032b7a429462ece781629cab9f785742991ebef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4032b7a429462ece781629cab9f785742991ebef", "html_url": "https://github.com/rust-lang/rust/commit/4032b7a429462ece781629cab9f785742991ebef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4032b7a429462ece781629cab9f785742991ebef/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5856797bda5b1cfecb486e8de439e958325a8a42", "url": "https://api.github.com/repos/rust-lang/rust/commits/5856797bda5b1cfecb486e8de439e958325a8a42", "html_url": "https://github.com/rust-lang/rust/commit/5856797bda5b1cfecb486e8de439e958325a8a42"}], "stats": {"total": 112, "additions": 96, "deletions": 16}, "files": [{"sha": "b387a8d59a56d1b10b028cc1f8f423d5e657877c", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4032b7a429462ece781629cab9f785742991ebef/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4032b7a429462ece781629cab9f785742991ebef/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=4032b7a429462ece781629cab9f785742991ebef", "patch": "@@ -27,15 +27,12 @@ use path::{self, PathBuf};\n use ptr;\n use slice;\n use str;\n-use sys_common::mutex::Mutex;\n+use sys_common::mutex::{Mutex, MutexGuard};\n use sys::cvt;\n use sys::fd;\n use vec;\n \n const TMPBUF_SZ: usize = 128;\n-// We never call `ENV_LOCK.init()`, so it is UB to attempt to\n-// acquire this mutex reentrantly!\n-static ENV_LOCK: Mutex = Mutex::new();\n \n \n extern {\n@@ -408,11 +405,18 @@ pub unsafe fn environ() -> *mut *const *const c_char {\n     &mut environ\n }\n \n+pub unsafe fn env_lock() -> MutexGuard<'static> {\n+    // We never call `ENV_LOCK.init()`, so it is UB to attempt to\n+    // acquire this mutex reentrantly!\n+    static ENV_LOCK: Mutex = Mutex::new();\n+    ENV_LOCK.lock()\n+}\n+\n /// Returns a vector of (variable, value) byte-vector pairs for all the\n /// environment variables of the current process.\n pub fn env() -> Env {\n     unsafe {\n-        let _guard = ENV_LOCK.lock();\n+        let _guard = env_lock();\n         let mut environ = *environ();\n         let mut result = Vec::new();\n         while environ != ptr::null() && *environ != ptr::null() {\n@@ -448,7 +452,7 @@ pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n     // always None as well\n     let k = CString::new(k.as_bytes())?;\n     unsafe {\n-        let _guard = ENV_LOCK.lock();\n+        let _guard = env_lock();\n         let s = libc::getenv(k.as_ptr()) as *const libc::c_char;\n         let ret = if s.is_null() {\n             None\n@@ -464,7 +468,7 @@ pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n     let v = CString::new(v.as_bytes())?;\n \n     unsafe {\n-        let _guard = ENV_LOCK.lock();\n+        let _guard = env_lock();\n         cvt(libc::setenv(k.as_ptr(), v.as_ptr(), 1)).map(|_| ())\n     }\n }\n@@ -473,7 +477,7 @@ pub fn unsetenv(n: &OsStr) -> io::Result<()> {\n     let nbuf = CString::new(n.as_bytes())?;\n \n     unsafe {\n-        let _guard = ENV_LOCK.lock();\n+        let _guard = env_lock();\n         cvt(libc::unsetenv(nbuf.as_ptr())).map(|_| ())\n     }\n }"}, {"sha": "bfbf12f34ee37d261b7ff90a8efad1fa0c32b00c", "filename": "src/libstd/sys/unix/process/process_unix.rs", "status": "modified", "additions": 48, "deletions": 8, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/4032b7a429462ece781629cab9f785742991ebef/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4032b7a429462ece781629cab9f785742991ebef/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=4032b7a429462ece781629cab9f785742991ebef", "patch": "@@ -11,9 +11,9 @@\n use io::{self, Error, ErrorKind};\n use libc::{self, c_int, gid_t, pid_t, uid_t};\n use ptr;\n-\n use sys::cvt;\n use sys::process::process_common::*;\n+use sys;\n \n ////////////////////////////////////////////////////////////////////////////////\n // Command\n@@ -22,8 +22,6 @@ use sys::process::process_common::*;\n impl Command {\n     pub fn spawn(&mut self, default: Stdio, needs_stdin: bool)\n                  -> io::Result<(Process, StdioPipes)> {\n-        use sys;\n-\n         const CLOEXEC_MSG_FOOTER: &'static [u8] = b\"NOEX\";\n \n         let envp = self.capture_env();\n@@ -41,8 +39,21 @@ impl Command {\n \n         let (input, output) = sys::pipe::anon_pipe()?;\n \n+        // Whatever happens after the fork is almost for sure going to touch or\n+        // look at the environment in one way or another (PATH in `execvp` or\n+        // accessing the `environ` pointer ourselves). Make sure no other thread\n+        // is accessing the environment when we do the fork itself.\n+        //\n+        // Note that as soon as we're done with the fork there's no need to hold\n+        // a lock any more because the parent won't do anything and the child is\n+        // in its own process.\n+        let result = unsafe {\n+            let _env_lock = sys::os::env_lock();\n+            cvt(libc::fork())?\n+        };\n+\n         let pid = unsafe {\n-            match cvt(libc::fork())? {\n+            match result {\n                 0 => {\n                     drop(input);\n                     let err = self.do_exec(theirs, envp.as_ref());\n@@ -114,7 +125,16 @@ impl Command {\n         }\n \n         match self.setup_io(default, true) {\n-            Ok((_, theirs)) => unsafe { self.do_exec(theirs, envp.as_ref()) },\n+            Ok((_, theirs)) => {\n+                unsafe {\n+                    // Similar to when forking, we want to ensure that access to\n+                    // the environment is synchronized, so make sure to grab the\n+                    // environment lock before we try to exec.\n+                    let _lock = sys::os::env_lock();\n+\n+                    self.do_exec(theirs, envp.as_ref())\n+                }\n+            }\n             Err(e) => e,\n         }\n     }\n@@ -193,9 +213,6 @@ impl Command {\n         if let Some(ref cwd) = *self.get_cwd() {\n             t!(cvt(libc::chdir(cwd.as_ptr())));\n         }\n-        if let Some(envp) = maybe_envp {\n-            *sys::os::environ() = envp.as_ptr();\n-        }\n \n         // emscripten has no signal support.\n         #[cfg(not(any(target_os = \"emscripten\")))]\n@@ -231,6 +248,27 @@ impl Command {\n             t!(callback());\n         }\n \n+        // Although we're performing an exec here we may also return with an\n+        // error from this function (without actually exec'ing) in which case we\n+        // want to be sure to restore the global environment back to what it\n+        // once was, ensuring that our temporary override, when free'd, doesn't\n+        // corrupt our process's environment.\n+        let mut _reset = None;\n+        if let Some(envp) = maybe_envp {\n+            struct Reset(*const *const libc::c_char);\n+\n+            impl Drop for Reset {\n+                fn drop(&mut self) {\n+                    unsafe {\n+                        *sys::os::environ() = self.0;\n+                    }\n+                }\n+            }\n+\n+            _reset = Some(Reset(*sys::os::environ()));\n+            *sys::os::environ() = envp.as_ptr();\n+        }\n+\n         libc::execvp(self.get_argv()[0], self.get_argv().as_ptr());\n         io::Error::last_os_error()\n     }\n@@ -330,6 +368,8 @@ impl Command {\n                 libc::POSIX_SPAWN_SETSIGMASK;\n             cvt(libc::posix_spawnattr_setflags(&mut attrs.0, flags as _))?;\n \n+            // Make sure we synchronize access to the global `environ` resource\n+            let _env_lock = sys::os::env_lock();\n             let envp = envp.map(|c| c.as_ptr())\n                 .unwrap_or_else(|| *sys::os::environ() as *const _);\n             let ret = libc::posix_spawnp("}, {"sha": "f662945c0cf3df600f1475332dc68b650357b10d", "filename": "src/test/run-pass/command-exec.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4032b7a429462ece781629cab9f785742991ebef/src%2Ftest%2Frun-pass%2Fcommand-exec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4032b7a429462ece781629cab9f785742991ebef/src%2Ftest%2Frun-pass%2Fcommand-exec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcommand-exec.rs?ref=4032b7a429462ece781629cab9f785742991ebef", "patch": "@@ -48,6 +48,23 @@ fn main() {\n                 println!(\"passed\");\n             }\n \n+            \"exec-test5\" => {\n+                env::set_var(\"VARIABLE\", \"ABC\");\n+                Command::new(\"definitely-not-a-real-binary\").env(\"VARIABLE\", \"XYZ\").exec();\n+                assert_eq!(env::var(\"VARIABLE\").unwrap(), \"ABC\");\n+                println!(\"passed\");\n+            }\n+\n+            \"exec-test6\" => {\n+                let err = Command::new(\"echo\").arg(\"passed\").env_clear().exec();\n+                panic!(\"failed to spawn: {}\", err);\n+            }\n+\n+            \"exec-test7\" => {\n+                let err = Command::new(\"echo\").arg(\"passed\").env_remove(\"PATH\").exec();\n+                panic!(\"failed to spawn: {}\", err);\n+            }\n+\n             _ => panic!(\"unknown argument: {}\", arg),\n         }\n         return\n@@ -72,4 +89,23 @@ fn main() {\n     assert!(output.status.success());\n     assert!(output.stderr.is_empty());\n     assert_eq!(output.stdout, b\"passed\\n\");\n+\n+    let output = Command::new(&me).arg(\"exec-test5\").output().unwrap();\n+    assert!(output.status.success());\n+    assert!(output.stderr.is_empty());\n+    assert_eq!(output.stdout, b\"passed\\n\");\n+\n+    if cfg!(target_os = \"linux\") {\n+        let output = Command::new(&me).arg(\"exec-test6\").output().unwrap();\n+        println!(\"{:?}\", output);\n+        assert!(output.status.success());\n+        assert!(output.stderr.is_empty());\n+        assert_eq!(output.stdout, b\"passed\\n\");\n+\n+        let output = Command::new(&me).arg(\"exec-test7\").output().unwrap();\n+        println!(\"{:?}\", output);\n+        assert!(output.status.success());\n+        assert!(output.stderr.is_empty());\n+        assert_eq!(output.stdout, b\"passed\\n\");\n+    }\n }"}]}