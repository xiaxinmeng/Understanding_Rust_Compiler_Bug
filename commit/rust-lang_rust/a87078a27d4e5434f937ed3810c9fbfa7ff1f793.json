{"sha": "a87078a27d4e5434f937ed3810c9fbfa7ff1f793", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4NzA3OGEyN2Q0ZTU0MzRmOTM3ZWQzODEwYzlmYmZhN2ZmMWY3OTM=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2014-10-25T19:27:15Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2014-11-03T20:53:59Z"}, "message": "Clean-up transmutes in librustc\n\nNone of them would break by implementation-defined struct layout, but\none would break with strict lifetime aliasing, and the rest are just\nugly code.", "tree": {"sha": "e948e57d5e71ef9cb5a2afb935d85f443af0b1bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e948e57d5e71ef9cb5a2afb935d85f443af0b1bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a87078a27d4e5434f937ed3810c9fbfa7ff1f793", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a87078a27d4e5434f937ed3810c9fbfa7ff1f793", "html_url": "https://github.com/rust-lang/rust/commit/a87078a27d4e5434f937ed3810c9fbfa7ff1f793", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a87078a27d4e5434f937ed3810c9fbfa7ff1f793/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbb90c3458e1db30fc62c96195c9e71ba2111aa4", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbb90c3458e1db30fc62c96195c9e71ba2111aa4", "html_url": "https://github.com/rust-lang/rust/commit/fbb90c3458e1db30fc62c96195c9e71ba2111aa4"}], "stats": {"total": 231, "additions": 61, "deletions": 170}, "files": [{"sha": "6da74eee8a3195383e65b430a9e49519556ab3ff", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a87078a27d4e5434f937ed3810c9fbfa7ff1f793/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87078a27d4e5434f937ed3810c9fbfa7ff1f793/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=a87078a27d4e5434f937ed3810c9fbfa7ff1f793", "patch": "@@ -532,7 +532,7 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_ids(&self, f: |&mut ast_util::IdVisitor<Context>|) {\n+    fn visit_ids(&mut self, f: |&mut ast_util::IdVisitor<Context>|) {\n         let mut v = ast_util::IdVisitor {\n             operation: self,\n             pass_through_items: false,\n@@ -749,7 +749,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n \n // Output any lints that were previously added to the session.\n impl<'a, 'tcx> IdVisitingOperation for Context<'a, 'tcx> {\n-    fn visit_id(&self, id: ast::NodeId) {\n+    fn visit_id(&mut self, id: ast::NodeId) {\n         match self.tcx.sess.lints.borrow_mut().pop(&id) {\n             None => {}\n             Some(lints) => {"}, {"sha": "a04f94c31bfc50d139285c8a1aec7417991d3129", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a87078a27d4e5434f937ed3810c9fbfa7ff1f793/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87078a27d4e5434f937ed3810c9fbfa7ff1f793/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=a87078a27d4e5434f937ed3810c9fbfa7ff1f793", "patch": "@@ -148,7 +148,7 @@ impl astencode_tag {\n     pub fn from_uint(value : uint) -> Option<astencode_tag> {\n         let is_a_tag = first_astencode_tag <= value && value <= last_astencode_tag;\n         if !is_a_tag { None } else {\n-            Some(unsafe { mem::transmute(value) })\n+            Some(unsafe { mem::transmute::<uint, astencode_tag>(value) })\n         }\n     }\n }\n@@ -247,4 +247,3 @@ pub const tag_type_param_def: uint = 0xa5;\n \n pub const tag_item_generics: uint = 0xa6;\n pub const tag_method_ty_generics: uint = 0xa7;\n-"}, {"sha": "fd389c1f3142691472f133fdb118305dc54d4386", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a87078a27d4e5434f937ed3810c9fbfa7ff1f793/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87078a27d4e5434f937ed3810c9fbfa7ff1f793/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=a87078a27d4e5434f937ed3810c9fbfa7ff1f793", "patch": "@@ -29,7 +29,6 @@ use serialize::Encodable;\n use std::cell::RefCell;\n use std::hash::Hash;\n use std::hash;\n-use std::mem;\n use std::collections::HashMap;\n use syntax::abi;\n use syntax::ast::*;\n@@ -1508,44 +1507,36 @@ fn my_visit_expr(_e: &Expr) { }\n \n fn my_visit_item(i: &Item,\n                  rbml_w: &mut Encoder,\n-                 ecx_ptr: *const int,\n+                 ecx: &EncodeContext,\n                  index: &mut Vec<entry<i64>>) {\n-    let mut rbml_w = unsafe { rbml_w.unsafe_clone() };\n-    // See above\n-    let ecx: &EncodeContext = unsafe { mem::transmute(ecx_ptr) };\n     ecx.tcx.map.with_path(i.id, |path| {\n-        encode_info_for_item(ecx, &mut rbml_w, i, index, path, i.vis);\n+        encode_info_for_item(ecx, rbml_w, i, index, path, i.vis);\n     });\n }\n \n fn my_visit_foreign_item(ni: &ForeignItem,\n                          rbml_w: &mut Encoder,\n-                         ecx_ptr:*const int,\n+                         ecx: &EncodeContext,\n                          index: &mut Vec<entry<i64>>) {\n-    // See above\n-    let ecx: &EncodeContext = unsafe { mem::transmute(ecx_ptr) };\n     debug!(\"writing foreign item {}::{}\",\n             ecx.tcx.map.path_to_string(ni.id),\n             token::get_ident(ni.ident));\n \n-    let mut rbml_w = unsafe {\n-        rbml_w.unsafe_clone()\n-    };\n     let abi = ecx.tcx.map.get_foreign_abi(ni.id);\n     ecx.tcx.map.with_path(ni.id, |path| {\n-        encode_info_for_foreign_item(ecx, &mut rbml_w,\n+        encode_info_for_foreign_item(ecx, rbml_w,\n                                      ni, index,\n                                      path, abi);\n     });\n }\n \n-struct EncodeVisitor<'a,'b:'a> {\n+struct EncodeVisitor<'a, 'b:'a, 'c:'a, 'tcx:'c> {\n     rbml_w_for_visit_item: &'a mut Encoder<'b>,\n-    ecx_ptr:*const int,\n+    ecx: &'a EncodeContext<'c,'tcx>,\n     index: &'a mut Vec<entry<i64>>,\n }\n \n-impl<'a, 'b, 'v> Visitor<'v> for EncodeVisitor<'a, 'b> {\n+impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for EncodeVisitor<'a, 'b, 'c, 'tcx> {\n     fn visit_expr(&mut self, ex: &Expr) {\n         visit::walk_expr(self, ex);\n         my_visit_expr(ex);\n@@ -1554,14 +1545,14 @@ impl<'a, 'b, 'v> Visitor<'v> for EncodeVisitor<'a, 'b> {\n         visit::walk_item(self, i);\n         my_visit_item(i,\n                       self.rbml_w_for_visit_item,\n-                      self.ecx_ptr,\n+                      self.ecx,\n                       self.index);\n     }\n     fn visit_foreign_item(&mut self, ni: &ForeignItem) {\n         visit::walk_foreign_item(self, ni);\n         my_visit_foreign_item(ni,\n                               self.rbml_w_for_visit_item,\n-                              self.ecx_ptr,\n+                              self.ecx,\n                               self.index);\n     }\n }\n@@ -1585,11 +1576,9 @@ fn encode_info_for_items(ecx: &EncodeContext,\n                         syntax::parse::token::special_idents::invalid,\n                         Public);\n \n-    // See comment in `encode_side_tables_for_ii` in astencode\n-    let ecx_ptr: *const int = unsafe { mem::transmute(ecx) };\n     visit::walk_crate(&mut EncodeVisitor {\n         index: &mut index,\n-        ecx_ptr: ecx_ptr,\n+        ecx: ecx,\n         rbml_w_for_visit_item: &mut *rbml_w,\n     }, krate);\n "}, {"sha": "1310e20d7a45f1bb32c62632a72d0439871d9cef", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a87078a27d4e5434f937ed3810c9fbfa7ff1f793/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87078a27d4e5434f937ed3810c9fbfa7ff1f793/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=a87078a27d4e5434f937ed3810c9fbfa7ff1f793", "patch": "@@ -231,7 +231,6 @@ use std::c_str::ToCStr;\n use std::cmp;\n use std::io::fs::PathExtensions;\n use std::io;\n-use std::mem;\n use std::ptr;\n use std::slice;\n use std::string;\n@@ -287,8 +286,8 @@ pub struct Library {\n \n pub struct ArchiveMetadata {\n     _archive: ArchiveRO,\n-    // See comments in ArchiveMetadata::new for why this is static\n-    data: &'static [u8],\n+    // points into self._archive\n+    data: *const [u8],\n }\n \n pub struct CratePaths {\n@@ -709,33 +708,21 @@ pub fn note_crate_name(diag: &SpanHandler, name: &str) {\n \n impl ArchiveMetadata {\n     fn new(ar: ArchiveRO) -> Option<ArchiveMetadata> {\n-        let data: &'static [u8] = {\n-            let data = match ar.read(METADATA_FILENAME) {\n-                Some(data) => data,\n-                None => {\n-                    debug!(\"didn't find '{}' in the archive\", METADATA_FILENAME);\n-                    return None;\n-                }\n-            };\n-            // This data is actually a pointer inside of the archive itself, but\n-            // we essentially want to cache it because the lookup inside the\n-            // archive is a fairly expensive operation (and it's queried for\n-            // *very* frequently). For this reason, we transmute it to the\n-            // static lifetime to put into the struct. Note that the buffer is\n-            // never actually handed out with a static lifetime, but rather the\n-            // buffer is loaned with the lifetime of this containing object.\n-            // Hence, we're guaranteed that the buffer will never be used after\n-            // this object is dead, so this is a safe operation to transmute and\n-            // store the data as a static buffer.\n-            unsafe { mem::transmute(data) }\n+        let data = match ar.read(METADATA_FILENAME) {\n+            Some(data) => data as *const [u8],\n+            None => {\n+                debug!(\"didn't find '{}' in the archive\", METADATA_FILENAME);\n+                return None;\n+            }\n         };\n+\n         Some(ArchiveMetadata {\n             _archive: ar,\n             data: data,\n         })\n     }\n \n-    pub fn as_slice<'a>(&'a self) -> &'a [u8] { self.data }\n+    pub fn as_slice<'a>(&'a self) -> &'a [u8] { unsafe { &*self.data } }\n }\n \n // Just a small wrapper to time how long reading metadata takes.\n@@ -798,7 +785,7 @@ fn get_metadata_section_imp(os: abi::Os, filename: &Path) -> Result<MetadataBlob\n                 let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;\n                 let mut found =\n                     Err(format!(\"metadata not found: '{}'\", filename.display()));\n-                let cvbuf: *const u8 = mem::transmute(cbuf);\n+                let cvbuf: *const u8 = cbuf as *const u8;\n                 let vlen = encoder::metadata_encoding_version.len();\n                 debug!(\"checking {} bytes of metadata-version stamp\",\n                        vlen);"}, {"sha": "8cd1004af403db4c58c04f54c9dded1576f70fe1", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 10, "deletions": 33, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a87078a27d4e5434f937ed3810c9fbfa7ff1f793/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87078a27d4e5434f937ed3810c9fbfa7ff1f793/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=a87078a27d4e5434f937ed3810c9fbfa7ff1f793", "patch": "@@ -38,9 +38,7 @@ use syntax::parse::token;\n use syntax::ptr::P;\n use syntax;\n \n-use libc;\n use std::io::Seek;\n-use std::mem;\n use std::rc::Rc;\n \n use rbml::io::SeekableMemWriter;\n@@ -1128,46 +1126,25 @@ impl<'a> write_tag_and_id for Encoder<'a> {\n     }\n }\n \n-struct SideTableEncodingIdVisitor<'a,'b:'a> {\n-    ecx_ptr: *const libc::c_void,\n-    new_rbml_w: &'a mut Encoder<'b>,\n+struct SideTableEncodingIdVisitor<'a, 'b:'a, 'c:'a, 'tcx:'c> {\n+    ecx: &'a e::EncodeContext<'c, 'tcx>,\n+    rbml_w: &'a mut Encoder<'b>,\n }\n \n-impl<'a,'b> ast_util::IdVisitingOperation for\n-        SideTableEncodingIdVisitor<'a,'b> {\n-    fn visit_id(&self, id: ast::NodeId) {\n-        // Note: this will cause a copy of rbml_w, which is bad as\n-        // it is mutable. But I believe it's harmless since we generate\n-        // balanced EBML.\n-        //\n-        // FIXME(pcwalton): Don't copy this way.\n-        let mut new_rbml_w = unsafe {\n-            self.new_rbml_w.unsafe_clone()\n-        };\n-        // See above\n-        let ecx: &e::EncodeContext = unsafe {\n-            mem::transmute(self.ecx_ptr)\n-        };\n-        encode_side_tables_for_id(ecx, &mut new_rbml_w, id)\n+impl<'a, 'b, 'c, 'tcx> ast_util::IdVisitingOperation for\n+        SideTableEncodingIdVisitor<'a, 'b, 'c, 'tcx> {\n+    fn visit_id(&mut self, id: ast::NodeId) {\n+        encode_side_tables_for_id(self.ecx, self.rbml_w, id)\n     }\n }\n \n fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n                              rbml_w: &mut Encoder,\n                              ii: &ast::InlinedItem) {\n     rbml_w.start_tag(c::tag_table as uint);\n-    let mut new_rbml_w = unsafe {\n-        rbml_w.unsafe_clone()\n-    };\n-\n-    // Because the ast visitor uses @IdVisitingOperation, I can't pass in\n-    // ecx directly, but /I/ know that it'll be fine since the lifetime is\n-    // tied to the CrateContext that lives throughout this entire section.\n-    ast_util::visit_ids_for_inlined_item(ii, &SideTableEncodingIdVisitor {\n-        ecx_ptr: unsafe {\n-            mem::transmute(ecx)\n-        },\n-        new_rbml_w: &mut new_rbml_w,\n+    ast_util::visit_ids_for_inlined_item(ii, &mut SideTableEncodingIdVisitor {\n+        ecx: ecx,\n+        rbml_w: rbml_w\n     });\n     rbml_w.end_tag();\n }"}, {"sha": "a612b4badc1758fdf910d9e7f0865e491bfa6526", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a87078a27d4e5434f937ed3810c9fbfa7ff1f793/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87078a27d4e5434f937ed3810c9fbfa7ff1f793/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=a87078a27d4e5434f937ed3810c9fbfa7ff1f793", "patch": "@@ -118,7 +118,6 @@ use util::nodemap::NodeMap;\n \n use std::fmt;\n use std::io;\n-use std::mem::transmute;\n use std::rc::Rc;\n use std::str;\n use std::uint;\n@@ -380,10 +379,7 @@ fn visit_fn(ir: &mut IrMaps,\n     // swap in a new set of IR maps for this function body:\n     let mut fn_maps = IrMaps::new(ir.tcx);\n \n-    unsafe {\n-        debug!(\"creating fn_maps: {}\",\n-               transmute::<&IrMaps, *const IrMaps>(&fn_maps));\n-    }\n+    debug!(\"creating fn_maps: {}\", &fn_maps as *const IrMaps);\n \n     for arg in decl.inputs.iter() {\n         pat_util::pat_bindings(&ir.tcx.def_map,"}, {"sha": "bec02c736adcb34f4ea7a9e958dc79322b85e39b", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 1, "deletions": 57, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/a87078a27d4e5434f937ed3810c9fbfa7ff1f793/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87078a27d4e5434f937ed3810c9fbfa7ff1f793/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=a87078a27d4e5434f937ed3810c9fbfa7ff1f793", "patch": "@@ -16,66 +16,10 @@ use middle::ty_fold::{TypeFoldable, TypeFolder};\n use util::ppaux::Repr;\n \n use std::fmt;\n-use std::mem;\n-use std::raw;\n-use std::slice::{Items, MutItems};\n+use std::slice::Items;\n use std::vec::Vec;\n use syntax::codemap::{Span, DUMMY_SP};\n \n-///////////////////////////////////////////////////////////////////////////\n-// HomogeneousTuple3 trait\n-//\n-// This could be moved into standard library at some point.\n-\n-trait HomogeneousTuple3<T> {\n-    fn len(&self) -> uint;\n-    fn as_slice<'a>(&'a self) -> &'a [T];\n-    fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T];\n-    fn iter<'a>(&'a self) -> Items<'a, T>;\n-    fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T>;\n-    fn get<'a>(&'a self, index: uint) -> Option<&'a T>;\n-    fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut T>;\n-}\n-\n-impl<T> HomogeneousTuple3<T> for (T, T, T) {\n-    fn len(&self) -> uint {\n-        3\n-    }\n-\n-    fn as_slice<'a>(&'a self) -> &'a [T] {\n-        unsafe {\n-            let ptr: *const T = mem::transmute(self);\n-            let slice = raw::Slice { data: ptr, len: 3 };\n-            mem::transmute(slice)\n-        }\n-    }\n-\n-    fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n-        unsafe {\n-            let ptr: *const T = mem::transmute(self);\n-            let slice = raw::Slice { data: ptr, len: 3 };\n-            mem::transmute(slice)\n-        }\n-    }\n-\n-    fn iter<'a>(&'a self) -> Items<'a, T> {\n-        let slice: &'a [T] = self.as_slice();\n-        slice.iter()\n-    }\n-\n-    fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T> {\n-        self.as_mut_slice().iter_mut()\n-    }\n-\n-    fn get<'a>(&'a self, index: uint) -> Option<&'a T> {\n-        self.as_slice().get(index)\n-    }\n-\n-    fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut T> {\n-        Some(&mut self.as_mut_slice()[index]) // wrong: fallible\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n \n /**"}, {"sha": "1746f78531161b1fae833a8bb45dff613f64bb43", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a87078a27d4e5434f937ed3810c9fbfa7ff1f793/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87078a27d4e5434f937ed3810c9fbfa7ff1f793/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=a87078a27d4e5434f937ed3810c9fbfa7ff1f793", "patch": "@@ -27,6 +27,7 @@ use std::collections::HashMap;\n use libc::c_uint;\n \n #[deriving(Clone, PartialEq, Show)]\n+#[repr(C)]\n pub struct Type {\n     rf: TypeRef\n }\n@@ -283,9 +284,10 @@ impl Type {\n             if n_elts == 0 {\n                 return Vec::new();\n             }\n-            let mut elts = Vec::from_elem(n_elts, 0 as TypeRef);\n-            llvm::LLVMGetStructElementTypes(self.to_ref(), &mut elts[0]);\n-            mem::transmute(elts)\n+            let mut elts = Vec::from_elem(n_elts, Type { rf: 0 as TypeRef });\n+            llvm::LLVMGetStructElementTypes(self.to_ref(),\n+                                            elts.as_mut_ptr() as *mut TypeRef);\n+            elts\n         }\n     }\n \n@@ -296,9 +298,10 @@ impl Type {\n     pub fn func_params(&self) -> Vec<Type> {\n         unsafe {\n             let n_args = llvm::LLVMCountParamTypes(self.to_ref()) as uint;\n-            let args = Vec::from_elem(n_args, 0 as TypeRef);\n-            llvm::LLVMGetParamTypes(self.to_ref(), args.as_ptr());\n-            mem::transmute(args)\n+            let mut args = Vec::from_elem(n_args, Type { rf: 0 as TypeRef });\n+            llvm::LLVMGetParamTypes(self.to_ref(),\n+                                    args.as_mut_ptr() as *mut TypeRef);\n+            args\n         }\n     }\n "}, {"sha": "48e1e590058bb16dbac9522005b37e29d3f12fed", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a87078a27d4e5434f937ed3810c9fbfa7ff1f793/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87078a27d4e5434f937ed3810c9fbfa7ff1f793/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=a87078a27d4e5434f937ed3810c9fbfa7ff1f793", "patch": "@@ -547,7 +547,7 @@ extern {\n     pub fn LLVMIsFunctionVarArg(FunctionTy: TypeRef) -> Bool;\n     pub fn LLVMGetReturnType(FunctionTy: TypeRef) -> TypeRef;\n     pub fn LLVMCountParamTypes(FunctionTy: TypeRef) -> c_uint;\n-    pub fn LLVMGetParamTypes(FunctionTy: TypeRef, Dest: *const TypeRef);\n+    pub fn LLVMGetParamTypes(FunctionTy: TypeRef, Dest: *mut TypeRef);\n \n     /* Operations on struct types */\n     pub fn LLVMStructTypeInContext(C: ContextRef,\n@@ -2195,4 +2195,3 @@ pub unsafe fn static_link_hack_this_sucks() {\n // Works to the above fix for #15460 to ensure LLVM dependencies that\n // are only used by rustllvm don't get stripped by the linker.\n mod llvmdeps;\n-"}, {"sha": "863f53be7988346f59c4e23c351d7de63425522d", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a87078a27d4e5434f937ed3810c9fbfa7ff1f793/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87078a27d4e5434f937ed3810c9fbfa7ff1f793/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=a87078a27d4e5434f937ed3810c9fbfa7ff1f793", "patch": "@@ -21,7 +21,6 @@ use ptr::P;\n use visit::Visitor;\n use visit;\n \n-use std::cell::Cell;\n use std::cmp;\n use std::u32;\n \n@@ -333,20 +332,20 @@ impl IdRange {\n }\n \n pub trait IdVisitingOperation {\n-    fn visit_id(&self, node_id: NodeId);\n+    fn visit_id(&mut self, node_id: NodeId);\n }\n \n /// A visitor that applies its operation to all of the node IDs\n /// in a visitable thing.\n \n pub struct IdVisitor<'a, O:'a> {\n-    pub operation: &'a O,\n+    pub operation: &'a mut O,\n     pub pass_through_items: bool,\n     pub visited_outermost: bool,\n }\n \n impl<'a, O: IdVisitingOperation> IdVisitor<'a, O> {\n-    fn visit_generics_helper(&self, generics: &Generics) {\n+    fn visit_generics_helper(&mut self, generics: &Generics) {\n         for type_parameter in generics.ty_params.iter() {\n             self.operation.visit_id(type_parameter.id)\n         }\n@@ -540,7 +539,7 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n }\n \n pub fn visit_ids_for_inlined_item<O: IdVisitingOperation>(item: &InlinedItem,\n-                                                          operation: &O) {\n+                                                          operation: &mut O) {\n     let mut id_visitor = IdVisitor {\n         operation: operation,\n         pass_through_items: true,\n@@ -551,23 +550,21 @@ pub fn visit_ids_for_inlined_item<O: IdVisitingOperation>(item: &InlinedItem,\n }\n \n struct IdRangeComputingVisitor {\n-    result: Cell<IdRange>,\n+    result: IdRange,\n }\n \n impl IdVisitingOperation for IdRangeComputingVisitor {\n-    fn visit_id(&self, id: NodeId) {\n-        let mut id_range = self.result.get();\n-        id_range.add(id);\n-        self.result.set(id_range)\n+    fn visit_id(&mut self, id: NodeId) {\n+        self.result.add(id);\n     }\n }\n \n pub fn compute_id_range_for_inlined_item(item: &InlinedItem) -> IdRange {\n-    let visitor = IdRangeComputingVisitor {\n-        result: Cell::new(IdRange::max())\n+    let mut visitor = IdRangeComputingVisitor {\n+        result: IdRange::max()\n     };\n-    visit_ids_for_inlined_item(item, &visitor);\n-    visitor.result.get()\n+    visit_ids_for_inlined_item(item, &mut visitor);\n+    visitor.result\n }\n \n pub fn compute_id_range_for_fn_body(fk: visit::FnKind,\n@@ -582,16 +579,16 @@ pub fn compute_id_range_for_fn_body(fk: visit::FnKind,\n      * ignoring nested items.\n      */\n \n-    let visitor = IdRangeComputingVisitor {\n-        result: Cell::new(IdRange::max())\n+    let mut visitor = IdRangeComputingVisitor {\n+        result: IdRange::max()\n     };\n     let mut id_visitor = IdVisitor {\n-        operation: &visitor,\n+        operation: &mut visitor,\n         pass_through_items: false,\n         visited_outermost: false,\n     };\n     id_visitor.visit_fn(fk, decl, body, sp, id);\n-    visitor.result.get()\n+    id_visitor.operation.result\n }\n \n pub fn walk_pat(pat: &Pat, it: |&Pat| -> bool) -> bool {"}]}