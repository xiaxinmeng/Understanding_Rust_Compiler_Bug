{"sha": "ae3b8690c1e9c4debf20b4455ad50a79d5859ee9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlM2I4NjkwYzFlOWM0ZGViZjIwYjQ0NTVhZDUwYTc5ZDU4NTllZTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-20T18:57:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-20T18:57:50Z"}, "message": "auto merge of #5975 : huonw/rust/rustc-intrinsics-fixed-stack, r=pcwalton\n\nThis implements the fixed_stack_segment for items with the rust-intrinsic abi, and then uses it to make f32 and f64 use intrinsics where appropriate, but without overflowing stacks and killing canaries (cf. #5686 and #5697). Hopefully.\r\n\r\n@pcwalton, the fixed_stack_segment implementation involved mirroring its implementation in `base.rs` in `trans_closure`, but without adding the `set_no_inline` (reasoning: that would defeat the purpose of intrinsics), which is possibly incorrect.\r\n\r\nI'm a little hazy about how the underlying structure works, so I've annotated the 4 that have caused problems so far, but there's no guarantee that the other intrinsics are entirely well-behaved.\r\n\r\nAnyway, it has good results (the following are just summing the result of each function for 1 up to 100 million):\r\n\r\n```\r\n$ ./intrinsics-perf.sh f32\r\nfunc   new   old   speedup\r\nsin    0.80  2.75  3.44\r\ncos    0.80  2.76  3.45\r\nsqrt   0.56  2.73  4.88\r\nln     1.01  2.94  2.91\r\nlog10  0.97  2.90  2.99\r\nlog2   1.01  2.95  2.92\r\nexp    0.90  2.85  3.17\r\nexp2   0.92  2.87  3.12\r\npow    6.95  8.57  1.23\r\n\r\n   geometric mean: 2.97\r\n\r\n$ ./intrinsics-perf.sh f64\r\nfunc   new   old   speedup\r\nsin    12.08  14.06  1.16\r\ncos    12.04  13.67  1.14\r\nsqrt   0.49  2.73  5.57\r\nln     4.11  5.59  1.36\r\nlog10  5.09  6.54  1.28\r\nlog2   2.78  5.10  1.83\r\nexp    2.00  3.97  1.99\r\nexp2   1.71  3.71  2.17\r\npow    5.90  7.51  1.27\r\n\r\n   geometric mean: 1.72\r\n```\r\n\r\nSo about 3x faster on average for f32, and 1.7x for f64. This isn't exactly apples to apples though, since this patch also adds #[inline(always)] to all the function definitions too, which possibly gives a speedup.\r\n\r\n(fwiw, GitHub is showing 93c0888 after d9c54f8 (since I cherry-picked the latter from #5697), but git's order is the other way.)", "tree": {"sha": "58406cf3c0ff22fc9ada505a40109c6acc779a2d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58406cf3c0ff22fc9ada505a40109c6acc779a2d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae3b8690c1e9c4debf20b4455ad50a79d5859ee9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae3b8690c1e9c4debf20b4455ad50a79d5859ee9", "html_url": "https://github.com/rust-lang/rust/commit/ae3b8690c1e9c4debf20b4455ad50a79d5859ee9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae3b8690c1e9c4debf20b4455ad50a79d5859ee9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b09267b762398a3c851ecfd55d5d01aee906352", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b09267b762398a3c851ecfd55d5d01aee906352", "html_url": "https://github.com/rust-lang/rust/commit/2b09267b762398a3c851ecfd55d5d01aee906352"}, {"sha": "c5baeb1db3d84e1ab0d14a8055db3a7d3cba638d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5baeb1db3d84e1ab0d14a8055db3a7d3cba638d", "html_url": "https://github.com/rust-lang/rust/commit/c5baeb1db3d84e1ab0d14a8055db3a7d3cba638d"}], "stats": {"total": 350, "additions": 188, "deletions": 162}, "files": [{"sha": "6233f8c2a61b53425aaa10999ddfddf2859028fa", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 80, "deletions": 72, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/ae3b8690c1e9c4debf20b4455ad50a79d5859ee9/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae3b8690c1e9c4debf20b4455ad50a79d5859ee9/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=ae3b8690c1e9c4debf20b4455ad50a79d5859ee9", "patch": "@@ -10,12 +10,9 @@\n \n //! Operations and constants for `f32`\n \n-use cmath;\n-use libc::{c_float, c_int};\n use num::strconv;\n use num;\n use option::Option;\n-use unstable::intrinsics::floorf32;\n use from_str;\n use to_str;\n \n@@ -24,79 +21,93 @@ use to_str;\n \n pub use cmath::c_float_targ_consts::*;\n \n+// An inner module is required to get the #[inline(always)] attribute on the\n+// functions.\n+pub use self::delegated::*;\n+\n macro_rules! delegate(\n     (\n-        fn $name:ident(\n-            $(\n-                $arg:ident : $arg_ty:ty\n-            ),*\n-        ) -> $rv:ty = $bound_name:path\n+        $(\n+            fn $name:ident(\n+                $(\n+                    $arg:ident : $arg_ty:ty\n+                ),*\n+            ) -> $rv:ty = $bound_name:path\n+        ),*\n     ) => (\n-        pub fn $name($( $arg : $arg_ty ),*) -> $rv {\n-            unsafe {\n-                $bound_name($( $arg ),*)\n-            }\n+        mod delegated {\n+            use cmath::c_float_utils;\n+            use libc::{c_float, c_int};\n+            use unstable::intrinsics;\n+\n+            $(\n+                #[inline(always)]\n+                pub fn $name($( $arg : $arg_ty ),*) -> $rv {\n+                    unsafe {\n+                        $bound_name($( $arg ),*)\n+                    }\n+                }\n+            )*\n         }\n     )\n )\n \n-delegate!(fn acos(n: c_float) -> c_float = cmath::c_float_utils::acos)\n-delegate!(fn asin(n: c_float) -> c_float = cmath::c_float_utils::asin)\n-delegate!(fn atan(n: c_float) -> c_float = cmath::c_float_utils::atan)\n-delegate!(fn atan2(a: c_float, b: c_float) -> c_float =\n-    cmath::c_float_utils::atan2)\n-delegate!(fn cbrt(n: c_float) -> c_float = cmath::c_float_utils::cbrt)\n-delegate!(fn ceil(n: c_float) -> c_float = cmath::c_float_utils::ceil)\n-delegate!(fn copysign(x: c_float, y: c_float) -> c_float =\n-    cmath::c_float_utils::copysign)\n-delegate!(fn cos(n: c_float) -> c_float = cmath::c_float_utils::cos)\n-delegate!(fn cosh(n: c_float) -> c_float = cmath::c_float_utils::cosh)\n-delegate!(fn erf(n: c_float) -> c_float = cmath::c_float_utils::erf)\n-delegate!(fn erfc(n: c_float) -> c_float = cmath::c_float_utils::erfc)\n-delegate!(fn exp(n: c_float) -> c_float = cmath::c_float_utils::exp)\n-delegate!(fn expm1(n: c_float) -> c_float = cmath::c_float_utils::expm1)\n-delegate!(fn exp2(n: c_float) -> c_float = cmath::c_float_utils::exp2)\n-delegate!(fn abs(n: c_float) -> c_float = cmath::c_float_utils::abs)\n-delegate!(fn abs_sub(a: c_float, b: c_float) -> c_float =\n-    cmath::c_float_utils::abs_sub)\n-delegate!(fn mul_add(a: c_float, b: c_float, c: c_float) -> c_float =\n-    cmath::c_float_utils::mul_add)\n-delegate!(fn fmax(a: c_float, b: c_float) -> c_float =\n-    cmath::c_float_utils::fmax)\n-delegate!(fn fmin(a: c_float, b: c_float) -> c_float =\n-    cmath::c_float_utils::fmin)\n-delegate!(fn nextafter(x: c_float, y: c_float) -> c_float =\n-    cmath::c_float_utils::nextafter)\n-delegate!(fn frexp(n: c_float, value: &mut c_int) -> c_float =\n-    cmath::c_float_utils::frexp)\n-delegate!(fn hypot(x: c_float, y: c_float) -> c_float =\n-    cmath::c_float_utils::hypot)\n-delegate!(fn ldexp(x: c_float, n: c_int) -> c_float =\n-    cmath::c_float_utils::ldexp)\n-delegate!(fn lgamma(n: c_float, sign: &mut c_int) -> c_float =\n-    cmath::c_float_utils::lgamma)\n-delegate!(fn ln(n: c_float) -> c_float = cmath::c_float_utils::ln)\n-delegate!(fn log_radix(n: c_float) -> c_float =\n-    cmath::c_float_utils::log_radix)\n-delegate!(fn ln1p(n: c_float) -> c_float = cmath::c_float_utils::ln1p)\n-delegate!(fn log10(n: c_float) -> c_float = cmath::c_float_utils::log10)\n-delegate!(fn log2(n: c_float) -> c_float = cmath::c_float_utils::log2)\n-delegate!(fn ilog_radix(n: c_float) -> c_int =\n-    cmath::c_float_utils::ilog_radix)\n-delegate!(fn modf(n: c_float, iptr: &mut c_float) -> c_float =\n-    cmath::c_float_utils::modf)\n-delegate!(fn pow(n: c_float, e: c_float) -> c_float =\n-    cmath::c_float_utils::pow)\n-delegate!(fn round(n: c_float) -> c_float = cmath::c_float_utils::round)\n-delegate!(fn ldexp_radix(n: c_float, i: c_int) -> c_float =\n-    cmath::c_float_utils::ldexp_radix)\n-delegate!(fn sin(n: c_float) -> c_float = cmath::c_float_utils::sin)\n-delegate!(fn sinh(n: c_float) -> c_float = cmath::c_float_utils::sinh)\n-delegate!(fn sqrt(n: c_float) -> c_float = cmath::c_float_utils::sqrt)\n-delegate!(fn tan(n: c_float) -> c_float = cmath::c_float_utils::tan)\n-delegate!(fn tanh(n: c_float) -> c_float = cmath::c_float_utils::tanh)\n-delegate!(fn tgamma(n: c_float) -> c_float = cmath::c_float_utils::tgamma)\n-delegate!(fn trunc(n: c_float) -> c_float = cmath::c_float_utils::trunc)\n+delegate!(\n+    // intrinsics\n+    fn abs(n: f32) -> f32 = intrinsics::fabsf32,\n+    fn cos(n: f32) -> f32 = intrinsics::cosf32,\n+    fn exp(n: f32) -> f32 = intrinsics::expf32,\n+    fn exp2(n: f32) -> f32 = intrinsics::exp2f32,\n+    fn floor(x: f32) -> f32 = intrinsics::floorf32,\n+    fn ln(n: f32) -> f32 = intrinsics::logf32,\n+    fn log10(n: f32) -> f32 = intrinsics::log10f32,\n+    fn log2(n: f32) -> f32 = intrinsics::log2f32,\n+    fn mul_add(a: f32, b: f32, c: f32) -> f32 = intrinsics::fmaf32,\n+    fn pow(n: f32, e: f32) -> f32 = intrinsics::powf32,\n+    fn powi(n: f32, e: c_int) -> f32 = intrinsics::powif32,\n+    fn sin(n: f32) -> f32 = intrinsics::sinf32,\n+    fn sqrt(n: f32) -> f32 = intrinsics::sqrtf32,\n+\n+    // LLVM 3.3 required to use intrinsics for these four\n+    fn ceil(n: c_float) -> c_float = c_float_utils::ceil,\n+    fn trunc(n: c_float) -> c_float = c_float_utils::trunc,\n+    /*\n+    fn ceil(n: f32) -> f32 = intrinsics::ceilf32,\n+    fn trunc(n: f32) -> f32 = intrinsics::truncf32,\n+    fn rint(n: f32) -> f32 = intrinsics::rintf32,\n+    fn nearbyint(n: f32) -> f32 = intrinsics::nearbyintf32,\n+    */\n+\n+    // cmath\n+    fn acos(n: c_float) -> c_float = c_float_utils::acos,\n+    fn asin(n: c_float) -> c_float = c_float_utils::asin,\n+    fn atan(n: c_float) -> c_float = c_float_utils::atan,\n+    fn atan2(a: c_float, b: c_float) -> c_float = c_float_utils::atan2,\n+    fn cbrt(n: c_float) -> c_float = c_float_utils::cbrt,\n+    fn copysign(x: c_float, y: c_float) -> c_float = c_float_utils::copysign,\n+    fn cosh(n: c_float) -> c_float = c_float_utils::cosh,\n+    fn erf(n: c_float) -> c_float = c_float_utils::erf,\n+    fn erfc(n: c_float) -> c_float = c_float_utils::erfc,\n+    fn expm1(n: c_float) -> c_float = c_float_utils::expm1,\n+    fn abs_sub(a: c_float, b: c_float) -> c_float = c_float_utils::abs_sub,\n+    fn fmax(a: c_float, b: c_float) -> c_float = c_float_utils::fmax,\n+    fn fmin(a: c_float, b: c_float) -> c_float = c_float_utils::fmin,\n+    fn nextafter(x: c_float, y: c_float) -> c_float = c_float_utils::nextafter,\n+    fn frexp(n: c_float, value: &mut c_int) -> c_float = c_float_utils::frexp,\n+    fn hypot(x: c_float, y: c_float) -> c_float = c_float_utils::hypot,\n+    fn ldexp(x: c_float, n: c_int) -> c_float = c_float_utils::ldexp,\n+    fn lgamma(n: c_float, sign: &mut c_int) -> c_float = c_float_utils::lgamma,\n+    fn log_radix(n: c_float) -> c_float = c_float_utils::log_radix,\n+    fn ln1p(n: c_float) -> c_float = c_float_utils::ln1p,\n+    fn ilog_radix(n: c_float) -> c_int = c_float_utils::ilog_radix,\n+    fn modf(n: c_float, iptr: &mut c_float) -> c_float = c_float_utils::modf,\n+    fn round(n: c_float) -> c_float = c_float_utils::round,\n+    fn ldexp_radix(n: c_float, i: c_int) -> c_float = c_float_utils::ldexp_radix,\n+    fn sinh(n: c_float) -> c_float = c_float_utils::sinh,\n+    fn tan(n: c_float) -> c_float = c_float_utils::tan,\n+    fn tanh(n: c_float) -> c_float = c_float_utils::tanh,\n+    fn tgamma(n: c_float) -> c_float = c_float_utils::tgamma)\n+\n \n // These are not defined inside consts:: for consistency with\n // the integer types\n@@ -143,9 +154,6 @@ pub fn ge(x: f32, y: f32) -> bool { return x >= y; }\n #[inline(always)]\n pub fn gt(x: f32, y: f32) -> bool { return x > y; }\n \n-/// Returns `x` rounded down\n-#[inline(always)]\n-pub fn floor(x: f32) -> f32 { unsafe { floorf32(x) } }\n \n // FIXME (#1999): replace the predicates below with llvm intrinsics or\n // calls to the libmath macros in the rust runtime for performance."}, {"sha": "7f32893f5bff76f21a30e101b6a19e78e9f38785", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 85, "deletions": 80, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/ae3b8690c1e9c4debf20b4455ad50a79d5859ee9/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae3b8690c1e9c4debf20b4455ad50a79d5859ee9/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=ae3b8690c1e9c4debf20b4455ad50a79d5859ee9", "patch": "@@ -10,12 +10,9 @@\n \n //! Operations and constants for `f64`\n \n-use cmath;\n-use libc::{c_double, c_int};\n use num::strconv;\n use num;\n use option::Option;\n-use unstable::intrinsics::floorf64;\n use to_str;\n use from_str;\n \n@@ -25,87 +22,98 @@ use from_str;\n pub use cmath::c_double_targ_consts::*;\n pub use cmp::{min, max};\n \n+// An inner module is required to get the #[inline(always)] attribute on the\n+// functions.\n+pub use self::delegated::*;\n+\n macro_rules! delegate(\n     (\n-        fn $name:ident(\n-            $(\n-                $arg:ident : $arg_ty:ty\n-            ),*\n-        ) -> $rv:ty = $bound_name:path\n+        $(\n+            fn $name:ident(\n+                $(\n+                    $arg:ident : $arg_ty:ty\n+                ),*\n+            ) -> $rv:ty = $bound_name:path\n+        ),*\n     ) => (\n-        pub fn $name($( $arg : $arg_ty ),*) -> $rv {\n-            unsafe {\n-                $bound_name($( $arg ),*)\n-            }\n+        mod delegated {\n+            use cmath::c_double_utils;\n+            use libc::{c_double, c_int};\n+            use unstable::intrinsics;\n+\n+            $(\n+                #[inline(always)]\n+                pub fn $name($( $arg : $arg_ty ),*) -> $rv {\n+                    unsafe {\n+                        $bound_name($( $arg ),*)\n+                    }\n+                }\n+            )*\n         }\n     )\n )\n \n-delegate!(fn acos(n: c_double) -> c_double = cmath::c_double_utils::acos)\n-delegate!(fn asin(n: c_double) -> c_double = cmath::c_double_utils::asin)\n-delegate!(fn atan(n: c_double) -> c_double = cmath::c_double_utils::atan)\n-delegate!(fn atan2(a: c_double, b: c_double) -> c_double =\n-    cmath::c_double_utils::atan2)\n-delegate!(fn cbrt(n: c_double) -> c_double = cmath::c_double_utils::cbrt)\n-delegate!(fn ceil(n: c_double) -> c_double = cmath::c_double_utils::ceil)\n-delegate!(fn copysign(x: c_double, y: c_double) -> c_double =\n-    cmath::c_double_utils::copysign)\n-delegate!(fn cos(n: c_double) -> c_double = cmath::c_double_utils::cos)\n-delegate!(fn cosh(n: c_double) -> c_double = cmath::c_double_utils::cosh)\n-delegate!(fn erf(n: c_double) -> c_double = cmath::c_double_utils::erf)\n-delegate!(fn erfc(n: c_double) -> c_double = cmath::c_double_utils::erfc)\n-delegate!(fn exp(n: c_double) -> c_double = cmath::c_double_utils::exp)\n-delegate!(fn expm1(n: c_double) -> c_double = cmath::c_double_utils::expm1)\n-delegate!(fn exp2(n: c_double) -> c_double = cmath::c_double_utils::exp2)\n-delegate!(fn abs(n: c_double) -> c_double = cmath::c_double_utils::abs)\n-delegate!(fn abs_sub(a: c_double, b: c_double) -> c_double =\n-    cmath::c_double_utils::abs_sub)\n-delegate!(fn mul_add(a: c_double, b: c_double, c: c_double) -> c_double =\n-    cmath::c_double_utils::mul_add)\n-delegate!(fn fmax(a: c_double, b: c_double) -> c_double =\n-    cmath::c_double_utils::fmax)\n-delegate!(fn fmin(a: c_double, b: c_double) -> c_double =\n-    cmath::c_double_utils::fmin)\n-delegate!(fn nextafter(x: c_double, y: c_double) -> c_double =\n-    cmath::c_double_utils::nextafter)\n-delegate!(fn frexp(n: c_double, value: &mut c_int) -> c_double =\n-    cmath::c_double_utils::frexp)\n-delegate!(fn hypot(x: c_double, y: c_double) -> c_double =\n-    cmath::c_double_utils::hypot)\n-delegate!(fn ldexp(x: c_double, n: c_int) -> c_double =\n-    cmath::c_double_utils::ldexp)\n-delegate!(fn lgamma(n: c_double, sign: &mut c_int) -> c_double =\n-    cmath::c_double_utils::lgamma)\n-delegate!(fn ln(n: c_double) -> c_double = cmath::c_double_utils::ln)\n-delegate!(fn log_radix(n: c_double) -> c_double =\n-    cmath::c_double_utils::log_radix)\n-delegate!(fn ln1p(n: c_double) -> c_double = cmath::c_double_utils::ln1p)\n-delegate!(fn log10(n: c_double) -> c_double = cmath::c_double_utils::log10)\n-delegate!(fn log2(n: c_double) -> c_double = cmath::c_double_utils::log2)\n-delegate!(fn ilog_radix(n: c_double) -> c_int =\n-    cmath::c_double_utils::ilog_radix)\n-delegate!(fn modf(n: c_double, iptr: &mut c_double) -> c_double =\n-    cmath::c_double_utils::modf)\n-delegate!(fn pow(n: c_double, e: c_double) -> c_double =\n-    cmath::c_double_utils::pow)\n-delegate!(fn round(n: c_double) -> c_double = cmath::c_double_utils::round)\n-delegate!(fn ldexp_radix(n: c_double, i: c_int) -> c_double =\n-    cmath::c_double_utils::ldexp_radix)\n-delegate!(fn sin(n: c_double) -> c_double = cmath::c_double_utils::sin)\n-delegate!(fn sinh(n: c_double) -> c_double = cmath::c_double_utils::sinh)\n-delegate!(fn sqrt(n: c_double) -> c_double = cmath::c_double_utils::sqrt)\n-delegate!(fn tan(n: c_double) -> c_double = cmath::c_double_utils::tan)\n-delegate!(fn tanh(n: c_double) -> c_double = cmath::c_double_utils::tanh)\n-delegate!(fn tgamma(n: c_double) -> c_double = cmath::c_double_utils::tgamma)\n-delegate!(fn trunc(n: c_double) -> c_double = cmath::c_double_utils::trunc)\n-delegate!(fn j0(n: c_double) -> c_double = cmath::c_double_utils::j0)\n-delegate!(fn j1(n: c_double) -> c_double = cmath::c_double_utils::j1)\n-delegate!(fn jn(i: c_int, n: c_double) -> c_double =\n-    cmath::c_double_utils::jn)\n-delegate!(fn y0(n: c_double) -> c_double = cmath::c_double_utils::y0)\n-delegate!(fn y1(n: c_double) -> c_double = cmath::c_double_utils::y1)\n-delegate!(fn yn(i: c_int, n: c_double) -> c_double =\n-    cmath::c_double_utils::yn)\n+delegate!(\n+    // intrinsics\n+    fn abs(n: f64) -> f64 = intrinsics::fabsf64,\n+    fn cos(n: f64) -> f64 = intrinsics::cosf64,\n+    fn exp(n: f64) -> f64 = intrinsics::expf64,\n+    fn exp2(n: f64) -> f64 = intrinsics::exp2f64,\n+    fn floor(x: f64) -> f64 = intrinsics::floorf64,\n+    fn ln(n: f64) -> f64 = intrinsics::logf64,\n+    fn log10(n: f64) -> f64 = intrinsics::log10f64,\n+    fn log2(n: f64) -> f64 = intrinsics::log2f64,\n+    fn mul_add(a: f64, b: f64, c: f64) -> f64 = intrinsics::fmaf64,\n+    fn pow(n: f64, e: f64) -> f64 = intrinsics::powf64,\n+    fn powi(n: f64, e: c_int) -> f64 = intrinsics::powif64,\n+    fn sin(n: f64) -> f64 = intrinsics::sinf64,\n+    fn sqrt(n: f64) -> f64 = intrinsics::sqrtf64,\n+\n+    // LLVM 3.3 required to use intrinsics for these four\n+    fn ceil(n: c_double) -> c_double = c_double_utils::ceil,\n+    fn trunc(n: c_double) -> c_double = c_double_utils::trunc,\n+    /*\n+    fn ceil(n: f64) -> f64 = intrinsics::ceilf64,\n+    fn trunc(n: f64) -> f64 = intrinsics::truncf64,\n+    fn rint(n: c_double) -> c_double = intrinsics::rintf64,\n+    fn nearbyint(n: c_double) -> c_double = intrinsics::nearbyintf64,\n+    */\n+\n+    // cmath\n+    fn acos(n: c_double) -> c_double = c_double_utils::acos,\n+    fn asin(n: c_double) -> c_double = c_double_utils::asin,\n+    fn atan(n: c_double) -> c_double = c_double_utils::atan,\n+    fn atan2(a: c_double, b: c_double) -> c_double = c_double_utils::atan2,\n+    fn cbrt(n: c_double) -> c_double = c_double_utils::cbrt,\n+    fn copysign(x: c_double, y: c_double) -> c_double = c_double_utils::copysign,\n+    fn cosh(n: c_double) -> c_double = c_double_utils::cosh,\n+    fn erf(n: c_double) -> c_double = c_double_utils::erf,\n+    fn erfc(n: c_double) -> c_double = c_double_utils::erfc,\n+    fn expm1(n: c_double) -> c_double = c_double_utils::expm1,\n+    fn abs_sub(a: c_double, b: c_double) -> c_double = c_double_utils::abs_sub,\n+    fn fmax(a: c_double, b: c_double) -> c_double = c_double_utils::fmax,\n+    fn fmin(a: c_double, b: c_double) -> c_double = c_double_utils::fmin,\n+    fn nextafter(x: c_double, y: c_double) -> c_double = c_double_utils::nextafter,\n+    fn frexp(n: c_double, value: &mut c_int) -> c_double = c_double_utils::frexp,\n+    fn hypot(x: c_double, y: c_double) -> c_double = c_double_utils::hypot,\n+    fn ldexp(x: c_double, n: c_int) -> c_double = c_double_utils::ldexp,\n+    fn lgamma(n: c_double, sign: &mut c_int) -> c_double = c_double_utils::lgamma,\n+    fn log_radix(n: c_double) -> c_double = c_double_utils::log_radix,\n+    fn ln1p(n: c_double) -> c_double = c_double_utils::ln1p,\n+    fn ilog_radix(n: c_double) -> c_int = c_double_utils::ilog_radix,\n+    fn modf(n: c_double, iptr: &mut c_double) -> c_double = c_double_utils::modf,\n+    fn round(n: c_double) -> c_double = c_double_utils::round,\n+    fn ldexp_radix(n: c_double, i: c_int) -> c_double = c_double_utils::ldexp_radix,\n+    fn sinh(n: c_double) -> c_double = c_double_utils::sinh,\n+    fn tan(n: c_double) -> c_double = c_double_utils::tan,\n+    fn tanh(n: c_double) -> c_double = c_double_utils::tanh,\n+    fn tgamma(n: c_double) -> c_double = c_double_utils::tgamma,\n+    fn j0(n: c_double) -> c_double = c_double_utils::j0,\n+    fn j1(n: c_double) -> c_double = c_double_utils::j1,\n+    fn jn(i: c_int, n: c_double) -> c_double = c_double_utils::jn,\n+    fn y0(n: c_double) -> c_double = c_double_utils::y0,\n+    fn y1(n: c_double) -> c_double = c_double_utils::y1,\n+    fn yn(i: c_int, n: c_double) -> c_double = c_double_utils::yn)\n \n // FIXME (#1433): obtain these in a different way\n \n@@ -218,9 +226,6 @@ pub fn is_finite(x: f64) -> bool {\n     return !(is_NaN(x) || is_infinite(x));\n }\n \n-/// Returns `x` rounded down\n-#[inline(always)]\n-pub fn floor(x: f64) -> f64 { unsafe { floorf64(x) } }\n \n // FIXME (#1999): add is_normal, is_subnormal, and fpclassify\n "}, {"sha": "c9cda20640d569666587d7461f500da418fdf788", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae3b8690c1e9c4debf20b4455ad50a79d5859ee9/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae3b8690c1e9c4debf20b4455ad50a79d5859ee9/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=ae3b8690c1e9c4debf20b4455ad50a79d5859ee9", "patch": "@@ -36,7 +36,7 @@ pub use f64::{acos, asin, atan2, cbrt, ceil, copysign, cosh, floor};\n pub use f64::{erf, erfc, exp, expm1, exp2, abs_sub};\n pub use f64::{mul_add, fmax, fmin, nextafter, frexp, hypot, ldexp};\n pub use f64::{lgamma, ln, log_radix, ln1p, log10, log2, ilog_radix};\n-pub use f64::{modf, pow, round, sinh, tanh, tgamma, trunc};\n+pub use f64::{modf, pow, powi, round, sinh, tanh, tgamma, trunc};\n pub use f64::signbit;\n pub use f64::{j0, j1, jn, y0, y1, yn};\n "}, {"sha": "a18ad1738861d1f346a3e864f2237612c5ef0cef", "filename": "src/libcore/unstable/intrinsics.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ae3b8690c1e9c4debf20b4455ad50a79d5859ee9/src%2Flibcore%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae3b8690c1e9c4debf20b4455ad50a79d5859ee9/src%2Flibcore%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fintrinsics.rs?ref=ae3b8690c1e9c4debf20b4455ad50a79d5859ee9", "patch": "@@ -70,16 +70,28 @@ pub extern \"rust-intrinsic\" {\n     pub fn powif32(a: f32, x: i32) -> f32;\n     pub fn powif64(a: f64, x: i32) -> f64;\n \n+    // the following kill the stack canary without\n+    // `fixed_stack_segment`. This possibly only affects the f64\n+    // variants, but it's hard to be sure since it seems to only\n+    // occur with fairly specific arguments.\n+    #[fixed_stack_segment]\n     pub fn sinf32(x: f32) -> f32;\n+    #[fixed_stack_segment]\n     pub fn sinf64(x: f64) -> f64;\n \n+    #[fixed_stack_segment]\n     pub fn cosf32(x: f32) -> f32;\n+    #[fixed_stack_segment]\n     pub fn cosf64(x: f64) -> f64;\n \n+    #[fixed_stack_segment]\n     pub fn powf32(a: f32, x: f32) -> f32;\n+    #[fixed_stack_segment]\n     pub fn powf64(a: f64, x: f64) -> f64;\n \n+    #[fixed_stack_segment]\n     pub fn expf32(x: f32) -> f32;\n+    #[fixed_stack_segment]\n     pub fn expf64(x: f64) -> f64;\n \n     pub fn exp2f32(x: f32) -> f32;\n@@ -128,4 +140,3 @@ pub extern \"rust-intrinsic\" {\n     pub fn bswap32(x: i32) -> i32;\n     pub fn bswap64(x: i64) -> i64;\n }\n-"}, {"sha": "956ee3bf1443e614366fb12415d9ca35693d5abe", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae3b8690c1e9c4debf20b4455ad50a79d5859ee9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae3b8690c1e9c4debf20b4455ad50a79d5859ee9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=ae3b8690c1e9c4debf20b4455ad50a79d5859ee9", "patch": "@@ -546,6 +546,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                        item: @ast::foreign_item,\n                        path: ast_map::path,\n                        substs: @param_substs,\n+                       attributes: &[ast::attribute],\n                        ref_id: Option<ast::node_id>) {\n     debug!(\"trans_intrinsic(item.ident=%s)\", *ccx.sess.str_of(item.ident));\n \n@@ -561,6 +562,11 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                                Some(copy substs),\n                                Some(item.span));\n \n+    // Set the fixed stack segment flag if necessary.\n+    if attr::attrs_contains_name(attributes, \"fixed_stack_segment\") {\n+        set_fixed_stack_segment(fcx.llfn);\n+    }\n+\n     let mut bcx = top_scope_block(fcx, None), lltop = bcx.llbb;\n     match *ccx.sess.str_of(item.ident) {\n         ~\"atomic_cxchg\" => {"}, {"sha": "52ca8ec49bb7f5c97ad3f4fb5c1ddfce03bc0330", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae3b8690c1e9c4debf20b4455ad50a79d5859ee9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae3b8690c1e9c4debf20b4455ad50a79d5859ee9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=ae3b8690c1e9c4debf20b4455ad50a79d5859ee9", "patch": "@@ -212,7 +212,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n       }\n       ast_map::node_foreign_item(i, _, _, _) => {\n           let d = mk_lldecl();\n-          foreign::trans_intrinsic(ccx, d, i, pt, psubsts.get(),\n+          foreign::trans_intrinsic(ccx, d, i, pt, psubsts.get(), i.attrs,\n                                 ref_id);\n           d\n       }"}, {"sha": "da06b36af67ee3ca9d62076aba2a1dc9667d564c", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae3b8690c1e9c4debf20b4455ad50a79d5859ee9/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae3b8690c1e9c4debf20b4455ad50a79d5859ee9/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=ae3b8690c1e9c4debf20b4455ad50a79d5859ee9", "patch": "@@ -1,6 +1,5 @@\n use core::from_str::FromStr;\n use core::uint::range;\n-use core::unstable::intrinsics::sqrtf64;\n \n static PI: f64 = 3.141592653589793;\n static SOLAR_MASS: f64 = 4.0 * PI * PI;\n@@ -88,7 +87,7 @@ fn advance(bodies: &mut [Planet, ..N_BODIES], dt: f64, steps: i32) {\n                 d[2] = bodies[i].x[2] - bodies[j].x[2];\n \n                 let d2 = d[0]*d[0] + d[1]*d[1] + d[2]*d[2];\n-                let mag = dt / (d2 * sqrtf64(d2));\n+                let mag = dt / (d2 * f64::sqrt(d2));\n \n                 let a_mass = bodies[i].mass, b_mass = bodies[j].mass;\n                 bodies[i].v[0] -= d[0] * b_mass * mag;\n@@ -121,7 +120,7 @@ fn energy(bodies: &[Planet, ..N_BODIES]) -> f64 {\n             for range(0, 3) |k| {\n                 d[k] = bodies[i].x[k] - bodies[j].x[k];\n             }\n-            let dist = sqrtf64(d[0]*d[0] + d[1]*d[1] + d[2]*d[2]);\n+            let dist = f64::sqrt(d[0]*d[0] + d[1]*d[1] + d[2]*d[2]);\n             e -= bodies[i].mass * bodies[j].mass / dist;\n         }\n     }\n@@ -147,4 +146,3 @@ fn main() {\n \n     println(fmt!(\"%.9f\", energy(&bodies) as float));\n }\n-"}, {"sha": "6840384ca7c8aa626c4cc0895f160b5b86847dde", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae3b8690c1e9c4debf20b4455ad50a79d5859ee9/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae3b8690c1e9c4debf20b4455ad50a79d5859ee9/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=ae3b8690c1e9c4debf20b4455ad50a79d5859ee9", "patch": "@@ -1,6 +1,5 @@\n use core::from_str::FromStr;\n use core::iter::ExtendedMutableIter;\n-use core::unstable::intrinsics::sqrtf64;\n \n #[inline]\n fn A(i: i32, j: i32) -> i32 {\n@@ -49,6 +48,5 @@ fn main() {\n         mult_AtAv(v, u, tmp);\n     }\n \n-    println(fmt!(\"%.9f\", sqrtf64(dot(u,v) / dot(v,v)) as float));\n+    println(fmt!(\"%.9f\", f64::sqrt(dot(u,v) / dot(v,v)) as float));\n }\n-"}]}