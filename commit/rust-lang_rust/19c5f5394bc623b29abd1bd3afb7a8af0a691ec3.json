{"sha": "19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5YzVmNTM5NGJjNjIzYjI5YWJkMWJkM2FmYjdhOGFmMGE2OTFlYzM=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-11-16T20:57:56Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-11-16T22:05:26Z"}, "message": "Rustup to rustc 1.15.0-nightly (0ed951993 2016-11-14)", "tree": {"sha": "dfa099d8524c5e545e633975f42a0ed646cb39ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dfa099d8524c5e545e633975f42a0ed646cb39ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIcBAABCAAGBQJYLNgzAAoJEF5CfHlMukXo45YP/iqCG0aNuxyNXHngtsFIO6eI\nMu4q+pkictQbTmik51jf6RNRs17jQRT3s2WFHRWjonjoo8cqAth5/383cKpKYjD8\nI4Ea8biqRr+agM0M0L684mzIX3/qsRutSq4P7Y7Fh+sPYp7qUxPrsp2lZ1gwhYVj\n2kTR+4fIgaiYz9Sl2h1+1ITByNmoOxNRdlJ7e4ijLysmfJoh+rTwi4K5Vft123vW\naIictzM+bhSHzYrXnj/4+2P3puiEx/Z5PglQIdptsBAJ8/EMqD5M6DwXfdfpi6Z4\ninHPhXYGAUNXjN4mMFzPGzZogwMmI6I0HaCs7K557f6+V2pSFnyzko0KVb7827Zo\nZQGnulXHzvmxd+mhtTAGo2FABapAigcJSP/L9m71/OyvCC+b9QqzUmPNJ9JTYYJl\nnejoC6WEPVMqVQPB+lZoB6yoERrdUGC/OlbAo28BXxxPR3OGotelZ2/IOuitbAGE\nsp2PMDaFx88LmVm1LL+w+/AstJH4EKCuRVy3OluZZO7UFn8MwHGkDy7i/mDZsDzu\n+MKTKIMdM/dpGrKE76QSIBvWMN9IgZgYg45paOAPHJ/csYNRzMmKA/YBV5f+XO/l\ncqgXYKh9/WDEZluPIlhvHgxxV/c/lC0w0h39dNGJ2xGDXxjieR6AH/pdxavrXCLb\ng9F/y7slC/jSSsR7MJ81\n=OyNv\n-----END PGP SIGNATURE-----", "payload": "tree dfa099d8524c5e545e633975f42a0ed646cb39ac\nparent bad26a5aca2e4e1887d6da29b083a23844a2a54d\nauthor mcarton <cartonmartin+git@gmail.com> 1479329876 +0100\ncommitter mcarton <cartonmartin+git@gmail.com> 1479333926 +0100\n\nRustup to rustc 1.15.0-nightly (0ed951993 2016-11-14)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "html_url": "https://github.com/rust-lang/rust/commit/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bad26a5aca2e4e1887d6da29b083a23844a2a54d", "url": "https://api.github.com/repos/rust-lang/rust/commits/bad26a5aca2e4e1887d6da29b083a23844a2a54d", "html_url": "https://github.com/rust-lang/rust/commit/bad26a5aca2e4e1887d6da29b083a23844a2a54d"}], "stats": {"total": 483, "additions": 237, "deletions": 246}, "files": [{"sha": "7c1042e52374d1d064561704339276783363a007", "filename": "clippy_lints/src/arithmetic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farithmetic.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -59,7 +59,7 @@ impl LateLintPass for Arithmetic {\n                     hir::BiShr | hir::BiEq | hir::BiLt | hir::BiLe | hir::BiNe | hir::BiGe | hir::BiGt => return,\n                     _ => (),\n                 }\n-                let (l_ty, r_ty) = (cx.tcx.expr_ty(l), cx.tcx.expr_ty(r));\n+                let (l_ty, r_ty) = (cx.tcx.tables().expr_ty(l), cx.tcx.tables().expr_ty(r));\n                 if l_ty.is_integral() && r_ty.is_integral() {\n                     span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n                     self.span = Some(expr.span);\n@@ -69,7 +69,7 @@ impl LateLintPass for Arithmetic {\n                 }\n             }\n             hir::ExprUnary(hir::UnOp::UnNeg, ref arg) => {\n-                let ty = cx.tcx.expr_ty(arg);\n+                let ty = cx.tcx.tables().expr_ty(arg);\n                 if ty.is_integral() {\n                     span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n                     self.span = Some(expr.span);"}, {"sha": "eb84f459e985ce20699404e0102c651b2b163fe1", "filename": "clippy_lints/src/array_indexing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Farray_indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Farray_indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farray_indexing.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -59,7 +59,7 @@ impl LateLintPass for ArrayIndexing {\n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         if let hir::ExprIndex(ref array, ref index) = e.node {\n             // Array with known size can be checked statically\n-            let ty = cx.tcx.expr_ty(array);\n+            let ty = cx.tcx.tables().expr_ty(array);\n             if let ty::TyArray(_, size) = ty.sty {\n                 let size = ConstInt::Infer(size as u64);\n "}, {"sha": "9e702fe3b4e3f08a54b0576cd11f37eea3c29f58", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -81,11 +81,11 @@ impl LateLintPass for AssignOps {\n                 if let hir::ExprBinary(binop, ref l, ref r) = rhs.node {\n                     if op.node == binop.node {\n                         let lint = |assignee: &hir::Expr, rhs: &hir::Expr| {\n-                            let ty = cx.tcx.expr_ty(assignee);\n+                            let ty = cx.tcx.tables().expr_ty(assignee);\n                             if ty.walk_shallow().next().is_some() {\n                                 return; // implements_trait does not work with generics\n                             }\n-                            let rty = cx.tcx.expr_ty(rhs);\n+                            let rty = cx.tcx.tables().expr_ty(rhs);\n                             if rty.walk_shallow().next().is_some() {\n                                 return; // implements_trait does not work with generics\n                             }\n@@ -116,11 +116,11 @@ impl LateLintPass for AssignOps {\n             hir::ExprAssign(ref assignee, ref e) => {\n                 if let hir::ExprBinary(op, ref l, ref r) = e.node {\n                     let lint = |assignee: &hir::Expr, rhs: &hir::Expr| {\n-                        let ty = cx.tcx.expr_ty(assignee);\n+                        let ty = cx.tcx.tables().expr_ty(assignee);\n                         if ty.walk_shallow().next().is_some() {\n                             return; // implements_trait does not work with generics\n                         }\n-                        let rty = cx.tcx.expr_ty(rhs);\n+                        let rty = cx.tcx.tables().expr_ty(rhs);\n                         if rty.walk_shallow().next().is_some() {\n                             return; // implements_trait does not work with generics\n                         }"}, {"sha": "1af2273dc782fe80125e8ca7c5fc9324bc9c24f7", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -152,24 +152,24 @@ impl LateLintPass for AttrPass {\n }\n \n fn is_relevant_item(cx: &LateContext, item: &Item) -> bool {\n-    if let ItemFn(_, _, _, _, _, ref block) = item.node {\n-        is_relevant_block(cx, block)\n+    if let ItemFn(_, _, _, _, _, ref expr) = item.node {\n+        is_relevant_expr(cx, expr)\n     } else {\n         false\n     }\n }\n \n fn is_relevant_impl(cx: &LateContext, item: &ImplItem) -> bool {\n     match item.node {\n-        ImplItemKind::Method(_, ref block) => is_relevant_block(cx, block),\n+        ImplItemKind::Method(_, ref expr) => is_relevant_expr(cx, expr),\n         _ => false,\n     }\n }\n \n fn is_relevant_trait(cx: &LateContext, item: &TraitItem) -> bool {\n     match item.node {\n         MethodTraitItem(_, None) => true,\n-        MethodTraitItem(_, Some(ref block)) => is_relevant_block(cx, block),\n+        MethodTraitItem(_, Some(ref expr)) => is_relevant_expr(cx, expr),\n         _ => false,\n     }\n }"}, {"sha": "2212ac21babd6416e5aba13d64b169b2604b6978", "filename": "clippy_lints/src/block_in_if_condition.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -55,17 +55,9 @@ struct ExVisitor<'v> {\n \n impl<'v> Visitor<'v> for ExVisitor<'v> {\n     fn visit_expr(&mut self, expr: &'v Expr) {\n-        if let ExprClosure(_, _, ref block, _) = expr.node {\n+        if let ExprClosure(_, _, ref expr, _) = expr.node {\n             let complex = {\n-                if block.stmts.is_empty() {\n-                    if let Some(ref ex) = block.expr {\n-                        matches!(ex.node, ExprBlock(_))\n-                    } else {\n-                        false\n-                    }\n-                } else {\n-                    true\n-                }\n+                matches!(expr.node, ExprBlock(_))\n             };\n             if complex {\n                 self.found_block = Some(expr);"}, {"sha": "21ac913253b29f72cc271f7d093ce62f57fa4c2c", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -392,7 +392,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for NonminimalBoolVisitor<'a, 'tcx> {\n         match e.node {\n             ExprBinary(binop, _, _) if binop.node == BiOr || binop.node == BiAnd => self.bool_expr(e),\n             ExprUnary(UnNot, ref inner) => {\n-                if self.0.tcx.node_types()[&inner.id].is_bool() {\n+                if self.0.tcx.tables.borrow().node_types[&inner.id].is_bool() {\n                     self.bool_expr(e);\n                 } else {\n                     walk_expr(self, e);"}, {"sha": "4d403329979a58c69edffb7f636d160c1eacac40", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -120,8 +120,8 @@ impl LateLintPass for CopyAndPaste {\n             }\n \n             let (conds, blocks) = if_sequence(expr);\n-            lint_same_then_else(cx, blocks.as_slice());\n-            lint_same_cond(cx, conds.as_slice());\n+            lint_same_then_else(cx, &blocks);\n+            lint_same_cond(cx, &conds);\n             lint_match_arms(cx, expr);\n         }\n     }\n@@ -219,8 +219,8 @@ fn lint_match_arms(cx: &LateContext, expr: &Expr) {\n /// Eg. would return `([a, b], [c, d, e])` for the expression\n /// `if a { c } else if b { d } else { e }`.\n fn if_sequence(mut expr: &Expr) -> (SmallVector<&Expr>, SmallVector<&Block>) {\n-    let mut conds = SmallVector::zero();\n-    let mut blocks = SmallVector::zero();\n+    let mut conds = SmallVector::new();\n+    let mut blocks = SmallVector::new();\n \n     while let ExprIf(ref cond, ref then_block, ref else_expr) = expr.node {\n         conds.push(&**cond);\n@@ -256,7 +256,7 @@ fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> HashMap<Interned\n             }\n             PatKind::Binding(_, ref ident, ref as_pat) => {\n                 if let Entry::Vacant(v) = map.entry(ident.node.as_str()) {\n-                    v.insert(cx.tcx.pat_ty(pat));\n+                    v.insert(cx.tcx.tables().pat_ty(pat));\n                 }\n                 if let Some(ref as_pat) = *as_pat {\n                     bindings_impl(cx, as_pat, map);"}, {"sha": "f7758e3af23107e7247bedd508382976c08df6c5", "filename": "clippy_lints/src/cyclomatic_complexity.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -42,12 +42,12 @@ impl LintPass for CyclomaticComplexity {\n }\n \n impl CyclomaticComplexity {\n-    fn check<'a, 'tcx>(&mut self, cx: &'a LateContext<'a, 'tcx>, block: &Block, span: Span) {\n+    fn check<'a, 'tcx>(&mut self, cx: &'a LateContext<'a, 'tcx>, expr: &Expr, span: Span) {\n         if in_macro(cx, span) {\n             return;\n         }\n \n-        let cfg = CFG::new(cx.tcx, block);\n+        let cfg = CFG::new(cx.tcx, expr);\n         let n = cfg.graph.len_nodes() as u64;\n         let e = cfg.graph.len_edges() as u64;\n         if e + 2 < n {\n@@ -62,9 +62,9 @@ impl CyclomaticComplexity {\n             returns: 0,\n             tcx: &cx.tcx,\n         };\n-        helper.visit_block(block);\n+        helper.visit_expr(expr);\n         let CCHelper { match_arms, divergence, short_circuits, returns, .. } = helper;\n-        let ret_ty = cx.tcx.node_id_to_type(block.id);\n+        let ret_ty = cx.tcx.tables().node_id_to_type(expr.id);\n         let ret_adjust = if match_type(cx, ret_ty, &paths::RESULT) {\n             returns\n         } else {\n@@ -92,22 +92,22 @@ impl CyclomaticComplexity {\n \n impl LateLintPass for CyclomaticComplexity {\n     fn check_item(&mut self, cx: &LateContext, item: &Item) {\n-        if let ItemFn(_, _, _, _, _, ref block) = item.node {\n+        if let ItemFn(_, _, _, _, _, ref expr) = item.node {\n             if !attr::contains_name(&item.attrs, \"test\") {\n-                self.check(cx, block, item.span);\n+                self.check(cx, expr, item.span);\n             }\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext, item: &ImplItem) {\n-        if let ImplItemKind::Method(_, ref block) = item.node {\n-            self.check(cx, block, item.span);\n+        if let ImplItemKind::Method(_, ref expr) = item.node {\n+            self.check(cx, expr, item.span);\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n-        if let MethodTraitItem(_, Some(ref block)) = item.node {\n-            self.check(cx, block, item.span);\n+        if let MethodTraitItem(_, Some(ref expr)) = item.node {\n+            self.check(cx, expr, item.span);\n         }\n     }\n \n@@ -139,7 +139,7 @@ impl<'a, 'b, 'tcx, 'gcx> Visitor<'a> for CCHelper<'b, 'gcx, 'tcx> {\n             }\n             ExprCall(ref callee, _) => {\n                 walk_expr(self, e);\n-                let ty = self.tcx.node_id_to_type(callee.id);\n+                let ty = self.tcx.tables().node_id_to_type(callee.id);\n                 match ty.sty {\n                     ty::TyFnDef(_, _, ty) |\n                     ty::TyFnPtr(ty) if ty.sig.skip_binder().output.sty == ty::TyNever => {"}, {"sha": "59687aa191befa1c525f099378be1754a7419bb3", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -73,7 +73,7 @@ impl LintPass for Derive {\n impl LateLintPass for Derive {\n     fn check_item(&mut self, cx: &LateContext, item: &Item) {\n         if let ItemImpl(_, _, _, Some(ref trait_ref), _, _) = item.node {\n-            let ty = cx.tcx.lookup_item_type(cx.tcx.map.local_def_id(item.id)).ty;\n+            let ty = cx.tcx.item_type(cx.tcx.map.local_def_id(item.id));\n             let is_automatically_derived = is_automatically_derived(&*item.attrs);\n \n             check_hash_peq(cx, item.span, trait_ref, ty, is_automatically_derived);"}, {"sha": "4fb4009dd2f0f1031e850434e89131883c365530", "filename": "clippy_lints/src/drop_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fdrop_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fdrop_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_ref.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -52,7 +52,7 @@ impl LateLintPass for Pass {\n }\n \n fn check_drop_arg(cx: &LateContext, call_span: Span, arg: &Expr) {\n-    let arg_ty = cx.tcx.expr_ty(arg);\n+    let arg_ty = cx.tcx.tables().expr_ty(arg);\n     if let ty::TyRef(..) = arg_ty.sty {\n         span_note_and_lint(cx,\n                            DROP_REF,"}, {"sha": "50bf299a3c3fccb183aa5ee23c2288b08dca7671", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -86,7 +86,7 @@ fn check_cond<'a, 'tcx, 'b>(cx: &'a LateContext<'a, 'tcx>, check: &'b Expr) -> O\n         let ExprAddrOf(_, ref key) = params[1].node\n     ], {\n         let map = &params[0];\n-        let obj_ty = walk_ptrs_ty(cx.tcx.expr_ty(map));\n+        let obj_ty = walk_ptrs_ty(cx.tcx.tables().expr_ty(map));\n \n         return if match_type(cx, obj_ty, &paths::BTREEMAP) {\n             Some((\"BTreeMap\", map, key))"}, {"sha": "703e37e77b014fa686b8cbc81569a9f5b03ce4c5", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -5,7 +5,6 @@ use rustc::infer::InferCtxt;\n use rustc::lint::*;\n use rustc::middle::expr_use_visitor::*;\n use rustc::middle::mem_categorization::{cmt, Categorization};\n-use rustc::ty::adjustment::AutoAdjustment;\n use rustc::ty;\n use rustc::ty::layout::TargetDataLayout;\n use rustc::util::nodemap::NodeSet;\n@@ -62,7 +61,7 @@ impl LintPass for Pass {\n }\n \n impl LateLintPass for Pass {\n-    fn check_fn(&mut self, cx: &LateContext, _: visit::FnKind, decl: &FnDecl, body: &Block, _: Span, id: NodeId) {\n+    fn check_fn(&mut self, cx: &LateContext, _: visit::FnKind, decl: &FnDecl, body: &Expr, _: Span, id: NodeId) {\n         let param_env = ty::ParameterEnvironment::for_item(cx.tcx, id);\n \n         let infcx = cx.tcx.borrowck_fake_infer_ctxt(param_env);\n@@ -146,32 +145,35 @@ impl<'a, 'tcx: 'a+'gcx, 'gcx: 'a> Delegate<'tcx> for EscapeDelegate<'a, 'tcx, 'g\n     }\n     fn borrow(&mut self, borrow_id: NodeId, _: Span, cmt: cmt<'tcx>, _: &ty::Region, _: ty::BorrowKind,\n               loan_cause: LoanCause) {\n+        use rustc::ty::adjustment::Adjust;\n \n         if let Categorization::Local(lid) = cmt.cat {\n             if self.set.contains(&lid) {\n-                if let Some(&AutoAdjustment::AdjustDerefRef(adj)) = self.tcx\n+                if let Some(&Adjust::DerefRef { autoderefs, .. }) = self.tcx\n                                                                         .tables\n                                                                         .borrow()\n                                                                         .adjustments\n-                                                                        .get(&borrow_id) {\n+                                                                        .get(&borrow_id)\n+                                                                        .map(|a| &a.kind) {\n                     if LoanCause::AutoRef == loan_cause {\n                         // x.foo()\n-                        if adj.autoderefs == 0 {\n+                        if autoderefs == 0 {\n                             self.set.remove(&lid); // Used without autodereffing (i.e. x.clone())\n                         }\n                     } else {\n                         span_bug!(cmt.span, \"Unknown adjusted AutoRef\");\n                     }\n                 } else if LoanCause::AddrOf == loan_cause {\n                     // &x\n-                    if let Some(&AutoAdjustment::AdjustDerefRef(adj)) = self.tcx\n+                    if let Some(&Adjust::DerefRef { autoderefs, .. }) = self.tcx\n                                                                             .tables\n                                                                             .borrow()\n                                                                             .adjustments\n                                                                             .get(&self.tcx\n-                                                                                      .map\n-                                                                                      .get_parent_node(borrow_id)) {\n-                        if adj.autoderefs <= 1 {\n+                                                                            .map\n+                                                                            .get_parent_node(borrow_id))\n+                                                                            .map(|a| &a.kind) {\n+                        if autoderefs <= 1 {\n                             // foo(&x) where no extra autoreffing is happening\n                             self.set.remove(&lid);\n                         }"}, {"sha": "ee0767f57dfd5a05c8e66223afae36b8e136a393", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 37, "deletions": 44, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -48,60 +48,53 @@ impl LateLintPass for EtaPass {\n }\n \n fn check_closure(cx: &LateContext, expr: &Expr) {\n-    if let ExprClosure(_, ref decl, ref blk, _) = expr.node {\n-        if !blk.stmts.is_empty() {\n-            // || {foo(); bar()}; can't be reduced here\n-            return;\n-        }\n-\n-        if let Some(ref ex) = blk.expr {\n-            if let ExprCall(ref caller, ref args) = ex.node {\n-                if args.len() != decl.inputs.len() {\n-                    // Not the same number of arguments, there\n-                    // is no way the closure is the same as the function\n-                    return;\n-                }\n-                if is_adjusted(cx, ex) || args.iter().any(|arg| is_adjusted(cx, arg)) {\n-                    // Are the expression or the arguments type-adjusted? Then we need the closure\n-                    return;\n+    if let ExprClosure(_, ref decl, ref ex, _) = expr.node {\n+        if let ExprCall(ref caller, ref args) = ex.node {\n+            if args.len() != decl.inputs.len() {\n+                // Not the same number of arguments, there\n+                // is no way the closure is the same as the function\n+                return;\n+            }\n+            if is_adjusted(cx, ex) || args.iter().any(|arg| is_adjusted(cx, arg)) {\n+                // Are the expression or the arguments type-adjusted? Then we need the closure\n+                return;\n+            }\n+            let fn_ty = cx.tcx.tables().expr_ty(caller);\n+            match fn_ty.sty {\n+                // Is it an unsafe function? They don't implement the closure traits\n+                ty::TyFnDef(_, _, fn_ty) |\n+                ty::TyFnPtr(fn_ty) => {\n+                    if fn_ty.unsafety == Unsafety::Unsafe ||\n+                       fn_ty.sig.skip_binder().output.sty == ty::TyNever {\n+                        return;\n+                    }\n                 }\n-                let fn_ty = cx.tcx.expr_ty(caller);\n-                match fn_ty.sty {\n-                    // Is it an unsafe function? They don't implement the closure traits\n-                    ty::TyFnDef(_, _, fn_ty) |\n-                    ty::TyFnPtr(fn_ty) => {\n-                        if fn_ty.unsafety == Unsafety::Unsafe ||\n-                           fn_ty.sig.skip_binder().output.sty == ty::TyNever {\n+                _ => (),\n+            }\n+            for (a1, a2) in decl.inputs.iter().zip(args) {\n+                if let PatKind::Binding(_, ident, _) = a1.pat.node {\n+                    // XXXManishearth Should I be checking the binding mode here?\n+                    if let ExprPath(None, ref p) = a2.node {\n+                        if p.segments.len() != 1 {\n+                            // If it's a proper path, it can't be a local variable\n                             return;\n                         }\n-                    }\n-                    _ => (),\n-                }\n-                for (a1, a2) in decl.inputs.iter().zip(args) {\n-                    if let PatKind::Binding(_, ident, _) = a1.pat.node {\n-                        // XXXManishearth Should I be checking the binding mode here?\n-                        if let ExprPath(None, ref p) = a2.node {\n-                            if p.segments.len() != 1 {\n-                                // If it's a proper path, it can't be a local variable\n-                                return;\n-                            }\n-                            if p.segments[0].name != ident.node {\n-                                // The two idents should be the same\n-                                return;\n-                            }\n-                        } else {\n+                        if p.segments[0].name != ident.node {\n+                            // The two idents should be the same\n                             return;\n                         }\n                     } else {\n                         return;\n                     }\n+                } else {\n+                    return;\n                 }\n-                span_lint_and_then(cx, REDUNDANT_CLOSURE, expr.span, \"redundant closure found\", |db| {\n-                    if let Some(snippet) = snippet_opt(cx, caller.span) {\n-                        db.span_suggestion(expr.span, \"remove closure as shown:\", snippet);\n-                    }\n-                });\n             }\n+            span_lint_and_then(cx, REDUNDANT_CLOSURE, expr.span, \"redundant closure found\", |db| {\n+                if let Some(snippet) = snippet_opt(cx, caller.span) {\n+                    db.span_suggestion(expr.span, \"remove closure as shown:\", snippet);\n+                }\n+            });\n         }\n     }\n }"}, {"sha": "be5e67391abb1ec8a077459c2a9e888d61915e4f", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -126,7 +126,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DivergenceVisitor<'a, 'tcx> {\n             ExprAgain(_) |\n             ExprBreak(_) |\n             ExprRet(_) => self.report_diverging_sub_expr(e),\n-            ExprCall(ref func, _) => match self.0.tcx.expr_ty(func).sty {\n+            ExprCall(ref func, _) => match self.0.tcx.tables().expr_ty(func).sty {\n                 ty::TyFnDef(_, _, fn_ty) |\n                 ty::TyFnPtr(fn_ty) => if let ty::TyNever = self.0.tcx.erase_late_bound_regions(&fn_ty.sig).output.sty {\n                     self.report_diverging_sub_expr(e);"}, {"sha": "2013b406f2b78524177f8bbe3e510ea6b050caa9", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -132,7 +132,7 @@ fn check_arg_is_display(cx: &LateContext, expr: &Expr) -> bool {\n         let Some(fun) = resolve_node(cx, args[1].id),\n         match_def_path(cx, fun.def_id(), &paths::DISPLAY_FMT_METHOD),\n     ], {\n-        let ty = walk_ptrs_ty(cx.tcx.pat_ty(&pat[0]));\n+        let ty = walk_ptrs_ty(cx.tcx.tables().pat_ty(&pat[0]));\n \n         return ty.sty == TypeVariants::TyStr || match_type(cx, ty, &paths::STRING);\n     }}"}, {"sha": "c6f17b615b621d003337502e235df326588253bd", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -69,7 +69,7 @@ impl LintPass for Functions {\n }\n \n impl LateLintPass for Functions {\n-    fn check_fn(&mut self, cx: &LateContext, kind: intravisit::FnKind, decl: &hir::FnDecl, block: &hir::Block, span: Span, nodeid: ast::NodeId) {\n+    fn check_fn(&mut self, cx: &LateContext, kind: intravisit::FnKind, decl: &hir::FnDecl, expr: &hir::Expr, span: Span, nodeid: ast::NodeId) {\n         use rustc::hir::map::Node::*;\n \n         let is_impl = if let Some(NodeItem(item)) = cx.tcx.map.find(cx.tcx.map.get_parent_node(nodeid)) {\n@@ -94,18 +94,18 @@ impl LateLintPass for Functions {\n             }\n         }\n \n-        self.check_raw_ptr(cx, unsafety, decl, block, nodeid);\n+        self.check_raw_ptr(cx, unsafety, decl, expr, nodeid);\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext, item: &hir::TraitItem) {\n-        if let hir::MethodTraitItem(ref sig, ref block) = item.node {\n+        if let hir::MethodTraitItem(ref sig, ref expr) = item.node {\n             // don't lint extern functions decls, it's not their fault\n             if sig.abi == Abi::Rust {\n                 self.check_arg_number(cx, &sig.decl, item.span);\n             }\n \n-            if let Some(ref block) = *block {\n-                self.check_raw_ptr(cx, sig.unsafety, &sig.decl, block, item.id);\n+            if let Some(ref expr) = *expr {\n+                self.check_raw_ptr(cx, sig.unsafety, &sig.decl, expr, item.id);\n             }\n         }\n     }\n@@ -122,7 +122,7 @@ impl Functions {\n         }\n     }\n \n-    fn check_raw_ptr(&self, cx: &LateContext, unsafety: hir::Unsafety, decl: &hir::FnDecl, block: &hir::Block, nodeid: ast::NodeId) {\n+    fn check_raw_ptr(&self, cx: &LateContext, unsafety: hir::Unsafety, decl: &hir::FnDecl, expr: &hir::Expr, nodeid: ast::NodeId) {\n         if unsafety == hir::Unsafety::Normal && cx.access_levels.is_exported(nodeid) {\n             let raw_ptrs = decl.inputs.iter().filter_map(|arg| raw_ptr_arg(cx, arg)).collect::<HashSet<_>>();\n \n@@ -132,7 +132,7 @@ impl Functions {\n                     ptrs: raw_ptrs,\n                 };\n \n-                hir::intravisit::walk_block(&mut v, block);\n+                hir::intravisit::walk_expr(&mut v, expr);\n             }\n         }\n     }\n@@ -155,7 +155,7 @@ impl<'a, 'tcx, 'v> hir::intravisit::Visitor<'v> for DerefVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'v hir::Expr) {\n         match expr.node {\n             hir::ExprCall(ref f, ref args) => {\n-                let ty = self.cx.tcx.expr_ty(f);\n+                let ty = self.cx.tcx.tables().expr_ty(f);\n \n                 if type_is_unsafe_function(ty) {\n                     for arg in args {"}, {"sha": "269936776f7a4d02d01fab4f0e6b6c6a5eb4f993", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -1,6 +1,6 @@\n use rustc::lint::*;\n use rustc::hir::def_id::DefId;\n-use rustc::ty::{self, ImplOrTraitItem};\n+use rustc::ty;\n use rustc::hir::*;\n use syntax::ast::{Lit, LitKind, Name};\n use syntax::codemap::{Span, Spanned};\n@@ -133,7 +133,8 @@ fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[ImplItem]) {\n \n     if let Some(i) = impl_items.iter().find(|i| is_named_self(i, \"len\")) {\n         if cx.access_levels.is_exported(i.id) {\n-            let ty = cx.tcx.node_id_to_type(item.id);\n+            let def_id = cx.tcx.map.local_def_id(item.id);\n+            let ty = cx.tcx.item_type(def_id);\n \n             span_lint(cx,\n                       LEN_WITHOUT_IS_EMPTY,\n@@ -183,10 +184,15 @@ fn check_len_zero(cx: &LateContext, span: Span, name: &Name, args: &[P<Expr>], l\n \n /// Check if this type has an `is_empty` method.\n fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n-    /// Get an `ImplOrTraitItem` and return true if it matches `is_empty(self)`.\n-    fn is_is_empty(item: &ImplOrTraitItem) -> bool {\n-        if let ty::MethodTraitItem(ref method) = *item {\n-            method.name.as_str() == \"is_empty\" && method.fty.sig.skip_binder().inputs.len() == 1\n+    /// Get an `AssociatedItem` and return true if it matches `is_empty(self)`.\n+    fn is_is_empty(cx: &LateContext, item: &ty::AssociatedItem) -> bool {\n+        if let ty::AssociatedKind::Method = item.kind {\n+            if item.name.as_str() == \"is_empty\" {\n+                let ty = cx.tcx.item_type(item.def_id).fn_sig().skip_binder();\n+                ty.inputs.len() == 1\n+            } else {\n+                false\n+            }\n         } else {\n             false\n         }\n@@ -195,19 +201,18 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n     /// Check the inherent impl's items for an `is_empty(self)` method.\n     fn has_is_empty_impl(cx: &LateContext, id: DefId) -> bool {\n         cx.tcx.inherent_impls.borrow().get(&id).map_or(false, |impls| impls.iter().any(|imp| {\n-            cx.tcx.impl_or_trait_items(*imp).iter().any(|item| {\n-                is_is_empty(&cx.tcx.impl_or_trait_item(*item))\n+            cx.tcx.associated_items(*imp).any(|item| {\n+                is_is_empty(cx, &item)\n             })\n         }))\n     }\n \n-    let ty = &walk_ptrs_ty(cx.tcx.expr_ty(expr));\n+    let ty = &walk_ptrs_ty(cx.tcx.tables().expr_ty(expr));\n     match ty.sty {\n         ty::TyTrait(_) => {\n             cx.tcx\n-              .impl_or_trait_items(ty.ty_to_def_id().expect(\"trait impl not found\"))\n-              .iter()\n-              .any(|item| is_is_empty(&cx.tcx.impl_or_trait_item(*item)))\n+              .associated_items(ty.ty_to_def_id().expect(\"trait impl not found\"))\n+              .any(|item| is_is_empty(cx, &item))\n         }\n         ty::TyProjection(_) => ty.ty_to_def_id().map_or(false, |id| has_is_empty_impl(cx, id)),\n         ty::TyAdt(id, _) => has_is_empty_impl(cx, id.did),"}, {"sha": "07ec1f3f244bed4cbd98dbc397a757e1fdde7dec", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -3,7 +3,6 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(custom_attribute)]\n-#![feature(dotdot_in_tuple_patterns)]\n #![feature(rustc_private)]\n #![feature(slice_patterns)]\n #![feature(stmt_expr_attributes)]"}, {"sha": "8f1ef44bf1c7bdab11484c16e95c0bf01ad9bc72", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -247,8 +247,8 @@ impl<'v, 't> RefVisitor<'v, 't> {\n                     match def {\n                         Def::TyAlias(def_id) |\n                         Def::Struct(def_id) => {\n-                            let type_scheme = self.cx.tcx.lookup_item_type(def_id);\n-                            for _ in type_scheme.generics.regions.as_slice() {\n+                            let generics = self.cx.tcx.item_generics(def_id);\n+                            for _ in generics.regions.as_slice() {\n                                 self.record(&None);\n                             }\n                         }"}, {"sha": "de4eee225738c4a2844bb6ddaa6610fe83975dbe", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -623,7 +623,7 @@ fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n \n /// Check for `for` loops over `Option`s and `Results`\n fn check_arg_type(cx: &LateContext, pat: &Pat, arg: &Expr) {\n-    let ty = cx.tcx.expr_ty(arg);\n+    let ty = cx.tcx.tables().expr_ty(arg);\n     if match_type(cx, ty, &paths::OPTION) {\n         span_help_and_lint(cx,\n                            FOR_LOOP_OVER_OPTION,\n@@ -709,7 +709,7 @@ fn check_for_loop_over_map_kv(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Ex\n                 _ => (arg.span, arg),\n             };\n \n-            let ty = walk_ptrs_ty(cx.tcx.expr_ty(arg));\n+            let ty = walk_ptrs_ty(cx.tcx.tables().expr_ty(arg));\n             if match_type(cx, ty, &paths::HASHMAP) || match_type(cx, ty, &paths::BTREEMAP) {\n                 span_lint_and_then(cx,\n                                    FOR_KV_MAP,\n@@ -854,7 +854,7 @@ impl<'v, 't> Visitor<'v> for VarUsedAfterLoopVisitor<'v, 't> {\n fn is_ref_iterable_type(cx: &LateContext, e: &Expr) -> bool {\n     // no walk_ptrs_ty: calling iter() on a reference can make sense because it\n     // will allow further borrows afterwards\n-    let ty = cx.tcx.expr_ty(e);\n+    let ty = cx.tcx.tables().expr_ty(e);\n     is_iterable_array(ty) ||\n     match_type(cx, ty, &paths::VEC) ||\n     match_type(cx, ty, &paths::LINKED_LIST) ||"}, {"sha": "17975ed37684cc70091add909d50984ccd8cd8b0", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -30,11 +30,8 @@ impl LateLintPass for Pass {\n         if let ExprMethodCall(name, _, ref args) = expr.node {\n             if name.node.as_str() == \"map\" && args.len() == 2 {\n                 match args[1].node {\n-                    ExprClosure(_, ref decl, ref blk, _) => {\n+                    ExprClosure(_, ref decl, ref closure_expr, _) => {\n                         if_let_chain! {[\n-                            // just one expression in the closure\n-                            blk.stmts.is_empty(),\n-                            let Some(ref closure_expr) = blk.expr,\n                             // nothing special in the argument, besides reference bindings\n                             // (e.g. .map(|&x| x) )\n                             let Some(arg_ident) = get_arg_name(&*decl.inputs[0].pat),\n@@ -44,7 +41,7 @@ impl LateLintPass for Pass {\n                             // look for derefs, for .map(|x| *x)\n                             if only_derefs(cx, &*closure_expr, arg_ident) &&\n                                 // .cloned() only removes one level of indirection, don't lint on more\n-                                walk_ptrs_ty_depth(cx.tcx.pat_ty(&*decl.inputs[0].pat)).1 == 1\n+                                walk_ptrs_ty_depth(cx.tcx.tables().pat_ty(&*decl.inputs[0].pat)).1 == 1\n                             {\n                                 span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n                                     \"you seem to be using .map() to clone the contents of an {}, consider \\\n@@ -101,7 +98,7 @@ fn expr_eq_name(expr: &Expr, id: ast::Name) -> bool {\n fn get_type_name(cx: &LateContext, expr: &Expr, arg: &Expr) -> Option<&'static str> {\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         Some(\"iterator\")\n-    } else if match_type(cx, walk_ptrs_ty(cx.tcx.expr_ty(arg)), &paths::OPTION) {\n+    } else if match_type(cx, walk_ptrs_ty(cx.tcx.tables().expr_ty(arg)), &paths::OPTION) {\n         Some(\"Option\")\n     } else {\n         None"}, {"sha": "844715835b992f0c1124d34c2b6a2877d1c593ef", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -159,7 +159,7 @@ fn check_single_match(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n             // allow match arms with just expressions\n             return;\n         };\n-        let ty = cx.tcx.expr_ty(ex);\n+        let ty = cx.tcx.tables().expr_ty(ex);\n         if ty.sty != ty::TyBool || cx.current_level(MATCH_BOOL) == Allow {\n             check_single_match_single_pattern(cx, ex, arms, expr, els);\n             check_single_match_opt_like(cx, ex, arms, expr, ty, els);\n@@ -243,7 +243,7 @@ fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr:\n \n fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     // type of expression == bool\n-    if cx.tcx.expr_ty(ex).sty == ty::TyBool {\n+    if cx.tcx.tables().expr_ty(ex).sty == ty::TyBool {\n         span_lint_and_then(cx,\n                            MATCH_BOOL,\n                            expr.span,\n@@ -296,7 +296,7 @@ fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n }\n \n fn check_overlapping_arms(cx: &LateContext, ex: &Expr, arms: &[Arm]) {\n-    if arms.len() >= 2 && cx.tcx.expr_ty(ex).is_integral() {\n+    if arms.len() >= 2 && cx.tcx.tables().expr_ty(ex).is_integral() {\n         let ranges = all_ranges(cx, arms);\n         let type_ranges = type_ranges(&ranges);\n         if !type_ranges.is_empty() {"}, {"sha": "492962def6ab805a1730daa6365780ce427008ad", "filename": "clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_forget.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -33,7 +33,7 @@ impl LateLintPass for MemForget {\n             if let ExprPath(None, _) = path_expr.node {\n                 let def_id = cx.tcx.expect_def(path_expr.id).def_id();\n                 if match_def_path(cx, def_id, &paths::MEM_FORGET) {\n-                    let forgot_ty = cx.tcx.expr_ty(&args[0]);\n+                    let forgot_ty = cx.tcx.tables().expr_ty(&args[0]);\n \n                     if match forgot_ty.ty_adt_def() {\n                         Some(def) => def.has_dtor(),"}, {"sha": "a0c64c23bb9d7d79fe1228d5b1e1bfb93a295d61", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -573,7 +573,7 @@ impl LateLintPass for Pass {\n \n                 lint_or_fun_call(cx, expr, &name.node.as_str(), args);\n \n-                let self_ty = cx.tcx.expr_ty_adjusted(&args[0]);\n+                let self_ty = cx.tcx.tables().expr_ty_adjusted(&args[0]);\n                 if args.len() == 1 && name.node.as_str() == \"clone\" {\n                     lint_clone_on_copy(cx, expr, &args[0], self_ty);\n                 }\n@@ -623,7 +623,7 @@ impl LateLintPass for Pass {\n             }\n \n             // check conventions w.r.t. conversion method names and predicates\n-            let ty = cx.tcx.lookup_item_type(cx.tcx.map.local_def_id(item.id)).ty;\n+            let ty = cx.tcx.item_type(cx.tcx.map.local_def_id(item.id));\n             let is_copy = is_copy(cx, ty, item.id);\n             for &(ref conv, self_kinds) in &CONVENTIONS {\n                 if_let_chain! {[\n@@ -680,7 +680,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[P<hi\n                                       .as_str();\n \n                 if [\"default\", \"new\"].contains(&path) {\n-                    let arg_ty = cx.tcx.expr_ty(arg);\n+                    let arg_ty = cx.tcx.tables().expr_ty(arg);\n                     let default_trait_id = if let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT) {\n                         default_trait_id\n                     } else {\n@@ -724,7 +724,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[P<hi\n                                                    \"else\"),\n                                                   (&paths::RESULT, true, &[\"or\", \"unwrap_or\"], \"else\")];\n \n-        let self_ty = cx.tcx.expr_ty(self_expr);\n+        let self_ty = cx.tcx.tables().expr_ty(self_expr);\n \n         let (fn_has_arguments, poss, suffix) = if let Some(&(_, fn_has_arguments, poss, suffix)) =\n                                                       know_types.iter().find(|&&i| match_type(cx, self_ty, i.0)) {\n@@ -762,7 +762,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[P<hi\n \n /// Checks for the `CLONE_ON_COPY` lint.\n fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_ty: ty::Ty) {\n-    let ty = cx.tcx.expr_ty(expr);\n+    let ty = cx.tcx.tables().expr_ty(expr);\n     let parent = cx.tcx.map.get_parent(expr.id);\n     let parameter_environment = ty::ParameterEnvironment::for_item(cx.tcx, parent);\n     if let ty::TyRef(_, ty::TypeAndMut { ty: inner, .. }) = arg_ty.sty {\n@@ -785,7 +785,7 @@ fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_t\n                            expr.span,\n                            \"using `clone` on a `Copy` type\",\n                            |db| if let Some(snip) = sugg::Sugg::hir_opt(cx, arg) {\n-                               if let ty::TyRef(..) = cx.tcx.expr_ty(arg).sty {\n+                               if let ty::TyRef(..) = cx.tcx.tables().expr_ty(arg).sty {\n                                    db.span_suggestion(expr.span, \"try dereferencing it\", format!(\"{}\", snip.deref()));\n                                } else {\n                                    db.span_suggestion(expr.span, \"try removing the `clone` call\", format!(\"{}\", snip));\n@@ -795,11 +795,11 @@ fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_t\n }\n \n fn lint_extend(cx: &LateContext, expr: &hir::Expr, args: &MethodArgs) {\n-    let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&args[0]));\n+    let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.tables().expr_ty(&args[0]));\n     if !match_type(cx, obj_ty, &paths::VEC) {\n         return;\n     }\n-    let arg_ty = cx.tcx.expr_ty(&args[1]);\n+    let arg_ty = cx.tcx.tables().expr_ty(&args[1]);\n     if let Some(slice) = derefs_to_slice(cx, &args[1], arg_ty) {\n         span_lint_and_then(cx, EXTEND_FROM_SLICE, expr.span, \"use of `extend` to extend a Vec by a slice\", |db| {\n             db.span_suggestion(expr.span,\n@@ -831,13 +831,13 @@ fn lint_cstring_as_ptr(cx: &LateContext, expr: &hir::Expr, new: &hir::Expr, unwr\n // Type of MethodArgs is potentially a Vec\n fn lint_iter_nth(cx: &LateContext, expr: &hir::Expr, iter_args: &MethodArgs, is_mut: bool){\n     let mut_str = if is_mut { \"_mut\" } else {\"\"};\n-    let caller_type = if derefs_to_slice(cx, &iter_args[0], cx.tcx.expr_ty(&iter_args[0])).is_some() {\n+    let caller_type = if derefs_to_slice(cx, &iter_args[0], cx.tcx.tables().expr_ty(&iter_args[0])).is_some() {\n         \"slice\"\n     }\n-    else if match_type(cx, cx.tcx.expr_ty(&iter_args[0]), &paths::VEC) {\n+    else if match_type(cx, cx.tcx.tables().expr_ty(&iter_args[0]), &paths::VEC) {\n         \"Vec\"\n     }\n-    else if match_type(cx, cx.tcx.expr_ty(&iter_args[0]), &paths::VEC_DEQUE) {\n+    else if match_type(cx, cx.tcx.tables().expr_ty(&iter_args[0]), &paths::VEC_DEQUE) {\n         \"VecDeque\"\n     }\n     else {\n@@ -856,7 +856,7 @@ fn lint_iter_nth(cx: &LateContext, expr: &hir::Expr, iter_args: &MethodArgs, is_\n fn lint_get_unwrap(cx: &LateContext, expr: &hir::Expr, get_args: &MethodArgs, is_mut: bool) {\n     // Note: we don't want to lint `get_mut().unwrap` for HashMap or BTreeMap,\n     // because they do not implement `IndexMut`\n-    let expr_ty = cx.tcx.expr_ty(&get_args[0]);\n+    let expr_ty = cx.tcx.tables().expr_ty(&get_args[0]);\n     let caller_type = if derefs_to_slice(cx, &get_args[0], expr_ty).is_some() {\n         \"slice\"\n     } else if match_type(cx, expr_ty, &paths::VEC) {\n@@ -915,7 +915,7 @@ fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: ty::Ty) -> Option<sug\n     }\n \n     if let hir::ExprMethodCall(name, _, ref args) = expr.node {\n-        if &name.node.as_str() == &\"iter\" && may_slice(cx, cx.tcx.expr_ty(&args[0])) {\n+        if &name.node.as_str() == &\"iter\" && may_slice(cx, cx.tcx.tables().expr_ty(&args[0])) {\n             sugg::Sugg::hir_opt(cx, &*args[0]).map(|sugg| {\n                 sugg.addr()\n             })\n@@ -942,7 +942,7 @@ fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: ty::Ty) -> Option<sug\n // Type of MethodArgs is potentially a Vec\n /// lint use of `unwrap()` for `Option`s and `Result`s\n fn lint_unwrap(cx: &LateContext, expr: &hir::Expr, unwrap_args: &MethodArgs) {\n-    let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&unwrap_args[0]));\n+    let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.tables().expr_ty(&unwrap_args[0]));\n \n     let mess = if match_type(cx, obj_ty, &paths::OPTION) {\n         Some((OPTION_UNWRAP_USED, \"an Option\", \"None\"))\n@@ -969,8 +969,8 @@ fn lint_unwrap(cx: &LateContext, expr: &hir::Expr, unwrap_args: &MethodArgs) {\n /// lint use of `ok().expect()` for `Result`s\n fn lint_ok_expect(cx: &LateContext, expr: &hir::Expr, ok_args: &MethodArgs) {\n     // lint if the caller of `ok()` is a `Result`\n-    if match_type(cx, cx.tcx.expr_ty(&ok_args[0]), &paths::RESULT) {\n-        let result_type = cx.tcx.expr_ty(&ok_args[0]);\n+    if match_type(cx, cx.tcx.tables().expr_ty(&ok_args[0]), &paths::RESULT) {\n+        let result_type = cx.tcx.tables().expr_ty(&ok_args[0]);\n         if let Some(error_type) = get_error_type(cx, result_type) {\n             if has_debug_impl(error_type, cx) {\n                 span_lint(cx,\n@@ -987,7 +987,7 @@ fn lint_ok_expect(cx: &LateContext, expr: &hir::Expr, ok_args: &MethodArgs) {\n /// lint use of `map().unwrap_or()` for `Option`s\n fn lint_map_unwrap_or(cx: &LateContext, expr: &hir::Expr, map_args: &MethodArgs, unwrap_args: &MethodArgs) {\n     // lint if the caller of `map()` is an `Option`\n-    if match_type(cx, cx.tcx.expr_ty(&map_args[0]), &paths::OPTION) {\n+    if match_type(cx, cx.tcx.tables().expr_ty(&map_args[0]), &paths::OPTION) {\n         // lint message\n         let msg = \"called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling \\\n                    `map_or(a, f)` instead\";\n@@ -1018,7 +1018,7 @@ fn lint_map_unwrap_or(cx: &LateContext, expr: &hir::Expr, map_args: &MethodArgs,\n /// lint use of `map().unwrap_or_else()` for `Option`s\n fn lint_map_unwrap_or_else(cx: &LateContext, expr: &hir::Expr, map_args: &MethodArgs, unwrap_args: &MethodArgs) {\n     // lint if the caller of `map()` is an `Option`\n-    if match_type(cx, cx.tcx.expr_ty(&map_args[0]), &paths::OPTION) {\n+    if match_type(cx, cx.tcx.tables().expr_ty(&map_args[0]), &paths::OPTION) {\n         // lint message\n         let msg = \"called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling \\\n                    `map_or_else(g, f)` instead\";\n@@ -1147,7 +1147,7 @@ fn lint_chars_next(cx: &LateContext, expr: &hir::Expr, chain: &hir::Expr, other:\n         let hir::ExprPath(None, ref path) = fun.node,\n         path.segments.len() == 1 && path.segments[0].name.as_str() == \"Some\"\n     ], {\n-        let self_ty = walk_ptrs_ty(cx.tcx.expr_ty_adjusted(&args[0][0]));\n+        let self_ty = walk_ptrs_ty(cx.tcx.tables().expr_ty_adjusted(&args[0][0]));\n \n         if self_ty.sty != ty::TyStr {\n             return false;"}, {"sha": "62aec0a718d8f8b7b54ded37066dc1edc8dc3947", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -168,7 +168,7 @@ impl LintPass for Pass {\n }\n \n impl LateLintPass for Pass {\n-    fn check_fn(&mut self, cx: &LateContext, k: FnKind, decl: &FnDecl, _: &Block, _: Span, _: NodeId) {\n+    fn check_fn(&mut self, cx: &LateContext, k: FnKind, decl: &FnDecl, _: &Expr, _: Span, _: NodeId) {\n         if let FnKind::Closure(_) = k {\n             // Does not apply to closures\n             return;\n@@ -353,22 +353,22 @@ fn is_allowed(cx: &LateContext, expr: &Expr) -> bool {\n }\n \n fn is_float(cx: &LateContext, expr: &Expr) -> bool {\n-    matches!(walk_ptrs_ty(cx.tcx.expr_ty(expr)).sty, ty::TyFloat(_))\n+    matches!(walk_ptrs_ty(cx.tcx.tables().expr_ty(expr)).sty, ty::TyFloat(_))\n }\n \n fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr, left: bool, op: Span) {\n     let (arg_ty, snip) = match expr.node {\n         ExprMethodCall(Spanned { node: ref name, .. }, _, ref args) if args.len() == 1 => {\n             if name.as_str() == \"to_string\" || name.as_str() == \"to_owned\" && is_str_arg(cx, args) {\n-                (cx.tcx.expr_ty(&args[0]), snippet(cx, args[0].span, \"..\"))\n+                (cx.tcx.tables().expr_ty(&args[0]), snippet(cx, args[0].span, \"..\"))\n             } else {\n                 return;\n             }\n         }\n         ExprCall(ref path, ref v) if v.len() == 1 => {\n             if let ExprPath(None, ref path) = path.node {\n                 if match_path(path, &[\"String\", \"from_str\"]) || match_path(path, &[\"String\", \"from\"]) {\n-                    (cx.tcx.expr_ty(&v[0]), snippet(cx, v[0].span, \"..\"))\n+                    (cx.tcx.tables().expr_ty(&v[0]), snippet(cx, v[0].span, \"..\"))\n                 } else {\n                     return;\n                 }\n@@ -379,7 +379,7 @@ fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr, left: bool, op: S\n         _ => return,\n     };\n \n-    let other_ty = cx.tcx.expr_ty(other);\n+    let other_ty = cx.tcx.tables().expr_ty(other);\n     let partial_eq_trait_id = match cx.tcx.lang_items.eq_trait() {\n         Some(id) => id,\n         None => return,\n@@ -413,7 +413,7 @@ fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr, left: bool, op: S\n \n fn is_str_arg(cx: &LateContext, args: &[P<Expr>]) -> bool {\n     args.len() == 1 &&\n-        matches!(walk_ptrs_ty(cx.tcx.expr_ty(&args[0])).sty, ty::TyStr)\n+        matches!(walk_ptrs_ty(cx.tcx.tables().expr_ty(&args[0])).sty, ty::TyStr)\n }\n \n /// Heuristic to see if an expression is used. Should be compatible with `unused_variables`'s idea"}, {"sha": "abb9d0fcb49a1841dcbade4e093f438e0da5f56a", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -239,7 +239,7 @@ impl EarlyLintPass for MiscEarly {\n         }\n     }\n \n-    fn check_fn(&mut self, cx: &EarlyContext, _: FnKind, decl: &FnDecl, _: &Block, _: Span, _: NodeId) {\n+    fn check_fn(&mut self, cx: &EarlyContext, _: FnKind, decl: &FnDecl, _: Span, _: NodeId) {\n         let mut registered_names: HashMap<String, Span> = HashMap::new();\n \n         for arg in &decl.inputs {"}, {"sha": "7ca00500475fa6ed6e01079c5669303199b23411", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -147,10 +147,7 @@ impl LateLintPass for MissingDoc {\n     fn check_impl_item(&mut self, cx: &LateContext, impl_item: &hir::ImplItem) {\n         // If the method is an impl for a trait, don't doc.\n         let def_id = cx.tcx.map.local_def_id(impl_item.id);\n-        match cx.tcx.impl_or_trait_items.borrow()\n-                                         .get(&def_id)\n-                                         .expect(\"missing method descriptor?!\")\n-                                         .container() {\n+        match cx.tcx.associated_item(def_id).container {\n             ty::TraitContainer(_) => return,\n             ty::ImplContainer(cid) => {\n                 if cx.tcx.impl_trait_ref(cid).is_some() {"}, {"sha": "fe430a539a0f9d6a8f1fdfc4c4a483a721d13791", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -65,7 +65,7 @@ impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for MutVisitor<'a, 'tcx> {\n         } else if let hir::ExprAddrOf(hir::MutMutable, ref e) = expr.node {\n             if let hir::ExprAddrOf(hir::MutMutable, _) = e.node {\n                 span_lint(self.cx, MUT_MUT, expr.span, \"generally you want to avoid `&mut &mut _` if possible\");\n-            } else if let TyRef(_, TypeAndMut { mutbl: hir::MutMutable, .. }) = self.cx.tcx.expr_ty(e).sty {\n+            } else if let TyRef(_, TypeAndMut { mutbl: hir::MutMutable, .. }) = self.cx.tcx.tables().expr_ty(e).sty {\n                 span_lint(self.cx,\n                           MUT_MUT,\n                           expr.span,"}, {"sha": "bdf0ad2af98ba2d0ccb1a5017ccb567421e43f9f", "filename": "clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -56,7 +56,7 @@ pub struct MutexAtomic;\n \n impl LateLintPass for MutexAtomic {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-        let ty = cx.tcx.expr_ty(expr);\n+        let ty = cx.tcx.tables().expr_ty(expr);\n         if let ty::TyAdt(_, subst) = ty.sty {\n             if match_type(cx, ty, &paths::MUTEX) {\n                 let mutex_param = &subst.type_at(0).sty;"}, {"sha": "b2199c226e96eaea41bdafe272009b712c734b0a", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -4,9 +4,8 @@\n \n use rustc::lint::*;\n use rustc::hir::{ExprAddrOf, Expr, MutImmutable, Pat, PatKind, BindingMode};\n-use rustc::ty::TyRef;\n+use rustc::ty;\n use utils::{span_lint, in_macro};\n-use rustc::ty::adjustment::AutoAdjustment::AdjustDerefRef;\n \n /// **What it does:** Checks for address of operations (`&`) that are going to\n /// be dereferenced immediately by the compiler.\n@@ -41,9 +40,9 @@ impl LateLintPass for NeedlessBorrow {\n             return;\n         }\n         if let ExprAddrOf(MutImmutable, ref inner) = e.node {\n-            if let TyRef(..) = cx.tcx.expr_ty(inner).sty {\n-                if let Some(&AdjustDerefRef(ref deref)) = cx.tcx.tables.borrow().adjustments.get(&e.id) {\n-                    if deref.autoderefs > 1 && deref.autoref.is_some() {\n+            if let ty::TyRef(..) = cx.tcx.tables().expr_ty(inner).sty {\n+                if let Some(&ty::adjustment::Adjust::DerefRef { autoderefs, autoref, .. }) = cx.tcx.tables.borrow().adjustments.get(&e.id).map(|a| &a.kind) {\n+                    if autoderefs > 1 && autoref.is_some() {\n                         span_lint(cx,\n                                   NEEDLESS_BORROW,\n                                   e.span,\n@@ -59,9 +58,9 @@ impl LateLintPass for NeedlessBorrow {\n             return;\n         }\n         if let PatKind::Binding(BindingMode::BindByRef(MutImmutable), _, _) = pat.node {\n-            if let TyRef(_, ref tam) = cx.tcx.pat_ty(pat).sty {\n+            if let ty::TyRef(_, ref tam) = cx.tcx.tables().pat_ty(pat).sty {\n                 if tam.mutbl == MutImmutable {\n-                    if let TyRef(..) = tam.ty.sty {\n+                    if let ty::TyRef(..) = tam.ty.sty {\n                         span_lint(cx,\n                                   NEEDLESS_BORROW,\n                                   pat.span,"}, {"sha": "cdd266ec2e87c589eec8578565ddef0b7a7315fb", "filename": "clippy_lints/src/needless_update.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_update.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -33,7 +33,7 @@ impl LintPass for Pass {\n impl LateLintPass for Pass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprStruct(_, ref fields, Some(ref base)) = expr.node {\n-            let ty = cx.tcx.expr_ty(expr);\n+            let ty = cx.tcx.tables().expr_ty(expr);\n             if let TyAdt(def, _) = ty.sty {\n                 if fields.len() == def.struct_variant().fields.len() {\n                     span_lint(cx,"}, {"sha": "5ca6172b6bcc827187f6fdaa9689e77f3f8204dd", "filename": "clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_multiply.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -50,7 +50,7 @@ fn check_mul(cx: &LateContext, span: Span, lit: &Expr, exp: &Expr) {\n         let Constant::Int(ref ci) = consts::lit_to_constant(&l.node),\n         let Some(val) = ci.to_u64(),\n         val == 1,\n-        cx.tcx.expr_ty(exp).is_integral()\n+        cx.tcx.tables().expr_ty(exp).is_integral()\n     ], {\n         span_lint(cx,\n                   NEG_MULTIPLY,"}, {"sha": "66420f00c674a42ae6df5cc5d4b0373000e7145a", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -90,7 +90,7 @@ impl LintPass for NewWithoutDefault {\n }\n \n impl LateLintPass for NewWithoutDefault {\n-    fn check_fn(&mut self, cx: &LateContext, kind: FnKind, decl: &hir::FnDecl, _: &hir::Block, span: Span, id: ast::NodeId) {\n+    fn check_fn(&mut self, cx: &LateContext, kind: FnKind, decl: &hir::FnDecl, _: &hir::Expr, span: Span, id: ast::NodeId) {\n         if in_external_macro(cx, span) {\n             return;\n         }\n@@ -102,8 +102,7 @@ impl LateLintPass for NewWithoutDefault {\n             }\n             if decl.inputs.is_empty() && name.as_str() == \"new\" && cx.access_levels.is_reachable(id) {\n                 let self_ty = cx.tcx\n-                    .lookup_item_type(cx.tcx.map.local_def_id(cx.tcx.map.get_parent(id)))\n-                    .ty;\n+                    .item_type(cx.tcx.map.local_def_id(cx.tcx.map.get_parent(id)));\n                 if_let_chain!{[\n                     self_ty.walk_shallow().next().is_none(), // implements_trait does not work with generics\n                     same_tys(cx, self_ty, return_ty(cx, id), id),"}, {"sha": "1fdfe43b6845d9d7ffaebc64e17422ee93fb32f4", "filename": "clippy_lints/src/ok_if_let.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fok_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fok_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fok_if_let.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -50,7 +50,7 @@ impl LateLintPass for Pass {\n             method_chain_args(op, &[\"ok\"]).is_some() //test to see if using ok() methoduse std::marker::Sized;\n \n         ], {\n-            let is_result_type = match_type(cx, cx.tcx.expr_ty(&result_types[0]), &paths::RESULT);\n+            let is_result_type = match_type(cx, cx.tcx.tables().expr_ty(&result_types[0]), &paths::RESULT);\n             let some_expr_string = snippet(cx, y[0].span, \"\");\n             if print::path_to_string(x) == \"Some\" && is_result_type {\n                 span_help_and_lint(cx, IF_LET_SOME_RESULT, expr.span,"}, {"sha": "51d961e9fe63aa293c2f462f07063212376c0949", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -35,7 +35,7 @@ impl LintPass for NonSensical {\n impl LateLintPass for NonSensical {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n         if let ExprMethodCall(ref name, _, ref arguments) = e.node {\n-            let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&arguments[0]));\n+            let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.tables().expr_ty(&arguments[0]));\n             if name.node.as_str() == \"open\" && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n                 let mut options = Vec::new();\n                 get_open_options(cx, &arguments[0], &mut options);\n@@ -63,7 +63,7 @@ enum OpenOption {\n \n fn get_open_options(cx: &LateContext, argument: &Expr, options: &mut Vec<(OpenOption, Argument)>) {\n     if let ExprMethodCall(ref name, _, ref arguments) = argument.node {\n-        let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&arguments[0]));\n+        let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.tables().expr_ty(&arguments[0]));\n \n         // Only proceed if this is a call on some object of type std::fs::OpenOptions\n         if match_type(cx, obj_ty, &paths::OPEN_OPTIONS) && arguments.len() >= 2 {"}, {"sha": "98c2b986d202353e013db186f3143307bfe1e637", "filename": "clippy_lints/src/overflow_check_conditional.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -39,8 +39,8 @@ impl LateLintPass for OverflowCheckConditional {\n             let Expr_::ExprPath(_, ref path2) = ident2.node,\n             let Expr_::ExprPath(_, ref path3) = second.node,\n             &path1.segments[0] == &path3.segments[0] || &path2.segments[0] == &path3.segments[0],\n-            cx.tcx.expr_ty(ident1).is_integral(),\n-            cx.tcx.expr_ty(ident2).is_integral()\n+            cx.tcx.tables().expr_ty(ident1).is_integral(),\n+            cx.tcx.tables().expr_ty(ident2).is_integral()\n         ], {\n             if let BinOp_::BiLt = op.node {\n                 if let BinOp_::BiAdd = op2.node {\n@@ -61,8 +61,8 @@ impl LateLintPass for OverflowCheckConditional {\n             let Expr_::ExprPath(_, ref path2) = ident2.node,\n             let Expr_::ExprPath(_, ref path3) = first.node,\n             &path1.segments[0] == &path3.segments[0] || &path2.segments[0] == &path3.segments[0],\n-            cx.tcx.expr_ty(ident1).is_integral(),\n-            cx.tcx.expr_ty(ident2).is_integral()\n+            cx.tcx.tables().expr_ty(ident1).is_integral(),\n+            cx.tcx.tables().expr_ty(ident2).is_integral()\n         ], {\n             if let BinOp_::BiGt = op.node {\n                 if let BinOp_::BiAdd = op2.node {"}, {"sha": "2863b14b1121049599fb9de39af04250df131428", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -91,7 +91,8 @@ impl LateLintPass for PointerPass {\n }\n \n fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId) {\n-    let fn_ty = cx.tcx.node_id_to_type(fn_id).fn_sig().skip_binder();\n+    let fn_def_id = cx.tcx.map.local_def_id(fn_id);\n+    let fn_ty = cx.tcx.item_type(fn_def_id).fn_sig().skip_binder();\n \n     for (arg, ty) in decl.inputs.iter().zip(&fn_ty.inputs) {\n         if let ty::TyRef(_, ty::TypeAndMut { ty, mutbl: MutImmutable }) = ty.sty {"}, {"sha": "45886a903942e4dc3060dc1a36921180e32d676b", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -89,7 +89,7 @@ impl LateLintPass for StepByZero {\n fn has_step_by(cx: &LateContext, expr: &Expr) -> bool {\n     // No need for walk_ptrs_ty here because step_by moves self, so it\n     // can't be called on a borrowed range.\n-    let ty = cx.tcx.expr_ty(expr);\n+    let ty = cx.tcx.tables().expr_ty(expr);\n \n     // Note: `RangeTo`, `RangeToInclusive` and `RangeFull` don't have step_by\n     match_type(cx, ty, &paths::RANGE)"}, {"sha": "fef03d19cc78d69bd380e9ca2b6e03181c2d0125", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -91,7 +91,7 @@ impl LateLintPass for Pass {\n         if_let_chain!{[\n             self.last.is_none(),\n             let Some(ref expr) = block.expr,\n-            match_type(cx, cx.tcx.expr_ty(expr), &paths::REGEX),\n+            match_type(cx, cx.tcx.tables().expr_ty(expr), &paths::REGEX),\n             let Some(span) = is_expn_of(cx, expr.span, \"regex\"),\n         ], {\n             if !self.spans.contains(&span) {"}, {"sha": "0e6de0d39b22201c663baaec4287006530cb802b", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -1,5 +1,5 @@\n use rustc::lint::*;\n-use syntax::ast::*;\n+use syntax::ast;\n use syntax::codemap::{Span, Spanned};\n use syntax::visit::FnKind;\n \n@@ -45,10 +45,10 @@ pub struct ReturnPass;\n \n impl ReturnPass {\n     // Check the final stmt or expr in a block for unnecessary return.\n-    fn check_block_return(&mut self, cx: &EarlyContext, block: &Block) {\n+    fn check_block_return(&mut self, cx: &EarlyContext, block: &ast::Block) {\n         if let Some(stmt) = block.stmts.last() {\n             match stmt.node {\n-                StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => {\n+                ast::StmtKind::Expr(ref expr) | ast::StmtKind::Semi(ref expr) => {\n                     self.check_final_expr(cx, expr, Some(stmt.span));\n                 }\n                 _ => (),\n@@ -57,25 +57,25 @@ impl ReturnPass {\n     }\n \n     // Check a the final expression in a block if it's a return.\n-    fn check_final_expr(&mut self, cx: &EarlyContext, expr: &Expr, span: Option<Span>) {\n+    fn check_final_expr(&mut self, cx: &EarlyContext, expr: &ast::Expr, span: Option<Span>) {\n         match expr.node {\n             // simple return is always \"bad\"\n-            ExprKind::Ret(Some(ref inner)) => {\n+            ast::ExprKind::Ret(Some(ref inner)) => {\n                 self.emit_return_lint(cx, span.expect(\"`else return` is not possible\"), inner.span);\n             }\n             // a whole block? check it!\n-            ExprKind::Block(ref block) => {\n+            ast::ExprKind::Block(ref block) => {\n                 self.check_block_return(cx, block);\n             }\n             // an if/if let expr, check both exprs\n             // note, if without else is going to be a type checking error anyways\n             // (except for unit type functions) so we don't match it\n-            ExprKind::If(_, ref ifblock, Some(ref elsexpr)) => {\n+            ast::ExprKind::If(_, ref ifblock, Some(ref elsexpr)) => {\n                 self.check_block_return(cx, ifblock);\n                 self.check_final_expr(cx, elsexpr, None);\n             }\n             // a match expr, check all arms\n-            ExprKind::Match(_, ref arms) => {\n+            ast::ExprKind::Match(_, ref arms) => {\n                 for arm in arms {\n                     self.check_final_expr(cx, &arm.body, Some(arm.body.span));\n                 }\n@@ -96,18 +96,18 @@ impl ReturnPass {\n     }\n \n     // Check for \"let x = EXPR; x\"\n-    fn check_let_return(&mut self, cx: &EarlyContext, block: &Block) {\n+    fn check_let_return(&mut self, cx: &EarlyContext, block: &ast::Block) {\n         let mut it = block.stmts.iter();\n \n         // we need both a let-binding stmt and an expr\n         if_let_chain! {[\n             let Some(ref retexpr) = it.next_back(),\n-            let StmtKind::Expr(ref retexpr) = retexpr.node,\n+            let ast::StmtKind::Expr(ref retexpr) = retexpr.node,\n             let Some(stmt) = it.next_back(),\n-            let StmtKind::Local(ref local) = stmt.node,\n+            let ast::StmtKind::Local(ref local) = stmt.node,\n             let Some(ref initexpr) = local.init,\n-            let PatKind::Ident(_, Spanned { node: id, .. }, _) = local.pat.node,\n-            let ExprKind::Path(_, ref path) = retexpr.node,\n+            let ast::PatKind::Ident(_, Spanned { node: id, .. }, _) = local.pat.node,\n+            let ast::ExprKind::Path(_, ref path) = retexpr.node,\n             match_path_ast(path, &[&id.name.as_str()]),\n             !in_external_macro(cx, initexpr.span),\n         ], {\n@@ -129,11 +129,14 @@ impl LintPass for ReturnPass {\n }\n \n impl EarlyLintPass for ReturnPass {\n-    fn check_fn(&mut self, cx: &EarlyContext, _: FnKind, _: &FnDecl, block: &Block, _: Span, _: NodeId) {\n-        self.check_block_return(cx, block);\n+    fn check_fn(&mut self, cx: &EarlyContext, kind: FnKind, _: &ast::FnDecl, _: Span, _: ast::NodeId) {\n+        match kind {\n+            FnKind::ItemFn(.., block) | FnKind::Method(.., block) => self.check_block_return(cx, block),\n+            FnKind::Closure(body) => self.check_final_expr(cx, body, None),\n+        }\n     }\n \n-    fn check_block(&mut self, cx: &EarlyContext, block: &Block) {\n+    fn check_block(&mut self, cx: &EarlyContext, block: &ast::Block) {\n         self.check_let_return(cx, block);\n     }\n }"}, {"sha": "b57ec1d052aa0e0f22903e852fbf33c67cdec397", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -81,22 +81,22 @@ impl LintPass for Pass {\n }\n \n impl LateLintPass for Pass {\n-    fn check_fn(&mut self, cx: &LateContext, _: FnKind, decl: &FnDecl, block: &Block, _: Span, _: NodeId) {\n-        if in_external_macro(cx, block.span) {\n+    fn check_fn(&mut self, cx: &LateContext, _: FnKind, decl: &FnDecl, expr: &Expr, _: Span, _: NodeId) {\n+        if in_external_macro(cx, expr.span) {\n             return;\n         }\n-        check_fn(cx, decl, block);\n+        check_fn(cx, decl, expr);\n     }\n }\n \n-fn check_fn(cx: &LateContext, decl: &FnDecl, block: &Block) {\n+fn check_fn(cx: &LateContext, decl: &FnDecl, expr: &Expr) {\n     let mut bindings = Vec::new();\n     for arg in &decl.inputs {\n         if let PatKind::Binding(_, ident, _) = arg.pat.node {\n             bindings.push((ident.node, ident.span))\n         }\n     }\n-    check_block(cx, block, &mut bindings);\n+    check_expr(cx, expr, &mut bindings);\n }\n \n fn check_block(cx: &LateContext, block: &Block, bindings: &mut Vec<(Name, Span)>) {"}, {"sha": "9fd09eab2ddc6117159c2664a015c965c25c9dd0", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -114,7 +114,7 @@ impl LateLintPass for StringAdd {\n }\n \n fn is_string(cx: &LateContext, e: &Expr) -> bool {\n-    match_type(cx, walk_ptrs_ty(cx.tcx.expr_ty(e)), &paths::STRING)\n+    match_type(cx, walk_ptrs_ty(cx.tcx.tables().expr_ty(e)), &paths::STRING)\n }\n \n fn is_add(cx: &LateContext, src: &Expr, target: &Expr) -> bool {"}, {"sha": "278df3bad3526454d219663f834fea280816cd80", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -85,7 +85,7 @@ fn check_manual_swap(cx: &LateContext, block: &Block) {\n                 if let ExprIndex(ref lhs1, ref idx1) = lhs1.node {\n                     if let ExprIndex(ref lhs2, ref idx2) = lhs2.node {\n                         if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, lhs2) {\n-                            let ty = walk_ptrs_ty(cx.tcx.expr_ty(lhs1));\n+                            let ty = walk_ptrs_ty(cx.tcx.tables().expr_ty(lhs1));\n \n                             if matches!(ty.sty, ty::TySlice(_)) ||\n                                 matches!(ty.sty, ty::TyArray(_, _)) ||"}, {"sha": "b4505c89f3b70af971458796d9735290f7598d5a", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -91,8 +91,8 @@ impl LateLintPass for Transmute {\n                 let def_id = cx.tcx.expect_def(path_expr.id).def_id();\n \n                 if match_def_path(cx, def_id, &paths::TRANSMUTE) {\n-                    let from_ty = cx.tcx.expr_ty(&args[0]);\n-                    let to_ty = cx.tcx.expr_ty(e);\n+                    let from_ty = cx.tcx.tables().expr_ty(&args[0]);\n+                    let to_ty = cx.tcx.tables().expr_ty(e);\n \n                     match (&from_ty.sty, &to_ty.sty) {\n                         _ if from_ty == to_ty => span_lint("}, {"sha": "de8fbdcc5d7a4aca872c110b4a598d8b1cdcc611", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -126,7 +126,7 @@ declare_lint! {\n \n fn check_let_unit(cx: &LateContext, decl: &Decl) {\n     if let DeclLocal(ref local) = decl.node {\n-        let bindtype = &cx.tcx.pat_ty(&local.pat).sty;\n+        let bindtype = &cx.tcx.tables().pat_ty(&local.pat).sty;\n         match *bindtype {\n             ty::TyTuple(slice) if slice.is_empty() => {\n                 if in_external_macro(cx, decl.span) || in_macro(cx, local.pat.span) {\n@@ -197,7 +197,7 @@ impl LateLintPass for UnitCmp {\n         if let ExprBinary(ref cmp, ref left, _) = expr.node {\n             let op = cmp.node;\n             if op.is_comparison() {\n-                let sty = &cx.tcx.expr_ty(left).sty;\n+                let sty = &cx.tcx.tables().expr_ty(left).sty;\n                 match *sty {\n                     ty::TyTuple(slice) if slice.is_empty() => {\n                         let result = match op {\n@@ -449,7 +449,7 @@ impl LintPass for CastPass {\n impl LateLintPass for CastPass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprCast(ref ex, _) = expr.node {\n-            let (cast_from, cast_to) = (cx.tcx.expr_ty(ex), cx.tcx.expr_ty(expr));\n+            let (cast_from, cast_to) = (cx.tcx.tables().expr_ty(ex), cx.tcx.tables().expr_ty(expr));\n             if cast_from.is_numeric() && cast_to.is_numeric() && !in_external_macro(cx, expr.span) {\n                 match (cast_from.is_integral(), cast_to.is_integral()) {\n                     (true, false) => {\n@@ -535,7 +535,7 @@ impl LintPass for TypeComplexityPass {\n }\n \n impl LateLintPass for TypeComplexityPass {\n-    fn check_fn(&mut self, cx: &LateContext, _: FnKind, decl: &FnDecl, _: &Block, _: Span, _: NodeId) {\n+    fn check_fn(&mut self, cx: &LateContext, _: FnKind, decl: &FnDecl, _: &Expr, _: Span, _: NodeId) {\n         self.check_fndecl(cx, decl);\n     }\n \n@@ -683,7 +683,7 @@ impl LateLintPass for CharLitAsU8 {\n         if let ExprCast(ref e, _) = expr.node {\n             if let ExprLit(ref l) = e.node {\n                 if let LitKind::Char(_) = l.node {\n-                    if ty::TyUint(UintTy::U8) == cx.tcx.expr_ty(expr).sty && !in_macro(cx, expr.span) {\n+                    if ty::TyUint(UintTy::U8) == cx.tcx.tables().expr_ty(expr).sty && !in_macro(cx, expr.span) {\n                         let msg = \"casting character literal to u8. `char`s \\\n                                    are 4 bytes wide in rust, so casting to u8 \\\n                                    truncates them\";\n@@ -791,7 +791,7 @@ fn detect_extreme_expr<'a>(cx: &LateContext, expr: &'a Expr) -> Option<ExtremeEx\n     use rustc_const_eval::*;\n     use types::ExtremeType::*;\n \n-    let ty = &cx.tcx.expr_ty(expr).sty;\n+    let ty = &cx.tcx.tables().expr_ty(expr).sty;\n \n     match *ty {\n         ty::TyBool | ty::TyInt(_) | ty::TyUint(_) => (),\n@@ -953,7 +953,7 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(\n     use std::*;\n \n     if let ExprCast(ref cast_exp, _) = expr.node {\n-        match cx.tcx.expr_ty(cast_exp).sty {\n+        match cx.tcx.tables().expr_ty(cast_exp).sty {\n             TyInt(int_ty) => {\n                 Some(match int_ty {\n                     IntTy::I8 => (FullInt::S(i8::min_value() as i64), FullInt::S(i8::max_value() as i64)),"}, {"sha": "63a6321f0eaef3fb72d1b412a369bd5a03c1f80c", "filename": "clippy_lints/src/unused_label.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Funused_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Funused_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_label.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -47,7 +47,7 @@ impl LintPass for UnusedLabel {\n }\n \n impl LateLintPass for UnusedLabel {\n-    fn check_fn(&mut self, cx: &LateContext, kind: FnKind, decl: &hir::FnDecl, body: &hir::Block, span: Span, fn_id: ast::NodeId) {\n+    fn check_fn(&mut self, cx: &LateContext, kind: FnKind, decl: &hir::FnDecl, body: &hir::Expr, span: Span, fn_id: ast::NodeId) {\n         if in_macro(cx, span) {\n             return;\n         }"}, {"sha": "bd9969714a4cc9ee2e46d979a64a7de3d175e4f4", "filename": "clippy_lints/src/utils/hir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -368,11 +368,11 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 self.hash_expr(e);\n                 // TODO: _ty\n             }\n-            ExprClosure(cap, _, ref b, _) => {\n+            ExprClosure(cap, _, ref e, _) => {\n                 let c: fn(_, _, _, _) -> _ = ExprClosure;\n                 c.hash(&mut self.s);\n                 cap.hash(&mut self.s);\n-                self.hash_block(b);\n+                self.hash_expr(e);\n             }\n             ExprField(ref e, ref f) => {\n                 let c: fn(_, _) -> _ = ExprField;"}, {"sha": "15bae8a7b1f9f75ee61df1864dcdebb2b2658e1a", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -135,7 +135,7 @@ fn has_attr(attrs: &[Attribute]) -> bool {\n fn print_decl(cx: &LateContext, decl: &hir::Decl) {\n     match decl.node {\n         hir::DeclLocal(ref local) => {\n-            println!(\"local variable of type {}\", cx.tcx.node_id_to_type(local.id));\n+            println!(\"local variable of type {}\", cx.tcx.tables().node_id_to_type(local.id));\n             println!(\"pattern:\");\n             print_pat(cx, &local.pat, 0);\n             if let Some(ref e) = local.init {\n@@ -149,7 +149,7 @@ fn print_decl(cx: &LateContext, decl: &hir::Decl) {\n \n fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n     let ind = \"  \".repeat(indent);\n-    let ty = cx.tcx.node_id_to_type(expr.id);\n+    let ty = cx.tcx.tables().node_id_to_type(expr.id);\n     println!(\"{}+\", ind);\n     match expr.node {\n         hir::ExprBox(ref e) => {\n@@ -350,25 +350,25 @@ fn print_item(cx: &LateContext, item: &hir::Item) {\n             }\n         }\n         hir::ItemUse(ref path) => println!(\"{:?}\", path.node),\n-        hir::ItemStatic(..) => println!(\"static item: {:#?}\", cx.tcx.opt_lookup_item_type(did)),\n-        hir::ItemConst(..) => println!(\"const item: {:#?}\", cx.tcx.opt_lookup_item_type(did)),\n+        hir::ItemStatic(..) => (), //println!(\"static item: {:#?}\", cx.tcx.opt_lookup_item_type(did)),\n+        hir::ItemConst(..) => (), //println!(\"const item: {:#?}\", cx.tcx.opt_lookup_item_type(did)),\n         hir::ItemFn(..) => {\n-            let item_ty = cx.tcx.opt_lookup_item_type(did);\n-            println!(\"function: {:#?}\", item_ty);\n+            //let item_ty = cx.tcx.opt_lookup_item_type(did);\n+            //println!(\"function: {:#?}\", item_ty);\n         },\n         hir::ItemMod(..) => println!(\"module\"),\n         hir::ItemForeignMod(ref fm) => println!(\"foreign module with abi: {}\", fm.abi),\n         hir::ItemTy(..) => {\n-            println!(\"type alias: {:?}\", cx.tcx.opt_lookup_item_type(did));\n+            //println!(\"type alias: {:?}\", cx.tcx.opt_lookup_item_type(did));\n         },\n         hir::ItemEnum(..) => {\n-            println!(\"enum definition: {:?}\", cx.tcx.opt_lookup_item_type(did));\n+            //println!(\"enum definition: {:?}\", cx.tcx.opt_lookup_item_type(did));\n         },\n         hir::ItemStruct(..) => {\n-            println!(\"struct definition: {:?}\", cx.tcx.opt_lookup_item_type(did));\n+            //println!(\"struct definition: {:?}\", cx.tcx.opt_lookup_item_type(did));\n         },\n         hir::ItemUnion(..) => {\n-            println!(\"union definition: {:?}\", cx.tcx.opt_lookup_item_type(did));\n+            //println!(\"union definition: {:?}\", cx.tcx.opt_lookup_item_type(did));\n         },\n         hir::ItemTrait(..) => {\n             println!(\"trait decl\");"}, {"sha": "f273233b947cbc733a8753116e33e3dbd5b2b7c5", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -429,7 +429,12 @@ pub fn get_enclosing_block<'c>(cx: &'c LateContext, node: NodeId) -> Option<&'c\n     if let Some(node) = enclosing_node {\n         match node {\n             Node::NodeBlock(block) => Some(block),\n-            Node::NodeItem(&Item { node: ItemFn(_, _, _, _, _, ref block), .. }) => Some(block),\n+            Node::NodeItem(&Item { node: ItemFn(_, _, _, _, _, ref expr), .. }) => {\n+                match expr.node {\n+                    ExprBlock(ref block) => Some(block),\n+                    _ => None,\n+                }\n+            }\n             _ => None,\n         }\n     } else {\n@@ -696,8 +701,9 @@ pub fn camel_case_from(s: &str) -> usize {\n /// Convenience function to get the return type of a function\n pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: NodeId) -> ty::Ty<'tcx> {\n     let parameter_env = ty::ParameterEnvironment::for_item(cx.tcx, fn_item);\n-    let fn_sig = cx.tcx.node_id_to_type(fn_item).fn_sig().subst(cx.tcx, parameter_env.free_substs);\n-    let fn_sig = cx.tcx.liberate_late_bound_regions(parameter_env.free_id_outlive, &fn_sig);\n+    let fn_def_id = cx.tcx.map.local_def_id(fn_item);\n+    let fn_sig = cx.tcx.item_type(fn_def_id).fn_sig();\n+    let fn_sig = cx.tcx.liberate_late_bound_regions(parameter_env.free_id_outlive, fn_sig);\n     fn_sig.output\n }\n "}, {"sha": "f847c397da868cf385bfdab40bf8bbdb8aaefc8e", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -36,7 +36,7 @@ impl LateLintPass for Pass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         // search for `&vec![_]` expressions where the adjusted type is `&[_]`\n         if_let_chain!{[\n-            let ty::TypeVariants::TyRef(_, ref ty) = cx.tcx.expr_ty_adjusted(expr).sty,\n+            let ty::TypeVariants::TyRef(_, ref ty) = cx.tcx.tables().expr_ty_adjusted(expr).sty,\n             let ty::TypeVariants::TySlice(..) = ty.ty.sty,\n             let ExprAddrOf(_, ref addressee) = expr.node,\n             let Some(vec_args) = higher::vec_macro(cx, addressee),\n@@ -48,7 +48,7 @@ impl LateLintPass for Pass {\n         if_let_chain!{[\n             let Some((_, arg, _)) = higher::for_loop(expr),\n             let Some(vec_args) = higher::vec_macro(cx, arg),\n-            is_copy(cx, vec_type(cx.tcx.expr_ty_adjusted(arg)), cx.tcx.map.get_parent(expr.id)),\n+            is_copy(cx, vec_type(cx.tcx.tables().expr_ty_adjusted(arg)), cx.tcx.map.get_parent(expr.id)),\n         ], {\n             // report the error around the `vec!` not inside `<std macros>:`\n             let span = cx.sess().codemap().source_callsite(arg.span);"}, {"sha": "3e65d1aeec47c63900537d65346466097f462f99", "filename": "tests/compile-fail/copies.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/tests%2Fcompile-fail%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/tests%2Fcompile-fail%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcopies.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -1,5 +1,4 @@\n #![feature(plugin, inclusive_range_syntax)]\n-#![feature(dotdot_in_tuple_patterns)]\n #![plugin(clippy)]\n \n #![allow(dead_code, no_effect, unnecessary_operation)]"}, {"sha": "e7daebfdf2f947bffcbcfedd69b8e87cd8fcb807", "filename": "tests/compile-fail/diverging_sub_expression.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/tests%2Fcompile-fail%2Fdiverging_sub_expression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/tests%2Fcompile-fail%2Fdiverging_sub_expression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdiverging_sub_expression.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -1,6 +1,7 @@\n #![feature(plugin, never_type)]\n #![plugin(clippy)]\n #![deny(diverging_sub_expression)]\n+#![allow(match_same_arms, logic_bug)]\n \n #[allow(empty_loop)]\n fn diverge() -> ! { loop {} }\n@@ -16,8 +17,6 @@ fn main() {\n     let b = true;\n     b || diverge(); //~ ERROR sub-expression diverges\n     b || A.foo(); //~ ERROR sub-expression diverges\n-    let y = (5, diverge(), 6); //~ ERROR sub-expression diverges\n-    println!(\"{}\", y.1);\n }\n \n #[allow(dead_code, unused_variables)]\n@@ -26,16 +25,16 @@ fn foobar() {\n         let x = match 5 {\n             4 => return,\n             5 => continue,\n-            6 => (println!(\"foo\"), return), //~ ERROR sub-expression diverges\n-            7 => (println!(\"bar\"), continue), //~ ERROR sub-expression diverges\n+            6 => true || return, //~ ERROR sub-expression diverges\n+            7 => true || continue, //~ ERROR sub-expression diverges\n             8 => break,\n             9 => diverge(),\n-            3 => (println!(\"moo\"), diverge()), //~ ERROR sub-expression diverges\n+            3 => true || diverge(), //~ ERROR sub-expression diverges\n             10 => match 42 {\n                 99 => return,\n-                _ => ((), panic!(\"boo\")),\n+                _ => true || panic!(\"boo\"),\n             },\n-            _ => (println!(\"boo\"), break), //~ ERROR sub-expression diverges\n+            _ => true || break, //~ ERROR sub-expression diverges\n         };\n     }\n }"}, {"sha": "f0502a7179687356df50527ca02f23b641add66e", "filename": "tests/compile-fail/eq_op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/tests%2Fcompile-fail%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5f5394bc623b29abd1bd3afb7a8af0a691ec3/tests%2Fcompile-fail%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Feq_op.rs?ref=19c5f5394bc623b29abd1bd3afb7a8af0a691ec3", "patch": "@@ -43,8 +43,8 @@ fn main() {\n     true || true; //~ERROR equal expressions\n     //~|ERROR this boolean expression can be simplified\n \n-    let a: u32 = unimplemented!();\n-    let b: u32 = unimplemented!();\n+    let a: u32 = 0;\n+    let b: u32 = 0;\n \n     a == b && b == a; //~ERROR equal expressions\n     //~|ERROR this boolean expression can be simplified"}]}