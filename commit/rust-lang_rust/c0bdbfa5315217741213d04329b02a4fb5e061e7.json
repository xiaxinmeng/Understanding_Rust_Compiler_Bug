{"sha": "c0bdbfa5315217741213d04329b02a4fb5e061e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwYmRiZmE1MzE1MjE3NzQxMjEzZDA0MzI5YjAyYTRmYjVlMDYxZTc=", "commit": {"author": {"name": "Michael Killough", "email": "michaeljkillough@gmail.com", "date": "2017-05-16T08:47:09Z"}, "committer": {"name": "Michael Killough", "email": "michaeljkillough@gmail.com", "date": "2017-05-16T08:47:09Z"}, "message": "Switch to accessing config items via method.\n\nPreparation for #865, which proposes adding a flag which outputs which\nconfig options are used during formatting.\n\nThis PR should not make any difference to functionality. A lot of this\nwas search-and-replace.\n\nSome areas worthy of review/discussion:\n\n - The method for each config item returns a clone of the underlying\n   value. We can't simply return an immutable reference, as lots of\n   places in the code expect to be able to pass the returned value as\n   `bool` (not `&bool). It would be nice if the `bool` items could\n   return a copy, but the more complex types a borrowed reference... but\n   unfortunately, I couldn't get the macro to do this.\n - A few places (mostly tests and `src/bin/rustfmt.rs`) were overriding\n   config items by modifying the fields of the `Config` struct directly.\n   They now use the existing `override_value()` method, which has been\n   modified to return a `Result` for use by `src/bin/rustfmt.rs`. This\n   benefits of this are that the complex `file_lines` and `write_mode`\n   strings are now parsed in one place (`Config.override_value`) instead\n   of multiple. The disadvantages are that it moves the compile-time\n   checks for config names to become run-time checks.", "tree": {"sha": "d0c03d2899942bf1fcd60c2807213b4b9144c2e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0c03d2899942bf1fcd60c2807213b4b9144c2e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0bdbfa5315217741213d04329b02a4fb5e061e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0bdbfa5315217741213d04329b02a4fb5e061e7", "html_url": "https://github.com/rust-lang/rust/commit/c0bdbfa5315217741213d04329b02a4fb5e061e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0bdbfa5315217741213d04329b02a4fb5e061e7/comments", "author": {"login": "mjkillough", "id": 532855, "node_id": "MDQ6VXNlcjUzMjg1NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/532855?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mjkillough", "html_url": "https://github.com/mjkillough", "followers_url": "https://api.github.com/users/mjkillough/followers", "following_url": "https://api.github.com/users/mjkillough/following{/other_user}", "gists_url": "https://api.github.com/users/mjkillough/gists{/gist_id}", "starred_url": "https://api.github.com/users/mjkillough/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mjkillough/subscriptions", "organizations_url": "https://api.github.com/users/mjkillough/orgs", "repos_url": "https://api.github.com/users/mjkillough/repos", "events_url": "https://api.github.com/users/mjkillough/events{/privacy}", "received_events_url": "https://api.github.com/users/mjkillough/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mjkillough", "id": 532855, "node_id": "MDQ6VXNlcjUzMjg1NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/532855?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mjkillough", "html_url": "https://github.com/mjkillough", "followers_url": "https://api.github.com/users/mjkillough/followers", "following_url": "https://api.github.com/users/mjkillough/following{/other_user}", "gists_url": "https://api.github.com/users/mjkillough/gists{/gist_id}", "starred_url": "https://api.github.com/users/mjkillough/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mjkillough/subscriptions", "organizations_url": "https://api.github.com/users/mjkillough/orgs", "repos_url": "https://api.github.com/users/mjkillough/repos", "events_url": "https://api.github.com/users/mjkillough/events{/privacy}", "received_events_url": "https://api.github.com/users/mjkillough/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09e5051deed87b4c2eee5be6f5868e14380fe996", "url": "https://api.github.com/repos/rust-lang/rust/commits/09e5051deed87b4c2eee5be6f5868e14380fe996", "html_url": "https://github.com/rust-lang/rust/commit/09e5051deed87b4c2eee5be6f5868e14380fe996"}], "stats": {"total": 729, "additions": 384, "deletions": 345}, "files": [{"sha": "730cefdca45490bdbc12d1dc01d330d23ee883f0", "filename": "Contributing.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bdbfa5315217741213d04329b02a4fb5e061e7/Contributing.md", "raw_url": "https://github.com/rust-lang/rust/raw/c0bdbfa5315217741213d04329b02a4fb5e061e7/Contributing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Contributing.md?ref=c0bdbfa5315217741213d04329b02a4fb5e061e7", "patch": "@@ -207,6 +207,6 @@ handling of configuration options is done in [src/config.rs](src/config.rs). Loo\n `create_config!` macro at the end of the file for all the options. The rest of\n the file defines a bunch of enums used for options, and the machinery to produce\n the config struct and parse a config file, etc. Checking an option is done by\n-accessing the correct field on the config struct, e.g., `config.max_width`. Most\n+accessing the correct field on the config struct, e.g., `config.max_width()`. Most\n functions have a `Config`, or one can be accessed via a visitor or context of\n some kind."}, {"sha": "43caa7b81f80114aa7ac7e9b7728f58bf8dfecd5", "filename": "Design.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bdbfa5315217741213d04329b02a4fb5e061e7/Design.md", "raw_url": "https://github.com/rust-lang/rust/raw/c0bdbfa5315217741213d04329b02a4fb5e061e7/Design.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Design.md?ref=c0bdbfa5315217741213d04329b02a4fb5e061e7", "patch": "@@ -150,7 +150,7 @@ for its configuration.\n \n Our visitor keeps track of the desired current indent due to blocks (\n `block_indent`). Each `visit_*` method reformats code according to this indent,\n-`config.comment_width` and `config.max_width`. Most reformatting done in the\n+`config.comment_width()` and `config.max_width()`. Most reformatting done in the\n `visit_*` methods is a bit hackey and is meant to be temporary until it can be\n done properly.\n "}, {"sha": "fac4f9f8714cf7ee061af25673d8fbe175e87d87", "filename": "src/bin/rustfmt.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Fbin%2Frustfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Fbin%2Frustfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Frustfmt.rs?ref=c0bdbfa5315217741213d04329b02a4fb5e061e7", "patch": "@@ -18,14 +18,12 @@ extern crate env_logger;\n extern crate getopts;\n \n use rustfmt::{run, Input, Summary};\n-use rustfmt::file_lines::FileLines;\n-use rustfmt::config::{Config, WriteMode};\n+use rustfmt::config::Config;\n \n use std::{env, error};\n use std::fs::{self, File};\n use std::io::{self, ErrorKind, Read, Write};\n use std::path::{Path, PathBuf};\n-use std::str::FromStr;\n \n use getopts::{Matches, Options};\n \n@@ -63,8 +61,8 @@ enum Operation {\n struct CliOptions {\n     skip_children: bool,\n     verbose: bool,\n-    write_mode: Option<WriteMode>,\n-    file_lines: FileLines, // Default is all lines in all files.\n+    write_mode: Option<String>,\n+    file_lines: Option<String>,\n }\n \n impl CliOptions {\n@@ -73,28 +71,29 @@ impl CliOptions {\n         options.skip_children = matches.opt_present(\"skip-children\");\n         options.verbose = matches.opt_present(\"verbose\");\n \n-        if let Some(ref write_mode) = matches.opt_str(\"write-mode\") {\n-            if let Ok(write_mode) = WriteMode::from_str(write_mode) {\n-                options.write_mode = Some(write_mode);\n-            } else {\n-                return Err(FmtError::from(format!(\"Invalid write-mode: {}\", write_mode)));\n-            }\n+        if let Some(write_mode) = matches.opt_str(\"write-mode\") {\n+            options.write_mode = Some(write_mode);\n         }\n \n-        if let Some(ref file_lines) = matches.opt_str(\"file-lines\") {\n-            options.file_lines = file_lines.parse()?;\n+        if let Some(file_lines) = matches.opt_str(\"file-lines\") {\n+            options.file_lines = Some(file_lines);\n         }\n \n         Ok(options)\n     }\n \n-    fn apply_to(self, config: &mut Config) {\n-        config.skip_children = self.skip_children;\n-        config.verbose = self.verbose;\n-        config.file_lines = self.file_lines;\n-        if let Some(write_mode) = self.write_mode {\n-            config.write_mode = write_mode;\n+    fn apply_to(&self, config: &mut Config) -> FmtResult<()> {\n+        let bool_to_str = |b| if b { \"true\" } else { \"false\" };\n+        config\n+            .override_value(\"skip_children\", bool_to_str(self.skip_children))?;\n+        config.override_value(\"verbose\", bool_to_str(self.verbose))?;\n+        if let Some(ref write_mode) = self.write_mode {\n+            config.override_value(\"write_mode\", &write_mode)?;\n         }\n+        if let Some(ref file_lines) = self.file_lines {\n+            config.override_value(\"file_lines\", &file_lines)?;\n+        }\n+        Ok(())\n     }\n }\n \n@@ -222,12 +221,12 @@ fn execute(opts: &Options) -> FmtResult<Summary> {\n                                                          &env::current_dir().unwrap())?;\n \n             // write_mode is always Plain for Stdin.\n-            config.write_mode = WriteMode::Plain;\n+            config.override_value(\"write_mode\", \"Plain\")?;\n \n             // parse file_lines\n             if let Some(ref file_lines) = matches.opt_str(\"file-lines\") {\n-                config.file_lines = file_lines.parse()?;\n-                for f in config.file_lines.files() {\n+                config.override_value(\"file-lines\", file_lines)?;\n+                for f in config.file_lines().files() {\n                     if f != \"stdin\" {\n                         println!(\"Warning: Extra file listed in file_lines option '{}'\", f);\n                     }\n@@ -239,12 +238,6 @@ fn execute(opts: &Options) -> FmtResult<Summary> {\n         Operation::Format { files, config_path } => {\n             let options = CliOptions::from_matches(&matches)?;\n \n-            for f in options.file_lines.files() {\n-                if !files.contains(&PathBuf::from(f)) {\n-                    println!(\"Warning: Extra file listed in file_lines option '{}'\", f);\n-                }\n-            }\n-\n             let mut config = Config::default();\n             let mut path = None;\n             // Load the config path file if provided\n@@ -253,6 +246,13 @@ fn execute(opts: &Options) -> FmtResult<Summary> {\n                 config = cfg_tmp;\n                 path = path_tmp;\n             };\n+            options.apply_to(&mut config)?;\n+\n+            for f in config.file_lines().files() {\n+                if !files.contains(&PathBuf::from(f)) {\n+                    println!(\"Warning: Extra file listed in file_lines option '{}'\", f);\n+                }\n+            }\n \n             if options.verbose {\n                 if let Some(path) = path.as_ref() {\n@@ -282,7 +282,7 @@ fn execute(opts: &Options) -> FmtResult<Summary> {\n                         config = config_tmp;\n                     }\n \n-                    options.clone().apply_to(&mut config);\n+                    options.apply_to(&mut config)?;\n                     error_summary.add(run(Input::File(file), &config));\n                 }\n             }"}, {"sha": "e8a334bb134cd21a1ca50578651e11f85aff64fc", "filename": "src/chains.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=c0bdbfa5315217741213d04329b02a4fb5e061e7", "patch": "@@ -114,23 +114,23 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     };\n     let (nested_shape, extend) = if !parent_rewrite_contains_newline && is_continuable(&parent) {\n         let nested_shape = if first_subexpr_is_try {\n-            parent_shape.block_indent(context.config.tab_spaces)\n+            parent_shape.block_indent(context.config.tab_spaces())\n         } else {\n             chain_indent(context, shape.add_offset(parent_rewrite.len()))\n         };\n         (nested_shape,\n-         context.config.chain_indent == IndentStyle::Visual ||\n-         parent_rewrite.len() <= context.config.tab_spaces)\n+         context.config.chain_indent() == IndentStyle::Visual ||\n+         parent_rewrite.len() <= context.config.tab_spaces())\n     } else if is_block_expr(&parent, &parent_rewrite) {\n         // The parent is a block, so align the rest of the chain with the closing\n         // brace.\n         (parent_shape, false)\n     } else if parent_rewrite_contains_newline {\n         (chain_indent(context,\n-                      parent_shape.block_indent(context.config.tab_spaces)),\n+                      parent_shape.block_indent(context.config.tab_spaces())),\n          false)\n     } else {\n-        (shape.block_indent(context.config.tab_spaces), false)\n+        (shape.block_indent(context.config.tab_spaces()), false)\n     };\n \n     let max_width = try_opt!((shape.width + shape.indent.width() + shape.offset)\n@@ -143,14 +143,14 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     };\n     let first_child_shape = if extend {\n         let mut shape = try_opt!(parent_shape.offset_left(last_line_width(&parent_rewrite)));\n-        match context.config.chain_indent {\n+        match context.config.chain_indent() {\n             IndentStyle::Visual => shape,\n             IndentStyle::Block => {\n                 shape.offset = shape\n                     .offset\n-                    .checked_sub(context.config.tab_spaces)\n+                    .checked_sub(context.config.tab_spaces())\n                     .unwrap_or(0);\n-                shape.indent.block_indent += context.config.tab_spaces;\n+                shape.indent.block_indent += context.config.tab_spaces();\n                 shape\n             }\n         }\n@@ -176,7 +176,7 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         .fold(0, |a, b| a + first_line_width(b)) + parent_rewrite.len();\n     let one_line_len = rewrites.iter().fold(0, |a, r| a + r.len()) + parent_rewrite.len();\n \n-    let veto_single_line = if one_line_len > context.config.chain_one_line_max {\n+    let veto_single_line = if one_line_len > context.config.chain_one_line_max() {\n         if rewrites.len() > 1 {\n             true\n         } else if rewrites.len() == 1 {\n@@ -185,7 +185,7 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         } else {\n             false\n         }\n-    } else if context.config.take_source_hints && subexpr_list.len() > 1 {\n+    } else if context.config.take_source_hints() && subexpr_list.len() > 1 {\n         // Look at the source code. Unless all chain elements start on the same\n         // line, we won't consider putting them on a single line either.\n         let last_span = context.snippet(mk_sp(subexpr_list[1].span.hi, total_span.hi));\n@@ -214,7 +214,7 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n                                                          shape) {\n                         // If the first line of the last method does not fit into a single line\n                         // after the others, allow new lines.\n-                        almost_total + first_line_width(&last[0]) < context.config.max_width\n+                        almost_total + first_line_width(&last[0]) < context.config.max_width()\n                     } else {\n                         false\n                     }\n@@ -242,7 +242,7 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n                      parent_rewrite,\n                      first_connector,\n                      join_rewrites(&rewrites, &subexpr_list, &connector)),\n-             context.config.max_width,\n+             context.config.max_width(),\n              shape)\n }\n \n@@ -320,9 +320,9 @@ fn make_subexpr_list(expr: &ast::Expr, context: &RewriteContext) -> (ast::Expr,\n }\n \n fn chain_indent(context: &RewriteContext, shape: Shape) -> Shape {\n-    match context.config.chain_indent {\n+    match context.config.chain_indent() {\n         IndentStyle::Visual => shape.visual_indent(0),\n-        IndentStyle::Block => shape.block_indent(context.config.tab_spaces),\n+        IndentStyle::Block => shape.block_indent(context.config.tab_spaces()),\n     }\n }\n \n@@ -372,7 +372,7 @@ fn pop_expr_chain(expr: &ast::Expr, context: &RewriteContext) -> Option<ast::Exp\n \n fn convert_try(expr: &ast::Expr, context: &RewriteContext) -> ast::Expr {\n     match expr.node {\n-        ast::ExprKind::Mac(ref mac) if context.config.use_try_shorthand => {\n+        ast::ExprKind::Mac(ref mac) if context.config.use_try_shorthand() => {\n             if let Some(subexpr) = convert_try_mac(mac, context) {\n                 subexpr\n             } else {\n@@ -428,7 +428,7 @@ fn rewrite_method_call(method_name: ast::Ident,\n         let type_list: Vec<_> =\n             try_opt!(types.iter().map(|ty| ty.rewrite(context, shape)).collect());\n \n-        let type_str = if context.config.spaces_within_angle_brackets && type_list.len() > 0 {\n+        let type_str = if context.config.spaces_within_angle_brackets() && type_list.len() > 0 {\n             format!(\"::< {} >\", type_list.join(\", \"))\n         } else {\n             format!(\"::<{}>\", type_list.join(\", \"))"}, {"sha": "ad52ec67f33432ecd1ec0fd70a4bdec98cc2761b", "filename": "src/comment.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=c0bdbfa5315217741213d04329b02a4fb5e061e7", "patch": "@@ -38,23 +38,23 @@ pub fn rewrite_comment(orig: &str,\n                        config: &Config)\n                        -> Option<String> {\n     // If there are lines without a starting sigil, we won't format them correctly\n-    // so in that case we won't even re-align (if !config.normalize_comments) and\n+    // so in that case we won't even re-align (if !config.normalize_comments()) and\n     // we should stop now.\n     let num_bare_lines = orig.lines()\n         .map(|line| line.trim())\n         .filter(|l| !(l.starts_with('*') || l.starts_with(\"//\") || l.starts_with(\"/*\")))\n         .count();\n-    if num_bare_lines > 0 && !config.normalize_comments {\n+    if num_bare_lines > 0 && !config.normalize_comments() {\n         return Some(orig.to_owned());\n     }\n \n-    if !config.normalize_comments && !config.wrap_comments {\n+    if !config.normalize_comments() && !config.wrap_comments() {\n         return light_rewrite_comment(orig, shape.indent, config);\n     }\n \n     let (opener, closer, line_start) = if block_style {\n         (\"/* \", \" */\", \" * \")\n-    } else if !config.normalize_comments {\n+    } else if !config.normalize_comments() {\n         if orig.starts_with(\"/**\") && !orig.starts_with(\"/**/\") {\n             (\"/** \", \" **/\", \" ** \")\n         } else if orig.starts_with(\"/*!\") {\n@@ -128,7 +128,7 @@ pub fn rewrite_comment(orig: &str,\n             result.push_str(line_start);\n         }\n \n-        if config.wrap_comments && line.len() > max_chars {\n+        if config.wrap_comments() && line.len() > max_chars {\n             let rewrite = rewrite_string(line, &fmt).unwrap_or(line.to_owned());\n             result.push_str(&rewrite);\n         } else {\n@@ -579,7 +579,7 @@ pub fn recover_comment_removed(new: String,\n     if changed_comment_content(&snippet, &new) {\n         // We missed some comments\n         // Keep previous formatting if it satisfies the constrains\n-        wrap_str(snippet, context.config.max_width, shape)\n+        wrap_str(snippet, context.config.max_width(), shape)\n     } else {\n         Some(new)\n     }\n@@ -731,8 +731,10 @@ mod test {\n     #[cfg_attr(rustfmt, rustfmt_skip)]\n     fn format_comments() {\n         let mut config: ::config::Config = Default::default();\n-        config.wrap_comments = true;\n-        config.normalize_comments = true;\n+        config.override_value(\"wrap_comments\", \"true\")\n+            .expect(\"Could not set wrap_comments to true\");\n+        config.override_value(\"normalize_comments\", \"true\")\n+            .expect(\"Could not set normalize_comments to true\");\n \n         let comment = rewrite_comment(\" //test\",\n                                       true,"}, {"sha": "63c33cdf6fc14600947b814e52bdc3712637a1a5", "filename": "src/config.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=c0bdbfa5315217741213d04329b02a4fb5e061e7", "patch": "@@ -10,6 +10,9 @@\n \n extern crate toml;\n \n+use std::error;\n+use std::result;\n+\n use file_lines::FileLines;\n use lists::{SeparatorTactic, ListTactic};\n \n@@ -212,7 +215,7 @@ macro_rules! create_config {\n     ($($i:ident: $ty:ty, $def:expr, $( $dstring:expr ),+ );+ $(;)*) => (\n         #[derive(Deserialize, Clone)]\n         pub struct Config {\n-            $(pub $i: $ty),+\n+            $($i: $ty),+\n         }\n \n         // Just like the Config struct but with each property wrapped\n@@ -227,6 +230,12 @@ macro_rules! create_config {\n \n         impl Config {\n \n+            $(\n+            pub fn $i(&self) -> $ty {\n+                self.$i.clone()\n+            }\n+            )+\n+\n             fn fill_from_parsed_config(mut self, parsed: ParsedConfig) -> Config {\n             $(\n                 if let Some(val) = parsed.$i {\n@@ -270,19 +279,16 @@ macro_rules! create_config {\n                 }\n             }\n \n-            pub fn override_value(&mut self, key: &str, val: &str) {\n+            pub fn override_value(&mut self, key: &str, val: &str)\n+                -> result::Result<(), Box<error::Error + Send + Sync>>\n+            {\n                 match key {\n                     $(\n-                        stringify!($i) => {\n-                            self.$i = val.parse::<$ty>()\n-                                .expect(&format!(\"Failed to parse override for {} (\\\"{}\\\") as a {}\",\n-                                                 stringify!($i),\n-                                                 val,\n-                                                 stringify!($ty)));\n-                        }\n+                        stringify!($i) => self.$i = val.parse::<$ty>()?,\n                     )+\n                     _ => panic!(\"Unknown config key in override: {}\", key)\n                 }\n+                Ok(())\n             }\n \n             pub fn print_docs() {"}, {"sha": "9d1f1093fa924eaccf98ee80b12c079cf4ffe416", "filename": "src/expr.rs", "status": "modified", "additions": 85, "deletions": 68, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=c0bdbfa5315217741213d04329b02a4fb5e061e7", "patch": "@@ -65,7 +65,11 @@ fn format_expr(expr: &ast::Expr,\n                 ast::LitKind::Str(_, ast::StrStyle::Cooked) => {\n                     rewrite_string_lit(context, l.span, shape)\n                 }\n-                _ => wrap_str(context.snippet(expr.span), context.config.max_width, shape),\n+                _ => {\n+                    wrap_str(context.snippet(expr.span),\n+                             context.config.max_width(),\n+                             shape)\n+                }\n             }\n         }\n         ast::ExprKind::Call(ref callee, ref args) => {\n@@ -146,7 +150,7 @@ fn format_expr(expr: &ast::Expr,\n                 None => String::new(),\n             };\n             wrap_str(format!(\"continue{}\", id_str),\n-                     context.config.max_width,\n+                     context.config.max_width(),\n                      shape)\n         }\n         ast::ExprKind::Break(ref opt_ident, ref opt_expr) => {\n@@ -158,7 +162,9 @@ fn format_expr(expr: &ast::Expr,\n             if let Some(ref expr) = *opt_expr {\n                 rewrite_unary_prefix(context, &format!(\"break{} \", id_str), &**expr, shape)\n             } else {\n-                wrap_str(format!(\"break{}\", id_str), context.config.max_width, shape)\n+                wrap_str(format!(\"break{}\", id_str),\n+                         context.config.max_width(),\n+                         shape)\n             }\n         }\n         ast::ExprKind::Closure(capture, ref fn_decl, ref body, _) => {\n@@ -171,10 +177,15 @@ fn format_expr(expr: &ast::Expr,\n         ast::ExprKind::Mac(ref mac) => {\n             // Failure to rewrite a marco should not imply failure to\n             // rewrite the expression.\n-            rewrite_macro(mac, None, context, shape, MacroPosition::Expression)\n-                .or_else(|| wrap_str(context.snippet(expr.span), context.config.max_width, shape))\n+            rewrite_macro(mac, None, context, shape, MacroPosition::Expression).or_else(|| {\n+                wrap_str(context.snippet(expr.span),\n+                         context.config.max_width(),\n+                         shape)\n+            })\n+        }\n+        ast::ExprKind::Ret(None) => {\n+            wrap_str(\"return\".to_owned(), context.config.max_width(), shape)\n         }\n-        ast::ExprKind::Ret(None) => wrap_str(\"return\".to_owned(), context.config.max_width, shape),\n         ast::ExprKind::Ret(Some(ref expr)) => {\n             rewrite_unary_prefix(context, \"return \", &**expr, shape)\n         }\n@@ -192,7 +203,7 @@ fn format_expr(expr: &ast::Expr,\n             rewrite_index(&**expr, &**index, context, shape)\n         }\n         ast::ExprKind::Repeat(ref expr, ref repeats) => {\n-            let (lbr, rbr) = if context.config.spaces_within_square_brackets {\n+            let (lbr, rbr) = if context.config.spaces_within_square_brackets() {\n                 (\"[ \", \" ]\")\n             } else {\n                 (\"[\", \"]\")\n@@ -207,37 +218,39 @@ fn format_expr(expr: &ast::Expr,\n \n             match (lhs.as_ref().map(|x| &**x), rhs.as_ref().map(|x| &**x)) {\n                 (Some(ref lhs), Some(ref rhs)) => {\n-                    let sp_delim = if context.config.spaces_around_ranges {\n+                    let sp_delim = if context.config.spaces_around_ranges() {\n                         format!(\" {} \", delim)\n                     } else {\n                         delim.into()\n                     };\n                     rewrite_pair(&**lhs, &**rhs, \"\", &sp_delim, \"\", context, shape)\n                 }\n                 (None, Some(ref rhs)) => {\n-                    let sp_delim = if context.config.spaces_around_ranges {\n+                    let sp_delim = if context.config.spaces_around_ranges() {\n                         format!(\"{} \", delim)\n                     } else {\n                         delim.into()\n                     };\n                     rewrite_unary_prefix(context, &sp_delim, &**rhs, shape)\n                 }\n                 (Some(ref lhs), None) => {\n-                    let sp_delim = if context.config.spaces_around_ranges {\n+                    let sp_delim = if context.config.spaces_around_ranges() {\n                         format!(\" {}\", delim)\n                     } else {\n                         delim.into()\n                     };\n                     rewrite_unary_suffix(context, &sp_delim, &**lhs, shape)\n                 }\n-                (None, None) => wrap_str(delim.into(), context.config.max_width, shape),\n+                (None, None) => wrap_str(delim.into(), context.config.max_width(), shape),\n             }\n         }\n         // We do not format these expressions yet, but they should still\n         // satisfy our width restrictions.\n         ast::ExprKind::InPlace(..) |\n         ast::ExprKind::InlineAsm(..) => {\n-            wrap_str(context.snippet(expr.span), context.config.max_width, shape)\n+            wrap_str(context.snippet(expr.span),\n+                     context.config.max_width(),\n+                     shape)\n         }\n     };\n     result.and_then(|res| recover_comment_removed(res, expr.span, context, shape))\n@@ -304,14 +317,14 @@ pub fn rewrite_pair<LHS, RHS>(lhs: &LHS,\n     let infix = infix.trim_right();\n     let lhs_budget = try_opt!(context\n                                   .config\n-                                  .max_width\n+                                  .max_width()\n                                   .checked_sub(shape.used_width() + prefix.len() +\n                                                infix.len()));\n-    let rhs_shape = match context.config.control_style {\n+    let rhs_shape = match context.config.control_style() {\n         Style::Default => {\n             try_opt!(shape.sub_width(suffix.len() + prefix.len())).visual_indent(prefix.len())\n         }\n-        Style::Rfc => try_opt!(shape.block_left(context.config.tab_spaces)),\n+        Style::Rfc => try_opt!(shape.block_left(context.config.tab_spaces())),\n     };\n \n     let rhs_result = try_opt!(rhs.rewrite(context, rhs_shape));\n@@ -336,14 +349,14 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n                             -> Option<String>\n     where I: Iterator<Item = &'a ast::Expr>\n {\n-    let bracket_size = if context.config.spaces_within_square_brackets {\n+    let bracket_size = if context.config.spaces_within_square_brackets() {\n         2 // \"[ \"\n     } else {\n         1 // \"[\"\n     };\n \n-    let nested_shape = match context.config.array_layout {\n-        IndentStyle::Block => shape.block().block_indent(context.config.tab_spaces),\n+    let nested_shape = match context.config.array_layout() {\n+        IndentStyle::Block => shape.block().block_indent(context.config.tab_spaces()),\n         IndentStyle::Visual => {\n             try_opt!(shape\n                          .visual_indent(bracket_size)\n@@ -362,7 +375,7 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n             .collect::<Vec<_>>();\n \n     if items.is_empty() {\n-        if context.config.spaces_within_square_brackets {\n+        if context.config.spaces_within_square_brackets() {\n             return Some(\"[ ]\".to_string());\n         } else {\n             return Some(\"[]\".to_string());\n@@ -375,12 +388,13 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n                                      .fold(Some(false),\n                                            |acc, x| acc.and_then(|y| x.map(|x| x || y))));\n \n-    let tactic = match context.config.array_layout {\n+    let tactic = match context.config.array_layout() {\n         IndentStyle::Block => {\n             // FIXME wrong shape in one-line case\n             match shape.width.checked_sub(2 * bracket_size) {\n                 Some(width) => {\n-                    let tactic = ListTactic::LimitedHorizontalVertical(context.config.array_width);\n+                    let tactic =\n+                        ListTactic::LimitedHorizontalVertical(context.config.array_width());\n                     definitive_tactic(&items, tactic, width)\n                 }\n                 None => DefinitiveListTactic::Vertical,\n@@ -389,7 +403,9 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n         IndentStyle::Visual => {\n             if has_long_item || items.iter().any(ListItem::is_multiline) {\n                 definitive_tactic(&items,\n-                                  ListTactic::LimitedHorizontalVertical(context.config.array_width),\n+                                  ListTactic::LimitedHorizontalVertical(context\n+                                                                            .config\n+                                                                            .array_width()),\n                                   nested_shape.width)\n             } else {\n                 DefinitiveListTactic::Mixed\n@@ -407,9 +423,9 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n     };\n     let list_str = try_opt!(write_list(&items, &fmt));\n \n-    let result = if context.config.array_layout == IndentStyle::Visual ||\n+    let result = if context.config.array_layout() == IndentStyle::Visual ||\n                     tactic != DefinitiveListTactic::Vertical {\n-        if context.config.spaces_within_square_brackets && list_str.len() > 0 {\n+        if context.config.spaces_within_square_brackets() && list_str.len() > 0 {\n             format!(\"[ {} ]\", list_str)\n         } else {\n             format!(\"[{}]\", list_str)\n@@ -574,7 +590,7 @@ fn rewrite_closure(capture: ast::CaptureBy,\n         // Start with visual indent, then fall back to block indent if the\n         // closure is large.\n         if let Some(block_str) = block.rewrite(&context, shape) {\n-            let block_threshold = context.config.closure_block_indent_threshold;\n+            let block_threshold = context.config.closure_block_indent_threshold();\n             if block_threshold < 0 || block_str.matches('\\n').count() <= block_threshold as usize {\n                 if let Some(block_str) = block_str.rewrite(context, shape) {\n                     return Some(format!(\"{} {}\", prefix, block_str));\n@@ -878,11 +894,11 @@ impl<'a> Rewrite for ControlFlow<'a> {\n \n         let pat_expr_string = match self.cond {\n             Some(cond) => {\n-                let mut cond_shape = match context.config.control_style {\n+                let mut cond_shape = match context.config.control_style() {\n                     Style::Default => try_opt!(constr_shape.shrink_left(add_offset)),\n                     Style::Rfc => constr_shape,\n                 };\n-                if context.config.control_brace_style != ControlBraceStyle::AlwaysNextLine {\n+                if context.config.control_brace_style() != ControlBraceStyle::AlwaysNextLine {\n                     // 2 = \" {\".len()\n                     cond_shape = try_opt!(cond_shape.sub_width(2));\n                 }\n@@ -897,15 +913,15 @@ impl<'a> Rewrite for ControlFlow<'a> {\n             None => String::new(),\n         };\n \n-        let force_newline_brace = context.config.control_style == Style::Rfc &&\n+        let force_newline_brace = context.config.control_style() == Style::Rfc &&\n                                   pat_expr_string.contains('\\n');\n \n         // Try to format if-else on single line.\n-        if self.allow_single_line && context.config.single_line_if_else_max_width > 0 {\n+        if self.allow_single_line && context.config.single_line_if_else_max_width() > 0 {\n             let trial = self.rewrite_single_line(&pat_expr_string, context, shape.width);\n \n             if trial.is_some() &&\n-               trial.as_ref().unwrap().len() <= context.config.single_line_if_else_max_width {\n+               trial.as_ref().unwrap().len() <= context.config.single_line_if_else_max_width() {\n                 return trial;\n             }\n         }\n@@ -957,7 +973,7 @@ impl<'a> Rewrite for ControlFlow<'a> {\n                             &shape.indent.block_only().to_string(context.config);\n         let block_sep = if self.cond.is_none() && between_kwd_cond_comment.is_some() {\n             \"\"\n-        } else if context.config.control_brace_style == ControlBraceStyle::AlwaysNextLine ||\n+        } else if context.config.control_brace_style() == ControlBraceStyle::AlwaysNextLine ||\n                   force_newline_brace {\n             alt_block_sep.as_str()\n         } else {\n@@ -1035,12 +1051,12 @@ impl<'a> Rewrite for ControlFlow<'a> {\n                       else_block.span.lo);\n             let after_else_comment = extract_comment(after_else, context, shape);\n \n-            let between_sep = match context.config.control_brace_style {\n+            let between_sep = match context.config.control_brace_style() {\n                 ControlBraceStyle::AlwaysNextLine |\n                 ControlBraceStyle::ClosingNextLine => &*alt_block_sep,\n                 ControlBraceStyle::AlwaysSameLine => \" \",\n             };\n-            let after_sep = match context.config.control_brace_style {\n+            let after_sep = match context.config.control_brace_style() {\n                 ControlBraceStyle::AlwaysNextLine if last_in_chain => &*alt_block_sep,\n                 _ => \" \",\n             };\n@@ -1169,14 +1185,14 @@ fn rewrite_match(context: &RewriteContext,\n     let cond_shape = try_opt!(cond_shape.sub_width(2));\n     let cond_str = try_opt!(cond.rewrite(context, cond_shape));\n     let alt_block_sep = String::from(\"\\n\") + &shape.indent.block_only().to_string(context.config);\n-    let block_sep = match context.config.control_brace_style {\n+    let block_sep = match context.config.control_brace_style() {\n         ControlBraceStyle::AlwaysSameLine => \" \",\n         _ => alt_block_sep.as_str(),\n     };\n     let mut result = format!(\"match {}{}{{\", cond_str, block_sep);\n \n-    let arm_shape = if context.config.indent_match_arms {\n-        shape.block_indent(context.config.tab_spaces)\n+    let arm_shape = if context.config.indent_match_arms() {\n+        shape.block_indent(context.config.tab_spaces())\n     } else {\n         shape.block_indent(0)\n     };\n@@ -1240,7 +1256,7 @@ fn arm_end_pos(arm: &ast::Arm) -> BytePos {\n }\n \n fn arm_comma(config: &Config, body: &ast::Expr) -> &'static str {\n-    if config.match_block_trailing_comma {\n+    if config.match_block_trailing_comma() {\n         \",\"\n     } else if let ast::ExprKind::Block(ref block) = body.node {\n         if let ast::BlockCheckMode::Default = block.rules {\n@@ -1322,7 +1338,7 @@ impl Rewrite for ast::Arm {\n         let body = match body.node {\n             ast::ExprKind::Block(ref block) if !is_unsafe_block(block) &&\n                                                is_simple_block(block, context.codemap) &&\n-                                               context.config.wrap_match_arms => {\n+                                               context.config.wrap_match_arms() => {\n                 if let ast::StmtKind::Expr(ref expr) = block.stmts[0].node {\n                     expr\n                 } else {\n@@ -1355,9 +1371,9 @@ impl Rewrite for ast::Arm {\n             match rewrite {\n                 Some(ref body_str) if (!body_str.contains('\\n') &&\n                                        body_str.len() <= arm_shape.width) ||\n-                                      !context.config.wrap_match_arms ||\n+                                      !context.config.wrap_match_arms() ||\n                                       is_block => {\n-                    let block_sep = match context.config.control_brace_style {\n+                    let block_sep = match context.config.control_brace_style() {\n                         ControlBraceStyle::AlwaysNextLine if is_block => alt_block_sep.as_str(),\n                         _ => \" \",\n                     };\n@@ -1375,16 +1391,16 @@ impl Rewrite for ast::Arm {\n \n         // FIXME: we're doing a second rewrite of the expr; This may not be\n         // necessary.\n-        let body_shape = try_opt!(shape.sub_width(context.config.tab_spaces))\n-            .block_indent(context.config.tab_spaces);\n+        let body_shape = try_opt!(shape.sub_width(context.config.tab_spaces()))\n+            .block_indent(context.config.tab_spaces());\n         let next_line_body = try_opt!(nop_block_collapse(body.rewrite(context, body_shape),\n                                                          body_shape.width));\n         let indent_str = shape\n             .indent\n             .block_indent(context.config)\n             .to_string(context.config);\n-        let (body_prefix, body_suffix) = if context.config.wrap_match_arms {\n-            if context.config.match_block_trailing_comma {\n+        let (body_prefix, body_suffix) = if context.config.wrap_match_arms() {\n+            if context.config.match_block_trailing_comma() {\n                 (\"{\", \"},\")\n             } else {\n                 (\"{\", \"}\")\n@@ -1394,13 +1410,13 @@ impl Rewrite for ast::Arm {\n         };\n \n \n-        let block_sep = match context.config.control_brace_style {\n+        let block_sep = match context.config.control_brace_style() {\n             ControlBraceStyle::AlwaysNextLine => alt_block_sep + body_prefix + \"\\n\",\n             _ if body_prefix.is_empty() => \"\\n\".to_owned(),\n             _ => \" \".to_owned() + body_prefix + \"\\n\",\n         };\n \n-        if context.config.wrap_match_arms {\n+        if context.config.wrap_match_arms() {\n             Some(format!(\"{}{} =>{}{}{}\\n{}{}\",\n                          attr_str.trim_left(),\n                          pats_str,\n@@ -1536,11 +1552,11 @@ fn rewrite_pat_expr(context: &RewriteContext,\n fn rewrite_string_lit(context: &RewriteContext, span: Span, shape: Shape) -> Option<String> {\n     let string_lit = context.snippet(span);\n \n-    if !context.config.format_strings && !context.config.force_format_strings {\n+    if !context.config.format_strings() && !context.config.force_format_strings() {\n         return Some(string_lit);\n     }\n \n-    if !context.config.force_format_strings &&\n+    if !context.config.force_format_strings() &&\n        !string_requires_rewrite(context, span, &string_lit, shape) {\n         return Some(string_lit);\n     }\n@@ -1621,7 +1637,7 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n         .ok_or(Ordering::Greater)?;\n \n     // 4 = `(  )`, 2 = `()`\n-    let paren_overhead = if context.config.spaces_within_parens {\n+    let paren_overhead = if context.config.spaces_within_parens() {\n         4\n     } else {\n         2\n@@ -1632,8 +1648,8 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n         .checked_sub(used_width + paren_overhead)\n         .ok_or(Ordering::Greater)?;\n \n-    let nested_shape = match context.config.fn_call_style {\n-            IndentStyle::Block => shape.block().block_left(context.config.tab_spaces),\n+    let nested_shape = match context.config.fn_call_style() {\n+            IndentStyle::Block => shape.block().block_left(context.config.tab_spaces()),\n             // 1 = (\n             IndentStyle::Visual => {\n                 shape\n@@ -1649,9 +1665,9 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n     let list_str = rewrite_call_args(context, args, span, nested_shape, one_line_width)\n         .ok_or(Ordering::Less)?;\n \n-    let result = if context.config.fn_call_style == IndentStyle::Visual ||\n+    let result = if context.config.fn_call_style() == IndentStyle::Visual ||\n                     (!list_str.contains('\\n') && list_str.chars().last().unwrap_or(' ') != ',') {\n-        if context.config.spaces_within_parens && list_str.len() > 0 {\n+        if context.config.spaces_within_parens() && list_str.len() > 0 {\n             format!(\"{}( {} )\", callee_str, list_str)\n         } else {\n             format!(\"{}({})\", callee_str, list_str)\n@@ -1723,7 +1739,7 @@ fn rewrite_call_args(context: &RewriteContext,\n \n     let tactic =\n         definitive_tactic(&item_vec,\n-                          ListTactic::LimitedHorizontalVertical(context.config.fn_call_width),\n+                          ListTactic::LimitedHorizontalVertical(context.config.fn_call_width()),\n                           one_line_width);\n \n     // Replace the stub with the full overflowing last argument if the rewrite\n@@ -1742,11 +1758,11 @@ fn rewrite_call_args(context: &RewriteContext,\n         tactic: tactic,\n         separator: \",\",\n         trailing_separator: if context.inside_macro ||\n-                               context.config.fn_call_style == IndentStyle::Visual ||\n+                               context.config.fn_call_style() == IndentStyle::Visual ||\n                                arg_count <= 1 {\n             SeparatorTactic::Never\n         } else {\n-            context.config.trailing_comma\n+            context.config.trailing_comma()\n         },\n         shape: one_line_shape,\n         ends_with_newline: false,\n@@ -1757,10 +1773,10 @@ fn rewrite_call_args(context: &RewriteContext,\n         // If arguments do not fit in a single line and do not contain newline,\n         // try to put it on the next line. Try this only when we are in block mode\n         // and not rewriting macro.\n-        Some(ref s) if context.config.fn_call_style == IndentStyle::Block &&\n+        Some(ref s) if context.config.fn_call_style() == IndentStyle::Block &&\n                        !context.inside_macro &&\n                        (!s.contains('\\n') &&\n-                        (s.len() > one_line_width || s.len() > context.config.fn_call_width)) => {\n+                        (s.len() > one_line_width || s.len() > context.config.fn_call_width())) => {\n             fmt.trailing_separator = SeparatorTactic::Vertical;\n             write_list(&item_vec, &fmt)\n         }\n@@ -1776,7 +1792,7 @@ fn rewrite_paren(context: &RewriteContext, subexpr: &ast::Expr, shape: Shape) ->\n     let subexpr_str = subexpr.rewrite(context, sub_shape);\n     debug!(\"rewrite_paren, subexpr_str: `{:?}`\", subexpr_str);\n \n-    subexpr_str.map(|s| if context.config.spaces_within_parens && s.len() > 0 {\n+    subexpr_str.map(|s| if context.config.spaces_within_parens() && s.len() > 0 {\n                         format!(\"( {} )\", s)\n                     } else {\n                         format!(\"({})\", s)\n@@ -1790,7 +1806,7 @@ fn rewrite_index(expr: &ast::Expr,\n                  -> Option<String> {\n     let expr_str = try_opt!(expr.rewrite(context, shape));\n \n-    let (lbr, rbr) = if context.config.spaces_within_square_brackets {\n+    let (lbr, rbr) = if context.config.spaces_within_square_brackets() {\n         (\"[ \", \" ]\")\n     } else {\n         (\"[\", \"]\")\n@@ -1811,7 +1827,7 @@ fn rewrite_index(expr: &ast::Expr,\n     // might be reduced from max_width by something on the right.\n     let budget = try_opt!(context\n                               .config\n-                              .max_width\n+                              .max_width()\n                               .checked_sub(indent.len() + lbr.len() + rbr.len()));\n     let index_str = try_opt!(index.rewrite(context, Shape::legacy(budget, shape.indent)));\n     Some(format!(\"{}\\n{}{}{}{}\", expr_str, indent, lbr, index_str, rbr))\n@@ -1887,9 +1903,10 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n     let fmt = struct_lit_formatting(nested_shape, tactic, context, base.is_some());\n \n     let fields_str = try_opt!(write_list(&item_vec, &fmt));\n-    let fields_str = if context.config.struct_lit_style == IndentStyle::Block &&\n+    let fields_str = if context.config.struct_lit_style() == IndentStyle::Block &&\n                         (fields_str.contains('\\n') ||\n-                         context.config.struct_lit_multiline_style == MultilineStyle::ForceMulti ||\n+                         context.config.struct_lit_multiline_style() ==\n+                         MultilineStyle::ForceMulti ||\n                          fields_str.len() > h_shape.map(|s| s.width).unwrap_or(0)) {\n         format!(\"\\n{}{}\\n{}\",\n                 v_shape.indent.to_string(context.config),\n@@ -1902,13 +1919,13 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n \n     Some(format!(\"{} {{{}}}\", path_str, fields_str))\n \n-    // FIXME if context.config.struct_lit_style == Visual, but we run out\n+    // FIXME if context.config.struct_lit_style() == Visual, but we run out\n     // of space, we should fall back to BlockIndent.\n }\n \n pub fn type_annotation_separator(config: &Config) -> &str {\n-    colon_spaces(config.space_before_type_annotation,\n-                 config.space_after_type_annotation_colon)\n+    colon_spaces(config.space_before_type_annotation(),\n+                 config.space_after_type_annotation_colon())\n }\n \n fn rewrite_field(context: &RewriteContext, field: &ast::Field, shape: Shape) -> Option<String> {\n@@ -1964,7 +1981,7 @@ pub fn rewrite_tuple<'a, I>(context: &RewriteContext,\n             .next()\n             .unwrap()\n             .rewrite(context, nested_shape)\n-            .map(|s| if context.config.spaces_within_parens {\n+            .map(|s| if context.config.spaces_within_parens() {\n                      format!(\"( {}, )\", s)\n                  } else {\n                      format!(\"({},)\", s)\n@@ -1983,7 +2000,7 @@ pub fn rewrite_tuple<'a, I>(context: &RewriteContext,\n                              span.hi - BytePos(1));\n     let list_str = try_opt!(format_item_list(items, nested_shape, context.config));\n \n-    if context.config.spaces_within_parens && list_str.len() > 0 {\n+    if context.config.spaces_within_parens() && list_str.len() > 0 {\n         Some(format!(\"( {} )\", list_str))\n     } else {\n         Some(format!(\"({})\", list_str))"}, {"sha": "d1486e94e39b77cb15daa7fd8d4f12c5f19482be", "filename": "src/filemap.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Ffilemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Ffilemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffilemap.rs?ref=c0bdbfa5315217741213d04329b02a4fb5e061e7", "patch": "@@ -33,11 +33,11 @@ pub fn append_newline(s: &mut StringBuffer) {\n pub fn write_all_files<T>(file_map: &FileMap, out: &mut T, config: &Config) -> Result<(), io::Error>\n     where T: Write\n {\n-    output_header(out, config.write_mode).ok();\n+    output_header(out, config.write_mode()).ok();\n     for &(ref filename, ref text) in file_map {\n         write_file(text, filename, out, config)?;\n     }\n-    output_footer(out, config.write_mode).ok();\n+    output_footer(out, config.write_mode()).ok();\n \n     Ok(())\n }\n@@ -52,14 +52,14 @@ pub fn write_system_newlines<T>(writer: T,\n     // Buffer output, since we're writing a since char at a time.\n     let mut writer = BufWriter::new(writer);\n \n-    let style = if config.newline_style == NewlineStyle::Native {\n+    let style = if config.newline_style() == NewlineStyle::Native {\n         if cfg!(windows) {\n             NewlineStyle::Windows\n         } else {\n             NewlineStyle::Unix\n         }\n     } else {\n-        config.newline_style\n+        config.newline_style()\n     };\n \n     match style {\n@@ -107,7 +107,7 @@ pub fn write_file<T>(text: &StringBuffer,\n         Ok(make_diff(&ori, &fmt, 3))\n     }\n \n-    match config.write_mode {\n+    match config.write_mode() {\n         WriteMode::Replace => {\n             if let Ok((ori, fmt)) = source_and_formatted_text(text, filename, config) {\n                 if fmt != ori {"}, {"sha": "46ce14f47b73942904d943fb0c34d37f980815c0", "filename": "src/imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=c0bdbfa5315217741213d04329b02a4fb5e061e7", "patch": "@@ -238,7 +238,7 @@ impl<'a> FmtVisitor<'a> {\n         offset.alignment += vis.len() + \"use \".len();\n         // 1 = \";\"\n         match vp.rewrite(&self.get_context(),\n-                         Shape::legacy(self.config.max_width - offset.width() - 1, offset)) {\n+                         Shape::legacy(self.config.max_width() - offset.width() - 1, offset)) {\n             Some(ref s) if s.is_empty() => {\n                 // Format up to last newline\n                 let prev_span = codemap::mk_sp(self.last_pos, source!(self, span).lo);\n@@ -339,7 +339,7 @@ pub fn rewrite_use_list(shape: Shape,\n     let has_self = move_self_to_front(&mut items);\n     let first_index = if has_self { 0 } else { 1 };\n \n-    if context.config.reorder_imported_names {\n+    if context.config.reorder_imported_names() {\n         items[1..].sort_by(|a, b| a.item.cmp(&b.item));\n     }\n "}, {"sha": "5fa7a05a14276d4cd0d08e0e5b30d806769cb1fc", "filename": "src/items.rs", "status": "modified", "additions": 119, "deletions": 115, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=c0bdbfa5315217741213d04329b02a4fb5e061e7", "patch": "@@ -94,7 +94,7 @@ struct Item<'a> {\n \n impl<'a> Item<'a> {\n     fn from_foreign_mod(fm: &'a ast::ForeignMod, span: Span, config: &Config) -> Item<'a> {\n-        let abi = if fm.abi == abi::Abi::C && !config.force_explicit_abi {\n+        let abi = if fm.abi == abi::Abi::C && !config.force_explicit_abi() {\n             \"extern\".into()\n         } else {\n             format!(\"extern {}\", fm.abi)\n@@ -243,7 +243,7 @@ impl<'a> FmtVisitor<'a> {\n \n         let block_snippet = self.snippet(codemap::mk_sp(block.span.lo, block.span.hi));\n         let has_body = !block_snippet[1..block_snippet.len() - 1].trim().is_empty() ||\n-                       !context.config.fn_empty_single_line;\n+                       !context.config.fn_empty_single_line();\n \n         let (mut result, force_newline_brace) = try_opt!(rewrite_fn_base(&context,\n                                                                          indent,\n@@ -260,7 +260,7 @@ impl<'a> FmtVisitor<'a> {\n                                                                          has_body,\n                                                                          true));\n \n-        if self.config.fn_brace_style != BraceStyle::AlwaysNextLine && !result.contains('\\n') {\n+        if self.config.fn_brace_style() != BraceStyle::AlwaysNextLine && !result.contains('\\n') {\n             newline_brace = false;\n         } else if force_newline_brace {\n             newline_brace = true;\n@@ -319,12 +319,12 @@ impl<'a> FmtVisitor<'a> {\n \n         let codemap = self.get_context().codemap;\n \n-        if self.config.fn_empty_single_line && is_empty_block(block, codemap) &&\n-           self.block_indent.width() + fn_str.len() + 2 <= self.config.max_width {\n+        if self.config.fn_empty_single_line() && is_empty_block(block, codemap) &&\n+           self.block_indent.width() + fn_str.len() + 2 <= self.config.max_width() {\n             return Some(format!(\"{}{{}}\", fn_str));\n         }\n \n-        if self.config.fn_single_line && is_simple_block_stmt(block, codemap) {\n+        if self.config.fn_single_line() && is_simple_block_stmt(block, codemap) {\n             let rewrite = {\n                 if let Some(ref stmt) = block.stmts.first() {\n                     match stmt_expr(stmt) {\n@@ -348,7 +348,7 @@ impl<'a> FmtVisitor<'a> {\n \n             if let Some(res) = rewrite {\n                 let width = self.block_indent.width() + fn_str.len() + res.len() + 4;\n-                if !res.contains('\\n') && width <= self.config.max_width {\n+                if !res.contains('\\n') && width <= self.config.max_width() {\n                     return Some(format!(\"{}{{ {} }}\", fn_str, res));\n                 }\n             }\n@@ -372,7 +372,7 @@ impl<'a> FmtVisitor<'a> {\n                                            generics,\n                                            \"{\",\n                                            \"{\",\n-                                           self.config.item_brace_style,\n+                                           self.config.item_brace_style(),\n                                            enum_def.variants.is_empty(),\n                                            self.block_indent,\n                                            mk_sp(span.lo, body_start))\n@@ -436,7 +436,7 @@ impl<'a> FmtVisitor<'a> {\n         let fmt = ListFormatting {\n             tactic: DefinitiveListTactic::Vertical,\n             separator: \",\",\n-            trailing_separator: self.config.trailing_comma,\n+            trailing_separator: self.config.trailing_comma(),\n             shape: shape,\n             ends_with_newline: true,\n             config: self.config,\n@@ -480,7 +480,7 @@ impl<'a> FmtVisitor<'a> {\n                               None,\n                               field.span,\n                               indent,\n-                              Some(self.config.struct_variant_width))\n+                              Some(self.config.struct_variant_width()))\n             }\n             ast::VariantData::Unit(..) => {\n                 let tag = if let Some(ref expr) = field.node.disr_expr {\n@@ -490,7 +490,7 @@ impl<'a> FmtVisitor<'a> {\n                 };\n \n                 wrap_str(tag,\n-                         self.config.max_width,\n+                         self.config.max_width(),\n                          Shape::indented(indent, self.config))\n             }\n         };\n@@ -520,14 +520,14 @@ pub fn format_impl(context: &RewriteContext, item: &ast::Item, offset: Indent) -\n \n         let where_budget = try_opt!(context\n                                         .config\n-                                        .max_width\n+                                        .max_width()\n                                         .checked_sub(last_line_width(&result)));\n         let where_clause_str = try_opt!(rewrite_where_clause(context,\n                                                              &generics.where_clause,\n-                                                             context.config.item_brace_style,\n+                                                             context.config.item_brace_style(),\n                                                              Shape::legacy(where_budget,\n                                                                            offset.block_only()),\n-                                                             context.config.where_density,\n+                                                             context.config.where_density(),\n                                                              \"{\",\n                                                              false,\n                                                              last_line_width(&ref_and_type) == 1,\n@@ -546,13 +546,13 @@ pub fn format_impl(context: &RewriteContext, item: &ast::Item, offset: Indent) -\n \n         if !where_clause_str.is_empty() && !where_clause_str.contains('\\n') {\n             result.push('\\n');\n-            let width = offset.block_indent + context.config.tab_spaces - 1;\n+            let width = offset.block_indent + context.config.tab_spaces() - 1;\n             let where_indent = Indent::new(0, width);\n             result.push_str(&where_indent.to_string(context.config));\n         }\n         result.push_str(&where_clause_str);\n \n-        match context.config.item_brace_style {\n+        match context.config.item_brace_style() {\n             BraceStyle::AlwaysNextLine => {\n                 result.push('\\n');\n                 result.push_str(&offset.to_string(context.config));\n@@ -615,8 +615,8 @@ fn is_impl_single_line(context: &RewriteContext,\n     let snippet = context.snippet(item.span);\n     let open_pos = try_opt!(snippet.find_uncommented(\"{\")) + 1;\n \n-    Some(context.config.impl_empty_single_line && items.is_empty() &&\n-         result.len() + where_clause_str.len() <= context.config.max_width &&\n+    Some(context.config.impl_empty_single_line() && items.is_empty() &&\n+         result.len() + where_clause_str.len() <= context.config.max_width() &&\n          !contains_comment(&snippet[open_pos..]))\n }\n \n@@ -651,15 +651,15 @@ fn format_impl_ref_and_type(context: &RewriteContext,\n                 result.push_str(\" \");\n             }\n             let used_space = last_line_width(&result);\n-            let budget = try_opt!(context.config.max_width.checked_sub(used_space));\n+            let budget = try_opt!(context.config.max_width().checked_sub(used_space));\n             let indent = offset + used_space;\n             result.push_str(&*try_opt!(trait_ref.rewrite(context, Shape::legacy(budget, indent))));\n \n             if split_at_for {\n                 result.push('\\n');\n \n                 // Add indentation of one additional tab.\n-                let width = offset.block_indent + context.config.tab_spaces;\n+                let width = offset.block_indent + context.config.tab_spaces();\n                 let for_indent = Indent::new(0, width);\n                 result.push_str(&for_indent.to_string(context.config));\n \n@@ -673,15 +673,15 @@ fn format_impl_ref_and_type(context: &RewriteContext,\n         if generics.where_clause.predicates.is_empty() {\n             // If there is no where clause adapt budget for type formatting to take space and curly\n             // brace into account.\n-            match context.config.item_brace_style {\n+            match context.config.item_brace_style() {\n                 BraceStyle::AlwaysNextLine => {}\n                 BraceStyle::PreferSameLine => used_space += 2,\n                 BraceStyle::SameLineWhere => used_space += 2,\n             }\n         }\n \n         // 1 = space before the type.\n-        let budget = try_opt!(context.config.max_width.checked_sub(used_space + 1));\n+        let budget = try_opt!(context.config.max_width().checked_sub(used_space + 1));\n         let indent = offset + result.len() + 1;\n         let self_ty_str = self_ty.rewrite(context, Shape::legacy(budget, indent));\n         if let Some(self_ty_str) = self_ty_str {\n@@ -759,11 +759,11 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n         let trait_bound_str =\n             try_opt!(rewrite_trait_bounds(context,\n                                           type_param_bounds,\n-                                          Shape::legacy(context.config.max_width, offset)));\n+                                          Shape::legacy(context.config.max_width(), offset)));\n         // If the trait, generics, and trait bound cannot fit on the same line,\n         // put the trait bounds on an indented new line\n         if offset.width() + last_line_width(&result) + trait_bound_str.len() >\n-           context.config.comment_width {\n+           context.config.comment_width() {\n             result.push('\\n');\n             let trait_indent = offset.block_only().block_indent(context.config);\n             result.push_str(&trait_indent.to_string(context.config));\n@@ -773,10 +773,11 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n         let has_body = !trait_items.is_empty();\n \n         let where_density =\n-            if (context.config.where_density == Density::Compressed &&\n-                (!result.contains('\\n') || context.config.fn_args_layout == IndentStyle::Block)) ||\n-               (context.config.fn_args_layout == IndentStyle::Block && result.is_empty()) ||\n-               (context.config.where_density == Density::CompressedIfEmpty && !has_body &&\n+            if (context.config.where_density() == Density::Compressed &&\n+                (!result.contains('\\n') ||\n+                 context.config.fn_args_layout() == IndentStyle::Block)) ||\n+               (context.config.fn_args_layout() == IndentStyle::Block && result.is_empty()) ||\n+               (context.config.where_density() == Density::CompressedIfEmpty && !has_body &&\n                 !result.contains('\\n')) {\n                 Density::Compressed\n             } else {\n@@ -785,11 +786,11 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n \n         let where_budget = try_opt!(context\n                                         .config\n-                                        .max_width\n+                                        .max_width()\n                                         .checked_sub(last_line_width(&result)));\n         let where_clause_str = try_opt!(rewrite_where_clause(context,\n                                                              &generics.where_clause,\n-                                                             context.config.item_brace_style,\n+                                                             context.config.item_brace_style(),\n                                                              Shape::legacy(where_budget,\n                                                                            offset.block_only()),\n                                                              where_density,\n@@ -802,15 +803,15 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n         // put the where clause on a new line\n         if !where_clause_str.contains('\\n') &&\n            last_line_width(&result) + where_clause_str.len() + offset.width() >\n-           context.config.comment_width {\n+           context.config.comment_width() {\n             result.push('\\n');\n-            let width = offset.block_indent + context.config.tab_spaces - 1;\n+            let width = offset.block_indent + context.config.tab_spaces() - 1;\n             let where_indent = Indent::new(0, width);\n             result.push_str(&where_indent.to_string(context.config));\n         }\n         result.push_str(&where_clause_str);\n \n-        match context.config.item_brace_style {\n+        match context.config.item_brace_style() {\n             BraceStyle::AlwaysNextLine => {\n                 result.push('\\n');\n                 result.push_str(&offset.to_string(context.config));\n@@ -888,13 +889,14 @@ fn format_struct_struct(context: &RewriteContext,\n                                      g,\n                                      \"{\",\n                                      \"{\",\n-                                     context.config.item_brace_style,\n+                                     context.config.item_brace_style(),\n                                      fields.is_empty(),\n                                      offset,\n                                      mk_sp(span.lo, body_lo)))\n         }\n         None => {\n-            if context.config.item_brace_style == BraceStyle::AlwaysNextLine && !fields.is_empty() {\n+            if context.config.item_brace_style() == BraceStyle::AlwaysNextLine &&\n+               !fields.is_empty() {\n                 format!(\"\\n{}{{\", offset.block_only().to_string(context.config))\n             } else {\n                 \" {\".to_owned()\n@@ -923,7 +925,7 @@ fn format_struct_struct(context: &RewriteContext,\n     // 1 = \",\"\n     let item_budget = try_opt!(context\n                                    .config\n-                                   .max_width\n+                                   .max_width()\n                                    .checked_sub(item_indent.width() + 1));\n \n     let items =\n@@ -944,7 +946,7 @@ fn format_struct_struct(context: &RewriteContext,\n                      span.hi)\n                 .collect::<Vec<_>>();\n     // 1 = ,\n-    let budget = context.config.max_width - offset.width() + context.config.tab_spaces - 1;\n+    let budget = context.config.max_width() - offset.width() + context.config.tab_spaces() - 1;\n \n     let tactic = match one_line_width {\n         Some(w) => definitive_tactic(&items, ListTactic::LimitedHorizontalVertical(w), budget),\n@@ -954,7 +956,7 @@ fn format_struct_struct(context: &RewriteContext,\n     let fmt = ListFormatting {\n         tactic: tactic,\n         separator: \",\",\n-        trailing_separator: context.config.trailing_comma,\n+        trailing_separator: context.config.trailing_comma(),\n         shape: Shape::legacy(budget, item_indent),\n         ends_with_newline: true,\n         config: context.config,\n@@ -1003,11 +1005,11 @@ fn format_tuple_struct(context: &RewriteContext,\n \n             let where_budget = try_opt!(context\n                                             .config\n-                                            .max_width\n+                                            .max_width()\n                                             .checked_sub(last_line_width(&result)));\n             try_opt!(rewrite_where_clause(context,\n                                           &generics.where_clause,\n-                                          context.config.item_brace_style,\n+                                          context.config.item_brace_style(),\n                                           Shape::legacy(where_budget, offset.block_only()),\n                                           Density::Compressed,\n                                           \";\",\n@@ -1032,7 +1034,7 @@ fn format_tuple_struct(context: &RewriteContext,\n         }\n         result.push(')');\n     } else {\n-        let (tactic, item_indent) = match context.config.fn_args_layout {\n+        let (tactic, item_indent) = match context.config.fn_args_layout() {\n             IndentStyle::Visual => {\n                 // 1 = `(`\n                 (ListTactic::HorizontalVertical, offset.block_only() + result.len() + 1)\n@@ -1044,7 +1046,7 @@ fn format_tuple_struct(context: &RewriteContext,\n         // 3 = `();`\n         let item_budget = try_opt!(context\n                                        .config\n-                                       .max_width\n+                                       .max_width()\n                                        .checked_sub(item_indent.width() + 3));\n \n         let items =\n@@ -1065,7 +1067,7 @@ fn format_tuple_struct(context: &RewriteContext,\n                          span.hi);\n         let body_budget = try_opt!(context\n                                        .config\n-                                       .max_width\n+                                       .max_width()\n                                        .checked_sub(offset.block_only().width() + result.len() +\n                                                     3));\n         let body = try_opt!(list_helper(items,\n@@ -1074,15 +1076,15 @@ fn format_tuple_struct(context: &RewriteContext,\n                                         context.config,\n                                         tactic));\n \n-        if context.config.fn_args_layout == IndentStyle::Visual || !body.contains('\\n') {\n+        if context.config.fn_args_layout() == IndentStyle::Visual || !body.contains('\\n') {\n             result.push('(');\n-            if context.config.spaces_within_parens && body.len() > 0 {\n+            if context.config.spaces_within_parens() && body.len() > 0 {\n                 result.push(' ');\n             }\n \n             result.push_str(&body);\n \n-            if context.config.spaces_within_parens && body.len() > 0 {\n+            if context.config.spaces_within_parens() && body.len() > 0 {\n                 result.push(' ');\n             }\n             result.push(')');\n@@ -1099,11 +1101,11 @@ fn format_tuple_struct(context: &RewriteContext,\n     if !where_clause_str.is_empty() && !where_clause_str.contains('\\n') &&\n        (result.contains('\\n') ||\n         offset.block_indent + result.len() + where_clause_str.len() + 1 >\n-        context.config.max_width) {\n+        context.config.max_width()) {\n         // We need to put the where clause on a new line, but we didn't\n         // know that earlier, so the where clause will not be indented properly.\n         result.push('\\n');\n-        result.push_str(&(offset.block_only() + (context.config.tab_spaces - 1))\n+        result.push_str(&(offset.block_only() + (context.config.tab_spaces() - 1))\n                             .to_string(context.config));\n     }\n     result.push_str(&where_clause_str);\n@@ -1135,13 +1137,13 @@ pub fn rewrite_type_alias(context: &RewriteContext,\n \n     let where_budget = try_opt!(context\n                                     .config\n-                                    .max_width\n+                                    .max_width()\n                                     .checked_sub(last_line_width(&result)));\n     let where_clause_str = try_opt!(rewrite_where_clause(context,\n                                                          &generics.where_clause,\n-                                                         context.config.item_brace_style,\n+                                                         context.config.item_brace_style(),\n                                                          Shape::legacy(where_budget, indent),\n-                                                         context.config.where_density,\n+                                                         context.config.where_density(),\n                                                          \"=\",\n                                                          true,\n                                                          true,\n@@ -1154,7 +1156,7 @@ pub fn rewrite_type_alias(context: &RewriteContext,\n     // In that case the budget is set to 0 which will make ty.rewrite retry on a new line\n     let budget = context\n         .config\n-        .max_width\n+        .max_width()\n         .checked_sub(indent.width() + line_width + \";\".len())\n         .unwrap_or(0);\n     let type_indent = indent + line_width;\n@@ -1170,7 +1172,7 @@ pub fn rewrite_type_alias(context: &RewriteContext,\n         result.push_str(&type_indent.to_string(context.config));\n         let budget = try_opt!(context\n                                   .config\n-                                  .max_width\n+                                  .max_width()\n                                   .checked_sub(type_indent.width() + \";\".len()));\n         ty.rewrite(context, Shape::legacy(budget, type_indent))\n     }));\n@@ -1180,12 +1182,12 @@ pub fn rewrite_type_alias(context: &RewriteContext,\n }\n \n fn type_annotation_spacing(config: &Config) -> (&str, &str) {\n-    (if config.space_before_type_annotation {\n+    (if config.space_before_type_annotation() {\n          \" \"\n      } else {\n          \"\"\n      },\n-     if config.space_after_type_annotation_colon {\n+     if config.space_after_type_annotation_colon() {\n          \" \"\n      } else {\n          \"\"\n@@ -1196,7 +1198,7 @@ impl Rewrite for ast::StructField {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         if contains_skip(&self.attrs) {\n             let span = context.snippet(mk_sp(self.attrs[0].span.lo, self.span.hi));\n-            return wrap_str(span, context.config.max_width, shape);\n+            return wrap_str(span, context.config.max_width(), shape);\n         }\n \n         let name = self.ident;\n@@ -1232,7 +1234,7 @@ impl Rewrite for ast::StructField {\n                 match new_ty {\n                     Some(ref new_ty) if !new_ty.contains('\\n') &&\n                                         new_ty.len() + type_offset.width() <=\n-                                        context.config.max_width => {\n+                                        context.config.max_width() => {\n                         Some(format!(\"{}\\n{}{}\",\n                                      result,\n                                      type_offset.to_string(&context.config),\n@@ -1282,15 +1284,16 @@ pub fn rewrite_static(prefix: &str,\n                          type_annotation_spacing.1);\n     // 2 = \" =\".len()\n     let ty_str = try_opt!(ty.rewrite(context,\n-                                     Shape::legacy(context.config.max_width - offset.block_indent -\n+                                     Shape::legacy(context.config.max_width() -\n+                                                   offset.block_indent -\n                                                    prefix.len() -\n                                                    2,\n                                                    offset.block_only())));\n \n     if let Some(expr) = expr_opt {\n         let lhs = format!(\"{}{} =\", prefix, ty_str);\n         // 1 = ;\n-        let remaining_width = context.config.max_width - offset.block_indent - 1;\n+        let remaining_width = context.config.max_width() - offset.block_indent - 1;\n         rewrite_assign_rhs(context,\n                            lhs,\n                            expr,\n@@ -1310,31 +1313,32 @@ pub fn rewrite_associated_type(ident: ast::Ident,\n                                -> Option<String> {\n     let prefix = format!(\"type {}\", ident);\n \n-    let type_bounds_str = if let Some(ty_param_bounds) = ty_param_bounds_opt {\n-        let joiner = match context.config.type_punctuation_density {\n-            TypeDensity::Compressed => \"+\",\n-            TypeDensity::Wide => \" + \",\n-        };\n-        let bounds: &[_] = ty_param_bounds;\n-        let bound_str = try_opt!(bounds\n-                                     .iter()\n-                                     .map(|ty_bound| {\n-            ty_bound.rewrite(context, Shape::legacy(context.config.max_width, indent))\n-        })\n-                                     .intersperse(Some(joiner.to_string()))\n-                                     .collect::<Option<String>>());\n-        if bounds.len() > 0 {\n-            format!(\": {}\", bound_str)\n+    let type_bounds_str =\n+        if let Some(ty_param_bounds) = ty_param_bounds_opt {\n+            let joiner = match context.config.type_punctuation_density() {\n+                TypeDensity::Compressed => \"+\",\n+                TypeDensity::Wide => \" + \",\n+            };\n+            let bounds: &[_] = ty_param_bounds;\n+            let bound_str = try_opt!(bounds\n+                                         .iter()\n+                                         .map(|ty_bound| {\n+                ty_bound.rewrite(context, Shape::legacy(context.config.max_width(), indent))\n+            })\n+                                         .intersperse(Some(joiner.to_string()))\n+                                         .collect::<Option<String>>());\n+            if bounds.len() > 0 {\n+                format!(\": {}\", bound_str)\n+            } else {\n+                String::new()\n+            }\n         } else {\n             String::new()\n-        }\n-    } else {\n-        String::new()\n-    };\n+        };\n \n     if let Some(ty) = ty_opt {\n         let ty_str = try_opt!(ty.rewrite(context,\n-                                         Shape::legacy(context.config.max_width -\n+                                         Shape::legacy(context.config.max_width() -\n                                                        indent.block_indent -\n                                                        prefix.len() -\n                                                        2,\n@@ -1382,11 +1386,11 @@ impl Rewrite for ast::Arg {\n                                                    Shape::legacy(shape.width, shape.indent)));\n \n             if self.ty.node != ast::TyKind::Infer {\n-                if context.config.space_before_type_annotation {\n+                if context.config.space_before_type_annotation() {\n                     result.push_str(\" \");\n                 }\n                 result.push_str(\":\");\n-                if context.config.space_after_type_annotation_colon {\n+                if context.config.space_after_type_annotation_colon() {\n                     result.push_str(\" \");\n                 }\n                 let max_width = try_opt!(shape.width.checked_sub(result.len()));\n@@ -1539,7 +1543,7 @@ fn rewrite_fn_base(context: &RewriteContext,\n     result.push_str(::utils::format_unsafety(unsafety));\n \n     if abi != abi::Abi::Rust {\n-        result.push_str(&::utils::format_abi(abi, context.config.force_explicit_abi));\n+        result.push_str(&::utils::format_abi(abi, context.config.force_explicit_abi()));\n     }\n \n     // fn foo\n@@ -1567,9 +1571,9 @@ fn rewrite_fn_base(context: &RewriteContext,\n     let (mut one_line_budget, mut multi_line_budget, mut arg_indent) =\n         try_opt!(compute_budgets_for_args(context, &result, indent, ret_str_len, newline_brace));\n \n-    if context.config.fn_args_layout == IndentStyle::Block {\n+    if context.config.fn_args_layout() == IndentStyle::Block {\n         arg_indent = indent.block_indent(context.config);\n-        multi_line_budget = context.config.max_width - arg_indent.width();\n+        multi_line_budget = context.config.max_width() - arg_indent.width();\n     }\n \n     debug!(\"rewrite_fn_base: one_line_budget: {}, multi_line_budget: {}, arg_indent: {:?}\",\n@@ -1581,12 +1585,12 @@ fn rewrite_fn_base(context: &RewriteContext,\n     if one_line_budget == 0 {\n         if snuggle_angle_bracket {\n             result.push_str(\"(\");\n-        } else if context.config.fn_args_paren_newline {\n+        } else if context.config.fn_args_paren_newline() {\n             result.push('\\n');\n             result.push_str(&arg_indent.to_string(context.config));\n             arg_indent = arg_indent + 1; // extra space for `(`\n             result.push('(');\n-            if context.config.spaces_within_parens && fd.inputs.len() > 0 {\n+            if context.config.spaces_within_parens() && fd.inputs.len() > 0 {\n                 result.push(' ')\n             }\n         } else {\n@@ -1595,7 +1599,7 @@ fn rewrite_fn_base(context: &RewriteContext,\n         }\n     } else {\n         result.push('(');\n-        if context.config.spaces_within_parens && fd.inputs.len() > 0 {\n+        if context.config.spaces_within_parens() && fd.inputs.len() > 0 {\n             result.push(' ')\n         }\n     }\n@@ -1624,7 +1628,7 @@ fn rewrite_fn_base(context: &RewriteContext,\n \n     let multi_line_arg_str = arg_str.contains('\\n');\n \n-    let put_args_in_block = match context.config.fn_args_layout {\n+    let put_args_in_block = match context.config.fn_args_layout() {\n         IndentStyle::Block => multi_line_arg_str || generics_str.contains('\\n'),\n         _ => false,\n     } && !fd.inputs.is_empty();\n@@ -1639,15 +1643,15 @@ fn rewrite_fn_base(context: &RewriteContext,\n         result.push(')');\n     } else {\n         result.push_str(&arg_str);\n-        if context.config.spaces_within_parens && fd.inputs.len() > 0 {\n+        if context.config.spaces_within_parens() && fd.inputs.len() > 0 {\n             result.push(' ')\n         }\n         result.push(')');\n     }\n \n     // Return type.\n     if !ret_str.is_empty() {\n-        let ret_should_indent = match context.config.fn_args_layout {\n+        let ret_should_indent = match context.config.fn_args_layout() {\n             // If our args are block layout then we surely must have space.\n             IndentStyle::Block if put_args_in_block => false,\n             _ => {\n@@ -1663,13 +1667,13 @@ fn rewrite_fn_base(context: &RewriteContext,\n                     sig_length += 2;\n                 }\n \n-                let overlong_sig = sig_length > context.config.max_width;\n+                let overlong_sig = sig_length > context.config.max_width();\n \n                 result.contains('\\n') || multi_line_ret_str || overlong_sig\n             }\n         };\n         let ret_indent = if ret_should_indent {\n-            let indent = match context.config.fn_return_indent {\n+            let indent = match context.config.fn_return_indent() {\n                 ReturnIndent::WithWhereClause => indent + 4,\n                 // Aligning with non-existent args looks silly.\n                 _ if arg_str.is_empty() => {\n@@ -1718,7 +1722,7 @@ fn rewrite_fn_base(context: &RewriteContext,\n         }\n     }\n \n-    let should_compress_where = match context.config.where_density {\n+    let should_compress_where = match context.config.where_density() {\n         Density::Compressed => !result.contains('\\n') || put_args_in_block,\n         Density::CompressedIfEmpty => !has_body && !result.contains('\\n'),\n         _ => false,\n@@ -1727,20 +1731,20 @@ fn rewrite_fn_base(context: &RewriteContext,\n     if where_clause.predicates.len() == 1 && should_compress_where {\n         let budget = try_opt!(context\n                                   .config\n-                                  .max_width\n+                                  .max_width()\n                                   .checked_sub(last_line_width(&result)));\n         if let Some(where_clause_str) =\n             rewrite_where_clause(context,\n                                  where_clause,\n-                                 context.config.fn_brace_style,\n+                                 context.config.fn_brace_style(),\n                                  Shape::legacy(budget, indent),\n                                  Density::Compressed,\n                                  \"{\",\n                                  !has_braces,\n                                  put_args_in_block && ret_str.is_empty(),\n                                  Some(span.hi)) {\n             if !where_clause_str.contains('\\n') {\n-                if last_line_width(&result) + where_clause_str.len() > context.config.max_width {\n+                if last_line_width(&result) + where_clause_str.len() > context.config.max_width() {\n                     result.push('\\n');\n                 }\n \n@@ -1753,7 +1757,7 @@ fn rewrite_fn_base(context: &RewriteContext,\n \n     let where_clause_str = try_opt!(rewrite_where_clause(context,\n                                                          where_clause,\n-                                                         context.config.fn_brace_style,\n+                                                         context.config.fn_brace_style(),\n                                                          Shape::indented(indent, context.config),\n                                                          Density::Tall,\n                                                          \"{\",\n@@ -1859,7 +1863,7 @@ fn rewrite_args(context: &RewriteContext,\n         item.item = Some(arg);\n     }\n \n-    let (indent, trailing_comma, end_with_newline) = match context.config.fn_args_layout {\n+    let (indent, trailing_comma, end_with_newline) = match context.config.fn_args_layout() {\n         IndentStyle::Block if !generics_str_contains_newline && arg_items.len() <= 1 => {\n             (indent.block_indent(context.config), SeparatorTactic::Never, true)\n         }\n@@ -1870,7 +1874,7 @@ fn rewrite_args(context: &RewriteContext,\n     };\n \n     let tactic = definitive_tactic(&arg_items,\n-                                   context.config.fn_args_density.to_list_tactic(),\n+                                   context.config.fn_args_density().to_list_tactic(),\n                                    one_line_budget);\n     let budget = match tactic {\n         DefinitiveListTactic::Horizontal => one_line_budget,\n@@ -1919,15 +1923,15 @@ fn compute_budgets_for_args(context: &RewriteContext,\n         }\n         let one_line_budget = context\n             .config\n-            .max_width\n+            .max_width()\n             .checked_sub(used_space)\n             .unwrap_or(0);\n \n         if one_line_budget > 0 {\n             // 4 = \"() {\".len()\n             let multi_line_budget = try_opt!(context\n                                                  .config\n-                                                 .max_width\n+                                                 .max_width()\n                                                  .checked_sub(indent.width() + result.len() +\n                                                               4));\n \n@@ -1938,7 +1942,7 @@ fn compute_budgets_for_args(context: &RewriteContext,\n     // Didn't work. we must force vertical layout and put args on a newline.\n     let new_indent = indent.block_indent(context.config);\n     let used_space = new_indent.width() + 4; // Account for `(` and `)` and possibly ` {`.\n-    let max_space = context.config.max_width;\n+    let max_space = context.config.max_width();\n     if used_space <= max_space {\n         Some((0, max_space - used_space, new_indent))\n     } else {\n@@ -1948,7 +1952,7 @@ fn compute_budgets_for_args(context: &RewriteContext,\n }\n \n fn newline_for_brace(config: &Config, where_clause: &ast::WhereClause) -> bool {\n-    match config.fn_brace_style {\n+    match config.fn_brace_style() {\n         BraceStyle::AlwaysNextLine => true,\n         BraceStyle::SameLineWhere if !where_clause.predicates.is_empty() => true,\n         _ => false,\n@@ -1968,7 +1972,7 @@ fn rewrite_generics(context: &RewriteContext,\n         return Some(String::new());\n     }\n \n-    let offset = match context.config.generics_indent {\n+    let offset = match context.config.generics_indent() {\n         IndentStyle::Block => shape.indent.block_only().block_indent(context.config),\n         // 1 = <\n         IndentStyle::Visual => shape.indent + 1,\n@@ -2009,13 +2013,13 @@ fn rewrite_generics(context: &RewriteContext,\n     let list_str =\n         try_opt!(format_item_list(items, Shape::legacy(h_budget, offset), context.config));\n \n-    let result = if context.config.generics_indent != IndentStyle::Visual &&\n+    let result = if context.config.generics_indent() != IndentStyle::Visual &&\n                     list_str.contains('\\n') {\n         format!(\"<\\n{}{}\\n{}>\",\n                 offset.to_string(context.config),\n                 list_str,\n                 shape.indent.block_only().to_string(context.config))\n-    } else if context.config.spaces_within_angle_brackets {\n+    } else if context.config.spaces_within_angle_brackets() {\n         format!(\"< {} >\", list_str)\n     } else {\n         format!(\"<{}>\", list_str)\n@@ -2032,7 +2036,7 @@ fn rewrite_trait_bounds(context: &RewriteContext,\n     if bounds.is_empty() {\n         return Some(String::new());\n     }\n-    let joiner = match context.config.type_punctuation_density {\n+    let joiner = match context.config.type_punctuation_density() {\n         TypeDensity::Compressed => \"+\",\n         TypeDensity::Wide => \" + \",\n     };\n@@ -2077,7 +2081,7 @@ fn rewrite_where_clause_rfc_style(context: &RewriteContext,\n         \"\\n\".to_owned() + &block_shape.indent.to_string(context.config)\n     };\n \n-    let clause_shape = block_shape.block_indent(context.config.tab_spaces);\n+    let clause_shape = block_shape.block_indent(context.config.tab_spaces());\n     // each clause on one line, trailing comma (except if suppress_comma)\n     let span_start = span_for_where_pred(&where_clause.predicates[0]).lo;\n     // If we don't have the start of the next span, then use the end of the\n@@ -2129,7 +2133,7 @@ fn rewrite_where_clause(context: &RewriteContext,\n         return Some(String::new());\n     }\n \n-    if context.config.where_style == Style::Rfc {\n+    if context.config.where_style() == Style::Rfc {\n         return rewrite_where_clause_rfc_style(context,\n                                               where_clause,\n                                               shape,\n@@ -2139,17 +2143,17 @@ fn rewrite_where_clause(context: &RewriteContext,\n                                               span_end);\n     }\n \n-    let extra_indent = Indent::new(context.config.tab_spaces, 0);\n+    let extra_indent = Indent::new(context.config.tab_spaces(), 0);\n \n-    let offset = match context.config.where_pred_indent {\n+    let offset = match context.config.where_pred_indent() {\n         IndentStyle::Block => shape.indent + extra_indent.block_indent(context.config),\n         // 6 = \"where \".len()\n         IndentStyle::Visual => shape.indent + extra_indent + 6,\n     };\n     // FIXME: if where_pred_indent != Visual, then the budgets below might\n     // be out by a char or two.\n \n-    let budget = context.config.max_width - offset.width();\n+    let budget = context.config.max_width() - offset.width();\n     let span_start = span_for_where_pred(&where_clause.predicates[0]).lo;\n     // If we don't have the start of the next span, then use the end of the\n     // predicates, but that means we miss comments.\n@@ -2167,9 +2171,9 @@ fn rewrite_where_clause(context: &RewriteContext,\n     let item_vec = items.collect::<Vec<_>>();\n     // FIXME: we don't need to collect here if the where_layout isn't\n     // HorizontalVertical.\n-    let tactic = definitive_tactic(&item_vec, context.config.where_layout, budget);\n+    let tactic = definitive_tactic(&item_vec, context.config.where_layout(), budget);\n \n-    let mut comma_tactic = context.config.trailing_comma;\n+    let mut comma_tactic = context.config.trailing_comma();\n     // Kind of a hack because we don't usually have trailing commas in where clauses.\n     if comma_tactic == SeparatorTactic::Vertical || suppress_comma {\n         comma_tactic = SeparatorTactic::Never;\n@@ -2227,7 +2231,7 @@ fn format_generics(context: &RewriteContext,\n     if !generics.where_clause.predicates.is_empty() || result.contains('\\n') {\n         let budget = try_opt!(context\n                                   .config\n-                                  .max_width\n+                                  .max_width()\n                                   .checked_sub(last_line_width(&result)));\n         let where_clause_str =\n             try_opt!(rewrite_where_clause(context,"}, {"sha": "8c112b5f8afb7b5ecc250b3c083bdb2f8ab37755", "filename": "src/lib.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=c0bdbfa5315217741213d04329b02a4fb5e061e7", "patch": "@@ -145,12 +145,12 @@ impl Indent {\n     }\n \n     pub fn block_indent(mut self, config: &Config) -> Indent {\n-        self.block_indent += config.tab_spaces;\n+        self.block_indent += config.tab_spaces();\n         self\n     }\n \n     pub fn block_unindent(mut self, config: &Config) -> Indent {\n-        self.block_indent -= config.tab_spaces;\n+        self.block_indent -= config.tab_spaces();\n         self\n     }\n \n@@ -159,8 +159,8 @@ impl Indent {\n     }\n \n     pub fn to_string(&self, config: &Config) -> String {\n-        let (num_tabs, num_spaces) = if config.hard_tabs {\n-            (self.block_indent / config.tab_spaces, self.alignment)\n+        let (num_tabs, num_spaces) = if config.hard_tabs() {\n+            (self.block_indent / config.tab_spaces(), self.alignment)\n         } else {\n             (0, self.width())\n         };\n@@ -248,7 +248,7 @@ impl Shape {\n \n     pub fn indented(indent: Indent, config: &Config) -> Shape {\n         Shape {\n-            width: config.max_width.checked_sub(indent.width()).unwrap_or(0),\n+            width: config.max_width().checked_sub(indent.width()).unwrap_or(0),\n             indent: indent,\n             offset: indent.alignment,\n         }\n@@ -257,7 +257,7 @@ impl Shape {\n     pub fn with_max_width(&self, config: &Config) -> Shape {\n         Shape {\n             width: config\n-                .max_width\n+                .max_width()\n                 .checked_sub(self.indent.width())\n                 .unwrap_or(0),\n             ..*self\n@@ -442,13 +442,13 @@ fn format_ast<F>(krate: &ast::Crate,\n \n     // We always skip children for the \"Plain\" write mode, since there is\n     // nothing to distinguish the nested module contents.\n-    let skip_children = config.skip_children || config.write_mode == config::WriteMode::Plain;\n+    let skip_children = config.skip_children() || config.write_mode() == config::WriteMode::Plain;\n     for (path, module) in modules::list_files(krate, parse_session.codemap()) {\n         if skip_children && path.as_path() != main_file {\n             continue;\n         }\n         let path = path.to_str().unwrap();\n-        if config.verbose {\n+        if config.verbose() {\n             println!(\"Formatting {}\", path);\n         }\n         let mut visitor = FmtVisitor::from_codemap(parse_session, config);\n@@ -473,14 +473,14 @@ fn format_lines(text: &mut StringBuffer, name: &str, config: &Config, report: &m\n     let mut cur_line = 1;\n     let mut newline_count = 0;\n     let mut errors = vec![];\n-    let mut issue_seeker = BadIssueSeeker::new(config.report_todo, config.report_fixme);\n+    let mut issue_seeker = BadIssueSeeker::new(config.report_todo(), config.report_fixme());\n \n     for (c, b) in text.chars() {\n         if c == '\\r' {\n             continue;\n         }\n \n-        let format_line = config.file_lines.contains_line(name, cur_line as usize);\n+        let format_line = config.file_lines().contains_line(name, cur_line as usize);\n \n         if format_line {\n             // Add warnings for bad todos/ fixmes\n@@ -501,10 +501,10 @@ fn format_lines(text: &mut StringBuffer, name: &str, config: &Config, report: &m\n                 }\n \n                 // Check for any line width errors we couldn't correct.\n-                if config.error_on_line_overflow && line_len > config.max_width {\n+                if config.error_on_line_overflow() && line_len > config.max_width() {\n                     errors.push(FormattingError {\n                                     line: cur_line,\n-                                    kind: ErrorKind::LineOverflow(line_len, config.max_width),\n+                                    kind: ErrorKind::LineOverflow(line_len, config.max_width()),\n                                 });\n                 }\n             }\n@@ -577,7 +577,7 @@ pub fn format_input<T: Write>(input: Input,\n                               mut out: Option<&mut T>)\n                               -> Result<(Summary, FileMap, FormatReport), (io::Error, Summary)> {\n     let mut summary = Summary::new();\n-    if config.disable_all_formatting {\n+    if config.disable_all_formatting() {\n         return Ok((summary, FileMap::new(), FormatReport::new()));\n     }\n     let codemap = Rc::new(CodeMap::new());\n@@ -651,10 +651,10 @@ pub enum Input {\n \n pub fn run(input: Input, config: &Config) -> Summary {\n     let mut out = &mut stdout();\n-    output_header(out, config.write_mode).ok();\n+    output_header(out, config.write_mode()).ok();\n     match format_input(input, config, Some(out)) {\n         Ok((summary, _, report)) => {\n-            output_footer(out, config.write_mode).ok();\n+            output_footer(out, config.write_mode()).ok();\n \n             if report.has_warnings() {\n                 msg!(\"{}\", report);\n@@ -708,7 +708,9 @@ mod test {\n     #[test]\n     fn indent_to_string_hard_tabs() {\n         let mut config = Config::default();\n-        config.hard_tabs = true;\n+        config\n+            .override_value(\"hard_tabs\", \"true\")\n+            .expect(\"Could not set hard_tabs to true\");\n         let indent = Indent::new(8, 4);\n \n         // 2 tabs + 4 spaces\n@@ -719,10 +721,10 @@ mod test {\n     fn shape_visual_indent() {\n         let config = Config::default();\n         let indent = Indent::new(4, 8);\n-        let shape = Shape::legacy(config.max_width, indent);\n+        let shape = Shape::legacy(config.max_width(), indent);\n         let shape = shape.visual_indent(20);\n \n-        assert_eq!(config.max_width, shape.width);\n+        assert_eq!(config.max_width(), shape.width);\n         assert_eq!(4, shape.indent.block_indent);\n         assert_eq!(28, shape.indent.alignment);\n         assert_eq!(28, shape.offset);\n@@ -732,10 +734,10 @@ mod test {\n     fn shape_block_indent_without_alignment() {\n         let config = Config::default();\n         let indent = Indent::new(4, 0);\n-        let shape = Shape::legacy(config.max_width, indent);\n+        let shape = Shape::legacy(config.max_width(), indent);\n         let shape = shape.block_indent(20);\n \n-        assert_eq!(config.max_width, shape.width);\n+        assert_eq!(config.max_width(), shape.width);\n         assert_eq!(24, shape.indent.block_indent);\n         assert_eq!(0, shape.indent.alignment);\n         assert_eq!(0, shape.offset);\n@@ -745,10 +747,10 @@ mod test {\n     fn shape_block_indent_with_alignment() {\n         let config = Config::default();\n         let indent = Indent::new(4, 8);\n-        let shape = Shape::legacy(config.max_width, indent);\n+        let shape = Shape::legacy(config.max_width(), indent);\n         let shape = shape.block_indent(20);\n \n-        assert_eq!(config.max_width, shape.width);\n+        assert_eq!(config.max_width(), shape.width);\n         assert_eq!(4, shape.indent.block_indent);\n         assert_eq!(28, shape.indent.alignment);\n         assert_eq!(28, shape.offset);"}, {"sha": "5e03afff6fdf67d0fa4fbc6fd67b2f5dc9be43d1", "filename": "src/lists.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=c0bdbfa5315217741213d04329b02a4fb5e061e7", "patch": "@@ -73,7 +73,7 @@ pub fn format_fn_args<I>(items: I, shape: Shape, config: &Config) -> Option<Stri\n     list_helper(items,\n                 shape,\n                 config,\n-                ListTactic::LimitedHorizontalVertical(config.fn_call_width))\n+                ListTactic::LimitedHorizontalVertical(config.fn_call_width()))\n }\n \n pub fn format_item_list<I>(items: I, shape: Shape, config: &Config) -> Option<String>\n@@ -527,14 +527,14 @@ pub fn struct_lit_shape(shape: Shape,\n                         prefix_width: usize,\n                         suffix_width: usize)\n                         -> Option<(Option<Shape>, Shape)> {\n-    let v_shape = match context.config.struct_lit_style {\n+    let v_shape = match context.config.struct_lit_style() {\n         IndentStyle::Visual => {\n             try_opt!(try_opt!(shape.shrink_left(prefix_width)).sub_width(suffix_width))\n         }\n         IndentStyle::Block => {\n-            let shape = shape.block_indent(context.config.tab_spaces);\n+            let shape = shape.block_indent(context.config.tab_spaces());\n             Shape {\n-                width: try_opt!(context.config.max_width.checked_sub(shape.indent.width())),\n+                width: try_opt!(context.config.max_width().checked_sub(shape.indent.width())),\n                 ..shape\n             }\n         }\n@@ -549,13 +549,14 @@ pub fn struct_lit_tactic(h_shape: Option<Shape>,\n                          items: &[ListItem])\n                          -> DefinitiveListTactic {\n     if let Some(h_shape) = h_shape {\n-        let mut prelim_tactic = match (context.config.struct_lit_style, items.len()) {\n+        let mut prelim_tactic = match (context.config.struct_lit_style(), items.len()) {\n             (IndentStyle::Visual, 1) => ListTactic::HorizontalVertical,\n-            _ => context.config.struct_lit_multiline_style.to_list_tactic(),\n+            _ => context.config.struct_lit_multiline_style().to_list_tactic(),\n         };\n \n         if prelim_tactic == ListTactic::HorizontalVertical && items.len() > 1 {\n-            prelim_tactic = ListTactic::LimitedHorizontalVertical(context.config.struct_lit_width);\n+            prelim_tactic =\n+                ListTactic::LimitedHorizontalVertical(context.config.struct_lit_width());\n         }\n \n         definitive_tactic(items, prelim_tactic, h_shape.width)\n@@ -583,15 +584,15 @@ pub fn struct_lit_formatting<'a>(shape: Shape,\n                                  context: &'a RewriteContext,\n                                  force_no_trailing_comma: bool)\n                                  -> ListFormatting<'a> {\n-    let ends_with_newline = context.config.struct_lit_style != IndentStyle::Visual &&\n+    let ends_with_newline = context.config.struct_lit_style() != IndentStyle::Visual &&\n                             tactic == DefinitiveListTactic::Vertical;\n     ListFormatting {\n         tactic: tactic,\n         separator: \",\",\n         trailing_separator: if force_no_trailing_comma {\n             SeparatorTactic::Never\n         } else {\n-            context.config.trailing_comma\n+            context.config.trailing_comma()\n         },\n         shape: shape,\n         ends_with_newline: ends_with_newline,"}, {"sha": "98472d67fa78802524e3eaed2ad1db970c8f754b", "filename": "src/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=c0bdbfa5315217741213d04329b02a4fb5e061e7", "patch": "@@ -67,7 +67,7 @@ pub fn rewrite_macro(mac: &ast::Mac,\n                      -> Option<String> {\n     let mut context = &mut context.clone();\n     context.inside_macro = true;\n-    if context.config.use_try_shorthand {\n+    if context.config.use_try_shorthand() {\n         if let Some(expr) = convert_try_mac(mac, context) {\n             return expr.rewrite(context, shape);\n         }"}, {"sha": "40b6bdd8ce9f37d956b8c8071325c93bb41599b9", "filename": "src/missed_spans.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=c0bdbfa5315217741213d04329b02a4fb5e061e7", "patch": "@@ -116,7 +116,7 @@ impl<'a> FmtVisitor<'a> {\n                 .collect()\n         }\n \n-        let replaced = match self.config.write_mode {\n+        let replaced = match self.config.write_mode() {\n             WriteMode::Coverage => replace_chars(old_snippet),\n             _ => old_snippet.to_owned(),\n         };\n@@ -138,7 +138,7 @@ impl<'a> FmtVisitor<'a> {\n \n                 if rewrite_next_comment &&\n                    !self.config\n-                       .file_lines\n+                       .file_lines()\n                        .intersects_range(file_name, cur_line, cur_line + subslice_num_lines) {\n                     rewrite_next_comment = false;\n                 }\n@@ -154,8 +154,8 @@ impl<'a> FmtVisitor<'a> {\n                         self.buffer.push_str(\" \");\n                     }\n \n-                    let comment_width = ::std::cmp::min(self.config.comment_width,\n-                                                        self.config.max_width -\n+                    let comment_width = ::std::cmp::min(self.config.comment_width(),\n+                                                        self.config.max_width() -\n                                                         self.block_indent.width());\n \n                     self.buffer\n@@ -197,7 +197,7 @@ impl<'a> FmtVisitor<'a> {\n                 i += offset;\n \n                 if c == '\\n' {\n-                    if !self.config.file_lines.contains_line(file_name, cur_line) {\n+                    if !self.config.file_lines().contains_line(file_name, cur_line) {\n                         last_wspace = None;\n                     }\n "}, {"sha": "7dd146efdf9e1d4f44aeec23792f41c87afa6cc8", "filename": "src/patterns.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=c0bdbfa5315217741213d04329b02a4fb5e061e7", "patch": "@@ -51,7 +51,7 @@ impl Rewrite for Pat {\n                 };\n \n                 let result = format!(\"{}{}{}{}\", prefix, mut_infix, id_str, sub_pat);\n-                wrap_str(result, context.config.max_width, shape)\n+                wrap_str(result, context.config.max_width(), shape)\n             }\n             PatKind::Wild => {\n                 if 1 <= shape.width {\n@@ -108,19 +108,21 @@ impl Rewrite for Pat {\n                 let pats = try_opt!(pats);\n \n                 // Unwrap all the sub-strings and join them with commas.\n-                let result = if context.config.spaces_within_square_brackets {\n+                let result = if context.config.spaces_within_square_brackets() {\n                     format!(\"[ {} ]\", pats.join(\", \"))\n                 } else {\n                     format!(\"[{}]\", pats.join(\", \"))\n                 };\n-                wrap_str(result, context.config.max_width, shape)\n+                wrap_str(result, context.config.max_width(), shape)\n             }\n             PatKind::Struct(ref path, ref fields, elipses) => {\n                 rewrite_struct_pat(path, fields, elipses, self.span, context, shape)\n             }\n             // FIXME(#819) format pattern macros.\n             PatKind::Mac(..) => {\n-                wrap_str(context.snippet(self.span), context.config.max_width, shape)\n+                wrap_str(context.snippet(self.span),\n+                         context.config.max_width(),\n+                         shape)\n             }\n         }\n     }\n@@ -187,9 +189,10 @@ fn rewrite_struct_pat(path: &ast::Path,\n     }\n \n \n-    let fields_str = if context.config.struct_lit_style == IndentStyle::Block &&\n+    let fields_str = if context.config.struct_lit_style() == IndentStyle::Block &&\n                         (fields_str.contains('\\n') ||\n-                         context.config.struct_lit_multiline_style == MultilineStyle::ForceMulti ||\n+                         context.config.struct_lit_multiline_style() ==\n+                         MultilineStyle::ForceMulti ||\n                          fields_str.len() > h_shape.map(|s| s.width).unwrap_or(0)) {\n         format!(\"\\n{}{}\\n{}\",\n                 v_shape.indent.to_string(context.config),\n@@ -210,7 +213,7 @@ impl Rewrite for FieldPat {\n             pat\n         } else {\n             wrap_str(format!(\"{}: {}\", self.ident.to_string(), try_opt!(pat)),\n-                     context.config.max_width,\n+                     context.config.max_width(),\n                      shape)\n         }\n     }\n@@ -296,7 +299,7 @@ fn rewrite_tuple_pat(pats: &[ptr::P<ast::Pat>],\n     // Condense wildcard string suffix into a single ..\n     let wildcard_suffix_len = count_wildcard_suffix_len(&items);\n \n-    let list = if context.config.condense_wildcard_suffices && wildcard_suffix_len >= 2 {\n+    let list = if context.config.condense_wildcard_suffices() && wildcard_suffix_len >= 2 {\n         let new_item_count = 1 + pats.len() - wildcard_suffix_len;\n         items[new_item_count - 1].item = Some(\"..\".to_owned());\n \n@@ -308,15 +311,15 @@ fn rewrite_tuple_pat(pats: &[ptr::P<ast::Pat>],\n \n     match path_str {\n         Some(path_str) => {\n-            Some(if context.config.spaces_within_parens {\n+            Some(if context.config.spaces_within_parens() {\n                      format!(\"{}( {} )\", path_str, list)\n                  } else {\n                      format!(\"{}({})\", path_str, list)\n                  })\n         }\n         None => {\n             let comma = if add_comma { \",\" } else { \"\" };\n-            Some(if context.config.spaces_within_parens {\n+            Some(if context.config.spaces_within_parens() {\n                      format!(\"( {}{} )\", list, comma)\n                  } else {\n                      format!(\"({}{})\", list, comma)"}, {"sha": "365d205aef100a4187fe1018aa7f3d764a19c043", "filename": "src/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring.rs?ref=c0bdbfa5315217741213d04329b02a4fb5e061e7", "patch": "@@ -119,7 +119,7 @@ pub fn rewrite_string<'a>(orig: &str, fmt: &StringFormat<'a>) -> Option<String>\n     }\n \n     result.push_str(fmt.closer);\n-    wrap_str(result, fmt.config.max_width, fmt.shape)\n+    wrap_str(result, fmt.config.max_width(), fmt.shape)\n }\n \n #[cfg(test)]"}, {"sha": "a0e7246e29dc45d047061ac44843371fe1b77841", "filename": "src/types.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=c0bdbfa5315217741213d04329b02a4fb5e061e7", "patch": "@@ -53,7 +53,7 @@ pub fn rewrite_path(context: &RewriteContext,\n \n     if let Some(qself) = qself {\n         result.push('<');\n-        if context.config.spaces_within_angle_brackets {\n+        if context.config.spaces_within_angle_brackets() {\n             result.push_str(\" \")\n         }\n \n@@ -79,7 +79,7 @@ pub fn rewrite_path(context: &RewriteContext,\n                                                     shape));\n         }\n \n-        if context.config.spaces_within_angle_brackets {\n+        if context.config.spaces_within_angle_brackets() {\n             result.push_str(\" \")\n         }\n \n@@ -158,7 +158,7 @@ impl<'a> Rewrite for SegmentParam<'a> {\n             SegmentParam::LifeTime(lt) => lt.rewrite(context, shape),\n             SegmentParam::Type(ty) => ty.rewrite(context, shape),\n             SegmentParam::Binding(binding) => {\n-                let mut result = match context.config.type_punctuation_density {\n+                let mut result = match context.config.type_punctuation_density() {\n                     TypeDensity::Wide => format!(\"{} = \", binding.ident),\n                     TypeDensity::Compressed => format!(\"{}=\", binding.ident),\n                 };\n@@ -237,7 +237,7 @@ fn rewrite_segment(path_context: PathContext,\n                 // Update position of last bracket.\n                 *span_lo = next_span_lo;\n \n-                if context.config.spaces_within_angle_brackets && list_str.len() > 0 {\n+                if context.config.spaces_within_angle_brackets() && list_str.len() > 0 {\n                     format!(\"{}< {} >\", separator, list_str)\n                 } else {\n                     format!(\"{}<{}>\", separator, list_str)\n@@ -338,16 +338,16 @@ fn format_function_type<'a, I>(inputs: I,\n         String::new()\n     };\n \n-    Some(if context.config.spaces_within_parens {\n+    Some(if context.config.spaces_within_parens() {\n              format!(\"( {} ){}{}\", list_str, infix, output)\n          } else {\n              format!(\"({}){}{}\", list_str, infix, output)\n          })\n }\n \n fn type_bound_colon(context: &RewriteContext) -> &'static str {\n-    colon_spaces(context.config.space_before_bound,\n-                 context.config.space_after_bound_colon)\n+    colon_spaces(context.config.space_before_bound(),\n+                 context.config.space_after_bound_colon())\n }\n \n impl Rewrite for ast::WherePredicate {\n@@ -370,7 +370,7 @@ impl Rewrite for ast::WherePredicate {\n                                      .intersperse(Some(\", \".to_string()))\n                                      .collect());\n \n-                    let joiner = match context.config.type_punctuation_density {\n+                    let joiner = match context.config.type_punctuation_density() {\n                         TypeDensity::Compressed => \"+\",\n                         TypeDensity::Wide => \" + \",\n                     };\n@@ -386,7 +386,7 @@ impl Rewrite for ast::WherePredicate {\n                                                     .intersperse(Some(joiner.to_string()))\n                                                     .collect());\n \n-                    if context.config.spaces_within_angle_brackets && lifetime_str.len() > 0 {\n+                    if context.config.spaces_within_angle_brackets() && lifetime_str.len() > 0 {\n                         format!(\"for< {} > {}{}{}\",\n                                 lifetime_str,\n                                 type_str,\n@@ -396,7 +396,7 @@ impl Rewrite for ast::WherePredicate {\n                         format!(\"for<{}> {}{}{}\", lifetime_str, type_str, colon, bounds_str)\n                     }\n                 } else {\n-                    let joiner = match context.config.type_punctuation_density {\n+                    let joiner = match context.config.type_punctuation_density() {\n                         TypeDensity::Compressed => \"+\",\n                         TypeDensity::Wide => \" + \",\n                     };\n@@ -437,7 +437,7 @@ impl Rewrite for ast::WherePredicate {\n             }\n         };\n \n-        wrap_str(result, context.config.max_width, shape)\n+        wrap_str(result, context.config.max_width(), shape)\n     }\n }\n \n@@ -464,12 +464,12 @@ fn rewrite_bounded_lifetime<'b, I>(lt: &ast::Lifetime,\n                                             .map(|b| b.rewrite(context, shape))\n                                             .collect());\n         let colon = type_bound_colon(context);\n-        let joiner = match context.config.type_punctuation_density {\n+        let joiner = match context.config.type_punctuation_density() {\n             TypeDensity::Compressed => \"+\",\n             TypeDensity::Wide => \" + \",\n         };\n         let result = format!(\"{}{}{}\", result, colon, appendix.join(joiner));\n-        wrap_str(result, context.config.max_width, shape)\n+        wrap_str(result, context.config.max_width(), shape)\n     }\n }\n \n@@ -493,19 +493,19 @@ impl Rewrite for ast::TyParamBound {\n impl Rewrite for ast::Lifetime {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         wrap_str(pprust::lifetime_to_string(self),\n-                 context.config.max_width,\n+                 context.config.max_width(),\n                  shape)\n     }\n }\n \n impl Rewrite for ast::TyParamBounds {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        let joiner = match context.config.type_punctuation_density {\n+        let joiner = match context.config.type_punctuation_density() {\n             TypeDensity::Compressed => \"+\",\n             TypeDensity::Wide => \" + \",\n         };\n         let strs: Vec<_> = try_opt!(self.iter().map(|b| b.rewrite(context, shape)).collect());\n-        wrap_str(strs.join(joiner), context.config.max_width, shape)\n+        wrap_str(strs.join(joiner), context.config.max_width(), shape)\n     }\n }\n \n@@ -514,14 +514,14 @@ impl Rewrite for ast::TyParam {\n         let mut result = String::with_capacity(128);\n         result.push_str(&self.ident.to_string());\n         if !self.bounds.is_empty() {\n-            if context.config.space_before_bound {\n+            if context.config.space_before_bound() {\n                 result.push_str(\" \");\n             }\n             result.push_str(\":\");\n-            if context.config.space_after_bound_colon {\n+            if context.config.space_after_bound_colon() {\n                 result.push_str(\" \");\n             }\n-            let joiner = match context.config.type_punctuation_density {\n+            let joiner = match context.config.type_punctuation_density() {\n                 TypeDensity::Compressed => \"+\",\n                 TypeDensity::Wide => \" + \",\n             };\n@@ -536,7 +536,7 @@ impl Rewrite for ast::TyParam {\n         }\n         if let Some(ref def) = self.default {\n \n-            let eq_str = match context.config.type_punctuation_density {\n+            let eq_str = match context.config.type_punctuation_density() {\n                 TypeDensity::Compressed => \"=\",\n                 TypeDensity::Wide => \" = \",\n             };\n@@ -547,7 +547,7 @@ impl Rewrite for ast::TyParam {\n             result.push_str(&rewrite);\n         }\n \n-        wrap_str(result, context.config.max_width, shape)\n+        wrap_str(result, context.config.max_width(), shape)\n     }\n }\n \n@@ -568,7 +568,7 @@ impl Rewrite for ast::PolyTraitRef {\n                                                  Shape::legacy(max_path_width,\n                                                                shape.indent + extra_offset)));\n \n-            Some(if context.config.spaces_within_angle_brackets && lifetime_str.len() > 0 {\n+            Some(if context.config.spaces_within_angle_brackets() && lifetime_str.len() > 0 {\n                      format!(\"for< {} > {}\", lifetime_str, path_str)\n                  } else {\n                      format!(\"for<{}> {}\", lifetime_str, path_str)\n@@ -637,20 +637,20 @@ impl Rewrite for ast::Ty {\n             ast::TyKind::Paren(ref ty) => {\n                 let budget = try_opt!(shape.width.checked_sub(2));\n                 ty.rewrite(context, Shape::legacy(budget, shape.indent + 1))\n-                    .map(|ty_str| if context.config.spaces_within_parens {\n+                    .map(|ty_str| if context.config.spaces_within_parens() {\n                              format!(\"( {} )\", ty_str)\n                          } else {\n                              format!(\"({})\", ty_str)\n                          })\n             }\n             ast::TyKind::Slice(ref ty) => {\n-                let budget = if context.config.spaces_within_square_brackets {\n+                let budget = if context.config.spaces_within_square_brackets() {\n                     try_opt!(shape.width.checked_sub(4))\n                 } else {\n                     try_opt!(shape.width.checked_sub(2))\n                 };\n                 ty.rewrite(context, Shape::legacy(budget, shape.indent + 1))\n-                    .map(|ty_str| if context.config.spaces_within_square_brackets {\n+                    .map(|ty_str| if context.config.spaces_within_square_brackets() {\n                              format!(\"[ {} ]\", ty_str)\n                          } else {\n                              format!(\"[{}]\", ty_str)\n@@ -663,7 +663,7 @@ impl Rewrite for ast::Ty {\n                 rewrite_path(context, PathContext::Type, q_self.as_ref(), path, shape)\n             }\n             ast::TyKind::Array(ref ty, ref repeats) => {\n-                let use_spaces = context.config.spaces_within_square_brackets;\n+                let use_spaces = context.config.spaces_within_square_brackets();\n                 let lbr = if use_spaces { \"[ \" } else { \"[\" };\n                 let rbr = if use_spaces { \" ]\" } else { \"]\" };\n                 rewrite_pair(&**ty, &**repeats, lbr, \"; \", rbr, context, shape)\n@@ -715,7 +715,7 @@ fn rewrite_bare_fn(bare_fn: &ast::BareFnTy,\n     result.push_str(::utils::format_unsafety(bare_fn.unsafety));\n \n     if bare_fn.abi != abi::Abi::Rust {\n-        result.push_str(&::utils::format_abi(bare_fn.abi, context.config.force_explicit_abi));\n+        result.push_str(&::utils::format_abi(bare_fn.abi, context.config.force_explicit_abi()));\n     }\n \n     result.push_str(\"fn\");"}, {"sha": "059040c70a237b62ac5b8d655e705a45beb1d070", "filename": "src/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=c0bdbfa5315217741213d04329b02a4fb5e061e7", "patch": "@@ -312,7 +312,7 @@ pub fn wrap_str<S: AsRef<str>>(s: S, max_width: usize, shape: Shape) -> Option<S\n \n impl Rewrite for String {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        wrap_str(self, context.config.max_width, shape).map(ToOwned::to_owned)\n+        wrap_str(self, context.config.max_width(), shape).map(ToOwned::to_owned)\n     }\n }\n "}, {"sha": "c8d8cf52e7a218362bce4044f05e29bff8f54863", "filename": "src/visitor.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bdbfa5315217741213d04329b02a4fb5e061e7/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=c0bdbfa5315217741213d04329b02a4fb5e061e7", "patch": "@@ -50,7 +50,7 @@ impl<'a> FmtVisitor<'a> {\n \n         // FIXME(#434): Move this check to somewhere more central, eg Rewrite.\n         if !self.config\n-               .file_lines\n+               .file_lines()\n                .intersects(&self.codemap.lookup_line_range(stmt.span)) {\n             return;\n         }\n@@ -113,10 +113,10 @@ impl<'a> FmtVisitor<'a> {\n     // level.\n     fn close_block(&mut self) {\n         let total_len = self.buffer.len;\n-        let chars_too_many = if self.config.hard_tabs {\n+        let chars_too_many = if self.config.hard_tabs() {\n             1\n         } else {\n-            self.config.tab_spaces\n+            self.config.tab_spaces()\n         };\n         self.buffer.truncate(total_len - chars_too_many);\n         self.buffer.push_str(\"}\");\n@@ -509,7 +509,7 @@ impl<'a> FmtVisitor<'a> {\n             // If the next item is a `use` declaration, then extract it and any subsequent `use`s\n             // to be potentially reordered within `format_imports`. Otherwise, just format the\n             // next item for output.\n-            if self.config.reorder_imports && is_use_item(&*items_left[0]) {\n+            if self.config.reorder_imports() && is_use_item(&*items_left[0]) {\n                 let use_item_length = items_left\n                     .iter()\n                     .take_while(|ppi| is_use_item(&***ppi))\n@@ -599,13 +599,13 @@ impl<'a> Rewrite for [ast::Attribute] {\n                 let multi_line = a_str.starts_with(\"//\") && comment.matches('\\n').count() > 1;\n                 let comment = comment.trim();\n                 if !comment.is_empty() {\n-                    let comment = try_opt!(rewrite_comment(comment,\n-                                                           false,\n-                                                           Shape::legacy(context.config\n-                                                                             .comment_width -\n-                                                                         shape.indent.width(),\n-                                                                         shape.indent),\n-                                                           context.config));\n+                    let comment =\n+                        try_opt!(rewrite_comment(comment,\n+                                                 false,\n+                                                 Shape::legacy(context.config.comment_width() -\n+                                                               shape.indent.width(),\n+                                                               shape.indent),\n+                                                 context.config));\n                     result.push_str(&indent);\n                     result.push_str(&comment);\n                     result.push('\\n');\n@@ -618,7 +618,7 @@ impl<'a> Rewrite for [ast::Attribute] {\n             if a_str.starts_with(\"//\") {\n                 a_str = try_opt!(rewrite_comment(&a_str,\n                                                  false,\n-                                                 Shape::legacy(context.config.comment_width -\n+                                                 Shape::legacy(context.config.comment_width() -\n                                                                shape.indent.width(),\n                                                                shape.indent),\n                                                  context.config));"}, {"sha": "91386a7f768d205d9478d38a4f199050e005caa3", "filename": "tests/system.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c0bdbfa5315217741213d04329b02a4fb5e061e7/tests%2Fsystem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bdbfa5315217741213d04329b02a4fb5e061e7/tests%2Fsystem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsystem.rs?ref=c0bdbfa5315217741213d04329b02a4fb5e061e7", "patch": "@@ -20,7 +20,7 @@ use std::path::{Path, PathBuf};\n \n use rustfmt::*;\n use rustfmt::filemap::{write_system_newlines, FileMap};\n-use rustfmt::config::{Config, ReportTactic};\n+use rustfmt::config::Config;\n use rustfmt::rustfmt_diff::*;\n \n const DIFF_CONTEXT_SIZE: usize = 3;\n@@ -224,12 +224,16 @@ fn read_config(filename: &str) -> Config {\n \n     for (key, val) in &sig_comments {\n         if key != \"target\" && key != \"config\" {\n-            config.override_value(key, val);\n+            config\n+                .override_value(key, val)\n+                .expect(&format!(\"Failed to override config {} (\\\"{}\\\")\", key, val));\n         }\n     }\n \n     // Don't generate warnings for to-do items.\n-    config.report_todo = ReportTactic::Never;\n+    config\n+        .override_value(\"report_todo\", \"Never\")\n+        .expect(\"Could not set report-todo to Never\");\n \n     config\n }"}]}