{"sha": "40a028c9a837f4f189b7db82cd4034536af87322", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwYTAyOGM5YTgzN2Y0ZjE4OWI3ZGI4MmNkNDAzNDUzNmFmODczMjI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-10-02T09:30:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-02T09:30:25Z"}, "message": "Merge #6105\n\n6105: Fix path comparison not comparing paths correctly with unequal lengths r=matklad a=Veykril\n\n~~This PR includes the commit from #6102 there as I found a bug while writing that(so either merging this or both in order works) so I included a test there already which was just ignored.~~ This PR fixes that, basically inserting imports didn't consider path length for equality, so depending on the order it might insert the path before or after another import if they only differ in segment length.\r\n\r\n~~Diff without the commit of #6102 https://github.com/rust-analyzer/rust-analyzer/commit/2d90d3937d71f9a00f3d44c15b20679215311637~~\r\n\r\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "6bf5fdbdef305be4122b2e8a0f8eabef2e6e37fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6bf5fdbdef305be4122b2e8a0f8eabef2e6e37fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40a028c9a837f4f189b7db82cd4034536af87322", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfdvMxCRBK7hj4Ov3rIwAAdHIIAAnRmCJmyFcQAY7Nq3LXh/RP\nrWjPnkOudu+iWfYcX3a5E/GtGvOEVNXZMMBjeaR3VXVzoWK/aqGckGphN1Ly1uU3\n1S2dwPkhK3nAuA/UWIbwwgneV+WKVT0m+oDZTixZHwBBwyFNz0QN5fMjK7Kvw4XC\nmEn5JNW1/nHPDDAeawBCoTfzJ+mxOZHYSWWyToSqv6xJgKq8eCxzXUWMOzYdrVzU\n6PhohQCUvlqKO/D2fM+sjM61uACfVqx9djwnGVe1dcrnwdDk/4KCg7muBiwkyz61\noHhVI0Nh8JJoclpXtDZj/Gb17ENu052XGWKf0A8hozHq8brHMZcnytk0e7h73CQ=\n=TEr0\n-----END PGP SIGNATURE-----\n", "payload": "tree 6bf5fdbdef305be4122b2e8a0f8eabef2e6e37fc\nparent c01cd6e3ed0763f8e773c34dc76db0e39396133d\nparent 95ea23cdef74aa8dc194d54db4d884df8ec3567d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1601631025 +0000\ncommitter GitHub <noreply@github.com> 1601631025 +0000\n\nMerge #6105\n\n6105: Fix path comparison not comparing paths correctly with unequal lengths r=matklad a=Veykril\n\n~~This PR includes the commit from #6102 there as I found a bug while writing that(so either merging this or both in order works) so I included a test there already which was just ignored.~~ This PR fixes that, basically inserting imports didn't consider path length for equality, so depending on the order it might insert the path before or after another import if they only differ in segment length.\r\n\r\n~~Diff without the commit of #6102 https://github.com/rust-analyzer/rust-analyzer/commit/2d90d3937d71f9a00f3d44c15b20679215311637~~\r\n\r\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40a028c9a837f4f189b7db82cd4034536af87322", "html_url": "https://github.com/rust-lang/rust/commit/40a028c9a837f4f189b7db82cd4034536af87322", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40a028c9a837f4f189b7db82cd4034536af87322/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c01cd6e3ed0763f8e773c34dc76db0e39396133d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c01cd6e3ed0763f8e773c34dc76db0e39396133d", "html_url": "https://github.com/rust-lang/rust/commit/c01cd6e3ed0763f8e773c34dc76db0e39396133d"}, {"sha": "95ea23cdef74aa8dc194d54db4d884df8ec3567d", "url": "https://api.github.com/repos/rust-lang/rust/commits/95ea23cdef74aa8dc194d54db4d884df8ec3567d", "html_url": "https://github.com/rust-lang/rust/commit/95ea23cdef74aa8dc194d54db4d884df8ec3567d"}], "stats": {"total": 133, "additions": 85, "deletions": 48}, "files": [{"sha": "f6025c99a1406ac85b7dd279ff0c09f1d2b1e286", "filename": "crates/assists/src/utils/insert_use.rs", "status": "modified", "additions": 85, "deletions": 48, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/40a028c9a837f4f189b7db82cd4034536af87322/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40a028c9a837f4f189b7db82cd4034536af87322/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs?ref=40a028c9a837f4f189b7db82cd4034536af87322", "patch": "@@ -4,13 +4,14 @@ use std::{\n     iter::{self, successors},\n };\n \n-use ast::{\n-    edit::{AstNodeEdit, IndentLevel},\n-    PathSegmentKind, VisibilityOwner,\n-};\n+use itertools::{EitherOrBoth, Itertools};\n use syntax::{\n     algo,\n-    ast::{self, make, AstNode},\n+    ast::{\n+        self,\n+        edit::{AstNodeEdit, IndentLevel},\n+        make, AstNode, PathSegmentKind, VisibilityOwner,\n+    },\n     InsertPosition, SyntaxElement, SyntaxNode,\n };\n \n@@ -193,13 +194,13 @@ fn recursive_merge(\n             false => None,\n         })\n         .collect::<Option<Vec<_>>>()?;\n-    use_trees.sort_unstable_by(|a, b| path_cmp_opt(a.path(), b.path()));\n+    use_trees.sort_unstable_by(|a, b| path_cmp_for_sort(a.path(), b.path()));\n     for rhs_t in rhs.use_tree_list().into_iter().flat_map(|list| list.use_trees()) {\n         if !merge.is_tree_allowed(&rhs_t) {\n             return None;\n         }\n         let rhs_path = rhs_t.path();\n-        match use_trees.binary_search_by(|p| path_cmp_opt(p.path(), rhs_path.clone())) {\n+        match use_trees.binary_search_by(|p| path_cmp_bin_search(p.path(), rhs_path.clone())) {\n             Ok(idx) => {\n                 let lhs_t = &mut use_trees[idx];\n                 let lhs_path = lhs_t.path()?;\n@@ -307,39 +308,77 @@ fn path_len(path: ast::Path) -> usize {\n \n /// Orders paths in the following way:\n /// the sole self token comes first, after that come uppercase identifiers, then lowercase identifiers\n-// FIXME: rustfmt sort lowercase idents before uppercase, in general we want to have the same ordering rustfmt has\n+// FIXME: rustfmt sorts lowercase idents before uppercase, in general we want to have the same ordering rustfmt has\n // which is `self` and `super` first, then identifier imports with lowercase ones first, then glob imports and at last list imports.\n // Example foo::{self, foo, baz, Baz, Qux, *, {Bar}}\n-fn path_cmp(a: &ast::Path, b: &ast::Path) -> Ordering {\n-    match (path_is_self(a), path_is_self(b)) {\n-        (true, true) => Ordering::Equal,\n-        (true, false) => Ordering::Less,\n-        (false, true) => Ordering::Greater,\n-        (false, false) => {\n-            let a = segment_iter(a);\n-            let b = segment_iter(b);\n-            // cmp_by would be useful for us here but that is currently unstable\n-            // cmp doesnt work due the lifetimes on text's return type\n-            a.zip(b)\n-                .flat_map(|(seg, seg2)| seg.name_ref().zip(seg2.name_ref()))\n-                .find_map(|(a, b)| match a.text().cmp(b.text()) {\n-                    ord @ Ordering::Greater | ord @ Ordering::Less => Some(ord),\n-                    Ordering::Equal => None,\n-                })\n-                .unwrap_or(Ordering::Equal)\n-        }\n+fn path_cmp_for_sort(a: Option<ast::Path>, b: Option<ast::Path>) -> Ordering {\n+    match (a, b) {\n+        (None, None) => Ordering::Equal,\n+        (None, Some(_)) => Ordering::Less,\n+        (Some(_), None) => Ordering::Greater,\n+        (Some(ref a), Some(ref b)) => match (path_is_self(a), path_is_self(b)) {\n+            (true, true) => Ordering::Equal,\n+            (true, false) => Ordering::Less,\n+            (false, true) => Ordering::Greater,\n+            (false, false) => path_cmp_short(a, b),\n+        },\n     }\n }\n \n-fn path_cmp_opt(a: Option<ast::Path>, b: Option<ast::Path>) -> Ordering {\n-    match (a, b) {\n+/// Path comparison func for binary searching for merging.\n+fn path_cmp_bin_search(lhs: Option<ast::Path>, rhs: Option<ast::Path>) -> Ordering {\n+    match (lhs, rhs) {\n         (None, None) => Ordering::Equal,\n         (None, Some(_)) => Ordering::Less,\n         (Some(_), None) => Ordering::Greater,\n-        (Some(a), Some(b)) => path_cmp(&a, &b),\n+        (Some(ref a), Some(ref b)) => path_cmp_short(a, b),\n     }\n }\n \n+/// Short circuiting comparison, if both paths are equal until one of them ends they are considered\n+/// equal\n+fn path_cmp_short(a: &ast::Path, b: &ast::Path) -> Ordering {\n+    let a = segment_iter(a);\n+    let b = segment_iter(b);\n+    // cmp_by would be useful for us here but that is currently unstable\n+    // cmp doesnt work due the lifetimes on text's return type\n+    a.zip(b)\n+        .find_map(|(a, b)| match path_segment_cmp(&a, &b) {\n+            Ordering::Equal => None,\n+            ord => Some(ord),\n+        })\n+        .unwrap_or(Ordering::Equal)\n+}\n+\n+/// Compares to paths, if one ends earlier than the other the has_tl parameters decide which is\n+/// greater as a a path that has a tree list should be greater, while one that just ends without\n+/// a tree list should be considered less.\n+fn use_tree_path_cmp(a: &ast::Path, a_has_tl: bool, b: &ast::Path, b_has_tl: bool) -> Ordering {\n+    let a_segments = segment_iter(a);\n+    let b_segments = segment_iter(b);\n+    // cmp_by would be useful for us here but that is currently unstable\n+    // cmp doesnt work due the lifetimes on text's return type\n+    a_segments\n+        .zip_longest(b_segments)\n+        .find_map(|zipped| match zipped {\n+            EitherOrBoth::Both(ref a, ref b) => match path_segment_cmp(a, b) {\n+                Ordering::Equal => None,\n+                ord => Some(ord),\n+            },\n+            EitherOrBoth::Left(_) if !b_has_tl => Some(Ordering::Greater),\n+            EitherOrBoth::Left(_) => Some(Ordering::Less),\n+            EitherOrBoth::Right(_) if !a_has_tl => Some(Ordering::Less),\n+            EitherOrBoth::Right(_) => Some(Ordering::Greater),\n+        })\n+        .unwrap_or(Ordering::Equal)\n+}\n+\n+fn path_segment_cmp(a: &ast::PathSegment, b: &ast::PathSegment) -> Ordering {\n+    let a = a.name_ref();\n+    let b = b.name_ref();\n+    a.as_ref().map(ast::NameRef::text).cmp(&b.as_ref().map(ast::NameRef::text))\n+}\n+\n /// What type of merges are allowed.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum MergeBehaviour {\n@@ -389,7 +428,6 @@ impl ImportGroup {\n             PathSegmentKind::Name(name) => match name.text().as_str() {\n                 \"std\" => ImportGroup::Std,\n                 \"core\" => ImportGroup::Std,\n-                // FIXME: can be ThisModule as well\n                 _ => ImportGroup::ExternCrate,\n             },\n             PathSegmentKind::Type { .. } => unreachable!(),\n@@ -415,30 +453,30 @@ fn find_insert_position(\n         .as_syntax_node()\n         .children()\n         .filter_map(|node| ast::Use::cast(node.clone()).zip(Some(node)))\n-        .flat_map(|(use_, node)| use_.use_tree().and_then(|tree| tree.path()).zip(Some(node)));\n+        .flat_map(|(use_, node)| {\n+            let tree = use_.use_tree()?;\n+            let path = tree.path()?;\n+            let has_tl = tree.use_tree_list().is_some();\n+            Some((path, has_tl, node))\n+        });\n     // Iterator that discards anything thats not in the required grouping\n     // This implementation allows the user to rearrange their import groups as this only takes the first group that fits\n     let group_iter = path_node_iter\n         .clone()\n-        .skip_while(|(path, _)| ImportGroup::new(path) != group)\n-        .take_while(|(path, _)| ImportGroup::new(path) == group);\n+        .skip_while(|(path, ..)| ImportGroup::new(path) != group)\n+        .take_while(|(path, ..)| ImportGroup::new(path) == group);\n \n-    let segments = segment_iter(&insert_path);\n     // track the last element we iterated over, if this is still None after the iteration then that means we never iterated in the first place\n     let mut last = None;\n     // find the element that would come directly after our new import\n-    let post_insert =\n-        group_iter.inspect(|(_, node)| last = Some(node.clone())).find(|(path, _)| {\n-            let check_segments = segment_iter(&path);\n-            segments\n-                .clone()\n-                .zip(check_segments)\n-                .flat_map(|(seg, seg2)| seg.name_ref().zip(seg2.name_ref()))\n-                .all(|(l, r)| l.text() <= r.text())\n-        });\n+    let post_insert = group_iter.inspect(|(.., node)| last = Some(node.clone())).find(\n+        |&(ref path, has_tl, _)| {\n+            use_tree_path_cmp(&insert_path, false, path, has_tl) != Ordering::Greater\n+        },\n+    );\n     match post_insert {\n         // insert our import before that element\n-        Some((_, node)) => (InsertPosition::Before(node.into()), AddBlankLine::After),\n+        Some((.., node)) => (InsertPosition::Before(node.into()), AddBlankLine::After),\n         // there is no element after our new import, so append it to the end of the group\n         None => match last {\n             Some(node) => (InsertPosition::After(node.into()), AddBlankLine::Before),\n@@ -448,10 +486,10 @@ fn find_insert_position(\n                 let mut last = None;\n                 // find the group that comes after where we want to insert\n                 let post_group = path_node_iter\n-                    .inspect(|(_, node)| last = Some(node.clone()))\n-                    .find(|(p, _)| ImportGroup::new(p) > group);\n+                    .inspect(|(.., node)| last = Some(node.clone()))\n+                    .find(|(p, ..)| ImportGroup::new(p) > group);\n                 match post_group {\n-                    Some((_, node)) => {\n+                    Some((.., node)) => {\n                         (InsertPosition::Before(node.into()), AddBlankLine::AfterTwice)\n                     }\n                     // there is no such group, so append after the last one\n@@ -844,7 +882,6 @@ use foo::bar::baz::Qux;\",\n     }\n \n     #[test]\n-    #[ignore] // FIXME: Order changes when switching lhs and rhs\n     fn skip_merge_last_too_long2() {\n         check_last(\n             \"foo::bar::baz::Qux\","}]}