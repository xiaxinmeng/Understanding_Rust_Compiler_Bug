{"sha": "fccde0018a618eb6f45d2a3c97f629809994dff6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjY2RlMDAxOGE2MThlYjZmNDVkMmEzYzk3ZjYyOTgwOTk5NGRmZjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-14T07:18:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-14T07:18:25Z"}, "message": "Auto merge of #54215 - kennytm:rollup, r=kennytm\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #53218 (Add a implementation of `From` for converting `&'a Option<T>` into `Option<&'a T>`)\n - #54024 (Fix compiling some rustc crates to wasm)\n - #54095 (Rename all mentions of `nil` to `unit`)\n - #54173 (Suggest valid crate type if invalid crate type is found)\n - #54194 (Remove println!() statement from HashMap unit test)\n - #54203 (Fix the stable release of os_str_str_ref_eq)\n - #54207 (re-mark the never docs as unstable)\n - #54210 (Update Cargo)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "d4c725cd7dfd72336822e39f899c27dbf13a6d99", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4c725cd7dfd72336822e39f899c27dbf13a6d99"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fccde0018a618eb6f45d2a3c97f629809994dff6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fccde0018a618eb6f45d2a3c97f629809994dff6", "html_url": "https://github.com/rust-lang/rust/commit/fccde0018a618eb6f45d2a3c97f629809994dff6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fccde0018a618eb6f45d2a3c97f629809994dff6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ff0b2ed163dab4389d88b14b5729514c11c682e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ff0b2ed163dab4389d88b14b5729514c11c682e", "html_url": "https://github.com/rust-lang/rust/commit/6ff0b2ed163dab4389d88b14b5729514c11c682e"}, {"sha": "dd4f5a2d48d986e0bf23b7cc690d3c2422d4391a", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd4f5a2d48d986e0bf23b7cc690d3c2422d4391a", "html_url": "https://github.com/rust-lang/rust/commit/dd4f5a2d48d986e0bf23b7cc690d3c2422d4391a"}], "stats": {"total": 905, "additions": 529, "deletions": 376}, "files": [{"sha": "dfdc375765d5faa52bd4bfa291f43ae581d90301", "filename": "src/libcore/option.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -1062,6 +1062,20 @@ impl<T> From<T> for Option<T> {\n     }\n }\n \n+#[stable(feature = \"option_ref_from_ref_option\", since = \"1.30.0\")]\n+impl<'a, T> From<&'a Option<T>> for Option<&'a T> {\n+    fn from(o: &'a Option<T>) -> Option<&'a T> {\n+        o.as_ref()\n+    }\n+}\n+\n+#[stable(feature = \"option_ref_from_ref_option\", since = \"1.30.0\")]\n+impl<'a, T> From<&'a mut Option<T>> for Option<&'a mut T> {\n+    fn from(o: &'a mut Option<T>) -> Option<&'a mut T> {\n+        o.as_mut()\n+    }\n+}\n+\n /////////////////////////////////////////////////////////////////////////////\n // The Option Iterators\n /////////////////////////////////////////////////////////////////////////////"}, {"sha": "e6452ad09278e45a7282490e0582a40d4c9efba2", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -422,6 +422,7 @@ pub enum BuiltinLintDiagnostics {\n     ProcMacroDeriveResolutionFallback(Span),\n     MacroExpandedMacroExportsAccessedByAbsolutePaths(Span),\n     ElidedLifetimesInPaths(usize, Span, bool, Span, String),\n+    UnknownCrateTypes(Span, String, String),\n }\n \n impl BuiltinLintDiagnostics {\n@@ -500,6 +501,14 @@ impl BuiltinLintDiagnostics {\n                     Applicability::MachineApplicable\n                 );\n             }\n+            BuiltinLintDiagnostics::UnknownCrateTypes(span, note, sugg) => {\n+                db.span_suggestion_with_applicability(\n+                    span,\n+                    &note,\n+                    sugg,\n+                    Applicability::MaybeIncorrect\n+                );\n+            }\n         }\n     }\n }"}, {"sha": "466d472cca338a92734ff8ee93dcc121a4a23c02", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -661,7 +661,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         {\n                             let predicate = trait_predicate.map_bound(|mut trait_pred| {\n                                 trait_pred.trait_ref.substs = self.tcx.mk_substs_trait(\n-                                    self.tcx.mk_nil(),\n+                                    self.tcx.mk_unit(),\n                                     &trait_pred.trait_ref.substs[1..],\n                                 );\n                                 trait_pred"}, {"sha": "6cc648b572c24e7de0c1465e6326a93840c9ed6a", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -2492,7 +2492,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_nil_ptr(self) -> Ty<'tcx> {\n-        self.mk_imm_ptr(self.mk_nil())\n+        self.mk_imm_ptr(self.mk_unit())\n     }\n \n     pub fn mk_array(self, ty: Ty<'tcx>, n: u64) -> Ty<'tcx> {\n@@ -2511,7 +2511,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         iter.intern_with(|ts| self.mk_ty(Tuple(self.intern_type_list(ts))))\n     }\n \n-    pub fn mk_nil(self) -> Ty<'tcx> {\n+    pub fn mk_unit(self) -> Ty<'tcx> {\n         self.intern_tup(&[])\n     }\n "}, {"sha": "a3316c2b8e2e4e433587d58c4ee87281814d759e", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -132,7 +132,7 @@ impl PrimitiveExt for Primitive {\n             Int(i, signed) => i.to_ty(tcx, signed),\n             Float(FloatTy::F32) => tcx.types.f32,\n             Float(FloatTy::F64) => tcx.types.f64,\n-            Pointer => tcx.mk_mut_ptr(tcx.mk_nil()),\n+            Pointer => tcx.mk_mut_ptr(tcx.mk_unit()),\n         }\n     }\n }\n@@ -1606,7 +1606,7 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n                 // (which may have no non-DST form), and will work as long\n                 // as the `Abi` or `FieldPlacement` is checked by users.\n                 if i == 0 {\n-                    let nil = tcx.mk_nil();\n+                    let nil = tcx.mk_unit();\n                     let ptr_ty = if this.ty.is_unsafe_ptr() {\n                         tcx.mk_mut_ptr(nil)\n                     } else {"}, {"sha": "19e235154cbd08d23cc440f856bcb6358fb27905", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -1020,7 +1020,7 @@ impl<'enc, 'a, 'tcx, E> Encoder for CacheEncoder<'enc, 'a, 'tcx, E>\n {\n     type Error = E::Error;\n \n-    fn emit_nil(&mut self) -> Result<(), Self::Error> {\n+    fn emit_unit(&mut self) -> Result<(), Self::Error> {\n         Ok(())\n     }\n "}, {"sha": "ea547c592d048a2bf98dfeeae7301ea7c4202b59", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -1458,7 +1458,7 @@ impl RegionKind {\n \n /// Type utilities\n impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n-    pub fn is_nil(&self) -> bool {\n+    pub fn is_unit(&self) -> bool {\n         match self.sty {\n             Tuple(ref tys) => tys.is_empty(),\n             _ => false,"}, {"sha": "3d7117dd46a21146529f94164e6db9e864066afd", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -234,7 +234,7 @@ impl PrintContext {\n             }\n         }\n         write!(f, \")\")?;\n-        if !output.is_nil() {\n+        if !output.is_unit() {\n             print!(f, self, write(\" -> \"), print_display(output))?;\n         }\n "}, {"sha": "f9eb80a1988af469263c9df86cef856d7dd88ed6", "filename": "src/librustc_codegen_llvm/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -160,7 +160,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n             output.push(')');\n \n-            if !sig.output().is_nil() {\n+            if !sig.output().is_unit() {\n                 output.push_str(\" -> \");\n                 push_debuginfo_type_name(cx, sig.output(), true, output);\n             }"}, {"sha": "5ec934ebd066750458e51275d6e75e24a9606862", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -968,7 +968,7 @@ fn get_rust_try_fn<'ll, 'tcx>(\n     let i8p = tcx.mk_mut_ptr(tcx.types.i8);\n     let fn_ty = tcx.mk_fn_ptr(ty::Binder::bind(tcx.mk_fn_sig(\n         iter::once(i8p),\n-        tcx.mk_nil(),\n+        tcx.mk_unit(),\n         false,\n         hir::Unsafety::Unsafe,\n         Abi::Rust"}, {"sha": "c3ec347f60876c03dc846bbec04f75f546b8d75d", "filename": "src/librustc_codegen_llvm/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -566,7 +566,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     ) -> &'ll Value {\n         let is_float = input_ty.is_fp();\n         let is_signed = input_ty.is_signed();\n-        let is_nil = input_ty.is_nil();\n+        let is_unit = input_ty.is_unit();\n         match op {\n             mir::BinOp::Add => if is_float {\n                 bx.fadd(lhs, rhs)\n@@ -604,7 +604,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n             mir::BinOp::Shl => common::build_unchecked_lshift(bx, lhs, rhs),\n             mir::BinOp::Shr => common::build_unchecked_rshift(bx, input_ty, lhs, rhs),\n             mir::BinOp::Ne | mir::BinOp::Lt | mir::BinOp::Gt |\n-            mir::BinOp::Eq | mir::BinOp::Le | mir::BinOp::Ge => if is_nil {\n+            mir::BinOp::Eq | mir::BinOp::Le | mir::BinOp::Ge => if is_unit {\n                 C_bool(bx.cx, match op {\n                     mir::BinOp::Ne | mir::BinOp::Lt | mir::BinOp::Gt => false,\n                     mir::BinOp::Eq | mir::BinOp::Le | mir::BinOp::Ge => true,"}, {"sha": "38ce331051fecc81b029a2bd460a0406963e8644", "filename": "src/librustc_data_structures/flock.rs", "status": "modified", "additions": 298, "deletions": 292, "changes": 590, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_data_structures%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_data_structures%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fflock.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -15,345 +15,351 @@\n //! librustdoc, it is not production quality at all.\n \n #![allow(non_camel_case_types)]\n-use std::path::Path;\n-\n-pub use self::imp::Lock;\n+#![allow(nonstandard_style)]\n \n-#[cfg(unix)]\n-mod imp {\n-    use std::ffi::{CString, OsStr};\n-    use std::os::unix::prelude::*;\n-    use std::path::Path;\n-    use std::io;\n-    use libc;\n+use std::io;\n+use std::path::Path;\n \n-    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-    mod os {\n+cfg_if! {\n+    if #[cfg(unix)] {\n+        use std::ffi::{CString, OsStr};\n+        use std::os::unix::prelude::*;\n         use libc;\n \n-        #[repr(C)]\n-        pub struct flock {\n-            pub l_type: libc::c_short,\n-            pub l_whence: libc::c_short,\n-            pub l_start: libc::off_t,\n-            pub l_len: libc::off_t,\n-            pub l_pid: libc::pid_t,\n-\n-            // not actually here, but brings in line with freebsd\n-            pub l_sysid: libc::c_int,\n-        }\n+        #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+        mod os {\n+            use libc;\n \n-        pub const F_RDLCK: libc::c_short = 0;\n-        pub const F_WRLCK: libc::c_short = 1;\n-        pub const F_UNLCK: libc::c_short = 2;\n-        pub const F_SETLK: libc::c_int = 6;\n-        pub const F_SETLKW: libc::c_int = 7;\n-    }\n+            #[repr(C)]\n+            pub struct flock {\n+                pub l_type: libc::c_short,\n+                pub l_whence: libc::c_short,\n+                pub l_start: libc::off_t,\n+                pub l_len: libc::off_t,\n+                pub l_pid: libc::pid_t,\n \n-    #[cfg(target_os = \"freebsd\")]\n-    mod os {\n-        use libc;\n+                // not actually here, but brings in line with freebsd\n+                pub l_sysid: libc::c_int,\n+            }\n \n-        #[repr(C)]\n-        pub struct flock {\n-            pub l_start: libc::off_t,\n-            pub l_len: libc::off_t,\n-            pub l_pid: libc::pid_t,\n-            pub l_type: libc::c_short,\n-            pub l_whence: libc::c_short,\n-            pub l_sysid: libc::c_int,\n+            pub const F_RDLCK: libc::c_short = 0;\n+            pub const F_WRLCK: libc::c_short = 1;\n+            pub const F_UNLCK: libc::c_short = 2;\n+            pub const F_SETLK: libc::c_int = 6;\n+            pub const F_SETLKW: libc::c_int = 7;\n         }\n \n-        pub const F_RDLCK: libc::c_short = 1;\n-        pub const F_UNLCK: libc::c_short = 2;\n-        pub const F_WRLCK: libc::c_short = 3;\n-        pub const F_SETLK: libc::c_int = 12;\n-        pub const F_SETLKW: libc::c_int = 13;\n-    }\n-\n-    #[cfg(any(target_os = \"dragonfly\",\n-              target_os = \"bitrig\",\n-              target_os = \"netbsd\",\n-              target_os = \"openbsd\"))]\n-    mod os {\n-        use libc;\n+        #[cfg(target_os = \"freebsd\")]\n+        mod os {\n+            use libc;\n+\n+            #[repr(C)]\n+            pub struct flock {\n+                pub l_start: libc::off_t,\n+                pub l_len: libc::off_t,\n+                pub l_pid: libc::pid_t,\n+                pub l_type: libc::c_short,\n+                pub l_whence: libc::c_short,\n+                pub l_sysid: libc::c_int,\n+            }\n \n-        #[repr(C)]\n-        pub struct flock {\n-            pub l_start: libc::off_t,\n-            pub l_len: libc::off_t,\n-            pub l_pid: libc::pid_t,\n-            pub l_type: libc::c_short,\n-            pub l_whence: libc::c_short,\n-\n-            // not actually here, but brings in line with freebsd\n-            pub l_sysid: libc::c_int,\n+            pub const F_RDLCK: libc::c_short = 1;\n+            pub const F_UNLCK: libc::c_short = 2;\n+            pub const F_WRLCK: libc::c_short = 3;\n+            pub const F_SETLK: libc::c_int = 12;\n+            pub const F_SETLKW: libc::c_int = 13;\n         }\n \n-        pub const F_RDLCK: libc::c_short = 1;\n-        pub const F_UNLCK: libc::c_short = 2;\n-        pub const F_WRLCK: libc::c_short = 3;\n-        pub const F_SETLK: libc::c_int = 8;\n-        pub const F_SETLKW: libc::c_int = 9;\n-    }\n-\n-    #[cfg(target_os = \"haiku\")]\n-    mod os {\n-        use libc;\n+        #[cfg(any(target_os = \"dragonfly\",\n+                  target_os = \"bitrig\",\n+                  target_os = \"netbsd\",\n+                  target_os = \"openbsd\"))]\n+        mod os {\n+            use libc;\n+\n+            #[repr(C)]\n+            pub struct flock {\n+                pub l_start: libc::off_t,\n+                pub l_len: libc::off_t,\n+                pub l_pid: libc::pid_t,\n+                pub l_type: libc::c_short,\n+                pub l_whence: libc::c_short,\n+\n+                // not actually here, but brings in line with freebsd\n+                pub l_sysid: libc::c_int,\n+            }\n \n-        #[repr(C)]\n-        pub struct flock {\n-            pub l_type: libc::c_short,\n-            pub l_whence: libc::c_short,\n-            pub l_start: libc::off_t,\n-            pub l_len: libc::off_t,\n-            pub l_pid: libc::pid_t,\n-\n-            // not actually here, but brings in line with freebsd\n-            pub l_sysid: libc::c_int,\n+            pub const F_RDLCK: libc::c_short = 1;\n+            pub const F_UNLCK: libc::c_short = 2;\n+            pub const F_WRLCK: libc::c_short = 3;\n+            pub const F_SETLK: libc::c_int = 8;\n+            pub const F_SETLKW: libc::c_int = 9;\n         }\n \n-        pub const F_RDLCK: libc::c_short = 0x0040;\n-        pub const F_UNLCK: libc::c_short = 0x0200;\n-        pub const F_WRLCK: libc::c_short = 0x0400;\n-        pub const F_SETLK: libc::c_int = 0x0080;\n-        pub const F_SETLKW: libc::c_int = 0x0100;\n-    }\n+        #[cfg(target_os = \"haiku\")]\n+        mod os {\n+            use libc;\n \n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-    mod os {\n-        use libc;\n+            #[repr(C)]\n+            pub struct flock {\n+                pub l_type: libc::c_short,\n+                pub l_whence: libc::c_short,\n+                pub l_start: libc::off_t,\n+                pub l_len: libc::off_t,\n+                pub l_pid: libc::pid_t,\n \n-        #[repr(C)]\n-        pub struct flock {\n-            pub l_start: libc::off_t,\n-            pub l_len: libc::off_t,\n-            pub l_pid: libc::pid_t,\n-            pub l_type: libc::c_short,\n-            pub l_whence: libc::c_short,\n-\n-            // not actually here, but brings in line with freebsd\n-            pub l_sysid: libc::c_int,\n+                // not actually here, but brings in line with freebsd\n+                pub l_sysid: libc::c_int,\n+            }\n+\n+            pub const F_RDLCK: libc::c_short = 0x0040;\n+            pub const F_UNLCK: libc::c_short = 0x0200;\n+            pub const F_WRLCK: libc::c_short = 0x0400;\n+            pub const F_SETLK: libc::c_int = 0x0080;\n+            pub const F_SETLKW: libc::c_int = 0x0100;\n         }\n \n-        pub const F_RDLCK: libc::c_short = 1;\n-        pub const F_UNLCK: libc::c_short = 2;\n-        pub const F_WRLCK: libc::c_short = 3;\n-        pub const F_SETLK: libc::c_int = 8;\n-        pub const F_SETLKW: libc::c_int = 9;\n-    }\n+        #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+        mod os {\n+            use libc;\n \n-    #[cfg(target_os = \"solaris\")]\n-    mod os {\n-        use libc;\n+            #[repr(C)]\n+            pub struct flock {\n+                pub l_start: libc::off_t,\n+                pub l_len: libc::off_t,\n+                pub l_pid: libc::pid_t,\n+                pub l_type: libc::c_short,\n+                pub l_whence: libc::c_short,\n \n-        #[repr(C)]\n-        pub struct flock {\n-            pub l_type: libc::c_short,\n-            pub l_whence: libc::c_short,\n-            pub l_start: libc::off_t,\n-            pub l_len: libc::off_t,\n-            pub l_sysid: libc::c_int,\n-            pub l_pid: libc::pid_t,\n+                // not actually here, but brings in line with freebsd\n+                pub l_sysid: libc::c_int,\n+            }\n+\n+            pub const F_RDLCK: libc::c_short = 1;\n+            pub const F_UNLCK: libc::c_short = 2;\n+            pub const F_WRLCK: libc::c_short = 3;\n+            pub const F_SETLK: libc::c_int = 8;\n+            pub const F_SETLKW: libc::c_int = 9;\n         }\n \n-        pub const F_RDLCK: libc::c_short = 1;\n-        pub const F_WRLCK: libc::c_short = 2;\n-        pub const F_UNLCK: libc::c_short = 3;\n-        pub const F_SETLK: libc::c_int = 6;\n-        pub const F_SETLKW: libc::c_int = 7;\n-    }\n+        #[cfg(target_os = \"solaris\")]\n+        mod os {\n+            use libc;\n+\n+            #[repr(C)]\n+            pub struct flock {\n+                pub l_type: libc::c_short,\n+                pub l_whence: libc::c_short,\n+                pub l_start: libc::off_t,\n+                pub l_len: libc::off_t,\n+                pub l_sysid: libc::c_int,\n+                pub l_pid: libc::pid_t,\n+            }\n \n-    #[derive(Debug)]\n-    pub struct Lock {\n-        fd: libc::c_int,\n-    }\n+            pub const F_RDLCK: libc::c_short = 1;\n+            pub const F_WRLCK: libc::c_short = 2;\n+            pub const F_UNLCK: libc::c_short = 3;\n+            pub const F_SETLK: libc::c_int = 6;\n+            pub const F_SETLKW: libc::c_int = 7;\n+        }\n \n-    impl Lock {\n-        pub fn new(p: &Path,\n-                   wait: bool,\n-                   create: bool,\n-                   exclusive: bool)\n-                   -> io::Result<Lock> {\n-            let os: &OsStr = p.as_ref();\n-            let buf = CString::new(os.as_bytes()).unwrap();\n-            let open_flags = if create {\n-                libc::O_RDWR | libc::O_CREAT\n-            } else {\n-                libc::O_RDWR\n-            };\n-\n-            let fd = unsafe {\n-                libc::open(buf.as_ptr(), open_flags,\n-                           libc::S_IRWXU as libc::c_int)\n-            };\n-\n-            if fd < 0 {\n-                return Err(io::Error::last_os_error());\n-            }\n+        #[derive(Debug)]\n+        pub struct Lock {\n+            fd: libc::c_int,\n+        }\n \n-            let lock_type = if exclusive {\n-                os::F_WRLCK\n-            } else {\n-                os::F_RDLCK\n-            };\n-\n-            let flock = os::flock {\n-                l_start: 0,\n-                l_len: 0,\n-                l_pid: 0,\n-                l_whence: libc::SEEK_SET as libc::c_short,\n-                l_type: lock_type,\n-                l_sysid: 0,\n-            };\n-            let cmd = if wait { os::F_SETLKW } else { os::F_SETLK };\n-            let ret = unsafe {\n-                libc::fcntl(fd, cmd, &flock)\n-            };\n-            if ret == -1 {\n-                let err = io::Error::last_os_error();\n-                unsafe { libc::close(fd); }\n-                Err(err)\n-            } else {\n-                Ok(Lock { fd: fd })\n+        impl Lock {\n+            pub fn new(p: &Path,\n+                       wait: bool,\n+                       create: bool,\n+                       exclusive: bool)\n+                       -> io::Result<Lock> {\n+                let os: &OsStr = p.as_ref();\n+                let buf = CString::new(os.as_bytes()).unwrap();\n+                let open_flags = if create {\n+                    libc::O_RDWR | libc::O_CREAT\n+                } else {\n+                    libc::O_RDWR\n+                };\n+\n+                let fd = unsafe {\n+                    libc::open(buf.as_ptr(), open_flags,\n+                               libc::S_IRWXU as libc::c_int)\n+                };\n+\n+                if fd < 0 {\n+                    return Err(io::Error::last_os_error());\n+                }\n+\n+                let lock_type = if exclusive {\n+                    os::F_WRLCK\n+                } else {\n+                    os::F_RDLCK\n+                };\n+\n+                let flock = os::flock {\n+                    l_start: 0,\n+                    l_len: 0,\n+                    l_pid: 0,\n+                    l_whence: libc::SEEK_SET as libc::c_short,\n+                    l_type: lock_type,\n+                    l_sysid: 0,\n+                };\n+                let cmd = if wait { os::F_SETLKW } else { os::F_SETLK };\n+                let ret = unsafe {\n+                    libc::fcntl(fd, cmd, &flock)\n+                };\n+                if ret == -1 {\n+                    let err = io::Error::last_os_error();\n+                    unsafe { libc::close(fd); }\n+                    Err(err)\n+                } else {\n+                    Ok(Lock { fd: fd })\n+                }\n             }\n         }\n-    }\n \n-    impl Drop for Lock {\n-        fn drop(&mut self) {\n-            let flock = os::flock {\n-                l_start: 0,\n-                l_len: 0,\n-                l_pid: 0,\n-                l_whence: libc::SEEK_SET as libc::c_short,\n-                l_type: os::F_UNLCK,\n-                l_sysid: 0,\n-            };\n-            unsafe {\n-                libc::fcntl(self.fd, os::F_SETLK, &flock);\n-                libc::close(self.fd);\n+        impl Drop for Lock {\n+            fn drop(&mut self) {\n+                let flock = os::flock {\n+                    l_start: 0,\n+                    l_len: 0,\n+                    l_pid: 0,\n+                    l_whence: libc::SEEK_SET as libc::c_short,\n+                    l_type: os::F_UNLCK,\n+                    l_sysid: 0,\n+                };\n+                unsafe {\n+                    libc::fcntl(self.fd, os::F_SETLK, &flock);\n+                    libc::close(self.fd);\n+                }\n             }\n         }\n-    }\n-}\n+    } else if #[cfg(windows)] {\n+        use std::mem;\n+        use std::os::windows::prelude::*;\n+        use std::os::windows::raw::HANDLE;\n+        use std::fs::{File, OpenOptions};\n+        use std::os::raw::{c_ulong, c_int};\n \n-#[cfg(windows)]\n-#[allow(nonstandard_style)]\n-mod imp {\n-    use std::io;\n-    use std::mem;\n-    use std::os::windows::prelude::*;\n-    use std::os::windows::raw::HANDLE;\n-    use std::path::Path;\n-    use std::fs::{File, OpenOptions};\n-    use std::os::raw::{c_ulong, c_int};\n-\n-    type DWORD = c_ulong;\n-    type BOOL = c_int;\n-    type ULONG_PTR = usize;\n-\n-    type LPOVERLAPPED = *mut OVERLAPPED;\n-    const LOCKFILE_EXCLUSIVE_LOCK: DWORD = 0x0000_0002;\n-    const LOCKFILE_FAIL_IMMEDIATELY: DWORD = 0x0000_0001;\n-\n-    const FILE_SHARE_DELETE: DWORD = 0x4;\n-    const FILE_SHARE_READ: DWORD = 0x1;\n-    const FILE_SHARE_WRITE: DWORD = 0x2;\n-\n-    #[repr(C)]\n-    struct OVERLAPPED {\n-        Internal: ULONG_PTR,\n-        InternalHigh: ULONG_PTR,\n-        Offset: DWORD,\n-        OffsetHigh: DWORD,\n-        hEvent: HANDLE,\n-    }\n+        type DWORD = c_ulong;\n+        type BOOL = c_int;\n+        type ULONG_PTR = usize;\n \n-    extern \"system\" {\n-        fn LockFileEx(hFile: HANDLE,\n-                      dwFlags: DWORD,\n-                      dwReserved: DWORD,\n-                      nNumberOfBytesToLockLow: DWORD,\n-                      nNumberOfBytesToLockHigh: DWORD,\n-                      lpOverlapped: LPOVERLAPPED) -> BOOL;\n-    }\n+        type LPOVERLAPPED = *mut OVERLAPPED;\n+        const LOCKFILE_EXCLUSIVE_LOCK: DWORD = 0x0000_0002;\n+        const LOCKFILE_FAIL_IMMEDIATELY: DWORD = 0x0000_0001;\n \n-    #[derive(Debug)]\n-    pub struct Lock {\n-        _file: File,\n-    }\n+        const FILE_SHARE_DELETE: DWORD = 0x4;\n+        const FILE_SHARE_READ: DWORD = 0x1;\n+        const FILE_SHARE_WRITE: DWORD = 0x2;\n \n-    impl Lock {\n-        pub fn new(p: &Path,\n-                   wait: bool,\n-                   create: bool,\n-                   exclusive: bool)\n-                   -> io::Result<Lock> {\n-            assert!(p.parent().unwrap().exists(),\n-                \"Parent directory of lock-file must exist: {}\",\n-                p.display());\n-\n-            let share_mode = FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE;\n-\n-            let mut open_options = OpenOptions::new();\n-            open_options.read(true)\n-                        .share_mode(share_mode);\n-\n-            if create {\n-                open_options.create(true)\n-                            .write(true);\n-            }\n+        #[repr(C)]\n+        struct OVERLAPPED {\n+            Internal: ULONG_PTR,\n+            InternalHigh: ULONG_PTR,\n+            Offset: DWORD,\n+            OffsetHigh: DWORD,\n+            hEvent: HANDLE,\n+        }\n \n-            debug!(\"Attempting to open lock file `{}`\", p.display());\n-            let file = match open_options.open(p) {\n-                Ok(file) => {\n-                    debug!(\"Lock file opened successfully\");\n-                    file\n-                }\n-                Err(err) => {\n-                    debug!(\"Error opening lock file: {}\", err);\n-                    return Err(err)\n-                }\n-            };\n+        extern \"system\" {\n+            fn LockFileEx(hFile: HANDLE,\n+                          dwFlags: DWORD,\n+                          dwReserved: DWORD,\n+                          nNumberOfBytesToLockLow: DWORD,\n+                          nNumberOfBytesToLockHigh: DWORD,\n+                          lpOverlapped: LPOVERLAPPED) -> BOOL;\n+        }\n \n-            let ret = unsafe {\n-                let mut overlapped: OVERLAPPED = mem::zeroed();\n+        #[derive(Debug)]\n+        pub struct Lock {\n+            _file: File,\n+        }\n \n-                let mut dwFlags = 0;\n-                if !wait {\n-                    dwFlags |= LOCKFILE_FAIL_IMMEDIATELY;\n+        impl Lock {\n+            pub fn new(p: &Path,\n+                       wait: bool,\n+                       create: bool,\n+                       exclusive: bool)\n+                       -> io::Result<Lock> {\n+                assert!(p.parent().unwrap().exists(),\n+                    \"Parent directory of lock-file must exist: {}\",\n+                    p.display());\n+\n+                let share_mode = FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE;\n+\n+                let mut open_options = OpenOptions::new();\n+                open_options.read(true)\n+                            .share_mode(share_mode);\n+\n+                if create {\n+                    open_options.create(true)\n+                                .write(true);\n                 }\n \n-                if exclusive {\n-                    dwFlags |= LOCKFILE_EXCLUSIVE_LOCK;\n+                debug!(\"Attempting to open lock file `{}`\", p.display());\n+                let file = match open_options.open(p) {\n+                    Ok(file) => {\n+                        debug!(\"Lock file opened successfully\");\n+                        file\n+                    }\n+                    Err(err) => {\n+                        debug!(\"Error opening lock file: {}\", err);\n+                        return Err(err)\n+                    }\n+                };\n+\n+                let ret = unsafe {\n+                    let mut overlapped: OVERLAPPED = mem::zeroed();\n+\n+                    let mut dwFlags = 0;\n+                    if !wait {\n+                        dwFlags |= LOCKFILE_FAIL_IMMEDIATELY;\n+                    }\n+\n+                    if exclusive {\n+                        dwFlags |= LOCKFILE_EXCLUSIVE_LOCK;\n+                    }\n+\n+                    debug!(\"Attempting to acquire lock on lock file `{}`\",\n+                           p.display());\n+                    LockFileEx(file.as_raw_handle(),\n+                               dwFlags,\n+                               0,\n+                               0xFFFF_FFFF,\n+                               0xFFFF_FFFF,\n+                               &mut overlapped)\n+                };\n+                if ret == 0 {\n+                    let err = io::Error::last_os_error();\n+                    debug!(\"Failed acquiring file lock: {}\", err);\n+                    Err(err)\n+                } else {\n+                    debug!(\"Successfully acquired lock.\");\n+                    Ok(Lock { _file: file })\n                 }\n+            }\n+        }\n \n-                debug!(\"Attempting to acquire lock on lock file `{}`\",\n-                       p.display());\n-                LockFileEx(file.as_raw_handle(),\n-                           dwFlags,\n-                           0,\n-                           0xFFFF_FFFF,\n-                           0xFFFF_FFFF,\n-                           &mut overlapped)\n-            };\n-            if ret == 0 {\n-                let err = io::Error::last_os_error();\n-                debug!(\"Failed acquiring file lock: {}\", err);\n-                Err(err)\n-            } else {\n-                debug!(\"Successfully acquired lock.\");\n-                Ok(Lock { _file: file })\n+        // Note that we don't need a Drop impl on the Windows: The file is unlocked\n+        // automatically when it's closed.\n+    } else {\n+        #[derive(Debug)]\n+        pub struct Lock(());\n+\n+        impl Lock {\n+            pub fn new(_p: &Path, _wait: bool, _create: bool, _exclusive: bool)\n+                -> io::Result<Lock>\n+            {\n+                let msg = \"file locks not supported on this platform\";\n+                Err(io::Error::new(io::ErrorKind::Other, msg))\n             }\n         }\n     }\n-\n-    // Note that we don't need a Drop impl on the Windows: The file is unlocked\n-    // automatically when it's closed.\n }\n \n-impl imp::Lock {\n+impl Lock {\n     pub fn panicking_new(p: &Path,\n                          wait: bool,\n                          create: bool,"}, {"sha": "7fb66ea97f26ba05a92e3f60a0140f0cbdc07777", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 41, "deletions": 7, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -57,6 +57,8 @@ use syntax::ext::base::ExtCtxt;\n use syntax::fold::Folder;\n use syntax::parse::{self, PResult};\n use syntax::util::node_count::NodeCounter;\n+use syntax::util::lev_distance::find_best_match_for_name;\n+use syntax::symbol::Symbol;\n use syntax_pos::{FileName, hygiene};\n use syntax_ext;\n \n@@ -1508,13 +1510,45 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<c\n                     Some(ref n) if *n == \"staticlib\" => Some(config::CrateType::Staticlib),\n                     Some(ref n) if *n == \"proc-macro\" => Some(config::CrateType::ProcMacro),\n                     Some(ref n) if *n == \"bin\" => Some(config::CrateType::Executable),\n-                    Some(_) => {\n-                        session.buffer_lint(\n-                            lint::builtin::UNKNOWN_CRATE_TYPES,\n-                            ast::CRATE_NODE_ID,\n-                            a.span,\n-                            \"invalid `crate_type` value\",\n-                        );\n+                    Some(ref n) => {\n+                        let crate_types = vec![\n+                            Symbol::intern(\"rlib\"),\n+                            Symbol::intern(\"dylib\"),\n+                            Symbol::intern(\"cdylib\"),\n+                            Symbol::intern(\"lib\"),\n+                            Symbol::intern(\"staticlib\"),\n+                            Symbol::intern(\"proc-macro\"),\n+                            Symbol::intern(\"bin\")\n+                        ];\n+                        if let ast::MetaItemKind::NameValue(spanned) = a.meta().unwrap().node {\n+                            let span = spanned.span;\n+                            let lev_candidate = find_best_match_for_name(\n+                                crate_types.iter(),\n+                                &n.as_str(),\n+                                None\n+                            );\n+                            if let Some(candidate) = lev_candidate {\n+                                session.buffer_lint_with_diagnostic(\n+                                    lint::builtin::UNKNOWN_CRATE_TYPES,\n+                                    ast::CRATE_NODE_ID,\n+                                    span,\n+                                    \"invalid `crate_type` value\",\n+                                    lint::builtin::BuiltinLintDiagnostics::\n+                                        UnknownCrateTypes(\n+                                            span,\n+                                            \"did you mean\".to_string(),\n+                                            format!(\"\\\"{}\\\"\", candidate)\n+                                        )\n+                                );\n+                            } else {\n+                                session.buffer_lint(\n+                                    lint::builtin::UNKNOWN_CRATE_TYPES,\n+                                    ast::CRATE_NODE_ID,\n+                                    span,\n+                                    \"invalid `crate_type` value\"\n+                                );\n+                            }\n+                        }\n                         None\n                     }\n                     _ => {"}, {"sha": "ff35371976aa49e3bdb024e1d2e928c5e6530ae0", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -309,7 +309,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn t_nil(&self) -> Ty<'tcx> {\n-        self.infcx.tcx.mk_nil()\n+        self.infcx.tcx.mk_unit()\n     }\n \n     pub fn t_pair(&self, ty1: Ty<'tcx>, ty2: Ty<'tcx>) -> Ty<'tcx> {"}, {"sha": "ff323073c6235eb40da49f36e75d1e4f82127827", "filename": "src/librustc_errors/lock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_errors%2Flock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_errors%2Flock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flock.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -109,7 +109,7 @@ pub fn acquire_global_lock(name: &str) -> Box<dyn Any> {\n     }\n }\n \n-#[cfg(unix)]\n+#[cfg(not(windows))]\n pub fn acquire_global_lock(_name: &str) -> Box<dyn Any> {\n     Box::new(())\n }"}, {"sha": "2bec9203e9ee5ff7021c1cd0830f83dd1d7fbba3", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -691,7 +691,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 }\n \n                 let sig = cx.erase_late_bound_regions(&sig);\n-                if !sig.output().is_nil() {\n+                if !sig.output().is_unit() {\n                     let r = self.check_type_for_ffi(cache, sig.output());\n                     match r {\n                         FfiSafe => {}\n@@ -767,7 +767,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n         if let hir::Return(ref ret_hir) = decl.output {\n             let ret_ty = sig.output();\n-            if !ret_ty.is_nil() {\n+            if !ret_ty.is_unit() {\n                 self.check_type_for_ffi_and_report_errors(ret_hir.span, ret_ty);\n             }\n         }"}, {"sha": "56b38cfbc872a2711e0b7912f27a556bdfdc7830", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -75,7 +75,7 @@ macro_rules! encoder_methods {\n impl<'a, 'tcx> Encoder for EncodeContext<'a, 'tcx> {\n     type Error = <opaque::Encoder as Encoder>::Error;\n \n-    fn emit_nil(&mut self) -> Result<(), Self::Error> {\n+    fn emit_unit(&mut self) -> Result<(), Self::Error> {\n         Ok(())\n     }\n "}, {"sha": "c4cb7958fd3c35865cf6eef19165b5c206227ff0", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -167,7 +167,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             // the case of `!`, no return value is required, as the block will never return.\n             let tcx = this.hir.tcx();\n             let ty = destination.ty(&this.local_decls, tcx).to_ty(tcx);\n-            if ty.is_nil() {\n+            if ty.is_unit() {\n                 // We only want to assign an implicit `()` as the return value of the block if the\n                 // block does not diverge. (Otherwise, we may try to assign a unit to a `!`-type.)\n                 this.cfg.push_assign_unit(block, source_info, destination);"}, {"sha": "4d4a89fca8b83b77023d08daad411e14c32ff178", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -118,7 +118,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn unit_ty(&mut self) -> Ty<'tcx> {\n-        self.tcx.mk_nil()\n+        self.tcx.mk_unit()\n     }\n \n     pub fn true_literal(&mut self) -> &'tcx ty::Const<'tcx> {"}, {"sha": "7ce96b1f62626340d9957b7c75221098efbf09c3", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -436,7 +436,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             layout: self.layout_of(self.tcx.mk_mut_ptr(place.layout.ty))?,\n         };\n \n-        let ty = self.tcx.mk_nil(); // return type is ()\n+        let ty = self.tcx.mk_unit(); // return type is ()\n         let dest = PlaceTy::null(&self, self.layout_of(ty)?);\n \n         self.eval_fn_call("}, {"sha": "3f5a05f9d0ed8381d0540cb1d84ca157e1344ac7", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -368,7 +368,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n \n                 output.push(')');\n \n-                if !sig.output().is_nil() {\n+                if !sig.output().is_unit() {\n                     output.push_str(\" -> \");\n                     self.push_type_name(sig.output(), output);\n                 }"}, {"sha": "01edfd2bfc9f220a63192f962b350900c9edfbd0", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -518,7 +518,7 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     let upvar_len = mir.upvar_decls.len();\n-    let dummy_local = LocalDecl::new_internal(tcx.mk_nil(), mir.span);\n+    let dummy_local = LocalDecl::new_internal(tcx.mk_unit(), mir.span);\n \n     // Gather live locals and their indices replacing values in mir.local_decls with a dummy\n     // to avoid changing local indices\n@@ -656,7 +656,7 @@ fn create_generator_drop_shim<'a, 'tcx>(\n     // Replace the return variable\n     mir.local_decls[RETURN_PLACE] = LocalDecl {\n         mutability: Mutability::Mut,\n-        ty: tcx.mk_nil(),\n+        ty: tcx.mk_unit(),\n         user_ty: None,\n         name: None,\n         source_info,"}, {"sha": "50bdc14d5099556e725c6054bf28a774bf6591b1", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -529,7 +529,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             mutbl: hir::Mutability::MutMutable\n         });\n         let ref_place = self.new_temp(ref_ty);\n-        let unit_temp = Place::Local(self.new_temp(tcx.mk_nil()));\n+        let unit_temp = Place::Local(self.new_temp(tcx.mk_unit()));\n \n         let result = BasicBlockData {\n             statements: vec![self.assign(\n@@ -891,7 +891,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         unwind: Unwind\n     ) -> BasicBlock {\n         let tcx = self.tcx();\n-        let unit_temp = Place::Local(self.new_temp(tcx.mk_nil()));\n+        let unit_temp = Place::Local(self.new_temp(tcx.mk_unit()));\n         let free_func = tcx.require_lang_item(lang_items::BoxFreeFnLangItem);\n         let args = adt.variants[0].fields.iter().enumerate().map(|(i, f)| {\n             let field = Field::new(i);"}, {"sha": "72502cda6e02d95491aa1d31abe5dd5eb54e19a2", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -1575,7 +1575,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n \n         let output_ty = match decl.output {\n             hir::Return(ref output) => self.ast_ty_to_ty(output),\n-            hir::DefaultReturn(..) => tcx.mk_nil(),\n+            hir::DefaultReturn(..) => tcx.mk_unit(),\n         };\n \n         debug!(\"ty_of_fn: output_ty={:?}\", output_ty);"}, {"sha": "0d2bc575401ef1733334a3cb4085083ffb4e7586", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -666,7 +666,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                 // us to give better error messages (pointing to a usually better\n                 // arm for inconsistent arms or to the whole match when a `()` type\n                 // is required).\n-                Expectation::ExpectHasType(ety) if ety != self.tcx.mk_nil() => ety,\n+                Expectation::ExpectHasType(ety) if ety != self.tcx.mk_unit() => ety,\n                 _ => self.next_ty_var(TypeVariableOrigin::MiscVariable(expr.span)),\n             };\n             CoerceMany::with_coercion_sites(coerce_first, arms)\n@@ -687,14 +687,14 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             // Handle the fallback arm of a desugared if-let like a missing else.\n             let is_if_let_fallback = match match_src {\n                 hir::MatchSource::IfLetDesugar { contains_else_clause: false } => {\n-                    i == arms.len() - 1 && arm_ty.is_nil()\n+                    i == arms.len() - 1 && arm_ty.is_unit()\n                 }\n                 _ => false\n             };\n \n             if is_if_let_fallback {\n                 let cause = self.cause(expr.span, ObligationCauseCode::IfExpressionWithNoElse);\n-                assert!(arm_ty.is_nil());\n+                assert!(arm_ty.is_unit());\n                 coercion.coerce_forced_unit(self, &cause, &mut |_| (), true);\n             } else {\n                 let cause = self.cause(expr.span, ObligationCauseCode::MatchExpressionArm {"}, {"sha": "9604eb3420fb3cc779a1f91735e8e1fd95933402", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -1077,7 +1077,7 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n         self.coerce_inner(fcx,\n                           cause,\n                           None,\n-                          fcx.tcx.mk_nil(),\n+                          fcx.tcx.mk_unit(),\n                           Some(augment_error),\n                           label_unit_as_expected)\n     }\n@@ -1146,8 +1146,8 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n             // `expression_ty` will be unit).\n             //\n             // Another example is `break` with no argument expression.\n-            assert!(expression_ty.is_nil());\n-            assert!(expression_ty.is_nil(), \"if let hack without unit type\");\n+            assert!(expression_ty.is_unit());\n+            assert!(expression_ty.is_unit(), \"if let hack without unit type\");\n             fcx.at(cause, fcx.param_env)\n                .eq_exp(label_expression_as_expected, expression_ty, self.merged_ty())\n                .map(|infer_ok| {"}, {"sha": "8215ae211c0b9285d940ccc9dcda665cd217bab0", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -94,15 +94,15 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             \"load\" => (1, vec![tcx.mk_imm_ptr(param(0))],\n                        param(0)),\n             \"store\" => (1, vec![tcx.mk_mut_ptr(param(0)), param(0)],\n-                        tcx.mk_nil()),\n+                        tcx.mk_unit()),\n \n             \"xchg\" | \"xadd\" | \"xsub\" | \"and\"  | \"nand\" | \"or\" | \"xor\" | \"max\" |\n             \"min\"  | \"umax\" | \"umin\" => {\n                 (1, vec![tcx.mk_mut_ptr(param(0)), param(0)],\n                  param(0))\n             }\n             \"fence\" | \"singlethreadfence\" => {\n-                (0, Vec::new(), tcx.mk_nil())\n+                (0, Vec::new(), tcx.mk_unit())\n             }\n             op => {\n                 struct_span_err!(tcx.sess, it.span, E0092,\n@@ -121,7 +121,7 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             _ => hir::Unsafety::Unsafe,\n         };\n         let (n_tps, inputs, output) = match &name[..] {\n-            \"breakpoint\" => (0, Vec::new(), tcx.mk_nil()),\n+            \"breakpoint\" => (0, Vec::new(), tcx.mk_unit()),\n             \"size_of\" |\n             \"pref_align_of\" | \"min_align_of\" => (1, Vec::new(), tcx.types.usize),\n             \"size_of_val\" |  \"min_align_of_val\" => {\n@@ -141,18 +141,18 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     tcx.mk_mut_ptr(param(0)),\n                     param(0)\n                   ],\n-               tcx.mk_nil())\n+               tcx.mk_unit())\n             }\n             \"prefetch_read_data\" | \"prefetch_write_data\" |\n             \"prefetch_read_instruction\" | \"prefetch_write_instruction\" => {\n                 (1, vec![tcx.mk_ptr(ty::TypeAndMut {\n                           ty: param(0),\n                           mutbl: hir::MutImmutable\n                          }), tcx.types.i32],\n-                    tcx.mk_nil())\n+                    tcx.mk_unit())\n             }\n             \"drop_in_place\" => {\n-                (1, vec![tcx.mk_mut_ptr(param(0))], tcx.mk_nil())\n+                (1, vec![tcx.mk_mut_ptr(param(0))], tcx.mk_unit())\n             }\n             \"needs_drop\" => (1, Vec::new(), tcx.types.bool),\n \n@@ -185,7 +185,7 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                   }),\n                   tcx.types.usize,\n                ],\n-               tcx.mk_nil())\n+               tcx.mk_unit())\n             }\n             \"volatile_copy_memory\" | \"volatile_copy_nonoverlapping_memory\" => {\n               (1,\n@@ -200,7 +200,7 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                   }),\n                   tcx.types.usize,\n                ],\n-               tcx.mk_nil())\n+               tcx.mk_unit())\n             }\n             \"write_bytes\" | \"volatile_set_memory\" => {\n               (1,\n@@ -212,7 +212,7 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                   tcx.types.u8,\n                   tcx.types.usize,\n                ],\n-               tcx.mk_nil())\n+               tcx.mk_unit())\n             }\n             \"sqrtf32\" => (0, vec![ tcx.types.f32 ], tcx.types.f32),\n             \"sqrtf64\" => (0, vec![ tcx.types.f64 ], tcx.types.f64),\n@@ -280,7 +280,7 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             \"volatile_load\" | \"unaligned_volatile_load\" =>\n                 (1, vec![ tcx.mk_imm_ptr(param(0)) ], param(0)),\n             \"volatile_store\" | \"unaligned_volatile_store\" =>\n-                (1, vec![ tcx.mk_mut_ptr(param(0)), param(0) ], tcx.mk_nil()),\n+                (1, vec![ tcx.mk_mut_ptr(param(0)), param(0) ], tcx.mk_unit()),\n \n             \"ctpop\" | \"ctlz\" | \"ctlz_nonzero\" | \"cttz\" | \"cttz_nonzero\" |\n             \"bswap\" | \"bitreverse\" =>\n@@ -300,7 +300,7 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             \"fadd_fast\" | \"fsub_fast\" | \"fmul_fast\" | \"fdiv_fast\" | \"frem_fast\" =>\n                 (1, vec![param(0), param(0)], param(0)),\n \n-            \"assume\" => (0, vec![tcx.types.bool], tcx.mk_nil()),\n+            \"assume\" => (0, vec![tcx.types.bool], tcx.mk_unit()),\n             \"likely\" => (0, vec![tcx.types.bool], tcx.types.bool),\n             \"unlikely\" => (0, vec![tcx.types.bool], tcx.types.bool),\n \n@@ -313,7 +313,7 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 let mut_u8 = tcx.mk_mut_ptr(tcx.types.u8);\n                 let fn_ty = ty::Binder::bind(tcx.mk_fn_sig(\n                     iter::once(mut_u8),\n-                    tcx.mk_nil(),\n+                    tcx.mk_unit(),\n                     false,\n                     hir::Unsafety::Normal,\n                     Abi::Rust,\n@@ -322,7 +322,7 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n \n             \"nontemporal_store\" => {\n-                (1, vec![ tcx.mk_mut_ptr(param(0)), param(0) ], tcx.mk_nil())\n+                (1, vec![ tcx.mk_mut_ptr(param(0)), param(0) ], tcx.mk_unit())\n             }\n \n             ref other => {\n@@ -376,7 +376,7 @@ pub fn check_platform_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             (3, vec![param(0), param(1), param(2)], param(0))\n         }\n         \"simd_scatter\" => {\n-            (3, vec![param(0), param(1), param(2)], tcx.mk_nil())\n+            (3, vec![param(0), param(1), param(2)], tcx.mk_unit())\n         }\n         \"simd_insert\" => (2, vec![param(0), tcx.types.u32, param(1)], param(0)),\n         \"simd_extract\" => (2, vec![param(0), tcx.types.u32], param(1)),"}, {"sha": "0305489b7079eadbf2b4b5aec32b3f6197a5164e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -2808,9 +2808,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         } else {\n             // is the missing argument of type `()`?\n             let sugg_unit = if expected_arg_tys.len() == 1 && supplied_arg_count == 0 {\n-                self.resolve_type_vars_if_possible(&expected_arg_tys[0]).is_nil()\n+                self.resolve_type_vars_if_possible(&expected_arg_tys[0]).is_unit()\n             } else if fn_inputs.len() == 1 && supplied_arg_count == 0 {\n-                self.resolve_type_vars_if_possible(&fn_inputs[0]).is_nil()\n+                self.resolve_type_vars_if_possible(&fn_inputs[0]).is_unit()\n             } else {\n                 false\n             };\n@@ -3918,7 +3918,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 for input in inputs {\n                     self.check_expr(input);\n                 }\n-                tcx.mk_nil()\n+                tcx.mk_unit()\n             }\n             hir::ExprKind::Break(destination, ref expr_opt) => {\n                 if let Ok(target_id) = destination.target_id {\n@@ -3945,7 +3945,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     } else {\n                         // Otherwise, this is a break *without* a value. That's\n                         // always legal, and is equivalent to `break ()`.\n-                        e_ty = tcx.mk_nil();\n+                        e_ty = tcx.mk_unit();\n                         cause = self.misc(expr.span);\n                     }\n \n@@ -3958,7 +3958,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         if let Some(ref e) = *expr_opt {\n                             coerce.coerce(self, &cause, e, e_ty);\n                         } else {\n-                            assert!(e_ty.is_nil());\n+                            assert!(e_ty.is_unit());\n                             coerce.coerce_forced_unit(self, &cause, &mut |_| (), true);\n                         }\n                     } else {\n@@ -4052,7 +4052,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if lhs_ty.references_error() || rhs_ty.references_error() {\n                     tcx.types.err\n                 } else {\n-                    tcx.mk_nil()\n+                    tcx.mk_unit()\n                 }\n             }\n             hir::ExprKind::If(ref cond, ref then_expr, ref opt_else_expr) => {\n@@ -4081,7 +4081,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     self.diverges.set(Diverges::Maybe);\n                 }\n \n-                self.tcx.mk_nil()\n+                self.tcx.mk_unit()\n             }\n             hir::ExprKind::Loop(ref body, _, source) => {\n                 let coerce = match source {\n@@ -4121,7 +4121,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // [1]\n                     self.tcx.sess.delay_span_bug(body.span, \"no coercion, but loop may not break\");\n                 }\n-                ctxt.coerce.map(|c| c.complete(self)).unwrap_or(self.tcx.mk_nil())\n+                ctxt.coerce.map(|c| c.complete(self)).unwrap_or(self.tcx.mk_unit())\n             }\n             hir::ExprKind::Match(ref discrim, ref arms, match_src) => {\n                 self.check_match(expr, &discrim, arms, expected, match_src)\n@@ -4352,7 +4352,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                         \"yield statement outside of generator literal\").emit();\n                     }\n                 }\n-                tcx.mk_nil()\n+                tcx.mk_unit()\n             }\n         }\n     }\n@@ -4516,7 +4516,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n             hir::StmtKind::Expr(ref expr, _) => {\n                 // Check with expected type of ()\n-                self.check_expr_has_type_or_error(&expr, self.tcx.mk_nil());\n+                self.check_expr_has_type_or_error(&expr, self.tcx.mk_unit());\n             }\n             hir::StmtKind::Semi(ref expr, _) => {\n                 self.check_expr(&expr);\n@@ -4529,7 +4529,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn check_block_no_value(&self, blk: &'gcx hir::Block)  {\n-        let unit = self.tcx.mk_nil();\n+        let unit = self.tcx.mk_unit();\n         let ty = self.check_block_with_expected(blk, ExpectHasType(unit));\n \n         // if the block produces a `!` value, that can always be\n@@ -4752,7 +4752,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                  expression: &'gcx hir::Expr,\n                                  expected: Ty<'tcx>,\n                                  cause_span: Span) {\n-        if expected.is_nil() {\n+        if expected.is_unit() {\n             // `BlockTailExpression` only relevant if the tail expr would be\n             // useful on its own.\n             match expression.node {\n@@ -4795,7 +4795,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                    can_suggest: bool) {\n         // Only suggest changing the return type for methods that\n         // haven't set a return type at all (and aren't `fn main()` or an impl).\n-        match (&fn_decl.output, found.is_suggestable(), can_suggest, expected.is_nil()) {\n+        match (&fn_decl.output, found.is_suggestable(), can_suggest, expected.is_unit()) {\n             (&hir::FunctionRetTy::DefaultReturn(span), true, true, true) => {\n                 err.span_suggestion_with_applicability(\n                     span,"}, {"sha": "5004880ce47b8bb1967176633a8600a43c4e9e9b", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -35,7 +35,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let ty = if !lhs_ty.is_ty_var() && !rhs_ty.is_ty_var()\n                     && is_builtin_binop(lhs_ty, rhs_ty, op) {\n             self.enforce_builtin_binop_types(lhs_expr, lhs_ty, rhs_expr, rhs_ty, op);\n-            self.tcx.mk_nil()\n+            self.tcx.mk_unit()\n         } else {\n             return_ty\n         };"}, {"sha": "c9aa0339dd469f8fc00c2b7358218fbe41940861", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -224,7 +224,7 @@ fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 actual.output().skip_binder()\n             } else {\n                 // standard () main return type\n-                tcx.mk_nil()\n+                tcx.mk_unit()\n             };\n \n             let se_ty = tcx.mk_fn_ptr(ty::Binder::bind("}, {"sha": "9439dc78d3ca447029f0ce336d689d6d83c4c6a0", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -490,7 +490,7 @@ macro_rules! emit_enquoted_if_mapkey {\n impl<'a> ::Encoder for Encoder<'a> {\n     type Error = EncoderError;\n \n-    fn emit_nil(&mut self) -> EncodeResult {\n+    fn emit_unit(&mut self) -> EncodeResult {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         write!(self.writer, \"null\")?;\n         Ok(())\n@@ -648,7 +648,7 @@ impl<'a> ::Encoder for Encoder<'a> {\n     }\n     fn emit_option_none(&mut self) -> EncodeResult {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n-        self.emit_nil()\n+        self.emit_unit()\n     }\n     fn emit_option_some<F>(&mut self, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n@@ -740,7 +740,7 @@ impl<'a> PrettyEncoder<'a> {\n impl<'a> ::Encoder for PrettyEncoder<'a> {\n     type Error = EncoderError;\n \n-    fn emit_nil(&mut self) -> EncodeResult {\n+    fn emit_unit(&mut self) -> EncodeResult {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         write!(self.writer, \"null\")?;\n         Ok(())\n@@ -923,7 +923,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n     }\n     fn emit_option_none(&mut self) -> EncodeResult {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n-        self.emit_nil()\n+        self.emit_unit()\n     }\n     fn emit_option_some<F>(&mut self, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n@@ -1016,7 +1016,7 @@ impl Encodable for Json {\n             Json::Boolean(v) => v.encode(e),\n             Json::Array(ref v) => v.encode(e),\n             Json::Object(ref v) => v.encode(e),\n-            Json::Null => e.emit_nil(),\n+            Json::Null => e.emit_unit(),\n         }\n     }\n }"}, {"sha": "4ce80bc36a080a44ce6b693d283a8f9fe043077e", "filename": "src/libserialize/opaque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibserialize%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibserialize%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fopaque.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -55,7 +55,7 @@ impl serialize::Encoder for Encoder {\n     type Error = !;\n \n     #[inline]\n-    fn emit_nil(&mut self) -> EncodeResult {\n+    fn emit_unit(&mut self) -> EncodeResult {\n         Ok(())\n     }\n "}, {"sha": "f0b49c3d9bc8faec0db174a40eeafe0f555e8d70", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -25,7 +25,7 @@ pub trait Encoder {\n     type Error;\n \n     // Primitive types:\n-    fn emit_nil(&mut self) -> Result<(), Self::Error>;\n+    fn emit_unit(&mut self) -> Result<(), Self::Error>;\n     fn emit_usize(&mut self, v: usize) -> Result<(), Self::Error>;\n     fn emit_u128(&mut self, v: u128) -> Result<(), Self::Error>;\n     fn emit_u64(&mut self, v: u64) -> Result<(), Self::Error>;\n@@ -537,7 +537,7 @@ impl Decodable for char {\n \n impl Encodable for () {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_nil()\n+        s.emit_unit()\n     }\n }\n "}, {"sha": "ef5dae724b247eef53a77abd52376d286f76c621", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -3532,12 +3532,11 @@ mod test_map {\n             m.insert(x, ());\n         }\n \n-        for i in 0..1000 {\n+        for _ in 0..1000 {\n             let x = rng.gen_range(-10, 10);\n             match m.entry(x) {\n                 Vacant(_) => {}\n                 Occupied(e) => {\n-                    println!(\"{}: remove {}\", i, x);\n                     e.remove();\n                 }\n             }"}, {"sha": "237af2f04e59d5fe9ad183e005a1adad09a2d42d", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -420,14 +420,14 @@ impl PartialEq<OsString> for str {\n     }\n }\n \n-#[stable(feature = \"os_str_str_ref_eq\", since = \"1.28.0\")]\n+#[stable(feature = \"os_str_str_ref_eq\", since = \"1.29.0\")]\n impl<'a> PartialEq<&'a str> for OsString {\n     fn eq(&self, other: &&'a str) -> bool {\n         **self == **other\n     }\n }\n \n-#[stable(feature = \"os_str_str_ref_eq\", since = \"1.28.0\")]\n+#[stable(feature = \"os_str_str_ref_eq\", since = \"1.29.0\")]\n impl<'a> PartialEq<OsString> for &'a str {\n     fn eq(&self, other: &OsString) -> bool {\n         **other == **self"}, {"sha": "4c1fdc4f895386a605a7c3fd6e615b727392c1f1", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -250,6 +250,7 @@ mod prim_bool { }\n /// [`Default`]: default/trait.Default.html\n /// [`default()`]: default/trait.Default.html#tymethod.default\n ///\n+#[unstable(feature = \"never_type\", issue = \"35121\")]\n mod prim_never { }\n \n #[doc(primitive = \"char\")]"}, {"sha": "e7f4e32dc7c41b17a757858e2e9b1ea6aa51ef7d", "filename": "src/test/ui/invalid/invalid-crate-type.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Ftest%2Fui%2Finvalid%2Finvalid-crate-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Ftest%2Fui%2Finvalid%2Finvalid-crate-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid%2Finvalid-crate-type.rs?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -11,6 +11,48 @@\n // regression test for issue 11256\n #![crate_type=\"foo\"]    //~ ERROR invalid `crate_type` value\n \n+// Tests for suggestions (#53958)\n+\n+#![crate_type=\"statoclib\"]\n+//~^ ERROR invalid `crate_type` value\n+//~| HELP did you mean\n+//~| SUGGESTION staticlib\n+\n+#![crate_type=\"procmacro\"]\n+//~^ ERROR invalid `crate_type` value\n+//~| HELP did you mean\n+//~| SUGGESTION proc-macro\n+\n+#![crate_type=\"static-lib\"]\n+//~^ ERROR invalid `crate_type` value\n+//~| HELP did you mean\n+//~| SUGGESTION staticlib\n+\n+#![crate_type=\"drylib\"]\n+//~^ ERROR invalid `crate_type` value\n+//~| HELP did you mean\n+//~| SUGGESTION dylib\n+\n+#![crate_type=\"dlib\"]\n+//~^ ERROR invalid `crate_type` value\n+//~| HELP did you mean\n+//~| SUGGESTION rlib\n+\n+#![crate_type=\"lob\"]\n+//~^ ERROR invalid `crate_type` value\n+//~| HELP did you mean\n+//~| SUGGESTION lib\n+\n+#![crate_type=\"bon\"]\n+//~^ ERROR invalid `crate_type` value\n+//~| HELP did you mean\n+//~| SUGGESTION bin\n+\n+#![crate_type=\"cdalib\"]\n+//~^ ERROR invalid `crate_type` value\n+//~| HELP did you mean\n+//~| SUGGESTION cdylib\n+\n fn main() {\n     return\n }"}, {"sha": "c82da865f33531b135ae8b628638220a0f378175", "filename": "src/test/ui/invalid/invalid-crate-type.stderr", "status": "modified", "additions": 51, "deletions": 3, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Ftest%2Fui%2Finvalid%2Finvalid-crate-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fccde0018a618eb6f45d2a3c97f629809994dff6/src%2Ftest%2Fui%2Finvalid%2Finvalid-crate-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid%2Finvalid-crate-type.stderr?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -1,10 +1,58 @@\n error: invalid `crate_type` value\n-  --> $DIR/invalid-crate-type.rs:12:1\n+  --> $DIR/invalid-crate-type.rs:12:15\n    |\n LL | #![crate_type=\"foo\"]    //~ ERROR invalid `crate_type` value\n-   | ^^^^^^^^^^^^^^^^^^^^\n+   |               ^^^^^\n    |\n    = note: #[deny(unknown_crate_types)] on by default\n \n-error: aborting due to previous error\n+error: invalid `crate_type` value\n+  --> $DIR/invalid-crate-type.rs:16:15\n+   |\n+LL | #![crate_type=\"statoclib\"]\n+   |               ^^^^^^^^^^^ help: did you mean: `\"staticlib\"`\n+\n+error: invalid `crate_type` value\n+  --> $DIR/invalid-crate-type.rs:21:15\n+   |\n+LL | #![crate_type=\"procmacro\"]\n+   |               ^^^^^^^^^^^ help: did you mean: `\"proc-macro\"`\n+\n+error: invalid `crate_type` value\n+  --> $DIR/invalid-crate-type.rs:26:15\n+   |\n+LL | #![crate_type=\"static-lib\"]\n+   |               ^^^^^^^^^^^^ help: did you mean: `\"staticlib\"`\n+\n+error: invalid `crate_type` value\n+  --> $DIR/invalid-crate-type.rs:31:15\n+   |\n+LL | #![crate_type=\"drylib\"]\n+   |               ^^^^^^^^ help: did you mean: `\"dylib\"`\n+\n+error: invalid `crate_type` value\n+  --> $DIR/invalid-crate-type.rs:36:15\n+   |\n+LL | #![crate_type=\"dlib\"]\n+   |               ^^^^^^ help: did you mean: `\"rlib\"`\n+\n+error: invalid `crate_type` value\n+  --> $DIR/invalid-crate-type.rs:41:15\n+   |\n+LL | #![crate_type=\"lob\"]\n+   |               ^^^^^ help: did you mean: `\"lib\"`\n+\n+error: invalid `crate_type` value\n+  --> $DIR/invalid-crate-type.rs:46:15\n+   |\n+LL | #![crate_type=\"bon\"]\n+   |               ^^^^^ help: did you mean: `\"bin\"`\n+\n+error: invalid `crate_type` value\n+  --> $DIR/invalid-crate-type.rs:51:15\n+   |\n+LL | #![crate_type=\"cdalib\"]\n+   |               ^^^^^^^^ help: did you mean: `\"cdylib\"`\n+\n+error: aborting due to 9 previous errors\n "}, {"sha": "a5d82949485802abb45f888d5b8b7f23927f031d", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=fccde0018a618eb6f45d2a3c97f629809994dff6", "patch": "@@ -1 +1 @@\n-Subproject commit b917e35248fe57d11765c5a835de33e335babb7e\n+Subproject commit a5d82949485802abb45f888d5b8b7f23927f031d"}]}