{"sha": "4fd742d6bc23e2f61d0980e15234f09d7e715b76", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmZDc0MmQ2YmMyM2UyZjYxZDA5ODBlMTUyMzRmMDlkN2U3MTViNzY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-11-03T21:34:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-03T21:34:50Z"}, "message": "Merge #2163\n\n2163: Move CrateDefMap to hir_def r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "c37d38f9313f54ea71580f6bd005f554388a57ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c37d38f9313f54ea71580f6bd005f554388a57ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4fd742d6bc23e2f61d0980e15234f09d7e715b76", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdv0f6CRBK7hj4Ov3rIwAAdHIIAJ6HfLrKluCIUoWsocR/tTSz\nciO7ZvAEIC/20pi/cCld4MVDOPzC+gxLJ23SJsvp+9YVNt0LjtdRodZNzFOde1/H\n/wqzoewxBcIuoKvx8/YtRTQAK/m+vhO/Wg6CYhkfKaLsFUOOAKmuFBBtvMTYV2dk\nivmAioEv6II2t5UIWP1rilO8mttvODnjxBu3H6Vl5K1IhpfOiHEWXOFTdexrAJ5e\n1HhK+jfEhVlsiHRGK0qVHmQx0yArHA9UtW+Ms4OYqYYjVidqhDyvvGald6f1hoE2\nQ7sN2ZYQKO1fiaqF/z9YX1H+Lr9e9Szqx9G2rDIeODZxNZZxYQBMd//GQsLooxU=\n=KVo/\n-----END PGP SIGNATURE-----\n", "payload": "tree c37d38f9313f54ea71580f6bd005f554388a57ab\nparent f9f1effd011b906903891c09f1cb6b2a42f73e95\nparent 8922a44395482896fec0c0a47a7fac4612112d45\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1572816890 +0000\ncommitter GitHub <noreply@github.com> 1572816890 +0000\n\nMerge #2163\n\n2163: Move CrateDefMap to hir_def r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4fd742d6bc23e2f61d0980e15234f09d7e715b76", "html_url": "https://github.com/rust-lang/rust/commit/4fd742d6bc23e2f61d0980e15234f09d7e715b76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4fd742d6bc23e2f61d0980e15234f09d7e715b76/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9f1effd011b906903891c09f1cb6b2a42f73e95", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9f1effd011b906903891c09f1cb6b2a42f73e95", "html_url": "https://github.com/rust-lang/rust/commit/f9f1effd011b906903891c09f1cb6b2a42f73e95"}, {"sha": "8922a44395482896fec0c0a47a7fac4612112d45", "url": "https://api.github.com/repos/rust-lang/rust/commits/8922a44395482896fec0c0a47a7fac4612112d45", "html_url": "https://github.com/rust-lang/rust/commit/8922a44395482896fec0c0a47a7fac4612112d45"}], "stats": {"total": 2278, "additions": 1295, "deletions": 983}, "files": [{"sha": "889820c9961295992b2d2219b728750567ad4991", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -985,6 +985,7 @@ dependencies = [\n  \"relative-path 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"salsa 0.13.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"test_utils 0.1.0\",\n ]\n \n [[package]]\n@@ -1027,6 +1028,7 @@ dependencies = [\n name = \"ra_hir_def\"\n version = \"0.1.0\"\n dependencies = [\n+ \"insta 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"once_cell 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_arena 0.1.0\","}, {"sha": "bf1f7920c583d8dfe92f2f400f52fa62f6bed961", "filename": "crates/ra_db/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2FCargo.toml?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -12,3 +12,4 @@ rustc-hash = \"1.0\"\n ra_syntax = { path = \"../ra_syntax\" }\n ra_cfg = { path = \"../ra_cfg\" }\n ra_prof = { path = \"../ra_prof\" }\n+test_utils = { path = \"../test_utils\" }"}, {"sha": "f5dd59f8401134fa96adb9895f93c4b9ae14b033", "filename": "crates/ra_db/src/fixture.rs", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Ffixture.rs?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -0,0 +1,186 @@\n+//! FIXME: write short doc here\n+\n+use std::sync::Arc;\n+\n+use ra_cfg::CfgOptions;\n+use rustc_hash::FxHashMap;\n+use test_utils::{extract_offset, parse_fixture, CURSOR_MARKER};\n+\n+use crate::{\n+    CrateGraph, Edition, FileId, FilePosition, RelativePathBuf, SourceDatabaseExt, SourceRoot,\n+    SourceRootId,\n+};\n+\n+pub const WORKSPACE: SourceRootId = SourceRootId(0);\n+\n+pub trait WithFixture: Default + SourceDatabaseExt + 'static {\n+    fn with_single_file(text: &str) -> (Self, FileId) {\n+        let mut db = Self::default();\n+        let file_id = with_single_file(&mut db, text);\n+        (db, file_id)\n+    }\n+\n+    fn with_files(fixture: &str) -> Self {\n+        let mut db = Self::default();\n+        let pos = with_files(&mut db, fixture);\n+        assert!(pos.is_none());\n+        db\n+    }\n+\n+    fn with_position(fixture: &str) -> (Self, FilePosition) {\n+        let mut db = Self::default();\n+        let pos = with_files(&mut db, fixture);\n+        (db, pos.unwrap())\n+    }\n+}\n+\n+impl<DB: SourceDatabaseExt + Default + 'static> WithFixture for DB {}\n+\n+fn with_single_file(db: &mut dyn SourceDatabaseExt, text: &str) -> FileId {\n+    let file_id = FileId(0);\n+    let rel_path: RelativePathBuf = \"/main.rs\".into();\n+\n+    let mut source_root = SourceRoot::default();\n+    source_root.insert_file(rel_path.clone(), file_id);\n+\n+    let mut crate_graph = CrateGraph::default();\n+    crate_graph.add_crate_root(file_id, Edition::Edition2018, CfgOptions::default());\n+\n+    db.set_file_text(file_id, Arc::new(text.to_string()));\n+    db.set_file_relative_path(file_id, rel_path);\n+    db.set_file_source_root(file_id, WORKSPACE);\n+    db.set_source_root(WORKSPACE, Arc::new(source_root));\n+    db.set_crate_graph(Arc::new(crate_graph));\n+\n+    file_id\n+}\n+\n+fn with_files(db: &mut dyn SourceDatabaseExt, fixture: &str) -> Option<FilePosition> {\n+    let fixture = parse_fixture(fixture);\n+\n+    let mut crate_graph = CrateGraph::default();\n+    let mut crates = FxHashMap::default();\n+    let mut crate_deps = Vec::new();\n+    let mut default_crate_root: Option<FileId> = None;\n+\n+    let mut source_root = SourceRoot::default();\n+    let mut source_root_id = WORKSPACE;\n+    let mut source_root_prefix: RelativePathBuf = \"/\".into();\n+    let mut file_id = FileId(0);\n+\n+    let mut file_position = None;\n+\n+    for entry in fixture.iter() {\n+        let meta = match parse_meta(&entry.meta) {\n+            ParsedMeta::Root { path } => {\n+                let source_root = std::mem::replace(&mut source_root, SourceRoot::default());\n+                db.set_source_root(source_root_id, Arc::new(source_root));\n+                source_root_id.0 += 1;\n+                source_root_prefix = path;\n+                continue;\n+            }\n+            ParsedMeta::File(it) => it,\n+        };\n+        assert!(meta.path.starts_with(&source_root_prefix));\n+\n+        if let Some(krate) = meta.krate {\n+            let crate_id = crate_graph.add_crate_root(file_id, meta.edition, meta.cfg);\n+            let prev = crates.insert(krate.clone(), crate_id);\n+            assert!(prev.is_none());\n+            for dep in meta.deps {\n+                crate_deps.push((krate.clone(), dep))\n+            }\n+        } else if meta.path == \"/main.rs\" || meta.path == \"/lib.rs\" {\n+            assert!(default_crate_root.is_none());\n+            default_crate_root = Some(file_id);\n+        }\n+\n+        let text = if entry.text.contains(CURSOR_MARKER) {\n+            let (offset, text) = extract_offset(&entry.text);\n+            assert!(file_position.is_none());\n+            file_position = Some(FilePosition { file_id, offset });\n+            text.to_string()\n+        } else {\n+            entry.text.to_string()\n+        };\n+\n+        db.set_file_text(file_id, Arc::new(text));\n+        db.set_file_relative_path(file_id, meta.path.clone());\n+        db.set_file_source_root(file_id, source_root_id);\n+        source_root.insert_file(meta.path, file_id);\n+\n+        file_id.0 += 1;\n+    }\n+\n+    if crates.is_empty() {\n+        let crate_root = default_crate_root.unwrap();\n+        crate_graph.add_crate_root(crate_root, Edition::Edition2018, CfgOptions::default());\n+    } else {\n+        for (from, to) in crate_deps {\n+            let from_id = crates[&from];\n+            let to_id = crates[&to];\n+            crate_graph.add_dep(from_id, to.into(), to_id).unwrap();\n+        }\n+    }\n+\n+    db.set_source_root(source_root_id, Arc::new(source_root));\n+    db.set_crate_graph(Arc::new(crate_graph));\n+\n+    file_position\n+}\n+\n+enum ParsedMeta {\n+    Root { path: RelativePathBuf },\n+    File(FileMeta),\n+}\n+\n+struct FileMeta {\n+    path: RelativePathBuf,\n+    krate: Option<String>,\n+    deps: Vec<String>,\n+    cfg: CfgOptions,\n+    edition: Edition,\n+}\n+\n+//- /lib.rs crate:foo deps:bar,baz\n+fn parse_meta(meta: &str) -> ParsedMeta {\n+    let components = meta.split_ascii_whitespace().collect::<Vec<_>>();\n+\n+    if components[0] == \"root\" {\n+        let path: RelativePathBuf = components[1].into();\n+        assert!(path.starts_with(\"/\") && path.ends_with(\"/\"));\n+        return ParsedMeta::Root { path };\n+    }\n+\n+    let path: RelativePathBuf = components[0].into();\n+    assert!(path.starts_with(\"/\"));\n+\n+    let mut krate = None;\n+    let mut deps = Vec::new();\n+    let mut edition = Edition::Edition2018;\n+    let mut cfg = CfgOptions::default();\n+    for component in components[1..].iter() {\n+        let (key, value) = split1(component, ':').unwrap();\n+        match key {\n+            \"crate\" => krate = Some(value.to_string()),\n+            \"deps\" => deps = value.split(',').map(|it| it.to_string()).collect(),\n+            \"edition\" => edition = Edition::from_string(&value),\n+            \"cfg\" => {\n+                for key in value.split(',') {\n+                    match split1(key, '=') {\n+                        None => cfg.insert_atom(key.into()),\n+                        Some((k, v)) => cfg.insert_key_value(k.into(), v.into()),\n+                    }\n+                }\n+            }\n+            _ => panic!(\"bad component: {:?}\", component),\n+        }\n+    }\n+\n+    ParsedMeta::File(FileMeta { path, krate, deps, edition, cfg })\n+}\n+\n+fn split1(haystack: &str, delim: char) -> Option<(&str, &str)> {\n+    let idx = haystack.find(delim)?;\n+    Some((&haystack[..idx], &haystack[idx + delim.len_utf8()..]))\n+}"}, {"sha": "7c8dac1d38daae7f43a40618d93a2c996c1d1923", "filename": "crates/ra_db/src/input.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Finput.rs?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -97,6 +97,7 @@ pub enum Edition {\n }\n \n impl Edition {\n+    //FIXME: replace with FromStr with proper error handling\n     pub fn from_string(s: &str) -> Edition {\n         match s {\n             \"2015\" => Edition::Edition2015,"}, {"sha": "b6bfd531de934029e4c19f81c8110ad0291735f1", "filename": "crates/ra_db/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -1,17 +1,18 @@\n //! ra_db defines basic database traits. The concrete DB is defined by ra_ide_api.\n mod cancellation;\n mod input;\n+pub mod fixture;\n \n use std::{panic, sync::Arc};\n \n use ra_prof::profile;\n use ra_syntax::{ast, Parse, SourceFile, TextRange, TextUnit};\n-use relative_path::{RelativePath, RelativePathBuf};\n \n pub use crate::{\n     cancellation::Canceled,\n     input::{CrateGraph, CrateId, Dependency, Edition, FileId, SourceRoot, SourceRootId},\n };\n+pub use relative_path::{RelativePath, RelativePathBuf};\n pub use salsa;\n \n pub trait CheckCanceled {"}, {"sha": "181c5d47afebd559a1c83dc071702331887fc3f9", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -9,7 +9,7 @@ use hir_def::{\n     adt::VariantData,\n     builtin_type::BuiltinType,\n     type_ref::{Mutability, TypeRef},\n-    CrateModuleId, LocalEnumVariantId, LocalStructFieldId, ModuleId,\n+    CrateModuleId, LocalEnumVariantId, LocalStructFieldId, ModuleId, UnionId,\n };\n use hir_expand::{\n     diagnostics::DiagnosticSink,\n@@ -28,11 +28,10 @@ use crate::{\n         TypeAliasId,\n     },\n     impl_block::ImplBlock,\n-    nameres::{ImportId, ModuleScope, Namespace},\n     resolve::{Resolver, Scope, TypeNs},\n     traits::TraitData,\n     ty::{InferenceResult, TraitRef},\n-    Either, HasSource, Name, Ty,\n+    Either, HasSource, Name, ScopeDef, Ty, {ImportId, Namespace},\n };\n \n /// hir::Crate describes a single crate. It's the main interface with which\n@@ -66,7 +65,7 @@ impl Crate {\n     }\n \n     pub fn root_module(self, db: &impl DefDatabase) -> Option<Module> {\n-        let module_id = db.crate_def_map(self).root();\n+        let module_id = db.crate_def_map(self.crate_id).root();\n         Some(Module::new(self, module_id))\n     }\n \n@@ -120,7 +119,7 @@ impl Module {\n \n     /// Name of this module.\n     pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n-        let def_map = db.crate_def_map(self.krate());\n+        let def_map = db.crate_def_map(self.id.krate);\n         let parent = def_map[self.id.module_id].parent?;\n         def_map[parent].children.iter().find_map(|(name, module_id)| {\n             if *module_id == self.id.module_id {\n@@ -151,20 +150,20 @@ impl Module {\n     /// might be missing `krate`. This can happen if a module's file is not included\n     /// in the module tree of any target in `Cargo.toml`.\n     pub fn crate_root(self, db: &impl DefDatabase) -> Module {\n-        let def_map = db.crate_def_map(self.krate());\n+        let def_map = db.crate_def_map(self.id.krate);\n         self.with_module_id(def_map.root())\n     }\n \n     /// Finds a child module with the specified name.\n     pub fn child(self, db: &impl HirDatabase, name: &Name) -> Option<Module> {\n-        let def_map = db.crate_def_map(self.krate());\n+        let def_map = db.crate_def_map(self.id.krate);\n         let child_id = def_map[self.id.module_id].children.get(name)?;\n         Some(self.with_module_id(*child_id))\n     }\n \n     /// Iterates over all child modules.\n     pub fn children(self, db: &impl DefDatabase) -> impl Iterator<Item = Module> {\n-        let def_map = db.crate_def_map(self.krate());\n+        let def_map = db.crate_def_map(self.id.krate);\n         let children = def_map[self.id.module_id]\n             .children\n             .iter()\n@@ -175,7 +174,7 @@ impl Module {\n \n     /// Finds a parent module.\n     pub fn parent(self, db: &impl DefDatabase) -> Option<Module> {\n-        let def_map = db.crate_def_map(self.krate());\n+        let def_map = db.crate_def_map(self.id.krate);\n         let parent_id = def_map[self.id.module_id].parent?;\n         Some(self.with_module_id(parent_id))\n     }\n@@ -191,12 +190,16 @@ impl Module {\n     }\n \n     /// Returns a `ModuleScope`: a set of items, visible in this module.\n-    pub fn scope(self, db: &impl HirDatabase) -> ModuleScope {\n-        db.crate_def_map(self.krate())[self.id.module_id].scope.clone()\n+    pub fn scope(self, db: &impl HirDatabase) -> Vec<(Name, ScopeDef, Option<ImportId>)> {\n+        db.crate_def_map(self.id.krate)[self.id.module_id]\n+            .scope\n+            .entries()\n+            .map(|(name, res)| (name.clone(), res.def.into(), res.import))\n+            .collect()\n     }\n \n     pub fn diagnostics(self, db: &impl HirDatabase, sink: &mut DiagnosticSink) {\n-        db.crate_def_map(self.krate()).add_diagnostics(db, self.id.module_id, sink);\n+        db.crate_def_map(self.id.krate).add_diagnostics(db, self.id.module_id, sink);\n         for decl in self.declarations(db) {\n             match decl {\n                 crate::ModuleDef::Function(f) => f.diagnostics(db, sink),\n@@ -220,19 +223,20 @@ impl Module {\n     }\n \n     pub(crate) fn resolver(self, db: &impl DefDatabase) -> Resolver {\n-        let def_map = db.crate_def_map(self.krate());\n+        let def_map = db.crate_def_map(self.id.krate);\n         Resolver::default().push_module_scope(def_map, self.id.module_id)\n     }\n \n     pub fn declarations(self, db: &impl DefDatabase) -> Vec<ModuleDef> {\n-        let def_map = db.crate_def_map(self.krate());\n+        let def_map = db.crate_def_map(self.id.krate);\n         def_map[self.id.module_id]\n             .scope\n             .entries()\n             .filter_map(|(_name, res)| if res.import.is_none() { Some(res.def) } else { None })\n             .flat_map(|per_ns| {\n                 per_ns.take_types().into_iter().chain(per_ns.take_values().into_iter())\n             })\n+            .map(ModuleDef::from)\n             .collect()\n     }\n \n@@ -336,12 +340,12 @@ impl Struct {\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Union {\n-    pub(crate) id: StructId,\n+    pub(crate) id: UnionId,\n }\n \n impl Union {\n     pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n-        db.struct_data(self.id).name.clone()\n+        db.union_data(self.id).name.clone()\n     }\n \n     pub fn module(self, db: &impl HirDatabase) -> Module {"}, {"sha": "6d116ee75c908f25391304922e7dd6dfac936ae4", "filename": "crates/ra_hir/src/code_model/src.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -22,7 +22,7 @@ pub trait HasSource {\n impl Module {\n     /// Returns a node which defines this module. That is, a file or a `mod foo {}` with items.\n     pub fn definition_source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ModuleSource> {\n-        let def_map = db.crate_def_map(self.krate());\n+        let def_map = db.crate_def_map(self.id.krate);\n         let decl_id = def_map[self.id.module_id].declaration;\n         let file_id = def_map[self.id.module_id].definition;\n         let ast = ModuleSource::new(db, file_id, decl_id);\n@@ -36,7 +36,7 @@ impl Module {\n         self,\n         db: &(impl DefDatabase + AstDatabase),\n     ) -> Option<Source<ast::Module>> {\n-        let def_map = db.crate_def_map(self.krate());\n+        let def_map = db.crate_def_map(self.id.krate);\n         let decl = def_map[self.id.module_id].declaration?;\n         let ast = decl.to_node(db);\n         Some(Source { file_id: decl.file_id(), ast })"}, {"sha": "eb66325f7f12624f32ba8650306386125424b0f4", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -11,20 +11,19 @@ use crate::{\n     ids,\n     impl_block::{ImplBlock, ImplSourceMap, ModuleImplBlocks},\n     lang_item::{LangItemTarget, LangItems},\n-    nameres::{CrateDefMap, Namespace},\n     traits::TraitData,\n     ty::{\n         method_resolution::CrateImplBlocks, traits::Impl, CallableDef, FnSig, GenericPredicate,\n         InferenceResult, Substs, Ty, TypableDef, TypeCtor,\n     },\n     type_alias::TypeAliasData,\n-    Const, ConstData, Crate, DefWithBody, ExprScopes, FnData, Function, Module, Static,\n+    Const, ConstData, Crate, DefWithBody, ExprScopes, FnData, Function, Module, Namespace, Static,\n     StructField, Trait, TypeAlias,\n };\n \n pub use hir_def::db::{\n-    DefDatabase2, DefDatabase2Storage, EnumDataQuery, InternDatabase, InternDatabaseStorage,\n-    RawItemsQuery, RawItemsWithSourceMapQuery, StructDataQuery,\n+    CrateDefMapQuery, DefDatabase2, DefDatabase2Storage, EnumDataQuery, InternDatabase,\n+    InternDatabaseStorage, RawItemsQuery, RawItemsWithSourceMapQuery, StructDataQuery,\n };\n pub use hir_expand::db::{\n     AstDatabase, AstDatabaseStorage, AstIdMapQuery, MacroArgQuery, MacroDefQuery, MacroExpandQuery,\n@@ -41,9 +40,6 @@ pub trait DefDatabase: HirDebugDatabase + DefDatabase2 {\n     #[salsa::invoke(crate::traits::TraitItemsIndex::trait_items_index)]\n     fn trait_items_index(&self, module: Module) -> crate::traits::TraitItemsIndex;\n \n-    #[salsa::invoke(CrateDefMap::crate_def_map_query)]\n-    fn crate_def_map(&self, krate: Crate) -> Arc<CrateDefMap>;\n-\n     #[salsa::invoke(ModuleImplBlocks::impls_in_module_with_source_map_query)]\n     fn impls_in_module_with_source_map(\n         &self,"}, {"sha": "1751e7be33a28a4a709d462847112bb0625dda9f", "filename": "crates/ra_hir/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -3,10 +3,10 @@\n use std::any::Any;\n \n use ra_syntax::{ast, AstNode, AstPtr, SyntaxNodePtr};\n-use relative_path::RelativePathBuf;\n \n use crate::{db::AstDatabase, HirFileId, Name, Source};\n \n+pub use hir_def::diagnostics::UnresolvedModule;\n pub use hir_expand::diagnostics::{AstDiagnostic, Diagnostic, DiagnosticSink};\n \n #[derive(Debug)]\n@@ -29,25 +29,6 @@ impl Diagnostic for NoSuchField {\n     }\n }\n \n-#[derive(Debug)]\n-pub struct UnresolvedModule {\n-    pub file: HirFileId,\n-    pub decl: AstPtr<ast::Module>,\n-    pub candidate: RelativePathBuf,\n-}\n-\n-impl Diagnostic for UnresolvedModule {\n-    fn message(&self) -> String {\n-        \"unresolved module\".to_string()\n-    }\n-    fn source(&self) -> Source<SyntaxNodePtr> {\n-        Source { file_id: self.file, ast: self.decl.into() }\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct MissingFields {\n     pub file: HirFileId,"}, {"sha": "089dbc9084a454f09248d3f229e1366099f95a85", "filename": "crates/ra_hir/src/from_id.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -0,0 +1,63 @@\n+//! Utility module for converting between hir_def ids and code_model wrappers.\n+//!\n+//! It's unclear if we need this long-term, but it's definitelly useful while we\n+//! are splitting the hir.\n+\n+use hir_def::{AdtId, EnumVariantId, ModuleDefId};\n+\n+use crate::{Adt, EnumVariant, ModuleDef};\n+\n+macro_rules! from_id {\n+    ($(($id:path, $ty:path)),*) => {$(\n+        impl From<$id> for $ty {\n+            fn from(id: $id) -> $ty {\n+                $ty { id }\n+            }\n+        }\n+    )*}\n+}\n+\n+from_id![\n+    (hir_def::ModuleId, crate::Module),\n+    (hir_def::StructId, crate::Struct),\n+    (hir_def::UnionId, crate::Union),\n+    (hir_def::EnumId, crate::Enum),\n+    (hir_def::TypeAliasId, crate::TypeAlias),\n+    (hir_def::TraitId, crate::Trait),\n+    (hir_def::StaticId, crate::Static),\n+    (hir_def::ConstId, crate::Const),\n+    (hir_def::FunctionId, crate::Function),\n+    (hir_expand::MacroDefId, crate::MacroDef)\n+];\n+\n+impl From<AdtId> for Adt {\n+    fn from(id: AdtId) -> Self {\n+        match id {\n+            AdtId::StructId(it) => Adt::Struct(it.into()),\n+            AdtId::UnionId(it) => Adt::Union(it.into()),\n+            AdtId::EnumId(it) => Adt::Enum(it.into()),\n+        }\n+    }\n+}\n+\n+impl From<EnumVariantId> for EnumVariant {\n+    fn from(id: EnumVariantId) -> Self {\n+        EnumVariant { parent: id.parent.into(), id: id.local_id }\n+    }\n+}\n+\n+impl From<ModuleDefId> for ModuleDef {\n+    fn from(id: ModuleDefId) -> Self {\n+        match id {\n+            ModuleDefId::ModuleId(it) => ModuleDef::Module(it.into()),\n+            ModuleDefId::FunctionId(it) => ModuleDef::Function(it.into()),\n+            ModuleDefId::AdtId(it) => ModuleDef::Adt(it.into()),\n+            ModuleDefId::EnumVariantId(it) => ModuleDef::EnumVariant(it.into()),\n+            ModuleDefId::ConstId(it) => ModuleDef::Const(it.into()),\n+            ModuleDefId::StaticId(it) => ModuleDef::Static(it.into()),\n+            ModuleDefId::TraitId(it) => ModuleDef::Trait(it.into()),\n+            ModuleDefId::TypeAliasId(it) => ModuleDef::TypeAlias(it.into()),\n+            ModuleDefId::BuiltinType(it) => ModuleDef::BuiltinType(it),\n+        }\n+    }\n+}"}, {"sha": "9899bdbbce26af5ccc65ccacfcc3691cef3dd639", "filename": "crates/ra_hir/src/from_source.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -149,14 +149,20 @@ impl Module {\n             ModuleSource::SourceFile(_) => None,\n         };\n \n-        db.relevant_crates(src.file_id.original_file(db))\n-            .iter()\n-            .map(|&crate_id| Crate { crate_id })\n-            .find_map(|krate| {\n-                let def_map = db.crate_def_map(krate);\n-                let module_id = def_map.find_module_by_source(src.file_id, decl_id)?;\n-                Some(Module::new(krate, module_id))\n-            })\n+        db.relevant_crates(src.file_id.original_file(db)).iter().find_map(|&crate_id| {\n+            let def_map = db.crate_def_map(crate_id);\n+\n+            let (module_id, _module_data) =\n+                def_map.modules.iter().find(|(_module_id, module_data)| {\n+                    if decl_id.is_some() {\n+                        module_data.declaration == decl_id\n+                    } else {\n+                        module_data.definition.map(|it| it.into()) == Some(src.file_id)\n+                    }\n+                })?;\n+\n+            Some(Module::new(Crate { crate_id }, module_id))\n+        })\n     }\n }\n "}, {"sha": "3ba99d92d70313671925d31696b150e9bd90dd7d", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -34,7 +34,6 @@ pub mod mock;\n pub mod source_binder;\n \n mod ids;\n-mod nameres;\n mod adt;\n mod traits;\n mod type_alias;\n@@ -47,6 +46,7 @@ mod resolve;\n pub mod diagnostics;\n mod util;\n \n+mod from_id;\n mod code_model;\n \n pub mod from_source;\n@@ -72,7 +72,6 @@ pub use crate::{\n     generics::{GenericDef, GenericParam, GenericParams, HasGenericParams},\n     ids::{HirFileId, MacroCallId, MacroCallLoc, MacroDefId, MacroFile},\n     impl_block::ImplBlock,\n-    nameres::{ImportId, Namespace, PerNs},\n     resolve::ScopeDef,\n     source_binder::{PathResolution, ScopeEntryWithSyntax, SourceAnalyzer},\n     ty::{\n@@ -82,6 +81,10 @@ pub use crate::{\n \n pub use hir_def::{\n     builtin_type::BuiltinType,\n+    nameres::{\n+        per_ns::{Namespace, PerNs},\n+        raw::ImportId,\n+    },\n     path::{Path, PathKind},\n     type_ref::Mutability,\n };"}, {"sha": "32a6ab47495fb372efe32c3bed2fe698a8db4995", "filename": "crates/ra_hir/src/nameres.rs", "status": "removed", "additions": 0, "deletions": 558, "changes": 558, "blob_url": "https://github.com/rust-lang/rust/blob/f9f1effd011b906903891c09f1cb6b2a42f73e95/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9f1effd011b906903891c09f1cb6b2a42f73e95/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=f9f1effd011b906903891c09f1cb6b2a42f73e95", "patch": "@@ -1,558 +0,0 @@\n-//! This module implements import-resolution/macro expansion algorithm.\n-//!\n-//! The result of this module is `CrateDefMap`: a data structure which contains:\n-//!\n-//!   * a tree of modules for the crate\n-//!   * for each module, a set of items visible in the module (directly declared\n-//!     or imported)\n-//!\n-//! Note that `CrateDefMap` contains fully macro expanded code.\n-//!\n-//! Computing `CrateDefMap` can be partitioned into several logically\n-//! independent \"phases\". The phases are mutually recursive though, there's no\n-//! strict ordering.\n-//!\n-//! ## Collecting RawItems\n-//!\n-//!  This happens in the `raw` module, which parses a single source file into a\n-//!  set of top-level items. Nested imports are desugared to flat imports in\n-//!  this phase. Macro calls are represented as a triple of (Path, Option<Name>,\n-//!  TokenTree).\n-//!\n-//! ## Collecting Modules\n-//!\n-//! This happens in the `collector` module. In this phase, we recursively walk\n-//! tree of modules, collect raw items from submodules, populate module scopes\n-//! with defined items (so, we assign item ids in this phase) and record the set\n-//! of unresolved imports and macros.\n-//!\n-//! While we walk tree of modules, we also record macro_rules definitions and\n-//! expand calls to macro_rules defined macros.\n-//!\n-//! ## Resolving Imports\n-//!\n-//! We maintain a list of currently unresolved imports. On every iteration, we\n-//! try to resolve some imports from this list. If the import is resolved, we\n-//! record it, by adding an item to current module scope and, if necessary, by\n-//! recursively populating glob imports.\n-//!\n-//! ## Resolving Macros\n-//!\n-//! macro_rules from the same crate use a global mutable namespace. We expand\n-//! them immediately, when we collect modules.\n-//!\n-//! Macros from other crates (including proc-macros) can be used with\n-//! `foo::bar!` syntax. We handle them similarly to imports. There's a list of\n-//! unexpanded macros. On every iteration, we try to resolve each macro call\n-//! path and, upon success, we run macro expansion and \"collect module\" phase\n-//! on the result\n-\n-mod per_ns;\n-mod collector;\n-#[cfg(test)]\n-mod tests;\n-\n-use std::sync::Arc;\n-\n-use hir_def::{builtin_type::BuiltinType, CrateModuleId};\n-use hir_expand::diagnostics::DiagnosticSink;\n-use once_cell::sync::Lazy;\n-use ra_arena::Arena;\n-use ra_db::{Edition, FileId};\n-use ra_prof::profile;\n-use ra_syntax::ast;\n-use rustc_hash::{FxHashMap, FxHashSet};\n-use test_utils::tested_by;\n-\n-use crate::{\n-    db::{AstDatabase, DefDatabase},\n-    ids::MacroDefId,\n-    nameres::diagnostics::DefDiagnostic,\n-    Adt, AstId, Crate, HirFileId, MacroDef, Module, ModuleDef, Name, Path, PathKind, Trait,\n-};\n-\n-pub use self::per_ns::{Namespace, PerNs};\n-\n-pub use hir_def::nameres::raw::ImportId;\n-\n-/// Contains all top-level defs from a macro-expanded crate\n-#[derive(Debug, PartialEq, Eq)]\n-pub struct CrateDefMap {\n-    krate: Crate,\n-    edition: Edition,\n-    /// The prelude module for this crate. This either comes from an import\n-    /// marked with the `prelude_import` attribute, or (in the normal case) from\n-    /// a dependency (`std` or `core`).\n-    prelude: Option<Module>,\n-    extern_prelude: FxHashMap<Name, ModuleDef>,\n-    root: CrateModuleId,\n-    modules: Arena<CrateModuleId, ModuleData>,\n-\n-    /// Some macros are not well-behavior, which leads to infinite loop\n-    /// e.g. macro_rules! foo { ($ty:ty) => { foo!($ty); } }\n-    /// We mark it down and skip it in collector\n-    ///\n-    /// FIXME:\n-    /// Right now it only handle a poison macro in a single crate,\n-    /// such that if other crate try to call that macro,\n-    /// the whole process will do again until it became poisoned in that crate.\n-    /// We should handle this macro set globally\n-    /// However, do we want to put it as a global variable?\n-    poison_macros: FxHashSet<MacroDefId>,\n-\n-    diagnostics: Vec<DefDiagnostic>,\n-}\n-\n-impl std::ops::Index<CrateModuleId> for CrateDefMap {\n-    type Output = ModuleData;\n-    fn index(&self, id: CrateModuleId) -> &ModuleData {\n-        &self.modules[id]\n-    }\n-}\n-\n-#[derive(Default, Debug, PartialEq, Eq)]\n-pub struct ModuleData {\n-    pub(crate) parent: Option<CrateModuleId>,\n-    pub(crate) children: FxHashMap<Name, CrateModuleId>,\n-    pub(crate) scope: ModuleScope,\n-    /// None for root\n-    pub(crate) declaration: Option<AstId<ast::Module>>,\n-    /// None for inline modules.\n-    ///\n-    /// Note that non-inline modules, by definition, live inside non-macro file.\n-    pub(crate) definition: Option<FileId>,\n-}\n-\n-#[derive(Debug, Default, PartialEq, Eq, Clone)]\n-pub struct ModuleScope {\n-    items: FxHashMap<Name, Resolution>,\n-    /// Macros visable in current module in legacy textual scope\n-    ///\n-    /// For macros invoked by an unquatified identifier like `bar!()`, `legacy_macros` will be searched in first.\n-    /// If it yields no result, then it turns to module scoped `macros`.\n-    /// It macros with name quatified with a path like `crate::foo::bar!()`, `legacy_macros` will be skipped,\n-    /// and only normal scoped `macros` will be searched in.\n-    ///\n-    /// Note that this automatically inherit macros defined textually before the definition of module itself.\n-    ///\n-    /// Module scoped macros will be inserted into `items` instead of here.\n-    // FIXME: Macro shadowing in one module is not properly handled. Non-item place macros will\n-    // be all resolved to the last one defined if shadowing happens.\n-    legacy_macros: FxHashMap<Name, MacroDef>,\n-}\n-\n-static BUILTIN_SCOPE: Lazy<FxHashMap<Name, Resolution>> = Lazy::new(|| {\n-    BuiltinType::ALL\n-        .iter()\n-        .map(|(name, ty)| {\n-            (name.clone(), Resolution { def: PerNs::types(ty.clone().into()), import: None })\n-        })\n-        .collect()\n-});\n-\n-/// Legacy macros can only be accessed through special methods like `get_legacy_macros`.\n-/// Other methods will only resolve values, types and module scoped macros only.\n-impl ModuleScope {\n-    pub fn entries<'a>(&'a self) -> impl Iterator<Item = (&'a Name, &'a Resolution)> + 'a {\n-        //FIXME: shadowing\n-        self.items.iter().chain(BUILTIN_SCOPE.iter())\n-    }\n-\n-    /// Iterate over all module scoped macros\n-    pub fn macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDef)> + 'a {\n-        self.items\n-            .iter()\n-            .filter_map(|(name, res)| res.def.get_macros().map(|macro_| (name, macro_)))\n-    }\n-\n-    /// Iterate over all legacy textual scoped macros visable at the end of the module\n-    pub fn legacy_macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDef)> + 'a {\n-        self.legacy_macros.iter().map(|(name, def)| (name, *def))\n-    }\n-\n-    /// Get a name from current module scope, legacy macros are not included\n-    pub fn get(&self, name: &Name) -> Option<&Resolution> {\n-        self.items.get(name).or_else(|| BUILTIN_SCOPE.get(name))\n-    }\n-\n-    pub fn traits<'a>(&'a self) -> impl Iterator<Item = Trait> + 'a {\n-        self.items.values().filter_map(|r| match r.def.take_types() {\n-            Some(ModuleDef::Trait(t)) => Some(t),\n-            _ => None,\n-        })\n-    }\n-\n-    fn get_legacy_macro(&self, name: &Name) -> Option<MacroDef> {\n-        self.legacy_macros.get(name).copied()\n-    }\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq, Default)]\n-pub struct Resolution {\n-    /// None for unresolved\n-    pub def: PerNs,\n-    /// ident by which this is imported into local scope.\n-    pub import: Option<ImportId>,\n-}\n-\n-impl Resolution {\n-    pub(crate) fn from_macro(macro_: MacroDef) -> Self {\n-        Resolution { def: PerNs::macros(macro_), import: None }\n-    }\n-}\n-\n-#[derive(Debug, Clone)]\n-struct ResolvePathResult {\n-    resolved_def: PerNs,\n-    segment_index: Option<usize>,\n-    reached_fixedpoint: ReachedFixedPoint,\n-}\n-\n-impl ResolvePathResult {\n-    fn empty(reached_fixedpoint: ReachedFixedPoint) -> ResolvePathResult {\n-        ResolvePathResult::with(PerNs::none(), reached_fixedpoint, None)\n-    }\n-\n-    fn with(\n-        resolved_def: PerNs,\n-        reached_fixedpoint: ReachedFixedPoint,\n-        segment_index: Option<usize>,\n-    ) -> ResolvePathResult {\n-        ResolvePathResult { resolved_def, reached_fixedpoint, segment_index }\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-enum ResolveMode {\n-    Import,\n-    Other,\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-enum ReachedFixedPoint {\n-    Yes,\n-    No,\n-}\n-\n-impl CrateDefMap {\n-    pub(crate) fn crate_def_map_query(\n-        // Note that this doesn't have `+ AstDatabase`!\n-        // This gurantess that `CrateDefMap` is stable across reparses.\n-        db: &impl DefDatabase,\n-        krate: Crate,\n-    ) -> Arc<CrateDefMap> {\n-        let _p = profile(\"crate_def_map_query\");\n-        let def_map = {\n-            let edition = krate.edition(db);\n-            let mut modules: Arena<CrateModuleId, ModuleData> = Arena::default();\n-            let root = modules.alloc(ModuleData::default());\n-            CrateDefMap {\n-                krate,\n-                edition,\n-                extern_prelude: FxHashMap::default(),\n-                prelude: None,\n-                root,\n-                modules,\n-                poison_macros: FxHashSet::default(),\n-                diagnostics: Vec::new(),\n-            }\n-        };\n-        let def_map = collector::collect_defs(db, def_map);\n-        Arc::new(def_map)\n-    }\n-\n-    pub(crate) fn krate(&self) -> Crate {\n-        self.krate\n-    }\n-\n-    pub(crate) fn root(&self) -> CrateModuleId {\n-        self.root\n-    }\n-\n-    pub(crate) fn prelude(&self) -> Option<Module> {\n-        self.prelude\n-    }\n-\n-    pub(crate) fn extern_prelude(&self) -> &FxHashMap<Name, ModuleDef> {\n-        &self.extern_prelude\n-    }\n-\n-    pub(crate) fn add_diagnostics(\n-        &self,\n-        db: &(impl DefDatabase + AstDatabase),\n-        module: CrateModuleId,\n-        sink: &mut DiagnosticSink,\n-    ) {\n-        self.diagnostics.iter().for_each(|it| it.add_to(db, module, sink))\n-    }\n-\n-    pub(crate) fn find_module_by_source(\n-        &self,\n-        file_id: HirFileId,\n-        decl_id: Option<AstId<ast::Module>>,\n-    ) -> Option<CrateModuleId> {\n-        let (module_id, _module_data) = self.modules.iter().find(|(_module_id, module_data)| {\n-            if decl_id.is_some() {\n-                module_data.declaration == decl_id\n-            } else {\n-                module_data.definition.map(|it| it.into()) == Some(file_id)\n-            }\n-        })?;\n-        Some(module_id)\n-    }\n-\n-    pub(crate) fn resolve_path(\n-        &self,\n-        db: &impl DefDatabase,\n-        original_module: CrateModuleId,\n-        path: &Path,\n-    ) -> (PerNs, Option<usize>) {\n-        let res = self.resolve_path_fp_with_macro(db, ResolveMode::Other, original_module, path);\n-        (res.resolved_def, res.segment_index)\n-    }\n-\n-    // Returns Yes if we are sure that additions to `ItemMap` wouldn't change\n-    // the result.\n-    fn resolve_path_fp_with_macro(\n-        &self,\n-        db: &impl DefDatabase,\n-        mode: ResolveMode,\n-        original_module: CrateModuleId,\n-        path: &Path,\n-    ) -> ResolvePathResult {\n-        let mut segments = path.segments.iter().enumerate();\n-        let mut curr_per_ns: PerNs = match path.kind {\n-            PathKind::DollarCrate(crate_id) => {\n-                let krate = Crate { crate_id };\n-                if krate == self.krate {\n-                    tested_by!(macro_dollar_crate_self);\n-                    PerNs::types(Module::new(self.krate, self.root).into())\n-                } else {\n-                    match krate.root_module(db) {\n-                        Some(module) => {\n-                            tested_by!(macro_dollar_crate_other);\n-                            PerNs::types(module.into())\n-                        }\n-                        None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n-                    }\n-                }\n-            }\n-            PathKind::Crate => PerNs::types(Module::new(self.krate, self.root).into()),\n-            PathKind::Self_ => PerNs::types(Module::new(self.krate, original_module).into()),\n-            // plain import or absolute path in 2015: crate-relative with\n-            // fallback to extern prelude (with the simplification in\n-            // rust-lang/rust#57745)\n-            // FIXME there must be a nicer way to write this condition\n-            PathKind::Plain | PathKind::Abs\n-                if self.edition == Edition::Edition2015\n-                    && (path.kind == PathKind::Abs || mode == ResolveMode::Import) =>\n-            {\n-                let segment = match segments.next() {\n-                    Some((_, segment)) => segment,\n-                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n-                };\n-                log::debug!(\"resolving {:?} in crate root (+ extern prelude)\", segment);\n-                self.resolve_name_in_crate_root_or_extern_prelude(&segment.name)\n-            }\n-            PathKind::Plain => {\n-                let segment = match segments.next() {\n-                    Some((_, segment)) => segment,\n-                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n-                };\n-                log::debug!(\"resolving {:?} in module\", segment);\n-                self.resolve_name_in_module(db, original_module, &segment.name)\n-            }\n-            PathKind::Super => {\n-                if let Some(p) = self.modules[original_module].parent {\n-                    PerNs::types(Module::new(self.krate, p).into())\n-                } else {\n-                    log::debug!(\"super path in root module\");\n-                    return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n-                }\n-            }\n-            PathKind::Abs => {\n-                // 2018-style absolute path -- only extern prelude\n-                let segment = match segments.next() {\n-                    Some((_, segment)) => segment,\n-                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n-                };\n-                if let Some(def) = self.extern_prelude.get(&segment.name) {\n-                    log::debug!(\"absolute path {:?} resolved to crate {:?}\", path, def);\n-                    PerNs::types(*def)\n-                } else {\n-                    return ResolvePathResult::empty(ReachedFixedPoint::No); // extern crate declarations can add to the extern prelude\n-                }\n-            }\n-            PathKind::Type(_) => {\n-                // This is handled in `infer::infer_path_expr`\n-                // The result returned here does not matter\n-                return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n-            }\n-        };\n-\n-        for (i, segment) in segments {\n-            let curr = match curr_per_ns.take_types() {\n-                Some(r) => r,\n-                None => {\n-                    // we still have path segments left, but the path so far\n-                    // didn't resolve in the types namespace => no resolution\n-                    // (don't break here because `curr_per_ns` might contain\n-                    // something in the value namespace, and it would be wrong\n-                    // to return that)\n-                    return ResolvePathResult::empty(ReachedFixedPoint::No);\n-                }\n-            };\n-            // resolve segment in curr\n-\n-            curr_per_ns = match curr {\n-                ModuleDef::Module(module) => {\n-                    if module.krate() != self.krate {\n-                        let path =\n-                            Path { segments: path.segments[i..].to_vec(), kind: PathKind::Self_ };\n-                        log::debug!(\"resolving {:?} in other crate\", path);\n-                        let defp_map = db.crate_def_map(module.krate());\n-                        let (def, s) = defp_map.resolve_path(db, module.id.module_id, &path);\n-                        return ResolvePathResult::with(\n-                            def,\n-                            ReachedFixedPoint::Yes,\n-                            s.map(|s| s + i),\n-                        );\n-                    }\n-\n-                    // Since it is a qualified path here, it should not contains legacy macros\n-                    match self[module.id.module_id].scope.get(&segment.name) {\n-                        Some(res) => res.def,\n-                        _ => {\n-                            log::debug!(\"path segment {:?} not found\", segment.name);\n-                            return ResolvePathResult::empty(ReachedFixedPoint::No);\n-                        }\n-                    }\n-                }\n-                ModuleDef::Adt(Adt::Enum(e)) => {\n-                    // enum variant\n-                    tested_by!(can_import_enum_variant);\n-                    match e.variant(db, &segment.name) {\n-                        Some(variant) => PerNs::both(variant.into(), variant.into()),\n-                        None => {\n-                            return ResolvePathResult::with(\n-                                PerNs::types(e.into()),\n-                                ReachedFixedPoint::Yes,\n-                                Some(i),\n-                            );\n-                        }\n-                    }\n-                }\n-                s => {\n-                    // could be an inherent method call in UFCS form\n-                    // (`Struct::method`), or some other kind of associated item\n-                    log::debug!(\n-                        \"path segment {:?} resolved to non-module {:?}, but is not last\",\n-                        segment.name,\n-                        curr,\n-                    );\n-\n-                    return ResolvePathResult::with(\n-                        PerNs::types(s),\n-                        ReachedFixedPoint::Yes,\n-                        Some(i),\n-                    );\n-                }\n-            };\n-        }\n-        ResolvePathResult::with(curr_per_ns, ReachedFixedPoint::Yes, None)\n-    }\n-\n-    fn resolve_name_in_crate_root_or_extern_prelude(&self, name: &Name) -> PerNs {\n-        let from_crate_root =\n-            self[self.root].scope.get(name).map_or_else(PerNs::none, |res| res.def);\n-        let from_extern_prelude = self.resolve_name_in_extern_prelude(name);\n-\n-        from_crate_root.or(from_extern_prelude)\n-    }\n-\n-    pub(crate) fn resolve_name_in_module(\n-        &self,\n-        db: &impl DefDatabase,\n-        module: CrateModuleId,\n-        name: &Name,\n-    ) -> PerNs {\n-        // Resolve in:\n-        //  - legacy scope of macro\n-        //  - current module / scope\n-        //  - extern prelude\n-        //  - std prelude\n-        let from_legacy_macro =\n-            self[module].scope.get_legacy_macro(name).map_or_else(PerNs::none, PerNs::macros);\n-        let from_scope = self[module].scope.get(name).map_or_else(PerNs::none, |res| res.def);\n-        let from_extern_prelude =\n-            self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it));\n-        let from_prelude = self.resolve_in_prelude(db, name);\n-\n-        from_legacy_macro.or(from_scope).or(from_extern_prelude).or(from_prelude)\n-    }\n-\n-    fn resolve_name_in_extern_prelude(&self, name: &Name) -> PerNs {\n-        self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it))\n-    }\n-\n-    fn resolve_in_prelude(&self, db: &impl DefDatabase, name: &Name) -> PerNs {\n-        if let Some(prelude) = self.prelude {\n-            let keep;\n-            let def_map = if prelude.krate() == self.krate {\n-                self\n-            } else {\n-                // Extend lifetime\n-                keep = db.crate_def_map(prelude.krate());\n-                &keep\n-            };\n-            def_map[prelude.id.module_id].scope.get(name).map_or_else(PerNs::none, |res| res.def)\n-        } else {\n-            PerNs::none()\n-        }\n-    }\n-}\n-\n-mod diagnostics {\n-    use hir_expand::diagnostics::DiagnosticSink;\n-    use ra_syntax::{ast, AstPtr};\n-    use relative_path::RelativePathBuf;\n-\n-    use crate::{\n-        db::{AstDatabase, DefDatabase},\n-        diagnostics::UnresolvedModule,\n-        nameres::CrateModuleId,\n-        AstId,\n-    };\n-\n-    #[derive(Debug, PartialEq, Eq)]\n-    pub(super) enum DefDiagnostic {\n-        UnresolvedModule {\n-            module: CrateModuleId,\n-            declaration: AstId<ast::Module>,\n-            candidate: RelativePathBuf,\n-        },\n-    }\n-\n-    impl DefDiagnostic {\n-        pub(super) fn add_to(\n-            &self,\n-            db: &(impl DefDatabase + AstDatabase),\n-            target_module: CrateModuleId,\n-            sink: &mut DiagnosticSink,\n-        ) {\n-            match self {\n-                DefDiagnostic::UnresolvedModule { module, declaration, candidate } => {\n-                    if *module != target_module {\n-                        return;\n-                    }\n-                    let decl = declaration.to_node(db);\n-                    sink.push(UnresolvedModule {\n-                        file: declaration.file_id(),\n-                        decl: AstPtr::new(&decl),\n-                        candidate: candidate.clone(),\n-                    })\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "b932b0c8cdbca0000a12172da3c3cb978fe9995c", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 57, "deletions": 53, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -3,8 +3,9 @@ use std::sync::Arc;\n \n use hir_def::{\n     builtin_type::BuiltinType,\n+    nameres::CrateDefMap,\n     path::{Path, PathKind},\n-    CrateModuleId,\n+    AdtId, CrateModuleId, ModuleDefId,\n };\n use hir_expand::name::{self, Name};\n use rustc_hash::FxHashSet;\n@@ -18,8 +19,8 @@ use crate::{\n     },\n     generics::GenericParams,\n     impl_block::ImplBlock,\n-    nameres::{CrateDefMap, PerNs},\n-    Adt, Const, Enum, EnumVariant, Function, MacroDef, ModuleDef, Static, Struct, Trait, TypeAlias,\n+    Adt, Const, Enum, EnumVariant, Function, MacroDef, ModuleDef, PerNs, Static, Struct, Trait,\n+    TypeAlias,\n };\n \n #[derive(Debug, Clone, Default)]\n@@ -90,7 +91,7 @@ impl Resolver {\n     pub(crate) fn resolve_known_trait(&self, db: &impl HirDatabase, path: &Path) -> Option<Trait> {\n         let res = self.resolve_module_path(db, path).take_types()?;\n         match res {\n-            ModuleDef::Trait(it) => Some(it),\n+            ModuleDefId::TraitId(it) => Some(it.into()),\n             _ => None,\n         }\n     }\n@@ -103,7 +104,7 @@ impl Resolver {\n     ) -> Option<Struct> {\n         let res = self.resolve_module_path(db, path).take_types()?;\n         match res {\n-            ModuleDef::Adt(Adt::Struct(it)) => Some(it),\n+            ModuleDefId::AdtId(AdtId::StructId(it)) => Some(it.into()),\n             _ => None,\n         }\n     }\n@@ -112,7 +113,7 @@ impl Resolver {\n     pub(crate) fn resolve_known_enum(&self, db: &impl HirDatabase, path: &Path) -> Option<Enum> {\n         let res = self.resolve_module_path(db, path).take_types()?;\n         match res {\n-            ModuleDef::Adt(Adt::Enum(it)) => Some(it),\n+            ModuleDefId::AdtId(AdtId::EnumId(it)) => Some(it.into()),\n             _ => None,\n         }\n     }\n@@ -166,18 +167,18 @@ impl Resolver {\n                 Scope::ModuleScope(m) => {\n                     let (module_def, idx) = m.crate_def_map.resolve_path(db, m.module_id, path);\n                     let res = match module_def.take_types()? {\n-                        ModuleDef::Adt(it) => TypeNs::Adt(it),\n-                        ModuleDef::EnumVariant(it) => TypeNs::EnumVariant(it),\n+                        ModuleDefId::AdtId(it) => TypeNs::Adt(it.into()),\n+                        ModuleDefId::EnumVariantId(it) => TypeNs::EnumVariant(it.into()),\n \n-                        ModuleDef::TypeAlias(it) => TypeNs::TypeAlias(it),\n-                        ModuleDef::BuiltinType(it) => TypeNs::BuiltinType(it),\n+                        ModuleDefId::TypeAliasId(it) => TypeNs::TypeAlias(it.into()),\n+                        ModuleDefId::BuiltinType(it) => TypeNs::BuiltinType(it),\n \n-                        ModuleDef::Trait(it) => TypeNs::Trait(it),\n+                        ModuleDefId::TraitId(it) => TypeNs::Trait(it.into()),\n \n-                        ModuleDef::Function(_)\n-                        | ModuleDef::Const(_)\n-                        | ModuleDef::Static(_)\n-                        | ModuleDef::Module(_) => return None,\n+                        ModuleDefId::FunctionId(_)\n+                        | ModuleDefId::ConstId(_)\n+                        | ModuleDefId::StaticId(_)\n+                        | ModuleDefId::ModuleId(_) => return None,\n                     };\n                     return Some((res, idx));\n                 }\n@@ -261,33 +262,35 @@ impl Resolver {\n                     return match idx {\n                         None => {\n                             let value = match module_def.take_values()? {\n-                                ModuleDef::Function(it) => ValueNs::Function(it),\n-                                ModuleDef::Adt(Adt::Struct(it)) => ValueNs::Struct(it),\n-                                ModuleDef::EnumVariant(it) => ValueNs::EnumVariant(it),\n-                                ModuleDef::Const(it) => ValueNs::Const(it),\n-                                ModuleDef::Static(it) => ValueNs::Static(it),\n-\n-                                ModuleDef::Adt(Adt::Enum(_))\n-                                | ModuleDef::Adt(Adt::Union(_))\n-                                | ModuleDef::Trait(_)\n-                                | ModuleDef::TypeAlias(_)\n-                                | ModuleDef::BuiltinType(_)\n-                                | ModuleDef::Module(_) => return None,\n+                                ModuleDefId::FunctionId(it) => ValueNs::Function(it.into()),\n+                                ModuleDefId::AdtId(AdtId::StructId(it)) => {\n+                                    ValueNs::Struct(it.into())\n+                                }\n+                                ModuleDefId::EnumVariantId(it) => ValueNs::EnumVariant(it.into()),\n+                                ModuleDefId::ConstId(it) => ValueNs::Const(it.into()),\n+                                ModuleDefId::StaticId(it) => ValueNs::Static(it.into()),\n+\n+                                ModuleDefId::AdtId(AdtId::EnumId(_))\n+                                | ModuleDefId::AdtId(AdtId::UnionId(_))\n+                                | ModuleDefId::TraitId(_)\n+                                | ModuleDefId::TypeAliasId(_)\n+                                | ModuleDefId::BuiltinType(_)\n+                                | ModuleDefId::ModuleId(_) => return None,\n                             };\n                             Some(ResolveValueResult::ValueNs(value))\n                         }\n                         Some(idx) => {\n                             let ty = match module_def.take_types()? {\n-                                ModuleDef::Adt(it) => TypeNs::Adt(it),\n-                                ModuleDef::Trait(it) => TypeNs::Trait(it),\n-                                ModuleDef::TypeAlias(it) => TypeNs::TypeAlias(it),\n-                                ModuleDef::BuiltinType(it) => TypeNs::BuiltinType(it),\n-\n-                                ModuleDef::Module(_)\n-                                | ModuleDef::Function(_)\n-                                | ModuleDef::EnumVariant(_)\n-                                | ModuleDef::Const(_)\n-                                | ModuleDef::Static(_) => return None,\n+                                ModuleDefId::AdtId(it) => TypeNs::Adt(it.into()),\n+                                ModuleDefId::TraitId(it) => TypeNs::Trait(it.into()),\n+                                ModuleDefId::TypeAliasId(it) => TypeNs::TypeAlias(it.into()),\n+                                ModuleDefId::BuiltinType(it) => TypeNs::BuiltinType(it),\n+\n+                                ModuleDefId::ModuleId(_)\n+                                | ModuleDefId::FunctionId(_)\n+                                | ModuleDefId::EnumVariantId(_)\n+                                | ModuleDefId::ConstId(_)\n+                                | ModuleDefId::StaticId(_) => return None,\n                             };\n                             Some(ResolveValueResult::Partial(ty, idx))\n                         }\n@@ -315,7 +318,7 @@ impl Resolver {\n         path: &Path,\n     ) -> Option<MacroDef> {\n         let (item_map, module) = self.module()?;\n-        item_map.resolve_path(db, module, path).0.get_macros()\n+        item_map.resolve_path(db, module, path).0.get_macros().map(MacroDef::from)\n     }\n \n     pub(crate) fn process_all_names(\n@@ -333,10 +336,11 @@ impl Resolver {\n         for scope in &self.scopes {\n             if let Scope::ModuleScope(m) = scope {\n                 if let Some(prelude) = m.crate_def_map.prelude() {\n-                    let prelude_def_map = db.crate_def_map(prelude.krate());\n-                    traits.extend(prelude_def_map[prelude.id.module_id].scope.traits());\n+                    let prelude_def_map = db.crate_def_map(prelude.krate);\n+                    traits\n+                        .extend(prelude_def_map[prelude.module_id].scope.traits().map(Trait::from));\n                 }\n-                traits.extend(m.crate_def_map[m.module_id].scope.traits());\n+                traits.extend(m.crate_def_map[m.module_id].scope.traits().map(Trait::from));\n             }\n         }\n         traits\n@@ -351,7 +355,7 @@ impl Resolver {\n     }\n \n     pub(crate) fn krate(&self) -> Option<Crate> {\n-        self.module().map(|t| t.0.krate())\n+        self.module().map(|t| Crate { crate_id: t.0.krate() })\n     }\n \n     pub(crate) fn where_predicates_in_scope<'a>(\n@@ -420,8 +424,10 @@ impl From<PerNs> for ScopeDef {\n     fn from(def: PerNs) -> Self {\n         def.take_types()\n             .or_else(|| def.take_values())\n-            .map(ScopeDef::ModuleDef)\n-            .or_else(|| def.get_macros().map(ScopeDef::MacroDef))\n+            .map(|module_def_id| ScopeDef::ModuleDef(module_def_id.into()))\n+            .or_else(|| {\n+                def.get_macros().map(|macro_def_id| ScopeDef::MacroDef(macro_def_id.into()))\n+            })\n             .unwrap_or(ScopeDef::Unknown)\n     }\n }\n@@ -441,18 +447,16 @@ impl Scope {\n                     f(name.clone(), res.def.into());\n                 });\n                 m.crate_def_map[m.module_id].scope.legacy_macros().for_each(|(name, macro_)| {\n-                    f(name.clone(), ScopeDef::MacroDef(macro_));\n+                    f(name.clone(), ScopeDef::MacroDef(macro_.into()));\n                 });\n-                m.crate_def_map.extern_prelude().iter().for_each(|(name, def)| {\n-                    f(name.clone(), ScopeDef::ModuleDef(*def));\n+                m.crate_def_map.extern_prelude().iter().for_each(|(name, &def)| {\n+                    f(name.clone(), ScopeDef::ModuleDef(def.into()));\n                 });\n                 if let Some(prelude) = m.crate_def_map.prelude() {\n-                    let prelude_def_map = db.crate_def_map(prelude.krate());\n-                    prelude_def_map[prelude.id.module_id].scope.entries().for_each(\n-                        |(name, res)| {\n-                            f(name.clone(), res.def.into());\n-                        },\n-                    );\n+                    let prelude_def_map = db.crate_def_map(prelude.krate);\n+                    prelude_def_map[prelude.module_id].scope.entries().for_each(|(name, res)| {\n+                        f(name.clone(), res.def.into());\n+                    });\n                 }\n             }\n             Scope::GenericParams(gp) => {"}, {"sha": "66cb4b357f886f6fbc9578b17a6126bb34b6ffd6", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -253,8 +253,11 @@ impl SourceAnalyzer {\n             Some(res)\n         });\n \n-        let items =\n-            self.resolver.resolve_module_path(db, &path).take_types().map(PathResolution::Def);\n+        let items = self\n+            .resolver\n+            .resolve_module_path(db, &path)\n+            .take_types()\n+            .map(|it| PathResolution::Def(it.into()));\n         types.or(values).or(items).or_else(|| {\n             self.resolver.resolve_path_as_macro(db, &path).map(|def| PathResolution::Macro(def))\n         })"}, {"sha": "a09ef5c5d3afc09247f635dfdd577872eb9ec1ae", "filename": "crates/ra_hir/src/ty/infer/expr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -11,12 +11,11 @@ use crate::{\n     db::HirDatabase,\n     expr::{self, Array, BinaryOp, Expr, ExprId, Literal, Statement, UnaryOp},\n     generics::{GenericParams, HasGenericParams},\n-    nameres::Namespace,\n     ty::{\n         autoderef, method_resolution, op, primitive, CallableDef, InferTy, Mutability, Obligation,\n         ProjectionPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor, TypeWalk,\n     },\n-    Adt, Name,\n+    Adt, Name, Namespace,\n };\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {"}, {"sha": "e29ab8492a5eed2a5bc107d34f76072661196229", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -23,15 +23,14 @@ use crate::{\n     db::HirDatabase,\n     generics::HasGenericParams,\n     generics::{GenericDef, WherePredicate},\n-    nameres::Namespace,\n     resolve::{Resolver, TypeNs},\n     ty::{\n         primitive::{FloatTy, IntTy},\n         Adt,\n     },\n     util::make_mut_slice,\n-    Const, Enum, EnumVariant, Function, ModuleDef, Path, Static, Struct, StructField, Trait,\n-    TypeAlias, Union,\n+    Const, Enum, EnumVariant, Function, ModuleDef, Namespace, Path, Static, Struct, StructField,\n+    Trait, TypeAlias, Union,\n };\n \n impl Ty {"}, {"sha": "f271557377d0dcc5a39e00fbaf45588babbad423", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -3403,7 +3403,7 @@ fn test() { S.foo()<|>; }\n \n #[test]\n fn infer_macro_with_dollar_crate_is_correct_in_expr() {\n-    covers!(macro_dollar_crate_other);\n+    // covers!(macro_dollar_crate_other);\n     let (mut db, pos) = MockDatabase::with_position(\n         r#\"\n //- /main.rs"}, {"sha": "15055db64e598b1bdecc65e6bea2e060f5fe8353", "filename": "crates/ra_hir_def/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2FCargo.toml?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -19,3 +19,7 @@ test_utils = { path = \"../test_utils\" }\n mbe = { path = \"../ra_mbe\", package = \"ra_mbe\" }\n ra_cfg = { path = \"../ra_cfg\" }\n tt = { path = \"../ra_tt\", package = \"ra_tt\" }\n+\n+[dev-dependencies]\n+insta = \"0.12.0\"\n+"}, {"sha": "8f41e55d26f9ab9e6bd88b6c7b5a6ff03d5bacea", "filename": "crates/ra_hir_def/src/adt.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fadt.rs?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -8,7 +8,7 @@ use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner};\n \n use crate::{\n     db::DefDatabase2, type_ref::TypeRef, AstItemDef, EnumId, LocalEnumVariantId,\n-    LocalStructFieldId, StructId,\n+    LocalStructFieldId, StructId, UnionId,\n };\n \n /// Note that we use `StructData` for unions as well!\n@@ -56,6 +56,13 @@ impl StructData {\n         let variant_data = Arc::new(variant_data);\n         Arc::new(StructData { name, variant_data })\n     }\n+    pub(crate) fn union_data_query(db: &impl DefDatabase2, struct_: UnionId) -> Arc<StructData> {\n+        let src = struct_.source(db);\n+        let name = src.ast.name().map(|n| n.as_name());\n+        let variant_data = VariantData::new(src.ast.kind());\n+        let variant_data = Arc::new(variant_data);\n+        Arc::new(StructData { name, variant_data })\n+    }\n }\n \n impl EnumData {\n@@ -74,6 +81,11 @@ impl EnumData {\n             .collect();\n         Arc::new(EnumData { name, variants })\n     }\n+\n+    pub(crate) fn variant(&self, name: &Name) -> Option<LocalEnumVariantId> {\n+        let (id, _) = self.variants.iter().find(|(_id, data)| data.name.as_ref() == Some(name))?;\n+        Some(id)\n+    }\n }\n \n impl VariantData {"}, {"sha": "a42348101b487a97988f150490bfc42555b1b272", "filename": "crates/ra_hir_def/src/db.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdb.rs?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -2,13 +2,16 @@\n use std::sync::Arc;\n \n use hir_expand::{db::AstDatabase, HirFileId};\n-use ra_db::{salsa, SourceDatabase};\n+use ra_db::{salsa, CrateId, SourceDatabase};\n use ra_syntax::ast;\n \n use crate::{\n     adt::{EnumData, StructData},\n-    nameres::raw::{ImportSourceMap, RawItems},\n-    EnumId, StructId,\n+    nameres::{\n+        raw::{ImportSourceMap, RawItems},\n+        CrateDefMap,\n+    },\n+    EnumId, StructId, UnionId,\n };\n \n #[salsa::query_group(InternDatabaseStorage)]\n@@ -42,9 +45,15 @@ pub trait DefDatabase2: InternDatabase + AstDatabase {\n     #[salsa::invoke(RawItems::raw_items_query)]\n     fn raw_items(&self, file_id: HirFileId) -> Arc<RawItems>;\n \n+    #[salsa::invoke(CrateDefMap::crate_def_map_query)]\n+    fn crate_def_map(&self, krate: CrateId) -> Arc<CrateDefMap>;\n+\n     #[salsa::invoke(StructData::struct_data_query)]\n     fn struct_data(&self, s: StructId) -> Arc<StructData>;\n \n+    #[salsa::invoke(StructData::union_data_query)]\n+    fn union_data(&self, s: UnionId) -> Arc<StructData>;\n+\n     #[salsa::invoke(EnumData::enum_data_query)]\n     fn enum_data(&self, e: EnumId) -> Arc<EnumData>;\n }"}, {"sha": "1c1ccdecb72f69dbb92878fba20d8bc3773baac8", "filename": "crates/ra_hir_def/src/diagnostics.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdiagnostics.rs?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -0,0 +1,28 @@\n+//! Diagnostics produced by `hir_def`.\n+\n+use std::any::Any;\n+\n+use hir_expand::diagnostics::Diagnostic;\n+use ra_syntax::{ast, AstPtr, SyntaxNodePtr};\n+use relative_path::RelativePathBuf;\n+\n+use hir_expand::{HirFileId, Source};\n+\n+#[derive(Debug)]\n+pub struct UnresolvedModule {\n+    pub file: HirFileId,\n+    pub decl: AstPtr<ast::Module>,\n+    pub candidate: RelativePathBuf,\n+}\n+\n+impl Diagnostic for UnresolvedModule {\n+    fn message(&self) -> String {\n+        \"unresolved module\".to_string()\n+    }\n+    fn source(&self) -> Source<SyntaxNodePtr> {\n+        Source { file_id: self.file, ast: self.decl.into() }\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}"}, {"sha": "63ed2a09833b77180a07e9fde83fa1abd9520c8e", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -13,6 +13,12 @@ pub mod path;\n pub mod type_ref;\n pub mod builtin_type;\n pub mod adt;\n+pub mod diagnostics;\n+\n+#[cfg(test)]\n+mod test_db;\n+#[cfg(test)]\n+mod marks;\n \n // FIXME: this should be private\n pub mod nameres;\n@@ -237,8 +243,8 @@ impl AstItemDef<ast::EnumDef> for EnumId {\n // FIXME: rename to `VariantId`, only enums can ave variants\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct EnumVariantId {\n-    parent: EnumId,\n-    local_id: LocalEnumVariantId,\n+    pub parent: EnumId,\n+    pub local_id: LocalEnumVariantId,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]"}, {"sha": "0b99eac7174990588cf791479d372f68d477e431", "filename": "crates/ra_hir_def/src/marks.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fmarks.rs?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -0,0 +1,14 @@\n+//! See test_utils/src/marks.rs\n+\n+test_utils::marks!(\n+    bogus_paths\n+    name_res_works_for_broken_modules\n+    can_import_enum_variant\n+    glob_enum\n+    glob_across_crates\n+    std_prelude\n+    macro_rules_from_other_crates_are_visible_with_macro_use\n+    prelude_is_macro_use\n+    macro_dollar_crate_self\n+    macro_dollar_crate_other\n+);"}, {"sha": "fbd4248e6a7495123b69bc8c79614882a5828be6", "filename": "crates/ra_hir_def/src/nameres.rs", "status": "modified", "additions": 539, "deletions": 1, "changes": 540, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -1,5 +1,543 @@\n-//! FIXME: write short doc here\n+//! This module implements import-resolution/macro expansion algorithm.\n+//!\n+//! The result of this module is `CrateDefMap`: a data structure which contains:\n+//!\n+//!   * a tree of modules for the crate\n+//!   * for each module, a set of items visible in the module (directly declared\n+//!     or imported)\n+//!\n+//! Note that `CrateDefMap` contains fully macro expanded code.\n+//!\n+//! Computing `CrateDefMap` can be partitioned into several logically\n+//! independent \"phases\". The phases are mutually recursive though, there's no\n+//! strict ordering.\n+//!\n+//! ## Collecting RawItems\n+//!\n+//!  This happens in the `raw` module, which parses a single source file into a\n+//!  set of top-level items. Nested imports are desugared to flat imports in\n+//!  this phase. Macro calls are represented as a triple of (Path, Option<Name>,\n+//!  TokenTree).\n+//!\n+//! ## Collecting Modules\n+//!\n+//! This happens in the `collector` module. In this phase, we recursively walk\n+//! tree of modules, collect raw items from submodules, populate module scopes\n+//! with defined items (so, we assign item ids in this phase) and record the set\n+//! of unresolved imports and macros.\n+//!\n+//! While we walk tree of modules, we also record macro_rules definitions and\n+//! expand calls to macro_rules defined macros.\n+//!\n+//! ## Resolving Imports\n+//!\n+//! We maintain a list of currently unresolved imports. On every iteration, we\n+//! try to resolve some imports from this list. If the import is resolved, we\n+//! record it, by adding an item to current module scope and, if necessary, by\n+//! recursively populating glob imports.\n+//!\n+//! ## Resolving Macros\n+//!\n+//! macro_rules from the same crate use a global mutable namespace. We expand\n+//! them immediately, when we collect modules.\n+//!\n+//! Macros from other crates (including proc-macros) can be used with\n+//! `foo::bar!` syntax. We handle them similarly to imports. There's a list of\n+//! unexpanded macros. On every iteration, we try to resolve each macro call\n+//! path and, upon success, we run macro expansion and \"collect module\" phase\n+//! on the result\n \n // FIXME: review privacy of submodules\n pub mod raw;\n+pub mod per_ns;\n+pub mod collector;\n pub mod mod_resolution;\n+\n+#[cfg(test)]\n+mod tests;\n+\n+use std::sync::Arc;\n+\n+use hir_expand::{diagnostics::DiagnosticSink, name::Name, MacroDefId};\n+use once_cell::sync::Lazy;\n+use ra_arena::Arena;\n+use ra_db::{CrateId, Edition, FileId};\n+use ra_prof::profile;\n+use ra_syntax::ast;\n+use rustc_hash::{FxHashMap, FxHashSet};\n+use test_utils::tested_by;\n+\n+use crate::{\n+    builtin_type::BuiltinType,\n+    db::DefDatabase2,\n+    nameres::{diagnostics::DefDiagnostic, per_ns::PerNs, raw::ImportId},\n+    path::{Path, PathKind},\n+    AdtId, AstId, CrateModuleId, EnumVariantId, ModuleDefId, ModuleId, TraitId,\n+};\n+\n+/// Contains all top-level defs from a macro-expanded crate\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct CrateDefMap {\n+    krate: CrateId,\n+    edition: Edition,\n+    /// The prelude module for this crate. This either comes from an import\n+    /// marked with the `prelude_import` attribute, or (in the normal case) from\n+    /// a dependency (`std` or `core`).\n+    prelude: Option<ModuleId>,\n+    extern_prelude: FxHashMap<Name, ModuleDefId>,\n+    root: CrateModuleId,\n+    pub modules: Arena<CrateModuleId, ModuleData>,\n+\n+    /// Some macros are not well-behavior, which leads to infinite loop\n+    /// e.g. macro_rules! foo { ($ty:ty) => { foo!($ty); } }\n+    /// We mark it down and skip it in collector\n+    ///\n+    /// FIXME:\n+    /// Right now it only handle a poison macro in a single crate,\n+    /// such that if other crate try to call that macro,\n+    /// the whole process will do again until it became poisoned in that crate.\n+    /// We should handle this macro set globally\n+    /// However, do we want to put it as a global variable?\n+    poison_macros: FxHashSet<MacroDefId>,\n+\n+    diagnostics: Vec<DefDiagnostic>,\n+}\n+\n+impl std::ops::Index<CrateModuleId> for CrateDefMap {\n+    type Output = ModuleData;\n+    fn index(&self, id: CrateModuleId) -> &ModuleData {\n+        &self.modules[id]\n+    }\n+}\n+\n+#[derive(Default, Debug, PartialEq, Eq)]\n+pub struct ModuleData {\n+    pub parent: Option<CrateModuleId>,\n+    pub children: FxHashMap<Name, CrateModuleId>,\n+    pub scope: ModuleScope,\n+    /// None for root\n+    pub declaration: Option<AstId<ast::Module>>,\n+    /// None for inline modules.\n+    ///\n+    /// Note that non-inline modules, by definition, live inside non-macro file.\n+    pub definition: Option<FileId>,\n+}\n+\n+#[derive(Debug, Default, PartialEq, Eq, Clone)]\n+pub struct ModuleScope {\n+    pub items: FxHashMap<Name, Resolution>,\n+    /// Macros visable in current module in legacy textual scope\n+    ///\n+    /// For macros invoked by an unquatified identifier like `bar!()`, `legacy_macros` will be searched in first.\n+    /// If it yields no result, then it turns to module scoped `macros`.\n+    /// It macros with name quatified with a path like `crate::foo::bar!()`, `legacy_macros` will be skipped,\n+    /// and only normal scoped `macros` will be searched in.\n+    ///\n+    /// Note that this automatically inherit macros defined textually before the definition of module itself.\n+    ///\n+    /// Module scoped macros will be inserted into `items` instead of here.\n+    // FIXME: Macro shadowing in one module is not properly handled. Non-item place macros will\n+    // be all resolved to the last one defined if shadowing happens.\n+    legacy_macros: FxHashMap<Name, MacroDefId>,\n+}\n+\n+static BUILTIN_SCOPE: Lazy<FxHashMap<Name, Resolution>> = Lazy::new(|| {\n+    BuiltinType::ALL\n+        .iter()\n+        .map(|(name, ty)| {\n+            (name.clone(), Resolution { def: PerNs::types(ty.clone().into()), import: None })\n+        })\n+        .collect()\n+});\n+\n+/// Legacy macros can only be accessed through special methods like `get_legacy_macros`.\n+/// Other methods will only resolve values, types and module scoped macros only.\n+impl ModuleScope {\n+    pub fn entries<'a>(&'a self) -> impl Iterator<Item = (&'a Name, &'a Resolution)> + 'a {\n+        //FIXME: shadowing\n+        self.items.iter().chain(BUILTIN_SCOPE.iter())\n+    }\n+\n+    /// Iterate over all module scoped macros\n+    pub fn macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDefId)> + 'a {\n+        self.items\n+            .iter()\n+            .filter_map(|(name, res)| res.def.get_macros().map(|macro_| (name, macro_)))\n+    }\n+\n+    /// Iterate over all legacy textual scoped macros visable at the end of the module\n+    pub fn legacy_macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDefId)> + 'a {\n+        self.legacy_macros.iter().map(|(name, def)| (name, *def))\n+    }\n+\n+    /// Get a name from current module scope, legacy macros are not included\n+    pub fn get(&self, name: &Name) -> Option<&Resolution> {\n+        self.items.get(name).or_else(|| BUILTIN_SCOPE.get(name))\n+    }\n+\n+    pub fn traits<'a>(&'a self) -> impl Iterator<Item = TraitId> + 'a {\n+        self.items.values().filter_map(|r| match r.def.take_types() {\n+            Some(ModuleDefId::TraitId(t)) => Some(t),\n+            _ => None,\n+        })\n+    }\n+\n+    fn get_legacy_macro(&self, name: &Name) -> Option<MacroDefId> {\n+        self.legacy_macros.get(name).copied()\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Default)]\n+pub struct Resolution {\n+    /// None for unresolved\n+    pub def: PerNs,\n+    /// ident by which this is imported into local scope.\n+    pub import: Option<ImportId>,\n+}\n+\n+impl Resolution {\n+    pub(crate) fn from_macro(macro_: MacroDefId) -> Self {\n+        Resolution { def: PerNs::macros(macro_), import: None }\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+struct ResolvePathResult {\n+    resolved_def: PerNs,\n+    segment_index: Option<usize>,\n+    reached_fixedpoint: ReachedFixedPoint,\n+}\n+\n+impl ResolvePathResult {\n+    fn empty(reached_fixedpoint: ReachedFixedPoint) -> ResolvePathResult {\n+        ResolvePathResult::with(PerNs::none(), reached_fixedpoint, None)\n+    }\n+\n+    fn with(\n+        resolved_def: PerNs,\n+        reached_fixedpoint: ReachedFixedPoint,\n+        segment_index: Option<usize>,\n+    ) -> ResolvePathResult {\n+        ResolvePathResult { resolved_def, reached_fixedpoint, segment_index }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+enum ResolveMode {\n+    Import,\n+    Other,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+enum ReachedFixedPoint {\n+    Yes,\n+    No,\n+}\n+\n+impl CrateDefMap {\n+    pub(crate) fn crate_def_map_query(\n+        // Note that this doesn't have `+ AstDatabase`!\n+        // This gurantess that `CrateDefMap` is stable across reparses.\n+        db: &impl DefDatabase2,\n+        krate: CrateId,\n+    ) -> Arc<CrateDefMap> {\n+        let _p = profile(\"crate_def_map_query\");\n+        let def_map = {\n+            let crate_graph = db.crate_graph();\n+            let edition = crate_graph.edition(krate);\n+            let mut modules: Arena<CrateModuleId, ModuleData> = Arena::default();\n+            let root = modules.alloc(ModuleData::default());\n+            CrateDefMap {\n+                krate,\n+                edition,\n+                extern_prelude: FxHashMap::default(),\n+                prelude: None,\n+                root,\n+                modules,\n+                poison_macros: FxHashSet::default(),\n+                diagnostics: Vec::new(),\n+            }\n+        };\n+        let def_map = collector::collect_defs(db, def_map);\n+        Arc::new(def_map)\n+    }\n+\n+    pub fn krate(&self) -> CrateId {\n+        self.krate\n+    }\n+\n+    pub fn root(&self) -> CrateModuleId {\n+        self.root\n+    }\n+\n+    pub fn prelude(&self) -> Option<ModuleId> {\n+        self.prelude\n+    }\n+\n+    pub fn extern_prelude(&self) -> &FxHashMap<Name, ModuleDefId> {\n+        &self.extern_prelude\n+    }\n+\n+    pub fn add_diagnostics(\n+        &self,\n+        db: &impl DefDatabase2,\n+        module: CrateModuleId,\n+        sink: &mut DiagnosticSink,\n+    ) {\n+        self.diagnostics.iter().for_each(|it| it.add_to(db, module, sink))\n+    }\n+\n+    pub fn resolve_path(\n+        &self,\n+        db: &impl DefDatabase2,\n+        original_module: CrateModuleId,\n+        path: &Path,\n+    ) -> (PerNs, Option<usize>) {\n+        let res = self.resolve_path_fp_with_macro(db, ResolveMode::Other, original_module, path);\n+        (res.resolved_def, res.segment_index)\n+    }\n+\n+    // Returns Yes if we are sure that additions to `ItemMap` wouldn't change\n+    // the result.\n+    fn resolve_path_fp_with_macro(\n+        &self,\n+        db: &impl DefDatabase2,\n+        mode: ResolveMode,\n+        original_module: CrateModuleId,\n+        path: &Path,\n+    ) -> ResolvePathResult {\n+        let mut segments = path.segments.iter().enumerate();\n+        let mut curr_per_ns: PerNs = match path.kind {\n+            PathKind::DollarCrate(krate) => {\n+                if krate == self.krate {\n+                    tested_by!(macro_dollar_crate_self);\n+                    PerNs::types(ModuleId { krate: self.krate, module_id: self.root }.into())\n+                } else {\n+                    let def_map = db.crate_def_map(krate);\n+                    let module = ModuleId { krate, module_id: def_map.root };\n+                    tested_by!(macro_dollar_crate_other);\n+                    PerNs::types(module.into())\n+                }\n+            }\n+            PathKind::Crate => {\n+                PerNs::types(ModuleId { krate: self.krate, module_id: self.root }.into())\n+            }\n+            PathKind::Self_ => {\n+                PerNs::types(ModuleId { krate: self.krate, module_id: original_module }.into())\n+            }\n+            // plain import or absolute path in 2015: crate-relative with\n+            // fallback to extern prelude (with the simplification in\n+            // rust-lang/rust#57745)\n+            // FIXME there must be a nicer way to write this condition\n+            PathKind::Plain | PathKind::Abs\n+                if self.edition == Edition::Edition2015\n+                    && (path.kind == PathKind::Abs || mode == ResolveMode::Import) =>\n+            {\n+                let segment = match segments.next() {\n+                    Some((_, segment)) => segment,\n+                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n+                };\n+                log::debug!(\"resolving {:?} in crate root (+ extern prelude)\", segment);\n+                self.resolve_name_in_crate_root_or_extern_prelude(&segment.name)\n+            }\n+            PathKind::Plain => {\n+                let segment = match segments.next() {\n+                    Some((_, segment)) => segment,\n+                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n+                };\n+                log::debug!(\"resolving {:?} in module\", segment);\n+                self.resolve_name_in_module(db, original_module, &segment.name)\n+            }\n+            PathKind::Super => {\n+                if let Some(p) = self.modules[original_module].parent {\n+                    PerNs::types(ModuleId { krate: self.krate, module_id: p }.into())\n+                } else {\n+                    log::debug!(\"super path in root module\");\n+                    return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n+                }\n+            }\n+            PathKind::Abs => {\n+                // 2018-style absolute path -- only extern prelude\n+                let segment = match segments.next() {\n+                    Some((_, segment)) => segment,\n+                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n+                };\n+                if let Some(def) = self.extern_prelude.get(&segment.name) {\n+                    log::debug!(\"absolute path {:?} resolved to crate {:?}\", path, def);\n+                    PerNs::types(*def)\n+                } else {\n+                    return ResolvePathResult::empty(ReachedFixedPoint::No); // extern crate declarations can add to the extern prelude\n+                }\n+            }\n+            PathKind::Type(_) => {\n+                // This is handled in `infer::infer_path_expr`\n+                // The result returned here does not matter\n+                return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n+            }\n+        };\n+\n+        for (i, segment) in segments {\n+            let curr = match curr_per_ns.take_types() {\n+                Some(r) => r,\n+                None => {\n+                    // we still have path segments left, but the path so far\n+                    // didn't resolve in the types namespace => no resolution\n+                    // (don't break here because `curr_per_ns` might contain\n+                    // something in the value namespace, and it would be wrong\n+                    // to return that)\n+                    return ResolvePathResult::empty(ReachedFixedPoint::No);\n+                }\n+            };\n+            // resolve segment in curr\n+\n+            curr_per_ns = match curr {\n+                ModuleDefId::ModuleId(module) => {\n+                    if module.krate != self.krate {\n+                        let path =\n+                            Path { segments: path.segments[i..].to_vec(), kind: PathKind::Self_ };\n+                        log::debug!(\"resolving {:?} in other crate\", path);\n+                        let defp_map = db.crate_def_map(module.krate);\n+                        let (def, s) = defp_map.resolve_path(db, module.module_id, &path);\n+                        return ResolvePathResult::with(\n+                            def,\n+                            ReachedFixedPoint::Yes,\n+                            s.map(|s| s + i),\n+                        );\n+                    }\n+\n+                    // Since it is a qualified path here, it should not contains legacy macros\n+                    match self[module.module_id].scope.get(&segment.name) {\n+                        Some(res) => res.def,\n+                        _ => {\n+                            log::debug!(\"path segment {:?} not found\", segment.name);\n+                            return ResolvePathResult::empty(ReachedFixedPoint::No);\n+                        }\n+                    }\n+                }\n+                ModuleDefId::AdtId(AdtId::EnumId(e)) => {\n+                    // enum variant\n+                    tested_by!(can_import_enum_variant);\n+                    let enum_data = db.enum_data(e);\n+                    match enum_data.variant(&segment.name) {\n+                        Some(local_id) => {\n+                            let variant = EnumVariantId { parent: e, local_id };\n+                            PerNs::both(variant.into(), variant.into())\n+                        }\n+                        None => {\n+                            return ResolvePathResult::with(\n+                                PerNs::types(e.into()),\n+                                ReachedFixedPoint::Yes,\n+                                Some(i),\n+                            );\n+                        }\n+                    }\n+                }\n+                s => {\n+                    // could be an inherent method call in UFCS form\n+                    // (`Struct::method`), or some other kind of associated item\n+                    log::debug!(\n+                        \"path segment {:?} resolved to non-module {:?}, but is not last\",\n+                        segment.name,\n+                        curr,\n+                    );\n+\n+                    return ResolvePathResult::with(\n+                        PerNs::types(s),\n+                        ReachedFixedPoint::Yes,\n+                        Some(i),\n+                    );\n+                }\n+            };\n+        }\n+        ResolvePathResult::with(curr_per_ns, ReachedFixedPoint::Yes, None)\n+    }\n+\n+    fn resolve_name_in_crate_root_or_extern_prelude(&self, name: &Name) -> PerNs {\n+        let from_crate_root =\n+            self[self.root].scope.get(name).map_or_else(PerNs::none, |res| res.def);\n+        let from_extern_prelude = self.resolve_name_in_extern_prelude(name);\n+\n+        from_crate_root.or(from_extern_prelude)\n+    }\n+\n+    pub(crate) fn resolve_name_in_module(\n+        &self,\n+        db: &impl DefDatabase2,\n+        module: CrateModuleId,\n+        name: &Name,\n+    ) -> PerNs {\n+        // Resolve in:\n+        //  - legacy scope of macro\n+        //  - current module / scope\n+        //  - extern prelude\n+        //  - std prelude\n+        let from_legacy_macro =\n+            self[module].scope.get_legacy_macro(name).map_or_else(PerNs::none, PerNs::macros);\n+        let from_scope = self[module].scope.get(name).map_or_else(PerNs::none, |res| res.def);\n+        let from_extern_prelude =\n+            self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it));\n+        let from_prelude = self.resolve_in_prelude(db, name);\n+\n+        from_legacy_macro.or(from_scope).or(from_extern_prelude).or(from_prelude)\n+    }\n+\n+    fn resolve_name_in_extern_prelude(&self, name: &Name) -> PerNs {\n+        self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it))\n+    }\n+\n+    fn resolve_in_prelude(&self, db: &impl DefDatabase2, name: &Name) -> PerNs {\n+        if let Some(prelude) = self.prelude {\n+            let keep;\n+            let def_map = if prelude.krate == self.krate {\n+                self\n+            } else {\n+                // Extend lifetime\n+                keep = db.crate_def_map(prelude.krate);\n+                &keep\n+            };\n+            def_map[prelude.module_id].scope.get(name).map_or_else(PerNs::none, |res| res.def)\n+        } else {\n+            PerNs::none()\n+        }\n+    }\n+}\n+\n+mod diagnostics {\n+    use hir_expand::diagnostics::DiagnosticSink;\n+    use ra_syntax::{ast, AstPtr};\n+    use relative_path::RelativePathBuf;\n+\n+    use crate::{db::DefDatabase2, diagnostics::UnresolvedModule, nameres::CrateModuleId, AstId};\n+\n+    #[derive(Debug, PartialEq, Eq)]\n+    pub(super) enum DefDiagnostic {\n+        UnresolvedModule {\n+            module: CrateModuleId,\n+            declaration: AstId<ast::Module>,\n+            candidate: RelativePathBuf,\n+        },\n+    }\n+\n+    impl DefDiagnostic {\n+        pub(super) fn add_to(\n+            &self,\n+            db: &impl DefDatabase2,\n+            target_module: CrateModuleId,\n+            sink: &mut DiagnosticSink,\n+        ) {\n+            match self {\n+                DefDiagnostic::UnresolvedModule { module, declaration, candidate } => {\n+                    if *module != target_module {\n+                        return;\n+                    }\n+                    let decl = declaration.to_node(db);\n+                    sink.push(UnresolvedModule {\n+                        file: declaration.file_id(),\n+                        decl: AstPtr::new(&decl),\n+                        candidate: candidate.clone(),\n+                    })\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "3b61d9895bc3024817d9e1f87a1c964915ca570c", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "renamed", "additions": 84, "deletions": 77, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -1,45 +1,49 @@\n //! FIXME: write short doc here\n \n-use hir_def::{\n-    attr::Attr,\n-    nameres::{mod_resolution::ModDir, raw},\n+use hir_expand::{\n+    name::{self, AsName, Name},\n+    HirFileId, MacroCallId, MacroCallLoc, MacroDefId, MacroFileKind,\n };\n-use hir_expand::name;\n use ra_cfg::CfgOptions;\n-use ra_db::FileId;\n+use ra_db::{CrateId, FileId};\n use ra_syntax::{ast, SmolStr};\n use rustc_hash::FxHashMap;\n use test_utils::tested_by;\n \n use crate::{\n-    db::DefDatabase,\n-    ids::{AstItemDef, LocationCtx, MacroCallId, MacroCallLoc, MacroDefId, MacroFileKind},\n+    attr::Attr,\n+    db::DefDatabase2,\n     nameres::{\n-        diagnostics::DefDiagnostic, Crate, CrateDefMap, CrateModuleId, ModuleData, ModuleDef,\n-        PerNs, ReachedFixedPoint, Resolution, ResolveMode,\n+        diagnostics::DefDiagnostic, mod_resolution::ModDir, per_ns::PerNs, raw, CrateDefMap,\n+        ModuleData, ReachedFixedPoint, Resolution, ResolveMode,\n     },\n-    Adt, AstId, Const, Enum, Function, HirFileId, MacroDef, Module, Name, Path, PathKind, Static,\n-    Struct, Trait, TypeAlias, Union,\n+    path::{Path, PathKind},\n+    AdtId, AstId, AstItemDef, ConstId, CrateModuleId, EnumId, EnumVariantId, FunctionId,\n+    LocationCtx, ModuleDefId, ModuleId, StaticId, StructId, TraitId, TypeAliasId, UnionId,\n };\n \n-pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> CrateDefMap {\n+pub(super) fn collect_defs(db: &impl DefDatabase2, mut def_map: CrateDefMap) -> CrateDefMap {\n+    let crate_graph = db.crate_graph();\n+\n     // populate external prelude\n-    for dep in def_map.krate.dependencies(db) {\n-        log::debug!(\"crate dep {:?} -> {:?}\", dep.name, dep.krate);\n-        if let Some(module) = dep.krate.root_module(db) {\n-            def_map.extern_prelude.insert(dep.name.clone(), module.into());\n-        }\n+    for dep in crate_graph.dependencies(def_map.krate) {\n+        let dep_def_map = db.crate_def_map(dep.crate_id);\n+        log::debug!(\"crate dep {:?} -> {:?}\", dep.name, dep.crate_id);\n+        def_map.extern_prelude.insert(\n+            dep.as_name(),\n+            ModuleId { krate: dep.crate_id, module_id: dep_def_map.root }.into(),\n+        );\n+\n         // look for the prelude\n         if def_map.prelude.is_none() {\n-            let map = db.crate_def_map(dep.krate);\n+            let map = db.crate_def_map(dep.crate_id);\n             if map.prelude.is_some() {\n                 def_map.prelude = map.prelude;\n             }\n         }\n     }\n \n-    let crate_graph = db.crate_graph();\n-    let cfg_options = crate_graph.cfg_options(def_map.krate().crate_id());\n+    let cfg_options = crate_graph.cfg_options(def_map.krate);\n \n     let mut collector = DefCollector {\n         db,\n@@ -101,11 +105,11 @@ struct DefCollector<'a, DB> {\n \n impl<DB> DefCollector<'_, DB>\n where\n-    DB: DefDatabase,\n+    DB: DefDatabase2,\n {\n     fn collect(&mut self) {\n         let crate_graph = self.db.crate_graph();\n-        let file_id = crate_graph.crate_root(self.def_map.krate.crate_id());\n+        let file_id = crate_graph.crate_root(self.def_map.krate);\n         let raw_items = self.db.raw_items(file_id.into());\n         let module_id = self.def_map.root;\n         self.def_map.modules[module_id].definition = Some(file_id);\n@@ -168,7 +172,7 @@ where\n         &mut self,\n         module_id: CrateModuleId,\n         name: Name,\n-        macro_: MacroDef,\n+        macro_: MacroDefId,\n         export: bool,\n     ) {\n         // Textual scoping\n@@ -189,7 +193,7 @@ where\n     /// the definition of current module.\n     /// And also, `macro_use` on a module will import all legacy macros visable inside to\n     /// current legacy scope, with possible shadowing.\n-    fn define_legacy_macro(&mut self, module_id: CrateModuleId, name: Name, macro_: MacroDef) {\n+    fn define_legacy_macro(&mut self, module_id: CrateModuleId, name: Name, macro_: MacroDefId) {\n         // Always shadowing\n         self.def_map.modules[module_id].scope.legacy_macros.insert(name, macro_);\n     }\n@@ -213,9 +217,9 @@ where\n                 .expect(\"extern crate should have been desugared to one-element path\"),\n         );\n \n-        if let Some(ModuleDef::Module(m)) = res.take_types() {\n+        if let Some(ModuleDefId::ModuleId(m)) = res.take_types() {\n             tested_by!(macro_rules_from_other_crates_are_visible_with_macro_use);\n-            self.import_all_macros_exported(current_module_id, m.krate());\n+            self.import_all_macros_exported(current_module_id, m.krate);\n         }\n     }\n \n@@ -224,7 +228,7 @@ where\n     /// Exported macros are just all macros in the root module scope.\n     /// Note that it contains not only all `#[macro_export]` macros, but also all aliases\n     /// created by `use` in the root module, ignoring the visibility of `use`.\n-    fn import_all_macros_exported(&mut self, current_module_id: CrateModuleId, krate: Crate) {\n+    fn import_all_macros_exported(&mut self, current_module_id: CrateModuleId, krate: CrateId) {\n         let def_map = self.db.crate_def_map(krate);\n         for (name, def) in def_map[def_map.root].scope.macros() {\n             // `macro_use` only bring things into legacy scope.\n@@ -288,15 +292,15 @@ where\n         if import.is_glob {\n             log::debug!(\"glob import: {:?}\", import);\n             match def.take_types() {\n-                Some(ModuleDef::Module(m)) => {\n+                Some(ModuleDefId::ModuleId(m)) => {\n                     if import.is_prelude {\n                         tested_by!(std_prelude);\n                         self.def_map.prelude = Some(m);\n-                    } else if m.krate() != self.def_map.krate {\n+                    } else if m.krate != self.def_map.krate {\n                         tested_by!(glob_across_crates);\n                         // glob import from other crate => we can just import everything once\n-                        let item_map = self.db.crate_def_map(m.krate());\n-                        let scope = &item_map[m.id.module_id].scope;\n+                        let item_map = self.db.crate_def_map(m.krate);\n+                        let scope = &item_map[m.module_id].scope;\n \n                         // Module scoped macros is included\n                         let items = scope\n@@ -310,7 +314,7 @@ where\n                         // glob import from same crate => we do an initial\n                         // import, and then need to propagate any further\n                         // additions\n-                        let scope = &self.def_map[m.id.module_id].scope;\n+                        let scope = &self.def_map[m.module_id].scope;\n \n                         // Module scoped macros is included\n                         let items = scope\n@@ -322,23 +326,25 @@ where\n                         self.update(module_id, Some(import_id), &items);\n                         // record the glob import in case we add further items\n                         self.glob_imports\n-                            .entry(m.id.module_id)\n+                            .entry(m.module_id)\n                             .or_default()\n                             .push((module_id, import_id));\n                     }\n                 }\n-                Some(ModuleDef::Adt(Adt::Enum(e))) => {\n+                Some(ModuleDefId::AdtId(AdtId::EnumId(e))) => {\n                     tested_by!(glob_enum);\n                     // glob import from enum => just import all the variants\n-                    let variants = e.variants(self.db);\n-                    let resolutions = variants\n-                        .into_iter()\n-                        .filter_map(|variant| {\n+                    let enum_data = self.db.enum_data(e);\n+                    let resolutions = enum_data\n+                        .variants\n+                        .iter()\n+                        .filter_map(|(local_id, variant_data)| {\n+                            let name = variant_data.name.clone()?;\n+                            let variant = EnumVariantId { parent: e, local_id };\n                             let res = Resolution {\n                                 def: PerNs::both(variant.into(), variant.into()),\n                                 import: Some(import_id),\n                             };\n-                            let name = variant.name(self.db)?;\n                             Some((name, res))\n                         })\n                         .collect::<Vec<_>>();\n@@ -451,8 +457,8 @@ where\n             );\n \n             if let Some(def) = resolved_res.resolved_def.get_macros() {\n-                let call_id = self.db.intern_macro(MacroCallLoc { def: def.id, ast_id: *ast_id });\n-                resolved.push((*module_id, call_id, def.id));\n+                let call_id = self.db.intern_macro(MacroCallLoc { def, ast_id: *ast_id });\n+                resolved.push((*module_id, call_id, def));\n                 res = ReachedFixedPoint::No;\n                 return false;\n             }\n@@ -517,7 +523,7 @@ struct ModCollector<'a, D> {\n \n impl<DB> ModCollector<'_, &'_ mut DefCollector<'_, DB>>\n where\n-    DB: DefDatabase,\n+    DB: DefDatabase2,\n {\n     fn collect(&mut self, items: &[raw::RawItem]) {\n         // Note: don't assert that inserted value is fresh: it's simply not true\n@@ -526,10 +532,9 @@ where\n \n         // Prelude module is always considered to be `#[macro_use]`.\n         if let Some(prelude_module) = self.def_collector.def_map.prelude {\n-            if prelude_module.krate() != self.def_collector.def_map.krate {\n+            if prelude_module.krate != self.def_collector.def_map.krate {\n                 tested_by!(prelude_is_macro_use);\n-                self.def_collector\n-                    .import_all_macros_exported(self.module_id, prelude_module.krate());\n+                self.def_collector.import_all_macros_exported(self.module_id, prelude_module.krate);\n             }\n         }\n \n@@ -635,38 +640,42 @@ where\n         modules[res].scope.legacy_macros = modules[self.module_id].scope.legacy_macros.clone();\n         modules[self.module_id].children.insert(name.clone(), res);\n         let resolution = Resolution {\n-            def: PerNs::types(Module::new(self.def_collector.def_map.krate, res).into()),\n+            def: PerNs::types(\n+                ModuleId { krate: self.def_collector.def_map.krate, module_id: res }.into(),\n+            ),\n             import: None,\n         };\n         self.def_collector.update(self.module_id, None, &[(name, resolution)]);\n         res\n     }\n \n     fn define_def(&mut self, def: &raw::DefData) {\n-        let module = Module::new(self.def_collector.def_map.krate, self.module_id);\n-        let ctx = LocationCtx::new(self.def_collector.db, module.id, self.file_id);\n+        let module =\n+            ModuleId { krate: self.def_collector.def_map.krate, module_id: self.module_id };\n+        let ctx = LocationCtx::new(self.def_collector.db, module, self.file_id);\n \n-        macro_rules! def {\n-            ($kind:ident, $ast_id:ident) => {\n-                $kind { id: AstItemDef::from_ast_id(ctx, $ast_id) }.into()\n-            };\n-        }\n         let name = def.name.clone();\n         let def: PerNs = match def.kind {\n-            raw::DefKind::Function(ast_id) => PerNs::values(def!(Function, ast_id)),\n+            raw::DefKind::Function(ast_id) => {\n+                PerNs::values(FunctionId::from_ast_id(ctx, ast_id).into())\n+            }\n             raw::DefKind::Struct(ast_id) => {\n-                let s = def!(Struct, ast_id);\n+                let s = StructId::from_ast_id(ctx, ast_id).into();\n                 PerNs::both(s, s)\n             }\n             raw::DefKind::Union(ast_id) => {\n-                let s = def!(Union, ast_id);\n+                let s = UnionId::from_ast_id(ctx, ast_id).into();\n                 PerNs::both(s, s)\n             }\n-            raw::DefKind::Enum(ast_id) => PerNs::types(def!(Enum, ast_id)),\n-            raw::DefKind::Const(ast_id) => PerNs::values(def!(Const, ast_id)),\n-            raw::DefKind::Static(ast_id) => PerNs::values(def!(Static, ast_id)),\n-            raw::DefKind::Trait(ast_id) => PerNs::types(def!(Trait, ast_id)),\n-            raw::DefKind::TypeAlias(ast_id) => PerNs::types(def!(TypeAlias, ast_id)),\n+            raw::DefKind::Enum(ast_id) => PerNs::types(EnumId::from_ast_id(ctx, ast_id).into()),\n+            raw::DefKind::Const(ast_id) => PerNs::values(ConstId::from_ast_id(ctx, ast_id).into()),\n+            raw::DefKind::Static(ast_id) => {\n+                PerNs::values(StaticId::from_ast_id(ctx, ast_id).into())\n+            }\n+            raw::DefKind::Trait(ast_id) => PerNs::types(TraitId::from_ast_id(ctx, ast_id).into()),\n+            raw::DefKind::TypeAlias(ast_id) => {\n+                PerNs::types(TypeAliasId::from_ast_id(ctx, ast_id).into())\n+            }\n         };\n         let resolution = Resolution { def, import: None };\n         self.def_collector.update(self.module_id, None, &[(name, resolution)])\n@@ -678,10 +687,8 @@ where\n         // Case 1: macro rules, define a macro in crate-global mutable scope\n         if is_macro_rules(&mac.path) {\n             if let Some(name) = &mac.name {\n-                let macro_id =\n-                    MacroDefId { ast_id, krate: self.def_collector.def_map.krate.crate_id };\n-                let macro_ = MacroDef { id: macro_id };\n-                self.def_collector.define_macro(self.module_id, name.clone(), macro_, mac.export);\n+                let macro_id = MacroDefId { ast_id, krate: self.def_collector.def_map.krate };\n+                self.def_collector.define_macro(self.module_id, name.clone(), macro_id, mac.export);\n             }\n             return;\n         }\n@@ -691,10 +698,10 @@ where\n         if let Some(macro_def) = mac.path.as_ident().and_then(|name| {\n             self.def_collector.def_map[self.module_id].scope.get_legacy_macro(&name)\n         }) {\n-            let def = macro_def.id;\n-            let macro_call_id = self.def_collector.db.intern_macro(MacroCallLoc { def, ast_id });\n+            let macro_call_id =\n+                self.def_collector.db.intern_macro(MacroCallLoc { def: macro_def, ast_id });\n \n-            self.def_collector.collect_macro_expansion(self.module_id, macro_call_id, def);\n+            self.def_collector.collect_macro_expansion(self.module_id, macro_call_id, macro_def);\n             return;\n         }\n \n@@ -733,15 +740,16 @@ fn is_macro_rules(path: &Path) -> bool {\n \n #[cfg(test)]\n mod tests {\n-    use ra_db::SourceDatabase;\n-\n-    use super::*;\n-    use crate::{db::DefDatabase, mock::MockDatabase, Crate};\n     use ra_arena::Arena;\n+    use ra_db::{fixture::WithFixture, SourceDatabase};\n     use rustc_hash::FxHashSet;\n \n+    use crate::{db::DefDatabase2, test_db::TestDB};\n+\n+    use super::*;\n+\n     fn do_collect_defs(\n-        db: &impl DefDatabase,\n+        db: &impl DefDatabase2,\n         def_map: CrateDefMap,\n         monitor: MacroStackMonitor,\n     ) -> CrateDefMap {\n@@ -760,12 +768,11 @@ mod tests {\n     }\n \n     fn do_limited_resolve(code: &str, limit: u32, poison_limit: u32) -> CrateDefMap {\n-        let (db, _source_root, _) = MockDatabase::with_single_file(&code);\n-        let crate_id = db.crate_graph().iter().next().unwrap();\n-        let krate = Crate { crate_id };\n+        let (db, _file_id) = TestDB::with_single_file(&code);\n+        let krate = db.crate_graph().iter().next().unwrap();\n \n         let def_map = {\n-            let edition = krate.edition(&db);\n+            let edition = db.crate_graph().edition(krate);\n             let mut modules: Arena<CrateModuleId, ModuleData> = Arena::default();\n             let root = modules.alloc(ModuleData::default());\n             CrateDefMap {", "previous_filename": "crates/ra_hir/src/nameres/collector.rs"}, {"sha": "298b0b0c724b302e6fb582a699b8a86382feaebc", "filename": "crates/ra_hir_def/src/nameres/per_ns.rs", "status": "renamed", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fper_ns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fper_ns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fper_ns.rs?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -1,6 +1,8 @@\n //! FIXME: write short doc here\n \n-use crate::{MacroDef, ModuleDef};\n+use hir_expand::MacroDefId;\n+\n+use crate::ModuleDefId;\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub enum Namespace {\n@@ -12,11 +14,11 @@ pub enum Namespace {\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct PerNs {\n-    pub types: Option<ModuleDef>,\n-    pub values: Option<ModuleDef>,\n+    pub types: Option<ModuleDefId>,\n+    pub values: Option<ModuleDefId>,\n     /// Since macros has different type, many methods simply ignore it.\n     /// We can only use special method like `get_macros` to access it.\n-    pub macros: Option<MacroDef>,\n+    pub macros: Option<MacroDefId>,\n }\n \n impl Default for PerNs {\n@@ -30,19 +32,19 @@ impl PerNs {\n         PerNs { types: None, values: None, macros: None }\n     }\n \n-    pub fn values(t: ModuleDef) -> PerNs {\n+    pub fn values(t: ModuleDefId) -> PerNs {\n         PerNs { types: None, values: Some(t), macros: None }\n     }\n \n-    pub fn types(t: ModuleDef) -> PerNs {\n+    pub fn types(t: ModuleDefId) -> PerNs {\n         PerNs { types: Some(t), values: None, macros: None }\n     }\n \n-    pub fn both(types: ModuleDef, values: ModuleDef) -> PerNs {\n+    pub fn both(types: ModuleDefId, values: ModuleDefId) -> PerNs {\n         PerNs { types: Some(types), values: Some(values), macros: None }\n     }\n \n-    pub fn macros(macro_: MacroDef) -> PerNs {\n+    pub fn macros(macro_: MacroDefId) -> PerNs {\n         PerNs { types: None, values: None, macros: Some(macro_) }\n     }\n \n@@ -54,15 +56,15 @@ impl PerNs {\n         self.types.is_some() && self.values.is_some() && self.macros.is_some()\n     }\n \n-    pub fn take_types(self) -> Option<ModuleDef> {\n+    pub fn take_types(self) -> Option<ModuleDefId> {\n         self.types\n     }\n \n-    pub fn take_values(self) -> Option<ModuleDef> {\n+    pub fn take_values(self) -> Option<ModuleDefId> {\n         self.values\n     }\n \n-    pub fn get_macros(&self) -> Option<MacroDef> {\n+    pub fn get_macros(&self) -> Option<MacroDefId> {\n         self.macros\n     }\n ", "previous_filename": "crates/ra_hir/src/nameres/per_ns.rs"}, {"sha": "cb47fa317d2d07a01f8555143a16ce3cfa5df076", "filename": "crates/ra_hir_def/src/nameres/raw.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -14,6 +14,7 @@ use ra_syntax::{\n     ast::{self, AttrsOwner, NameOwner},\n     AstNode, AstPtr, SourceFile,\n };\n+use test_utils::tested_by;\n \n use crate::{attr::Attr, db::DefDatabase2, path::Path, FileAstId, HirFileId, ModuleSource, Source};\n \n@@ -297,8 +298,7 @@ impl RawItemsCollector {\n             self.push_item(current_module, attrs, RawItemKind::Module(item));\n             return;\n         }\n-        // FIXME: restore this mark once we complete hir splitting\n-        // tested_by!(name_res_works_for_broken_modules);\n+        tested_by!(name_res_works_for_broken_modules);\n     }\n \n     fn add_use_item(&mut self, current_module: Option<Module>, use_item: ast::UseItem) {"}, {"sha": "52bd0aa91e8ce7ada8188c8e1a1ed545329b0301", "filename": "crates/ra_hir_def/src/nameres/tests.rs", "status": "renamed", "additions": 48, "deletions": 104, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -1,35 +1,31 @@\n-mod macros;\n mod globs;\n mod incremental;\n-mod primitives;\n+mod macros;\n mod mod_resolution;\n+mod primitives;\n \n use std::sync::Arc;\n \n use insta::assert_snapshot;\n-use ra_db::SourceDatabase;\n+use ra_db::{fixture::WithFixture, SourceDatabase};\n use test_utils::covers;\n \n-use crate::{\n-    mock::{CrateGraphFixture, MockDatabase},\n-    Crate,\n-};\n+use crate::{db::DefDatabase2, nameres::*, test_db::TestDB, CrateModuleId};\n \n-use super::*;\n+fn def_map(fixtute: &str) -> String {\n+    let dm = compute_crate_def_map(fixtute);\n+    render_crate_def_map(&dm)\n+}\n \n-fn compute_crate_def_map(fixture: &str, graph: Option<CrateGraphFixture>) -> Arc<CrateDefMap> {\n-    let mut db = MockDatabase::with_files(fixture);\n-    if let Some(graph) = graph {\n-        db.set_crate_graph_from_fixture(graph);\n-    }\n-    let crate_id = db.crate_graph().iter().next().unwrap();\n-    let krate = Crate { crate_id };\n+fn compute_crate_def_map(fixture: &str) -> Arc<CrateDefMap> {\n+    let db = TestDB::with_files(fixture);\n+    let krate = db.crate_graph().iter().next().unwrap();\n     db.crate_def_map(krate)\n }\n \n fn render_crate_def_map(map: &CrateDefMap) -> String {\n     let mut buf = String::new();\n-    go(&mut buf, map, \"\\ncrate\", map.root);\n+    go(&mut buf, map, \"\\ncrate\", map.root());\n     return buf.trim().to_string();\n \n     fn go(buf: &mut String, map: &CrateDefMap, path: &str, module: CrateModuleId) {\n@@ -70,16 +66,6 @@ fn render_crate_def_map(map: &CrateDefMap) -> String {\n     }\n }\n \n-fn def_map(fixtute: &str) -> String {\n-    let dm = compute_crate_def_map(fixtute, None);\n-    render_crate_def_map(&dm)\n-}\n-\n-fn def_map_with_crate_graph(fixture: &str, graph: CrateGraphFixture) -> String {\n-    let dm = compute_crate_def_map(fixture, Some(graph));\n-    render_crate_def_map(&dm)\n-}\n-\n #[test]\n fn crate_def_map_smoke_test() {\n     let map = def_map(\n@@ -234,23 +220,19 @@ fn re_exports() {\n #[test]\n fn std_prelude() {\n     covers!(std_prelude);\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:test_crate\n         use Foo::*;\n \n-        //- /lib.rs\n+        //- /lib.rs crate:test_crate\n         mod prelude;\n         #[prelude_import]\n         use prelude::*;\n \n         //- /prelude.rs\n         pub enum Foo { Bar, Baz };\n         \",\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", [\"test_crate\"]),\n-            \"test_crate\": (\"/lib.rs\", []),\n-        },\n     );\n     assert_snapshot!(map, @r###\"\n         \u22eecrate\n@@ -279,9 +261,9 @@ fn can_import_enum_variant() {\n \n #[test]\n fn edition_2015_imports() {\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:other_crate edition:2015\n         mod foo;\n         mod bar;\n \n@@ -292,13 +274,9 @@ fn edition_2015_imports() {\n         use bar::Bar;\n         use other_crate::FromLib;\n \n-        //- /lib.rs\n+        //- /lib.rs crate:other_crate edition:2018\n         struct FromLib;\n         \",\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", \"2015\", [\"other_crate\"]),\n-            \"other_crate\": (\"/lib.rs\", \"2018\", []),\n-        },\n     );\n \n     assert_snapshot!(map, @r###\"\n@@ -343,18 +321,14 @@ fn item_map_using_self() {\n \n #[test]\n fn item_map_across_crates() {\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:test_crate\n         use test_crate::Baz;\n \n-        //- /lib.rs\n+        //- /lib.rs crate:test_crate\n         pub struct Baz;\n         \",\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", [\"test_crate\"]),\n-            \"test_crate\": (\"/lib.rs\", []),\n-        },\n     );\n \n     assert_snapshot!(map, @r###\"\n@@ -365,9 +339,9 @@ fn item_map_across_crates() {\n \n #[test]\n fn extern_crate_rename() {\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:alloc\n         extern crate alloc as alloc_crate;\n \n         mod alloc;\n@@ -376,13 +350,9 @@ fn extern_crate_rename() {\n         //- /sync.rs\n         use alloc_crate::Arc;\n \n-        //- /lib.rs\n+        //- /lib.rs crate:alloc\n         struct Arc;\n         \",\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", [\"alloc\"]),\n-            \"alloc\": (\"/lib.rs\", []),\n-        },\n     );\n \n     assert_snapshot!(map, @r###\"\n@@ -397,9 +367,9 @@ fn extern_crate_rename() {\n \n #[test]\n fn extern_crate_rename_2015_edition() {\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:alloc edition:2015\n         extern crate alloc as alloc_crate;\n \n         mod alloc;\n@@ -408,13 +378,9 @@ fn extern_crate_rename_2015_edition() {\n         //- /sync.rs\n         use alloc_crate::Arc;\n \n-        //- /lib.rs\n+        //- /lib.rs crate:alloc\n         struct Arc;\n         \",\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", \"2015\", [\"alloc\"]),\n-            \"alloc\": (\"/lib.rs\", []),\n-        },\n     );\n \n     assert_snapshot!(map,\n@@ -431,24 +397,21 @@ fn extern_crate_rename_2015_edition() {\n \n #[test]\n fn import_across_source_roots() {\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /lib.rs\n+        //- /main.rs crate:main deps:test_crate\n+        use test_crate::a::b::C;\n+\n+        //- root /test_crate/\n+\n+        //- /test_crate/lib.rs crate:test_crate\n         pub mod a {\n             pub mod b {\n                 pub struct C;\n             }\n         }\n \n-        //- root /main/\n-\n-        //- /main/main.rs\n-        use test_crate::a::b::C;\n         \",\n-        crate_graph! {\n-            \"main\": (\"/main/main.rs\", [\"test_crate\"]),\n-            \"test_crate\": (\"/lib.rs\", []),\n-        },\n     );\n \n     assert_snapshot!(map, @r###\"\n@@ -459,23 +422,19 @@ fn import_across_source_roots() {\n \n #[test]\n fn reexport_across_crates() {\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:test_crate\n         use test_crate::Baz;\n \n-        //- /lib.rs\n+        //- /lib.rs crate:test_crate\n         pub use foo::Baz;\n \n         mod foo;\n \n         //- /foo.rs\n         pub struct Baz;\n         \",\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", [\"test_crate\"]),\n-            \"test_crate\": (\"/lib.rs\", []),\n-        },\n     );\n \n     assert_snapshot!(map, @r###\"\n@@ -486,19 +445,15 @@ fn reexport_across_crates() {\n \n #[test]\n fn values_dont_shadow_extern_crates() {\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:foo\n         fn foo() {}\n         use foo::Bar;\n \n-        //- /foo/lib.rs\n+        //- /foo/lib.rs crate:foo\n         pub struct Bar;\n         \",\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", [\"foo\"]),\n-            \"foo\": (\"/foo/lib.rs\", []),\n-        },\n     );\n \n     assert_snapshot!(map, @r###\"\n@@ -510,11 +465,12 @@ fn values_dont_shadow_extern_crates() {\n \n #[test]\n fn cfg_not_test() {\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         r#\"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:std\n         use {Foo, Bar, Baz};\n-        //- /lib.rs\n+\n+        //- /lib.rs crate:std\n         #[prelude_import]\n         pub use self::prelude::*;\n         mod prelude {\n@@ -526,10 +482,6 @@ fn cfg_not_test() {\n             pub struct Baz;\n         }\n         \"#,\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", [\"std\"]),\n-            \"std\": (\"/lib.rs\", []),\n-        },\n     );\n \n     assert_snapshot!(map, @r###\"\n@@ -542,11 +494,12 @@ fn cfg_not_test() {\n \n #[test]\n fn cfg_test() {\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         r#\"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:std\n         use {Foo, Bar, Baz};\n-        //- /lib.rs\n+\n+        //- /lib.rs crate:std cfg:test,feature=foo,feature=bar,opt=42\n         #[prelude_import]\n         pub use self::prelude::*;\n         mod prelude {\n@@ -558,15 +511,6 @@ fn cfg_test() {\n             pub struct Baz;\n         }\n         \"#,\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", [\"std\"]),\n-            \"std\": (\"/lib.rs\", [], cfg = {\n-                \"test\",\n-                \"feature\" = \"foo\",\n-                \"feature\" = \"bar\",\n-                \"opt\" = \"42\",\n-            }),\n-        },\n     );\n \n     assert_snapshot!(map, @r###\"", "previous_filename": "crates/ra_hir/src/nameres/tests.rs"}, {"sha": "5b03fe36504a46cc2475be629188112c06e545b4", "filename": "crates/ra_hir_def/src/nameres/tests/globs.rs", "status": "renamed", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -76,18 +76,14 @@ fn glob_2() {\n #[test]\n fn glob_across_crates() {\n     covers!(glob_across_crates);\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:test_crate\n         use test_crate::*;\n \n-        //- /lib.rs\n+        //- /lib.rs crate:test_crate\n         pub struct Baz;\n         \",\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", [\"test_crate\"]),\n-            \"test_crate\": (\"/lib.rs\", []),\n-        },\n     );\n     assert_snapshot!(map, @r###\"\n    \u22eecrate", "previous_filename": "crates/ra_hir/src/nameres/tests/globs.rs"}, {"sha": "80dcec62f0f99b3f0f008915a80ed943730b94e5", "filename": "crates/ra_hir_def/src/nameres/tests/incremental.rs", "status": "renamed", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -1,13 +1,12 @@\n-use super::*;\n-\n use std::sync::Arc;\n \n use ra_db::{SourceDatabase, SourceDatabaseExt};\n \n+use super::*;\n+\n fn check_def_map_is_not_recomputed(initial: &str, file_change: &str) {\n-    let (mut db, pos) = MockDatabase::with_position(initial);\n-    let crate_id = db.crate_graph().iter().next().unwrap();\n-    let krate = Crate { crate_id };\n+    let (mut db, pos) = TestDB::with_position(initial);\n+    let krate = db.crate_graph().iter().next().unwrap();\n     {\n         let events = db.log_executed(|| {\n             db.crate_def_map(krate);\n@@ -92,7 +91,7 @@ fn adding_inner_items_should_not_invalidate_def_map() {\n \n #[test]\n fn typing_inside_a_macro_should_not_invalidate_def_map() {\n-    let (mut db, pos) = MockDatabase::with_position(\n+    let (mut db, pos) = TestDB::with_position(\n         \"\n         //- /lib.rs\n         macro_rules! m {\n@@ -112,29 +111,22 @@ fn typing_inside_a_macro_should_not_invalidate_def_map() {\n         m!(X);\n         \",\n     );\n+    let krate = db.crate_graph().iter().next().unwrap();\n     {\n         let events = db.log_executed(|| {\n-            let src = crate::Source {\n-                file_id: pos.file_id.into(),\n-                ast: crate::ModuleSource::new(&db, Some(pos.file_id), None),\n-            };\n-            let module = crate::Module::from_definition(&db, src).unwrap();\n-            let decls = module.declarations(&db);\n-            assert_eq!(decls.len(), 18);\n+            let crate_def_map = db.crate_def_map(krate);\n+            let (_, module_data) = crate_def_map.modules.iter().last().unwrap();\n+            assert_eq!(module_data.scope.items.len(), 1);\n         });\n         assert!(format!(\"{:?}\", events).contains(\"crate_def_map\"), \"{:#?}\", events)\n     }\n     db.set_file_text(pos.file_id, Arc::new(\"m!(Y);\".to_string()));\n \n     {\n         let events = db.log_executed(|| {\n-            let src = crate::Source {\n-                file_id: pos.file_id.into(),\n-                ast: crate::ModuleSource::new(&db, Some(pos.file_id), None),\n-            };\n-            let module = crate::Module::from_definition(&db, src).unwrap();\n-            let decls = module.declarations(&db);\n-            assert_eq!(decls.len(), 18);\n+            let crate_def_map = db.crate_def_map(krate);\n+            let (_, module_data) = crate_def_map.modules.iter().last().unwrap();\n+            assert_eq!(module_data.scope.items.len(), 1);\n         });\n         assert!(!format!(\"{:?}\", events).contains(\"crate_def_map\"), \"{:#?}\", events)\n     }", "previous_filename": "crates/ra_hir/src/nameres/tests/incremental.rs"}, {"sha": "704065633a5f329a0cb6a6b050e5b5918fc74a6b", "filename": "crates/ra_hir_def/src/nameres/tests/macros.rs", "status": "renamed", "additions": 25, "deletions": 58, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -71,27 +71,23 @@ fn macro_rules_can_define_modules() {\n \n #[test]\n fn macro_rules_from_other_crates_are_visible() {\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:foo\n         foo::structs!(Foo, Bar)\n         mod bar;\n \n         //- /bar.rs\n         use crate::*;\n \n-        //- /lib.rs\n+        //- /lib.rs crate:foo\n         #[macro_export]\n         macro_rules! structs {\n             ($($i:ident),*) => {\n                 $(struct $i { field: u32 } )*\n             }\n         }\n         \",\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", [\"foo\"]),\n-            \"foo\": (\"/lib.rs\", []),\n-        },\n     );\n     assert_snapshot!(map, @r###\"\n    \u22eecrate\n@@ -108,27 +104,23 @@ fn macro_rules_from_other_crates_are_visible() {\n \n #[test]\n fn macro_rules_export_with_local_inner_macros_are_visible() {\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:foo\n         foo::structs!(Foo, Bar)\n         mod bar;\n \n         //- /bar.rs\n         use crate::*;\n \n-        //- /lib.rs\n+        //- /lib.rs crate:foo\n         #[macro_export(local_inner_macros)]\n         macro_rules! structs {\n             ($($i:ident),*) => {\n                 $(struct $i { field: u32 } )*\n             }\n         }\n         \",\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", [\"foo\"]),\n-            \"foo\": (\"/lib.rs\", []),\n-        },\n     );\n     assert_snapshot!(map, @r###\"\n    \u22eecrate\n@@ -145,9 +137,9 @@ fn macro_rules_export_with_local_inner_macros_are_visible() {\n \n #[test]\n fn unexpanded_macro_should_expand_by_fixedpoint_loop() {\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:foo\n         macro_rules! baz {\n             () => {\n                 use foo::bar;\n@@ -158,7 +150,7 @@ fn unexpanded_macro_should_expand_by_fixedpoint_loop() {\n         bar!();\n         baz!();\n \n-        //- /lib.rs\n+        //- /lib.rs crate:foo\n         #[macro_export]\n         macro_rules! foo {\n             () => {\n@@ -172,10 +164,6 @@ fn unexpanded_macro_should_expand_by_fixedpoint_loop() {\n             }\n         }\n         \",\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", [\"foo\"]),\n-            \"foo\": (\"/lib.rs\", []),\n-        },\n     );\n     assert_snapshot!(map, @r###\"\n    \u22eecrate\n@@ -188,9 +176,9 @@ fn unexpanded_macro_should_expand_by_fixedpoint_loop() {\n #[test]\n fn macro_rules_from_other_crates_are_visible_with_macro_use() {\n     covers!(macro_rules_from_other_crates_are_visible_with_macro_use);\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:foo\n         structs!(Foo);\n         structs_priv!(Bar);\n         structs_not_exported!(MacroNotResolved1);\n@@ -205,7 +193,7 @@ fn macro_rules_from_other_crates_are_visible_with_macro_use() {\n         structs!(Baz);\n         crate::structs!(MacroNotResolved3);\n \n-        //- /lib.rs\n+        //- /lib.rs crate:foo\n         #[macro_export]\n         macro_rules! structs {\n             ($i:ident) => { struct $i; }\n@@ -222,10 +210,6 @@ fn macro_rules_from_other_crates_are_visible_with_macro_use() {\n             }\n         }\n         \",\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", [\"foo\"]),\n-            \"foo\": (\"/lib.rs\", []),\n-        },\n     );\n     assert_snapshot!(map, @r###\"\n    \u22eecrate\n@@ -242,9 +226,9 @@ fn macro_rules_from_other_crates_are_visible_with_macro_use() {\n #[test]\n fn prelude_is_macro_use() {\n     covers!(prelude_is_macro_use);\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:foo\n         structs!(Foo);\n         structs_priv!(Bar);\n         structs_outside!(Out);\n@@ -256,7 +240,7 @@ fn prelude_is_macro_use() {\n         structs!(Baz);\n         crate::structs!(MacroNotResolved3);\n \n-        //- /lib.rs\n+        //- /lib.rs crate:foo\n         #[prelude_import]\n         use self::prelude::*;\n \n@@ -279,10 +263,6 @@ fn prelude_is_macro_use() {\n             ($i:ident) => { struct $i; }\n         }\n         \",\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", [\"foo\"]),\n-            \"foo\": (\"/lib.rs\", []),\n-        },\n     );\n     assert_snapshot!(map, @r###\"\n    \u22eecrate\n@@ -447,16 +427,16 @@ fn type_value_macro_live_in_different_scopes() {\n \n #[test]\n fn macro_use_can_be_aliased() {\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:foo\n         #[macro_use]\n         extern crate foo;\n \n         foo!(Direct);\n         bar!(Alias);\n \n-        //- /lib.rs\n+        //- /lib.rs crate:foo\n         use crate::foo as bar;\n \n         mod m {\n@@ -466,10 +446,6 @@ fn macro_use_can_be_aliased() {\n             }\n         }\n         \",\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", [\"foo\"]),\n-            \"foo\": (\"/lib.rs\", []),\n-        },\n     );\n     assert_snapshot!(map, @r###\"\n         \u22eecrate\n@@ -533,9 +509,9 @@ fn path_qualified_macros() {\n fn macro_dollar_crate_is_correct_in_item() {\n     covers!(macro_dollar_crate_self);\n     covers!(macro_dollar_crate_other);\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:foo\n         #[macro_use]\n         extern crate foo;\n \n@@ -554,7 +530,7 @@ fn macro_dollar_crate_is_correct_in_item() {\n         not_current1!();\n         foo::not_current2!();\n \n-        //- /lib.rs\n+        //- /lib.rs crate:foo\n         mod m {\n             #[macro_export]\n             macro_rules! not_current1 {\n@@ -574,10 +550,6 @@ fn macro_dollar_crate_is_correct_in_item() {\n         struct Bar;\n         struct Baz;\n         \",\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", [\"foo\"]),\n-            \"foo\": (\"/lib.rs\", []),\n-        },\n     );\n     assert_snapshot!(map, @r###\"\n         \u22eecrate\n@@ -596,12 +568,12 @@ fn macro_dollar_crate_is_correct_in_item() {\n fn macro_dollar_crate_is_correct_in_indirect_deps() {\n     covers!(macro_dollar_crate_other);\n     // From std\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         r#\"\n-        //- /main.rs\n+        //- /main.rs crate:main deps:std\n         foo!();\n \n-        //- /std.rs\n+        //- /std.rs crate:std deps:core\n         #[prelude_import]\n         use self::prelude::*;\n \n@@ -612,7 +584,7 @@ fn macro_dollar_crate_is_correct_in_indirect_deps() {\n         #[macro_use]\n         mod std_macros;\n \n-        //- /core.rs\n+        //- /core.rs crate:core\n         #[macro_export]\n         macro_rules! foo {\n             () => {\n@@ -622,11 +594,6 @@ fn macro_dollar_crate_is_correct_in_indirect_deps() {\n \n         pub struct bar;\n         \"#,\n-        crate_graph! {\n-            \"main\": (\"/main.rs\", [\"std\"]),\n-            \"std\": (\"/std.rs\", [\"core\"]),\n-            \"core\": (\"/core.rs\", []),\n-        },\n     );\n     assert_snapshot!(map, @r###\"\n         \u22eecrate", "previous_filename": "crates/ra_hir/src/nameres/tests/macros.rs"}, {"sha": "dee364a1422fb975ba5462d30385780e43944327", "filename": "crates/ra_hir_def/src/nameres/tests/mod_resolution.rs", "status": "renamed", "additions": 35, "deletions": 12, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -2,7 +2,7 @@ use super::*;\n \n #[test]\n fn name_res_works_for_broken_modules() {\n-    // covers!(name_res_works_for_broken_modules);\n+    covers!(name_res_works_for_broken_modules);\n     let map = def_map(\n         \"\n         //- /lib.rs\n@@ -54,18 +54,15 @@ fn nested_module_resolution() {\n \n #[test]\n fn module_resolution_works_for_non_standard_filenames() {\n-    let map = def_map_with_crate_graph(\n+    let map = def_map(\n         \"\n-        //- /my_library.rs\n+        //- /my_library.rs crate:my_library\n         mod foo;\n         use self::foo::Bar;\n \n         //- /foo/mod.rs\n         pub struct Bar;\n         \",\n-        crate_graph! {\n-            \"my_library\": (\"/my_library.rs\", []),\n-        },\n     );\n \n     assert_snapshot!(map, @r###\"\n@@ -650,19 +647,45 @@ fn module_resolution_decl_inside_inline_module_in_non_crate_root_2() {\n \n #[test]\n fn unresolved_module_diagnostics() {\n-    let diagnostics = MockDatabase::with_files(\n+    let db = TestDB::with_files(\n         r\"\n         //- /lib.rs\n         mod foo;\n         mod bar;\n         mod baz {}\n         //- /foo.rs\n         \",\n-    )\n-    .diagnostics();\n-\n-    assert_snapshot!(diagnostics, @r###\"\n-    \"mod bar;\": unresolved module\n+    );\n+    let krate = db.crate_graph().iter().next().unwrap();\n+\n+    let crate_def_map = db.crate_def_map(krate);\n+\n+    insta::assert_debug_snapshot!(\n+        crate_def_map.diagnostics,\n+        @r###\"\n+    [\n+        UnresolvedModule {\n+            module: CrateModuleId(\n+                0,\n+            ),\n+            declaration: AstId {\n+                file_id: HirFileId(\n+                    FileId(\n+                        FileId(\n+                            0,\n+                        ),\n+                    ),\n+                ),\n+                file_ast_id: FileAstId {\n+                    raw: ErasedFileAstId(\n+                        1,\n+                    ),\n+                    _ty: PhantomData,\n+                },\n+            },\n+            candidate: \"bar.rs\",\n+        },\n+    ]\n     \"###\n     );\n }", "previous_filename": "crates/ra_hir/src/nameres/tests/mod_resolution.rs"}, {"sha": "0e27086585c3635dcc2a84027f0073bff87c2322", "filename": "crates/ra_hir_def/src/nameres/tests/primitives.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fprimitives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fprimitives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fprimitives.rs?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "previous_filename": "crates/ra_hir/src/nameres/tests/primitives.rs"}, {"sha": "f91a5b41df2bb434a777c439a7ee3845acf193b5", "filename": "crates/ra_hir_def/src/test_db.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_hir_def%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftest_db.rs?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -0,0 +1,76 @@\n+//! Database used for testing `hir_def`.\n+\n+use std::{\n+    panic,\n+    sync::{Arc, Mutex},\n+};\n+\n+use ra_db::{salsa, CrateId, FileId, FileLoader, FileLoaderDelegate};\n+use relative_path::RelativePath;\n+\n+#[salsa::database(\n+    ra_db::SourceDatabaseExtStorage,\n+    ra_db::SourceDatabaseStorage,\n+    hir_expand::db::AstDatabaseStorage,\n+    crate::db::InternDatabaseStorage,\n+    crate::db::DefDatabase2Storage\n+)]\n+#[derive(Debug, Default)]\n+pub struct TestDB {\n+    runtime: salsa::Runtime<TestDB>,\n+    events: Mutex<Option<Vec<salsa::Event<TestDB>>>>,\n+}\n+\n+impl salsa::Database for TestDB {\n+    fn salsa_runtime(&self) -> &salsa::Runtime<Self> {\n+        &self.runtime\n+    }\n+\n+    fn salsa_event(&self, event: impl Fn() -> salsa::Event<TestDB>) {\n+        let mut events = self.events.lock().unwrap();\n+        if let Some(events) = &mut *events {\n+            events.push(event());\n+        }\n+    }\n+}\n+\n+impl panic::RefUnwindSafe for TestDB {}\n+\n+impl FileLoader for TestDB {\n+    fn file_text(&self, file_id: FileId) -> Arc<String> {\n+        FileLoaderDelegate(self).file_text(file_id)\n+    }\n+    fn resolve_relative_path(\n+        &self,\n+        anchor: FileId,\n+        relative_path: &RelativePath,\n+    ) -> Option<FileId> {\n+        FileLoaderDelegate(self).resolve_relative_path(anchor, relative_path)\n+    }\n+    fn relevant_crates(&self, file_id: FileId) -> Arc<Vec<CrateId>> {\n+        FileLoaderDelegate(self).relevant_crates(file_id)\n+    }\n+}\n+\n+impl TestDB {\n+    pub fn log(&self, f: impl FnOnce()) -> Vec<salsa::Event<TestDB>> {\n+        *self.events.lock().unwrap() = Some(Vec::new());\n+        f();\n+        self.events.lock().unwrap().take().unwrap()\n+    }\n+\n+    pub fn log_executed(&self, f: impl FnOnce()) -> Vec<String> {\n+        let events = self.log(f);\n+        events\n+            .into_iter()\n+            .filter_map(|e| match e.kind {\n+                // This pretty horrible, but `Debug` is the only way to inspect\n+                // QueryDescriptor at the moment.\n+                salsa::EventKind::WillExecute { database_key } => {\n+                    Some(format!(\"{:?}\", database_key))\n+                }\n+                _ => None,\n+            })\n+            .collect()\n+    }\n+}"}, {"sha": "09ca401794eae55df799242dbcac4e5f113273ec", "filename": "crates/ra_ide_api/src/completion/complete_path.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -18,15 +18,15 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n     match def {\n         hir::ModuleDef::Module(module) => {\n             let module_scope = module.scope(ctx.db);\n-            for (name, res) in module_scope.entries() {\n-                if let Some(hir::ModuleDef::BuiltinType(..)) = res.def.take_types() {\n+            for (name, def, import) in module_scope {\n+                if let hir::ScopeDef::ModuleDef(hir::ModuleDef::BuiltinType(..)) = def {\n                     if ctx.use_item_syntax.is_some() {\n                         tested_by!(dont_complete_primitive_in_use);\n                         continue;\n                     }\n                 }\n                 if Some(module) == ctx.module {\n-                    if let Some(import) = res.import {\n+                    if let Some(import) = import {\n                         if let Either::A(use_tree) = module.import_source(ctx.db, import) {\n                             if use_tree.syntax().text_range().contains_inclusive(ctx.offset) {\n                                 // for `use self::foo<|>`, don't suggest `foo` as a completion\n@@ -36,7 +36,7 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n                         }\n                     }\n                 }\n-                acc.add_resolution(ctx, name.to_string(), &res.def.into());\n+                acc.add_resolution(ctx, name.to_string(), &def);\n             }\n         }\n         hir::ModuleDef::Adt(_) | hir::ModuleDef::TypeAlias(_) => {"}, {"sha": "227937f462a626641beb929fe4402270f5c5f2f5", "filename": "xtask/tests/tidy-tests/docs.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4fd742d6bc23e2f61d0980e15234f09d7e715b76/xtask%2Ftests%2Ftidy-tests%2Fdocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd742d6bc23e2f61d0980e15234f09d7e715b76/xtask%2Ftests%2Ftidy-tests%2Fdocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftests%2Ftidy-tests%2Fdocs.rs?ref=4fd742d6bc23e2f61d0980e15234f09d7e715b76", "patch": "@@ -36,6 +36,7 @@ fn is_hidden(entry: &DirEntry) -> bool {\n fn no_docs_comments() {\n     let crates = project_root().join(\"crates\");\n     let iter = WalkDir::new(crates);\n+    let mut missing_docs = Vec::new();\n     for f in iter.into_iter().filter_entry(|e| !is_hidden(e)) {\n         let f = f.unwrap();\n         if f.file_type().is_dir() {\n@@ -54,12 +55,14 @@ fn no_docs_comments() {\n         let mut line = String::new();\n         reader.read_line(&mut line).unwrap();\n         if !line.starts_with(\"//!\") {\n-            panic!(\n-                \"\\nMissing docs strings\\n\\\n-                 module: {}\\n\\\n-                 Need add doc for module\\n\",\n-                f.path().display()\n-            )\n+            missing_docs.push(f.path().display().to_string());\n         }\n     }\n+    if !missing_docs.is_empty() {\n+        panic!(\n+            \"\\nMissing docs strings\\n\\n\\\n+             modules:\\n{}\\n\\n\",\n+            missing_docs.join(\"\\n\")\n+        )\n+    }\n }"}]}