{"sha": "ecca8c532850a2cce403264bd3c85961a38c8308", "node_id": "C_kwDOAAsO6NoAKGVjY2E4YzUzMjg1MGEyY2NlNDAzMjY0YmQzYzg1OTYxYTM4YzgzMDg", "commit": {"author": {"name": "Markus Everling", "email": "markuseverling@gmail.com", "date": "2022-11-25T02:36:11Z"}, "committer": {"name": "Markus Everling", "email": "markuseverling@gmail.com", "date": "2022-11-25T02:39:59Z"}, "message": "Changes according to code review", "tree": {"sha": "8a3d6c59aa2e68addf01b14b96030d5685a27065", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a3d6c59aa2e68addf01b14b96030d5685a27065"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ecca8c532850a2cce403264bd3c85961a38c8308", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ecca8c532850a2cce403264bd3c85961a38c8308", "html_url": "https://github.com/rust-lang/rust/commit/ecca8c532850a2cce403264bd3c85961a38c8308", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ecca8c532850a2cce403264bd3c85961a38c8308/comments", "author": {"login": "Sp00ph", "id": 61327188, "node_id": "MDQ6VXNlcjYxMzI3MTg4", "avatar_url": "https://avatars.githubusercontent.com/u/61327188?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Sp00ph", "html_url": "https://github.com/Sp00ph", "followers_url": "https://api.github.com/users/Sp00ph/followers", "following_url": "https://api.github.com/users/Sp00ph/following{/other_user}", "gists_url": "https://api.github.com/users/Sp00ph/gists{/gist_id}", "starred_url": "https://api.github.com/users/Sp00ph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Sp00ph/subscriptions", "organizations_url": "https://api.github.com/users/Sp00ph/orgs", "repos_url": "https://api.github.com/users/Sp00ph/repos", "events_url": "https://api.github.com/users/Sp00ph/events{/privacy}", "received_events_url": "https://api.github.com/users/Sp00ph/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Sp00ph", "id": 61327188, "node_id": "MDQ6VXNlcjYxMzI3MTg4", "avatar_url": "https://avatars.githubusercontent.com/u/61327188?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Sp00ph", "html_url": "https://github.com/Sp00ph", "followers_url": "https://api.github.com/users/Sp00ph/followers", "following_url": "https://api.github.com/users/Sp00ph/following{/other_user}", "gists_url": "https://api.github.com/users/Sp00ph/gists{/gist_id}", "starred_url": "https://api.github.com/users/Sp00ph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Sp00ph/subscriptions", "organizations_url": "https://api.github.com/users/Sp00ph/orgs", "repos_url": "https://api.github.com/users/Sp00ph/repos", "events_url": "https://api.github.com/users/Sp00ph/events{/privacy}", "received_events_url": "https://api.github.com/users/Sp00ph/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1bf25e2bdbebad2f1f42118ba1d2c4a7ae4f7b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1bf25e2bdbebad2f1f42118ba1d2c4a7ae4f7b0", "html_url": "https://github.com/rust-lang/rust/commit/a1bf25e2bdbebad2f1f42118ba1d2c4a7ae4f7b0"}], "stats": {"total": 325, "additions": 181, "deletions": 144}, "files": [{"sha": "89feb361ddc116d2885e7c948ced45a27af6a211", "filename": "library/alloc/src/collections/vec_deque/drain.rs", "status": "modified", "additions": 46, "deletions": 33, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/ecca8c532850a2cce403264bd3c85961a38c8308/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fdrain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecca8c532850a2cce403264bd3c85961a38c8308/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fdrain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fdrain.rs?ref=ecca8c532850a2cce403264bd3c85961a38c8308", "patch": "@@ -53,27 +53,36 @@ impl<'a, T, A: Allocator> Drain<'a, T, A> {\n     }\n \n     // Only returns pointers to the slices, as that's\n-    // all we need to drop them\n-    fn as_slices(&self) -> (*mut [T], *mut [T]) {\n+    // all we need to drop them. May only be called if `self.remaining != 0`.\n+    unsafe fn as_slices(&self) -> (*mut [T], *mut [T]) {\n         unsafe {\n             let deque = self.deque.as_ref();\n-            let wrapped_start = deque.wrap_idx(self.idx);\n-\n-            if self.remaining <= deque.capacity() - wrapped_start {\n-                // there's only one contigous slice\n-                (\n-                    ptr::slice_from_raw_parts_mut(deque.ptr().add(wrapped_start), self.remaining),\n-                    &mut [] as *mut [T],\n-                )\n+            // FIXME: This is doing almost exactly the same thing as the else branch in `VecDeque::slice_ranges`.\n+            // Unfortunately, we can't just call `slice_ranges` here, as the deque's `len` is currently\n+            // just `drain_start`, so the range check would (almost) always panic. Between temporarily\n+            // adjusting the deques `len` to call `slice_ranges`, and just copy pasting the `slice_ranges`\n+            // implementation, this seemed like the less hacky solution, though it might be good to\n+            // find a better one in the future.\n+\n+            // because `self.remaining != 0`, we know that `self.idx < deque.original_len`, so it's a valid\n+            // logical index.\n+            let wrapped_start = deque.to_physical_idx(self.idx);\n+\n+            let head_len = deque.capacity() - wrapped_start;\n+\n+            let (a_range, b_range) = if head_len >= self.remaining {\n+                (wrapped_start..wrapped_start + self.remaining, 0..0)\n             } else {\n-                let head_len = deque.capacity() - wrapped_start;\n-                // this will never overflow due to the if condition\n                 let tail_len = self.remaining - head_len;\n-                (\n-                    ptr::slice_from_raw_parts_mut(deque.ptr().add(wrapped_start), head_len),\n-                    ptr::slice_from_raw_parts_mut(deque.ptr(), tail_len),\n-                )\n-            }\n+                (wrapped_start..deque.capacity(), 0..tail_len)\n+            };\n+\n+            // SAFETY: the range `self.idx..self.idx+self.remaining` lies strictly inside\n+            // the range `0..deque.original_len`. because of this, and because of the fact\n+            // that we acquire `a_range` and `b_range` exactly like `slice_ranges` would,\n+            // it's guaranteed that `a_range` and `b_range` represent valid ranges into\n+            // the deques buffer.\n+            (deque.buffer_range(a_range), deque.buffer_range(b_range))\n         }\n     }\n }\n@@ -103,8 +112,9 @@ impl<T, A: Allocator> Drop for Drain<'_, T, A> {\n         impl<'r, 'a, T, A: Allocator> Drop for DropGuard<'r, 'a, T, A> {\n             fn drop(&mut self) {\n                 if self.0.remaining != 0 {\n-                    let (front, back) = self.0.as_slices();\n                     unsafe {\n+                        // SAFETY: We just checked that `self.remaining != 0`.\n+                        let (front, back) = self.0.as_slices();\n                         ptr::drop_in_place(front);\n                         ptr::drop_in_place(back);\n                     }\n@@ -133,7 +143,7 @@ impl<T, A: Allocator> Drop for Drain<'_, T, A> {\n                         source_deque.len = 0;\n                     }\n                     (0, _) => {\n-                        source_deque.head = source_deque.wrap_idx(drain_len);\n+                        source_deque.head = source_deque.to_physical_idx(drain_len);\n                         source_deque.len = orig_len - drain_len;\n                     }\n                     (_, 0) => {\n@@ -143,15 +153,15 @@ impl<T, A: Allocator> Drop for Drain<'_, T, A> {\n                         if head_len <= tail_len {\n                             source_deque.wrap_copy(\n                                 source_deque.head,\n-                                source_deque.wrap_idx(drain_len),\n+                                source_deque.to_physical_idx(drain_len),\n                                 head_len,\n                             );\n-                            source_deque.head = source_deque.wrap_idx(drain_len);\n+                            source_deque.head = source_deque.to_physical_idx(drain_len);\n                             source_deque.len = orig_len - drain_len;\n                         } else {\n                             source_deque.wrap_copy(\n-                                source_deque.wrap_idx(head_len + drain_len),\n-                                source_deque.wrap_idx(head_len),\n+                                source_deque.to_physical_idx(head_len + drain_len),\n+                                source_deque.to_physical_idx(head_len),\n                                 tail_len,\n                             );\n                             source_deque.len = orig_len - drain_len;\n@@ -162,14 +172,17 @@ impl<T, A: Allocator> Drop for Drain<'_, T, A> {\n         }\n \n         let guard = DropGuard(self);\n-        let (front, back) = guard.0.as_slices();\n-        unsafe {\n-            // since idx is a logical index, we don't need to worry about wrapping.\n-            guard.0.idx += front.len();\n-            guard.0.remaining -= front.len();\n-            ptr::drop_in_place(front);\n-            guard.0.remaining = 0;\n-            ptr::drop_in_place(back);\n+        if guard.0.remaining != 0 {\n+            unsafe {\n+                // SAFETY: We just checked that `self.remaining != 0`.\n+                let (front, back) = guard.0.as_slices();\n+                // since idx is a logical index, we don't need to worry about wrapping.\n+                guard.0.idx += front.len();\n+                guard.0.remaining -= front.len();\n+                ptr::drop_in_place(front);\n+                guard.0.remaining = 0;\n+                ptr::drop_in_place(back);\n+            }\n         }\n \n         // Dropping `guard` handles moving the remaining elements into place.\n@@ -185,7 +198,7 @@ impl<T, A: Allocator> Iterator for Drain<'_, T, A> {\n         if self.remaining == 0 {\n             return None;\n         }\n-        let wrapped_idx = unsafe { self.deque.as_ref().wrap_idx(self.idx) };\n+        let wrapped_idx = unsafe { self.deque.as_ref().to_physical_idx(self.idx) };\n         self.idx += 1;\n         self.remaining -= 1;\n         Some(unsafe { self.deque.as_mut().buffer_read(wrapped_idx) })\n@@ -206,7 +219,7 @@ impl<T, A: Allocator> DoubleEndedIterator for Drain<'_, T, A> {\n             return None;\n         }\n         self.remaining -= 1;\n-        let wrapped_idx = unsafe { self.deque.as_ref().wrap_idx(self.idx + self.remaining) };\n+        let wrapped_idx = unsafe { self.deque.as_ref().to_physical_idx(self.idx + self.remaining) };\n         Some(unsafe { self.deque.as_mut().buffer_read(wrapped_idx) })\n     }\n }"}, {"sha": "d9f3937144d04c0c9d51ba7c3e9f2b1729679f86", "filename": "library/alloc/src/collections/vec_deque/iter.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ecca8c532850a2cce403264bd3c85961a38c8308/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecca8c532850a2cce403264bd3c85961a38c8308/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter.rs?ref=ecca8c532850a2cce403264bd3c85961a38c8308", "patch": "@@ -39,15 +39,6 @@ impl<T> Clone for Iter<'_, T> {\n impl<'a, T> Iterator for Iter<'a, T> {\n     type Item = &'a T;\n \n-    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n-        let m = match self.i1.advance_by(n) {\n-            Ok(_) => return Ok(()),\n-            Err(m) => m,\n-        };\n-        mem::swap(&mut self.i1, &mut self.i2);\n-        self.i1.advance_by(n - m).map_err(|o| o + m)\n-    }\n-\n     #[inline]\n     fn next(&mut self) -> Option<&'a T> {\n         match self.i1.next() {\n@@ -64,6 +55,15 @@ impl<'a, T> Iterator for Iter<'a, T> {\n         }\n     }\n \n+    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        let m = match self.i1.advance_by(n) {\n+            Ok(_) => return Ok(()),\n+            Err(m) => m,\n+        };\n+        mem::swap(&mut self.i1, &mut self.i2);\n+        self.i1.advance_by(n - m).map_err(|o| o + m)\n+    }\n+\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let len = self.len();\n@@ -75,17 +75,16 @@ impl<'a, T> Iterator for Iter<'a, T> {\n         F: FnMut(Acc, Self::Item) -> Acc,\n     {\n         let accum = self.i1.fold(accum, &mut f);\n-        self.i2.fold(accum, f)\n+        self.i2.fold(accum, &mut f)\n     }\n \n     fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n     where\n-        Self: Sized,\n         F: FnMut(B, Self::Item) -> R,\n         R: Try<Output = B>,\n     {\n         let acc = self.i1.try_fold(init, &mut f)?;\n-        self.i2.try_fold(acc, f)\n+        self.i2.try_fold(acc, &mut f)\n     }\n \n     #[inline]\n@@ -117,7 +116,7 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n             None => {\n                 // most of the time, the iterator will either always\n                 // call next(), or always call next_back(). By swapping\n-                // the iterators once the first one is empty, we ensure\n+                // the iterators once the second one is empty, we ensure\n                 // that the first branch is taken as often as possible,\n                 // without sacrificing correctness, as i2 is empty anyways\n                 mem::swap(&mut self.i1, &mut self.i2);\n@@ -141,17 +140,16 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n         F: FnMut(Acc, Self::Item) -> Acc,\n     {\n         let accum = self.i2.rfold(accum, &mut f);\n-        self.i1.rfold(accum, f)\n+        self.i1.rfold(accum, &mut f)\n     }\n \n     fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n     where\n-        Self: Sized,\n         F: FnMut(B, Self::Item) -> R,\n         R: Try<Output = B>,\n     {\n         let acc = self.i2.try_rfold(init, &mut f)?;\n-        self.i1.try_rfold(acc, f)\n+        self.i1.try_rfold(acc, &mut f)\n     }\n }\n "}, {"sha": "2c59d95cd53e9360101d312f477ea452dcd24e75", "filename": "library/alloc/src/collections/vec_deque/iter_mut.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ecca8c532850a2cce403264bd3c85961a38c8308/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecca8c532850a2cce403264bd3c85961a38c8308/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter_mut.rs?ref=ecca8c532850a2cce403264bd3c85961a38c8308", "patch": "@@ -67,17 +67,16 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n         F: FnMut(Acc, Self::Item) -> Acc,\n     {\n         let accum = self.i1.fold(accum, &mut f);\n-        self.i2.fold(accum, f)\n+        self.i2.fold(accum, &mut f)\n     }\n \n     fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n     where\n-        Self: Sized,\n         F: FnMut(B, Self::Item) -> R,\n         R: Try<Output = B>,\n     {\n         let acc = self.i1.try_fold(init, &mut f)?;\n-        self.i2.try_fold(acc, f)\n+        self.i2.try_fold(acc, &mut f)\n     }\n \n     #[inline]\n@@ -133,17 +132,16 @@ impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n         F: FnMut(Acc, Self::Item) -> Acc,\n     {\n         let accum = self.i2.rfold(accum, &mut f);\n-        self.i1.rfold(accum, f)\n+        self.i1.rfold(accum, &mut f)\n     }\n \n     fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n     where\n-        Self: Sized,\n         F: FnMut(B, Self::Item) -> R,\n         R: Try<Output = B>,\n     {\n         let acc = self.i2.try_rfold(init, &mut f)?;\n-        self.i1.try_rfold(acc, f)\n+        self.i1.try_rfold(acc, &mut f)\n     }\n }\n "}, {"sha": "52b46e448c458c8b2625b5683f99ff582d691c92", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 104, "deletions": 78, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/ecca8c532850a2cce403264bd3c85961a38c8308/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecca8c532850a2cce403264bd3c85961a38c8308/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=ecca8c532850a2cce403264bd3c85961a38c8308", "patch": "@@ -91,7 +91,12 @@ pub struct VecDeque<\n     T,\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n > {\n+    // `self[0]`, if it exists, is `buf[head]`.\n+    // `head < buf.capacity()`, unless `buf.capacity() == 0` when `head == 0`.\n     head: usize,\n+    // the number of initialized elements, starting from the one at `head` and potentially wrapping around.\n+    // if `len == 0`, the exact value of `head` is unimportant.\n+    // if `T` is zero-Sized, then `self.len <= usize::MAX`, otherwise `self.len <= isize::MAX as usize`.\n     len: usize,\n     buf: RawVec<T, A>,\n }\n@@ -106,15 +111,7 @@ impl<T: Clone, A: Allocator + Clone> Clone for VecDeque<T, A> {\n \n     fn clone_from(&mut self, other: &Self) {\n         self.clear();\n-        self.head = 0;\n-        self.reserve(other.len);\n-\n-        let (a, b) = other.as_slices();\n-        unsafe {\n-            self.write_iter(0, a.iter().cloned(), &mut 0);\n-            self.write_iter(a.len(), b.iter().cloned(), &mut 0);\n-        }\n-        self.len = other.len;\n+        self.extend(other.iter().cloned());\n     }\n }\n \n@@ -133,13 +130,11 @@ unsafe impl<#[may_dangle] T, A: Allocator> Drop for VecDeque<T, A> {\n             }\n         }\n \n-        if mem::needs_drop::<T>() {\n-            let (front, back) = self.as_mut_slices();\n-            unsafe {\n-                let _back_dropper = Dropper(back);\n-                // use drop for [T]\n-                ptr::drop_in_place(front);\n-            }\n+        let (front, back) = self.as_mut_slices();\n+        unsafe {\n+            let _back_dropper = Dropper(back);\n+            // use drop for [T]\n+            ptr::drop_in_place(front);\n         }\n         // RawVec handles deallocation\n     }\n@@ -175,6 +170,15 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         }\n     }\n \n+    /// Returns a slice pointer into the buffer.\n+    /// `range` must lie inside `0..self.capacity()`.\n+    #[inline]\n+    unsafe fn buffer_range(&self, range: Range<usize>) -> *mut [T] {\n+        unsafe {\n+            ptr::slice_from_raw_parts_mut(self.ptr().add(range.start), range.end - range.start)\n+        }\n+    }\n+\n     /// Returns `true` if the buffer is at full capacity.\n     #[inline]\n     fn is_full(&self) -> bool {\n@@ -189,7 +193,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     }\n \n     #[inline]\n-    fn wrap_idx(&self, idx: usize) -> usize {\n+    fn to_physical_idx(&self, idx: usize) -> usize {\n         self.wrap_add(self.head, idx)\n     }\n \n@@ -473,6 +477,10 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         debug_assert!(new_capacity >= old_capacity);\n \n         // Move the shortest contiguous section of the ring buffer\n+        //\n+        // H := head\n+        // L := last element (`self.to_physical_idx(self.len - 1)`)\n+        //\n         //    H           L\n         //   [o o o o o o o . ]\n         //    H           L\n@@ -597,7 +605,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self, index: usize) -> Option<&T> {\n         if index < self.len {\n-            let idx = self.wrap_idx(index);\n+            let idx = self.to_physical_idx(index);\n             unsafe { Some(&*self.ptr().add(idx)) }\n         } else {\n             None\n@@ -626,7 +634,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self, index: usize) -> Option<&mut T> {\n         if index < self.len {\n-            let idx = self.wrap_idx(index);\n+            let idx = self.to_physical_idx(index);\n             unsafe { Some(&mut *self.ptr().add(idx)) }\n         } else {\n             None\n@@ -660,8 +668,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     pub fn swap(&mut self, i: usize, j: usize) {\n         assert!(i < self.len());\n         assert!(j < self.len());\n-        let ri = self.wrap_idx(i);\n-        let rj = self.wrap_idx(j);\n+        let ri = self.to_physical_idx(i);\n+        let rj = self.to_physical_idx(j);\n         unsafe { ptr::swap(self.ptr().add(ri), self.ptr().add(rj)) }\n     }\n \n@@ -913,6 +921,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n             if self.len == 0 {\n                 self.head = 0;\n             } else if self.head >= target_cap && tail_outside {\n+                //  H := head\n+                //  L := last element\n                 //                    H           L\n                 //   [. . . . . . . . o o o o o o o . ]\n                 //    H           L\n@@ -923,6 +933,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n                 }\n                 self.head = 0;\n             } else if self.head < target_cap && tail_outside {\n+                //  H := head\n+                //  L := last element\n                 //          H           L\n                 //   [. . . o o o o o o o . . . . . . ]\n                 //      L   H\n@@ -932,6 +944,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n                     self.copy_nonoverlapping(target_cap, 0, len);\n                 }\n             } else if self.head >= target_cap {\n+                //  H := head\n+                //  L := last element\n                 //            L                   H\n                 //   [o o o o o . . . . . . . . . o o ]\n                 //            L   H\n@@ -998,11 +1012,6 @@ impl<T, A: Allocator> VecDeque<T, A> {\n                 return;\n             }\n \n-            if !mem::needs_drop::<T>() {\n-                self.len = len;\n-                return;\n-            }\n-\n             let (front, back) = self.as_mut_slices();\n             if len > front.len() {\n                 let begin = len - front.len();\n@@ -1102,18 +1111,10 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     #[inline]\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn as_slices(&self) -> (&[T], &[T]) {\n-        if self.is_contiguous() {\n-            (unsafe { slice::from_raw_parts(self.ptr().add(self.head), self.len) }, &[])\n-        } else {\n-            let head_len = self.capacity() - self.head;\n-            let tail_len = self.len - head_len;\n-            unsafe {\n-                (\n-                    slice::from_raw_parts(self.ptr().add(self.head), head_len),\n-                    slice::from_raw_parts(self.ptr(), tail_len),\n-                )\n-            }\n-        }\n+        let (a_range, b_range) = self.slice_ranges(..);\n+        // SAFETY: `slice_ranges` always returns valid ranges into\n+        // the physical buffer.\n+        unsafe { (&*self.buffer_range(a_range), &*self.buffer_range(b_range)) }\n     }\n \n     /// Returns a pair of slices which contain, in order, the contents of the\n@@ -1144,18 +1145,10 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     #[inline]\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn as_mut_slices(&mut self) -> (&mut [T], &mut [T]) {\n-        if self.is_contiguous() {\n-            (unsafe { slice::from_raw_parts_mut(self.ptr().add(self.head), self.len) }, &mut [])\n-        } else {\n-            let head_len = self.capacity() - self.head;\n-            let tail_len = self.len - head_len;\n-            unsafe {\n-                (\n-                    slice::from_raw_parts_mut(self.ptr().add(self.head), head_len),\n-                    slice::from_raw_parts_mut(self.ptr(), tail_len),\n-                )\n-            }\n-        }\n+        let (a_range, b_range) = self.slice_ranges(..);\n+        // SAFETY: `slice_ranges` always returns valid ranges into\n+        // the physical buffer.\n+        unsafe { (&mut *self.buffer_range(a_range), &mut *self.buffer_range(b_range)) }\n     }\n \n     /// Returns the number of elements in the deque.\n@@ -1192,18 +1185,37 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         self.len == 0\n     }\n \n+    /// Given a range into the logical buffer of the deque, this function\n+    /// return two ranges into the physical buffer that correspond to\n+    /// the given range.\n     fn slice_ranges<R>(&self, range: R) -> (Range<usize>, Range<usize>)\n     where\n         R: RangeBounds<usize>,\n     {\n         let Range { start, end } = slice::range(range, ..self.len);\n-        let a_len = self.len.min(self.capacity() - self.head);\n-        if end <= a_len {\n-            (start..end, 0..0)\n-        } else if start >= a_len {\n-            (0..0, start - a_len..end - a_len)\n+        let len = end - start;\n+\n+        if len == 0 {\n+            (0..0, 0..0)\n         } else {\n-            (start..a_len, 0..end - a_len)\n+            // `slice::range` guarantees that `start <= end <= self.len`.\n+            // because `len != 0`, we know that `start < end`, so `start < self.len`\n+            // and the indexing is valid.\n+            let wrapped_start = self.to_physical_idx(start);\n+\n+            // this subtraction can never overflow because `wrapped_start` is\n+            // at most `self.capacity()` (and if `self.capacity != 0`, then `wrapped_start` is strictly less\n+            // than `self.capacity`).\n+            let head_len = self.capacity() - wrapped_start;\n+\n+            if head_len >= len {\n+                // we know that `len + wrapped_start <= self.capacity <= usize::MAX`, so this addition can't overflow\n+                (wrapped_start..wrapped_start + len, 0..0)\n+            } else {\n+                // can't overflow because of the if condition\n+                let tail_len = len - head_len;\n+                (wrapped_start..self.capacity(), 0..tail_len)\n+            }\n         }\n     }\n \n@@ -1233,9 +1245,14 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     where\n         R: RangeBounds<usize>,\n     {\n-        let (a, b) = self.as_slices();\n         let (a_range, b_range) = self.slice_ranges(range);\n-        Iter::new(a[a_range].iter(), b[b_range].iter())\n+        // SAFETY: The ranges returned by `slice_ranges`\n+        // are valid ranges into the physical buffer, so\n+        // it's ok to pass them to `buffer_range` and\n+        // dereference the result.\n+        let a = unsafe { &*self.buffer_range(a_range) };\n+        let b = unsafe { &*self.buffer_range(b_range) };\n+        Iter::new(a.iter(), b.iter())\n     }\n \n     /// Creates an iterator that covers the specified mutable range in the deque.\n@@ -1269,8 +1286,13 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         R: RangeBounds<usize>,\n     {\n         let (a_range, b_range) = self.slice_ranges(range);\n-        let (a, b) = self.as_mut_slices();\n-        IterMut::new(a[a_range].iter_mut(), b[b_range].iter_mut())\n+        // SAFETY: The ranges returned by `slice_ranges`\n+        // are valid ranges into the physical buffer, so\n+        // it's ok to pass them to `buffer_range` and\n+        // dereference the result.\n+        let a = unsafe { &mut *self.buffer_range(a_range) };\n+        let b = unsafe { &mut *self.buffer_range(b_range) };\n+        IterMut::new(a.iter_mut(), b.iter_mut())\n     }\n \n     /// Removes the specified range from the deque in bulk, returning all\n@@ -1509,7 +1531,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n             None\n         } else {\n             let old_head = self.head;\n-            self.head = self.wrap_idx(1);\n+            self.head = self.to_physical_idx(1);\n             self.len -= 1;\n             Some(unsafe { self.buffer_read(old_head) })\n         }\n@@ -1535,7 +1557,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n             None\n         } else {\n             self.len -= 1;\n-            Some(unsafe { self.buffer_read(self.wrap_idx(self.len)) })\n+            Some(unsafe { self.buffer_read(self.to_physical_idx(self.len)) })\n         }\n     }\n \n@@ -1583,7 +1605,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n             self.grow();\n         }\n \n-        unsafe { self.buffer_write(self.wrap_idx(self.len), value) }\n+        unsafe { self.buffer_write(self.to_physical_idx(self.len), value) }\n         self.len += 1;\n     }\n \n@@ -1700,16 +1722,16 @@ impl<T, A: Allocator> VecDeque<T, A> {\n             // and panicked.\n             unsafe {\n                 // see `remove()` for explanation why this wrap_copy() call is safe.\n-                self.wrap_copy(self.wrap_idx(index), self.wrap_idx(index + 1), k);\n-                self.buffer_write(self.wrap_idx(index), value);\n+                self.wrap_copy(self.to_physical_idx(index), self.to_physical_idx(index + 1), k);\n+                self.buffer_write(self.to_physical_idx(index), value);\n                 self.len += 1;\n             }\n         } else {\n             let old_head = self.head;\n             self.head = self.wrap_sub(self.head, 1);\n             unsafe {\n                 self.wrap_copy(old_head, self.head, index);\n-                self.buffer_write(self.wrap_idx(index), value);\n+                self.buffer_write(self.to_physical_idx(index), value);\n                 self.len += 1;\n             }\n         }\n@@ -1742,7 +1764,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n             return None;\n         }\n \n-        let wrapped_idx = self.wrap_idx(index);\n+        let wrapped_idx = self.to_physical_idx(index);\n \n         let elem = unsafe { Some(self.buffer_read(wrapped_idx)) };\n \n@@ -1755,7 +1777,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n             self.len -= 1;\n         } else {\n             let old_head = self.head;\n-            self.head = self.wrap_idx(1);\n+            self.head = self.to_physical_idx(1);\n             unsafe { self.wrap_copy(old_head, self.head, index) };\n             self.len -= 1;\n         }\n@@ -1866,14 +1888,14 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         self.reserve(other.len);\n         unsafe {\n             let (left, right) = other.as_slices();\n-            self.copy_slice(self.wrap_idx(self.len), left);\n+            self.copy_slice(self.to_physical_idx(self.len), left);\n             // no overflow, because self.capacity() >= old_cap + left.len() >= self.len + left.len()\n-            self.copy_slice(self.wrap_idx(self.len + left.len()), right);\n+            self.copy_slice(self.to_physical_idx(self.len + left.len()), right);\n         }\n         // SAFETY: Update pointers after copying to avoid leaving doppelganger\n         // in case of panics.\n         self.len += other.len;\n-        // Silently drop values in `other`.\n+        // Now that we own its values, forget everything in `other`.\n         other.len = 0;\n         other.head = 0;\n     }\n@@ -1982,8 +2004,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         // buffer without it being full emerge\n         debug_assert!(self.is_full());\n         let old_cap = self.capacity();\n-        // if the cap was 0, we need to reserve at least 1.\n-        self.buf.reserve(old_cap, old_cap.max(1));\n+        self.buf.reserve_for_push(old_cap);\n         unsafe {\n             self.handle_capacity_increase(old_cap);\n         }\n@@ -2265,16 +2286,16 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     unsafe fn rotate_left_inner(&mut self, mid: usize) {\n         debug_assert!(mid * 2 <= self.len());\n         unsafe {\n-            self.wrap_copy(self.head, self.wrap_idx(self.len), mid);\n+            self.wrap_copy(self.head, self.to_physical_idx(self.len), mid);\n         }\n-        self.head = self.wrap_idx(mid);\n+        self.head = self.to_physical_idx(mid);\n     }\n \n     unsafe fn rotate_right_inner(&mut self, k: usize) {\n         debug_assert!(k * 2 <= self.len());\n         self.head = self.wrap_sub(self.head, k);\n         unsafe {\n-            self.wrap_copy(self.wrap_idx(self.len), self.head, k);\n+            self.wrap_copy(self.to_physical_idx(self.len), self.head, k);\n         }\n     }\n \n@@ -2532,8 +2553,13 @@ impl<T: Clone, A: Allocator> VecDeque<T, A> {\n \n /// Returns the index in the underlying buffer for a given logical element index.\n #[inline]\n-fn wrap_index(index: usize, size: usize) -> usize {\n-    if index >= size { index - size } else { index }\n+fn wrap_index(logical_index: usize, capacity: usize) -> usize {\n+    debug_assert!(\n+        (logical_index == 0 && capacity == 0)\n+            || logical_index < capacity\n+            || (logical_index - capacity) < capacity\n+    );\n+    if logical_index >= capacity { logical_index - capacity } else { logical_index }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "adcc8862a8c316d24181e95f208905924fca8daf", "filename": "library/alloc/src/collections/vec_deque/spec_extend.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ecca8c532850a2cce403264bd3c85961a38c8308/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fspec_extend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecca8c532850a2cce403264bd3c85961a38c8308/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fspec_extend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fspec_extend.rs?ref=ecca8c532850a2cce403264bd3c85961a38c8308", "patch": "@@ -38,7 +38,7 @@ where\n                 // and `room == self.capacity() - self.len`\n                 //   => `self.len + room <= self.capacity()`\n                 self.write_iter_wrapping(\n-                    self.wrap_idx(self.len),\n+                    self.to_physical_idx(self.len),\n                     ByRefSized(&mut iter).take(room),\n                     room,\n                 );\n@@ -63,8 +63,9 @@ where\n             );\n             self.reserve(additional);\n \n-            let written =\n-                unsafe { self.write_iter_wrapping(self.wrap_idx(self.len), iter, additional) };\n+            let written = unsafe {\n+                self.write_iter_wrapping(self.to_physical_idx(self.len), iter, additional)\n+            };\n \n             debug_assert_eq!(\n                 additional, written,\n@@ -87,7 +88,7 @@ impl<T, A: Allocator> SpecExtend<T, vec::IntoIter<T>> for VecDeque<T, A> {\n         self.reserve(slice.len());\n \n         unsafe {\n-            self.copy_slice(self.wrap_idx(self.len), slice);\n+            self.copy_slice(self.to_physical_idx(self.len), slice);\n             self.len += slice.len();\n         }\n         iterator.forget_remaining_elements();\n@@ -113,7 +114,7 @@ where\n         self.reserve(slice.len());\n \n         unsafe {\n-            self.copy_slice(self.wrap_idx(self.len), slice);\n+            self.copy_slice(self.to_physical_idx(self.len), slice);\n             self.len += slice.len();\n         }\n     }"}, {"sha": "553f8da3e2d01efe8db37f1d376db73f002c0152", "filename": "library/alloc/src/collections/vec_deque/tests.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ecca8c532850a2cce403264bd3c85961a38c8308/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecca8c532850a2cce403264bd3c85961a38c8308/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=ecca8c532850a2cce403264bd3c85961a38c8308", "patch": "@@ -257,13 +257,14 @@ fn test_swap_panic() {\n #[test]\n fn test_reserve_exact() {\n     let mut tester: VecDeque<i32> = VecDeque::with_capacity(1);\n-    assert!(tester.capacity() == 1);\n+    assert_eq!(tester.capacity(), 1);\n     tester.reserve_exact(50);\n-    assert!(tester.capacity() >= 50);\n+    assert_eq!(tester.capacity(), 50);\n     tester.reserve_exact(40);\n-    assert!(tester.capacity() >= 40);\n+    // reserving won't shrink the buffer\n+    assert_eq!(tester.capacity(), 50);\n     tester.reserve_exact(200);\n-    assert!(tester.capacity() >= 200);\n+    assert_eq!(tester.capacity(), 200);\n }\n \n #[test]\n@@ -479,7 +480,7 @@ fn make_contiguous_big_tail() {\n     assert_eq!(tester.capacity(), 15);\n     assert_eq!((&[9, 8, 7, 6, 5, 4, 3] as &[_], &[0, 1, 2] as &[_]), tester.as_slices());\n \n-    let expected_start = tester.wrap_idx(tester.len);\n+    let expected_start = tester.to_physical_idx(tester.len);\n     tester.make_contiguous();\n     assert_eq!(tester.head, expected_start);\n     assert_eq!((&[9, 8, 7, 6, 5, 4, 3, 0, 1, 2] as &[_], &[] as &[_]), tester.as_slices());\n@@ -679,7 +680,7 @@ fn test_drain() {\n \n     let cap = tester.capacity();\n     for len in 0..=cap {\n-        for head in 0..=cap {\n+        for head in 0..cap {\n             for drain_start in 0..=len {\n                 for drain_end in drain_start..=len {\n                     tester.head = head;"}]}