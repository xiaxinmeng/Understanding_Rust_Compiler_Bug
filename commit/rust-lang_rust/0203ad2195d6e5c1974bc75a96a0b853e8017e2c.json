{"sha": "0203ad2195d6e5c1974bc75a96a0b853e8017e2c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyMDNhZDIxOTVkNmU1YzE5NzRiYzc1YTk2YTBiODUzZTgwMTdlMmM=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-03-31T17:29:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-31T17:29:29Z"}, "message": "Rollup merge of #70268 - tmiasko:sanitizer-docs, r=steveklabnik\n\nDocument ThreadSanitizer in unstable-book", "tree": {"sha": "2be3ce3232ea6ec3c7ddb749647687c17caedf80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2be3ce3232ea6ec3c7ddb749647687c17caedf80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0203ad2195d6e5c1974bc75a96a0b853e8017e2c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeg335CRBK7hj4Ov3rIwAAdHIIAAxpFsRzeNWbgJnv6+kSzOvP\ni0THj8sekR+ylh3cLp3oFXhiR7vP2CJ23Di0pJ3pllqA/MvZfXeHvLu+EiFL6oi7\n5qJmc1eurHRNH+J32xfGJOSD87sDr2mu8HWg7eWnqa/wfjTquQ3hWPgfUZmZZYKh\nlerrZD+uR7cpsZ8owjuiQaT3Ao2cneNHtLYvfBwDlGWbtnm9WgpasN9f1X2SGccW\ntSDJSIzv7Azjj1d+K+LQ0dhsUztk7Xb9iOSujDnKJmNjhHOn4Zlro4pLxV4Yu6RK\nezAFz+ZCZpuBpSMMUJnep/V8Y3H144Luwm9eqimAMT4Q0EaOQPg+LfiPEeaHw0Y=\n=sCuS\n-----END PGP SIGNATURE-----\n", "payload": "tree 2be3ce3232ea6ec3c7ddb749647687c17caedf80\nparent 3e31006f3c45b8672247cd00ff9d2789843b25b5\nparent 6582299cdd632b78f76d578ce6e751f0eac3a17a\nauthor Dylan DPC <dylan.dpc@gmail.com> 1585675769 +0200\ncommitter GitHub <noreply@github.com> 1585675769 +0200\n\nRollup merge of #70268 - tmiasko:sanitizer-docs, r=steveklabnik\n\nDocument ThreadSanitizer in unstable-book\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0203ad2195d6e5c1974bc75a96a0b853e8017e2c", "html_url": "https://github.com/rust-lang/rust/commit/0203ad2195d6e5c1974bc75a96a0b853e8017e2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0203ad2195d6e5c1974bc75a96a0b853e8017e2c/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e31006f3c45b8672247cd00ff9d2789843b25b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e31006f3c45b8672247cd00ff9d2789843b25b5", "html_url": "https://github.com/rust-lang/rust/commit/3e31006f3c45b8672247cd00ff9d2789843b25b5"}, {"sha": "6582299cdd632b78f76d578ce6e751f0eac3a17a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6582299cdd632b78f76d578ce6e751f0eac3a17a", "html_url": "https://github.com/rust-lang/rust/commit/6582299cdd632b78f76d578ce6e751f0eac3a17a"}], "stats": {"total": 236, "additions": 150, "deletions": 86}, "files": [{"sha": "7ebd8054ba0b0d19361365675332ba55b1d32eb2", "filename": "src/doc/unstable-book/src/compiler-flags/sanitizer.md", "status": "modified", "additions": 150, "deletions": 86, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/0203ad2195d6e5c1974bc75a96a0b853e8017e2c/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "raw_url": "https://github.com/rust-lang/rust/raw/0203ad2195d6e5c1974bc75a96a0b853e8017e2c/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md?ref=0203ad2195d6e5c1974bc75a96a0b853e8017e2c", "patch": "@@ -6,73 +6,78 @@ The tracking issue for this feature is: [#39699](https://github.com/rust-lang/ru\n \n This feature allows for use of one of following sanitizers:\n \n-* [AddressSanitizer][clang-asan] a faster memory error detector. Can\n-  detect out-of-bounds access to heap, stack, and globals, use after free, use\n-  after return, double free, invalid free, memory leaks.\n+* [AddressSanitizer][clang-asan] a fast memory error detector.\n * [LeakSanitizer][clang-lsan] a run-time memory leak detector.\n * [MemorySanitizer][clang-msan] a detector of uninitialized reads.\n * [ThreadSanitizer][clang-tsan] a fast data race detector.\n \n-To enable a sanitizer compile with `-Zsanitizer=...` option, where value is one\n-of `address`, `leak`, `memory` or `thread`.\n+To enable a sanitizer compile with `-Zsanitizer=address`, `-Zsanitizer=leak`,\n+`-Zsanitizer=memory` or `-Zsanitizer=thread`. Only a single sanitizer can be\n+enabled at a time.\n \n-# Examples\n+# AddressSanitizer\n \n-This sections show various issues that can be detected with sanitizers.  For\n-simplicity, the examples are prepared under assumption that optimization level\n-used is zero.\n+AddressSanitizer is a memory error detector. It can detect the following types\n+of bugs:\n \n-## AddressSanitizer\n+* Out of bound accesses to heap, stack and globals\n+* Use after free\n+* Use after return (runtime flag `ASAN_OPTIONS=detect_stack_use_after_return=1`)\n+* Use after scope\n+* Double-free, invalid free\n+* Memory leaks\n+\n+AddressSanitizer is supported on the following targets:\n+\n+* `x86_64-apple-darwin`\n+* `x86_64-unknown-linux-gnu`\n+\n+AddressSanitizer works with non-instrumented code although it will impede its\n+ability to detect some bugs.  It is not expected to produce false positive\n+reports.\n+\n+## Examples\n \n Stack buffer overflow:\n \n-```shell\n-$ cat a.rs\n+```rust\n fn main() {\n     let xs = [0, 1, 2, 3];\n     let _y = unsafe { *xs.as_ptr().offset(4) };\n }\n-$ rustc -Zsanitizer=address a.rs\n-$ ./a\n-=================================================================\n-==10029==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffcc15f43d0 at pc 0x55f77dc015c5 bp 0x7ffcc15f4390 sp 0x7ffcc15f4388\n-READ of size 4 at 0x7ffcc15f43d0 thread T0\n-    #0 0x55f77dc015c4 in a::main::hab3bd2a745c2d0ac (/tmp/a+0xa5c4)\n-    #1 0x55f77dc01cdb in std::rt::lang_start::_$u7b$$u7b$closure$u7d$$u7d$::haa8c76d1faa7b7ca (/tmp/a+0xacdb)\n-    #2 0x55f77dc90f02 in std::rt::lang_start_internal::_$u7b$$u7b$closure$u7d$$u7d$::hfeb9a1aef9ac820d /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libstd/rt.rs:48:12\n-    #3 0x55f77dc90f02 in std::panicking::try::do_call::h12f0919717b8e0a6 /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libstd/panicking.rs:288:39\n-    #4 0x55f77dc926c9 in __rust_maybe_catch_panic /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libpanic_unwind/lib.rs:80:7\n-    #5 0x55f77dc9197c in std::panicking::try::h413b21cdcd6cfd86 /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libstd/panicking.rs:267:12\n-    #6 0x55f77dc9197c in std::panic::catch_unwind::hc5cc8ef2fd73424d /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libstd/panic.rs:396:8\n-    #7 0x55f77dc9197c in std::rt::lang_start_internal::h2039f418ab92218f /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libstd/rt.rs:47:24\n-    #8 0x55f77dc01c61 in std::rt::lang_start::ha905d28f6b61d691 (/tmp/a+0xac61)\n-    #9 0x55f77dc0163a in main (/tmp/a+0xa63a)\n-    #10 0x7f9b3cf5bbba in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x26bba)\n-    #11 0x55f77dc01289 in _start (/tmp/a+0xa289)\n-\n-Address 0x7ffcc15f43d0 is located in stack of thread T0 at offset 48 in frame\n-    #0 0x55f77dc0135f in a::main::hab3bd2a745c2d0ac (/tmp/a+0xa35f)\n+```\n+\n+```shell\n+$ export RUSTFLAGS=-Zsanitizer=address RUSTDOCFLAGS=-Zsanitizer=address\n+$ cargo run -Zbuild-std --target x86_64-unknown-linux-gnu\n+==37882==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffe400e6250 at pc 0x5609a841fb20 bp 0x7ffe400e6210 sp 0x7ffe400e6208\n+READ of size 4 at 0x7ffe400e6250 thread T0\n+    #0 0x5609a841fb1f in example::main::h628ffc6626ed85b2 /.../src/main.rs:3:23\n+    ...\n+\n+Address 0x7ffe400e6250 is located in stack of thread T0 at offset 48 in frame\n+    #0 0x5609a841f8af in example::main::h628ffc6626ed85b2 /.../src/main.rs:1\n \n   This frame has 1 object(s):\n-    [32, 48) 'xs' <== Memory access at offset 48 overflows this variable\n+    [32, 48) 'xs' (line 2) <== Memory access at offset 48 overflows this variable\n HINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n       (longjmp and C++ exceptions *are* supported)\n-SUMMARY: AddressSanitizer: stack-buffer-overflow (/tmp/a+0xa5c4) in a::main::hab3bd2a745c2d0ac\n+SUMMARY: AddressSanitizer: stack-buffer-overflow /.../src/main.rs:3:23 in example::main::h628ffc6626ed85b2\n Shadow bytes around the buggy address:\n-  0x1000182b6820: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b6830: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b6840: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b6850: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b6860: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-=>0x1000182b6870: 00 00 00 00 f1 f1 f1 f1 00 00[f3]f3 00 00 00 00\n-  0x1000182b6880: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b6890: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b68a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b68b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b68c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014bf0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014c00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014c10: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014c20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014c30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+=>0x100048014c40: 00 00 00 00 f1 f1 f1 f1 00 00[f3]f3 00 00 00 00\n+  0x100048014c50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014c60: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014c70: f1 f1 f1 f1 00 00 f3 f3 00 00 00 00 00 00 00 00\n+  0x100048014c80: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1\n+  0x100048014c90: 00 00 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00\n Shadow byte legend (one shadow byte represents 8 application bytes):\n   Addressable:           00\n-  Partially addressable: 01 02 03 04 05 06 07 \n+  Partially addressable: 01 02 03 04 05 06 07\n   Heap left redzone:       fa\n   Freed heap region:       fd\n   Stack left redzone:      f1\n@@ -90,13 +95,12 @@ Shadow byte legend (one shadow byte represents 8 application bytes):\n   Left alloca redzone:     ca\n   Right alloca redzone:    cb\n   Shadow gap:              cc\n-==10029==ABORTING\n+==37882==ABORTING\n ```\n \n Use of a stack object after its scope has already ended:\n \n-```shell\n-$ cat b.rs\n+```rust\n static mut P: *mut usize = std::ptr::null_mut();\n \n fn main() {\n@@ -108,42 +112,38 @@ fn main() {\n         std::ptr::write_volatile(P, 123);\n     }\n }\n-$ rustc -Zsanitizer=address b.rs\n-$./b\n+```\n+\n+```shell\n+$ export RUSTFLAGS=-Zsanitizer=address RUSTDOCFLAGS=-Zsanitizer=address\n+$ cargo run -Zbuild-std --target x86_64-unknown-linux-gnu\n =================================================================\n-==424427==ERROR: AddressSanitizer: stack-use-after-scope on address 0x7fff67be6be0 at pc 0x5647a3ea4658 bp 0x7fff67be6b90 sp 0x7fff67be6b88\n-WRITE of size 8 at 0x7fff67be6be0 thread T0\n-    #0 0x5647a3ea4657 in core::ptr::write_volatile::h4b04601757d0376d (/tmp/b+0xb8657)\n-    #1 0x5647a3ea4432 in b::main::h5574a756e615c9cf (/tmp/b+0xb8432)\n-    #2 0x5647a3ea480b in std::rt::lang_start::_$u7b$$u7b$closure$u7d$$u7d$::hd57e7ee01866077e (/tmp/b+0xb880b)\n-    #3 0x5647a3eab412 in std::panicking::try::do_call::he0421ca82dd11ba3 (.llvm.8083791802951296215) (/tmp/b+0xbf412)\n-    #4 0x5647a3eacb26 in __rust_maybe_catch_panic (/tmp/b+0xc0b26)\n-    #5 0x5647a3ea5b66 in std::rt::lang_start_internal::h19bc96b28f670a64 (/tmp/b+0xb9b66)\n-    #6 0x5647a3ea4788 in std::rt::lang_start::h642d10b4b6965fb8 (/tmp/b+0xb8788)\n-    #7 0x5647a3ea449a in main (/tmp/b+0xb849a)\n-    #8 0x7fd1d18b3bba in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x26bba)\n-    #9 0x5647a3df7299 in _start (/tmp/b+0xb299)\n-\n-Address 0x7fff67be6be0 is located in stack of thread T0 at offset 32 in frame\n-    #0 0x5647a3ea433f in b::main::h5574a756e615c9cf (/tmp/b+0xb833f)\n+==39249==ERROR: AddressSanitizer: stack-use-after-scope on address 0x7ffc7ed3e1a0 at pc 0x55c98b262a8e bp 0x7ffc7ed3e050 sp 0x7ffc7ed3e048\n+WRITE of size 8 at 0x7ffc7ed3e1a0 thread T0\n+    #0 0x55c98b262a8d in core::ptr::write_volatile::he21f1df5a82f329a /.../src/rust/src/libcore/ptr/mod.rs:1048:5\n+    #1 0x55c98b262cd2 in example::main::h628ffc6626ed85b2 /.../src/main.rs:9:9\n+    ...\n+\n+Address 0x7ffc7ed3e1a0 is located in stack of thread T0 at offset 32 in frame\n+    #0 0x55c98b262bdf in example::main::h628ffc6626ed85b2 /.../src/main.rs:3\n \n   This frame has 1 object(s):\n-    [32, 40) 'x' <== Memory access at offset 32 is inside this variable\n+    [32, 40) 'x' (line 6) <== Memory access at offset 32 is inside this variable\n HINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n       (longjmp and C++ exceptions *are* supported)\n-SUMMARY: AddressSanitizer: stack-use-after-scope (/tmp/b+0xb8657) in core::ptr::write_volatile::h4b04601757d0376d\n+SUMMARY: AddressSanitizer: stack-use-after-scope /.../src/rust/src/libcore/ptr/mod.rs:1048:5 in core::ptr::write_volatile::he21f1df5a82f329a\n Shadow bytes around the buggy address:\n-  0x10006cf74d20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74d30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74d40: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74d50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74d60: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-=>0x10006cf74d70: 00 00 00 00 00 00 00 00 f1 f1 f1 f1[f8]f3 f3 f3\n-  0x10006cf74d80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74d90: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74da0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74db0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74dc0: f1 f1 f1 f1 00 f3 f3 f3 00 00 00 00 00 00 00 00\n+  0x10000fd9fbe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x10000fd9fbf0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x10000fd9fc00: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1\n+  0x10000fd9fc10: f8 f8 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x10000fd9fc20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+=>0x10000fd9fc30: f1 f1 f1 f1[f8]f3 f3 f3 00 00 00 00 00 00 00 00\n+  0x10000fd9fc40: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1\n+  0x10000fd9fc50: 00 00 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x10000fd9fc60: 00 00 00 00 00 00 00 00 f1 f1 f1 f1 00 00 f3 f3\n+  0x10000fd9fc70: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x10000fd9fc80: 00 00 00 00 f1 f1 f1 f1 00 00 f3 f3 00 00 00 00\n Shadow byte legend (one shadow byte represents 8 application bytes):\n   Addressable:           00\n   Partially addressable: 01 02 03 04 05 06 07\n@@ -164,17 +164,26 @@ Shadow byte legend (one shadow byte represents 8 application bytes):\n   Left alloca redzone:     ca\n   Right alloca redzone:    cb\n   Shadow gap:              cc\n-==424427==ABORTING\n+==39249==ABORTING\n ```\n \n-## MemorySanitizer\n+# MemorySanitizer\n+\n+MemorySanitizer is detector of uninitialized reads. It is only supported on the\n+`x86_64-unknown-linux-gnu` target.\n+\n+MemorySanitizer requires all program code to be instrumented. C/C++ dependencies\n+need to be recompiled using Clang with `-fsanitize=memory` option. Failing to\n+achieve that will result in false positive reports.\n+\n+## Example\n \n-Use of uninitialized memory. Note that we are using `-Zbuild-std` to instrument\n-the standard library, and passing `-Zsanitizer-track-origins` to track the\n+Detecting the use of uninitialized memory. The `-Zbuild-std` flag rebuilds and\n+instruments the standard library, and is strictly necessary for the correct\n+operation of the tool. The `-Zsanitizer-track-origins` enables tracking of the\n origins of uninitialized memory:\n \n-```shell\n-$ cat src/main.rs\n+```rust\n use std::mem::MaybeUninit;\n \n fn main() {\n@@ -184,7 +193,9 @@ fn main() {\n         println!(\"{}\", a[2]);\n     }\n }\n+```\n \n+```shell\n $ export \\\n   CC=clang \\\n   CXX=clang++ \\\n@@ -193,7 +204,7 @@ $ export \\\n   RUSTFLAGS='-Zsanitizer=memory -Zsanitizer-memory-track-origins' \\\n   RUSTDOCFLAGS='-Zsanitizer=memory -Zsanitizer-memory-track-origins'\n $ cargo clean\n-$ cargo -Zbuild-std run --target x86_64-unknown-linux-gnu\n+$ cargo run -Zbuild-std --target x86_64-unknown-linux-gnu\n ==9416==WARNING: MemorySanitizer: use-of-uninitialized-value\n     #0 0x560c04f7488a in core::fmt::num::imp::fmt_u64::haa293b0b098501ca $RUST/build/x86_64-unknown-linux-gnu/stage1/lib/rustlib/src/rust/src/libcore/fmt/num.rs:202:16\n ...\n@@ -205,6 +216,55 @@ $ cargo -Zbuild-std run --target x86_64-unknown-linux-gnu\n     #0 0x560c04b2bc50 in memory::main::hd2333c1899d997f5 $CWD/src/main.rs:3\n ```\n \n+# ThreadSanitizer\n+\n+ThreadSanitizer is a data race detection tool. It is supported on the following\n+targets:\n+\n+* `x86_64-apple-darwin`\n+* `x86_64-unknown-linux-gnu`\n+\n+To work correctly ThreadSanitizer needs to be \"aware\" of all synchronization\n+operations in a program. It generally achieves that through combination of\n+library interception (for example synchronization performed through\n+`pthread_mutex_lock` / `pthread_mutex_unlock`) and compile time instrumentation\n+(e.g. atomic operations). Using it without instrumenting all the program code\n+can lead to false positive reports.\n+\n+ThreadSanitizer does not support atomic fences `std::sync::atomic::fence`,\n+nor synchronization performed using inline assembly code.\n+\n+## Example\n+\n+```rust\n+static mut A: usize = 0;\n+\n+fn main() {\n+    let t = std::thread::spawn(|| {\n+        unsafe { A += 1 };\n+    });\n+    unsafe { A += 1 };\n+\n+    t.join().unwrap();\n+}\n+```\n+\n+```shell\n+$ export RUSTFLAGS=-Zsanitizer=thread RUSTDOCFLAGS=-Zsanitizer=thread\n+$ cargo run -Zbuild-std --target x86_64-unknown-linux-gnu\n+==================\n+WARNING: ThreadSanitizer: data race (pid=10574)\n+  Read of size 8 at 0x5632dfe3d030 by thread T1:\n+    #0 example::main::_$u7b$$u7b$closure$u7d$$u7d$::h23f64b0b2f8c9484 ../src/main.rs:5:18 (example+0x86cec)\n+    ...\n+\n+  Previous write of size 8 at 0x5632dfe3d030 by main thread:\n+    #0 example::main::h628ffc6626ed85b2 /.../src/main.rs:7:14 (example+0x868c8)\n+    ...\n+    #11 main <null> (example+0x86a1a)\n+\n+  Location is global 'example::A::h43ac149ddf992709' of size 8 at 0x5632dfe3d030 (example+0x000000bd9030)\n+```\n \n # Instrumentation of external dependencies and std\n \n@@ -231,6 +291,10 @@ In more practical terms when using cargo always remember to pass `--target`\n flag, so that rustflags will not be applied to build scripts and procedural\n macros.\n \n+# Symbolizing the Reports\n+\n+Sanitizers produce symbolized stacktraces when llvm-symbolizer binary is in `PATH`.\n+\n # Additional Information\n \n * [Sanitizers project page](https://github.com/google/sanitizers/wiki/)"}]}