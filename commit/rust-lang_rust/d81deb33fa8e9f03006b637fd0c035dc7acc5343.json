{"sha": "d81deb33fa8e9f03006b637fd0c035dc7acc5343", "node_id": "C_kwDOAAsO6NoAKGQ4MWRlYjMzZmE4ZTlmMDMwMDZiNjM3ZmQwYzAzNWRjN2FjYzUzNDM", "commit": {"author": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-11-24T20:27:37Z"}, "committer": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-11-25T20:08:05Z"}, "message": "Stop re-exporting `Type::ResolvedPath`\n\nI would like to rename it to `Type::Path`, but then it can't be\nre-exported since the name would conflict with the `Path` struct.\nUsually enum variants are referred to using their qualified names in\nRust (and parts of rustdoc already do that with `clean::Type`), so this\nis also more consistent with the language.", "tree": {"sha": "30221794a3a99eaf49f63148f3be006652a1a657", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30221794a3a99eaf49f63148f3be006652a1a657"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d81deb33fa8e9f03006b637fd0c035dc7acc5343", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d81deb33fa8e9f03006b637fd0c035dc7acc5343", "html_url": "https://github.com/rust-lang/rust/commit/d81deb33fa8e9f03006b637fd0c035dc7acc5343", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d81deb33fa8e9f03006b637fd0c035dc7acc5343/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8adb0b6d6c264facc6e213ad06a25194e7591682", "url": "https://api.github.com/repos/rust-lang/rust/commits/8adb0b6d6c264facc6e213ad06a25194e7591682", "html_url": "https://github.com/rust-lang/rust/commit/8adb0b6d6c264facc6e213ad06a25194e7591682"}], "stats": {"total": 75, "additions": 39, "deletions": 36}, "files": [{"sha": "e8c55d10901e8e7a6660b6ac722f5ecde9731ceb", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d81deb33fa8e9f03006b637fd0c035dc7acc5343/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81deb33fa8e9f03006b637fd0c035dc7acc5343/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d81deb33fa8e9f03006b637fd0c035dc7acc5343", "patch": "@@ -41,9 +41,8 @@ use crate::visit_ast::Module as DocModule;\n \n use utils::*;\n \n-crate use utils::{get_auto_trait_and_blanket_impls, krate, register_res};\n-\n crate use self::types::*;\n+crate use self::utils::{get_auto_trait_and_blanket_impls, krate, register_res};\n \n crate trait Clean<T> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> T;\n@@ -1406,12 +1405,12 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 };\n                 inline::record_extern_fqn(cx, did, kind);\n                 let path = external_path(cx, did, false, vec![], substs);\n-                ResolvedPath { path }\n+                Type::ResolvedPath { path }\n             }\n             ty::Foreign(did) => {\n                 inline::record_extern_fqn(cx, did, ItemType::ForeignType);\n                 let path = external_path(cx, did, false, vec![], InternalSubsts::empty());\n-                ResolvedPath { path }\n+                Type::ResolvedPath { path }\n             }\n             ty::Dynamic(obj, ref reg) => {\n                 // HACK: pick the first `did` as the `did` of the trait object. Someone"}, {"sha": "b5192d2c08257f09b44e9e952aac1ed4c2f890bb", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d81deb33fa8e9f03006b637fd0c035dc7acc5343/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81deb33fa8e9f03006b637fd0c035dc7acc5343/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=d81deb33fa8e9f03006b637fd0c035dc7acc5343", "patch": "@@ -47,7 +47,7 @@ crate use self::ItemKind::*;\n crate use self::SelfTy::*;\n crate use self::Type::{\n     Array, BareFunction, BorrowedRef, DynTrait, Generic, ImplTrait, Infer, Primitive, QPath,\n-    RawPointer, ResolvedPath, Slice, Tuple,\n+    RawPointer, Slice, Tuple,\n };\n crate use self::Visibility::{Inherited, Public};\n \n@@ -1488,7 +1488,7 @@ impl Type {\n     /// Checks if this is a `T::Name` path for an associated type.\n     crate fn is_assoc_ty(&self) -> bool {\n         match self {\n-            ResolvedPath { path, .. } => path.is_assoc_ty(),\n+            Type::ResolvedPath { path, .. } => path.is_assoc_ty(),\n             _ => false,\n         }\n     }\n@@ -1502,7 +1502,7 @@ impl Type {\n \n     crate fn generics(&self) -> Option<Vec<&Type>> {\n         match self {\n-            ResolvedPath { path, .. } => path.generics(),\n+            Type::ResolvedPath { path, .. } => path.generics(),\n             _ => None,\n         }\n     }\n@@ -1525,7 +1525,7 @@ impl Type {\n \n     fn inner_def_id(&self, cache: Option<&Cache>) -> Option<DefId> {\n         let t: PrimitiveType = match *self {\n-            ResolvedPath { ref path } => return Some(path.def_id()),\n+            Type::ResolvedPath { ref path } => return Some(path.def_id()),\n             DynTrait(ref bounds, _) => return Some(bounds[0].trait_.def_id()),\n             Primitive(p) => return cache.and_then(|c| c.primitive_locations.get(&p).cloned()),\n             BorrowedRef { type_: box Generic(..), .. } => PrimitiveType::Reference,"}, {"sha": "40fa5b8a33e1b755892204801b527558d4ec20af", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d81deb33fa8e9f03006b637fd0c035dc7acc5343/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81deb33fa8e9f03006b637fd0c035dc7acc5343/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=d81deb33fa8e9f03006b637fd0c035dc7acc5343", "patch": "@@ -2,8 +2,7 @@ use crate::clean::auto_trait::AutoTraitFinder;\n use crate::clean::blanket_impl::BlanketImplFinder;\n use crate::clean::{\n     inline, Clean, Crate, ExternalCrate, Generic, GenericArg, GenericArgs, ImportSource, Item,\n-    ItemKind, Lifetime, Path, PathSegment, Primitive, PrimitiveType, ResolvedPath, Type,\n-    TypeBinding, Visibility,\n+    ItemKind, Lifetime, Path, PathSegment, Primitive, PrimitiveType, Type, TypeBinding, Visibility,\n };\n use crate::core::DocContext;\n use crate::formats::item_type::ItemType;\n@@ -187,7 +186,7 @@ crate fn build_deref_target_impls(cx: &mut DocContext<'_>, items: &[Item], ret:\n             for &did in prim.impls(tcx).iter().filter(|did| !did.is_local()) {\n                 inline::build_impl(cx, None, did, None, ret);\n             }\n-        } else if let ResolvedPath { path } = target {\n+        } else if let Type::ResolvedPath { path } = target {\n             let did = path.def_id();\n             if !did.is_local() {\n                 inline::build_impls(cx, None, did, None, ret);\n@@ -362,7 +361,7 @@ crate fn resolve_type(cx: &mut DocContext<'_>, path: Path) -> Type {\n         Res::Def(DefKind::TyParam, _) if path.segments.len() == 1 => Generic(path.segments[0].name),\n         _ => {\n             let _ = register_res(cx, path.res);\n-            ResolvedPath { path }\n+            Type::ResolvedPath { path }\n         }\n     }\n }"}, {"sha": "06fcdd0521287f0967a7d8cd053fe99d3e7f6b3a", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d81deb33fa8e9f03006b637fd0c035dc7acc5343/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81deb33fa8e9f03006b637fd0c035dc7acc5343/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=d81deb33fa8e9f03006b637fd0c035dc7acc5343", "patch": "@@ -401,7 +401,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n             clean::ImplItem(ref i) => {\n                 self.cache.parent_is_trait_impl = i.trait_.is_some();\n                 match i.for_ {\n-                    clean::ResolvedPath { ref path } => {\n+                    clean::Type::ResolvedPath { ref path } => {\n                         self.cache.parent_stack.push(path.def_id());\n                         true\n                     }\n@@ -436,8 +436,10 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n             // Note: matching twice to restrict the lifetime of the `i` borrow.\n             let mut dids = FxHashSet::default();\n             match i.for_ {\n-                clean::ResolvedPath { ref path }\n-                | clean::BorrowedRef { type_: box clean::ResolvedPath { ref path }, .. } => {\n+                clean::Type::ResolvedPath { ref path }\n+                | clean::BorrowedRef {\n+                    type_: box clean::Type::ResolvedPath { ref path }, ..\n+                } => {\n                     dids.insert(path.def_id());\n                 }\n                 clean::DynTrait(ref bounds, _)"}, {"sha": "d3603d17925da35e5a12e41612aa829c7c2a5d67", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d81deb33fa8e9f03006b637fd0c035dc7acc5343/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81deb33fa8e9f03006b637fd0c035dc7acc5343/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=d81deb33fa8e9f03006b637fd0c035dc7acc5343", "patch": "@@ -762,7 +762,7 @@ fn fmt_type<'cx>(\n \n     match *t {\n         clean::Generic(name) => write!(f, \"{}\", name),\n-        clean::ResolvedPath { ref path } => {\n+        clean::Type::ResolvedPath { ref path } => {\n             // Paths like `T::Output` and `Self::Output` should be rendered with all segments.\n             let did = path.def_id();\n             resolved_path(f, did, path, path.is_assoc_ty(), use_absolute, cx)"}, {"sha": "ffa5ec8a3ee320a8945f151437b3d237bb891817", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d81deb33fa8e9f03006b637fd0c035dc7acc5343/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81deb33fa8e9f03006b637fd0c035dc7acc5343/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=d81deb33fa8e9f03006b637fd0c035dc7acc5343", "patch": "@@ -218,7 +218,7 @@ fn get_index_type(clean_type: &clean::Type, generics: Vec<TypeWithKind>) -> Rend\n \n fn get_index_type_name(clean_type: &clean::Type, accept_generic: bool) -> Option<Symbol> {\n     match *clean_type {\n-        clean::ResolvedPath { ref path, .. } => {\n+        clean::Type::ResolvedPath { ref path, .. } => {\n             let path_segment = path.segments.last().unwrap();\n             Some(path_segment.name)\n         }"}, {"sha": "42a2defa757a456f4447179073a4115300bcc798", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d81deb33fa8e9f03006b637fd0c035dc7acc5343/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81deb33fa8e9f03006b637fd0c035dc7acc5343/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=d81deb33fa8e9f03006b637fd0c035dc7acc5343", "patch": "@@ -1227,7 +1227,7 @@ fn should_render_item(item: &clean::Item, deref_mut_: bool, tcx: TyCtxt<'_>) ->\n             | SelfTy::SelfExplicit(clean::BorrowedRef { mutability, .. }) => {\n                 (mutability == Mutability::Mut, false, false)\n             }\n-            SelfTy::SelfExplicit(clean::ResolvedPath { path }) => {\n+            SelfTy::SelfExplicit(clean::Type::ResolvedPath { path }) => {\n                 (false, Some(path.def_id()) == tcx.lang_items().owned_box(), false)\n             }\n             SelfTy::SelfValue => (false, false, true),"}, {"sha": "f8a16fb9b713d0af1d345b78179dea9b0a30e453", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d81deb33fa8e9f03006b637fd0c035dc7acc5343/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81deb33fa8e9f03006b637fd0c035dc7acc5343/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=d81deb33fa8e9f03006b637fd0c035dc7acc5343", "patch": "@@ -727,10 +727,10 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         let mut implementor_dups: FxHashMap<Symbol, (DefId, bool)> = FxHashMap::default();\n         for implementor in implementors {\n             match implementor.inner_impl().for_ {\n-                clean::ResolvedPath { ref path }\n-                | clean::BorrowedRef { type_: box clean::ResolvedPath { ref path }, .. }\n-                    if !path.is_assoc_ty() =>\n-                {\n+                clean::Type::ResolvedPath { ref path }\n+                | clean::BorrowedRef {\n+                    type_: box clean::Type::ResolvedPath { ref path }, ..\n+                } if !path.is_assoc_ty() => {\n                     let did = path.def_id();\n                     let &mut (prev_did, ref mut has_duplicates) =\n                         implementor_dups.entry(path.last()).or_insert((did, false));\n@@ -1452,15 +1452,14 @@ fn render_implementor(\n ) {\n     // If there's already another implementor that has the same abridged name, use the\n     // full path, for example in `std::iter::ExactSizeIterator`\n-    let use_absolute = match implementor.inner_impl().for_ {\n-        clean::ResolvedPath { ref path, .. }\n-        | clean::BorrowedRef { type_: box clean::ResolvedPath { ref path, .. }, .. }\n-            if !path.is_assoc_ty() =>\n-        {\n-            implementor_dups[&path.last()].1\n-        }\n-        _ => false,\n-    };\n+    let use_absolute =\n+        match implementor.inner_impl().for_ {\n+            clean::Type::ResolvedPath { ref path, .. }\n+            | clean::BorrowedRef {\n+                type_: box clean::Type::ResolvedPath { ref path, .. }, ..\n+            } if !path.is_assoc_ty() => implementor_dups[&path.last()].1,\n+            _ => false,\n+        };\n     render_impl(\n         w,\n         cx,"}, {"sha": "ed8f7274591d6faf5b712395da4065d17039c29d", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d81deb33fa8e9f03006b637fd0c035dc7acc5343/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d81deb33fa8e9f03006b637fd0c035dc7acc5343/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=d81deb33fa8e9f03006b637fd0c035dc7acc5343", "patch": "@@ -365,7 +365,7 @@ impl FromWithTcx<clean::GenericBound> for GenericBound {\n         match bound {\n             TraitBound(clean::PolyTrait { trait_, generic_params }, modifier) => {\n                 // FIXME: should `trait_` be a clean::Path equivalent in JSON?\n-                let trait_ = clean::ResolvedPath { path: trait_ }.into_tcx(tcx);\n+                let trait_ = clean::Type::ResolvedPath { path: trait_ }.into_tcx(tcx);\n                 GenericBound::TraitBound {\n                     trait_,\n                     generic_params: generic_params.into_iter().map(|x| x.into_tcx(tcx)).collect(),\n@@ -388,9 +388,13 @@ crate fn from_trait_bound_modifier(modifier: rustc_hir::TraitBoundModifier) -> T\n \n impl FromWithTcx<clean::Type> for Type {\n     fn from_tcx(ty: clean::Type, tcx: TyCtxt<'_>) -> Self {\n-        use clean::Type::*;\n+        use clean::Type::{\n+            Array, BareFunction, BorrowedRef, DynTrait, Generic, ImplTrait, Infer, Primitive,\n+            QPath, RawPointer, Slice, Tuple,\n+        };\n+\n         match ty {\n-            ResolvedPath { path } => Type::ResolvedPath {\n+            clean::Type::ResolvedPath { path } => Type::ResolvedPath {\n                 name: path.whole_name(),\n                 id: from_item_id(path.def_id().into()),\n                 args: path.segments.last().map(|args| Box::new(args.clone().args.into_tcx(tcx))),\n@@ -435,7 +439,7 @@ impl FromWithTcx<clean::Type> for Type {\n             },\n             QPath { name, self_type, trait_, .. } => {\n                 // FIXME: should `trait_` be a clean::Path equivalent in JSON?\n-                let trait_ = ResolvedPath { path: trait_ }.into_tcx(tcx);\n+                let trait_ = clean::Type::ResolvedPath { path: trait_ }.into_tcx(tcx);\n                 Type::QualifiedPath {\n                     name: name.to_string(),\n                     self_type: Box::new((*self_type).into_tcx(tcx)),\n@@ -501,7 +505,7 @@ impl FromWithTcx<clean::Impl> for Impl {\n         let provided_trait_methods = impl_.provided_trait_methods(tcx);\n         let clean::Impl { unsafety, generics, trait_, for_, items, polarity, kind } = impl_;\n         // FIXME: should `trait_` be a clean::Path equivalent in JSON?\n-        let trait_ = trait_.map(|path| clean::ResolvedPath { path }.into_tcx(tcx));\n+        let trait_ = trait_.map(|path| clean::Type::ResolvedPath { path }.into_tcx(tcx));\n         // FIXME: use something like ImplKind in JSON?\n         let (synthetic, blanket_impl) = match kind {\n             clean::ImplKind::Normal => (false, None),"}]}