{"sha": "597ac36547f5b135d55bd4cf26964762c8c4796f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5N2FjMzY1NDdmNWIxMzVkNTViZDRjZjI2OTY0NzYyYzhjNDc5NmY=", "commit": {"author": {"name": "Joshua Sheard", "email": "mail@jsheard.com", "date": "2017-09-14T13:19:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-09-14T13:19:53Z"}, "message": "Merge branch 'master' into threadname", "tree": {"sha": "d722ef4a71813b7182eb47f4584d9b35490b3476", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d722ef4a71813b7182eb47f4584d9b35490b3476"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/597ac36547f5b135d55bd4cf26964762c8c4796f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/597ac36547f5b135d55bd4cf26964762c8c4796f", "html_url": "https://github.com/rust-lang/rust/commit/597ac36547f5b135d55bd4cf26964762c8c4796f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/597ac36547f5b135d55bd4cf26964762c8c4796f/comments", "author": {"login": "jsheard", "id": 3153547, "node_id": "MDQ6VXNlcjMxNTM1NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3153547?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsheard", "html_url": "https://github.com/jsheard", "followers_url": "https://api.github.com/users/jsheard/followers", "following_url": "https://api.github.com/users/jsheard/following{/other_user}", "gists_url": "https://api.github.com/users/jsheard/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsheard/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsheard/subscriptions", "organizations_url": "https://api.github.com/users/jsheard/orgs", "repos_url": "https://api.github.com/users/jsheard/repos", "events_url": "https://api.github.com/users/jsheard/events{/privacy}", "received_events_url": "https://api.github.com/users/jsheard/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e80cee144f1a75ab902c3b64e58979b140b9f52", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e80cee144f1a75ab902c3b64e58979b140b9f52", "html_url": "https://github.com/rust-lang/rust/commit/8e80cee144f1a75ab902c3b64e58979b140b9f52"}, {"sha": "2b6bc588ca7197bc5d9f212e9e91a2c3811d025c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b6bc588ca7197bc5d9f212e9e91a2c3811d025c", "html_url": "https://github.com/rust-lang/rust/commit/2b6bc588ca7197bc5d9f212e9e91a2c3811d025c"}], "stats": {"total": 13781, "additions": 9718, "deletions": 4063}, "files": [{"sha": "23bae6d9f1721eba30a74acc68beb90e1ce5dbd7", "filename": ".travis.yml", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -125,9 +125,9 @@ matrix:\n env:\n   global:\n     - SCCACHE_BUCKET=rust-lang-ci-sccache\n-    - AWS_ACCESS_KEY_ID=AKIAIMX7VLAS3PZAVLUQ\n+    - AWS_ACCESS_KEY_ID=AKIAJAMV3QAMMA6AXHFQ\n     # AWS_SECRET_ACCESS_KEY=...\n-    - secure: \"Pixhh0hXDqGCdOyLtGFjli3J2AtDWIpyb2btIrLe956nCBDRutRoMm6rv5DI9sFZN07Mms7VzNNvhc9wCW1y63JAm414d2Co7Ob8kWMZlz9l9t7ACHuktUiis8yr+S4Quq1Vqd6pqi7pf2J++UxC8R/uLeqVrubzr6+X7AbmEFE=\"\n+    - secure: \"j96XxTVOSUf4s4r4htIxn/fvIa5DWbMgLqWl7r8z2QfgUwscmkMXAwXuFNc7s7bGTpV/+CgDiMFFM6BAFLGKutytIF6oA02s9b+usQYnM0th7YQ2AIgm9GtMTJCJp4AoyfFmh8F2faUICBZlfVLUJ34udHEe35vOklix+0k4WDo=\"\n \n before_install:\n   # If we are building a pull request, do the build if $ALLOW_PR == 1\n@@ -260,9 +260,9 @@ deploy:\n     upload_dir: rustc-builds\n     acl: public_read\n     region: us-east-1\n-    access_key_id: AKIAIPQVNYF2T3DTYIWQ\n+    access_key_id: AKIAJVBODR3IA4O72THQ\n     secret_access_key:\n-      secure: \"FBqDqOTeIPMu6v/WYPf4CFSlh9rLRZGKVtpLa5KkyuOhXRTrnEzBduEtS8/FMIxdQImvurhSvxWvqRybMOi4qoVfjMqqpHAI7uBbidbrvAcJoHNsx6BgUNVCIoH6a0UsAjTUtm6/YPIpzbHoLZXPL0GrHPMk6Mu04qVSmcYNWn4=\"\n+      secure: \"kUGd3t7JcVWFESgIlzvsM8viZgCA9Encs3creW0xLJaLSeI1iVjlJK4h/2/nO6y224AFrh/GUfsNr4/4AlxPuYb8OU5oC5Lv+Ff2JiRDYtuNpyQSKAQp+bRYytWMtrmhja91h118Mbm90cUfcLPwkdiINgJNTXhPKg5Cqu3VYn0=\"\n     on:\n       branch: auto\n       condition: $DEPLOY = 1\n@@ -274,9 +274,9 @@ deploy:\n     upload_dir: rustc-builds-try\n     acl: public_read\n     region: us-east-1\n-    access_key_id: AKIAIPQVNYF2T3DTYIWQ\n+    access_key_id: AKIAJVBODR3IA4O72THQ\n     secret_access_key:\n-      secure: \"FBqDqOTeIPMu6v/WYPf4CFSlh9rLRZGKVtpLa5KkyuOhXRTrnEzBduEtS8/FMIxdQImvurhSvxWvqRybMOi4qoVfjMqqpHAI7uBbidbrvAcJoHNsx6BgUNVCIoH6a0UsAjTUtm6/YPIpzbHoLZXPL0GrHPMk6Mu04qVSmcYNWn4=\"\n+      secure: \"kUGd3t7JcVWFESgIlzvsM8viZgCA9Encs3creW0xLJaLSeI1iVjlJK4h/2/nO6y224AFrh/GUfsNr4/4AlxPuYb8OU5oC5Lv+Ff2JiRDYtuNpyQSKAQp+bRYytWMtrmhja91h118Mbm90cUfcLPwkdiINgJNTXhPKg5Cqu3VYn0=\"\n     on:\n       branch: try\n       condition: $DEPLOY = 1 && $ALLOW_TRY = 1\n@@ -290,9 +290,9 @@ deploy:\n     upload_dir: rustc-builds-alt\n     acl: public_read\n     region: us-east-1\n-    access_key_id: AKIAIPQVNYF2T3DTYIWQ\n+    access_key_id: AKIAJVBODR3IA4O72THQ\n     secret_access_key:\n-      secure: \"FBqDqOTeIPMu6v/WYPf4CFSlh9rLRZGKVtpLa5KkyuOhXRTrnEzBduEtS8/FMIxdQImvurhSvxWvqRybMOi4qoVfjMqqpHAI7uBbidbrvAcJoHNsx6BgUNVCIoH6a0UsAjTUtm6/YPIpzbHoLZXPL0GrHPMk6Mu04qVSmcYNWn4=\"\n+      secure: \"kUGd3t7JcVWFESgIlzvsM8viZgCA9Encs3creW0xLJaLSeI1iVjlJK4h/2/nO6y224AFrh/GUfsNr4/4AlxPuYb8OU5oC5Lv+Ff2JiRDYtuNpyQSKAQp+bRYytWMtrmhja91h118Mbm90cUfcLPwkdiINgJNTXhPKg5Cqu3VYn0=\"\n     on:\n       branch: auto\n       condition: $DEPLOY_ALT = 1"}, {"sha": "2979ffe136c90af382669f56f007d65d7ac85d52", "filename": "RELEASES.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -170,7 +170,7 @@ Compatibility Notes\n [`slice::sort_unstable_by_key`]: https://doc.rust-lang.org/std/primitive.slice.html#method.sort_unstable_by_key\n [`slice::sort_unstable_by`]: https://doc.rust-lang.org/std/primitive.slice.html#method.sort_unstable_by\n [`slice::sort_unstable`]: https://doc.rust-lang.org/std/primitive.slice.html#method.sort_unstable\n-[`ste::from_boxed_utf8_unchecked`]: https://doc.rust-lang.org/std/str/fn.from_boxed_utf8_unchecked.html\n+[`str::from_boxed_utf8_unchecked`]: https://doc.rust-lang.org/std/str/fn.from_boxed_utf8_unchecked.html\n [`str::as_bytes_mut`]: https://doc.rust-lang.org/std/primitive.str.html#method.as_bytes_mut\n [`str::from_utf8_mut`]: https://doc.rust-lang.org/std/str/fn.from_utf8_mut.html\n [`str::from_utf8_unchecked_mut`]: https://doc.rust-lang.org/std/str/fn.from_utf8_unchecked_mut.html"}, {"sha": "62b62ae7c42e9da0343d4c0365ae29e519072e21", "filename": "appveyor.yml", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -1,8 +1,8 @@\n environment:\n   SCCACHE_BUCKET: rust-lang-ci-sccache\n-  AWS_ACCESS_KEY_ID: AKIAIMX7VLAS3PZAVLUQ\n+  AWS_ACCESS_KEY_ID: AKIAJAMV3QAMMA6AXHFQ\n   AWS_SECRET_ACCESS_KEY:\n-    secure: 1UkmbiDd15tWtYbMm5O2Uqm0b0Ur8v1MoSlydxl4ojcroPeerRMlUges0l57py8c\n+    secure: 7Y+JiquYedOAgnUU26uL0DPzrxmTtR+qIwG6rNKSuWDffqU3vVZxbGXim9QpTO80\n   SCCACHE_DIGEST: f808afabb4a4eb1d7112bcb3fa6be03b61e93412890c88e177c667eb37f46353d7ec294e559b16f9f4b5e894f2185fe7670a0df15fd064889ecbd80f0c34166c\n \n   # By default schannel checks revocation of certificates unlike some other SSL\n@@ -185,9 +185,9 @@ before_deploy:\n deploy:\n   - provider: S3\n     skip_cleanup: true\n-    access_key_id: AKIAIPQVNYF2T3DTYIWQ\n+    access_key_id: AKIAJVBODR3IA4O72THQ\n     secret_access_key:\n-      secure: +11jsUNFTQ9dq5Ad1i2+PeUJaXluFJ0zIJAXESE1dFT3Kdjku4/eDdgyjgsB6GnV\n+      secure: tQWIE+DJHjXaV4np/3YeETkEmXngtIuIgAO/LYKQaUshGLgN8cBCFGG3cHx5lKLt\n     bucket: rust-lang-ci\n     set_public: true\n     region: us-east-1\n@@ -202,9 +202,9 @@ deploy:\n   # different upload directory and a slightly different trigger\n   - provider: S3\n     skip_cleanup: true\n-    access_key_id: AKIAIPQVNYF2T3DTYIWQ\n+    access_key_id: AKIAJVBODR3IA4O72THQ\n     secret_access_key:\n-      secure: +11jsUNFTQ9dq5Ad1i2+PeUJaXluFJ0zIJAXESE1dFT3Kdjku4/eDdgyjgsB6GnV\n+      secure: tQWIE+DJHjXaV4np/3YeETkEmXngtIuIgAO/LYKQaUshGLgN8cBCFGG3cHx5lKLt\n     bucket: rust-lang-ci\n     set_public: true\n     region: us-east-1"}, {"sha": "266f4250132135a78593035e6abd7546c5950550", "filename": "config.toml.example", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -146,10 +146,10 @@\n # option to true.\n #full-bootstrap = false\n \n-# Enable a build of the and extended rust tool set which is not only the\n-# compiler but also tools such as Cargo. This will also produce \"combined\n-# installers\" which are used to install Rust and Cargo together. This is\n-# disabled by default.\n+# Enable a build of the extended rust tool set which is not only the compiler\n+# but also tools such as Cargo. This will also produce \"combined installers\"\n+# which are used to install Rust and Cargo together. This is disabled by\n+# default.\n #extended = false\n \n # Verbosity level: 0 == not verbose, 1 == verbose, 2 == very verbose\n@@ -175,7 +175,7 @@\n # script.\n #configure-args = []\n \n-# Indicates that a local rebuild is ocurring instead of a full bootstrap,\n+# Indicates that a local rebuild is occurring instead of a full bootstrap,\n # essentially skipping stage0 as the local compiler is recompiling itself again.\n #local-rebuild = false\n "}, {"sha": "186eda95fecbde4424d34a3325fbb723ed94cbd5", "filename": "fn.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/fn.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -0,0 +1,8 @@\n+\n+fn foo(x:  fn(&u8, &u8), y: Vec<&u8>, z: &u8) {\n+// Debruijn   1    1            1        1\n+// Anon-Index 0    1            0        1\n+//            ------\n+//            debruijn indices are shifted by 1 in here\n+  y.push(z); // index will be zero or one\n+}"}, {"sha": "1bbe8ca7575f11b6b9110ec415b1dd504296cfda", "filename": "src/Cargo.lock", "status": "modified", "additions": 39, "deletions": 42, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -47,7 +47,7 @@ dependencies = [\n  \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n  \"core 0.0.0\",\n- \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.53 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.0.0\",\n ]\n \n@@ -103,7 +103,7 @@ name = \"backtrace-sys\"\n version = \"0.1.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.53 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -137,7 +137,7 @@ dependencies = [\n  \"build_helper 0.1.0\",\n  \"cmake 0.1.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.53 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -183,11 +183,11 @@ dependencies = [\n  \"cargotest 0.1.0\",\n  \"core-foundation 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"crates-io 0.12.0\",\n- \"crossbeam 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"crossbeam 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"curl 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"docopt 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"error-chain 0.11.0-rc.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"error-chain 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fs2 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -209,10 +209,10 @@ dependencies = [\n  \"psapi-sys 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"same-file 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"scoped-tls 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"semver 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"semver 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_ignored 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_ignored 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"shell-escape 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tar 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -270,7 +270,7 @@ name = \"cmake\"\n version = \"0.1.24\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.53 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -286,7 +286,7 @@ name = \"compiler_builtins\"\n version = \"0.0.0\"\n dependencies = [\n  \"core 0.0.0\",\n- \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.53 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -343,7 +343,7 @@ name = \"crates-io\"\n version = \"0.12.0\"\n dependencies = [\n  \"curl 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"error-chain 0.11.0-rc.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"error-chain 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -355,6 +355,11 @@ name = \"crossbeam\"\n version = \"0.2.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"crossbeam\"\n+version = \"0.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"cssparser\"\n version = \"0.13.7\"\n@@ -397,7 +402,7 @@ name = \"curl-sys\"\n version = \"0.3.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.53 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libz-sys 1.0.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl-sys 0.9.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -487,15 +492,7 @@ dependencies = [\n \n [[package]]\n name = \"error-chain\"\n-version = \"0.10.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"backtrace 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"error-chain\"\n-version = \"0.11.0-rc.2\"\n+version = \"0.11.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"backtrace 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -577,7 +574,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"gcc\"\n-version = \"0.3.51\"\n+version = \"0.3.53\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -744,7 +741,7 @@ name = \"installer\"\n version = \"0.0.0\"\n dependencies = [\n  \"clap 2.26.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"error-chain 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"error-chain 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -837,7 +834,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cmake 0.1.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"curl-sys 0.3.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.53 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libssh2-sys 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libz-sys 1.0.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -862,7 +859,7 @@ name = \"libz-sys\"\n version = \"1.0.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.53 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"vcpkg 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -883,7 +880,7 @@ version = \"0.1.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.53 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -965,7 +962,7 @@ name = \"miniz-sys\"\n version = \"0.1.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.53 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1101,7 +1098,7 @@ name = \"openssl-sys\"\n version = \"0.9.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.53 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"vcpkg 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1206,7 +1203,7 @@ name = \"profiler_builtins\"\n version = \"0.0.0\"\n dependencies = [\n  \"core 0.0.0\",\n- \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.53 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1339,7 +1336,7 @@ dependencies = [\n  \"racer 2.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-analysis 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-data 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rls-rustc 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-rustc 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-vfs 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustfmt-nightly 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1374,7 +1371,7 @@ dependencies = [\n \n [[package]]\n name = \"rls-rustc\"\n-version = \"0.1.0\"\n+version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -1602,7 +1599,7 @@ name = \"rustc_llvm\"\n version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n- \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.53 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_bitflags 0.0.0\",\n ]\n \n@@ -1732,7 +1729,7 @@ name = \"rustc_trans\"\n version = \"0.0.0\"\n dependencies = [\n  \"flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.53 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"jobserver 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1797,7 +1794,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n  \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.53 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"html-diff 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pulldown-cmark 0.0.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1868,7 +1865,7 @@ dependencies = [\n \n [[package]]\n name = \"semver\"\n-version = \"0.7.0\"\n+version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1906,7 +1903,7 @@ dependencies = [\n \n [[package]]\n name = \"serde_ignored\"\n-version = \"0.0.3\"\n+version = \"0.0.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1970,7 +1967,7 @@ dependencies = [\n  \"collections 0.0.0\",\n  \"compiler_builtins 0.0.0\",\n  \"core 0.0.0\",\n- \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.53 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.0.0\",\n  \"panic_abort 0.0.0\",\n  \"panic_unwind 0.0.0\",\n@@ -2451,6 +2448,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum core-foundation 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5909502e547762013619f4c4e01cc7393c20fe2d52d7fa471c1210adb2320dc7\"\n \"checksum core-foundation-sys 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bc9fb3d6cb663e6fd7cf1c63f9b144ee2b1e4a78595a0451dd34bff85b9a3387\"\n \"checksum crossbeam 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0c5ea215664ca264da8a9d9c3be80d2eaf30923c259d03e870388eb927508f97\"\n+\"checksum crossbeam 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8837ab96533202c5b610ed44bc7f4183e7957c1c8f56e8cc78bb098593c8ba0a\"\n \"checksum cssparser 0.13.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ef6124306e5ebc5ab11891d063aeafdd0cdc308079b708c8b566125f3680292b\"\n \"checksum cssparser-macros 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"079adec4af52bb5275eadd004292028c79eb3c5f5b4ee8086a36d4197032f6df\"\n \"checksum curl 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7034c534a1d7d22f7971d6088aa9d281d219ef724026c3428092500f41ae9c2c\"\n@@ -2465,16 +2463,15 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum enum_primitive 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"be4551092f4d519593039259a9ed8daedf0da12e5109c5280338073eaeb81180\"\n \"checksum env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15abd780e45b3ea4f76b4e9a26ff4843258dd8a3eed2775a0e7368c2e7936c2f\"\n \"checksum env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3ddf21e73e016298f5cb37d6ef8e8da8e39f91f9ec8b0df44b7deb16a9f8cd5b\"\n-\"checksum error-chain 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9435d864e017c3c6afeac1654189b06cdb491cf2ff73dbf0d73b0f292f42ff8\"\n-\"checksum error-chain 0.11.0-rc.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"38d3a55d9a7a456748f2a3912c0941a5d9a68006eb15b3c3c9836b8420dc102d\"\n+\"checksum error-chain 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ff511d5dc435d703f4971bc399647c9bc38e20cb41452e3b9feb4765419ed3f3\"\n \"checksum filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5363ab8e4139b8568a6237db5248646e5a8a2f89bd5ccb02092182b11fd3e922\"\n \"checksum flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\" = \"36df0166e856739905cd3d7e0b210fe818592211a008862599845e012d8d304c\"\n \"checksum fnv 1.0.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6cc484842f1e2884faf56f529f960cc12ad8c71ce96cc7abba0a067c98fee344\"\n \"checksum foreign-types 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3e4056b9bd47f8ac5ba12be771f77a0dae796d1bbaaf5fd0b9c2d38b69b8a29d\"\n \"checksum fs2 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9ab76cfd2aaa59b7bf6688ad9ba15bbae64bff97f04ea02144cfd3443e5c2866\"\n \"checksum futf 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"51f93f3de6ba1794dcd5810b3546d004600a59a98266487c8407bc4b24e398f3\"\n \"checksum futures 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a82bdc62350ca9d7974c760e9665102fc9d740992a528c2254aa930e53b783c4\"\n-\"checksum gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\" = \"120d07f202dcc3f72859422563522b66fe6463a4c513df062874daad05f85f0a\"\n+\"checksum gcc 0.3.53 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e8310f7e9c890398b0e80e301c4f474e9918d2b27fca8f48486ca775fa9ffc5a\"\n \"checksum getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9047cfbd08a437050b363d35ef160452c5fe8ea5187ae0a624708c91581d685\"\n \"checksum git2 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0c1c0203d653f4140241da0c1375a404f0a397249ec818cd2076c6280c50f6fa\"\n \"checksum git2-curl 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"68676bc784bf0bef83278898929bf64a251e87c0340723d0b93fa096c9c5bf8e\"\n@@ -2547,7 +2544,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum regex-syntax 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ad890a5eef7953f55427c50575c680c42841653abd2b028b68cd223d157f62db\"\n \"checksum rls-analysis 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d2cb40c0371765897ae428b5706bb17135705ad4f6d1b8b6afbaabcf8c9b5cff\"\n \"checksum rls-data 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"11d339f1888e33e74d8032de0f83c40b2bdaaaf04a8cfc03b32186c3481fb534\"\n-\"checksum rls-rustc 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5fa757c9d547d460427ceff01875f9cac5f5acd8fc6543946e9b0335ba29d537\"\n+\"checksum rls-rustc 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b21ea952e9bf1569929abf1bb920262cde04b7b1b26d8e0260286302807299d2\"\n \"checksum rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5d7c7046dc6a92f2ae02ed302746db4382e75131b9ce20ce967259f6b5867a6a\"\n \"checksum rls-vfs 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ffd34691a510938bb67fe0444fb363103c73ffb31c121d1e16bc92d8945ea8ff\"\n \"checksum rustc-demangle 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aee45432acc62f7b9a108cc054142dac51f979e69e71ddce7d6fc7adf29e817e\"\n@@ -2557,12 +2554,12 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum scoped-tls 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f417c22df063e9450888a7561788e9bd46d3bb3c1466435b4eccb903807f147d\"\n \"checksum scopeguard 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"59a076157c1e2dc561d8de585151ee6965d910dd4dcb5dabb7ae3e83981a6c57\"\n \"checksum selectors 0.18.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e3c89b1c6a3c029c82263f7dd2d44d0005ee7374eb09e254ab59dede4353a8c0\"\n-\"checksum semver 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3fdd61b85a0fa777f7fb7c454b9189b2941b110d1385ce84d7f76efdf1606a85\"\n+\"checksum semver 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bee2bc909ab2d8d60dab26e8cad85b25d795b14603a0dcb627b78b9d30b6454b\"\n \"checksum semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n \"checksum serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f7726f29ddf9731b17ff113c461e362c381d9d69433f79de4f3dd572488823e9\"\n \"checksum serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cf823e706be268e73e7747b147aa31c8f633ab4ba31f115efb57e5047c3a76dd\"\n \"checksum serde_derive_internals 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"37aee4e0da52d801acfbc0cc219eb1eda7142112339726e427926a6f6ee65d3a\"\n-\"checksum serde_ignored 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c10e798e4405d7dcec3658989e35ee6706f730a9ed7c1184d5ebd84317e82f46\"\n+\"checksum serde_ignored 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"190e9765dcedb56be63b6e0993a006c7e3b071a016a304736e4a315dc01fb142\"\n \"checksum serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"48b04779552e92037212c3615370f6bd57a40ebba7f20e554ff9f55e41a69a7b\"\n \"checksum shell-escape 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dd5cc96481d54583947bfe88bf30c23d53f883c6cd0145368b69989d97b84ef8\"\n \"checksum siphasher 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0df90a788073e8d0235a67e50441d47db7c8ad9debd91cbf43736a2a92d36537\""}, {"sha": "266dffa5c92c76790a0026848d7ad30b3d5941aa", "filename": "src/bootstrap/bin/sccache-plus-cl.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fbootstrap%2Fbin%2Fsccache-plus-cl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fbootstrap%2Fbin%2Fsccache-plus-cl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Fsccache-plus-cl.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -18,12 +18,13 @@ fn main() {\n     // Locate the actual compiler that we're invoking\n     env::remove_var(\"CC\");\n     env::remove_var(\"CXX\");\n-    let mut cfg = gcc::Config::new();\n+    let mut cfg = gcc::Build::new();\n     cfg.cargo_metadata(false)\n        .out_dir(\"/\")\n        .target(&target)\n        .host(&target)\n        .opt_level(0)\n+       .warnings(false)\n        .debug(false);\n     let compiler = cfg.get_compiler();\n "}, {"sha": "4765546b184d39bffa0c1375f8af83da2e9e9b2f", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -251,9 +251,9 @@ impl<'a> Builder<'a> {\n                 tool::RustInstaller, tool::Cargo, tool::Rls, tool::Rustdoc, tool::Clippy,\n                 native::Llvm),\n             Kind::Test => describe!(check::Tidy, check::Bootstrap, check::DefaultCompiletest,\n-                check::HostCompiletest, check::Crate, check::CrateLibrustc, check::Linkcheck,\n-                check::Cargotest, check::Cargo, check::Rls, check::Docs, check::ErrorIndex,\n-                check::Distcheck),\n+                check::HostCompiletest, check::Crate, check::CrateLibrustc, check::Rustdoc,\n+                check::Linkcheck, check::Cargotest, check::Cargo, check::Rls, check::Docs,\n+                check::ErrorIndex, check::Distcheck),\n             Kind::Bench => describe!(check::Crate, check::CrateLibrustc),\n             Kind::Doc => describe!(doc::UnstableBook, doc::UnstableBookGen, doc::TheBook,\n                 doc::Standalone, doc::Std, doc::Test, doc::Rustc, doc::ErrorIndex, doc::Nomicon,"}, {"sha": "c77e609d70be06b8dbd36f4bd49de5e274cfcc29", "filename": "src/bootstrap/cc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fbootstrap%2Fcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fbootstrap%2Fcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -45,8 +45,8 @@ pub fn find(build: &mut Build) {\n     // For all targets we're going to need a C compiler for building some shims\n     // and such as well as for being a linker for Rust code.\n     for target in build.targets.iter().chain(&build.hosts).cloned().chain(iter::once(build.build)) {\n-        let mut cfg = gcc::Config::new();\n-        cfg.cargo_metadata(false).opt_level(0).debug(false)\n+        let mut cfg = gcc::Build::new();\n+        cfg.cargo_metadata(false).opt_level(0).warnings(false).debug(false)\n            .target(&target).host(&build.build);\n \n         let config = build.config.target_config.get(&target);\n@@ -67,8 +67,8 @@ pub fn find(build: &mut Build) {\n \n     // For all host triples we need to find a C++ compiler as well\n     for host in build.hosts.iter().cloned().chain(iter::once(build.build)) {\n-        let mut cfg = gcc::Config::new();\n-        cfg.cargo_metadata(false).opt_level(0).debug(false).cpp(true)\n+        let mut cfg = gcc::Build::new();\n+        cfg.cargo_metadata(false).opt_level(0).warnings(false).debug(false).cpp(true)\n            .target(&host).host(&build.build);\n         let config = build.config.target_config.get(&host);\n         if let Some(cxx) = config.and_then(|c| c.cxx.as_ref()) {\n@@ -82,7 +82,7 @@ pub fn find(build: &mut Build) {\n     }\n }\n \n-fn set_compiler(cfg: &mut gcc::Config,\n+fn set_compiler(cfg: &mut gcc::Build,\n                 gnu_compiler: &str,\n                 target: Interned<String>,\n                 config: Option<&Target>,"}, {"sha": "0d5c3addd9e7447df135a5ac11610f57af94dc1d", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 68, "deletions": 1, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -900,7 +900,6 @@ impl Step for CrateLibrustc {\n     }\n }\n \n-\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Crate {\n     compiler: Compiler,\n@@ -1080,6 +1079,74 @@ impl Step for Crate {\n     }\n }\n \n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Rustdoc {\n+    host: Interned<String>,\n+    test_kind: TestKind,\n+}\n+\n+impl Step for Rustdoc {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/librustdoc\").path(\"src/tools/rustdoc\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        let builder = run.builder;\n+\n+        let test_kind = if builder.kind == Kind::Test {\n+            TestKind::Test\n+        } else if builder.kind == Kind::Bench {\n+            TestKind::Bench\n+        } else {\n+            panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n+        };\n+\n+        builder.ensure(Rustdoc {\n+            host: run.host,\n+            test_kind,\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let test_kind = self.test_kind;\n+\n+        let compiler = builder.compiler(builder.top_stage, self.host);\n+        let target = compiler.host;\n+\n+        builder.ensure(RemoteCopyLibs { compiler, target });\n+\n+        let mut cargo = builder.cargo(compiler, Mode::Librustc, target, test_kind.subcommand());\n+        compile::rustc_cargo(build, &compiler, target, &mut cargo);\n+        let _folder = build.fold_output(|| {\n+            format!(\"{}_stage{}-rustdoc\", test_kind.subcommand(), compiler.stage)\n+        });\n+        println!(\"{} rustdoc stage{} ({} -> {})\", test_kind, compiler.stage,\n+                &compiler.host, target);\n+\n+        if test_kind.subcommand() == \"test\" && !build.fail_fast {\n+            cargo.arg(\"--no-fail-fast\");\n+        }\n+\n+        cargo.arg(\"-p\").arg(\"rustdoc:0.0.0\");\n+\n+        cargo.arg(\"--\");\n+        cargo.args(&build.config.cmd.test_args());\n+\n+        if build.config.quiet_tests {\n+            cargo.arg(\"--quiet\");\n+        }\n+\n+        let _time = util::timeit();\n+\n+        try_run(build, &mut cargo);\n+    }\n+}\n+\n fn envify(s: &str) -> String {\n     s.chars().map(|c| {\n         match c {"}, {"sha": "9180c7d165a37a300379280f68f725bb93e36adb", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -20,7 +20,7 @@\n \n use std::env;\n use std::fs::{self, File};\n-use std::io::{Read, Write};\n+use std::io::{self, Read, Write};\n use std::path::{PathBuf, Path};\n use std::process::{Command, Stdio};\n \n@@ -365,6 +365,9 @@ impl Step for Rustc {\n         // tiny morsel of metadata is used by rust-packaging\n         let version = build.rust_version();\n         t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n+        if let Some(sha) = build.rust_sha() {\n+            t!(t!(File::create(overlay.join(\"git-commit-hash\"))).write_all(sha.as_bytes()));\n+        }\n \n         // On MinGW we've got a few runtime DLL dependencies that we need to\n         // include. The first argument to this script is where to put these DLLs\n@@ -429,7 +432,7 @@ impl Step for Rustc {\n \n             // Man pages\n             t!(fs::create_dir_all(image.join(\"share/man/man1\")));\n-            cp_r(&build.src.join(\"man\"), &image.join(\"share/man/man1\"));\n+            cp_r(&build.src.join(\"src/doc/man\"), &image.join(\"share/man/man1\"));\n \n             // Debugger scripts\n             builder.ensure(DebuggerScripts {\n@@ -831,7 +834,6 @@ impl Step for PlainSourceTarball {\n             \"config.toml.example\",\n         ];\n         let src_dirs = [\n-            \"man\",\n             \"src\",\n         ];\n \n@@ -844,6 +846,9 @@ impl Step for PlainSourceTarball {\n \n         // Create the version file\n         write_file(&plain_dst_src.join(\"version\"), build.rust_version().as_bytes());\n+        if let Some(sha) = build.rust_sha() {\n+            write_file(&plain_dst_src.join(\"git-commit-hash\"), sha.as_bytes());\n+        }\n \n         // If we're building from git sources, we need to vendor a complete distribution.\n         if build.rust_info.is_git() {\n@@ -894,7 +899,12 @@ impl Step for PlainSourceTarball {\n fn install(src: &Path, dstdir: &Path, perms: u32) {\n     let dst = dstdir.join(src.file_name().unwrap());\n     t!(fs::create_dir_all(dstdir));\n-    t!(fs::copy(src, &dst));\n+    drop(fs::remove_file(&dst));\n+    {\n+        let mut s = t!(fs::File::open(&src));\n+        let mut d = t!(fs::File::create(&dst));\n+        io::copy(&mut s, &mut d).expect(\"failed to copy\");\n+    }\n     chmod(&dst, perms);\n }\n \n@@ -1157,14 +1167,20 @@ impl Step for Extended {\n         install(&build.src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n         let version = build.rust_version();\n         t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n+        if let Some(sha) = build.rust_sha() {\n+            t!(t!(File::create(overlay.join(\"git-commit-hash\"))).write_all(sha.as_bytes()));\n+        }\n         install(&etc.join(\"README.md\"), &overlay, 0o644);\n \n         // When rust-std package split from rustc, we needed to ensure that during\n         // upgrades rustc was upgraded before rust-std. To avoid rustc clobbering\n         // the std files during uninstall. To do this ensure that rustc comes\n         // before rust-std in the list below.\n         let mut tarballs = vec![rustc_installer, cargo_installer, rls_installer,\n-                                analysis_installer, docs_installer, std_installer];\n+                                analysis_installer, std_installer];\n+        if build.config.docs {\n+            tarballs.push(docs_installer);\n+        }\n         if target.contains(\"pc-windows-gnu\") {\n             tarballs.push(mingw_installer.unwrap());\n         }"}, {"sha": "608924c9c28d196b623d421a87e185030cbc59d5", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -200,7 +200,7 @@ install!((self, builder, _config),\n         builder.ensure(dist::Src);\n         install_src(builder, self.stage);\n     }, ONLY_BUILD;\n-    Rustc, \"src/librustc\", _config.extended, only_hosts: true, {\n+    Rustc, \"src/librustc\", true, only_hosts: true, {\n         builder.ensure(dist::Rustc {\n             compiler: builder.compiler(self.stage, self.target),\n         });"}, {"sha": "67791e8758c0bef14305ff987505c6a81d497943", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -797,6 +797,11 @@ impl Build {\n         self.rust_info.version(self, channel::CFG_RELEASE_NUM)\n     }\n \n+    /// Return the full commit hash\n+    fn rust_sha(&self) -> Option<&str> {\n+        self.rust_info.sha()\n+    }\n+\n     /// Returns the `a.b.c` version that the given package is at.\n     fn release_num(&self, package: &str) -> String {\n         let mut toml = String::new();"}, {"sha": "2cbae083fc464bd7610d825fcb72e3e5e41e8c95", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -289,7 +289,7 @@ impl Step for TestHelpers {\n         let _folder = build.fold_output(|| \"build_test_helpers\");\n         println!(\"Building test helpers\");\n         t!(fs::create_dir_all(&dst));\n-        let mut cfg = gcc::Config::new();\n+        let mut cfg = gcc::Build::new();\n \n         // We may have found various cross-compilers a little differently due to our\n         // extra configuration, so inform gcc of these compilers. Note, though, that\n@@ -306,6 +306,7 @@ impl Step for TestHelpers {\n            .target(&target)\n            .host(&build.build)\n            .opt_level(0)\n+           .warnings(false)\n            .debug(false)\n            .file(build.src.join(\"src/rt/rust_test_helpers.c\"))\n            .compile(\"librust_test_helpers.a\");\n@@ -416,6 +417,7 @@ impl Step for Openssl {\n             \"powerpc64-unknown-linux-gnu\" => \"linux-ppc64\",\n             \"powerpc64le-unknown-linux-gnu\" => \"linux-ppc64le\",\n             \"s390x-unknown-linux-gnu\" => \"linux64-s390x\",\n+            \"sparc64-unknown-netbsd\" => \"BSD-sparc64\",\n             \"x86_64-apple-darwin\" => \"darwin64-x86_64-cc\",\n             \"x86_64-linux-android\" => \"linux-x86_64\",\n             \"x86_64-unknown-freebsd\" => \"BSD-x86_64\",\n@@ -435,6 +437,15 @@ impl Step for Openssl {\n             configure.arg(\"-mandroid\");\n             configure.arg(\"-fomit-frame-pointer\");\n         }\n+        if target == \"sparc64-unknown-netbsd\" {\n+            // Need -m64 to get assembly generated correctly for sparc64.\n+            configure.arg(\"-m64\");\n+            if build.build.contains(\"netbsd\") {\n+                // Disable sparc64 asm on NetBSD builders, it uses\n+                // m4(1)'s -B flag, which NetBSD m4 does not support.\n+                configure.arg(\"no-asm\");\n+            }\n+        }\n         // Make PIE binaries\n         // Non-PIE linker support was removed in Lollipop\n         // https://source.android.com/security/enhancements/enhancements50"}, {"sha": "eaa2b1244236fa59f74c9836229305fd0a704e59", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -62,6 +62,7 @@ struct ToolBuild {\n     compiler: Compiler,\n     target: Interned<String>,\n     tool: &'static str,\n+    path: &'static str,\n     mode: Mode,\n }\n \n@@ -81,6 +82,7 @@ impl Step for ToolBuild {\n         let compiler = self.compiler;\n         let target = self.target;\n         let tool = self.tool;\n+        let path = self.path;\n \n         match self.mode {\n             Mode::Libstd => builder.ensure(compile::Std { compiler, target }),\n@@ -92,7 +94,7 @@ impl Step for ToolBuild {\n         let _folder = build.fold_output(|| format!(\"stage{}-{}\", compiler.stage, tool));\n         println!(\"Building stage{} tool {} ({})\", compiler.stage, tool, target);\n \n-        let mut cargo = prepare_tool_cargo(builder, compiler, target, tool);\n+        let mut cargo = prepare_tool_cargo(builder, compiler, target, path);\n         build.run(&mut cargo);\n         build.cargo_out(compiler, Mode::Tool, target).join(exe(tool, &compiler.host))\n     }\n@@ -102,11 +104,11 @@ fn prepare_tool_cargo(\n     builder: &Builder,\n     compiler: Compiler,\n     target: Interned<String>,\n-    tool: &'static str,\n+    path: &'static str,\n ) -> Command {\n     let build = builder.build;\n     let mut cargo = builder.cargo(compiler, Mode::Tool, target, \"build\");\n-    let dir = build.src.join(\"src/tools\").join(tool);\n+    let dir = build.src.join(path);\n     cargo.arg(\"--manifest-path\").arg(dir.join(\"Cargo.toml\"));\n \n     // We don't want to build tools dynamically as they'll be running across\n@@ -184,6 +186,7 @@ macro_rules! tool {\n                     target: self.target,\n                     tool: $tool_name,\n                     mode: $mode,\n+                    path: $path,\n                 })\n             }\n         }\n@@ -201,7 +204,7 @@ tool!(\n     Compiletest, \"src/tools/compiletest\", \"compiletest\", Mode::Libtest;\n     BuildManifest, \"src/tools/build-manifest\", \"build-manifest\", Mode::Libstd;\n     RemoteTestClient, \"src/tools/remote-test-client\", \"remote-test-client\", Mode::Libstd;\n-    RustInstaller, \"src/tools/rust-installer\", \"rust-installer\", Mode::Libstd;\n+    RustInstaller, \"src/tools/rust-installer\", \"fabricate\", Mode::Libstd;\n );\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n@@ -230,6 +233,7 @@ impl Step for RemoteTestServer {\n             target: self.target,\n             tool: \"remote-test-server\",\n             mode: Mode::Libstd,\n+            path: \"src/tools/remote-test-server\",\n         })\n     }\n }\n@@ -276,7 +280,10 @@ impl Step for Rustdoc {\n         let _folder = build.fold_output(|| format!(\"stage{}-rustdoc\", target_compiler.stage));\n         println!(\"Building rustdoc for stage{} ({})\", target_compiler.stage, target_compiler.host);\n \n-        let mut cargo = prepare_tool_cargo(builder, build_compiler, target, \"rustdoc\");\n+        let mut cargo = prepare_tool_cargo(builder,\n+                                           build_compiler,\n+                                           target,\n+                                           \"src/tools/rustdoc\");\n         build.run(&mut cargo);\n         // Cargo adds a number of paths to the dylib search path on windows, which results in\n         // the wrong rustdoc being executed. To avoid the conflicting rustdocs, we name the \"tool\"\n@@ -337,6 +344,7 @@ impl Step for Cargo {\n             target: self.target,\n             tool: \"cargo\",\n             mode: Mode::Librustc,\n+            path: \"src/tools/cargo\",\n         })\n     }\n }\n@@ -375,6 +383,7 @@ impl Step for Clippy {\n             target: self.target,\n             tool: \"clippy\",\n             mode: Mode::Librustc,\n+            path: \"src/tools/clippy\",\n         })\n     }\n }\n@@ -417,6 +426,7 @@ impl Step for Rls {\n             target: self.target,\n             tool: \"rls\",\n             mode: Mode::Librustc,\n+            path: \"src/tools/rls\",\n         })\n     }\n }"}, {"sha": "a521dd09453916b263f081638a70799286608e62", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -34,8 +34,12 @@ pub fn staticlib(name: &str, target: &str) -> String {\n /// Copies a file from `src` to `dst`\n pub fn copy(src: &Path, dst: &Path) {\n     let _ = fs::remove_file(&dst);\n-    let res = fs::copy(src, dst);\n-    if let Err(e) = res {\n+    // Attempt to \"easy copy\" by creating a hard link (symlinks don't work on\n+    // windows), but if that fails just fall back to a slow `copy` operation.\n+    if let Ok(()) = fs::hard_link(src, dst) {\n+        return\n+    }\n+    if let Err(e) = fs::copy(src, dst) {\n         panic!(\"failed to copy `{}` to `{}`: {}\", src.display(),\n                dst.display(), e)\n     }\n@@ -44,7 +48,6 @@ pub fn copy(src: &Path, dst: &Path) {\n     let atime = FileTime::from_last_access_time(&metadata);\n     let mtime = FileTime::from_last_modification_time(&metadata);\n     t!(filetime::set_file_times(dst, atime, mtime));\n-\n }\n \n /// Copies the `src` directory recursively to `dst`. Both are assumed to exist"}, {"sha": "6c80f11fa7205fdd22fd35f579134624ea6da15b", "filename": "src/doc/man/rustc.1", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fdoc%2Fman%2Frustc.1", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fdoc%2Fman%2Frustc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fman%2Frustc.1?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "previous_filename": "man/rustc.1"}, {"sha": "d34ab6135499d80a74fd0a87f8dbc0bc539d317c", "filename": "src/doc/man/rustdoc.1", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fdoc%2Fman%2Frustdoc.1", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fdoc%2Fman%2Frustdoc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fman%2Frustdoc.1?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "previous_filename": "man/rustdoc.1"}, {"sha": "f8c8a2a7a718bafa31c0f1dcd8adabb885cd12f6", "filename": "src/doc/unstable-book/src/library-features/entry-or-default.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fentry-or-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fentry-or-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fentry-or-default.md?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -0,0 +1,13 @@\n+# `entry_or_default`\n+\n+The tracking issue for this feature is: [#44324]\n+\n+[#44324]: https://github.com/rust-lang/rust/issues/44324\n+\n+------------------------\n+\n+The `entry_or_default` feature adds a new method to `hash_map::Entry`\n+and `btree_map::Entry`, `or_default`, when `V: Default`. This method is\n+semantically identical to `or_insert_with(Default::default)`, and will\n+insert the default value for the type if no entry exists for the current\n+key."}, {"sha": "626843818425466a3a2dd6aa2be5207a86b90200", "filename": "src/etc/platform-intrinsics/powerpc.json", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fetc%2Fplatform-intrinsics%2Fpowerpc.json", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fetc%2Fplatform-intrinsics%2Fpowerpc.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fpowerpc.json?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -156,6 +156,69 @@\n             \"llvm\": \"vupkh{1.kind}{1.data_type_short}\",\n             \"ret\": \"s(16-32)\",\n             \"args\": [\"0N\"]\n+        },\n+        {\n+            \"intrinsic\": \"madds\",\n+            \"width\": [128],\n+            \"llvm\": \"vmhaddshs\",\n+            \"ret\": \"s16\",\n+            \"args\": [\"0\", \"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"msumu{1.data_type_short}m\",\n+            \"width\": [128],\n+            \"llvm\": \"vmsumu{1.data_type_short}m\",\n+            \"ret\": \"u32\",\n+            \"args\": [\"u(8-16)\", \"1\", \"u32\"]\n+        },\n+        {\n+            \"intrinsic\": \"msummbm\",\n+            \"width\": [128],\n+            \"llvm\": \"vmsummbm\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"s8\", \"u8\", \"s32\"]\n+        },\n+        {\n+            \"intrinsic\": \"msumshm\",\n+            \"width\": [128],\n+            \"llvm\": \"vmsumshm\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"s16\", \"s16\", \"s32\"]\n+        },\n+        {\n+            \"intrinsic\": \"msum{0.kind}hs\",\n+            \"width\": [128],\n+            \"llvm\": \"vmsum{0.kind}hs\",\n+            \"ret\": \"i32\",\n+            \"args\": [\"0N\", \"0N\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"sum2s\",\n+            \"width\": [128],\n+            \"llvm\": \"vsum2sws\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"sum4{0.kind}bs\",\n+            \"width\": [128],\n+            \"llvm\": \"vsum4{0.kind}bs\",\n+            \"ret\": \"i32\",\n+            \"args\": [\"0NN\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"sum4shs\",\n+            \"width\": [128],\n+            \"llvm\": \"vsum4shs\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"0N\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"sums\",\n+            \"width\": [128],\n+            \"llvm\": \"vsumsws\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"0\", \"0\"]\n         }\n     ]\n }"}, {"sha": "4341b0b2975beeb9fccf93bb750153a929d61403", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -62,7 +62,7 @@ use core::any::Any;\n use core::borrow;\n use core::cmp::Ordering;\n use core::fmt;\n-use core::hash::{self, Hash};\n+use core::hash::{self, Hash, Hasher};\n use core::iter::FusedIterator;\n use core::marker::{self, Unsize};\n use core::mem;\n@@ -456,6 +456,52 @@ impl<T: ?Sized + Hash> Hash for Box<T> {\n     }\n }\n \n+#[stable(feature = \"indirect_hasher_impl\", since = \"1.22.0\")]\n+impl<T: ?Sized + Hasher> Hasher for Box<T> {\n+    fn finish(&self) -> u64 {\n+        (**self).finish()\n+    }\n+    fn write(&mut self, bytes: &[u8]) {\n+        (**self).write(bytes)\n+    }\n+    fn write_u8(&mut self, i: u8) {\n+        (**self).write_u8(i)\n+    }\n+    fn write_u16(&mut self, i: u16) {\n+        (**self).write_u16(i)\n+    }\n+    fn write_u32(&mut self, i: u32) {\n+        (**self).write_u32(i)\n+    }\n+    fn write_u64(&mut self, i: u64) {\n+        (**self).write_u64(i)\n+    }\n+    fn write_u128(&mut self, i: u128) {\n+        (**self).write_u128(i)\n+    }\n+    fn write_usize(&mut self, i: usize) {\n+        (**self).write_usize(i)\n+    }\n+    fn write_i8(&mut self, i: i8) {\n+        (**self).write_i8(i)\n+    }\n+    fn write_i16(&mut self, i: i16) {\n+        (**self).write_i16(i)\n+    }\n+    fn write_i32(&mut self, i: i32) {\n+        (**self).write_i32(i)\n+    }\n+    fn write_i64(&mut self, i: i64) {\n+        (**self).write_i64(i)\n+    }\n+    fn write_i128(&mut self, i: i128) {\n+        (**self).write_i128(i)\n+    }\n+    fn write_isize(&mut self, i: isize) {\n+        (**self).write_isize(i)\n+    }\n+}\n+\n #[stable(feature = \"from_for_ptrs\", since = \"1.6.0\")]\n impl<T> From<T> for Box<T> {\n     fn from(t: T) -> Self {"}, {"sha": "4c93fead172372fa20201861e0f47096e18e5f2f", "filename": "src/liballoc/btree/map.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fliballoc%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fliballoc%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fmap.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -2104,6 +2104,33 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n     }\n }\n \n+impl<'a, K: Ord, V: Default> Entry<'a, K, V> {\n+    #[unstable(feature = \"entry_or_default\", issue = \"44324\")]\n+    /// Ensures a value is in the entry by inserting the default value if empty,\n+    /// and returns a mutable reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(entry_or_default)]\n+    /// # fn main() {\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, Option<usize>> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_default();\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], None);\n+    /// # }\n+    /// ```\n+    pub fn or_default(self) -> &'a mut V {\n+        match self {\n+            Occupied(entry) => entry.into_mut(),\n+            Vacant(entry) => entry.insert(Default::default()),\n+        }\n+    }\n+\n+}\n+\n impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n     /// Gets a reference to the key that would be used when inserting a value\n     /// through the VacantEntry."}, {"sha": "2845d349ae165b0961467201e2cd4e30b87e39a4", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -121,7 +121,7 @@\n #![feature(unsize)]\n #![feature(allocator_internals)]\n \n-#![cfg_attr(not(test), feature(fused, fn_traits, placement_new_protocol, swap_with_slice))]\n+#![cfg_attr(not(test), feature(fused, fn_traits, placement_new_protocol, swap_with_slice, i128))]\n #![cfg_attr(test, feature(test, box_heap))]\n \n // Allow testing this library"}, {"sha": "2045d5ddd972ddc37645294b811535bf6974e925", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -671,10 +671,25 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// ```\n-    /// let v = [10, 40, 30, 20, 50];\n-    /// let (v1, v2) = v.split_at(2);\n-    /// assert_eq!([10, 40], v1);\n-    /// assert_eq!([30, 20, 50], v2);\n+    /// let v = [1, 2, 3, 4, 5, 6];\n+    ///\n+    /// {\n+    ///    let (left, right) = v.split_at(0);\n+    ///    assert!(left == []);\n+    ///    assert!(right == [1, 2, 3, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.split_at(2);\n+    ///     assert!(left == [1, 2]);\n+    ///     assert!(right == [3, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.split_at(6);\n+    ///     assert!(left == [1, 2, 3, 4, 5, 6]);\n+    ///     assert!(right == []);\n+    /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -695,26 +710,16 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut v = [1, 2, 3, 4, 5, 6];\n-    ///\n+    /// let mut v = [1, 0, 3, 0, 5, 6];\n     /// // scoped to restrict the lifetime of the borrows\n     /// {\n-    ///    let (left, right) = v.split_at_mut(0);\n-    ///    assert!(left == []);\n-    ///    assert!(right == [1, 2, 3, 4, 5, 6]);\n-    /// }\n-    ///\n-    /// {\n     ///     let (left, right) = v.split_at_mut(2);\n-    ///     assert!(left == [1, 2]);\n-    ///     assert!(right == [3, 4, 5, 6]);\n-    /// }\n-    ///\n-    /// {\n-    ///     let (left, right) = v.split_at_mut(6);\n-    ///     assert!(left == [1, 2, 3, 4, 5, 6]);\n-    ///     assert!(right == []);\n+    ///     assert!(left == [1, 0]);\n+    ///     assert!(right == [3, 0, 5, 6]);\n+    ///     left[1] = 2;\n+    ///     right[1] = 4;\n     /// }\n+    /// assert!(v == [1, 2, 3, 4, 5, 6]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]"}, {"sha": "f0c63a2eb55d5cb99f58c2861f8e3e7b2f428a4f", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 44, "deletions": 7, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -297,6 +297,34 @@ impl str {\n     /// [`str::from_utf8_mut`] function.\n     ///\n     /// [`str::from_utf8_mut`]: ./str/fn.from_utf8_mut.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let mut s = String::from(\"Hello\");\n+    /// let bytes = unsafe { s.as_bytes_mut() };\n+    ///\n+    /// assert_eq!(b\"Hello\", bytes);\n+    /// ```\n+    ///\n+    /// Mutability:\n+    ///\n+    /// ```\n+    /// let mut s = String::from(\"\ud83d\uddfb\u2208\ud83c\udf0f\");\n+    ///\n+    /// unsafe {\n+    ///     let bytes = s.as_bytes_mut();\n+    ///\n+    ///     bytes[0] = 0xF0;\n+    ///     bytes[1] = 0x9F;\n+    ///     bytes[2] = 0x8D;\n+    ///     bytes[3] = 0x94;\n+    /// }\n+    ///\n+    /// assert_eq!(\"\ud83c\udf54\u2208\ud83c\udf0f\", s);\n+    /// ```\n     #[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n     #[inline(always)]\n     pub unsafe fn as_bytes_mut(&mut self) -> &mut [u8] {\n@@ -362,16 +390,25 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut v = String::from(\"\ud83d\uddfb\u2208\ud83c\udf0f\");\n-    ///\n-    /// assert_eq!(Some(\"\ud83d\uddfb\"), v.get_mut(0..4).map(|v| &*v));\n-    ///\n-    /// // indices not on UTF-8 sequence boundaries\n-    /// assert!(v.get_mut(1..).is_none());\n-    /// assert!(v.get_mut(..8).is_none());\n+    /// use std::ascii::AsciiExt;\n     ///\n+    /// let mut v = String::from(\"hello\");\n+    /// // correct length\n+    /// assert!(v.get_mut(0..5).is_some());\n     /// // out of bounds\n     /// assert!(v.get_mut(..42).is_none());\n+    /// assert_eq!(Some(\"he\"), v.get_mut(0..2).map(|v| &*v));\n+    ///\n+    /// assert_eq!(\"hello\", v);\n+    /// {\n+    ///     let s = v.get_mut(0..2);\n+    ///     let s = s.map(|s| {\n+    ///         s.make_ascii_uppercase();\n+    ///         &*s\n+    ///     });\n+    ///     assert_eq!(Some(\"HE\"), s);\n+    /// }\n+    /// assert_eq!(\"HEllo\", v);\n     /// ```\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     #[inline]"}, {"sha": "1708f3e398756d493b22d8ec6c8810363c6ede06", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -743,6 +743,16 @@ impl String {\n     }\n \n     /// Extracts a string slice containing the entire string.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = String::from(\"foo\");\n+    ///\n+    /// assert_eq!(\"foo\", s.as_str());\n+    /// ```\n     #[inline]\n     #[stable(feature = \"string_as_str\", since = \"1.7.0\")]\n     pub fn as_str(&self) -> &str {"}, {"sha": "c5beb63d12e9d0f07052b3fd1d38f54d30198f61", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -50,3 +50,19 @@ fn hash<T: Hash>(t: &T) -> u64 {\n     t.hash(&mut s);\n     s.finish()\n }\n+\n+// FIXME: Instantiated functions with i128 in the signature is not supported in Emscripten.\n+// See https://github.com/kripken/emscripten-fastcomp/issues/169\n+#[cfg(not(target_os = \"emscripten\"))]\n+#[test]\n+fn test_boxed_hasher() {\n+    let ordinary_hash = hash(&5u32);\n+\n+    let mut hasher_1 = Box::new(DefaultHasher::new());\n+    5u32.hash(&mut hasher_1);\n+    assert_eq!(ordinary_hash, hasher_1.finish());\n+\n+    let mut hasher_2 = Box::new(DefaultHasher::new()) as Box<Hasher>;\n+    5u32.hash(&mut hasher_2);\n+    assert_eq!(ordinary_hash, hasher_2.finish());\n+}"}, {"sha": "1864df4477abfadd7bc2808f239440fa659a1c2a", "filename": "src/liballoc_jemalloc/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fliballoc_jemalloc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fliballoc_jemalloc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Fbuild.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -63,7 +63,7 @@ fn main() {\n         _ => return,\n     };\n \n-    let compiler = gcc::Config::new().get_compiler();\n+    let compiler = gcc::Build::new().get_compiler();\n     // only msvc returns None for ar so unwrap is okay\n     let ar = build_helper::cc2ar(compiler.path(), &target).unwrap();\n     let cflags = compiler.args()\n@@ -150,7 +150,7 @@ fn main() {\n     // sure the symbols are available.\n     if target.contains(\"androideabi\") {\n         println!(\"cargo:rerun-if-changed=pthread_atfork_dummy.c\");\n-        gcc::Config::new()\n+        gcc::Build::new()\n             .flag(\"-fvisibility=hidden\")\n             .file(\"pthread_atfork_dummy.c\")\n             .compile(\"libpthread_atfork_dummy.a\");"}, {"sha": "d153f19c4622f021d78dee45d2453b22b10dc9a5", "filename": "src/liballoc_jemalloc/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fliballoc_jemalloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fliballoc_jemalloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Flib.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![no_std]\n+#![allow(unused_attributes)]\n #![unstable(feature = \"alloc_jemalloc\",\n             reason = \"this library is unlikely to be stabilized in its current \\\n                       form or name\",\n@@ -19,8 +20,10 @@\n #![feature(libc)]\n #![feature(linkage)]\n #![feature(staged_api)]\n+#![feature(rustc_attrs)]\n #![cfg_attr(dummy_jemalloc, allow(dead_code, unused_extern_crates))]\n #![cfg_attr(not(dummy_jemalloc), feature(allocator_api))]\n+#![rustc_alloc_kind = \"exe\"]\n \n extern crate alloc;\n extern crate alloc_system;"}, {"sha": "2eb659699eb9b4839c3615c41c99d47686c6cb22", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![no_std]\n+#![allow(unused_attributes)]\n #![deny(warnings)]\n #![unstable(feature = \"alloc_system\",\n             reason = \"this library is unlikely to be stabilized in its current \\\n@@ -19,7 +20,9 @@\n #![feature(alloc)]\n #![feature(core_intrinsics)]\n #![feature(staged_api)]\n+#![feature(rustc_attrs)]\n #![cfg_attr(any(unix, target_os = \"redox\"), feature(libc))]\n+#![rustc_alloc_kind = \"lib\"]\n \n // The minimum alignment guaranteed by the architecture. This value is used to\n // add fast paths for low alignment values. In practice, the alignment is a\n@@ -221,7 +224,7 @@ mod platform {\n         }\n     }\n \n-    #[cfg(any(target_os = \"android\", target_os = \"redox\"))]\n+    #[cfg(any(target_os = \"android\", target_os = \"redox\", target_os = \"solaris\"))]\n     #[inline]\n     unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n         // On android we currently target API level 9 which unfortunately\n@@ -244,7 +247,7 @@ mod platform {\n         libc::memalign(layout.align(), layout.size()) as *mut u8\n     }\n \n-    #[cfg(not(any(target_os = \"android\", target_os = \"redox\")))]\n+    #[cfg(not(any(target_os = \"android\", target_os = \"redox\", target_os = \"solaris\")))]\n     #[inline]\n     unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n         let mut out = ptr::null_mut();"}, {"sha": "ed47ba3c2fa0822f621a5db62db529c1b5dd0a13", "filename": "src/libbacktrace/configure", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibbacktrace%2Fconfigure", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibbacktrace%2Fconfigure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fconfigure?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -11844,6 +11844,9 @@ elf*) FORMAT_FILE=\"elf.lo\" ;;\n pecoff) FORMAT_FILE=\"pecoff.lo\"\n         backtrace_supports_data=no\n \t;;\n+macho*) FORMAT_FILE=\"macho.lo\"\n+        backtrace_supports_data=no\n+        ;;\n *) { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: could not determine output file type\" >&5\n $as_echo \"$as_me: WARNING: could not determine output file type\" >&2;}\n    FORMAT_FILE=\"unknown.lo\""}, {"sha": "7ae21b8d1a68c78bb67af749d939d525c01ed0b0", "filename": "src/libbacktrace/configure.ac", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibbacktrace%2Fconfigure.ac", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibbacktrace%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fconfigure.ac?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -231,6 +231,9 @@ elf*) FORMAT_FILE=\"elf.lo\" ;;\n pecoff) FORMAT_FILE=\"pecoff.lo\"\n         backtrace_supports_data=no\n \t;;\n+macho*) FORMAT_FILE=\"macho.lo\"\n+        backtrace_supports_data=no\n+        ;;\n *) AC_MSG_WARN([could not determine output file type])\n    FORMAT_FILE=\"unknown.lo\"\n    backtrace_supported=no"}, {"sha": "a5f6c8cc1800f0cb24d415cade2b0905f54a730f", "filename": "src/libbacktrace/filetype.awk", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibbacktrace%2Ffiletype.awk", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibbacktrace%2Ffiletype.awk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Ffiletype.awk?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -3,3 +3,9 @@\n /\\177ELF\\002/ { if (NR == 1) { print \"elf64\"; exit } }\n /\\114\\001/    { if (NR == 1) { print \"pecoff\"; exit } }\n /\\144\\206/    { if (NR == 1) { print \"pecoff\"; exit } }\n+/\\xFE\\xED\\xFA\\xCE/ { if (NR == 1) { print \"macho32\"; exit } }\n+/\\xCE\\xFA\\xED\\xFE/ { if (NR == 1) { print \"macho32\"; exit } }\n+/\\xFE\\xED\\xFA\\xCF/ { if (NR == 1) { print \"macho64\"; exit } }\n+/\\xCF\\xFA\\xED\\xFE/ { if (NR == 1) { print \"macho64\"; exit } }\n+/\\xCA\\xFE\\xBA\\xBE/ { if (NR == 1) { print \"macho-fat\"; exit } }\n+/\\xBE\\xBA\\xFE\\xCA/ { if (NR == 1) { print \"macho-fat\"; exit } }"}, {"sha": "9af14e724b40d8b292f5b9683e5ad7a51c07ee2b", "filename": "src/libbacktrace/macho.c", "status": "added", "additions": 1416, "deletions": 0, "changes": 1416, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibbacktrace%2Fmacho.c", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibbacktrace%2Fmacho.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fmacho.c?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -0,0 +1,1416 @@\n+/* macho.c -- Get debug data from an Mach-O file for backtraces.\n+   Copyright (C) 2012-2016 Free Software Foundation, Inc.\n+   Written by John Colanduoni.\n+\n+   Pending upstream pull request:\n+   https://github.com/ianlancetaylor/libbacktrace/pull/2\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+/* We can't use autotools to detect the pointer width of our program because\n+   we may be building a fat Mach-O file containing both 32-bit and 64-bit\n+   variants. However Mach-O runs a limited set of platforms so detection\n+   via preprocessor is not difficult.  */\n+\n+#if defined(__MACH__)\n+#if defined(__LP64__)\n+#define BACKTRACE_BITS 64\n+#else\n+#define BACKTRACE_BITS 32\n+#endif\n+#else\n+#error Attempting to build Mach-O support on incorrect platform\n+#endif\n+\n+#if defined(__x86_64__)\n+#define NATIVE_CPU_TYPE CPU_TYPE_X86_64\n+#elif defined(__i386__)\n+#define NATIVE_CPU_TYPE CPU_TYPE_X86\n+#elif defined(__aarch64__)\n+#define NATIVE_CPU_TYPE CPU_TYPE_ARM64\n+#elif defined(__arm__)\n+#define NATIVE_CPU_TYPE CPU_TYPE_ARM\n+#else\n+#error Could not detect native Mach-O cpu_type_t\n+#endif\n+\n+#include <sys/types.h>\n+#include <sys/syslimits.h>\n+#include <string.h>\n+#include <mach-o/loader.h>\n+#include <mach-o/nlist.h>\n+#include <mach-o/fat.h>\n+#include <mach-o/dyld.h>\n+#include <uuid/uuid.h>\n+#include <dirent.h>\n+#include <stdlib.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+struct macho_commands_view\n+{\n+    struct backtrace_view view;\n+    uint32_t commands_count;\n+    uint32_t commands_total_size;\n+    int bytes_swapped;\n+    size_t base_offset;\n+};\n+\n+enum debug_section\n+{\n+    DEBUG_INFO,\n+    DEBUG_LINE,\n+    DEBUG_ABBREV,\n+    DEBUG_RANGES,\n+    DEBUG_STR,\n+    DEBUG_MAX\n+};\n+\n+static const char *const debug_section_names[DEBUG_MAX] =\n+    {\n+        \"__debug_info\",\n+        \"__debug_line\",\n+        \"__debug_abbrev\",\n+        \"__debug_ranges\",\n+        \"__debug_str\"\n+    };\n+\n+struct found_dwarf_section\n+{\n+    uint32_t file_offset;\n+    uintptr_t file_size;\n+    const unsigned char *data;\n+};\n+\n+/* Mach-O symbols don't have a length. As a result we have to infer it\n+   by sorting the symbol addresses for each image and recording the\n+   memory range attributed to each image.  */\n+struct macho_symbol\n+{\n+    uintptr_t addr;\n+    size_t size;\n+    const char *name;\n+};\n+\n+struct macho_syminfo_data\n+{\n+    struct macho_syminfo_data *next;\n+    struct macho_symbol *symbols;\n+    size_t symbol_count;\n+    uintptr_t min_addr;\n+    uintptr_t max_addr;\n+};\n+\n+uint16_t\n+macho_file_to_host_u16 (int file_bytes_swapped, uint16_t input)\n+{\n+  if (file_bytes_swapped)\n+    return (input >> 8) | (input << 8);\n+  else\n+    return input;\n+}\n+\n+uint32_t\n+macho_file_to_host_u32 (int file_bytes_swapped, uint32_t input)\n+{\n+  if (file_bytes_swapped)\n+    {\n+      return ((input >> 24) & 0x000000FF)\n+             | ((input >> 8) & 0x0000FF00)\n+             | ((input << 8) & 0x00FF0000)\n+             | ((input << 24) & 0xFF000000);\n+    }\n+  else\n+    {\n+      return input;\n+    }\n+}\n+\n+uint64_t\n+macho_file_to_host_u64 (int file_bytes_swapped, uint64_t input)\n+{\n+  if (file_bytes_swapped)\n+    {\n+      return macho_file_to_host_u32 (file_bytes_swapped,\n+                                     (uint32_t) (input >> 32))\n+             | (((uint64_t) macho_file_to_host_u32 (file_bytes_swapped,\n+                                                    (uint32_t) input)) << 32);\n+    }\n+  else\n+    {\n+      return input;\n+    }\n+}\n+\n+#if BACKTRACE_BITS == 64\n+#define macho_file_to_host_usize macho_file_to_host_u64\n+typedef struct mach_header_64 mach_header_native_t;\n+#define LC_SEGMENT_NATIVE LC_SEGMENT_64\n+typedef struct segment_command_64 segment_command_native_t;\n+typedef struct nlist_64 nlist_native_t;\n+typedef struct section_64 section_native_t;\n+#else /* BACKTRACE_BITS == 32 */\n+#define macho_file_to_host_usize macho_file_to_host_u32\n+typedef struct mach_header mach_header_native_t;\n+#define LC_SEGMENT_NATIVE LC_SEGMENT\n+typedef struct segment_command segment_command_native_t;\n+typedef struct nlist nlist_native_t;\n+typedef struct section section_native_t;\n+#endif\n+\n+// Gets a view into a Mach-O image, taking any slice offset into account\n+int\n+macho_get_view (struct backtrace_state *state, int descriptor,\n+                off_t offset, size_t size,\n+                backtrace_error_callback error_callback,\n+                void *data, struct macho_commands_view *commands_view,\n+                struct backtrace_view *view)\n+{\n+  return backtrace_get_view (state, descriptor,\n+                             commands_view->base_offset + offset, size,\n+                             error_callback, data, view);\n+}\n+\n+int\n+macho_get_commands (struct backtrace_state *state, int descriptor,\n+                    backtrace_error_callback error_callback,\n+                    void *data, struct macho_commands_view *commands_view,\n+                    int *incompatible)\n+{\n+  int ret = 0;\n+  int is_fat = 0;\n+  struct backtrace_view file_header_view;\n+  int file_header_view_valid = 0;\n+  struct backtrace_view fat_archs_view;\n+  int fat_archs_view_valid = 0;\n+  const mach_header_native_t *file_header;\n+  uint64_t commands_offset;\n+\n+  *incompatible = 0;\n+\n+  if (!backtrace_get_view (state, descriptor, 0, sizeof (mach_header_native_t),\n+                           error_callback, data, &file_header_view))\n+    goto end;\n+  file_header_view_valid = 1;\n+\n+  switch (*(uint32_t *) file_header_view.data)\n+    {\n+      case MH_MAGIC:\n+        if (BACKTRACE_BITS == 32)\n+          commands_view->bytes_swapped = 0;\n+        else\n+          {\n+            *incompatible = 1;\n+            goto end;\n+          }\n+      break;\n+      case MH_CIGAM:\n+        if (BACKTRACE_BITS == 32)\n+          commands_view->bytes_swapped = 1;\n+        else\n+          {\n+            *incompatible = 1;\n+            goto end;\n+          }\n+      break;\n+      case MH_MAGIC_64:\n+        if (BACKTRACE_BITS == 64)\n+          commands_view->bytes_swapped = 0;\n+        else\n+          {\n+            *incompatible = 1;\n+            goto end;\n+          }\n+      break;\n+      case MH_CIGAM_64:\n+        if (BACKTRACE_BITS == 64)\n+          commands_view->bytes_swapped = 1;\n+        else\n+          {\n+            *incompatible = 1;\n+            goto end;\n+          }\n+      break;\n+      case FAT_MAGIC:\n+        is_fat = 1;\n+        commands_view->bytes_swapped = 0;\n+      break;\n+      case FAT_CIGAM:\n+        is_fat = 1;\n+        commands_view->bytes_swapped = 1;\n+      break;\n+      default:\n+        goto end;\n+    }\n+\n+  if (is_fat)\n+    {\n+      uint32_t native_slice_offset;\n+      size_t archs_total_size;\n+      uint32_t arch_count;\n+      const struct fat_header *fat_header;\n+      const struct fat_arch *archs;\n+      uint32_t i;\n+\n+      fat_header = file_header_view.data;\n+      arch_count =\n+          macho_file_to_host_u32 (commands_view->bytes_swapped,\n+                                  fat_header->nfat_arch);\n+\n+      archs_total_size = arch_count * sizeof (struct fat_arch);\n+\n+      if (!backtrace_get_view (state, descriptor, sizeof (struct fat_header),\n+                               archs_total_size, error_callback,\n+                               data, &fat_archs_view))\n+        goto end;\n+      fat_archs_view_valid = 1;\n+\n+      native_slice_offset = 0;\n+      archs = fat_archs_view.data;\n+      for (i = 0; i < arch_count; i++)\n+        {\n+          const struct fat_arch *raw_arch = archs + i;\n+          int cpu_type =\n+              (int) macho_file_to_host_u32 (commands_view->bytes_swapped,\n+                                            (uint32_t) raw_arch->cputype);\n+\n+          if (cpu_type == NATIVE_CPU_TYPE)\n+            {\n+              native_slice_offset =\n+                  macho_file_to_host_u32 (commands_view->bytes_swapped,\n+                                          raw_arch->offset);\n+\n+              break;\n+            }\n+        }\n+\n+      if (native_slice_offset == 0)\n+        {\n+          *incompatible = 1;\n+          goto end;\n+        }\n+\n+      backtrace_release_view (state, &file_header_view, error_callback, data);\n+      file_header_view_valid = 0;\n+      if (!backtrace_get_view (state, descriptor, native_slice_offset,\n+                               sizeof (mach_header_native_t), error_callback,\n+                               data, &file_header_view))\n+        goto end;\n+      file_header_view_valid = 1;\n+\n+      // The endianess of the slice may be different than the fat image\n+      switch (*(uint32_t *) file_header_view.data)\n+        {\n+          case MH_MAGIC:\n+            if (BACKTRACE_BITS == 32)\n+              commands_view->bytes_swapped = 0;\n+            else\n+              goto end;\n+          break;\n+          case MH_CIGAM:\n+            if (BACKTRACE_BITS == 32)\n+              commands_view->bytes_swapped = 1;\n+            else\n+              goto end;\n+          break;\n+          case MH_MAGIC_64:\n+            if (BACKTRACE_BITS == 64)\n+              commands_view->bytes_swapped = 0;\n+            else\n+              goto end;\n+          break;\n+          case MH_CIGAM_64:\n+            if (BACKTRACE_BITS == 64)\n+              commands_view->bytes_swapped = 1;\n+            else\n+              goto end;\n+          break;\n+          default:\n+            goto end;\n+        }\n+\n+      commands_view->base_offset = native_slice_offset;\n+    }\n+  else\n+    commands_view->base_offset = 0;\n+\n+  file_header = file_header_view.data;\n+  commands_view->commands_count =\n+      macho_file_to_host_u32 (commands_view->bytes_swapped,\n+                              file_header->ncmds);\n+  commands_view->commands_total_size =\n+      macho_file_to_host_u32 (commands_view->bytes_swapped,\n+                              file_header->sizeofcmds);\n+  commands_offset =\n+      commands_view->base_offset + sizeof (mach_header_native_t);\n+\n+  if (!backtrace_get_view (state, descriptor, commands_offset,\n+                           commands_view->commands_total_size, error_callback,\n+                           data, &commands_view->view))\n+    goto end;\n+\n+  ret = 1;\n+\n+end:\n+  if (file_header_view_valid)\n+    backtrace_release_view (state, &file_header_view, error_callback, data);\n+  if (fat_archs_view_valid)\n+    backtrace_release_view (state, &fat_archs_view, error_callback, data);\n+  return ret;\n+}\n+\n+int\n+macho_get_uuid (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+                int descriptor ATTRIBUTE_UNUSED,\n+                backtrace_error_callback error_callback,\n+                void *data, struct macho_commands_view *commands_view,\n+                uuid_t *uuid)\n+{\n+  size_t offset = 0;\n+  uint32_t i = 0;\n+\n+  for (i = 0; i < commands_view->commands_count; i++)\n+    {\n+      const struct load_command *raw_command;\n+      struct load_command command;\n+\n+      if (offset + sizeof (struct load_command)\n+          > commands_view->commands_total_size)\n+        {\n+          error_callback (data,\n+                          \"executable file contains out of range command offset\",\n+                          0);\n+          return 0;\n+        }\n+\n+      raw_command =\n+          commands_view->view.data + offset;\n+      command.cmd = macho_file_to_host_u32 (commands_view->bytes_swapped,\n+                                            raw_command->cmd);\n+      command.cmdsize = macho_file_to_host_u32 (commands_view->bytes_swapped,\n+                                                raw_command->cmdsize);\n+\n+      if (command.cmd == LC_UUID)\n+        {\n+          const struct uuid_command *uuid_command;\n+\n+          if (offset + sizeof (struct uuid_command)\n+              > commands_view->commands_total_size)\n+            {\n+              error_callback (data,\n+                              \"executable file contains out of range command offset\",\n+                              0);\n+              return 0;\n+            }\n+\n+          uuid_command =\n+              (struct uuid_command *) raw_command;\n+          memcpy (uuid, uuid_command->uuid, sizeof (uuid_t));\n+          return 1;\n+        }\n+\n+      offset += command.cmdsize;\n+    }\n+\n+  error_callback (data, \"executable file is missing an identifying UUID\", 0);\n+  return 0;\n+}\n+\n+/* Returns the base address of a Mach-O image, as encoded in the file header.\n+ * WARNING: This does not take ASLR into account, which is ubiquitous on recent\n+ * Darwin platforms.\n+ */\n+int\n+macho_get_addr_range (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+                      int descriptor ATTRIBUTE_UNUSED,\n+                      backtrace_error_callback error_callback,\n+                      void *data, struct macho_commands_view *commands_view,\n+                      uintptr_t *base_address, uintptr_t *max_address)\n+{\n+  size_t offset = 0;\n+  int found_text = 0;\n+  uint32_t i = 0;\n+\n+  *max_address = 0;\n+\n+  for (i = 0; i < commands_view->commands_count; i++)\n+    {\n+      const struct load_command *raw_command;\n+      struct load_command command;\n+\n+      if (offset + sizeof (struct load_command)\n+          > commands_view->commands_total_size)\n+        {\n+          error_callback (data,\n+                          \"executable file contains out of range command offset\",\n+                          0);\n+          return 0;\n+        }\n+\n+      raw_command = commands_view->view.data + offset;\n+      command.cmd = macho_file_to_host_u32 (commands_view->bytes_swapped,\n+                                            raw_command->cmd);\n+      command.cmdsize = macho_file_to_host_u32 (commands_view->bytes_swapped,\n+                                                raw_command->cmdsize);\n+\n+      if (command.cmd == LC_SEGMENT_NATIVE)\n+        {\n+          const segment_command_native_t *raw_segment;\n+          uintptr_t segment_vmaddr;\n+          uintptr_t segment_vmsize;\n+          uintptr_t segment_maxaddr;\n+          uintptr_t text_fileoff;\n+\n+          if (offset + sizeof (segment_command_native_t)\n+              > commands_view->commands_total_size)\n+            {\n+              error_callback (data,\n+                              \"executable file contains out of range command offset\",\n+                              0);\n+              return 0;\n+            }\n+\n+          raw_segment = (segment_command_native_t *) raw_command;\n+\n+          segment_vmaddr = macho_file_to_host_usize (\n+              commands_view->bytes_swapped, raw_segment->vmaddr);\n+          segment_vmsize = macho_file_to_host_usize (\n+              commands_view->bytes_swapped, raw_segment->vmsize);\n+          segment_maxaddr = segment_vmaddr + segment_vmsize;\n+\n+          if (strncmp (raw_segment->segname, \"__TEXT\",\n+                       sizeof (raw_segment->segname)) == 0)\n+            {\n+              text_fileoff = macho_file_to_host_usize (\n+                  commands_view->bytes_swapped, raw_segment->fileoff);\n+              *base_address = segment_vmaddr - text_fileoff;\n+\n+              found_text = 1;\n+            }\n+\n+          if (segment_maxaddr > *max_address)\n+            *max_address = segment_maxaddr;\n+        }\n+\n+      offset += command.cmdsize;\n+    }\n+\n+  if (found_text)\n+    return 1;\n+  else\n+    {\n+      error_callback (data, \"executable is missing __TEXT segment\", 0);\n+      return 0;\n+    }\n+}\n+\n+static int\n+macho_symbol_compare_addr (const void *left_raw, const void *right_raw)\n+{\n+  const struct macho_symbol *left = left_raw;\n+  const struct macho_symbol *right = right_raw;\n+\n+  if (left->addr > right->addr)\n+    return 1;\n+  else if (left->addr < right->addr)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+int\n+macho_symbol_type_relevant (uint8_t type)\n+{\n+  uint8_t type_field = (uint8_t) (type & N_TYPE);\n+\n+  return !(type & N_EXT) &&\n+         (type_field == N_ABS || type_field == N_SECT);\n+}\n+\n+int\n+macho_add_symtab (struct backtrace_state *state,\n+                  backtrace_error_callback error_callback,\n+                  void *data, int descriptor,\n+                  struct macho_commands_view *commands_view,\n+                  uintptr_t base_address, uintptr_t max_image_address,\n+                  intptr_t vmslide, int *found_sym)\n+{\n+  struct macho_syminfo_data *syminfo_data;\n+\n+  int ret = 0;\n+  size_t offset = 0;\n+  struct backtrace_view symtab_view;\n+  int symtab_view_valid = 0;\n+  struct backtrace_view strtab_view;\n+  int strtab_view_valid = 0;\n+  size_t syminfo_index = 0;\n+  size_t function_count = 0;\n+  uint32_t i = 0;\n+  uint32_t j = 0;\n+  uint32_t symtab_index = 0;\n+\n+  *found_sym = 0;\n+\n+  for (i = 0; i < commands_view->commands_count; i++)\n+    {\n+      const struct load_command *raw_command;\n+      struct load_command command;\n+\n+      if (offset + sizeof (struct load_command)\n+          > commands_view->commands_total_size)\n+        {\n+          error_callback (data,\n+                          \"executable file contains out of range command offset\",\n+                          0);\n+          return 0;\n+        }\n+\n+      raw_command = commands_view->view.data + offset;\n+      command.cmd = macho_file_to_host_u32 (commands_view->bytes_swapped,\n+                                            raw_command->cmd);\n+      command.cmdsize = macho_file_to_host_u32 (commands_view->bytes_swapped,\n+                                                raw_command->cmdsize);\n+\n+      if (command.cmd == LC_SYMTAB)\n+        {\n+          const struct symtab_command *symtab_command;\n+          uint32_t symbol_table_offset;\n+          uint32_t symbol_count;\n+          uint32_t string_table_offset;\n+          uint32_t string_table_size;\n+\n+          if (offset + sizeof (struct symtab_command)\n+              > commands_view->commands_total_size)\n+            {\n+              error_callback (data,\n+                              \"executable file contains out of range command offset\",\n+                              0);\n+              return 0;\n+            }\n+\n+          symtab_command = (struct symtab_command *) raw_command;\n+\n+          symbol_table_offset = macho_file_to_host_u32 (\n+              commands_view->bytes_swapped, symtab_command->symoff);\n+          symbol_count = macho_file_to_host_u32 (\n+              commands_view->bytes_swapped, symtab_command->nsyms);\n+          string_table_offset = macho_file_to_host_u32 (\n+              commands_view->bytes_swapped, symtab_command->stroff);\n+          string_table_size = macho_file_to_host_u32 (\n+              commands_view->bytes_swapped, symtab_command->strsize);\n+\n+\n+          if (!macho_get_view (state, descriptor, symbol_table_offset,\n+                               symbol_count * sizeof (nlist_native_t),\n+                               error_callback, data, commands_view,\n+                               &symtab_view))\n+            goto end;\n+          symtab_view_valid = 1;\n+\n+          if (!macho_get_view (state, descriptor, string_table_offset,\n+                               string_table_size, error_callback, data,\n+                               commands_view, &strtab_view))\n+            goto end;\n+          strtab_view_valid = 1;\n+\n+          // Count functions first\n+          for (j = 0; j < symbol_count; j++)\n+            {\n+              const nlist_native_t *raw_sym =\n+                  ((const nlist_native_t *) symtab_view.data) + j;\n+\n+              if (macho_symbol_type_relevant (raw_sym->n_type))\n+                {\n+                  function_count += 1;\n+                }\n+            }\n+\n+          // Allocate space for the:\n+          //  (a) macho_syminfo_data for this image\n+          //  (b) macho_symbol entries\n+          syminfo_data =\n+              backtrace_alloc (state,\n+                               sizeof (struct macho_syminfo_data),\n+                               error_callback, data);\n+          if (syminfo_data == NULL)\n+            goto end;\n+\n+          syminfo_data->symbols = backtrace_alloc (\n+              state, function_count * sizeof (struct macho_symbol),\n+              error_callback, data);\n+          if (syminfo_data->symbols == NULL)\n+            goto end;\n+\n+          syminfo_data->symbol_count = function_count;\n+          syminfo_data->next = NULL;\n+          syminfo_data->min_addr = base_address;\n+          syminfo_data->max_addr = max_image_address;\n+\n+          for (symtab_index = 0;\n+               symtab_index < symbol_count; symtab_index++)\n+            {\n+              const nlist_native_t *raw_sym =\n+                  ((const nlist_native_t *) symtab_view.data) +\n+                  symtab_index;\n+\n+              if (macho_symbol_type_relevant (raw_sym->n_type))\n+                {\n+                  size_t strtab_index;\n+                  const char *name;\n+                  size_t max_len_plus_one;\n+\n+                  syminfo_data->symbols[syminfo_index].addr =\n+                      macho_file_to_host_usize (commands_view->bytes_swapped,\n+                                                raw_sym->n_value) + vmslide;\n+\n+                  strtab_index = macho_file_to_host_u32 (\n+                      commands_view->bytes_swapped,\n+                      raw_sym->n_un.n_strx);\n+\n+                  // Check the range of the supposed \"string\" we've been\n+                  // given\n+                  if (strtab_index >= string_table_size)\n+                    {\n+                      error_callback (\n+                          data,\n+                          \"dSYM file contains out of range string table index\",\n+                          0);\n+                      goto end;\n+                    }\n+\n+                  name = strtab_view.data + strtab_index;\n+                  max_len_plus_one = string_table_size - strtab_index;\n+\n+                  if (strnlen (name, max_len_plus_one) >= max_len_plus_one)\n+                    {\n+                      error_callback (\n+                          data,\n+                          \"dSYM file contains unterminated string\",\n+                          0);\n+                      goto end;\n+                    }\n+\n+                  // Remove underscore prefixes\n+                  if (name[0] == '_')\n+                    {\n+                      name = name + 1;\n+                    }\n+\n+                  syminfo_data->symbols[syminfo_index].name = name;\n+\n+                  syminfo_index += 1;\n+                }\n+            }\n+\n+          backtrace_qsort (syminfo_data->symbols,\n+                           syminfo_data->symbol_count,\n+                           sizeof (struct macho_symbol),\n+                           macho_symbol_compare_addr);\n+\n+          // Calculate symbol sizes\n+          for (syminfo_index = 0;\n+               syminfo_index < syminfo_data->symbol_count; syminfo_index++)\n+            {\n+              if (syminfo_index + 1 < syminfo_data->symbol_count)\n+                {\n+                  syminfo_data->symbols[syminfo_index].size =\n+                      syminfo_data->symbols[syminfo_index + 1].addr -\n+                      syminfo_data->symbols[syminfo_index].addr;\n+                }\n+              else\n+                {\n+                  syminfo_data->symbols[syminfo_index].size =\n+                      max_image_address -\n+                      syminfo_data->symbols[syminfo_index].addr;\n+                }\n+            }\n+\n+          if (!state->threaded)\n+            {\n+              struct macho_syminfo_data **pp;\n+\n+              for (pp = (struct macho_syminfo_data **) (void *) &state->syminfo_data;\n+                   *pp != NULL;\n+                   pp = &(*pp)->next);\n+              *pp = syminfo_data;\n+            }\n+          else\n+            {\n+              while (1)\n+                {\n+                  struct macho_syminfo_data **pp;\n+\n+                  pp = (struct macho_syminfo_data **) (void *) &state->syminfo_data;\n+\n+                  while (1)\n+                    {\n+                      struct macho_syminfo_data *p;\n+\n+                      p = backtrace_atomic_load_pointer (pp);\n+\n+                      if (p == NULL)\n+                        break;\n+\n+                      pp = &p->next;\n+                    }\n+\n+                  if (__sync_bool_compare_and_swap (pp, NULL, syminfo_data))\n+                    break;\n+                }\n+            }\n+\n+          strtab_view_valid = 0; // We need to keep string table around\n+          *found_sym = 1;\n+          ret = 1;\n+          goto end;\n+        }\n+\n+      offset += command.cmdsize;\n+    }\n+\n+  // No symbol table here\n+  ret = 1;\n+  goto end;\n+\n+end:\n+  if (symtab_view_valid)\n+    backtrace_release_view (state, &symtab_view, error_callback, data);\n+  if (strtab_view_valid)\n+    backtrace_release_view (state, &strtab_view, error_callback, data);\n+  return ret;\n+}\n+\n+int\n+macho_try_dwarf (struct backtrace_state *state,\n+                 backtrace_error_callback error_callback,\n+                 void *data, fileline *fileline_fn, uuid_t *executable_uuid,\n+                 uintptr_t base_address, uintptr_t max_image_address,\n+                 intptr_t vmslide, char *dwarf_filename, int *matched,\n+                 int *found_sym, int *found_dwarf)\n+{\n+  uuid_t dwarf_uuid;\n+\n+  int ret = 0;\n+  int dwarf_descriptor;\n+  int dwarf_descriptor_valid = 0;\n+  struct macho_commands_view commands_view;\n+  int commands_view_valid = 0;\n+  struct backtrace_view dwarf_view;\n+  int dwarf_view_valid = 0;\n+  size_t offset = 0;\n+  struct found_dwarf_section dwarf_sections[DEBUG_MAX];\n+  uintptr_t min_dwarf_offset = 0;\n+  uintptr_t max_dwarf_offset = 0;\n+  uint32_t i = 0;\n+  uint32_t j = 0;\n+  int k = 0;\n+\n+  *matched = 0;\n+  *found_sym = 0;\n+  *found_dwarf = 0;\n+\n+  if ((dwarf_descriptor = backtrace_open (dwarf_filename, error_callback,\n+                                          data, NULL)) == 0)\n+    goto end;\n+  dwarf_descriptor_valid = 1;\n+\n+  int incompatible;\n+  if (!macho_get_commands (state, dwarf_descriptor, error_callback, data,\n+                           &commands_view, &incompatible))\n+    {\n+      // Failing to read the header here is fine, because this dSYM may be\n+      // for a different architecture\n+      if (incompatible)\n+        {\n+          ret = 1;\n+        }\n+      goto end;\n+    }\n+  commands_view_valid = 1;\n+\n+  // Get dSYM UUID and compare\n+  if (!macho_get_uuid (state, dwarf_descriptor, error_callback, data,\n+                       &commands_view, &dwarf_uuid))\n+    {\n+      error_callback (data, \"dSYM file is missing an identifying uuid\", 0);\n+      goto end;\n+    }\n+  if (memcmp (executable_uuid, &dwarf_uuid, sizeof (uuid_t)) != 0)\n+    {\n+      // DWARF doesn't belong to desired executable\n+      ret = 1;\n+      goto end;\n+    }\n+\n+  *matched = 1;\n+\n+  // Read symbol table\n+  if (!macho_add_symtab (state, error_callback, data, dwarf_descriptor,\n+                         &commands_view, base_address, max_image_address,\n+                         vmslide, found_sym))\n+    goto end;\n+\n+  // Get DWARF sections\n+\n+  memset (dwarf_sections, 0, sizeof (dwarf_sections));\n+  offset = 0;\n+  for (i = 0; i < commands_view.commands_count; i++)\n+    {\n+      const struct load_command *raw_command;\n+      struct load_command command;\n+\n+      if (offset + sizeof (struct load_command)\n+          > commands_view.commands_total_size)\n+        {\n+          error_callback (data,\n+                          \"dSYM file contains out of range command offset\", 0);\n+          goto end;\n+        }\n+\n+      raw_command = commands_view.view.data + offset;\n+      command.cmd = macho_file_to_host_u32 (commands_view.bytes_swapped,\n+                                            raw_command->cmd);\n+      command.cmdsize = macho_file_to_host_u32 (commands_view.bytes_swapped,\n+                                                raw_command->cmdsize);\n+\n+      if (command.cmd == LC_SEGMENT_NATIVE)\n+        {\n+          uint32_t section_count;\n+          size_t section_offset;\n+          const segment_command_native_t *raw_segment;\n+\n+          if (offset + sizeof (segment_command_native_t)\n+              > commands_view.commands_total_size)\n+            {\n+              error_callback (data,\n+                              \"dSYM file contains out of range command offset\",\n+                              0);\n+              goto end;\n+            }\n+\n+          raw_segment = (const segment_command_native_t *) raw_command;\n+\n+          if (strncmp (raw_segment->segname, \"__DWARF\",\n+                       sizeof (raw_segment->segname)) == 0)\n+            {\n+              section_count = macho_file_to_host_u32 (\n+                  commands_view.bytes_swapped,\n+                  raw_segment->nsects);\n+\n+              section_offset = offset + sizeof (segment_command_native_t);\n+\n+              // Search sections for relevant DWARF section names\n+              for (j = 0; j < section_count; j++)\n+                {\n+                  const section_native_t *raw_section;\n+\n+                  if (section_offset + sizeof (section_native_t) >\n+                      commands_view.commands_total_size)\n+                    {\n+                      error_callback (data,\n+                                      \"dSYM file contains out of range command offset\",\n+                                      0);\n+                      goto end;\n+                    }\n+\n+                  raw_section = commands_view.view.data + section_offset;\n+\n+                  for (k = 0; k < DEBUG_MAX; k++)\n+                    {\n+                      uintptr_t dwarf_section_end;\n+\n+                      if (strncmp (raw_section->sectname,\n+                                   debug_section_names[k],\n+                                   sizeof (raw_section->sectname)) == 0)\n+                        {\n+                          *found_dwarf = 1;\n+\n+                          dwarf_sections[k].file_offset =\n+                              macho_file_to_host_u32 (\n+                                  commands_view.bytes_swapped,\n+                                  raw_section->offset);\n+                          dwarf_sections[k].file_size =\n+                              macho_file_to_host_usize (\n+                                  commands_view.bytes_swapped,\n+                                  raw_section->size);\n+\n+                          if (min_dwarf_offset == 0 ||\n+                              dwarf_sections[k].file_offset <\n+                              min_dwarf_offset)\n+                            min_dwarf_offset = dwarf_sections[k].file_offset;\n+\n+                          dwarf_section_end =\n+                              dwarf_sections[k].file_offset +\n+                              dwarf_sections[k].file_size;\n+                          if (dwarf_section_end > max_dwarf_offset)\n+                            max_dwarf_offset = dwarf_section_end;\n+\n+                          break;\n+                        }\n+                    }\n+\n+                  section_offset += sizeof (section_native_t);\n+                }\n+\n+              break;\n+            }\n+        }\n+\n+      offset += command.cmdsize;\n+    }\n+\n+  if (!*found_dwarf)\n+    {\n+      // No DWARF in this file\n+      ret = 1;\n+      goto end;\n+    }\n+\n+  if (!macho_get_view (state, dwarf_descriptor, (off_t) min_dwarf_offset,\n+                       max_dwarf_offset - min_dwarf_offset, error_callback,\n+                       data, &commands_view, &dwarf_view))\n+    goto end;\n+  dwarf_view_valid = 1;\n+\n+  for (i = 0; i < DEBUG_MAX; i++)\n+    {\n+      if (dwarf_sections[i].file_offset == 0)\n+        dwarf_sections[i].data = NULL;\n+      else\n+        dwarf_sections[i].data =\n+            dwarf_view.data + dwarf_sections[i].file_offset - min_dwarf_offset;\n+    }\n+\n+  if (!backtrace_dwarf_add (state, vmslide,\n+                            dwarf_sections[DEBUG_INFO].data,\n+                            dwarf_sections[DEBUG_INFO].file_size,\n+                            dwarf_sections[DEBUG_LINE].data,\n+                            dwarf_sections[DEBUG_LINE].file_size,\n+                            dwarf_sections[DEBUG_ABBREV].data,\n+                            dwarf_sections[DEBUG_ABBREV].file_size,\n+                            dwarf_sections[DEBUG_RANGES].data,\n+                            dwarf_sections[DEBUG_RANGES].file_size,\n+                            dwarf_sections[DEBUG_STR].data,\n+                            dwarf_sections[DEBUG_STR].file_size,\n+                            ((__DARWIN_BYTE_ORDER == __DARWIN_BIG_ENDIAN)\n+                            ^ commands_view.bytes_swapped),\n+                            error_callback, data, fileline_fn))\n+    goto end;\n+\n+  // Don't release the DWARF view because it is still in use\n+  dwarf_descriptor_valid = 0;\n+  dwarf_view_valid = 0;\n+  ret = 1;\n+\n+end:\n+  if (dwarf_descriptor_valid)\n+    backtrace_close (dwarf_descriptor, error_callback, data);\n+  if (commands_view_valid)\n+    backtrace_release_view (state, &commands_view.view, error_callback, data);\n+  if (dwarf_view_valid)\n+    backtrace_release_view (state, &dwarf_view, error_callback, data);\n+  return ret;\n+}\n+\n+int\n+macho_try_dsym (struct backtrace_state *state,\n+                backtrace_error_callback error_callback,\n+                void *data, fileline *fileline_fn, uuid_t *executable_uuid,\n+                uintptr_t base_address, uintptr_t max_image_address,\n+                intptr_t vmslide, char *dsym_filename, int *matched,\n+                int *found_sym, int *found_dwarf)\n+{\n+  int ret = 0;\n+  char dwarf_image_dir_path[PATH_MAX];\n+  DIR *dwarf_image_dir;\n+  int dwarf_image_dir_valid = 0;\n+  struct dirent *directory_entry;\n+  char dwarf_filename[PATH_MAX];\n+  int dwarf_matched;\n+  int dwarf_had_sym;\n+  int dwarf_had_dwarf;\n+\n+  *matched = 0;\n+  *found_sym = 0;\n+  *found_dwarf = 0;\n+\n+  strncpy (dwarf_image_dir_path, dsym_filename, PATH_MAX);\n+  strncat (dwarf_image_dir_path, \"/Contents/Resources/DWARF\", PATH_MAX);\n+\n+  if (!(dwarf_image_dir = opendir (dwarf_image_dir_path)))\n+    {\n+      error_callback (data, \"could not open DWARF directory in dSYM\",\n+                      0);\n+      goto end;\n+    }\n+  dwarf_image_dir_valid = 1;\n+\n+  while ((directory_entry = readdir (dwarf_image_dir)))\n+    {\n+      if (directory_entry->d_type != DT_REG)\n+        continue;\n+\n+      strncpy (dwarf_filename, dwarf_image_dir_path, PATH_MAX);\n+      strncat (dwarf_filename, \"/\", PATH_MAX);\n+      strncat (dwarf_filename, directory_entry->d_name, PATH_MAX);\n+\n+      if (!macho_try_dwarf (state, error_callback, data, fileline_fn,\n+                            executable_uuid, base_address, max_image_address,\n+                            vmslide, dwarf_filename,\n+                            &dwarf_matched, &dwarf_had_sym, &dwarf_had_dwarf))\n+        goto end;\n+\n+      if (dwarf_matched)\n+        {\n+          *matched = 1;\n+          *found_sym = dwarf_had_sym;\n+          *found_dwarf = dwarf_had_dwarf;\n+          ret = 1;\n+          goto end;\n+        }\n+    }\n+\n+  // No matching DWARF in this dSYM\n+  ret = 1;\n+  goto end;\n+\n+end:\n+  if (dwarf_image_dir_valid)\n+    closedir (dwarf_image_dir);\n+  return ret;\n+}\n+\n+int\n+macho_add (struct backtrace_state *state,\n+           backtrace_error_callback error_callback, void *data, int descriptor,\n+           const char *filename, fileline *fileline_fn, intptr_t vmslide,\n+           int *found_sym, int *found_dwarf)\n+{\n+  uuid_t image_uuid;\n+  uintptr_t image_file_base_address;\n+  uintptr_t image_file_max_address;\n+  uintptr_t image_actual_base_address = 0;\n+  uintptr_t image_actual_max_address = 0;\n+\n+  int ret = 0;\n+  struct macho_commands_view commands_view;\n+  int commands_view_valid = 0;\n+  char executable_dirname[PATH_MAX];\n+  size_t filename_len;\n+  DIR *executable_dir = NULL;\n+  int executable_dir_valid = 0;\n+  struct dirent *directory_entry;\n+  char dsym_full_path[PATH_MAX];\n+  static const char *extension;\n+  size_t extension_len;\n+  ssize_t i;\n+\n+  *found_sym = 0;\n+  *found_dwarf = 0;\n+\n+  // Find Mach-O commands list\n+  int incompatible;\n+  if (!macho_get_commands (state, descriptor, error_callback, data,\n+                           &commands_view, &incompatible))\n+    goto end;\n+  commands_view_valid = 1;\n+\n+  // First we need to get the uuid of our file so we can hunt down the correct\n+  // dSYM\n+  if (!macho_get_uuid (state, descriptor, error_callback, data, &commands_view,\n+                       &image_uuid))\n+    goto end;\n+\n+  // Now we need to find the in memory base address. Step one is to find out\n+  // what the executable thinks the base address is\n+  if (!macho_get_addr_range (state, descriptor, error_callback, data,\n+                             &commands_view,\n+                             &image_file_base_address,\n+                             &image_file_max_address))\n+    goto end;\n+\n+  image_actual_base_address =\n+      image_file_base_address + vmslide;\n+  image_actual_max_address =\n+      image_file_max_address + vmslide;\n+\n+  if (image_actual_base_address == 0)\n+    {\n+      error_callback (data, \"executable file is not loaded\", 0);\n+      goto end;\n+    }\n+\n+  // Look for dSYM in our executable's directory\n+  strncpy (executable_dirname, filename, PATH_MAX);\n+  filename_len = strlen (executable_dirname);\n+  for (i = filename_len - 1; i >= 0; i--)\n+    {\n+      if (executable_dirname[i] == '/')\n+        {\n+          executable_dirname[i] = '\\0';\n+          break;\n+        }\n+      else if (i == 0)\n+        {\n+          executable_dirname[0] = '.';\n+          executable_dirname[1] = '\\0';\n+          break;\n+        }\n+    }\n+\n+  if (!(executable_dir = opendir (executable_dirname)))\n+    {\n+      error_callback (data, \"could not open directory containing executable\",\n+                      0);\n+      goto end;\n+    }\n+  executable_dir_valid = 1;\n+\n+  extension = \".dSYM\";\n+  extension_len = strlen (extension);\n+  while ((directory_entry = readdir (executable_dir)))\n+    {\n+      if (directory_entry->d_namlen < extension_len)\n+        continue;\n+      if (strncasecmp (directory_entry->d_name + directory_entry->d_namlen\n+                       - extension_len, extension, extension_len) == 0)\n+        {\n+          int matched;\n+          int dsym_had_sym;\n+          int dsym_had_dwarf;\n+\n+          // Found a dSYM\n+          strncpy (dsym_full_path, executable_dirname, PATH_MAX);\n+          strncat (dsym_full_path, \"/\", PATH_MAX);\n+          strncat (dsym_full_path, directory_entry->d_name, PATH_MAX);\n+\n+          if (!macho_try_dsym (state, error_callback, data,\n+                               fileline_fn, &image_uuid,\n+                               image_actual_base_address,\n+                               image_actual_max_address, vmslide,\n+                               dsym_full_path,\n+                               &matched, &dsym_had_sym, &dsym_had_dwarf))\n+            goto end;\n+\n+          if (matched)\n+            {\n+              *found_sym = dsym_had_sym;\n+              *found_dwarf = dsym_had_dwarf;\n+              ret = 1;\n+              goto end;\n+            }\n+        }\n+    }\n+\n+  // No matching dSYM\n+  ret = 1;\n+  goto end;\n+\n+end:\n+  if (commands_view_valid)\n+    backtrace_release_view (state, &commands_view.view, error_callback,\n+                            data);\n+  if (executable_dir_valid)\n+    closedir (executable_dir);\n+  return ret;\n+}\n+\n+static int\n+macho_symbol_search (const void *vkey, const void *ventry)\n+{\n+  const uintptr_t *key = (const uintptr_t *) vkey;\n+  const struct macho_symbol *entry = (const struct macho_symbol *) ventry;\n+  uintptr_t addr;\n+\n+  addr = *key;\n+  if (addr < entry->addr)\n+    return -1;\n+  else if (addr >= entry->addr + entry->size)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+static void\n+macho_syminfo (struct backtrace_state *state,\n+               uintptr_t addr,\n+               backtrace_syminfo_callback callback,\n+               backtrace_error_callback error_callback ATTRIBUTE_UNUSED,\n+               void *data)\n+{\n+  struct macho_syminfo_data *edata;\n+  struct macho_symbol *sym = NULL;\n+\n+  if (!state->threaded)\n+    {\n+      for (edata = (struct macho_syminfo_data *) state->syminfo_data;\n+           edata != NULL;\n+           edata = edata->next)\n+        {\n+          if (addr >= edata->min_addr && addr <= edata->max_addr)\n+            {\n+              sym = ((struct macho_symbol *)\n+                  bsearch (&addr, edata->symbols, edata->symbol_count,\n+                           sizeof (struct macho_symbol), macho_symbol_search));\n+              if (sym != NULL)\n+                break;\n+            }\n+        }\n+    }\n+  else\n+    {\n+      struct macho_syminfo_data **pp;\n+\n+      pp = (struct macho_syminfo_data **) (void *) &state->syminfo_data;\n+      while (1)\n+        {\n+          edata = backtrace_atomic_load_pointer (pp);\n+          if (edata == NULL)\n+            break;\n+\n+          if (addr >= edata->min_addr && addr <= edata->max_addr)\n+            {\n+              sym = ((struct macho_symbol *)\n+                  bsearch (&addr, edata->symbols, edata->symbol_count,\n+                           sizeof (struct macho_symbol), macho_symbol_search));\n+              if (sym != NULL)\n+                break;\n+            }\n+\n+          pp = &edata->next;\n+        }\n+    }\n+\n+  if (sym == NULL)\n+    callback (data, addr, NULL, 0, 0);\n+  else\n+    callback (data, addr, sym->name, sym->addr, sym->size);\n+}\n+\n+\n+static int\n+macho_nodebug (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+               uintptr_t pc ATTRIBUTE_UNUSED,\n+               backtrace_full_callback callback ATTRIBUTE_UNUSED,\n+               backtrace_error_callback error_callback, void *data)\n+{\n+  error_callback (data, \"no debug info in Mach-O executable\", -1);\n+  return 0;\n+}\n+\n+static void\n+macho_nosyms (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+              uintptr_t addr ATTRIBUTE_UNUSED,\n+              backtrace_syminfo_callback callback ATTRIBUTE_UNUSED,\n+              backtrace_error_callback error_callback, void *data)\n+{\n+  error_callback (data, \"no symbol table in Mach-O executable\", -1);\n+}\n+\n+int\n+backtrace_initialize (struct backtrace_state *state, int descriptor,\n+                      backtrace_error_callback error_callback,\n+                      void *data, fileline *fileline_fn)\n+{\n+  int ret;\n+  fileline macho_fileline_fn = macho_nodebug;\n+  int found_sym = 0;\n+  int found_dwarf = 0;\n+  uint32_t i = 0;\n+  uint32_t loaded_image_count;\n+\n+  // Add all loaded images\n+  loaded_image_count = _dyld_image_count ();\n+  for (i = 0; i < loaded_image_count; i++)\n+    {\n+      int current_found_sym;\n+      int current_found_dwarf;\n+      int current_descriptor;\n+      intptr_t current_vmslide;\n+      const char *current_name;\n+\n+      current_vmslide = _dyld_get_image_vmaddr_slide (i);\n+      current_name = _dyld_get_image_name (i);\n+\n+      if (current_name == NULL || (i != 0 && current_vmslide == 0))\n+        continue;\n+\n+      if (!(current_descriptor =\n+                backtrace_open (current_name, error_callback, data, NULL)))\n+        {\n+          continue;\n+        }\n+\n+      if (macho_add (state, error_callback, data, current_descriptor,\n+                      current_name, &macho_fileline_fn, current_vmslide,\n+                      &current_found_sym, &current_found_dwarf))\n+        {\n+          found_sym = found_sym || current_found_sym;\n+          found_dwarf = found_dwarf || current_found_dwarf;\n+        }\n+\n+      backtrace_close (current_descriptor, error_callback, data);\n+    }\n+\n+  if (!state->threaded)\n+    {\n+      if (found_sym)\n+        state->syminfo_fn = macho_syminfo;\n+      else if (state->syminfo_fn == NULL)\n+        state->syminfo_fn = macho_nosyms;\n+    }\n+  else\n+    {\n+      if (found_sym)\n+        backtrace_atomic_store_pointer (&state->syminfo_fn, macho_syminfo);\n+      else\n+        (void) __sync_bool_compare_and_swap (&state->syminfo_fn, NULL,\n+                                             macho_nosyms);\n+    }\n+\n+  if (!state->threaded)\n+    {\n+      if (state->fileline_fn == NULL || state->fileline_fn == macho_nodebug)\n+        *fileline_fn = macho_fileline_fn;\n+    }\n+  else\n+    {\n+      fileline current_fn;\n+\n+      current_fn = backtrace_atomic_load_pointer (&state->fileline_fn);\n+      if (current_fn == NULL || current_fn == macho_nodebug)\n+        *fileline_fn = macho_fileline_fn;\n+    }\n+\n+  return 1;\n+}\n+"}, {"sha": "38ffaf97aa418cc369ca0197a72a0b927cc0f622", "filename": "src/libcompiler_builtins", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -1 +1 @@\n-Subproject commit 6b9281d2b2f0ebb94838814b1e8ace2de4b7035b\n+Subproject commit 38ffaf97aa418cc369ca0197a72a0b927cc0f622"}, {"sha": "bc1b911cd78ccdc97d54e531516bbed6bc1b2670", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -359,6 +359,52 @@ pub trait Hasher {\n     }\n }\n \n+#[stable(feature = \"indirect_hasher_impl\", since = \"1.22.0\")]\n+impl<'a, H: Hasher + ?Sized> Hasher for &'a mut H {\n+    fn finish(&self) -> u64 {\n+        (**self).finish()\n+    }\n+    fn write(&mut self, bytes: &[u8]) {\n+        (**self).write(bytes)\n+    }\n+    fn write_u8(&mut self, i: u8) {\n+        (**self).write_u8(i)\n+    }\n+    fn write_u16(&mut self, i: u16) {\n+        (**self).write_u16(i)\n+    }\n+    fn write_u32(&mut self, i: u32) {\n+        (**self).write_u32(i)\n+    }\n+    fn write_u64(&mut self, i: u64) {\n+        (**self).write_u64(i)\n+    }\n+    fn write_u128(&mut self, i: u128) {\n+        (**self).write_u128(i)\n+    }\n+    fn write_usize(&mut self, i: usize) {\n+        (**self).write_usize(i)\n+    }\n+    fn write_i8(&mut self, i: i8) {\n+        (**self).write_i8(i)\n+    }\n+    fn write_i16(&mut self, i: i16) {\n+        (**self).write_i16(i)\n+    }\n+    fn write_i32(&mut self, i: i32) {\n+        (**self).write_i32(i)\n+    }\n+    fn write_i64(&mut self, i: i64) {\n+        (**self).write_i64(i)\n+    }\n+    fn write_i128(&mut self, i: i128) {\n+        (**self).write_i128(i)\n+    }\n+    fn write_isize(&mut self, i: isize) {\n+        (**self).write_isize(i)\n+    }\n+}\n+\n /// A trait for creating instances of [`Hasher`].\n ///\n /// A `BuildHasher` is typically used (e.g. by [`HashMap`]) to create"}, {"sha": "d64c984ea7d284786f392e1e0e19d9ee15364afb", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -17,18 +17,11 @@ macro_rules! panic {\n         panic!(\"explicit panic\")\n     );\n     ($msg:expr) => ({\n-        static _MSG_FILE_LINE_COL: (&'static str, &'static str, u32, u32) =\n-            ($msg, file!(), line!(), __rust_unstable_column!());\n-        $crate::panicking::panic(&_MSG_FILE_LINE_COL)\n+        $crate::panicking::panic(&($msg, file!(), line!(), __rust_unstable_column!()))\n     });\n     ($fmt:expr, $($arg:tt)*) => ({\n-        // The leading _'s are to avoid dead code warnings if this is\n-        // used inside a dead function. Just `#[allow(dead_code)]` is\n-        // insufficient, since the user may have\n-        // `#[forbid(dead_code)]` and which cannot be overridden.\n-        static _MSG_FILE_LINE_COL: (&'static str, u32, u32) =\n-            (file!(), line!(), __rust_unstable_column!());\n-        $crate::panicking::panic_fmt(format_args!($fmt, $($arg)*), &_MSG_FILE_LINE_COL)\n+        $crate::panicking::panic_fmt(format_args!($fmt, $($arg)*),\n+                                     &(file!(), line!(), __rust_unstable_column!()))\n     });\n }\n \n@@ -531,15 +524,13 @@ macro_rules! unreachable {\n \n /// A standardized placeholder for marking unfinished code.\n ///\n-/// It panics with the message `\"not yet implemented\"` when executed.\n-///\n /// This can be useful if you are prototyping and are just looking to have your\n /// code typecheck, or if you're implementing a trait that requires multiple\n /// methods, and you're only planning on using one of them.\n ///\n /// # Panics\n ///\n-/// This macro always panics.\n+/// This will always [panic!](macro.panic.html)\n ///\n /// # Examples\n ///"}, {"sha": "af2f876a2f35906010bad6e63e94c1d8c4ceeca6", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 73, "deletions": 2, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -22,6 +22,7 @@ use hash;\n use intrinsics;\n use marker::{Copy, PhantomData, Sized};\n use ptr;\n+use ops::{Deref, DerefMut};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use intrinsics::transmute;\n@@ -821,6 +822,7 @@ pub fn discriminant<T>(v: &T) -> Discriminant<T> {\n /// ```\n #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n #[allow(unions_with_drop_fields)]\n+#[derive(Copy)]\n pub union ManuallyDrop<T>{ value: T }\n \n impl<T> ManuallyDrop<T> {\n@@ -870,7 +872,7 @@ impl<T> ManuallyDrop<T> {\n }\n \n #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n-impl<T> ::ops::Deref for ManuallyDrop<T> {\n+impl<T> Deref for ManuallyDrop<T> {\n     type Target = T;\n     #[inline]\n     fn deref(&self) -> &Self::Target {\n@@ -881,7 +883,7 @@ impl<T> ::ops::Deref for ManuallyDrop<T> {\n }\n \n #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n-impl<T> ::ops::DerefMut for ManuallyDrop<T> {\n+impl<T> DerefMut for ManuallyDrop<T> {\n     #[inline]\n     fn deref_mut(&mut self) -> &mut Self::Target {\n         unsafe {\n@@ -899,6 +901,75 @@ impl<T: ::fmt::Debug> ::fmt::Debug for ManuallyDrop<T> {\n     }\n }\n \n+#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+impl<T: Clone> Clone for ManuallyDrop<T> {\n+    fn clone(&self) -> Self {\n+        ManuallyDrop::new(self.deref().clone())\n+    }\n+\n+    fn clone_from(&mut self, source: &Self) {\n+        self.deref_mut().clone_from(source);\n+    }\n+}\n+\n+#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+impl<T: Default> Default for ManuallyDrop<T> {\n+    fn default() -> Self {\n+        ManuallyDrop::new(Default::default())\n+    }\n+}\n+\n+#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+impl<T: PartialEq> PartialEq for ManuallyDrop<T> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.deref().eq(other)\n+    }\n+\n+    fn ne(&self, other: &Self) -> bool {\n+        self.deref().ne(other)\n+    }\n+}\n+\n+#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+impl<T: Eq> Eq for ManuallyDrop<T> {}\n+\n+#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+impl<T: PartialOrd> PartialOrd for ManuallyDrop<T> {\n+    fn partial_cmp(&self, other: &Self) -> Option<::cmp::Ordering> {\n+        self.deref().partial_cmp(other)\n+    }\n+\n+    fn lt(&self, other: &Self) -> bool {\n+        self.deref().lt(other)\n+    }\n+\n+    fn le(&self, other: &Self) -> bool {\n+        self.deref().le(other)\n+    }\n+\n+    fn gt(&self, other: &Self) -> bool {\n+        self.deref().gt(other)\n+    }\n+\n+    fn ge(&self, other: &Self) -> bool {\n+        self.deref().ge(other)\n+    }\n+}\n+\n+#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+impl<T: Ord> Ord for ManuallyDrop<T> {\n+    fn cmp(&self, other: &Self) -> ::cmp::Ordering {\n+        self.deref().cmp(other)\n+    }\n+}\n+\n+#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+impl<T: ::hash::Hash> ::hash::Hash for ManuallyDrop<T> {\n+    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+        self.deref().hash(state);\n+    }\n+}\n+\n /// Tells LLVM that this point in the code is not reachable, enabling further\n /// optimizations.\n ///"}, {"sha": "f93564c2849f5613ca499649793c8b2abdd990d1", "filename": "src/libcore/num/dec2flt/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -121,7 +121,6 @@ macro_rules! from_str_float_impl {\n             /// * '-3.14'\n             /// * '2.5E10', or equivalently, '2.5e10'\n             /// * '2.5E-10'\n-            /// * '.' (understood as 0)\n             /// * '5.'\n             /// * '.5', or, equivalently,  '0.5'\n             /// * 'inf', '-inf', 'NaN'"}, {"sha": "e8ea6044f5ffe9b627a7d7dc5dc12796c15380ea", "filename": "src/libcore/tests/hash/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibcore%2Ftests%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibcore%2Ftests%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fhash%2Fmod.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -109,3 +109,16 @@ fn test_custom_state() {\n \n     assert_eq!(hash(&Custom { hash: 5 }), 5);\n }\n+\n+// FIXME: Instantiated functions with i128 in the signature is not supported in Emscripten.\n+// See https://github.com/kripken/emscripten-fastcomp/issues/169\n+#[cfg(not(target_os = \"emscripten\"))]\n+#[test]\n+fn test_indirect_hasher() {\n+    let mut hasher = MyHasher { hash: 0 };\n+    {\n+        let mut indirect_hasher: &mut Hasher = &mut hasher;\n+        5u32.hash(&mut indirect_hasher);\n+    }\n+    assert_eq!(hasher.hash, 5);\n+}"}, {"sha": "95848f9622deccc9cbadcd5d3a4faef01a90ead4", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -1 +1 @@\n-Subproject commit 04a5e75c99dc92afab490c38fcbbeac9b4bc8104\n+Subproject commit 95848f9622deccc9cbadcd5d3a4faef01a90ead4"}, {"sha": "41e92b33475dacb7d05b09eb9b7d211438a464c1", "filename": "src/libprofiler_builtins/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibprofiler_builtins%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibprofiler_builtins%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibprofiler_builtins%2Fbuild.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -19,7 +19,7 @@ use std::path::Path;\n \n fn main() {\n     let target = env::var(\"TARGET\").expect(\"TARGET was not set\");\n-    let cfg = &mut gcc::Config::new();\n+    let cfg = &mut gcc::Build::new();\n \n     let mut profile_sources = vec![\"GCDAProfiling.c\",\n                                    \"InstrProfiling.c\","}, {"sha": "27561bddd295bdedc62ea43add3fd8165cda2680", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 74, "deletions": 11, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -60,9 +60,9 @@\n //! user of the `DepNode` API of having to know how to compute the expected\n //! fingerprint for a given set of node parameters.\n \n-use hir::def_id::{CrateNum, DefId};\n+use hir::def_id::{CrateNum, DefId, DefIndex};\n use hir::map::DefPathHash;\n-use hir::HirId;\n+use hir::{HirId, ItemLocalId};\n \n use ich::Fingerprint;\n use ty::{TyCtxt, Instance, InstanceDef};\n@@ -511,8 +511,8 @@ define_dep_nodes!( <'tcx>\n     [] ParamEnv(DefId),\n     [] DescribeDef(DefId),\n     [] DefSpan(DefId),\n-    [] Stability(DefId),\n-    [] Deprecation(DefId),\n+    [] LookupStability(DefId),\n+    [] LookupDeprecationEntry(DefId),\n     [] ItemBodyNestedBodies(DefId),\n     [] ConstIsRvaluePromotableToStatic(DefId),\n     [] ImplParent(DefId),\n@@ -521,16 +521,60 @@ define_dep_nodes!( <'tcx>\n     [] IsMirAvailable(DefId),\n     [] ItemAttrs(DefId),\n     [] FnArgNames(DefId),\n-    [] DylibDepFormats(DefId),\n-    [] IsAllocator(DefId),\n-    [] IsPanicRuntime(DefId),\n-    [] IsCompilerBuiltins(DefId),\n-    [] HasGlobalAllocator(DefId),\n+    [] DylibDepFormats(CrateNum),\n+    [] IsPanicRuntime(CrateNum),\n+    [] IsCompilerBuiltins(CrateNum),\n+    [] HasGlobalAllocator(CrateNum),\n     [] ExternCrate(DefId),\n     [] LintLevels,\n     [] Specializes { impl1: DefId, impl2: DefId },\n-    [] InScopeTraits(HirId),\n-    [] ModuleExports(HirId),\n+    [] InScopeTraits(DefIndex),\n+    [] ModuleExports(DefId),\n+    [] IsSanitizerRuntime(CrateNum),\n+    [] IsProfilerRuntime(CrateNum),\n+    [] GetPanicStrategy(CrateNum),\n+    [] IsNoBuiltins(CrateNum),\n+    [] ImplDefaultness(DefId),\n+    [] ExportedSymbols(CrateNum),\n+    [] NativeLibraries(CrateNum),\n+    [] PluginRegistrarFn(CrateNum),\n+    [] DeriveRegistrarFn(CrateNum),\n+    [] CrateDisambiguator(CrateNum),\n+    [] CrateHash(CrateNum),\n+    [] OriginalCrateName(CrateNum),\n+\n+    [] ImplementationsOfTrait { krate: CrateNum, trait_id: DefId },\n+    [] AllTraitImplementations(CrateNum),\n+\n+    [] IsDllimportForeignItem(DefId),\n+    [] IsStaticallyIncludedForeignItem(DefId),\n+    [] NativeLibraryKind(DefId),\n+    [] LinkArgs,\n+\n+    [] NamedRegion(DefIndex),\n+    [] IsLateBound(DefIndex),\n+    [] ObjectLifetimeDefaults(DefIndex),\n+\n+    [] Visibility(DefId),\n+    [] DepKind(CrateNum),\n+    [] CrateName(CrateNum),\n+    [] ItemChildren(DefId),\n+    [] ExternModStmtCnum(DefId),\n+    [] GetLangItems,\n+    [] DefinedLangItems(CrateNum),\n+    [] MissingLangItems(CrateNum),\n+    [] ExternConstBody(DefId),\n+    [] VisibleParentMap,\n+    [] IsDirectExternCrate(CrateNum),\n+    [] MissingExternCrateItem(CrateNum),\n+    [] UsedCrateSource(CrateNum),\n+    [] PostorderCnums,\n+\n+    [] Freevars(DefId),\n+    [] MaybeUnusedTraitImport(DefId),\n+    [] MaybeUnusedExternCrates,\n+    [] StabilityIndex,\n+    [] AllCrateNums,\n );\n \n trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {\n@@ -638,6 +682,25 @@ impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefIdList\n     }\n }\n \n+impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (HirId,) {\n+    const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n+\n+    // We actually would not need to specialize the implementation of this\n+    // method but it's faster to combine the hashes than to instantiate a full\n+    // hashing context and stable-hashing state.\n+    fn to_fingerprint(&self, tcx: TyCtxt) -> Fingerprint {\n+        let (HirId {\n+            owner,\n+            local_id: ItemLocalId(local_id),\n+        },) = *self;\n+\n+        let def_path_hash = tcx.def_path_hash(DefId::local(owner));\n+        let local_id = Fingerprint::from_smaller_hash(local_id as u64);\n+\n+        def_path_hash.0.combine(local_id)\n+    }\n+}\n+\n /// A \"work product\" corresponds to a `.o` (or other) file that we\n /// save in between runs. These ids do not have a DefId but rather\n /// some independent path or string that persists between runs without"}, {"sha": "34cb1d2a6d7957278c8b02f3c9cffec7130a71ad", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -235,10 +235,13 @@ impl DepGraph {\n                                           debug_str_gen: F)\n         where F: FnOnce() -> String\n     {\n-        let mut dep_node_debug = self.data.as_ref().unwrap().dep_node_debug.borrow_mut();\n+        let dep_node_debug = &self.data.as_ref().unwrap().dep_node_debug;\n \n-        dep_node_debug.entry(dep_node)\n-                      .or_insert_with(debug_str_gen);\n+        if dep_node_debug.borrow().contains_key(&dep_node) {\n+            return\n+        }\n+        let debug_str = debug_str_gen();\n+        dep_node_debug.borrow_mut().insert(dep_node, debug_str);\n     }\n \n     pub(super) fn dep_node_debug_str(&self, dep_node: DepNode) -> Option<String> {"}, {"sha": "4d21e5e0f4708ddff31e0b9567a38481b025435a", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 48, "deletions": 12, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -1389,30 +1389,66 @@ A lifetime of reference outlives lifetime of borrowed content.\n Erroneous code example:\n \n ```compile_fail,E0312\n-fn make_child<'human, 'elve>(x: &mut &'human isize, y: &mut &'elve isize) {\n-    *x = *y;\n-    // error: lifetime of reference outlives lifetime of borrowed content\n+fn make_child<'tree, 'human>(\n+  x: &'human i32,\n+  y: &'tree i32\n+) -> &'human i32 {\n+    if x > y\n+       { x }\n+    else\n+       { y }\n+       // error: lifetime of reference outlives lifetime of borrowed content\n }\n ```\n \n-The compiler cannot determine if the `human` lifetime will live long enough\n-to keep up on the elve one. To solve this error, you have to give an\n-explicit lifetime hierarchy:\n+The function declares that it returns a reference with the `'human`\n+lifetime, but it may return data with the `'tree` lifetime. As neither\n+lifetime is declared longer than the other, this results in an\n+error. Sometimes, this error is because the function *body* is\n+incorrect -- that is, maybe you did not *mean* to return data from\n+`y`. In that case, you should fix the function body.\n+\n+Often, however, the body is correct. In that case, the function\n+signature needs to be altered to match the body, so that the caller\n+understands that data from either `x` or `y` may be returned. The\n+simplest way to do this is to give both function parameters the *same*\n+named lifetime:\n \n ```\n-fn make_child<'human, 'elve: 'human>(x: &mut &'human isize,\n-                                     y: &mut &'elve isize) {\n-    *x = *y; // ok!\n+fn make_child<'human>(\n+  x: &'human i32,\n+  y: &'human i32\n+) -> &'human i32 {\n+    if x > y\n+       { x }\n+    else\n+       { y } // ok!\n }\n ```\n \n-Or use the same lifetime for every variable:\n+However, in some cases, you may prefer to explicitly declare that one lifetime\n+outlives another using a `where` clause:\n \n ```\n-fn make_child<'elve>(x: &mut &'elve isize, y: &mut &'elve isize) {\n-    *x = *y; // ok!\n+fn make_child<'tree, 'human>(\n+  x: &'human i32,\n+  y: &'tree i32\n+) -> &'human i32\n+where\n+  'tree: 'human\n+{\n+    if x > y\n+       { x }\n+    else\n+       { y } // ok!\n }\n ```\n+\n+Here, the where clause `'tree: 'human` can be read as \"the lifetime\n+'tree outlives the lifetime 'human\" -- meaning, references with the\n+`'tree` lifetime live *at least as long as* references with the\n+`'human` lifetime. Therefore, it is safe to return data with lifetime\n+`'tree` when data with the lifetime `'human` is needed.\n \"##,\n \n E0317: r##\""}, {"sha": "4e0c6479abf141c1e3fff1dfc8e3648389be1622", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use hir::def_id::DefId;\n-use util::nodemap::NodeMap;\n+use util::nodemap::{NodeMap, DefIdMap};\n use syntax::ast;\n use syntax::ext::base::MacroKind;\n use syntax_pos::Span;\n@@ -48,8 +48,9 @@ pub enum Def {\n     VariantCtor(DefId, CtorKind),\n     Method(DefId),\n     AssociatedConst(DefId),\n-    Local(DefId),\n-    Upvar(DefId,        // def id of closed over local\n+\n+    Local(ast::NodeId),\n+    Upvar(ast::NodeId,  // node id of closed over local\n           usize,        // index in the freevars list of the closure\n           ast::NodeId), // expr node that creates the closure\n     Label(ast::NodeId),\n@@ -114,7 +115,7 @@ pub type DefMap = NodeMap<PathResolution>;\n \n /// This is the replacement export map. It maps a module to all of the exports\n /// within.\n-pub type ExportMap = NodeMap<Vec<Export>>;\n+pub type ExportMap = DefIdMap<Vec<Export>>;\n \n #[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct Export {\n@@ -150,11 +151,13 @@ impl Def {\n             Def::Variant(id) | Def::VariantCtor(id, ..) | Def::Enum(id) | Def::TyAlias(id) |\n             Def::AssociatedTy(id) | Def::TyParam(id) | Def::Struct(id) | Def::StructCtor(id, ..) |\n             Def::Union(id) | Def::Trait(id) | Def::Method(id) | Def::Const(id) |\n-            Def::AssociatedConst(id) | Def::Local(id) | Def::Upvar(id, ..) | Def::Macro(id, ..) |\n+            Def::AssociatedConst(id) | Def::Macro(id, ..) |\n             Def::GlobalAsm(id) => {\n                 id\n             }\n \n+            Def::Local(..) |\n+            Def::Upvar(..) |\n             Def::Label(..)  |\n             Def::PrimTy(..) |\n             Def::SelfTy(..) |"}, {"sha": "78daff9f67aa5dde75bc1ba8e590a89b113d4cc3", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -93,10 +93,19 @@ impl serialize::UseSpecializedDecodable for CrateNum {\n ///\n /// Since the DefIndex is mostly treated as an opaque ID, you probably\n /// don't have to care about these ranges.\n-#[derive(Clone, Debug, Eq, Ord, PartialOrd, PartialEq, RustcEncodable,\n+#[derive(Clone, Eq, Ord, PartialOrd, PartialEq, RustcEncodable,\n            RustcDecodable, Hash, Copy)]\n pub struct DefIndex(u32);\n \n+impl fmt::Debug for DefIndex {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f,\n+               \"DefIndex({}:{})\",\n+               self.address_space().index(),\n+               self.as_array_index())\n+    }\n+}\n+\n impl DefIndex {\n     #[inline]\n     pub fn new(x: usize) -> DefIndex {"}, {"sha": "216a6d025e3b0d579b6dcccb15a52bbc87f46101", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -653,8 +653,8 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n         PatKind::Ref(ref subpattern, _) => {\n             visitor.visit_pat(subpattern)\n         }\n-        PatKind::Binding(_, def_id, ref pth1, ref optional_subpattern) => {\n-            visitor.visit_def_mention(Def::Local(def_id));\n+        PatKind::Binding(_, canonical_id, ref pth1, ref optional_subpattern) => {\n+            visitor.visit_def_mention(Def::Local(canonical_id));\n             visitor.visit_name(pth1.span, pth1.node);\n             walk_list!(visitor, visit_pat, optional_subpattern);\n         }"}, {"sha": "bae419da26c58839e44bf087cf222ba563806c6f", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 31, "deletions": 44, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -41,11 +41,11 @@\n //! in the HIR, especially for multiple identifiers.\n \n use hir;\n-use hir::map::{Definitions, DefKey, REGULAR_SPACE};\n-use hir::map::definitions::DefPathData;\n+use hir::map::{Definitions, DefKey};\n use hir::def_id::{DefIndex, DefId, CRATE_DEF_INDEX};\n use hir::def::{Def, PathResolution};\n use lint::builtin::PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES;\n+use middle::cstore::CrateStore;\n use rustc_data_structures::indexed_vec::IndexVec;\n use session::Session;\n use util::common::FN_OUTPUT_NAME;\n@@ -75,6 +75,8 @@ pub struct LoweringContext<'a> {\n     // Use to assign ids to hir nodes that do not directly correspond to an ast node\n     sess: &'a Session,\n \n+    cstore: &'a CrateStore,\n+\n     // As we walk the AST we must keep track of the current 'parent' def id (in\n     // the form of a DefIndex) so that if we create a new node which introduces\n     // a definition, then we can properly create the def id.\n@@ -119,6 +121,7 @@ pub trait Resolver {\n }\n \n pub fn lower_crate(sess: &Session,\n+                   cstore: &CrateStore,\n                    krate: &Crate,\n                    resolver: &mut Resolver)\n                    -> hir::Crate {\n@@ -130,6 +133,7 @@ pub fn lower_crate(sess: &Session,\n     LoweringContext {\n         crate_root: std_inject::injected_crate_name(krate),\n         sess,\n+        cstore,\n         parent_def: None,\n         resolver,\n         name_map: FxHashMap(),\n@@ -535,7 +539,7 @@ impl<'a> LoweringContext<'a> {\n         if id.is_local() {\n             self.resolver.definitions().def_key(id.index)\n         } else {\n-            self.sess.cstore.def_key(id)\n+            self.cstore.def_key(id)\n         }\n     }\n \n@@ -787,7 +791,7 @@ impl<'a> LoweringContext<'a> {\n                         return n;\n                     }\n                     assert!(!def_id.is_local());\n-                    let n = self.sess.cstore.item_generics_cloned(def_id).regions.len();\n+                    let n = self.cstore.item_generics_cloned_untracked(def_id).regions.len();\n                     self.type_def_lifetime_params.insert(def_id, n);\n                     n\n                 });\n@@ -1738,29 +1742,28 @@ impl<'a> LoweringContext<'a> {\n             node: match p.node {\n                 PatKind::Wild => hir::PatKind::Wild,\n                 PatKind::Ident(ref binding_mode, pth1, ref sub) => {\n-                    self.with_parent_def(p.id, |this| {\n-                        match this.resolver.get_resolution(p.id).map(|d| d.base_def()) {\n-                            // `None` can occur in body-less function signatures\n-                            def @ None | def @ Some(Def::Local(_)) => {\n-                                let def_id = def.map(|d| d.def_id()).unwrap_or_else(|| {\n-                                    this.resolver.definitions().local_def_id(p.id)\n-                                });\n-                                hir::PatKind::Binding(this.lower_binding_mode(binding_mode),\n-                                                      def_id,\n-                                                      respan(pth1.span, pth1.node.name),\n-                                                      sub.as_ref().map(|x| this.lower_pat(x)))\n-                            }\n-                            Some(def) => {\n-                                hir::PatKind::Path(hir::QPath::Resolved(None, P(hir::Path {\n-                                    span: pth1.span,\n-                                    def,\n-                                    segments: hir_vec![\n-                                        hir::PathSegment::from_name(pth1.node.name)\n-                                    ],\n-                                })))\n-                            }\n+                    match self.resolver.get_resolution(p.id).map(|d| d.base_def()) {\n+                        // `None` can occur in body-less function signatures\n+                        def @ None | def @ Some(Def::Local(_)) => {\n+                            let canonical_id = match def {\n+                                Some(Def::Local(id)) => id,\n+                                _ => p.id\n+                            };\n+                            hir::PatKind::Binding(self.lower_binding_mode(binding_mode),\n+                                                  canonical_id,\n+                                                  respan(pth1.span, pth1.node.name),\n+                                                  sub.as_ref().map(|x| self.lower_pat(x)))\n                         }\n-                    })\n+                        Some(def) => {\n+                            hir::PatKind::Path(hir::QPath::Resolved(None, P(hir::Path {\n+                                span: pth1.span,\n+                                def,\n+                                segments: hir_vec![\n+                                    hir::PathSegment::from_name(pth1.node.name)\n+                                ],\n+                            })))\n+                        }\n+                    }\n                 }\n                 PatKind::Lit(ref e) => hir::PatKind::Lit(P(self.lower_expr(e))),\n                 PatKind::TupleStruct(ref path, ref pats, ddpos) => {\n@@ -2715,14 +2718,9 @@ impl<'a> LoweringContext<'a> {\n                                         id: Name,\n                                         binding: NodeId,\n                                         attrs: ThinVec<Attribute>) -> hir::Expr {\n-        let def = {\n-            let defs = self.resolver.definitions();\n-            Def::Local(defs.local_def_id(binding))\n-        };\n-\n         let expr_path = hir::ExprPath(hir::QPath::Resolved(None, P(hir::Path {\n             span,\n-            def,\n+            def: Def::Local(binding),\n             segments: hir_vec![hir::PathSegment::from_name(id)],\n         })));\n \n@@ -2860,23 +2858,12 @@ impl<'a> LoweringContext<'a> {\n     fn pat_ident_binding_mode(&mut self, span: Span, name: Name, bm: hir::BindingAnnotation)\n                               -> P<hir::Pat> {\n         let LoweredNodeId { node_id, hir_id } = self.next_id();\n-        let parent_def = self.parent_def.unwrap();\n-        let def_id = {\n-            let defs = self.resolver.definitions();\n-            let def_path_data = DefPathData::Binding(name);\n-            let def_index = defs.create_def_with_parent(parent_def,\n-                                                        node_id,\n-                                                        def_path_data,\n-                                                        REGULAR_SPACE,\n-                                                        Mark::root());\n-            DefId::local(def_index)\n-        };\n \n         P(hir::Pat {\n             id: node_id,\n             hir_id,\n             node: hir::PatKind::Binding(bm,\n-                                        def_id,\n+                                        node_id,\n                                         Spanned {\n                                             span,\n                                             node: name,"}, {"sha": "673e6d3bbfbae6b439cba2026ea59a54d92b4bf2", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -104,14 +104,14 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                 DefPathData::Impl,\n             ItemKind::Enum(..) | ItemKind::Struct(..) | ItemKind::Union(..) | ItemKind::Trait(..) |\n             ItemKind::ExternCrate(..) | ItemKind::ForeignMod(..) | ItemKind::Ty(..) =>\n-                DefPathData::TypeNs(i.ident.name),\n+                DefPathData::TypeNs(i.ident.name.as_str()),\n             ItemKind::Mod(..) if i.ident == keywords::Invalid.ident() => {\n                 return visit::walk_item(self, i);\n             }\n-            ItemKind::Mod(..) => DefPathData::Module(i.ident.name),\n+            ItemKind::Mod(..) => DefPathData::Module(i.ident.name.as_str()),\n             ItemKind::Static(..) | ItemKind::Const(..) | ItemKind::Fn(..) =>\n-                DefPathData::ValueNs(i.ident.name),\n-            ItemKind::MacroDef(..) => DefPathData::MacroDef(i.ident.name),\n+                DefPathData::ValueNs(i.ident.name.as_str()),\n+            ItemKind::MacroDef(..) => DefPathData::MacroDef(i.ident.name.as_str()),\n             ItemKind::Mac(..) => return self.visit_macro_invoc(i.id, false),\n             ItemKind::GlobalAsm(..) => DefPathData::Misc,\n             ItemKind::Use(ref view_path) => {\n@@ -139,13 +139,15 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                     for v in &enum_definition.variants {\n                         let variant_def_index =\n                             this.create_def(v.node.data.id(),\n-                                            DefPathData::EnumVariant(v.node.name.name),\n+                                            DefPathData::EnumVariant(v.node.name.name.as_str()),\n                                             REGULAR_SPACE);\n                         this.with_parent(variant_def_index, |this| {\n                             for (index, field) in v.node.data.fields().iter().enumerate() {\n                                 let name = field.ident.map(|ident| ident.name)\n                                     .unwrap_or_else(|| Symbol::intern(&index.to_string()));\n-                                this.create_def(field.id, DefPathData::Field(name), REGULAR_SPACE);\n+                                this.create_def(field.id,\n+                                                DefPathData::Field(name.as_str()),\n+                                                REGULAR_SPACE);\n                             }\n \n                             if let Some(ref expr) = v.node.disr_expr {\n@@ -165,7 +167,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                     for (index, field) in struct_def.fields().iter().enumerate() {\n                         let name = field.ident.map(|ident| ident.name)\n                             .unwrap_or_else(|| Symbol::intern(&index.to_string()));\n-                        this.create_def(field.id, DefPathData::Field(name), REGULAR_SPACE);\n+                        this.create_def(field.id, DefPathData::Field(name.as_str()), REGULAR_SPACE);\n                     }\n                 }\n                 _ => {}\n@@ -176,7 +178,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n     fn visit_foreign_item(&mut self, foreign_item: &'a ForeignItem) {\n         let def = self.create_def(foreign_item.id,\n-                                  DefPathData::ValueNs(foreign_item.ident.name),\n+                                  DefPathData::ValueNs(foreign_item.ident.name.as_str()),\n                                   REGULAR_SPACE);\n \n         self.with_parent(def, |this| {\n@@ -187,7 +189,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     fn visit_generics(&mut self, generics: &'a Generics) {\n         for ty_param in generics.ty_params.iter() {\n             self.create_def(ty_param.id,\n-                            DefPathData::TypeParam(ty_param.ident.name),\n+                            DefPathData::TypeParam(ty_param.ident.name.as_str()),\n                             REGULAR_SPACE);\n         }\n \n@@ -197,8 +199,8 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     fn visit_trait_item(&mut self, ti: &'a TraitItem) {\n         let def_data = match ti.node {\n             TraitItemKind::Method(..) | TraitItemKind::Const(..) =>\n-                DefPathData::ValueNs(ti.ident.name),\n-            TraitItemKind::Type(..) => DefPathData::TypeNs(ti.ident.name),\n+                DefPathData::ValueNs(ti.ident.name.as_str()),\n+            TraitItemKind::Type(..) => DefPathData::TypeNs(ti.ident.name.as_str()),\n             TraitItemKind::Macro(..) => return self.visit_macro_invoc(ti.id, false),\n         };\n \n@@ -215,8 +217,8 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n         let def_data = match ii.node {\n             ImplItemKind::Method(..) | ImplItemKind::Const(..) =>\n-                DefPathData::ValueNs(ii.ident.name),\n-            ImplItemKind::Type(..) => DefPathData::TypeNs(ii.ident.name),\n+                DefPathData::ValueNs(ii.ident.name.as_str()),\n+            ImplItemKind::Type(..) => DefPathData::TypeNs(ii.ident.name.as_str()),\n             ImplItemKind::Macro(..) => return self.visit_macro_invoc(ii.id, false),\n         };\n \n@@ -231,21 +233,10 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     }\n \n     fn visit_pat(&mut self, pat: &'a Pat) {\n-        let parent_def = self.parent_def;\n-\n         match pat.node {\n             PatKind::Mac(..) => return self.visit_macro_invoc(pat.id, false),\n-            PatKind::Ident(_, id, _) => {\n-                let def = self.create_def(pat.id,\n-                                          DefPathData::Binding(id.node.name),\n-                                          REGULAR_SPACE);\n-                self.parent_def = Some(def);\n-            }\n-            _ => {}\n+            _ => visit::walk_pat(self, pat),\n         }\n-\n-        visit::walk_pat(self, pat);\n-        self.parent_def = parent_def;\n     }\n \n     fn visit_expr(&mut self, expr: &'a Expr) {\n@@ -282,7 +273,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n     fn visit_lifetime_def(&mut self, def: &'a LifetimeDef) {\n         self.create_def(def.lifetime.id,\n-                        DefPathData::LifetimeDef(def.lifetime.ident.name),\n+                        DefPathData::LifetimeDef(def.lifetime.ident.name.as_str()),\n                         REGULAR_SPACE);\n     }\n "}, {"sha": "bd80b613e77f5d7c851883c22ebcdbab167aa168", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -80,8 +80,10 @@ impl DefPathTable {\n \n     #[inline(always)]\n     pub fn def_path_hash(&self, index: DefIndex) -> DefPathHash {\n-        self.def_path_hashes[index.address_space().index()]\n-                            [index.as_array_index()]\n+        let ret = self.def_path_hashes[index.address_space().index()]\n+                                      [index.as_array_index()];\n+        debug!(\"def_path_hash({:?}) = {:?}\", index, ret);\n+        return ret\n     }\n \n     pub fn add_def_path_hashes_to(&self,\n@@ -210,10 +212,9 @@ impl DefKey {\n             DefPathData::TypeParam(name) |\n             DefPathData::LifetimeDef(name) |\n             DefPathData::EnumVariant(name) |\n-            DefPathData::Binding(name) |\n             DefPathData::Field(name) |\n             DefPathData::GlobalMetaData(name) => {\n-                (*name.as_str()).hash(&mut hasher);\n+                name.hash(&mut hasher);\n             }\n \n             DefPathData::Impl |\n@@ -347,31 +348,29 @@ pub enum DefPathData {\n     /// An impl\n     Impl,\n     /// Something in the type NS\n-    TypeNs(Symbol),\n+    TypeNs(InternedString),\n     /// Something in the value NS\n-    ValueNs(Symbol),\n+    ValueNs(InternedString),\n     /// A module declaration\n-    Module(Symbol),\n+    Module(InternedString),\n     /// A macro rule\n-    MacroDef(Symbol),\n+    MacroDef(InternedString),\n     /// A closure expression\n     ClosureExpr,\n \n     // Subportions of items\n     /// A type parameter (generic parameter)\n-    TypeParam(Symbol),\n+    TypeParam(InternedString),\n     /// A lifetime definition\n-    LifetimeDef(Symbol),\n+    LifetimeDef(InternedString),\n     /// A variant of a enum\n-    EnumVariant(Symbol),\n+    EnumVariant(InternedString),\n     /// A struct field\n-    Field(Symbol),\n+    Field(InternedString),\n     /// Implicit ctor for a tuple-like struct\n     StructCtor,\n     /// Initializer for a const\n     Initializer,\n-    /// Pattern binding\n-    Binding(Symbol),\n     /// An `impl Trait` type node.\n     ImplTrait,\n     /// A `typeof` type node.\n@@ -380,7 +379,7 @@ pub enum DefPathData {\n     /// GlobalMetaData identifies a piece of crate metadata that is global to\n     /// a whole crate (as opposed to just one item). GlobalMetaData components\n     /// are only supposed to show up right below the crate root.\n-    GlobalMetaData(Symbol)\n+    GlobalMetaData(InternedString)\n }\n \n #[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug,\n@@ -601,7 +600,7 @@ impl Definitions {\n }\n \n impl DefPathData {\n-    pub fn get_opt_name(&self) -> Option<Symbol> {\n+    pub fn get_opt_name(&self) -> Option<InternedString> {\n         use self::DefPathData::*;\n         match *self {\n             TypeNs(name) |\n@@ -611,7 +610,6 @@ impl DefPathData {\n             TypeParam(name) |\n             LifetimeDef(name) |\n             EnumVariant(name) |\n-            Binding(name) |\n             Field(name) |\n             GlobalMetaData(name) => Some(name),\n \n@@ -636,10 +634,9 @@ impl DefPathData {\n             TypeParam(name) |\n             LifetimeDef(name) |\n             EnumVariant(name) |\n-            Binding(name) |\n             Field(name) |\n             GlobalMetaData(name) => {\n-                return name.as_str();\n+                return name\n             }\n \n             // note that this does not show up in user printouts\n@@ -684,7 +681,7 @@ macro_rules! define_global_metadata_kind {\n                     definitions.create_def_with_parent(\n                         CRATE_DEF_INDEX,\n                         ast::DUMMY_NODE_ID,\n-                        DefPathData::GlobalMetaData(instance.name()),\n+                        DefPathData::GlobalMetaData(instance.name().as_str()),\n                         GLOBAL_MD_ADDRESS_SPACE,\n                         Mark::root()\n                     );\n@@ -698,7 +695,7 @@ macro_rules! define_global_metadata_kind {\n                 let def_key = DefKey {\n                     parent: Some(CRATE_DEF_INDEX),\n                     disambiguated_data: DisambiguatedDefPathData {\n-                        data: DefPathData::GlobalMetaData(self.name()),\n+                        data: DefPathData::GlobalMetaData(self.name().as_str()),\n                         disambiguator: 0,\n                     }\n                 };"}, {"sha": "d043d8346e6a850a781a3849b160c74f79a17a62", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -878,7 +878,17 @@ impl<'hir> Map<'hir> {\n \n             Some(RootCrate(_)) => self.forest.krate.span,\n             Some(NotPresent) | None => {\n-                bug!(\"hir::map::Map::span: id not in map: {:?}\", id)\n+                // Some nodes, notably macro definitions, are not\n+                // present in the map for whatever reason, but\n+                // they *do* have def-ids. So if we encounter an\n+                // empty hole, check for that case.\n+                if let Some(def_index) = self.definitions.opt_def_index(id) {\n+                    let def_path_hash = self.definitions.def_path_hash(def_index);\n+                    self.dep_graph.read(def_path_hash.to_dep_node(DepKind::Hir));\n+                    DUMMY_SP\n+                } else {\n+                    bug!(\"hir::map::Map::span: id not in map: {:?}\", id)\n+                }\n             }\n         }\n     }"}, {"sha": "dd2a3978d884405a18972f8dc6d1e4cc494251cc", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -611,7 +611,7 @@ pub enum BindingAnnotation {\n   RefMut,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum RangeEnd {\n     Included,\n     Excluded,\n@@ -623,8 +623,10 @@ pub enum PatKind {\n     Wild,\n \n     /// A fresh binding `ref mut binding @ OPT_SUBPATTERN`.\n-    /// The `DefId` is for the definition of the variable being bound.\n-    Binding(BindingAnnotation, DefId, Spanned<Name>, Option<P<Pat>>),\n+    /// The `NodeId` is the canonical ID for the variable being bound,\n+    /// e.g. in `Ok(x) | Err(x)`, both `x` use the same canonical ID,\n+    /// which is the pattern ID of the first `x`.\n+    Binding(BindingAnnotation, NodeId, Spanned<Name>, Option<P<Pat>>),\n \n     /// A struct or struct variant pattern, e.g. `Variant {x, y, ..}`.\n     /// The `bool` is `true` in the presence of a `..`.\n@@ -1843,6 +1845,15 @@ pub struct Freevar {\n     pub span: Span\n }\n \n+impl Freevar {\n+    pub fn var_id(&self) -> NodeId {\n+        match self.def {\n+            Def::Local(id) | Def::Upvar(id, ..) => id,\n+            _ => bug!(\"Freevar::var_id: bad def ({:?})\", self.def)\n+        }\n+    }\n+}\n+\n pub type FreevarMap = NodeMap<Vec<Freevar>>;\n \n pub type CaptureModeMap = NodeMap<CaptureClause>;"}, {"sha": "a06ea0af2a9e65cce8da09ec2f5b808c0bb724df", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 179, "deletions": 38, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -20,6 +20,7 @@ use syntax::print::pp::Breaks::{Consistent, Inconsistent};\n use syntax::print::pprust::PrintState;\n use syntax::ptr::P;\n use syntax::symbol::keywords;\n+use syntax::util::parser::{self, AssocOp, Fixity};\n use syntax_pos::{self, BytePos};\n \n use hir;\n@@ -210,18 +211,6 @@ pub fn visibility_qualified(vis: &hir::Visibility, w: &str) -> String {\n     })\n }\n \n-fn needs_parentheses(expr: &hir::Expr) -> bool {\n-    match expr.node {\n-        hir::ExprAssign(..) |\n-        hir::ExprBinary(..) |\n-        hir::ExprClosure(..) |\n-        hir::ExprAssignOp(..) |\n-        hir::ExprCast(..) |\n-        hir::ExprType(..) => true,\n-        _ => false,\n-    }\n-}\n-\n impl<'a> State<'a> {\n     pub fn cbox(&mut self, u: usize) -> io::Result<()> {\n         self.boxes.push(pp::Breaks::Consistent);\n@@ -1047,7 +1036,7 @@ impl<'a> State<'a> {\n                         self.cbox(indent_unit - 1)?;\n                         self.ibox(0)?;\n                         self.s.word(\" else if \")?;\n-                        self.print_expr(&i)?;\n+                        self.print_expr_as_cond(&i)?;\n                         self.s.space()?;\n                         self.print_expr(&then)?;\n                         self.print_else(e.as_ref().map(|e| &**e))\n@@ -1075,7 +1064,7 @@ impl<'a> State<'a> {\n                     elseopt: Option<&hir::Expr>)\n                     -> io::Result<()> {\n         self.head(\"if\")?;\n-        self.print_expr(test)?;\n+        self.print_expr_as_cond(test)?;\n         self.s.space()?;\n         self.print_expr(blk)?;\n         self.print_else(elseopt)\n@@ -1091,7 +1080,7 @@ impl<'a> State<'a> {\n         self.print_pat(pat)?;\n         self.s.space()?;\n         self.word_space(\"=\")?;\n-        self.print_expr(expr)?;\n+        self.print_expr_as_cond(expr)?;\n         self.s.space()?;\n         self.print_block(blk)?;\n         self.print_else(elseopt)\n@@ -1104,8 +1093,31 @@ impl<'a> State<'a> {\n         self.pclose()\n     }\n \n-    pub fn print_expr_maybe_paren(&mut self, expr: &hir::Expr) -> io::Result<()> {\n-        let needs_par = needs_parentheses(expr);\n+    pub fn print_expr_maybe_paren(&mut self, expr: &hir::Expr, prec: i8) -> io::Result<()> {\n+        let needs_par = expr_precedence(expr) < prec;\n+        if needs_par {\n+            self.popen()?;\n+        }\n+        self.print_expr(expr)?;\n+        if needs_par {\n+            self.pclose()?;\n+        }\n+        Ok(())\n+    }\n+\n+    /// Print an expr using syntax that's acceptable in a condition position, such as the `cond` in\n+    /// `if cond { ... }`.\n+    pub fn print_expr_as_cond(&mut self, expr: &hir::Expr) -> io::Result<()> {\n+        let needs_par = match expr.node {\n+            // These cases need parens due to the parse error observed in #26461: `if return {}`\n+            // parses as the erroneous construct `if (return {})`, not `if (return) {}`.\n+            hir::ExprClosure(..) |\n+            hir::ExprRet(..) |\n+            hir::ExprBreak(..) => true,\n+\n+            _ => contains_exterior_struct_lit(expr),\n+        };\n+\n         if needs_par {\n             self.popen()?;\n         }\n@@ -1182,7 +1194,14 @@ impl<'a> State<'a> {\n     }\n \n     fn print_expr_call(&mut self, func: &hir::Expr, args: &[hir::Expr]) -> io::Result<()> {\n-        self.print_expr_maybe_paren(func)?;\n+        let prec =\n+            match func.node {\n+                hir::ExprField(..) |\n+                hir::ExprTupField(..) => parser::PREC_FORCE_PAREN,\n+                _ => parser::PREC_POSTFIX,\n+            };\n+\n+        self.print_expr_maybe_paren(func, prec)?;\n         self.print_call_post(args)\n     }\n \n@@ -1191,7 +1210,7 @@ impl<'a> State<'a> {\n                               args: &[hir::Expr])\n                               -> io::Result<()> {\n         let base_args = &args[1..];\n-        self.print_expr(&args[0])?;\n+        self.print_expr_maybe_paren(&args[0], parser::PREC_POSTFIX)?;\n         self.s.word(\".\")?;\n         self.print_name(segment.name)?;\n         if !segment.parameters.lifetimes.is_empty() ||\n@@ -1207,15 +1226,25 @@ impl<'a> State<'a> {\n                          lhs: &hir::Expr,\n                          rhs: &hir::Expr)\n                          -> io::Result<()> {\n-        self.print_expr(lhs)?;\n+        let assoc_op = bin_op_to_assoc_op(op.node);\n+        let prec = assoc_op.precedence() as i8;\n+        let fixity = assoc_op.fixity();\n+\n+        let (left_prec, right_prec) = match fixity {\n+            Fixity::Left => (prec, prec + 1),\n+            Fixity::Right => (prec + 1, prec),\n+            Fixity::None => (prec + 1, prec + 1),\n+        };\n+\n+        self.print_expr_maybe_paren(lhs, left_prec)?;\n         self.s.space()?;\n         self.word_space(op.node.as_str())?;\n-        self.print_expr(rhs)\n+        self.print_expr_maybe_paren(rhs, right_prec)\n     }\n \n     fn print_expr_unary(&mut self, op: hir::UnOp, expr: &hir::Expr) -> io::Result<()> {\n         self.s.word(op.as_str())?;\n-        self.print_expr_maybe_paren(expr)\n+        self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n     }\n \n     fn print_expr_addr_of(&mut self,\n@@ -1224,7 +1253,7 @@ impl<'a> State<'a> {\n                           -> io::Result<()> {\n         self.s.word(\"&\")?;\n         self.print_mutability(mutability)?;\n-        self.print_expr_maybe_paren(expr)\n+        self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n     }\n \n     pub fn print_expr(&mut self, expr: &hir::Expr) -> io::Result<()> {\n@@ -1235,7 +1264,7 @@ impl<'a> State<'a> {\n         match expr.node {\n             hir::ExprBox(ref expr) => {\n                 self.word_space(\"box\")?;\n-                self.print_expr(expr)?;\n+                self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)?;\n             }\n             hir::ExprArray(ref exprs) => {\n                 self.print_expr_vec(exprs)?;\n@@ -1268,13 +1297,15 @@ impl<'a> State<'a> {\n                 self.print_literal(&lit)?;\n             }\n             hir::ExprCast(ref expr, ref ty) => {\n-                self.print_expr(&expr)?;\n+                let prec = AssocOp::As.precedence() as i8;\n+                self.print_expr_maybe_paren(&expr, prec)?;\n                 self.s.space()?;\n                 self.word_space(\"as\")?;\n                 self.print_type(&ty)?;\n             }\n             hir::ExprType(ref expr, ref ty) => {\n-                self.print_expr(&expr)?;\n+                let prec = AssocOp::Colon.precedence() as i8;\n+                self.print_expr_maybe_paren(&expr, prec)?;\n                 self.word_space(\":\")?;\n                 self.print_type(&ty)?;\n             }\n@@ -1287,7 +1318,7 @@ impl<'a> State<'a> {\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"while\")?;\n-                self.print_expr(&test)?;\n+                self.print_expr_as_cond(&test)?;\n                 self.s.space()?;\n                 self.print_block(&blk)?;\n             }\n@@ -1304,7 +1335,7 @@ impl<'a> State<'a> {\n                 self.cbox(indent_unit)?;\n                 self.ibox(4)?;\n                 self.word_nbsp(\"match\")?;\n-                self.print_expr(&expr)?;\n+                self.print_expr_as_cond(&expr)?;\n                 self.s.space()?;\n                 self.bopen()?;\n                 for arm in arms {\n@@ -1335,30 +1366,32 @@ impl<'a> State<'a> {\n                 self.print_block(&blk)?;\n             }\n             hir::ExprAssign(ref lhs, ref rhs) => {\n-                self.print_expr(&lhs)?;\n+                let prec = AssocOp::Assign.precedence() as i8;\n+                self.print_expr_maybe_paren(&lhs, prec + 1)?;\n                 self.s.space()?;\n                 self.word_space(\"=\")?;\n-                self.print_expr(&rhs)?;\n+                self.print_expr_maybe_paren(&rhs, prec)?;\n             }\n             hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n-                self.print_expr(&lhs)?;\n+                let prec = AssocOp::Assign.precedence() as i8;\n+                self.print_expr_maybe_paren(&lhs, prec + 1)?;\n                 self.s.space()?;\n                 self.s.word(op.node.as_str())?;\n                 self.word_space(\"=\")?;\n-                self.print_expr(&rhs)?;\n+                self.print_expr_maybe_paren(&rhs, prec)?;\n             }\n             hir::ExprField(ref expr, name) => {\n-                self.print_expr(&expr)?;\n+                self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX)?;\n                 self.s.word(\".\")?;\n                 self.print_name(name.node)?;\n             }\n             hir::ExprTupField(ref expr, id) => {\n-                self.print_expr(&expr)?;\n+                self.print_expr_maybe_paren(&expr, parser::PREC_POSTFIX)?;\n                 self.s.word(\".\")?;\n                 self.print_usize(id.node)?;\n             }\n             hir::ExprIndex(ref expr, ref index) => {\n-                self.print_expr(&expr)?;\n+                self.print_expr_maybe_paren(&expr, parser::PREC_POSTFIX)?;\n                 self.s.word(\"[\")?;\n                 self.print_expr(&index)?;\n                 self.s.word(\"]\")?;\n@@ -1374,7 +1407,7 @@ impl<'a> State<'a> {\n                     self.s.space()?;\n                 }\n                 if let Some(ref expr) = *opt_expr {\n-                    self.print_expr(expr)?;\n+                    self.print_expr_maybe_paren(expr, parser::PREC_JUMP)?;\n                     self.s.space()?;\n                 }\n             }\n@@ -1391,7 +1424,7 @@ impl<'a> State<'a> {\n                 match *result {\n                     Some(ref expr) => {\n                         self.s.word(\" \")?;\n-                        self.print_expr(&expr)?;\n+                        self.print_expr_maybe_paren(&expr, parser::PREC_JUMP)?;\n                     }\n                     _ => (),\n                 }\n@@ -1463,7 +1496,7 @@ impl<'a> State<'a> {\n             }\n             hir::ExprYield(ref expr) => {\n                 self.s.word(\"yield\")?;\n-                self.print_expr(&expr)?;\n+                self.print_expr_maybe_paren(&expr, parser::PREC_JUMP)?;\n             }\n         }\n         self.ann.post(self, NodeExpr(expr))?;\n@@ -2246,3 +2279,111 @@ fn stmt_ends_with_semi(stmt: &hir::Stmt_) -> bool {\n         }\n     }\n }\n+\n+\n+fn expr_precedence(expr: &hir::Expr) -> i8 {\n+    use syntax::util::parser::*;\n+\n+    match expr.node {\n+        hir::ExprClosure(..) => PREC_CLOSURE,\n+\n+        hir::ExprBreak(..) |\n+        hir::ExprAgain(..) |\n+        hir::ExprRet(..) |\n+        hir::ExprYield(..) => PREC_JUMP,\n+\n+        // Binop-like expr kinds, handled by `AssocOp`.\n+        hir::ExprBinary(op, _, _) => bin_op_to_assoc_op(op.node).precedence() as i8,\n+\n+        hir::ExprCast(..) => AssocOp::As.precedence() as i8,\n+        hir::ExprType(..) => AssocOp::Colon.precedence() as i8,\n+\n+        hir::ExprAssign(..) |\n+        hir::ExprAssignOp(..) => AssocOp::Assign.precedence() as i8,\n+\n+        // Unary, prefix\n+        hir::ExprBox(..) |\n+        hir::ExprAddrOf(..) |\n+        hir::ExprUnary(..) => PREC_PREFIX,\n+\n+        // Unary, postfix\n+        hir::ExprCall(..) |\n+        hir::ExprMethodCall(..) |\n+        hir::ExprField(..) |\n+        hir::ExprTupField(..) |\n+        hir::ExprIndex(..) |\n+        hir::ExprInlineAsm(..) => PREC_POSTFIX,\n+\n+        // Never need parens\n+        hir::ExprArray(..) |\n+        hir::ExprRepeat(..) |\n+        hir::ExprTup(..) |\n+        hir::ExprLit(..) |\n+        hir::ExprPath(..) |\n+        hir::ExprIf(..) |\n+        hir::ExprWhile(..) |\n+        hir::ExprLoop(..) |\n+        hir::ExprMatch(..) |\n+        hir::ExprBlock(..) |\n+        hir::ExprStruct(..) => PREC_PAREN,\n+    }\n+}\n+\n+fn bin_op_to_assoc_op(op: hir::BinOp_) -> AssocOp {\n+    use hir::BinOp_::*;\n+    match op {\n+        BiAdd => AssocOp::Add,\n+        BiSub => AssocOp::Subtract,\n+        BiMul => AssocOp::Multiply,\n+        BiDiv => AssocOp::Divide,\n+        BiRem => AssocOp::Modulus,\n+\n+        BiAnd => AssocOp::LAnd,\n+        BiOr => AssocOp::LOr,\n+\n+        BiBitXor => AssocOp::BitXor,\n+        BiBitAnd => AssocOp::BitAnd,\n+        BiBitOr => AssocOp::BitOr,\n+        BiShl => AssocOp::ShiftLeft,\n+        BiShr => AssocOp::ShiftRight,\n+\n+        BiEq => AssocOp::Equal,\n+        BiLt => AssocOp::Less,\n+        BiLe => AssocOp::LessEqual,\n+        BiNe => AssocOp::NotEqual,\n+        BiGe => AssocOp::GreaterEqual,\n+        BiGt => AssocOp::Greater,\n+    }\n+}\n+\n+/// Expressions that syntactically contain an \"exterior\" struct literal i.e. not surrounded by any\n+/// parens or other delimiters, e.g. `X { y: 1 }`, `X { y: 1 }.method()`, `foo == X { y: 1 }` and\n+/// `X { y: 1 } == foo` all do, but `(X { y: 1 }) == foo` does not.\n+fn contains_exterior_struct_lit(value: &hir::Expr) -> bool {\n+    match value.node {\n+        hir::ExprStruct(..) => true,\n+\n+        hir::ExprAssign(ref lhs, ref rhs) |\n+        hir::ExprAssignOp(_, ref lhs, ref rhs) |\n+        hir::ExprBinary(_, ref lhs, ref rhs) => {\n+            // X { y: 1 } + X { y: 2 }\n+            contains_exterior_struct_lit(&lhs) || contains_exterior_struct_lit(&rhs)\n+        }\n+        hir::ExprUnary(_, ref x) |\n+        hir::ExprCast(ref x, _) |\n+        hir::ExprType(ref x, _) |\n+        hir::ExprField(ref x, _) |\n+        hir::ExprTupField(ref x, _) |\n+        hir::ExprIndex(ref x, _) => {\n+            // &X { y: 1 }, X { y: 1 }.y\n+            contains_exterior_struct_lit(&x)\n+        }\n+\n+        hir::ExprMethodCall(.., ref exprs) => {\n+            // X { y: 1 }.bar(...)\n+            contains_exterior_struct_lit(&exprs[0])\n+        }\n+\n+        _ => false,\n+    }\n+}"}, {"sha": "81cf20cfc77f0f4a7b4104096d1af2334072facd", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -199,20 +199,19 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ast::N\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n+        let hir_id = hcx.tcx.hir.node_to_hir_id(*self);\n         match hcx.node_id_hashing_mode {\n             NodeIdHashingMode::Ignore => {\n                 // Most NodeIds in the HIR can be ignored, but if there is a\n                 // corresponding entry in the `trait_map` we need to hash that.\n                 // Make sure we don't ignore too much by checking that there is\n                 // no entry in a debug_assert!().\n-                let hir_id = hcx.tcx.hir.node_to_hir_id(*self);\n                 debug_assert!(hcx.tcx.in_scope_traits(hir_id).is_none());\n             }\n             NodeIdHashingMode::HashDefPath => {\n-                hcx.tcx.hir.definitions().node_to_hir_id(*self).hash_stable(hcx, hasher);\n+                hir_id.hash_stable(hcx, hasher);\n             }\n             NodeIdHashingMode::HashTraitsInScope => {\n-                let hir_id = hcx.tcx.hir.node_to_hir_id(*self);\n                 if let Some(traits) = hcx.tcx.in_scope_traits(hir_id) {\n                     // The ordering of the candidates is not fixed. So we hash\n                     // the def-ids and then sort them and hash the collection."}, {"sha": "dce1639b375b781587fb1be335e0d94045312478", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -493,10 +493,6 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::L\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n-            mir::Literal::Item { def_id, substs } => {\n-                def_id.hash_stable(hcx, hasher);\n-                substs.hash_stable(hcx, hasher);\n-            }\n             mir::Literal::Value { ref value } => {\n                 value.hash_stable(hcx, hasher);\n             }"}, {"sha": "e933ca4c2b551db0fc395c68bf66acfaaab4e50b", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 32, "deletions": 19, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -16,7 +16,6 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n use std::hash as std_hash;\n use std::mem;\n-use syntax_pos::symbol::InternedString;\n use middle::region;\n use ty;\n \n@@ -236,6 +235,10 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::Pr\n                 def_id.hash_stable(hcx, hasher);\n                 closure_kind.hash_stable(hcx, hasher);\n             }\n+            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+                def_id.hash_stable(hcx, hasher);\n+                substs.hash_stable(hcx, hasher);\n+            }\n         }\n     }\n }\n@@ -272,59 +275,69 @@ for ::middle::const_val::ConstVal<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n-        use middle::const_val::ConstVal;\n+        use middle::const_val::ConstVal::*;\n+        use middle::const_val::ConstAggregate::*;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n         match *self {\n-            ConstVal::Float(ref value) => {\n+            Integral(ref value) => {\n                 value.hash_stable(hcx, hasher);\n             }\n-            ConstVal::Integral(ref value) => {\n+            Float(ref value) => {\n                 value.hash_stable(hcx, hasher);\n             }\n-            ConstVal::Str(ref value) => {\n+            Str(ref value) => {\n                 value.hash_stable(hcx, hasher);\n             }\n-            ConstVal::ByteStr(ref value) => {\n+            ByteStr(ref value) => {\n                 value.hash_stable(hcx, hasher);\n             }\n-            ConstVal::Bool(value) => {\n+            Bool(value) => {\n                 value.hash_stable(hcx, hasher);\n             }\n-            ConstVal::Char(value) => {\n+            Char(value) => {\n                 value.hash_stable(hcx, hasher);\n             }\n-            ConstVal::Variant(def_id) => {\n+            Variant(def_id) => {\n                 def_id.hash_stable(hcx, hasher);\n             }\n-            ConstVal::Function(def_id, substs) => {\n+            Function(def_id, substs) => {\n                 def_id.hash_stable(hcx, hasher);\n                 substs.hash_stable(hcx, hasher);\n             }\n-            ConstVal::Struct(ref name_value_map) => {\n-                let mut values: Vec<(InternedString, &ConstVal)> =\n-                    name_value_map.iter()\n-                                  .map(|(name, val)| (name.as_str(), val))\n-                                  .collect();\n-\n+            Aggregate(Struct(ref name_values)) => {\n+                let mut values = name_values.to_vec();\n                 values.sort_unstable_by_key(|&(ref name, _)| name.clone());\n                 values.hash_stable(hcx, hasher);\n             }\n-            ConstVal::Tuple(ref value) => {\n+            Aggregate(Tuple(ref value)) => {\n                 value.hash_stable(hcx, hasher);\n             }\n-            ConstVal::Array(ref value) => {\n+            Aggregate(Array(ref value)) => {\n                 value.hash_stable(hcx, hasher);\n             }\n-            ConstVal::Repeat(ref value, times) => {\n+            Aggregate(Repeat(ref value, times)) => {\n                 value.hash_stable(hcx, hasher);\n                 times.hash_stable(hcx, hasher);\n             }\n+            Unevaluated(def_id, substs) => {\n+                def_id.hash_stable(hcx, hasher);\n+                substs.hash_stable(hcx, hasher);\n+            }\n         }\n     }\n }\n \n+impl_stable_hash_for!(struct ::middle::const_val::ByteArray<'tcx> {\n+    data\n+});\n+\n+impl_stable_hash_for!(struct ty::Const<'tcx> {\n+    ty,\n+    val\n+});\n+\n impl_stable_hash_for!(struct ty::ClosureSubsts<'tcx> { substs });\n \n impl_stable_hash_for!(struct ty::GeneratorInterior<'tcx> { witness });"}, {"sha": "051263dfb53ef30f5e8f5283c7550d25049b3f70", "filename": "src/librustc/infer/error_reporting/different_lifetimes.rs", "status": "renamed", "additions": 107, "deletions": 52, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fdifferent_lifetimes.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -46,9 +46,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         // Determine whether the sub and sup consist of both anonymous (elided) regions.\n-        let anon_reg_sup = or_false!(self.is_suitable_anonymous_region(sup));\n+        let anon_reg_sup = or_false!(self.is_suitable_region(sup));\n \n-        let anon_reg_sub = or_false!(self.is_suitable_anonymous_region(sub));\n+        let anon_reg_sub = or_false!(self.is_suitable_region(sub));\n         let scope_def_id_sup = anon_reg_sup.def_id;\n         let bregion_sup = anon_reg_sup.boundregion;\n         let scope_def_id_sub = anon_reg_sub.def_id;\n@@ -57,10 +57,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let ty_sup = or_false!(self.find_anon_type(sup, &bregion_sup));\n \n         let ty_sub = or_false!(self.find_anon_type(sub, &bregion_sub));\n+        debug!(\"try_report_anon_anon_conflict: found_arg1={:?} sup={:?} br1={:?}\",\n+               ty_sub,\n+               sup,\n+               bregion_sup);\n+        debug!(\"try_report_anon_anon_conflict: found_arg2={:?} sub={:?} br2={:?}\",\n+               ty_sup,\n+               sub,\n+               bregion_sub);\n \n         let (main_label, label1, label2) = if let (Some(sup_arg), Some(sub_arg)) =\n-            (self.find_arg_with_anonymous_region(sup, sup),\n-             self.find_arg_with_anonymous_region(sub, sub)) {\n+            (self.find_arg_with_region(sup, sup), self.find_arg_with_region(sub, sub)) {\n \n             let (anon_arg_sup, is_first_sup, anon_arg_sub, is_first_sub) =\n                 (sup_arg.arg, sup_arg.is_first, sub_arg.arg, sub_arg.is_first);\n@@ -97,6 +104,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 (span_label, span_label_var1, span_label_var2)\n             }\n         } else {\n+            debug!(\"no arg with anon region found\");\n+            debug!(\"try_report_anon_anon_conflict: is_suitable(sub) = {:?}\",\n+                   self.is_suitable_region(sub));\n+            debug!(\"try_report_anon_anon_conflict: is_suitable(sup) = {:?}\",\n+                   self.is_suitable_region(sup));\n             return false;\n         };\n \n@@ -124,35 +136,27 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// The function returns the nested type corresponding to the anonymous region\n     /// for e.g. `&u8` and Vec<`&u8`.\n     pub fn find_anon_type(&self, region: Region<'tcx>, br: &ty::BoundRegion) -> Option<&hir::Ty> {\n-        if let Some(anon_reg) = self.is_suitable_anonymous_region(region) {\n+        if let Some(anon_reg) = self.is_suitable_region(region) {\n             let def_id = anon_reg.def_id;\n             if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n-                let ret_ty = self.tcx.type_of(def_id);\n-                if let ty::TyFnDef(_, _) = ret_ty.sty {\n-                    let inputs: &[_] =\n-                        match self.tcx.hir.get(node_id) {\n-                            hir_map::NodeItem(&hir::Item {\n-                                                  node: hir::ItemFn(ref fndecl, ..), ..\n-                                              }) => &fndecl.inputs,\n-                            hir_map::NodeTraitItem(&hir::TraitItem {\n-                                                   node: hir::TraitItemKind::Method(ref fndecl, ..),\n-                                                   ..\n-                                               }) => &fndecl.decl.inputs,\n-                            hir_map::NodeImplItem(&hir::ImplItem {\n-                                                  node: hir::ImplItemKind::Method(ref fndecl, ..),\n-                                                  ..\n-                                              }) => &fndecl.decl.inputs,\n+                let inputs: &[_] = match self.tcx.hir.get(node_id) {\n+                    hir_map::NodeItem(&hir::Item { node: hir::ItemFn(ref fndecl, ..), .. }) => {\n+                        &fndecl.inputs\n+                    }\n+                    hir_map::NodeTraitItem(&hir::TraitItem {\n+                                               node: hir::TraitItemKind::Method(ref fndecl, ..), ..\n+                                           }) => &fndecl.decl.inputs,\n+                    hir_map::NodeImplItem(&hir::ImplItem {\n+                                              node: hir::ImplItemKind::Method(ref fndecl, ..), ..\n+                                          }) => &fndecl.decl.inputs,\n \n-                            _ => &[],\n-                        };\n+                    _ => &[],\n+                };\n \n-                    return inputs\n-                               .iter()\n-                               .filter_map(|arg| {\n-                                               self.find_component_for_bound_region(&**arg, br)\n-                                           })\n-                               .next();\n-                }\n+                return inputs\n+                           .iter()\n+                           .filter_map(|arg| self.find_component_for_bound_region(&**arg, br))\n+                           .next();\n             }\n         }\n         None\n@@ -169,6 +173,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             hir_map: &self.tcx.hir,\n             bound_region: *br,\n             found_type: None,\n+            depth: 1,\n         };\n         nested_visitor.visit_ty(arg);\n         nested_visitor.found_type\n@@ -191,6 +196,7 @@ struct FindNestedTypeVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     // The type where the anonymous lifetime appears\n     // for e.g. Vec<`&u8`> and <`&u8`>\n     found_type: Option<&'gcx hir::Ty>,\n+    depth: u32,\n }\n \n impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n@@ -199,29 +205,77 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, arg: &'gcx hir::Ty) {\n-        // Find the index of the anonymous region that was part of the\n-        // error. We will then search the function parameters for a bound\n-        // region at the right depth with the same index.\n-        let br_index = match self.bound_region {\n-            ty::BrAnon(index) => index,\n-            _ => return,\n-        };\n-\n         match arg.node {\n+            hir::TyBareFn(_) => {\n+                self.depth += 1;\n+                intravisit::walk_ty(self, arg);\n+                self.depth -= 1;\n+                return;\n+            }\n+\n+            hir::TyTraitObject(ref bounds, _) => {\n+                for bound in bounds {\n+                    self.depth += 1;\n+                    self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n+                    self.depth -= 1;\n+                }\n+            }\n+\n             hir::TyRptr(ref lifetime, _) => {\n-                match self.infcx.tcx.named_region_map.defs.get(&lifetime.id) {\n-                    // the lifetime of the TyRptr\n-                    Some(&rl::Region::LateBoundAnon(debruijn_index, anon_index)) => {\n-                        if debruijn_index.depth == 1 && anon_index == br_index {\n+                // the lifetime of the TyRptr\n+                let hir_id = self.infcx.tcx.hir.node_to_hir_id(lifetime.id);\n+                match (self.infcx.tcx.named_region(hir_id), self.bound_region) {\n+                    // Find the index of the anonymous region that was part of the\n+                    // error. We will then search the function parameters for a bound\n+                    // region at the right depth with the same index\n+                    (Some(rl::Region::LateBoundAnon(debruijn_index, anon_index)),\n+                     ty::BrAnon(br_index)) => {\n+                        debug!(\"LateBoundAnon depth = {:?} anon_index = {:?} br_index={:?}\",\n+                               debruijn_index.depth,\n+                               anon_index,\n+                               br_index);\n+                        if debruijn_index.depth == self.depth && anon_index == br_index {\n+                            self.found_type = Some(arg);\n+                            return; // we can stop visiting now\n+                        }\n+                    }\n+\n+                    // Find the index of the named region that was part of the\n+                    // error. We will then search the function parameters for a bound\n+                    // region at the right depth with the same index\n+                    (Some(rl::Region::EarlyBound(_, id)), ty::BrNamed(def_id, _)) => {\n+                        debug!(\"EarlyBound self.infcx.tcx.hir.local_def_id(id)={:?} \\\n+                                        def_id={:?}\",\n+                               self.infcx.tcx.hir.local_def_id(id),\n+                               def_id);\n+                        if self.infcx.tcx.hir.local_def_id(id) == def_id {\n                             self.found_type = Some(arg);\n                             return; // we can stop visiting now\n                         }\n                     }\n-                    Some(&rl::Region::Static) |\n-                    Some(&rl::Region::EarlyBound(_, _)) |\n-                    Some(&rl::Region::LateBound(_, _)) |\n-                    Some(&rl::Region::Free(_, _)) |\n-                    None => {\n+\n+                    // Find the index of the named region that was part of the\n+                    // error. We will then search the function parameters for a bound\n+                    // region at the right depth with the same index\n+                    (Some(rl::Region::LateBound(debruijn_index, id)), ty::BrNamed(def_id, _)) => {\n+                        debug!(\"FindNestedTypeVisitor::visit_ty: LateBound depth = {:?}\",\n+                               debruijn_index.depth);\n+                        debug!(\"self.infcx.tcx.hir.local_def_id(id)={:?}\",\n+                               self.infcx.tcx.hir.local_def_id(id));\n+                        debug!(\"def_id={:?}\", def_id);\n+                        if debruijn_index.depth == self.depth &&\n+                           self.infcx.tcx.hir.local_def_id(id) == def_id {\n+                            self.found_type = Some(arg);\n+                            return; // we can stop visiting now\n+                        }\n+                    }\n+\n+                    (Some(rl::Region::Static), _) |\n+                    (Some(rl::Region::Free(_, _)), _) |\n+                    (Some(rl::Region::EarlyBound(_, _)), _) |\n+                    (Some(rl::Region::LateBound(_, _)), _) |\n+                    (Some(rl::Region::LateBoundAnon(_, _)), _) |\n+                    (None, _) => {\n                         debug!(\"no arg found\");\n                     }\n                 }\n@@ -272,17 +326,18 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for TyPathVisitor<'a, 'gcx, 'tcx> {\n             _ => return,\n         };\n \n-        match self.infcx.tcx.named_region_map.defs.get(&lifetime.id) {\n+        let hir_id = self.infcx.tcx.hir.node_to_hir_id(lifetime.id);\n+        match self.infcx.tcx.named_region(hir_id) {\n             // the lifetime of the TyPath!\n-            Some(&rl::Region::LateBoundAnon(debruijn_index, anon_index)) => {\n+            Some(rl::Region::LateBoundAnon(debruijn_index, anon_index)) => {\n                 if debruijn_index.depth == 1 && anon_index == br_index {\n                     self.found_it = true;\n                 }\n             }\n-            Some(&rl::Region::Static) |\n-            Some(&rl::Region::EarlyBound(_, _)) |\n-            Some(&rl::Region::LateBound(_, _)) |\n-            Some(&rl::Region::Free(_, _)) |\n+            Some(rl::Region::Static) |\n+            Some(rl::Region::EarlyBound(_, _)) |\n+            Some(rl::Region::LateBound(_, _)) |\n+            Some(rl::Region::Free(_, _)) |\n             None => {\n                 debug!(\"no arg found\");\n             }", "previous_filename": "src/librustc/infer/error_reporting/anon_anon_conflict.rs"}, {"sha": "6fc76a1d09037740ec003bb723dead46eb348828", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -79,7 +79,7 @@ mod need_type_info;\n mod named_anon_conflict;\n #[macro_use]\n mod util;\n-mod anon_anon_conflict;\n+mod different_lifetimes;\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn note_and_explain_region(self,\n@@ -357,7 +357,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 // for imported and non-imported crates\n                 if exp_path == found_path\n                 || exp_abs_path == found_abs_path {\n-                    let crate_name = self.tcx.sess.cstore.crate_name(did1.krate);\n+                    let crate_name = self.tcx.crate_name(did1.krate);\n                     err.span_note(sp, &format!(\"Perhaps two different versions \\\n                                                 of crate `{}` are being used?\",\n                                                crate_name));\n@@ -913,8 +913,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         name)\n             }\n             infer::UpvarRegion(ref upvar_id, _) => {\n-                format!(\" for capture of `{}` by closure\",\n-                        self.tcx.local_var_name_str_def_index(upvar_id.var_id))\n+                let var_node_id = self.tcx.hir.hir_to_node_id(upvar_id.var_id);\n+                let var_name = self.tcx.hir.name(var_node_id);\n+                format!(\" for capture of `{}` by closure\", var_name)\n             }\n         };\n "}, {"sha": "a3bbdab497a9b2439de7250a9ff577bbecfe6fb9", "filename": "src/librustc/infer/error_reporting/named_anon_conflict.rs", "status": "modified", "additions": 39, "deletions": 11, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -13,6 +13,7 @@\n use infer::InferCtxt;\n use infer::region_inference::RegionResolutionError::*;\n use infer::region_inference::RegionResolutionError;\n+use ty;\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // This method generates the error message for the case when\n@@ -24,39 +25,68 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             _ => return false, // inapplicable\n         };\n \n+        debug!(\"try_report_named_anon_conflict(sub={:?}, sup={:?})\",\n+               sub,\n+               sup);\n+\n         // Determine whether the sub and sup consist of one named region ('a)\n         // and one anonymous (elided) region. If so, find the parameter arg\n         // where the anonymous region appears (there must always be one; we\n         // only introduced anonymous regions in parameters) as well as a\n         // version new_ty of its type where the anonymous region is replaced\n         // with the named one.//scope_def_id\n         let (named, anon_arg_info, region_info) =\n-            if sub.is_named_region() && self.is_suitable_anonymous_region(sup).is_some() {\n+            if self.is_named_region(sub) && self.is_suitable_region(sup).is_some() &&\n+               self.find_arg_with_region(sup, sub).is_some() {\n                 (sub,\n-                 self.find_arg_with_anonymous_region(sup, sub).unwrap(),\n-                 self.is_suitable_anonymous_region(sup).unwrap())\n-            } else if sup.is_named_region() && self.is_suitable_anonymous_region(sub).is_some() {\n+                 self.find_arg_with_region(sup, sub).unwrap(),\n+                 self.is_suitable_region(sup).unwrap())\n+            } else if self.is_named_region(sup) && self.is_suitable_region(sub).is_some() &&\n+                      self.find_arg_with_region(sub, sup).is_some() {\n                 (sup,\n-                 self.find_arg_with_anonymous_region(sub, sup).unwrap(),\n-                 self.is_suitable_anonymous_region(sub).unwrap())\n+                 self.find_arg_with_region(sub, sup).unwrap(),\n+                 self.is_suitable_region(sub).unwrap())\n             } else {\n                 return false; // inapplicable\n             };\n \n+        debug!(\"try_report_named_anon_conflict: named = {:?}\", named);\n+        debug!(\"try_report_named_anon_conflict: anon_arg_info = {:?}\",\n+               anon_arg_info);\n+        debug!(\"try_report_named_anon_conflict: region_info = {:?}\",\n+               region_info);\n+\n         let (arg, new_ty, br, is_first, scope_def_id, is_impl_item) = (anon_arg_info.arg,\n                                                                        anon_arg_info.arg_ty,\n                                                                        anon_arg_info.bound_region,\n                                                                        anon_arg_info.is_first,\n                                                                        region_info.def_id,\n                                                                        region_info.is_impl_item);\n+        match br {\n+            ty::BrAnon(_) => {}\n+            _ => {\n+                /* not an anonymous region */\n+                debug!(\"try_report_named_anon_conflict: not an anonymous region\");\n+                return false;\n+            }\n+        }\n+\n         if is_impl_item {\n+            debug!(\"try_report_named_anon_conflict: impl item, bail out\");\n             return false;\n         }\n \n-        if self.is_return_type_anon(scope_def_id, br) || self.is_self_anon(is_first, scope_def_id) {\n+        if self.is_return_type_anon(scope_def_id, br) {\n+            debug!(\"try_report_named_anon_conflict: is_return_type_anon({:?}, {:?}) = true\",\n+                   scope_def_id,\n+                   br);\n+            return false;\n+        } else if self.is_self_anon(is_first, scope_def_id) {\n+            debug!(\"try_report_named_anon_conflict: is_self_anon({:?}, {:?}) = true\",\n+                   is_first,\n+                   scope_def_id);\n             return false;\n         } else {\n-\n             let (error_var, span_label_var) = if let Some(simple_name) = arg.pat.simple_name() {\n                 (format!(\"the type of `{}`\", simple_name), format!(\"the type of `{}`\", simple_name))\n             } else {\n@@ -72,9 +102,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                 format!(\"consider changing {} to `{}`\", span_label_var, new_ty))\n                     .span_label(span, format!(\"lifetime `{}` required\", named))\n                     .emit();\n-\n-\n+            return true;\n         }\n-        return true;\n     }\n }"}, {"sha": "1f0fd7b01d37dcd97d4b9459edc9da08047b27b4", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -43,10 +43,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                               \"...so that reference does not outlive borrowed content\");\n             }\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n+                let var_node_id = self.tcx.hir.hir_to_node_id(upvar_id.var_id);\n+                let var_name = self.tcx.hir.name(var_node_id);\n                 err.span_note(span,\n-                              &format!(\"...so that closure can access `{}`\",\n-                                       self.tcx\n-                                           .local_var_name_str_def_index(upvar_id.var_id)));\n+                              &format!(\"...so that closure can access `{}`\", var_name));\n             }\n             infer::InfStackClosure(span) => {\n                 err.span_note(span, \"...so that closure does not outlive its stack frame\");\n@@ -63,7 +63,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 err.span_note(span,\n                               &format!(\"...so that captured variable `{}` does not outlive the \\\n                                         enclosing closure\",\n-                                       self.tcx.local_var_name_str(id)));\n+                                       self.tcx.hir.name(id)));\n             }\n             infer::IndexSlice(span) => {\n                 err.span_note(span, \"...so that slice is not indexed outside the lifetime\");\n@@ -176,22 +176,22 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 err\n             }\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n+                let var_node_id = self.tcx.hir.hir_to_node_id(upvar_id.var_id);\n+                let var_name = self.tcx.hir.name(var_node_id);\n                 let mut err = struct_span_err!(self.tcx.sess,\n                                                span,\n                                                E0313,\n                                                \"lifetime of borrowed pointer outlives lifetime \\\n                                                 of captured variable `{}`...\",\n-                                               self.tcx\n-                                                   .local_var_name_str_def_index(upvar_id.var_id));\n+                                               var_name);\n                 self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                                                  \"...the borrowed pointer is valid for \",\n                                                  sub,\n                                                  \"...\");\n                 self.tcx.note_and_explain_region(\n                     region_scope_tree,\n                     &mut err,\n-                    &format!(\"...but `{}` is only valid for \",\n-                        self.tcx.local_var_name_str_def_index(upvar_id.var_id)),\n+                    &format!(\"...but `{}` is only valid for \", var_name),\n                     sup,\n                     \"\");\n                 err\n@@ -234,7 +234,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0474,\n                                                \"captured variable `{}` does not outlive the \\\n                                                 enclosing closure\",\n-                                               self.tcx.local_var_name_str(id));\n+                                               self.tcx.hir.name(id));\n                 self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                     \"captured variable is valid for \", sup, \"\");\n                 self.tcx.note_and_explain_region(region_scope_tree, &mut err,"}, {"sha": "b58fa6b0e7cbdc3f3ca153adcde528c0bde086d9", "filename": "src/librustc/infer/error_reporting/util.rs", "status": "modified", "additions": 102, "deletions": 76, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -18,15 +18,19 @@ use hir::map as hir_map;\n \n macro_rules! or_false {\n      ($v:expr) => {\n-          match $v {\n-               Some(v) => v,\n-               None => return false,\n-          }\n+         match $v {\n+             Some(v) => v,\n+             None => {\n+                 debug!(\"or_false failed: {}\", stringify!($v));\n+                 return false;\n+             }\n+         }\n      }\n }\n \n // The struct contains the information about the anonymous region\n // we are searching for.\n+#[derive(Debug)]\n pub struct AnonymousArgInfo<'tcx> {\n     // the argument corresponding to the anonymous region\n     pub arg: &'tcx hir::Arg,\n@@ -41,6 +45,7 @@ pub struct AnonymousArgInfo<'tcx> {\n \n // This struct contains information regarding the\n // Refree((FreeRegion) corresponding to lifetime conflict\n+#[derive(Debug)]\n pub struct FreeRegionInfo {\n     // def id corresponding to FreeRegion\n     pub def_id: DefId,\n@@ -62,47 +67,54 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // i32, which is the type of y but with the anonymous region replaced\n     // with 'a, the corresponding bound region and is_first which is true if\n     // the hir::Arg is the first argument in the function declaration.\n-    pub fn find_arg_with_anonymous_region(&self,\n-                                          anon_region: Region<'tcx>,\n-                                          replace_region: Region<'tcx>)\n-                                          -> Option<AnonymousArgInfo> {\n-\n-        if let ty::ReFree(ref free_region) = *anon_region {\n-            let id = free_region.scope;\n-            let hir = &self.tcx.hir;\n-            if let Some(node_id) = hir.as_local_node_id(id) {\n-                if let Some(body_id) = hir.maybe_body_owned_by(node_id) {\n-                    let body = hir.body(body_id);\n-                    if let Some(tables) = self.in_progress_tables {\n-                        body.arguments\n-                            .iter()\n-                            .enumerate()\n-                            .filter_map(|(index, arg)| {\n-                                let ty = tables.borrow().node_id_to_type(arg.hir_id);\n-                                let mut found_anon_region = false;\n-                                let new_arg_ty = self.tcx\n-                                    .fold_regions(&ty, &mut false, |r, _| if *r == *anon_region {\n-                                        found_anon_region = true;\n-                                        replace_region\n-                                    } else {\n-                                        r\n-                                    });\n-                                if found_anon_region {\n-                                    let is_first = index == 0;\n-                                    Some(AnonymousArgInfo {\n-                                             arg: arg,\n-                                             arg_ty: new_arg_ty,\n-                                             bound_region: free_region.bound_region,\n-                                             is_first: is_first,\n-                                         })\n+    pub fn find_arg_with_region(&self,\n+                                anon_region: Region<'tcx>,\n+                                replace_region: Region<'tcx>)\n+                                -> Option<AnonymousArgInfo> {\n+\n+        let (id, bound_region) = match *anon_region {\n+            ty::ReFree(ref free_region) => (free_region.scope, free_region.bound_region),\n+            ty::ReEarlyBound(ref ebr) => {\n+                (self.tcx.parent_def_id(ebr.def_id).unwrap(),\n+                 ty::BoundRegion::BrNamed(ebr.def_id, ebr.name))\n+            }\n+            _ => return None, // not a free region\n+        };\n+\n+        let hir = &self.tcx.hir;\n+        if let Some(node_id) = hir.as_local_node_id(id) {\n+            if let Some(body_id) = hir.maybe_body_owned_by(node_id) {\n+                let body = hir.body(body_id);\n+                if let Some(tables) = self.in_progress_tables {\n+                    body.arguments\n+                        .iter()\n+                        .enumerate()\n+                        .filter_map(|(index, arg)| {\n+                            let ty = match tables.borrow().node_id_to_type_opt(arg.hir_id) {\n+                                Some(v) => v,\n+                                None => return None, // sometimes the tables are not yet populated\n+                            };\n+                            let mut found_anon_region = false;\n+                            let new_arg_ty = self.tcx\n+                                .fold_regions(&ty, &mut false, |r, _| if *r == *anon_region {\n+                                    found_anon_region = true;\n+                                    replace_region\n                                 } else {\n-                                    None\n-                                }\n-                            })\n-                            .next()\n-                    } else {\n-                        None\n-                    }\n+                                    r\n+                                });\n+                            if found_anon_region {\n+                                let is_first = index == 0;\n+                                Some(AnonymousArgInfo {\n+                                         arg: arg,\n+                                         arg_ty: new_arg_ty,\n+                                         bound_region: bound_region,\n+                                         is_first: is_first,\n+                                     })\n+                            } else {\n+                                None\n+                            }\n+                        })\n+                        .next()\n                 } else {\n                     None\n                 }\n@@ -114,37 +126,38 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    // This method returns whether the given Region is Anonymous\n-    // and returns the DefId and the BoundRegion corresponding to the given region.\n-    pub fn is_suitable_anonymous_region(&self, region: Region<'tcx>) -> Option<FreeRegionInfo> {\n-        if let ty::ReFree(ref free_region) = *region {\n-            if let ty::BrAnon(..) = free_region.bound_region {\n-                let anonymous_region_binding_scope = free_region.scope;\n-                let node_id = self.tcx\n-                    .hir\n-                    .as_local_node_id(anonymous_region_binding_scope)\n-                    .unwrap();\n-                let mut is_impl_item = false;\n-                match self.tcx.hir.find(node_id) {\n-\n-                    Some(hir_map::NodeItem(..)) |\n-                    Some(hir_map::NodeTraitItem(..)) => {\n-                        // Success -- proceed to return Some below\n-                    }\n-                    Some(hir_map::NodeImplItem(..)) => {\n-                        is_impl_item =\n-                            self.is_bound_region_in_impl_item(anonymous_region_binding_scope);\n-                    }\n-                    _ => return None,\n-                }\n-                return Some(FreeRegionInfo {\n-                                def_id: anonymous_region_binding_scope,\n-                                boundregion: free_region.bound_region,\n-                                is_impl_item: is_impl_item,\n-                            });\n+    // This method returns the DefId and the BoundRegion corresponding to the given region.\n+    pub fn is_suitable_region(&self, region: Region<'tcx>) -> Option<FreeRegionInfo> {\n+\n+        let (suitable_region_binding_scope, bound_region) = match *region {\n+            ty::ReFree(ref free_region) => (free_region.scope, free_region.bound_region),\n+            ty::ReEarlyBound(ref ebr) => {\n+                (self.tcx.parent_def_id(ebr.def_id).unwrap(),\n+                 ty::BoundRegion::BrNamed(ebr.def_id, ebr.name))\n             }\n-        }\n-        None\n+            _ => return None, // not a free region\n+        };\n+\n+        let node_id = self.tcx\n+            .hir\n+            .as_local_node_id(suitable_region_binding_scope)\n+            .unwrap();\n+        let is_impl_item = match self.tcx.hir.find(node_id) {\n+\n+            Some(hir_map::NodeItem(..)) |\n+            Some(hir_map::NodeTraitItem(..)) => false,\n+            Some(hir_map::NodeImplItem(..)) => {\n+                self.is_bound_region_in_impl_item(suitable_region_binding_scope)\n+            }\n+            _ => return None,\n+        };\n+\n+        return Some(FreeRegionInfo {\n+                        def_id: suitable_region_binding_scope,\n+                        boundregion: bound_region,\n+                        is_impl_item: is_impl_item,\n+                    });\n+\n     }\n \n     // Here, we check for the case where the anonymous region\n@@ -177,9 +190,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     // Here we check if the bound region is in Impl Item.\n-    pub fn is_bound_region_in_impl_item(&self, anonymous_region_binding_scope: DefId) -> bool {\n+    pub fn is_bound_region_in_impl_item(&self, suitable_region_binding_scope: DefId) -> bool {\n         let container_id = self.tcx\n-            .associated_item(anonymous_region_binding_scope)\n+            .associated_item(suitable_region_binding_scope)\n             .container\n             .id();\n         if self.tcx.impl_trait_ref(container_id).is_some() {\n@@ -193,4 +206,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n         false\n     }\n+\n+    // This method returns whether the given Region is Named\n+    pub fn is_named_region(&self, region: Region<'tcx>) -> bool {\n+        match *region {\n+            ty::ReFree(ref free_region) => {\n+                match free_region.bound_region {\n+                    ty::BrNamed(..) => true,\n+                    _ => false,\n+                }\n+            }\n+            _ => false,\n+        }\n+    }\n }"}, {"sha": "6ccf7e42fd5fd7fba6e73e0f3e89344bad8e04ad", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -442,6 +442,7 @@ macro_rules! impl_trans_normalize {\n \n impl_trans_normalize!('gcx,\n     Ty<'gcx>,\n+    &'gcx ty::Const<'gcx>,\n     &'gcx Substs<'gcx>,\n     ty::FnSig<'gcx>,\n     ty::PolyFnSig<'gcx>,\n@@ -493,7 +494,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         let param_env = ty::ParamEnv::empty(Reveal::All);\n         let value = self.erase_regions(value);\n \n-        if !value.has_projection_types() {\n+        if !value.has_projections() {\n             return value;\n         }\n \n@@ -515,7 +516,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n \n         let value = self.erase_regions(value);\n \n-        if !value.has_projection_types() {\n+        if !value.has_projections() {\n             return value;\n         }\n \n@@ -1160,6 +1161,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         value.fold_with(&mut r)\n     }\n \n+    /// Returns true if `T` contains unresolved type variables. In the\n+    /// process of visiting `T`, this will resolve (where possible)\n+    /// type variables in `T`, but it never constructs the final,\n+    /// resolved type, so it's more efficient than\n+    /// `resolve_type_vars_if_possible()`.\n+    pub fn any_unresolved_type_vars<T>(&self, value: &T) -> bool\n+        where T: TypeFoldable<'tcx>\n+    {\n+        let mut r = resolve::UnresolvedTypeFinder::new(self);\n+        value.visit_with(&mut r)\n+    }\n+\n     pub fn resolve_type_and_region_vars_if_possible<T>(&self, value: &T) -> T\n         where T: TypeFoldable<'tcx>\n     {"}, {"sha": "10899e42afb819b74ad124db8506ca87a939f930", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -10,7 +10,7 @@\n \n use super::{InferCtxt, FixupError, FixupResult};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n-use ty::fold::TypeFolder;\n+use ty::fold::{TypeFolder, TypeVisitor};\n \n ///////////////////////////////////////////////////////////////////////////\n // OPPORTUNISTIC TYPE RESOLVER\n@@ -80,6 +80,43 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticTypeAndRegionResolv\n     }\n }\n \n+///////////////////////////////////////////////////////////////////////////\n+// UNRESOLVED TYPE FINDER\n+\n+/// The unresolved type **finder** walks your type and searches for\n+/// type variables that don't yet have a value. They get pushed into a\n+/// vector. It does not construct the fully resolved type (which might\n+/// involve some hashing and so forth).\n+pub struct UnresolvedTypeFinder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> UnresolvedTypeFinder<'a, 'gcx, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n+        UnresolvedTypeFinder { infcx }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeFinder<'a, 'gcx, 'tcx> {\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+        let t = self.infcx.shallow_resolve(t);\n+        if t.has_infer_types() {\n+            if let ty::TyInfer(_) = t.sty {\n+                // Since we called `shallow_resolve` above, this must\n+                // be an (as yet...) unresolved inference variable.\n+                true\n+            } else {\n+                // Otherwise, visit its contents.\n+                t.super_visit_with(self)\n+            }\n+        } else {\n+            // Micro-optimize: no inference types at all Can't have unresolved type\n+            // variables, no need to visit the contents.\n+            false\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // FULL TYPE RESOLUTION\n "}, {"sha": "7b239980467303ff9720e1eb7e788a5781dd3ba3", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 33, "deletions": 70, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -8,64 +8,66 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use self::ConstVal::*;\n pub use rustc_const_math::ConstInt;\n \n-use hir;\n-use hir::def::Def;\n use hir::def_id::DefId;\n-use traits::Reveal;\n use ty::{self, TyCtxt, layout};\n use ty::subst::Substs;\n-use util::common::ErrorReported;\n use rustc_const_math::*;\n \n use graphviz::IntoCow;\n use errors::DiagnosticBuilder;\n+use serialize::{self, Encodable, Encoder, Decodable, Decoder};\n use syntax::symbol::InternedString;\n use syntax::ast;\n use syntax_pos::Span;\n \n use std::borrow::Cow;\n-use std::collections::BTreeMap;\n-use std::rc::Rc;\n \n-pub type EvalResult<'tcx> = Result<ConstVal<'tcx>, ConstEvalErr<'tcx>>;\n+pub type EvalResult<'tcx> = Result<&'tcx ty::Const<'tcx>, ConstEvalErr<'tcx>>;\n \n-#[derive(Clone, Debug, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq)]\n+#[derive(Copy, Clone, Debug, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq)]\n pub enum ConstVal<'tcx> {\n-    Float(ConstFloat),\n     Integral(ConstInt),\n+    Float(ConstFloat),\n     Str(InternedString),\n-    ByteStr(Rc<Vec<u8>>),\n+    ByteStr(ByteArray<'tcx>),\n     Bool(bool),\n     Char(char),\n     Variant(DefId),\n     Function(DefId, &'tcx Substs<'tcx>),\n-    Struct(BTreeMap<ast::Name, ConstVal<'tcx>>),\n-    Tuple(Vec<ConstVal<'tcx>>),\n-    Array(Vec<ConstVal<'tcx>>),\n-    Repeat(Box<ConstVal<'tcx>>, u64),\n+    Aggregate(ConstAggregate<'tcx>),\n+    Unevaluated(DefId, &'tcx Substs<'tcx>),\n }\n \n-impl<'tcx> ConstVal<'tcx> {\n-    pub fn description(&self) -> &'static str {\n-        match *self {\n-            Float(f) => f.description(),\n-            Integral(i) => i.description(),\n-            Str(_) => \"string literal\",\n-            ByteStr(_) => \"byte string literal\",\n-            Bool(_) => \"boolean\",\n-            Char(..) => \"char\",\n-            Variant(_) => \"enum variant\",\n-            Struct(_) => \"struct\",\n-            Tuple(_) => \"tuple\",\n-            Function(..) => \"function definition\",\n-            Array(..) => \"array\",\n-            Repeat(..) => \"repeat\",\n-        }\n+#[derive(Copy, Clone, Debug, Hash, RustcEncodable, Eq, PartialEq)]\n+pub struct ByteArray<'tcx> {\n+    pub data: &'tcx [u8],\n+}\n+\n+impl<'tcx> serialize::UseSpecializedDecodable for ByteArray<'tcx> {}\n+\n+#[derive(Copy, Clone, Debug, Hash, Eq, PartialEq)]\n+pub enum ConstAggregate<'tcx> {\n+    Struct(&'tcx [(ast::Name, &'tcx ty::Const<'tcx>)]),\n+    Tuple(&'tcx [&'tcx ty::Const<'tcx>]),\n+    Array(&'tcx [&'tcx ty::Const<'tcx>]),\n+    Repeat(&'tcx ty::Const<'tcx>, u64),\n+}\n+\n+impl<'tcx> Encodable for ConstAggregate<'tcx> {\n+    fn encode<S: Encoder>(&self, _: &mut S) -> Result<(), S::Error> {\n+        bug!(\"should never encode ConstAggregate::{:?}\", self)\n+    }\n+}\n+\n+impl<'tcx> Decodable for ConstAggregate<'tcx> {\n+    fn decode<D: Decoder>(_: &mut D) -> Result<Self, D::Error> {\n+        bug!(\"should never decode ConstAggregate\")\n     }\n+}\n \n+impl<'tcx> ConstVal<'tcx> {\n     pub fn to_const_int(&self) -> Option<ConstInt> {\n         match *self {\n             ConstVal::Integral(i) => Some(i),\n@@ -86,8 +88,6 @@ pub struct ConstEvalErr<'tcx> {\n pub enum ErrKind<'tcx> {\n     CannotCast,\n     MissingStructField,\n-    NegateOn(ConstVal<'tcx>),\n-    NotOn(ConstVal<'tcx>),\n \n     NonConstPath,\n     UnimplementedConstVal(&'static str),\n@@ -146,9 +146,6 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n \n         match self.kind {\n             CannotCast => simple!(\"can't cast this type\"),\n-            NegateOn(ref const_val) => simple!(\"negate on {}\", const_val.description()),\n-            NotOn(ref const_val) => simple!(\"not on {}\", const_val.description()),\n-\n             MissingStructField  => simple!(\"nonexistent struct field\"),\n             NonConstPath        => simple!(\"non-constant path in constant expression\"),\n             UnimplementedConstVal(what) =>\n@@ -221,37 +218,3 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n         self.struct_error(tcx, primary_span, primary_kind).emit();\n     }\n }\n-\n-/// Returns the value of the length-valued expression\n-pub fn eval_length(tcx: TyCtxt,\n-                   count: hir::BodyId,\n-                   reason: &str)\n-                   -> Result<usize, ErrorReported>\n-{\n-    let count_expr = &tcx.hir.body(count).value;\n-    let count_def_id = tcx.hir.body_owner_def_id(count);\n-    let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n-    let substs = Substs::identity_for_item(tcx.global_tcx(), count_def_id);\n-    match tcx.at(count_expr.span).const_eval(param_env.and((count_def_id, substs))) {\n-        Ok(Integral(Usize(count))) => {\n-            let val = count.as_u64(tcx.sess.target.uint_type);\n-            assert_eq!(val as usize as u64, val);\n-            Ok(val as usize)\n-        },\n-        Ok(_) |\n-        Err(ConstEvalErr { kind: ErrKind::TypeckError, .. }) => Err(ErrorReported),\n-        Err(err) => {\n-            let mut diag = err.struct_error(tcx, count_expr.span, reason);\n-\n-            if let hir::ExprPath(hir::QPath::Resolved(None, ref path)) = count_expr.node {\n-                if let Def::Local(..) = path.def {\n-                    diag.note(&format!(\"`{}` is a variable\",\n-                                       tcx.hir.node_to_pretty_string(count_expr.id)));\n-                }\n-            }\n-\n-            diag.emit();\n-            Err(ErrorReported)\n-        }\n-    }\n-}"}, {"sha": "a7d874386d1c9c82b4fff0385449a7c1e6ce14e3", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 81, "deletions": 120, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -23,16 +23,15 @@\n //! probably get a better home if someone can find one.\n \n use hir::def;\n-use hir::def_id::{CrateNum, DefId, DefIndex};\n+use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use hir::map as hir_map;\n use hir::map::definitions::{Definitions, DefKey, DefPathTable};\n use hir::svh::Svh;\n use ich;\n-use middle::lang_items;\n use ty::{self, TyCtxt};\n use session::Session;\n use session::search_paths::PathKind;\n-use util::nodemap::{NodeSet, DefIdMap};\n+use util::nodemap::NodeSet;\n \n use std::any::Any;\n use std::path::{Path, PathBuf};\n@@ -43,8 +42,6 @@ use syntax::ext::base::SyntaxExtension;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use rustc_back::target::Target;\n-use hir;\n-use rustc_back::PanicStrategy;\n \n pub use self::NativeLibraryKind::*;\n \n@@ -223,75 +220,44 @@ pub trait MetadataLoader {\n \n /// A store of Rust crates, through with their metadata\n /// can be accessed.\n+///\n+/// Note that this trait should probably not be expanding today. All new\n+/// functionality should be driven through queries instead!\n+///\n+/// If you find a method on this trait named `{name}_untracked` it signifies\n+/// that it's *not* tracked for dependency information throughout compilation\n+/// (it'd break incremental compilation) and should only be called pre-HIR (e.g.\n+/// during resolve)\n pub trait CrateStore {\n     fn crate_data_as_rc_any(&self, krate: CrateNum) -> Rc<Any>;\n \n     // access to the metadata loader\n     fn metadata_loader(&self) -> &MetadataLoader;\n \n-    // item info\n-    fn visibility(&self, def: DefId) -> ty::Visibility;\n-    fn visible_parent_map<'a>(&'a self, sess: &Session) -> ::std::cell::Ref<'a, DefIdMap<DefId>>;\n-    fn item_generics_cloned(&self, def: DefId) -> ty::Generics;\n-\n-    // trait info\n-    fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId>;\n-\n-    // impl info\n-    fn impl_defaultness(&self, def: DefId) -> hir::Defaultness;\n-\n-    // trait/impl-item info\n-    fn associated_item_cloned(&self, def: DefId) -> ty::AssociatedItem;\n-\n-    // flags\n-    fn is_dllimport_foreign_item(&self, def: DefId) -> bool;\n-    fn is_statically_included_foreign_item(&self, def_id: DefId) -> bool;\n-\n-    // crate metadata\n-    fn dep_kind(&self, cnum: CrateNum) -> DepKind;\n-    fn export_macros(&self, cnum: CrateNum);\n-    fn lang_items(&self, cnum: CrateNum) -> Vec<(DefIndex, usize)>;\n-    fn missing_lang_items(&self, cnum: CrateNum) -> Vec<lang_items::LangItem>;\n-    fn is_compiler_builtins(&self, cnum: CrateNum) -> bool;\n-    fn is_sanitizer_runtime(&self, cnum: CrateNum) -> bool;\n-    fn is_profiler_runtime(&self, cnum: CrateNum) -> bool;\n-    fn panic_strategy(&self, cnum: CrateNum) -> PanicStrategy;\n-    /// The name of the crate as it is referred to in source code of the current\n-    /// crate.\n-    fn crate_name(&self, cnum: CrateNum) -> Symbol;\n-    /// The name of the crate as it is stored in the crate's metadata.\n-    fn original_crate_name(&self, cnum: CrateNum) -> Symbol;\n-    fn crate_hash(&self, cnum: CrateNum) -> Svh;\n-    fn crate_disambiguator(&self, cnum: CrateNum) -> Symbol;\n-    fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>;\n-    fn derive_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>;\n-    fn native_libraries(&self, cnum: CrateNum) -> Vec<NativeLibrary>;\n-    fn exported_symbols(&self, cnum: CrateNum) -> Vec<DefId>;\n-    fn is_no_builtins(&self, cnum: CrateNum) -> bool;\n-\n     // resolve\n     fn def_key(&self, def: DefId) -> DefKey;\n     fn def_path(&self, def: DefId) -> hir_map::DefPath;\n     fn def_path_hash(&self, def: DefId) -> hir_map::DefPathHash;\n     fn def_path_table(&self, cnum: CrateNum) -> Rc<DefPathTable>;\n-    fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>;\n-    fn item_children(&self, did: DefId, sess: &Session) -> Vec<def::Export>;\n-    fn load_macro(&self, did: DefId, sess: &Session) -> LoadedMacro;\n \n-    // misc. metadata\n-    fn item_body<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                           -> &'tcx hir::Body;\n+    // \"queries\" used in resolve that aren't tracked for incremental compilation\n+    fn visibility_untracked(&self, def: DefId) -> ty::Visibility;\n+    fn export_macros_untracked(&self, cnum: CrateNum);\n+    fn dep_kind_untracked(&self, cnum: CrateNum) -> DepKind;\n+    fn crate_name_untracked(&self, cnum: CrateNum) -> Symbol;\n+    fn struct_field_names_untracked(&self, def: DefId) -> Vec<ast::Name>;\n+    fn item_children_untracked(&self, did: DefId, sess: &Session) -> Vec<def::Export>;\n+    fn load_macro_untracked(&self, did: DefId, sess: &Session) -> LoadedMacro;\n+    fn extern_mod_stmt_cnum_untracked(&self, emod_id: ast::NodeId) -> Option<CrateNum>;\n+    fn item_generics_cloned_untracked(&self, def: DefId) -> ty::Generics;\n+    fn associated_item_cloned_untracked(&self, def: DefId) -> ty::AssociatedItem;\n+    fn postorder_cnums_untracked(&self) -> Vec<CrateNum>;\n \n     // This is basically a 1-based range of ints, which is a little\n     // silly - I may fix that.\n-    fn crates(&self) -> Vec<CrateNum>;\n-    fn used_libraries(&self) -> Vec<NativeLibrary>;\n-    fn used_link_args(&self) -> Vec<String>;\n+    fn crates_untracked(&self) -> Vec<CrateNum>;\n \n     // utility functions\n-    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>;\n-    fn used_crate_source(&self, cnum: CrateNum) -> CrateSource;\n-    fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum>;\n     fn encode_metadata<'a, 'tcx>(&self,\n                                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  link_meta: &LinkMeta,\n@@ -336,57 +302,18 @@ impl CrateStore for DummyCrateStore {\n     fn crate_data_as_rc_any(&self, krate: CrateNum) -> Rc<Any>\n         { bug!(\"crate_data_as_rc_any\") }\n     // item info\n-    fn visibility(&self, def: DefId) -> ty::Visibility { bug!(\"visibility\") }\n-    fn visible_parent_map<'a>(&'a self, session: &Session)\n-        -> ::std::cell::Ref<'a, DefIdMap<DefId>>\n-    {\n-        bug!(\"visible_parent_map\")\n-    }\n-    fn item_generics_cloned(&self, def: DefId) -> ty::Generics\n+    fn visibility_untracked(&self, def: DefId) -> ty::Visibility { bug!(\"visibility\") }\n+    fn item_generics_cloned_untracked(&self, def: DefId) -> ty::Generics\n         { bug!(\"item_generics_cloned\") }\n \n-    // trait info\n-    fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId> { vec![] }\n-\n-    // impl info\n-    fn impl_defaultness(&self, def: DefId) -> hir::Defaultness { bug!(\"impl_defaultness\") }\n-\n     // trait/impl-item info\n-    fn associated_item_cloned(&self, def: DefId) -> ty::AssociatedItem\n+    fn associated_item_cloned_untracked(&self, def: DefId) -> ty::AssociatedItem\n         { bug!(\"associated_item_cloned\") }\n \n-    // flags\n-    fn is_dllimport_foreign_item(&self, id: DefId) -> bool { false }\n-    fn is_statically_included_foreign_item(&self, def_id: DefId) -> bool { false }\n-\n     // crate metadata\n-    fn lang_items(&self, cnum: CrateNum) -> Vec<(DefIndex, usize)>\n-        { bug!(\"lang_items\") }\n-    fn missing_lang_items(&self, cnum: CrateNum) -> Vec<lang_items::LangItem>\n-        { bug!(\"missing_lang_items\") }\n-    fn dep_kind(&self, cnum: CrateNum) -> DepKind { bug!(\"is_explicitly_linked\") }\n-    fn export_macros(&self, cnum: CrateNum) { bug!(\"export_macros\") }\n-    fn is_compiler_builtins(&self, cnum: CrateNum) -> bool { bug!(\"is_compiler_builtins\") }\n-    fn is_profiler_runtime(&self, cnum: CrateNum) -> bool { bug!(\"is_profiler_runtime\") }\n-    fn is_sanitizer_runtime(&self, cnum: CrateNum) -> bool { bug!(\"is_sanitizer_runtime\") }\n-    fn panic_strategy(&self, cnum: CrateNum) -> PanicStrategy {\n-        bug!(\"panic_strategy\")\n-    }\n-    fn crate_name(&self, cnum: CrateNum) -> Symbol { bug!(\"crate_name\") }\n-    fn original_crate_name(&self, cnum: CrateNum) -> Symbol {\n-        bug!(\"original_crate_name\")\n-    }\n-    fn crate_hash(&self, cnum: CrateNum) -> Svh { bug!(\"crate_hash\") }\n-    fn crate_disambiguator(&self, cnum: CrateNum)\n-                           -> Symbol { bug!(\"crate_disambiguator\") }\n-    fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>\n-        { bug!(\"plugin_registrar_fn\") }\n-    fn derive_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>\n-        { bug!(\"derive_registrar_fn\") }\n-    fn native_libraries(&self, cnum: CrateNum) -> Vec<NativeLibrary>\n-        { bug!(\"native_libraries\") }\n-    fn exported_symbols(&self, cnum: CrateNum) -> Vec<DefId> { bug!(\"exported_symbols\") }\n-    fn is_no_builtins(&self, cnum: CrateNum) -> bool { bug!(\"is_no_builtins\") }\n+    fn dep_kind_untracked(&self, cnum: CrateNum) -> DepKind { bug!(\"is_explicitly_linked\") }\n+    fn export_macros_untracked(&self, cnum: CrateNum) { bug!(\"export_macros\") }\n+    fn crate_name_untracked(&self, cnum: CrateNum) -> Symbol { bug!(\"crate_name\") }\n \n     // resolve\n     fn def_key(&self, def: DefId) -> DefKey { bug!(\"def_key\") }\n@@ -399,29 +326,18 @@ impl CrateStore for DummyCrateStore {\n     fn def_path_table(&self, cnum: CrateNum) -> Rc<DefPathTable> {\n         bug!(\"def_path_table\")\n     }\n-    fn struct_field_names(&self, def: DefId) -> Vec<ast::Name> { bug!(\"struct_field_names\") }\n-    fn item_children(&self, did: DefId, sess: &Session) -> Vec<def::Export> {\n+    fn struct_field_names_untracked(&self, def: DefId) -> Vec<ast::Name> {\n+        bug!(\"struct_field_names\")\n+    }\n+    fn item_children_untracked(&self, did: DefId, sess: &Session) -> Vec<def::Export> {\n         bug!(\"item_children\")\n     }\n-    fn load_macro(&self, did: DefId, sess: &Session) -> LoadedMacro { bug!(\"load_macro\") }\n+    fn load_macro_untracked(&self, did: DefId, sess: &Session) -> LoadedMacro { bug!(\"load_macro\") }\n \n-    // misc. metadata\n-    fn item_body<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                           -> &'tcx hir::Body {\n-        bug!(\"item_body\")\n-    }\n-\n-    // This is basically a 1-based range of ints, which is a little\n-    // silly - I may fix that.\n-    fn crates(&self) -> Vec<CrateNum> { vec![] }\n-    fn used_libraries(&self) -> Vec<NativeLibrary> { vec![] }\n-    fn used_link_args(&self) -> Vec<String> { vec![] }\n+    fn crates_untracked(&self) -> Vec<CrateNum> { vec![] }\n \n     // utility functions\n-    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>\n-        { vec![] }\n-    fn used_crate_source(&self, cnum: CrateNum) -> CrateSource { bug!(\"used_crate_source\") }\n-    fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum> { None }\n+    fn extern_mod_stmt_cnum_untracked(&self, emod_id: ast::NodeId) -> Option<CrateNum> { None }\n     fn encode_metadata<'a, 'tcx>(&self,\n                                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  link_meta: &LinkMeta,\n@@ -430,6 +346,7 @@ impl CrateStore for DummyCrateStore {\n         bug!(\"encode_metadata\")\n     }\n     fn metadata_encoding_version(&self) -> &[u8] { bug!(\"metadata_encoding_version\") }\n+    fn postorder_cnums_untracked(&self) -> Vec<CrateNum> { bug!(\"postorder_cnums_untracked\") }\n \n     // access to the metadata loader\n     fn metadata_loader(&self) -> &MetadataLoader { bug!(\"metadata_loader\") }\n@@ -439,3 +356,47 @@ pub trait CrateLoader {\n     fn process_item(&mut self, item: &ast::Item, defs: &Definitions);\n     fn postprocess(&mut self, krate: &ast::Crate);\n }\n+\n+// This method is used when generating the command line to pass through to\n+// system linker. The linker expects undefined symbols on the left of the\n+// command line to be defined in libraries on the right, not the other way\n+// around. For more info, see some comments in the add_used_library function\n+// below.\n+//\n+// In order to get this left-to-right dependency ordering, we perform a\n+// topological sort of all crates putting the leaves at the right-most\n+// positions.\n+pub fn used_crates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)> {\n+    let mut libs = tcx.crates()\n+        .iter()\n+        .cloned()\n+        .filter_map(|cnum| {\n+            if tcx.dep_kind(cnum).macros_only() {\n+                return None\n+            }\n+            let source = tcx.used_crate_source(cnum);\n+            let path = match prefer {\n+                LinkagePreference::RequireDynamic => source.dylib.clone().map(|p| p.0),\n+                LinkagePreference::RequireStatic => source.rlib.clone().map(|p| p.0),\n+            };\n+            let path = match path {\n+                Some(p) => LibSource::Some(p),\n+                None => {\n+                    if source.rmeta.is_some() {\n+                        LibSource::MetadataOnly\n+                    } else {\n+                        LibSource::None\n+                    }\n+                }\n+            };\n+            Some((cnum, path))\n+        })\n+        .collect::<Vec<_>>();\n+    let mut ordering = tcx.postorder_cnums(LOCAL_CRATE);\n+    Rc::make_mut(&mut ordering).reverse();\n+    libs.sort_by_key(|&(a, _)| {\n+        ordering.iter().position(|x| *x == a)\n+    });\n+    libs\n+}"}, {"sha": "66a425a2d476bd85295879f4d432e16e8d5132d2", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -79,7 +79,8 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                 self.check_def_id(def.def_id());\n             }\n             _ if self.ignore_non_const_paths => (),\n-            Def::PrimTy(..) | Def::SelfTy(..) => (),\n+            Def::PrimTy(..) | Def::SelfTy(..) |\n+            Def::Local(..) | Def::Upvar(..) => {}\n             Def::Variant(variant_id) | Def::VariantCtor(variant_id, ..) => {\n                 if let Some(enum_id) = self.tcx.parent_def_id(variant_id) {\n                     self.check_def_id(enum_id);\n@@ -469,7 +470,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     fn should_warn_about_field(&mut self, field: &hir::StructField) -> bool {\n         let field_type = self.tcx.type_of(self.tcx.hir.local_def_id(field.id));\n         let is_marker_field = match field_type.ty_to_def_id() {\n-            Some(def_id) => self.tcx.lang_items.items().iter().any(|item| *item == Some(def_id)),\n+            Some(def_id) => self.tcx.lang_items().items().iter().any(|item| *item == Some(def_id)),\n             _ => false\n         };\n         !field.is_positional()"}, {"sha": "1c7d0b76a643ea17e8b5a40c4cf02363345155dc", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 37, "deletions": 38, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -66,7 +66,7 @@ use hir::def_id::CrateNum;\n use session;\n use session::config;\n use ty::TyCtxt;\n-use middle::cstore::DepKind;\n+use middle::cstore::{self, DepKind};\n use middle::cstore::LinkagePreference::{self, RequireStatic, RequireDynamic};\n use util::nodemap::FxHashMap;\n use rustc_back::PanicStrategy;\n@@ -132,12 +132,12 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             if let Some(v) = attempt_static(tcx) {\n                 return v;\n             }\n-            for cnum in sess.cstore.crates() {\n-                if sess.cstore.dep_kind(cnum).macros_only() { continue }\n-                let src = sess.cstore.used_crate_source(cnum);\n+            for &cnum in tcx.crates().iter() {\n+                if tcx.dep_kind(cnum).macros_only() { continue }\n+                let src = tcx.used_crate_source(cnum);\n                 if src.rlib.is_some() { continue }\n                 sess.err(&format!(\"dependency `{}` not found in rlib format\",\n-                                  sess.cstore.crate_name(cnum)));\n+                                  tcx.crate_name(cnum)));\n             }\n             return Vec::new();\n         }\n@@ -165,24 +165,23 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Sweep all crates for found dylibs. Add all dylibs, as well as their\n     // dependencies, ensuring there are no conflicts. The only valid case for a\n     // dependency to be relied upon twice is for both cases to rely on a dylib.\n-    for cnum in sess.cstore.crates() {\n-        if sess.cstore.dep_kind(cnum).macros_only() { continue }\n-        let name = sess.cstore.crate_name(cnum);\n-        let src = sess.cstore.used_crate_source(cnum);\n+    for &cnum in tcx.crates().iter() {\n+        if tcx.dep_kind(cnum).macros_only() { continue }\n+        let name = tcx.crate_name(cnum);\n+        let src = tcx.used_crate_source(cnum);\n         if src.dylib.is_some() {\n             info!(\"adding dylib: {}\", name);\n-            add_library(sess, cnum, RequireDynamic, &mut formats);\n-            let deps = tcx.dylib_dependency_formats(cnum.as_def_id());\n+            add_library(tcx, cnum, RequireDynamic, &mut formats);\n+            let deps = tcx.dylib_dependency_formats(cnum);\n             for &(depnum, style) in deps.iter() {\n-                info!(\"adding {:?}: {}\", style,\n-                      sess.cstore.crate_name(depnum));\n-                add_library(sess, depnum, style, &mut formats);\n+                info!(\"adding {:?}: {}\", style, tcx.crate_name(depnum));\n+                add_library(tcx, depnum, style, &mut formats);\n             }\n         }\n     }\n \n     // Collect what we've got so far in the return vector.\n-    let last_crate = sess.cstore.crates().len();\n+    let last_crate = tcx.crates().len();\n     let mut ret = (1..last_crate+1).map(|cnum| {\n         match formats.get(&CrateNum::new(cnum)) {\n             Some(&RequireDynamic) => Linkage::Dynamic,\n@@ -196,14 +195,14 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     //\n     // If the crate hasn't been included yet and it's not actually required\n     // (e.g. it's an allocator) then we skip it here as well.\n-    for cnum in sess.cstore.crates() {\n-        let src = sess.cstore.used_crate_source(cnum);\n+    for &cnum in tcx.crates().iter() {\n+        let src = tcx.used_crate_source(cnum);\n         if src.dylib.is_none() &&\n            !formats.contains_key(&cnum) &&\n-           sess.cstore.dep_kind(cnum) == DepKind::Explicit {\n+           tcx.dep_kind(cnum) == DepKind::Explicit {\n             assert!(src.rlib.is_some() || src.rmeta.is_some());\n-            info!(\"adding staticlib: {}\", sess.cstore.crate_name(cnum));\n-            add_library(sess, cnum, RequireStatic, &mut formats);\n+            info!(\"adding staticlib: {}\", tcx.crate_name(cnum));\n+            add_library(tcx, cnum, RequireStatic, &mut formats);\n             ret[cnum.as_usize() - 1] = Linkage::Static;\n         }\n     }\n@@ -215,7 +214,7 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Things like allocators and panic runtimes may not have been activated\n     // quite yet, so do so here.\n     activate_injected_dep(sess.injected_panic_runtime.get(), &mut ret,\n-                          &|cnum| tcx.is_panic_runtime(cnum.as_def_id()));\n+                          &|cnum| tcx.is_panic_runtime(cnum));\n     activate_injected_allocator(sess, &mut ret);\n \n     // When dylib B links to dylib A, then when using B we must also link to A.\n@@ -226,7 +225,7 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // making sure that everything is available in the requested format.\n     for (cnum, kind) in ret.iter().enumerate() {\n         let cnum = CrateNum::new(cnum + 1);\n-        let src = sess.cstore.used_crate_source(cnum);\n+        let src = tcx.used_crate_source(cnum);\n         match *kind {\n             Linkage::NotLinked |\n             Linkage::IncludedFromDylib => {}\n@@ -237,7 +236,7 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     Linkage::Static => \"rlib\",\n                     _ => \"dylib\",\n                 };\n-                let name = sess.cstore.crate_name(cnum);\n+                let name = tcx.crate_name(cnum);\n                 sess.err(&format!(\"crate `{}` required to be available in {}, \\\n                                   but it was not available in this form\",\n                                   name, kind));\n@@ -248,7 +247,7 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     return ret;\n }\n \n-fn add_library(sess: &session::Session,\n+fn add_library(tcx: TyCtxt,\n                cnum: CrateNum,\n                link: LinkagePreference,\n                m: &mut FxHashMap<CrateNum, LinkagePreference>) {\n@@ -262,8 +261,8 @@ fn add_library(sess: &session::Session,\n             // This error is probably a little obscure, but I imagine that it\n             // can be refined over time.\n             if link2 != link || link == RequireStatic {\n-                sess.struct_err(&format!(\"cannot satisfy dependencies so `{}` only \\\n-                                          shows up once\", sess.cstore.crate_name(cnum)))\n+                tcx.sess.struct_err(&format!(\"cannot satisfy dependencies so `{}` only \\\n+                                              shows up once\", tcx.crate_name(cnum)))\n                     .help(\"having upstream crates all available in one format \\\n                            will likely make this go away\")\n                     .emit();\n@@ -275,16 +274,16 @@ fn add_library(sess: &session::Session,\n \n fn attempt_static<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<DependencyList> {\n     let sess = &tcx.sess;\n-    let crates = sess.cstore.used_crates(RequireStatic);\n+    let crates = cstore::used_crates(tcx, RequireStatic);\n     if !crates.iter().by_ref().all(|&(_, ref p)| p.is_some()) {\n         return None\n     }\n \n     // All crates are available in an rlib format, so we're just going to link\n     // everything in explicitly so long as it's actually required.\n-    let last_crate = sess.cstore.crates().len();\n+    let last_crate = tcx.crates().len();\n     let mut ret = (1..last_crate+1).map(|cnum| {\n-        if sess.cstore.dep_kind(CrateNum::new(cnum)) == DepKind::Explicit {\n+        if tcx.dep_kind(CrateNum::new(cnum)) == DepKind::Explicit {\n             Linkage::Static\n         } else {\n             Linkage::NotLinked\n@@ -295,7 +294,7 @@ fn attempt_static<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<DependencyLis\n     // explicitly linked, which is the case for any injected dependency. Handle\n     // that here and activate them.\n     activate_injected_dep(sess.injected_panic_runtime.get(), &mut ret,\n-                          &|cnum| tcx.is_panic_runtime(cnum.as_def_id()));\n+                          &|cnum| tcx.is_panic_runtime(cnum));\n     activate_injected_allocator(sess, &mut ret);\n \n     Some(ret)\n@@ -355,15 +354,15 @@ fn verify_ok<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, list: &[Linkage]) {\n         }\n         let cnum = CrateNum::new(i + 1);\n \n-        if tcx.is_panic_runtime(cnum.as_def_id()) {\n+        if tcx.is_panic_runtime(cnum) {\n             if let Some((prev, _)) = panic_runtime {\n-                let prev_name = sess.cstore.crate_name(prev);\n-                let cur_name = sess.cstore.crate_name(cnum);\n+                let prev_name = tcx.crate_name(prev);\n+                let cur_name = tcx.crate_name(cnum);\n                 sess.err(&format!(\"cannot link together two \\\n                                    panic runtimes: {} and {}\",\n                                   prev_name, cur_name));\n             }\n-            panic_runtime = Some((cnum, sess.cstore.panic_strategy(cnum)));\n+            panic_runtime = Some((cnum, tcx.panic_strategy(cnum)));\n         }\n     }\n \n@@ -379,7 +378,7 @@ fn verify_ok<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, list: &[Linkage]) {\n             sess.err(&format!(\"the linked panic runtime `{}` is \\\n                                not compiled with this crate's \\\n                                panic strategy `{}`\",\n-                              sess.cstore.crate_name(cnum),\n+                              tcx.crate_name(cnum),\n                               desired_strategy.desc()));\n         }\n \n@@ -395,8 +394,8 @@ fn verify_ok<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, list: &[Linkage]) {\n                 continue\n             }\n             let cnum = CrateNum::new(i + 1);\n-            let found_strategy = sess.cstore.panic_strategy(cnum);\n-            let is_compiler_builtins = sess.cstore.is_compiler_builtins(cnum);\n+            let found_strategy = tcx.panic_strategy(cnum);\n+            let is_compiler_builtins = tcx.is_compiler_builtins(cnum);\n             if is_compiler_builtins || desired_strategy == found_strategy {\n                 continue\n             }\n@@ -405,7 +404,7 @@ fn verify_ok<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, list: &[Linkage]) {\n                                panic strategy `{}` which is \\\n                                incompatible with this crate's \\\n                                strategy of `{}`\",\n-                              sess.cstore.crate_name(cnum),\n+                              tcx.crate_name(cnum),\n                               found_strategy.desc(),\n                               desired_strategy.desc()));\n         }"}, {"sha": "b036b145a96e4639f1a488a658e160305a463b51", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -211,9 +211,9 @@ enum OverloadedCallType {\n impl OverloadedCallType {\n     fn from_trait_id(tcx: TyCtxt, trait_id: DefId) -> OverloadedCallType {\n         for &(maybe_function_trait, overloaded_call_type) in &[\n-            (tcx.lang_items.fn_once_trait(), FnOnceOverloadedCall),\n-            (tcx.lang_items.fn_mut_trait(), FnMutOverloadedCall),\n-            (tcx.lang_items.fn_trait(), FnOverloadedCall)\n+            (tcx.lang_items().fn_once_trait(), FnOnceOverloadedCall),\n+            (tcx.lang_items().fn_mut_trait(), FnMutOverloadedCall),\n+            (tcx.lang_items().fn_trait(), FnOverloadedCall)\n         ] {\n             match maybe_function_trait {\n                 Some(function_trait) if function_trait == trait_id => {\n@@ -828,7 +828,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n         let ExprUseVisitor { ref mc, ref mut delegate, param_env } = *self;\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |cmt_pat, pat| {\n-            if let PatKind::Binding(_, def_id, ..) = pat.node {\n+            if let PatKind::Binding(_, canonical_id, ..) = pat.node {\n                 debug!(\"binding cmt_pat={:?} pat={:?} match_mode={:?}\", cmt_pat, pat, match_mode);\n                 let bm = *mc.tables.pat_binding_modes().get(pat.hir_id)\n                                                      .expect(\"missing binding mode\");\n@@ -838,7 +838,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n                 // Each match binding is effectively an assignment to the\n                 // binding being produced.\n-                let def = Def::Local(def_id);\n+                let def = Def::Local(canonical_id);\n                 if let Ok(binding_cmt) = mc.cat_def(pat.id, pat.span, pat_ty, def) {\n                     delegate.mutate(pat.id, pat.span, binding_cmt, MutateMode::Init);\n                 }\n@@ -895,17 +895,16 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n         self.tcx().with_freevars(closure_expr.id, |freevars| {\n             for freevar in freevars {\n-                let var_def_id = freevar.def.def_id();\n-                debug_assert!(var_def_id.is_local());\n+                let var_hir_id = self.tcx().hir.node_to_hir_id(freevar.var_id());\n                 let closure_def_id = self.tcx().hir.local_def_id(closure_expr.id);\n                 let upvar_id = ty::UpvarId {\n-                    var_id: var_def_id.index,\n+                    var_id: var_hir_id,\n                     closure_expr_id: closure_def_id.index\n                 };\n                 let upvar_capture = self.mc.tables.upvar_capture(upvar_id);\n                 let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,\n                                                                    fn_decl_span,\n-                                                                   freevar.def));\n+                                                                   freevar));\n                 match upvar_capture {\n                     ty::UpvarCapture::ByValue => {\n                         let mode = copy_or_move(&self.mc,\n@@ -930,14 +929,13 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     fn cat_captured_var(&mut self,\n                         closure_id: ast::NodeId,\n                         closure_span: Span,\n-                        upvar_def: Def)\n+                        upvar: &hir::Freevar)\n                         -> mc::McResult<mc::cmt<'tcx>> {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective\n-        let var_node_id = self.tcx().hir.as_local_node_id(upvar_def.def_id()).unwrap();\n-        let var_hir_id = self.tcx().hir.node_to_hir_id(var_node_id);\n+        let var_hir_id = self.tcx().hir.node_to_hir_id(upvar.var_id());\n         let var_ty = self.mc.node_ty(var_hir_id)?;\n-        self.mc.cat_def(closure_id, closure_span, var_ty, upvar_def)\n+        self.mc.cat_def(closure_id, closure_span, var_ty, upvar.def)\n     }\n }\n "}, {"sha": "4de86b669160eb03736d17c98f3b2cc6bb2163ec", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -147,7 +147,8 @@ impl<'tcx> FreeRegionMap<'tcx> {\n                 ty::Predicate::WellFormed(..) |\n                 ty::Predicate::ObjectSafe(..) |\n                 ty::Predicate::ClosureKind(..) |\n-                ty::Predicate::TypeOutlives(..) => {\n+                ty::Predicate::TypeOutlives(..) |\n+                ty::Predicate::ConstEvaluatable(..) => {\n                     // No region bounds here\n                 }\n                 ty::Predicate::RegionOutlives(ty::Binder(ty::OutlivesPredicate(r_a, r_b))) => {"}, {"sha": "da9f9128cf4cef6b4bbe8b2be146f9b62f9e9244", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 41, "deletions": 90, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -21,10 +21,8 @@\n \n pub use self::LangItem::*;\n \n-use hir::map as hir_map;\n-use session::Session;\n use hir::def_id::DefId;\n-use ty;\n+use ty::{self, TyCtxt};\n use middle::weak_lang_items;\n use util::nodemap::FxHashMap;\n \n@@ -48,6 +46,14 @@ enum_from_u32! {\n     }\n }\n \n+impl LangItem {\n+    fn name(self) -> &'static str {\n+        match self {\n+            $( $variant => $name, )*\n+        }\n+    }\n+}\n+\n pub struct LanguageItems {\n     pub items: Vec<Option<DefId>>,\n     pub missing: Vec<LangItem>,\n@@ -67,42 +73,17 @@ impl LanguageItems {\n         &*self.items\n     }\n \n-    pub fn item_name(index: usize) -> &'static str {\n-        let item: Option<LangItem> = LangItem::from_u32(index as u32);\n-        match item {\n-            $( Some($variant) => $name, )*\n-            None => \"???\"\n-        }\n-    }\n-\n     pub fn require(&self, it: LangItem) -> Result<DefId, String> {\n-        match self.items[it as usize] {\n-            Some(id) => Ok(id),\n-            None => {\n-                Err(format!(\"requires `{}` lang_item\",\n-                            LanguageItems::item_name(it as usize)))\n-            }\n-        }\n-    }\n-\n-    pub fn require_owned_box(&self) -> Result<DefId, String> {\n-        self.require(OwnedBoxLangItem)\n+        self.items[it as usize].ok_or_else(|| format!(\"requires `{}` lang_item\", it.name()))\n     }\n \n     pub fn fn_trait_kind(&self, id: DefId) -> Option<ty::ClosureKind> {\n-        let def_id_kinds = [\n-            (self.fn_trait(), ty::ClosureKind::Fn),\n-            (self.fn_mut_trait(), ty::ClosureKind::FnMut),\n-            (self.fn_once_trait(), ty::ClosureKind::FnOnce),\n-            ];\n-\n-        for &(opt_def_id, kind) in &def_id_kinds {\n-            if Some(id) == opt_def_id {\n-                return Some(kind);\n-            }\n+        match Some(id) {\n+            x if x == self.fn_trait() => Some(ty::ClosureKind::Fn),\n+            x if x == self.fn_mut_trait() => Some(ty::ClosureKind::FnMut),\n+            x if x == self.fn_once_trait() => Some(ty::ClosureKind::FnOnce),\n+            _ => None\n         }\n-\n-        None\n     }\n \n     $(\n@@ -116,9 +97,7 @@ impl LanguageItems {\n struct LanguageItemCollector<'a, 'tcx: 'a> {\n     items: LanguageItems,\n \n-    hir_map: &'a hir_map::Map<'tcx>,\n-\n-    session: &'a Session,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     item_refs: FxHashMap<&'static str, usize>,\n }\n@@ -129,10 +108,11 @@ impl<'a, 'v, 'tcx> ItemLikeVisitor<'v> for LanguageItemCollector<'a, 'tcx> {\n             let item_index = self.item_refs.get(&*value.as_str()).cloned();\n \n             if let Some(item_index) = item_index {\n-                self.collect_item(item_index, self.hir_map.local_def_id(item.id))\n+                let def_id = self.tcx.hir.local_def_id(item.id);\n+                self.collect_item(item_index, def_id);\n             } else {\n-                let span = self.hir_map.span(item.id);\n-                span_err!(self.session, span, E0522,\n+                let span = self.tcx.hir.span(item.id);\n+                span_err!(self.tcx.sess, span, E0522,\n                           \"definition of an unknown language item: `{}`.\",\n                           value);\n             }\n@@ -149,45 +129,41 @@ impl<'a, 'v, 'tcx> ItemLikeVisitor<'v> for LanguageItemCollector<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n-    pub fn new(session: &'a Session, hir_map: &'a hir_map::Map<'tcx>)\n-               -> LanguageItemCollector<'a, 'tcx> {\n+    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> LanguageItemCollector<'a, 'tcx> {\n         let mut item_refs = FxHashMap();\n \n         $( item_refs.insert($name, $variant as usize); )*\n \n         LanguageItemCollector {\n-            session,\n-            hir_map,\n+            tcx,\n             items: LanguageItems::new(),\n             item_refs,\n         }\n     }\n \n-    pub fn collect_item(&mut self, item_index: usize,\n-                        item_def_id: DefId) {\n+    fn collect_item(&mut self, item_index: usize, item_def_id: DefId) {\n         // Check for duplicates.\n         match self.items.items[item_index] {\n             Some(original_def_id) if original_def_id != item_def_id => {\n-                let cstore = &self.session.cstore;\n-                let name = LanguageItems::item_name(item_index);\n-                let mut err = match self.hir_map.span_if_local(item_def_id) {\n+                let name = LangItem::from_u32(item_index as u32).unwrap().name();\n+                let mut err = match self.tcx.hir.span_if_local(item_def_id) {\n                     Some(span) => struct_span_err!(\n-                        self.session,\n+                        self.tcx.sess,\n                         span,\n                         E0152,\n                         \"duplicate lang item found: `{}`.\",\n                         name),\n-                    None => self.session.struct_err(&format!(\n+                    None => self.tcx.sess.struct_err(&format!(\n                             \"duplicate lang item in crate `{}`: `{}`.\",\n-                            cstore.crate_name(item_def_id.krate),\n+                            self.tcx.crate_name(item_def_id.krate),\n                             name)),\n                 };\n-                if let Some(span) = self.hir_map.span_if_local(original_def_id) {\n+                if let Some(span) = self.tcx.hir.span_if_local(original_def_id) {\n                     span_note!(&mut err, span,\n                                \"first defined here.\");\n                 } else {\n                     err.note(&format!(\"first defined in crate `{}`.\",\n-                                      cstore.crate_name(original_def_id.krate)));\n+                                      self.tcx.crate_name(original_def_id.krate)));\n                 }\n                 err.emit();\n             }\n@@ -199,26 +175,6 @@ impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n         // Matched.\n         self.items.items[item_index] = Some(item_def_id);\n     }\n-\n-    pub fn collect_local_language_items(&mut self, krate: &hir::Crate) {\n-        krate.visit_all_item_likes(self);\n-    }\n-\n-    pub fn collect_external_language_items(&mut self) {\n-        let cstore = &self.session.cstore;\n-\n-        for cnum in cstore.crates() {\n-            for (index, item_index) in cstore.lang_items(cnum) {\n-                let def_id = DefId { krate: cnum, index: index };\n-                self.collect_item(item_index, def_id);\n-            }\n-        }\n-    }\n-\n-    pub fn collect(&mut self, krate: &hir::Crate) {\n-        self.collect_external_language_items();\n-        self.collect_local_language_items(krate);\n-    }\n }\n \n pub fn extract(attrs: &[ast::Attribute]) -> Option<Symbol> {\n@@ -233,14 +189,17 @@ pub fn extract(attrs: &[ast::Attribute]) -> Option<Symbol> {\n     return None;\n }\n \n-pub fn collect_language_items(session: &Session,\n-                              map: &hir_map::Map)\n-                              -> LanguageItems {\n-    let krate: &hir::Crate = map.krate();\n-    let mut collector = LanguageItemCollector::new(session, map);\n-    collector.collect(krate);\n+pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> LanguageItems {\n+    let mut collector = LanguageItemCollector::new(tcx);\n+    for &cnum in tcx.crates().iter() {\n+        for &(index, item_index) in tcx.defined_lang_items(cnum).iter() {\n+            let def_id = DefId { krate: cnum, index: index };\n+            collector.collect_item(item_index, def_id);\n+        }\n+    }\n+    tcx.hir.krate().visit_all_item_likes(&mut collector);\n     let LanguageItemCollector { mut items, .. } = collector;\n-    weak_lang_items::check_crate(krate, session, &mut items);\n+    weak_lang_items::check_crate(tcx, &mut items);\n     items\n }\n \n@@ -351,22 +310,14 @@ language_item_table! {\n \n     PhantomDataItem,                 \"phantom_data\",            phantom_data;\n \n-    // Deprecated:\n-    CovariantTypeItem,               \"covariant_type\",          covariant_type;\n-    ContravariantTypeItem,           \"contravariant_type\",      contravariant_type;\n-    InvariantTypeItem,               \"invariant_type\",          invariant_type;\n-    CovariantLifetimeItem,           \"covariant_lifetime\",      covariant_lifetime;\n-    ContravariantLifetimeItem,       \"contravariant_lifetime\",  contravariant_lifetime;\n-    InvariantLifetimeItem,           \"invariant_lifetime\",      invariant_lifetime;\n-\n     NonZeroItem,                     \"non_zero\",                non_zero;\n \n     DebugTraitLangItem,              \"debug_trait\",             debug_trait;\n }\n \n impl<'a, 'tcx, 'gcx> ty::TyCtxt<'a, 'tcx, 'gcx> {\n     pub fn require_lang_item(&self, lang_item: LangItem) -> DefId {\n-        self.lang_items.require(lang_item).unwrap_or_else(|msg| {\n+        self.lang_items().require(lang_item).unwrap_or_else(|msg| {\n             self.sess.fatal(&msg)\n         })\n     }"}, {"sha": "80beaaed051dbff558f9cef84d70159ae3ad2205", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -429,8 +429,7 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n         let mut call_caps = Vec::new();\n         ir.tcx.with_freevars(expr.id, |freevars| {\n             for fv in freevars {\n-                if let Def::Local(def_id) = fv.def {\n-                    let rv = ir.tcx.hir.as_local_node_id(def_id).unwrap();\n+                if let Def::Local(rv) = fv.def {\n                     let fv_ln = ir.add_live_node(FreeVarNode(fv.span));\n                     call_caps.push(CaptureInfo {ln: fv_ln,\n                                                 var_nid: rv});\n@@ -1238,8 +1237,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn access_path(&mut self, id: NodeId, path: &hir::Path, succ: LiveNode, acc: u32)\n                    -> LiveNode {\n         match path.def {\n-          Def::Local(def_id) => {\n-            let nid = self.ir.tcx.hir.as_local_node_id(def_id).unwrap();\n+          Def::Local(nid) => {\n             self.access_var(id, nid, succ, acc, path.span)\n           }\n           _ => succ\n@@ -1414,12 +1412,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn check_lvalue(&mut self, expr: &'tcx Expr) {\n         match expr.node {\n             hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n-                if let Def::Local(def_id) = path.def {\n+                if let Def::Local(nid) = path.def {\n                     // Assignment to an immutable variable or argument: only legal\n                     // if there is no later assignment. If this local is actually\n                     // mutable, then check for a reassignment to flag the mutability\n                     // as being used.\n-                    let nid = self.ir.tcx.hir.as_local_node_id(def_id).unwrap();\n                     let ln = self.live_node(expr.id, expr.span);\n                     let var = self.variable(nid, expr.span);\n                     self.warn_about_dead_assign(expr.span, expr.id, ln, var);"}, {"sha": "5102b41598d6fcd6ee6ace871efbe8fb98e870a5", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -670,13 +670,11 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n               }))\n           }\n \n-          Def::Upvar(def_id, _, fn_node_id) => {\n-              let var_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n+          Def::Upvar(var_id, _, fn_node_id) => {\n               self.cat_upvar(id, span, var_id, fn_node_id)\n           }\n \n-          Def::Local(def_id) => {\n-            let vid = self.tcx.hir.as_local_node_id(def_id).unwrap();\n+          Def::Local(vid) => {\n             Ok(Rc::new(cmt_ {\n                 id,\n                 span,\n@@ -736,13 +734,12 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         };\n \n         let closure_expr_def_index = self.tcx.hir.local_def_id(fn_node_id).index;\n-        let var_def_index = self.tcx.hir.local_def_id(var_id).index;\n-\n+        let var_hir_id = self.tcx.hir.node_to_hir_id(var_id);\n         let upvar_id = ty::UpvarId {\n-            var_id: var_def_index,\n+            var_id: var_hir_id,\n             closure_expr_id: closure_expr_def_index\n         };\n-        let var_hir_id = self.tcx.hir.node_to_hir_id(var_id);\n+\n         let var_ty = self.node_ty(var_hir_id)?;\n \n         // Mutability of original variable itself\n@@ -879,7 +876,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         // Always promote `[T; 0]` (even when e.g. borrowed mutably).\n         let promotable = match expr_ty.sty {\n-            ty::TyArray(_, 0) => true,\n+            ty::TyArray(_, len) if\n+                len.val.to_const_int().and_then(|i| i.to_u64()) == Some(0) => true,\n             _ => promotable,\n         };\n \n@@ -1441,7 +1439,7 @@ impl<'tcx> fmt::Debug for Categorization<'tcx> {\n             Categorization::StaticItem => write!(f, \"static\"),\n             Categorization::Rvalue(r) => { write!(f, \"rvalue({:?})\", r) }\n             Categorization::Local(id) => {\n-               let name = ty::tls::with(|tcx| tcx.local_var_name_str(id));\n+               let name = ty::tls::with(|tcx| tcx.hir.name(id));\n                write!(f, \"local({})\", name)\n             }\n             Categorization::Upvar(upvar) => {"}, {"sha": "d3e34c851f3d644aa963e9c0d35d499ce97ead1f", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -115,28 +115,34 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n             _ => None\n         };\n \n-        if let Some(def) = def {\n-            let def_id = def.def_id();\n-            if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n-                if self.def_id_represents_local_inlined_item(def_id) {\n-                    self.worklist.push(node_id);\n-                } else {\n-                    match def {\n-                        // If this path leads to a constant, then we need to\n-                        // recurse into the constant to continue finding\n-                        // items that are reachable.\n-                        Def::Const(..) | Def::AssociatedConst(..) => {\n-                            self.worklist.push(node_id);\n-                        }\n+        match def {\n+            Some(Def::Local(node_id)) | Some(Def::Upvar(node_id, ..)) => {\n+                self.reachable_symbols.insert(node_id);\n+            }\n+            Some(def) => {\n+                let def_id = def.def_id();\n+                if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n+                    if self.def_id_represents_local_inlined_item(def_id) {\n+                        self.worklist.push(node_id);\n+                    } else {\n+                        match def {\n+                            // If this path leads to a constant, then we need to\n+                            // recurse into the constant to continue finding\n+                            // items that are reachable.\n+                            Def::Const(..) | Def::AssociatedConst(..) => {\n+                                self.worklist.push(node_id);\n+                            }\n \n-                        // If this wasn't a static, then the destination is\n-                        // surely reachable.\n-                        _ => {\n-                            self.reachable_symbols.insert(node_id);\n+                            // If this wasn't a static, then the destination is\n+                            // surely reachable.\n+                            _ => {\n+                                self.reachable_symbols.insert(node_id);\n+                            }\n                         }\n                     }\n                 }\n             }\n+            _ => {}\n         }\n \n         intravisit::walk_expr(self, expr)\n@@ -392,7 +398,7 @@ fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) ->\n     for (id, _) in &access_levels.map {\n         reachable_context.worklist.push(*id);\n     }\n-    for item in tcx.lang_items.items().iter() {\n+    for item in tcx.lang_items().items().iter() {\n         if let Some(did) = *item {\n             if let Some(node_id) = tcx.hir.as_local_node_id(did) {\n                 reachable_context.worklist.push(node_id);"}, {"sha": "657c30289ebb5906ed85605c5177007e64e855d1", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -16,9 +16,10 @@\n //! way. Therefore we break lifetime name resolution into a separate pass.\n \n use hir::map::Map;\n-use session::Session;\n use hir::def::Def;\n use hir::def_id::DefId;\n+use middle::cstore::CrateStore;\n+use session::Session;\n use ty;\n \n use std::cell::Cell;\n@@ -160,6 +161,7 @@ pub struct NamedRegionMap {\n \n struct LifetimeContext<'a, 'tcx: 'a> {\n     sess: &'a Session,\n+    cstore: &'a CrateStore,\n     hir_map: &'a Map<'tcx>,\n     map: &'a mut NamedRegionMap,\n     scope: ScopeRef<'a>,\n@@ -251,6 +253,7 @@ type ScopeRef<'a> = &'a Scope<'a>;\n const ROOT_SCOPE: ScopeRef<'static> = &Scope::Root;\n \n pub fn krate(sess: &Session,\n+             cstore: &CrateStore,\n              hir_map: &Map)\n              -> Result<NamedRegionMap, ErrorReported> {\n     let krate = hir_map.krate();\n@@ -262,6 +265,7 @@ pub fn krate(sess: &Session,\n     sess.track_errors(|| {\n         let mut visitor = LifetimeContext {\n             sess,\n+            cstore,\n             hir_map,\n             map: &mut map,\n             scope: ROOT_SCOPE,\n@@ -765,12 +769,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     fn with<F>(&mut self, wrap_scope: Scope, f: F) where\n         F: for<'b> FnOnce(ScopeRef, &mut LifetimeContext<'b, 'tcx>),\n     {\n-        let LifetimeContext {sess, hir_map, ref mut map, ..} = *self;\n+        let LifetimeContext {sess, cstore, hir_map, ref mut map, ..} = *self;\n         let labels_in_fn = replace(&mut self.labels_in_fn, vec![]);\n         let xcrate_object_lifetime_defaults =\n             replace(&mut self.xcrate_object_lifetime_defaults, DefIdMap());\n         let mut this = LifetimeContext {\n             sess,\n+            cstore,\n             hir_map,\n             map: *map,\n             scope: &wrap_scope,\n@@ -932,7 +937,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             let def_key = if def_id.is_local() {\n                 this.hir_map.def_key(def_id)\n             } else {\n-                this.sess.cstore.def_key(def_id)\n+                this.cstore.def_key(def_id)\n             };\n             DefId {\n                 krate: def_id.krate,\n@@ -976,9 +981,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             let unsubst = if let Some(id) = self.hir_map.as_local_node_id(def_id) {\n                 &map.object_lifetime_defaults[&id]\n             } else {\n-                let cstore = &self.sess.cstore;\n+                let cstore = self.cstore;\n                 self.xcrate_object_lifetime_defaults.entry(def_id).or_insert_with(|| {\n-                    cstore.item_generics_cloned(def_id).types.into_iter().map(|def| {\n+                    cstore.item_generics_cloned_untracked(def_id).types.into_iter().map(|def| {\n                         def.object_lifetime_default\n                     }).collect()\n                 })"}, {"sha": "5ca235b2ad3ec538fee18d5f65a94ce5ff667764", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 105, "deletions": 147, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -15,20 +15,19 @@ pub use self::StabilityLevel::*;\n \n use lint;\n use hir::def::Def;\n-use hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, DefIndex, LOCAL_CRATE};\n+use hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, LOCAL_CRATE};\n use ty::{self, TyCtxt};\n use middle::privacy::AccessLevels;\n-use session::Session;\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, DUMMY_SP};\n use syntax::ast;\n use syntax::ast::{NodeId, Attribute};\n use syntax::feature_gate::{GateIssue, emit_feature_err, find_lang_feature_accepted_version};\n use syntax::attr::{self, Stability, Deprecation};\n-use util::nodemap::{DefIdMap, FxHashSet, FxHashMap};\n+use util::nodemap::{FxHashSet, FxHashMap};\n \n use hir;\n-use hir::{Item, Generics, StructField, Variant};\n+use hir::{Item, Generics, StructField, Variant, HirId};\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n \n use std::mem::replace;\n@@ -63,19 +62,18 @@ pub struct DeprecationEntry {\n     pub attr: Deprecation,\n     /// The def id where the attr was originally attached. `None` for non-local\n     /// `DefId`'s.\n-    origin: Option<DefIndex>,\n+    origin: Option<HirId>,\n }\n \n impl DeprecationEntry {\n-    fn local(attr: Deprecation, id: DefId) -> DeprecationEntry {\n-        assert!(id.is_local());\n+    fn local(attr: Deprecation, id: HirId) -> DeprecationEntry {\n         DeprecationEntry {\n             attr,\n-            origin: Some(id.index),\n+            origin: Some(id),\n         }\n     }\n \n-    fn external(attr: Deprecation) -> DeprecationEntry {\n+    pub fn external(attr: Deprecation) -> DeprecationEntry {\n         DeprecationEntry {\n             attr,\n             origin: None,\n@@ -94,17 +92,14 @@ impl DeprecationEntry {\n pub struct Index<'tcx> {\n     /// This is mostly a cache, except the stabilities of local items\n     /// are filled by the annotator.\n-    stab_map: DefIdMap<Option<&'tcx Stability>>,\n-    depr_map: DefIdMap<Option<DeprecationEntry>>,\n+    stab_map: FxHashMap<HirId, &'tcx Stability>,\n+    depr_map: FxHashMap<HirId, DeprecationEntry>,\n \n     /// Maps for each crate whether it is part of the staged API.\n     staged_api: FxHashMap<CrateNum, bool>,\n \n     /// Features enabled for this crate.\n     active_features: FxHashSet<Symbol>,\n-\n-    /// Features used by this crate. Updated before and during typeck.\n-    used_features: FxHashMap<Symbol, attr::StabilityLevel>\n }\n \n // A private tree-walker for producing an Index.\n@@ -178,8 +173,8 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                     }\n                 }\n \n-                let def_id = self.tcx.hir.local_def_id(id);\n-                self.index.stab_map.insert(def_id, Some(stab));\n+                let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                self.index.stab_map.insert(hir_id, stab);\n \n                 let orig_parent_stab = replace(&mut self.parent_stab, Some(stab));\n                 visit_children(self);\n@@ -188,8 +183,8 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                 debug!(\"annotate: not found, parent = {:?}\", self.parent_stab);\n                 if let Some(stab) = self.parent_stab {\n                     if stab.level.is_unstable() {\n-                        let def_id = self.tcx.hir.local_def_id(id);\n-                        self.index.stab_map.insert(def_id, Some(stab));\n+                        let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                        self.index.stab_map.insert(hir_id, stab);\n                     }\n                 }\n                 visit_children(self);\n@@ -209,8 +204,8 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n             // -Zforce-unstable-if-unmarked is set.\n             if let Some(stab) = self.parent_stab {\n                 if stab.level.is_unstable() {\n-                    let def_id = self.tcx.hir.local_def_id(id);\n-                    self.index.stab_map.insert(def_id, Some(stab));\n+                    let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                    self.index.stab_map.insert(hir_id, stab);\n                 }\n             }\n \n@@ -220,16 +215,17 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                 }\n \n                 // `Deprecation` is just two pointers, no need to intern it\n-                let def_id = self.tcx.hir.local_def_id(id);\n-                let depr_entry = Some(DeprecationEntry::local(depr, def_id));\n-                self.index.depr_map.insert(def_id, depr_entry.clone());\n+                let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                let depr_entry = DeprecationEntry::local(depr, hir_id);\n+                self.index.depr_map.insert(hir_id, depr_entry.clone());\n \n-                let orig_parent_depr = replace(&mut self.parent_depr, depr_entry);\n+                let orig_parent_depr = replace(&mut self.parent_depr,\n+                                               Some(depr_entry));\n                 visit_children(self);\n                 self.parent_depr = orig_parent_depr;\n-            } else if let parent_depr @ Some(_) = self.parent_depr.clone() {\n-                let def_id = self.tcx.hir.local_def_id(id);\n-                self.index.depr_map.insert(def_id, parent_depr);\n+            } else if let Some(parent_depr) = self.parent_depr.clone() {\n+                let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                self.index.depr_map.insert(hir_id, parent_depr);\n                 visit_children(self);\n             } else {\n                 visit_children(self);\n@@ -322,10 +318,10 @@ struct MissingStabilityAnnotations<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx: 'a> MissingStabilityAnnotations<'a, 'tcx> {\n     fn check_missing_stability(&self, id: NodeId, span: Span) {\n-        let def_id = self.tcx.hir.local_def_id(id);\n-        let stab = self.tcx.stability.borrow().stab_map.get(&def_id).cloned();\n+        let hir_id = self.tcx.hir.node_to_hir_id(id);\n+        let stab = self.tcx.stability().local_stability(hir_id);\n         let is_error = !self.tcx.sess.opts.test &&\n-                        (stab == None || stab == Some(None)) &&\n+                        stab.is_none() &&\n                         self.access_levels.is_reachable(id);\n         if is_error {\n             self.tcx.sess.span_err(span, \"This node does not have a stability attribute\");\n@@ -386,60 +382,70 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Index<'tcx> {\n-    /// Construct the stability index for a crate being compiled.\n-    pub fn build(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Index<'tcx> {\n+        let is_staged_api =\n+            tcx.sess.opts.debugging_opts.force_unstable_if_unmarked ||\n+            tcx.sess.features.borrow().staged_api;\n+        let mut staged_api = FxHashMap();\n+        staged_api.insert(LOCAL_CRATE, is_staged_api);\n+        let mut index = Index {\n+            staged_api,\n+            stab_map: FxHashMap(),\n+            depr_map: FxHashMap(),\n+            active_features: FxHashSet(),\n+        };\n+\n         let ref active_lib_features = tcx.sess.features.borrow().declared_lib_features;\n \n         // Put the active features into a map for quick lookup\n-        self.active_features = active_lib_features.iter().map(|&(ref s, _)| s.clone()).collect();\n+        index.active_features = active_lib_features.iter().map(|&(ref s, _)| s.clone()).collect();\n+\n+        {\n+            let krate = tcx.hir.krate();\n+            let mut annotator = Annotator {\n+                tcx,\n+                index: &mut index,\n+                parent_stab: None,\n+                parent_depr: None,\n+                in_trait_impl: false,\n+            };\n \n-        let krate = tcx.hir.krate();\n-        let mut annotator = Annotator {\n-            tcx,\n-            index: self,\n-            parent_stab: None,\n-            parent_depr: None,\n-            in_trait_impl: false,\n-        };\n+            // If the `-Z force-unstable-if-unmarked` flag is passed then we provide\n+            // a parent stability annotation which indicates that this is private\n+            // with the `rustc_private` feature. This is intended for use when\n+            // compiling librustc crates themselves so we can leverage crates.io\n+            // while maintaining the invariant that all sysroot crates are unstable\n+            // by default and are unable to be used.\n+            if tcx.sess.opts.debugging_opts.force_unstable_if_unmarked {\n+                let reason = \"this crate is being loaded from the sysroot, and \\\n+                              unstable location; did you mean to load this crate \\\n+                              from crates.io via `Cargo.toml` instead?\";\n+                let stability = tcx.intern_stability(Stability {\n+                    level: attr::StabilityLevel::Unstable {\n+                        reason: Some(Symbol::intern(reason)),\n+                        issue: 27812,\n+                    },\n+                    feature: Symbol::intern(\"rustc_private\"),\n+                    rustc_depr: None,\n+                });\n+                annotator.parent_stab = Some(stability);\n+            }\n \n-        // If the `-Z force-unstable-if-unmarked` flag is passed then we provide\n-        // a parent stability annotation which indicates that this is private\n-        // with the `rustc_private` feature. This is intended for use when\n-        // compiling librustc crates themselves so we can leverage crates.io\n-        // while maintaining the invariant that all sysroot crates are unstable\n-        // by default and are unable to be used.\n-        if tcx.sess.opts.debugging_opts.force_unstable_if_unmarked {\n-            let reason = \"this crate is being loaded from the sysroot, and \\\n-                          unstable location; did you mean to load this crate \\\n-                          from crates.io via `Cargo.toml` instead?\";\n-            let stability = tcx.intern_stability(Stability {\n-                level: attr::StabilityLevel::Unstable {\n-                    reason: Some(Symbol::intern(reason)),\n-                    issue: 27812,\n-                },\n-                feature: Symbol::intern(\"rustc_private\"),\n-                rustc_depr: None,\n-            });\n-            annotator.parent_stab = Some(stability);\n+            annotator.annotate(ast::CRATE_NODE_ID,\n+                               &krate.attrs,\n+                               krate.span,\n+                               AnnotationKind::Required,\n+                               |v| intravisit::walk_crate(v, krate));\n         }\n+        return index\n+    }\n \n-        annotator.annotate(ast::CRATE_NODE_ID, &krate.attrs, krate.span, AnnotationKind::Required,\n-                           |v| intravisit::walk_crate(v, krate));\n+    pub fn local_stability(&self, id: HirId) -> Option<&'tcx Stability> {\n+        self.stab_map.get(&id).cloned()\n     }\n \n-    pub fn new(sess: &Session) -> Index<'tcx> {\n-        let is_staged_api =\n-            sess.opts.debugging_opts.force_unstable_if_unmarked ||\n-            sess.features.borrow().staged_api;\n-        let mut staged_api = FxHashMap();\n-        staged_api.insert(LOCAL_CRATE, is_staged_api);\n-        Index {\n-            staged_api,\n-            stab_map: DefIdMap(),\n-            depr_map: DefIdMap(),\n-            active_features: FxHashSet(),\n-            used_features: FxHashMap(),\n-        }\n+    pub fn local_deprecation_entry(&self, id: HirId) -> Option<DeprecationEntry> {\n+        self.depr_map.get(&id).cloned()\n     }\n }\n \n@@ -476,7 +482,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             _ => {}\n         }\n \n-        let visibility = self.sess.cstore.visibility(def_id);\n+        let visibility = self.visibility(def_id);\n \n         match visibility {\n             // must check stability for pub items.\n@@ -547,18 +553,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             return\n         }\n \n-        if let Some(&Stability { ref level, ref feature, .. }) = stability {\n-            self.stability.borrow_mut().used_features.insert(feature.clone(), level.clone());\n-        }\n-\n         // Issue 38412: private items lack stability markers.\n         if self.skip_stability_check_due_to_privacy(def_id) {\n             return\n         }\n \n         match stability {\n             Some(&Stability { level: attr::Unstable {ref reason, issue}, ref feature, .. }) => {\n-                if self.stability.borrow().active_features.contains(feature) {\n+                if self.stability().active_features.contains(feature) {\n                     return\n                 }\n \n@@ -610,7 +612,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 // compiler-generated `extern crate` items have a dummy span.\n                 if item.span == DUMMY_SP { return }\n \n-                let cnum = match self.tcx.sess.cstore.extern_mod_stmt_cnum(item.id) {\n+                let def_id = self.tcx.hir.local_def_id(item.id);\n+                let cnum = match self.tcx.extern_mod_stmt_cnum(def_id) {\n                     Some(cnum) => cnum,\n                     None => return,\n                 };\n@@ -663,6 +666,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n \n     fn visit_path(&mut self, path: &'tcx hir::Path, id: ast::NodeId) {\n         match path.def {\n+            Def::Local(..) | Def::Upvar(..) |\n             Def::PrimTy(..) | Def::SelfTy(..) | Def::Err => {}\n             _ => self.tcx.check_stability(path.def.def_id(), id, path.span)\n         }\n@@ -671,49 +675,9 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    /// Lookup the stability for a node, loading external crate\n-    /// metadata as necessary.\n-    pub fn lookup_stability(self, id: DefId) -> Option<&'gcx Stability> {\n-        if let Some(st) = self.stability.borrow().stab_map.get(&id) {\n-            return *st;\n-        }\n-\n-        let st = self.lookup_stability_uncached(id);\n-        self.stability.borrow_mut().stab_map.insert(id, st);\n-        st\n-    }\n-\n     pub fn lookup_deprecation(self, id: DefId) -> Option<Deprecation> {\n         self.lookup_deprecation_entry(id).map(|depr| depr.attr)\n     }\n-\n-    pub fn lookup_deprecation_entry(self, id: DefId) -> Option<DeprecationEntry> {\n-        if let Some(depr) = self.stability.borrow().depr_map.get(&id) {\n-            return depr.clone();\n-        }\n-\n-        let depr = self.lookup_deprecation_uncached(id);\n-        self.stability.borrow_mut().depr_map.insert(id, depr.clone());\n-        depr\n-    }\n-\n-    fn lookup_stability_uncached(self, id: DefId) -> Option<&'gcx Stability> {\n-        debug!(\"lookup(id={:?})\", id);\n-        if id.is_local() {\n-            None // The stability cache is filled partially lazily\n-        } else {\n-            self.stability(id).map(|st| self.intern_stability(st))\n-        }\n-    }\n-\n-    fn lookup_deprecation_uncached(self, id: DefId) -> Option<DeprecationEntry> {\n-        debug!(\"lookup(id={:?})\", id);\n-        if id.is_local() {\n-            None // The stability cache is filled partially lazily\n-        } else {\n-            self.deprecation(id).map(DeprecationEntry::external)\n-        }\n-    }\n }\n \n /// Given the list of enabled features that were not language features (i.e. that\n@@ -724,7 +688,7 @@ pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n \n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n \n-    if tcx.stability.borrow().staged_api[&LOCAL_CRATE] {\n+    if tcx.stability().staged_api[&LOCAL_CRATE] {\n         let krate = tcx.hir.krate();\n         let mut missing = MissingStabilityAnnotations {\n             tcx,\n@@ -740,10 +704,6 @@ pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         = declared_lib_features.clone().into_iter().collect();\n     remaining_lib_features.remove(&Symbol::intern(\"proc_macro\"));\n \n-    fn format_stable_since_msg(version: &str) -> String {\n-        format!(\"this feature has been stable since {}. Attribute no longer needed\", version)\n-    }\n-\n     for &(ref stable_lang_feature, span) in &sess.features.borrow().declared_stable_lang_features {\n         let version = find_lang_feature_accepted_version(&stable_lang_feature.as_str())\n             .expect(\"unexpectedly couldn't find version feature was stabilized\");\n@@ -753,25 +713,23 @@ pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n                       &format_stable_since_msg(version));\n     }\n \n-    let index = tcx.stability.borrow();\n-    for (used_lib_feature, level) in &index.used_features {\n-        match remaining_lib_features.remove(used_lib_feature) {\n-            Some(span) => {\n-                if let &attr::StabilityLevel::Stable { since: ref version } = level {\n-                    tcx.lint_node(lint::builtin::STABLE_FEATURES,\n-                                  ast::CRATE_NODE_ID,\n-                                  span,\n-                                  &format_stable_since_msg(&version.as_str()));\n-                }\n-            }\n-            None => ( /* used but undeclared, handled during the previous ast visit */ )\n-        }\n-    }\n+    // FIXME(#44232) the `used_features` table no longer exists, so we don't\n+    //               lint about unknown or unused features. We should reenable\n+    //               this one day!\n+    //\n+    // let index = tcx.stability();\n+    // for (used_lib_feature, level) in &index.used_features {\n+    //     remaining_lib_features.remove(used_lib_feature);\n+    // }\n+    //\n+    // for &span in remaining_lib_features.values() {\n+    //     tcx.lint_node(lint::builtin::UNUSED_FEATURES,\n+    //                   ast::CRATE_NODE_ID,\n+    //                   span,\n+    //                   \"unused or unknown feature\");\n+    // }\n+}\n \n-    for &span in remaining_lib_features.values() {\n-        tcx.lint_node(lint::builtin::UNUSED_FEATURES,\n-                      ast::CRATE_NODE_ID,\n-                      span,\n-                      \"unused or unknown feature\");\n-    }\n+fn format_stable_since_msg(version: &str) -> String {\n+    format!(\"this feature has been stable since {}. Attribute no longer needed\", version)\n }"}, {"sha": "50fb584070262f9f5e9c5a58c84486109085f453", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -11,7 +11,6 @@\n //! Validity checking for weak lang items\n \n use session::config;\n-use session::Session;\n use middle::lang_items;\n \n use rustc_back::PanicStrategy;\n@@ -21,38 +20,38 @@ use syntax_pos::Span;\n use hir::intravisit::{Visitor, NestedVisitorMap};\n use hir::intravisit;\n use hir;\n+use ty::TyCtxt;\n \n use std::collections::HashSet;\n \n macro_rules! weak_lang_items {\n     ($($name:ident, $item:ident, $sym:ident;)*) => (\n \n-struct Context<'a> {\n-    sess: &'a Session,\n+struct Context<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     items: &'a mut lang_items::LanguageItems,\n }\n \n /// Checks the crate for usage of weak lang items, returning a vector of all the\n /// language items required by this crate, but not defined yet.\n-pub fn check_crate(krate: &hir::Crate,\n-                   sess: &Session,\n-                   items: &mut lang_items::LanguageItems) {\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             items: &mut lang_items::LanguageItems) {\n     // These are never called by user code, they're generated by the compiler.\n     // They will never implicitly be added to the `missing` array unless we do\n     // so here.\n     if items.eh_personality().is_none() {\n         items.missing.push(lang_items::EhPersonalityLangItem);\n     }\n-    if sess.target.target.options.custom_unwind_resume &\n+    if tcx.sess.target.target.options.custom_unwind_resume &\n        items.eh_unwind_resume().is_none() {\n         items.missing.push(lang_items::EhUnwindResumeLangItem);\n     }\n \n     {\n-        let mut cx = Context { sess: sess, items: items };\n-        krate.visit_all_item_likes(&mut cx.as_deep_visitor());\n+        let mut cx = Context { tcx, items };\n+        tcx.hir.krate().visit_all_item_likes(&mut cx.as_deep_visitor());\n     }\n-    verify(sess, items);\n+    verify(tcx, items);\n }\n \n pub fn link_name(attrs: &[ast::Attribute]) -> Option<Symbol> {\n@@ -65,10 +64,11 @@ pub fn link_name(attrs: &[ast::Attribute]) -> Option<Symbol> {\n     })\n }\n \n-fn verify(sess: &Session, items: &lang_items::LanguageItems) {\n+fn verify<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    items: &lang_items::LanguageItems) {\n     // We only need to check for the presence of weak lang items if we're\n     // emitting something that's not an rlib.\n-    let needs_check = sess.crate_types.borrow().iter().any(|kind| {\n+    let needs_check = tcx.sess.crate_types.borrow().iter().any(|kind| {\n         match *kind {\n             config::CrateTypeDylib |\n             config::CrateTypeProcMacro |\n@@ -83,8 +83,8 @@ fn verify(sess: &Session, items: &lang_items::LanguageItems) {\n     }\n \n     let mut missing = HashSet::new();\n-    for cnum in sess.cstore.crates() {\n-        for item in sess.cstore.missing_lang_items(cnum) {\n+    for &cnum in tcx.crates().iter() {\n+        for &item in tcx.missing_lang_items(cnum).iter() {\n             missing.insert(item);\n         }\n     }\n@@ -93,7 +93,7 @@ fn verify(sess: &Session, items: &lang_items::LanguageItems) {\n     // symbols. Other panic runtimes ensure that the relevant symbols are\n     // available to link things together, but they're never exercised.\n     let mut whitelisted = HashSet::new();\n-    if sess.panic_strategy() != PanicStrategy::Unwind {\n+    if tcx.sess.panic_strategy() != PanicStrategy::Unwind {\n         whitelisted.insert(lang_items::EhPersonalityLangItem);\n         whitelisted.insert(lang_items::EhUnwindResumeLangItem);\n     }\n@@ -102,28 +102,28 @@ fn verify(sess: &Session, items: &lang_items::LanguageItems) {\n         if missing.contains(&lang_items::$item) &&\n            !whitelisted.contains(&lang_items::$item) &&\n            items.$name().is_none() {\n-            sess.err(&format!(\"language item required, but not found: `{}`\",\n-                              stringify!($name)));\n+            tcx.sess.err(&format!(\"language item required, but not found: `{}`\",\n+                                  stringify!($name)));\n \n         }\n     )*\n }\n \n-impl<'a> Context<'a> {\n+impl<'a, 'tcx> Context<'a, 'tcx> {\n     fn register(&mut self, name: &str, span: Span) {\n         $(if name == stringify!($name) {\n             if self.items.$name().is_none() {\n                 self.items.missing.push(lang_items::$item);\n             }\n         } else)* {\n-            span_err!(self.sess, span, E0264,\n+            span_err!(self.tcx.sess, span, E0264,\n                       \"unknown external lang item: `{}`\",\n                       name);\n         }\n     }\n }\n \n-impl<'a, 'v> Visitor<'v> for Context<'a> {\n+impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v> {\n         NestedVisitorMap::None\n     }"}, {"sha": "38dfe010c153cc14af61ca38ad7cbc07c2e6f829", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 25, "deletions": 31, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -1187,10 +1187,16 @@ impl<'tcx> Operand<'tcx> {\n         substs: &'tcx Substs<'tcx>,\n         span: Span,\n     ) -> Self {\n+        let ty = tcx.type_of(def_id).subst(tcx, substs);\n         Operand::Constant(box Constant {\n             span,\n-            ty: tcx.type_of(def_id).subst(tcx, substs),\n-            literal: Literal::Value { value: ConstVal::Function(def_id, substs) },\n+            ty,\n+            literal: Literal::Value {\n+                value: tcx.mk_const(ty::Const {\n+                    val: ConstVal::Function(def_id, substs),\n+                    ty\n+                })\n+            },\n         })\n     }\n \n@@ -1416,10 +1422,8 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n \n                             tcx.with_freevars(node_id, |freevars| {\n                                 for (freevar, lv) in freevars.iter().zip(lvs) {\n-                                    let def_id = freevar.def.def_id();\n-                                    let var_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-                                    let var_name = tcx.local_var_name_str(var_id);\n-                                    struct_fmt.field(&var_name, lv);\n+                                    let var_name = tcx.hir.name(freevar.var_id());\n+                                    struct_fmt.field(&var_name.as_str(), lv);\n                                 }\n                             });\n \n@@ -1436,10 +1440,8 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n \n                             tcx.with_freevars(node_id, |freevars| {\n                                 for (freevar, lv) in freevars.iter().zip(lvs) {\n-                                    let def_id = freevar.def.def_id();\n-                                    let var_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-                                    let var_name = tcx.local_var_name_str(var_id);\n-                                    struct_fmt.field(&var_name, lv);\n+                                    let var_name = tcx.hir.name(freevar.var_id());\n+                                    struct_fmt.field(&var_name.as_str(), lv);\n                                 }\n                                 struct_fmt.field(\"$state\", &lvs[freevars.len()]);\n                                 for i in (freevars.len() + 1)..lvs.len() {\n@@ -1477,12 +1479,8 @@ newtype_index!(Promoted, \"promoted\");\n \n #[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum Literal<'tcx> {\n-    Item {\n-        def_id: DefId,\n-        substs: &'tcx Substs<'tcx>,\n-    },\n     Value {\n-        value: ConstVal<'tcx>,\n+        value: &'tcx ty::Const<'tcx>,\n     },\n     Promoted {\n         // Index into the `promoted` vector of `Mir`.\n@@ -1500,12 +1498,9 @@ impl<'tcx> Debug for Literal<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n         use self::Literal::*;\n         match *self {\n-            Item { def_id, substs } => {\n-                ppaux::parameterized(fmt, substs, def_id, &[])\n-            }\n-            Value { ref value } => {\n+            Value { value } => {\n                 write!(fmt, \"const \")?;\n-                fmt_const_val(fmt, value)\n+                fmt_const_val(fmt, &value.val)\n             }\n             Promoted { index } => {\n                 write!(fmt, \"{:?}\", index)\n@@ -1520,9 +1515,9 @@ fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ConstVal) -> fmt::Result {\n     match *const_val {\n         Float(f) => write!(fmt, \"{:?}\", f),\n         Integral(n) => write!(fmt, \"{}\", n),\n-        Str(ref s) => write!(fmt, \"{:?}\", s),\n-        ByteStr(ref bytes) => {\n-            let escaped: String = bytes\n+        Str(s) => write!(fmt, \"{:?}\", s),\n+        ByteStr(bytes) => {\n+            let escaped: String = bytes.data\n                 .iter()\n                 .flat_map(|&ch| ascii::escape_default(ch).map(|c| c as char))\n                 .collect();\n@@ -1532,8 +1527,8 @@ fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ConstVal) -> fmt::Result {\n         Char(c) => write!(fmt, \"{:?}\", c),\n         Variant(def_id) |\n         Function(def_id, _) => write!(fmt, \"{}\", item_path_str(def_id)),\n-        Struct(_) | Tuple(_) | Array(_) | Repeat(..) =>\n-            bug!(\"ConstVal `{:?}` should not be in MIR\", const_val),\n+        Aggregate(_) => bug!(\"`ConstVal::{:?}` should not be in MIR\", const_val),\n+        Unevaluated(..) => write!(fmt, \"{:?}\", const_val)\n     }\n }\n \n@@ -2000,17 +1995,16 @@ impl<'tcx> TypeFoldable<'tcx> for Constant<'tcx> {\n impl<'tcx> TypeFoldable<'tcx> for Literal<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n-            Literal::Item { def_id, substs } => Literal::Item {\n-                def_id,\n-                substs: substs.fold_with(folder)\n+            Literal::Value { value } => Literal::Value {\n+                value: value.fold_with(folder)\n             },\n-            _ => self.clone()\n+            Literal::Promoted { index } => Literal::Promoted { index }\n         }\n     }\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         match *self {\n-            Literal::Item { substs, .. } => substs.visit_with(visitor),\n-            _ => false\n+            Literal::Value { value } => value.visit_with(visitor),\n+            Literal::Promoted { .. } => false\n         }\n     }\n }"}, {"sha": "d645a00e15781a3436c9bdbeb696d4e184c9ab42", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -70,7 +70,9 @@ impl<'a, 'gcx, 'tcx> LvalueTy<'tcx> {\n                 LvalueTy::Ty {\n                     ty: match ty.sty {\n                         ty::TyArray(inner, size) => {\n-                            tcx.mk_array(inner, size-(from as usize)-(to as usize))\n+                            let size = size.val.to_const_int().unwrap().to_u64().unwrap();\n+                            let len = size - (from as u64) - (to as u64);\n+                            tcx.mk_array(inner, len)\n                         }\n                         ty::TySlice(..) => ty,\n                         _ => {\n@@ -146,11 +148,8 @@ impl<'tcx> Rvalue<'tcx> {\n     {\n         match *self {\n             Rvalue::Use(ref operand) => operand.ty(local_decls, tcx),\n-            Rvalue::Repeat(ref operand, ref count) => {\n-                let op_ty = operand.ty(local_decls, tcx);\n-                let count = count.as_u64(tcx.sess.target.uint_type);\n-                assert_eq!(count as usize as u64, count);\n-                tcx.mk_array(op_ty, count as usize)\n+            Rvalue::Repeat(ref operand, count) => {\n+                tcx.mk_array_const_usize(operand.ty(local_decls, tcx), count)\n             }\n             Rvalue::Ref(reg, bk, ref lv) => {\n                 let lv_ty = lv.ty(local_decls, tcx).to_ty(tcx);\n@@ -193,7 +192,7 @@ impl<'tcx> Rvalue<'tcx> {\n             Rvalue::Aggregate(ref ak, ref ops) => {\n                 match **ak {\n                     AggregateKind::Array(ty) => {\n-                        tcx.mk_array(ty, ops.len())\n+                        tcx.mk_array(ty, ops.len() as u64)\n                     }\n                     AggregateKind::Tuple => {\n                         tcx.mk_tup("}, {"sha": "37c97ad3dad9058aa763e8f15c84ef0bb485705f", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::const_val::ConstVal;\n use hir::def_id::DefId;\n use ty::subst::Substs;\n use ty::{ClosureSubsts, Region, Ty, GeneratorInterior};\n@@ -214,6 +213,18 @@ macro_rules! make_mir_visitor {\n                 self.super_ty(ty);\n             }\n \n+            fn visit_region(&mut self,\n+                            region: & $($mutability)* ty::Region<'tcx>,\n+                            _: Location) {\n+                self.super_region(region);\n+            }\n+\n+            fn visit_const(&mut self,\n+                           constant: & $($mutability)* &'tcx ty::Const<'tcx>,\n+                           _: Location) {\n+                self.super_const(constant);\n+            }\n+\n             fn visit_substs(&mut self,\n                             substs: & $($mutability)* &'tcx Substs<'tcx>,\n                             _: Location) {\n@@ -232,12 +243,6 @@ macro_rules! make_mir_visitor {\n                 self.super_generator_interior(interior);\n             }\n \n-            fn visit_const_val(&mut self,\n-                               const_val: & $($mutability)* ConstVal,\n-                               _: Location) {\n-                self.super_const_val(const_val);\n-            }\n-\n             fn visit_const_int(&mut self,\n                                const_int: &ConstInt,\n                                _: Location) {\n@@ -517,9 +522,10 @@ macro_rules! make_mir_visitor {\n                         self.visit_const_usize(length, location);\n                     }\n \n-                    Rvalue::Ref(r, bk, ref $($mutability)* path) => {\n+                    Rvalue::Ref(ref $($mutability)* r, bk, ref $($mutability)* path) => {\n+                        self.visit_region(r, location);\n                         self.visit_lvalue(path, LvalueContext::Borrow {\n-                            region: r,\n+                            region: *r,\n                             kind: bk\n                         }, location);\n                     }\n@@ -718,13 +724,8 @@ macro_rules! make_mir_visitor {\n                              literal: & $($mutability)* Literal<'tcx>,\n                              location: Location) {\n                 match *literal {\n-                    Literal::Item { ref $($mutability)* def_id,\n-                                    ref $($mutability)* substs } => {\n-                        self.visit_def_id(def_id, location);\n-                        self.visit_substs(substs, location);\n-                    }\n                     Literal::Value { ref $($mutability)* value } => {\n-                        self.visit_const_val(value, location);\n+                        self.visit_const(value, location);\n                     }\n                     Literal::Promoted { index: _ } => {}\n                 }\n@@ -749,6 +750,12 @@ macro_rules! make_mir_visitor {\n             fn super_ty(&mut self, _ty: & $($mutability)* Ty<'tcx>) {\n             }\n \n+            fn super_region(&mut self, _region: & $($mutability)* ty::Region<'tcx>) {\n+            }\n+\n+            fn super_const(&mut self, _const: & $($mutability)* &'tcx ty::Const<'tcx>) {\n+            }\n+\n             fn super_substs(&mut self, _substs: & $($mutability)* &'tcx Substs<'tcx>) {\n             }\n \n@@ -760,9 +767,6 @@ macro_rules! make_mir_visitor {\n                                     _substs: & $($mutability)* ClosureSubsts<'tcx>) {\n             }\n \n-            fn super_const_val(&mut self, _const_val: & $($mutability)* ConstVal) {\n-            }\n-\n             fn super_const_int(&mut self, _const_int: &ConstInt) {\n             }\n "}, {"sha": "59f600f39077c33e53cdad551b39b5d5bc8b4afd", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -48,8 +48,8 @@ use std::path::PathBuf;\n \n pub struct Config {\n     pub target: Target,\n-    pub int_type: IntTy,\n-    pub uint_type: UintTy,\n+    pub isize_ty: IntTy,\n+    pub usize_ty: UintTy,\n }\n \n #[derive(Clone, Hash, Debug)]\n@@ -919,6 +919,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"when debug-printing compiler state, do not include spans\"), // o/w tests have closure@path\n     identify_regions: bool = (false, parse_bool, [UNTRACKED],\n         \"make unnamed regions display as '# (where # is some non-ident unique id)\"),\n+    emit_end_regions: bool = (false, parse_bool, [UNTRACKED],\n+        \"emit EndRegion as part of MIR; enable transforms that solely process EndRegion\"),\n     borrowck_mir: bool = (false, parse_bool, [UNTRACKED],\n         \"implicitly treat functions as if they have `#[rustc_mir_borrowck]` attribute\"),\n     time_passes: bool = (false, parse_bool, [UNTRACKED],\n@@ -1147,7 +1149,7 @@ pub fn build_target_config(opts: &Options, sp: &Handler) -> Config {\n         }\n     };\n \n-    let (int_type, uint_type) = match &target.target_pointer_width[..] {\n+    let (isize_ty, usize_ty) = match &target.target_pointer_width[..] {\n         \"16\" => (ast::IntTy::I16, ast::UintTy::U16),\n         \"32\" => (ast::IntTy::I32, ast::UintTy::U32),\n         \"64\" => (ast::IntTy::I64, ast::UintTy::U64),\n@@ -1157,8 +1159,8 @@ pub fn build_target_config(opts: &Options, sp: &Handler) -> Config {\n \n     Config {\n         target,\n-        int_type,\n-        uint_type,\n+        isize_ty,\n+        usize_ty,\n     }\n }\n \n@@ -1951,13 +1953,12 @@ mod tests {\n     use errors;\n     use getopts;\n     use lint;\n-    use middle::cstore::{self, DummyCrateStore};\n+    use middle::cstore;\n     use session::config::{build_configuration, build_session_options_and_crate_config};\n     use session::build_session;\n     use std::collections::{BTreeMap, BTreeSet};\n     use std::iter::FromIterator;\n     use std::path::PathBuf;\n-    use std::rc::Rc;\n     use super::{OutputType, OutputTypes, Externs};\n     use rustc_back::{PanicStrategy, RelroLevel};\n     use syntax::symbol::Symbol;\n@@ -1989,7 +1990,7 @@ mod tests {\n             };\n         let registry = errors::registry::Registry::new(&[]);\n         let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n-        let sess = build_session(sessopts, &dep_graph, None, registry, Rc::new(DummyCrateStore));\n+        let sess = build_session(sessopts, &dep_graph, None, registry);\n         let cfg = build_configuration(&sess, cfg);\n         assert!(cfg.contains(&(Symbol::intern(\"test\"), None)));\n     }\n@@ -2008,8 +2009,7 @@ mod tests {\n             };\n         let registry = errors::registry::Registry::new(&[]);\n         let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n-        let sess = build_session(sessopts, &dep_graph, None, registry,\n-                                 Rc::new(DummyCrateStore));\n+        let sess = build_session(sessopts, &dep_graph, None, registry);\n         let cfg = build_configuration(&sess, cfg);\n         let mut test_items = cfg.iter().filter(|&&(name, _)| name == \"test\");\n         assert!(test_items.next().is_some());\n@@ -2025,8 +2025,7 @@ mod tests {\n             ]).unwrap();\n             let registry = errors::registry::Registry::new(&[]);\n             let (sessopts, _) = build_session_options_and_crate_config(&matches);\n-            let sess = build_session(sessopts, &dep_graph, None, registry,\n-                                     Rc::new(DummyCrateStore));\n+            let sess = build_session(sessopts, &dep_graph, None, registry);\n             assert!(!sess.diagnostic().can_emit_warnings);\n         }\n \n@@ -2037,8 +2036,7 @@ mod tests {\n             ]).unwrap();\n             let registry = errors::registry::Registry::new(&[]);\n             let (sessopts, _) = build_session_options_and_crate_config(&matches);\n-            let sess = build_session(sessopts, &dep_graph, None, registry,\n-                                     Rc::new(DummyCrateStore));\n+            let sess = build_session(sessopts, &dep_graph, None, registry);\n             assert!(sess.diagnostic().can_emit_warnings);\n         }\n \n@@ -2048,8 +2046,7 @@ mod tests {\n             ]).unwrap();\n             let registry = errors::registry::Registry::new(&[]);\n             let (sessopts, _) = build_session_options_and_crate_config(&matches);\n-            let sess = build_session(sessopts, &dep_graph, None, registry,\n-                                     Rc::new(DummyCrateStore));\n+            let sess = build_session(sessopts, &dep_graph, None, registry);\n             assert!(sess.diagnostic().can_emit_warnings);\n         }\n     }"}, {"sha": "1f9cb2b03100fba2fec8d091d2c3b554e2bed528", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -15,7 +15,6 @@ use dep_graph::DepGraph;\n use hir::def_id::{CrateNum, DefIndex};\n \n use lint;\n-use middle::cstore::CrateStore;\n use middle::allocator::AllocatorKind;\n use middle::dependency_format;\n use session::search_paths::PathKind;\n@@ -63,7 +62,6 @@ pub struct Session {\n     pub target: config::Config,\n     pub host: Target,\n     pub opts: config::Options,\n-    pub cstore: Rc<CrateStore>,\n     pub parse_sess: ParseSess,\n     // For a library crate, this is always none\n     pub entry_fn: RefCell<Option<(NodeId, Span)>>,\n@@ -410,6 +408,10 @@ impl Session {\n     pub fn print_llvm_passes(&self) -> bool {\n         self.opts.debugging_opts.print_llvm_passes\n     }\n+    pub fn emit_end_regions(&self) -> bool {\n+        self.opts.debugging_opts.emit_end_regions ||\n+            (self.opts.debugging_opts.mir_emit_validate > 0)\n+    }\n     pub fn lto(&self) -> bool {\n         self.opts.cg.lto\n     }\n@@ -617,16 +619,14 @@ impl Session {\n pub fn build_session(sopts: config::Options,\n                      dep_graph: &DepGraph,\n                      local_crate_source_file: Option<PathBuf>,\n-                     registry: errors::registry::Registry,\n-                     cstore: Rc<CrateStore>)\n+                     registry: errors::registry::Registry)\n                      -> Session {\n     let file_path_mapping = sopts.file_path_mapping();\n \n     build_session_with_codemap(sopts,\n                                dep_graph,\n                                local_crate_source_file,\n                                registry,\n-                               cstore,\n                                Rc::new(codemap::CodeMap::new(file_path_mapping)),\n                                None)\n }\n@@ -635,7 +635,6 @@ pub fn build_session_with_codemap(sopts: config::Options,\n                                   dep_graph: &DepGraph,\n                                   local_crate_source_file: Option<PathBuf>,\n                                   registry: errors::registry::Registry,\n-                                  cstore: Rc<CrateStore>,\n                                   codemap: Rc<codemap::CodeMap>,\n                                   emitter_dest: Option<Box<Write + Send>>)\n                                   -> Session {\n@@ -676,16 +675,14 @@ pub fn build_session_with_codemap(sopts: config::Options,\n                    dep_graph,\n                    local_crate_source_file,\n                    diagnostic_handler,\n-                   codemap,\n-                   cstore)\n+                   codemap)\n }\n \n pub fn build_session_(sopts: config::Options,\n                       dep_graph: &DepGraph,\n                       local_crate_source_file: Option<PathBuf>,\n                       span_diagnostic: errors::Handler,\n-                      codemap: Rc<codemap::CodeMap>,\n-                      cstore: Rc<CrateStore>)\n+                      codemap: Rc<codemap::CodeMap>)\n                       -> Session {\n     let host = match Target::search(config::host_triple()) {\n         Ok(t) => t,\n@@ -722,7 +719,6 @@ pub fn build_session_(sopts: config::Options,\n         target: target_cfg,\n         host,\n         opts: sopts,\n-        cstore,\n         parse_sess: p_s,\n         // For a library crate, this is always none\n         entry_fn: RefCell::new(None),"}, {"sha": "b491baadd7c2bc7a888509d2c46c927a49b90bb4", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -19,6 +19,7 @@ use super::{\n     OnUnimplementedNote,\n     OutputTypeParameterMismatch,\n     TraitNotObjectSafe,\n+    ConstEvalFailure,\n     PredicateObligation,\n     Reveal,\n     SelectionContext,\n@@ -31,6 +32,7 @@ use hir;\n use hir::def_id::DefId;\n use infer::{self, InferCtxt};\n use infer::type_variable::TypeVariableOrigin;\n+use middle::const_val;\n use rustc::lint::builtin::EXTRA_REQUIREMENT_IN_IMPL;\n use std::fmt;\n use syntax::ast;\n@@ -348,7 +350,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             //\n             // Currently I'm leaving it for what I need for `try`.\n             if self.tcx.trait_of_item(item) == Some(trait_ref.def_id) {\n-                method = self.tcx.item_name(item).as_str();\n+                method = self.tcx.item_name(item);\n                 flags.push((\"from_method\", None));\n                 flags.push((\"from_method\", Some(&*method)));\n             }\n@@ -698,6 +700,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         // (which may fail).\n                         span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n                     }\n+\n+                    ty::Predicate::ConstEvaluatable(..) => {\n+                        // Errors for `ConstEvaluatable` predicates show up as\n+                        // `SelectionError::ConstEvalFailure`,\n+                        // not `Unimplemented`.\n+                        span_bug!(span,\n+                            \"const-evaluatable requirement gave wrong error: `{:?}`\", obligation)\n+                    }\n                 }\n             }\n \n@@ -762,6 +772,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 self.tcx.report_object_safety_error(span, did,\n                                                     violations)\n             }\n+\n+            ConstEvalFailure(ref err) => {\n+                if let const_val::ErrKind::TypeckError = err.kind {\n+                    return;\n+                }\n+                err.struct_error(self.tcx, span, \"constant expression\")\n+            }\n         };\n         self.note_obligation_cause(&mut err, obligation);\n         err.emit();\n@@ -919,7 +936,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 // anyway. In that case, why inundate the user.\n                 if !self.tcx.sess.has_errors() {\n                     if\n-                        self.tcx.lang_items.sized_trait()\n+                        self.tcx.lang_items().sized_trait()\n                         .map_or(false, |sized_id| sized_id == trait_ref.def_id())\n                     {\n                         self.need_type_info(body_id, span, self_ty);"}, {"sha": "cc2506d1afc505c7f6d2553fafc160becf80c410", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -25,7 +25,7 @@ use super::{FulfillmentError, FulfillmentErrorCode};\n use super::{ObligationCause, PredicateObligation, Obligation};\n use super::project;\n use super::select::SelectionContext;\n-use super::Unimplemented;\n+use super::{Unimplemented, ConstEvalFailure};\n \n impl<'tcx> ForestObligation for PendingPredicateObligation<'tcx> {\n     type Predicate = ty::Predicate<'tcx>;\n@@ -540,6 +540,29 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n                 }\n             }\n         }\n+\n+        ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+            match selcx.tcx().lift_to_global(&obligation.param_env) {\n+                None => {\n+                    Ok(None)\n+                }\n+                Some(param_env) => {\n+                    match selcx.tcx().lift_to_global(&substs) {\n+                        None => {\n+                            pending_obligation.stalled_on = substs.types().collect();\n+                            Ok(None)\n+                        }\n+                        Some(substs) => {\n+                            match selcx.tcx().at(obligation.cause.span)\n+                                             .const_eval(param_env.and((def_id, substs))) {\n+                                Ok(_) => Ok(Some(vec![])),\n+                                Err(e) => Err(CodeSelectionError(ConstEvalFailure(e)))\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n     }\n }\n "}, {"sha": "fb71d9cc49b9e1efe1b0585bfcb17cb6b907d24a", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -17,6 +17,7 @@ pub use self::ObligationCauseCode::*;\n \n use hir;\n use hir::def_id::DefId;\n+use middle::const_val::ConstEvalErr;\n use middle::region;\n use middle::free_region::FreeRegionMap;\n use ty::subst::Substs;\n@@ -218,6 +219,7 @@ pub enum SelectionError<'tcx> {\n                                 ty::PolyTraitRef<'tcx>,\n                                 ty::error::TypeError<'tcx>),\n     TraitNotObjectSafe(DefId),\n+    ConstEvalFailure(ConstEvalErr<'tcx>),\n }\n \n pub struct FulfillmentError<'tcx> {"}, {"sha": "1e9816095ea2ec419330dc3b154f20ee5080b869", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -169,7 +169,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     ty::Predicate::RegionOutlives(..) |\n                     ty::Predicate::ClosureKind(..) |\n                     ty::Predicate::Subtype(..) |\n-                    ty::Predicate::Equate(..) => {\n+                    ty::Predicate::Equate(..) |\n+                    ty::Predicate::ConstEvaluatable(..) => {\n                         false\n                     }\n                 }\n@@ -181,7 +182,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn generics_require_sized_self(self, def_id: DefId) -> bool {\n-        let sized_def_id = match self.lang_items.sized_trait() {\n+        let sized_def_id = match self.lang_items().sized_trait() {\n             Some(def_id) => def_id,\n             None => { return false; /* No Sized trait, can't require it! */ }\n         };\n@@ -203,7 +204,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     ty::Predicate::WellFormed(..) |\n                     ty::Predicate::ObjectSafe(..) |\n                     ty::Predicate::ClosureKind(..) |\n-                    ty::Predicate::TypeOutlives(..) => {\n+                    ty::Predicate::TypeOutlives(..) |\n+                    ty::Predicate::ConstEvaluatable(..) => {\n                         false\n                     }\n                 }"}, {"sha": "94f6efcad4adc7efdee2cd0ed6e47edf74f229f4", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -227,7 +227,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n               span: Span)\n               -> Result<(), ErrorReported>\n     {\n-        let name = tcx.item_name(trait_def_id).as_str();\n+        let name = tcx.item_name(trait_def_id);\n         let generics = tcx.generics_of(trait_def_id);\n         let parser = Parser::new(&self.0);\n         let types = &generics.types;\n@@ -272,7 +272,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n                   trait_ref: ty::TraitRef<'tcx>)\n                   -> String\n     {\n-        let name = tcx.item_name(trait_ref.def_id).as_str();\n+        let name = tcx.item_name(trait_ref.def_id);\n         let trait_str = tcx.item_path_str(trait_ref.def_id);\n         let generics = tcx.generics_of(trait_ref.def_id);\n         let generic_map = generics.types.iter().map(|param| {"}, {"sha": "54e31aed272a31389a2271906dc096b53d1747a2", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 141, "deletions": 12, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -25,12 +25,13 @@ use super::VtableImplData;\n use super::util;\n \n use hir::def_id::DefId;\n-use infer::InferOk;\n+use infer::{InferCtxt, InferOk};\n use infer::type_variable::TypeVariableOrigin;\n+use middle::const_val::ConstVal;\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n use syntax::ast;\n use syntax::symbol::Symbol;\n-use ty::subst::Subst;\n+use ty::subst::{Subst, Substs};\n use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder};\n use util::common::FN_OUTPUT_NAME;\n@@ -260,7 +261,7 @@ impl<'a, 'b, 'gcx, 'tcx> AssociatedTypeNormalizer<'a, 'b, 'gcx, 'tcx> {\n     fn fold<T:TypeFoldable<'tcx>>(&mut self, value: &T) -> T {\n         let value = self.selcx.infcx().resolve_type_vars_if_possible(value);\n \n-        if !value.has_projection_types() {\n+        if !value.has_projections() {\n             value.clone()\n         } else {\n             value.fold_with(self)\n@@ -332,6 +333,39 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n             }\n         }\n     }\n+\n+    fn fold_const(&mut self, constant: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        if let ConstVal::Unevaluated(def_id, substs) = constant.val {\n+            if substs.needs_infer() {\n+                let identity_substs = Substs::identity_for_item(self.tcx(), def_id);\n+                let data = self.param_env.and((def_id, identity_substs));\n+                match self.tcx().lift_to_global(&data) {\n+                    Some(data) => {\n+                        match self.tcx().const_eval(data) {\n+                            Ok(evaluated) => {\n+                                let evaluated = evaluated.subst(self.tcx(), substs);\n+                                return self.fold_const(evaluated);\n+                            }\n+                            Err(_) => {}\n+                        }\n+                    }\n+                    None => {}\n+                }\n+            } else {\n+                let data = self.param_env.and((def_id, substs));\n+                match self.tcx().lift_to_global(&data) {\n+                    Some(data) => {\n+                        match self.tcx().const_eval(data) {\n+                            Ok(evaluated) => return self.fold_const(evaluated),\n+                            Err(_) => {}\n+                        }\n+                    }\n+                    None => {}\n+                }\n+            }\n+        }\n+        constant\n+    }\n }\n \n #[derive(Clone)]\n@@ -416,7 +450,8 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n     // bounds. It might be the case that we want two distinct caches,\n     // or else another kind of cache entry.\n \n-    match infcx.projection_cache.borrow_mut().try_start(cache_key) {\n+    let cache_result = infcx.projection_cache.borrow_mut().try_start(cache_key);\n+    match cache_result {\n         Ok(()) => { }\n         Err(ProjectionCacheEntry::Ambiguous) => {\n             // If we found ambiguity the last time, that generally\n@@ -466,7 +501,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                                                     projection_ty);\n             selcx.infcx().report_overflow_error(&obligation, false);\n         }\n-        Err(ProjectionCacheEntry::NormalizedTy(ty)) => {\n+        Err(ProjectionCacheEntry::NormalizedTy(mut ty)) => {\n             // If we find the value in the cache, then return it along\n             // with the obligations that went along with it. Note\n             // that, when using a fulfillment context, these\n@@ -479,6 +514,21 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             debug!(\"opt_normalize_projection_type: \\\n                     found normalized ty `{:?}`\",\n                    ty);\n+\n+            // Once we have inferred everything we need to know, we\n+            // can ignore the `obligations` from that point on.\n+            if !infcx.any_unresolved_type_vars(&ty.value) {\n+                infcx.projection_cache.borrow_mut().complete(cache_key);\n+                ty.obligations = vec![];\n+            }\n+\n+            push_paranoid_cache_value_obligation(infcx,\n+                                                 param_env,\n+                                                 projection_ty,\n+                                                 cause,\n+                                                 depth,\n+                                                 &mut ty);\n+\n             return Some(ty);\n         }\n         Err(ProjectionCacheEntry::Error) => {\n@@ -504,7 +554,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                    depth,\n                    obligations);\n \n-            let result = if projected_ty.has_projection_types() {\n+            let result = if projected_ty.has_projections() {\n                 let mut normalizer = AssociatedTypeNormalizer::new(selcx,\n                                                                    param_env,\n                                                                    cause,\n@@ -527,7 +577,10 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                     obligations,\n                 }\n             };\n-            infcx.projection_cache.borrow_mut().insert_ty(cache_key, &result);\n+\n+            let cache_value = prune_cache_value_obligations(infcx, &result);\n+            infcx.projection_cache.borrow_mut().insert_ty(cache_key, cache_value);\n+\n             Some(result)\n         }\n         Ok(ProjectedTy::NoProgress(projected_ty)) => {\n@@ -538,7 +591,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                 value: projected_ty,\n                 obligations: vec![]\n             };\n-            infcx.projection_cache.borrow_mut().insert_ty(cache_key, &result);\n+            infcx.projection_cache.borrow_mut().insert_ty(cache_key, result.clone());\n             Some(result)\n         }\n         Err(ProjectionTyError::TooManyCandidates) => {\n@@ -562,6 +615,82 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n     }\n }\n \n+/// If there are unresolved type variables, then we need to include\n+/// any subobligations that bind them, at least until those type\n+/// variables are fully resolved.\n+fn prune_cache_value_obligations<'a, 'gcx, 'tcx>(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+                                                 result: &NormalizedTy<'tcx>)\n+                                                 -> NormalizedTy<'tcx> {\n+    if !infcx.any_unresolved_type_vars(&result.value) {\n+        return NormalizedTy { value: result.value, obligations: vec![] };\n+    }\n+\n+    let mut obligations: Vec<_> =\n+        result.obligations\n+              .iter()\n+              .filter(|obligation| match obligation.predicate {\n+                  // We found a `T: Foo<X = U>` predicate, let's check\n+                  // if `U` references any unresolved type\n+                  // variables. In principle, we only care if this\n+                  // projection can help resolve any of the type\n+                  // variables found in `result.value` -- but we just\n+                  // check for any type variables here, for fear of\n+                  // indirect obligations (e.g., we project to `?0`,\n+                  // but we have `T: Foo<X = ?1>` and `?1: Bar<X =\n+                  // ?0>`).\n+                  ty::Predicate::Projection(ref data) =>\n+                      !infcx.any_unresolved_type_vars(&data.ty()),\n+\n+                  // We are only interested in `T: Foo<X = U>` predicates, whre\n+                  // `U` references one of `unresolved_type_vars`. =)\n+                  _ => false,\n+              })\n+              .cloned()\n+              .collect();\n+\n+    obligations.shrink_to_fit();\n+\n+    NormalizedTy { value: result.value, obligations }\n+}\n+\n+/// Whenever we give back a cache result for a projection like `<T as\n+/// Trait>::Item ==> X`, we *always* include the obligation to prove\n+/// that `T: Trait` (we may also include some other obligations). This\n+/// may or may not be necessary -- in principle, all the obligations\n+/// that must be proven to show that `T: Trait` were also returned\n+/// when the cache was first populated. But there are some vague concerns,\n+/// and so we take the precatuionary measure of including `T: Trait` in\n+/// the result:\n+///\n+/// Concern #1. The current setup is fragile. Perhaps someone could\n+/// have failed to prove the concerns from when the cache was\n+/// populated, but also not have used a snapshot, in which case the\n+/// cache could remain populated even though `T: Trait` has not been\n+/// shown. In this case, the \"other code\" is at fault -- when you\n+/// project something, you are supposed to either have a snapshot or\n+/// else prove all the resulting obligations -- but it's still easy to\n+/// get wrong.\n+///\n+/// Concern #2. Even within the snapshot, if those original\n+/// obligations are not yet proven, then we are able to do projections\n+/// that may yet turn out to be wrong.  This *may* lead to some sort\n+/// of trouble, though we don't have a concrete example of how that\n+/// can occur yet.  But it seems risky at best.\n+fn push_paranoid_cache_value_obligation<'a, 'gcx, 'tcx>(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+                                                        param_env: ty::ParamEnv<'tcx>,\n+                                                        projection_ty: ty::ProjectionTy<'tcx>,\n+                                                        cause: ObligationCause<'tcx>,\n+                                                        depth: usize,\n+                                                        result: &mut NormalizedTy<'tcx>)\n+{\n+    let trait_ref = projection_ty.trait_ref(infcx.tcx).to_poly_trait_ref();\n+    let trait_obligation = Obligation { cause,\n+                                        recursion_depth: depth,\n+                                        param_env,\n+                                        predicate: trait_ref.to_predicate() };\n+    result.obligations.push(trait_obligation);\n+}\n+\n /// If we are projecting `<T as Trait>::Item`, but `T: Trait` does not\n /// hold. In various error cases, we cannot generate a valid\n /// normalized projection. Therefore, we create an inference variable\n@@ -1155,7 +1284,7 @@ fn confirm_generator_candidate<'cx, 'gcx, 'tcx>(\n \n     let tcx = selcx.tcx();\n \n-    let gen_def_id = tcx.lang_items.gen_trait().unwrap();\n+    let gen_def_id = tcx.lang_items().gen_trait().unwrap();\n \n     // Note: we unwrap the binder here but re-create it below (1)\n     let ty::Binder((trait_ref, yield_ty, return_ty)) =\n@@ -1252,7 +1381,7 @@ fn confirm_callable_candidate<'cx, 'gcx, 'tcx>(\n            fn_sig);\n \n     // the `Output` associated type is declared on `FnOnce`\n-    let fn_once_def_id = tcx.lang_items.fn_once_trait().unwrap();\n+    let fn_once_def_id = tcx.lang_items().fn_once_trait().unwrap();\n \n     // Note: we unwrap the binder here but re-create it below (1)\n     let ty::Binder((trait_ref, ret_type)) =\n@@ -1493,10 +1622,10 @@ impl<'tcx> ProjectionCache<'tcx> {\n     }\n \n     /// Indicates that `key` was normalized to `value`.\n-    fn insert_ty(&mut self, key: ProjectionCacheKey<'tcx>, value: &NormalizedTy<'tcx>) {\n+    fn insert_ty(&mut self, key: ProjectionCacheKey<'tcx>, value: NormalizedTy<'tcx>) {\n         debug!(\"ProjectionCacheEntry::insert_ty: adding cache entry: key={:?}, value={:?}\",\n                key, value);\n-        let fresh_key = self.map.insert(key, ProjectionCacheEntry::NormalizedTy(value.clone()));\n+        let fresh_key = self.map.insert(key, ProjectionCacheEntry::NormalizedTy(value));\n         assert!(!fresh_key, \"never started projecting `{:?}`\", key);\n     }\n "}, {"sha": "f5f69ad0a7cec124372e076141136b2873e1b951", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -732,6 +732,21 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n+\n+            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+                match self.tcx().lift_to_global(&(obligation.param_env, substs)) {\n+                    Some((param_env, substs)) => {\n+                        match self.tcx().const_eval(param_env.and((def_id, substs))) {\n+                            Ok(_) => EvaluatedToOk,\n+                            Err(_) => EvaluatedToErr\n+                        }\n+                    }\n+                    None => {\n+                        // Inference variables still left in param_env or substs.\n+                        EvaluatedToAmbig\n+                    }\n+                }\n+            }\n         }\n     }\n \n@@ -1315,7 +1330,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // and applicable impls. There is a certain set of precedence rules here.\n \n         let def_id = obligation.predicate.def_id();\n-        if self.tcx().lang_items.copy_trait() == Some(def_id) {\n+        let lang_items = self.tcx().lang_items();\n+        if lang_items.copy_trait() == Some(def_id) {\n             debug!(\"obligation self ty is {:?}\",\n                    obligation.predicate.0.self_ty());\n \n@@ -1326,16 +1342,16 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // For other types, we'll use the builtin rules.\n             let copy_conditions = self.copy_conditions(obligation);\n             self.assemble_builtin_bound_candidates(copy_conditions, &mut candidates)?;\n-        } else if self.tcx().lang_items.sized_trait() == Some(def_id) {\n+        } else if lang_items.sized_trait() == Some(def_id) {\n             // Sized is never implementable by end-users, it is\n             // always automatically computed.\n             let sized_conditions = self.sized_conditions(obligation);\n             self.assemble_builtin_bound_candidates(sized_conditions,\n                                                    &mut candidates)?;\n-         } else if self.tcx().lang_items.unsize_trait() == Some(def_id) {\n+         } else if lang_items.unsize_trait() == Some(def_id) {\n              self.assemble_candidates_for_unsizing(obligation, &mut candidates);\n          } else {\n-             if self.tcx().lang_items.clone_trait() == Some(def_id) {\n+             if lang_items.clone_trait() == Some(def_id) {\n                  // Same builtin conditions as `Copy`, i.e. every type which has builtin support\n                  // for `Copy` also has builtin support for `Clone`, + tuples and arrays of `Clone`\n                  // types have builtin support for `Clone`.\n@@ -1533,7 +1549,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                    candidates: &mut SelectionCandidateSet<'tcx>)\n                                    -> Result<(),SelectionError<'tcx>>\n     {\n-        if self.tcx().lang_items.gen_trait() != Some(obligation.predicate.def_id()) {\n+        if self.tcx().lang_items().gen_trait() != Some(obligation.predicate.def_id()) {\n             return Ok(());\n         }\n \n@@ -1570,7 +1586,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                    candidates: &mut SelectionCandidateSet<'tcx>)\n                                    -> Result<(),SelectionError<'tcx>>\n     {\n-        let kind = match self.tcx().lang_items.fn_trait_kind(obligation.predicate.0.def_id()) {\n+        let kind = match self.tcx().lang_items().fn_trait_kind(obligation.predicate.0.def_id()) {\n             Some(k) => k,\n             None => { return Ok(()); }\n         };\n@@ -1612,7 +1628,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                       -> Result<(),SelectionError<'tcx>>\n     {\n         // We provide impl of all fn traits for fn pointers.\n-        if self.tcx().lang_items.fn_trait_kind(obligation.predicate.def_id()).is_none() {\n+        if self.tcx().lang_items().fn_trait_kind(obligation.predicate.def_id()).is_none() {\n             return Ok(());\n         }\n \n@@ -2346,16 +2362,17 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         debug!(\"confirm_builtin_candidate({:?}, {:?})\",\n                obligation, has_nested);\n \n+        let lang_items = self.tcx().lang_items();\n         let obligations = if has_nested {\n             let trait_def = obligation.predicate.def_id();\n             let conditions = match trait_def {\n-                _ if Some(trait_def) == self.tcx().lang_items.sized_trait() => {\n+                _ if Some(trait_def) == lang_items.sized_trait() => {\n                     self.sized_conditions(obligation)\n                 }\n-                _ if Some(trait_def) == self.tcx().lang_items.copy_trait() => {\n+                _ if Some(trait_def) == lang_items.copy_trait() => {\n                     self.copy_conditions(obligation)\n                 }\n-                _ if Some(trait_def) == self.tcx().lang_items.clone_trait() => {\n+                _ if Some(trait_def) == lang_items.clone_trait() => {\n                     self.copy_conditions(obligation)\n                 }\n                 _ => bug!(\"unexpected builtin trait {:?}\", trait_def)\n@@ -2658,7 +2675,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     {\n         debug!(\"confirm_closure_candidate({:?})\", obligation);\n \n-        let kind = match self.tcx().lang_items.fn_trait_kind(obligation.predicate.0.def_id()) {\n+        let kind = match self.tcx().lang_items().fn_trait_kind(obligation.predicate.0.def_id()) {\n             Some(k) => k,\n             None => bug!(\"closure candidate for non-fn trait {:?}\", obligation)\n         };"}, {"sha": "19ed03aa14917b8e67e5b77c0e49d7e89471e663", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -173,6 +173,9 @@ impl<'a, 'tcx> Lift<'tcx> for traits::SelectionError<'a> {\n             super::TraitNotObjectSafe(def_id) => {\n                 Some(super::TraitNotObjectSafe(def_id))\n             }\n+            super::ConstEvalFailure(ref err) => {\n+                tcx.lift(err).map(super::ConstEvalFailure)\n+            }\n         }\n     }\n }"}, {"sha": "9c4a260b35d49a03cc213eb98f0e3928ca40a6eb", "filename": "src/librustc/traits/trans/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -120,7 +120,7 @@ impl<'a, 'gcx> AssociatedTypeNormalizer<'a, 'gcx> {\n     }\n \n     fn fold<T:TypeFoldable<'gcx>>(&mut self, value: &T) -> T {\n-        if !value.has_projection_types() {\n+        if !value.has_projections() {\n             value.clone()\n         } else {\n             value.fold_with(self)\n@@ -134,7 +134,7 @@ impl<'a, 'gcx> TypeFolder<'gcx, 'gcx> for AssociatedTypeNormalizer<'a, 'gcx> {\n     }\n \n     fn fold_ty(&mut self, ty: Ty<'gcx>) -> Ty<'gcx> {\n-        if !ty.has_projection_types() {\n+        if !ty.has_projections() {\n             ty\n         } else {\n             self.tcx.trans_trait_caches.project_cache.memoize(ty, || {"}, {"sha": "42e0834e8e43b1498e260125fe42d9fe9bc49aec", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -48,6 +48,9 @@ fn anonymize_predicate<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n         ty::Predicate::Subtype(ref data) =>\n             ty::Predicate::Subtype(tcx.anonymize_late_bound_regions(data)),\n+\n+        ty::Predicate::ConstEvaluatable(def_id, substs) =>\n+            ty::Predicate::ConstEvaluatable(def_id, substs),\n     }\n }\n \n@@ -175,6 +178,10 @@ impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n             ty::Predicate::ClosureKind(..) => {\n                 // Nothing to elaborate when waiting for a closure's kind to be inferred.\n             }\n+            ty::Predicate::ConstEvaluatable(..) => {\n+                // Currently, we do not elaborate const-evaluatable\n+                // predicates.\n+            }\n \n             ty::Predicate::RegionOutlives(..) => {\n                 // Nothing to elaborate from `'a: 'b`.\n@@ -538,8 +545,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             }\n             None => {\n                 self.global_tcx()\n-                    .sess\n-                    .cstore\n                     .impl_defaultness(node_item_def_id)\n                     .is_default()\n             }"}, {"sha": "349d77cfc1b244fcbeefd8f30a4baa1f6b7628c1", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -110,8 +110,8 @@ impl<'a, 'gcx, 'tcx> OverloadedDeref<'tcx> {\n     pub fn method_call(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, source: Ty<'tcx>)\n                        -> (DefId, &'tcx Substs<'tcx>) {\n         let trait_def_id = match self.mutbl {\n-            hir::MutImmutable => tcx.lang_items.deref_trait(),\n-            hir::MutMutable => tcx.lang_items.deref_mut_trait()\n+            hir::MutImmutable => tcx.lang_items().deref_trait(),\n+            hir::MutMutable => tcx.lang_items().deref_mut_trait()\n         };\n         let method_def_id = tcx.associated_items(trait_def_id.unwrap())\n             .find(|m| m.kind == ty::AssociatedKind::Method).unwrap().def_id;"}, {"sha": "fb0cdab0b6a0fa6f3e47e4200412418ce638af8d", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 306, "deletions": 97, "changes": 403, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -14,16 +14,19 @@ use dep_graph::DepGraph;\n use errors::DiagnosticBuilder;\n use session::Session;\n use middle;\n-use hir::{TraitCandidate, HirId};\n+use hir::{TraitCandidate, HirId, ItemLocalId};\n use hir::def::{Def, Export};\n-use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use hir::map as hir_map;\n use hir::map::DefPathHash;\n use lint::{self, Lint};\n use ich::{self, StableHashingContext, NodeIdHashingMode};\n+use middle::const_val::ConstVal;\n+use middle::cstore::{CrateStore, LinkMeta, EncodedMetadataHashes};\n+use middle::cstore::EncodedMetadata;\n use middle::free_region::FreeRegionMap;\n use middle::lang_items;\n-use middle::resolve_lifetime;\n+use middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use middle::stability;\n use mir::Mir;\n use mir::transform::Passes;\n@@ -32,8 +35,7 @@ use ty::ReprOptions;\n use traits;\n use ty::{self, Ty, TypeAndMut};\n use ty::{TyS, TypeVariants, Slice};\n-use ty::{AdtKind, AdtDef, ClosureSubsts, GeneratorInterior, Region};\n-use hir::FreevarMap;\n+use ty::{AdtKind, AdtDef, ClosureSubsts, GeneratorInterior, Region, Const};\n use ty::{PolyFnSig, InferTy, ParamTy, ProjectionTy, ExistentialPredicate, Predicate};\n use ty::RegionKind;\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n@@ -50,7 +52,9 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n \n use arena::{TypedArena, DroplessArena};\n+use rustc_const_math::{ConstInt, ConstUsize};\n use rustc_data_structures::indexed_vec::IndexVec;\n+use std::any::Any;\n use std::borrow::Borrow;\n use std::cell::{Cell, RefCell};\n use std::cmp::Ordering;\n@@ -109,6 +113,7 @@ pub struct CtxtInterners<'tcx> {\n     region: RefCell<FxHashSet<Interned<'tcx, RegionKind>>>,\n     existential_predicates: RefCell<FxHashSet<Interned<'tcx, Slice<ExistentialPredicate<'tcx>>>>>,\n     predicates: RefCell<FxHashSet<Interned<'tcx, Slice<Predicate<'tcx>>>>>,\n+    const_: RefCell<FxHashSet<Interned<'tcx, Const<'tcx>>>>,\n }\n \n impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n@@ -121,6 +126,7 @@ impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n             region: RefCell::new(FxHashSet()),\n             existential_predicates: RefCell::new(FxHashSet()),\n             predicates: RefCell::new(FxHashSet()),\n+            const_: RefCell::new(FxHashSet()),\n         }\n     }\n \n@@ -719,15 +725,16 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for Typeck\n                 let local_id_root =\n                     local_id_root.expect(\"trying to hash invalid TypeckTables\");\n \n-                let var_def_id = DefId {\n+                let var_owner_def_id = DefId {\n                     krate: local_id_root.krate,\n-                    index: var_id,\n+                    index: var_id.owner,\n                 };\n                 let closure_def_id = DefId {\n                     krate: local_id_root.krate,\n                     index: closure_expr_id,\n                 };\n-                (hcx.def_path_hash(var_def_id), hcx.def_path_hash(closure_def_id))\n+                ((hcx.def_path_hash(var_owner_def_id), var_id.local_id),\n+                 hcx.def_path_hash(closure_def_id))\n             });\n \n             ich::hash_stable_itemlocalmap(hcx, hasher, closure_tys);\n@@ -806,8 +813,11 @@ pub struct GlobalCtxt<'tcx> {\n     global_arenas: &'tcx GlobalArenas<'tcx>,\n     global_interners: CtxtInterners<'tcx>,\n \n+    cstore: &'tcx CrateStore,\n+\n     pub sess: &'tcx Session,\n \n+\n     pub trans_trait_caches: traits::trans::TransTraitCaches<'tcx>,\n \n     pub dep_graph: DepGraph,\n@@ -817,12 +827,12 @@ pub struct GlobalCtxt<'tcx> {\n \n     /// Map indicating what traits are in scope for places where this\n     /// is relevant; generated by resolve.\n-    trait_map: FxHashMap<HirId, Rc<Vec<TraitCandidate>>>,\n+    trait_map: FxHashMap<DefIndex, Rc<FxHashMap<ItemLocalId, Rc<Vec<TraitCandidate>>>>>,\n \n     /// Export map produced by name resolution.\n-    export_map: FxHashMap<HirId, Rc<Vec<Export>>>,\n+    export_map: FxHashMap<DefId, Rc<Vec<Export>>>,\n \n-    pub named_region_map: resolve_lifetime::NamedRegionMap,\n+    named_region_map: NamedRegionMap,\n \n     pub hir: hir_map::Map<'tcx>,\n \n@@ -837,11 +847,11 @@ pub struct GlobalCtxt<'tcx> {\n     // Records the free variables refrenced by every closure\n     // expression. Do not track deps for this, just recompute it from\n     // scratch every time.\n-    pub freevars: RefCell<FreevarMap>,\n+    freevars: FxHashMap<DefId, Rc<Vec<hir::Freevar>>>,\n \n-    pub maybe_unused_trait_imports: NodeSet,\n+    maybe_unused_trait_imports: FxHashSet<DefId>,\n \n-    pub maybe_unused_extern_crates: Vec<(NodeId, Span)>,\n+    maybe_unused_extern_crates: Vec<(DefId, Span)>,\n \n     // Internal cache for metadata decoding. No need to track deps on this.\n     pub rcache: RefCell<FxHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n@@ -851,16 +861,11 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub inhabitedness_cache: RefCell<FxHashMap<Ty<'tcx>, DefIdForest>>,\n \n-    pub lang_items: middle::lang_items::LanguageItems,\n-\n     /// Set of nodes which mark locals as mutable which end up getting used at\n     /// some point. Local variable definitions not in this set can be warned\n     /// about.\n     pub used_mut_nodes: RefCell<NodeSet>,\n \n-    /// Maps any item's def-id to its stability index.\n-    pub stability: RefCell<stability::Index<'tcx>>,\n-\n     /// Caches the results of trait selection. This cache is used\n     /// for things that do not have to do with the parameters in scope.\n     pub selection_cache: traits::SelectionCache<'tcx>,\n@@ -909,30 +914,6 @@ impl<'tcx> GlobalCtxt<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn crate_name(self, cnum: CrateNum) -> Symbol {\n-        if cnum == LOCAL_CRATE {\n-            self.crate_name\n-        } else {\n-            self.sess.cstore.crate_name(cnum)\n-        }\n-    }\n-\n-    pub fn original_crate_name(self, cnum: CrateNum) -> Symbol {\n-        if cnum == LOCAL_CRATE {\n-            self.crate_name.clone()\n-        } else {\n-            self.sess.cstore.original_crate_name(cnum)\n-        }\n-    }\n-\n-    pub fn crate_disambiguator(self, cnum: CrateNum) -> Symbol {\n-        if cnum == LOCAL_CRATE {\n-            self.sess.local_crate_disambiguator()\n-        } else {\n-            self.sess.cstore.crate_disambiguator(cnum)\n-        }\n-    }\n-\n     pub fn alloc_generics(self, generics: ty::Generics) -> &'gcx ty::Generics {\n         self.global_arenas.generics.alloc(generics)\n     }\n@@ -963,6 +944,32 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.global_arenas.adt_def.alloc(def)\n     }\n \n+    pub fn alloc_byte_array(self, bytes: &[u8]) -> &'gcx [u8] {\n+        if bytes.is_empty() {\n+            &[]\n+        } else {\n+            self.global_interners.arena.alloc_slice(bytes)\n+        }\n+    }\n+\n+    pub fn alloc_const_slice(self, values: &[&'tcx ty::Const<'tcx>])\n+                             -> &'tcx [&'tcx ty::Const<'tcx>] {\n+        if values.is_empty() {\n+            &[]\n+        } else {\n+            self.interners.arena.alloc_slice(values)\n+        }\n+    }\n+\n+    pub fn alloc_name_const_slice(self, values: &[(ast::Name, &'tcx ty::Const<'tcx>)])\n+                                  -> &'tcx [(ast::Name, &'tcx ty::Const<'tcx>)] {\n+        if values.is_empty() {\n+            &[]\n+        } else {\n+            self.interners.arena.alloc_slice(values)\n+        }\n+    }\n+\n     pub fn intern_stability(self, stab: attr::Stability) -> &'gcx attr::Stability {\n         if let Some(st) = self.stability_interner.borrow().get(&stab) {\n             return st;\n@@ -1008,6 +1015,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// value (types, substs, etc.) can only be used while `ty::tls` has a valid\n     /// reference to the context, to allow formatting values that need it.\n     pub fn create_and_enter<F, R>(s: &'tcx Session,\n+                                  cstore: &'tcx CrateStore,\n                                   local_providers: ty::maps::Providers<'tcx>,\n                                   extern_providers: ty::maps::Providers<'tcx>,\n                                   mir_passes: Rc<Passes>,\n@@ -1016,8 +1024,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                   resolutions: ty::Resolutions,\n                                   named_region_map: resolve_lifetime::NamedRegionMap,\n                                   hir: hir_map::Map<'tcx>,\n-                                  lang_items: middle::lang_items::LanguageItems,\n-                                  stability: stability::Index<'tcx>,\n                                   crate_name: &str,\n                                   f: F) -> R\n                                   where F: for<'b> FnOnce(TyCtxt<'b, 'tcx, 'tcx>) -> R\n@@ -1026,16 +1032,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let interners = CtxtInterners::new(arena);\n         let common_types = CommonTypes::new(&interners);\n         let dep_graph = hir.dep_graph.clone();\n-        let max_cnum = s.cstore.crates().iter().map(|c| c.as_usize()).max().unwrap_or(0);\n+        let max_cnum = cstore.crates_untracked().iter().map(|c| c.as_usize()).max().unwrap_or(0);\n         let mut providers = IndexVec::from_elem_n(extern_providers, max_cnum + 1);\n         providers[LOCAL_CRATE] = local_providers;\n \n         let def_path_hash_to_def_id = if s.opts.build_dep_graph() {\n-            let upstream_def_path_tables: Vec<(CrateNum, Rc<_>)> = s\n-                .cstore\n-                .crates()\n+            let upstream_def_path_tables: Vec<(CrateNum, Rc<_>)> = cstore\n+                .crates_untracked()\n                 .iter()\n-                .map(|&cnum| (cnum, s.cstore.def_path_table(cnum)))\n+                .map(|&cnum| (cnum, cstore.def_path_table(cnum)))\n                 .collect();\n \n             let def_path_tables = || {\n@@ -1063,33 +1068,73 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             None\n         };\n \n+        let mut trait_map = FxHashMap();\n+        for (k, v) in resolutions.trait_map {\n+            let hir_id = hir.node_to_hir_id(k);\n+            let map = trait_map.entry(hir_id.owner)\n+                .or_insert_with(|| Rc::new(FxHashMap()));\n+            Rc::get_mut(map).unwrap().insert(hir_id.local_id, Rc::new(v));\n+        }\n+        let mut defs = FxHashMap();\n+        for (k, v) in named_region_map.defs {\n+            let hir_id = hir.node_to_hir_id(k);\n+            let map = defs.entry(hir_id.owner)\n+                .or_insert_with(|| Rc::new(FxHashMap()));\n+            Rc::get_mut(map).unwrap().insert(hir_id.local_id, v);\n+        }\n+        let mut late_bound = FxHashMap();\n+        for k in named_region_map.late_bound {\n+            let hir_id = hir.node_to_hir_id(k);\n+            let map = late_bound.entry(hir_id.owner)\n+                .or_insert_with(|| Rc::new(FxHashSet()));\n+            Rc::get_mut(map).unwrap().insert(hir_id.local_id);\n+        }\n+        let mut object_lifetime_defaults = FxHashMap();\n+        for (k, v) in named_region_map.object_lifetime_defaults {\n+            let hir_id = hir.node_to_hir_id(k);\n+            let map = object_lifetime_defaults.entry(hir_id.owner)\n+                .or_insert_with(|| Rc::new(FxHashMap()));\n+            Rc::get_mut(map).unwrap().insert(hir_id.local_id, Rc::new(v));\n+        }\n+\n         tls::enter_global(GlobalCtxt {\n             sess: s,\n+            cstore,\n             trans_trait_caches: traits::trans::TransTraitCaches::new(dep_graph.clone()),\n             global_arenas: arenas,\n             global_interners: interners,\n             dep_graph: dep_graph.clone(),\n             types: common_types,\n-            named_region_map,\n-            trait_map: resolutions.trait_map.into_iter().map(|(k, v)| {\n-                (hir.node_to_hir_id(k), Rc::new(v))\n-            }).collect(),\n+            named_region_map: NamedRegionMap {\n+                defs,\n+                late_bound,\n+                object_lifetime_defaults,\n+            },\n+            trait_map,\n             export_map: resolutions.export_map.into_iter().map(|(k, v)| {\n-                (hir.node_to_hir_id(k), Rc::new(v))\n+                (k, Rc::new(v))\n             }).collect(),\n+            freevars: resolutions.freevars.into_iter().map(|(k, v)| {\n+                (hir.local_def_id(k), Rc::new(v))\n+            }).collect(),\n+            maybe_unused_trait_imports:\n+                resolutions.maybe_unused_trait_imports\n+                    .into_iter()\n+                    .map(|id| hir.local_def_id(id))\n+                    .collect(),\n+            maybe_unused_extern_crates:\n+                resolutions.maybe_unused_extern_crates\n+                    .into_iter()\n+                    .map(|(id, sp)| (hir.local_def_id(id), sp))\n+                    .collect(),\n             hir,\n             def_path_hash_to_def_id,\n             maps: maps::Maps::new(providers),\n             mir_passes,\n-            freevars: RefCell::new(resolutions.freevars),\n-            maybe_unused_trait_imports: resolutions.maybe_unused_trait_imports,\n-            maybe_unused_extern_crates: resolutions.maybe_unused_extern_crates,\n             rcache: RefCell::new(FxHashMap()),\n             normalized_cache: RefCell::new(FxHashMap()),\n             inhabitedness_cache: RefCell::new(FxHashMap()),\n-            lang_items,\n             used_mut_nodes: RefCell::new(NodeSet()),\n-            stability: RefCell::new(stability),\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n             rvalue_promotable_to_static: RefCell::new(NodeMap()),\n@@ -1107,6 +1152,80 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let cname = self.crate_name(LOCAL_CRATE).as_str();\n         self.sess.consider_optimizing(&cname, msg)\n     }\n+\n+    pub fn lang_items(self) -> Rc<middle::lang_items::LanguageItems> {\n+        // FIXME(#42293) Right now we insert a `with_ignore` node in the dep\n+        // graph here to ignore the fact that `get_lang_items` below depends on\n+        // the entire crate.  For now this'll prevent false positives of\n+        // recompiling too much when anything changes.\n+        //\n+        // Once red/green incremental compilation lands we should be able to\n+        // remove this because while the crate changes often the lint level map\n+        // will change rarely.\n+        self.dep_graph.with_ignore(|| {\n+            self.get_lang_items(LOCAL_CRATE)\n+        })\n+    }\n+\n+    pub fn stability(self) -> Rc<stability::Index<'tcx>> {\n+        // FIXME(#42293) we should actually track this, but fails too many tests\n+        // today.\n+        self.dep_graph.with_ignore(|| {\n+            self.stability_index(LOCAL_CRATE)\n+        })\n+    }\n+\n+    pub fn crates(self) -> Rc<Vec<CrateNum>> {\n+        self.all_crate_nums(LOCAL_CRATE)\n+    }\n+\n+    pub fn def_key(self, id: DefId) -> hir_map::DefKey {\n+        if id.is_local() {\n+            self.hir.def_key(id)\n+        } else {\n+            self.cstore.def_key(id)\n+        }\n+    }\n+\n+    /// Convert a `DefId` into its fully expanded `DefPath` (every\n+    /// `DefId` is really just an interned def-path).\n+    ///\n+    /// Note that if `id` is not local to this crate, the result will\n+    ///  be a non-local `DefPath`.\n+    pub fn def_path(self, id: DefId) -> hir_map::DefPath {\n+        if id.is_local() {\n+            self.hir.def_path(id)\n+        } else {\n+            self.cstore.def_path(id)\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn def_path_hash(self, def_id: DefId) -> hir_map::DefPathHash {\n+        if def_id.is_local() {\n+            self.hir.definitions().def_path_hash(def_id.index)\n+        } else {\n+            self.cstore.def_path_hash(def_id)\n+        }\n+    }\n+\n+    pub fn metadata_encoding_version(self) -> Vec<u8> {\n+        self.cstore.metadata_encoding_version().to_vec()\n+    }\n+\n+    // Note that this is *untracked* and should only be used within the query\n+    // system if the result is otherwise tracked through queries\n+    pub fn crate_data_as_rc_any(self, cnum: CrateNum) -> Rc<Any> {\n+        self.cstore.crate_data_as_rc_any(cnum)\n+    }\n+}\n+\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+    pub fn encode_metadata(self, link_meta: &LinkMeta, reachable: &NodeSet)\n+        -> (EncodedMetadata, EncodedMetadataHashes)\n+    {\n+        self.cstore.encode_metadata(self, link_meta, reachable)\n+    }\n }\n \n impl<'gcx: 'tcx, 'tcx> GlobalCtxt<'gcx> {\n@@ -1141,18 +1260,6 @@ pub trait Lift<'tcx> {\n     fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted>;\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for ty::ParamEnv<'a> {\n-    type Lifted = ty::ParamEnv<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<ty::ParamEnv<'tcx>> {\n-        self.caller_bounds.lift_to_tcx(tcx).and_then(|caller_bounds| {\n-            Some(ty::ParamEnv {\n-                reveal: self.reveal,\n-                caller_bounds,\n-            })\n-        })\n-    }\n-}\n-\n impl<'a, 'tcx> Lift<'tcx> for Ty<'a> {\n     type Lifted = Ty<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Ty<'tcx>> {\n@@ -1168,13 +1275,10 @@ impl<'a, 'tcx> Lift<'tcx> for Ty<'a> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n-    type Lifted = &'tcx Substs<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx Substs<'tcx>> {\n-        if self.len() == 0 {\n-            return Some(Slice::empty());\n-        }\n-        if tcx.interners.arena.in_arena(&self[..] as *const _) {\n+impl<'a, 'tcx> Lift<'tcx> for Region<'a> {\n+    type Lifted = Region<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Region<'tcx>> {\n+        if tcx.interners.arena.in_arena(*self as *const _) {\n             return Some(unsafe { mem::transmute(*self) });\n         }\n         // Also try in the global tcx if we're not that.\n@@ -1186,9 +1290,9 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for Region<'a> {\n-    type Lifted = Region<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Region<'tcx>> {\n+impl<'a, 'tcx> Lift<'tcx> for &'a Const<'a> {\n+    type Lifted = &'tcx Const<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx Const<'tcx>> {\n         if tcx.interners.arena.in_arena(*self as *const _) {\n             return Some(unsafe { mem::transmute(*self) });\n         }\n@@ -1201,6 +1305,24 @@ impl<'a, 'tcx> Lift<'tcx> for Region<'a> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n+    type Lifted = &'tcx Substs<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx Substs<'tcx>> {\n+        if self.len() == 0 {\n+            return Some(Slice::empty());\n+        }\n+        if tcx.interners.arena.in_arena(&self[..] as *const _) {\n+            return Some(unsafe { mem::transmute(*self) });\n+        }\n+        // Also try in the global tcx if we're not that.\n+        if !tcx.is_global() {\n+            self.lift_to_tcx(tcx.global_tcx())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx> Lift<'tcx> for &'a Slice<Ty<'a>> {\n     type Lifted = &'tcx Slice<Ty<'tcx>>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n@@ -1488,6 +1610,12 @@ impl<'tcx: 'lcx, 'lcx> Borrow<[Predicate<'lcx>]>\n     }\n }\n \n+impl<'tcx: 'lcx, 'lcx> Borrow<Const<'lcx>> for Interned<'tcx, Const<'tcx>> {\n+    fn borrow<'a>(&'a self) -> &'a Const<'lcx> {\n+        &self.0\n+    }\n+}\n+\n macro_rules! intern_method {\n     ($lt_tcx:tt, $name:ident: $method:ident($alloc:ty,\n                                             $alloc_method:ident,\n@@ -1568,7 +1696,8 @@ direct_interners!('tcx,\n             &ty::ReVar(_) | &ty::ReSkolemized(..) => true,\n             _ => false\n         }\n-    }) -> RegionKind\n+    }) -> RegionKind,\n+    const_: mk_const(|c: &Const| keep_local(&c.ty) || keep_local(&c.val)) -> Const<'tcx>\n );\n \n macro_rules! slice_interners {\n@@ -1685,8 +1814,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_imm_ptr(self.mk_nil())\n     }\n \n-    pub fn mk_array(self, ty: Ty<'tcx>, n: usize) -> Ty<'tcx> {\n-        self.mk_ty(TyArray(ty, n))\n+    pub fn mk_array(self, ty: Ty<'tcx>, n: u64) -> Ty<'tcx> {\n+        let n = ConstUsize::new(n, self.sess.target.usize_ty).unwrap();\n+        self.mk_array_const_usize(ty, n)\n+    }\n+\n+    pub fn mk_array_const_usize(self, ty: Ty<'tcx>, n: ConstUsize) -> Ty<'tcx> {\n+        self.mk_ty(TyArray(ty, self.mk_const(ty::Const {\n+            val: ConstVal::Integral(ConstInt::Usize(n)),\n+            ty: self.types.usize\n+        })))\n     }\n \n     pub fn mk_slice(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n@@ -1948,6 +2085,29 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let (level, src) = self.lint_level_at_node(lint, id);\n         lint::struct_lint_level(self.sess, lint, level, src, None, msg)\n     }\n+\n+    pub fn in_scope_traits(self, id: HirId) -> Option<Rc<Vec<TraitCandidate>>> {\n+        self.in_scope_traits_map(id.owner)\n+            .and_then(|map| map.get(&id.local_id).cloned())\n+    }\n+\n+    pub fn named_region(self, id: HirId) -> Option<resolve_lifetime::Region> {\n+        self.named_region_map(id.owner)\n+            .and_then(|map| map.get(&id.local_id).cloned())\n+    }\n+\n+    pub fn is_late_bound(self, id: HirId) -> bool {\n+        self.is_late_bound_map(id.owner)\n+            .map(|set| set.contains(&id.local_id))\n+            .unwrap_or(false)\n+    }\n+\n+    pub fn object_lifetime_defaults(self, id: HirId)\n+        -> Option<Rc<Vec<ObjectLifetimeDefault>>>\n+    {\n+        self.object_lifetime_defaults_map(id.owner)\n+            .and_then(|map| map.get(&id.local_id).cloned())\n+    }\n }\n \n pub trait InternAs<T: ?Sized, R> {\n@@ -1994,19 +2154,68 @@ impl<T, R, E> InternIteratorElement<T, R> for Result<T, E> {\n     }\n }\n \n-fn in_scope_traits<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: HirId)\n-    -> Option<Rc<Vec<TraitCandidate>>>\n-{\n-    tcx.gcx.trait_map.get(&id).cloned()\n-}\n-\n-fn module_exports<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: HirId)\n-    -> Option<Rc<Vec<Export>>>\n-{\n-    tcx.gcx.export_map.get(&id).cloned()\n+struct NamedRegionMap {\n+    defs: FxHashMap<DefIndex, Rc<FxHashMap<ItemLocalId, resolve_lifetime::Region>>>,\n+    late_bound: FxHashMap<DefIndex, Rc<FxHashSet<ItemLocalId>>>,\n+    object_lifetime_defaults:\n+        FxHashMap<\n+            DefIndex,\n+            Rc<FxHashMap<ItemLocalId, Rc<Vec<ObjectLifetimeDefault>>>>,\n+        >,\n }\n \n pub fn provide(providers: &mut ty::maps::Providers) {\n-    providers.in_scope_traits = in_scope_traits;\n-    providers.module_exports = module_exports;\n+    // FIXME(#44234) - almost all of these queries have no sub-queries and\n+    // therefore no actual inputs, they're just reading tables calculated in\n+    // resolve! Does this work? Unsure! That's what the issue is about\n+    providers.in_scope_traits_map = |tcx, id| tcx.gcx.trait_map.get(&id).cloned();\n+    providers.module_exports = |tcx, id| tcx.gcx.export_map.get(&id).cloned();\n+    providers.named_region_map = |tcx, id| tcx.gcx.named_region_map.defs.get(&id).cloned();\n+    providers.is_late_bound_map = |tcx, id| tcx.gcx.named_region_map.late_bound.get(&id).cloned();\n+    providers.object_lifetime_defaults_map = |tcx, id| {\n+        tcx.gcx.named_region_map.object_lifetime_defaults.get(&id).cloned()\n+    };\n+    providers.crate_name = |tcx, id| {\n+        assert_eq!(id, LOCAL_CRATE);\n+        tcx.crate_name\n+    };\n+    providers.get_lang_items = |tcx, id| {\n+        assert_eq!(id, LOCAL_CRATE);\n+        Rc::new(middle::lang_items::collect(tcx))\n+    };\n+    providers.freevars = |tcx, id| tcx.gcx.freevars.get(&id).cloned();\n+    providers.maybe_unused_trait_import = |tcx, id| {\n+        tcx.maybe_unused_trait_imports.contains(&id)\n+    };\n+    providers.maybe_unused_extern_crates = |tcx, cnum| {\n+        assert_eq!(cnum, LOCAL_CRATE);\n+        Rc::new(tcx.maybe_unused_extern_crates.clone())\n+    };\n+\n+    providers.stability_index = |tcx, cnum| {\n+        assert_eq!(cnum, LOCAL_CRATE);\n+        Rc::new(stability::Index::new(tcx))\n+    };\n+    providers.lookup_stability = |tcx, id| {\n+        assert_eq!(id.krate, LOCAL_CRATE);\n+        let id = tcx.hir.definitions().def_index_to_hir_id(id.index);\n+        tcx.stability().local_stability(id)\n+    };\n+    providers.lookup_deprecation_entry = |tcx, id| {\n+        assert_eq!(id.krate, LOCAL_CRATE);\n+        let id = tcx.hir.definitions().def_index_to_hir_id(id.index);\n+        tcx.stability().local_deprecation_entry(id)\n+    };\n+    providers.extern_mod_stmt_cnum = |tcx, id| {\n+        let id = tcx.hir.as_local_node_id(id).unwrap();\n+        tcx.cstore.extern_mod_stmt_cnum_untracked(id)\n+    };\n+    providers.all_crate_nums = |tcx, cnum| {\n+        assert_eq!(cnum, LOCAL_CRATE);\n+        Rc::new(tcx.cstore.crates_untracked())\n+    };\n+    providers.postorder_cnums = |tcx, cnum| {\n+        assert_eq!(cnum, LOCAL_CRATE);\n+        Rc::new(tcx.cstore.postorder_cnums_untracked())\n+    };\n }"}, {"sha": "52a8389bd8f5fcebb63921f425f466310ba6df99", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -10,6 +10,7 @@\n \n use hir::def_id::DefId;\n use infer::type_variable;\n+use middle::const_val::ConstVal;\n use ty::{self, BoundRegion, DefIdTree, Region, Ty, TyCtxt};\n \n use std::fmt;\n@@ -18,6 +19,8 @@ use syntax::ast;\n use errors::DiagnosticBuilder;\n use syntax_pos::Span;\n \n+use rustc_const_math::ConstInt;\n+\n use hir;\n \n #[derive(Clone, Copy, Debug)]\n@@ -34,7 +37,7 @@ pub enum TypeError<'tcx> {\n     AbiMismatch(ExpectedFound<abi::Abi>),\n     Mutability,\n     TupleSize(ExpectedFound<usize>),\n-    FixedArraySize(ExpectedFound<usize>),\n+    FixedArraySize(ExpectedFound<u64>),\n     ArgCount,\n \n     RegionsDoesNotOutlive(Region<'tcx>, Region<'tcx>),\n@@ -179,7 +182,13 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n             ty::TyTuple(ref tys, _) if tys.is_empty() => self.to_string(),\n \n             ty::TyAdt(def, _) => format!(\"{} `{}`\", def.descr(), tcx.item_path_str(def.did)),\n-            ty::TyArray(_, n) => format!(\"array of {} elements\", n),\n+            ty::TyArray(_, n) => {\n+                if let ConstVal::Integral(ConstInt::Usize(n)) = n.val {\n+                    format!(\"array of {} elements\", n)\n+                } else {\n+                    \"array\".to_string()\n+                }\n+            }\n             ty::TySlice(_) => \"slice\".to_string(),\n             ty::TyRawPtr(_) => \"*-ptr\".to_string(),\n             ty::TyRef(region, tymut) => {"}, {"sha": "9ece719c764704b5dc41815f7ade8c1dab3a74cb", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use middle::const_val::{ConstVal, ConstAggregate};\n use ty::subst::Substs;\n use ty::{self, Ty, TypeFlags, TypeFoldable};\n \n@@ -145,7 +146,12 @@ impl FlagComputation {\n                 self.add_region(r);\n             }\n \n-            &ty::TyArray(tt, _) | &ty::TySlice(tt) => {\n+            &ty::TyArray(tt, len) => {\n+                self.add_ty(tt);\n+                self.add_const(len);\n+            }\n+\n+            &ty::TySlice(tt) => {\n                 self.add_ty(tt)\n             }\n \n@@ -202,6 +208,40 @@ impl FlagComputation {\n         }\n     }\n \n+    fn add_const(&mut self, constant: &ty::Const) {\n+        self.add_ty(constant.ty);\n+        match constant.val {\n+            ConstVal::Integral(_) |\n+            ConstVal::Float(_) |\n+            ConstVal::Str(_) |\n+            ConstVal::ByteStr(_) |\n+            ConstVal::Bool(_) |\n+            ConstVal::Char(_) |\n+            ConstVal::Variant(_) => {}\n+            ConstVal::Function(_, substs) => {\n+                self.add_substs(substs);\n+            }\n+            ConstVal::Aggregate(ConstAggregate::Struct(fields)) => {\n+                for &(_, v) in fields {\n+                    self.add_const(v);\n+                }\n+            }\n+            ConstVal::Aggregate(ConstAggregate::Tuple(fields)) |\n+            ConstVal::Aggregate(ConstAggregate::Array(fields)) => {\n+                for v in fields {\n+                    self.add_const(v);\n+                }\n+            }\n+            ConstVal::Aggregate(ConstAggregate::Repeat(v, _)) => {\n+                self.add_const(v);\n+            }\n+            ConstVal::Unevaluated(_, substs) => {\n+                self.add_flags(TypeFlags::HAS_PROJECTION);\n+                self.add_substs(substs);\n+            }\n+        }\n+    }\n+\n     fn add_existential_projection(&mut self, projection: &ty::ExistentialProjection) {\n         self.add_substs(projection.substs);\n         self.add_ty(projection.ty);"}, {"sha": "543e8f3e2f04d9511cbce9a1e1c68eefa9bb306f", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -39,6 +39,7 @@\n //! These methods return true to indicate that the visitor has found what it is looking for\n //! and does not need to visit anything else.\n \n+use middle::const_val::ConstVal;\n use ty::{self, Binder, Ty, TyCtxt, TypeFlags};\n \n use std::fmt;\n@@ -67,7 +68,7 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     fn has_type_flags(&self, flags: TypeFlags) -> bool {\n         self.visit_with(&mut HasTypeFlagsVisitor { flags: flags })\n     }\n-    fn has_projection_types(&self) -> bool {\n+    fn has_projections(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_PROJECTION)\n     }\n     fn references_error(&self) -> bool {\n@@ -139,6 +140,10 @@ pub trait TypeFolder<'gcx: 'tcx, 'tcx> : Sized {\n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         r.super_fold_with(self)\n     }\n+\n+    fn fold_const(&mut self, c: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        c.super_fold_with(self)\n+    }\n }\n \n pub trait TypeVisitor<'tcx> : Sized {\n@@ -153,6 +158,10 @@ pub trait TypeVisitor<'tcx> : Sized {\n     fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n         r.super_visit_with(self)\n     }\n+\n+    fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n+        c.super_visit_with(self)\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -603,6 +612,17 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n         debug!(\"HasTypeFlagsVisitor: r={:?} r.flags={:?} self.flags={:?}\", r, flags, self.flags);\n         flags.intersects(self.flags)\n     }\n+\n+    fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n+        if let ConstVal::Unevaluated(..) = c.val {\n+            let projection_flags = TypeFlags::HAS_NORMALIZABLE_PROJECTION |\n+                TypeFlags::HAS_PROJECTION;\n+            if projection_flags.intersects(self.flags) {\n+                return true;\n+            }\n+        }\n+        c.super_visit_with(self)\n+    }\n }\n \n /// Collects all the late-bound regions it finds into a hash set."}, {"sha": "a829814e0905ba2b9d1c51baf4df34149ec20359", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -205,7 +205,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n                 }))\n             },\n             TyArray(ty, len) => {\n-                if len == 0 {\n+                if len.val.to_const_int().and_then(|i| i.to_u64()) == Some(0) {\n                     DefIdForest::empty()\n                 } else {\n                     ty.uninhabited_from(visited, tcx)"}, {"sha": "a8ccb3e269ffcc00ef8bf2f493add0bb188b0b13", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -13,6 +13,7 @@ use hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use ty::{self, Ty, TyCtxt};\n use syntax::ast;\n use syntax::symbol::Symbol;\n+use syntax::symbol::InternedString;\n \n use std::cell::Cell;\n \n@@ -128,31 +129,31 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn try_push_visible_item_path<T>(self, buffer: &mut T, external_def_id: DefId) -> bool\n         where T: ItemPathBuffer\n     {\n-        let visible_parent_map = self.sess.cstore.visible_parent_map(self.sess);\n+        let visible_parent_map = self.visible_parent_map(LOCAL_CRATE);\n \n-        let (mut cur_def, mut cur_path) = (external_def_id, Vec::<ast::Name>::new());\n+        let (mut cur_def, mut cur_path) = (external_def_id, Vec::<InternedString>::new());\n         loop {\n             // If `cur_def` is a direct or injected extern crate, push the path to the crate\n             // followed by the path to the item within the crate and return.\n             if cur_def.index == CRATE_DEF_INDEX {\n                 match *self.extern_crate(cur_def) {\n                     Some(ref extern_crate) if extern_crate.direct => {\n                         self.push_item_path(buffer, extern_crate.def_id);\n-                        cur_path.iter().rev().map(|segment| buffer.push(&segment.as_str())).count();\n+                        cur_path.iter().rev().map(|segment| buffer.push(&segment)).count();\n                         return true;\n                     }\n                     None => {\n                         buffer.push(&self.crate_name(cur_def.krate).as_str());\n-                        cur_path.iter().rev().map(|segment| buffer.push(&segment.as_str())).count();\n+                        cur_path.iter().rev().map(|segment| buffer.push(&segment)).count();\n                         return true;\n                     }\n                     _ => {},\n                 }\n             }\n \n-            cur_path.push(self.sess.cstore.def_key(cur_def)\n+            cur_path.push(self.def_key(cur_def)\n                               .disambiguated_data.data.get_opt_name().unwrap_or_else(||\n-                Symbol::intern(\"<unnamed>\")));\n+                Symbol::intern(\"<unnamed>\").as_str()));\n             match visible_parent_map.get(&cur_def) {\n                 Some(&def) => cur_def = def,\n                 None => return false,\n@@ -194,7 +195,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             data @ DefPathData::Initializer |\n             data @ DefPathData::MacroDef(..) |\n             data @ DefPathData::ClosureExpr |\n-            data @ DefPathData::Binding(..) |\n             data @ DefPathData::ImplTrait |\n             data @ DefPathData::Typeof |\n             data @ DefPathData::GlobalMetaData(..) => {"}, {"sha": "0106d98b64130e1938929322e0eb03e1ff007bac", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -837,12 +837,22 @@ impl<'a, 'tcx> Struct {\n \n             // Is this a fixed-size array of something non-zero\n             // with at least one element?\n-            (_, &ty::TyArray(ety, d)) if d > 0 => {\n-                Struct::non_zero_field_paths(\n-                    tcx,\n-                    param_env,\n-                    Some(ety).into_iter(),\n-                    None)\n+            (_, &ty::TyArray(ety, mut count)) => {\n+                if count.has_projections() {\n+                    count = tcx.normalize_associated_type_in_env(&count, param_env);\n+                    if count.has_projections() {\n+                        return Err(LayoutError::Unknown(ty));\n+                    }\n+                }\n+                if count.val.to_const_int().unwrap().to_u64().unwrap() != 0 {\n+                    Struct::non_zero_field_paths(\n+                        tcx,\n+                        param_env,\n+                        Some(ety).into_iter(),\n+                        None)\n+                } else {\n+                    Ok(None)\n+                }\n             }\n \n             (_, &ty::TyProjection(_)) | (_, &ty::TyAnon(..)) => {\n@@ -1174,12 +1184,17 @@ impl<'a, 'tcx> Layout {\n             }\n \n             // Arrays and slices.\n-            ty::TyArray(element, count) => {\n+            ty::TyArray(element, mut count) => {\n+                if count.has_projections() {\n+                    count = tcx.normalize_associated_type_in_env(&count, param_env);\n+                    if count.has_projections() {\n+                        return Err(LayoutError::Unknown(ty));\n+                    }\n+                }\n+\n                 let element = element.layout(tcx, param_env)?;\n                 let element_size = element.size(dl);\n-                // FIXME(eddyb) Don't use host `usize` for array lengths.\n-                let usize_count: usize = count;\n-                let count = usize_count as u64;\n+                let count = count.val.to_const_int().unwrap().to_u64().unwrap();\n                 if element_size.checked_mul(count, dl).is_none() {\n                     return Err(LayoutError::SizeOverflow(ty));\n                 }\n@@ -1344,7 +1359,7 @@ impl<'a, 'tcx> Layout {\n                     } else {\n                         let st = Struct::new(dl, &fields, &def.repr,\n                           kind, ty)?;\n-                        let non_zero = Some(def.did) == tcx.lang_items.non_zero();\n+                        let non_zero = Some(def.did) == tcx.lang_items().non_zero();\n                         Univariant { variant: st, non_zero: non_zero }\n                     };\n                     return success(layout);\n@@ -2043,7 +2058,7 @@ impl<'a, 'tcx> SizeSkeleton<'tcx> {\n                     if let Some(SizeSkeleton::Pointer { non_zero, tail }) = v0 {\n                         return Ok(SizeSkeleton::Pointer {\n                             non_zero: non_zero ||\n-                                Some(def.did) == tcx.lang_items.non_zero(),\n+                                Some(def.did) == tcx.lang_items().non_zero(),\n                             tail,\n                         });\n                     } else {"}, {"sha": "18c59d405a2014c6f5ea5963794679d7a3b6d738", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 302, "deletions": 37, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -10,14 +10,19 @@\n \n use dep_graph::{DepConstructor, DepNode, DepNodeIndex};\n use errors::{Diagnostic, DiagnosticBuilder};\n-use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use hir::def_id::{CrateNum, DefId, LOCAL_CRATE, DefIndex};\n use hir::def::{Def, Export};\n-use hir::{self, TraitCandidate, HirId};\n+use hir::{self, TraitCandidate, ItemLocalId};\n+use hir::svh::Svh;\n use lint;\n use middle::const_val;\n-use middle::cstore::{ExternCrate, LinkagePreference};\n+use middle::cstore::{ExternCrate, LinkagePreference, NativeLibrary};\n+use middle::cstore::{NativeLibraryKind, DepKind, CrateSource};\n use middle::privacy::AccessLevels;\n use middle::region;\n+use middle::resolve_lifetime::{Region, ObjectLifetimeDefault};\n+use middle::stability::{self, DeprecationEntry};\n+use middle::lang_items::{LanguageItems, LangItem};\n use mir;\n use mir::transform::{MirSuite, MirPassIndex};\n use session::CompileResult;\n@@ -28,12 +33,13 @@ use ty::item_path;\n use ty::steal::Steal;\n use ty::subst::Substs;\n use ty::fast_reject::SimplifiedType;\n-use util::nodemap::{DefIdSet, NodeSet};\n+use util::nodemap::{DefIdSet, NodeSet, DefIdMap};\n use util::common::{profq_msg, ProfileQueriesMsg};\n \n use rustc_data_structures::indexed_set::IdxSetBuf;\n+use rustc_back::PanicStrategy;\n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use std::cell::{RefCell, RefMut, Cell};\n use std::fmt::Debug;\n use std::hash::Hash;\n@@ -81,7 +87,7 @@ impl Key for CrateNum {\n     }\n }\n \n-impl Key for HirId {\n+impl Key for DefIndex {\n     fn map_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -153,7 +159,7 @@ impl Key for (MirSuite, MirPassIndex, DefId) {\n     }\n }\n \n-impl<'tcx, T: Clone + Hash + Eq + Debug> Key for ty::ParamEnvAnd<'tcx, T> {\n+impl<'tcx> Key for Ty<'tcx> {\n     fn map_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -162,6 +168,15 @@ impl<'tcx, T: Clone + Hash + Eq + Debug> Key for ty::ParamEnvAnd<'tcx, T> {\n     }\n }\n \n+impl<'tcx, T: Key> Key for ty::ParamEnvAnd<'tcx, T> {\n+    fn map_crate(&self) -> CrateNum {\n+        self.value.map_crate()\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        self.value.default_span(tcx)\n+    }\n+}\n+\n trait Value<'tcx>: Sized {\n     fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self;\n }\n@@ -428,13 +443,13 @@ impl<'tcx> QueryDescription for queries::def_span<'tcx> {\n }\n \n \n-impl<'tcx> QueryDescription for queries::stability<'tcx> {\n+impl<'tcx> QueryDescription for queries::lookup_stability<'tcx> {\n     fn describe(_: TyCtxt, _: DefId) -> String {\n         bug!(\"stability\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::deprecation<'tcx> {\n+impl<'tcx> QueryDescription for queries::lookup_deprecation_entry<'tcx> {\n     fn describe(_: TyCtxt, _: DefId) -> String {\n         bug!(\"deprecation\")\n     }\n@@ -509,31 +524,25 @@ impl<'tcx> QueryDescription for queries::is_const_fn<'tcx> {\n }\n \n impl<'tcx> QueryDescription for queries::dylib_dependency_formats<'tcx> {\n-    fn describe(_: TyCtxt, _: DefId) -> String {\n+    fn describe(_: TyCtxt, _: CrateNum) -> String {\n         \"dylib dependency formats of crate\".to_string()\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::is_allocator<'tcx> {\n-    fn describe(_: TyCtxt, _: DefId) -> String {\n-        \"checking if the crate is_allocator\".to_string()\n-    }\n-}\n-\n impl<'tcx> QueryDescription for queries::is_panic_runtime<'tcx> {\n-    fn describe(_: TyCtxt, _: DefId) -> String {\n+    fn describe(_: TyCtxt, _: CrateNum) -> String {\n         \"checking if the crate is_panic_runtime\".to_string()\n     }\n }\n \n impl<'tcx> QueryDescription for queries::is_compiler_builtins<'tcx> {\n-    fn describe(_: TyCtxt, _: DefId) -> String {\n+    fn describe(_: TyCtxt, _: CrateNum) -> String {\n         \"checking if the crate is_compiler_builtins\".to_string()\n     }\n }\n \n impl<'tcx> QueryDescription for queries::has_global_allocator<'tcx> {\n-    fn describe(_: TyCtxt, _: DefId) -> String {\n+    fn describe(_: TyCtxt, _: CrateNum) -> String {\n         \"checking if the crate has_global_allocator\".to_string()\n     }\n }\n@@ -556,15 +565,183 @@ impl<'tcx> QueryDescription for queries::specializes<'tcx> {\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::in_scope_traits<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: HirId) -> String {\n-        format!(\"fetching the traits in scope at a particular ast node\")\n+impl<'tcx> QueryDescription for queries::in_scope_traits_map<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: DefIndex) -> String {\n+        format!(\"traits in scope at a block\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_no_builtins<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"test whether a crate has #![no_builtins]\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::panic_strategy<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"query a crate's configured panic strategy\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_profiler_runtime<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"query a crate is #![profiler_runtime]\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_sanitizer_runtime<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"query a crate is #![sanitizer_runtime]\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::exported_symbols<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up the exported symbols of a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::native_libraries<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up the native libraries of a linked crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::plugin_registrar_fn<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up the plugin registrar for a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::derive_registrar_fn<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up the derive registrar for a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::crate_disambiguator<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up the disambiguator a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::crate_hash<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up the hash a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::original_crate_name<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up the original name a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::implementations_of_trait<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: (CrateNum, DefId)) -> String {\n+        format!(\"looking up implementations of a trait in a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::all_trait_implementations<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up all (?) trait implementations\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::link_args<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up link arguments for a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::named_region_map<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: DefIndex) -> String {\n+        format!(\"looking up a named region\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_late_bound_map<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: DefIndex) -> String {\n+        format!(\"testing if a region is late boudn\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::object_lifetime_defaults_map<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: DefIndex) -> String {\n+        format!(\"looking up lifetime defaults for a region\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::dep_kind<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"fetching what a dependency looks like\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::crate_name<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"fetching what a crate is named\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::get_lang_items<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"calculating the lang items map\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::defined_lang_items<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"calculating the lang items defined in a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::missing_lang_items<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"calculating the missing lang items in a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::visible_parent_map<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"calculating the visible parent map\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::missing_extern_crate_item<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"seeing if we're missing an `extern crate` item for this crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::used_crate_source<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking at the source for a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::postorder_cnums<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"generating a postorder list of CrateNums\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::maybe_unused_extern_crates<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up all possibly unused extern crates\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::stability_index<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"calculating the stability index for the local crate\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::module_exports<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: HirId) -> String {\n-        format!(\"fetching the exported items for a module\")\n+impl<'tcx> QueryDescription for queries::all_crate_nums<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"fetching all foreign CrateNum instances\")\n     }\n }\n \n@@ -1092,8 +1269,8 @@ define_maps! { <'tcx>\n \n     [] fn describe_def: DescribeDef(DefId) -> Option<Def>,\n     [] fn def_span: DefSpan(DefId) -> Span,\n-    [] fn stability: Stability(DefId) -> Option<attr::Stability>,\n-    [] fn deprecation: Deprecation(DefId) -> Option<attr::Deprecation>,\n+    [] fn lookup_stability: LookupStability(DefId) -> Option<&'tcx attr::Stability>,\n+    [] fn lookup_deprecation_entry: LookupDeprecationEntry(DefId) -> Option<DeprecationEntry>,\n     [] fn item_attrs: ItemAttrs(DefId) -> Rc<[ast::Attribute]>,\n     [] fn fn_arg_names: FnArgNames(DefId) -> Vec<ast::Name>,\n     [] fn impl_parent: ImplParent(DefId) -> Option<DefId>,\n@@ -1125,21 +1302,75 @@ define_maps! { <'tcx>\n     [] fn layout_raw: layout_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n                                   -> Result<&'tcx Layout, LayoutError<'tcx>>,\n \n-    [] fn dylib_dependency_formats: DylibDepFormats(DefId)\n+    [] fn dylib_dependency_formats: DylibDepFormats(CrateNum)\n                                     -> Rc<Vec<(CrateNum, LinkagePreference)>>,\n \n-    [] fn is_allocator: IsAllocator(DefId) -> bool,\n-    [] fn is_panic_runtime: IsPanicRuntime(DefId) -> bool,\n-    [] fn is_compiler_builtins: IsCompilerBuiltins(DefId) -> bool,\n-    [] fn has_global_allocator: HasGlobalAllocator(DefId) -> bool,\n+    [] fn is_panic_runtime: IsPanicRuntime(CrateNum) -> bool,\n+    [] fn is_compiler_builtins: IsCompilerBuiltins(CrateNum) -> bool,\n+    [] fn has_global_allocator: HasGlobalAllocator(CrateNum) -> bool,\n+    [] fn is_sanitizer_runtime: IsSanitizerRuntime(CrateNum) -> bool,\n+    [] fn is_profiler_runtime: IsProfilerRuntime(CrateNum) -> bool,\n+    [] fn panic_strategy: GetPanicStrategy(CrateNum) -> PanicStrategy,\n+    [] fn is_no_builtins: IsNoBuiltins(CrateNum) -> bool,\n \n     [] fn extern_crate: ExternCrate(DefId) -> Rc<Option<ExternCrate>>,\n \n-    [] fn lint_levels: lint_levels(CrateNum) -> Rc<lint::LintLevelMap>,\n-\n     [] fn specializes: specializes_node((DefId, DefId)) -> bool,\n-    [] fn in_scope_traits: InScopeTraits(HirId) -> Option<Rc<Vec<TraitCandidate>>>,\n-    [] fn module_exports: ModuleExports(HirId) -> Option<Rc<Vec<Export>>>,\n+    [] fn in_scope_traits_map: InScopeTraits(DefIndex)\n+        -> Option<Rc<FxHashMap<ItemLocalId, Rc<Vec<TraitCandidate>>>>>,\n+    [] fn module_exports: ModuleExports(DefId) -> Option<Rc<Vec<Export>>>,\n+    [] fn lint_levels: lint_levels_node(CrateNum) -> Rc<lint::LintLevelMap>,\n+\n+    [] fn impl_defaultness: ImplDefaultness(DefId) -> hir::Defaultness,\n+    [] fn exported_symbols: ExportedSymbols(CrateNum) -> Rc<Vec<DefId>>,\n+    [] fn native_libraries: NativeLibraries(CrateNum) -> Rc<Vec<NativeLibrary>>,\n+    [] fn plugin_registrar_fn: PluginRegistrarFn(CrateNum) -> Option<DefId>,\n+    [] fn derive_registrar_fn: DeriveRegistrarFn(CrateNum) -> Option<DefId>,\n+    [] fn crate_disambiguator: CrateDisambiguator(CrateNum) -> Symbol,\n+    [] fn crate_hash: CrateHash(CrateNum) -> Svh,\n+    [] fn original_crate_name: OriginalCrateName(CrateNum) -> Symbol,\n+\n+    [] fn implementations_of_trait: implementations_of_trait_node((CrateNum, DefId))\n+        -> Rc<Vec<DefId>>,\n+    [] fn all_trait_implementations: AllTraitImplementations(CrateNum)\n+        -> Rc<Vec<DefId>>,\n+\n+    [] fn is_dllimport_foreign_item: IsDllimportForeignItem(DefId) -> bool,\n+    [] fn is_statically_included_foreign_item: IsStaticallyIncludedForeignItem(DefId) -> bool,\n+    [] fn native_library_kind: NativeLibraryKind(DefId)\n+        -> Option<NativeLibraryKind>,\n+    [] fn link_args: link_args_node(CrateNum) -> Rc<Vec<String>>,\n+\n+    [] fn named_region_map: NamedRegion(DefIndex) ->\n+        Option<Rc<FxHashMap<ItemLocalId, Region>>>,\n+    [] fn is_late_bound_map: IsLateBound(DefIndex) ->\n+        Option<Rc<FxHashSet<ItemLocalId>>>,\n+    [] fn object_lifetime_defaults_map: ObjectLifetimeDefaults(DefIndex)\n+        -> Option<Rc<FxHashMap<ItemLocalId, Rc<Vec<ObjectLifetimeDefault>>>>>,\n+\n+    [] fn visibility: Visibility(DefId) -> ty::Visibility,\n+    [] fn dep_kind: DepKind(CrateNum) -> DepKind,\n+    [] fn crate_name: CrateName(CrateNum) -> Symbol,\n+    [] fn item_children: ItemChildren(DefId) -> Rc<Vec<Export>>,\n+    [] fn extern_mod_stmt_cnum: ExternModStmtCnum(DefId) -> Option<CrateNum>,\n+\n+    [] fn get_lang_items: get_lang_items_node(CrateNum) -> Rc<LanguageItems>,\n+    [] fn defined_lang_items: DefinedLangItems(CrateNum) -> Rc<Vec<(DefIndex, usize)>>,\n+    [] fn missing_lang_items: MissingLangItems(CrateNum) -> Rc<Vec<LangItem>>,\n+    [] fn extern_const_body: ExternConstBody(DefId) -> &'tcx hir::Body,\n+    [] fn visible_parent_map: visible_parent_map_node(CrateNum)\n+        -> Rc<DefIdMap<DefId>>,\n+    [] fn missing_extern_crate_item: MissingExternCrateItem(CrateNum) -> bool,\n+    [] fn used_crate_source: UsedCrateSource(CrateNum) -> Rc<CrateSource>,\n+    [] fn postorder_cnums: postorder_cnums_node(CrateNum) -> Rc<Vec<CrateNum>>,\n+\n+    [] fn freevars: Freevars(DefId) -> Option<Rc<Vec<hir::Freevar>>>,\n+    [] fn maybe_unused_trait_import: MaybeUnusedTraitImport(DefId) -> bool,\n+    [] fn maybe_unused_extern_crates: maybe_unused_extern_crates_node(CrateNum)\n+        -> Rc<Vec<(DefId, Span)>>,\n+\n+    [] fn stability_index: stability_index_node(CrateNum) -> Rc<stability::Index<'tcx>>,\n+    [] fn all_crate_nums: all_crate_nums_node(CrateNum) -> Rc<Vec<CrateNum>>,\n }\n \n fn type_param_predicates<'tcx>((item_id, param_id): (DefId, DefId)) -> DepConstructor<'tcx> {\n@@ -1212,10 +1443,44 @@ fn layout_dep_node<'tcx>(_: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'\n     DepConstructor::Layout\n }\n \n-fn lint_levels<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+fn lint_levels_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n     DepConstructor::LintLevels\n }\n \n fn specializes_node<'tcx>((a, b): (DefId, DefId)) -> DepConstructor<'tcx> {\n     DepConstructor::Specializes { impl1: a, impl2: b }\n }\n+\n+fn implementations_of_trait_node<'tcx>((krate, trait_id): (CrateNum, DefId))\n+    -> DepConstructor<'tcx>\n+{\n+    DepConstructor::ImplementationsOfTrait { krate, trait_id }\n+}\n+\n+fn link_args_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::LinkArgs\n+}\n+\n+fn get_lang_items_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::GetLangItems\n+}\n+\n+fn visible_parent_map_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::VisibleParentMap\n+}\n+\n+fn postorder_cnums_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::PostorderCnums\n+}\n+\n+fn maybe_unused_extern_crates_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::MaybeUnusedExternCrates\n+}\n+\n+fn stability_index_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::StabilityIndex\n+}\n+\n+fn all_crate_nums_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::AllCrateNums\n+}"}, {"sha": "2d5b0ce0954fcba6fd4892cc0f1ff51ace3d4a26", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 45, "deletions": 66, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -64,7 +64,7 @@ pub use self::sty::{InferTy, ParamTy, ProjectionTy, ExistentialPredicate};\n pub use self::sty::{ClosureSubsts, GeneratorInterior, TypeAndMut};\n pub use self::sty::{TraitRef, TypeVariants, PolyTraitRef};\n pub use self::sty::{ExistentialTraitRef, PolyExistentialTraitRef};\n-pub use self::sty::{ExistentialProjection, PolyExistentialProjection};\n+pub use self::sty::{ExistentialProjection, PolyExistentialProjection, Const};\n pub use self::sty::{BoundRegion, EarlyBoundRegion, FreeRegion, Region};\n pub use self::sty::RegionKind;\n pub use self::sty::{TyVid, IntVid, FloatVid, RegionVid, SkolemizedRegionVid};\n@@ -575,7 +575,7 @@ impl<T> Slice<T> {\n /// by the upvar) and the id of the closure expression.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct UpvarId {\n-    pub var_id: DefIndex,\n+    pub var_id: hir::HirId,\n     pub closure_expr_id: DefIndex,\n }\n \n@@ -846,6 +846,9 @@ pub enum Predicate<'tcx> {\n \n     /// `T1 <: T2`\n     Subtype(PolySubtypePredicate<'tcx>),\n+\n+    /// Constant initializer must evaluate successfully.\n+    ConstEvaluatable(DefId, &'tcx Substs<'tcx>),\n }\n \n impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n@@ -938,6 +941,8 @@ impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n                 Predicate::ObjectSafe(trait_def_id),\n             Predicate::ClosureKind(closure_def_id, kind) =>\n                 Predicate::ClosureKind(closure_def_id, kind),\n+            Predicate::ConstEvaluatable(def_id, const_substs) =>\n+                Predicate::ConstEvaluatable(def_id, const_substs.subst(tcx, substs)),\n         }\n     }\n }\n@@ -1017,6 +1022,10 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n         // levels.\n         ty::Binder(self.0.projection_ty.trait_ref(tcx))\n     }\n+\n+    pub fn ty(&self) -> Binder<Ty<'tcx>> {\n+        Binder(self.skip_binder().ty) // preserves binding levels\n+    }\n }\n \n pub trait ToPolyTraitRef<'tcx> {\n@@ -1116,6 +1125,9 @@ impl<'tcx> Predicate<'tcx> {\n             ty::Predicate::ClosureKind(_closure_def_id, _kind) => {\n                 vec![]\n             }\n+            ty::Predicate::ConstEvaluatable(_, substs) => {\n+                substs.types().collect()\n+            }\n         };\n \n         // The only reason to collect into a vector here is that I was\n@@ -1138,7 +1150,8 @@ impl<'tcx> Predicate<'tcx> {\n             Predicate::WellFormed(..) |\n             Predicate::ObjectSafe(..) |\n             Predicate::ClosureKind(..) |\n-            Predicate::TypeOutlives(..) => {\n+            Predicate::TypeOutlives(..) |\n+            Predicate::ConstEvaluatable(..) => {\n                 None\n             }\n         }\n@@ -1447,10 +1460,10 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         if attr::contains_name(&attrs, \"fundamental\") {\n             flags = flags | AdtFlags::IS_FUNDAMENTAL;\n         }\n-        if Some(did) == tcx.lang_items.phantom_data() {\n+        if Some(did) == tcx.lang_items().phantom_data() {\n             flags = flags | AdtFlags::IS_PHANTOM_DATA;\n         }\n-        if Some(did) == tcx.lang_items.owned_box() {\n+        if Some(did) == tcx.lang_items().owned_box() {\n             flags = flags | AdtFlags::IS_BOX;\n         }\n         match kind {\n@@ -1597,7 +1610,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n             if let VariantDiscr::Explicit(expr_did) = v.discr {\n                 let substs = Substs::identity_for_item(tcx.global_tcx(), expr_did);\n                 match tcx.const_eval(param_env.and((expr_did, substs))) {\n-                    Ok(ConstVal::Integral(v)) => {\n+                    Ok(&ty::Const { val: ConstVal::Integral(v), .. }) => {\n                         discr = v;\n                     }\n                     err => {\n@@ -1637,7 +1650,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                 ty::VariantDiscr::Explicit(expr_did) => {\n                     let substs = Substs::identity_for_item(tcx.global_tcx(), expr_did);\n                     match tcx.const_eval(param_env.and((expr_did, substs))) {\n-                        Ok(ConstVal::Integral(v)) => {\n+                        Ok(&ty::Const { val: ConstVal::Integral(v), .. }) => {\n                             explicit_value = v;\n                             break;\n                         }\n@@ -1661,11 +1674,11 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         match repr_type {\n             attr::UnsignedInt(ty) => {\n                 ConstInt::new_unsigned_truncating(discr, ty,\n-                                                  tcx.sess.target.uint_type)\n+                                                  tcx.sess.target.usize_ty)\n             }\n             attr::SignedInt(ty) => {\n                 ConstInt::new_signed_truncating(discr as i128, ty,\n-                                                tcx.sess.target.int_type)\n+                                                tcx.sess.target.isize_ty)\n             }\n         }\n     }\n@@ -1746,7 +1759,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                 // we know that `T` is Sized and do not need to check\n                 // it on the impl.\n \n-                let sized_trait = match tcx.lang_items.sized_trait() {\n+                let sized_trait = match tcx.lang_items().sized_trait() {\n                     Some(x) => x,\n                     _ => return vec![ty]\n                 };\n@@ -1975,25 +1988,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn local_var_name_str(self, id: NodeId) -> InternedString {\n-        match self.hir.find(id) {\n-            Some(hir_map::NodeBinding(pat)) => {\n-                match pat.node {\n-                    hir::PatKind::Binding(_, _, ref path1, _) => path1.node.as_str(),\n-                    _ => {\n-                        bug!(\"Variable id {} maps to {:?}, not local\", id, pat);\n-                    },\n-                }\n-            },\n-            r => bug!(\"Variable id {} maps to {:?}, not local\", id, r),\n-        }\n-    }\n-\n-    pub fn local_var_name_str_def_index(self, def_index: DefIndex) -> InternedString {\n-        let node_id = self.hir.as_local_node_id(DefId::local(def_index)).unwrap();\n-        self.local_var_name_str(node_id)\n-    }\n-\n     pub fn expr_is_lval(self, expr: &hir::Expr) -> bool {\n          match expr.node {\n             hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n@@ -2176,43 +2170,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn def_key(self, id: DefId) -> hir_map::DefKey {\n-        if id.is_local() {\n-            self.hir.def_key(id)\n-        } else {\n-            self.sess.cstore.def_key(id)\n-        }\n-    }\n-\n-    /// Convert a `DefId` into its fully expanded `DefPath` (every\n-    /// `DefId` is really just an interned def-path).\n-    ///\n-    /// Note that if `id` is not local to this crate, the result will\n-    ///  be a non-local `DefPath`.\n-    pub fn def_path(self, id: DefId) -> hir_map::DefPath {\n-        if id.is_local() {\n-            self.hir.def_path(id)\n-        } else {\n-            self.sess.cstore.def_path(id)\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn def_path_hash(self, def_id: DefId) -> hir_map::DefPathHash {\n-        if def_id.is_local() {\n-            self.hir.definitions().def_path_hash(def_id.index)\n-        } else {\n-            self.sess.cstore.def_path_hash(def_id)\n-        }\n-    }\n-\n-    pub fn item_name(self, id: DefId) -> ast::Name {\n+    pub fn item_name(self, id: DefId) -> InternedString {\n         if let Some(id) = self.hir.as_local_node_id(id) {\n-            self.hir.name(id)\n+            self.hir.name(id).as_str()\n         } else if id.index == CRATE_DEF_INDEX {\n-            self.sess.cstore.original_crate_name(id.krate)\n+            self.original_crate_name(id.krate).as_str()\n         } else {\n-            let def_key = self.sess.cstore.def_key(id);\n+            let def_key = self.def_key(id);\n             // The name of a StructCtor is that of its struct parent.\n             if let hir_map::DefPathData::StructCtor = def_key.disambiguated_data.data {\n                 self.item_name(DefId {\n@@ -2315,7 +2279,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             let node_id = self.hir.as_local_node_id(impl_did).unwrap();\n             Ok(self.hir.span(node_id))\n         } else {\n-            Err(self.sess.cstore.crate_name(impl_did.krate))\n+            Err(self.crate_name(impl_did.krate))\n         }\n     }\n \n@@ -2340,9 +2304,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn with_freevars<T, F>(self, fid: NodeId, f: F) -> T where\n         F: FnOnce(&[hir::Freevar]) -> T,\n     {\n-        match self.freevars.borrow().get(&fid) {\n+        let def_id = self.hir.local_def_id(fid);\n+        match self.freevars(def_id) {\n             None => f(&[]),\n-            Some(d) => f(&d[..])\n+            Some(d) => f(&d),\n         }\n     }\n }\n@@ -2510,6 +2475,18 @@ fn param_env<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     traits::normalize_param_env_or_error(tcx, def_id, unnormalized_env, cause)\n }\n \n+fn crate_disambiguator<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 crate_num: CrateNum) -> Symbol {\n+    assert_eq!(crate_num, LOCAL_CRATE);\n+    tcx.sess.local_crate_disambiguator()\n+}\n+\n+fn original_crate_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 crate_num: CrateNum) -> Symbol {\n+    assert_eq!(crate_num, LOCAL_CRATE);\n+    tcx.crate_name.clone()\n+}\n+\n pub fn provide(providers: &mut ty::maps::Providers) {\n     util::provide(providers);\n     context::provide(providers);\n@@ -2521,6 +2498,8 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n         def_span,\n         param_env,\n         trait_of_item,\n+        crate_disambiguator,\n+        original_crate_name,\n         trait_impls_of: trait_def::trait_impls_of_provider,\n         ..*providers\n     };"}, {"sha": "309880ba06333174b6dc6b4197f9b90cc9f9ffa5", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 42, "deletions": 4, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -14,9 +14,12 @@\n //! type equality, etc.\n \n use hir::def_id::DefId;\n+use middle::const_val::ConstVal;\n+use traits::Reveal;\n use ty::subst::{Kind, Substs};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::error::{ExpectedFound, TypeError};\n+use util::common::ErrorReported;\n use std::rc::Rc;\n use std::iter;\n use syntax::abi;\n@@ -428,10 +431,45 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n         (&ty::TyArray(a_t, sz_a), &ty::TyArray(b_t, sz_b)) =>\n         {\n             let t = relation.relate(&a_t, &b_t)?;\n-            if sz_a == sz_b {\n-                Ok(tcx.mk_array(t, sz_a))\n-            } else {\n-                Err(TypeError::FixedArraySize(expected_found(relation, &sz_a, &sz_b)))\n+            assert_eq!(sz_a.ty, tcx.types.usize);\n+            assert_eq!(sz_b.ty, tcx.types.usize);\n+            let to_u64 = |x: &'tcx ty::Const<'tcx>| -> Result<u64, ErrorReported> {\n+                match x.val {\n+                    ConstVal::Integral(x) => Ok(x.to_u64().unwrap()),\n+                    ConstVal::Unevaluated(def_id, substs) => {\n+                        // FIXME(eddyb) get the right param_env.\n+                        let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n+                        match tcx.lift_to_global(&substs) {\n+                            Some(substs) => {\n+                                match tcx.const_eval(param_env.and((def_id, substs))) {\n+                                    Ok(&ty::Const { val: ConstVal::Integral(x), .. }) => {\n+                                        return Ok(x.to_u64().unwrap());\n+                                    }\n+                                    _ => {}\n+                                }\n+                            }\n+                            None => {}\n+                        }\n+                        tcx.sess.delay_span_bug(tcx.def_span(def_id),\n+                            \"array length could not be evaluated\");\n+                        Err(ErrorReported)\n+                    }\n+                    _ => bug!(\"arrays should not have {:?} as length\", x)\n+                }\n+            };\n+            match (to_u64(sz_a), to_u64(sz_b)) {\n+                (Ok(sz_a_u64), Ok(sz_b_u64)) => {\n+                    if sz_a_u64 == sz_b_u64 {\n+                        Ok(tcx.mk_ty(ty::TyArray(t, sz_a)))\n+                    } else {\n+                        Err(TypeError::FixedArraySize(\n+                            expected_found(relation, &sz_a_u64, &sz_b_u64)))\n+                    }\n+                }\n+                // We reported an error or will ICE, so we can return TyError.\n+                (Err(ErrorReported), _) | (_, Err(ErrorReported)) => {\n+                    Ok(tcx.types.err)\n+                }\n             }\n         }\n "}, {"sha": "54d55748c8e3a2e5e5179621a01ab3116befcd52", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 213, "deletions": 2, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use infer::type_variable;\n+use middle::const_val::{self, ConstVal, ConstAggregate, ConstEvalErr};\n use ty::{self, Lift, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n@@ -58,6 +59,13 @@ impl<'tcx, T: Lift<'tcx>, E: Lift<'tcx>> Lift<'tcx> for Result<T, E> {\n     }\n }\n \n+impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Box<T> {\n+    type Lifted = Box<T::Lifted>;\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&**self).map(Box::new)\n+    }\n+}\n+\n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for [T] {\n     type Lifted = Vec<T::Lifted>;\n     fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n@@ -209,6 +217,11 @@ impl<'a, 'tcx> Lift<'tcx> for ty::Predicate<'a> {\n             ty::Predicate::ObjectSafe(trait_def_id) => {\n                 Some(ty::Predicate::ObjectSafe(trait_def_id))\n             }\n+            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+                tcx.lift(&substs).map(|substs| {\n+                    ty::Predicate::ConstEvaluatable(def_id, substs)\n+                })\n+            }\n         }\n     }\n }\n@@ -220,6 +233,32 @@ impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::Binder<T> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for ty::ParamEnv<'a> {\n+    type Lifted = ty::ParamEnv<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.caller_bounds).map(|caller_bounds| {\n+            ty::ParamEnv {\n+                reveal: self.reveal,\n+                caller_bounds,\n+            }\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::ParamEnvAnd<'a, T> {\n+    type Lifted = ty::ParamEnvAnd<'tcx, T::Lifted>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.param_env).and_then(|param_env| {\n+            tcx.lift(&self.value).map(|value| {\n+                ty::ParamEnvAnd {\n+                    param_env,\n+                    value,\n+                }\n+            })\n+        })\n+    }\n+}\n+\n impl<'a, 'tcx> Lift<'tcx> for ty::ClosureSubsts<'a> {\n     type Lifted = ty::ClosureSubsts<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n@@ -394,6 +433,64 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for ConstEvalErr<'a> {\n+    type Lifted = ConstEvalErr<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.kind).map(|kind| {\n+            ConstEvalErr {\n+                span: self.span,\n+                kind,\n+            }\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for const_val::ErrKind<'a> {\n+    type Lifted = const_val::ErrKind<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        use middle::const_val::ErrKind::*;\n+\n+        Some(match *self {\n+            CannotCast => CannotCast,\n+            MissingStructField => MissingStructField,\n+            NonConstPath => NonConstPath,\n+            UnimplementedConstVal(s) => UnimplementedConstVal(s),\n+            ExpectedConstTuple => ExpectedConstTuple,\n+            ExpectedConstStruct => ExpectedConstStruct,\n+            IndexedNonVec => IndexedNonVec,\n+            IndexNotUsize => IndexNotUsize,\n+            IndexOutOfBounds { len, index } => IndexOutOfBounds { len, index },\n+            MiscBinaryOp => MiscBinaryOp,\n+            MiscCatchAll => MiscCatchAll,\n+            IndexOpFeatureGated => IndexOpFeatureGated,\n+            Math(ref e) => Math(e.clone()),\n+\n+            LayoutError(ref e) => {\n+                return tcx.lift(e).map(LayoutError)\n+            }\n+            ErroneousReferencedConstant(ref e) => {\n+                return tcx.lift(e).map(ErroneousReferencedConstant)\n+            }\n+\n+            TypeckError => TypeckError,\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for ty::layout::LayoutError<'a> {\n+    type Lifted = ty::layout::LayoutError<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        match *self {\n+            ty::layout::LayoutError::Unknown(ref ty) => {\n+                tcx.lift(ty).map(ty::layout::LayoutError::Unknown)\n+            }\n+            ty::layout::LayoutError::SizeOverflow(ref ty) => {\n+                tcx.lift(ty).map(ty::layout::LayoutError::SizeOverflow)\n+            }\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // TypeFoldable implementations.\n //\n@@ -408,6 +505,13 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n macro_rules! CopyImpls {\n     ($($ty:ty),+) => {\n         $(\n+            impl<'tcx> Lift<'tcx> for $ty {\n+                type Lifted = Self;\n+                fn lift_to_tcx<'a, 'gcx>(&self, _: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self> {\n+                    Some(*self)\n+                }\n+            }\n+\n             impl<'tcx> TypeFoldable<'tcx> for $ty {\n                 fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _: &mut F) -> $ty {\n                     *self\n@@ -551,7 +655,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let sty = match self.sty {\n             ty::TyRawPtr(tm) => ty::TyRawPtr(tm.fold_with(folder)),\n-            ty::TyArray(typ, sz) => ty::TyArray(typ.fold_with(folder), sz),\n+            ty::TyArray(typ, sz) => ty::TyArray(typ.fold_with(folder), sz.fold_with(folder)),\n             ty::TySlice(typ) => ty::TySlice(typ.fold_with(folder)),\n             ty::TyAdt(tid, substs) => ty::TyAdt(tid, substs.fold_with(folder)),\n             ty::TyDynamic(ref trait_ty, ref region) =>\n@@ -589,7 +693,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         match self.sty {\n             ty::TyRawPtr(ref tm) => tm.visit_with(visitor),\n-            ty::TyArray(typ, _sz) => typ.visit_with(visitor),\n+            ty::TyArray(typ, sz) => typ.visit_with(visitor) || sz.visit_with(visitor),\n             ty::TySlice(typ) => typ.visit_with(visitor),\n             ty::TyAdt(_, substs) => substs.visit_with(visitor),\n             ty::TyDynamic(ref trait_ty, ref reg) =>\n@@ -865,6 +969,8 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n                 ty::Predicate::ClosureKind(closure_def_id, kind),\n             ty::Predicate::ObjectSafe(trait_def_id) =>\n                 ty::Predicate::ObjectSafe(trait_def_id),\n+            ty::Predicate::ConstEvaluatable(def_id, substs) =>\n+                ty::Predicate::ConstEvaluatable(def_id, substs.fold_with(folder)),\n         }\n     }\n \n@@ -879,6 +985,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n             ty::Predicate::WellFormed(data) => data.visit_with(visitor),\n             ty::Predicate::ClosureKind(_closure_def_id, _kind) => false,\n             ty::Predicate::ObjectSafe(_trait_def_id) => false,\n+            ty::Predicate::ConstEvaluatable(_def_id, substs) => substs.visit_with(visitor),\n         }\n     }\n }\n@@ -1101,3 +1208,107 @@ impl<'tcx> TypeFoldable<'tcx> for ty::error::TypeError<'tcx> {\n         }\n     }\n }\n+\n+impl<'tcx> TypeFoldable<'tcx> for ConstVal<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        match *self {\n+            ConstVal::Integral(i) => ConstVal::Integral(i),\n+            ConstVal::Float(f) => ConstVal::Float(f),\n+            ConstVal::Str(s) => ConstVal::Str(s),\n+            ConstVal::ByteStr(b) => ConstVal::ByteStr(b),\n+            ConstVal::Bool(b) => ConstVal::Bool(b),\n+            ConstVal::Char(c) => ConstVal::Char(c),\n+            ConstVal::Variant(def_id) => ConstVal::Variant(def_id),\n+            ConstVal::Function(def_id, substs) => {\n+                ConstVal::Function(def_id, substs.fold_with(folder))\n+            }\n+            ConstVal::Aggregate(ConstAggregate::Struct(fields)) => {\n+                let new_fields: Vec<_> = fields.iter().map(|&(name, v)| {\n+                    (name, v.fold_with(folder))\n+                }).collect();\n+                let fields = if new_fields == fields {\n+                    fields\n+                } else {\n+                    folder.tcx().alloc_name_const_slice(&new_fields)\n+                };\n+                ConstVal::Aggregate(ConstAggregate::Struct(fields))\n+            }\n+            ConstVal::Aggregate(ConstAggregate::Tuple(fields)) => {\n+                let new_fields: Vec<_> = fields.iter().map(|v| {\n+                    v.fold_with(folder)\n+                }).collect();\n+                let fields = if new_fields == fields {\n+                    fields\n+                } else {\n+                    folder.tcx().alloc_const_slice(&new_fields)\n+                };\n+                ConstVal::Aggregate(ConstAggregate::Tuple(fields))\n+            }\n+            ConstVal::Aggregate(ConstAggregate::Array(fields)) => {\n+                let new_fields: Vec<_> = fields.iter().map(|v| {\n+                    v.fold_with(folder)\n+                }).collect();\n+                let fields = if new_fields == fields {\n+                    fields\n+                } else {\n+                    folder.tcx().alloc_const_slice(&new_fields)\n+                };\n+                ConstVal::Aggregate(ConstAggregate::Array(fields))\n+            }\n+            ConstVal::Aggregate(ConstAggregate::Repeat(v, count)) => {\n+                let v = v.fold_with(folder);\n+                ConstVal::Aggregate(ConstAggregate::Repeat(v, count))\n+            }\n+            ConstVal::Unevaluated(def_id, substs) => {\n+                ConstVal::Unevaluated(def_id, substs.fold_with(folder))\n+            }\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        match *self {\n+            ConstVal::Integral(_) |\n+            ConstVal::Float(_) |\n+            ConstVal::Str(_) |\n+            ConstVal::ByteStr(_) |\n+            ConstVal::Bool(_) |\n+            ConstVal::Char(_) |\n+            ConstVal::Variant(_) => false,\n+            ConstVal::Function(_, substs) => substs.visit_with(visitor),\n+            ConstVal::Aggregate(ConstAggregate::Struct(fields)) => {\n+                fields.iter().any(|&(_, v)| v.visit_with(visitor))\n+            }\n+            ConstVal::Aggregate(ConstAggregate::Tuple(fields)) |\n+            ConstVal::Aggregate(ConstAggregate::Array(fields)) => {\n+                fields.iter().any(|v| v.visit_with(visitor))\n+            }\n+            ConstVal::Aggregate(ConstAggregate::Repeat(v, _)) => {\n+                v.visit_with(visitor)\n+            }\n+            ConstVal::Unevaluated(_, substs) => substs.visit_with(visitor),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Const<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        let ty = self.ty.fold_with(folder);\n+        let val = self.val.fold_with(folder);\n+        folder.tcx().mk_const(ty::Const {\n+            ty,\n+            val\n+        })\n+    }\n+\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        folder.fold_const(*self)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.ty.visit_with(visitor) || self.val.visit_with(visitor)\n+    }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        visitor.visit_const(self)\n+    }\n+}"}, {"sha": "f17f81ca06bea5bbc2534887b003bdee9dd0d544", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -12,6 +12,7 @@\n \n use hir::def_id::DefId;\n \n+use middle::const_val::ConstVal;\n use middle::region;\n use ty::subst::{Substs, Subst};\n use ty::{self, AdtDef, TypeFlags, Ty, TyCtxt, TypeFoldable};\n@@ -109,7 +110,7 @@ pub enum TypeVariants<'tcx> {\n     TyStr,\n \n     /// An array with the given length. Written as `[T; n]`.\n-    TyArray(Ty<'tcx>, usize),\n+    TyArray(Ty<'tcx>, &'tcx ty::Const<'tcx>),\n \n     /// The pointee of an array slice.  Written as `[T]`.\n     TySlice(Ty<'tcx>),\n@@ -1041,19 +1042,6 @@ impl RegionKind {\n \n         flags\n     }\n-\n-    // This method returns whether the given Region is Named\n-    pub fn is_named_region(&self) -> bool {\n-        match *self {\n-            ty::ReFree(ref free_region) => {\n-                match free_region.bound_region {\n-                    ty::BrNamed(..) => true,\n-                    _ => false,\n-                }\n-            }\n-            _ => false,\n-        }\n-    }\n }\n \n /// Type utilities\n@@ -1471,3 +1459,14 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n }\n+\n+/// Typed constant value.\n+#[derive(Copy, Clone, Debug, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq)]\n+pub struct Const<'tcx> {\n+    pub ty: Ty<'tcx>,\n+\n+    // FIXME(eddyb) Replace this with a miri value.\n+    pub val: ConstVal<'tcx>,\n+}\n+\n+impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Const<'tcx> {}"}, {"sha": "3aadacfe826fd2ea1a1b8f4a9d475cb873dc3b83", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -141,13 +141,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n pub(super) fn trait_impls_of_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                 trait_id: DefId)\n                                                 -> Rc<TraitImpls> {\n-    let remote_impls = if trait_id.is_local() {\n-        // Traits defined in the current crate can't have impls in upstream\n-        // crates, so we don't bother querying the cstore.\n-        Vec::new()\n-    } else {\n-        tcx.sess.cstore.implementations_of_trait(Some(trait_id))\n-    };\n+    let mut remote_impls = Vec::new();\n+\n+    // Traits defined in the current crate can't have impls in upstream\n+    // crates, so we don't bother querying the cstore.\n+    if !trait_id.is_local() {\n+        for &cnum in tcx.crates().iter() {\n+            let impls = tcx.implementations_of_trait((cnum, trait_id));\n+            remote_impls.extend(impls.iter().cloned());\n+        }\n+    }\n \n     let mut blanket_impls = Vec::new();\n     let mut non_blanket_impls = FxHashMap();"}, {"sha": "16ae3cdbf1796964dd217da36a7324725a43fdd6", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -13,6 +13,7 @@\n use hir::def_id::{DefId, LOCAL_CRATE};\n use hir::map::DefPathData;\n use ich::{StableHashingContext, NodeIdHashingMode};\n+use middle::const_val::ConstVal;\n use traits::{self, Reveal};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::fold::TypeVisitor;\n@@ -53,7 +54,7 @@ macro_rules! typed_literal {\n             SignedInt(ast::IntTy::I32)   => ConstInt::I32($lit),\n             SignedInt(ast::IntTy::I64)   => ConstInt::I64($lit),\n             SignedInt(ast::IntTy::I128)   => ConstInt::I128($lit),\n-            SignedInt(ast::IntTy::Is) => match $tcx.sess.target.int_type {\n+            SignedInt(ast::IntTy::Is) => match $tcx.sess.target.isize_ty {\n                 ast::IntTy::I16 => ConstInt::Isize(ConstIsize::Is16($lit)),\n                 ast::IntTy::I32 => ConstInt::Isize(ConstIsize::Is32($lit)),\n                 ast::IntTy::I64 => ConstInt::Isize(ConstIsize::Is64($lit)),\n@@ -64,7 +65,7 @@ macro_rules! typed_literal {\n             UnsignedInt(ast::UintTy::U32) => ConstInt::U32($lit),\n             UnsignedInt(ast::UintTy::U64) => ConstInt::U64($lit),\n             UnsignedInt(ast::UintTy::U128) => ConstInt::U128($lit),\n-            UnsignedInt(ast::UintTy::Us) => match $tcx.sess.target.uint_type {\n+            UnsignedInt(ast::UintTy::Us) => match $tcx.sess.target.usize_ty {\n                 ast::UintTy::U16 => ConstInt::Usize(ConstUsize::Us16($lit)),\n                 ast::UintTy::U32 => ConstInt::Usize(ConstUsize::Us32($lit)),\n                 ast::UintTy::U64 => ConstInt::Usize(ConstUsize::Us64($lit)),\n@@ -388,7 +389,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     ty::Predicate::WellFormed(..) |\n                     ty::Predicate::ObjectSafe(..) |\n                     ty::Predicate::ClosureKind(..) |\n-                    ty::Predicate::RegionOutlives(..) => {\n+                    ty::Predicate::RegionOutlives(..) |\n+                    ty::Predicate::ConstEvaluatable(..) => {\n                         None\n                     }\n                     ty::Predicate::TypeOutlives(ty::Binder(ty::OutlivesPredicate(t, r))) => {\n@@ -418,7 +420,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         adt_did: DefId,\n         validate: &mut FnMut(Self, DefId) -> Result<(), ErrorReported>\n     ) -> Option<ty::Destructor> {\n-        let drop_trait = if let Some(def_id) = self.lang_items.drop_trait() {\n+        let drop_trait = if let Some(def_id) = self.lang_items().drop_trait() {\n             def_id\n         } else {\n             return None;\n@@ -638,7 +640,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn const_usize(&self, val: u16) -> ConstInt {\n-        match self.sess.target.uint_type {\n+        match self.sess.target.usize_ty {\n             ast::UintTy::U16 => ConstInt::Usize(ConstUsize::Us16(val as u16)),\n             ast::UintTy::U32 => ConstInt::Usize(ConstUsize::Us32(val as u32)),\n             ast::UintTy::U64 => ConstInt::Usize(ConstUsize::Us64(val as u64)),\n@@ -697,7 +699,14 @@ impl<'a, 'gcx, 'tcx, W> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, W>\n             TyInt(i) => self.hash(i),\n             TyUint(u) => self.hash(u),\n             TyFloat(f) => self.hash(f),\n-            TyArray(_, n) => self.hash(n),\n+            TyArray(_, n) => {\n+                self.hash_discriminant_u8(&n.val);\n+                match n.val {\n+                    ConstVal::Integral(x) => self.hash(x.to_u64().unwrap()),\n+                    ConstVal::Unevaluated(def_id, _) => self.def_id(def_id),\n+                    _ => bug!(\"arrays should not have {:?} as length\", n)\n+                }\n+            }\n             TyRawPtr(m) |\n             TyRef(_, m) => self.hash(m.mutbl),\n             TyClosure(def_id, _) |"}, {"sha": "df07844ccebaf040be2661872903aee9f3c1e823", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 40, "deletions": 6, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -11,6 +11,7 @@\n //! An iterator over the type substructure.\n //! WARNING: this does not keep track of the region depth.\n \n+use middle::const_val::{ConstVal, ConstAggregate};\n use ty::{self, Ty};\n use rustc_data_structures::small_vec::SmallVec;\n use rustc_data_structures::accumulate_vec::IntoIter as AccIntoIter;\n@@ -83,7 +84,11 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n         ty::TyBool | ty::TyChar | ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) |\n         ty::TyStr | ty::TyInfer(_) | ty::TyParam(_) | ty::TyNever | ty::TyError => {\n         }\n-        ty::TyArray(ty, _) | ty::TySlice(ty) => {\n+        ty::TyArray(ty, len) => {\n+            push_const(stack, len);\n+            stack.push(ty);\n+        }\n+        ty::TySlice(ty) => {\n             stack.push(ty);\n         }\n         ty::TyRawPtr(ref mt) | ty::TyRef(_, ref mt) => {\n@@ -122,13 +127,42 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n         ty::TyFnDef(_, substs) => {\n             stack.extend(substs.types().rev());\n         }\n-        ty::TyFnPtr(ft) => {\n-            push_sig_subtypes(stack, ft);\n+        ty::TyFnPtr(sig) => {\n+            stack.push(sig.skip_binder().output());\n+            stack.extend(sig.skip_binder().inputs().iter().cloned().rev());\n         }\n     }\n }\n \n-fn push_sig_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, sig: ty::PolyFnSig<'tcx>) {\n-    stack.push(sig.skip_binder().output());\n-    stack.extend(sig.skip_binder().inputs().iter().cloned().rev());\n+fn push_const<'tcx>(stack: &mut TypeWalkerStack<'tcx>, constant: &'tcx ty::Const<'tcx>) {\n+    match constant.val {\n+        ConstVal::Integral(_) |\n+        ConstVal::Float(_) |\n+        ConstVal::Str(_) |\n+        ConstVal::ByteStr(_) |\n+        ConstVal::Bool(_) |\n+        ConstVal::Char(_) |\n+        ConstVal::Variant(_) => {}\n+        ConstVal::Function(_, substs) => {\n+            stack.extend(substs.types().rev());\n+        }\n+        ConstVal::Aggregate(ConstAggregate::Struct(fields)) => {\n+            for &(_, v) in fields.iter().rev() {\n+                push_const(stack, v);\n+            }\n+        }\n+        ConstVal::Aggregate(ConstAggregate::Tuple(fields)) |\n+        ConstVal::Aggregate(ConstAggregate::Array(fields)) => {\n+            for v in fields.iter().rev() {\n+                push_const(stack, v);\n+            }\n+        }\n+        ConstVal::Aggregate(ConstAggregate::Repeat(v, _)) => {\n+            push_const(stack, v);\n+        }\n+        ConstVal::Unevaluated(_, substs) => {\n+            stack.extend(substs.types().rev());\n+        }\n+    }\n+    stack.push(constant.ty);\n }"}, {"sha": "41e27fca3f320ce0c43738808ce0f310199add97", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 56, "deletions": 2, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use hir::def_id::DefId;\n+use middle::const_val::{ConstVal, ConstAggregate};\n use infer::InferCtxt;\n use ty::subst::Substs;\n use traits;\n@@ -101,6 +102,14 @@ pub fn predicate_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n             wf.compute(data.skip_binder().a); // (*)\n             wf.compute(data.skip_binder().b); // (*)\n         }\n+        ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+            let obligations = wf.nominal_obligations(def_id, substs);\n+            wf.out.extend(obligations);\n+\n+            for ty in substs.types() {\n+                wf.compute(ty);\n+            }\n+        }\n     }\n \n     wf.normalize()\n@@ -207,6 +216,46 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Pushes the obligations required for a constant value to be WF\n+    /// into `self.out`.\n+    fn compute_const(&mut self, constant: &'tcx ty::Const<'tcx>) {\n+        self.require_sized(constant.ty, traits::ConstSized);\n+        match constant.val {\n+            ConstVal::Integral(_) |\n+            ConstVal::Float(_) |\n+            ConstVal::Str(_) |\n+            ConstVal::ByteStr(_) |\n+            ConstVal::Bool(_) |\n+            ConstVal::Char(_) |\n+            ConstVal::Variant(_) |\n+            ConstVal::Function(..) => {}\n+            ConstVal::Aggregate(ConstAggregate::Struct(fields)) => {\n+                for &(_, v) in fields {\n+                    self.compute_const(v);\n+                }\n+            }\n+            ConstVal::Aggregate(ConstAggregate::Tuple(fields)) |\n+            ConstVal::Aggregate(ConstAggregate::Array(fields)) => {\n+                for v in fields {\n+                    self.compute_const(v);\n+                }\n+            }\n+            ConstVal::Aggregate(ConstAggregate::Repeat(v, _)) => {\n+                self.compute_const(v);\n+            }\n+            ConstVal::Unevaluated(def_id, substs) => {\n+                let obligations = self.nominal_obligations(def_id, substs);\n+                self.out.extend(obligations);\n+\n+                let predicate = ty::Predicate::ConstEvaluatable(def_id, substs);\n+                let cause = self.cause(traits::MiscObligation);\n+                self.out.push(traits::Obligation::new(cause,\n+                                                      self.param_env,\n+                                                      predicate));\n+            }\n+        }\n+    }\n+\n     fn require_sized(&mut self, subty: Ty<'tcx>, cause: traits::ObligationCauseCode<'tcx>) {\n         if !subty.has_escaping_regions() {\n             let cause = self.cause(cause);\n@@ -239,9 +288,14 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     // WfScalar, WfParameter, etc\n                 }\n \n-                ty::TySlice(subty) |\n-                ty::TyArray(subty, _) => {\n+                ty::TySlice(subty) => {\n+                    self.require_sized(subty, traits::SliceOrArrayElem);\n+                }\n+\n+                ty::TyArray(subty, len) => {\n                     self.require_sized(subty, traits::SliceOrArrayElem);\n+                    assert_eq!(len.ty, self.infcx.tcx.types.usize);\n+                    self.compute_const(len);\n                 }\n \n                 ty::TyTuple(ref tys, _) => {"}, {"sha": "cf7a29d2845ac8c58c57c7537f6fbb9c77945a42", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -10,6 +10,7 @@\n \n use hir::def_id::DefId;\n use hir::map::definitions::DefPathData;\n+use middle::const_val::ConstVal;\n use middle::region::{self, BlockRemainder};\n use ty::subst::{self, Subst};\n use ty::{BrAnon, BrEnv, BrFresh, BrNamed};\n@@ -24,6 +25,7 @@ use std::cell::Cell;\n use std::fmt;\n use std::usize;\n \n+use rustc_const_math::ConstInt;\n use syntax::abi::Abi;\n use syntax::ast::CRATE_NODE_ID;\n use syntax::symbol::Symbol;\n@@ -159,7 +161,7 @@ pub fn parameterized(f: &mut fmt::Formatter,\n         }\n \n         write!(f, \"{}\", tcx.item_path_str(path_def_id))?;\n-        Ok(tcx.lang_items.fn_trait_kind(path_def_id))\n+        Ok(tcx.lang_items().fn_trait_kind(path_def_id))\n     })?;\n \n     if !verbose && fn_trait_kind.is_some() && projections.len() == 1 {\n@@ -428,6 +430,9 @@ impl<'tcx> fmt::Debug for ty::Predicate<'tcx> {\n             ty::Predicate::ClosureKind(closure_def_id, kind) => {\n                 write!(f, \"ClosureKind({:?}, {:?})\", closure_def_id, kind)\n             }\n+            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+                write!(f, \"ConstEvaluatable({:?}, {:?})\", def_id, substs)\n+            }\n         }\n     }\n }\n@@ -802,7 +807,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                     for predicate in bounds.predicates {\n                         if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n                             // Don't print +Sized, but rather +?Sized if absent.\n-                            if Some(trait_ref.def_id()) == tcx.lang_items.sized_trait() {\n+                            if Some(trait_ref.def_id()) == tcx.lang_items().sized_trait() {\n                                 is_sized = true;\n                                 continue;\n                             }\n@@ -827,12 +832,10 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                     let mut sep = \" \";\n                     tcx.with_freevars(node_id, |freevars| {\n                         for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n-                            let def_id = freevar.def.def_id();\n-                            let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n                             write!(f,\n                                         \"{}{}:{}\",\n                                         sep,\n-                                        tcx.local_var_name_str(node_id),\n+                                        tcx.hir.name(freevar.var_id()),\n                                         upvar_ty)?;\n                             sep = \", \";\n                         }\n@@ -866,12 +869,10 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                     let mut sep = \" \";\n                     tcx.with_freevars(node_id, |freevars| {\n                         for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n-                            let def_id = freevar.def.def_id();\n-                            let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n                             write!(f,\n                                         \"{}{}:{}\",\n                                         sep,\n-                                        tcx.local_var_name_str(node_id),\n+                                        tcx.hir.name(freevar.var_id()),\n                                         upvar_ty)?;\n                             sep = \", \";\n                         }\n@@ -890,7 +891,21 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n \n                 write!(f, \"]\")\n             }),\n-            TyArray(ty, sz) => write!(f, \"[{}; {}]\",  ty, sz),\n+            TyArray(ty, sz) => {\n+                write!(f, \"[{}; \", ty)?;\n+                match sz.val {\n+                    ConstVal::Integral(ConstInt::Usize(sz)) => {\n+                        write!(f, \"{}\", sz)?;\n+                    }\n+                    ConstVal::Unevaluated(_def_id, substs) => {\n+                        write!(f, \"<unevaluated{:?}>\", &substs[..])?;\n+                    }\n+                    _ => {\n+                        write!(f, \"{:?}\", sz)?;\n+                    }\n+                }\n+                write!(f, \"]\")\n+            }\n             TySlice(ty) => write!(f, \"[{}]\",  ty)\n         }\n     }\n@@ -906,7 +921,7 @@ impl fmt::Debug for ty::UpvarId {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"UpvarId({:?};`{}`;{:?})\",\n                self.var_id,\n-               ty::tls::with(|tcx| tcx.local_var_name_str_def_index(self.var_id)),\n+               ty::tls::with(|tcx| tcx.hir.name(tcx.hir.hir_to_node_id(self.var_id))),\n                self.closure_expr_id)\n     }\n }\n@@ -1039,6 +1054,11 @@ impl<'tcx> fmt::Display for ty::Predicate<'tcx> {\n                     write!(f, \"the closure `{}` implements the trait `{}`\",\n                            tcx.item_path_str(closure_def_id), kind)\n                 }),\n+            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+                write!(f, \"the constant `\")?;\n+                parameterized(f, substs, def_id, &[])?;\n+                write!(f, \"` can be evaluated\")\n+            }\n         }\n     }\n }"}, {"sha": "301cf3f8c8208d0019ba55fbd43477ad9f9e1c36", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -425,6 +425,9 @@ pub struct TargetOptions {\n \n     /// Whether or not stack probes (__rust_probestack) are enabled\n     pub stack_probes: bool,\n+\n+    /// The minimum alignment for global symbols.\n+    pub min_global_align: Option<u64>,\n }\n \n impl Default for TargetOptions {\n@@ -486,6 +489,7 @@ impl Default for TargetOptions {\n             crt_static_default: false,\n             crt_static_respected: false,\n             stack_probes: false,\n+            min_global_align: None,\n         }\n     }\n }\n@@ -724,6 +728,7 @@ impl Target {\n         key!(crt_static_default, bool);\n         key!(crt_static_respected, bool);\n         key!(stack_probes, bool);\n+        key!(min_global_align, Option<u64>);\n \n         if let Some(array) = obj.find(\"abi-blacklist\").and_then(Json::as_array) {\n             for name in array.iter().filter_map(|abi| abi.as_string()) {\n@@ -914,6 +919,7 @@ impl ToJson for Target {\n         target_option_val!(crt_static_default);\n         target_option_val!(crt_static_respected);\n         target_option_val!(stack_probes);\n+        target_option_val!(min_global_align);\n \n         if default.abi_blacklist != self.options.abi_blacklist {\n             d.insert(\"abi-blacklist\".to_string(), self.options.abi_blacklist.iter()"}, {"sha": "aad9effacd440460898b21f105a3818b2b314ef9", "filename": "src/librustc_back/target/s390x_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_back%2Ftarget%2Fs390x_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_back%2Ftarget%2Fs390x_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fs390x_unknown_linux_gnu.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -22,6 +22,7 @@ pub fn target() -> TargetResult {\n     base.max_atomic_width = Some(64);\n     // see #36994\n     base.exe_allocation_crate = None;\n+    base.min_global_align = Some(16);\n \n     Ok(Target {\n         llvm_target: \"s390x-unknown-linux-gnu\".to_string(),"}, {"sha": "a58b62ba2a7092351bda2deb4daaf6b9caef79be", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -447,7 +447,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                     None\n                 }\n                 LpUpvar(ty::UpvarId{ var_id, closure_expr_id: _ }) => {\n-                    let local_id = self.tcx().hir.def_index_to_node_id(var_id);\n+                    let local_id = self.tcx().hir.hir_to_node_id(var_id);\n                     self.tcx().used_mut_nodes.borrow_mut().insert(local_id);\n                     None\n                 }"}, {"sha": "de3f6f083256d8580dd0abb9e89f0b5e9366c8ad", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -93,7 +93,7 @@ fn report_move_errors<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>, errors: &Vec<Move\n             }\n         }\n         if let NoteClosureEnv(upvar_id) = error.move_from.note {\n-            let var_node_id = bccx.tcx.hir.def_index_to_node_id(upvar_id.var_id);\n+            let var_node_id = bccx.tcx.hir.hir_to_node_id(upvar_id.var_id);\n             err.span_label(bccx.tcx.hir.span(var_node_id),\n                            \"captured outer variable\");\n         }"}, {"sha": "6527ac0e927213feb66bf36b7737980c9b3aef6e", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -1311,10 +1311,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                       out: &mut String) {\n         match loan_path.kind {\n             LpUpvar(ty::UpvarId { var_id: id, closure_expr_id: _ }) => {\n-                out.push_str(&self.tcx.local_var_name_str_def_index(id));\n+                out.push_str(&self.tcx.hir.name(self.tcx.hir.hir_to_node_id(id)).as_str());\n             }\n             LpVar(id) => {\n-                out.push_str(&self.tcx.local_var_name_str(id));\n+                out.push_str(&self.tcx.hir.name(id).as_str());\n             }\n \n             LpDowncast(ref lp_base, variant_def_id) => {\n@@ -1439,7 +1439,7 @@ impl<'tcx> fmt::Debug for LoanPath<'tcx> {\n \n             LpUpvar(ty::UpvarId{ var_id, closure_expr_id }) => {\n                 let s = ty::tls::with(|tcx| {\n-                    let var_node_id = tcx.hir.def_index_to_node_id(var_id);\n+                    let var_node_id = tcx.hir.hir_to_node_id(var_id);\n                     tcx.hir.node_to_string(var_node_id)\n                 });\n                 write!(f, \"$({} captured by id={:?})\", s, closure_expr_id)\n@@ -1474,7 +1474,7 @@ impl<'tcx> fmt::Display for LoanPath<'tcx> {\n \n             LpUpvar(ty::UpvarId{ var_id, closure_expr_id: _ }) => {\n                 let s = ty::tls::with(|tcx| {\n-                    let var_node_id = tcx.hir.def_index_to_node_id(var_id);\n+                    let var_node_id = tcx.hir.hir_to_node_id(var_id);\n                     tcx.hir.node_to_string(var_node_id)\n                 });\n                 write!(f, \"$({} captured by closure)\", s)"}, {"sha": "b836b71e74bf65227e8ef9c3d2b2b8e45262299d", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 67, "deletions": 53, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -182,13 +182,16 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n         self.byte_array_map.entry(pat).or_insert_with(|| {\n             match pat.kind {\n                 box PatternKind::Constant {\n-                    value: ConstVal::ByteStr(ref data)\n+                    value: &ty::Const { val: ConstVal::ByteStr(b), .. }\n                 } => {\n-                    data.iter().map(|c| &*pattern_arena.alloc(Pattern {\n+                    b.data.iter().map(|&b| &*pattern_arena.alloc(Pattern {\n                         ty: tcx.types.u8,\n                         span: pat.span,\n                         kind: box PatternKind::Constant {\n-                            value: ConstVal::Integral(ConstInt::U8(*c))\n+                            value: tcx.mk_const(ty::Const {\n+                                val: ConstVal::Integral(ConstInt::U8(b)),\n+                                ty: tcx.types.u8\n+                            })\n                         }\n                     })).collect()\n                 }\n@@ -228,11 +231,11 @@ pub enum Constructor<'tcx> {\n     /// Enum variants.\n     Variant(DefId),\n     /// Literal values.\n-    ConstantValue(ConstVal<'tcx>),\n+    ConstantValue(&'tcx ty::Const<'tcx>),\n     /// Ranges of literal values (`2...5` and `2..5`).\n-    ConstantRange(ConstVal<'tcx>, ConstVal<'tcx>, RangeEnd),\n+    ConstantRange(&'tcx ty::Const<'tcx>, &'tcx ty::Const<'tcx>, RangeEnd),\n     /// Array patterns of length n.\n-    Slice(usize),\n+    Slice(u64),\n }\n \n impl<'tcx> Constructor<'tcx> {\n@@ -273,7 +276,7 @@ pub enum WitnessPreference {\n #[derive(Copy, Clone, Debug)]\n struct PatternContext<'tcx> {\n     ty: Ty<'tcx>,\n-    max_slice_length: usize,\n+    max_slice_length: u64,\n }\n \n /// A stack of patterns in reverse order of construction\n@@ -327,8 +330,8 @@ impl<'tcx> Witness<'tcx> {\n     {\n         let arity = constructor_arity(cx, ctor, ty);\n         let pat = {\n-            let len = self.0.len();\n-            let mut pats = self.0.drain(len-arity..).rev();\n+            let len = self.0.len() as u64;\n+            let mut pats = self.0.drain((len-arity) as usize..).rev();\n \n             match ty.sty {\n                 ty::TyAdt(..) |\n@@ -370,7 +373,7 @@ impl<'tcx> Witness<'tcx> {\n \n                 _ => {\n                     match *ctor {\n-                        ConstantValue(ref v) => PatternKind::Constant { value: v.clone() },\n+                        ConstantValue(value) => PatternKind::Constant { value },\n                         _ => PatternKind::Wild,\n                     }\n                 }\n@@ -404,22 +407,31 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n {\n     debug!(\"all_constructors({:?})\", pcx.ty);\n     match pcx.ty.sty {\n-        ty::TyBool =>\n-            [true, false].iter().map(|b| ConstantValue(ConstVal::Bool(*b))).collect(),\n+        ty::TyBool => {\n+            [true, false].iter().map(|&b| {\n+                ConstantValue(cx.tcx.mk_const(ty::Const {\n+                    val: ConstVal::Bool(b),\n+                    ty: cx.tcx.types.bool\n+                }))\n+            }).collect()\n+        }\n+        ty::TyArray(ref sub_ty, len) if len.val.to_const_int().is_some() => {\n+            let len = len.val.to_const_int().unwrap().to_u64().unwrap();\n+            if len != 0 && cx.is_uninhabited(sub_ty) {\n+                vec![]\n+            } else {\n+                vec![Slice(len)]\n+            }\n+        }\n+        // Treat arrays of a constant but unknown length like slices.\n+        ty::TyArray(ref sub_ty, _) |\n         ty::TySlice(ref sub_ty) => {\n             if cx.is_uninhabited(sub_ty) {\n                 vec![Slice(0)]\n             } else {\n                 (0..pcx.max_slice_length+1).map(|length| Slice(length)).collect()\n             }\n         }\n-        ty::TyArray(ref sub_ty, length) => {\n-            if length > 0 && cx.is_uninhabited(sub_ty) {\n-                vec![]\n-            } else {\n-                vec![Slice(length)]\n-            }\n-        }\n         ty::TyAdt(def, substs) if def.is_enum() && def.variants.len() != 1 => {\n             def.variants.iter()\n                 .filter(|v| !cx.is_variant_uninhabited(v, substs))\n@@ -438,7 +450,7 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n \n fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n     _cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-    patterns: I) -> usize\n+    patterns: I) -> u64\n     where I: Iterator<Item=&'p Pattern<'tcx>>\n {\n     // The exhaustiveness-checking paper does not include any details on\n@@ -511,16 +523,16 @@ fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n \n     for row in patterns {\n         match *row.kind {\n-            PatternKind::Constant { value: ConstVal::ByteStr(ref data) } => {\n-                max_fixed_len = cmp::max(max_fixed_len, data.len());\n+            PatternKind::Constant { value: &ty::Const { val: ConstVal::ByteStr(b), .. } } => {\n+                max_fixed_len = cmp::max(max_fixed_len, b.data.len() as u64);\n             }\n             PatternKind::Slice { ref prefix, slice: None, ref suffix } => {\n-                let fixed_len = prefix.len() + suffix.len();\n+                let fixed_len = prefix.len() as u64 + suffix.len() as u64;\n                 max_fixed_len = cmp::max(max_fixed_len, fixed_len);\n             }\n             PatternKind::Slice { ref prefix, slice: Some(_), ref suffix } => {\n-                max_prefix_len = cmp::max(max_prefix_len, prefix.len());\n-                max_suffix_len = cmp::max(max_suffix_len, suffix.len());\n+                max_prefix_len = cmp::max(max_prefix_len, prefix.len() as u64);\n+                max_suffix_len = cmp::max(max_suffix_len, suffix.len() as u64);\n             }\n             _ => {}\n         }\n@@ -715,16 +727,18 @@ fn pat_constructors<'tcx>(_cx: &mut MatchCheckCtxt,\n             Some(vec![Single]),\n         PatternKind::Variant { adt_def, variant_index, .. } =>\n             Some(vec![Variant(adt_def.variants[variant_index].did)]),\n-        PatternKind::Constant { ref value } =>\n-            Some(vec![ConstantValue(value.clone())]),\n-        PatternKind::Range { ref lo, ref hi, ref end } =>\n-            Some(vec![ConstantRange(lo.clone(), hi.clone(), end.clone())]),\n+        PatternKind::Constant { value } =>\n+            Some(vec![ConstantValue(value)]),\n+        PatternKind::Range { lo, hi, end } =>\n+            Some(vec![ConstantRange(lo, hi, end)]),\n         PatternKind::Array { .. } => match pcx.ty.sty {\n-            ty::TyArray(_, length) => Some(vec![Slice(length)]),\n+            ty::TyArray(_, length) => Some(vec![\n+                Slice(length.val.to_const_int().unwrap().to_u64().unwrap())\n+            ]),\n             _ => span_bug!(pat.span, \"bad ty {:?} for array pattern\", pcx.ty)\n         },\n         PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n-            let pat_len = prefix.len() + suffix.len();\n+            let pat_len = prefix.len() as u64 + suffix.len() as u64;\n             if slice.is_some() {\n                 Some((pat_len..pcx.max_slice_length+1).map(Slice).collect())\n             } else {\n@@ -739,18 +753,18 @@ fn pat_constructors<'tcx>(_cx: &mut MatchCheckCtxt,\n ///\n /// For instance, a tuple pattern (_, 42, Some([])) has the arity of 3.\n /// A struct pattern's arity is the number of fields it contains, etc.\n-fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usize {\n+fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> u64 {\n     debug!(\"constructor_arity({:?}, {:?})\", ctor, ty);\n     match ty.sty {\n-        ty::TyTuple(ref fs, _) => fs.len(),\n+        ty::TyTuple(ref fs, _) => fs.len() as u64,\n         ty::TySlice(..) | ty::TyArray(..) => match *ctor {\n             Slice(length) => length,\n             ConstantValue(_) => 0,\n             _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty)\n         },\n         ty::TyRef(..) => 1,\n         ty::TyAdt(adt, _) => {\n-            adt.variants[ctor.variant_index_for_adt(adt)].fields.len()\n+            adt.variants[ctor.variant_index_for_adt(adt)].fields.len() as u64\n         }\n         _ => 0\n     }\n@@ -768,7 +782,7 @@ fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n     match ty.sty {\n         ty::TyTuple(ref fs, _) => fs.into_iter().map(|t| *t).collect(),\n         ty::TySlice(ty) | ty::TyArray(ty, _) => match *ctor {\n-            Slice(length) => repeat(ty).take(length).collect(),\n+            Slice(length) => (0..length).map(|_| ty).collect(),\n             ConstantValue(_) => vec![],\n             _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty)\n         },\n@@ -806,7 +820,7 @@ fn slice_pat_covered_by_constructor(_tcx: TyCtxt, _span: Span,\n                                     suffix: &[Pattern])\n                                     -> Result<bool, ErrorReported> {\n     let data = match *ctor {\n-        ConstantValue(ConstVal::ByteStr(ref data)) => data,\n+        ConstantValue(&ty::Const { val: ConstVal::ByteStr(b), .. }) => b.data,\n         _ => bug!()\n     };\n \n@@ -820,7 +834,7 @@ fn slice_pat_covered_by_constructor(_tcx: TyCtxt, _span: Span,\n             data[data.len()-suffix.len()..].iter().zip(suffix))\n     {\n         match pat.kind {\n-            box PatternKind::Constant { ref value } => match *value {\n+            box PatternKind::Constant { value } => match value.val {\n                 ConstVal::Integral(ConstInt::U8(u)) => {\n                     if u != *ch {\n                         return Ok(false);\n@@ -843,23 +857,23 @@ fn constructor_covered_by_range(tcx: TyCtxt, span: Span,\n     let cmp_from = |c_from| Ok(compare_const_vals(tcx, span, c_from, from)? != Ordering::Less);\n     let cmp_to = |c_to| compare_const_vals(tcx, span, c_to, to);\n     match *ctor {\n-        ConstantValue(ref value) => {\n-            let to = cmp_to(value)?;\n+        ConstantValue(value) => {\n+            let to = cmp_to(&value.val)?;\n             let end = (to == Ordering::Less) ||\n                       (end == RangeEnd::Included && to == Ordering::Equal);\n-            Ok(cmp_from(value)? && end)\n+            Ok(cmp_from(&value.val)? && end)\n         },\n-        ConstantRange(ref from, ref to, RangeEnd::Included) => {\n-            let to = cmp_to(to)?;\n+        ConstantRange(from, to, RangeEnd::Included) => {\n+            let to = cmp_to(&to.val)?;\n             let end = (to == Ordering::Less) ||\n                       (end == RangeEnd::Included && to == Ordering::Equal);\n-            Ok(cmp_from(from)? && end)\n+            Ok(cmp_from(&from.val)? && end)\n         },\n-        ConstantRange(ref from, ref to, RangeEnd::Excluded) => {\n-            let to = cmp_to(to)?;\n+        ConstantRange(from, to, RangeEnd::Excluded) => {\n+            let to = cmp_to(&to.val)?;\n             let end = (to == Ordering::Less) ||\n                       (end == RangeEnd::Excluded && to == Ordering::Equal);\n-            Ok(cmp_from(from)? && end)\n+            Ok(cmp_from(&from.val)? && end)\n         }\n         Single => Ok(true),\n         _ => bug!(),\n@@ -919,11 +933,11 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n             Some(vec![subpattern])\n         }\n \n-        PatternKind::Constant { ref value } => {\n+        PatternKind::Constant { value } => {\n             match *constructor {\n-                Slice(..) => match *value {\n-                    ConstVal::ByteStr(ref data) => {\n-                        if wild_patterns.len() == data.len() {\n+                Slice(..) => match value.val {\n+                    ConstVal::ByteStr(b) => {\n+                        if wild_patterns.len() == b.data.len() {\n                             Some(cx.lower_byte_str_pattern(pat))\n                         } else {\n                             None\n@@ -934,7 +948,7 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                 },\n                 _ => {\n                     match constructor_covered_by_range(\n-                        cx.tcx, pat.span, constructor, value, value, RangeEnd::Included\n+                        cx.tcx, pat.span, constructor, &value.val, &value.val, RangeEnd::Included\n                             ) {\n                         Ok(true) => Some(vec![]),\n                         Ok(false) => None,\n@@ -944,9 +958,9 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n             }\n         }\n \n-        PatternKind::Range { ref lo, ref hi, ref end } => {\n+        PatternKind::Range { lo, hi, ref end } => {\n             match constructor_covered_by_range(\n-                cx.tcx, pat.span, constructor, lo, hi, end.clone()\n+                cx.tcx, pat.span, constructor, &lo.val, &hi.val, end.clone()\n             ) {\n                 Ok(true) => Some(vec![]),\n                 Ok(false) => None,"}, {"sha": "0339969f2b45adf21fc79436d94b08806e618f6c", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -140,7 +140,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n     fn check_match(\n         &self,\n         scrut: &hir::Expr,\n-        arms: &[hir::Arm],\n+        arms: &'tcx [hir::Arm],\n         source: hir::MatchSource)\n     {\n         for arm in arms {\n@@ -231,7 +231,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn check_irrefutable(&self, pat: &Pat, origin: &str) {\n+    fn check_irrefutable(&self, pat: &'tcx Pat, origin: &str) {\n         let module = self.tcx.hir.get_module_parent(pat.id);\n         MatchCheckCtxt::create_and_enter(self.tcx, module, |ref mut cx| {\n             let mut patcx = PatternContext::new(self.tcx,"}, {"sha": "d01b3c45f7fd1642603e3402008addf6085d6c5f", "filename": "src/librustc_const_eval/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fdiagnostics.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -565,7 +565,7 @@ See also https://github.com/rust-lang/rust/issues/14587\n \n \n register_diagnostics! {\n-    E0298, // cannot compare constants\n+//  E0298, // cannot compare constants\n //  E0299, // mismatched types between arms\n //  E0471, // constant evaluation error (in pattern)\n }"}, {"sha": "61eb5dfd18b9c15537edac5e250f5da7ae48d015", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 115, "deletions": 99, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -9,8 +9,9 @@\n // except according to those terms.\n \n use rustc::middle::const_val::ConstVal::*;\n+use rustc::middle::const_val::ConstAggregate::*;\n use rustc::middle::const_val::ErrKind::*;\n-use rustc::middle::const_val::{ConstVal, ConstEvalErr, EvalResult, ErrKind};\n+use rustc::middle::const_val::{ByteArray, ConstVal, ConstEvalErr, EvalResult, ErrKind};\n \n use rustc::hir::map as hir_map;\n use rustc::hir::map::blocks::FnLikeNode;\n@@ -22,7 +23,7 @@ use rustc::ty::maps::Providers;\n use rustc::ty::util::IntTypeExt;\n use rustc::ty::subst::{Substs, Subst};\n use rustc::util::common::ErrorReported;\n-use rustc::util::nodemap::DefIdMap;\n+use rustc::util::nodemap::NodeMap;\n \n use syntax::abi::Abi;\n use syntax::ast;\n@@ -88,7 +89,7 @@ pub struct ConstContext<'a, 'tcx: 'a> {\n     tables: &'a ty::TypeckTables<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     substs: &'tcx Substs<'tcx>,\n-    fn_args: Option<DefIdMap<ConstVal<'tcx>>>\n+    fn_args: Option<NodeMap<&'tcx ty::Const<'tcx>>>\n }\n \n impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n@@ -107,7 +108,7 @@ impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n \n     /// Evaluate a constant expression in a context where the expression isn't\n     /// guaranteed to be evaluable.\n-    pub fn eval(&self, e: &Expr) -> EvalResult<'tcx> {\n+    pub fn eval(&self, e: &'tcx Expr) -> EvalResult<'tcx> {\n         if self.tables.tainted_by_errors {\n             signal!(e, TypeckError);\n         }\n@@ -118,9 +119,10 @@ impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n type CastResult<'tcx> = Result<ConstVal<'tcx>, ErrKind<'tcx>>;\n \n fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n-                                     e: &Expr) -> EvalResult<'tcx> {\n+                                     e: &'tcx Expr) -> EvalResult<'tcx> {\n     let tcx = cx.tcx;\n-    let ety = cx.tables.expr_ty(e).subst(tcx, cx.substs);\n+    let ty = cx.tables.expr_ty(e).subst(tcx, cx.substs);\n+    let mk_const = |val| tcx.mk_const(ty::Const { val, ty });\n \n     let result = match e.node {\n       hir::ExprUnary(hir::UnNeg, ref inner) => {\n@@ -133,65 +135,74 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n             const I32_OVERFLOW: u128 = i32::min_value() as u32 as u128;\n             const I64_OVERFLOW: u128 = i64::min_value() as u64 as u128;\n             const I128_OVERFLOW: u128 = i128::min_value() as u128;\n-            match (&lit.node, &ety.sty) {\n+            let negated = match (&lit.node, &ty.sty) {\n                 (&LitKind::Int(I8_OVERFLOW, _), &ty::TyInt(IntTy::I8)) |\n                 (&LitKind::Int(I8_OVERFLOW, Signed(IntTy::I8)), _) => {\n-                    return Ok(Integral(I8(i8::min_value())))\n+                    Some(I8(i8::min_value()))\n                 },\n                 (&LitKind::Int(I16_OVERFLOW, _), &ty::TyInt(IntTy::I16)) |\n                 (&LitKind::Int(I16_OVERFLOW, Signed(IntTy::I16)), _) => {\n-                    return Ok(Integral(I16(i16::min_value())))\n+                    Some(I16(i16::min_value()))\n                 },\n                 (&LitKind::Int(I32_OVERFLOW, _), &ty::TyInt(IntTy::I32)) |\n                 (&LitKind::Int(I32_OVERFLOW, Signed(IntTy::I32)), _) => {\n-                    return Ok(Integral(I32(i32::min_value())))\n+                    Some(I32(i32::min_value()))\n                 },\n                 (&LitKind::Int(I64_OVERFLOW, _), &ty::TyInt(IntTy::I64)) |\n                 (&LitKind::Int(I64_OVERFLOW, Signed(IntTy::I64)), _) => {\n-                    return Ok(Integral(I64(i64::min_value())))\n+                    Some(I64(i64::min_value()))\n                 },\n                 (&LitKind::Int(I128_OVERFLOW, _), &ty::TyInt(IntTy::I128)) |\n                 (&LitKind::Int(I128_OVERFLOW, Signed(IntTy::I128)), _) => {\n-                    return Ok(Integral(I128(i128::min_value())))\n+                    Some(I128(i128::min_value()))\n                 },\n                 (&LitKind::Int(n, _), &ty::TyInt(IntTy::Is)) |\n                 (&LitKind::Int(n, Signed(IntTy::Is)), _) => {\n-                    match tcx.sess.target.int_type {\n+                    match tcx.sess.target.isize_ty {\n                         IntTy::I16 => if n == I16_OVERFLOW {\n-                            return Ok(Integral(Isize(Is16(i16::min_value()))));\n+                            Some(Isize(Is16(i16::min_value())))\n+                        } else {\n+                            None\n                         },\n                         IntTy::I32 => if n == I32_OVERFLOW {\n-                            return Ok(Integral(Isize(Is32(i32::min_value()))));\n+                            Some(Isize(Is32(i32::min_value())))\n+                        } else {\n+                            None\n                         },\n                         IntTy::I64 => if n == I64_OVERFLOW {\n-                            return Ok(Integral(Isize(Is64(i64::min_value()))));\n+                            Some(Isize(Is64(i64::min_value())))\n+                        } else {\n+                            None\n                         },\n                         _ => span_bug!(e.span, \"typeck error\")\n                     }\n                 },\n-                _ => {},\n+                _ => None\n+            };\n+            if let Some(i) = negated {\n+                return Ok(mk_const(Integral(i)));\n             }\n         }\n-        match cx.eval(inner)? {\n+        mk_const(match cx.eval(inner)?.val {\n           Float(f) => Float(-f),\n           Integral(i) => Integral(math!(e, -i)),\n-          const_val => signal!(e, NegateOn(const_val)),\n-        }\n+          _ => signal!(e, TypeckError)\n+        })\n       }\n       hir::ExprUnary(hir::UnNot, ref inner) => {\n-        match cx.eval(inner)? {\n+        mk_const(match cx.eval(inner)?.val {\n           Integral(i) => Integral(math!(e, !i)),\n           Bool(b) => Bool(!b),\n-          const_val => signal!(e, NotOn(const_val)),\n-        }\n+          _ => signal!(e, TypeckError)\n+        })\n       }\n       hir::ExprUnary(hir::UnDeref, _) => signal!(e, UnimplementedConstVal(\"deref operation\")),\n       hir::ExprBinary(op, ref a, ref b) => {\n         // technically, if we don't have type hints, but integral eval\n         // gives us a type through a type-suffix, cast or const def type\n         // we need to re-eval the other value of the BinOp if it was\n         // not inferred\n-        match (cx.eval(a)?, cx.eval(b)?) {\n+        mk_const(match (cx.eval(a)?.val, cx.eval(b)?.val) {\n           (Float(a), Float(b)) => {\n             use std::cmp::Ordering::*;\n             match op.node {\n@@ -260,16 +271,16 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n           }\n \n           _ => signal!(e, MiscBinaryOp),\n-        }\n+        })\n       }\n       hir::ExprCast(ref base, _) => {\n         let base_val = cx.eval(base)?;\n         let base_ty = cx.tables.expr_ty(base).subst(tcx, cx.substs);\n-        if ety == base_ty {\n+        if ty == base_ty {\n             base_val\n         } else {\n-            match cast_const(tcx, base_val, ety) {\n-                Ok(val) => val,\n+            match cast_const(tcx, base_val.val, ty) {\n+                Ok(val) => mk_const(val),\n                 Err(kind) => signal!(e, kind),\n             }\n         }\n@@ -291,52 +302,53 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n                     }\n               },\n               Def::VariantCtor(variant_def, CtorKind::Const) => {\n-                Variant(variant_def)\n+                mk_const(Variant(variant_def))\n               }\n               Def::VariantCtor(_, CtorKind::Fn) => {\n                   signal!(e, UnimplementedConstVal(\"enum variants\"));\n               }\n               Def::StructCtor(_, CtorKind::Const) => {\n-                  ConstVal::Struct(Default::default())\n+                  mk_const(Aggregate(Struct(&[])))\n               }\n               Def::StructCtor(_, CtorKind::Fn) => {\n                   signal!(e, UnimplementedConstVal(\"tuple struct constructors\"))\n               }\n-              Def::Local(def_id) => {\n-                  debug!(\"Def::Local({:?}): {:?}\", def_id, cx.fn_args);\n-                  if let Some(val) = cx.fn_args.as_ref().and_then(|args| args.get(&def_id)) {\n-                      val.clone()\n+              Def::Local(id) => {\n+                  debug!(\"Def::Local({:?}): {:?}\", id, cx.fn_args);\n+                  if let Some(&val) = cx.fn_args.as_ref().and_then(|args| args.get(&id)) {\n+                      val\n                   } else {\n                       signal!(e, NonConstPath);\n                   }\n               },\n-              Def::Method(id) | Def::Fn(id) => Function(id, substs),\n+              Def::Method(id) | Def::Fn(id) => mk_const(Function(id, substs)),\n               Def::Err => span_bug!(e.span, \"typeck error\"),\n               _ => signal!(e, NonConstPath),\n           }\n       }\n       hir::ExprCall(ref callee, ref args) => {\n-          let (def_id, substs) = match cx.eval(callee)? {\n+          let (def_id, substs) = match cx.eval(callee)?.val {\n               Function(def_id, substs) => (def_id, substs),\n               _ => signal!(e, TypeckError),\n           };\n \n           if tcx.fn_sig(def_id).abi() == Abi::RustIntrinsic {\n             let layout_of = |ty: Ty<'tcx>| {\n-                ty.layout(tcx, cx.param_env).map_err(|err| {\n+                let ty = tcx.erase_regions(&ty);\n+                tcx.at(e.span).layout_raw(cx.param_env.reveal_all().and(ty)).map_err(|err| {\n                     ConstEvalErr { span: e.span, kind: LayoutError(err) }\n                 })\n             };\n-            match &tcx.item_name(def_id).as_str()[..] {\n+            match &tcx.item_name(def_id)[..] {\n                 \"size_of\" => {\n-                    let size = layout_of(substs.type_at(0))?.size(tcx);\n-                    return Ok(Integral(Usize(ConstUsize::new(size.bytes(),\n-                        tcx.sess.target.uint_type).unwrap())));\n+                    let size = layout_of(substs.type_at(0))?.size(tcx).bytes();\n+                    return Ok(mk_const(Integral(Usize(ConstUsize::new(size,\n+                        tcx.sess.target.usize_ty).unwrap()))));\n                 }\n                 \"min_align_of\" => {\n-                    let align = layout_of(substs.type_at(0))?.align(tcx);\n-                    return Ok(Integral(Usize(ConstUsize::new(align.abi(),\n-                        tcx.sess.target.uint_type).unwrap())));\n+                    let align = layout_of(substs.type_at(0))?.align(tcx).abi();\n+                    return Ok(mk_const(Integral(Usize(ConstUsize::new(align,\n+                        tcx.sess.target.usize_ty).unwrap()))));\n                 }\n                 _ => signal!(e, TypeckError)\n             }\n@@ -354,24 +366,24 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n             }\n           } else {\n             if tcx.is_const_fn(def_id) {\n-                tcx.sess.cstore.item_body(tcx, def_id)\n+                tcx.extern_const_body(def_id)\n             } else {\n                 signal!(e, TypeckError)\n             }\n           };\n \n-          let arg_defs = body.arguments.iter().map(|arg| match arg.pat.node {\n-               hir::PatKind::Binding(_, def_id, _, _) => Some(def_id),\n+          let arg_ids = body.arguments.iter().map(|arg| match arg.pat.node {\n+               hir::PatKind::Binding(_, canonical_id, _, _) => Some(canonical_id),\n                _ => None\n            }).collect::<Vec<_>>();\n-          assert_eq!(arg_defs.len(), args.len());\n+          assert_eq!(arg_ids.len(), args.len());\n \n-          let mut call_args = DefIdMap();\n-          for (arg, arg_expr) in arg_defs.into_iter().zip(args.iter()) {\n+          let mut call_args = NodeMap();\n+          for (arg, arg_expr) in arg_ids.into_iter().zip(args.iter()) {\n               let arg_val = cx.eval(arg_expr)?;\n               debug!(\"const call arg: {:?}\", arg);\n-              if let Some(def_id) = arg {\n-                assert!(call_args.insert(def_id, arg_val).is_none());\n+              if let Some(id) = arg {\n+                assert!(call_args.insert(id, arg_val).is_none());\n               }\n           }\n           debug!(\"const call({:?})\", call_args);\n@@ -384,84 +396,83 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n           };\n           callee_cx.eval(&body.value)?\n       },\n-      hir::ExprLit(ref lit) => match lit_to_const(&lit.node, tcx, ety) {\n-          Ok(val) => val,\n+      hir::ExprLit(ref lit) => match lit_to_const(&lit.node, tcx, ty) {\n+          Ok(val) => mk_const(val),\n           Err(err) => signal!(e, err),\n       },\n       hir::ExprBlock(ref block) => {\n         match block.expr {\n             Some(ref expr) => cx.eval(expr)?,\n-            None => Tuple(vec![]),\n+            None => mk_const(Aggregate(Tuple(&[]))),\n         }\n       }\n       hir::ExprType(ref e, _) => cx.eval(e)?,\n       hir::ExprTup(ref fields) => {\n-        Tuple(fields.iter().map(|e| cx.eval(e)).collect::<Result<_, _>>()?)\n+        let values = fields.iter().map(|e| cx.eval(e)).collect::<Result<Vec<_>, _>>()?;\n+        mk_const(Aggregate(Tuple(tcx.alloc_const_slice(&values))))\n       }\n       hir::ExprStruct(_, ref fields, _) => {\n-        Struct(fields.iter().map(|f| {\n+        mk_const(Aggregate(Struct(tcx.alloc_name_const_slice(&fields.iter().map(|f| {\n             cx.eval(&f.expr).map(|v| (f.name.node, v))\n-        }).collect::<Result<_, _>>()?)\n+        }).collect::<Result<Vec<_>, _>>()?))))\n       }\n       hir::ExprIndex(ref arr, ref idx) => {\n         if !tcx.sess.features.borrow().const_indexing {\n             signal!(e, IndexOpFeatureGated);\n         }\n         let arr = cx.eval(arr)?;\n-        let idx = match cx.eval(idx)? {\n-            Integral(Usize(i)) => i.as_u64(tcx.sess.target.uint_type),\n+        let idx = match cx.eval(idx)?.val {\n+            Integral(Usize(i)) => i.as_u64(),\n             _ => signal!(idx, IndexNotUsize),\n         };\n         assert_eq!(idx as usize as u64, idx);\n-        match arr {\n-            Array(ref v) => {\n-                if let Some(elem) = v.get(idx as usize) {\n-                    elem.clone()\n+        match arr.val {\n+            Aggregate(Array(v)) => {\n+                if let Some(&elem) = v.get(idx as usize) {\n+                    elem\n                 } else {\n                     let n = v.len() as u64;\n-                    assert_eq!(n as usize as u64, n);\n                     signal!(e, IndexOutOfBounds { len: n, index: idx })\n                 }\n             }\n \n-            Repeat(.., n) if idx >= n => {\n+            Aggregate(Repeat(.., n)) if idx >= n => {\n                 signal!(e, IndexOutOfBounds { len: n, index: idx })\n             }\n-            Repeat(ref elem, _) => (**elem).clone(),\n+            Aggregate(Repeat(elem, _)) => elem,\n \n-            ByteStr(ref data) if idx >= data.len() as u64 => {\n-                signal!(e, IndexOutOfBounds { len: data.len() as u64, index: idx })\n+            ByteStr(b) if idx >= b.data.len() as u64 => {\n+                signal!(e, IndexOutOfBounds { len: b.data.len() as u64, index: idx })\n             }\n-            ByteStr(data) => {\n-                Integral(U8(data[idx as usize]))\n+            ByteStr(b) => {\n+                mk_const(Integral(U8(b.data[idx as usize])))\n             },\n \n             _ => signal!(e, IndexedNonVec),\n         }\n       }\n       hir::ExprArray(ref v) => {\n-        Array(v.iter().map(|e| cx.eval(e)).collect::<Result<_, _>>()?)\n+        let values = v.iter().map(|e| cx.eval(e)).collect::<Result<Vec<_>, _>>()?;\n+        mk_const(Aggregate(Array(tcx.alloc_const_slice(&values))))\n       }\n       hir::ExprRepeat(ref elem, _) => {\n-          let n = match ety.sty {\n-            ty::TyArray(_, n) => n as u64,\n+          let n = match ty.sty {\n+            ty::TyArray(_, n) => n.val.to_const_int().unwrap().to_u64().unwrap(),\n             _ => span_bug!(e.span, \"typeck error\")\n           };\n-          Repeat(Box::new(cx.eval(elem)?), n)\n+          mk_const(Aggregate(Repeat(cx.eval(elem)?, n)))\n       },\n       hir::ExprTupField(ref base, index) => {\n-        let c = cx.eval(base)?;\n-        if let Tuple(ref fields) = c {\n-            fields[index.node].clone()\n+        if let Aggregate(Tuple(fields)) = cx.eval(base)?.val {\n+            fields[index.node]\n         } else {\n             signal!(base, ExpectedConstTuple);\n         }\n       }\n       hir::ExprField(ref base, field_name) => {\n-        let c = cx.eval(base)?;\n-        if let Struct(ref fields) = c {\n-            if let Some(f) = fields.get(&field_name.node) {\n-                f.clone()\n+        if let Aggregate(Struct(fields)) = cx.eval(base)?.val {\n+            if let Some(&(_, f)) = fields.iter().find(|&&(name, _)| name == field_name.node) {\n+                f\n             } else {\n                 signal!(e, MissingStructField);\n             }\n@@ -551,15 +562,15 @@ fn cast_const_int<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ty::TyInt(ast::IntTy::I64) => Ok(Integral(I64(v as i128 as i64))),\n         ty::TyInt(ast::IntTy::I128) => Ok(Integral(I128(v as i128))),\n         ty::TyInt(ast::IntTy::Is) => {\n-            Ok(Integral(Isize(ConstIsize::new_truncating(v as i128, tcx.sess.target.int_type))))\n+            Ok(Integral(Isize(ConstIsize::new_truncating(v as i128, tcx.sess.target.isize_ty))))\n         },\n         ty::TyUint(ast::UintTy::U8) => Ok(Integral(U8(v as u8))),\n         ty::TyUint(ast::UintTy::U16) => Ok(Integral(U16(v as u16))),\n         ty::TyUint(ast::UintTy::U32) => Ok(Integral(U32(v as u32))),\n         ty::TyUint(ast::UintTy::U64) => Ok(Integral(U64(v as u64))),\n         ty::TyUint(ast::UintTy::U128) => Ok(Integral(U128(v as u128))),\n         ty::TyUint(ast::UintTy::Us) => {\n-            Ok(Integral(Usize(ConstUsize::new_truncating(v, tcx.sess.target.uint_type))))\n+            Ok(Integral(Usize(ConstUsize::new_truncating(v, tcx.sess.target.usize_ty))))\n         },\n         ty::TyFloat(fty) => {\n             if let Some(i) = val.to_u128() {\n@@ -625,7 +636,14 @@ fn cast_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 Err(ErrKind::UnimplementedConstVal(\"casting a bytestr to a raw ptr\"))\n             },\n             ty::TyRef(_, ty::TypeAndMut { ref ty, mutbl: hir::MutImmutable }) => match ty.sty {\n-                ty::TyArray(ty, n) if ty == tcx.types.u8 && n == b.len() => Ok(ByteStr(b)),\n+                ty::TyArray(ty, n) => {\n+                    let n = n.val.to_const_int().unwrap().to_u64().unwrap();\n+                    if ty == tcx.types.u8 && n == b.data.len() as u64 {\n+                        Ok(val)\n+                    } else {\n+                        Err(CannotCast)\n+                    }\n+                }\n                 ty::TySlice(_) => {\n                     Err(ErrKind::UnimplementedConstVal(\"casting a bytestr to slice\"))\n                 },\n@@ -645,7 +663,7 @@ fn cast_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn lit_to_const<'a, 'tcx>(lit: &ast::LitKind,\n+fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           mut ty: Ty<'tcx>)\n                           -> Result<ConstVal<'tcx>, ErrKind<'tcx>> {\n@@ -660,19 +678,19 @@ fn lit_to_const<'a, 'tcx>(lit: &ast::LitKind,\n \n     match *lit {\n         LitKind::Str(ref s, _) => Ok(Str(s.as_str())),\n-        LitKind::ByteStr(ref data) => Ok(ByteStr(data.clone())),\n+        LitKind::ByteStr(ref data) => Ok(ByteStr(ByteArray { data })),\n         LitKind::Byte(n) => Ok(Integral(U8(n))),\n         LitKind::Int(n, hint) => {\n             match (&ty.sty, hint) {\n                 (&ty::TyInt(ity), _) |\n                 (_, Signed(ity)) => {\n                     Ok(Integral(ConstInt::new_signed_truncating(n as i128,\n-                        ity, tcx.sess.target.int_type)))\n+                        ity, tcx.sess.target.isize_ty)))\n                 }\n                 (&ty::TyUint(uty), _) |\n                 (_, Unsigned(uty)) => {\n                     Ok(Integral(ConstInt::new_unsigned_truncating(n as u128,\n-                        uty, tcx.sess.target.uint_type)))\n+                        uty, tcx.sess.target.usize_ty)))\n                 }\n                 _ => bug!()\n             }\n@@ -708,19 +726,17 @@ pub fn compare_const_vals(tcx: TyCtxt, span: Span, a: &ConstVal, b: &ConstVal)\n         (&Float(a), &Float(b)) => a.try_cmp(b).ok(),\n         (&Str(ref a), &Str(ref b)) => Some(a.cmp(b)),\n         (&Bool(a), &Bool(b)) => Some(a.cmp(&b)),\n-        (&ByteStr(ref a), &ByteStr(ref b)) => Some(a.cmp(b)),\n-        (&Char(a), &Char(ref b)) => Some(a.cmp(b)),\n+        (&ByteStr(a), &ByteStr(b)) => Some(a.data.cmp(b.data)),\n+        (&Char(a), &Char(b)) => Some(a.cmp(&b)),\n         _ => None,\n     };\n \n     match result {\n         Some(result) => Ok(result),\n         None => {\n             // FIXME: can this ever be reached?\n-            span_err!(tcx.sess, span, E0298,\n-                      \"type mismatch comparing {} and {}\",\n-                      a.description(),\n-                      b.description());\n+            tcx.sess.delay_span_bug(span,\n+                &format!(\"type mismatch comparing {:?} and {:?}\", a, b));\n             Err(ErrorReported)\n         }\n     }\n@@ -729,8 +745,8 @@ pub fn compare_const_vals(tcx: TyCtxt, span: Span, a: &ConstVal, b: &ConstVal)\n impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n     pub fn compare_lit_exprs(&self,\n                              span: Span,\n-                             a: &Expr,\n-                             b: &Expr) -> Result<Ordering, ErrorReported> {\n+                             a: &'tcx Expr,\n+                             b: &'tcx Expr) -> Result<Ordering, ErrorReported> {\n         let tcx = self.tcx;\n         let a = match self.eval(a) {\n             Ok(a) => a,\n@@ -746,7 +762,7 @@ impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n                 return Err(ErrorReported);\n             }\n         };\n-        compare_const_vals(tcx, span, &a, &b)\n+        compare_const_vals(tcx, span, &a.val, &b.val)\n     }\n }\n \n@@ -774,7 +790,7 @@ fn const_eval<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         tcx.mir_const_qualif(def_id);\n         tcx.hir.body(tcx.hir.body_owned_by(id))\n     } else {\n-        tcx.sess.cstore.item_body(tcx, def_id)\n+        tcx.extern_const_body(def_id)\n     };\n     ConstContext::new(tcx, key.param_env.and(substs), tables).eval(&body.value)\n }"}, {"sha": "a87fa0c2746a3d3b413aa4ee8add356f8ffabce2", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 36, "deletions": 38, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -83,12 +83,12 @@ pub enum PatternKind<'tcx> {\n     },\n \n     Constant {\n-        value: ConstVal<'tcx>,\n+        value: &'tcx ty::Const<'tcx>,\n     },\n \n     Range {\n-        lo: ConstVal<'tcx>,\n-        hi: ConstVal<'tcx>,\n+        lo: &'tcx ty::Const<'tcx>,\n+        hi: &'tcx ty::Const<'tcx>,\n         end: RangeEnd,\n     },\n \n@@ -112,15 +112,13 @@ fn print_const_val(value: &ConstVal, f: &mut fmt::Formatter) -> fmt::Result {\n         ConstVal::Float(ref x) => write!(f, \"{}\", x),\n         ConstVal::Integral(ref i) => write!(f, \"{}\", i),\n         ConstVal::Str(ref s) => write!(f, \"{:?}\", &s[..]),\n-        ConstVal::ByteStr(ref b) => write!(f, \"{:?}\", &b[..]),\n+        ConstVal::ByteStr(b) => write!(f, \"{:?}\", b.data),\n         ConstVal::Bool(b) => write!(f, \"{:?}\", b),\n         ConstVal::Char(c) => write!(f, \"{:?}\", c),\n         ConstVal::Variant(_) |\n-        ConstVal::Struct(_) |\n-        ConstVal::Tuple(_) |\n         ConstVal::Function(..) |\n-        ConstVal::Array(..) |\n-        ConstVal::Repeat(..) => bug!(\"{:?} not printable in a pattern\", value)\n+        ConstVal::Aggregate(_) |\n+        ConstVal::Unevaluated(..) => bug!(\"{:?} not printable in a pattern\", value)\n     }\n }\n \n@@ -230,16 +228,16 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n                 }\n                 write!(f, \"{}\", subpattern)\n             }\n-            PatternKind::Constant { ref value } => {\n-                print_const_val(value, f)\n+            PatternKind::Constant { value } => {\n+                print_const_val(&value.val, f)\n             }\n-            PatternKind::Range { ref lo, ref hi, ref end } => {\n-                print_const_val(lo, f)?;\n-                match *end {\n+            PatternKind::Range { lo, hi, end } => {\n+                print_const_val(&lo.val, f)?;\n+                match end {\n                     RangeEnd::Included => write!(f, \"...\")?,\n                     RangeEnd::Excluded => write!(f, \"..\")?,\n                 }\n-                print_const_val(hi, f)\n+                print_const_val(&hi.val, f)\n             }\n             PatternKind::Slice { ref prefix, ref slice, ref suffix } |\n             PatternKind::Array { ref prefix, ref slice, ref suffix } => {\n@@ -278,7 +276,7 @@ impl<'a, 'tcx> Pattern<'tcx> {\n     pub fn from_hir(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     param_env_and_substs: ty::ParamEnvAnd<'tcx, &'tcx Substs<'tcx>>,\n                     tables: &'a ty::TypeckTables<'tcx>,\n-                    pat: &hir::Pat) -> Self {\n+                    pat: &'tcx hir::Pat) -> Self {\n         let mut pcx = PatternContext::new(tcx, param_env_and_substs, tables);\n         let result = pcx.lower_pattern(pat);\n         if !pcx.errors.is_empty() {\n@@ -302,19 +300,19 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         }\n     }\n \n-    pub fn lower_pattern(&mut self, pat: &hir::Pat) -> Pattern<'tcx> {\n+    pub fn lower_pattern(&mut self, pat: &'tcx hir::Pat) -> Pattern<'tcx> {\n         let mut ty = self.tables.node_id_to_type(pat.hir_id);\n \n         let kind = match pat.node {\n             PatKind::Wild => PatternKind::Wild,\n \n             PatKind::Lit(ref value) => self.lower_lit(value),\n \n-            PatKind::Range(ref lo, ref hi, ref end) => {\n+            PatKind::Range(ref lo, ref hi, end) => {\n                 match (self.lower_lit(lo), self.lower_lit(hi)) {\n                     (PatternKind::Constant { value: lo },\n                      PatternKind::Constant { value: hi }) => {\n-                        PatternKind::Range { lo: lo, hi: hi, end: end.clone() }\n+                        PatternKind::Range { lo, hi, end }\n                     }\n                     _ => PatternKind::Wild\n                 }\n@@ -374,8 +372,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 }\n             }\n \n-            PatKind::Binding(_, def_id, ref ident, ref sub) => {\n-                let id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n+            PatKind::Binding(_, id, ref ident, ref sub) => {\n                 let var_ty = self.tables.node_id_to_type(pat.hir_id);\n                 let region = match var_ty.sty {\n                     ty::TyRef(r, _) => Some(r),\n@@ -475,11 +472,11 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         }\n     }\n \n-    fn lower_patterns(&mut self, pats: &[P<hir::Pat>]) -> Vec<Pattern<'tcx>> {\n+    fn lower_patterns(&mut self, pats: &'tcx [P<hir::Pat>]) -> Vec<Pattern<'tcx>> {\n         pats.iter().map(|p| self.lower_pattern(p)).collect()\n     }\n \n-    fn lower_opt_pattern(&mut self, pat: &Option<P<hir::Pat>>) -> Option<Pattern<'tcx>>\n+    fn lower_opt_pattern(&mut self, pat: &'tcx Option<P<hir::Pat>>) -> Option<Pattern<'tcx>>\n     {\n         pat.as_ref().map(|p| self.lower_pattern(p))\n     }\n@@ -522,9 +519,9 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         &mut self,\n         span: Span,\n         ty: Ty<'tcx>,\n-        prefix: &[P<hir::Pat>],\n-        slice: &Option<P<hir::Pat>>,\n-        suffix: &[P<hir::Pat>])\n+        prefix: &'tcx [P<hir::Pat>],\n+        slice: &'tcx Option<P<hir::Pat>>,\n+        suffix: &'tcx [P<hir::Pat>])\n         -> PatternKind<'tcx>\n     {\n         let prefix = self.lower_patterns(prefix);\n@@ -541,7 +538,8 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n             ty::TyArray(_, len) => {\n                 // fixed-length array\n-                assert!(len >= prefix.len() + suffix.len());\n+                let len = len.val.to_const_int().unwrap().to_u64().unwrap();\n+                assert!(len >= prefix.len() as u64 + suffix.len() as u64);\n                 PatternKind::Array { prefix: prefix, slice: slice, suffix: suffix }\n             }\n \n@@ -609,7 +607,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                         let body = if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n                             self.tcx.hir.body(self.tcx.hir.body_owned_by(id))\n                         } else {\n-                            self.tcx.sess.cstore.item_body(self.tcx, def_id)\n+                            self.tcx.extern_const_body(def_id)\n                         };\n                         let pat = self.lower_const_expr(&body.value, pat_id, span);\n                         self.tables = old_tables;\n@@ -632,17 +630,17 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         }\n     }\n \n-    fn lower_lit(&mut self, expr: &hir::Expr) -> PatternKind<'tcx> {\n+    fn lower_lit(&mut self, expr: &'tcx hir::Expr) -> PatternKind<'tcx> {\n         let const_cx = eval::ConstContext::new(self.tcx,\n                                                self.param_env.and(self.substs),\n                                                self.tables);\n         match const_cx.eval(expr) {\n             Ok(value) => {\n-                if let ConstVal::Variant(def_id) = value {\n+                if let ConstVal::Variant(def_id) = value.val {\n                     let ty = self.tables.expr_ty(expr);\n                     self.lower_variant_or_leaf(Def::Variant(def_id), ty, vec![])\n                 } else {\n-                    PatternKind::Constant { value: value }\n+                    PatternKind::Constant { value }\n                 }\n             }\n             Err(e) => {\n@@ -653,7 +651,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n     }\n \n     fn lower_const_expr(&mut self,\n-                        expr: &hir::Expr,\n+                        expr: &'tcx hir::Expr,\n                         pat_id: ast::NodeId,\n                         span: Span)\n                         -> Pattern<'tcx> {\n@@ -820,8 +818,8 @@ macro_rules! CloneImpls {\n }\n \n CloneImpls!{ <'tcx>\n-    Span, Field, Mutability, ast::Name, ast::NodeId, usize, ConstVal<'tcx>, Region<'tcx>,\n-    Ty<'tcx>, BindingMode<'tcx>, &'tcx AdtDef,\n+    Span, Field, Mutability, ast::Name, ast::NodeId, usize, &'tcx ty::Const<'tcx>,\n+    Region<'tcx>, Ty<'tcx>, BindingMode<'tcx>, &'tcx AdtDef,\n     &'tcx Substs<'tcx>, &'tcx Kind<'tcx>\n }\n \n@@ -893,18 +891,18 @@ impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n                 subpattern: subpattern.fold_with(folder),\n             },\n             PatternKind::Constant {\n-                ref value\n+                value\n             } => PatternKind::Constant {\n                 value: value.fold_with(folder)\n             },\n             PatternKind::Range {\n-                ref lo,\n-                ref hi,\n-                ref end,\n+                lo,\n+                hi,\n+                end,\n             } => PatternKind::Range {\n                 lo: lo.fold_with(folder),\n                 hi: hi.fold_with(folder),\n-                end: end.clone(),\n+                end,\n             },\n             PatternKind::Slice {\n                 ref prefix,"}, {"sha": "08473d729e4e5a24877696659e3a323750423cb5", "filename": "src/librustc_const_math/int.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_const_math%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_const_math%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fint.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -311,17 +311,13 @@ impl ::std::fmt::Display for ConstInt {\n             I32(i) => write!(fmt, \"{}i32\", i),\n             I64(i) => write!(fmt, \"{}i64\", i),\n             I128(i) => write!(fmt, \"{}i128\", i),\n-            Isize(ConstIsize::Is64(i)) => write!(fmt, \"{}isize\", i),\n-            Isize(ConstIsize::Is32(i)) => write!(fmt, \"{}isize\", i),\n-            Isize(ConstIsize::Is16(i)) => write!(fmt, \"{}isize\", i),\n+            Isize(i) => write!(fmt, \"{}isize\", i),\n             U8(i) => write!(fmt, \"{}u8\", i),\n             U16(i) => write!(fmt, \"{}u16\", i),\n             U32(i) => write!(fmt, \"{}u32\", i),\n             U64(i) => write!(fmt, \"{}u64\", i),\n             U128(i) => write!(fmt, \"{}u128\", i),\n-            Usize(ConstUsize::Us64(i)) => write!(fmt, \"{}usize\", i),\n-            Usize(ConstUsize::Us32(i)) => write!(fmt, \"{}usize\", i),\n-            Usize(ConstUsize::Us16(i)) => write!(fmt, \"{}usize\", i),\n+            Usize(i) => write!(fmt, \"{}usize\", i),\n         }\n     }\n }"}, {"sha": "50dfb60112991aa98fbe83b8182ca1dfb6129537", "filename": "src/librustc_const_math/is.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_const_math%2Fis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_const_math%2Fis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fis.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -21,18 +21,22 @@ pub enum ConstIsize {\n }\n pub use self::ConstIsize::*;\n \n+impl ::std::fmt::Display for ConstIsize {\n+    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n+        write!(fmt, \"{}\", self.as_i64())\n+    }\n+}\n+\n impl ConstIsize {\n-    pub fn as_i64(self, target_int_ty: ast::IntTy) -> i64 {\n-        match (self, target_int_ty) {\n-            (Is16(i), ast::IntTy::I16) => i as i64,\n-            (Is32(i), ast::IntTy::I32) => i as i64,\n-            (Is64(i), ast::IntTy::I64) => i,\n-            _ => panic!(\"unable to convert self ({:?}) to target isize ({:?})\",\n-                        self, target_int_ty),\n+    pub fn as_i64(self) -> i64 {\n+        match self {\n+            Is16(i) => i as i64,\n+            Is32(i) => i as i64,\n+            Is64(i) => i,\n         }\n     }\n-    pub fn new(i: i64, target_int_ty: ast::IntTy) -> Result<Self, ConstMathErr> {\n-        match target_int_ty {\n+    pub fn new(i: i64, isize_ty: ast::IntTy) -> Result<Self, ConstMathErr> {\n+        match isize_ty {\n             ast::IntTy::I16 if i as i16 as i64 == i => Ok(Is16(i as i16)),\n             ast::IntTy::I16 => Err(LitOutOfRange(ast::IntTy::Is)),\n             ast::IntTy::I32 if i as i32 as i64 == i => Ok(Is32(i as i32)),\n@@ -41,8 +45,8 @@ impl ConstIsize {\n             _ => unreachable!(),\n         }\n     }\n-    pub fn new_truncating(i: i128, target_int_ty: ast::IntTy) -> Self {\n-        match target_int_ty {\n+    pub fn new_truncating(i: i128, isize_ty: ast::IntTy) -> Self {\n+        match isize_ty {\n             ast::IntTy::I16 => Is16(i as i16),\n             ast::IntTy::I32 => Is32(i as i32),\n             ast::IntTy::I64 => Is64(i as i64),"}, {"sha": "9876bc4d779a0cc1914547963fa9e0720ada0f0c", "filename": "src/librustc_const_math/us.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_const_math%2Fus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_const_math%2Fus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fus.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -21,18 +21,22 @@ pub enum ConstUsize {\n }\n pub use self::ConstUsize::*;\n \n+impl ::std::fmt::Display for ConstUsize {\n+    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n+        write!(fmt, \"{}\", self.as_u64())\n+    }\n+}\n+\n impl ConstUsize {\n-    pub fn as_u64(self, target_uint_ty: ast::UintTy) -> u64 {\n-        match (self, target_uint_ty) {\n-            (Us16(i), ast::UintTy::U16) => i as u64,\n-            (Us32(i), ast::UintTy::U32) => i as u64,\n-            (Us64(i), ast::UintTy::U64) => i,\n-            _ => panic!(\"unable to convert self ({:?}) to target usize ({:?})\",\n-                        self, target_uint_ty),\n+    pub fn as_u64(self) -> u64 {\n+        match self {\n+            Us16(i) => i as u64,\n+            Us32(i) => i as u64,\n+            Us64(i) => i,\n         }\n     }\n-    pub fn new(i: u64, target_uint_ty: ast::UintTy) -> Result<Self, ConstMathErr> {\n-        match target_uint_ty {\n+    pub fn new(i: u64, usize_ty: ast::UintTy) -> Result<Self, ConstMathErr> {\n+        match usize_ty {\n             ast::UintTy::U16 if i as u16 as u64 == i => Ok(Us16(i as u16)),\n             ast::UintTy::U16 => Err(ULitOutOfRange(ast::UintTy::Us)),\n             ast::UintTy::U32 if i as u32 as u64 == i => Ok(Us32(i as u32)),\n@@ -41,8 +45,8 @@ impl ConstUsize {\n             _ => unreachable!(),\n         }\n     }\n-    pub fn new_truncating(i: u128, target_uint_ty: ast::UintTy) -> Self {\n-        match target_uint_ty {\n+    pub fn new_truncating(i: u128, usize_ty: ast::UintTy) -> Self {\n+        match usize_ty {\n             ast::UintTy::U16 => Us16(i as u16),\n             ast::UintTy::U32 => Us32(i as u32),\n             ast::UintTy::U64 => Us64(i as u64),"}, {"sha": "c41d5beec6877ab61570ae2f6fcfa17601e1b080", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -21,6 +21,7 @@ use rustc::session::config::{self, Input, OutputFilenames, OutputType};\n use rustc::session::search_paths::PathKind;\n use rustc::lint;\n use rustc::middle::{self, stability, reachable};\n+use rustc::middle::cstore::CrateStore;\n use rustc::middle::privacy::AccessLevels;\n use rustc::mir::transform::{MIR_CONST, MIR_VALIDATED, MIR_OPTIMIZED, Passes};\n use rustc::ty::{self, TyCtxt, Resolutions, GlobalArenas};\n@@ -200,6 +201,7 @@ pub fn compile_input(sess: &Session,\n         };\n \n         phase_3_run_analysis_passes(sess,\n+                                    cstore,\n                                     hir_map,\n                                     analysis,\n                                     resolutions,\n@@ -385,7 +387,7 @@ pub struct CompileState<'a, 'tcx: 'a> {\n     pub session: &'tcx Session,\n     pub krate: Option<ast::Crate>,\n     pub registry: Option<Registry<'a>>,\n-    pub cstore: Option<&'a CStore>,\n+    pub cstore: Option<&'tcx CStore>,\n     pub crate_name: Option<&'a str>,\n     pub output_filenames: Option<&'a OutputFilenames>,\n     pub out_dir: Option<&'a Path>,\n@@ -433,7 +435,7 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n                          out_dir: &'a Option<PathBuf>,\n                          out_file: &'a Option<PathBuf>,\n                          krate: ast::Crate,\n-                         cstore: &'a CStore)\n+                         cstore: &'tcx CStore)\n                          -> Self {\n         CompileState {\n             // Initialize the registry before moving `krate`\n@@ -449,7 +451,7 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n                           session: &'tcx Session,\n                           out_dir: &'a Option<PathBuf>,\n                           out_file: &'a Option<PathBuf>,\n-                          cstore: &'a CStore,\n+                          cstore: &'tcx CStore,\n                           expanded_crate: &'a ast::Crate,\n                           crate_name: &'a str)\n                           -> Self {\n@@ -468,7 +470,7 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n                                 out_file: &'a Option<PathBuf>,\n                                 arena: &'tcx DroplessArena,\n                                 arenas: &'tcx GlobalArenas<'tcx>,\n-                                cstore: &'a CStore,\n+                                cstore: &'tcx CStore,\n                                 hir_map: &'a hir_map::Map<'tcx>,\n                                 analysis: &'a ty::CrateAnalysis,\n                                 resolutions: &'a Resolutions,\n@@ -694,9 +696,9 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n     // this back at some point.\n     let _ignore = sess.dep_graph.in_ignore();\n     let mut crate_loader = CrateLoader::new(sess, &cstore, crate_name);\n-    crate_loader.preprocess(&krate);\n     let resolver_arenas = Resolver::arenas();\n     let mut resolver = Resolver::new(sess,\n+                                     cstore,\n                                      &krate,\n                                      crate_name,\n                                      make_glob_map,\n@@ -845,7 +847,7 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n \n     // Lower ast -> hir.\n     let hir_forest = time(time_passes, \"lowering ast -> hir\", || {\n-        let hir_crate = lower_crate(sess, &krate, &mut resolver);\n+        let hir_crate = lower_crate(sess, cstore, &krate, &mut resolver);\n \n         if sess.opts.debugging_opts.hir_stats {\n             hir_stats::print_hir_stats(&hir_crate);\n@@ -887,6 +889,7 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n /// miscellaneous analysis passes on the crate. Return various\n /// structures carrying the results of the analysis.\n pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n+                                               cstore: &'tcx CrateStore,\n                                                hir_map: hir_map::Map<'tcx>,\n                                                mut analysis: ty::CrateAnalysis,\n                                                resolutions: Resolutions,\n@@ -914,15 +917,9 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     let time_passes = sess.time_passes();\n \n-    let lang_items = time(time_passes, \"language item collection\", || {\n-        sess.track_errors(|| {\n-            middle::lang_items::collect_language_items(&sess, &hir_map)\n-        })\n-    })?;\n-\n     let named_region_map = time(time_passes,\n                                 \"lifetime resolution\",\n-                                || middle::resolve_lifetime::krate(sess, &hir_map))?;\n+                                || middle::resolve_lifetime::krate(sess, cstore, &hir_map))?;\n \n     time(time_passes,\n          \"looking for entry point\",\n@@ -941,8 +938,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n               \"static item recursion checking\",\n               || static_recursion::check_crate(sess, &hir_map))?;\n \n-    let index = stability::Index::new(&sess);\n-\n     let mut local_providers = ty::maps::Providers::default();\n     borrowck::provide(&mut local_providers);\n     mir::provide(&mut local_providers);\n@@ -1021,6 +1016,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::dump_mir::Marker(\"PreTrans\"));\n \n     TyCtxt::create_and_enter(sess,\n+                             cstore,\n                              local_providers,\n                              extern_providers,\n                              Rc::new(passes),\n@@ -1029,8 +1025,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                              resolutions,\n                              named_region_map,\n                              hir_map,\n-                             lang_items,\n-                             index,\n                              name,\n                              |tcx| {\n         let incremental_hashes_map =\n@@ -1042,10 +1036,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              \"load_dep_graph\",\n              || rustc_incremental::load_dep_graph(tcx, &incremental_hashes_map));\n \n-        time(time_passes, \"stability index\", || {\n-            tcx.stability.borrow_mut().build(tcx)\n-        });\n-\n         time(time_passes,\n              \"stability checking\",\n              || stability::check_unstable_api_usage(tcx));\n@@ -1166,7 +1156,10 @@ pub fn phase_6_link_output(sess: &Session,\n                            trans: &trans::CrateTranslation,\n                            outputs: &OutputFilenames) {\n     time(sess.time_passes(), \"linking\", || {\n-        ::rustc_trans::back::link::link_binary(sess, trans, outputs, &trans.crate_name.as_str())\n+        ::rustc_trans::back::link::link_binary(sess,\n+                                               trans,\n+                                               outputs,\n+                                               &trans.crate_name.as_str())\n     });\n }\n "}, {"sha": "099dda17823e67f864b112e437ae8ba72c65ec77", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -72,6 +72,7 @@ use rustc::session::config::nightly_options;\n use rustc::session::{early_error, early_warn};\n use rustc::lint::Lint;\n use rustc::lint;\n+use rustc::middle::cstore::CrateStore;\n use rustc_metadata::locator;\n use rustc_metadata::cstore::CStore;\n use rustc::util::common::{time, ErrorReported};\n@@ -294,12 +295,12 @@ pub fn run_compiler<'a>(args: &[String],\n     };\n \n     let dep_graph = DepGraph::new(sopts.build_dep_graph());\n-    let cstore = Rc::new(CStore::new(&dep_graph, box ::MetadataLoader));\n+    let cstore = Rc::new(CStore::new(box ::MetadataLoader));\n \n     let loader = file_loader.unwrap_or(box RealFileLoader);\n     let codemap = Rc::new(CodeMap::with_file_loader(loader, sopts.file_path_mapping()));\n     let mut sess = session::build_session_with_codemap(\n-        sopts, &dep_graph, input_file_path, descriptions, cstore.clone(), codemap, emitter_dest,\n+        sopts, &dep_graph, input_file_path, descriptions, codemap, emitter_dest,\n     );\n     rustc_trans::init(&sess);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n@@ -308,7 +309,12 @@ pub fn run_compiler<'a>(args: &[String],\n     target_features::add_configuration(&mut cfg, &sess);\n     sess.parse_sess.config = cfg;\n \n-    do_or_return!(callbacks.late_callback(&matches, &sess, &input, &odir, &ofile), Some(sess));\n+    do_or_return!(callbacks.late_callback(&matches,\n+                                          &sess,\n+                                          &*cstore,\n+                                          &input,\n+                                          &odir,\n+                                          &ofile), Some(sess));\n \n     let plugins = sess.opts.debugging_opts.extra_plugins.clone();\n     let control = callbacks.build_controller(&sess, &matches);\n@@ -400,6 +406,7 @@ pub trait CompilerCalls<'a> {\n     fn late_callback(&mut self,\n                      _: &getopts::Matches,\n                      _: &Session,\n+                     _: &CrateStore,\n                      _: &Input,\n                      _: &Option<PathBuf>,\n                      _: &Option<PathBuf>)\n@@ -574,12 +581,10 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                     return None;\n                 }\n                 let dep_graph = DepGraph::new(sopts.build_dep_graph());\n-                let cstore = Rc::new(CStore::new(&dep_graph, box ::MetadataLoader));\n                 let mut sess = build_session(sopts.clone(),\n                     &dep_graph,\n                     None,\n-                    descriptions.clone(),\n-                    cstore.clone());\n+                    descriptions.clone());\n                 rustc_trans::init(&sess);\n                 rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n                 let mut cfg = config::build_configuration(&sess, cfg.clone());\n@@ -601,12 +606,13 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n     fn late_callback(&mut self,\n                      matches: &getopts::Matches,\n                      sess: &Session,\n+                     cstore: &CrateStore,\n                      input: &Input,\n                      odir: &Option<PathBuf>,\n                      ofile: &Option<PathBuf>)\n                      -> Compilation {\n         RustcDefaultCalls::print_crate_info(sess, Some(input), odir, ofile)\n-            .and_then(|| RustcDefaultCalls::list_metadata(sess, matches, input))\n+            .and_then(|| RustcDefaultCalls::list_metadata(sess, cstore, matches, input))\n     }\n \n     fn build_controller(&mut self,\n@@ -627,6 +633,7 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                 };\n                 control.after_hir_lowering.callback = box move |state| {\n                     pretty::print_after_hir_lowering(state.session,\n+                                                     state.cstore.unwrap(),\n                                                      state.hir_map.unwrap(),\n                                                      state.analysis.unwrap(),\n                                                      state.resolutions.unwrap(),\n@@ -711,7 +718,11 @@ fn save_analysis(sess: &Session) -> bool {\n }\n \n impl RustcDefaultCalls {\n-    pub fn list_metadata(sess: &Session, matches: &getopts::Matches, input: &Input) -> Compilation {\n+    pub fn list_metadata(sess: &Session,\n+                         cstore: &CrateStore,\n+                         matches: &getopts::Matches,\n+                         input: &Input)\n+                         -> Compilation {\n         let r = matches.opt_strs(\"Z\");\n         if r.contains(&(\"ls\".to_string())) {\n             match input {\n@@ -720,7 +731,7 @@ impl RustcDefaultCalls {\n                     let mut v = Vec::new();\n                     locator::list_file_metadata(&sess.target.target,\n                                                 path,\n-                                                sess.cstore.metadata_loader(),\n+                                                cstore.metadata_loader(),\n                                                 &mut v)\n                             .unwrap();\n                     println!(\"{}\", String::from_utf8(v).unwrap());"}, {"sha": "82dda2d2aa16278dfa6804132ac83d6df4780ff2", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -21,6 +21,7 @@ use rustc::ty::{self, TyCtxt, GlobalArenas, Resolutions};\n use rustc::cfg;\n use rustc::cfg::graphviz::LabelledCFG;\n use rustc::dep_graph::DepGraph;\n+use rustc::middle::cstore::CrateStore;\n use rustc::session::Session;\n use rustc::session::config::Input;\n use rustc_borrowck as borrowck;\n@@ -198,6 +199,7 @@ impl PpSourceMode {\n     }\n     fn call_with_pp_support_hir<'tcx, A, F>(&self,\n                                                sess: &'tcx Session,\n+                                               cstore: &'tcx CrateStore,\n                                                hir_map: &hir_map::Map<'tcx>,\n                                                analysis: &ty::CrateAnalysis,\n                                                resolutions: &Resolutions,\n@@ -226,6 +228,7 @@ impl PpSourceMode {\n             }\n             PpmTyped => {\n                 abort_on_err(driver::phase_3_run_analysis_passes(sess,\n+                                                                 cstore,\n                                                                  hir_map.clone(),\n                                                                  analysis.clone(),\n                                                                  resolutions.clone(),\n@@ -875,6 +878,7 @@ pub fn print_after_parsing(sess: &Session,\n }\n \n pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n+                                                cstore: &'tcx CrateStore,\n                                                 hir_map: &hir_map::Map<'tcx>,\n                                                 analysis: &ty::CrateAnalysis,\n                                                 resolutions: &Resolutions,\n@@ -891,6 +895,7 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n \n     if ppm.needs_analysis() {\n         print_with_analysis(sess,\n+                            cstore,\n                             hir_map,\n                             analysis,\n                             resolutions,\n@@ -929,6 +934,7 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n             (PpmHir(s), None) => {\n                 let out: &mut Write = &mut out;\n                 s.call_with_pp_support_hir(sess,\n+                                           cstore,\n                                            hir_map,\n                                            analysis,\n                                            resolutions,\n@@ -952,6 +958,7 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n             (PpmHir(s), Some(uii)) => {\n                 let out: &mut Write = &mut out;\n                 s.call_with_pp_support_hir(sess,\n+                                           cstore,\n                                            hir_map,\n                                            analysis,\n                                            resolutions,\n@@ -993,6 +1000,7 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n // with a different callback than the standard driver, so that isn't easy.\n // Instead, we call that function ourselves.\n fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n+                                       cstore: &'a CrateStore,\n                                        hir_map: &hir_map::Map<'tcx>,\n                                        analysis: &ty::CrateAnalysis,\n                                        resolutions: &Resolutions,\n@@ -1013,6 +1021,7 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n     let mut out = Vec::new();\n \n     abort_on_err(driver::phase_3_run_analysis_passes(sess,\n+                                                     cstore,\n                                                      hir_map.clone(),\n                                                      analysis.clone(),\n                                                      resolutions.clone(),"}, {"sha": "d2fb9903683676a5e6b853183108de3d203166c0", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -15,11 +15,9 @@ use rustc::dep_graph::DepGraph;\n use rustc_lint;\n use rustc_resolve::MakeGlobMap;\n use rustc_trans;\n-use rustc::middle::lang_items;\n use rustc::middle::free_region::FreeRegionMap;\n use rustc::middle::region;\n use rustc::middle::resolve_lifetime;\n-use rustc::middle::stability;\n use rustc::ty::subst::{Kind, Subst};\n use rustc::traits::{ObligationCause, Reveal};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n@@ -106,13 +104,12 @@ fn test_env<F>(source_string: &str,\n \n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n-    let cstore = Rc::new(CStore::new(&dep_graph, box ::MetadataLoader));\n+    let cstore = Rc::new(CStore::new(box ::MetadataLoader));\n     let sess = session::build_session_(options,\n                                        &dep_graph,\n                                        None,\n                                        diagnostic_handler,\n-                                       Rc::new(CodeMap::new(FilePathMapping::empty())),\n-                                       cstore.clone());\n+                                       Rc::new(CodeMap::new(FilePathMapping::empty())));\n     rustc_trans::init(&sess);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     let input = config::Input::Str {\n@@ -140,10 +137,9 @@ fn test_env<F>(source_string: &str,\n     let hir_map = hir_map::map_crate(&mut hir_forest, defs);\n \n     // run just enough stuff to build a tcx:\n-    let lang_items = lang_items::collect_language_items(&sess, &hir_map);\n-    let named_region_map = resolve_lifetime::krate(&sess, &hir_map);\n-    let index = stability::Index::new(&sess);\n+    let named_region_map = resolve_lifetime::krate(&sess, &*cstore, &hir_map);\n     TyCtxt::create_and_enter(&sess,\n+                             &*cstore,\n                              ty::maps::Providers::default(),\n                              ty::maps::Providers::default(),\n                              Rc::new(Passes::new()),\n@@ -152,8 +148,6 @@ fn test_env<F>(source_string: &str,\n                              resolutions,\n                              named_region_map.unwrap(),\n                              hir_map,\n-                             lang_items,\n-                             index,\n                              \"test_crate\",\n                              |tcx| {\n         tcx.infer_ctxt().enter(|infcx| {\n@@ -807,13 +801,13 @@ fn walk_ty() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let tcx = env.infcx.tcx;\n         let int_ty = tcx.types.isize;\n-        let uint_ty = tcx.types.usize;\n-        let tup1_ty = tcx.intern_tup(&[int_ty, uint_ty, int_ty, uint_ty], false);\n-        let tup2_ty = tcx.intern_tup(&[tup1_ty, tup1_ty, uint_ty], false);\n+        let usize_ty = tcx.types.usize;\n+        let tup1_ty = tcx.intern_tup(&[int_ty, usize_ty, int_ty, usize_ty], false);\n+        let tup2_ty = tcx.intern_tup(&[tup1_ty, tup1_ty, usize_ty], false);\n         let walked: Vec<_> = tup2_ty.walk().collect();\n         assert_eq!(walked,\n-                   [tup2_ty, tup1_ty, int_ty, uint_ty, int_ty, uint_ty, tup1_ty, int_ty,\n-                    uint_ty, int_ty, uint_ty, uint_ty]);\n+                   [tup2_ty, tup1_ty, int_ty, usize_ty, int_ty, usize_ty, tup1_ty, int_ty,\n+                    usize_ty, int_ty, usize_ty, usize_ty]);\n     })\n }\n \n@@ -822,20 +816,20 @@ fn walk_ty_skip_subtree() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let tcx = env.infcx.tcx;\n         let int_ty = tcx.types.isize;\n-        let uint_ty = tcx.types.usize;\n-        let tup1_ty = tcx.intern_tup(&[int_ty, uint_ty, int_ty, uint_ty], false);\n-        let tup2_ty = tcx.intern_tup(&[tup1_ty, tup1_ty, uint_ty], false);\n+        let usize_ty = tcx.types.usize;\n+        let tup1_ty = tcx.intern_tup(&[int_ty, usize_ty, int_ty, usize_ty], false);\n+        let tup2_ty = tcx.intern_tup(&[tup1_ty, tup1_ty, usize_ty], false);\n \n         // types we expect to see (in order), plus a boolean saying\n         // whether to skip the subtree.\n         let mut expected = vec![(tup2_ty, false),\n                                 (tup1_ty, false),\n                                 (int_ty, false),\n-                                (uint_ty, false),\n+                                (usize_ty, false),\n                                 (int_ty, false),\n-                                (uint_ty, false),\n+                                (usize_ty, false),\n                                 (tup1_ty, true), // skip the isize/usize/isize/usize\n-                                (uint_ty, false)];\n+                                (usize_ty, false)];\n         expected.reverse();\n \n         let mut walker = tup2_ty.walk();"}, {"sha": "ceb94f27dc3cea3ef9ff340f32f09c1d09311551", "filename": "src/librustc_errors/styled_buffer.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_errors%2Fstyled_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_errors%2Fstyled_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fstyled_buffer.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -26,14 +26,11 @@ impl StyledBuffer {\n         }\n     }\n \n-    pub fn copy_tabs(&mut self, row: usize) {\n-        if row < self.text.len() {\n-            for i in row + 1..self.text.len() {\n-                for j in 0..self.text[i].len() {\n-                    if self.text[row].len() > j && self.text[row][j] == '\\t' &&\n-                       self.text[i][j] == ' ' {\n-                        self.text[i][j] = '\\t';\n-                    }\n+    fn replace_tabs(&mut self) {\n+        for line in self.text.iter_mut() {\n+            for c in line.iter_mut() {\n+                if *c == '\\t' {\n+                    *c = ' ';\n                 }\n             }\n         }\n@@ -43,8 +40,8 @@ impl StyledBuffer {\n         let mut output: Vec<Vec<StyledString>> = vec![];\n         let mut styled_vec: Vec<StyledString> = vec![];\n \n-        // before we render, do a little patch-up work to support tabs\n-        self.copy_tabs(3);\n+        // before we render, replace tabs with spaces\n+        self.replace_tabs();\n \n         for (row, row_style) in self.text.iter().zip(&self.styles) {\n             let mut current_style = Style::NoStyle;"}, {"sha": "434c82095bd9a98d0e21cbf8a3639d934646202c", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -632,7 +632,7 @@ pub fn find_metadata_hashes_for(tcx: TyCtxt, cnum: CrateNum) -> Option<PathBuf>\n         }\n     };\n \n-    let target_svh = tcx.sess.cstore.crate_hash(cnum);\n+    let target_svh = tcx.crate_hash(cnum);\n     let target_svh = base_n::encode(target_svh.as_u64(), INT_ENCODE_BASE);\n \n     let sub_dir = find_metadata_hashes_iter(&target_svh, dir_entries.filter_map(|e| {"}, {"sha": "44d6788c773651569c5164b90d9fe5eabf177f28", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -133,7 +133,7 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n     fn load_data(&mut self, cnum: CrateNum) {\n         debug!(\"load_data(cnum={})\", cnum);\n \n-        let svh = self.tcx.sess.cstore.crate_hash(cnum);\n+        let svh = self.tcx.crate_hash(cnum);\n         let old = self.crate_hashes.insert(cnum, svh);\n         debug!(\"load_data: svh={}\", svh);\n         assert!(old.is_none(), \"loaded data for crate {:?} twice\", cnum);"}, {"sha": "f3bf37c11a5468866b6feb2cdedabdb7bf2b280f", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -547,7 +547,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n             _ => return,\n         }\n \n-        let debug = match cx.tcx.lang_items.debug_trait() {\n+        let debug = match cx.tcx.lang_items().debug_trait() {\n             Some(debug) => debug,\n             None => return,\n         };\n@@ -913,7 +913,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n                     } else {\n                         return false;\n                     };\n-                    def.def_id() == cx.tcx.hir.local_def_id(fn_id)\n+                    match def {\n+                        Def::Local(..) | Def::Upvar(..) => false,\n+                        _ => def.def_id() == cx.tcx.hir.local_def_id(fn_id)\n+                    }\n                 }\n                 _ => false,\n             }\n@@ -1063,8 +1066,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PluginAsLibrary {\n             _ => return,\n         };\n \n-        let prfn = match cx.sess().cstore.extern_mod_stmt_cnum(it.id) {\n-            Some(cnum) => cx.sess().cstore.plugin_registrar_fn(cnum),\n+        let def_id = cx.tcx.hir.local_def_id(it.id);\n+        let prfn = match cx.tcx.extern_mod_stmt_cnum(def_id) {\n+            Some(cnum) => cx.tcx.plugin_registrar_fn(cnum),\n             None => {\n                 // Probably means we aren't linking the crate for some reason.\n                 //"}, {"sha": "d3a5d52b295afa54938281d317249855537beed6", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -76,7 +76,7 @@ impl LintPass for TypeLimits {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n-    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx hir::Expr) {\n         match e.node {\n             hir::ExprUnary(hir::UnNeg, ref expr) => {\n                 // propagate negation, if the negation itself isn't negated\n@@ -93,8 +93,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n \n                 if binop.node.is_shift() {\n                     let opt_ty_bits = match cx.tables.node_id_to_type(l.hir_id).sty {\n-                        ty::TyInt(t) => Some(int_ty_bits(t, cx.sess().target.int_type)),\n-                        ty::TyUint(t) => Some(uint_ty_bits(t, cx.sess().target.uint_type)),\n+                        ty::TyInt(t) => Some(int_ty_bits(t, cx.sess().target.isize_ty)),\n+                        ty::TyUint(t) => Some(uint_ty_bits(t, cx.sess().target.usize_ty)),\n                         _ => None,\n                     };\n \n@@ -117,7 +117,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                                                              cx.param_env.and(substs),\n                                                              cx.tables);\n                             match const_cx.eval(&r) {\n-                                Ok(ConstVal::Integral(i)) => {\n+                                Ok(&ty::Const { val: ConstVal::Integral(i), .. }) => {\n                                     i.is_negative() ||\n                                     i.to_u64()\n                                         .map(|i| i >= bits)\n@@ -141,7 +141,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                             ast::LitKind::Int(v, ast::LitIntType::Signed(_)) |\n                             ast::LitKind::Int(v, ast::LitIntType::Unsuffixed) => {\n                                 let int_type = if let ast::IntTy::Is = t {\n-                                    cx.sess().target.int_type\n+                                    cx.sess().target.isize_ty\n                                 } else {\n                                     t\n                                 };\n@@ -164,7 +164,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                     }\n                     ty::TyUint(t) => {\n                         let uint_type = if let ast::UintTy::Us = t {\n-                            cx.sess().target.uint_type\n+                            cx.sess().target.usize_ty\n                         } else {\n                             t\n                         };\n@@ -250,9 +250,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n             }\n         }\n \n-        fn int_ty_bits(int_ty: ast::IntTy, target_int_ty: ast::IntTy) -> u64 {\n+        fn int_ty_bits(int_ty: ast::IntTy, isize_ty: ast::IntTy) -> u64 {\n             match int_ty {\n-                ast::IntTy::Is => int_ty_bits(target_int_ty, target_int_ty),\n+                ast::IntTy::Is => int_ty_bits(isize_ty, isize_ty),\n                 ast::IntTy::I8 => 8,\n                 ast::IntTy::I16 => 16 as u64,\n                 ast::IntTy::I32 => 32,\n@@ -261,9 +261,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n             }\n         }\n \n-        fn uint_ty_bits(uint_ty: ast::UintTy, target_uint_ty: ast::UintTy) -> u64 {\n+        fn uint_ty_bits(uint_ty: ast::UintTy, usize_ty: ast::UintTy) -> u64 {\n             match uint_ty {\n-                ast::UintTy::Us => uint_ty_bits(target_uint_ty, target_uint_ty),\n+                ast::UintTy::Us => uint_ty_bits(usize_ty, usize_ty),\n                 ast::UintTy::U8 => 8,\n                 ast::UintTy::U16 => 16,\n                 ast::UintTy::U32 => 32,"}, {"sha": "91646ce9f8b963ed58d4698d6ed319c5426f16f5", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 3, "deletions": 35, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -22,6 +22,7 @@ use syntax::attr;\n use syntax::feature_gate::{BUILTIN_ATTRIBUTES, AttributeType};\n use syntax::symbol::keywords;\n use syntax::ptr::P;\n+use syntax::util::parser;\n use syntax_pos::Span;\n \n use rustc_back::slice;\n@@ -313,47 +314,14 @@ impl UnusedParens {\n                                 msg: &str,\n                                 struct_lit_needs_parens: bool) {\n         if let ast::ExprKind::Paren(ref inner) = value.node {\n-            let necessary = struct_lit_needs_parens && contains_exterior_struct_lit(&inner);\n+            let necessary = struct_lit_needs_parens &&\n+                            parser::contains_exterior_struct_lit(&inner);\n             if !necessary {\n                 cx.span_lint(UNUSED_PARENS,\n                              value.span,\n                              &format!(\"unnecessary parentheses around {}\", msg))\n             }\n         }\n-\n-        /// Expressions that syntactically contain an \"exterior\" struct\n-        /// literal i.e. not surrounded by any parens or other\n-        /// delimiters, e.g. `X { y: 1 }`, `X { y: 1 }.method()`, `foo\n-        /// == X { y: 1 }` and `X { y: 1 } == foo` all do, but `(X {\n-        /// y: 1 }) == foo` does not.\n-        fn contains_exterior_struct_lit(value: &ast::Expr) -> bool {\n-            match value.node {\n-                ast::ExprKind::Struct(..) => true,\n-\n-                ast::ExprKind::Assign(ref lhs, ref rhs) |\n-                ast::ExprKind::AssignOp(_, ref lhs, ref rhs) |\n-                ast::ExprKind::Binary(_, ref lhs, ref rhs) => {\n-                    // X { y: 1 } + X { y: 2 }\n-                    contains_exterior_struct_lit(&lhs) || contains_exterior_struct_lit(&rhs)\n-                }\n-                ast::ExprKind::Unary(_, ref x) |\n-                ast::ExprKind::Cast(ref x, _) |\n-                ast::ExprKind::Type(ref x, _) |\n-                ast::ExprKind::Field(ref x, _) |\n-                ast::ExprKind::TupField(ref x, _) |\n-                ast::ExprKind::Index(ref x, _) => {\n-                    // &X { y: 1 }, X { y: 1 }.y\n-                    contains_exterior_struct_lit(&x)\n-                }\n-\n-                ast::ExprKind::MethodCall(.., ref exprs) => {\n-                    // X { y: 1 }.bar(...)\n-                    contains_exterior_struct_lit(&exprs[0])\n-                }\n-\n-                _ => false,\n-            }\n-        }\n     }\n }\n "}, {"sha": "393aa7fa43bab8c22504dec5f32a0385d6a0f709", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -136,7 +136,8 @@ fn main() {\n     let mut cmd = Command::new(&llvm_config);\n     cmd.arg(\"--cxxflags\");\n     let cxxflags = output(&mut cmd);\n-    let mut cfg = gcc::Config::new();\n+    let mut cfg = gcc::Build::new();\n+    cfg.warnings(false);\n     for flag in cxxflags.split_whitespace() {\n         // Ignore flags like `-m64` when we're doing a cross build\n         if is_crossed && flag.starts_with(\"-m\") {"}, {"sha": "dc6c260ec7174abdeab0d398c3f9586794609d19", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 88, "deletions": 300, "changes": 388, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -12,9 +12,10 @@\n \n use cstore::{self, CStore, CrateSource, MetadataBlob};\n use locator::{self, CratePaths};\n-use schema::{CrateRoot, Tracked};\n+use native_libs::relevant_lib;\n+use schema::CrateRoot;\n \n-use rustc::hir::def_id::{CrateNum, DefIndex};\n+use rustc::hir::def_id::{CrateNum, DefIndex, CRATE_DEF_INDEX};\n use rustc::hir::svh::Svh;\n use rustc::middle::allocator::AllocatorKind;\n use rustc::middle::cstore::DepKind;\n@@ -23,10 +24,9 @@ use rustc::session::config::{Sanitizer, self};\n use rustc_back::PanicStrategy;\n use rustc::session::search_paths::PathKind;\n use rustc::middle;\n-use rustc::middle::cstore::{CrateStore, validate_crate_name, ExternCrate};\n+use rustc::middle::cstore::{validate_crate_name, ExternCrate};\n use rustc::util::common::record_time;\n use rustc::util::nodemap::FxHashSet;\n-use rustc::middle::cstore::NativeLibrary;\n use rustc::hir::map::Definitions;\n \n use std::cell::{RefCell, Cell};\n@@ -36,10 +36,8 @@ use std::rc::Rc;\n use std::{cmp, fs};\n \n use syntax::ast;\n-use syntax::abi::Abi;\n use syntax::attr;\n use syntax::ext::base::SyntaxExtension;\n-use syntax::feature_gate::{self, GateIssue};\n use syntax::symbol::Symbol;\n use syntax::visit;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -81,56 +79,6 @@ struct ExternCrateInfo {\n     dep_kind: DepKind,\n }\n \n-fn register_native_lib(sess: &Session,\n-                       cstore: &CStore,\n-                       span: Option<Span>,\n-                       lib: NativeLibrary) {\n-    if lib.name.as_str().is_empty() {\n-        match span {\n-            Some(span) => {\n-                struct_span_err!(sess, span, E0454,\n-                                 \"#[link(name = \\\"\\\")] given with empty name\")\n-                    .span_label(span, \"empty name given\")\n-                    .emit();\n-            }\n-            None => {\n-                sess.err(\"empty library name given via `-l`\");\n-            }\n-        }\n-        return\n-    }\n-    let is_osx = sess.target.target.options.is_like_osx;\n-    if lib.kind == cstore::NativeFramework && !is_osx {\n-        let msg = \"native frameworks are only available on macOS targets\";\n-        match span {\n-            Some(span) => span_err!(sess, span, E0455, \"{}\", msg),\n-            None => sess.err(msg),\n-        }\n-    }\n-    if lib.cfg.is_some() && !sess.features.borrow().link_cfg {\n-        feature_gate::emit_feature_err(&sess.parse_sess,\n-                                       \"link_cfg\",\n-                                       span.unwrap(),\n-                                       GateIssue::Language,\n-                                       \"is feature gated\");\n-    }\n-    if lib.kind == cstore::NativeStaticNobundle && !sess.features.borrow().static_nobundle {\n-        feature_gate::emit_feature_err(&sess.parse_sess,\n-                                       \"static_nobundle\",\n-                                       span.unwrap(),\n-                                       GateIssue::Language,\n-                                       \"kind=\\\"static-nobundle\\\" is feature gated\");\n-    }\n-    cstore.add_used_library(lib);\n-}\n-\n-fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n-    match lib.cfg {\n-        Some(ref cfg) => attr::cfg_matches(cfg, &sess.parse_sess, None),\n-        None => true,\n-    }\n-}\n-\n // Extra info about a crate loaded for plugins or exported macros.\n struct ExtensionCrate {\n     metadata: PMDSource,\n@@ -218,7 +166,7 @@ impl<'a> CrateLoader<'a> {\n             // We're also sure to compare *paths*, not actual byte slices. The\n             // `source` stores paths which are normalized which may be different\n             // from the strings on the command line.\n-            let source = self.cstore.used_crate_source(cnum);\n+            let source = &self.cstore.get_crate_data(cnum).source;\n             if let Some(locs) = self.sess.opts.externs.get(&*name.as_str()) {\n                 let found = locs.iter().any(|l| {\n                     let l = fs::canonicalize(l).ok();\n@@ -313,16 +261,13 @@ impl<'a> CrateLoader<'a> {\n             crate_root.def_path_table.decode(&metadata)\n         });\n \n-        let exported_symbols = crate_root.exported_symbols\n-                                         .map(|x| x.decode(&metadata).collect());\n+        let exported_symbols = crate_root.exported_symbols.decode(&metadata).collect();\n \n         let trait_impls = crate_root\n             .impls\n-            .map(|impls| {\n-                impls.decode(&metadata)\n-                     .map(|trait_impls| (trait_impls.trait_id, trait_impls.impls))\n-                     .collect()\n-            });\n+            .decode(&metadata)\n+            .map(|trait_impls| (trait_impls.trait_id, trait_impls.impls))\n+            .collect();\n \n         let mut cmeta = cstore::CrateMetadata {\n             name,\n@@ -347,23 +292,17 @@ impl<'a> CrateLoader<'a> {\n             },\n             // Initialize this with an empty set. The field is populated below\n             // after we were able to deserialize its contents.\n-            dllimport_foreign_items: Tracked::new(FxHashSet()),\n+            dllimport_foreign_items: FxHashSet(),\n         };\n \n-        let dllimports: Tracked<FxHashSet<_>> = cmeta\n+        let dllimports: FxHashSet<_> = cmeta\n             .root\n             .native_libraries\n-            .map(|native_libraries| {\n-                let native_libraries: Vec<_> = native_libraries.decode(&cmeta)\n-                                                               .collect();\n-                native_libraries\n-                    .iter()\n-                    .filter(|lib| relevant_lib(self.sess, lib) &&\n-                                  lib.kind == cstore::NativeLibraryKind::NativeUnknown)\n-                    .flat_map(|lib| lib.foreign_items.iter())\n-                    .map(|id| *id)\n-                    .collect()\n-            });\n+            .decode(&cmeta)\n+            .filter(|lib| relevant_lib(self.sess, lib) &&\n+                          lib.kind == cstore::NativeLibraryKind::NativeUnknown)\n+            .flat_map(|lib| lib.foreign_items.into_iter())\n+            .collect();\n \n         cmeta.dllimport_foreign_items = dllimports;\n \n@@ -521,7 +460,6 @@ impl<'a> CrateLoader<'a> {\n         // We map 0 and all other holes in the map to our parent crate. The \"additional\"\n         // self-dependencies should be harmless.\n         ::std::iter::once(krate).chain(crate_root.crate_deps\n-                                                 .get_untracked()\n                                                  .decode(metadata)\n                                                  .map(|dep| {\n             debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n@@ -721,33 +659,6 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    fn get_foreign_items_of_kind(&self, kind: cstore::NativeLibraryKind) -> Vec<DefIndex> {\n-        let mut items = vec![];\n-        let libs = self.cstore.get_used_libraries();\n-        for lib in libs.borrow().iter() {\n-            if relevant_lib(self.sess, lib) && lib.kind == kind {\n-                items.extend(&lib.foreign_items);\n-            }\n-        }\n-        items\n-    }\n-\n-    fn register_statically_included_foreign_items(&mut self) {\n-        for id in self.get_foreign_items_of_kind(cstore::NativeStatic) {\n-            self.cstore.add_statically_included_foreign_item(id);\n-        }\n-        for id in self.get_foreign_items_of_kind(cstore::NativeStaticNobundle) {\n-            self.cstore.add_statically_included_foreign_item(id);\n-        }\n-    }\n-\n-    fn register_dllimport_foreign_items(&mut self) {\n-        let mut dllimports = self.cstore.dllimport_foreign_items.borrow_mut();\n-        for id in self.get_foreign_items_of_kind(cstore::NativeUnknown) {\n-            dllimports.insert(id);\n-        }\n-    }\n-\n     fn inject_panic_runtime(&mut self, krate: &ast::Crate) {\n         // If we're only compiling an rlib, then there's no need to select a\n         // panic runtime, so we just skip this section entirely.\n@@ -771,16 +682,14 @@ impl<'a> CrateLoader<'a> {\n         let mut needs_panic_runtime = attr::contains_name(&krate.attrs,\n                                                           \"needs_panic_runtime\");\n \n-        let dep_graph = &self.sess.dep_graph;\n-\n         self.cstore.iter_crate_data(|cnum, data| {\n             needs_panic_runtime = needs_panic_runtime ||\n-                                  data.needs_panic_runtime(dep_graph);\n-            if data.is_panic_runtime(dep_graph) {\n+                                  data.needs_panic_runtime();\n+            if data.is_panic_runtime() {\n                 // Inject a dependency from all #![needs_panic_runtime] to this\n                 // #![panic_runtime] crate.\n                 self.inject_dependency_if(cnum, \"a panic runtime\",\n-                                          &|data| data.needs_panic_runtime(dep_graph));\n+                                          &|data| data.needs_panic_runtime());\n                 runtime_found = runtime_found || data.dep_kind.get() == DepKind::Explicit;\n             }\n         });\n@@ -816,19 +725,19 @@ impl<'a> CrateLoader<'a> {\n \n         // Sanity check the loaded crate to ensure it is indeed a panic runtime\n         // and the panic strategy is indeed what we thought it was.\n-        if !data.is_panic_runtime(dep_graph) {\n+        if !data.is_panic_runtime() {\n             self.sess.err(&format!(\"the crate `{}` is not a panic runtime\",\n                                    name));\n         }\n-        if data.panic_strategy(dep_graph) != desired_strategy {\n+        if data.panic_strategy() != desired_strategy {\n             self.sess.err(&format!(\"the crate `{}` does not have the panic \\\n                                     strategy `{}`\",\n                                    name, desired_strategy.desc()));\n         }\n \n         self.sess.injected_panic_runtime.set(Some(cnum));\n         self.inject_dependency_if(cnum, \"a panic runtime\",\n-                                  &|data| data.needs_panic_runtime(dep_graph));\n+                                  &|data| data.needs_panic_runtime());\n     }\n \n     fn inject_sanitizer_runtime(&mut self) {\n@@ -923,7 +832,7 @@ impl<'a> CrateLoader<'a> {\n                                        PathKind::Crate, dep_kind);\n \n                 // Sanity check the loaded crate to ensure it is indeed a sanitizer runtime\n-                if !data.is_sanitizer_runtime(&self.sess.dep_graph) {\n+                if !data.is_sanitizer_runtime() {\n                     self.sess.err(&format!(\"the crate `{}` is not a sanitizer runtime\",\n                                            name));\n                 }\n@@ -944,7 +853,7 @@ impl<'a> CrateLoader<'a> {\n                                    PathKind::Crate, dep_kind);\n \n             // Sanity check the loaded crate to ensure it is indeed a profiler runtime\n-            if !data.is_profiler_runtime(&self.sess.dep_graph) {\n+            if !data.is_profiler_runtime() {\n                 self.sess.err(&format!(\"the crate `profiler_builtins` is not \\\n                                         a profiler runtime\"));\n             }\n@@ -962,9 +871,8 @@ impl<'a> CrateLoader<'a> {\n         // written down in liballoc.\n         let mut needs_allocator = attr::contains_name(&krate.attrs,\n                                                       \"needs_allocator\");\n-        let dep_graph = &self.sess.dep_graph;\n         self.cstore.iter_crate_data(|_, data| {\n-            needs_allocator = needs_allocator || data.needs_allocator(dep_graph);\n+            needs_allocator = needs_allocator || data.needs_allocator();\n         });\n         if !needs_allocator {\n             return\n@@ -996,14 +904,13 @@ impl<'a> CrateLoader<'a> {\n         // First up we check for global allocators. Look at the crate graph here\n         // and see what's a global allocator, including if we ourselves are a\n         // global allocator.\n-        let dep_graph = &self.sess.dep_graph;\n         let mut global_allocator = if has_global_allocator {\n             Some(None)\n         } else {\n             None\n         };\n         self.cstore.iter_crate_data(|_, data| {\n-            if !data.has_global_allocator(dep_graph) {\n+            if !data.has_global_allocator() {\n                 return\n             }\n             match global_allocator {\n@@ -1037,59 +944,80 @@ impl<'a> CrateLoader<'a> {\n         // (need_lib_alloc and prefer_dynamic) then we select `None`, and if the\n         // exe allocation crate doesn't exist for this target then we also\n         // select `None`.\n-        let exe_allocation_crate =\n+        let exe_allocation_crate_data =\n             if need_lib_alloc && !self.sess.opts.cg.prefer_dynamic {\n                 None\n             } else {\n-                self.sess.target.target.options.exe_allocation_crate.as_ref()\n+                self.sess\n+                    .target\n+                    .target\n+                    .options\n+                    .exe_allocation_crate\n+                    .as_ref()\n+                    .map(|name| {\n+                        // We've determined that we're injecting an \"exe allocator\" which means\n+                        // that we're going to load up a whole new crate. An example of this is\n+                        // that we're producing a normal binary on Linux which means we need to\n+                        // load the `alloc_jemalloc` crate to link as an allocator.\n+                        let name = Symbol::intern(name);\n+                        let (cnum, data) = self.resolve_crate(&None,\n+                                                              name,\n+                                                              name,\n+                                                              None,\n+                                                              DUMMY_SP,\n+                                                              PathKind::Crate,\n+                                                              DepKind::Implicit);\n+                        self.sess.injected_allocator.set(Some(cnum));\n+                        data\n+                    })\n             };\n \n-        match exe_allocation_crate {\n-            // We've determined that we're injecting an \"exe allocator\" which\n-            // means that we're going to load up a whole new crate. An example\n-            // of this is that we're producing a normal binary on Linux which\n-            // means we need to load the `alloc_jemalloc` crate to link as an\n-            // allocator.\n-            Some(krate) => {\n-                self.sess.allocator_kind.set(Some(AllocatorKind::DefaultExe));\n-                let name = Symbol::intern(krate);\n-                let dep_kind = DepKind::Implicit;\n-                let (cnum, _data) =\n-                    self.resolve_crate(&None,\n-                                       name,\n-                                       name,\n-                                       None,\n-                                       DUMMY_SP,\n-                                       PathKind::Crate, dep_kind);\n-                self.sess.injected_allocator.set(Some(cnum));\n-            //     self.cstore.iter_crate_data(|_, data| {\n-            //         if !data.needs_allocator(dep_graph) {\n-            //             return\n-            //         }\n-            //         data.cnum_map.borrow_mut().push(cnum);\n-            //     });\n+        let allocation_crate_data = exe_allocation_crate_data.or_else(|| {\n+            if attr::contains_name(&krate.attrs, \"default_lib_allocator\") {\n+                // Prefer self as the allocator if there's a collision\n+                return None;\n             }\n-\n             // We're not actually going to inject an allocator, we're going to\n             // require that something in our crate graph is the default lib\n             // allocator. This is typically libstd, so this'll rarely be an\n             // error.\n-            None => {\n-                self.sess.allocator_kind.set(Some(AllocatorKind::DefaultLib));\n-                let mut found_lib_allocator =\n-                    attr::contains_name(&krate.attrs, \"default_lib_allocator\");\n-                self.cstore.iter_crate_data(|_, data| {\n-                    if !found_lib_allocator {\n-                        if data.has_default_lib_allocator(dep_graph) {\n-                            found_lib_allocator = true;\n-                        }\n+            let mut allocator = None;\n+            self.cstore.iter_crate_data(|_, data| {\n+                if allocator.is_none() && data.has_default_lib_allocator() {\n+                    allocator = Some(data.clone());\n+                }\n+            });\n+            allocator\n+        });\n+\n+        match allocation_crate_data {\n+            Some(data) => {\n+                // We have an allocator. We detect separately what kind it is, to allow for some\n+                // flexibility in misconfiguration.\n+                let attrs = data.get_item_attrs(CRATE_DEF_INDEX);\n+                let kind_interned = attr::first_attr_value_str_by_name(&attrs, \"rustc_alloc_kind\")\n+                    .map(Symbol::as_str);\n+                let kind_str = kind_interned\n+                    .as_ref()\n+                    .map(|s| s as &str);\n+                let alloc_kind = match kind_str {\n+                    None |\n+                    Some(\"lib\") => AllocatorKind::DefaultLib,\n+                    Some(\"exe\") => AllocatorKind::DefaultExe,\n+                    Some(other) => {\n+                        self.sess.err(&format!(\"Allocator kind {} not known\", other));\n+                        return;\n                     }\n-                });\n-                if found_lib_allocator {\n-                    return\n+                };\n+                self.sess.allocator_kind.set(Some(alloc_kind));\n+            },\n+            None => {\n+                if !attr::contains_name(&krate.attrs, \"default_lib_allocator\") {\n+                    self.sess.err(\"no #[default_lib_allocator] found but one is \\\n+                                   required; is libstd not linked?\");\n+                    return;\n                 }\n-                self.sess.err(\"no #[default_lib_allocator] found but one is \\\n-                               required; is libstd not linked?\");\n+                self.sess.allocator_kind.set(Some(AllocatorKind::DefaultLib));\n             }\n         }\n \n@@ -1152,84 +1080,6 @@ impl<'a> CrateLoader<'a> {\n     }\n }\n \n-impl<'a> CrateLoader<'a> {\n-    pub fn preprocess(&mut self, krate: &ast::Crate) {\n-        for attr in &krate.attrs {\n-            if attr.path == \"link_args\" {\n-                if let Some(linkarg) = attr.value_str() {\n-                    self.cstore.add_used_link_args(&linkarg.as_str());\n-                }\n-            }\n-        }\n-    }\n-\n-    fn process_foreign_mod(&mut self, i: &ast::Item, fm: &ast::ForeignMod,\n-                           definitions: &Definitions) {\n-        if fm.abi == Abi::Rust || fm.abi == Abi::RustIntrinsic || fm.abi == Abi::PlatformIntrinsic {\n-            return;\n-        }\n-\n-        // First, add all of the custom #[link_args] attributes\n-        for m in i.attrs.iter().filter(|a| a.check_name(\"link_args\")) {\n-            if let Some(linkarg) = m.value_str() {\n-                self.cstore.add_used_link_args(&linkarg.as_str());\n-            }\n-        }\n-\n-        // Next, process all of the #[link(..)]-style arguments\n-        for m in i.attrs.iter().filter(|a| a.check_name(\"link\")) {\n-            let items = match m.meta_item_list() {\n-                Some(item) => item,\n-                None => continue,\n-            };\n-            let kind = items.iter().find(|k| {\n-                k.check_name(\"kind\")\n-            }).and_then(|a| a.value_str()).map(Symbol::as_str);\n-            let kind = match kind.as_ref().map(|s| &s[..]) {\n-                Some(\"static\") => cstore::NativeStatic,\n-                Some(\"static-nobundle\") => cstore::NativeStaticNobundle,\n-                Some(\"dylib\") => cstore::NativeUnknown,\n-                Some(\"framework\") => cstore::NativeFramework,\n-                Some(k) => {\n-                    struct_span_err!(self.sess, m.span, E0458,\n-                              \"unknown kind: `{}`\", k)\n-                        .span_label(m.span, \"unknown kind\").emit();\n-                    cstore::NativeUnknown\n-                }\n-                None => cstore::NativeUnknown\n-            };\n-            let n = items.iter().find(|n| {\n-                n.check_name(\"name\")\n-            }).and_then(|a| a.value_str());\n-            let n = match n {\n-                Some(n) => n,\n-                None => {\n-                    struct_span_err!(self.sess, m.span, E0459,\n-                                     \"#[link(...)] specified without `name = \\\"foo\\\"`\")\n-                        .span_label(m.span, \"missing `name` argument\").emit();\n-                    Symbol::intern(\"foo\")\n-                }\n-            };\n-            let cfg = items.iter().find(|k| {\n-                k.check_name(\"cfg\")\n-            }).and_then(|a| a.meta_item_list());\n-            let cfg = cfg.map(|list| {\n-                list[0].meta_item().unwrap().clone()\n-            });\n-            let foreign_items = fm.items.iter()\n-                .map(|it| definitions.opt_def_index(it.id).unwrap())\n-                .collect();\n-            let lib = NativeLibrary {\n-                name: n,\n-                kind,\n-                cfg,\n-                foreign_items,\n-            };\n-            register_native_lib(self.sess, self.cstore, Some(m.span), lib);\n-        }\n-    }\n-}\n-\n impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n     fn postprocess(&mut self, krate: &ast::Crate) {\n         // inject the sanitizer runtime before the allocator runtime because all\n@@ -1242,72 +1092,10 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n         if log_enabled!(log::LogLevel::Info) {\n             dump_crates(&self.cstore);\n         }\n-\n-        // Process libs passed on the command line\n-        // First, check for errors\n-        let mut renames = FxHashSet();\n-        for &(ref name, ref new_name, _) in &self.sess.opts.libs {\n-            if let &Some(ref new_name) = new_name {\n-                if new_name.is_empty() {\n-                    self.sess.err(\n-                        &format!(\"an empty renaming target was specified for library `{}`\",name));\n-                } else if !self.cstore.get_used_libraries().borrow().iter()\n-                                                           .any(|lib| lib.name == name as &str) {\n-                    self.sess.err(&format!(\"renaming of the library `{}` was specified, \\\n-                                            however this crate contains no #[link(...)] \\\n-                                            attributes referencing this library.\", name));\n-                } else if renames.contains(name) {\n-                    self.sess.err(&format!(\"multiple renamings were specified for library `{}` .\",\n-                                            name));\n-                } else {\n-                    renames.insert(name);\n-                }\n-            }\n-        }\n-        // Update kind and, optionally, the name of all native libaries\n-        // (there may be more than one) with the specified name.\n-        for &(ref name, ref new_name, kind) in &self.sess.opts.libs {\n-            let mut found = false;\n-            for lib in self.cstore.get_used_libraries().borrow_mut().iter_mut() {\n-                if lib.name == name as &str {\n-                    let mut changed = false;\n-                    if let Some(k) = kind {\n-                        lib.kind = k;\n-                        changed = true;\n-                    }\n-                    if let &Some(ref new_name) = new_name {\n-                        lib.name = Symbol::intern(new_name);\n-                        changed = true;\n-                    }\n-                    if !changed {\n-                        self.sess.warn(&format!(\"redundant linker flag specified for library `{}`\",\n-                                                name));\n-                    }\n-\n-                    found = true;\n-                }\n-            }\n-            if !found {\n-                // Add if not found\n-                let new_name = new_name.as_ref().map(|s| &**s); // &Option<String> -> Option<&str>\n-                let lib = NativeLibrary {\n-                    name: Symbol::intern(new_name.unwrap_or(name)),\n-                    kind: if let Some(k) = kind { k } else { cstore::NativeUnknown },\n-                    cfg: None,\n-                    foreign_items: Vec::new(),\n-                };\n-                register_native_lib(self.sess, self.cstore, None, lib);\n-            }\n-        }\n-        self.register_statically_included_foreign_items();\n-        self.register_dllimport_foreign_items();\n     }\n \n     fn process_item(&mut self, item: &ast::Item, definitions: &Definitions) {\n         match item.node {\n-            ast::ItemKind::ForeignMod(ref fm) => {\n-                self.process_foreign_mod(item, fm, definitions)\n-            },\n             ast::ItemKind::ExternCrate(_) => {\n                 let info = self.extract_crate_info(item).unwrap();\n                 let (cnum, ..) = self.resolve_crate("}, {"sha": "83a468171ccfef82b571d701757744e79787affd", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 30, "deletions": 134, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -11,16 +11,15 @@\n // The crate store - a central repo for information collected about external\n // crates and libraries\n \n-use schema::{self, Tracked};\n+use schema;\n \n-use rustc::dep_graph::DepGraph;\n-use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, CrateNum, DefIndex, DefId};\n-use rustc::hir::map::definitions::{DefPathTable, GlobalMetaDataKind};\n+use rustc::hir::def_id::{CRATE_DEF_INDEX, CrateNum, DefIndex};\n+use rustc::hir::map::definitions::DefPathTable;\n use rustc::hir::svh::Svh;\n use rustc::middle::cstore::{DepKind, ExternCrate, MetadataLoader};\n use rustc_back::PanicStrategy;\n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc::util::nodemap::{FxHashMap, FxHashSet, NodeMap, DefIdMap};\n+use rustc::util::nodemap::{FxHashMap, FxHashSet, NodeMap};\n \n use std::cell::{RefCell, Cell};\n use std::rc::Rc;\n@@ -78,42 +77,30 @@ pub struct CrateMetadata {\n     /// compilation support.\n     pub def_path_table: Rc<DefPathTable>,\n \n-    pub exported_symbols: Tracked<FxHashSet<DefIndex>>,\n+    pub exported_symbols: FxHashSet<DefIndex>,\n \n-    pub trait_impls: Tracked<FxHashMap<(u32, DefIndex), schema::LazySeq<DefIndex>>>,\n+    pub trait_impls: FxHashMap<(u32, DefIndex), schema::LazySeq<DefIndex>>,\n \n     pub dep_kind: Cell<DepKind>,\n     pub source: CrateSource,\n \n     pub proc_macros: Option<Vec<(ast::Name, Rc<SyntaxExtension>)>>,\n     // Foreign items imported from a dylib (Windows only)\n-    pub dllimport_foreign_items: Tracked<FxHashSet<DefIndex>>,\n+    pub dllimport_foreign_items: FxHashSet<DefIndex>,\n }\n \n pub struct CStore {\n-    pub dep_graph: DepGraph,\n     metas: RefCell<FxHashMap<CrateNum, Rc<CrateMetadata>>>,\n     /// Map from NodeId's of local extern crate statements to crate numbers\n     extern_mod_crate_map: RefCell<NodeMap<CrateNum>>,\n-    used_libraries: RefCell<Vec<NativeLibrary>>,\n-    used_link_args: RefCell<Vec<String>>,\n-    statically_included_foreign_items: RefCell<FxHashSet<DefIndex>>,\n-    pub dllimport_foreign_items: RefCell<FxHashSet<DefIndex>>,\n-    pub visible_parent_map: RefCell<DefIdMap<DefId>>,\n     pub metadata_loader: Box<MetadataLoader>,\n }\n \n impl CStore {\n-    pub fn new(dep_graph: &DepGraph, metadata_loader: Box<MetadataLoader>) -> CStore {\n+    pub fn new(metadata_loader: Box<MetadataLoader>) -> CStore {\n         CStore {\n-            dep_graph: dep_graph.clone(),\n             metas: RefCell::new(FxHashMap()),\n             extern_mod_crate_map: RefCell::new(FxHashMap()),\n-            used_libraries: RefCell::new(Vec::new()),\n-            used_link_args: RefCell::new(Vec::new()),\n-            statically_included_foreign_items: RefCell::new(FxHashSet()),\n-            dllimport_foreign_items: RefCell::new(FxHashSet()),\n-            visible_parent_map: RefCell::new(FxHashMap()),\n             metadata_loader,\n         }\n     }\n@@ -126,10 +113,6 @@ impl CStore {\n         self.metas.borrow().get(&cnum).unwrap().clone()\n     }\n \n-    pub fn get_crate_hash(&self, cnum: CrateNum) -> Svh {\n-        self.get_crate_data(cnum).hash()\n-    }\n-\n     pub fn set_crate_data(&self, cnum: CrateNum, data: Rc<CrateMetadata>) {\n         self.metas.borrow_mut().insert(cnum, data);\n     }\n@@ -164,96 +147,21 @@ impl CStore {\n         ordering.push(krate);\n     }\n \n-    // This method is used when generating the command line to pass through to\n-    // system linker. The linker expects undefined symbols on the left of the\n-    // command line to be defined in libraries on the right, not the other way\n-    // around. For more info, see some comments in the add_used_library function\n-    // below.\n-    //\n-    // In order to get this left-to-right dependency ordering, we perform a\n-    // topological sort of all crates putting the leaves at the right-most\n-    // positions.\n-    pub fn do_get_used_crates(&self,\n-                              prefer: LinkagePreference)\n-                              -> Vec<(CrateNum, LibSource)> {\n+    pub fn do_postorder_cnums_untracked(&self) -> Vec<CrateNum> {\n         let mut ordering = Vec::new();\n         for (&num, _) in self.metas.borrow().iter() {\n             self.push_dependencies_in_postorder(&mut ordering, num);\n         }\n-        info!(\"topological ordering: {:?}\", ordering);\n-        ordering.reverse();\n-        let mut libs = self.metas\n-            .borrow()\n-            .iter()\n-            .filter_map(|(&cnum, data)| {\n-                if data.dep_kind.get().macros_only() { return None; }\n-                let path = match prefer {\n-                    LinkagePreference::RequireDynamic => data.source.dylib.clone().map(|p| p.0),\n-                    LinkagePreference::RequireStatic => data.source.rlib.clone().map(|p| p.0),\n-                };\n-                let path = match path {\n-                    Some(p) => LibSource::Some(p),\n-                    None => {\n-                        if data.source.rmeta.is_some() {\n-                            LibSource::MetadataOnly\n-                        } else {\n-                            LibSource::None\n-                        }\n-                    }\n-                };\n-                Some((cnum, path))\n-            })\n-            .collect::<Vec<_>>();\n-        libs.sort_by(|&(a, _), &(b, _)| {\n-            let a = ordering.iter().position(|x| *x == a);\n-            let b = ordering.iter().position(|x| *x == b);\n-            a.cmp(&b)\n-        });\n-        libs\n-    }\n-\n-    pub fn add_used_library(&self, lib: NativeLibrary) {\n-        assert!(!lib.name.as_str().is_empty());\n-        self.used_libraries.borrow_mut().push(lib);\n-    }\n-\n-    pub fn get_used_libraries(&self) -> &RefCell<Vec<NativeLibrary>> {\n-        &self.used_libraries\n-    }\n-\n-    pub fn add_used_link_args(&self, args: &str) {\n-        for s in args.split(' ').filter(|s| !s.is_empty()) {\n-            self.used_link_args.borrow_mut().push(s.to_string());\n-        }\n-    }\n-\n-    pub fn get_used_link_args<'a>(&'a self) -> &'a RefCell<Vec<String>> {\n-        &self.used_link_args\n+        return ordering\n     }\n \n     pub fn add_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId, cnum: CrateNum) {\n         self.extern_mod_crate_map.borrow_mut().insert(emod_id, cnum);\n     }\n \n-    pub fn add_statically_included_foreign_item(&self, id: DefIndex) {\n-        self.statically_included_foreign_items.borrow_mut().insert(id);\n-    }\n-\n-    pub fn do_is_statically_included_foreign_item(&self, def_id: DefId) -> bool {\n-        assert!(def_id.krate == LOCAL_CRATE);\n-        self.statically_included_foreign_items.borrow().contains(&def_id.index)\n-    }\n-\n     pub fn do_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum> {\n         self.extern_mod_crate_map.borrow().get(&emod_id).cloned()\n     }\n-\n-    pub fn read_dep_node(&self, def_id: DefId) {\n-        use rustc::middle::cstore::CrateStore;\n-        let def_path_hash = self.def_path_hash(def_id);\n-        let dep_node = def_path_hash.to_dep_node(::rustc::dep_graph::DepKind::MetaData);\n-        self.dep_graph.read(dep_node);\n-    }\n }\n \n impl CrateMetadata {\n@@ -267,62 +175,50 @@ impl CrateMetadata {\n         self.root.disambiguator\n     }\n \n-    pub fn needs_allocator(&self, dep_graph: &DepGraph) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, dep_graph);\n+    pub fn needs_allocator(&self) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n         attr::contains_name(&attrs, \"needs_allocator\")\n     }\n \n-    pub fn has_global_allocator(&self, dep_graph: &DepGraph) -> bool {\n-        let dep_node = self.metadata_dep_node(GlobalMetaDataKind::Krate);\n-        self.root\n-            .has_global_allocator\n-            .get(dep_graph, dep_node)\n-            .clone()\n+    pub fn has_global_allocator(&self) -> bool {\n+        self.root.has_global_allocator.clone()\n     }\n \n-    pub fn has_default_lib_allocator(&self, dep_graph: &DepGraph) -> bool {\n-        let dep_node = self.metadata_dep_node(GlobalMetaDataKind::Krate);\n-        self.root\n-            .has_default_lib_allocator\n-            .get(dep_graph, dep_node)\n-            .clone()\n+    pub fn has_default_lib_allocator(&self) -> bool {\n+        self.root.has_default_lib_allocator.clone()\n     }\n \n-    pub fn is_panic_runtime(&self, dep_graph: &DepGraph) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, dep_graph);\n+    pub fn is_panic_runtime(&self) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n         attr::contains_name(&attrs, \"panic_runtime\")\n     }\n \n-    pub fn needs_panic_runtime(&self, dep_graph: &DepGraph) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, dep_graph);\n+    pub fn needs_panic_runtime(&self) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n         attr::contains_name(&attrs, \"needs_panic_runtime\")\n     }\n \n-    pub fn is_compiler_builtins(&self, dep_graph: &DepGraph) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, dep_graph);\n+    pub fn is_compiler_builtins(&self) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n         attr::contains_name(&attrs, \"compiler_builtins\")\n     }\n \n-    pub fn is_sanitizer_runtime(&self, dep_graph: &DepGraph) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, dep_graph);\n+    pub fn is_sanitizer_runtime(&self) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n         attr::contains_name(&attrs, \"sanitizer_runtime\")\n     }\n \n-    pub fn is_profiler_runtime(&self, dep_graph: &DepGraph) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, dep_graph);\n+    pub fn is_profiler_runtime(&self) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n         attr::contains_name(&attrs, \"profiler_runtime\")\n     }\n \n-    pub fn is_no_builtins(&self, dep_graph: &DepGraph) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, dep_graph);\n+    pub fn is_no_builtins(&self) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n         attr::contains_name(&attrs, \"no_builtins\")\n     }\n \n-    pub fn panic_strategy(&self, dep_graph: &DepGraph) -> PanicStrategy {\n-        let dep_node = self.metadata_dep_node(GlobalMetaDataKind::Krate);\n-        self.root\n-            .panic_strategy\n-            .get(dep_graph, dep_node)\n-            .clone()\n+    pub fn panic_strategy(&self) -> PanicStrategy {\n+        self.root.panic_strategy.clone()\n     }\n }"}, {"sha": "74e4ffcdfffdc2a1adf023b014e7b9b1adc84edc", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 213, "deletions": 246, "changes": 459, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -10,24 +10,25 @@\n \n use cstore;\n use encoder;\n+use link_args;\n+use native_libs;\n use schema;\n \n use rustc::ty::maps::QueryConfig;\n-use rustc::middle::cstore::{CrateStore, CrateSource, LibSource, DepKind,\n-                            NativeLibrary, MetadataLoader, LinkMeta,\n-                            LinkagePreference, LoadedMacro, EncodedMetadata,\n-                            EncodedMetadataHashes};\n+use rustc::middle::cstore::{CrateStore, DepKind,\n+                            MetadataLoader, LinkMeta,\n+                            LoadedMacro, EncodedMetadata,\n+                            EncodedMetadataHashes, NativeLibraryKind};\n+use rustc::middle::stability::DeprecationEntry;\n use rustc::hir::def;\n-use rustc::middle::lang_items;\n use rustc::session::Session;\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::maps::Providers;\n-use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE, CRATE_DEF_INDEX};\n use rustc::hir::map::{DefKey, DefPath, DefPathHash};\n use rustc::hir::map::blocks::FnLikeNode;\n-use rustc::hir::map::definitions::{DefPathTable, GlobalMetaDataKind};\n+use rustc::hir::map::definitions::DefPathTable;\n use rustc::util::nodemap::{NodeSet, DefIdMap};\n-use rustc_back::PanicStrategy;\n \n use std::any::Any;\n use std::rc::Rc;\n@@ -39,23 +40,27 @@ use syntax::parse::filemap_to_stream;\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, NO_EXPANSION};\n use rustc_data_structures::indexed_set::IdxSetBuf;\n-use rustc::hir::svh::Svh;\n use rustc::hir;\n \n macro_rules! provide {\n-    (<$lt:tt> $tcx:ident, $def_id:ident, $cdata:ident, $($name:ident => $compute:block)*) => {\n+    (<$lt:tt> $tcx:ident, $def_id:ident, $other:ident, $cdata:ident,\n+      $($name:ident => $compute:block)*) => {\n         pub fn provide<$lt>(providers: &mut Providers<$lt>) {\n-            $(fn $name<'a, $lt:$lt>($tcx: TyCtxt<'a, $lt, $lt>, $def_id: DefId)\n+            $(fn $name<'a, $lt:$lt, T>($tcx: TyCtxt<'a, $lt, $lt>, def_id_arg: T)\n                                     -> <ty::queries::$name<$lt> as\n-                                        QueryConfig>::Value {\n+                                        QueryConfig>::Value\n+                where T: IntoArgs,\n+            {\n+                #[allow(unused_variables)]\n+                let ($def_id, $other) = def_id_arg.into_args();\n                 assert!(!$def_id.is_local());\n \n                 let def_path_hash = $tcx.def_path_hash($def_id);\n                 let dep_node = def_path_hash.to_dep_node(::rustc::dep_graph::DepKind::MetaData);\n \n                 $tcx.dep_graph.read(dep_node);\n \n-                let $cdata = $tcx.sess.cstore.crate_data_as_rc_any($def_id.krate);\n+                let $cdata = $tcx.crate_data_as_rc_any($def_id.krate);\n                 let $cdata = $cdata.downcast_ref::<cstore::CrateMetadata>()\n                     .expect(\"CrateStore crated ata is not a CrateMetadata\");\n                 $compute\n@@ -69,7 +74,25 @@ macro_rules! provide {\n     }\n }\n \n-provide! { <'tcx> tcx, def_id, cdata,\n+// small trait to work around different signature queries all being defined via\n+// the macro above.\n+trait IntoArgs {\n+    fn into_args(self) -> (DefId, DefId);\n+}\n+\n+impl IntoArgs for DefId {\n+    fn into_args(self) -> (DefId, DefId) { (self, self) }\n+}\n+\n+impl IntoArgs for CrateNum {\n+    fn into_args(self) -> (DefId, DefId) { (self.as_def_id(), self.as_def_id()) }\n+}\n+\n+impl IntoArgs for (CrateNum, DefId) {\n+    fn into_args(self) -> (DefId, DefId) { (self.0.as_def_id(), self.1) }\n+}\n+\n+provide! { <'tcx> tcx, def_id, other, cdata,\n     type_of => { cdata.get_type(def_id.index, tcx) }\n     generics_of => { tcx.alloc_generics(cdata.get_generics(def_id.index)) }\n     predicates_of => { cdata.get_predicates(def_id.index, tcx) }\n@@ -119,9 +142,13 @@ provide! { <'tcx> tcx, def_id, cdata,\n     is_default_impl => { cdata.is_default_impl(def_id.index) }\n     describe_def => { cdata.get_def(def_id.index) }\n     def_span => { cdata.get_span(def_id.index, &tcx.sess) }\n-    stability => { cdata.get_stability(def_id.index) }\n-    deprecation => { cdata.get_deprecation(def_id.index) }\n-    item_attrs => { cdata.get_item_attrs(def_id.index, &tcx.dep_graph) }\n+    lookup_stability => {\n+        cdata.get_stability(def_id.index).map(|s| tcx.intern_stability(s))\n+    }\n+    lookup_deprecation_entry => {\n+        cdata.get_deprecation(def_id.index).map(DeprecationEntry::external)\n+    }\n+    item_attrs => { cdata.get_item_attrs(def_id.index) }\n     // FIXME(#38501) We've skipped a `read` on the `HirBody` of\n     // a `fn` when encoding, so the dep-tracking wouldn't work.\n     // This is only used by rustdoc anyway, which shouldn't have\n@@ -130,20 +157,80 @@ provide! { <'tcx> tcx, def_id, cdata,\n     impl_parent => { cdata.get_parent_impl(def_id.index) }\n     trait_of_item => { cdata.get_trait_of_item(def_id.index) }\n     is_exported_symbol => {\n-        let dep_node = cdata.metadata_dep_node(GlobalMetaDataKind::ExportedSymbols);\n-        cdata.exported_symbols.get(&tcx.dep_graph, dep_node).contains(&def_id.index)\n+        cdata.exported_symbols.contains(&def_id.index)\n     }\n     item_body_nested_bodies => { Rc::new(cdata.item_body_nested_bodies(def_id.index)) }\n     const_is_rvalue_promotable_to_static => {\n         cdata.const_is_rvalue_promotable_to_static(def_id.index)\n     }\n     is_mir_available => { cdata.is_item_mir_available(def_id.index) }\n \n-    dylib_dependency_formats => { Rc::new(cdata.get_dylib_dependency_formats(&tcx.dep_graph)) }\n-    is_panic_runtime => { cdata.is_panic_runtime(&tcx.dep_graph) }\n-    is_compiler_builtins => { cdata.is_compiler_builtins(&tcx.dep_graph) }\n-    has_global_allocator => { cdata.has_global_allocator(&tcx.dep_graph) }\n+    dylib_dependency_formats => { Rc::new(cdata.get_dylib_dependency_formats()) }\n+    is_panic_runtime => { cdata.is_panic_runtime() }\n+    is_compiler_builtins => { cdata.is_compiler_builtins() }\n+    has_global_allocator => { cdata.has_global_allocator() }\n+    is_sanitizer_runtime => { cdata.is_sanitizer_runtime() }\n+    is_profiler_runtime => { cdata.is_profiler_runtime() }\n+    panic_strategy => { cdata.panic_strategy() }\n     extern_crate => { Rc::new(cdata.extern_crate.get()) }\n+    is_no_builtins => { cdata.is_no_builtins() }\n+    impl_defaultness => { cdata.get_impl_defaultness(def_id.index) }\n+    exported_symbols => { Rc::new(cdata.get_exported_symbols()) }\n+    native_libraries => { Rc::new(cdata.get_native_libraries()) }\n+    plugin_registrar_fn => {\n+        cdata.root.plugin_registrar_fn.map(|index| {\n+            DefId { krate: def_id.krate, index }\n+        })\n+    }\n+    derive_registrar_fn => {\n+        cdata.root.macro_derive_registrar.map(|index| {\n+            DefId { krate: def_id.krate, index }\n+        })\n+    }\n+    crate_disambiguator => { cdata.disambiguator() }\n+    crate_hash => { cdata.hash() }\n+    original_crate_name => { cdata.name() }\n+\n+    implementations_of_trait => {\n+        let mut result = vec![];\n+        let filter = Some(other);\n+        cdata.get_implementations_for_trait(filter, &mut result);\n+        Rc::new(result)\n+    }\n+\n+    all_trait_implementations => {\n+        let mut result = vec![];\n+        cdata.get_implementations_for_trait(None, &mut result);\n+        Rc::new(result)\n+    }\n+\n+    is_dllimport_foreign_item => {\n+        cdata.is_dllimport_foreign_item(def_id.index)\n+    }\n+    visibility => { cdata.get_visibility(def_id.index) }\n+    dep_kind => { cdata.dep_kind.get() }\n+    crate_name => { cdata.name }\n+    item_children => {\n+        let mut result = vec![];\n+        cdata.each_child_of_item(def_id.index, |child| result.push(child), tcx.sess);\n+        Rc::new(result)\n+    }\n+    defined_lang_items => { Rc::new(cdata.get_lang_items()) }\n+    missing_lang_items => { Rc::new(cdata.get_missing_lang_items()) }\n+\n+    extern_const_body => {\n+        debug!(\"item_body({:?}): inlining item\", def_id);\n+        cdata.extern_const_body(tcx, def_id.index)\n+    }\n+\n+    missing_extern_crate_item => {\n+        match cdata.extern_crate.get() {\n+            Some(extern_crate) if !extern_crate.direct => true,\n+            _ => false,\n+        }\n+    }\n+\n+    used_crate_source => { Rc::new(cdata.source.clone()) }\n }\n \n pub fn provide_local<'tcx>(providers: &mut Providers<'tcx>) {\n@@ -158,8 +245,94 @@ pub fn provide_local<'tcx>(providers: &mut Providers<'tcx>) {\n         }\n     }\n \n+    // FIXME(#44234) - almost all of these queries have no sub-queries and\n+    // therefore no actual inputs, they're just reading tables calculated in\n+    // resolve! Does this work? Unsure! That's what the issue is about\n     *providers = Providers {\n         is_const_fn,\n+        is_dllimport_foreign_item: |tcx, id| {\n+            tcx.native_library_kind(id) == Some(NativeLibraryKind::NativeUnknown)\n+        },\n+        is_statically_included_foreign_item: |tcx, id| {\n+            match tcx.native_library_kind(id) {\n+                Some(NativeLibraryKind::NativeStatic) |\n+                Some(NativeLibraryKind::NativeStaticNobundle) => true,\n+                _ => false,\n+            }\n+        },\n+        native_library_kind: |tcx, id| {\n+            tcx.native_libraries(id.krate)\n+                .iter()\n+                .filter(|lib| native_libs::relevant_lib(&tcx.sess, lib))\n+                .find(|l| l.foreign_items.contains(&id.index))\n+                .map(|l| l.kind)\n+        },\n+        native_libraries: |tcx, cnum| {\n+            assert_eq!(cnum, LOCAL_CRATE);\n+            Rc::new(native_libs::collect(tcx))\n+        },\n+        link_args: |tcx, cnum| {\n+            assert_eq!(cnum, LOCAL_CRATE);\n+            Rc::new(link_args::collect(tcx))\n+        },\n+\n+        // Returns a map from a sufficiently visible external item (i.e. an\n+        // external item that is visible from at least one local module) to a\n+        // sufficiently visible parent (considering modules that re-export the\n+        // external item to be parents).\n+        visible_parent_map: |tcx, cnum| {\n+            use std::collections::vec_deque::VecDeque;\n+            use std::collections::hash_map::Entry;\n+\n+            assert_eq!(cnum, LOCAL_CRATE);\n+            let mut visible_parent_map: DefIdMap<DefId> = DefIdMap();\n+\n+            for &cnum in tcx.crates().iter() {\n+                // Ignore crates without a corresponding local `extern crate` item.\n+                if tcx.missing_extern_crate_item(cnum) {\n+                    continue\n+                }\n+\n+                let bfs_queue = &mut VecDeque::new();\n+                let visible_parent_map = &mut visible_parent_map;\n+                let mut add_child = |bfs_queue: &mut VecDeque<_>,\n+                                     child: &def::Export,\n+                                     parent: DefId| {\n+                    let child = child.def.def_id();\n+\n+                    if tcx.visibility(child) != ty::Visibility::Public {\n+                        return;\n+                    }\n+\n+                    match visible_parent_map.entry(child) {\n+                        Entry::Occupied(mut entry) => {\n+                            // If `child` is defined in crate `cnum`, ensure\n+                            // that it is mapped to a parent in `cnum`.\n+                            if child.krate == cnum && entry.get().krate != cnum {\n+                                entry.insert(parent);\n+                            }\n+                        }\n+                        Entry::Vacant(entry) => {\n+                            entry.insert(parent);\n+                            bfs_queue.push_back(child);\n+                        }\n+                    }\n+                };\n+\n+                bfs_queue.push_back(DefId {\n+                    krate: cnum,\n+                    index: CRATE_DEF_INDEX\n+                });\n+                while let Some(def) = bfs_queue.pop_front() {\n+                    for child in tcx.item_children(def).iter() {\n+                        add_child(bfs_queue, child, def);\n+                    }\n+                }\n+            }\n+\n+            Rc::new(visible_parent_map)\n+        },\n+\n         ..*providers\n     };\n }\n@@ -173,147 +346,36 @@ impl CrateStore for cstore::CStore {\n         &*self.metadata_loader\n     }\n \n-    fn visibility(&self, def: DefId) -> ty::Visibility {\n-        self.read_dep_node(def);\n+    fn visibility_untracked(&self, def: DefId) -> ty::Visibility {\n         self.get_crate_data(def.krate).get_visibility(def.index)\n     }\n \n-    fn item_generics_cloned(&self, def: DefId) -> ty::Generics {\n-        self.read_dep_node(def);\n+    fn item_generics_cloned_untracked(&self, def: DefId) -> ty::Generics {\n         self.get_crate_data(def.krate).get_generics(def.index)\n     }\n \n-    fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId>\n-    {\n-        let mut result = vec![];\n-\n-        self.iter_crate_data(|_, cdata| {\n-            cdata.get_implementations_for_trait(filter, &self.dep_graph, &mut result)\n-        });\n-        result\n-    }\n-\n-    fn impl_defaultness(&self, def: DefId) -> hir::Defaultness\n+    fn associated_item_cloned_untracked(&self, def: DefId) -> ty::AssociatedItem\n     {\n-        self.read_dep_node(def);\n-        self.get_crate_data(def.krate).get_impl_defaultness(def.index)\n-    }\n-\n-    fn associated_item_cloned(&self, def: DefId) -> ty::AssociatedItem\n-    {\n-        self.read_dep_node(def);\n         self.get_crate_data(def.krate).get_associated_item(def.index)\n     }\n \n-    fn is_statically_included_foreign_item(&self, def_id: DefId) -> bool\n+    fn dep_kind_untracked(&self, cnum: CrateNum) -> DepKind\n     {\n-        self.do_is_statically_included_foreign_item(def_id)\n-    }\n-\n-    fn is_dllimport_foreign_item(&self, def_id: DefId) -> bool {\n-        if def_id.krate == LOCAL_CRATE {\n-            self.dllimport_foreign_items.borrow().contains(&def_id.index)\n-        } else {\n-            self.get_crate_data(def_id.krate)\n-                .is_dllimport_foreign_item(def_id.index, &self.dep_graph)\n-        }\n+        self.get_crate_data(cnum).dep_kind.get()\n     }\n \n-    fn dep_kind(&self, cnum: CrateNum) -> DepKind\n-    {\n+    fn export_macros_untracked(&self, cnum: CrateNum) {\n         let data = self.get_crate_data(cnum);\n-        let dep_node = data.metadata_dep_node(GlobalMetaDataKind::CrateDeps);\n-        self.dep_graph.read(dep_node);\n-        data.dep_kind.get()\n-    }\n-\n-    fn export_macros(&self, cnum: CrateNum) {\n-        let data = self.get_crate_data(cnum);\n-        let dep_node = data.metadata_dep_node(GlobalMetaDataKind::CrateDeps);\n-\n-        self.dep_graph.read(dep_node);\n         if data.dep_kind.get() == DepKind::UnexportedMacrosOnly {\n             data.dep_kind.set(DepKind::MacrosOnly)\n         }\n     }\n \n-    fn lang_items(&self, cnum: CrateNum) -> Vec<(DefIndex, usize)>\n-    {\n-        self.get_crate_data(cnum).get_lang_items(&self.dep_graph)\n-    }\n-\n-    fn missing_lang_items(&self, cnum: CrateNum)\n-                          -> Vec<lang_items::LangItem>\n-    {\n-        self.get_crate_data(cnum).get_missing_lang_items(&self.dep_graph)\n-    }\n-\n-    fn is_compiler_builtins(&self, cnum: CrateNum) -> bool {\n-        self.get_crate_data(cnum).is_compiler_builtins(&self.dep_graph)\n-    }\n-\n-    fn is_sanitizer_runtime(&self, cnum: CrateNum) -> bool {\n-        self.get_crate_data(cnum).is_sanitizer_runtime(&self.dep_graph)\n-    }\n-\n-    fn is_profiler_runtime(&self, cnum: CrateNum) -> bool {\n-        self.get_crate_data(cnum).is_profiler_runtime(&self.dep_graph)\n-    }\n-\n-    fn panic_strategy(&self, cnum: CrateNum) -> PanicStrategy {\n-        self.get_crate_data(cnum).panic_strategy(&self.dep_graph)\n-    }\n-\n-    fn crate_name(&self, cnum: CrateNum) -> Symbol\n+    fn crate_name_untracked(&self, cnum: CrateNum) -> Symbol\n     {\n         self.get_crate_data(cnum).name\n     }\n \n-    fn original_crate_name(&self, cnum: CrateNum) -> Symbol\n-    {\n-        self.get_crate_data(cnum).name()\n-    }\n-\n-    fn crate_hash(&self, cnum: CrateNum) -> Svh\n-    {\n-        self.get_crate_hash(cnum)\n-    }\n-\n-    fn crate_disambiguator(&self, cnum: CrateNum) -> Symbol\n-    {\n-        self.get_crate_data(cnum).disambiguator()\n-    }\n-\n-    fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>\n-    {\n-        self.get_crate_data(cnum).root.plugin_registrar_fn.map(|index| DefId {\n-            krate: cnum,\n-            index,\n-        })\n-    }\n-\n-    fn derive_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>\n-    {\n-        self.get_crate_data(cnum).root.macro_derive_registrar.map(|index| DefId {\n-            krate: cnum,\n-            index,\n-        })\n-    }\n-\n-    fn native_libraries(&self, cnum: CrateNum) -> Vec<NativeLibrary>\n-    {\n-        self.get_crate_data(cnum).get_native_libraries(&self.dep_graph)\n-    }\n-\n-    fn exported_symbols(&self, cnum: CrateNum) -> Vec<DefId>\n-    {\n-        self.get_crate_data(cnum).get_exported_symbols(&self.dep_graph)\n-    }\n-\n-    fn is_no_builtins(&self, cnum: CrateNum) -> bool {\n-        self.get_crate_data(cnum).is_no_builtins(&self.dep_graph)\n-    }\n-\n     /// Returns the `DefKey` for a given `DefId`. This indicates the\n     /// parent `DefId` as well as some idea of what kind of data the\n     /// `DefId` refers to.\n@@ -343,22 +405,20 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(cnum).def_path_table.clone()\n     }\n \n-    fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>\n+    fn struct_field_names_untracked(&self, def: DefId) -> Vec<ast::Name>\n     {\n-        self.read_dep_node(def);\n         self.get_crate_data(def.krate).get_struct_field_names(def.index)\n     }\n \n-    fn item_children(&self, def_id: DefId, sess: &Session) -> Vec<def::Export>\n+    fn item_children_untracked(&self, def_id: DefId, sess: &Session) -> Vec<def::Export>\n     {\n-        self.read_dep_node(def_id);\n         let mut result = vec![];\n         self.get_crate_data(def_id.krate)\n             .each_child_of_item(def_id.index, |child| result.push(child), sess);\n         result\n     }\n \n-    fn load_macro(&self, id: DefId, sess: &Session) -> LoadedMacro {\n+    fn load_macro_untracked(&self, id: DefId, sess: &Session) -> LoadedMacro {\n         let data = self.get_crate_data(id.krate);\n         if let Some(ref proc_macros) = data.proc_macros {\n             return LoadedMacro::ProcMacro(proc_macros[id.index.as_usize() - 1].1.clone());\n@@ -376,7 +436,7 @@ impl CrateStore for cstore::CStore {\n         let body = filemap_to_stream(&sess.parse_sess, filemap, None);\n \n         // Mark the attrs as used\n-        let attrs = data.get_item_attrs(id.index, &self.dep_graph);\n+        let attrs = data.get_item_attrs(id.index);\n         for attr in attrs.iter() {\n             attr::mark_used(attr);\n         }\n@@ -387,7 +447,7 @@ impl CrateStore for cstore::CStore {\n             .insert(local_span, (name.to_string(), data.get_span(id.index, sess)));\n \n         LoadedMacro::MacroDef(ast::Item {\n-            ident: ast::Ident::with_empty_ctxt(name),\n+            ident: ast::Ident::from_str(&name),\n             id: ast::DUMMY_NODE_ID,\n             span: local_span,\n             attrs: attrs.iter().cloned().collect(),\n@@ -400,50 +460,20 @@ impl CrateStore for cstore::CStore {\n         })\n     }\n \n-    fn item_body<'a, 'tcx>(&self,\n-                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           def_id: DefId)\n-                           -> &'tcx hir::Body {\n-        self.read_dep_node(def_id);\n-\n-        if let Some(cached) = tcx.hir.get_inlined_body_untracked(def_id) {\n-            return cached;\n-        }\n-\n-        debug!(\"item_body({:?}): inlining item\", def_id);\n-\n-        self.get_crate_data(def_id.krate).item_body(tcx, def_id.index)\n-    }\n-\n-    fn crates(&self) -> Vec<CrateNum>\n+    fn crates_untracked(&self) -> Vec<CrateNum>\n     {\n         let mut result = vec![];\n         self.iter_crate_data(|cnum, _| result.push(cnum));\n         result\n     }\n \n-    fn used_libraries(&self) -> Vec<NativeLibrary>\n-    {\n-        self.get_used_libraries().borrow().clone()\n-    }\n-\n-    fn used_link_args(&self) -> Vec<String>\n-    {\n-        self.get_used_link_args().borrow().clone()\n-    }\n-    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>\n+    fn extern_mod_stmt_cnum_untracked(&self, emod_id: ast::NodeId) -> Option<CrateNum>\n     {\n-        self.do_get_used_crates(prefer)\n+        self.do_extern_mod_stmt_cnum(emod_id)\n     }\n \n-    fn used_crate_source(&self, cnum: CrateNum) -> CrateSource\n-    {\n-        self.get_crate_data(cnum).source.clone()\n-    }\n-\n-    fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum>\n-    {\n-        self.do_extern_mod_stmt_cnum(emod_id)\n+    fn postorder_cnums_untracked(&self) -> Vec<CrateNum> {\n+        self.do_postorder_cnums_untracked()\n     }\n \n     fn encode_metadata<'a, 'tcx>(&self,\n@@ -459,67 +489,4 @@ impl CrateStore for cstore::CStore {\n     {\n         schema::METADATA_HEADER\n     }\n-\n-    /// Returns a map from a sufficiently visible external item (i.e. an external item that is\n-    /// visible from at least one local module) to a sufficiently visible parent (considering\n-    /// modules that re-export the external item to be parents).\n-    fn visible_parent_map<'a>(&'a self, sess: &Session) -> ::std::cell::Ref<'a, DefIdMap<DefId>> {\n-        {\n-            let visible_parent_map = self.visible_parent_map.borrow();\n-            if !visible_parent_map.is_empty() {\n-                return visible_parent_map;\n-            }\n-        }\n-\n-        use std::collections::vec_deque::VecDeque;\n-        use std::collections::hash_map::Entry;\n-\n-        let mut visible_parent_map = self.visible_parent_map.borrow_mut();\n-\n-        for cnum in (1 .. self.next_crate_num().as_usize()).map(CrateNum::new) {\n-            let cdata = self.get_crate_data(cnum);\n-\n-            match cdata.extern_crate.get() {\n-                // Ignore crates without a corresponding local `extern crate` item.\n-                Some(extern_crate) if !extern_crate.direct => continue,\n-                _ => {},\n-            }\n-\n-            let bfs_queue = &mut VecDeque::new();\n-            let mut add_child = |bfs_queue: &mut VecDeque<_>, child: def::Export, parent: DefId| {\n-                let child = child.def.def_id();\n-\n-                if self.visibility(child) != ty::Visibility::Public {\n-                    return;\n-                }\n-\n-                match visible_parent_map.entry(child) {\n-                    Entry::Occupied(mut entry) => {\n-                        // If `child` is defined in crate `cnum`, ensure\n-                        // that it is mapped to a parent in `cnum`.\n-                        if child.krate == cnum && entry.get().krate != cnum {\n-                            entry.insert(parent);\n-                        }\n-                    }\n-                    Entry::Vacant(entry) => {\n-                        entry.insert(parent);\n-                        bfs_queue.push_back(child);\n-                    }\n-                }\n-            };\n-\n-            bfs_queue.push_back(DefId {\n-                krate: cnum,\n-                index: CRATE_DEF_INDEX\n-            });\n-            while let Some(def) = bfs_queue.pop_front() {\n-                for child in self.item_children(def, sess) {\n-                    add_child(bfs_queue, child, def);\n-                }\n-            }\n-        }\n-\n-        drop(visible_parent_map);\n-        self.visible_parent_map.borrow()\n-    }\n }"}, {"sha": "689f9f5b244304b6a133a9055613747906dcbd64", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 38, "deletions": 61, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -13,11 +13,10 @@\n use cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary};\n use schema::*;\n \n-use rustc::dep_graph::{DepGraph, DepNode, DepKind};\n use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash};\n-use rustc::hir::map::definitions::GlobalMetaDataKind;\n use rustc::hir;\n \n+use rustc::middle::const_val::ByteArray;\n use rustc::middle::cstore::LinkagePreference;\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -41,6 +40,7 @@ use rustc_serialize::{Decodable, Decoder, SpecializedDecoder, opaque};\n use syntax::attr;\n use syntax::ast::{self, Ident};\n use syntax::codemap;\n+use syntax::symbol::{InternedString, Symbol};\n use syntax::ext::base::MacroKind;\n use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP, NO_EXPANSION};\n \n@@ -378,6 +378,20 @@ impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>\n     }\n }\n \n+impl<'a, 'tcx> SpecializedDecoder<ByteArray<'tcx>> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<ByteArray<'tcx>, Self::Error> {\n+        Ok(ByteArray {\n+            data: self.tcx().alloc_byte_array(&Vec::decode(self)?)\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::Const<'tcx>> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n+        Ok(self.tcx().mk_const(Decodable::decode(self)?))\n+    }\n+}\n+\n impl<'a, 'tcx> MetadataBlob {\n     pub fn is_compatible(&self) -> bool {\n         self.raw_bytes().starts_with(METADATA_HEADER)\n@@ -401,7 +415,6 @@ impl<'a, 'tcx> MetadataBlob {\n         write!(out, \"=External Dependencies=\\n\")?;\n         let root = self.get_root();\n         for (i, dep) in root.crate_deps\n-                            .get_untracked()\n                             .decode(self)\n                             .enumerate() {\n             write!(out, \"{} {}-{}\\n\", i + 1, dep.name, dep.hash)?;\n@@ -473,7 +486,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn item_name(&self, item_index: DefIndex) -> ast::Name {\n+    pub fn item_name(&self, item_index: DefIndex) -> InternedString {\n         self.def_key(item_index)\n             .disambiguated_data\n             .data\n@@ -520,12 +533,12 @@ impl<'a, 'tcx> CrateMetadata {\n \n         ty::VariantDef {\n             did: self.local_def_id(data.struct_ctor.unwrap_or(index)),\n-            name: self.item_name(index),\n+            name: Symbol::intern(&self.item_name(index)),\n             fields: item.children.decode(self).map(|index| {\n                 let f = self.entry(index);\n                 ty::FieldDef {\n                     did: self.local_def_id(index),\n-                    name: self.item_name(index),\n+                    name: Symbol::intern(&self.item_name(index)),\n                     vis: f.visibility.decode(self)\n                 }\n             }).collect(),\n@@ -645,11 +658,9 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     /// Iterates over the language items in the given crate.\n-    pub fn get_lang_items(&self, dep_graph: &DepGraph) -> Vec<(DefIndex, usize)> {\n-        let dep_node = self.metadata_dep_node(GlobalMetaDataKind::LangItems);\n+    pub fn get_lang_items(&self) -> Vec<(DefIndex, usize)> {\n         self.root\n             .lang_items\n-            .get(dep_graph, dep_node)\n             .decode(self)\n             .collect()\n     }\n@@ -705,7 +716,7 @@ impl<'a, 'tcx> CrateMetadata {\n                             if let Some(def) = self.get_def(child_index) {\n                                 callback(def::Export {\n                                     def,\n-                                    ident: Ident::with_empty_ctxt(self.item_name(child_index)),\n+                                    ident: Ident::from_str(&self.item_name(child_index)),\n                                     span: self.entry(child_index).span.decode((self, sess)),\n                                 });\n                             }\n@@ -722,7 +733,7 @@ impl<'a, 'tcx> CrateMetadata {\n                 let span = child.span.decode((self, sess));\n                 if let (Some(def), Some(name)) =\n                     (self.get_def(child_index), def_key.disambiguated_data.data.get_opt_name()) {\n-                    let ident = Ident::with_empty_ctxt(name);\n+                    let ident = Ident::from_str(&name);\n                     callback(def::Export { def: def, ident: ident, span: span });\n                     // For non-reexport structs and variants add their constructors to children.\n                     // Reexport lists automatically contain constructors when necessary.\n@@ -759,10 +770,10 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn item_body(&self,\n-                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                     id: DefIndex)\n-                     -> &'tcx hir::Body {\n+    pub fn extern_const_body(&self,\n+                             tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             id: DefIndex)\n+                             -> &'tcx hir::Body {\n         assert!(!self.is_proc_macro(id));\n         let ast = self.entry(id).ast.unwrap();\n         let def_id = self.local_def_id(id);\n@@ -836,7 +847,7 @@ impl<'a, 'tcx> CrateMetadata {\n         };\n \n         ty::AssociatedItem {\n-            name,\n+            name: Symbol::intern(&name),\n             kind,\n             vis: item.visibility.decode(self),\n             defaultness: container.defaultness(),\n@@ -868,18 +879,13 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_item_attrs(&self,\n-                          node_id: DefIndex,\n-                          dep_graph: &DepGraph) -> Rc<[ast::Attribute]> {\n+    pub fn get_item_attrs(&self, node_id: DefIndex) -> Rc<[ast::Attribute]> {\n         let (node_as, node_index) =\n             (node_id.address_space().index(), node_id.as_array_index());\n         if self.is_proc_macro(node_id) {\n             return Rc::new([]);\n         }\n \n-        let dep_node = self.def_path_hash(node_id).to_dep_node(DepKind::MetaData);\n-        dep_graph.read(dep_node);\n-\n         if let Some(&Some(ref val)) =\n             self.attribute_cache.borrow()[node_as].get(node_index) {\n             return val.clone();\n@@ -906,7 +912,7 @@ impl<'a, 'tcx> CrateMetadata {\n         self.entry(id)\n             .children\n             .decode(self)\n-            .map(|index| self.item_name(index))\n+            .map(|index| Symbol::intern(&self.item_name(index)))\n             .collect()\n     }\n \n@@ -946,7 +952,6 @@ impl<'a, 'tcx> CrateMetadata {\n \n     pub fn get_implementations_for_trait(&self,\n                                          filter: Option<DefId>,\n-                                         dep_graph: &DepGraph,\n                                          result: &mut Vec<DefId>) {\n         // Do a reverse lookup beforehand to avoid touching the crate_num\n         // hash map in the loop below.\n@@ -957,16 +962,13 @@ impl<'a, 'tcx> CrateMetadata {\n             None => None,\n         };\n \n-        let dep_node = self.metadata_dep_node(GlobalMetaDataKind::Impls);\n-\n         if let Some(filter) = filter {\n             if let Some(impls) = self.trait_impls\n-                                     .get(dep_graph, dep_node)\n                                      .get(&filter) {\n                 result.extend(impls.decode(self).map(|idx| self.local_def_id(idx)));\n             }\n         } else {\n-            for impls in self.trait_impls.get(dep_graph, dep_node).values() {\n+            for impls in self.trait_impls.values() {\n                 result.extend(impls.decode(self).map(|idx| self.local_def_id(idx)));\n             }\n         }\n@@ -982,25 +984,13 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n \n-    pub fn get_native_libraries(&self,\n-                                dep_graph: &DepGraph)\n-                                -> Vec<NativeLibrary> {\n-        let dep_node = self.metadata_dep_node(GlobalMetaDataKind::NativeLibraries);\n-        self.root\n-            .native_libraries\n-            .get(dep_graph, dep_node)\n-            .decode(self)\n-            .collect()\n+    pub fn get_native_libraries(&self) -> Vec<NativeLibrary> {\n+        self.root.native_libraries.decode(self).collect()\n     }\n \n-    pub fn get_dylib_dependency_formats(&self,\n-                                        dep_graph: &DepGraph)\n-                                        -> Vec<(CrateNum, LinkagePreference)> {\n-        let dep_node =\n-            self.metadata_dep_node(GlobalMetaDataKind::DylibDependencyFormats);\n+    pub fn get_dylib_dependency_formats(&self) -> Vec<(CrateNum, LinkagePreference)> {\n         self.root\n             .dylib_dependency_formats\n-            .get(dep_graph, dep_node)\n             .decode(self)\n             .enumerate()\n             .flat_map(|(i, link)| {\n@@ -1010,11 +1000,9 @@ impl<'a, 'tcx> CrateMetadata {\n             .collect()\n     }\n \n-    pub fn get_missing_lang_items(&self, dep_graph: &DepGraph) -> Vec<lang_items::LangItem> {\n-        let dep_node = self.metadata_dep_node(GlobalMetaDataKind::LangItemsMissing);\n+    pub fn get_missing_lang_items(&self) -> Vec<lang_items::LangItem> {\n         self.root\n             .lang_items_missing\n-            .get(dep_graph, dep_node)\n             .decode(self)\n             .collect()\n     }\n@@ -1029,16 +1017,14 @@ impl<'a, 'tcx> CrateMetadata {\n         arg_names.decode(self).collect()\n     }\n \n-    pub fn get_exported_symbols(&self, dep_graph: &DepGraph) -> Vec<DefId> {\n-        let dep_node = self.metadata_dep_node(GlobalMetaDataKind::ExportedSymbols);\n+    pub fn get_exported_symbols(&self) -> Vec<DefId> {\n         self.exported_symbols\n-            .get(dep_graph, dep_node)\n             .iter()\n             .map(|&index| self.local_def_id(index))\n             .collect()\n     }\n \n-    pub fn get_macro(&self, id: DefIndex) -> (ast::Name, MacroDef) {\n+    pub fn get_macro(&self, id: DefIndex) -> (InternedString, MacroDef) {\n         let entry = self.entry(id);\n         match entry.kind {\n             EntryKind::MacroDef(macro_def) => (self.item_name(id), macro_def.decode(self)),\n@@ -1064,11 +1050,8 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn is_dllimport_foreign_item(&self, id: DefIndex, dep_graph: &DepGraph) -> bool {\n-        let dep_node = self.metadata_dep_node(GlobalMetaDataKind::NativeLibraries);\n-        self.dllimport_foreign_items\n-            .get(dep_graph, dep_node)\n-            .contains(&id)\n+    pub fn is_dllimport_foreign_item(&self, id: DefIndex) -> bool {\n+        self.dllimport_foreign_items.contains(&id)\n     }\n \n     pub fn is_default_impl(&self, impl_id: DefIndex) -> bool {\n@@ -1220,10 +1203,4 @@ impl<'a, 'tcx> CrateMetadata {\n         *self.codemap_import_info.borrow_mut() = imported_filemaps;\n         self.codemap_import_info.borrow()\n     }\n-\n-    pub fn metadata_dep_node(&self, kind: GlobalMetaDataKind) -> DepNode {\n-        let def_index = kind.def_index(&self.def_path_table);\n-        let def_path_hash = self.def_path_table.def_path_hash(def_index);\n-        def_path_hash.to_dep_node(DepKind::MetaData)\n-    }\n }"}, {"sha": "0a1662dd42d909eae0c8147e7795880c26aae5b5", "filename": "src/librustc_metadata/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_metadata%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_metadata%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdiagnostics.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -14,7 +14,7 @@ register_long_diagnostics! {\n E0454: r##\"\n A link name was given with an empty name. Erroneous code example:\n \n-```compile_fail,E0454\n+```ignore (cannot-test-this-because-rustdoc-stops-compile-fail-before-trans)\n #[link(name = \"\")] extern {} // error: #[link(name = \"\")] given with empty name\n ```\n \n@@ -51,7 +51,7 @@ https://doc.rust-lang.org/book/first-edition/conditional-compilation.html\n E0458: r##\"\n An unknown \"kind\" was specified for a link attribute. Erroneous code example:\n \n-```compile_fail,E0458\n+```ignore (cannot-test-this-because-rustdoc-stops-compile-fail-before-trans)\n #[link(kind = \"wonderful_unicorn\")] extern {}\n // error: unknown kind: `wonderful_unicorn`\n ```\n@@ -67,7 +67,7 @@ Please specify a valid \"kind\" value, from one of the following:\n E0459: r##\"\n A link was used without a name parameter. Erroneous code example:\n \n-```compile_fail,E0459\n+```ignore (cannot-test-this-because-rustdoc-stops-compile-fail-before-trans)\n #[link(kind = \"dylib\")] extern {}\n // error: #[link(...)] specified without `name = \"foo\"`\n ```"}, {"sha": "6b49be3e12192a9757b857cc41305af15006c4a7", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -248,7 +248,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                                 def_index: DefIndex,\n                                 op: fn(&mut IsolatedEncoder<'x, 'a, 'tcx>, DATA) -> R,\n                                 data: DATA)\n-                                -> Tracked<R> {\n+                                -> R {\n         let mut entry_builder = IsolatedEncoder::new(self);\n         let ret = op(&mut entry_builder, data);\n         let (fingerprint, this) = entry_builder.finish();\n@@ -260,7 +260,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             })\n         }\n \n-        Tracked::new(ret)\n+        ret\n     }\n \n     fn encode_info_for_items(&mut self) -> Index {\n@@ -408,9 +408,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             triple: tcx.sess.opts.target_triple.clone(),\n             hash: link_meta.crate_hash,\n             disambiguator: tcx.sess.local_crate_disambiguator(),\n-            panic_strategy: Tracked::new(tcx.sess.panic_strategy()),\n-            has_global_allocator: Tracked::new(has_global_allocator),\n-            has_default_lib_allocator: Tracked::new(has_default_lib_allocator),\n+            panic_strategy: tcx.sess.panic_strategy(),\n+            has_global_allocator: has_global_allocator,\n+            has_default_lib_allocator: has_default_lib_allocator,\n             plugin_registrar_fn: tcx.sess\n                 .plugin_registrar_fn\n                 .get()\n@@ -548,12 +548,11 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                                                                  &hir::Visibility)>)\n                            -> Entry<'tcx> {\n         let tcx = self.tcx;\n-        let hir_id = tcx.hir.node_to_hir_id(id);\n         let def_id = tcx.hir.local_def_id(id);\n         debug!(\"IsolatedEncoder::encode_info_for_mod({:?})\", def_id);\n \n         let data = ModData {\n-            reexports: match tcx.module_exports(hir_id) {\n+            reexports: match tcx.module_exports(def_id) {\n                 Some(ref exports) if *vis == hir::Public => {\n                     self.lazy_seq_from_slice(exports.as_slice())\n                 }\n@@ -991,7 +990,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 // \"unsized info\", else just store None\n                 let coerce_unsized_info =\n                     trait_ref.and_then(|t| {\n-                        if Some(t.def_id) == tcx.lang_items.coerce_unsized_trait() {\n+                        if Some(t.def_id) == tcx.lang_items().coerce_unsized_trait() {\n                             Some(tcx.at(item.span).coerce_unsized_info(def_id))\n                         } else {\n                             None\n@@ -1283,21 +1282,20 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_native_libraries(&mut self, _: ()) -> LazySeq<NativeLibrary> {\n-        let used_libraries = self.tcx.sess.cstore.used_libraries();\n-        self.lazy_seq(used_libraries)\n+        let used_libraries = self.tcx.native_libraries(LOCAL_CRATE);\n+        self.lazy_seq(used_libraries.iter().cloned())\n     }\n \n     fn encode_crate_deps(&mut self, _: ()) -> LazySeq<CrateDep> {\n-        let cstore = &*self.tcx.sess.cstore;\n-        let crates = cstore.crates();\n+        let crates = self.tcx.crates();\n \n         let mut deps = crates\n             .iter()\n             .map(|&cnum| {\n                 let dep = CrateDep {\n-                    name: cstore.original_crate_name(cnum),\n-                    hash: cstore.crate_hash(cnum),\n-                    kind: cstore.dep_kind(cnum),\n+                    name: self.tcx.original_crate_name(cnum),\n+                    hash: self.tcx.crate_hash(cnum),\n+                    kind: self.tcx.dep_kind(cnum),\n                 };\n                 (cnum, dep)\n             })\n@@ -1323,7 +1321,8 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n     fn encode_lang_items(&mut self, _: ()) -> LazySeq<(DefIndex, usize)> {\n         let tcx = self.tcx;\n-        let lang_items = tcx.lang_items.items().iter();\n+        let lang_items = tcx.lang_items();\n+        let lang_items = lang_items.items().iter();\n         self.lazy_seq(lang_items.enumerate().filter_map(|(i, &opt_def_id)| {\n             if let Some(def_id) = opt_def_id {\n                 if def_id.is_local() {\n@@ -1336,7 +1335,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n     fn encode_lang_items_missing(&mut self, _: ()) -> LazySeq<lang_items::LangItem> {\n         let tcx = self.tcx;\n-        self.lazy_seq_ref(&tcx.lang_items.missing)\n+        self.lazy_seq_ref(&tcx.lang_items().missing)\n     }\n \n     /// Encodes an index, mapping each trait to its (local) implementations.\n@@ -1521,9 +1520,16 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_info_for_ty(&mut self, ty: &hir::Ty) {\n-        if let hir::TyImplTrait(_) = ty.node {\n-            let def_id = self.tcx.hir.local_def_id(ty.id);\n-            self.record(def_id, IsolatedEncoder::encode_info_for_anon_ty, def_id);\n+        match ty.node {\n+            hir::TyImplTrait(_) => {\n+                let def_id = self.tcx.hir.local_def_id(ty.id);\n+                self.record(def_id, IsolatedEncoder::encode_info_for_anon_ty, def_id);\n+            }\n+            hir::TyArray(_, len) => {\n+                let def_id = self.tcx.hir.body_owner_def_id(len);\n+                self.record(def_id, IsolatedEncoder::encode_info_for_embedded_const, def_id);\n+            }\n+            _ => {}\n         }\n     }\n "}, {"sha": "54dbb68667b3a4aabeb268103806471d1b88bbf5", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -50,6 +50,8 @@ mod decoder;\n mod cstore_impl;\n mod isolated_encoder;\n mod schema;\n+mod native_libs;\n+mod link_args;\n \n pub mod creader;\n pub mod cstore;"}, {"sha": "6fafde0d09c16f04e8f2e62e6a071db442cbc2c1", "filename": "src/librustc_metadata/link_args.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_metadata%2Flink_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_metadata%2Flink_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flink_args.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::hir;\n+use rustc::ty::TyCtxt;\n+use syntax::abi::Abi;\n+\n+pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Vec<String> {\n+    let mut collector = Collector {\n+        args: Vec::new(),\n+    };\n+    tcx.hir.krate().visit_all_item_likes(&mut collector);\n+\n+    for attr in tcx.hir.krate().attrs.iter() {\n+        if attr.path == \"link_args\" {\n+            if let Some(linkarg) = attr.value_str() {\n+                collector.add_link_args(&linkarg.as_str());\n+            }\n+        }\n+    }\n+\n+    return collector.args\n+}\n+\n+struct Collector {\n+    args: Vec<String>,\n+}\n+\n+impl<'tcx> ItemLikeVisitor<'tcx> for Collector {\n+    fn visit_item(&mut self, it: &'tcx hir::Item) {\n+        let fm = match it.node {\n+            hir::ItemForeignMod(ref fm) => fm,\n+            _ => return,\n+        };\n+        if fm.abi == Abi::Rust ||\n+            fm.abi == Abi::RustIntrinsic ||\n+            fm.abi == Abi::PlatformIntrinsic {\n+            return\n+        }\n+\n+        // First, add all of the custom #[link_args] attributes\n+        for m in it.attrs.iter().filter(|a| a.check_name(\"link_args\")) {\n+            if let Some(linkarg) = m.value_str() {\n+                self.add_link_args(&linkarg.as_str());\n+            }\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, _it: &'tcx hir::TraitItem) {}\n+    fn visit_impl_item(&mut self, _it: &'tcx hir::ImplItem) {}\n+}\n+\n+impl Collector {\n+    fn add_link_args(&mut self, args: &str) {\n+        self.args.extend(args.split(' ').filter(|s| !s.is_empty()).map(|s| s.to_string()))\n+    }\n+}"}, {"sha": "669681d2aadde5ea71d462fedc11bdba0ef761e5", "filename": "src/librustc_metadata/native_libs.rs", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -0,0 +1,217 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::hir;\n+use rustc::middle::cstore::{self, NativeLibrary};\n+use rustc::session::Session;\n+use rustc::ty::TyCtxt;\n+use rustc::util::nodemap::FxHashSet;\n+use syntax::abi::Abi;\n+use syntax::attr;\n+use syntax::codemap::Span;\n+use syntax::feature_gate::{self, GateIssue};\n+use syntax::symbol::Symbol;\n+\n+pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Vec<NativeLibrary> {\n+    let mut collector = Collector {\n+        tcx,\n+        libs: Vec::new(),\n+    };\n+    tcx.hir.krate().visit_all_item_likes(&mut collector);\n+    collector.process_command_line();\n+    return collector.libs\n+}\n+\n+pub fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n+    match lib.cfg {\n+        Some(ref cfg) => attr::cfg_matches(cfg, &sess.parse_sess, None),\n+        None => true,\n+    }\n+}\n+\n+struct Collector<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    libs: Vec<NativeLibrary>,\n+}\n+\n+impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n+    fn visit_item(&mut self, it: &'tcx hir::Item) {\n+        let fm = match it.node {\n+            hir::ItemForeignMod(ref fm) => fm,\n+            _ => return,\n+        };\n+\n+        if fm.abi == Abi::Rust ||\n+            fm.abi == Abi::RustIntrinsic ||\n+            fm.abi == Abi::PlatformIntrinsic {\n+            return\n+        }\n+\n+        // Process all of the #[link(..)]-style arguments\n+        for m in it.attrs.iter().filter(|a| a.check_name(\"link\")) {\n+            let items = match m.meta_item_list() {\n+                Some(item) => item,\n+                None => continue,\n+            };\n+            let kind = items.iter().find(|k| {\n+                k.check_name(\"kind\")\n+            }).and_then(|a| a.value_str()).map(Symbol::as_str);\n+            let kind = match kind.as_ref().map(|s| &s[..]) {\n+                Some(\"static\") => cstore::NativeStatic,\n+                Some(\"static-nobundle\") => cstore::NativeStaticNobundle,\n+                Some(\"dylib\") => cstore::NativeUnknown,\n+                Some(\"framework\") => cstore::NativeFramework,\n+                Some(k) => {\n+                    struct_span_err!(self.tcx.sess, m.span, E0458,\n+                              \"unknown kind: `{}`\", k)\n+                        .span_label(m.span, \"unknown kind\").emit();\n+                    cstore::NativeUnknown\n+                }\n+                None => cstore::NativeUnknown\n+            };\n+            let n = items.iter().find(|n| {\n+                n.check_name(\"name\")\n+            }).and_then(|a| a.value_str());\n+            let n = match n {\n+                Some(n) => n,\n+                None => {\n+                    struct_span_err!(self.tcx.sess, m.span, E0459,\n+                                     \"#[link(...)] specified without `name = \\\"foo\\\"`\")\n+                        .span_label(m.span, \"missing `name` argument\").emit();\n+                    Symbol::intern(\"foo\")\n+                }\n+            };\n+            let cfg = items.iter().find(|k| {\n+                k.check_name(\"cfg\")\n+            }).and_then(|a| a.meta_item_list());\n+            let cfg = cfg.map(|list| {\n+                list[0].meta_item().unwrap().clone()\n+            });\n+            let foreign_items = fm.items.iter()\n+                .map(|it| self.tcx.hir.local_def_id(it.id).index)\n+                .collect();\n+            let lib = NativeLibrary {\n+                name: n,\n+                kind,\n+                cfg,\n+                foreign_items,\n+            };\n+            self.register_native_lib(Some(m.span), lib);\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, _it: &'tcx hir::TraitItem) {}\n+    fn visit_impl_item(&mut self, _it: &'tcx hir::ImplItem) {}\n+}\n+\n+impl<'a, 'tcx> Collector<'a, 'tcx> {\n+    fn register_native_lib(&mut self, span: Option<Span>, lib: NativeLibrary) {\n+        if lib.name.as_str().is_empty() {\n+            match span {\n+                Some(span) => {\n+                    struct_span_err!(self.tcx.sess, span, E0454,\n+                                     \"#[link(name = \\\"\\\")] given with empty name\")\n+                        .span_label(span, \"empty name given\")\n+                        .emit();\n+                }\n+                None => {\n+                    self.tcx.sess.err(\"empty library name given via `-l`\");\n+                }\n+            }\n+            return\n+        }\n+        let is_osx = self.tcx.sess.target.target.options.is_like_osx;\n+        if lib.kind == cstore::NativeFramework && !is_osx {\n+            let msg = \"native frameworks are only available on macOS targets\";\n+            match span {\n+                Some(span) => span_err!(self.tcx.sess, span, E0455, \"{}\", msg),\n+                None => self.tcx.sess.err(msg),\n+            }\n+        }\n+        if lib.cfg.is_some() && !self.tcx.sess.features.borrow().link_cfg {\n+            feature_gate::emit_feature_err(&self.tcx.sess.parse_sess,\n+                                           \"link_cfg\",\n+                                           span.unwrap(),\n+                                           GateIssue::Language,\n+                                           \"is feature gated\");\n+        }\n+        if lib.kind == cstore::NativeStaticNobundle &&\n+           !self.tcx.sess.features.borrow().static_nobundle {\n+            feature_gate::emit_feature_err(&self.tcx.sess.parse_sess,\n+                                           \"static_nobundle\",\n+                                           span.unwrap(),\n+                                           GateIssue::Language,\n+                                           \"kind=\\\"static-nobundle\\\" is feature gated\");\n+        }\n+        self.libs.push(lib);\n+    }\n+\n+    // Process libs passed on the command line\n+    fn process_command_line(&mut self) {\n+        // First, check for errors\n+        let mut renames = FxHashSet();\n+        for &(ref name, ref new_name, _) in &self.tcx.sess.opts.libs {\n+            if let &Some(ref new_name) = new_name {\n+                if new_name.is_empty() {\n+                    self.tcx.sess.err(\n+                        &format!(\"an empty renaming target was specified for library `{}`\",name));\n+                } else if !self.libs.iter().any(|lib| lib.name == name as &str) {\n+                    self.tcx.sess.err(&format!(\"renaming of the library `{}` was specified, \\\n+                                                however this crate contains no #[link(...)] \\\n+                                                attributes referencing this library.\", name));\n+                } else if renames.contains(name) {\n+                    self.tcx.sess.err(&format!(\"multiple renamings were \\\n+                                                specified for library `{}` .\",\n+                                               name));\n+                } else {\n+                    renames.insert(name);\n+                }\n+            }\n+        }\n+\n+        // Update kind and, optionally, the name of all native libaries\n+        // (there may be more than one) with the specified name.\n+        for &(ref name, ref new_name, kind) in &self.tcx.sess.opts.libs {\n+            let mut found = false;\n+            for lib in self.libs.iter_mut() {\n+                if lib.name == name as &str {\n+                    let mut changed = false;\n+                    if let Some(k) = kind {\n+                        lib.kind = k;\n+                        changed = true;\n+                    }\n+                    if let &Some(ref new_name) = new_name {\n+                        lib.name = Symbol::intern(new_name);\n+                        changed = true;\n+                    }\n+                    if !changed {\n+                        let msg = format!(\"redundant linker flag specified for \\\n+                                           library `{}`\", name);\n+                        self.tcx.sess.warn(&msg);\n+                    }\n+\n+                    found = true;\n+                }\n+            }\n+            if !found {\n+                // Add if not found\n+                let new_name = new_name.as_ref().map(|s| &**s); // &Option<String> -> Option<&str>\n+                let lib = NativeLibrary {\n+                    name: Symbol::intern(new_name.unwrap_or(name)),\n+                    kind: if let Some(k) = kind { k } else { cstore::NativeUnknown },\n+                    cfg: None,\n+                    foreign_items: Vec::new(),\n+                };\n+                self.register_native_lib(None, lib);\n+            }\n+        }\n+    }\n+}"}, {"sha": "ee196d74bb8143cf19d7407262eb9f4b5d39da9c", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 10, "deletions": 60, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -32,8 +32,6 @@ use std::mem;\n use rustc_data_structures::stable_hasher::{StableHasher, HashStable,\n                                            StableHasherResult};\n \n-use rustc::dep_graph::{DepGraph, DepNode};\n-\n pub fn rustc_version() -> String {\n     format!(\"rustc {}\",\n             option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\"))\n@@ -188,75 +186,27 @@ pub enum LazyState {\n     Previous(usize),\n }\n \n-/// A `Tracked<T>` wraps a value so that one can only access it when specifying\n-/// the `DepNode` for that value. This makes it harder to forget registering\n-/// reads.\n-#[derive(RustcEncodable, RustcDecodable)]\n-pub struct Tracked<T> {\n-    state: T,\n-}\n-\n-impl<T> Tracked<T> {\n-    pub fn new(state: T) -> Tracked<T> {\n-        Tracked {\n-            state,\n-        }\n-    }\n-\n-    pub fn get(&self, dep_graph: &DepGraph, dep_node: DepNode) -> &T {\n-        dep_graph.read(dep_node);\n-        &self.state\n-    }\n-\n-    pub fn get_untracked(&self) -> &T {\n-        &self.state\n-    }\n-\n-    pub fn map<F, R>(&self, f: F) -> Tracked<R>\n-        where F: FnOnce(&T) -> R\n-    {\n-        Tracked {\n-            state: f(&self.state),\n-        }\n-    }\n-}\n-\n-impl<'a, 'gcx, 'tcx, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for Tracked<T>\n-    where T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n-{\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let Tracked {\n-            ref state\n-        } = *self;\n-\n-        state.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct CrateRoot {\n     pub name: Symbol,\n     pub triple: String,\n     pub hash: hir::svh::Svh,\n     pub disambiguator: Symbol,\n-    pub panic_strategy: Tracked<PanicStrategy>,\n-    pub has_global_allocator: Tracked<bool>,\n-    pub has_default_lib_allocator: Tracked<bool>,\n+    pub panic_strategy: PanicStrategy,\n+    pub has_global_allocator: bool,\n+    pub has_default_lib_allocator: bool,\n     pub plugin_registrar_fn: Option<DefIndex>,\n     pub macro_derive_registrar: Option<DefIndex>,\n \n-    pub crate_deps: Tracked<LazySeq<CrateDep>>,\n-    pub dylib_dependency_formats: Tracked<LazySeq<Option<LinkagePreference>>>,\n-    pub lang_items: Tracked<LazySeq<(DefIndex, usize)>>,\n-    pub lang_items_missing: Tracked<LazySeq<lang_items::LangItem>>,\n-    pub native_libraries: Tracked<LazySeq<NativeLibrary>>,\n+    pub crate_deps: LazySeq<CrateDep>,\n+    pub dylib_dependency_formats: LazySeq<Option<LinkagePreference>>,\n+    pub lang_items: LazySeq<(DefIndex, usize)>,\n+    pub lang_items_missing: LazySeq<lang_items::LangItem>,\n+    pub native_libraries: LazySeq<NativeLibrary>,\n     pub codemap: LazySeq<syntax_pos::FileMap>,\n     pub def_path_table: Lazy<hir::map::definitions::DefPathTable>,\n-    pub impls: Tracked<LazySeq<TraitImpls>>,\n-    pub exported_symbols: Tracked<LazySeq<DefIndex>>,\n+    pub impls: LazySeq<TraitImpls>,\n+    pub exported_symbols: LazySeq<DefIndex>,\n     pub index: LazySeq<index::Index>,\n }\n "}, {"sha": "a6e31bcddd2427c54add2d692b6641905a4b2081", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -16,6 +16,7 @@\n use build::CFG;\n use rustc::middle::region;\n use rustc::mir::*;\n+use rustc::ty;\n \n impl<'tcx> CFG<'tcx> {\n     pub fn block_data(&self, blk: BasicBlock) -> &BasicBlockData<'tcx> {\n@@ -44,14 +45,17 @@ impl<'tcx> CFG<'tcx> {\n         self.block_data_mut(block).statements.push(statement);\n     }\n \n-    pub fn push_end_region(&mut self,\n-                           block: BasicBlock,\n-                           source_info: SourceInfo,\n-                           region_scope: region::Scope) {\n-        self.push(block, Statement {\n-            source_info,\n-            kind: StatementKind::EndRegion(region_scope),\n-        });\n+    pub fn push_end_region<'a, 'gcx:'a+'tcx>(&mut self,\n+                                             tcx: ty::TyCtxt<'a, 'gcx, 'tcx>,\n+                                             block: BasicBlock,\n+                                             source_info: SourceInfo,\n+                                             region_scope: region::Scope) {\n+        if tcx.sess.emit_end_regions() {\n+            self.push(block, Statement {\n+                source_info,\n+                kind: StatementKind::EndRegion(region_scope),\n+            });\n+        }\n     }\n \n     pub fn push_assign(&mut self,"}, {"sha": "eeae4bce335ca692680d7e7496b9d0711da17ff6", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -197,7 +197,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         span: expr_span,\n                         ty: this.hir.tcx().types.u32,\n                         literal: Literal::Value {\n-                            value: ConstVal::Integral(ConstInt::U32(0)),\n+                            value: this.hir.tcx().mk_const(ty::Const {\n+                                val: ConstVal::Integral(ConstInt::U32(0)),\n+                                ty: this.hir.tcx().types.u32\n+                            }),\n                         },\n                     }));\n                     box AggregateKind::Generator(closure_id, substs, interior)\n@@ -385,13 +388,18 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     ast::IntTy::I64 => ConstInt::I64(-1),\n                     ast::IntTy::I128 => ConstInt::I128(-1),\n                     ast::IntTy::Is => {\n-                        let int_ty = self.hir.tcx().sess.target.int_type;\n+                        let int_ty = self.hir.tcx().sess.target.isize_ty;\n                         let val = ConstIsize::new(-1, int_ty).unwrap();\n                         ConstInt::Isize(val)\n                     }\n                 };\n \n-                Literal::Value { value: ConstVal::Integral(val) }\n+                Literal::Value {\n+                    value: self.hir.tcx().mk_const(ty::Const {\n+                        val: ConstVal::Integral(val),\n+                        ty\n+                    })\n+                }\n             }\n             _ => {\n                 span_bug!(span, \"Invalid type for neg_1_literal: `{:?}`\", ty)\n@@ -412,7 +420,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     ast::IntTy::I64 => ConstInt::I64(i64::min_value()),\n                     ast::IntTy::I128 => ConstInt::I128(i128::min_value()),\n                     ast::IntTy::Is => {\n-                        let int_ty = self.hir.tcx().sess.target.int_type;\n+                        let int_ty = self.hir.tcx().sess.target.isize_ty;\n                         let min = match int_ty {\n                             ast::IntTy::I16 => std::i16::MIN as i64,\n                             ast::IntTy::I32 => std::i32::MIN as i64,\n@@ -424,7 +432,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     }\n                 };\n \n-                Literal::Value { value: ConstVal::Integral(val) }\n+                Literal::Value {\n+                    value: self.hir.tcx().mk_const(ty::Const {\n+                        val: ConstVal::Integral(val),\n+                        ty\n+                    })\n+                }\n             }\n             _ => {\n                 span_bug!(span, \"Invalid type for minval_literal: `{:?}`\", ty)"}, {"sha": "ec06e474980a63478a68a681e3a2f30dab256ad7", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -209,7 +209,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         let f = ty.fn_sig(this.hir.tcx());\n                         if f.abi() == Abi::RustIntrinsic ||\n                            f.abi() == Abi::PlatformIntrinsic {\n-                            Some(this.hir.tcx().item_name(def_id).as_str())\n+                            Some(this.hir.tcx().item_name(def_id))\n                         } else {\n                             None\n                         }"}, {"sha": "f560fa426e22e2e380ff80ed0fd5ad2ddfba10d9", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -16,8 +16,7 @@\n use build::{BlockAnd, BlockAndExtension, Builder};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::bitvec::BitVector;\n-use rustc::middle::const_val::ConstVal;\n-use rustc::ty::{AdtDef, Ty};\n+use rustc::ty::{self, Ty};\n use rustc::mir::*;\n use rustc::hir;\n use hair::*;\n@@ -294,20 +293,20 @@ pub struct MatchPair<'pat, 'tcx:'pat> {\n enum TestKind<'tcx> {\n     // test the branches of enum\n     Switch {\n-        adt_def: &'tcx AdtDef,\n+        adt_def: &'tcx ty::AdtDef,\n         variants: BitVector,\n     },\n \n     // test the branches of enum\n     SwitchInt {\n         switch_ty: Ty<'tcx>,\n-        options: Vec<ConstVal<'tcx>>,\n-        indices: FxHashMap<ConstVal<'tcx>, usize>,\n+        options: Vec<&'tcx ty::Const<'tcx>>,\n+        indices: FxHashMap<&'tcx ty::Const<'tcx>, usize>,\n     },\n \n     // test for equality\n     Eq {\n-        value: ConstVal<'tcx>,\n+        value: &'tcx ty::Const<'tcx>,\n         ty: Ty<'tcx>,\n     },\n "}, {"sha": "7b91c43aa37222dbeaf0a8f1c255d2fe0a6eb861", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -61,24 +61,24 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            PatternKind::Constant { ref value } => {\n+            PatternKind::Constant { value } => {\n                 Test {\n                     span: match_pair.pattern.span,\n                     kind: TestKind::Eq {\n-                        value: value.clone(),\n+                        value,\n                         ty: match_pair.pattern.ty.clone()\n                     }\n                 }\n             }\n \n-            PatternKind::Range { ref lo, ref hi, ref end } => {\n+            PatternKind::Range { lo, hi, end } => {\n                 Test {\n                     span: match_pair.pattern.span,\n                     kind: TestKind::Range {\n-                        lo: Literal::Value { value: lo.clone() },\n-                        hi: Literal::Value { value: hi.clone() },\n+                        lo: Literal::Value { value: lo },\n+                        hi: Literal::Value { value: hi },\n                         ty: match_pair.pattern.ty.clone(),\n-                        end: end.clone(),\n+                        end,\n                     },\n                 }\n             }\n@@ -112,8 +112,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                      test_lvalue: &Lvalue<'tcx>,\n                                      candidate: &Candidate<'pat, 'tcx>,\n                                      switch_ty: Ty<'tcx>,\n-                                     options: &mut Vec<ConstVal<'tcx>>,\n-                                     indices: &mut FxHashMap<ConstVal<'tcx>, usize>)\n+                                     options: &mut Vec<&'tcx ty::Const<'tcx>>,\n+                                     indices: &mut FxHashMap<&'tcx ty::Const<'tcx>, usize>)\n                                      -> bool\n     {\n         let match_pair = match candidate.match_pairs.iter().find(|mp| mp.lvalue == *test_lvalue) {\n@@ -122,13 +122,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         };\n \n         match *match_pair.pattern.kind {\n-            PatternKind::Constant { ref value } => {\n+            PatternKind::Constant { value } => {\n                 // if the lvalues match, the type should match\n                 assert_eq!(match_pair.pattern.ty, switch_ty);\n \n-                indices.entry(value.clone())\n+                indices.entry(value)\n                        .or_insert_with(|| {\n-                           options.push(value.clone());\n+                           options.push(value);\n                            options.len() - 1\n                        });\n                 true\n@@ -228,9 +228,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     assert!(options.len() > 0 && options.len() <= 2);\n                     let (true_bb, false_bb) = (self.cfg.start_new_block(),\n                                                self.cfg.start_new_block());\n-                    let ret = match &options[0] {\n-                        &ConstVal::Bool(true) => vec![true_bb, false_bb],\n-                        &ConstVal::Bool(false) => vec![false_bb, true_bb],\n+                    let ret = match options[0].val {\n+                        ConstVal::Bool(true) => vec![true_bb, false_bb],\n+                        ConstVal::Bool(false) => vec![false_bb, true_bb],\n                         v => span_bug!(test.span, \"expected boolean value but got {:?}\", v)\n                     };\n                     (ret, TerminatorKind::if_(self.hir.tcx(), Operand::Consume(lvalue.clone()),\n@@ -245,7 +245,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                .chain(Some(otherwise))\n                                .collect();\n                     let values: Vec<_> = options.iter().map(|v|\n-                        v.to_const_int().expect(\"switching on integral\")\n+                        v.val.to_const_int().expect(\"switching on integral\")\n                     ).collect();\n                     (targets.clone(), TerminatorKind::SwitchInt {\n                         discr: Operand::Consume(lvalue.clone()),\n@@ -258,12 +258,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 ret\n             }\n \n-            TestKind::Eq { ref value, mut ty } => {\n+            TestKind::Eq { value, mut ty } => {\n                 let mut val = Operand::Consume(lvalue.clone());\n \n                 // If we're using b\"...\" as a pattern, we need to insert an\n                 // unsizing coercion, as the byte string has the type &[u8; N].\n-                let expect = if let ConstVal::ByteStr(ref bytes) = *value {\n+                let expect = if let ConstVal::ByteStr(bytes) = value.val {\n                     let tcx = self.hir.tcx();\n \n                     // Unsize the lvalue to &[u8], too, if necessary.\n@@ -279,10 +279,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                     assert!(ty.is_slice());\n \n-                    let array_ty = tcx.mk_array(tcx.types.u8, bytes.len());\n+                    let array_ty = tcx.mk_array(tcx.types.u8, bytes.data.len() as u64);\n                     let array_ref = tcx.mk_imm_ref(tcx.types.re_static, array_ty);\n                     let array = self.literal_operand(test.span, array_ref, Literal::Value {\n-                        value: value.clone()\n+                        value\n                     });\n \n                     let slice = self.temp(ty, test.span);\n@@ -291,15 +291,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     Operand::Consume(slice)\n                 } else {\n                     self.literal_operand(test.span, ty, Literal::Value {\n-                        value: value.clone()\n+                        value\n                     })\n                 };\n \n                 // Use PartialEq::eq for &str and &[u8] slices, instead of BinOp::Eq.\n                 let fail = self.cfg.start_new_block();\n                 if let ty::TyRef(_, mt) = ty.sty {\n                     assert!(ty.is_slice());\n-                    let eq_def_id = self.hir.tcx().lang_items.eq_trait().unwrap();\n+                    let eq_def_id = self.hir.tcx().lang_items().eq_trait().unwrap();\n                     let ty = mt.ty;\n                     let (mty, method) = self.hir.trait_method(eq_def_id, \"eq\", ty, &[ty]);\n "}, {"sha": "1976b70ac0a2367c98f5c556a065518fe75418bb", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -59,7 +59,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ty::TyBool => {\n                 self.hir.false_literal()\n             }\n-            ty::TyChar => Literal::Value { value: ConstVal::Char('\\0') },\n+            ty::TyChar => {\n+                Literal::Value {\n+                    value: self.hir.tcx().mk_const(ty::Const {\n+                        val: ConstVal::Char('\\0'),\n+                        ty\n+                    })\n+                }\n+            }\n             ty::TyUint(ity) => {\n                 let val = match ity {\n                     ast::UintTy::U8  => ConstInt::U8(0),\n@@ -68,13 +75,18 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     ast::UintTy::U64 => ConstInt::U64(0),\n                     ast::UintTy::U128 => ConstInt::U128(0),\n                     ast::UintTy::Us => {\n-                        let uint_ty = self.hir.tcx().sess.target.uint_type;\n+                        let uint_ty = self.hir.tcx().sess.target.usize_ty;\n                         let val = ConstUsize::new(0, uint_ty).unwrap();\n                         ConstInt::Usize(val)\n                     }\n                 };\n \n-                Literal::Value { value: ConstVal::Integral(val) }\n+                Literal::Value {\n+                    value: self.hir.tcx().mk_const(ty::Const {\n+                        val: ConstVal::Integral(val),\n+                        ty\n+                    })\n+                }\n             }\n             ty::TyInt(ity) => {\n                 let val = match ity {\n@@ -84,13 +96,18 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     ast::IntTy::I64 => ConstInt::I64(0),\n                     ast::IntTy::I128 => ConstInt::I128(0),\n                     ast::IntTy::Is => {\n-                        let int_ty = self.hir.tcx().sess.target.int_type;\n+                        let int_ty = self.hir.tcx().sess.target.isize_ty;\n                         let val = ConstIsize::new(0, int_ty).unwrap();\n                         ConstInt::Isize(val)\n                     }\n                 };\n \n-                Literal::Value { value: ConstVal::Integral(val) }\n+                Literal::Value {\n+                    value: self.hir.tcx().mk_const(ty::Const {\n+                        val: ConstVal::Integral(val),\n+                        ty\n+                    })\n+                }\n             }\n             _ => {\n                 span_bug!(span, \"Invalid type for zero_literal: `{:?}`\", ty)"}, {"sha": "be6f8c9e56c40b7a67db94bdf3a8b008440ef240", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -11,7 +11,6 @@\n \n use build;\n use hair::cx::Cx;\n-use hair::Pattern;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::middle::region;\n@@ -167,6 +166,26 @@ impl<'a, 'gcx: 'tcx, 'tcx> MutVisitor<'tcx> for GlobalizeMir<'a, 'gcx> {\n         }\n     }\n \n+    fn visit_region(&mut self, region: &mut ty::Region<'tcx>, _: Location) {\n+        if let Some(lifted) = self.tcx.lift(region) {\n+            *region = lifted;\n+        } else {\n+            span_bug!(self.span,\n+                      \"found region `{:?}` with inference types/regions in MIR\",\n+                      region);\n+        }\n+    }\n+\n+    fn visit_const(&mut self, constant: &mut &'tcx ty::Const<'tcx>, _: Location) {\n+        if let Some(lifted) = self.tcx.lift(constant) {\n+            *constant = lifted;\n+        } else {\n+            span_bug!(self.span,\n+                      \"found constant `{:?}` with inference types/regions in MIR\",\n+                      constant);\n+        }\n+    }\n+\n     fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>, _: Location) {\n         if let Some(lifted) = self.tcx.lift(substs) {\n             *substs = lifted;\n@@ -384,11 +403,11 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     // Gather the upvars of a closure, if any.\n     let upvar_decls: Vec<_> = tcx.with_freevars(fn_id, |freevars| {\n         freevars.iter().map(|fv| {\n-            let var_def_id = fv.def.def_id();\n-            let var_node_id = tcx.hir.as_local_node_id(var_def_id).unwrap();\n+            let var_id = fv.var_id();\n+            let var_hir_id = tcx.hir.node_to_hir_id(var_id);\n             let closure_expr_id = tcx.hir.local_def_id(fn_id).index;\n             let capture = hir.tables().upvar_capture(ty::UpvarId {\n-                var_id: var_def_id.index,\n+                var_id: var_hir_id,\n                 closure_expr_id,\n             });\n             let by_ref = match capture {\n@@ -399,7 +418,7 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                 debug_name: keywords::Invalid.name(),\n                 by_ref,\n             };\n-            if let Some(hir::map::NodeBinding(pat)) = tcx.hir.find(var_node_id) {\n+            if let Some(hir::map::NodeBinding(pat)) = tcx.hir.find(var_id) {\n                 if let hir::PatKind::Binding(_, _, ref ident, _) = pat.node {\n                     decl.debug_name = ident.node;\n                 }\n@@ -537,10 +556,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let lvalue = Lvalue::Local(Local::new(index + 1));\n \n             if let Some(pattern) = pattern {\n-                let pattern = Pattern::from_hir(self.hir.tcx().global_tcx(),\n-                                                self.hir.param_env.and(self.hir.identity_substs),\n-                                                self.hir.tables(),\n-                                                pattern);\n+                let pattern = self.hir.pattern_from_hir(pattern);\n                 scope = self.declare_bindings(scope, ast_body.span, &pattern);\n                 unpack!(block = self.lvalue_into_pattern(block, pattern, &lvalue));\n             }"}, {"sha": "bac884b4d01e9f94dfa898838a0073d7cadbe89d", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -89,7 +89,7 @@ should go to.\n \n use build::{BlockAnd, BlockAndExtension, Builder, CFG};\n use rustc::middle::region;\n-use rustc::ty::Ty;\n+use rustc::ty::{Ty, TyCtxt};\n use rustc::mir::*;\n use rustc::mir::transform::MirSource;\n use syntax_pos::{Span};\n@@ -352,14 +352,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n         let scope = self.scopes.pop().unwrap();\n         assert_eq!(scope.region_scope, region_scope.0);\n+\n+        self.cfg.push_end_region(self.hir.tcx(), block, region_scope.1, scope.region_scope);\n         unpack!(block = build_scope_drops(&mut self.cfg,\n                                           &scope,\n                                           &self.scopes,\n                                           block,\n                                           self.arg_count,\n                                           false));\n \n-        self.cfg.push_end_region(block, region_scope.1, scope.region_scope);\n         block.unit()\n     }\n \n@@ -406,15 +407,16 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 scope.cached_exits.insert((target, region_scope.0), b);\n                 b\n             };\n+\n+            // End all regions for scopes out of which we are breaking.\n+            self.cfg.push_end_region(self.hir.tcx(), block, region_scope.1, scope.region_scope);\n+\n             unpack!(block = build_scope_drops(&mut self.cfg,\n                                               scope,\n                                               rest,\n                                               block,\n                                               self.arg_count,\n                                               false));\n-\n-            // End all regions for scopes out of which we are breaking.\n-            self.cfg.push_end_region(block, region_scope.1, scope.region_scope);\n         }\n         }\n         let scope = &self.scopes[len - scope_count];\n@@ -463,7 +465,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                               true));\n \n             // End all regions for scopes out of which we are breaking.\n-            self.cfg.push_end_region(block, src_info, scope.region_scope);\n+            self.cfg.push_end_region(self.hir.tcx(), block, src_info, scope.region_scope);\n         }\n \n         self.cfg.terminate(block, src_info, TerminatorKind::GeneratorDrop);\n@@ -694,7 +696,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         };\n \n         for scope in scopes.iter_mut() {\n-            target = build_diverge_scope(cfg, scope.region_scope_span,\n+            target = build_diverge_scope(self.hir.tcx(), cfg, scope.region_scope_span,\n                                          scope, target, generator_drop);\n         }\n         Some(target)\n@@ -831,7 +833,8 @@ fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n     block.unit()\n }\n \n-fn build_diverge_scope<'a, 'gcx, 'tcx>(cfg: &mut CFG<'tcx>,\n+fn build_diverge_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                       cfg: &mut CFG<'tcx>,\n                                        span: Span,\n                                        scope: &mut Scope<'tcx>,\n                                        mut target: BasicBlock,\n@@ -893,7 +896,7 @@ fn build_diverge_scope<'a, 'gcx, 'tcx>(cfg: &mut CFG<'tcx>,\n     // becomes trivial goto after pass that removes all EndRegions.)\n     {\n         let block = cfg.start_new_cleanup_block();\n-        cfg.push_end_region(block, source_info(span), scope.region_scope);\n+        cfg.push_end_region(tcx, block, source_info(span), scope.region_scope);\n         cfg.terminate(block, source_info(span), TerminatorKind::Goto { target: target });\n         target = block\n     }"}, {"sha": "4b71a429f847a39c36d73e4679bbbb028be21658", "filename": "src/librustc_mir/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -431,29 +431,6 @@ Remember this solution is unsafe! You will have to ensure that accesses to the\n cell are synchronized.\n \"##,\n \n-E0493: r##\"\n-A type with a destructor was assigned to an invalid type of variable. Erroneous\n-code example:\n-\n-```compile_fail,E0493\n-struct Foo {\n-    a: u32\n-}\n-\n-impl Drop for Foo {\n-    fn drop(&mut self) {}\n-}\n-\n-const F : Foo = Foo { a : 0 };\n-// error: constants are not allowed to have destructors\n-static S : Foo = Foo { a : 0 };\n-// error: destructors in statics are an unstable feature\n-```\n-\n-To solve this issue, please use a type which does allow the usage of type with\n-destructors.\n-\"##,\n-\n E0494: r##\"\n A reference of an interior static was assigned to another const/static.\n Erroneous code example:\n@@ -991,6 +968,7 @@ fn print_fancy_ref(fancy_ref: &FancyNum){\n }\n \n register_diagnostics! {\n+    E0493, // destructors cannot be evaluated at compile-time\n     E0524, // two closures require unique access to `..` at the same time\n     E0526, // shuffle indices are not constant\n     E0625, // thread-local statics cannot be accessed at compile-time"}, {"sha": "f6b847d6d6de55a7778ca6a550547d0f1943b0d1", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -64,10 +64,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                             first_statement_index: index as u32,\n                         });\n \n-                        let pattern = Pattern::from_hir(cx.tcx.global_tcx(),\n-                                                        cx.param_env.and(cx.identity_substs),\n-                                                        cx.tables(),\n-                                                        &local.pat);\n+                        let pattern = cx.pattern_from_hir(&local.pat);\n                         result.push(StmtRef::Mirror(Box::new(Stmt {\n                             kind: StmtKind::Let {\n                                 remainder_scope: remainder_scope,"}, {"sha": "45449103c8083fde0b139e22f1b5e2450dbf3c97", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -473,7 +473,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             let def_id = cx.tcx.hir.body_owner_def_id(count);\n             let substs = Substs::identity_for_item(cx.tcx.global_tcx(), def_id);\n             let count = match cx.tcx.at(c.span).const_eval(cx.param_env.and((def_id, substs))) {\n-                Ok(ConstVal::Integral(ConstInt::Usize(u))) => u,\n+                Ok(&ty::Const { val: ConstVal::Integral(ConstInt::Usize(u)), .. }) => u,\n                 Ok(other) => bug!(\"constant evaluation of repeat count yielded {:?}\", other),\n                 Err(s) => cx.fatal_const_eval_err(&s, c.span, \"expression\")\n             };\n@@ -591,13 +591,17 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         (cx.tables().type_dependent_defs()[expr.hir_id].def_id(),\n          cx.tables().node_substs(expr.hir_id))\n     });\n+    let ty = cx.tcx().mk_fn_def(def_id, substs);\n     Expr {\n         temp_lifetime,\n-        ty: cx.tcx().mk_fn_def(def_id, substs),\n+        ty,\n         span: expr.span,\n         kind: ExprKind::Literal {\n             literal: Literal::Value {\n-                value: ConstVal::Function(def_id, substs),\n+                value: cx.tcx.mk_const(ty::Const {\n+                    val: ConstVal::Function(def_id, substs),\n+                    ty\n+                }),\n             },\n         },\n     }\n@@ -612,12 +616,7 @@ fn to_borrow_kind(m: hir::Mutability) -> BorrowKind {\n \n fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>, arm: &'tcx hir::Arm) -> Arm<'tcx> {\n     Arm {\n-        patterns: arm.pats.iter().map(|p| {\n-            Pattern::from_hir(cx.tcx.global_tcx(),\n-                              cx.param_env.and(cx.identity_substs),\n-                              cx.tables(),\n-                              p)\n-        }).collect(),\n+        patterns: arm.pats.iter().map(|p| cx.pattern_from_hir(p)).collect(),\n         guard: arm.guard.to_ref(),\n         body: arm.body.to_ref(),\n     }\n@@ -635,15 +634,20 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         Def::StructCtor(def_id, CtorKind::Fn) |\n         Def::VariantCtor(def_id, CtorKind::Fn) => ExprKind::Literal {\n             literal: Literal::Value {\n-                value: ConstVal::Function(def_id, substs),\n+                value: cx.tcx.mk_const(ty::Const {\n+                    val: ConstVal::Function(def_id, substs),\n+                    ty: cx.tables().node_id_to_type(expr.hir_id)\n+                }),\n             },\n         },\n \n         Def::Const(def_id) |\n         Def::AssociatedConst(def_id) => ExprKind::Literal {\n-            literal: Literal::Item {\n-                def_id,\n-                substs,\n+            literal: Literal::Value {\n+                value: cx.tcx.mk_const(ty::Const {\n+                    val: ConstVal::Unevaluated(def_id, substs),\n+                    ty: cx.tables().node_id_to_type(expr.hir_id)\n+                }),\n             },\n         },\n \n@@ -680,19 +684,15 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n \n     match def {\n-        Def::Local(def_id) => {\n-            let node_id = cx.tcx.hir.as_local_node_id(def_id).unwrap();\n-            ExprKind::VarRef { id: node_id }\n-        }\n+        Def::Local(id) => ExprKind::VarRef { id },\n \n-        Def::Upvar(var_def_id, index, closure_expr_id) => {\n-            let id_var = cx.tcx.hir.as_local_node_id(var_def_id).unwrap();\n+        Def::Upvar(var_id, index, closure_expr_id) => {\n             debug!(\"convert_var(upvar({:?}, {:?}, {:?}))\",\n-                   id_var,\n+                   var_id,\n                    index,\n                    closure_expr_id);\n-            let var_ty = cx.tables()\n-                           .node_id_to_type(cx.tcx.hir.node_to_hir_id(id_var));\n+            let var_hir_id = cx.tcx.hir.node_to_hir_id(var_id);\n+            let var_ty = cx.tables().node_id_to_type(var_hir_id);\n \n             // FIXME free regions in closures are not right\n             let closure_ty = cx.tables()\n@@ -778,7 +778,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             // ...but the upvar might be an `&T` or `&mut T` capture, at which\n             // point we need an implicit deref\n             let upvar_id = ty::UpvarId {\n-                var_id: var_def_id.index,\n+                var_id: var_hir_id,\n                 closure_expr_id: closure_def_id.index,\n             };\n             match cx.tables().upvar_capture(upvar_id) {\n@@ -890,16 +890,14 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                    freevar: &hir::Freevar,\n                                    freevar_ty: Ty<'tcx>)\n                                    -> ExprRef<'tcx> {\n-    let var_def_id = freevar.def.def_id();\n-    let var_node_id = cx.tcx.hir.as_local_node_id(var_def_id).unwrap();\n+    let var_hir_id = cx.tcx.hir.node_to_hir_id(freevar.var_id());\n     let upvar_id = ty::UpvarId {\n-        var_id: var_def_id.index,\n+        var_id: var_hir_id,\n         closure_expr_id: cx.tcx.hir.local_def_id(closure_expr.id).index,\n     };\n     let upvar_capture = cx.tables().upvar_capture(upvar_id);\n     let temp_lifetime = cx.region_scope_tree.temporary_scope(closure_expr.hir_id.local_id);\n-    let var_ty = cx.tables()\n-                   .node_id_to_type(cx.tcx.hir.node_to_hir_id(var_node_id));\n+    let var_ty = cx.tables().node_id_to_type(var_hir_id);\n     let captured_var = Expr {\n         temp_lifetime,\n         ty: var_ty,"}, {"sha": "f5e15979006af50f96569e30238fcd282d3cc540", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 39, "deletions": 7, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -112,8 +112,15 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn usize_literal(&mut self, value: u64) -> Literal<'tcx> {\n-        match ConstUsize::new(value, self.tcx.sess.target.uint_type) {\n-            Ok(val) => Literal::Value { value: ConstVal::Integral(ConstInt::Usize(val)) },\n+        match ConstUsize::new(value, self.tcx.sess.target.usize_ty) {\n+            Ok(val) => {\n+                Literal::Value {\n+                    value: self.tcx.mk_const(ty::Const {\n+                        val: ConstVal::Integral(ConstInt::Usize(val)),\n+                        ty: self.tcx.types.usize\n+                    })\n+                }\n+            }\n             Err(_) => bug!(\"usize literal out of range for target\"),\n         }\n     }\n@@ -127,24 +134,46 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn true_literal(&mut self) -> Literal<'tcx> {\n-        Literal::Value { value: ConstVal::Bool(true) }\n+        Literal::Value {\n+            value: self.tcx.mk_const(ty::Const {\n+                val: ConstVal::Bool(true),\n+                ty: self.tcx.types.bool\n+            })\n+        }\n     }\n \n     pub fn false_literal(&mut self) -> Literal<'tcx> {\n-        Literal::Value { value: ConstVal::Bool(false) }\n+        Literal::Value {\n+            value: self.tcx.mk_const(ty::Const {\n+                val: ConstVal::Bool(false),\n+                ty: self.tcx.types.bool\n+            })\n+        }\n     }\n \n     pub fn const_eval_literal(&mut self, e: &hir::Expr) -> Literal<'tcx> {\n         let tcx = self.tcx.global_tcx();\n         let const_cx = ConstContext::new(tcx,\n                                          self.param_env.and(self.identity_substs),\n                                          self.tables());\n-        match const_cx.eval(e) {\n-            Ok(value) => Literal::Value { value: value },\n+        match const_cx.eval(tcx.hir.expect_expr(e.id)) {\n+            Ok(value) => Literal::Value { value },\n             Err(s) => self.fatal_const_eval_err(&s, e.span, \"expression\")\n         }\n     }\n \n+    pub fn pattern_from_hir(&mut self, p: &hir::Pat) -> Pattern<'tcx> {\n+        let tcx = self.tcx.global_tcx();\n+        let p = match tcx.hir.get(p.id) {\n+            hir::map::NodePat(p) | hir::map::NodeBinding(p) => p,\n+            node => bug!(\"pattern became {:?}\", node)\n+        };\n+        Pattern::from_hir(tcx,\n+                          self.param_env.and(self.identity_substs),\n+                          self.tables(),\n+                          p)\n+    }\n+\n     pub fn fatal_const_eval_err(&mut self,\n         err: &ConstEvalErr<'tcx>,\n         primary_span: Span,\n@@ -170,7 +199,10 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                 let method_ty = method_ty.subst(self.tcx, substs);\n                 return (method_ty,\n                         Literal::Value {\n-                            value: ConstVal::Function(item.def_id, substs),\n+                            value: self.tcx.mk_const(ty::Const {\n+                                val: ConstVal::Function(item.def_id, substs),\n+                                ty: method_ty\n+                            }),\n                         });\n             }\n         }"}, {"sha": "00ee417e02b5534ab984e243da49c1c86891aff5", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -47,7 +47,7 @@ fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n             bug!(\"item {:?} passed to make_shim\", instance),\n         ty::InstanceDef::FnPtrShim(def_id, ty) => {\n             let trait_ = tcx.trait_of_item(def_id).unwrap();\n-            let adjustment = match tcx.lang_items.fn_trait_kind(trait_) {\n+            let adjustment = match tcx.lang_items().fn_trait_kind(trait_) {\n                 Some(ty::ClosureKind::FnOnce) => Adjustment::Identity,\n                 Some(ty::ClosureKind::FnMut) |\n                 Some(ty::ClosureKind::Fn) => Adjustment::Deref,\n@@ -82,7 +82,7 @@ fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n             )\n         }\n         ty::InstanceDef::ClosureOnceShim { call_once } => {\n-            let fn_mut = tcx.lang_items.fn_mut_trait().unwrap();\n+            let fn_mut = tcx.lang_items().fn_mut_trait().unwrap();\n             let call_mut = tcx.global_tcx()\n                 .associated_items(fn_mut)\n                 .find(|it| it.kind == ty::AssociatedKind::Method)\n@@ -100,7 +100,7 @@ fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n             build_drop_shim(tcx, def_id, ty)\n         }\n         ty::InstanceDef::CloneShim(def_id, ty) => {\n-            let name = tcx.item_name(def_id).as_str();\n+            let name = tcx.item_name(def_id);\n             if name == \"clone\" {\n                 build_clone_shim(tcx, def_id, ty)\n             } else if name == \"clone_from\" {\n@@ -292,7 +292,10 @@ fn build_clone_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n \n     match self_ty.sty {\n         _ if is_copy => builder.copy_shim(),\n-        ty::TyArray(ty, len) => builder.array_shim(ty, len),\n+        ty::TyArray(ty, len) => {\n+            let len = len.val.to_const_int().unwrap().to_u64().unwrap();\n+            builder.array_shim(ty, len)\n+        }\n         ty::TyTuple(tys, _) => builder.tuple_shim(tys),\n         _ => {\n             bug!(\"clone shim for `{:?}` which is not `Copy` and is not an aggregate\", self_ty);\n@@ -403,11 +406,15 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         );\n \n         // `func == Clone::clone(&ty) -> ty`\n+        let func_ty = tcx.mk_fn_def(self.def_id, substs);\n         let func = Operand::Constant(box Constant {\n             span: self.span,\n-            ty: tcx.mk_fn_def(self.def_id, substs),\n+            ty: func_ty,\n             literal: Literal::Value {\n-                value: ConstVal::Function(self.def_id, substs),\n+                value: tcx.mk_const(ty::Const {\n+                    val: ConstVal::Function(self.def_id, substs),\n+                    ty: func_ty\n+                }),\n             },\n         });\n \n@@ -466,18 +473,21 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         );\n     }\n \n-    fn make_usize(&self, value: usize) -> Box<Constant<'tcx>> {\n-        let value = ConstUsize::new(value as u64, self.tcx.sess.target.uint_type).unwrap();\n+    fn make_usize(&self, value: u64) -> Box<Constant<'tcx>> {\n+        let value = ConstUsize::new(value, self.tcx.sess.target.usize_ty).unwrap();\n         box Constant {\n             span: self.span,\n             ty: self.tcx.types.usize,\n             literal: Literal::Value {\n-                value: ConstVal::Integral(ConstInt::Usize(value))\n+                value: self.tcx.mk_const(ty::Const {\n+                    val: ConstVal::Integral(ConstInt::Usize(value)),\n+                    ty: self.tcx.types.usize,\n+                })\n             }\n         }\n     }\n \n-    fn array_shim(&mut self, ty: ty::Ty<'tcx>, len: usize) {\n+    fn array_shim(&mut self, ty: ty::Ty<'tcx>, len: u64) {\n         let tcx = self.tcx;\n         let span = self.span;\n         let rcvr = Lvalue::Local(Local::new(1+0)).deref();\n@@ -706,17 +716,21 @@ fn build_call_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n \n     let (callee, mut args) = match call_kind {\n         CallKind::Indirect => (rcvr, vec![]),\n-        CallKind::Direct(def_id) => (\n-            Operand::Constant(box Constant {\n+        CallKind::Direct(def_id) => {\n+            let ty = tcx.type_of(def_id);\n+            (Operand::Constant(box Constant {\n                 span,\n-                ty: tcx.type_of(def_id),\n+                ty,\n                 literal: Literal::Value {\n-                    value: ConstVal::Function(def_id,\n-                        Substs::identity_for_item(tcx, def_id)),\n+                    value: tcx.mk_const(ty::Const {\n+                        val: ConstVal::Function(def_id,\n+                            Substs::identity_for_item(tcx, def_id)),\n+                        ty\n+                    }),\n                 },\n-            }),\n-            vec![rcvr]\n-        )\n+             }),\n+             vec![rcvr])\n+        }\n     };\n \n     if let Some(untuple_args) = untuple_args {"}, {"sha": "a6750f400ba939ca4d1e9d903a1aa533ce40104d", "filename": "src/librustc_mir/transform/clean_end_regions.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Ftransform%2Fclean_end_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Ftransform%2Fclean_end_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fclean_end_regions.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -39,9 +39,11 @@ struct DeleteTrivialEndRegions<'a> {\n \n impl MirPass for CleanEndRegions {\n     fn run_pass<'a, 'tcx>(&self,\n-                          _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _source: MirSource,\n                           mir: &mut Mir<'tcx>) {\n+        if !tcx.sess.emit_end_regions() { return; }\n+\n         let mut gather = GatherBorrowedRegions {\n             seen_regions: FxHashSet()\n         };"}, {"sha": "1077f3b0146168ccd48e1a0e166324306a8bbcdc", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -29,7 +29,6 @@ use syntax::ast;\n use syntax_pos::Span;\n \n use std::fmt;\n-use std::u32;\n \n pub struct ElaborateDrops;\n \n@@ -521,7 +520,12 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         Rvalue::Use(Operand::Constant(Box::new(Constant {\n             span,\n             ty: self.tcx.types.bool,\n-            literal: Literal::Value { value: ConstVal::Bool(val) }\n+            literal: Literal::Value {\n+                value: self.tcx.mk_const(ty::Const {\n+                    val: ConstVal::Bool(val),\n+                    ty: self.tcx.types.bool\n+                })\n+            }\n         })))\n     }\n "}, {"sha": "dc18cdd8f0dd6006e2270974f8cae06240319d0e", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -15,7 +15,7 @@\n //! \"types-as-contracts\"-validation, namely, AcquireValid, ReleaseValid, and EndRegion.\n \n use rustc::ty::subst::Substs;\n-use rustc::ty::{Ty, TyCtxt, ClosureSubsts};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::mir::*;\n use rustc::mir::visit::{MutVisitor, Lookup};\n use rustc::mir::transform::{MirPass, MirSource};\n@@ -37,38 +37,25 @@ impl<'a, 'tcx> EraseRegionsVisitor<'a, 'tcx> {\n impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &mut Ty<'tcx>, _: Lookup) {\n         if !self.in_validation_statement {\n-            *ty = self.tcx.erase_regions(&{*ty});\n+            *ty = self.tcx.erase_regions(ty);\n         }\n         self.super_ty(ty);\n     }\n \n-    fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>, _: Location) {\n-        *substs = self.tcx.erase_regions(&{*substs});\n+    fn visit_region(&mut self, region: &mut ty::Region<'tcx>, _: Location) {\n+        *region = self.tcx.types.re_erased;\n     }\n \n-    fn visit_rvalue(&mut self, rvalue: &mut Rvalue<'tcx>, location: Location) {\n-        match *rvalue {\n-            Rvalue::Ref(ref mut r, _, _) => {\n-                *r = self.tcx.types.re_erased;\n-            }\n-            Rvalue::Use(..) |\n-            Rvalue::Repeat(..) |\n-            Rvalue::Len(..) |\n-            Rvalue::Cast(..) |\n-            Rvalue::BinaryOp(..) |\n-            Rvalue::CheckedBinaryOp(..) |\n-            Rvalue::UnaryOp(..) |\n-            Rvalue::Discriminant(..) |\n-            Rvalue::NullaryOp(..) |\n-            Rvalue::Aggregate(..) => {\n-                // These variants don't contain regions.\n-            }\n-        }\n-        self.super_rvalue(rvalue, location);\n+    fn visit_const(&mut self, constant: &mut &'tcx ty::Const<'tcx>, _: Location) {\n+        *constant = self.tcx.erase_regions(constant);\n+    }\n+\n+    fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>, _: Location) {\n+        *substs = self.tcx.erase_regions(substs);\n     }\n \n     fn visit_closure_substs(&mut self,\n-                            substs: &mut ClosureSubsts<'tcx>,\n+                            substs: &mut ty::ClosureSubsts<'tcx>,\n                             _: Location) {\n         *substs = self.tcx.erase_regions(substs);\n     }"}, {"sha": "a52656becd74534190b114501df7e4bff8d6be39", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -175,7 +175,10 @@ impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n             span: source_info.span,\n             ty: self.tcx.types.u32,\n             literal: Literal::Value {\n-                value: ConstVal::Integral(ConstInt::U32(state_disc)),\n+                value: self.tcx.mk_const(ty::Const {\n+                    val: ConstVal::Integral(ConstInt::U32(state_disc)),\n+                    ty: self.tcx.types.u32\n+                }),\n             },\n         });\n         Statement {\n@@ -553,7 +556,10 @@ fn insert_panic_on_resume_after_return<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             span: mir.span,\n             ty: tcx.types.bool,\n             literal: Literal::Value {\n-                value: ConstVal::Bool(false),\n+                value: tcx.mk_const(ty::Const {\n+                    val: ConstVal::Bool(false),\n+                    ty: tcx.types.bool\n+                }),\n             },\n         }),\n         expected: true,\n@@ -603,7 +609,10 @@ fn create_generator_resume_function<'a, 'tcx>(\n             span: mir.span,\n             ty: tcx.types.bool,\n             literal: Literal::Value {\n-                value: ConstVal::Bool(false),\n+                value: tcx.mk_const(ty::Const {\n+                    val: ConstVal::Bool(false),\n+                    ty: tcx.types.bool\n+                }),\n             },\n         }),\n         expected: true,\n@@ -715,7 +724,7 @@ impl MirPass for StateTransform {\n         let gen_ty = mir.local_decls.raw[1].ty;\n \n         // Compute GeneratorState<yield_ty, return_ty>\n-        let state_did = tcx.lang_items.gen_state().unwrap();\n+        let state_did = tcx.lang_items().gen_state().unwrap();\n         let state_adt_ref = tcx.adt_def(state_did);\n         let state_substs = tcx.mk_substs([Kind::from(yield_ty),\n             Kind::from(mir.return_ty)].iter());"}, {"sha": "48a21dfdbd467032026d387863a2de94054c2900", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -88,12 +88,14 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                 if let TerminatorKind::Call {\n                     func: Operand::Constant(ref f), .. } = terminator.kind {\n                     if let ty::TyFnDef(callee_def_id, substs) = f.ty.sty {\n-                        callsites.push_back(CallSite {\n-                            callee: callee_def_id,\n-                            substs,\n-                            bb,\n-                            location: terminator.source_info\n-                        });\n+                        if self.tcx.trait_of_item(callee_def_id).is_none() {\n+                            callsites.push_back(CallSite {\n+                                callee: callee_def_id,\n+                                substs,\n+                                bb,\n+                                location: terminator.source_info\n+                            });\n+                        }\n                     }\n                 }\n             }\n@@ -338,7 +340,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             TerminatorKind::Call { args, destination: Some(destination), cleanup, .. } => {\n                 debug!(\"Inlined {:?} into {:?}\", callsite.callee, self.source);\n \n-                let is_box_free = Some(callsite.callee) == self.tcx.lang_items.box_free_fn();\n+                let is_box_free = Some(callsite.callee) == self.tcx.lang_items().box_free_fn();\n \n                 let mut local_map = IndexVec::with_capacity(callee_mir.local_decls.len());\n                 let mut scope_map = IndexVec::with_capacity(callee_mir.visibility_scopes.len());\n@@ -606,14 +608,20 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n                    _location: Location) {\n         if *local == RETURN_POINTER {\n             match self.destination {\n-                Lvalue::Local(l) => *local = l,\n+                Lvalue::Local(l) => {\n+                    *local = l;\n+                    return;\n+                },\n                 ref lval => bug!(\"Return lvalue is {:?}, not local\", lval)\n             }\n         }\n         let idx = local.index() - 1;\n         if idx < self.args.len() {\n             match self.args[idx] {\n-                Operand::Consume(Lvalue::Local(l)) => *local = l,\n+                Operand::Consume(Lvalue::Local(l)) => {\n+                    *local = l;\n+                    return;\n+                },\n                 ref op => bug!(\"Arg operand `{:?}` is {:?}, not local\", idx, op)\n             }\n         }"}, {"sha": "f8c26dc99c633fc062d228676432dff4457ab8ff", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 27, "deletions": 137, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -18,8 +18,8 @@ use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc::hir;\n-use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n+use rustc::middle::const_val::ConstVal;\n use rustc::traits::{self, Reveal};\n use rustc::ty::{self, TyCtxt, Ty, TypeFoldable};\n use rustc::ty::cast::CastTy;\n@@ -196,89 +196,6 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n         self.add(original);\n     }\n \n-    /// Check for NEEDS_DROP (from an ADT or const fn call) and\n-    /// error, unless we're in a function.\n-    fn always_deny_drop(&self) {\n-        self.deny_drop_with_feature_gate_override(false);\n-    }\n-\n-    /// Check for NEEDS_DROP (from an ADT or const fn call) and\n-    /// error, unless we're in a function, or the feature-gate\n-    /// for globals with destructors is enabled.\n-    fn deny_drop(&self) {\n-        self.deny_drop_with_feature_gate_override(true);\n-    }\n-\n-    fn deny_drop_with_feature_gate_override(&self, allow_gate: bool) {\n-        if self.mode == Mode::Fn || !self.qualif.intersects(Qualif::NEEDS_DROP) {\n-            return;\n-        }\n-\n-        // Static and const fn's allow destructors, but they're feature-gated.\n-        let msg = if allow_gate && self.mode != Mode::Const {\n-            // Feature-gate for globals with destructors is enabled.\n-            if self.tcx.sess.features.borrow().drop_types_in_const {\n-                return;\n-            }\n-\n-            // This comes from a macro that has #[allow_internal_unstable].\n-            if self.span.allows_unstable() {\n-                return;\n-            }\n-\n-            format!(\"destructors in {}s are an unstable feature\",\n-                    self.mode)\n-        } else {\n-            format!(\"{}s are not allowed to have destructors\",\n-                    self.mode)\n-        };\n-\n-        let mut err =\n-            struct_span_err!(self.tcx.sess, self.span, E0493, \"{}\", msg);\n-\n-        if allow_gate && self.mode != Mode::Const {\n-            help!(&mut err,\n-                  \"in Nightly builds, add `#![feature(drop_types_in_const)]` \\\n-                   to the crate attributes to enable\");\n-        } else {\n-            self.find_drop_implementation_method_span()\n-                .map(|span| err.span_label(span, \"destructor defined here\"));\n-\n-            err.span_label(self.span,\n-                format!(\"{}s cannot have destructors\", self.mode));\n-        }\n-\n-        err.emit();\n-    }\n-\n-    fn find_drop_implementation_method_span(&self) -> Option<Span> {\n-        self.tcx.lang_items\n-            .drop_trait()\n-            .and_then(|drop_trait_id| {\n-                let mut span = None;\n-\n-                self.tcx\n-                    .for_each_relevant_impl(drop_trait_id, self.mir.return_ty, |impl_did| {\n-                        self.tcx.hir\n-                            .as_local_node_id(impl_did)\n-                            .and_then(|impl_node_id| self.tcx.hir.find(impl_node_id))\n-                            .map(|node| {\n-                                if let hir_map::NodeItem(item) = node {\n-                                    if let hir::ItemImpl(.., ref impl_item_refs) = item.node {\n-                                        span = impl_item_refs.first()\n-                                                             .map(|iiref| {\n-                                                                 self.tcx.hir.impl_item(iiref.id)\n-                                                                             .span\n-                                                             });\n-                                    }\n-                                }\n-                            });\n-                    });\n-\n-                span\n-            })\n-    }\n-\n     /// Check if an Lvalue with the current qualifications could\n     /// be consumed, by either an operand or a Deref projection.\n     fn try_consume(&mut self) -> bool {\n@@ -455,25 +372,17 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n             }\n         }\n \n-        let return_ty = mir.return_ty;\n         self.qualif = self.return_qualif.unwrap_or(Qualif::NOT_CONST);\n \n-        match self.mode {\n-            Mode::StaticMut => {\n-                // Check for destructors in static mut.\n-                self.add_type(return_ty);\n-                self.deny_drop();\n-            }\n-            _ => {\n-                // Account for errors in consts by using the\n-                // conservative type qualification instead.\n-                if self.qualif.intersects(Qualif::CONST_ERROR) {\n-                    self.qualif = Qualif::empty();\n-                    self.add_type(return_ty);\n-                }\n-            }\n+        // Account for errors in consts by using the\n+        // conservative type qualification instead.\n+        if self.qualif.intersects(Qualif::CONST_ERROR) {\n+            self.qualif = Qualif::empty();\n+            let return_ty = mir.return_ty;\n+            self.add_type(return_ty);\n         }\n \n+\n         // Collect all the temps we need to promote.\n         let mut promoted_temps = IdxSetBuf::new_empty(self.temp_promotion_state.len());\n \n@@ -620,10 +529,12 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 }\n             }\n             Operand::Constant(ref constant) => {\n-                if let Literal::Item { def_id, substs: _ } = constant.literal {\n+                if let Literal::Value {\n+                    value: &ty::Const { val: ConstVal::Unevaluated(def_id, _), ty }\n+                } = constant.literal {\n                     // Don't peek inside trait associated constants.\n                     if self.tcx.trait_of_item(def_id).is_some() {\n-                        self.add_type(constant.ty);\n+                        self.add_type(ty);\n                     } else {\n                         let (bits, _) = self.tcx.at(constant.span).mir_const_qualif(def_id);\n \n@@ -633,13 +544,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                         // Just in case the type is more specific than\n                         // the definition, e.g. impl associated const\n                         // with type parameters, take it into account.\n-                        self.qualif.restrict(constant.ty, self.tcx, self.param_env);\n-                    }\n-\n-                    // Let `const fn` transitively have destructors,\n-                    // but they do get stopped in `const` or `static`.\n-                    if self.mode != Mode::ConstFn {\n-                        self.deny_drop();\n+                        self.qualif.restrict(ty, self.tcx, self.param_env);\n                     }\n                 }\n             }\n@@ -685,16 +590,12 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     let allow = if self.mode == Mode::StaticMut {\n                         // Inside a `static mut`, &mut [...] is also allowed.\n                         match ty.sty {\n-                            ty::TyArray(..) | ty::TySlice(_) => {\n-                                // Mutating can expose drops, be conservative.\n-                                self.add_type(ty);\n-                                self.deny_drop();\n-                                true\n-                            }\n+                            ty::TyArray(..) | ty::TySlice(_) => true,\n                             _ => false\n                         }\n-                    } else if let ty::TyArray(_, 0) = ty.sty {\n-                        self.mode == Mode::Fn\n+                    } else if let ty::TyArray(_, len) = ty.sty {\n+                        len.val.to_const_int().unwrap().to_u64().unwrap() == 0 &&\n+                            self.mode == Mode::Fn\n                     } else {\n                         false\n                     };\n@@ -792,18 +693,12 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 if let AggregateKind::Adt(def, ..) = **kind {\n                     if def.has_dtor(self.tcx) {\n                         self.add(Qualif::NEEDS_DROP);\n-                        self.deny_drop();\n                     }\n \n-                    if Some(def.did) == self.tcx.lang_items.unsafe_cell_type() {\n+                    if Some(def.did) == self.tcx.lang_items().unsafe_cell_type() {\n                         let ty = rvalue.ty(self.mir, self.tcx);\n                         self.add_type(ty);\n                         assert!(self.qualif.intersects(Qualif::MUTABLE_INTERIOR));\n-                        // Even if the value inside may not need dropping,\n-                        // mutating it would change that.\n-                        if !self.qualif.intersects(Qualif::NOT_CONST) {\n-                            self.deny_drop();\n-                        }\n                     }\n                 }\n             }\n@@ -824,7 +719,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     Abi::RustIntrinsic |\n                     Abi::PlatformIntrinsic => {\n                         assert!(!self.tcx.is_const_fn(def_id));\n-                        match &self.tcx.item_name(def_id).as_str()[..] {\n+                        match &self.tcx.item_name(def_id)[..] {\n                             \"size_of\" | \"min_align_of\" => is_const_fn = true,\n \n                             name if name.starts_with(\"simd_shuffle\") => {\n@@ -913,12 +808,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     let ty = dest.ty(self.mir, tcx).to_ty(tcx);\n                     self.qualif = Qualif::empty();\n                     self.add_type(ty);\n-\n-                    // Let `const fn` transitively have destructors,\n-                    // but they do get stopped in `const` or `static`.\n-                    if self.mode != Mode::ConstFn {\n-                        self.deny_drop();\n-                    }\n                 }\n                 self.assign(dest, location);\n             }\n@@ -936,14 +825,15 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 };\n \n                 if let Some(span) = needs_drop {\n+                    // Double-check the type being dropped, to minimize false positives.\n                     let ty = lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n-                    self.add_type(ty);\n-\n-                    // Use the original assignment span to be more precise.\n-                    let old_span = self.span;\n-                    self.span = span;\n-                    self.always_deny_drop();\n-                    self.span = old_span;\n+                    if ty.needs_drop(self.tcx, self.param_env) {\n+                        struct_span_err!(self.tcx.sess, span, E0493,\n+                                         \"destructors cannot be evaluated at compile-time\")\n+                            .span_label(span, format!(\"{}s cannot evaluate destructors\",\n+                                                      self.mode))\n+                            .emit();\n+                    }\n                 }\n             }\n         } else {"}, {"sha": "0dff145ecbce94c547568b7651b91529fcf4079f", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -10,7 +10,7 @@\n \n //! A pass that simplifies branches when their condition is known.\n \n-use rustc::ty::TyCtxt;\n+use rustc::ty::{self, TyCtxt};\n use rustc::middle::const_val::ConstVal;\n use rustc::mir::transform::{MirPass, MirSource};\n use rustc::mir::*;\n@@ -40,7 +40,7 @@ impl MirPass for SimplifyBranches {\n                 TerminatorKind::SwitchInt { discr: Operand::Constant(box Constant {\n                     literal: Literal::Value { ref value }, ..\n                 }), ref values, ref targets, .. } => {\n-                    if let Some(ref constint) = value.to_const_int() {\n+                    if let Some(ref constint) = value.val.to_const_int() {\n                         let (otherwise, targets) = targets.split_last().unwrap();\n                         let mut ret = TerminatorKind::Goto { target: *otherwise };\n                         for (v, t) in values.iter().zip(targets.iter()) {\n@@ -56,7 +56,7 @@ impl MirPass for SimplifyBranches {\n                 },\n                 TerminatorKind::Assert { target, cond: Operand::Constant(box Constant {\n                     literal: Literal::Value {\n-                        value: ConstVal::Bool(cond)\n+                        value: &ty::Const { val: ConstVal::Bool(cond), .. }\n                     }, ..\n                 }), expected, .. } if cond == expected => {\n                     TerminatorKind::Goto { target: target }"}, {"sha": "ab5998a34805b085f930fbd444799b5e8c9b4d88", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -209,7 +209,8 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 LvalueTy::Ty {\n                     ty: match base_ty.sty {\n                         ty::TyArray(inner, size) => {\n-                            let min_size = (from as usize) + (to as usize);\n+                            let size = size.val.to_const_int().unwrap().to_u64().unwrap();\n+                            let min_size = (from as u64) + (to as u64);\n                             if let Some(rest_size) = size.checked_sub(min_size) {\n                                 tcx.mk_array(inner, rest_size)\n                             } else {\n@@ -572,10 +573,10 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         match operand {\n             &Operand::Constant(box Constant {\n                 literal: Literal::Value {\n-                    value: ConstVal::Function(def_id, _), ..\n+                    value: &ty::Const { val: ConstVal::Function(def_id, _), .. }, ..\n                 }, ..\n             }) => {\n-                Some(def_id) == self.tcx().lang_items.box_free_fn()\n+                Some(def_id) == self.tcx().lang_items().box_free_fn()\n             }\n             _ => false,\n         }"}, {"sha": "4a11ac11680906c076346e0728e1e5ee06e1b819", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -515,7 +515,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     {\n         debug!(\"destructor_call_block({:?}, {:?})\", self, succ);\n         let tcx = self.tcx();\n-        let drop_trait = tcx.lang_items.drop_trait().unwrap();\n+        let drop_trait = tcx.lang_items().drop_trait().unwrap();\n         let drop_fn = tcx.associated_items(drop_trait).next().unwrap();\n         let ty = self.lvalue_ty(self.lvalue);\n         let substs = tcx.mk_substs(iter::once(Kind::from(ty)));\n@@ -922,7 +922,12 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         Operand::Constant(box Constant {\n             span: self.source_info.span,\n             ty: self.tcx().types.usize,\n-            literal: Literal::Value { value: ConstVal::Integral(self.tcx().const_usize(val)) }\n+            literal: Literal::Value {\n+                value: self.tcx().mk_const(ty::Const {\n+                    val: ConstVal::Integral(self.tcx().const_usize(val)),\n+                    ty: self.tcx().types.usize\n+                })\n+            }\n         })\n     }\n "}, {"sha": "547d63fc3d4aa68f58b400bc7aa9b7a14b3a4767", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 43, "deletions": 5, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -56,6 +56,7 @@ use std::cmp::Ordering;\n struct CheckCrateVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     in_fn: bool,\n+    in_static: bool,\n     promotable: bool,\n     mut_rvalue_borrows: NodeSet,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -128,10 +129,16 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         let outer_param_env = self.param_env;\n         let outer_identity_substs = self.identity_substs;\n \n-        self.in_fn = match MirSource::from_node(self.tcx, item_id) {\n-            MirSource::Fn(_) => true,\n-            _ => false\n+        self.in_fn = false;\n+        self.in_static = false;\n+\n+        match MirSource::from_node(self.tcx, item_id) {\n+            MirSource::Fn(_) => self.in_fn = true,\n+            MirSource::Static(_, _) => self.in_static = true,\n+            _ => {}\n         };\n+\n+\n         self.tables = self.tcx.typeck_tables_of(item_def_id);\n         self.param_env = self.tcx.param_env(item_def_id);\n         self.identity_substs = Substs::identity_for_item(self.tcx, item_def_id);\n@@ -327,7 +334,37 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             let def = v.tables.qpath_def(qpath, e.hir_id);\n             match def {\n                 Def::VariantCtor(..) | Def::StructCtor(..) |\n-                Def::Fn(..) | Def::Method(..) => {}\n+                Def::Fn(..) | Def::Method(..) =>  {}\n+\n+                // References to a static that are themselves within a static\n+                // are inherently promotable with the exception\n+                //  of \"#[thread_loca]\" statics, which may not\n+                // outlive the current function\n+                Def::Static(did, _) => {\n+\n+                    if v.in_static {\n+                        let mut thread_local = false;\n+\n+                        for attr in &v.tcx.get_attrs(did)[..] {\n+                            if attr.check_name(\"thread_local\") {\n+                                debug!(\"Reference to Static(id={:?}) is unpromotable \\\n+                                       due to a #[thread_local] attribute\", did);\n+                                v.promotable = false;\n+                                thread_local = true;\n+                                break;\n+                            }\n+                        }\n+\n+                        if !thread_local {\n+                            debug!(\"Allowing promotion of reference to Static(id={:?})\", did);\n+                        }\n+                    } else {\n+                        debug!(\"Reference to Static(id={:?}) is unpromotable as it is not \\\n+                               referenced from a static\", did);\n+                        v.promotable = false;\n+\n+                    }\n+                }\n \n                 Def::Const(did) |\n                 Def::AssociatedConst(did) => {\n@@ -401,7 +438,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n         hir::ExprStruct(..) => {\n             if let ty::TyAdt(adt, ..) = v.tables.expr_ty(e).sty {\n                 // unsafe_cell_type doesn't necessarily exist with no_core\n-                if Some(adt.did) == v.tcx.lang_items.unsafe_cell_type() {\n+                if Some(adt.did) == v.tcx.lang_items().unsafe_cell_type() {\n                     v.promotable = false;\n                 }\n             }\n@@ -481,6 +518,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         tcx,\n         tables: &ty::TypeckTables::empty(None),\n         in_fn: false,\n+        in_static: false,\n         promotable: false,\n         mut_rvalue_borrows: NodeSet(),\n         param_env: ty::ParamEnv::empty(Reveal::UserFacing),"}, {"sha": "1fa49614580a3a19b091faf077d6361062a0e75a", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -13,15 +13,14 @@\n // completely accurate (some things might be counted twice, others missed).\n \n use rustc_const_math::{ConstUsize};\n-use rustc::middle::const_val::{ConstVal};\n use rustc::mir::{AggregateKind, AssertMessage, BasicBlock, BasicBlockData};\n use rustc::mir::{Constant, Literal, Location, LocalDecl};\n use rustc::mir::{Lvalue, LvalueElem, LvalueProjection};\n use rustc::mir::{Mir, Operand, ProjectionElem};\n use rustc::mir::{Rvalue, SourceInfo, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind, VisibilityScope, VisibilityScopeData};\n use rustc::mir::visit as mir_visit;\n-use rustc::ty::{ClosureSubsts, TyCtxt};\n+use rustc::ty::{self, ClosureSubsts, TyCtxt};\n use rustc::util::nodemap::{FxHashMap};\n \n struct NodeData {\n@@ -236,7 +235,6 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n                      location: Location) {\n         self.record(\"Literal\", literal);\n         self.record(match *literal {\n-            Literal::Item { .. } => \"Literal::Item\",\n             Literal::Value { .. } => \"Literal::Value\",\n             Literal::Promoted { .. } => \"Literal::Promoted\",\n         }, literal);\n@@ -256,11 +254,11 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n         self.super_closure_substs(substs);\n     }\n \n-    fn visit_const_val(&mut self,\n-                       const_val: &ConstVal,\n-                       _: Location) {\n-        self.record(\"ConstVal\", const_val);\n-        self.super_const_val(const_val);\n+    fn visit_const(&mut self,\n+                   constant: &&'tcx ty::Const<'tcx>,\n+                   _: Location) {\n+        self.record(\"Const\", constant);\n+        self.super_const(constant);\n     }\n \n     fn visit_const_usize(&mut self,"}, {"sha": "a9c56309aa8ba9ec1072bd04ef030834321399a0", "filename": "src/librustc_platform_intrinsics/powerpc.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_platform_intrinsics%2Fpowerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_platform_intrinsics%2Fpowerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_platform_intrinsics%2Fpowerpc.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -337,6 +337,66 @@ pub fn find(name: &str) -> Option<Intrinsic> {\n             output: &::I32x4,\n             definition: Named(\"llvm.ppc.altivec.vupkhsh\")\n         },\n+        \"_vec_madds\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::I16x8, &::I16x8, &::I16x8]; &INPUTS },\n+            output: &::I16x8,\n+            definition: Named(\"llvm.ppc.altivec.vmhaddshs\")\n+        },\n+        \"_vec_msumubm\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::U8x16, &::U8x16, &::U32x4]; &INPUTS },\n+            output: &::U32x4,\n+            definition: Named(\"llvm.ppc.altivec.vmsumubm\")\n+        },\n+        \"_vec_msumuhm\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::U16x8, &::U16x8, &::U32x4]; &INPUTS },\n+            output: &::U32x4,\n+            definition: Named(\"llvm.ppc.altivec.vmsumuhm\")\n+        },\n+        \"_vec_msummbm\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::I8x16, &::U8x16, &::I32x4]; &INPUTS },\n+            output: &::I32x4,\n+            definition: Named(\"llvm.ppc.altivec.vmsummbm\")\n+        },\n+        \"_vec_msumshm\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::I16x8, &::I16x8, &::I32x4]; &INPUTS },\n+            output: &::I32x4,\n+            definition: Named(\"llvm.ppc.altivec.vmsumshm\")\n+        },\n+        \"_vec_msumshs\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::I16x8, &::I16x8, &::I32x4]; &INPUTS },\n+            output: &::I32x4,\n+            definition: Named(\"llvm.ppc.altivec.vmsumshs\")\n+        },\n+        \"_vec_msumuhs\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::U16x8, &::U16x8, &::U32x4]; &INPUTS },\n+            output: &::U32x4,\n+            definition: Named(\"llvm.ppc.altivec.vmsumuhs\")\n+        },\n+        \"_vec_sum2s\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I32x4, &::I32x4]; &INPUTS },\n+            output: &::I32x4,\n+            definition: Named(\"llvm.ppc.altivec.vsum2sws\")\n+        },\n+        \"_vec_sum4sbs\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I8x16, &::I32x4]; &INPUTS },\n+            output: &::I32x4,\n+            definition: Named(\"llvm.ppc.altivec.vsum4sbs\")\n+        },\n+        \"_vec_sum4ubs\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U8x16, &::U32x4]; &INPUTS },\n+            output: &::U32x4,\n+            definition: Named(\"llvm.ppc.altivec.vsum4ubs\")\n+        },\n+        \"_vec_sum4shs\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x8, &::I32x4]; &INPUTS },\n+            output: &::I32x4,\n+            definition: Named(\"llvm.ppc.altivec.vsum4shs\")\n+        },\n+        \"_vec_sums\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I32x4, &::I32x4]; &INPUTS },\n+            output: &::I32x4,\n+            definition: Named(\"llvm.ppc.altivec.vsumsws\")\n+        },\n         _ => return None,\n     })\n }"}, {"sha": "0d5ad6f47c9ad8a927685e14768649031b239f9e", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -325,8 +325,8 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n         // This code is here instead of in visit_item so that the\n         // crate module gets processed as well.\n         if self.prev_level.is_some() {\n-            let hir_id = self.tcx.hir.node_to_hir_id(id);\n-            if let Some(exports) = self.tcx.module_exports(hir_id) {\n+            let def_id = self.tcx.hir.local_def_id(id);\n+            if let Some(exports) = self.tcx.module_exports(def_id) {\n                 for export in exports.iter() {\n                     if let Some(node_id) = self.tcx.hir.as_local_node_id(export.def.def_id()) {\n                         self.update(node_id, Some(AccessLevel::Exported));\n@@ -630,7 +630,7 @@ impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n                 };\n                 ty::Visibility::from_hir(vis, node_id, self.tcx)\n             }\n-            None => self.tcx.sess.cstore.visibility(did),\n+            None => self.tcx.visibility(did),\n         }\n     }\n "}, {"sha": "a4d1ae162157180509ec3a380146e278a3b8785c", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -42,6 +42,7 @@ use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n use syntax::parse::token;\n use syntax::symbol::keywords;\n+use syntax::symbol::Symbol;\n use syntax::visit::{self, Visitor};\n \n use syntax_pos::{Span, DUMMY_SP};\n@@ -253,7 +254,7 @@ impl<'a> Resolver<'a> {\n                 self.crate_loader.process_item(item, &self.definitions);\n \n                 // n.b. we don't need to look at the path option here, because cstore already did\n-                let crate_id = self.session.cstore.extern_mod_stmt_cnum(item.id).unwrap();\n+                let crate_id = self.cstore.extern_mod_stmt_cnum_untracked(item.id).unwrap();\n                 let module =\n                     self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX });\n                 self.populate_module_if_necessary(module);\n@@ -449,7 +450,7 @@ impl<'a> Resolver<'a> {\n         let ident = child.ident;\n         let def = child.def;\n         let def_id = def.def_id();\n-        let vis = self.session.cstore.visibility(def_id);\n+        let vis = self.cstore.visibility_untracked(def_id);\n         let span = child.span;\n         let expansion = Mark::root(); // FIXME(jseyfried) intercrate hygiene\n         match def {\n@@ -471,7 +472,7 @@ impl<'a> Resolver<'a> {\n                 self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, expansion));\n \n                 if let Some(struct_def_id) =\n-                        self.session.cstore.def_key(def_id).parent\n+                        self.cstore.def_key(def_id).parent\n                             .map(|index| DefId { krate: def_id.krate, index: index }) {\n                     self.struct_constructors.insert(struct_def_id, (def, vis));\n                 }\n@@ -485,12 +486,12 @@ impl<'a> Resolver<'a> {\n                                              span);\n                 self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, expansion));\n \n-                for child in self.session.cstore.item_children(def_id, self.session) {\n+                for child in self.cstore.item_children_untracked(def_id, self.session) {\n                     let ns = if let Def::AssociatedTy(..) = child.def { TypeNS } else { ValueNS };\n                     self.define(module, child.ident, ns,\n                                 (child.def, ty::Visibility::Public, DUMMY_SP, expansion));\n \n-                    if self.session.cstore.associated_item_cloned(child.def.def_id())\n+                    if self.cstore.associated_item_cloned_untracked(child.def.def_id())\n                            .method_has_self_argument {\n                         self.has_self.insert(child.def.def_id());\n                     }\n@@ -501,7 +502,7 @@ impl<'a> Resolver<'a> {\n                 self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, expansion));\n \n                 // Record field names for error reporting.\n-                let field_names = self.session.cstore.struct_field_names(def_id);\n+                let field_names = self.cstore.struct_field_names_untracked(def_id);\n                 self.insert_field_names(def_id, field_names);\n             }\n             Def::Macro(..) => {\n@@ -516,20 +517,20 @@ impl<'a> Resolver<'a> {\n             return self.module_map[&def_id]\n         }\n \n-        let macros_only = self.session.cstore.dep_kind(def_id.krate).macros_only();\n+        let macros_only = self.cstore.dep_kind_untracked(def_id.krate).macros_only();\n         if let Some(&module) = self.extern_module_map.get(&(def_id, macros_only)) {\n             return module;\n         }\n \n         let (name, parent) = if def_id.index == CRATE_DEF_INDEX {\n-            (self.session.cstore.crate_name(def_id.krate), None)\n+            (self.cstore.crate_name_untracked(def_id.krate).as_str(), None)\n         } else {\n-            let def_key = self.session.cstore.def_key(def_id);\n+            let def_key = self.cstore.def_key(def_id);\n             (def_key.disambiguated_data.data.get_opt_name().unwrap(),\n              Some(self.get_module(DefId { index: def_key.parent.unwrap(), ..def_id })))\n         };\n \n-        let kind = ModuleKind::Def(Def::Mod(def_id), name);\n+        let kind = ModuleKind::Def(Def::Mod(def_id), Symbol::intern(&name));\n         let module =\n             self.arenas.alloc_module(ModuleData::new(parent, kind, def_id, Mark::root(), DUMMY_SP));\n         self.extern_module_map.insert((def_id, macros_only), module);\n@@ -558,7 +559,7 @@ impl<'a> Resolver<'a> {\n             return ext.clone();\n         }\n \n-        let macro_def = match self.session.cstore.load_macro(def_id, &self.session) {\n+        let macro_def = match self.cstore.load_macro_untracked(def_id, &self.session) {\n             LoadedMacro::MacroDef(macro_def) => macro_def,\n             LoadedMacro::ProcMacro(ext) => return ext,\n         };\n@@ -574,7 +575,8 @@ impl<'a> Resolver<'a> {\n     /// is built, building it if it is not.\n     pub fn populate_module_if_necessary(&mut self, module: Module<'a>) {\n         if module.populated.get() { return }\n-        for child in self.session.cstore.item_children(module.def_id().unwrap(), self.session) {\n+        let def_id = module.def_id().unwrap();\n+        for child in self.cstore.item_children_untracked(def_id, self.session) {\n             self.build_reduced_graph_for_external_crate_def(module, child);\n         }\n         module.populated.set(true)\n@@ -605,7 +607,8 @@ impl<'a> Resolver<'a> {\n             span_err!(self.session, item.span, E0468,\n                       \"an `extern crate` loading macros must be at the crate root\");\n         } else if !self.use_extern_macros && !used &&\n-                  self.session.cstore.dep_kind(module.def_id().unwrap().krate).macros_only() {\n+                  self.cstore.dep_kind_untracked(module.def_id().unwrap().krate)\n+                      .macros_only() {\n             let msg = \"proc macro crates and `#[no_link]` crates have no effect without \\\n                        `#[macro_use]`\";\n             self.session.span_warn(item.span, msg);\n@@ -648,7 +651,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n         for (name, span) in legacy_imports.reexports {\n-            self.session.cstore.export_macros(module.def_id().unwrap().krate);\n+            self.cstore.export_macros_untracked(module.def_id().unwrap().krate);\n             let ident = Ident::with_empty_ctxt(name);\n             let result = self.resolve_ident_in_module(module, ident, MacroNS, false, false, span);\n             if let Ok(binding) = result {"}, {"sha": "691329c608c978a78f98731c7d1d6ba48cd06ce4", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -31,7 +31,7 @@ use self::RibKind::*;\n \n use rustc::hir::map::{Definitions, DefCollector};\n use rustc::hir::{self, PrimTy, TyBool, TyChar, TyFloat, TyInt, TyUint, TyStr};\n-use rustc::middle::cstore::CrateLoader;\n+use rustc::middle::cstore::{CrateStore, CrateLoader};\n use rustc::session::Session;\n use rustc::lint;\n use rustc::hir::def::*;\n@@ -1176,6 +1176,7 @@ impl PrimitiveTypeTable {\n /// The main resolver class.\n pub struct Resolver<'a> {\n     session: &'a Session,\n+    cstore: &'a CrateStore,\n \n     pub definitions: Definitions,\n \n@@ -1343,7 +1344,7 @@ impl<'a, 'b: 'a> ty::DefIdTree for &'a Resolver<'b> {\n     fn parent(self, id: DefId) -> Option<DefId> {\n         match id.krate {\n             LOCAL_CRATE => self.definitions.def_key(id.index).parent,\n-            _ => self.session.cstore.def_key(id).parent,\n+            _ => self.cstore.def_key(id).parent,\n         }.map(|index| DefId { index: index, ..id })\n     }\n }\n@@ -1383,6 +1384,7 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n \n impl<'a> Resolver<'a> {\n     pub fn new(session: &'a Session,\n+               cstore: &'a CrateStore,\n                krate: &Crate,\n                crate_name: &str,\n                make_glob_map: MakeGlobMap,\n@@ -1414,6 +1416,8 @@ impl<'a> Resolver<'a> {\n         Resolver {\n             session,\n \n+            cstore,\n+\n             definitions,\n \n             // The outermost module has def ID 0; this is not reflected in the\n@@ -1443,7 +1447,7 @@ impl<'a> Resolver<'a> {\n             def_map: NodeMap(),\n             freevars: NodeMap(),\n             freevars_seen: NodeMap(),\n-            export_map: NodeMap(),\n+            export_map: FxHashMap(),\n             trait_map: NodeMap(),\n             module_map,\n             block_map: NodeMap(),\n@@ -2291,7 +2295,7 @@ impl<'a> Resolver<'a> {\n         // must not add it if it's in the bindings map\n         // because that breaks the assumptions later\n         // passes make about or-patterns.)\n-        let mut def = Def::Local(self.definitions.local_def_id(pat_id));\n+        let mut def = Def::Local(pat_id);\n         match bindings.get(&ident.node).cloned() {\n             Some(id) if id == outer_pat_id => {\n                 // `Variant(a, a)`, error\n@@ -2946,7 +2950,7 @@ impl<'a> Resolver<'a> {\n             Def::Upvar(..) => {\n                 span_bug!(span, \"unexpected {:?} in bindings\", def)\n             }\n-            Def::Local(def_id) => {\n+            Def::Local(node_id) => {\n                 for rib in ribs {\n                     match rib.kind {\n                         NormalRibKind | ModuleRibKind(..) | MacroDefinition(..) |\n@@ -2955,20 +2959,19 @@ impl<'a> Resolver<'a> {\n                         }\n                         ClosureRibKind(function_id) => {\n                             let prev_def = def;\n-                            let node_id = self.definitions.as_local_node_id(def_id).unwrap();\n \n                             let seen = self.freevars_seen\n                                            .entry(function_id)\n                                            .or_insert_with(|| NodeMap());\n                             if let Some(&index) = seen.get(&node_id) {\n-                                def = Def::Upvar(def_id, index, function_id);\n+                                def = Def::Upvar(node_id, index, function_id);\n                                 continue;\n                             }\n                             let vec = self.freevars\n                                           .entry(function_id)\n                                           .or_insert_with(|| vec![]);\n                             let depth = vec.len();\n-                            def = Def::Upvar(def_id, depth, function_id);\n+                            def = Def::Upvar(node_id, depth, function_id);\n \n                             if record_used {\n                                 vec.push(Freevar {\n@@ -3043,7 +3046,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         // Fields are generally expected in the same contexts as locals.\n-        if filter_fn(Def::Local(DefId::local(CRATE_DEF_INDEX))) {\n+        if filter_fn(Def::Local(ast::DUMMY_NODE_ID)) {\n             if let Some(node_id) = self.current_self_type.as_ref().and_then(extract_node_id) {\n                 // Look for a field with the same name in the current self_type.\n                 if let Some(resolution) = self.def_map.get(&node_id) {"}, {"sha": "064032b888499abb77d13451e8c2c4967dee59c8", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -778,7 +778,7 @@ impl<'a> Resolver<'a> {\n             _ => return,\n         };\n \n-        let crate_name = self.session.cstore.crate_name(krate);\n+        let crate_name = self.cstore.crate_name_untracked(krate);\n \n         self.session.struct_span_err(use_span, warn_msg)\n             .help(&format!(\"instead, import the procedural macro like any other item: \\"}, {"sha": "b85bf18ea800c4fec42d0a7947aa566c4d49d3e6", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -844,7 +844,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 let def = binding.def();\n                 if def != Def::Err {\n                     if !def.def_id().is_local() {\n-                        self.session.cstore.export_macros(def.def_id().krate);\n+                        self.cstore.export_macros_untracked(def.def_id().krate);\n                     }\n                     if let Def::Macro(..) = def {\n                         if let Some(&span) = exported_macro_names.get(&ident.modern()) {\n@@ -892,8 +892,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n \n         if reexports.len() > 0 {\n             if let Some(def_id) = module.def_id() {\n-                let node_id = self.definitions.as_local_node_id(def_id).unwrap();\n-                self.export_map.insert(node_id, reexports);\n+                self.export_map.insert(def_id, reexports);\n             }\n         }\n     }"}, {"sha": "3e730cf836523ac4291a5eabd5ff3c1fbe977335", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -1432,8 +1432,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n         // process collected paths\n         for &(id, ref p, immut) in &collector.collected_paths {\n             match self.save_ctxt.get_path_def(id) {\n-                HirDef::Local(def_id) => {\n-                    let id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n+                HirDef::Local(id) => {\n                     let mut value = if immut == ast::Mutability::Immutable {\n                         self.span.snippet(p.span).to_string()\n                     } else {"}, {"sha": "1c6007966afa3a5614c4336a7428e2a69eb1d856", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -38,7 +38,7 @@ mod sig;\n use rustc::hir;\n use rustc::hir::def::Def as HirDef;\n use rustc::hir::map::{Node, NodeItem};\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{LOCAL_CRATE, DefId};\n use rustc::session::config::CrateType::CrateTypeExecutable;\n use rustc::ty::{self, TyCtxt};\n use rustc_typeck::hir_ty_to_ty;\n@@ -109,7 +109,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     pub fn get_external_crates(&self) -> Vec<ExternalCrateData> {\n         let mut result = Vec::new();\n \n-        for n in self.tcx.sess.cstore.crates() {\n+        for &n in self.tcx.crates().iter() {\n             let span = match *self.tcx.extern_crate(n.as_def_id()) {\n                 Some(ref c) => c.span,\n                 None => {\n@@ -119,7 +119,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             };\n             let lo_loc = self.span_utils.sess.codemap().lookup_char_pos(span.lo());\n             result.push(ExternalCrateData {\n-                name: self.tcx.sess.cstore.crate_name(n).to_string(),\n+                name: self.tcx.crate_name(n).to_string(),\n                 num: n.as_u32(),\n                 file_name: SpanUtils::make_path_string(&lo_loc.file.name),\n             });\n@@ -586,9 +586,9 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 self.tables.qpath_def(qpath, hir_id)\n             }\n \n-            Node::NodeBinding(&hir::Pat { node: hir::PatKind::Binding(_, def_id, ..), .. }) => {\n-                HirDef::Local(def_id)\n-            }\n+            Node::NodeBinding(&hir::Pat {\n+                node: hir::PatKind::Binding(_, canonical_id, ..), ..\n+            }) => HirDef::Local(canonical_id),\n \n             Node::NodeTy(ty) => {\n                 if let hir::Ty { node: hir::TyPath(ref qpath), .. } = *ty {\n@@ -616,8 +616,15 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         let sub_span = self.span_utils.span_for_last_ident(path.span);\n         filter!(self.span_utils, sub_span, path.span, None);\n         match def {\n-            HirDef::Upvar(..) |\n-            HirDef::Local(..) |\n+            HirDef::Upvar(id, ..) |\n+            HirDef::Local(id) => {\n+                let span = self.span_from_span(sub_span.unwrap());\n+                Some(Ref {\n+                    kind: RefKind::Variable,\n+                    span,\n+                    ref_id: id_from_node_id(id, self),\n+                })\n+            }\n             HirDef::Static(..) |\n             HirDef::Const(..) |\n             HirDef::AssociatedConst(..) |\n@@ -1013,7 +1020,15 @@ fn id_from_def_id(id: DefId) -> rls_data::Id {\n \n fn id_from_node_id(id: NodeId, scx: &SaveContext) -> rls_data::Id {\n     let def_id = scx.tcx.hir.opt_local_def_id(id);\n-    def_id.map(|id| id_from_def_id(id)).unwrap_or_else(null_id)\n+    def_id.map(|id| id_from_def_id(id)).unwrap_or_else(|| {\n+        // Create a *fake* `DefId` out of a `NodeId` by subtracting the `NodeId`\n+        // out of the maximum u32 value. This will work unless you have *billions*\n+        // of definitions in a single crate (very unlikely to actually happen).\n+        rls_data::Id {\n+            krate: LOCAL_CRATE.as_u32(),\n+            index: !id.as_u32(),\n+        }\n+    })\n }\n \n fn null_id() -> rls_data::Id {"}, {"sha": "4211c8df5ca0385dd8ae27112ec42bc442cc65fb", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -11,7 +11,7 @@\n use llvm::{self, ValueRef, AttributePlace};\n use base;\n use builder::Builder;\n-use common::{instance_ty, ty_fn_sig, type_is_fat_ptr, C_uint};\n+use common::{instance_ty, ty_fn_sig, type_is_fat_ptr, C_usize};\n use context::CrateContext;\n use cabi_x86;\n use cabi_x86_64;\n@@ -527,7 +527,7 @@ impl<'a, 'tcx> ArgType<'tcx> {\n         }\n         let ccx = bcx.ccx;\n         if self.is_indirect() {\n-            let llsz = C_uint(ccx, self.layout.size(ccx).bytes());\n+            let llsz = C_usize(ccx, self.layout.size(ccx).bytes());\n             let llalign = self.layout.align(ccx).abi();\n             base::call_memcpy(bcx, dst, val, llsz, llalign as u32);\n         } else if let Some(ty) = self.cast {\n@@ -564,7 +564,7 @@ impl<'a, 'tcx> ArgType<'tcx> {\n                 base::call_memcpy(bcx,\n                                   bcx.pointercast(dst, Type::i8p(ccx)),\n                                   bcx.pointercast(llscratch, Type::i8p(ccx)),\n-                                  C_uint(ccx, self.layout.size(ccx).bytes()),\n+                                  C_usize(ccx, self.layout.size(ccx).bytes()),\n                                   cmp::min(self.layout.align(ccx).abi() as u32,\n                                            llalign_of_min(ccx, ty)));\n "}, {"sha": "23a45a7962abfacf6c5cbffa7ddce260d0eaa1ee", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -397,11 +397,11 @@ pub fn trans_set_discr<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, val: Valu\n     match *l {\n         layout::CEnum{ discr, min, max, .. } => {\n             assert_discr_in_range(min, max, to);\n-            bcx.store(C_integral(Type::from_integer(bcx.ccx, discr), to, true),\n+            bcx.store(C_int(Type::from_integer(bcx.ccx, discr), to as i64),\n                   val, None);\n         }\n         layout::General{ discr, .. } => {\n-            bcx.store(C_integral(Type::from_integer(bcx.ccx, discr), to, true),\n+            bcx.store(C_int(Type::from_integer(bcx.ccx, discr), to as i64),\n                   bcx.struct_gep(val, 0), None);\n         }\n         layout::Univariant { .. }\n@@ -423,7 +423,7 @@ pub fn trans_set_discr<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, val: Valu\n                     // than storing null to single target field.\n                     let llptr = bcx.pointercast(val, Type::i8(bcx.ccx).ptr_to());\n                     let fill_byte = C_u8(bcx.ccx, 0);\n-                    let size = C_uint(bcx.ccx, nonnull.stride().bytes());\n+                    let size = C_usize(bcx.ccx, nonnull.stride().bytes());\n                     let align = C_i32(bcx.ccx, nonnull.align.abi() as i32);\n                     base::call_memset(bcx, llptr, fill_byte, size, align, false);\n                 } else {"}, {"sha": "ea68e3b28b668e8047630f476b673c51fc0ec071", "filename": "src/librustc_trans/back/command.rs", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fback%2Fcommand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fback%2Fcommand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fcommand.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -0,0 +1,114 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A thin wrapper around `Command` in the standard library which allows us to\n+//! read the arguments that are built up.\n+\n+use std::ffi::{OsStr, OsString};\n+use std::fmt;\n+use std::io;\n+use std::process::{self, Output, Child};\n+\n+pub struct Command {\n+    program: OsString,\n+    args: Vec<OsString>,\n+    env: Vec<(OsString, OsString)>,\n+}\n+\n+impl Command {\n+    pub fn new<P: AsRef<OsStr>>(program: P) -> Command {\n+        Command::_new(program.as_ref())\n+    }\n+\n+    fn _new(program: &OsStr) -> Command {\n+        Command {\n+            program: program.to_owned(),\n+            args: Vec::new(),\n+            env: Vec::new(),\n+        }\n+    }\n+\n+    pub fn arg<P: AsRef<OsStr>>(&mut self, arg: P) -> &mut Command {\n+        self._arg(arg.as_ref());\n+        self\n+    }\n+\n+    pub fn args<I>(&mut self, args: I) -> &mut Command\n+        where I: IntoIterator,\n+              I::Item: AsRef<OsStr>,\n+    {\n+        for arg in args {\n+            self._arg(arg.as_ref());\n+        }\n+        self\n+    }\n+\n+    fn _arg(&mut self, arg: &OsStr) {\n+        self.args.push(arg.to_owned());\n+    }\n+\n+    pub fn env<K, V>(&mut self, key: K, value: V) -> &mut Command\n+        where K: AsRef<OsStr>,\n+              V: AsRef<OsStr>\n+    {\n+        self._env(key.as_ref(), value.as_ref());\n+        self\n+    }\n+\n+    pub fn envs<I, K, V>(&mut self, envs: I) -> &mut Command\n+        where I: IntoIterator<Item=(K, V)>,\n+              K: AsRef<OsStr>,\n+              V: AsRef<OsStr>\n+    {\n+        for (key, value) in envs {\n+            self._env(key.as_ref(), value.as_ref());\n+        }\n+        self\n+    }\n+\n+    fn _env(&mut self, key: &OsStr, value: &OsStr) {\n+        self.env.push((key.to_owned(), value.to_owned()));\n+    }\n+\n+    pub fn output(&mut self) -> io::Result<Output> {\n+        self.command().output()\n+    }\n+\n+    pub fn spawn(&mut self) -> io::Result<Child> {\n+        self.command().spawn()\n+    }\n+\n+    pub fn command(&self) -> process::Command {\n+        let mut ret = process::Command::new(&self.program);\n+        ret.args(&self.args);\n+        ret.envs(self.env.clone());\n+        return ret\n+    }\n+\n+    // extensions\n+\n+    pub fn get_program(&self) -> &OsStr {\n+        &self.program\n+    }\n+\n+    pub fn get_args(&self) -> &[OsString] {\n+        &self.args\n+    }\n+\n+    pub fn get_env(&self) -> &[(OsString, OsString)] {\n+        &self.env\n+    }\n+}\n+\n+impl fmt::Debug for Command {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.command().fmt(f)\n+    }\n+}"}, {"sha": "efb56ab5a6cac64231d53b5b5915d0629a33c280", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 167, "deletions": 54, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -12,17 +12,17 @@ extern crate rustc_trans_utils;\n \n use super::archive::{ArchiveBuilder, ArchiveConfig};\n use super::linker::Linker;\n+use super::command::Command;\n use super::rpath::RPathConfig;\n use super::rpath;\n use metadata::METADATA_FILENAME;\n use rustc::session::config::{self, NoDebugInfo, OutputFilenames, OutputType, PrintRequest};\n use rustc::session::filesearch;\n use rustc::session::search_paths::PathKind;\n use rustc::session::Session;\n-use rustc::middle::cstore::{LinkMeta, NativeLibrary, LibSource, LinkagePreference,\n-                            NativeLibraryKind};\n+use rustc::middle::cstore::{LinkMeta, NativeLibrary, LibSource, NativeLibraryKind};\n use rustc::middle::dependency_format::Linkage;\n-use CrateTranslation;\n+use {CrateTranslation, CrateInfo};\n use rustc::util::common::time;\n use rustc::util::fs::fix_windows_verbatim_for_gcc;\n use rustc::dep_graph::{DepKind, DepNode};\n@@ -38,11 +38,12 @@ use std::ascii;\n use std::char;\n use std::env;\n use std::ffi::OsString;\n-use std::fs;\n-use std::io::{self, Read, Write};\n+use std::fmt;\n+use std::fs::{self, File};\n+use std::io::{self, Read, Write, BufWriter};\n use std::mem;\n use std::path::{Path, PathBuf};\n-use std::process::Command;\n+use std::process::{Output, Stdio};\n use std::str;\n use flate2::Compression;\n use flate2::write::DeflateEncoder;\n@@ -125,8 +126,13 @@ pub fn msvc_link_exe_cmd(sess: &Session) -> (Command, Vec<(OsString, OsString)>)\n     let tool = windows_registry::find_tool(target, \"link.exe\");\n \n     if let Some(tool) = tool {\n+        let mut cmd = Command::new(tool.path());\n+        cmd.args(tool.args());\n+        for &(ref k, ref v) in tool.env() {\n+            cmd.env(k, v);\n+        }\n         let envs = tool.env().to_vec();\n-        (tool.to_command(), envs)\n+        (cmd, envs)\n     } else {\n         debug!(\"Failed to locate linker.\");\n         (Command::new(\"link.exe\"), vec![])\n@@ -179,7 +185,11 @@ pub fn link_binary(sess: &Session,\n            bug!(\"invalid output type `{:?}` for target os `{}`\",\n                 crate_type, sess.opts.target_triple);\n         }\n-        let mut out_files = link_binary_output(sess, trans, crate_type, outputs, crate_name);\n+        let mut out_files = link_binary_output(sess,\n+                                               trans,\n+                                               crate_type,\n+                                               outputs,\n+                                               crate_name);\n         out_filenames.append(&mut out_files);\n     }\n \n@@ -216,8 +226,9 @@ fn filename_for_metadata(sess: &Session, crate_name: &str, outputs: &OutputFilen\n }\n \n pub fn each_linked_rlib(sess: &Session,\n+                        info: &CrateInfo,\n                         f: &mut FnMut(CrateNum, &Path)) -> Result<(), String> {\n-    let crates = sess.cstore.used_crates(LinkagePreference::RequireStatic).into_iter();\n+    let crates = info.used_crates_static.iter();\n     let fmts = sess.dependency_formats.borrow();\n     let fmts = fmts.get(&config::CrateTypeExecutable)\n                    .or_else(|| fmts.get(&config::CrateTypeStaticlib))\n@@ -227,16 +238,16 @@ pub fn each_linked_rlib(sess: &Session,\n         Some(f) => f,\n         None => return Err(format!(\"could not find formats for rlibs\"))\n     };\n-    for (cnum, path) in crates {\n+    for &(cnum, ref path) in crates {\n         match fmts.get(cnum.as_usize() - 1) {\n             Some(&Linkage::NotLinked) |\n             Some(&Linkage::IncludedFromDylib) => continue,\n             Some(_) => {}\n             None => return Err(format!(\"could not find formats for rlibs\"))\n         }\n-        let name = sess.cstore.crate_name(cnum).clone();\n-        let path = match path {\n-            LibSource::Some(p) => p,\n+        let name = &info.crate_name[&cnum];\n+        let path = match *path {\n+            LibSource::Some(ref p) => p,\n             LibSource::MetadataOnly => {\n                 return Err(format!(\"could not find rlib for: `{}`, found rmeta (metadata) file\",\n                                    name))\n@@ -260,12 +271,12 @@ pub fn each_linked_rlib(sess: &Session,\n /// It's unusual for a crate to not participate in LTO. Typically only\n /// compiler-specific and unstable crates have a reason to not participate in\n /// LTO.\n-pub fn ignored_for_lto(sess: &Session, cnum: CrateNum) -> bool {\n+pub fn ignored_for_lto(info: &CrateInfo, cnum: CrateNum) -> bool {\n     // `#![no_builtins]` crates don't participate in LTO because the state\n     // of builtins gets messed up (our crate isn't tagged with no builtins).\n     // Similarly `#![compiler_builtins]` doesn't participate because we want\n     // those builtins!\n-    sess.cstore.is_no_builtins(cnum) || sess.cstore.is_compiler_builtins(cnum)\n+    info.is_no_builtins.contains(&cnum) || info.compiler_builtins == Some(cnum)\n }\n \n fn out_filename(sess: &Session,\n@@ -339,8 +350,8 @@ fn link_binary_output(sess: &Session,\n                                tmpdir.path());\n             }\n             _ => {\n-                link_natively(sess, crate_type, &objects, &out_filename, trans,\n-                              outputs, tmpdir.path());\n+                link_natively(sess, crate_type, &objects, &out_filename,\n+                              trans, outputs, tmpdir.path());\n             }\n         }\n         out_filenames.push(out_filename);\n@@ -431,7 +442,7 @@ fn link_rlib<'a>(sess: &'a Session,\n     // feature then we'll need to figure out how to record what objects were\n     // loaded from the libraries found here and then encode that into the\n     // metadata of the rlib we're generating somehow.\n-    for lib in sess.cstore.used_libraries() {\n+    for lib in trans.crate_info.used_libraries.iter() {\n         match lib.kind {\n             NativeLibraryKind::NativeStatic => {}\n             NativeLibraryKind::NativeStaticNobundle |\n@@ -611,9 +622,9 @@ fn link_staticlib(sess: &Session,\n                            tempdir);\n     let mut all_native_libs = vec![];\n \n-    let res = each_linked_rlib(sess, &mut |cnum, path| {\n-        let name = sess.cstore.crate_name(cnum);\n-        let native_libs = sess.cstore.native_libraries(cnum);\n+    let res = each_linked_rlib(sess, &trans.crate_info, &mut |cnum, path| {\n+        let name = &trans.crate_info.crate_name[&cnum];\n+        let native_libs = &trans.crate_info.native_libraries[&cnum];\n \n         // Here when we include the rlib into our staticlib we need to make a\n         // decision whether to include the extra object files along the way.\n@@ -634,10 +645,10 @@ fn link_staticlib(sess: &Session,\n         });\n         ab.add_rlib(path,\n                     &name.as_str(),\n-                    sess.lto() && !ignored_for_lto(sess, cnum),\n+                    sess.lto() && !ignored_for_lto(&trans.crate_info, cnum),\n                     skip_object_files).unwrap();\n \n-        all_native_libs.extend(sess.cstore.native_libraries(cnum));\n+        all_native_libs.extend(trans.crate_info.native_libraries[&cnum].iter().cloned());\n     });\n     if let Err(e) = res {\n         sess.fatal(&e);\n@@ -797,7 +808,9 @@ fn link_natively(sess: &Session,\n     let mut i = 0;\n     loop {\n         i += 1;\n-        prog = time(sess.time_passes(), \"running linker\", || cmd.output());\n+        prog = time(sess.time_passes(), \"running linker\", || {\n+            exec_linker(sess, &mut cmd, tmpdir)\n+        });\n         if !retry_on_segfault || i > 3 {\n             break\n         }\n@@ -875,6 +888,98 @@ fn link_natively(sess: &Session,\n     }\n }\n \n+fn exec_linker(sess: &Session, cmd: &mut Command, tmpdir: &Path)\n+    -> io::Result<Output>\n+{\n+    // When attempting to spawn the linker we run a risk of blowing out the\n+    // size limits for spawning a new process with respect to the arguments\n+    // we pass on the command line.\n+    //\n+    // Here we attempt to handle errors from the OS saying \"your list of\n+    // arguments is too big\" by reinvoking the linker again with an `@`-file\n+    // that contains all the arguments. The theory is that this is then\n+    // accepted on all linkers and the linker will read all its options out of\n+    // there instead of looking at the command line.\n+    match cmd.command().stdout(Stdio::piped()).stderr(Stdio::piped()).spawn() {\n+        Ok(child) => return child.wait_with_output(),\n+        Err(ref e) if command_line_too_big(e) => {}\n+        Err(e) => return Err(e)\n+    }\n+\n+    let file = tmpdir.join(\"linker-arguments\");\n+    let mut cmd2 = Command::new(cmd.get_program());\n+    cmd2.arg(format!(\"@{}\", file.display()));\n+    for &(ref k, ref v) in cmd.get_env() {\n+        cmd2.env(k, v);\n+    }\n+    let mut f = BufWriter::new(File::create(&file)?);\n+    for arg in cmd.get_args() {\n+        writeln!(f, \"{}\", Escape {\n+            arg: arg.to_str().unwrap(),\n+            is_like_msvc: sess.target.target.options.is_like_msvc,\n+        })?;\n+    }\n+    f.into_inner()?;\n+    return cmd2.output();\n+\n+    #[cfg(unix)]\n+    fn command_line_too_big(err: &io::Error) -> bool {\n+        err.raw_os_error() == Some(::libc::E2BIG)\n+    }\n+\n+    #[cfg(windows)]\n+    fn command_line_too_big(err: &io::Error) -> bool {\n+        const ERROR_FILENAME_EXCED_RANGE: i32 = 206;\n+        err.raw_os_error() == Some(ERROR_FILENAME_EXCED_RANGE)\n+    }\n+\n+    struct Escape<'a> {\n+        arg: &'a str,\n+        is_like_msvc: bool,\n+    }\n+\n+    impl<'a> fmt::Display for Escape<'a> {\n+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+            if self.is_like_msvc {\n+                // This is \"documented\" at\n+                // https://msdn.microsoft.com/en-us/library/4xdcbak7.aspx\n+                //\n+                // Unfortunately there's not a great specification of the\n+                // syntax I could find online (at least) but some local\n+                // testing showed that this seemed sufficient-ish to catch\n+                // at least a few edge cases.\n+                write!(f, \"\\\"\")?;\n+                for c in self.arg.chars() {\n+                    match c {\n+                        '\"' => write!(f, \"\\\\{}\", c)?,\n+                        c => write!(f, \"{}\", c)?,\n+                    }\n+                }\n+                write!(f, \"\\\"\")?;\n+            } else {\n+                // This is documented at https://linux.die.net/man/1/ld, namely:\n+                //\n+                // > Options in file are separated by whitespace. A whitespace\n+                // > character may be included in an option by surrounding the\n+                // > entire option in either single or double quotes. Any\n+                // > character (including a backslash) may be included by\n+                // > prefixing the character to be included with a backslash.\n+                //\n+                // We put an argument on each line, so all we need to do is\n+                // ensure the line is interpreted as one whole argument.\n+                for c in self.arg.chars() {\n+                    match c {\n+                        '\\\\' |\n+                        ' ' => write!(f, \"\\\\{}\", c)?,\n+                        c => write!(f, \"{}\", c)?,\n+                    }\n+                }\n+            }\n+            Ok(())\n+        }\n+    }\n+}\n+\n fn link_args(cmd: &mut Linker,\n              sess: &Session,\n              crate_type: config::CrateType,\n@@ -930,7 +1035,7 @@ fn link_args(cmd: &mut Linker,\n         cmd.gc_sections(keep_metadata);\n     }\n \n-    let used_link_args = sess.cstore.used_link_args();\n+    let used_link_args = &trans.crate_info.link_args;\n \n     if crate_type == config::CrateTypeExecutable &&\n        t.options.position_independent_executables {\n@@ -1000,9 +1105,9 @@ fn link_args(cmd: &mut Linker,\n     // link line. And finally upstream native libraries can't depend on anything\n     // in this DAG so far because they're only dylibs and dylibs can only depend\n     // on other dylibs (e.g. other native deps).\n-    add_local_native_libraries(cmd, sess);\n-    add_upstream_rust_crates(cmd, sess, crate_type, tmpdir);\n-    add_upstream_native_libraries(cmd, sess, crate_type);\n+    add_local_native_libraries(cmd, sess, trans);\n+    add_upstream_rust_crates(cmd, sess, trans, crate_type, tmpdir);\n+    add_upstream_native_libraries(cmd, sess, trans, crate_type);\n \n     // Tell the linker what we're doing.\n     if crate_type != config::CrateTypeExecutable {\n@@ -1027,7 +1132,7 @@ fn link_args(cmd: &mut Linker,\n             path\n         };\n         let mut rpath_config = RPathConfig {\n-            used_crates: sess.cstore.used_crates(LinkagePreference::RequireDynamic),\n+            used_crates: &trans.crate_info.used_crates_dynamic,\n             out_filename: out_filename.to_path_buf(),\n             has_rpath: sess.target.target.options.has_rpath,\n             is_like_osx: sess.target.target.options.is_like_osx,\n@@ -1057,15 +1162,17 @@ fn link_args(cmd: &mut Linker,\n // Also note that the native libraries linked here are only the ones located\n // in the current crate. Upstream crates with native library dependencies\n // may have their native library pulled in above.\n-fn add_local_native_libraries(cmd: &mut Linker, sess: &Session) {\n+fn add_local_native_libraries(cmd: &mut Linker,\n+                              sess: &Session,\n+                              trans: &CrateTranslation) {\n     sess.target_filesearch(PathKind::All).for_each_lib_search_path(|path, k| {\n         match k {\n             PathKind::Framework => { cmd.framework_path(path); }\n             _ => { cmd.include_path(&fix_windows_verbatim_for_gcc(path)); }\n         }\n     });\n \n-    let relevant_libs = sess.cstore.used_libraries().into_iter().filter(|l| {\n+    let relevant_libs = trans.crate_info.used_libraries.iter().filter(|l| {\n         relevant_lib(sess, l)\n     });\n \n@@ -1088,6 +1195,7 @@ fn add_local_native_libraries(cmd: &mut Linker, sess: &Session) {\n // the intermediate rlib version)\n fn add_upstream_rust_crates(cmd: &mut Linker,\n                             sess: &Session,\n+                            trans: &CrateTranslation,\n                             crate_type: config::CrateType,\n                             tmpdir: &Path) {\n     // All of the heavy lifting has previously been accomplished by the\n@@ -1103,35 +1211,35 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n \n     // Invoke get_used_crates to ensure that we get a topological sorting of\n     // crates.\n-    let deps = sess.cstore.used_crates(LinkagePreference::RequireDynamic);\n+    let deps = &trans.crate_info.used_crates_dynamic;\n \n     let mut compiler_builtins = None;\n \n-    for &(cnum, _) in &deps {\n+    for &(cnum, _) in deps.iter() {\n         // We may not pass all crates through to the linker. Some crates may\n         // appear statically in an existing dylib, meaning we'll pick up all the\n         // symbols from the dylib.\n-        let src = sess.cstore.used_crate_source(cnum);\n+        let src = &trans.crate_info.used_crate_source[&cnum];\n         match data[cnum.as_usize() - 1] {\n-            _ if sess.cstore.is_profiler_runtime(cnum) => {\n-                add_static_crate(cmd, sess, tmpdir, crate_type, cnum);\n+            _ if trans.crate_info.profiler_runtime == Some(cnum) => {\n+                add_static_crate(cmd, sess, trans, tmpdir, crate_type, cnum);\n             }\n-            _ if sess.cstore.is_sanitizer_runtime(cnum) => {\n-                link_sanitizer_runtime(cmd, sess, tmpdir, cnum);\n+            _ if trans.crate_info.sanitizer_runtime == Some(cnum) => {\n+                link_sanitizer_runtime(cmd, sess, trans, tmpdir, cnum);\n             }\n             // compiler-builtins are always placed last to ensure that they're\n             // linked correctly.\n-            _ if sess.cstore.is_compiler_builtins(cnum) => {\n+            _ if trans.crate_info.compiler_builtins == Some(cnum) => {\n                 assert!(compiler_builtins.is_none());\n                 compiler_builtins = Some(cnum);\n             }\n             Linkage::NotLinked |\n             Linkage::IncludedFromDylib => {}\n             Linkage::Static => {\n-                add_static_crate(cmd, sess, tmpdir, crate_type, cnum);\n+                add_static_crate(cmd, sess, trans, tmpdir, crate_type, cnum);\n             }\n             Linkage::Dynamic => {\n-                add_dynamic_crate(cmd, sess, &src.dylib.unwrap().0)\n+                add_dynamic_crate(cmd, sess, &src.dylib.as_ref().unwrap().0)\n             }\n         }\n     }\n@@ -1142,7 +1250,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n     // was already \"included\" in a dylib (e.g. `libstd` when `-C prefer-dynamic`\n     // is used)\n     if let Some(cnum) = compiler_builtins {\n-        add_static_crate(cmd, sess, tmpdir, crate_type, cnum);\n+        add_static_crate(cmd, sess, trans, tmpdir, crate_type, cnum);\n     }\n \n     // Converts a library file-stem into a cc -l argument\n@@ -1160,10 +1268,11 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n     // linking it.\n     fn link_sanitizer_runtime(cmd: &mut Linker,\n                               sess: &Session,\n+                              trans: &CrateTranslation,\n                               tmpdir: &Path,\n                               cnum: CrateNum) {\n-        let src = sess.cstore.used_crate_source(cnum);\n-        let cratepath = &src.rlib.unwrap().0;\n+        let src = &trans.crate_info.used_crate_source[&cnum];\n+        let cratepath = &src.rlib.as_ref().unwrap().0;\n \n         if sess.target.target.options.is_like_osx {\n             // On Apple platforms, the sanitizer is always built as a dylib, and\n@@ -1228,21 +1337,22 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n     // we're at the end of the dependency chain.\n     fn add_static_crate(cmd: &mut Linker,\n                         sess: &Session,\n+                        trans: &CrateTranslation,\n                         tmpdir: &Path,\n                         crate_type: config::CrateType,\n                         cnum: CrateNum) {\n-        let src = sess.cstore.used_crate_source(cnum);\n-        let cratepath = &src.rlib.unwrap().0;\n+        let src = &trans.crate_info.used_crate_source[&cnum];\n+        let cratepath = &src.rlib.as_ref().unwrap().0;\n \n         // See the comment above in `link_staticlib` and `link_rlib` for why if\n         // there's a static library that's not relevant we skip all object\n         // files.\n-        let native_libs = sess.cstore.native_libraries(cnum);\n+        let native_libs = &trans.crate_info.native_libraries[&cnum];\n         let skip_native = native_libs.iter().any(|lib| {\n             lib.kind == NativeLibraryKind::NativeStatic && !relevant_lib(sess, lib)\n         });\n \n-        if (!sess.lto() || ignored_for_lto(sess, cnum)) &&\n+        if (!sess.lto() || ignored_for_lto(&trans.crate_info, cnum)) &&\n            crate_type != config::CrateTypeDylib &&\n            !skip_native {\n             cmd.link_rlib(&fix_windows_verbatim_for_gcc(cratepath));\n@@ -1284,7 +1394,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n                 // LTO module. Note that `#![no_builtins]` is excluded from LTO,\n                 // though, so we let that object file slide.\n                 let skip_because_lto = sess.lto() && is_rust_object &&\n-                                        !sess.cstore.is_no_builtins(cnum);\n+                                        !trans.crate_info.is_no_builtins.contains(&cnum);\n \n                 if skip_because_cfg_say_so || skip_because_lto {\n                     archive.remove_file(&f);\n@@ -1306,7 +1416,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n             // compiler-builtins crate (e.g. compiler-rt) because it'll get\n             // repeatedly linked anyway.\n             if crate_type == config::CrateTypeDylib &&\n-               !sess.cstore.is_compiler_builtins(cnum) {\n+                trans.crate_info.compiler_builtins != Some(cnum) {\n                 cmd.link_whole_rlib(&fix_windows_verbatim_for_gcc(&dst));\n             } else {\n                 cmd.link_rlib(&fix_windows_verbatim_for_gcc(&dst));\n@@ -1350,7 +1460,10 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n // generic function calls a native function, then the generic function must\n // be instantiated in the target crate, meaning that the native symbol must\n // also be resolved in the target crate.\n-fn add_upstream_native_libraries(cmd: &mut Linker, sess: &Session, crate_type: config::CrateType) {\n+fn add_upstream_native_libraries(cmd: &mut Linker,\n+                                 sess: &Session,\n+                                 trans: &CrateTranslation,\n+                                 crate_type: config::CrateType) {\n     // Be sure to use a topological sorting of crates because there may be\n     // interdependencies between native libraries. When passing -nodefaultlibs,\n     // for example, almost all native libraries depend on libc, so we have to\n@@ -1363,9 +1476,9 @@ fn add_upstream_native_libraries(cmd: &mut Linker, sess: &Session, crate_type: c\n     let formats = sess.dependency_formats.borrow();\n     let data = formats.get(&crate_type).unwrap();\n \n-    let crates = sess.cstore.used_crates(LinkagePreference::RequireStatic);\n-    for (cnum, _) in crates {\n-        for lib in sess.cstore.native_libraries(cnum) {\n+    let crates = &trans.crate_info.used_crates_static;\n+    for &(cnum, _) in crates {\n+        for lib in trans.crate_info.native_libraries[&cnum].iter() {\n             if !relevant_lib(sess, &lib) {\n                 continue\n             }"}, {"sha": "487d9e059458c6db2b4eeb63f6f5d8cf4a454256", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -14,11 +14,11 @@ use std::fs::{self, File};\n use std::io::prelude::*;\n use std::io::{self, BufWriter};\n use std::path::{Path, PathBuf};\n-use std::process::Command;\n \n use context::SharedCrateContext;\n \n use back::archive;\n+use back::command::Command;\n use back::symbol_export::ExportedSymbols;\n use rustc::middle::dependency_format::Linkage;\n use rustc::hir::def_id::{LOCAL_CRATE, CrateNum};"}, {"sha": "8e5e7d376488b7df5b69af8b100b736f6fe15a8d", "filename": "src/librustc_trans/back/rpath.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Frpath.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -17,7 +17,7 @@ use rustc::hir::def_id::CrateNum;\n use rustc::middle::cstore::LibSource;\n \n pub struct RPathConfig<'a> {\n-    pub used_crates: Vec<(CrateNum, LibSource)>,\n+    pub used_crates: &'a [(CrateNum, LibSource)],\n     pub out_filename: PathBuf,\n     pub is_like_osx: bool,\n     pub has_rpath: bool,\n@@ -36,7 +36,7 @@ pub fn get_rpath_flags(config: &mut RPathConfig) -> Vec<String> {\n     debug!(\"preparing the RPATH!\");\n \n     let libs = config.used_crates.clone();\n-    let libs = libs.into_iter().filter_map(|(_, l)| l.option()).collect::<Vec<_>>();\n+    let libs = libs.iter().filter_map(|&(_, ref l)| l.option()).collect::<Vec<_>>();\n     let rpaths = get_rpaths(config, &libs);\n     flags.extend_from_slice(&rpaths_to_flags(&rpaths));\n "}, {"sha": "b546059b4c51d1fcbdf7d96eefa0587a2038bcf7", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -110,13 +110,13 @@ impl ExportedSymbols {\n         let mut exports = FxHashMap();\n         exports.insert(LOCAL_CRATE, local_crate);\n \n-        for cnum in tcx.sess.cstore.crates() {\n+        for &cnum in tcx.crates().iter() {\n             debug_assert!(cnum != LOCAL_CRATE);\n \n             // If this crate is a plugin and/or a custom derive crate, then\n             // we're not even going to link those in so we skip those crates.\n-            if tcx.sess.cstore.plugin_registrar_fn(cnum).is_some() ||\n-               tcx.sess.cstore.derive_registrar_fn(cnum).is_some() {\n+            if tcx.plugin_registrar_fn(cnum).is_some() ||\n+               tcx.derive_registrar_fn(cnum).is_some() {\n                 continue;\n             }\n \n@@ -128,12 +128,9 @@ impl ExportedSymbols {\n             // Down below we'll hardwire all of the symbols to the `Rust` export\n             // level instead.\n             let special_runtime_crate =\n-                tcx.is_panic_runtime(cnum.as_def_id()) ||\n-                tcx.sess.cstore.is_compiler_builtins(cnum);\n+                tcx.is_panic_runtime(cnum) || tcx.is_compiler_builtins(cnum);\n \n             let crate_exports = tcx\n-                .sess\n-                .cstore\n                 .exported_symbols(cnum)\n                 .iter()\n                 .map(|&def_id| {"}, {"sha": "abeb2568cbe1eea17f1645ace755b12fa35d7055", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -242,7 +242,7 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n             return name.to_string();\n         }\n         // Don't mangle foreign items.\n-        return tcx.item_name(def_id).as_str().to_string();\n+        return tcx.item_name(def_id).to_string();\n     }\n \n     if let Some(name) = attr::find_export_name_attr(tcx.sess.diagnostic(), &attrs) {\n@@ -252,7 +252,7 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n \n     if attr::contains_name(&attrs, \"no_mangle\") {\n         // Don't mangle\n-        return tcx.item_name(def_id).as_str().to_string();\n+        return tcx.item_name(def_id).to_string();\n     }\n \n     // We want to compute the \"type\" of this item. Unfortunately, some"}, {"sha": "72e1fc34789540b7e055f4f4ae66da7ff69521ba", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -22,6 +22,7 @@ use llvm;\n use llvm::{ModuleRef, TargetMachineRef, PassManagerRef, DiagnosticInfoRef};\n use llvm::SMDiagnosticRef;\n use {CrateTranslation, ModuleSource, ModuleTranslation, CompiledModule, ModuleKind};\n+use CrateInfo;\n use rustc::hir::def_id::CrateNum;\n use rustc::util::common::{time, time_depth, set_time_depth, path2cstr, print_time_passes_entry};\n use rustc::util::fs::{link_or_copy, rename_or_copy_remove};\n@@ -675,6 +676,7 @@ pub fn start_async_translation(sess: &Session,\n                                no_builtins: bool,\n                                windows_subsystem: Option<String>,\n                                linker_info: LinkerInfo,\n+                               crate_info: CrateInfo,\n                                no_integrated_as: bool)\n                                -> OngoingCrateTranslation {\n     let output_types_override = if no_integrated_as {\n@@ -774,6 +776,7 @@ pub fn start_async_translation(sess: &Session,\n     let (coordinator_send, coordinator_receive) = channel();\n \n     let coordinator_thread = start_executing_work(sess,\n+                                                  &crate_info,\n                                                   shared_emitter,\n                                                   trans_worker_send,\n                                                   coordinator_send.clone(),\n@@ -788,6 +791,7 @@ pub fn start_async_translation(sess: &Session,\n         windows_subsystem,\n         linker_info,\n         no_integrated_as,\n+        crate_info,\n \n         regular_module_config: modules_config,\n         metadata_module_config: metadata_config,\n@@ -1101,6 +1105,7 @@ enum MainThreadWorkerState {\n }\n \n fn start_executing_work(sess: &Session,\n+                        crate_info: &CrateInfo,\n                         shared_emitter: SharedEmitter,\n                         trans_worker_send: Sender<Message>,\n                         coordinator_send: Sender<Message>,\n@@ -1125,8 +1130,8 @@ fn start_executing_work(sess: &Session,\n     }).expect(\"failed to spawn helper thread\");\n \n     let mut each_linked_rlib_for_lto = Vec::new();\n-    drop(link::each_linked_rlib(sess, &mut |cnum, path| {\n-        if link::ignored_for_lto(sess, cnum) {\n+    drop(link::each_linked_rlib(sess, crate_info, &mut |cnum, path| {\n+        if link::ignored_for_lto(crate_info, cnum) {\n             return\n         }\n         each_linked_rlib_for_lto.push((cnum, path.to_path_buf()));\n@@ -1802,6 +1807,7 @@ pub struct OngoingCrateTranslation {\n     windows_subsystem: Option<String>,\n     linker_info: LinkerInfo,\n     no_integrated_as: bool,\n+    crate_info: CrateInfo,\n \n     output_filenames: OutputFilenames,\n     regular_module_config: ModuleConfig,\n@@ -1850,6 +1856,7 @@ impl OngoingCrateTranslation {\n             metadata: self.metadata,\n             windows_subsystem: self.windows_subsystem,\n             linker_info: self.linker_info,\n+            crate_info: self.crate_info,\n \n             modules: compiled_modules.modules,\n             allocator_module: compiled_modules.allocator_module,"}, {"sha": "026417682cc74221809d7c1bda153a60ae346c10", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 58, "deletions": 12, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -41,7 +41,7 @@ use rustc::middle::lang_items::StartFnLangItem;\n use rustc::middle::cstore::{EncodedMetadata, EncodedMetadataHashes};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::dep_graph::AssertDepGraphSafe;\n-use rustc::middle::cstore::LinkMeta;\n+use rustc::middle::cstore::{self, LinkMeta, LinkagePreference};\n use rustc::hir::map as hir_map;\n use rustc::util::common::{time, print_time_passes_entry};\n use rustc::session::config::{self, NoDebugInfo, OutputFilenames, OutputType};\n@@ -53,7 +53,7 @@ use mir::lvalue::LvalueRef;\n use attributes;\n use builder::Builder;\n use callee;\n-use common::{C_bool, C_bytes_in_context, C_i32, C_uint};\n+use common::{C_bool, C_bytes_in_context, C_i32, C_usize};\n use collector::{self, TransItemCollectionMode};\n use common::{C_struct_in_context, C_u64, C_undef, C_array};\n use common::CrateContext;\n@@ -75,6 +75,7 @@ use type_::Type;\n use type_of;\n use value::Value;\n use rustc::util::nodemap::{NodeSet, FxHashMap, FxHashSet};\n+use CrateInfo;\n \n use libc::c_uint;\n use std::ffi::{CStr, CString};\n@@ -200,7 +201,9 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n                                 -> ValueRef {\n     let (source, target) = ccx.tcx().struct_lockstep_tails(source, target);\n     match (&source.sty, &target.sty) {\n-        (&ty::TyArray(_, len), &ty::TySlice(_)) => C_uint(ccx, len),\n+        (&ty::TyArray(_, len), &ty::TySlice(_)) => {\n+            C_usize(ccx, len.val.to_const_int().unwrap().to_u64().unwrap())\n+        }\n         (&ty::TyDynamic(..), &ty::TyDynamic(..)) => {\n             // For now, upcasts are limited to changes in marker\n             // traits, and hence never actually require an actual\n@@ -523,7 +526,7 @@ pub fn call_memcpy<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n     let memcpy = ccx.get_intrinsic(&key);\n     let src_ptr = b.pointercast(src, Type::i8p(ccx));\n     let dst_ptr = b.pointercast(dst, Type::i8p(ccx));\n-    let size = b.intcast(n_bytes, ccx.int_type(), false);\n+    let size = b.intcast(n_bytes, ccx.isize_ty(), false);\n     let align = C_i32(ccx, align as i32);\n     let volatile = C_bool(ccx, false);\n     b.call(memcpy, &[dst_ptr, src_ptr, size, align, volatile], None);\n@@ -544,7 +547,7 @@ pub fn memcpy_ty<'a, 'tcx>(\n     }\n \n     let align = align.unwrap_or_else(|| ccx.align_of(t));\n-    call_memcpy(bcx, dst, src, C_uint(ccx, size), align);\n+    call_memcpy(bcx, dst, src, C_usize(ccx, size), align);\n }\n \n pub fn call_memset<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n@@ -695,7 +698,7 @@ fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n                        sp: Span,\n                        rust_main: ValueRef,\n                        use_start_lang_item: bool) {\n-        let llfty = Type::func(&[ccx.int_type(), Type::i8p(ccx).ptr_to()], &ccx.int_type());\n+        let llfty = Type::func(&[ccx.isize_ty(), Type::i8p(ccx).ptr_to()], &ccx.isize_ty());\n \n         if declare::get_defined_value(ccx, \"main\").is_some() {\n             // FIXME: We should be smart and show a better diagnostic here.\n@@ -774,16 +777,13 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n                 EncodedMetadataHashes::new());\n     }\n \n-    let cstore = &tcx.sess.cstore;\n-    let (metadata, hashes) = cstore.encode_metadata(tcx,\n-                                                    &link_meta,\n-                                                    exported_symbols);\n+    let (metadata, hashes) = tcx.encode_metadata(link_meta, exported_symbols);\n     if kind == MetadataKind::Uncompressed {\n         return (metadata_llcx, metadata_llmod, metadata, hashes);\n     }\n \n     assert!(kind == MetadataKind::Compressed);\n-    let mut compressed = cstore.metadata_encoding_version().to_vec();\n+    let mut compressed = tcx.metadata_encoding_version();\n     DeflateEncoder::new(&mut compressed, Compression::Fast)\n         .write_all(&metadata.raw_data).unwrap();\n \n@@ -904,7 +904,7 @@ pub fn find_exported_symbols(tcx: TyCtxt, reachable: &NodeSet) -> NodeSet {\n         match tcx.hir.get(id) {\n             hir_map::NodeForeignItem(..) => {\n                 let def_id = tcx.hir.local_def_id(id);\n-                tcx.sess.cstore.is_statically_included_foreign_item(def_id)\n+                tcx.is_statically_included_foreign_item(def_id)\n             }\n \n             // Only consider nodes that actually have exported symbols.\n@@ -970,6 +970,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     } else {\n         None\n     };\n+    let crate_info = CrateInfo::new(tcx);\n \n     // Skip crate items and just output metadata in -Z no-trans mode.\n     if tcx.sess.opts.debugging_opts.no_trans ||\n@@ -987,6 +988,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             no_builtins,\n             None,\n             linker_info,\n+            crate_info,\n             false);\n \n         ongoing_translation.submit_pre_translated_module_to_llvm(tcx.sess, metadata_module, true);\n@@ -1039,6 +1041,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         no_builtins,\n         windows_subsystem,\n         linker_info,\n+        crate_info,\n         no_integrated_as);\n \n     // Translate an allocator shim, if any\n@@ -1502,3 +1505,46 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n \n     (translation_items, codegen_units)\n }\n+\n+impl CrateInfo {\n+    pub fn new<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CrateInfo {\n+        let mut info = CrateInfo {\n+            panic_runtime: None,\n+            compiler_builtins: None,\n+            profiler_runtime: None,\n+            sanitizer_runtime: None,\n+            is_no_builtins: FxHashSet(),\n+            native_libraries: FxHashMap(),\n+            used_libraries: tcx.native_libraries(LOCAL_CRATE),\n+            link_args: tcx.link_args(LOCAL_CRATE),\n+            crate_name: FxHashMap(),\n+            used_crates_dynamic: cstore::used_crates(tcx, LinkagePreference::RequireDynamic),\n+            used_crates_static: cstore::used_crates(tcx, LinkagePreference::RequireStatic),\n+            used_crate_source: FxHashMap(),\n+        };\n+\n+        for &cnum in tcx.crates().iter() {\n+            info.native_libraries.insert(cnum, tcx.native_libraries(cnum));\n+            info.crate_name.insert(cnum, tcx.crate_name(cnum).to_string());\n+            info.used_crate_source.insert(cnum, tcx.used_crate_source(cnum));\n+            if tcx.is_panic_runtime(cnum) {\n+                info.panic_runtime = Some(cnum);\n+            }\n+            if tcx.is_compiler_builtins(cnum) {\n+                info.compiler_builtins = Some(cnum);\n+            }\n+            if tcx.is_profiler_runtime(cnum) {\n+                info.profiler_runtime = Some(cnum);\n+            }\n+            if tcx.is_sanitizer_runtime(cnum) {\n+                info.sanitizer_runtime = Some(cnum);\n+            }\n+            if tcx.is_no_builtins(cnum) {\n+                info.is_no_builtins.insert(cnum);\n+            }\n+        }\n+\n+\n+        return info\n+    }\n+}"}, {"sha": "246eb49ffa674ee0a33b8cd380b4f362844d4dd4", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -124,13 +124,17 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             }\n         }\n \n-        if ccx.use_dll_storage_attrs() &&\n-            ccx.sess().cstore.is_dllimport_foreign_item(instance_def_id)\n-        {\n-            unsafe {\n-                llvm::LLVMSetDLLStorageClass(llfn, llvm::DLLStorageClass::DllImport);\n+        // FIXME(#42293) we should actually track this, but fails too many tests\n+        // today.\n+        tcx.dep_graph.with_ignore(|| {\n+            if ccx.use_dll_storage_attrs() &&\n+                tcx.is_dllimport_foreign_item(instance_def_id)\n+            {\n+                unsafe {\n+                    llvm::LLVMSetDLLStorageClass(llfn, llvm::DLLStorageClass::DllImport);\n+                }\n             }\n-        }\n+        });\n         llfn\n     };\n "}, {"sha": "3bf709ff7ba9d227fa679e3d2edc7fa022c5754e", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -193,6 +193,7 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n \n use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n+use rustc::middle::const_val::ConstVal;\n use rustc::middle::lang_items::{ExchangeMallocFnLangItem};\n use rustc::traits;\n use rustc::ty::subst::Substs;\n@@ -432,7 +433,7 @@ fn check_recursion_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let recursion_depth = recursion_depths.get(&def_id).cloned().unwrap_or(0);\n     debug!(\" => recursion depth={}\", recursion_depth);\n \n-    let recursion_depth = if Some(def_id) == tcx.lang_items.drop_in_place_fn() {\n+    let recursion_depth = if Some(def_id) == tcx.lang_items().drop_in_place_fn() {\n         // HACK: drop_in_place creates tight monomorphization loops. Give\n         // it more margin.\n         recursion_depth / 4\n@@ -550,7 +551,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             mir::Rvalue::NullaryOp(mir::NullOp::Box, _) => {\n                 let tcx = self.scx.tcx();\n                 let exchange_malloc_fn_def_id = tcx\n-                    .lang_items\n+                    .lang_items()\n                     .require(ExchangeMallocFnLangItem)\n                     .unwrap_or_else(|e| self.scx.sess().fatal(&e));\n                 let instance = Instance::mono(tcx, exchange_malloc_fn_def_id);\n@@ -564,24 +565,17 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         self.super_rvalue(rvalue, location);\n     }\n \n-    fn visit_constant(&mut self, constant: &mir::Constant<'tcx>, location: Location) {\n-        debug!(\"visiting constant {:?} @ {:?}\", *constant, location);\n+    fn visit_const(&mut self, constant: &&'tcx ty::Const<'tcx>, location: Location) {\n+        debug!(\"visiting const {:?} @ {:?}\", *constant, location);\n \n-        if let ty::TyFnDef(..) = constant.ty.sty {\n-            // function definitions are zero-sized, and only generate\n-            // IR when they are called/reified.\n-            self.super_constant(constant, location);\n-            return\n-        }\n-\n-        if let mir::Literal::Item { def_id, substs } = constant.literal {\n+        if let ConstVal::Unevaluated(def_id, substs) = constant.val {\n             let substs = self.scx.tcx().trans_apply_param_substs(self.param_substs,\n                                                                  &substs);\n             let instance = monomorphize::resolve(self.scx, def_id, substs);\n             collect_neighbours(self.scx, instance, true, self.output);\n         }\n \n-        self.super_constant(constant, location);\n+        self.super_const(constant);\n     }\n \n     fn visit_terminator_kind(&mut self,"}, {"sha": "67c95b92e523b6adc4924defe6d6732575e61e37", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 22, "deletions": 31, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -221,9 +221,15 @@ pub fn C_undef(t: Type) -> ValueRef {\n     }\n }\n \n-pub fn C_integral(t: Type, u: u64, sign_extend: bool) -> ValueRef {\n+pub fn C_int(t: Type, i: i64) -> ValueRef {\n     unsafe {\n-        llvm::LLVMConstInt(t.to_ref(), u, sign_extend as Bool)\n+        llvm::LLVMConstInt(t.to_ref(), i as u64, True)\n+    }\n+}\n+\n+pub fn C_uint(t: Type, i: u64) -> ValueRef {\n+    unsafe {\n+        llvm::LLVMConstInt(t.to_ref(), i, False)\n     }\n }\n \n@@ -239,49 +245,34 @@ pub fn C_nil(ccx: &CrateContext) -> ValueRef {\n }\n \n pub fn C_bool(ccx: &CrateContext, val: bool) -> ValueRef {\n-    C_integral(Type::i1(ccx), val as u64, false)\n+    C_uint(Type::i1(ccx), val as u64)\n }\n \n pub fn C_i32(ccx: &CrateContext, i: i32) -> ValueRef {\n-    C_integral(Type::i32(ccx), i as u64, true)\n+    C_int(Type::i32(ccx), i as i64)\n }\n \n pub fn C_u32(ccx: &CrateContext, i: u32) -> ValueRef {\n-    C_integral(Type::i32(ccx), i as u64, false)\n+    C_uint(Type::i32(ccx), i as u64)\n }\n \n pub fn C_u64(ccx: &CrateContext, i: u64) -> ValueRef {\n-    C_integral(Type::i64(ccx), i, false)\n+    C_uint(Type::i64(ccx), i)\n }\n \n-pub fn C_uint<I: AsU64>(ccx: &CrateContext, i: I) -> ValueRef {\n-    let v = i.as_u64();\n-\n-    let bit_size = machine::llbitsize_of_real(ccx, ccx.int_type());\n+pub fn C_usize(ccx: &CrateContext, i: u64) -> ValueRef {\n+    let bit_size = machine::llbitsize_of_real(ccx, ccx.isize_ty());\n \n     if bit_size < 64 {\n         // make sure it doesn't overflow\n-        assert!(v < (1<<bit_size));\n+        assert!(i < (1<<bit_size));\n     }\n \n-    C_integral(ccx.int_type(), v, false)\n+    C_uint(ccx.isize_ty(), i)\n }\n \n-pub trait AsI64 { fn as_i64(self) -> i64; }\n-pub trait AsU64 { fn as_u64(self) -> u64; }\n-\n-// FIXME: remove the intptr conversions, because they\n-// are host-architecture-dependent\n-impl AsI64 for i64 { fn as_i64(self) -> i64 { self as i64 }}\n-impl AsI64 for i32 { fn as_i64(self) -> i64 { self as i64 }}\n-impl AsI64 for isize { fn as_i64(self) -> i64 { self as i64 }}\n-\n-impl AsU64 for u64  { fn as_u64(self) -> u64 { self as u64 }}\n-impl AsU64 for u32  { fn as_u64(self) -> u64 { self as u64 }}\n-impl AsU64 for usize { fn as_u64(self) -> u64 { self as u64 }}\n-\n pub fn C_u8(ccx: &CrateContext, i: u8) -> ValueRef {\n-    C_integral(Type::i8(ccx), i as u64, false)\n+    C_uint(Type::i8(ccx), i as u64)\n }\n \n \n@@ -315,7 +306,7 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n pub fn C_str_slice(cx: &CrateContext, s: InternedString) -> ValueRef {\n     let len = s.len();\n     let cs = consts::ptrcast(C_cstr(cx, s, false), Type::i8p(cx));\n-    C_named_struct(cx.str_slice_type(), &[cs, C_uint(cx, len)])\n+    C_named_struct(cx.str_slice_type(), &[cs, C_usize(cx, len as u64)])\n }\n \n pub fn C_struct(cx: &CrateContext, elts: &[ValueRef], packed: bool) -> ValueRef {\n@@ -423,7 +414,7 @@ pub fn langcall(tcx: TyCtxt,\n                 msg: &str,\n                 li: LangItem)\n                 -> DefId {\n-    match tcx.lang_items.require(li) {\n+    match tcx.lang_items().require(li) {\n         Ok(id) => id,\n         Err(s) => {\n             let msg = format!(\"{} {}\", msg, s);\n@@ -482,9 +473,9 @@ pub fn shift_mask_val<'a, 'tcx>(\n             // i8/u8 can shift by at most 7, i16/u16 by at most 15, etc.\n             let val = llty.int_width() - 1;\n             if invert {\n-                C_integral(mask_llty, !val, true)\n+                C_int(mask_llty, !val as i64)\n             } else {\n-                C_integral(mask_llty, val, false)\n+                C_uint(mask_llty, val)\n             }\n         },\n         TypeKind::Vector => {\n@@ -530,7 +521,7 @@ pub fn ty_fn_sig<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             let env_ty = tcx.mk_mut_ref(tcx.mk_region(env_region), ty);\n \n             sig.map_bound(|sig| {\n-                let state_did = tcx.lang_items.gen_state().unwrap();\n+                let state_did = tcx.lang_items().gen_state().unwrap();\n                 let state_adt_ref = tcx.adt_def(state_did);\n                 let state_substs = tcx.mk_substs([Kind::from(sig.yield_ty),\n                     Kind::from(sig.return_ty)].iter());"}, {"sha": "bad8a8655d0938cc5625bc9e0dfed2c1de2a362d", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -26,6 +26,7 @@ use rustc::ty;\n \n use rustc::hir;\n \n+use std::cmp;\n use std::ffi::{CStr, CString};\n use syntax::ast;\n use syntax::attr;\n@@ -42,6 +43,25 @@ pub fn bitcast(val: ValueRef, ty: Type) -> ValueRef {\n     }\n }\n \n+fn set_global_alignment(ccx: &CrateContext,\n+                        gv: ValueRef,\n+                        mut align: machine::llalign) {\n+    // The target may require greater alignment for globals than the type does.\n+    // Note: GCC and Clang also allow `__attribute__((aligned))` on variables,\n+    // which can force it to be smaller.  Rust doesn't support this yet.\n+    if let Some(min) = ccx.sess().target.target.options.min_global_align {\n+        match ty::layout::Align::from_bits(min, min) {\n+            Ok(min) => align = cmp::max(align, min.abi() as machine::llalign),\n+            Err(err) => {\n+                ccx.sess().err(&format!(\"invalid minimum global alignment: {}\", err));\n+            }\n+        }\n+    }\n+    unsafe {\n+        llvm::LLVMSetAlignment(gv, align);\n+    }\n+}\n+\n pub fn addr_of_mut(ccx: &CrateContext,\n                    cv: ValueRef,\n                    align: machine::llalign,\n@@ -53,7 +73,7 @@ pub fn addr_of_mut(ccx: &CrateContext,\n             bug!(\"symbol `{}` is already defined\", name);\n         });\n         llvm::LLVMSetInitializer(gv, cv);\n-        llvm::LLVMSetAlignment(gv, align);\n+        set_global_alignment(ccx, gv, align);\n         llvm::LLVMRustSetLinkage(gv, llvm::Linkage::InternalLinkage);\n         SetUnnamedAddr(gv, true);\n         gv\n@@ -211,12 +231,17 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n         g\n     };\n \n-    if ccx.use_dll_storage_attrs() && ccx.sess().cstore.is_dllimport_foreign_item(def_id) {\n-        // For foreign (native) libs we know the exact storage type to use.\n-        unsafe {\n-            llvm::LLVMSetDLLStorageClass(g, llvm::DLLStorageClass::DllImport);\n+\n+    // FIXME(#42293) we should actually track this, but fails too many tests\n+    // today.\n+    ccx.tcx().dep_graph.with_ignore(|| {\n+        if ccx.use_dll_storage_attrs() && ccx.tcx().is_dllimport_foreign_item(def_id) {\n+            // For foreign (native) libs we know the exact storage type to use.\n+            unsafe {\n+                llvm::LLVMSetDLLStorageClass(g, llvm::DLLStorageClass::DllImport);\n+            }\n         }\n-    }\n+    });\n     ccx.instances().borrow_mut().insert(instance, g);\n     ccx.statics().borrow_mut().insert(g, def_id);\n     g\n@@ -271,7 +296,7 @@ pub fn trans_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             ccx.statics_to_rauw().borrow_mut().push((g, new_g));\n             new_g\n         };\n-        llvm::LLVMSetAlignment(g, ccx.align_of(ty));\n+        set_global_alignment(ccx, g, ccx.align_of(ty));\n         llvm::LLVMSetInitializer(g, v);\n \n         // As an optimization, all shared statics which do not have interior"}, {"sha": "77bddc7731b5bee0a3a65203102f9bc7f2e2dee6", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -136,7 +136,7 @@ pub struct LocalCrateContext<'a, 'tcx: 'a> {\n     used_statics: RefCell<Vec<ValueRef>>,\n \n     lltypes: RefCell<FxHashMap<Ty<'tcx>, Type>>,\n-    int_type: Type,\n+    isize_ty: Type,\n     opaque_vec_type: Type,\n     str_slice_type: Type,\n \n@@ -398,7 +398,7 @@ impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n                 statics_to_rauw: RefCell::new(Vec::new()),\n                 used_statics: RefCell::new(Vec::new()),\n                 lltypes: RefCell::new(FxHashMap()),\n-                int_type: Type::from_ref(ptr::null_mut()),\n+                isize_ty: Type::from_ref(ptr::null_mut()),\n                 opaque_vec_type: Type::from_ref(ptr::null_mut()),\n                 str_slice_type: Type::from_ref(ptr::null_mut()),\n                 dbg_cx,\n@@ -410,23 +410,23 @@ impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n                 placeholder: PhantomData,\n             };\n \n-            let (int_type, opaque_vec_type, str_slice_ty, mut local_ccx) = {\n+            let (isize_ty, opaque_vec_type, str_slice_ty, mut local_ccx) = {\n                 // Do a little dance to create a dummy CrateContext, so we can\n                 // create some things in the LLVM module of this codegen unit\n                 let mut local_ccxs = vec![local_ccx];\n-                let (int_type, opaque_vec_type, str_slice_ty) = {\n+                let (isize_ty, opaque_vec_type, str_slice_ty) = {\n                     let dummy_ccx = LocalCrateContext::dummy_ccx(shared,\n                                                                  local_ccxs.as_mut_slice());\n                     let mut str_slice_ty = Type::named_struct(&dummy_ccx, \"str_slice\");\n                     str_slice_ty.set_struct_body(&[Type::i8p(&dummy_ccx),\n-                                                   Type::int(&dummy_ccx)],\n+                                                   Type::isize(&dummy_ccx)],\n                                                  false);\n-                    (Type::int(&dummy_ccx), Type::opaque_vec(&dummy_ccx), str_slice_ty)\n+                    (Type::isize(&dummy_ccx), Type::opaque_vec(&dummy_ccx), str_slice_ty)\n                 };\n-                (int_type, opaque_vec_type, str_slice_ty, local_ccxs.pop().unwrap())\n+                (isize_ty, opaque_vec_type, str_slice_ty, local_ccxs.pop().unwrap())\n             };\n \n-            local_ccx.int_type = int_type;\n+            local_ccx.isize_ty = isize_ty;\n             local_ccx.opaque_vec_type = opaque_vec_type;\n             local_ccx.str_slice_type = str_slice_ty;\n \n@@ -549,8 +549,8 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().stats\n     }\n \n-    pub fn int_type(&self) -> Type {\n-        self.local().int_type\n+    pub fn isize_ty(&self) -> Type {\n+        self.local().isize_ty\n     }\n \n     pub fn str_slice_type(&self) -> Type {\n@@ -616,7 +616,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n             return llpersonality\n         }\n         let tcx = self.tcx();\n-        let llfn = match tcx.lang_items.eh_personality() {\n+        let llfn = match tcx.lang_items().eh_personality() {\n             Some(def_id) if !base::wants_msvc_seh(self.sess()) => {\n                 callee::resolve_and_get_fn(self, def_id, tcx.intern_substs(&[]))\n             }\n@@ -645,7 +645,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n \n         let tcx = self.tcx();\n         assert!(self.sess().target.target.options.custom_unwind_resume);\n-        if let Some(def_id) = tcx.lang_items.eh_unwind_resume() {\n+        if let Some(def_id) = tcx.lang_items().eh_unwind_resume() {\n             let llfn = callee::resolve_and_get_fn(self, def_id, tcx.intern_substs(&[]));\n             unwresume.set(Some(llfn));\n             return llfn;"}, {"sha": "3c87bc293b5b58cc67faf14f7127025e780d3614", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -366,7 +366,7 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                          -> bool {\n         member_llvm_types.len() == 2 &&\n         member_llvm_types[0] == type_of::type_of(cx, element_type).ptr_to() &&\n-        member_llvm_types[1] == cx.int_type()\n+        member_llvm_types[1] == cx.isize_ty()\n     }\n }\n \n@@ -530,7 +530,8 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n         }\n         ty::TyArray(typ, len) => {\n-            fixed_vec_metadata(cx, unique_type_id, typ, Some(len as u64), usage_site_span)\n+            let len = len.val.to_const_int().unwrap().to_u64().unwrap();\n+            fixed_vec_metadata(cx, unique_type_id, typ, Some(len), usage_site_span)\n         }\n         ty::TySlice(typ) => {\n             fixed_vec_metadata(cx, unique_type_id, typ, None, usage_site_span)\n@@ -1612,7 +1613,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     fn get_enum_discriminant_name(cx: &CrateContext,\n                                   def_id: DefId)\n                                   -> InternedString {\n-        cx.tcx().item_name(def_id).as_str()\n+        cx.tcx().item_name(def_id)\n     }\n }\n "}, {"sha": "7bf9d39ea2f252bdee9f0704c3c0e97369464e64", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -96,7 +96,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyArray(inner_type, len) => {\n             output.push('[');\n             push_debuginfo_type_name(cx, inner_type, true, output);\n-            output.push_str(&format!(\"; {}\", len));\n+            output.push_str(&format!(\"; {}\", len.val.to_const_int().unwrap().to_u64().unwrap()));\n             output.push(']');\n         },\n         ty::TySlice(inner_type) => {\n@@ -189,7 +189,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 output.push_str(&path_element.data.as_interned_str());\n             }\n         } else {\n-            output.push_str(&cx.tcx().item_name(def_id).as_str());\n+            output.push_str(&cx.tcx().item_name(def_id));\n         }\n     }\n "}, {"sha": "8dd0b4e466ce491bedcb291c963218b64317aaf6", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -70,8 +70,8 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n         let align = bcx.ccx.align_of(t);\n         debug!(\"size_and_align_of_dst t={} info={:?} size: {} align: {}\",\n                t, Value(info), size, align);\n-        let size = C_uint(bcx.ccx, size);\n-        let align = C_uint(bcx.ccx, align);\n+        let size = C_usize(bcx.ccx, size);\n+        let align = C_usize(bcx.ccx, align as u64);\n         return (size, align);\n     }\n     assert!(!info.is_null());\n@@ -96,8 +96,8 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n             };\n             debug!(\"DST {} statically sized prefix size: {} align: {}\",\n                    t, sized_size, sized_align);\n-            let sized_size = C_uint(ccx, sized_size);\n-            let sized_align = C_uint(ccx, sized_align);\n+            let sized_size = C_usize(ccx, sized_size);\n+            let sized_align = C_usize(ccx, sized_align);\n \n             // Recurse to get the size of the dynamically sized field (must be\n             // the last field).\n@@ -128,7 +128,7 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n                 (Some(sized_align), Some(unsized_align)) => {\n                     // If both alignments are constant, (the sized_align should always be), then\n                     // pick the correct alignment statically.\n-                    C_uint(ccx, std::cmp::max(sized_align, unsized_align) as u64)\n+                    C_usize(ccx, std::cmp::max(sized_align, unsized_align) as u64)\n                 }\n                 _ => bcx.select(bcx.icmp(llvm::IntUGT, sized_align, unsized_align),\n                                 sized_align,\n@@ -146,7 +146,7 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n             //\n             //   `(size + (align-1)) & -align`\n \n-            let addend = bcx.sub(align, C_uint(bcx.ccx, 1_u64));\n+            let addend = bcx.sub(align, C_usize(bcx.ccx, 1));\n             let size = bcx.and(bcx.add(size, addend), bcx.neg(align));\n \n             (size, align)\n@@ -159,8 +159,8 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n             let unit = t.sequence_element_type(bcx.tcx());\n             // The info in this case is the length of the str, so the size is that\n             // times the unit size.\n-            (bcx.mul(info, C_uint(bcx.ccx, bcx.ccx.size_of(unit))),\n-             C_uint(bcx.ccx, bcx.ccx.align_of(unit)))\n+            (bcx.mul(info, C_usize(bcx.ccx, bcx.ccx.size_of(unit))),\n+             C_usize(bcx.ccx, bcx.ccx.align_of(unit) as u64))\n         }\n         _ => bug!(\"Unexpected unsized type, found {}\", t)\n     }"}, {"sha": "f78d80a197ca9a68ffa84c6c60bd46f227bdd8cb", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -104,7 +104,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n     let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n     let arg_tys = sig.inputs();\n     let ret_ty = sig.output();\n-    let name = &*tcx.item_name(def_id).as_str();\n+    let name = &*tcx.item_name(def_id);\n \n     let llret_ty = type_of::type_of(ccx, ret_ty);\n \n@@ -135,7 +135,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         \"size_of\" => {\n             let tp_ty = substs.type_at(0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            C_uint(ccx, machine::llsize_of_alloc(ccx, lltp_ty))\n+            C_usize(ccx, machine::llsize_of_alloc(ccx, lltp_ty))\n         }\n         \"size_of_val\" => {\n             let tp_ty = substs.type_at(0);\n@@ -145,12 +145,12 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 llsize\n             } else {\n                 let lltp_ty = type_of::type_of(ccx, tp_ty);\n-                C_uint(ccx, machine::llsize_of_alloc(ccx, lltp_ty))\n+                C_usize(ccx, machine::llsize_of_alloc(ccx, lltp_ty))\n             }\n         }\n         \"min_align_of\" => {\n             let tp_ty = substs.type_at(0);\n-            C_uint(ccx, ccx.align_of(tp_ty))\n+            C_usize(ccx, ccx.align_of(tp_ty) as u64)\n         }\n         \"min_align_of_val\" => {\n             let tp_ty = substs.type_at(0);\n@@ -159,13 +159,13 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                     glue::size_and_align_of_dst(bcx, tp_ty, llargs[1]);\n                 llalign\n             } else {\n-                C_uint(ccx, ccx.align_of(tp_ty))\n+                C_usize(ccx, ccx.align_of(tp_ty) as u64)\n             }\n         }\n         \"pref_align_of\" => {\n             let tp_ty = substs.type_at(0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            C_uint(ccx, machine::llalign_of_pref(ccx, lltp_ty))\n+            C_usize(ccx, machine::llalign_of_pref(ccx, lltp_ty) as u64)\n         }\n         \"type_name\" => {\n             let tp_ty = substs.type_at(0);\n@@ -182,7 +182,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 // If we store a zero constant, LLVM will drown in vreg allocation for large data\n                 // structures, and the generated code will be awful. (A telltale sign of this is\n                 // large quantities of `mov [byte ptr foo],0` in the generated code.)\n-                memset_intrinsic(bcx, false, ty, llresult, C_u8(ccx, 0), C_uint(ccx, 1usize));\n+                memset_intrinsic(bcx, false, ty, llresult, C_u8(ccx, 0), C_usize(ccx, 1));\n             }\n             C_nil(ccx)\n         }\n@@ -386,10 +386,10 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n         \"align_offset\" => {\n             // `ptr as usize`\n-            let ptr_val = bcx.ptrtoint(llargs[0], bcx.ccx.int_type());\n+            let ptr_val = bcx.ptrtoint(llargs[0], bcx.ccx.isize_ty());\n             // `ptr_val % align`\n             let offset = bcx.urem(ptr_val, llargs[1]);\n-            let zero = C_null(bcx.ccx.int_type());\n+            let zero = C_null(bcx.ccx.isize_ty());\n             // `offset == 0`\n             let is_zero = bcx.icmp(llvm::IntPredicate::IntEQ, offset, zero);\n             // `if offset == 0 { 0 } else { offset - align }`\n@@ -688,7 +688,7 @@ fn copy_intrinsic<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n     let lltp_ty = type_of::type_of(ccx, tp_ty);\n     let align = C_i32(ccx, ccx.align_of(tp_ty) as i32);\n     let size = machine::llsize_of(ccx, lltp_ty);\n-    let int_size = machine::llbitsize_of_real(ccx, ccx.int_type());\n+    let int_size = machine::llbitsize_of_real(ccx, ccx.isize_ty());\n \n     let operation = if allow_overlap {\n         \"memmove\"\n@@ -822,7 +822,7 @@ fn trans_msvc_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         catchswitch.add_handler(cs, catchpad.llbb());\n \n         let tcx = ccx.tcx();\n-        let tydesc = match tcx.lang_items.msvc_try_filter() {\n+        let tydesc = match tcx.lang_items().msvc_try_filter() {\n             Some(did) => ::consts::get_static(ccx, did),\n             None => bug!(\"msvc_try_filter not defined\"),\n         };"}, {"sha": "63fd37c2b98bf62816b9f61cf23cca78b02937f8", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -66,8 +66,15 @@ pub use back::symbol_names::provide;\n pub use metadata::LlvmMetadataLoader;\n pub use llvm_util::{init, target_features, print_version, print_passes, print, enable_llvm_debug};\n \n+use std::rc::Rc;\n+\n+use rustc::hir::def_id::CrateNum;\n+use rustc::util::nodemap::{FxHashSet, FxHashMap};\n+use rustc::middle::cstore::{NativeLibrary, CrateSource, LibSource};\n+\n pub mod back {\n     mod archive;\n+    mod command;\n     pub(crate) mod linker;\n     pub mod link;\n     mod lto;\n@@ -216,7 +223,24 @@ pub struct CrateTranslation {\n     pub link: rustc::middle::cstore::LinkMeta,\n     pub metadata: rustc::middle::cstore::EncodedMetadata,\n     windows_subsystem: Option<String>,\n-    linker_info: back::linker::LinkerInfo\n+    linker_info: back::linker::LinkerInfo,\n+    crate_info: CrateInfo,\n+}\n+\n+// Misc info we load from metadata to persist beyond the tcx\n+pub struct CrateInfo {\n+    panic_runtime: Option<CrateNum>,\n+    compiler_builtins: Option<CrateNum>,\n+    profiler_runtime: Option<CrateNum>,\n+    sanitizer_runtime: Option<CrateNum>,\n+    is_no_builtins: FxHashSet<CrateNum>,\n+    native_libraries: FxHashMap<CrateNum, Rc<Vec<NativeLibrary>>>,\n+    crate_name: FxHashMap<CrateNum, String>,\n+    used_libraries: Rc<Vec<NativeLibrary>>,\n+    link_args: Rc<Vec<String>>,\n+    used_crate_source: FxHashMap<CrateNum, Rc<CrateSource>>,\n+    used_crates_static: Vec<(CrateNum, LibSource)>,\n+    used_crates_dynamic: Vec<(CrateNum, LibSource)>,\n }\n \n __build_diagnostic_array! { librustc_trans, DIAGNOSTICS }"}, {"sha": "bc383abc7e0ecc96aeb18ead69c13991aaa3d55f", "filename": "src/librustc_trans/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmachine.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -48,7 +48,7 @@ pub fn llsize_of(cx: &CrateContext, ty: Type) -> ValueRef {\n     // there's no need for that contrivance.  The instruction\n     // selection DAG generator would flatten that GEP(1) node into a\n     // constant of the type's alloc size, so let's save it some work.\n-    return C_uint(cx, llsize_of_alloc(cx, ty));\n+    return C_usize(cx, llsize_of_alloc(cx, ty));\n }\n \n // Returns the preferred alignment of the given type for the current target."}, {"sha": "6eedd53974e70482a76cca732d4c90ea6c2a6719", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -46,7 +46,7 @@ impl<'a, 'tcx> VirtualIndex {\n         // Load the data pointer from the object.\n         debug!(\"get_int({:?}, {:?})\", Value(llvtable), self);\n \n-        let llvtable = bcx.pointercast(llvtable, Type::int(bcx.ccx).ptr_to());\n+        let llvtable = bcx.pointercast(llvtable, Type::isize(bcx.ccx).ptr_to());\n         let ptr = bcx.load(bcx.gepi(llvtable, &[self.0]), None);\n         // Vtable loads are invariant\n         bcx.set_invariant_load(ptr);\n@@ -81,8 +81,8 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let mut components: Vec<_> = [\n         callee::get_fn(ccx, monomorphize::resolve_drop_in_place(ccx.shared(), ty)),\n-        C_uint(ccx, ccx.size_of(ty)),\n-        C_uint(ccx, ccx.align_of(ty))\n+        C_usize(ccx, ccx.size_of(ty)),\n+        C_usize(ccx, ccx.align_of(ty) as u64)\n     ].iter().cloned().collect();\n \n     if let Some(trait_ref) = trait_ref {"}, {"sha": "1017ec6b3c3f85608e33a553e916e39d4fe25988", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -17,6 +17,7 @@ use rustc::middle::const_val::ConstVal;\n use rustc::mir::{self, Location, TerminatorKind, Literal};\n use rustc::mir::visit::{Visitor, LvalueContext};\n use rustc::mir::traversal;\n+use rustc::ty;\n use common;\n use super::MirContext;\n \n@@ -110,11 +111,11 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n             mir::TerminatorKind::Call {\n                 func: mir::Operand::Constant(box mir::Constant {\n                     literal: Literal::Value {\n-                        value: ConstVal::Function(def_id, _), ..\n+                        value: &ty::Const { val: ConstVal::Function(def_id, _), .. }, ..\n                     }, ..\n                 }),\n                 ref args, ..\n-            } if Some(def_id) == self.cx.ccx.tcx().lang_items.box_free_fn() => {\n+            } if Some(def_id) == self.cx.ccx.tcx().lang_items().box_free_fn() => {\n                 // box_free(x) shares with `drop x` the property that it\n                 // is not guaranteed to be statically dominated by the\n                 // definition of x, so x must always be in an alloca."}, {"sha": "3e802c8be5bf4f3569648b76e06162b128e05e26", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -383,16 +383,16 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         };\n                         let msg_str = Symbol::intern(str).as_str();\n                         let msg_str = C_str_slice(bcx.ccx, msg_str);\n-                        let msg_file_line = C_struct(bcx.ccx,\n-                                                     &[msg_str, filename, line],\n+                        let msg_file_line_col = C_struct(bcx.ccx,\n+                                                     &[msg_str, filename, line, col],\n                                                      false);\n-                        let align = llalign_of_min(bcx.ccx, common::val_ty(msg_file_line));\n-                        let msg_file_line = consts::addr_of(bcx.ccx,\n-                                                            msg_file_line,\n-                                                            align,\n-                                                            \"panic_loc\");\n+                        let align = llalign_of_min(bcx.ccx, common::val_ty(msg_file_line_col));\n+                        let msg_file_line_col = consts::addr_of(bcx.ccx,\n+                                                                msg_file_line_col,\n+                                                                align,\n+                                                                \"panic_loc\");\n                         (lang_items::PanicFnLangItem,\n-                         vec![msg_file_line],\n+                         vec![msg_file_line_col],\n                          None)\n                     }\n                 };\n@@ -445,7 +445,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 // Handle intrinsics old trans wants Expr's for, ourselves.\n                 let intrinsic = match def {\n                     Some(ty::InstanceDef::Intrinsic(def_id))\n-                        => Some(bcx.tcx().item_name(def_id).as_str()),\n+                        => Some(bcx.tcx().item_name(def_id)),\n                     _ => None\n                 };\n                 let intrinsic = intrinsic.as_ref().map(|s| &s[..]);"}, {"sha": "4c3326a466d3a4f919ecebd1789fada6c78b1619", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 46, "deletions": 47, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -26,8 +26,8 @@ use abi::{self, Abi};\n use callee;\n use builder::Builder;\n use common::{self, CrateContext, const_get_elt, val_ty};\n-use common::{C_array, C_bool, C_bytes, C_integral, C_big_integral, C_u32, C_u64};\n-use common::{C_null, C_struct, C_str_slice, C_undef, C_uint, C_vector, is_undef};\n+use common::{C_array, C_bool, C_bytes, C_int, C_uint, C_big_integral, C_u32, C_u64};\n+use common::{C_null, C_struct, C_str_slice, C_undef, C_usize, C_vector, is_undef};\n use common::const_to_opt_u128;\n use consts;\n use monomorphize;\n@@ -66,35 +66,29 @@ impl<'tcx> Const<'tcx> {\n     -> Const<'tcx> {\n         let tcx = ccx.tcx();\n         let (llval, ty) = match *ci {\n-            I8(v) => (C_integral(Type::i8(ccx), v as u64, true), tcx.types.i8),\n-            I16(v) => (C_integral(Type::i16(ccx), v as u64, true), tcx.types.i16),\n-            I32(v) => (C_integral(Type::i32(ccx), v as u64, true), tcx.types.i32),\n-            I64(v) => (C_integral(Type::i64(ccx), v as u64, true), tcx.types.i64),\n+            I8(v) => (C_int(Type::i8(ccx), v as i64), tcx.types.i8),\n+            I16(v) => (C_int(Type::i16(ccx), v as i64), tcx.types.i16),\n+            I32(v) => (C_int(Type::i32(ccx), v as i64), tcx.types.i32),\n+            I64(v) => (C_int(Type::i64(ccx), v as i64), tcx.types.i64),\n             I128(v) => (C_big_integral(Type::i128(ccx), v as u128), tcx.types.i128),\n-            Isize(v) => {\n-                let i = v.as_i64(ccx.tcx().sess.target.int_type);\n-                (C_integral(Type::int(ccx), i as u64, true), tcx.types.isize)\n-            },\n-            U8(v) => (C_integral(Type::i8(ccx), v as u64, false), tcx.types.u8),\n-            U16(v) => (C_integral(Type::i16(ccx), v as u64, false), tcx.types.u16),\n-            U32(v) => (C_integral(Type::i32(ccx), v as u64, false), tcx.types.u32),\n-            U64(v) => (C_integral(Type::i64(ccx), v, false), tcx.types.u64),\n+            Isize(v) => (C_int(Type::isize(ccx), v.as_i64()), tcx.types.isize),\n+            U8(v) => (C_uint(Type::i8(ccx), v as u64), tcx.types.u8),\n+            U16(v) => (C_uint(Type::i16(ccx), v as u64), tcx.types.u16),\n+            U32(v) => (C_uint(Type::i32(ccx), v as u64), tcx.types.u32),\n+            U64(v) => (C_uint(Type::i64(ccx), v), tcx.types.u64),\n             U128(v) => (C_big_integral(Type::i128(ccx), v), tcx.types.u128),\n-            Usize(v) => {\n-                let u = v.as_u64(ccx.tcx().sess.target.uint_type);\n-                (C_integral(Type::int(ccx), u, false), tcx.types.usize)\n-            },\n+            Usize(v) => (C_uint(Type::isize(ccx), v.as_u64()), tcx.types.usize),\n         };\n         Const { llval: llval, ty: ty }\n     }\n \n     /// Translate ConstVal into a LLVM constant value.\n     pub fn from_constval<'a>(ccx: &CrateContext<'a, 'tcx>,\n-                             cv: ConstVal,\n+                             cv: &ConstVal,\n                              ty: Ty<'tcx>)\n                              -> Const<'tcx> {\n         let llty = type_of::type_of(ccx, ty);\n-        let val = match cv {\n+        let val = match *cv {\n             ConstVal::Float(v) => {\n                 let bits = match v.ty {\n                     ast::FloatTy::F32 => C_u32(ccx, v.bits as u32),\n@@ -105,12 +99,12 @@ impl<'tcx> Const<'tcx> {\n             ConstVal::Bool(v) => C_bool(ccx, v),\n             ConstVal::Integral(ref i) => return Const::from_constint(ccx, i),\n             ConstVal::Str(ref v) => C_str_slice(ccx, v.clone()),\n-            ConstVal::ByteStr(ref v) => consts::addr_of(ccx, C_bytes(ccx, v), 1, \"byte_str\"),\n-            ConstVal::Char(c) => C_integral(Type::char(ccx), c as u64, false),\n+            ConstVal::ByteStr(v) => consts::addr_of(ccx, C_bytes(ccx, v.data), 1, \"byte_str\"),\n+            ConstVal::Char(c) => C_uint(Type::char(ccx), c as u64),\n             ConstVal::Function(..) => C_null(type_of::type_of(ccx, ty)),\n             ConstVal::Variant(_) |\n-            ConstVal::Struct(_) | ConstVal::Tuple(_) |\n-            ConstVal::Array(..) | ConstVal::Repeat(..) => {\n+            ConstVal::Aggregate(..) |\n+            ConstVal::Unevaluated(..) => {\n                 bug!(\"MIR must not use `{:?}` (aggregates are expanded to MIR rvalues)\", cv)\n             }\n         };\n@@ -207,7 +201,9 @@ impl<'tcx> ConstLvalue<'tcx> {\n \n     pub fn len<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n         match self.ty.sty {\n-            ty::TyArray(_, n) => C_uint(ccx, n),\n+            ty::TyArray(_, n) => {\n+                C_usize(ccx, n.val.to_const_int().unwrap().to_u64().unwrap())\n+            }\n             ty::TySlice(_) | ty::TyStr => {\n                 assert!(self.llextra != ptr::null_mut());\n                 self.llextra\n@@ -365,15 +361,15 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     }\n                     if let Some((ref dest, target)) = *destination {\n                         let result = if fn_ty.fn_sig(tcx).abi() == Abi::RustIntrinsic {\n-                            match &tcx.item_name(def_id).as_str()[..] {\n+                            match &tcx.item_name(def_id)[..] {\n                                 \"size_of\" => {\n-                                    let llval = C_uint(self.ccx,\n+                                    let llval = C_usize(self.ccx,\n                                         self.ccx.size_of(substs.type_at(0)));\n                                     Ok(Const::new(llval, tcx.types.usize))\n                                 }\n                                 \"min_align_of\" => {\n-                                    let llval = C_uint(self.ccx,\n-                                        self.ccx.align_of(substs.type_at(0)));\n+                                    let llval = C_usize(self.ccx,\n+                                        self.ccx.align_of(substs.type_at(0)) as u64);\n                                     Ok(Const::new(llval, tcx.types.usize))\n                                 }\n                                 _ => span_bug!(span, \"{:?} in constant\", terminator.kind)\n@@ -514,16 +510,17 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n             mir::Operand::Constant(ref constant) => {\n                 let ty = self.monomorphize(&constant.ty);\n                 match constant.literal.clone() {\n-                    mir::Literal::Item { def_id, substs } => {\n-                        let substs = self.monomorphize(&substs);\n-                        MirConstContext::trans_def(self.ccx, def_id, substs, IndexVec::new())\n-                    }\n                     mir::Literal::Promoted { index } => {\n                         let mir = &self.mir.promoted[index];\n                         MirConstContext::new(self.ccx, mir, self.substs, IndexVec::new()).trans()\n                     }\n                     mir::Literal::Value { value } => {\n-                        Ok(Const::from_constval(self.ccx, value, ty))\n+                        if let ConstVal::Unevaluated(def_id, substs) = value.val {\n+                            let substs = self.monomorphize(&substs);\n+                            MirConstContext::trans_def(self.ccx, def_id, substs, IndexVec::new())\n+                        } else {\n+                            Ok(Const::from_constval(self.ccx, &value.val, ty))\n+                        }\n                     }\n                 }\n             }\n@@ -557,9 +554,10 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n         let val = match *rvalue {\n             mir::Rvalue::Use(ref operand) => self.const_operand(operand, span)?,\n \n-            mir::Rvalue::Repeat(ref elem, ref count) => {\n+            mir::Rvalue::Repeat(ref elem, count) => {\n                 let elem = self.const_operand(elem, span)?;\n-                let size = count.as_u64(tcx.sess.target.uint_type);\n+                let size = count.as_u64();\n+                assert_eq!(size as usize as u64, size);\n                 let fields = vec![elem.llval; size as usize];\n                 self.const_array(dest_ty, &fields)\n             }\n@@ -610,7 +608,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         match operand.ty.sty {\n                             ty::TyClosure(def_id, substs) => {\n                                 // Get the def_id for FnOnce::call_once\n-                                let fn_once = tcx.lang_items.fn_once_trait().unwrap();\n+                                let fn_once = tcx.lang_items().fn_once_trait().unwrap();\n                                 let call_once = tcx\n                                     .global_tcx().associated_items(fn_once)\n                                     .find(|it| it.kind == ty::AssociatedKind::Method)\n@@ -836,7 +834,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n             mir::Rvalue::NullaryOp(mir::NullOp::SizeOf, ty) => {\n                 assert!(self.ccx.shared().type_is_sized(ty));\n-                let llval = C_uint(self.ccx, self.ccx.size_of(ty));\n+                let llval = C_usize(self.ccx, self.ccx.size_of(ty));\n                 Const::new(llval, tcx.types.usize)\n             }\n \n@@ -854,10 +852,10 @@ fn to_const_int(value: ValueRef, t: Ty, tcx: TyCtxt) -> Option<ConstInt> {\n     match t.sty {\n         ty::TyInt(int_type) => const_to_opt_u128(value, true)\n             .and_then(|input| ConstInt::new_signed(input as i128, int_type,\n-                                                   tcx.sess.target.int_type)),\n+                                                   tcx.sess.target.isize_ty)),\n         ty::TyUint(uint_type) => const_to_opt_u128(value, false)\n             .and_then(|input| ConstInt::new_unsigned(input, uint_type,\n-                                                     tcx.sess.target.uint_type)),\n+                                                     tcx.sess.target.usize_ty)),\n         _ => None\n \n     }\n@@ -963,16 +961,17 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         debug!(\"trans_constant({:?})\", constant);\n         let ty = self.monomorphize(&constant.ty);\n         let result = match constant.literal.clone() {\n-            mir::Literal::Item { def_id, substs } => {\n-                let substs = self.monomorphize(&substs);\n-                MirConstContext::trans_def(bcx.ccx, def_id, substs, IndexVec::new())\n-            }\n             mir::Literal::Promoted { index } => {\n                 let mir = &self.mir.promoted[index];\n                 MirConstContext::new(bcx.ccx, mir, self.param_substs, IndexVec::new()).trans()\n             }\n             mir::Literal::Value { value } => {\n-                Ok(Const::from_constval(bcx.ccx, value, ty))\n+                if let ConstVal::Unevaluated(def_id, substs) = value.val {\n+                    let substs = self.monomorphize(&substs);\n+                    MirConstContext::trans_def(bcx.ccx, def_id, substs, IndexVec::new())\n+                } else {\n+                    Ok(Const::from_constval(bcx.ccx, &value.val, ty))\n+                }\n             }\n         };\n \n@@ -1038,11 +1037,11 @@ fn trans_const<'a, 'tcx>(\n             };\n             assert_eq!(vals.len(), 0);\n             adt::assert_discr_in_range(min, max, discr);\n-            C_integral(Type::from_integer(ccx, d), discr, true)\n+            C_int(Type::from_integer(ccx, d), discr as i64)\n         }\n         layout::General { discr: d, ref variants, .. } => {\n             let variant = &variants[variant_index];\n-            let lldiscr = C_integral(Type::from_integer(ccx, d), variant_index as u64, true);\n+            let lldiscr = C_int(Type::from_integer(ccx, d), variant_index as i64);\n             let mut vals_with_discr = vec![lldiscr];\n             vals_with_discr.extend_from_slice(vals);\n             let mut contents = build_const_struct(ccx, &variant, &vals_with_discr[..]);"}, {"sha": "6799e52904d3432f6c27d943d9d0a9ea4e588ab4", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -16,7 +16,7 @@ use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;\n use adt;\n use builder::Builder;\n-use common::{self, CrateContext, C_uint};\n+use common::{self, CrateContext, C_usize};\n use consts;\n use machine;\n use type_of;\n@@ -106,7 +106,9 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n     pub fn len(&self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n         let ty = self.ty.to_ty(ccx.tcx());\n         match ty.sty {\n-            ty::TyArray(_, n) => common::C_uint(ccx, n),\n+            ty::TyArray(_, n) => {\n+                common::C_usize(ccx, n.val.to_const_int().unwrap().to_u64().unwrap())\n+            }\n             ty::TySlice(_) | ty::TyStr => {\n                 assert!(self.llextra != ptr::null_mut());\n                 self.llextra\n@@ -186,7 +188,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n \n \n         let offset = st.offsets[ix].bytes();\n-        let unaligned_offset = C_uint(bcx.ccx, offset);\n+        let unaligned_offset = C_usize(bcx.ccx, offset);\n \n         // Get the alignment of the field\n         let (_, align) = glue::size_and_align_of_dst(bcx, fty, meta);\n@@ -197,7 +199,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         //   (unaligned offset + (align - 1)) & -align\n \n         // Calculate offset\n-        let align_sub_1 = bcx.sub(align, C_uint(bcx.ccx, 1u64));\n+        let align_sub_1 = bcx.sub(align, C_usize(bcx.ccx, 1));\n         let offset = bcx.and(bcx.add(unaligned_offset, align_sub_1),\n         bcx.neg(align));\n \n@@ -276,7 +278,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             // Slices already point to the array element type.\n             bcx.inbounds_gep(self.llval, &[llindex])\n         } else {\n-            let zero = common::C_uint(bcx.ccx, 0u64);\n+            let zero = common::C_usize(bcx.ccx, 0);\n             bcx.inbounds_gep(self.llval, &[zero, llindex])\n         }\n     }\n@@ -342,19 +344,19 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: false,\n                                                          min_length: _ } => {\n-                        let lloffset = C_uint(bcx.ccx, offset);\n+                        let lloffset = C_usize(bcx.ccx, offset as u64);\n                         ((tr_base.project_index(bcx, lloffset), align), ptr::null_mut())\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: true,\n                                                          min_length: _ } => {\n-                        let lloffset = C_uint(bcx.ccx, offset);\n+                        let lloffset = C_usize(bcx.ccx, offset as u64);\n                         let lllen = tr_base.len(bcx.ccx);\n                         let llindex = bcx.sub(lllen, lloffset);\n                         ((tr_base.project_index(bcx, llindex), align), ptr::null_mut())\n                     }\n                     mir::ProjectionElem::Subslice { from, to } => {\n-                        let llbase = tr_base.project_index(bcx, C_uint(bcx.ccx, from));\n+                        let llbase = tr_base.project_index(bcx, C_usize(bcx.ccx, from as u64));\n \n                         let base_ty = tr_base.ty.to_ty(bcx.tcx());\n                         match base_ty.sty {\n@@ -369,7 +371,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             ty::TySlice(..) => {\n                                 assert!(tr_base.llextra != ptr::null_mut());\n                                 let lllen = bcx.sub(tr_base.llextra,\n-                                                    C_uint(bcx.ccx, from+to));\n+                                                    C_usize(bcx.ccx, (from as u64)+(to as u64)));\n                                 ((llbase, align), lllen)\n                             }\n                             _ => bug!(\"unexpected type {:?} in Subslice\", base_ty)\n@@ -397,11 +399,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     /// nmatsakis: is this still necessary? Not sure.\n     fn prepare_index(&mut self, bcx: &Builder<'a, 'tcx>, llindex: ValueRef) -> ValueRef {\n         let index_size = machine::llbitsize_of_real(bcx.ccx, common::val_ty(llindex));\n-        let int_size = machine::llbitsize_of_real(bcx.ccx, bcx.ccx.int_type());\n+        let int_size = machine::llbitsize_of_real(bcx.ccx, bcx.ccx.isize_ty());\n         if index_size < int_size {\n-            bcx.zext(llindex, bcx.ccx.int_type())\n+            bcx.zext(llindex, bcx.ccx.isize_ty())\n         } else if index_size > int_size {\n-            bcx.trunc(llindex, bcx.ccx.int_type())\n+            bcx.trunc(llindex, bcx.ccx.isize_ty())\n         } else {\n             llindex\n         }"}, {"sha": "20ed4ab50a00f136065345fa903640923359048b", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -19,8 +19,7 @@ use rustc::middle::lang_items::ExchangeMallocFnLangItem;\n use base;\n use builder::Builder;\n use callee;\n-use common::{self, val_ty, C_bool, C_null, C_uint};\n-use common::{C_integral, C_i32};\n+use common::{self, val_ty, C_bool, C_i32, C_null, C_usize, C_uint};\n use adt;\n use machine;\n use monomorphize;\n@@ -92,7 +91,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 bcx\n             }\n \n-            mir::Rvalue::Repeat(ref elem, ref count) => {\n+            mir::Rvalue::Repeat(ref elem, count) => {\n                 let dest_ty = dest.ty.to_ty(bcx.tcx());\n \n                 // No need to inizialize memory of a zero-sized slice\n@@ -101,8 +100,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 }\n \n                 let tr_elem = self.trans_operand(&bcx, elem);\n-                let size = count.as_u64(bcx.tcx().sess.target.uint_type);\n-                let size = C_uint(bcx.ccx, size);\n+                let size = count.as_u64();\n+                let size = C_usize(bcx.ccx, size);\n                 let base = base::get_dataptr(&bcx, dest.llval);\n                 let align = dest.alignment.to_align();\n \n@@ -113,7 +112,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         let align = C_i32(bcx.ccx, align as i32);\n                         let ty = type_of::type_of(bcx.ccx, dest_ty);\n                         let size = machine::llsize_of(bcx.ccx, ty);\n-                        let fill = C_integral(Type::i8(bcx.ccx), 0, false);\n+                        let fill = C_uint(Type::i8(bcx.ccx), 0);\n                         base::call_memset(&bcx, base, fill, size, align, false);\n                         return bcx;\n                     }\n@@ -301,7 +300,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 base::call_assume(&bcx, bcx.icmp(\n                                     llvm::IntULE,\n                                     llval,\n-                                    C_integral(common::val_ty(llval), max, false)\n+                                    C_uint(common::val_ty(llval), max)\n                                 ));\n                             }\n \n@@ -464,7 +463,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n             mir::Rvalue::NullaryOp(mir::NullOp::SizeOf, ty) => {\n                 assert!(bcx.ccx.shared().type_is_sized(ty));\n-                let val = C_uint(bcx.ccx, bcx.ccx.size_of(ty));\n+                let val = C_usize(bcx.ccx, bcx.ccx.size_of(ty));\n                 let tcx = bcx.tcx();\n                 (bcx, OperandRef {\n                     val: OperandValue::Immediate(val),\n@@ -477,12 +476,12 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let llty = type_of::type_of(bcx.ccx, content_ty);\n                 let llsize = machine::llsize_of(bcx.ccx, llty);\n                 let align = bcx.ccx.align_of(content_ty);\n-                let llalign = C_uint(bcx.ccx, align);\n+                let llalign = C_usize(bcx.ccx, align as u64);\n                 let llty_ptr = llty.ptr_to();\n                 let box_ty = bcx.tcx().mk_box(content_ty);\n \n                 // Allocate space:\n-                let def_id = match bcx.tcx().lang_items.require(ExchangeMallocFnLangItem) {\n+                let def_id = match bcx.tcx().lang_items().require(ExchangeMallocFnLangItem) {\n                     Ok(id) => id,\n                     Err(s) => {\n                         bcx.sess().fatal(&format!(\"allocation of `{}` {}\", box_ty, s));\n@@ -522,7 +521,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             if let LocalRef::Operand(Some(op)) = self.locals[index] {\n                 if common::type_is_zero_size(bcx.ccx, op.ty) {\n                     if let ty::TyArray(_, n) = op.ty.sty {\n-                        return common::C_uint(bcx.ccx, n);\n+                        let n = n.val.to_const_int().unwrap().to_u64().unwrap();\n+                        return common::C_usize(bcx.ccx, n);\n                     }\n                 }\n             }"}, {"sha": "9a7f1524d209f7b0b16e82c159f1197395577acb", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -31,7 +31,7 @@ fn fn_once_adapter_instance<'a, 'tcx>(\n     debug!(\"fn_once_adapter_shim({:?}, {:?})\",\n            closure_did,\n            substs);\n-    let fn_once = tcx.lang_items.fn_once_trait().unwrap();\n+    let fn_once = tcx.lang_items().fn_once_trait().unwrap();\n     let call_once = tcx.associated_items(fn_once)\n         .find(|it| it.kind == ty::AssociatedKind::Method)\n         .unwrap().def_id;\n@@ -132,7 +132,7 @@ fn resolve_associated_item<'a, 'tcx>(\n             }\n         }\n         traits::VtableClosure(closure_data) => {\n-            let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n+            let trait_closure_kind = tcx.lang_items().fn_trait_kind(trait_id).unwrap();\n             resolve_closure(scx, closure_data.closure_def_id, closure_data.substs,\n                             trait_closure_kind)\n         }\n@@ -149,7 +149,7 @@ fn resolve_associated_item<'a, 'tcx>(\n                 substs: rcvr_substs\n             }\n         }\n-        traits::VtableBuiltin(..) if Some(trait_id) == tcx.lang_items.clone_trait() => {\n+        traits::VtableBuiltin(..) if Some(trait_id) == tcx.lang_items().clone_trait() => {\n             Instance {\n                 def: ty::InstanceDef::CloneShim(def_id, trait_ref.self_ty()),\n                 substs: rcvr_substs\n@@ -187,7 +187,7 @@ pub fn resolve<'a, 'tcx>(\n                 ty::InstanceDef::Intrinsic(def_id)\n             }\n             _ => {\n-                if Some(def_id) == scx.tcx().lang_items.drop_in_place_fn() {\n+                if Some(def_id) == scx.tcx().lang_items().drop_in_place_fn() {\n                     let ty = substs.type_at(0);\n                     if glue::needs_drop_glue(scx, ty) {\n                         debug!(\" => nontrivial drop glue\");\n@@ -224,7 +224,7 @@ pub fn custom_coerce_unsize_info<'scx, 'tcx>(scx: &SharedCrateContext<'scx, 'tcx\n                                              target_ty: Ty<'tcx>)\n                                              -> CustomCoerceUnsized {\n     let trait_ref = ty::Binder(ty::TraitRef {\n-        def_id: scx.tcx().lang_items.coerce_unsized_trait().unwrap(),\n+        def_id: scx.tcx().lang_items().coerce_unsized_trait().unwrap(),\n         substs: scx.tcx().mk_substs_trait(source_ty, &[target_ty])\n     });\n "}, {"sha": "1f27eb9fcb3095af2079e8ce2dd4101c84d6c18c", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -446,7 +446,8 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n             ty::TyArray(inner_type, len) => {\n                 output.push('[');\n                 self.push_type_name(inner_type, output);\n-                write!(output, \"; {}\", len).unwrap();\n+                write!(output, \"; {}\",\n+                    len.val.to_const_int().unwrap().to_u64().unwrap()).unwrap();\n                 output.push(']');\n             },\n             ty::TySlice(inner_type) => {"}, {"sha": "da4a4e55a67f4819356305a7b692979f8006b1af", "filename": "src/librustc_trans/tvec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftvec.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -34,7 +34,7 @@ pub fn slice_for_each<'a, 'tcx, F>(\n     let next_bcx = bcx.build_sibling_block(\"slice_loop_next\");\n \n     let start = if zst {\n-        C_uint(bcx.ccx, 0usize)\n+        C_usize(bcx.ccx, 1)\n     } else {\n         data_ptr\n     };\n@@ -46,7 +46,7 @@ pub fn slice_for_each<'a, 'tcx, F>(\n     let keep_going = header_bcx.icmp(llvm::IntNE, current, end);\n     header_bcx.cond_br(keep_going, body_bcx.llbb(), next_bcx.llbb());\n \n-    let next = add(&body_bcx, current, C_uint(bcx.ccx, 1usize));\n+    let next = add(&body_bcx, current, C_usize(bcx.ccx, 1));\n     f(&body_bcx, if zst { data_ptr } else { current }, header_bcx.llbb());\n     header_bcx.add_incoming_to_phi(current, next, body_bcx.llbb());\n     next_bcx"}, {"sha": "e5e532703d7d002ecf3a245ec6c6cd2bdb0b0a62", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -131,7 +131,7 @@ impl Type {\n         Type::i8_llcx(llcx).ptr_to()\n     }\n \n-    pub fn int(ccx: &CrateContext) -> Type {\n+    pub fn isize(ccx: &CrateContext) -> Type {\n         match &ccx.tcx().sess.target.target.target_pointer_width[..] {\n             \"16\" => Type::i16(ccx),\n             \"32\" => Type::i32(ccx),\n@@ -142,7 +142,7 @@ impl Type {\n \n     pub fn int_from_ty(ccx: &CrateContext, t: ast::IntTy) -> Type {\n         match t {\n-            ast::IntTy::Is => ccx.int_type(),\n+            ast::IntTy::Is => ccx.isize_ty(),\n             ast::IntTy::I8 => Type::i8(ccx),\n             ast::IntTy::I16 => Type::i16(ccx),\n             ast::IntTy::I32 => Type::i32(ccx),\n@@ -153,7 +153,7 @@ impl Type {\n \n     pub fn uint_from_ty(ccx: &CrateContext, t: ast::UintTy) -> Type {\n         match t {\n-            ast::UintTy::Us => ccx.int_type(),\n+            ast::UintTy::Us => ccx.isize_ty(),\n             ast::UintTy::U8 => Type::i8(ccx),\n             ast::UintTy::U16 => Type::i16(ccx),\n             ast::UintTy::U32 => Type::i32(ccx),\n@@ -207,7 +207,7 @@ impl Type {\n \n     pub fn vec(ccx: &CrateContext, ty: &Type) -> Type {\n         Type::struct_(ccx,\n-            &[Type::array(ty, 0), Type::int(ccx)],\n+            &[Type::array(ty, 0), Type::isize(ccx)],\n         false)\n     }\n "}, {"sha": "992c74b9020c314eddd516664cb693fc6c1279e0", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -148,8 +148,8 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n       }\n \n       ty::TyArray(ty, size) => {\n-          let size = size as u64;\n           let llty = in_memory_type_of(cx, ty);\n+          let size = size.val.to_const_int().unwrap().to_u64().unwrap();\n           Type::array(&llty, size)\n       }\n "}, {"sha": "8f8663385b02001e1de8a7f479670e664cade831", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -12,7 +12,7 @@\n //! representation.  The main routine here is `ast_ty_to_ty()`: each use\n //! is parameterized by an instance of `AstConv`.\n \n-use rustc::middle::const_val::eval_length;\n+use rustc::middle::const_val::ConstVal;\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n use hir;\n use hir::def::Def;\n@@ -96,22 +96,23 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         -> ty::Region<'tcx>\n     {\n         let tcx = self.tcx();\n-        let r = match tcx.named_region_map.defs.get(&lifetime.id) {\n-            Some(&rl::Region::Static) => {\n+        let hir_id = tcx.hir.node_to_hir_id(lifetime.id);\n+        let r = match tcx.named_region(hir_id) {\n+            Some(rl::Region::Static) => {\n                 tcx.types.re_static\n             }\n \n-            Some(&rl::Region::LateBound(debruijn, id)) => {\n+            Some(rl::Region::LateBound(debruijn, id)) => {\n                 let name = tcx.hir.name(id);\n                 tcx.mk_region(ty::ReLateBound(debruijn,\n                     ty::BrNamed(tcx.hir.local_def_id(id), name)))\n             }\n \n-            Some(&rl::Region::LateBoundAnon(debruijn, index)) => {\n+            Some(rl::Region::LateBoundAnon(debruijn, index)) => {\n                 tcx.mk_region(ty::ReLateBound(debruijn, ty::BrAnon(index)))\n             }\n \n-            Some(&rl::Region::EarlyBound(index, id)) => {\n+            Some(rl::Region::EarlyBound(index, id)) => {\n                 let name = tcx.hir.name(id);\n                 tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n                     def_id: tcx.hir.local_def_id(id),\n@@ -120,7 +121,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 }))\n             }\n \n-            Some(&rl::Region::Free(scope, id)) => {\n+            Some(rl::Region::Free(scope, id)) => {\n                 let name = tcx.hir.name(id);\n                 tcx.mk_region(ty::ReFree(ty::FreeRegion {\n                     scope,\n@@ -627,7 +628,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             self.ast_region_to_region(lifetime, None)\n         } else {\n             self.compute_object_lifetime_bound(span, existential_predicates).unwrap_or_else(|| {\n-                if tcx.named_region_map.defs.contains_key(&lifetime.id) {\n+                let hir_id = tcx.hir.node_to_hir_id(lifetime.id);\n+                if tcx.named_region(hir_id).is_some() {\n                     self.ast_region_to_region(lifetime, None)\n                 } else {\n                     self.re_infer(span, None).unwrap_or_else(|| {\n@@ -1080,11 +1082,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 self.associated_path_def_to_ty(ast_ty.id, ast_ty.span, ty, def, segment).0\n             }\n             hir::TyArray(ref ty, length) => {\n-                if let Ok(length) = eval_length(tcx, length, \"array length\") {\n-                    tcx.mk_array(self.ast_ty_to_ty(&ty), length)\n-                } else {\n-                    self.tcx().types.err\n-                }\n+                let length_def_id = tcx.hir.body_owner_def_id(length);\n+                let substs = Substs::identity_for_item(tcx, length_def_id);\n+                let length = tcx.mk_const(ty::Const {\n+                    val: ConstVal::Unevaluated(length_def_id, substs),\n+                    ty: tcx.types.usize\n+                });\n+                let array_ty = tcx.mk_ty(ty::TyArray(self.ast_ty_to_ty(&ty), length));\n+                self.normalize_ty(ast_ty.span, array_ty)\n             }\n             hir::TyTypeof(ref _e) => {\n                 struct_span_err!(tcx.sess, ast_ty.span, E0516,\n@@ -1286,8 +1291,8 @@ fn split_auto_traits<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n             Def::Trait(trait_did) => {\n                 // Checks whether `trait_did` refers to one of the builtin\n                 // traits, like `Send`, and adds it to `auto_traits` if so.\n-                if Some(trait_did) == tcx.lang_items.send_trait() ||\n-                    Some(trait_did) == tcx.lang_items.sync_trait() {\n+                if Some(trait_did) == tcx.lang_items().send_trait() ||\n+                    Some(trait_did) == tcx.lang_items().sync_trait() {\n                     let segments = &bound.trait_ref.path.segments;\n                     let parameters = &segments[segments.len() - 1].parameters;\n                     if !parameters.types.is_empty() {\n@@ -1400,7 +1405,7 @@ impl<'a, 'gcx, 'tcx> Bounds<'tcx> {\n \n         // If it could be sized, and is, add the sized predicate\n         if self.implicitly_sized {\n-            if let Some(sized) = tcx.lang_items.sized_trait() {\n+            if let Some(sized) = tcx.lang_items().sized_trait() {\n                 let trait_ref = ty::TraitRef {\n                     def_id: sized,\n                     substs: tcx.mk_substs_trait(param_ty, &[])"}, {"sha": "cbf58209d056aea6ed16e91be89041610f4f55a3", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -113,7 +113,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.demand_eqtype(pat.span, expected, rhs_ty);\n                 common_type\n             }\n-            PatKind::Binding(ba, def_id, _, ref sub) => {\n+            PatKind::Binding(ba, var_id, _, ref sub) => {\n                 // Note the binding mode in the typeck tables. For now, what we store is always\n                 // identical to what could be scraped from the HIR, but this will change with\n                 // default binding modes (#42640).\n@@ -149,7 +149,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 // if there are multiple arms, make sure they all agree on\n                 // what the type of the binding `x` ought to be\n-                let var_id = tcx.hir.as_local_node_id(def_id).unwrap();\n                 if var_id != pat.id {\n                     let vt = self.local_ty(pat.span, var_id);\n                     self.demand_eqtype(pat.span, vt, typ);\n@@ -265,7 +264,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let expected_ty = self.structurally_resolved_type(pat.span, expected);\n                 let (inner_ty, slice_ty) = match expected_ty.sty {\n                     ty::TyArray(inner_ty, size) => {\n-                        let min_len = before.len() + after.len();\n+                        let size = size.val.to_const_int().unwrap().to_u64().unwrap();\n+                        let min_len = before.len() as u64 + after.len() as u64;\n                         if slice.is_none() {\n                             if min_len != size {\n                                 struct_span_err!("}, {"sha": "a25deb7685af5902d7722ba4158fd9fc150f664c", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -108,7 +108,7 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n \n         // <cur_ty as Deref>\n         let trait_ref = TraitRef {\n-            def_id: match tcx.lang_items.deref_trait() {\n+            def_id: match tcx.lang_items().deref_trait() {\n                 Some(f) => f,\n                 None => return None,\n             },"}, {"sha": "7461df8bda509b1d66ed57cfc68ce0065ccb983f", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -28,7 +28,7 @@ use rustc::hir;\n /// to `trait_id` (this only cares about the trait, not the specific\n /// method that is called)\n pub fn check_legal_trait_for_method_call(tcx: TyCtxt, span: Span, trait_id: DefId) {\n-    if tcx.lang_items.drop_trait() == Some(trait_id) {\n+    if tcx.lang_items().drop_trait() == Some(trait_id) {\n         struct_span_err!(tcx.sess, span, E0040, \"explicit use of destructor method\")\n             .span_label(span, \"explicit destructor calls not allowed\")\n             .emit();\n@@ -157,9 +157,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                              MethodCallee<'tcx>)> {\n         // Try the options that are least restrictive on the caller first.\n         for &(opt_trait_def_id, method_name, borrow) in\n-            &[(self.tcx.lang_items.fn_trait(), Symbol::intern(\"call\"), true),\n-              (self.tcx.lang_items.fn_mut_trait(), Symbol::intern(\"call_mut\"), true),\n-              (self.tcx.lang_items.fn_once_trait(), Symbol::intern(\"call_once\"), false)] {\n+            &[(self.tcx.lang_items().fn_trait(), Symbol::intern(\"call\"), true),\n+              (self.tcx.lang_items().fn_mut_trait(), Symbol::intern(\"call_mut\"), true),\n+              (self.tcx.lang_items().fn_once_trait(), Symbol::intern(\"call_once\"), false)] {\n             let trait_def_id = match opt_trait_def_id {\n                 Some(def_id) => def_id,\n                 None => continue,\n@@ -227,10 +227,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     } else {\n                         Def::Err\n                     };\n-                    if def != Def::Err {\n-                        if let Some(span) = self.tcx.hir.span_if_local(def.def_id()) {\n-                            err.span_note(span, \"defined here\");\n+                    let def_span = match def {\n+                        Def::Err => None,\n+                        Def::Local(id) | Def::Upvar(id, ..) => {\n+                            Some(self.tcx.hir.span(id))\n                         }\n+                        _ => self.tcx.hir.span_if_local(def.def_id())\n+                    };\n+                    if let Some(span) = def_span {\n+                        err.span_note(span, \"defined here\");\n                     }\n                 }\n "}, {"sha": "07159770d5ba2a15766553e188692c9fed78f434", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -139,7 +139,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     })\n                     .next();\n                 let kind = object_type.principal()\n-                    .and_then(|p| self.tcx.lang_items.fn_trait_kind(p.def_id()));\n+                    .and_then(|p| self.tcx.lang_items().fn_trait_kind(p.def_id()));\n                 (sig, kind)\n             }\n             ty::TyInfer(ty::TyVar(vid)) => self.deduce_expectations_from_obligations(vid),\n@@ -192,6 +192,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     ty::Predicate::TypeOutlives(..) => None,\n                     ty::Predicate::WellFormed(..) => None,\n                     ty::Predicate::ObjectSafe(..) => None,\n+                    ty::Predicate::ConstEvaluatable(..) => None,\n \n                     // NB: This predicate is created by breaking down a\n                     // `ClosureType: FnFoo()` predicate, where\n@@ -204,7 +205,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     ty::Predicate::ClosureKind(..) => None,\n                 };\n                 opt_trait_ref.and_then(|tr| self.self_type_matches_expected_vid(tr, expected_vid))\n-                    .and_then(|tr| self.tcx.lang_items.fn_trait_kind(tr.def_id()))\n+                    .and_then(|tr| self.tcx.lang_items().fn_trait_kind(tr.def_id()))\n             })\n             .fold(None,\n                   |best, cur| Some(best.map_or(cur, |best| cmp::min(best, cur))));\n@@ -223,7 +224,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let trait_ref = projection.to_poly_trait_ref(tcx);\n \n-        if tcx.lang_items.fn_trait_kind(trait_ref.def_id()).is_none() {\n+        if tcx.lang_items().fn_trait_kind(trait_ref.def_id()).is_none() {\n             return None;\n         }\n "}, {"sha": "cfcdbcc11959bdba6664f2a9f7d12d4135f6cf34", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -438,8 +438,8 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n     fn coerce_unsized(&self, source: Ty<'tcx>, target: Ty<'tcx>) -> CoerceResult<'tcx> {\n         debug!(\"coerce_unsized(source={:?}, target={:?})\", source, target);\n \n-        let traits = (self.tcx.lang_items.unsize_trait(),\n-                      self.tcx.lang_items.coerce_unsized_trait());\n+        let traits = (self.tcx.lang_items().unsize_trait(),\n+                      self.tcx.lang_items().coerce_unsized_trait());\n         let (unsize_did, coerce_unsized_did) = if let (Some(u), Some(cu)) = traits {\n             (u, cu)\n         } else {"}, {"sha": "65900dc3f36e7d8242903846e0995187ac6858ee", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -207,7 +207,29 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                  expected: Ty<'tcx>)\n                  -> Option<String> {\n         match (&expected.sty, &checked_ty.sty) {\n-            (&ty::TyRef(_, _), &ty::TyRef(_, _)) => None,\n+            (&ty::TyRef(_, exp), &ty::TyRef(_, check)) => match (&exp.ty.sty, &check.ty.sty) {\n+                (&ty::TyStr, &ty::TyArray(arr, _)) |\n+                (&ty::TyStr, &ty::TySlice(arr)) if arr == self.tcx.types.u8 => {\n+                    if let hir::ExprLit(_) = expr.node {\n+                        let sp = self.sess().codemap().call_span_if_macro(expr.span);\n+                        if let Ok(src) = self.tcx.sess.codemap().span_to_snippet(sp) {\n+                            return Some(format!(\"try `{}`\", &src[1..]));\n+                        }\n+                    }\n+                    None\n+                },\n+                (&ty::TyArray(arr, _), &ty::TyStr) |\n+                (&ty::TySlice(arr), &ty::TyStr) if arr == self.tcx.types.u8 => {\n+                    if let hir::ExprLit(_) = expr.node {\n+                        let sp = self.sess().codemap().call_span_if_macro(expr.span);\n+                        if let Ok(src) = self.tcx.sess.codemap().span_to_snippet(sp) {\n+                            return Some(format!(\"try `b{}`\", src));\n+                        }\n+                    }\n+                    None\n+                }\n+                _ => None,\n+            },\n             (&ty::TyRef(_, mutability), _) => {\n                 // Check if it can work when put into a ref. For example:\n                 //"}, {"sha": "fa8d3b9bcc1cb41cc2eb5df9f32285a90d9c9b96", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -360,7 +360,7 @@ pub fn check_platform_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             match name[\"simd_shuffle\".len()..].parse() {\n                 Ok(n) => {\n                     let params = vec![param(0), param(0),\n-                                      tcx.mk_ty(ty::TyArray(tcx.types.u32, n))];\n+                                      tcx.mk_array(tcx.types.u32, n)];\n                     (2, params, param(1))\n                 }\n                 Err(_) => {"}, {"sha": "852134bbee3154e516d59a08a0b37259a2fec744", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -540,7 +540,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     fn predicates_require_illegal_sized_bound(&self,\n                                               predicates: &ty::InstantiatedPredicates<'tcx>)\n                                               -> bool {\n-        let sized_def_id = match self.tcx.lang_items.sized_trait() {\n+        let sized_def_id = match self.tcx.lang_items().sized_trait() {\n             Some(def_id) => def_id,\n             None => return false,\n         };"}, {"sha": "7b94781832512da2fecc36399fcecdee1e84d4a9", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -393,6 +393,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     fn assemble_probe(&mut self, self_ty: Ty<'tcx>) {\n         debug!(\"assemble_probe: self_ty={:?}\", self_ty);\n+        let lang_items = self.tcx.lang_items();\n \n         match self_ty.sty {\n             ty::TyDynamic(ref data, ..) => {\n@@ -408,79 +409,79 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 self.assemble_inherent_candidates_from_param(self_ty, p);\n             }\n             ty::TyChar => {\n-                let lang_def_id = self.tcx.lang_items.char_impl();\n+                let lang_def_id = lang_items.char_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyStr => {\n-                let lang_def_id = self.tcx.lang_items.str_impl();\n+                let lang_def_id = lang_items.str_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TySlice(_) => {\n-                let lang_def_id = self.tcx.lang_items.slice_impl();\n+                let lang_def_id = lang_items.slice_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n-                let lang_def_id = self.tcx.lang_items.const_ptr_impl();\n+                let lang_def_id = lang_items.const_ptr_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n-                let lang_def_id = self.tcx.lang_items.mut_ptr_impl();\n+                let lang_def_id = lang_items.mut_ptr_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyInt(ast::IntTy::I8) => {\n-                let lang_def_id = self.tcx.lang_items.i8_impl();\n+                let lang_def_id = lang_items.i8_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyInt(ast::IntTy::I16) => {\n-                let lang_def_id = self.tcx.lang_items.i16_impl();\n+                let lang_def_id = lang_items.i16_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyInt(ast::IntTy::I32) => {\n-                let lang_def_id = self.tcx.lang_items.i32_impl();\n+                let lang_def_id = lang_items.i32_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyInt(ast::IntTy::I64) => {\n-                let lang_def_id = self.tcx.lang_items.i64_impl();\n+                let lang_def_id = lang_items.i64_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyInt(ast::IntTy::I128) => {\n-                let lang_def_id = self.tcx.lang_items.i128_impl();\n+                let lang_def_id = lang_items.i128_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyInt(ast::IntTy::Is) => {\n-                let lang_def_id = self.tcx.lang_items.isize_impl();\n+                let lang_def_id = lang_items.isize_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyUint(ast::UintTy::U8) => {\n-                let lang_def_id = self.tcx.lang_items.u8_impl();\n+                let lang_def_id = lang_items.u8_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyUint(ast::UintTy::U16) => {\n-                let lang_def_id = self.tcx.lang_items.u16_impl();\n+                let lang_def_id = lang_items.u16_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyUint(ast::UintTy::U32) => {\n-                let lang_def_id = self.tcx.lang_items.u32_impl();\n+                let lang_def_id = lang_items.u32_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyUint(ast::UintTy::U64) => {\n-                let lang_def_id = self.tcx.lang_items.u64_impl();\n+                let lang_def_id = lang_items.u64_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyUint(ast::UintTy::U128) => {\n-                let lang_def_id = self.tcx.lang_items.u128_impl();\n+                let lang_def_id = lang_items.u128_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyUint(ast::UintTy::Us) => {\n-                let lang_def_id = self.tcx.lang_items.usize_impl();\n+                let lang_def_id = lang_items.usize_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyFloat(ast::FloatTy::F32) => {\n-                let lang_def_id = self.tcx.lang_items.f32_impl();\n+                let lang_def_id = lang_items.f32_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyFloat(ast::FloatTy::F64) => {\n-                let lang_def_id = self.tcx.lang_items.f64_impl();\n+                let lang_def_id = lang_items.f64_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             _ => {}\n@@ -589,7 +590,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                     ty::Predicate::WellFormed(..) |\n                     ty::Predicate::ObjectSafe(..) |\n                     ty::Predicate::ClosureKind(..) |\n-                    ty::Predicate::TypeOutlives(..) => None,\n+                    ty::Predicate::TypeOutlives(..) |\n+                    ty::Predicate::ConstEvaluatable(..) => None,\n                 }\n             })\n             .collect();"}, {"sha": "7fa3dd7472db804dbf623914a610d439d943a13b", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -45,7 +45,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             ty::TyFnPtr(_) => true,\n             // If it's not a simple function, look for things which implement FnOnce\n             _ => {\n-                let fn_once = match tcx.lang_items.require(FnOnceTraitLangItem) {\n+                let fn_once = match tcx.lang_items().require(FnOnceTraitLangItem) {\n                     Ok(fn_once) => fn_once,\n                     Err(..) => return false,\n                 };\n@@ -552,14 +552,14 @@ pub fn all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> AllTraits<'a>\n                     if !external_mods.insert(def_id) {\n                         return;\n                     }\n-                    for child in tcx.sess.cstore.item_children(def_id, tcx.sess) {\n+                    for child in tcx.item_children(def_id).iter() {\n                         handle_external_def(tcx, traits, external_mods, child.def)\n                     }\n                 }\n                 _ => {}\n             }\n         }\n-        for cnum in tcx.sess.cstore.crates() {\n+        for &cnum in tcx.crates().iter() {\n             let def_id = DefId {\n                 krate: cnum,\n                 index: CRATE_DEF_INDEX,"}, {"sha": "ae2430990ba5794d008b7a83d10809325eba0a12", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -128,7 +128,6 @@ use rustc::hir::map::Node;\n use rustc::hir::{self, PatKind};\n use rustc::middle::lang_items;\n use rustc_back::slice;\n-use rustc::middle::const_val::eval_length;\n use rustc_const_math::ConstInt;\n \n mod autoderef;\n@@ -1554,9 +1553,12 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let repr_type_ty = def.repr.discr_type().to_ty(tcx);\n     if repr_type_ty == tcx.types.i128 || repr_type_ty == tcx.types.u128 {\n-        if !tcx.sess.features.borrow().i128_type {\n+        if !tcx.sess.features.borrow().repr128 {\n             emit_feature_err(&tcx.sess.parse_sess,\n-                             \"i128_type\", sp, GateIssue::Language, \"128-bit type is unstable\");\n+                             \"repr128\",\n+                             sp,\n+                             GateIssue::Language,\n+                             \"repr with 128-bit type is unstable\");\n         }\n     }\n \n@@ -2296,13 +2298,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn resolve_lvalue_op(&self, op: LvalueOp, is_mut: bool) -> (Option<DefId>, Symbol) {\n         let (tr, name) = match (op, is_mut) {\n             (LvalueOp::Deref, false) =>\n-                (self.tcx.lang_items.deref_trait(), \"deref\"),\n+                (self.tcx.lang_items().deref_trait(), \"deref\"),\n             (LvalueOp::Deref, true) =>\n-                (self.tcx.lang_items.deref_mut_trait(), \"deref_mut\"),\n+                (self.tcx.lang_items().deref_mut_trait(), \"deref_mut\"),\n             (LvalueOp::Index, false) =>\n-                (self.tcx.lang_items.index_trait(), \"index\"),\n+                (self.tcx.lang_items().index_trait(), \"index\"),\n             (LvalueOp::Index, true) =>\n-                (self.tcx.lang_items.index_mut_trait(), \"index_mut\"),\n+                (self.tcx.lang_items().index_mut_trait(), \"index_mut\"),\n         };\n         (tr, Symbol::intern(name))\n     }\n@@ -2633,7 +2635,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             ast::LitKind::Str(..) => tcx.mk_static_str(),\n             ast::LitKind::ByteStr(ref v) => {\n                 tcx.mk_imm_ref(tcx.types.re_static,\n-                                tcx.mk_array(tcx.types.u8, v.len()))\n+                                tcx.mk_array(tcx.types.u8, v.len() as u64))\n             }\n             ast::LitKind::Byte(_) => tcx.types.u8,\n             ast::LitKind::Char(_) => tcx.types.char,\n@@ -3892,11 +3894,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n               } else {\n                   self.next_ty_var(TypeVariableOrigin::TypeInference(expr.span))\n               };\n-              tcx.mk_array(element_ty, args.len())\n+              tcx.mk_array(element_ty, args.len() as u64)\n           }\n           hir::ExprRepeat(ref element, count) => {\n-            let count = eval_length(self.tcx, count, \"repeat count\")\n-                  .unwrap_or(0);\n+            let count_def_id = tcx.hir.body_owner_def_id(count);\n+            let param_env = ty::ParamEnv::empty(traits::Reveal::UserFacing);\n+            let substs = Substs::identity_for_item(tcx.global_tcx(), count_def_id);\n+            let count = tcx.const_eval(param_env.and((count_def_id, substs)));\n+\n+            if let Err(ref err) = count {\n+               err.report(tcx, tcx.def_span(count_def_id), \"constant expression\");\n+            }\n \n             let uty = match expected {\n                 ExpectHasType(uty) => {\n@@ -3920,17 +3928,24 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             };\n \n-            if count > 1 {\n-                // For [foo, ..n] where n > 1, `foo` must have\n-                // Copy type:\n-                let lang_item = self.tcx.require_lang_item(lang_items::CopyTraitLangItem);\n-                self.require_type_meets(t, expr.span, traits::RepeatVec, lang_item);\n+            if let Ok(count) = count {\n+                let zero_or_one = count.val.to_const_int().and_then(|count| {\n+                    count.to_u64().map(|count| count <= 1)\n+                }).unwrap_or(false);\n+                if !zero_or_one {\n+                    // For [foo, ..n] where n > 1, `foo` must have\n+                    // Copy type:\n+                    let lang_item = self.tcx.require_lang_item(lang_items::CopyTraitLangItem);\n+                    self.require_type_meets(t, expr.span, traits::RepeatVec, lang_item);\n+                }\n             }\n \n             if element_ty.references_error() {\n                 tcx.types.err\n+            } else if let Ok(count) = count {\n+                tcx.mk_ty(ty::TyArray(t, count))\n             } else {\n-                tcx.mk_array(t, count)\n+                tcx.types.err\n             }\n           }\n           hir::ExprTup(ref elts) => {\n@@ -4612,8 +4627,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         AstConv::prohibit_type_params(self, &segments[..segments.len() - poly_segments]);\n \n         match def {\n-            Def::Local(def_id) | Def::Upvar(def_id, ..) => {\n-                let nid = self.tcx.hir.as_local_node_id(def_id).unwrap();\n+            Def::Local(nid) | Def::Upvar(nid, ..) => {\n                 let ty = self.local_ty(span, nid);\n                 let ty = self.normalize_associated_types_in(span, &ty);\n                 self.write_ty(self.tcx.hir.node_to_hir_id(node_id), ty);"}, {"sha": "a3dd81fdddee33d78a664faa7786ce3e749648b4", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -362,7 +362,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn lookup_op_method(&self, lhs_ty: Ty<'tcx>, other_tys: &[Ty<'tcx>], op: Op)\n                         -> Result<MethodCallee<'tcx>, ()>\n     {\n-        let lang = &self.tcx.lang_items;\n+        let lang = self.tcx.lang_items();\n \n         let span = match op {\n             Op::Binary(op, _) => op.span,"}, {"sha": "609af638e97c65476968fc3300fd81db87284bac", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -511,7 +511,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                             ty::Predicate::Subtype(..) |\n                             ty::Predicate::Projection(..) |\n                             ty::Predicate::ClosureKind(..) |\n-                            ty::Predicate::ObjectSafe(..) =>\n+                            ty::Predicate::ObjectSafe(..) |\n+                            ty::Predicate::ConstEvaluatable(..) =>\n                                 vec![],\n \n                             ty::Predicate::WellFormed(subty) => {"}, {"sha": "acdd58f4ecfe43c92d640b92800653e38ae56b24", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -126,9 +126,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         self.tcx.with_freevars(closure_node_id, |freevars| {\n             for freevar in freevars {\n-                let var_def_id = freevar.def.def_id();\n                 let upvar_id = ty::UpvarId {\n-                    var_id: var_def_id.index,\n+                    var_id: self.tcx.hir.node_to_hir_id(freevar.var_id()),\n                     closure_expr_id: closure_def_id.index,\n                 };\n                 debug!(\"seed upvar_id {:?}\", upvar_id);\n@@ -236,11 +235,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         tcx.with_freevars(closure_id, |freevars| {\n             freevars.iter().map(|freevar| {\n-                let var_def_id = freevar.def.def_id();\n-                let var_node_id = tcx.hir.as_local_node_id(var_def_id).unwrap();\n-                let freevar_ty = self.node_ty(tcx.hir.node_to_hir_id(var_node_id));\n+                let var_node_id = freevar.var_id();\n+                let var_hir_id = tcx.hir.node_to_hir_id(var_node_id);\n+                let freevar_ty = self.node_ty(var_hir_id);\n                 let upvar_id = ty::UpvarId {\n-                    var_id: var_def_id.index,\n+                    var_id: var_hir_id,\n                     closure_expr_id: closure_def_index,\n                 };\n                 let capture = self.tables.borrow().upvar_capture(upvar_id);\n@@ -587,7 +586,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'gcx, 'tcx> {\n     }\n }\n \n-fn var_name(tcx: ty::TyCtxt, var_def_index: DefIndex) -> ast::Name {\n-    let var_node_id = tcx.hir.def_index_to_node_id(var_def_index);\n+fn var_name(tcx: ty::TyCtxt, var_hir_id: hir::HirId) -> ast::Name {\n+    let var_node_id = tcx.hir.hir_to_node_id(var_hir_id);\n     tcx.hir.name(var_node_id)\n }"}, {"sha": "9c19aef5992e698bd324f5e56199200eacee4de3", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -539,7 +539,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n     {\n         let mut err = error_392(self.tcx, span, param_name);\n \n-        let suggested_marker_id = self.tcx.lang_items.phantom_data();\n+        let suggested_marker_id = self.tcx.lang_items().phantom_data();\n         match suggested_marker_id {\n             Some(def_id) => {\n                 err.help("}, {"sha": "0c35b5e6834deb2a87b62dd5b2e1074d9b9e8d94", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -14,8 +14,9 @@ use rustc::ty::TyCtxt;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n \n-use rustc::hir;\n+use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::hir;\n use rustc::util::nodemap::DefIdSet;\n \n struct CheckVisitor<'a, 'tcx: 'a> {\n@@ -25,7 +26,8 @@ struct CheckVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> CheckVisitor<'a, 'tcx> {\n     fn check_import(&self, id: ast::NodeId, span: Span) {\n-        if !self.tcx.maybe_unused_trait_imports.contains(&id) {\n+        let def_id = self.tcx.hir.local_def_id(id);\n+        if !self.tcx.maybe_unused_trait_import(def_id) {\n             return;\n         }\n \n@@ -73,14 +75,22 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut visitor = CheckVisitor { tcx, used_trait_imports };\n     tcx.hir.krate().visit_all_item_likes(&mut visitor);\n \n-    for &(id, span) in &tcx.maybe_unused_extern_crates {\n-        let cnum = tcx.sess.cstore.extern_mod_stmt_cnum(id).unwrap().as_def_id();\n-        if !tcx.is_compiler_builtins(cnum)\n-            && !tcx.is_panic_runtime(cnum)\n-            && !tcx.has_global_allocator(cnum) {\n-                let lint = lint::builtin::UNUSED_EXTERN_CRATES;\n-                let msg = \"unused extern crate\";\n-                tcx.lint_node(lint, id, span, msg);\n-            }\n+    for &(def_id, span) in tcx.maybe_unused_extern_crates(LOCAL_CRATE).iter() {\n+        let cnum = tcx.extern_mod_stmt_cnum(def_id).unwrap();\n+        if tcx.is_compiler_builtins(cnum) {\n+            continue\n+        }\n+        if tcx.is_panic_runtime(cnum) {\n+            continue\n+        }\n+        if tcx.has_global_allocator(cnum) {\n+            continue\n+        }\n+        assert_eq!(def_id.krate, LOCAL_CRATE);\n+        let hir_id = tcx.hir.definitions().def_index_to_hir_id(def_id.index);\n+        let id = tcx.hir.definitions().find_node_for_hir_id(hir_id);\n+        let lint = lint::builtin::UNUSED_EXTERN_CRATES;\n+        let msg = \"unused extern crate\";\n+        tcx.lint_node(lint, id, span, msg);\n     }\n }"}, {"sha": "fedfa51d61d115efde45a784e9a5e6c73e55e233", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -28,9 +28,9 @@ use rustc::hir::{self, ItemImpl};\n \n pub fn check_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_def_id: DefId) {\n     Checker { tcx, trait_def_id }\n-        .check(tcx.lang_items.drop_trait(), visit_implementation_of_drop)\n-        .check(tcx.lang_items.copy_trait(), visit_implementation_of_copy)\n-        .check(tcx.lang_items.coerce_unsized_trait(),\n+        .check(tcx.lang_items().drop_trait(), visit_implementation_of_drop)\n+        .check(tcx.lang_items().copy_trait(), visit_implementation_of_copy)\n+        .check(tcx.lang_items().coerce_unsized_trait(),\n                visit_implementation_of_coerce_unsized);\n }\n \n@@ -176,9 +176,9 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      impl_did: DefId)\n                                      -> CoerceUnsizedInfo {\n     debug!(\"compute_coerce_unsized_info(impl_did={:?})\", impl_did);\n-    let coerce_unsized_trait = tcx.lang_items.coerce_unsized_trait().unwrap();\n+    let coerce_unsized_trait = tcx.lang_items().coerce_unsized_trait().unwrap();\n \n-    let unsize_trait = match tcx.lang_items.require(UnsizeTraitLangItem) {\n+    let unsize_trait = match tcx.lang_items().require(UnsizeTraitLangItem) {\n         Ok(id) => id,\n         Err(err) => {\n             tcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err));"}, {"sha": "15e15abfb3606d4c5fcf1da5e2589dbc209626b2", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -112,6 +112,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n \n         let def_id = self.tcx.hir.local_def_id(item.id);\n         let self_ty = self.tcx.type_of(def_id);\n+        let lang_items = self.tcx.lang_items();\n         match self_ty.sty {\n             ty::TyAdt(def, _) => {\n                 self.check_def_id(item, def.did);\n@@ -121,133 +122,133 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n             }\n             ty::TyChar => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.char_impl(),\n+                                          lang_items.char_impl(),\n                                           \"char\",\n                                           \"char\",\n                                           item.span);\n             }\n             ty::TyStr => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.str_impl(),\n+                                          lang_items.str_impl(),\n                                           \"str\",\n                                           \"str\",\n                                           item.span);\n             }\n             ty::TySlice(_) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.slice_impl(),\n+                                          lang_items.slice_impl(),\n                                           \"slice\",\n                                           \"[T]\",\n                                           item.span);\n             }\n             ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.const_ptr_impl(),\n+                                          lang_items.const_ptr_impl(),\n                                           \"const_ptr\",\n                                           \"*const T\",\n                                           item.span);\n             }\n             ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.mut_ptr_impl(),\n+                                          lang_items.mut_ptr_impl(),\n                                           \"mut_ptr\",\n                                           \"*mut T\",\n                                           item.span);\n             }\n             ty::TyInt(ast::IntTy::I8) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.i8_impl(),\n+                                          lang_items.i8_impl(),\n                                           \"i8\",\n                                           \"i8\",\n                                           item.span);\n             }\n             ty::TyInt(ast::IntTy::I16) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.i16_impl(),\n+                                          lang_items.i16_impl(),\n                                           \"i16\",\n                                           \"i16\",\n                                           item.span);\n             }\n             ty::TyInt(ast::IntTy::I32) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.i32_impl(),\n+                                          lang_items.i32_impl(),\n                                           \"i32\",\n                                           \"i32\",\n                                           item.span);\n             }\n             ty::TyInt(ast::IntTy::I64) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.i64_impl(),\n+                                          lang_items.i64_impl(),\n                                           \"i64\",\n                                           \"i64\",\n                                           item.span);\n             }\n             ty::TyInt(ast::IntTy::I128) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.i128_impl(),\n+                                          lang_items.i128_impl(),\n                                           \"i128\",\n                                           \"i128\",\n                                           item.span);\n             }\n             ty::TyInt(ast::IntTy::Is) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.isize_impl(),\n+                                          lang_items.isize_impl(),\n                                           \"isize\",\n                                           \"isize\",\n                                           item.span);\n             }\n             ty::TyUint(ast::UintTy::U8) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.u8_impl(),\n+                                          lang_items.u8_impl(),\n                                           \"u8\",\n                                           \"u8\",\n                                           item.span);\n             }\n             ty::TyUint(ast::UintTy::U16) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.u16_impl(),\n+                                          lang_items.u16_impl(),\n                                           \"u16\",\n                                           \"u16\",\n                                           item.span);\n             }\n             ty::TyUint(ast::UintTy::U32) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.u32_impl(),\n+                                          lang_items.u32_impl(),\n                                           \"u32\",\n                                           \"u32\",\n                                           item.span);\n             }\n             ty::TyUint(ast::UintTy::U64) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.u64_impl(),\n+                                          lang_items.u64_impl(),\n                                           \"u64\",\n                                           \"u64\",\n                                           item.span);\n             }\n             ty::TyUint(ast::UintTy::U128) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.u128_impl(),\n+                                          lang_items.u128_impl(),\n                                           \"u128\",\n                                           \"u128\",\n                                           item.span);\n             }\n             ty::TyUint(ast::UintTy::Us) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.usize_impl(),\n+                                          lang_items.usize_impl(),\n                                           \"usize\",\n                                           \"usize\",\n                                           item.span);\n             }\n             ty::TyFloat(ast::FloatTy::F32) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.f32_impl(),\n+                                          lang_items.f32_impl(),\n                                           \"f32\",\n                                           \"f32\",\n                                           item.span);\n             }\n             ty::TyFloat(ast::FloatTy::F64) => {\n                 self.check_primitive_impl(def_id,\n-                                          self.tcx.lang_items.f64_impl(),\n+                                          lang_items.f64_impl(),\n                                           \"f64\",\n                                           \"f64\",\n                                           item.span);"}, {"sha": "6109fc57b0dfccfa5f6041e627d5e7d304ccc5f0", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -51,7 +51,7 @@ fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeId) {\n \n fn enforce_trait_manually_implementable(tcx: TyCtxt, impl_def_id: DefId, trait_def_id: DefId) {\n     let did = Some(trait_def_id);\n-    let li = &tcx.lang_items;\n+    let li = tcx.lang_items();\n \n     // Disallow *all* explicit impls of `Sized` and `Unsize` for now.\n     if did == li.sized_trait() {"}, {"sha": "1735ec7cc698c29788d0cdc51a0aa3de97536420", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -572,7 +572,7 @@ fn convert_enum_variant_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n \n             match result {\n-                Ok(ConstVal::Integral(x)) => Some(x),\n+                Ok(&ty::Const { val: ConstVal::Integral(x), .. }) => Some(x),\n                 _ => None\n             }\n         } else if let Some(discr) = repr_type.disr_incr(tcx, prev_discr) {\n@@ -812,7 +812,8 @@ fn has_late_bound_regions<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         fn visit_lifetime(&mut self, lt: &'tcx hir::Lifetime) {\n             if self.has_late_bound_regions.is_some() { return }\n \n-            match self.tcx.named_region_map.defs.get(&lt.id).cloned() {\n+            let hir_id = self.tcx.hir.node_to_hir_id(lt.id);\n+            match self.tcx.named_region(hir_id) {\n                 Some(rl::Region::Static) | Some(rl::Region::EarlyBound(..)) => {}\n                 Some(rl::Region::LateBound(debruijn, _)) |\n                 Some(rl::Region::LateBoundAnon(debruijn, _))\n@@ -830,7 +831,8 @@ fn has_late_bound_regions<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             tcx, binder_depth: 1, has_late_bound_regions: None\n         };\n         for lifetime in &generics.lifetimes {\n-            if tcx.named_region_map.late_bound.contains(&lifetime.lifetime.id) {\n+            let hir_id = tcx.hir.node_to_hir_id(lifetime.lifetime.id);\n+            if tcx.is_late_bound(hir_id) {\n                 return Some(lifetime.lifetime.span);\n             }\n         }\n@@ -987,8 +989,8 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }).collect::<Vec<_>>();\n \n-    let object_lifetime_defaults =\n-        tcx.named_region_map.object_lifetime_defaults.get(&node_id);\n+    let hir_id = tcx.hir.node_to_hir_id(node_id);\n+    let object_lifetime_defaults = tcx.object_lifetime_defaults(hir_id);\n \n     // Now create the real type parameters.\n     let type_start = own_start + regions.len() as u32;\n@@ -1014,7 +1016,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             def_id: tcx.hir.local_def_id(p.id),\n             has_default: p.default.is_some(),\n             object_lifetime_default:\n-                object_lifetime_defaults.map_or(rl::Set1::Empty, |o| o[i]),\n+                object_lifetime_defaults.as_ref().map_or(rl::Set1::Empty, |o| o[i]),\n             pure_wrt_drop: p.pure_wrt_drop,\n         }\n     });\n@@ -1307,7 +1309,7 @@ fn is_unsized<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n         }\n     }\n \n-    let kind_id = tcx.lang_items.require(SizedTraitLangItem);\n+    let kind_id = tcx.lang_items().require(SizedTraitLangItem);\n     match unbound {\n         Some(ref tpb) => {\n             // FIXME(#8559) currently requires the unbound to be built-in.\n@@ -1343,7 +1345,10 @@ fn early_bound_lifetimes_from_generics<'a, 'tcx>(\n     ast_generics\n         .lifetimes\n         .iter()\n-        .filter(move |l| !tcx.named_region_map.late_bound.contains(&l.lifetime.id))\n+        .filter(move |l| {\n+            let hir_id = tcx.hir.node_to_hir_id(l.lifetime.id);\n+            !tcx.is_late_bound(hir_id)\n+        })\n }\n \n fn predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "ac3d575b64882de9516d892a213abd16fb46e293", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -94,18 +94,10 @@ pub fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n }\n \n fn lang_items(tcx: TyCtxt) -> Vec<(ast::NodeId, Vec<ty::Variance>)> {\n+    let lang_items = tcx.lang_items();\n     let all = vec![\n-        (tcx.lang_items.phantom_data(), vec![ty::Covariant]),\n-        (tcx.lang_items.unsafe_cell_type(), vec![ty::Invariant]),\n-\n-        // Deprecated:\n-        (tcx.lang_items.covariant_type(), vec![ty::Covariant]),\n-        (tcx.lang_items.contravariant_type(), vec![ty::Contravariant]),\n-        (tcx.lang_items.invariant_type(), vec![ty::Invariant]),\n-        (tcx.lang_items.covariant_lifetime(), vec![ty::Covariant]),\n-        (tcx.lang_items.contravariant_lifetime(), vec![ty::Contravariant]),\n-        (tcx.lang_items.invariant_lifetime(), vec![ty::Invariant]),\n-\n+        (lang_items.phantom_data(), vec![ty::Covariant]),\n+        (lang_items.unsafe_cell_type(), vec![ty::Invariant]),\n         ];\n \n     all.into_iter() // iterating over (Option<DefId>, Variance)"}, {"sha": "61ac541e2c13998aec67606c3fe0b4264a3a6707", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -7,6 +7,8 @@ build = \"build.rs\"\n [lib]\n name = \"rustdoc\"\n path = \"lib.rs\"\n+# SNAP/stage0(cargo)\n+doctest = false\n \n [dependencies]\n env_logger = { version = \"0.4\", default-features = false }"}, {"sha": "830492dec9482f0c7857529d5583f727231116a0", "filename": "src/librustdoc/build.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustdoc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustdoc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fbuild.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -14,7 +14,7 @@ extern crate gcc;\n fn main() {\n     let src_dir = std::path::Path::new(\"../rt/hoedown/src\");\n     build_helper::rerun_if_changed_anything_in_dir(src_dir);\n-    let mut cfg = gcc::Config::new();\n+    let mut cfg = gcc::Build::new();\n     cfg.file(\"../rt/hoedown/src/autolink.c\")\n        .file(\"../rt/hoedown/src/buffer.c\")\n        .file(\"../rt/hoedown/src/document.c\")\n@@ -24,7 +24,9 @@ fn main() {\n        .file(\"../rt/hoedown/src/html_smartypants.c\")\n        .file(\"../rt/hoedown/src/stack.c\")\n        .file(\"../rt/hoedown/src/version.c\")\n+       .warnings(false)\n        .include(src_dir)\n+       .warnings(false)\n        .compile(\"libhoedown.a\");\n }\n "}, {"sha": "70563b3d267132762b31352c5fa2f6656d4442f1", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -120,7 +120,7 @@ pub fn load_attrs(cx: &DocContext, did: DefId) -> clean::Attributes {\n /// These names are used later on by HTML rendering to generate things like\n /// source links back to the original item.\n pub fn record_extern_fqn(cx: &DocContext, did: DefId, kind: clean::TypeKind) {\n-    let crate_name = cx.tcx.sess.cstore.crate_name(did.krate).to_string();\n+    let crate_name = cx.tcx.crate_name(did.krate).to_string();\n     let relative = cx.tcx.def_path(did).data.into_iter().filter_map(|elem| {\n         // extern blocks have an empty name\n         let s = elem.data.to_string();\n@@ -236,31 +236,34 @@ pub fn build_impls(cx: &DocContext, did: DefId) -> Vec<clean::Item> {\n \n     cx.populated_all_crate_impls.set(true);\n \n-    for did in tcx.sess.cstore.implementations_of_trait(None) {\n-        build_impl(cx, did, &mut impls);\n+    for &cnum in tcx.crates().iter() {\n+        for did in tcx.all_trait_implementations(cnum).iter() {\n+            build_impl(cx, *did, &mut impls);\n+        }\n     }\n \n     // Also try to inline primitive impls from other crates.\n+    let lang_items = tcx.lang_items();\n     let primitive_impls = [\n-        tcx.lang_items.isize_impl(),\n-        tcx.lang_items.i8_impl(),\n-        tcx.lang_items.i16_impl(),\n-        tcx.lang_items.i32_impl(),\n-        tcx.lang_items.i64_impl(),\n-        tcx.lang_items.i128_impl(),\n-        tcx.lang_items.usize_impl(),\n-        tcx.lang_items.u8_impl(),\n-        tcx.lang_items.u16_impl(),\n-        tcx.lang_items.u32_impl(),\n-        tcx.lang_items.u64_impl(),\n-        tcx.lang_items.u128_impl(),\n-        tcx.lang_items.f32_impl(),\n-        tcx.lang_items.f64_impl(),\n-        tcx.lang_items.char_impl(),\n-        tcx.lang_items.str_impl(),\n-        tcx.lang_items.slice_impl(),\n-        tcx.lang_items.const_ptr_impl(),\n-        tcx.lang_items.mut_ptr_impl(),\n+        lang_items.isize_impl(),\n+        lang_items.i8_impl(),\n+        lang_items.i16_impl(),\n+        lang_items.i32_impl(),\n+        lang_items.i64_impl(),\n+        lang_items.i128_impl(),\n+        lang_items.usize_impl(),\n+        lang_items.u8_impl(),\n+        lang_items.u16_impl(),\n+        lang_items.u32_impl(),\n+        lang_items.u64_impl(),\n+        lang_items.u128_impl(),\n+        lang_items.f32_impl(),\n+        lang_items.f64_impl(),\n+        lang_items.char_impl(),\n+        lang_items.str_impl(),\n+        lang_items.slice_impl(),\n+        lang_items.const_ptr_impl(),\n+        lang_items.mut_ptr_impl(),\n     ];\n \n     for def_id in primitive_impls.iter().filter_map(|&def_id| def_id) {\n@@ -399,7 +402,7 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n             clean::RegionBound(..) => unreachable!(),\n         }\n     });\n-    if trait_.def_id() == tcx.lang_items.deref_trait() {\n+    if trait_.def_id() == tcx.lang_items().deref_trait() {\n         super::build_deref_target_impls(cx, &trait_items, ret);\n     }\n \n@@ -443,9 +446,9 @@ fn build_module(cx: &DocContext, did: DefId) -> clean::Module {\n         // two namespaces, so the target may be listed twice. Make sure we only\n         // visit each node at most once.\n         let mut visited = FxHashSet();\n-        for item in cx.tcx.sess.cstore.item_children(did, cx.tcx.sess) {\n+        for &item in cx.tcx.item_children(did).iter() {\n             let def_id = item.def.def_id();\n-            if cx.tcx.sess.cstore.visibility(def_id) == ty::Visibility::Public {\n+            if cx.tcx.visibility(def_id) == ty::Visibility::Public {\n                 if !visited.insert(def_id) { continue }\n                 if let Some(i) = try_inline(cx, item.def, item.ident.name) {\n                     items.extend(i)\n@@ -471,7 +474,7 @@ impl hir::print::PpAnn for InlinedConst {\n }\n \n fn print_inlined_const(cx: &DocContext, did: DefId) -> String {\n-    let body = cx.tcx.sess.cstore.item_body(cx.tcx, did);\n+    let body = cx.tcx.extern_const_body(did);\n     let inlined = InlinedConst {\n         nested_bodies: cx.tcx.item_body_nested_bodies(did)\n     };"}, {"sha": "ce3bf896256eca3efbcd73d11d5534bc929711e6", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 57, "deletions": 38, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -27,11 +27,13 @@ use syntax::ptr::P;\n use syntax::symbol::keywords;\n use syntax_pos::{self, DUMMY_SP, Pos};\n \n+use rustc::middle::const_val::ConstVal;\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::resolve_lifetime as rl;\n use rustc::middle::lang_items;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc::traits::Reveal;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, AdtKind};\n use rustc::middle::stability;\n@@ -40,6 +42,7 @@ use rustc_typeck::hir_ty_to_ty;\n \n use rustc::hir;\n \n+use rustc_const_math::ConstInt;\n use std::{mem, slice, vec};\n use std::path::PathBuf;\n use std::rc::Rc;\n@@ -125,13 +128,13 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n \n         {\n             let mut r = cx.renderinfo.borrow_mut();\n-            r.deref_trait_did = cx.tcx.lang_items.deref_trait();\n-            r.deref_mut_trait_did = cx.tcx.lang_items.deref_mut_trait();\n-            r.owned_box_did = cx.tcx.lang_items.owned_box();\n+            r.deref_trait_did = cx.tcx.lang_items().deref_trait();\n+            r.deref_mut_trait_did = cx.tcx.lang_items().deref_mut_trait();\n+            r.owned_box_did = cx.tcx.lang_items().owned_box();\n         }\n \n         let mut externs = Vec::new();\n-        for cnum in cx.sess().cstore.crates() {\n+        for &cnum in cx.tcx.crates().iter() {\n             externs.push((cnum, cnum.clean(cx)));\n             // Analyze doc-reachability for extern items\n             LibEmbargoVisitor::new(cx).visit_lib(cnum);\n@@ -244,7 +247,7 @@ impl Clean<ExternalCrate> for CrateNum {\n                 }\n             }).collect()\n         } else {\n-            cx.tcx.sess.cstore.item_children(root, cx.tcx.sess).iter().map(|item| item.def)\n+            cx.tcx.item_children(root).iter().map(|item| item.def)\n               .filter_map(as_primitive).collect()\n         };\n \n@@ -672,7 +675,7 @@ impl TyParamBound {\n     fn maybe_sized(cx: &DocContext) -> TyParamBound {\n         let did = cx.tcx.require_lang_item(lang_items::SizedTraitLangItem);\n         let empty = cx.tcx.intern_substs(&[]);\n-        let path = external_path(cx, &cx.tcx.item_name(did).as_str(),\n+        let path = external_path(cx, &cx.tcx.item_name(did),\n             Some(did), false, vec![], empty);\n         inline::record_extern_fqn(cx, did, TypeKind::Trait);\n         TraitBound(PolyTrait {\n@@ -689,7 +692,7 @@ impl TyParamBound {\n     fn is_sized_bound(&self, cx: &DocContext) -> bool {\n         use rustc::hir::TraitBoundModifier as TBM;\n         if let TyParamBound::TraitBound(PolyTrait { ref trait_, .. }, TBM::None) = *self {\n-            if trait_.def_id() == cx.tcx.lang_items.sized_trait() {\n+            if trait_.def_id() == cx.tcx.lang_items().sized_trait() {\n                 return true;\n             }\n         }\n@@ -713,7 +716,7 @@ fn external_path_params(cx: &DocContext, trait_did: Option<DefId>, has_self: boo\n \n     match trait_did {\n         // Attempt to sugar an external path like Fn<(A, B,), C> to Fn(A, B) -> C\n-        Some(did) if cx.tcx.lang_items.fn_trait_kind(did).is_some() => {\n+        Some(did) if cx.tcx.lang_items().fn_trait_kind(did).is_some() => {\n             assert_eq!(types.len(), 1);\n             let inputs = match types[0].sty {\n                 ty::TyTuple(ref tys, _) => tys.iter().map(|t| t.clean(cx)).collect(),\n@@ -763,7 +766,7 @@ fn external_path(cx: &DocContext, name: &str, trait_did: Option<DefId>, has_self\n impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n     fn clean(&self, cx: &DocContext) -> TyParamBound {\n         inline::record_extern_fqn(cx, self.def_id, TypeKind::Trait);\n-        let path = external_path(cx, &cx.tcx.item_name(self.def_id).as_str(),\n+        let path = external_path(cx, &cx.tcx.item_name(self.def_id),\n                                  Some(self.def_id), true, vec![], self.substs);\n \n         debug!(\"ty::TraitRef\\n  subst: {:?}\\n\", self.substs);\n@@ -830,7 +833,8 @@ impl Lifetime {\n \n impl Clean<Lifetime> for hir::Lifetime {\n     fn clean(&self, cx: &DocContext) -> Lifetime {\n-        let def = cx.tcx.named_region_map.defs.get(&self.id).cloned();\n+        let hir_id = cx.tcx.hir.node_to_hir_id(self.id);\n+        let def = cx.tcx.named_region(hir_id);\n         match def {\n             Some(rl::Region::EarlyBound(_, node_id)) |\n             Some(rl::Region::LateBound(_, node_id)) |\n@@ -933,6 +937,7 @@ impl<'a> Clean<WherePredicate> for ty::Predicate<'a> {\n             Predicate::WellFormed(_) => panic!(\"not user writable\"),\n             Predicate::ObjectSafe(_) => panic!(\"not user writable\"),\n             Predicate::ClosureKind(..) => panic!(\"not user writable\"),\n+            Predicate::ConstEvaluatable(..) => panic!(\"not user writable\"),\n         }\n     }\n }\n@@ -1554,7 +1559,7 @@ pub enum Type {\n     BareFunction(Box<BareFunctionDecl>),\n     Tuple(Vec<Type>),\n     Slice(Box<Type>),\n-    Array(Box<Type>, usize),\n+    Array(Box<Type>, String),\n     Never,\n     Unique(Box<Type>),\n     RawPointer(Mutability, Box<Type>),\n@@ -1781,9 +1786,16 @@ impl Clean<Type> for hir::Ty {\n                              type_: box m.ty.clean(cx)}\n             }\n             TySlice(ref ty) => Slice(box ty.clean(cx)),\n-            TyArray(ref ty, length) => {\n-                use rustc::middle::const_val::eval_length;\n-                let n = eval_length(cx.tcx, length, \"array length\").unwrap();\n+            TyArray(ref ty, n) => {\n+                let def_id = cx.tcx.hir.body_owner_def_id(n);\n+                let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n+                let substs = Substs::identity_for_item(cx.tcx, def_id);\n+                let n = cx.tcx.const_eval(param_env.and((def_id, substs))).unwrap();\n+                let n = if let ConstVal::Integral(ConstInt::Usize(n)) = n.val {\n+                    n.to_string()\n+                } else {\n+                    format!(\"{:?}\", n)\n+                };\n                 Array(box ty.clean(cx), n)\n             },\n             TyTup(ref tys) => Tuple(tys.clean(cx)),\n@@ -1894,7 +1906,14 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n             ty::TyFloat(float_ty) => Primitive(float_ty.into()),\n             ty::TyStr => Primitive(PrimitiveType::Str),\n             ty::TySlice(ty) => Slice(box ty.clean(cx)),\n-            ty::TyArray(ty, n) => Array(box ty.clean(cx), n),\n+            ty::TyArray(ty, n) => {\n+                let n = if let ConstVal::Integral(ConstInt::Usize(n)) = n.val {\n+                    n.to_string()\n+                } else {\n+                    format!(\"{:?}\", n)\n+                };\n+                Array(box ty.clean(cx), n)\n+            }\n             ty::TyRawPtr(mt) => RawPointer(mt.mutbl.clean(cx), box mt.ty.clean(cx)),\n             ty::TyRef(r, mt) => BorrowedRef {\n                 lifetime: r.clean(cx),\n@@ -1924,7 +1943,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                     AdtKind::Enum => TypeKind::Enum,\n                 };\n                 inline::record_extern_fqn(cx, did, kind);\n-                let path = external_path(cx, &cx.tcx.item_name(did).as_str(),\n+                let path = external_path(cx, &cx.tcx.item_name(did),\n                                          None, false, vec![], substs);\n                 ResolvedPath {\n                     path,\n@@ -1942,7 +1961,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                     reg.clean(cx).map(|b| typarams.push(RegionBound(b)));\n                     for did in obj.auto_traits() {\n                         let empty = cx.tcx.intern_substs(&[]);\n-                        let path = external_path(cx, &cx.tcx.item_name(did).as_str(),\n+                        let path = external_path(cx, &cx.tcx.item_name(did),\n                             Some(did), false, vec![], empty);\n                         inline::record_extern_fqn(cx, did, TypeKind::Trait);\n                         let bound = TraitBound(PolyTrait {\n@@ -1965,7 +1984,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                         });\n                     }\n \n-                    let path = external_path(cx, &cx.tcx.item_name(did).as_str(), Some(did),\n+                    let path = external_path(cx, &cx.tcx.item_name(did), Some(did),\n                         false, bindings, principal.0.substs);\n                     ResolvedPath {\n                         path,\n@@ -2535,7 +2554,7 @@ impl Clean<Vec<Item>> for doctree::Impl {\n \n         // If this impl block is an implementation of the Deref trait, then we\n         // need to try inlining the target's inherent impl blocks as well.\n-        if trait_.def_id() == cx.tcx.lang_items.deref_trait() {\n+        if trait_.def_id() == cx.tcx.lang_items().deref_trait() {\n             build_deref_target_impls(cx, &items, &mut ret);\n         }\n \n@@ -2591,27 +2610,27 @@ fn build_deref_target_impls(cx: &DocContext,\n             }\n         };\n         let did = match primitive {\n-            Isize => tcx.lang_items.isize_impl(),\n-            I8 => tcx.lang_items.i8_impl(),\n-            I16 => tcx.lang_items.i16_impl(),\n-            I32 => tcx.lang_items.i32_impl(),\n-            I64 => tcx.lang_items.i64_impl(),\n-            I128 => tcx.lang_items.i128_impl(),\n-            Usize => tcx.lang_items.usize_impl(),\n-            U8 => tcx.lang_items.u8_impl(),\n-            U16 => tcx.lang_items.u16_impl(),\n-            U32 => tcx.lang_items.u32_impl(),\n-            U64 => tcx.lang_items.u64_impl(),\n-            U128 => tcx.lang_items.u128_impl(),\n-            F32 => tcx.lang_items.f32_impl(),\n-            F64 => tcx.lang_items.f64_impl(),\n-            Char => tcx.lang_items.char_impl(),\n+            Isize => tcx.lang_items().isize_impl(),\n+            I8 => tcx.lang_items().i8_impl(),\n+            I16 => tcx.lang_items().i16_impl(),\n+            I32 => tcx.lang_items().i32_impl(),\n+            I64 => tcx.lang_items().i64_impl(),\n+            I128 => tcx.lang_items().i128_impl(),\n+            Usize => tcx.lang_items().usize_impl(),\n+            U8 => tcx.lang_items().u8_impl(),\n+            U16 => tcx.lang_items().u16_impl(),\n+            U32 => tcx.lang_items().u32_impl(),\n+            U64 => tcx.lang_items().u64_impl(),\n+            U128 => tcx.lang_items().u128_impl(),\n+            F32 => tcx.lang_items().f32_impl(),\n+            F64 => tcx.lang_items().f64_impl(),\n+            Char => tcx.lang_items().char_impl(),\n             Bool => None,\n-            Str => tcx.lang_items.str_impl(),\n-            Slice => tcx.lang_items.slice_impl(),\n-            Array => tcx.lang_items.slice_impl(),\n+            Str => tcx.lang_items().str_impl(),\n+            Slice => tcx.lang_items().slice_impl(),\n+            Array => tcx.lang_items().slice_impl(),\n             Tuple => None,\n-            RawPointer => tcx.lang_items.const_ptr_impl(),\n+            RawPointer => tcx.lang_items().const_ptr_impl(),\n             Reference => None,\n             Fn => None,\n         };"}, {"sha": "dd36b28bb39acd6dcf0b9b4f360aa0624bf80648", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -15,13 +15,8 @@\n //! the AST (e.g. see all of `clean::inline`), but this is not always a\n //! non-lossy transformation. The current format of storage for where clauses\n //! for functions and such is simply a list of predicates. One example of this\n-//! is that the AST predicate of:\n-//!\n-//!     where T: Trait<Foo=Bar>\n-//!\n-//! is encoded as:\n-//!\n-//!     where T: Trait, <T as Trait>::Foo = Bar\n+//! is that the AST predicate of: `where T: Trait<Foo=Bar>` is encoded as:\n+//! `where T: Trait, <T as Trait>::Foo = Bar`.\n //!\n //! This module attempts to reconstruct the original where and/or parameter\n //! bounds by special casing scenarios such as these. Fun!"}, {"sha": "d7ce5e262ce381b07cd0f412da0dff4b4ad80704", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -146,9 +146,9 @@ pub fn run_core(search_paths: SearchPaths,\n \n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n-    let cstore = Rc::new(CStore::new(&dep_graph, box rustc_trans::LlvmMetadataLoader));\n+    let cstore = Rc::new(CStore::new(box rustc_trans::LlvmMetadataLoader));\n     let mut sess = session::build_session_(\n-        sessopts, &dep_graph, cpath, diagnostic_handler, codemap, cstore.clone()\n+        sessopts, &dep_graph, cpath, diagnostic_handler, codemap\n     );\n     rustc_trans::init(&sess);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n@@ -181,6 +181,7 @@ pub fn run_core(search_paths: SearchPaths,\n     let hir_map = hir_map::map_crate(&mut hir_forest, defs);\n \n     abort_on_err(driver::phase_3_run_analysis_passes(&sess,\n+                                                     &*cstore,\n                                                      hir_map,\n                                                      analysis,\n                                                      resolutions,\n@@ -214,7 +215,7 @@ pub fn run_core(search_paths: SearchPaths,\n         debug!(\"crate: {:?}\", tcx.hir.krate());\n \n         let krate = {\n-            let mut v = RustdocVisitor::new(&ctxt);\n+            let mut v = RustdocVisitor::new(&*cstore, &ctxt);\n             v.visit(tcx.hir.krate());\n             v.clean(&ctxt)\n         };"}, {"sha": "6303fd662bf2b02871540c151be9e507422bbdd9", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -633,7 +633,7 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt:\n             fmt::Display::fmt(t, f)?;\n             primitive_link(f, PrimitiveType::Slice, \"]\")\n         }\n-        clean::Array(ref t, n) => {\n+        clean::Array(ref t, ref n) => {\n             primitive_link(f, PrimitiveType::Array, \"[\")?;\n             fmt::Display::fmt(t, f)?;\n             primitive_link(f, PrimitiveType::Array, &format!(\"; {}]\", n))"}, {"sha": "8d913c7552813aa185468092fd8b4ee335071eb4", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -16,10 +16,12 @@\n //! of `fmt::Display`. Example usage:\n //!\n //! ```\n-//! use rustdoc::html::markdown::Markdown;\n+//! #![feature(rustc_private)]\n+//!\n+//! use rustdoc::html::markdown::{RenderType, Markdown};\n //!\n //! let s = \"My *markdown* _text_\";\n-//! let html = format!(\"{}\", Markdown(s));\n+//! let html = format!(\"{}\", Markdown(s, RenderType::Pulldown));\n //! // ... something using html\n //! ```\n "}, {"sha": "49d4bd2324033dbaeb3c3d327aee8c6afd96e7eb", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 29, "deletions": 83, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -606,12 +606,20 @@ pub fn run(mut krate: clean::Crate,\n }\n \n // A short, single-line view of `s`.\n-fn concise_str(s: &str) -> String {\n+fn concise_str(mut s: &str) -> String {\n     if s.contains('\\n') {\n-        return format!(\"{}...\", s.lines().next().expect(\"Impossible! We just found a newline\"));\n+        s = s.lines().next().expect(\"Impossible! We just found a newline\");\n     }\n     if s.len() > 70 {\n-        return format!(\"{} ... {}\", &s[..50], &s[s.len()-20..]);\n+        let mut lo = 50;\n+        let mut hi = s.len() - 20;\n+        while !s.is_char_boundary(lo) {\n+            lo -= 1;\n+        }\n+        while !s.is_char_boundary(hi) {\n+            hi += 1;\n+        }\n+        return format!(\"{} ... {}\", &s[..lo], &s[hi..]);\n     }\n     s.to_owned()\n }\n@@ -660,9 +668,13 @@ fn render_difference(diff: &html_diff::Difference) {\n                      elem.path, elem.element_name, elem_attributes, opposite_elem_attributes);\n         }\n         html_diff::Difference::NodeText { ref elem, ref elem_text, ref opposite_elem_text, .. } => {\n-            let (s1, s2) = concise_compared_strs(elem_text, opposite_elem_text);\n-            println!(\"    {} Text differs:\\n        expected: `{}`\\n        found:    `{}`\",\n-                     elem.path, s1, s2);\n+            if elem_text.split(\"\\n\")\n+                        .zip(opposite_elem_text.split(\"\\n\"))\n+                        .any(|(a, b)| a.trim() != b.trim()) {\n+                let (s1, s2) = concise_compared_strs(elem_text, opposite_elem_text);\n+                println!(\"    {} Text differs:\\n        expected: `{}`\\n        found:    `{}`\",\n+                         elem.path, s1, s2);\n+            }\n         }\n         html_diff::Difference::NotPresent { ref elem, ref opposite_elem } => {\n             if let Some(ref elem) = *elem {\n@@ -1756,18 +1768,18 @@ fn render_markdown(w: &mut fmt::Formatter,\n     // We only emit warnings if the user has opted-in to Pulldown rendering.\n     let output = if render_type == RenderType::Pulldown {\n         let pulldown_output = format!(\"{}\", Markdown(md_text, RenderType::Pulldown));\n-        let differences = html_diff::get_differences(&pulldown_output, &hoedown_output);\n-        let differences = differences.into_iter()\n-            .filter(|s| {\n-                match *s {\n-                    html_diff::Difference::NodeText { ref elem_text,\n-                                                      ref opposite_elem_text,\n-                                                      .. }\n-                        if match_non_whitespace(elem_text, opposite_elem_text) => false,\n-                    _ => true,\n+        let mut differences = html_diff::get_differences(&pulldown_output, &hoedown_output);\n+        differences.retain(|s| {\n+            match *s {\n+                html_diff::Difference::NodeText { ref elem_text,\n+                                                  ref opposite_elem_text,\n+                                                  .. }\n+                    if elem_text.split_whitespace().eq(opposite_elem_text.split_whitespace()) => {\n+                        false\n                 }\n-            })\n-            .collect::<Vec<_>>();\n+                _ => true,\n+            }\n+        });\n \n         if !differences.is_empty() {\n             scx.markdown_warnings.borrow_mut().push((span, md_text.to_owned(), differences));\n@@ -1781,40 +1793,6 @@ fn render_markdown(w: &mut fmt::Formatter,\n     write!(w, \"<div class='docblock'>{}{}</div>\", prefix, output)\n }\n \n-// Returns true iff s1 and s2 match, ignoring whitespace.\n-fn match_non_whitespace(s1: &str, s2: &str) -> bool {\n-    let s1 = s1.trim();\n-    let s2 = s2.trim();\n-    let mut cs1 = s1.chars();\n-    let mut cs2 = s2.chars();\n-    while let Some(c1) = cs1.next() {\n-        if c1.is_whitespace() {\n-            continue;\n-        }\n-\n-        loop {\n-            if let Some(c2) = cs2.next() {\n-                if !c2.is_whitespace() {\n-                    if c1 != c2 {\n-                        return false;\n-                    }\n-                    break;\n-                }\n-            } else {\n-                return false;\n-            }\n-        }\n-    }\n-\n-    while let Some(c2) = cs2.next() {\n-        if !c2.is_whitespace() {\n-            return false;\n-        }\n-    }\n-\n-    true\n-}\n-\n fn document_short(w: &mut fmt::Formatter, item: &clean::Item, link: AssocItemLink,\n                   cx: &Context, prefix: &str) -> fmt::Result {\n     if let Some(s) = item.doc_value() {\n@@ -3791,35 +3769,3 @@ fn test_name_sorting() {\n     sorted.sort_by_key(|&s| name_key(s));\n     assert_eq!(names, sorted);\n }\n-\n-#[cfg(test)]\n-#[test]\n-fn test_match_non_whitespace() {\n-    assert!(match_non_whitespace(\"\", \"\"));\n-    assert!(match_non_whitespace(\"  \", \"\"));\n-    assert!(match_non_whitespace(\"\", \"  \"));\n-\n-    assert!(match_non_whitespace(\"a\", \"a\"));\n-    assert!(match_non_whitespace(\" a \", \"a\"));\n-    assert!(match_non_whitespace(\"a\", \"  a\"));\n-    assert!(match_non_whitespace(\"abc\", \"abc\"));\n-    assert!(match_non_whitespace(\"abc\", \" abc \"));\n-    assert!(match_non_whitespace(\"abc  \", \"abc\"));\n-    assert!(match_non_whitespace(\"abc xyz\", \"abc xyz\"));\n-    assert!(match_non_whitespace(\"abc xyz\", \"abc\\nxyz\"));\n-    assert!(match_non_whitespace(\"abc xyz\", \"abcxyz\"));\n-    assert!(match_non_whitespace(\"abcxyz\", \"abc xyz\"));\n-    assert!(match_non_whitespace(\"abc    xyz \", \" abc xyz\\n\"));\n-\n-    assert!(!match_non_whitespace(\"a\", \"b\"));\n-    assert!(!match_non_whitespace(\" a \", \"c\"));\n-    assert!(!match_non_whitespace(\"a\", \"  aa\"));\n-    assert!(!match_non_whitespace(\"abc\", \"ac\"));\n-    assert!(!match_non_whitespace(\"abc\", \" adc \"));\n-    assert!(!match_non_whitespace(\"abc  \", \"abca\"));\n-    assert!(!match_non_whitespace(\"abc xyz\", \"abc xy\"));\n-    assert!(!match_non_whitespace(\"abc xyz\", \"bc\\nxyz\"));\n-    assert!(!match_non_whitespace(\"abc xyz\", \"abc.xyz\"));\n-    assert!(!match_non_whitespace(\"abcxyz\", \"abc.xyz\"));\n-    assert!(!match_non_whitespace(\"abc    xyz \", \" abc xyz w\"));\n-}"}, {"sha": "9563ccfcc65fd9e9617a4c29e2226ccb82e0eb72", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -32,6 +32,7 @@ extern crate html_diff;\n extern crate libc;\n extern crate rustc;\n extern crate rustc_data_structures;\n+extern crate rustc_const_math;\n extern crate rustc_trans;\n extern crate rustc_driver;\n extern crate rustc_resolve;"}, {"sha": "9b76a713b1769541561b0727fd74b2d3c463b6b9", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -85,9 +85,9 @@ pub fn run(input: &str,\n \n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n-    let cstore = Rc::new(CStore::new(&dep_graph, box rustc_trans::LlvmMetadataLoader));\n+    let cstore = Rc::new(CStore::new(box rustc_trans::LlvmMetadataLoader));\n     let mut sess = session::build_session_(\n-        sessopts, &dep_graph, Some(input_path.clone()), handler, codemap.clone(), cstore.clone(),\n+        sessopts, &dep_graph, Some(input_path.clone()), handler, codemap.clone()\n     );\n     rustc_trans::init(&sess);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n@@ -238,9 +238,9 @@ fn run_test(test: &str, cratename: &str, filename: &str, cfgs: Vec<String>, libs\n     let diagnostic_handler = errors::Handler::with_emitter(true, false, box emitter);\n \n     let dep_graph = DepGraph::new(false);\n-    let cstore = Rc::new(CStore::new(&dep_graph, box rustc_trans::LlvmMetadataLoader));\n+    let cstore = Rc::new(CStore::new(box rustc_trans::LlvmMetadataLoader));\n     let mut sess = session::build_session_(\n-        sessopts, &dep_graph, None, diagnostic_handler, codemap, cstore.clone(),\n+        sessopts, &dep_graph, None, diagnostic_handler, codemap\n     );\n     rustc_trans::init(&sess);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));"}, {"sha": "327a330c2a2e5dba7a181a28a556a459f94828aa", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -21,7 +21,7 @@ use syntax_pos::Span;\n use rustc::hir::map as hir_map;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc::middle::cstore::LoadedMacro;\n+use rustc::middle::cstore::{LoadedMacro, CrateStore};\n use rustc::middle::privacy::AccessLevel;\n use rustc::util::nodemap::FxHashSet;\n \n@@ -40,6 +40,7 @@ use doctree::*;\n // framework from syntax?\n \n pub struct RustdocVisitor<'a, 'tcx: 'a> {\n+    cstore: &'tcx CrateStore,\n     pub module: Module,\n     pub attrs: hir::HirVec<ast::Attribute>,\n     pub cx: &'a core::DocContext<'a, 'tcx>,\n@@ -51,7 +52,8 @@ pub struct RustdocVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n-    pub fn new(cx: &'a core::DocContext<'a, 'tcx>) -> RustdocVisitor<'a, 'tcx> {\n+    pub fn new(cstore: &'tcx CrateStore,\n+               cx: &'a core::DocContext<'a, 'tcx>) -> RustdocVisitor<'a, 'tcx> {\n         // If the root is reexported, terminate all recursion.\n         let mut stack = FxHashSet();\n         stack.insert(ast::CRATE_NODE_ID);\n@@ -63,6 +65,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             inlining: false,\n             inside_public_path: true,\n             reexported_macros: FxHashSet(),\n+            cstore,\n         }\n     }\n \n@@ -199,16 +202,16 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             self.visit_item(item, None, &mut om);\n         }\n         self.inside_public_path = orig_inside_public_path;\n-        let hir_id = self.cx.tcx.hir.node_to_hir_id(id);\n-        if let Some(exports) = self.cx.tcx.module_exports(hir_id) {\n+        let def_id = self.cx.tcx.hir.local_def_id(id);\n+        if let Some(exports) = self.cx.tcx.module_exports(def_id) {\n             for export in exports.iter() {\n                 if let Def::Macro(def_id, ..) = export.def {\n                     if def_id.krate == LOCAL_CRATE || self.reexported_macros.contains(&def_id) {\n                         continue // These are `krate.exported_macros`, handled in `self.visit()`.\n                     }\n \n-                    let imported_from = self.cx.sess().cstore.original_crate_name(def_id.krate);\n-                    let def = match self.cx.sess().cstore.load_macro(def_id, self.cx.sess()) {\n+                    let imported_from = self.cx.tcx.original_crate_name(def_id.krate);\n+                    let def = match self.cstore.load_macro_untracked(def_id, self.cx.sess()) {\n                         LoadedMacro::MacroDef(macro_def) => macro_def,\n                         // FIXME(jseyfried): document proc macro reexports\n                         LoadedMacro::ProcMacro(..) => continue,\n@@ -371,9 +374,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             _ if self.inlining && item.vis != hir::Public => {}\n             hir::ItemGlobalAsm(..) => {}\n             hir::ItemExternCrate(ref p) => {\n-                let cstore = &self.cx.sess().cstore;\n+                let def_id = self.cx.tcx.hir.local_def_id(item.id);\n                 om.extern_crates.push(ExternCrate {\n-                    cnum: cstore.extern_mod_stmt_cnum(item.id)\n+                    cnum: self.cx.tcx.extern_mod_stmt_cnum(def_id)\n                                 .unwrap_or(LOCAL_CRATE),\n                     name,\n                     path: p.map(|x|x.to_string()),"}, {"sha": "9f75388238f0c0785bafb78d1659c389fc80a759", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::middle::cstore::CrateStore;\n use rustc::middle::privacy::{AccessLevels, AccessLevel};\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n@@ -25,7 +24,6 @@ use clean::{AttributesExt, NestedAttributesExt};\n /// specific rustdoc annotations into account (i.e. `doc(hidden)`)\n pub struct LibEmbargoVisitor<'a, 'b: 'a, 'tcx: 'b> {\n     cx: &'a ::core::DocContext<'b, 'tcx>,\n-    cstore: &'a CrateStore,\n     // Accessibility levels for reachable nodes\n     access_levels: RefMut<'a, AccessLevels<DefId>>,\n     // Previous accessibility level, None means unreachable\n@@ -38,7 +36,6 @@ impl<'a, 'b, 'tcx> LibEmbargoVisitor<'a, 'b, 'tcx> {\n     pub fn new(cx: &'a ::core::DocContext<'b, 'tcx>) -> LibEmbargoVisitor<'a, 'b, 'tcx> {\n         LibEmbargoVisitor {\n             cx,\n-            cstore: &*cx.sess().cstore,\n             access_levels: cx.access_levels.borrow_mut(),\n             prev_level: Some(AccessLevel::Public),\n             visited_mods: FxHashSet()\n@@ -70,14 +67,14 @@ impl<'a, 'b, 'tcx> LibEmbargoVisitor<'a, 'b, 'tcx> {\n             return;\n         }\n \n-        for item in self.cstore.item_children(def_id, self.cx.tcx.sess) {\n+        for item in self.cx.tcx.item_children(def_id).iter() {\n             self.visit_item(item.def);\n         }\n     }\n \n     fn visit_item(&mut self, def: Def) {\n         let def_id = def.def_id();\n-        let vis = self.cstore.visibility(def_id);\n+        let vis = self.cx.tcx.visibility(def_id);\n         let inherited_item_level = if vis == Visibility::Public {\n             self.prev_level\n         } else {"}, {"sha": "ebf07eb0423a09a23f70ad731a19330fe60c18bb", "filename": "src/libstd/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -20,7 +20,7 @@ use build_helper::{run, native_lib_boilerplate};\n fn main() {\n     let target = env::var(\"TARGET\").expect(\"TARGET was not set\");\n     let host = env::var(\"HOST\").expect(\"HOST was not set\");\n-    if cfg!(feature = \"backtrace\") && !target.contains(\"apple\") && !target.contains(\"msvc\") &&\n+    if cfg!(feature = \"backtrace\") && !target.contains(\"msvc\") &&\n         !target.contains(\"emscripten\") && !target.contains(\"fuchsia\") {\n         let _ = build_libbacktrace(&host, &target);\n     }\n@@ -77,7 +77,7 @@ fn main() {\n fn build_libbacktrace(host: &str, target: &str) -> Result<(), ()> {\n     let native = native_lib_boilerplate(\"libbacktrace\", \"libbacktrace\", \"backtrace\", \".libs\")?;\n \n-    let compiler = gcc::Config::new().get_compiler();\n+    let compiler = gcc::Build::new().get_compiler();\n     // only msvc returns None for ar so unwrap is okay\n     let ar = build_helper::cc2ar(compiler.path(), target).unwrap();\n     let mut cflags = compiler.args().iter().map(|s| s.to_str().unwrap())"}, {"sha": "fbb69ca974930ae3e442882485a57fda24bc856e", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -2001,6 +2001,33 @@ impl<'a, K, V> Entry<'a, K, V> {\n     }\n }\n \n+impl<'a, K, V: Default> Entry<'a, K, V> {\n+    #[unstable(feature = \"entry_or_default\", issue = \"44324\")]\n+    /// Ensures a value is in the entry by inserting the default value if empty,\n+    /// and returns a mutable reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(entry_or_default)]\n+    /// # fn main() {\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map: HashMap<&str, Option<u32>> = HashMap::new();\n+    /// map.entry(\"poneyland\").or_default();\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], None);\n+    /// # }\n+    /// ```\n+    pub fn or_default(self) -> &'a mut V {\n+        match self {\n+            Occupied(entry) => entry.into_mut(),\n+            Vacant(entry) => entry.insert(Default::default()),\n+        }\n+    }\n+\n+}\n+\n impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// Gets a reference to the key in the entry.\n     ///"}, {"sha": "7992aefcb42037305df4d587b2405d7e055d445b", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -545,7 +545,7 @@ impl fmt::Debug for CStr {\n #[stable(feature = \"cstr_default\", since = \"1.10.0\")]\n impl<'a> Default for &'a CStr {\n     fn default() -> &'a CStr {\n-        static SLICE: &'static [c_char] = &[0];\n+        const SLICE: &'static [c_char] = &[0];\n         unsafe { CStr::from_ptr(SLICE.as_ptr()) }\n     }\n }"}, {"sha": "8089671f309d28d22e63fecc8710b5e2c704e6aa", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -66,23 +66,11 @@ macro_rules! panic {\n         panic!(\"explicit panic\")\n     });\n     ($msg:expr) => ({\n-        $crate::rt::begin_panic($msg, {\n-            // static requires less code at runtime, more constant data\n-            static _FILE_LINE_COL: (&'static str, u32, u32) = (file!(), line!(),\n-                __rust_unstable_column!());\n-            &_FILE_LINE_COL\n-        })\n+        $crate::rt::begin_panic($msg, &(file!(), line!(), __rust_unstable_column!()))\n     });\n     ($fmt:expr, $($arg:tt)+) => ({\n-        $crate::rt::begin_panic_fmt(&format_args!($fmt, $($arg)+), {\n-            // The leading _'s are to avoid dead code warnings if this is\n-            // used inside a dead function. Just `#[allow(dead_code)]` is\n-            // insufficient, since the user may have\n-            // `#[forbid(dead_code)]` and which cannot be overridden.\n-            static _FILE_LINE_COL: (&'static str, u32, u32) = (file!(), line!(),\n-                __rust_unstable_column!());\n-            &_FILE_LINE_COL\n-        })\n+        $crate::rt::begin_panic_fmt(&format_args!($fmt, $($arg)+),\n+                                    &(file!(), line!(), __rust_unstable_column!()))\n     });\n }\n "}, {"sha": "b460bd90f173558f10ef3080b48c995529dc7cb5", "filename": "src/libstd/os/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmod.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -27,7 +27,7 @@ pub use sys::unix_ext as unix;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use sys::windows_ext as windows;\n \n-#[cfg(any(dox, target_os = \"linux\"))]\n+#[cfg(any(dox, target_os = \"linux\", target_os = \"l4re\"))]\n #[doc(cfg(target_os = \"linux\"))]\n pub mod linux;\n "}, {"sha": "95439640f7cc5c5000fbf98091a29cdf84b733a7", "filename": "src/libstd/os/raw.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fos%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fos%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fraw.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -21,6 +21,7 @@ use fmt;\n                                        target_arch = \"s390x\")),\n           all(target_os = \"android\", any(target_arch = \"aarch64\",\n                                          target_arch = \"arm\")),\n+          all(target_os = \"l4re\", target_arch = \"x86_64\"),\n           all(target_os = \"fuchsia\", target_arch = \"aarch64\")))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_char = u8;\n #[cfg(not(any(all(target_os = \"linux\", any(target_arch = \"aarch64\",\n@@ -30,6 +31,7 @@ use fmt;\n                                            target_arch = \"s390x\")),\n               all(target_os = \"android\", any(target_arch = \"aarch64\",\n                                              target_arch = \"arm\")),\n+              all(target_os = \"l4re\", target_arch = \"x86_64\"),\n               all(target_os = \"fuchsia\", target_arch = \"aarch64\"))))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_char = i8;\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_schar = i8;"}, {"sha": "c4aad8d86f8b1f5e4b6fba452c4eb64e9476cf6d", "filename": "src/libstd/sys/redox/thread.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Fredox%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Fredox%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fthread.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f", "patch": "@@ -16,6 +16,8 @@ use sys_common::thread::start_thread;\n use sys::{cvt, syscall};\n use time::Duration;\n \n+pub const DEFAULT_MIN_STACK_SIZE: usize = 2 * 1024 * 1024;\n+\n pub struct Thread {\n     id: usize,\n }"}, {"sha": "6c071afd42d05a142108ee598f263e2d367abedf", "filename": "src/libstd/sys/redox/time.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Fredox%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Fredox%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ftime.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "72169773df596ee977e384d37513e7515ecbe17b", "filename": "src/libstd/sys/unix/args.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Funix%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Funix%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fargs.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "b5bf20c747be6e8ad6933ca31fc0e2a0c2096570", "filename": "src/libstd/sys/unix/backtrace/mod.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fmod.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "21f0b3724c13066883416d8eaf41e2f7278d1f0a", "filename": "src/libstd/sys/unix/backtrace/printing/dladdr.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fdladdr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fdladdr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fdladdr.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "8bd2d9eccd82a73db84ee6662d4df33e2af8e192", "filename": "src/libstd/sys/unix/backtrace/printing/mod.rs", "status": "modified", "additions": 31, "deletions": 10, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fmod.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "89a44b976578363f1d439d87cf0c0420c4dbd0d4", "filename": "src/libstd/sys/unix/condvar.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "3d9a06bedd57cc74898803dc17764547c7e5ad6d", "filename": "src/libstd/sys/unix/env.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Funix%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Funix%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fenv.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "5dafc3251e7551e10f6c68573b479a16cd2efbf6", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "13112fc1fa5904e6d6b4f8bfcda702893b2c056b", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "21218489679393a92a655bf0012caa5ad242f962", "filename": "src/libstd/sys/unix/l4re.rs", "status": "added", "additions": 441, "deletions": 0, "changes": 441, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "1b3f1000b77bbdf681b31946e1cf482678305e21", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "5ef98d247105e6e1a36e9f59484bf76f4ac97aff", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "870db8200273eb84e543bbda841519eada1f46b3", "filename": "src/libstd/sys/unix/process/process_unix.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "6c4a332429646be75c156884d409d8c090c7bdb3", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "c1bea95ce91abb0135ab2507f0807f19dbb92597", "filename": "src/libstd/sys/unix/time.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftime.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "c47baaa2434025fe4476fd8ac4b6dc3431c31dad", "filename": "src/libstd/sys/windows/thread.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "1be29b5139a557145ca14b7f5dd771cb3476fa41", "filename": "src/libstd/sys/windows/time.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "d7654ce9300b377d124000a0c1de02dd92673a64", "filename": "src/libstd/sys_common/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmod.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "19dc841b9b5024961abb1eea38c84d22d1fc6693", "filename": "src/libstd/sys_common/net.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fnet.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "87fb34a9dec06459f95806377a451db8bbc27648", "filename": "src/libstd/sys_common/thread.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys_common%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys_common%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fthread.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "a391c7cc6ef0c959c2e25eaf0bddf175cbb59cec", "filename": "src/libstd/sys_common/util.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys_common%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fsys_common%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Futil.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "a53c76a333a99dbc576ec72411c5da6433ea3df1", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "ca01eaefcaef4c8ac7ebb4a7b453d3e2f4390429", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "d4993ded843ddb5304306e4588728089b62ffb58", "filename": "src/libstd/time/mod.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Ftime%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd%2Ftime%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fmod.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "0046e3f7bd0938ca379cbe00b31b4fd022e0d3de", "filename": "src/libstd_unicode/u_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd_unicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibstd_unicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Fu_str.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "5248f874a6e970da106a42098ab485a02f991877", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "3d4ded2ae815fd03d0a9bbc7813e57cb267c1c7e", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "ce3f16d2ba1b906df8b8fb086f9d9692a84a36a0", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 47, "deletions": 40, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "c679efd41ea4629339f24cac4cd5eb5cad7d3965", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "cd1a7e7b794ba16578b910363f981734eebb08ef", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 43, "deletions": 11, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "9903dc50f36fb4480aab744724df83cff444252f", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 82, "deletions": 65, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "a4f06cb1b45da6fca561a7cba8cdde6f4ada1e9b", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 103, "deletions": 1, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "63c533df198d0173239e67e0d202ba42b09d3dc5", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 3, "deletions": 36, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "64dcdd39e7c2c59e30c2aedccd7113844132f336", "filename": "src/test/compile-fail/associated-types-subtyping-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Fassociated-types-subtyping-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Fassociated-types-subtyping-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-subtyping-1.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "37f665960c8c821aada4c30e4382363ca050b46d", "filename": "src/test/compile-fail/check-static-values-constraints.rs", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "707037911015cc50bc7ee0759f3f46471fc481f2", "filename": "src/test/compile-fail/const-block-non-item-statement-3.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement-3.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "802e660b9048db4a68133b9849b254add584d278", "filename": "src/test/compile-fail/const-block-non-item-statement.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "385daef44dfe54a27db729d344af2ae20ff51f3a", "filename": "src/test/compile-fail/const-fn-error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Fconst-fn-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Fconst-fn-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-fn-error.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "3c84810554214c4fa9b548cfc8188b822a3bc09a", "filename": "src/test/compile-fail/const-len-underflow-separate-spans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-separate-spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-separate-spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-separate-spans.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "cbeafdfe6acc97eeb74a2b337920af6c177299bf", "filename": "src/test/compile-fail/const-size_of-cycle.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Fconst-size_of-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Fconst-size_of-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-size_of-cycle.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "20e0f9cd0b2516d6dbffee47c3e09f8b0196a009", "filename": "src/test/compile-fail/empty-linkname.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Fempty-linkname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Fempty-linkname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-linkname.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "96fffa6cdd0dcee0625459da8023f981709789f7", "filename": "src/test/compile-fail/feature-gate-repr128.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Ffeature-gate-repr128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Ffeature-gate-repr128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-repr128.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "0d13a4937c468ccb397a1e8cefe68687e4709323", "filename": "src/test/compile-fail/feature-gate-static-nobundle.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Ffeature-gate-static-nobundle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Ffeature-gate-static-nobundle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-static-nobundle.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "06b872066695393aed63937490d1779dc88bc952", "filename": "src/test/compile-fail/feature-gate/issue-43106-gating-of-builtin-attrs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Ffeature-gate%2Fissue-43106-gating-of-builtin-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Ffeature-gate%2Fissue-43106-gating-of-builtin-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate%2Fissue-43106-gating-of-builtin-attrs.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "3d9ec0a6581d63e08f358b69d5c48ca13f30abf0", "filename": "src/test/compile-fail/issue-22706.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Fissue-22706.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Fissue-22706.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22706.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "97456c2da87fec29571e500861ce315c0d653e24", "filename": "src/test/compile-fail/issue-22933-2.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Fissue-22933-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Fissue-22933-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22933-2.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "62adae41adfc8ae283858981aaefd6f18f1dd2ea", "filename": "src/test/compile-fail/issue-22933-3.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Fissue-22933-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Fissue-22933-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22933-3.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "2da21fb14bd3c483314f6d6edec946643d5ea54f", "filename": "src/test/compile-fail/issue-39559.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Fissue-39559.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Fissue-39559.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-39559.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "31bc21c23ba5f08e1f2306a097717b9f4d041986", "filename": "src/test/compile-fail/issue-41229-ref-str.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Fissue-41229-ref-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Fissue-41229-ref-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-41229-ref-str.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}, {"sha": "0fd31454596e645ece7c87be14ea4a34f29f3518", "filename": "src/test/compile-fail/issue-43733-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Fissue-43733-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597ac36547f5b135d55bd4cf26964762c8c4796f/src%2Ftest%2Fcompile-fail%2Fissue-43733-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-43733-2.rs?ref=597ac36547f5b135d55bd4cf26964762c8c4796f"}]}