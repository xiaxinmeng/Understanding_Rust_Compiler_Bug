{"sha": "a94e197105a0ce67cba816299cdd59efdb6df7a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5NGUxOTcxMDVhMGNlNjdjYmE4MTYyOTljZGQ1OWVmZGI2ZGY3YTQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-07T20:08:20Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-15T08:35:40Z"}, "message": "better test the special exception for reading through unique when things are shared", "tree": {"sha": "e6390b1f62d8fd3c73888c3f4b1483da30f2cef9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6390b1f62d8fd3c73888c3f4b1483da30f2cef9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a94e197105a0ce67cba816299cdd59efdb6df7a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a94e197105a0ce67cba816299cdd59efdb6df7a4", "html_url": "https://github.com/rust-lang/rust/commit/a94e197105a0ce67cba816299cdd59efdb6df7a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a94e197105a0ce67cba816299cdd59efdb6df7a4/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa8f523df6447a32c15d2620a52a55761f94da97", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa8f523df6447a32c15d2620a52a55761f94da97", "html_url": "https://github.com/rust-lang/rust/commit/aa8f523df6447a32c15d2620a52a55761f94da97"}], "stats": {"total": 46, "additions": 41, "deletions": 5}, "files": [{"sha": "56688ca10f49a85d99450063148b72b7f78daf41", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a94e197105a0ce67cba816299cdd59efdb6df7a4/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a94e197105a0ce67cba816299cdd59efdb6df7a4/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=a94e197105a0ce67cba816299cdd59efdb6df7a4", "patch": "@@ -167,13 +167,15 @@ impl<'tcx> Stack {\n                                         behind a barrier\", bor))\n                 }\n                 (BorStackItem::Uniq(itm_t), Borrow::Uniq(bor_t)) if itm_t == bor_t => {\n-                    // Found matching unique item.\n+                    // Found matching unique item.  This is *always* required to use a `Uniq`:\n+                    // The item must still be on the stack.\n                     if !is_write {\n-                        // As a special case, if we are reading and since we *did* find the `Uniq`,\n-                        // we try to pop less: We are happy with making a `Shr` or `Frz` active;\n-                        // that one will not mind concurrent reads.\n+                        // As a special case, if we are reading, let us see if it would be\n+                        // beneficial to pretend we are a raw pointer instead.  If\n+                        // raw pointers are allowed to read while popping *less* than we\n+                        // would have to pop, there is no reason not to let them do this.\n                         match self.reactivatable(Borrow::default(), is_write) {\n-                            // If we got something better that `idx`, use that\n+                            // If we got something better (popping less) that `idx`, use that\n                             Ok(None) => return Ok(None),\n                             Ok(Some(shr_idx)) if shr_idx <= idx => return Ok(Some(shr_idx)),\n                             // Otherwise just go on.\n@@ -329,6 +331,8 @@ impl<'tcx> Stacks {\n                 )))\n             }\n             // Sometimes we also need to be frozen.\n+            // In this case we *both* push `Shr` and then freeze.  This means that a `&mut`\n+            // to `*const` to `*mut` cast through `&` actually works.\n             if frozen {\n                 // Even shared refs can have uniq tags (after transmute).  That's not an error\n                 // but they do not get any freezing benefits."}, {"sha": "c86ec1286daad8121b41b45e1672521e69e91f53", "filename": "tests/compile-fail/stacked_borrows/illegal_read4.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a94e197105a0ce67cba816299cdd59efdb6df7a4/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a94e197105a0ce67cba816299cdd59efdb6df7a4/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read4.rs?ref=a94e197105a0ce67cba816299cdd59efdb6df7a4", "patch": "@@ -0,0 +1,9 @@\n+// Using a raw invalidates derived `&mut` even for reading.\n+fn main() {\n+    let mut x = 2;\n+    let xref1 = &mut x;\n+    let xraw = xref1 as *mut _;\n+    let xref2 = unsafe { &mut *xraw };\n+    let _val = unsafe { *xraw }; // use the raw again, this invalidates xref2 *even* with the special read except for uniq refs\n+    let _illegal = *xref2; //~ ERROR does not exist on the stack\n+}"}, {"sha": "7b7a7c9be2030b50dc6c9f0244b42845e67c6b8f", "filename": "tests/run-pass/stacked-borrows.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a94e197105a0ce67cba816299cdd59efdb6df7a4/tests%2Frun-pass%2Fstacked-borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a94e197105a0ce67cba816299cdd59efdb6df7a4/tests%2Frun-pass%2Fstacked-borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstacked-borrows.rs?ref=a94e197105a0ce67cba816299cdd59efdb6df7a4", "patch": "@@ -6,6 +6,7 @@ fn main() {\n     ref_raw_int_raw();\n     mut_shr_raw();\n     mut_raw_then_mut_shr();\n+    mut_raw_mut();\n }\n \n // Deref a raw ptr to access a field of a large struct, where the field\n@@ -76,3 +77,25 @@ fn mut_raw_then_mut_shr() {\n     }\n     assert_eq!(x, 4);\n }\n+\n+// Ensure that if we derive from a mut a raw, and then from that a mut,\n+// and then read through the original mut, that does not invalidate the raw.\n+// This shows that the read-exception for `&mut` applies even if the `Shr` item\n+// on the stack is not at the top.\n+fn mut_raw_mut() {\n+    let mut x = 2;\n+    {\n+        let xref1 = &mut x;\n+        let xraw = xref1 as *mut _;\n+        let _xref2 = unsafe { &mut *xraw };\n+        let _val = *xref1;\n+        unsafe { *xraw = 4; }\n+        // we can now use both xraw and xref1, for reading\n+        assert_eq!(*xref1, 4);\n+        assert_eq!(unsafe { *xraw }, 4);\n+        assert_eq!(*xref1, 4);\n+        assert_eq!(unsafe { *xraw }, 4);\n+        // we cannot use xref2; see `compile-fail/stacked-borows/illegal_read4.rs`\n+    }\n+    assert_eq!(x, 4);\n+}"}]}