{"sha": "762d4ac734e096e8e4ea9fdeb23cf6ce9965d2c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2MmQ0YWM3MzRlMDk2ZThlNGVhOWZkZWIyM2NmNmNlOTk2NWQyYzM=", "commit": {"author": {"name": "Jonathan S", "email": "gereeter+code@gmail.com", "date": "2016-01-21T03:12:39Z"}, "committer": {"name": "Jonathan S", "email": "gereeter+code@gmail.com", "date": "2016-02-06T01:49:13Z"}, "message": "Start documenting BTreeMap's node interface", "tree": {"sha": "dd19ba21be1aedb637135158c7303207350e07d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd19ba21be1aedb637135158c7303207350e07d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/762d4ac734e096e8e4ea9fdeb23cf6ce9965d2c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/762d4ac734e096e8e4ea9fdeb23cf6ce9965d2c3", "html_url": "https://github.com/rust-lang/rust/commit/762d4ac734e096e8e4ea9fdeb23cf6ce9965d2c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/762d4ac734e096e8e4ea9fdeb23cf6ce9965d2c3/comments", "author": {"login": "gereeter", "id": 2328242, "node_id": "MDQ6VXNlcjIzMjgyNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2328242?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gereeter", "html_url": "https://github.com/gereeter", "followers_url": "https://api.github.com/users/gereeter/followers", "following_url": "https://api.github.com/users/gereeter/following{/other_user}", "gists_url": "https://api.github.com/users/gereeter/gists{/gist_id}", "starred_url": "https://api.github.com/users/gereeter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gereeter/subscriptions", "organizations_url": "https://api.github.com/users/gereeter/orgs", "repos_url": "https://api.github.com/users/gereeter/repos", "events_url": "https://api.github.com/users/gereeter/events{/privacy}", "received_events_url": "https://api.github.com/users/gereeter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gereeter", "id": 2328242, "node_id": "MDQ6VXNlcjIzMjgyNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2328242?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gereeter", "html_url": "https://github.com/gereeter", "followers_url": "https://api.github.com/users/gereeter/followers", "following_url": "https://api.github.com/users/gereeter/following{/other_user}", "gists_url": "https://api.github.com/users/gereeter/gists{/gist_id}", "starred_url": "https://api.github.com/users/gereeter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gereeter/subscriptions", "organizations_url": "https://api.github.com/users/gereeter/orgs", "repos_url": "https://api.github.com/users/gereeter/repos", "events_url": "https://api.github.com/users/gereeter/events{/privacy}", "received_events_url": "https://api.github.com/users/gereeter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "url": "https://api.github.com/repos/rust-lang/rust/commits/34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "html_url": "https://github.com/rust-lang/rust/commit/34af2de4096b3b1c5d3a5b70171c6e27822aaefb"}], "stats": {"total": 152, "additions": 149, "deletions": 3}, "files": [{"sha": "cfca717f992faefe535d466fe90504260bc48bc2", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 149, "deletions": 3, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/762d4ac734e096e8e4ea9fdeb23cf6ce9965d2c3/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/762d4ac734e096e8e4ea9fdeb23cf6ce9965d2c3/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=762d4ac734e096e8e4ea9fdeb23cf6ce9965d2c3", "patch": "@@ -31,6 +31,16 @@\n // Since Rust doesn't acutally have dependent types and polymorphic recursion,\n // we make do with lots of unsafety.\n \n+// A major goal of this module is to avoid complexity by treating the tree as a generic (if\n+// weirdly shaped) container and avoiding dealing with most of the B-Tree invariants. As such,\n+// this module doesn't care whether the entries are sorted, which nodes can be underfull, or\n+// even what underfull means. However, we do rely on a few invariants:\n+//\n+// - Trees must have uniform depth/height. This means that every path down to a leaf from a\n+//   given node has exactly the same length.\n+// - A node of length `n` has `n` keys, `n` values, and (in an internal node) `n + 1` edges.\n+//   This implies that even an empty node has at least one edge.\n+\n use alloc::heap;\n use core::marker::PhantomData;\n use core::mem;\n@@ -43,17 +53,39 @@ use boxed::Box;\n const B: usize = 6;\n pub const CAPACITY: usize = 2 * B - 1;\n \n+/// The underlying representation of leaf nodes. Note that is often unsafe to actually store\n+/// these, since only the first `len` keys and values are assumed to initialized. See also\n+/// rust-lang/rfcs#197, which would make this structure significantly more safe by avoiding\n+/// accidentally dropping unused and uninitialized keys and values.\n struct LeafNode<K, V> {\n+    // The arrays storing the actual data of the node. Only the first `len` elements of each\n+    // array are initialized and valid.\n     keys: [K; CAPACITY],\n     vals: [V; CAPACITY],\n+\n+    // We use `*const` as opposed to `*mut` so as to be covariant in `K` and `V`.\n+    // This either points to an actual node or is null.\n     parent: *const InternalNode<K, V>,\n+\n+    // The index into the parent node's `edges` array. `*node.parent.edges[node.parent_idx]`\n+    // should be the same thing as `node`.\n+    // This is only guaranteed to be initialized when `parent` is nonnull.\n     parent_idx: u16,\n+\n+    // The number of keys and values this node stores.\n+    // This is at the end of the node's representation and next to `parent_idx` to encourage\n+    // the compiler to join `len` and `parent_idx` into the same 32-bit word, reducing space\n+    // overhead.\n     len: u16,\n }\n \n impl<K, V> LeafNode<K, V> {\n+    /// Create a new `LeafNode`. Unsafe because all nodes should really be hidden behind\n+    /// `BoxedNode`, preventing accidental dropping of uninitialized keys and values.\n     unsafe fn new() -> Self {\n         LeafNode {\n+            // As a general policy, we leave fields uninitialized if they can be, as this should\n+            // be both slightly faster and easier to track in Valgrind.\n             keys: mem::uninitialized(),\n             vals: mem::uninitialized(),\n             parent: ptr::null(),\n@@ -63,15 +95,25 @@ impl<K, V> LeafNode<K, V> {\n     }\n }\n \n-// We use repr(C) so that a pointer to an internal node can be\n-// directly used as a pointer to a leaf node\n+/// The underlying representation of internal nodes. As with `LeafNode`s, these should be hidden\n+/// behind `BoxedNode`s to prevent dropping uninitialized keys and values. Any pointer to an\n+/// `InternalNode` can be directly casted to a pointer to the underlying `LeafNode` portion of the\n+/// node, allowing code to act on leaf and internal nodes generically without having to even check\n+/// which of the two a pointer is pointing at. This property is enabled by the use of `repr(C)`.\n #[repr(C)]\n struct InternalNode<K, V> {\n     data: LeafNode<K, V>,\n+\n+    // `len + 1` of these are considered to be initialized and valid.\n     edges: [BoxedNode<K, V>; 2 * B],\n }\n \n impl<K, V> InternalNode<K, V> {\n+    /// Create a new `InternalNode`. This is unsafe for two reasons. First, it returns an\n+    /// `InternalNode` by value, risking dropping of uninitialized fields. Second, an invariant of\n+    /// internal nodes is that `len + 1` edges are initialized and valid, meaning that even when\n+    /// the node is empty (having `len` 0), there must be one initialized and valid edge. This\n+    /// function does not set up such an edge.\n     unsafe fn new() -> Self {\n         InternalNode {\n             data: LeafNode::new(),\n@@ -80,8 +122,12 @@ impl<K, V> InternalNode<K, V> {\n     }\n }\n \n+/// An owned pointer to a node. This basically is either `Box<LeafNode<K, V>>` or\n+/// `Box<InternalNode<K, V>>`. However, it contains no information as to which of the two types\n+/// of nodes is acutally behind the box, and, partially due to this lack of information, has no\n+/// destructor.\n struct BoxedNode<K, V> {\n-    ptr: Unique<LeafNode<K, V>> // we don't know if this points to a leaf node or an internal node\n+    ptr: Unique<LeafNode<K, V>>\n }\n \n impl<K, V> BoxedNode<K, V> {\n@@ -229,6 +275,7 @@ impl<K, V> Root<K, V> {\n pub struct NodeRef<BorrowType, K, V, Type> {\n     height: usize,\n     node: NonZero<*const LeafNode<K, V>>,\n+    // This is null unless the borrow type is `Mut`\n     root: *const Root<K, V>,\n     _marker: PhantomData<(BorrowType, Type)>\n }\n@@ -268,10 +315,14 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n \n \n impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n+    /// Find the length of the node. This is the number of keys or values. In an\n+    /// internal node, the number of edges is `len() + 1`.\n     pub fn len(&self) -> usize {\n         self.as_leaf().len as usize\n     }\n \n+    /// Remove any static information about whether this node is a `Leaf` or an\n+    /// `Internal` node.\n     pub fn forget_type(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n         NodeRef {\n             height: self.height,\n@@ -281,6 +332,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         }\n     }\n \n+    /// Temporarily take out another, immutable reference to the same node.\n     fn reborrow<'a>(&'a self) -> NodeRef<marker::Immut<'a>, K, V, Type> {\n         NodeRef {\n             height: self.height,\n@@ -304,6 +356,13 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         self.reborrow().into_slices().1\n     }\n \n+    /// Find the parent of the current node. Returns `Ok(handle)` if the current\n+    /// node actually has a parent, where `handle` points to the edge of the parent\n+    /// that points to the current node. Returns `Err(self)` if the current node has\n+    /// no parent, giving back the original `NodeRef`.\n+    ///\n+    /// `edge.descend().ascend().unwrap()` and `node.ascend().unwrap().descend()` should\n+    /// both, upon success, do nothing.\n     pub fn ascend(self) -> Result<\n         Handle<\n             NodeRef<\n@@ -344,6 +403,9 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n }\n \n impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n+    /// Similar to `ascend`, get a reference to a node's parent node, but also\n+    /// deallocate the current node in the process. This is unsafe because the\n+    /// current node will still be accessible despite being deallocated.\n     pub unsafe fn deallocate_and_ascend(self) -> Option<\n         Handle<\n             NodeRef<\n@@ -362,6 +424,9 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n }\n \n impl<K, V> NodeRef<marker::Owned, K, V, marker::Internal> {\n+    /// Similar to `ascend`, get a reference to a node's parent node, but also\n+    /// deallocate the current node in the process. This is unsafe because the\n+    /// current node will still be accessible despite being deallocated.\n     pub unsafe fn deallocate_and_ascend(self) -> Option<\n         Handle<\n             NodeRef<\n@@ -384,6 +449,8 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Internal> {\n }\n \n impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n+    /// Unsafely assert to the compiler some static information about whether this\n+    /// node is a `Leaf`.\n     unsafe fn cast_unchecked<NewType>(&mut self)\n             -> NodeRef<marker::Mut, K, V, NewType> {\n \n@@ -395,6 +462,16 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         }\n     }\n \n+    /// Temporarily take out another, mutable reference to the same node. Beware, as\n+    /// this method is very dangerous, doubly so since it may not immediately appear\n+    /// dangerous.\n+    ///\n+    /// Because mutable pointers can roam anywhere around the tree and can even (through\n+    /// `into_root_mut`) mess with the root of the tree, the result of `reborrow_mut`\n+    /// can easily be used to make the original mutable pointer dangling, or, in the case\n+    /// of a reborrowed handle, out of bounds.\n+    // FIXME(@gereeter) consider adding yet another type parameter to `NodeRef` that restricts\n+    // the use of `ascend` and `into_root_mut` on reborrowed pointers, preventing this unsafety.\n     unsafe fn reborrow_mut(&mut self) -> NodeRef<marker::Mut, K, V, Type> {\n         NodeRef {\n             height: self.height,\n@@ -437,6 +514,8 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n }\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n+    /// Get a mutable reference to the root itself. This is useful primarily when the\n+    /// height of the tree needs to be adjusted. Never call this on a reborrowed pointer.\n     pub fn into_root_mut(self) -> &'a mut Root<K, V> {\n         unsafe {\n             &mut *(self.root as *mut Root<K, V>)\n@@ -460,6 +539,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n+    /// Add a key/value pair the end of the node.\n     pub fn push(&mut self, key: K, val: V) {\n         // Necessary for correctness, but this is an internal module\n         debug_assert!(self.len() < CAPACITY);\n@@ -474,6 +554,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n         self.as_leaf_mut().len += 1;\n     }\n \n+    /// Add a key/value pair to the beginning of the node.\n     pub fn push_front(&mut self, key: K, val: V) {\n         // Necessary for correctness, but this is an internal module\n         debug_assert!(self.len() < CAPACITY);\n@@ -488,6 +569,8 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n+    /// Add a key/value pair and an edge to go to the right of that pair to\n+    /// the end of the node.\n     pub fn push(&mut self, key: K, val: V, edge: Root<K, V>) {\n         // Necessary for correctness, but this is an internal module\n         debug_assert!(edge.height == self.height - 1);\n@@ -506,6 +589,8 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         }\n     }\n \n+    /// Add a key/value pair and an edge to go to the left of that pair to\n+    /// the beginning of the node.\n     pub fn push_front(&mut self, key: K, val: V, edge: Root<K, V>) {\n         // Necessary for correctness, but this is an internal module\n         debug_assert!(edge.height == self.height - 1);\n@@ -534,6 +619,8 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n+    /// Remove a key/value pair from the end of this node. If this is an internal node,\n+    /// also remove the edge that was to the right of that pair.\n     pub fn pop(&mut self) -> (K, V, Option<Root<K, V>>) {\n         // Necessary for correctness, but this is an internal module\n         debug_assert!(self.len() > 0);\n@@ -558,6 +645,8 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         }\n     }\n \n+    /// Remove a key/value pair from the beginning of this node. If this is an internal node,\n+    /// also remove the edge that was to the left of that pair.\n     pub fn pop_front(&mut self) -> (K, V, Option<Root<K, V>>) {\n         // Necessary for correctness, but this is an internal module\n         debug_assert!(self.len() > 0);\n@@ -597,6 +686,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n }\n \n impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n+    /// Check whether a node is an `Internal` node or a `Leaf` node.\n     pub fn force(self) -> ForceResult<\n         NodeRef<BorrowType, K, V, marker::Leaf>,\n         NodeRef<BorrowType, K, V, marker::Internal>\n@@ -619,26 +709,33 @@ impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n     }\n }\n \n+/// A reference to a specific key/value pair or edge within a node. The `Node` parameter\n+/// must be a `NodeRef`, while the `Type` can either be `KV` (signifying a handle on a key/value\n+/// pair) or `Edge` (signifying a handle on an edge).\n pub struct Handle<Node, Type> {\n     node: Node,\n     idx: usize,\n     _marker: PhantomData<Type>\n }\n \n impl<Node: Copy, Type> Copy for Handle<Node, Type> { }\n+// We don't need the full generality of `#[derive(Clone)]`, as the only time `Node` will be\n+// `Clone`able is when it is an immutable reference and therefore `Copy`.\n impl<Node: Copy, Type> Clone for Handle<Node, Type> {\n     fn clone(&self) -> Self {\n         *self\n     }\n }\n \n impl<Node, Type> Handle<Node, Type> {\n+    /// Retrieve the node that contains the edge of key/value pair this handle pointes to.\n     pub fn into_node(self) -> Node {\n         self.node\n     }\n }\n \n impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::KV> {\n+    /// Create a new handle to a key/value pair in `node`. `idx` must be less than `node.len()`.\n     pub fn new_kv(node: NodeRef<BorrowType, K, V, NodeType>, idx: usize) -> Self {\n         // Necessary for correctness, but in a private module\n         debug_assert!(idx < node.len());\n@@ -670,6 +767,7 @@ impl<BorrowType, K, V, NodeType, HandleType> PartialEq\n impl<BorrowType, K, V, NodeType, HandleType>\n         Handle<NodeRef<BorrowType, K, V, NodeType>, HandleType> {\n \n+    /// Temporarily take out another, immutable handle on the same location.\n     pub fn reborrow(&self)\n             -> Handle<NodeRef<marker::Immut, K, V, NodeType>, HandleType> {\n \n@@ -685,6 +783,16 @@ impl<BorrowType, K, V, NodeType, HandleType>\n impl<'a, K, V, NodeType, HandleType>\n         Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, HandleType> {\n \n+    /// Temporarily take out another, mutable handle on the same location. Beware, as\n+    /// this method is very dangerous, doubly so since it may not immediately appear\n+    /// dangerous.\n+    ///\n+    /// Because mutable pointers can roam anywhere around the tree and can even (through\n+    /// `into_root_mut`) mess with the root of the tree, the result of `reborrow_mut`\n+    /// can easily be used to make the original mutable pointer dangling, or, in the case\n+    /// of a reborrowed handle, out of bounds.\n+    // FIXME(@gereeter) consider adding yet another type parameter to `NodeRef` that restricts\n+    // the use of `ascend` and `into_root_mut` on reborrowed pointers, preventing this unsafety.\n     pub unsafe fn reborrow_mut(&mut self)\n             -> Handle<NodeRef<marker::Mut, K, V, NodeType>, HandleType> {\n \n@@ -700,6 +808,8 @@ impl<'a, K, V, NodeType, HandleType>\n impl<BorrowType, K, V, NodeType>\n         Handle<NodeRef<BorrowType, K, V, NodeType>, marker::Edge> {\n \n+    /// Create a new handle to an edge in `node`. `idx` must be less than or equal to\n+    /// `node.len()`.\n     pub fn new_edge(node: NodeRef<BorrowType, K, V, NodeType>, idx: usize) -> Self {\n         // Necessary for correctness, but in a private module\n         debug_assert!(idx <= node.len());\n@@ -733,6 +843,10 @@ impl<BorrowType, K, V, NodeType>\n }\n \n impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {\n+    /// Insert a new key/value pair into the space defined by this edge, assuming that there\n+    /// is enough space in the node for the new pair to fit.\n+    ///\n+    /// The returned pointer points to the inserted value.\n     fn insert_fit(&mut self, key: K, val: V) -> *mut V {\n         // Necessary for correctness, but in a private module\n         debug_assert!(self.node.len() < CAPACITY);\n@@ -747,6 +861,10 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n         }\n     }\n \n+    /// Insert a new key/value pair into the space defined by this edge, possibly splitting\n+    /// the node if there isn't enough room.\n+    ///\n+    /// The returned pointer points to the inserted value.\n     pub fn insert(mut self, key: K, val: V)\n             -> (InsertResult<'a, K, V, marker::Leaf>, *mut V) {\n \n@@ -774,6 +892,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n }\n \n impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::Edge> {\n+    /// Fix the parent pointer and index in the child node below this edge. This is useful\n+    /// when the ordering of edges has been changed, such as in the various `insert` methods.\n     fn correct_parent_link(mut self) {\n         let idx = self.idx as u16;\n         let ptr = self.node.as_internal_mut() as *mut _;\n@@ -782,18 +902,24 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         child.as_leaf_mut().parent_idx = idx;\n     }\n \n+    /// Unsafely assert to the compiler some static information about whether the underlying\n+    /// node of this handle is a `Leaf`.\n     unsafe fn cast_unchecked<NewType>(&mut self)\n             -> Handle<NodeRef<marker::Mut, K, V, NewType>, marker::Edge> {\n \n         Handle::new_edge(self.node.cast_unchecked(), self.idx)\n     }\n \n+    /// Insert a new key/value pair into the space defined by this edge, as well as a new edge\n+    /// to go to the right of the new pair, assuming that there is enough space in the node for\n+    /// the new pair to fit.\n     fn insert_fit(&mut self, key: K, val: V, edge: Root<K, V>) {\n         // Necessary for correctness, but in an internal module\n         debug_assert!(self.node.len() < CAPACITY);\n         debug_assert!(edge.height == self.node.height - 1);\n \n         unsafe {\n+            // This cast is a lie, but it allows us to reuse the key/value insertion logic.\n             self.cast_unchecked::<marker::Leaf>().insert_fit(key, val);\n \n             slice_insert(\n@@ -811,6 +937,9 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         }\n     }\n \n+    /// Insert a new key/value pair into the space defined by this edge, as well as a new edge\n+    /// to go to the right of the new pair, possibly splitting the node if there isn't enough\n+    /// room.\n     pub fn insert(mut self, key: K, val: V, edge: Root<K, V>)\n             -> InsertResult<'a, K, V, marker::Internal> {\n \n@@ -843,6 +972,10 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n impl<BorrowType, K, V>\n         Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::Edge> {\n \n+    /// Find the node pointed to by this edge.\n+    ///\n+    /// `edge.descend().ascend().unwrap()` and `node.ascend().unwrap().descend()` should\n+    /// both, upon success, do nothing.\n     pub fn descend(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n         NodeRef {\n             height: self.node.height - 1,\n@@ -885,6 +1018,9 @@ impl<'a, K, V, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker\n }\n \n impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV> {\n+    /// Split the underlying node into three parts. The node is truncated in place to what is\n+    /// to the left of this handle, and the key and value pointed at by this handle and the\n+    /// rest of the node to the right of this handle are returned separately.\n     pub fn split(mut self)\n             -> (NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, K, V, Root<K, V>) {\n         unsafe {\n@@ -920,6 +1056,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n         }\n     }\n \n+    /// Remove the key/value pair pointed to by this handle, returning the edge representing\n+    /// the empty space left behind.\n     pub fn remove(mut self)\n             -> (Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>, K, V) {\n         unsafe {\n@@ -932,6 +1070,9 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n }\n \n impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::KV> {\n+    /// Split the underlying node into three parts. The node is truncated in place to what is\n+    /// to the left of this handle, and the key and value pointed at by this handle and the\n+    /// rest of the node to the right of this handle are returned separately.\n     pub fn split(mut self)\n             -> (NodeRef<marker::Mut<'a>, K, V, marker::Internal>, K, V, Root<K, V>) {\n         unsafe {\n@@ -979,6 +1120,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         }\n     }\n \n+    /// Return whether it is valid to call `.merge()`.\n     pub fn can_merge(&self) -> bool {\n         (\n             self.reborrow()\n@@ -993,6 +1135,9 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         ) <= CAPACITY\n     }\n \n+    /// Combine the node immediately to the left of this handle, the key/value pair pointed\n+    /// to by this handle, and the node immediately to the right of this handle into one new\n+    /// child of the underlying node, returning an edge referencing that new child.\n     pub fn merge(mut self)\n             -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::Edge> {\n         let self1 = unsafe { ptr::read(&self) };\n@@ -1068,6 +1213,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n impl<BorrowType, K, V, HandleType>\n         Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, HandleType> {\n \n+    /// Check whether the underlying node is an `Internal` node or a `Leaf` node.\n     pub fn force(self) -> ForceResult<\n         Handle<NodeRef<BorrowType, K, V, marker::Leaf>, HandleType>,\n         Handle<NodeRef<BorrowType, K, V, marker::Internal>, HandleType>"}]}