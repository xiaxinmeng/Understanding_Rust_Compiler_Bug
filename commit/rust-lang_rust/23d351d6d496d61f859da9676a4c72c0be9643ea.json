{"sha": "23d351d6d496d61f859da9676a4c72c0be9643ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzZDM1MWQ2ZDQ5NmQ2MWY4NTlkYTk2NzZhNGM3MmMwYmU5NjQzZWE=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-07-31T11:30:44Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-08-01T07:56:21Z"}, "message": "Move tls code to its own file", "tree": {"sha": "e1165c6b908d48e02b545b38effb59f1d3cbe385", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1165c6b908d48e02b545b38effb59f1d3cbe385"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/23d351d6d496d61f859da9676a4c72c0be9643ea", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlmANCUACgkQpp+NIls6\n19lRiBAAh3ICmVTJAZhs5gAVtK0a+YIJcGmR9nPqf3vD9scc46F6PrxYx1rWqlRf\n5Tk168w33raoa+81VAT4tyKw9BfG4vq4e7UmgjetFuxKV3hKBa+hhNye7jazEvo5\nmbMjT4whXbVo5+4zBS87isy+w4MHTPPJFhcDqhC0rEfIqW+HaoBoTVSMbollEftu\n+dvjDhZLdBUFkFUQ3F587NCFfSU5jFW5ropAi/Y0OpvGGqKD02gc1bqRAa0wBEDf\nEs2b3qCLf/MWbGz4hUGk5QQXFreBWWTZhhrNQkmm+aZ65yyJgUd90VNDkEKajVF6\nGvpZTz6vZD2rhYnFHj5nx2Iz1OQzGOIKZJEALbKQ+dwpwLb6rIJHMbiuozMCvHh0\nTyVQmexiIxlvEKykvkKQmluytO/4iljx2cdkZ3cCIZhIR4qyUhiM8q87DGzqvXcx\neyg7maelSNP9uD431nfmK45NqjFMJAnbi85ZLl44e8XCzqHnebRFsnoOi2XzqjWU\nhNUDc/mpY0cf/FGPz2Yr6r2/qXdIMGXxSRXqzpHntQ2G/QGcjF4Bp2YiE02/cWeN\nZa3RwD01Y/VBhE6jTHaklX6u7YVMYhW+SB6hJHcezY8BwPceTydZoOa5suKUlfFM\n0VLKhRLcomL0zzGfuq1pswm5u+nuNMk8PbqbIFb5ZYGmE/Tpezo=\n=FjU4\n-----END PGP SIGNATURE-----", "payload": "tree e1165c6b908d48e02b545b38effb59f1d3cbe385\nparent adfea61665385428b9c9aced9442dba65464c3c8\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1501500644 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1501574181 +0200\n\nMove tls code to its own file\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/23d351d6d496d61f859da9676a4c72c0be9643ea", "html_url": "https://github.com/rust-lang/rust/commit/23d351d6d496d61f859da9676a4c72c0be9643ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/23d351d6d496d61f859da9676a4c72c0be9643ea/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "adfea61665385428b9c9aced9442dba65464c3c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/adfea61665385428b9c9aced9442dba65464c3c8", "html_url": "https://github.com/rust-lang/rust/commit/adfea61665385428b9c9aced9442dba65464c3c8"}], "stats": {"total": 188, "additions": 101, "deletions": 87}, "files": [{"sha": "bef37c57981e20fd5aba5b343800176e160ffd29", "filename": "miri/fn_call.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/23d351d6d496d61f859da9676a4c72c0be9643ea/miri%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23d351d6d496d61f859da9676a4c72c0be9643ea/miri%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Ffn_call.rs?ref=23d351d6d496d61f859da9676a4c72c0be9643ea", "patch": "@@ -12,9 +12,10 @@ use rustc_miri::interpret::*;\n use super::{\n     TlsKey,\n     EvalContext,\n-    MemoryExt,\n };\n \n+use tls::MemoryExt;\n+\n use super::memory::Kind;\n \n pub trait EvalContextExt<'tcx> {"}, {"sha": "ab63ff7f29e616fd6fae51885adfac53b15ea2a1", "filename": "miri/lib.rs", "status": "modified", "additions": 5, "deletions": 86, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/23d351d6d496d61f859da9676a4c72c0be9643ea/miri%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23d351d6d496d61f859da9676a4c72c0be9643ea/miri%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Flib.rs?ref=23d351d6d496d61f859da9676a4c72c0be9643ea", "patch": "@@ -33,10 +33,12 @@ mod operator;\n mod intrinsic;\n mod helpers;\n mod memory;\n+mod tls;\n \n use fn_call::EvalContextExt as MissingFnsEvalContextExt;\n use operator::EvalContextExt as OperatorEvalContextExt;\n use intrinsic::EvalContextExt as IntrinsicEvalContextExt;\n+use tls::MemoryExt as TlsMemoryExt;\n \n pub fn eval_main<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -165,7 +167,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, Evaluator> {\n         // FIXME: replace loop by some structure that works with stepping\n         while let Some((instance, ptr, key)) = dtor {\n             trace!(\"Running TLS dtor {:?} on {:?}\", instance, ptr);\n-            // TODO: Potentially, this has to support all the other possible instances? See eval_fn_call in terminator/mod.rs\n+            // TODO: Potentially, this has to support all the other possible instances?\n+            // See eval_fn_call in interpret/terminator/mod.rs\n             let mir = self.load_mir(instance.def)?;\n             self.push_stack_frame(\n                 instance,\n@@ -191,91 +194,6 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, Evaluator> {\n     }\n }\n \n-trait MemoryExt<'tcx> {\n-    fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>) -> TlsKey;\n-    fn delete_tls_key(&mut self, key: TlsKey) -> EvalResult<'tcx>;\n-    fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Pointer>;\n-    fn store_tls(&mut self, key: TlsKey, new_data: Pointer) -> EvalResult<'tcx>;\n-    fn fetch_tls_dtor(&mut self, key: Option<TlsKey>) -> EvalResult<'tcx, Option<(ty::Instance<'tcx>, Pointer, TlsKey)>>;\n-}\n-\n-impl<'a, 'tcx: 'a> MemoryExt<'tcx> for Memory<'a, 'tcx, Evaluator> {\n-    fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>) -> TlsKey {\n-        let new_key = self.data.next_thread_local;\n-        self.data.next_thread_local += 1;\n-        self.data.thread_local.insert(new_key, TlsEntry { data: Pointer::null(), dtor });\n-        trace!(\"New TLS key allocated: {} with dtor {:?}\", new_key, dtor);\n-        return new_key;\n-    }\n-\n-    fn delete_tls_key(&mut self, key: TlsKey) -> EvalResult<'tcx> {\n-        return match self.data.thread_local.remove(&key) {\n-            Some(_) => {\n-                trace!(\"TLS key {} removed\", key);\n-                Ok(())\n-            },\n-            None => Err(EvalError::TlsOutOfBounds)\n-        }\n-    }\n-\n-    fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Pointer> {\n-        return match self.data.thread_local.get(&key) {\n-            Some(&TlsEntry { data, .. }) => {\n-                trace!(\"TLS key {} loaded: {:?}\", key, data);\n-                Ok(data)\n-            },\n-            None => Err(EvalError::TlsOutOfBounds)\n-        }\n-    }\n-\n-    fn store_tls(&mut self, key: TlsKey, new_data: Pointer) -> EvalResult<'tcx> {\n-        return match self.data.thread_local.get_mut(&key) {\n-            Some(&mut TlsEntry { ref mut data, .. }) => {\n-                trace!(\"TLS key {} stored: {:?}\", key, new_data);\n-                *data = new_data;\n-                Ok(())\n-            },\n-            None => Err(EvalError::TlsOutOfBounds)\n-        }\n-    }\n-    \n-    /// Returns a dtor, its argument and its index, if one is supposed to run\n-    ///\n-    /// An optional destructor function may be associated with each key value.\n-    /// At thread exit, if a key value has a non-NULL destructor pointer,\n-    /// and the thread has a non-NULL value associated with that key,\n-    /// the value of the key is set to NULL, and then the function pointed\n-    /// to is called with the previously associated value as its sole argument.\n-    /// The order of destructor calls is unspecified if more than one destructor\n-    /// exists for a thread when it exits.\n-    ///\n-    /// If, after all the destructors have been called for all non-NULL values\n-    /// with associated destructors, there are still some non-NULL values with\n-    /// associated destructors, then the process is repeated.\n-    /// If, after at least {PTHREAD_DESTRUCTOR_ITERATIONS} iterations of destructor\n-    /// calls for outstanding non-NULL values, there are still some non-NULL values\n-    /// with associated destructors, implementations may stop calling destructors,\n-    /// or they may continue calling destructors until no non-NULL values with\n-    /// associated destructors exist, even though this might result in an infinite loop.\n-    fn fetch_tls_dtor(&mut self, key: Option<TlsKey>) -> EvalResult<'tcx, Option<(ty::Instance<'tcx>, Pointer, TlsKey)>> {\n-        use std::collections::Bound::*;\n-        let start = match key {\n-            Some(key) => Excluded(key),\n-            None => Unbounded,\n-        };\n-        for (&key, &mut TlsEntry { ref mut data, dtor }) in self.data.thread_local.range_mut((start, Unbounded)) {\n-            if !data.is_null()? {\n-                if let Some(dtor) = dtor {\n-                    let ret = Some((dtor, *data, key));\n-                    *data = Pointer::null();\n-                    return Ok(ret);\n-                }\n-            }\n-        }\n-        return Ok(None);\n-    }\n-}\n-\n impl<'tcx> Machine<'tcx> for Evaluator {\n     type Data = EvaluatorData;\n     type MemoryData = MemoryData<'tcx>;\n@@ -329,6 +247,7 @@ impl<'tcx> Machine<'tcx> for Evaluator {\n         ecx: &mut EvalContext<'a, 'tcx, Self>,\n         ty: ty::Ty<'tcx>,\n     ) -> EvalResult<'tcx, PrimVal> {\n+        // FIXME: call the `exchange_malloc` lang item if available\n         let size = ecx.type_size(ty)?.expect(\"box only works with sized types\");\n         let align = ecx.type_align(ty)?;\n         if size == 0 {"}, {"sha": "035cd7f0aaf8d38c9f68090d76488aae9e165d57", "filename": "miri/tls.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/23d351d6d496d61f859da9676a4c72c0be9643ea/miri%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23d351d6d496d61f859da9676a4c72c0be9643ea/miri%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Ftls.rs?ref=23d351d6d496d61f859da9676a4c72c0be9643ea", "patch": "@@ -0,0 +1,94 @@\n+use rustc::ty;\n+\n+use super::{\n+    TlsKey, TlsEntry,\n+    EvalResult, EvalError,\n+    Pointer,\n+    Memory,\n+    Evaluator,\n+};\n+\n+pub trait MemoryExt<'tcx> {\n+    fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>) -> TlsKey;\n+    fn delete_tls_key(&mut self, key: TlsKey) -> EvalResult<'tcx>;\n+    fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Pointer>;\n+    fn store_tls(&mut self, key: TlsKey, new_data: Pointer) -> EvalResult<'tcx>;\n+    fn fetch_tls_dtor(&mut self, key: Option<TlsKey>) -> EvalResult<'tcx, Option<(ty::Instance<'tcx>, Pointer, TlsKey)>>;\n+}\n+\n+impl<'a, 'tcx: 'a> MemoryExt<'tcx> for Memory<'a, 'tcx, Evaluator> {\n+    fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>) -> TlsKey {\n+        let new_key = self.data.next_thread_local;\n+        self.data.next_thread_local += 1;\n+        self.data.thread_local.insert(new_key, TlsEntry { data: Pointer::null(), dtor });\n+        trace!(\"New TLS key allocated: {} with dtor {:?}\", new_key, dtor);\n+        return new_key;\n+    }\n+\n+    fn delete_tls_key(&mut self, key: TlsKey) -> EvalResult<'tcx> {\n+        return match self.data.thread_local.remove(&key) {\n+            Some(_) => {\n+                trace!(\"TLS key {} removed\", key);\n+                Ok(())\n+            },\n+            None => Err(EvalError::TlsOutOfBounds)\n+        }\n+    }\n+\n+    fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Pointer> {\n+        return match self.data.thread_local.get(&key) {\n+            Some(&TlsEntry { data, .. }) => {\n+                trace!(\"TLS key {} loaded: {:?}\", key, data);\n+                Ok(data)\n+            },\n+            None => Err(EvalError::TlsOutOfBounds)\n+        }\n+    }\n+\n+    fn store_tls(&mut self, key: TlsKey, new_data: Pointer) -> EvalResult<'tcx> {\n+        return match self.data.thread_local.get_mut(&key) {\n+            Some(&mut TlsEntry { ref mut data, .. }) => {\n+                trace!(\"TLS key {} stored: {:?}\", key, new_data);\n+                *data = new_data;\n+                Ok(())\n+            },\n+            None => Err(EvalError::TlsOutOfBounds)\n+        }\n+    }\n+    \n+    /// Returns a dtor, its argument and its index, if one is supposed to run\n+    ///\n+    /// An optional destructor function may be associated with each key value.\n+    /// At thread exit, if a key value has a non-NULL destructor pointer,\n+    /// and the thread has a non-NULL value associated with that key,\n+    /// the value of the key is set to NULL, and then the function pointed\n+    /// to is called with the previously associated value as its sole argument.\n+    /// The order of destructor calls is unspecified if more than one destructor\n+    /// exists for a thread when it exits.\n+    ///\n+    /// If, after all the destructors have been called for all non-NULL values\n+    /// with associated destructors, there are still some non-NULL values with\n+    /// associated destructors, then the process is repeated.\n+    /// If, after at least {PTHREAD_DESTRUCTOR_ITERATIONS} iterations of destructor\n+    /// calls for outstanding non-NULL values, there are still some non-NULL values\n+    /// with associated destructors, implementations may stop calling destructors,\n+    /// or they may continue calling destructors until no non-NULL values with\n+    /// associated destructors exist, even though this might result in an infinite loop.\n+    fn fetch_tls_dtor(&mut self, key: Option<TlsKey>) -> EvalResult<'tcx, Option<(ty::Instance<'tcx>, Pointer, TlsKey)>> {\n+        use std::collections::Bound::*;\n+        let start = match key {\n+            Some(key) => Excluded(key),\n+            None => Unbounded,\n+        };\n+        for (&key, &mut TlsEntry { ref mut data, dtor }) in self.data.thread_local.range_mut((start, Unbounded)) {\n+            if !data.is_null()? {\n+                if let Some(dtor) = dtor {\n+                    let ret = Some((dtor, *data, key));\n+                    *data = Pointer::null();\n+                    return Ok(ret);\n+                }\n+            }\n+        }\n+        return Ok(None);\n+    }\n+}"}]}