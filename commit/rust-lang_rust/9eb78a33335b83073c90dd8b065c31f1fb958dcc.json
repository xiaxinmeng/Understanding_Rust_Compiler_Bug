{"sha": "9eb78a33335b83073c90dd8b065c31f1fb958dcc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllYjc4YTMzMzM1YjgzMDczYzkwZGQ4YjA2NWMzMWYxZmI5NThkY2M=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-02-22T03:20:50Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-02-23T00:15:48Z"}, "message": "Fallout", "tree": {"sha": "e97bddd58194324584b1f076c1a600b9c0def510", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e97bddd58194324584b1f076c1a600b9c0def510"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9eb78a33335b83073c90dd8b065c31f1fb958dcc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9eb78a33335b83073c90dd8b065c31f1fb958dcc", "html_url": "https://github.com/rust-lang/rust/commit/9eb78a33335b83073c90dd8b065c31f1fb958dcc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9eb78a33335b83073c90dd8b065c31f1fb958dcc/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba1202f6b3dfc634ed651e1b1f0994b613f7a85c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba1202f6b3dfc634ed651e1b1f0994b613f7a85c", "html_url": "https://github.com/rust-lang/rust/commit/ba1202f6b3dfc634ed651e1b1f0994b613f7a85c"}], "stats": {"total": 837, "additions": 431, "deletions": 406}, "files": [{"sha": "207d48eeb66b5c6d04331642e39e3482e6631400", "filename": "build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9eb78a33335b83073c90dd8b065c31f1fb958dcc/build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb78a33335b83073c90dd8b065c31f1fb958dcc/build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build.rs?ref=9eb78a33335b83073c90dd8b065c31f1fb958dcc", "patch": "@@ -16,11 +16,11 @@ fn main() {\n     writeln!(f,\n              \"const COMMIT_HASH: Option<&'static str> = {:?};\",\n              git_head_sha1())\n-        .unwrap();\n+            .unwrap();\n     writeln!(f,\n              \"const WORKTREE_CLEAN: Option<bool> = {:?};\",\n              git_tree_is_clean())\n-        .unwrap();\n+            .unwrap();\n \n     // cargo:rerun-if-changed requires one entry per individual file.\n     for entry in WalkDir::new(\"src\") {"}, {"sha": "d64a51ac7d942ccb87cf7881e894e294ba4e203e", "filename": "src/chains.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9eb78a33335b83073c90dd8b065c31f1fb958dcc/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb78a33335b83073c90dd8b065c31f1fb958dcc/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=9eb78a33335b83073c90dd8b065c31f1fb958dcc", "patch": "@@ -119,20 +119,25 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         // brace.\n         (parent_shape, false)\n     } else if parent_rewrite.contains('\\n') {\n-        (chain_indent(context, parent_shape.block_indent(context.config.tab_spaces)), false)\n+        (chain_indent(context,\n+                      parent_shape.block_indent(context.config.tab_spaces)),\n+         false)\n     } else {\n         (chain_indent_newline(context, shape.add_offset(parent_rewrite.len())), false)\n     };\n \n-    let max_width = try_opt!((shape.width + shape.indent.width() + shape.offset).checked_sub(nested_shape.indent.width() + nested_shape.offset));\n+    let max_width = try_opt!((shape.width + shape.indent.width() + shape.offset)\n+                                 .checked_sub(nested_shape.indent.width() +\n+                                              nested_shape.offset));\n     // The alignement in the shape is only used if we start the item on a new\n     // line, so we don't need to preserve the offset.\n     let child_shape = Shape { width: max_width, ..nested_shape };\n     debug!(\"child_shape {:?}\", child_shape);\n-    let mut rewrites = try_opt!(subexpr_list.iter()\n-        .rev()\n-        .map(|e| rewrite_chain_subexpr(e, total_span, context, child_shape))\n-        .collect::<Option<Vec<_>>>());\n+    let mut rewrites =\n+        try_opt!(subexpr_list.iter()\n+                     .rev()\n+                     .map(|e| rewrite_chain_subexpr(e, total_span, context, child_shape))\n+                     .collect::<Option<Vec<_>>>());\n \n     // Total of all items excluding the last.\n     let almost_total = rewrites[..rewrites.len() - 1]\n@@ -199,10 +204,10 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n // True if the chain is only `?`s.\n fn chain_only_try(exprs: &[ast::Expr]) -> bool {\n     exprs.iter().all(|e| if let ast::ExprKind::Try(_) = e.node {\n-        true\n-    } else {\n-        false\n-    })\n+                         true\n+                     } else {\n+                         false\n+                     })\n }\n \n pub fn rewrite_try(expr: &ast::Expr,\n@@ -400,8 +405,8 @@ fn rewrite_method_call(method_name: ast::Ident,\n         (args[0].span.hi, String::new())\n     } else {\n         let type_list: Vec<_> = try_opt!(types.iter()\n-            .map(|ty| ty.rewrite(context, shape))\n-            .collect());\n+                                             .map(|ty| ty.rewrite(context, shape))\n+                                             .collect());\n \n         let type_str = if context.config.spaces_within_angle_brackets && type_list.len() > 0 {\n             format!(\"::< {} >\", type_list.join(\", \"))"}, {"sha": "3f85dd27ac9d4db9c8729db5410f7510e4b654cf", "filename": "src/comment.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9eb78a33335b83073c90dd8b065c31f1fb958dcc/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb78a33335b83073c90dd8b065c31f1fb958dcc/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=9eb78a33335b83073c90dd8b065c31f1fb958dcc", "patch": "@@ -110,10 +110,10 @@ pub fn rewrite_comment(orig: &str,\n         })\n         .map(left_trim_comment_line)\n         .map(|line| if orig.starts_with(\"/*\") && line_breaks == 0 {\n-            line.trim_left()\n-        } else {\n-            line\n-        });\n+                 line.trim_left()\n+             } else {\n+                 line\n+             });\n \n     let mut result = opener.to_owned();\n     for line in lines {\n@@ -771,9 +771,9 @@ mod test {\n     fn uncommented(text: &str) -> String {\n         CharClasses::new(text.chars())\n             .filter_map(|(s, c)| match s {\n-                FullCodeCharKind::Normal => Some(c),\n-                _ => None,\n-            })\n+                            FullCodeCharKind::Normal => Some(c),\n+                            _ => None,\n+                        })\n             .collect()\n     }\n "}, {"sha": "d54a724b5e99716c6b36eaeb25c7253d0d92203e", "filename": "src/expr.rs", "status": "modified", "additions": 147, "deletions": 147, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/9eb78a33335b83073c90dd8b065c31f1fb958dcc/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb78a33335b83073c90dd8b065c31f1fb958dcc/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=9eb78a33335b83073c90dd8b065c31f1fb958dcc", "patch": "@@ -115,7 +115,7 @@ fn format_expr(expr: &ast::Expr,\n                                 expr_type == ExprType::SubExpression,\n                                 false,\n                                 expr.span)\n-                .rewrite(context, shape)\n+                    .rewrite(context, shape)\n         }\n         ast::ExprKind::IfLet(ref pat, ref cond, ref if_block, ref else_block) => {\n             ControlFlow::new_if(cond,\n@@ -125,7 +125,7 @@ fn format_expr(expr: &ast::Expr,\n                                 expr_type == ExprType::SubExpression,\n                                 false,\n                                 expr.span)\n-                .rewrite(context, shape)\n+                    .rewrite(context, shape)\n         }\n         ast::ExprKind::Match(ref cond, ref arms) => {\n             rewrite_match(context, cond, arms, shape, expr.span)\n@@ -170,8 +170,9 @@ fn format_expr(expr: &ast::Expr,\n         ast::ExprKind::Mac(ref mac) => {\n             // Failure to rewrite a marco should not imply failure to\n             // rewrite the expression.\n-            rewrite_macro(mac, None, context, shape, MacroPosition::Expression)\n-                .or_else(|| wrap_str(context.snippet(expr.span), context.config.max_width, shape))\n+            rewrite_macro(mac, None, context, shape, MacroPosition::Expression).or_else(|| {\n+                wrap_str(context.snippet(expr.span), context.config.max_width, shape)\n+            })\n         }\n         ast::ExprKind::Ret(None) => wrap_str(\"return\".to_owned(), context.config.max_width, shape),\n         ast::ExprKind::Ret(Some(ref expr)) => {\n@@ -300,9 +301,11 @@ pub fn rewrite_pair<LHS, RHS>(lhs: &LHS,\n     // Re-evaluate the rhs because we have more space now:\n     let infix = infix.trim_right();\n     let lhs_budget = try_opt!(context.config\n-        .max_width\n-        .checked_sub(shape.used_width() + prefix.len() + infix.len()));\n-    let rhs_shape = try_opt!(shape.sub_width(suffix.len() + prefix.len())).visual_indent(prefix.len());\n+                                  .max_width\n+                                  .checked_sub(shape.used_width() + prefix.len() +\n+                                               infix.len()));\n+    let rhs_shape = try_opt!(shape.sub_width(suffix.len() + prefix.len()))\n+        .visual_indent(prefix.len());\n \n     let rhs_result = try_opt!(rhs.rewrite(context, rhs_shape));\n     let lhs_result = try_opt!(lhs.rewrite(context, Shape { width: lhs_budget, ..shape }));\n@@ -328,20 +331,20 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n         1 // \"[\"\n     };\n     let nested_shape = try_opt!(shape.visual_indent(bracket_size).sub_width(bracket_size * 2));\n-    let items =\n-        itemize_list(context.codemap,\n-                     expr_iter,\n-                     \"]\",\n-                     |item| item.span.lo,\n-                     |item| item.span.hi,\n-                     |item| item.rewrite(context, nested_shape),\n-                     span.lo,\n-                     span.hi)\n+    let items = itemize_list(context.codemap,\n+                             expr_iter,\n+                             \"]\",\n+                             |item| item.span.lo,\n+                             |item| item.span.hi,\n+                             |item| item.rewrite(context, nested_shape),\n+                             span.lo,\n+                             span.hi)\n             .collect::<Vec<_>>();\n \n     let has_long_item = try_opt!(items.iter()\n-        .map(|li| li.item.as_ref().map(|s| s.len() > 10))\n-        .fold(Some(false), |acc, x| acc.and_then(|y| x.map(|x| x || y))));\n+                                     .map(|li| li.item.as_ref().map(|s| s.len() > 10))\n+                                     .fold(Some(false),\n+                                           |acc, x| acc.and_then(|y| x.map(|x| x || y))));\n \n     let tactic = if has_long_item || items.iter().any(ListItem::is_multiline) {\n         definitive_tactic(&items, ListTactic::HorizontalVertical, nested_shape.width)\n@@ -360,10 +363,10 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n     let list_str = try_opt!(write_list(&items, &fmt));\n \n     Some(if context.config.spaces_within_square_brackets && list_str.len() > 0 {\n-        format!(\"[ {} ]\", list_str)\n-    } else {\n-        format!(\"[{}]\", list_str)\n-    })\n+             format!(\"[ {} ]\", list_str)\n+         } else {\n+             format!(\"[{}]\", list_str)\n+         })\n }\n \n // This functions is pretty messy because of the rules around closures and blocks:\n@@ -396,15 +399,14 @@ fn rewrite_closure(capture: ast::CaptureBy,\n     let arg_shape = try_opt!(nested_shape.shrink_left(1)).visual_indent(0);\n     let ret_str = try_opt!(fn_decl.output.rewrite(context, arg_shape));\n \n-    let arg_items =\n-        itemize_list(context.codemap,\n-                     fn_decl.inputs.iter(),\n-                     \"|\",\n-                     |arg| span_lo_for_arg(arg),\n-                     |arg| span_hi_for_arg(arg),\n-                     |arg| arg.rewrite(context, arg_shape),\n-                     context.codemap.span_after(span, \"|\"),\n-                     body.span.lo);\n+    let arg_items = itemize_list(context.codemap,\n+                                 fn_decl.inputs.iter(),\n+                                 \"|\",\n+                                 |arg| span_lo_for_arg(arg),\n+                                 |arg| span_hi_for_arg(arg),\n+                                 |arg| arg.rewrite(context, arg_shape),\n+                                 context.codemap.span_after(span, \"|\"),\n+                                 body.span.lo);\n     let item_vec = arg_items.collect::<Vec<_>>();\n     // 1 = space between arguments and return type.\n     let horizontal_budget = nested_shape.width.checked_sub(ret_str.len() + 1).unwrap_or(0);\n@@ -453,10 +455,7 @@ fn rewrite_closure(capture: ast::CaptureBy,\n         if ret_str.is_empty() && !needs_block {\n             // lock.stmts.len() == 1\n             if let Some(ref expr) = stmt_expr(&block.stmts[0]) {\n-                if let Some(rw) = rewrite_closure_expr(expr,\n-                                                       &prefix,\n-                                                       context,\n-                                                       body_shape) {\n+                if let Some(rw) = rewrite_closure_expr(expr, &prefix, context, body_shape) {\n                     return Some(rw);\n                 }\n             }\n@@ -466,8 +465,7 @@ fn rewrite_closure(capture: ast::CaptureBy,\n             // We need braces, but we might still prefer a one-liner.\n             let stmt = &block.stmts[0];\n             // 4 = braces and spaces.\n-            let mut rewrite = stmt.rewrite(context,\n-                                           try_opt!(body_shape.sub_width(4)));\n+            let mut rewrite = stmt.rewrite(context, try_opt!(body_shape.sub_width(4)));\n \n             // Checks if rewrite succeeded and fits on a single line.\n             rewrite = and_one_line(rewrite);\n@@ -482,10 +480,7 @@ fn rewrite_closure(capture: ast::CaptureBy,\n         return rewrite_closure_block(&block, prefix, context, body_shape);\n     }\n \n-    if let Some(rw) = rewrite_closure_expr(body,\n-                                           &prefix,\n-                                           context,\n-                                           body_shape) {\n+    if let Some(rw) = rewrite_closure_expr(body, &prefix, context, body_shape) {\n         return Some(rw);\n     }\n \n@@ -546,10 +541,10 @@ fn nop_block_collapse(block_str: Option<String>, budget: usize) -> Option<String\n     block_str.map(|block_str| if block_str.starts_with('{') && budget >= 2 &&\n                                  (block_str[1..].find(|c: char| !c.is_whitespace()).unwrap() ==\n                                   block_str.len() - 2) {\n-        \"{}\".to_owned()\n-    } else {\n-        block_str.to_owned()\n-    })\n+                      \"{}\".to_owned()\n+                  } else {\n+                      block_str.to_owned()\n+                  })\n }\n \n impl Rewrite for ast::Block {\n@@ -599,9 +594,10 @@ impl Rewrite for ast::Block {\n                 };\n \n                 if is_simple_block(self, context.codemap) && prefix.len() < shape.width {\n-                    let expr_str = self.stmts[0].rewrite(context,\n-                                                         Shape::legacy(shape.width - prefix.len(),\n-                                                                       shape.indent));\n+                    let expr_str =\n+                        self.stmts[0].rewrite(context,\n+                                              Shape::legacy(shape.width - prefix.len(),\n+                                                            shape.indent));\n                     let expr_str = try_opt!(expr_str);\n                     let result = format!(\"{}{{ {} }}\", prefix, expr_str);\n                     if result.len() <= shape.width && !result.contains('\\n') {\n@@ -643,7 +639,7 @@ impl Rewrite for ast::Stmt {\n                             },\n                             context,\n                             try_opt!(shape.sub_width(suffix.len())))\n-                    .map(|s| s + suffix)\n+                        .map(|s| s + suffix)\n             }\n             ast::StmtKind::Mac(..) |\n             ast::StmtKind::Item(..) => None,\n@@ -782,8 +778,8 @@ impl<'a> ControlFlow<'a> {\n \n             let new_width = try_opt!(new_width.checked_sub(if_str.len()));\n             let else_expr = &else_node.stmts[0];\n-            let else_str =\n-                try_opt!(else_expr.rewrite(context, Shape::legacy(new_width, Indent::empty())));\n+            let else_str = try_opt!(else_expr.rewrite(context,\n+                                                      Shape::legacy(new_width, Indent::empty())));\n \n             if if_str.contains('\\n') || else_str.contains('\\n') {\n                 return None;\n@@ -877,17 +873,18 @@ impl<'a> Rewrite for ControlFlow<'a> {\n         let between_kwd_cond =\n             mk_sp(context.codemap.span_after(self.span, self.keyword.trim()),\n                   self.pat.map_or(cond_span.lo, |p| if self.matcher.is_empty() {\n-                      p.span.lo\n-                  } else {\n-                      context.codemap.span_before(self.span, self.matcher.trim())\n-                  }));\n+                p.span.lo\n+            } else {\n+                context.codemap.span_before(self.span, self.matcher.trim())\n+            }));\n \n         let between_kwd_cond_comment = extract_comment(between_kwd_cond, context, shape);\n \n         let after_cond_comment =\n             extract_comment(mk_sp(cond_span.hi, self.block.span.lo), context, shape);\n \n-        let alt_block_sep = String::from(\"\\n\") + &shape.indent.block_only().to_string(context.config);\n+        let alt_block_sep = String::from(\"\\n\") +\n+                            &shape.indent.block_only().to_string(context.config);\n         let block_sep = if self.cond.is_none() && between_kwd_cond_comment.is_some() {\n             \"\"\n         } else if context.config.control_brace_style ==\n@@ -897,15 +894,15 @@ impl<'a> Rewrite for ControlFlow<'a> {\n             \" \"\n         };\n \n-        let mut result = format!(\"{}{}{}{}{}{}\",\n-                                 label_string,\n-                                 self.keyword,\n-                                 between_kwd_cond_comment.as_ref()\n-                                     .map_or(if pat_expr_string.is_empty() { \"\" } else { \" \" },\n-                                             |s| &**s),\n-                                 pat_expr_string,\n-                                 after_cond_comment.as_ref().map_or(block_sep, |s| &**s),\n-                                 block_str);\n+        let mut result =\n+            format!(\"{}{}{}{}{}{}\",\n+                    label_string,\n+                    self.keyword,\n+                    between_kwd_cond_comment.as_ref()\n+                        .map_or(if pat_expr_string.is_empty() { \"\" } else { \" \" }, |s| &**s),\n+                    pat_expr_string,\n+                    after_cond_comment.as_ref().map_or(block_sep, |s| &**s),\n+                    block_str);\n \n         if let Some(else_block) = self.else_block {\n             // Since this is an else block, we should not indent for the assignment preceding\n@@ -925,7 +922,7 @@ impl<'a> Rewrite for ControlFlow<'a> {\n                                         false,\n                                         true,\n                                         mk_sp(else_block.span.lo, self.span.hi))\n-                        .rewrite(context, shape.visual_indent(0))\n+                            .rewrite(context, shape.visual_indent(0))\n                 }\n                 ast::ExprKind::If(ref cond, ref if_block, ref next_else_block) => {\n                     ControlFlow::new_if(cond,\n@@ -935,7 +932,7 @@ impl<'a> Rewrite for ControlFlow<'a> {\n                                         false,\n                                         true,\n                                         mk_sp(else_block.span.lo, self.span.hi))\n-                        .rewrite(context, shape.visual_indent(0))\n+                            .rewrite(context, shape.visual_indent(0))\n                 }\n                 _ => {\n                     last_in_chain = true;\n@@ -953,10 +950,10 @@ impl<'a> Rewrite for ControlFlow<'a> {\n             let between_kwd_else_block_comment =\n                 extract_comment(between_kwd_else_block, context, shape);\n \n-            let after_else = mk_sp(context.codemap\n-                                       .span_after(mk_sp(self.block.span.hi, else_block.span.lo),\n-                                                   \"else\"),\n-                                   else_block.span.lo);\n+            let after_else =\n+                mk_sp(context.codemap\n+                          .span_after(mk_sp(self.block.span.hi, else_block.span.lo), \"else\"),\n+                      else_block.span.lo);\n             let after_else_comment = extract_comment(after_else, context, shape);\n \n             let between_sep = match context.config.control_brace_style {\n@@ -973,7 +970,7 @@ impl<'a> Rewrite for ControlFlow<'a> {\n                             between_kwd_else_block_comment.as_ref()\n                                 .map_or(between_sep, |s| &**s),\n                             after_else_comment.as_ref().map_or(after_sep, |s| &**s))\n-                .ok());\n+                             .ok());\n             result.push_str(&try_opt!(rewrite));\n         }\n \n@@ -1108,16 +1105,17 @@ fn rewrite_match(context: &RewriteContext,\n         } else {\n             context.snippet(mk_sp(arm_end_pos(&arms[i - 1]), arm_start_pos(arm)))\n         };\n-        let comment = try_opt!(rewrite_match_arm_comment(context,\n-                                                         &missed_str,\n-                                                         arm_shape,\n-                                                         &arm_indent_str));\n+        let comment =\n+            try_opt!(rewrite_match_arm_comment(context, &missed_str, arm_shape, &arm_indent_str));\n         result.push_str(&comment);\n         result.push('\\n');\n         result.push_str(&arm_indent_str);\n \n         let arm_str = arm.rewrite(&context,\n-                                  Shape { width: context.config.max_width - arm_shape.indent.width(), .. arm_shape });\n+                                  Shape {\n+                                      width: context.config.max_width - arm_shape.indent.width(),\n+                                      ..arm_shape\n+                                  });\n         if let Some(ref arm_str) = arm_str {\n             result.push_str(arm_str);\n         } else {\n@@ -1130,10 +1128,8 @@ fn rewrite_match(context: &RewriteContext,\n     // BytePos(1) = closing match brace.\n     let last_span = mk_sp(arm_end_pos(&arms[arms.len() - 1]), span.hi - BytePos(1));\n     let last_comment = context.snippet(last_span);\n-    let comment = try_opt!(rewrite_match_arm_comment(context,\n-                                                     &last_comment,\n-                                                     arm_shape,\n-                                                     &arm_indent_str));\n+    let comment =\n+        try_opt!(rewrite_match_arm_comment(context, &last_comment, arm_shape, &arm_indent_str));\n     result.push_str(&comment);\n     result.push('\\n');\n     result.push_str(&shape.indent.to_string(context.config));\n@@ -1203,8 +1199,8 @@ impl Rewrite for ast::Arm {\n         let pat_shape = try_opt!(shape.sub_width(5));\n \n         let pat_strs = try_opt!(pats.iter()\n-            .map(|p| p.rewrite(context, pat_shape))\n-            .collect::<Option<Vec<_>>>());\n+                                    .map(|p| p.rewrite(context, pat_shape))\n+                                    .collect::<Option<Vec<_>>>());\n \n         let all_simple = pat_strs.iter().all(|p| pat_is_simple(p));\n         let items: Vec<_> = pat_strs.into_iter().map(ListItem::from_str).collect();\n@@ -1251,17 +1247,18 @@ impl Rewrite for ast::Arm {\n         };\n \n         let comma = arm_comma(&context.config, self, body);\n-        let alt_block_sep = String::from(\"\\n\") + &shape.indent.block_only().to_string(context.config);\n+        let alt_block_sep = String::from(\"\\n\") +\n+                            &shape.indent.block_only().to_string(context.config);\n \n         // Let's try and get the arm body on the same line as the condition.\n         // 4 = ` => `.len()\n         if shape.width > line_start + comma.len() + 4 {\n-            let arm_shape = shape.shrink_left(line_start + 4).unwrap().sub_width(comma.len()).unwrap().block();\n+            let arm_shape =\n+                shape.shrink_left(line_start + 4).unwrap().sub_width(comma.len()).unwrap().block();\n             // TODO\n             // let offset = Indent::new(shape.indent.block_indent,\n             //                          line_start + 4 - shape.indent.block_indent);\n-            let rewrite = nop_block_collapse(body.rewrite(context, arm_shape),\n-                                             arm_shape.width);\n+            let rewrite = nop_block_collapse(body.rewrite(context, arm_shape), arm_shape.width);\n             let is_block = if let ast::ExprKind::Block(..) = body.node {\n                 true\n             } else {\n@@ -1292,7 +1289,8 @@ impl Rewrite for ast::Arm {\n         // TODO\n         // let body_budget = try_opt!(shape.width.checked_sub(context.config.tab_spaces));\n         // let indent = shape.indent.block_only().block_indent(context.config);\n-        let body_shape = try_opt!(shape.sub_width(context.config.tab_spaces)).block_indent(context.config.tab_spaces);\n+        let body_shape = try_opt!(shape.sub_width(context.config.tab_spaces))\n+            .block_indent(context.config.tab_spaces);\n         let next_line_body = try_opt!(nop_block_collapse(body.rewrite(context, body_shape),\n                                                          body_shape.width));\n         let indent_str = shape.indent.block_indent(context.config).to_string(context.config);\n@@ -1341,9 +1339,10 @@ fn rewrite_guard(context: &RewriteContext,\n         // 4 = ` if `, 5 = ` => {`\n         let overhead = pattern_width + 4 + 5;\n         if overhead < shape.width {\n-            let cond_str = guard.rewrite(context,\n-                                         Shape::legacy(shape.width - overhead,\n-                                                       shape.indent + pattern_width + 4));\n+            let cond_str =\n+                guard.rewrite(context,\n+                              Shape::legacy(shape.width - overhead,\n+                                            shape.indent + pattern_width + 4));\n             if let Some(cond_str) = cond_str {\n                 return Some(format!(\" if {}\", cond_str));\n             }\n@@ -1389,7 +1388,8 @@ fn rewrite_pat_expr(context: &RewriteContext,\n             } else {\n                 format!(\"{} \", matcher)\n             };\n-            let pat_shape = try_opt!(try_opt!(shape.shrink_left(matcher.len())).sub_width(connector.len()));\n+            let pat_shape = try_opt!(try_opt!(shape.shrink_left(matcher.len()))\n+                                         .sub_width(connector.len()));\n             let pat_string = try_opt!(pat.rewrite(context, pat_shape));\n             format!(\"{}{}{}\", matcher, pat_string, connector)\n         }\n@@ -1403,12 +1403,14 @@ fn rewrite_pat_expr(context: &RewriteContext,\n     if shape.width > extra_offset + 1 {\n         let spacer = if pat.is_some() { \" \" } else { \"\" };\n \n-        let expr_shape = try_opt!(shape.sub_width(extra_offset + spacer.len())).add_offset(extra_offset + spacer.len());\n+        let expr_shape = try_opt!(shape.sub_width(extra_offset + spacer.len()))\n+            .add_offset(extra_offset + spacer.len());\n         let expr_rewrite = expr.rewrite(context, expr_shape);\n \n         if let Some(expr_string) = expr_rewrite {\n             let pat_simple = pat.and_then(|p| {\n-                    p.rewrite(context, Shape::legacy(context.config.max_width, Indent::empty()))\n+                    p.rewrite(context,\n+                              Shape::legacy(context.config.max_width, Indent::empty()))\n                 })\n                 .map(|s| pat_is_simple(&s));\n \n@@ -1540,15 +1542,16 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n     let nested_shape = shape.visual_indent(used_width + 1);\n     let arg_count = args.len();\n \n-    let items =\n-        itemize_list(context.codemap,\n-                     args.iter(),\n-                     \")\",\n-                     |item| item.span.lo,\n-                     |item| item.span.hi,\n-                     |item| item.rewrite(context, Shape { width: remaining_width, ..nested_shape }),\n-                     span.lo,\n-                     span.hi);\n+    let items = itemize_list(context.codemap,\n+                             args.iter(),\n+                             \")\",\n+                             |item| item.span.lo,\n+                             |item| item.span.hi,\n+                             |item| {\n+        item.rewrite(context, Shape { width: remaining_width, ..nested_shape })\n+    },\n+                             span.lo,\n+                             span.hi);\n     let mut item_vec: Vec<_> = items.collect();\n \n     // Try letting the last argument overflow to the next line with block\n@@ -1584,7 +1587,7 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n \n     let tactic = definitive_tactic(&item_vec,\n                                    ListTactic::LimitedHorizontalVertical(context.config\n-                                       .fn_call_width),\n+                                                                             .fn_call_width),\n                                    remaining_width);\n \n     // Replace the stub with the full overflowing last argument if the rewrite\n@@ -1614,10 +1617,10 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n     };\n \n     Ok(if context.config.spaces_within_parens && list_str.len() > 0 {\n-        format!(\"{}( {} )\", callee_str, list_str)\n-    } else {\n-        format!(\"{}({})\", callee_str, list_str)\n-    })\n+           format!(\"{}( {} )\", callee_str, list_str)\n+       } else {\n+           format!(\"{}({})\", callee_str, list_str)\n+       })\n }\n \n fn rewrite_paren(context: &RewriteContext, subexpr: &ast::Expr, shape: Shape) -> Option<String> {\n@@ -1629,10 +1632,10 @@ fn rewrite_paren(context: &RewriteContext, subexpr: &ast::Expr, shape: Shape) ->\n     debug!(\"rewrite_paren, subexpr_str: `{:?}`\", subexpr_str);\n \n     subexpr_str.map(|s| if context.config.spaces_within_parens && s.len() > 0 {\n-        format!(\"( {} )\", s)\n-    } else {\n-        format!(\"({})\", s)\n-    })\n+                        format!(\"( {} )\", s)\n+                    } else {\n+                        format!(\"({})\", s)\n+                    })\n }\n \n fn rewrite_index(expr: &ast::Expr,\n@@ -1658,8 +1661,8 @@ fn rewrite_index(expr: &ast::Expr,\n     let indent = indent.to_string(&context.config);\n     // FIXME this is not right, since we don't take into account that shape.width\n     // might be reduced from max_width by something on the right.\n-    let budget =\n-        try_opt!(context.config.max_width.checked_sub(indent.len() + lbr.len() + rbr.len()));\n+    let budget = try_opt!(context.config.max_width.checked_sub(indent.len() + lbr.len() +\n+                                                               rbr.len()));\n     let index_str = try_opt!(index.rewrite(context, Shape::legacy(budget, shape.indent)));\n     Some(format!(\"{}\\n{}{}{}{}\", expr_str, indent, lbr, index_str, rbr))\n }\n@@ -1680,19 +1683,20 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n \n     // 2 = \" {\".len()\n     let path_shape = try_opt!(shape.sub_width(2));\n-    let path_str = try_opt!(rewrite_path(context,\n-                                         PathContext::Expr,\n-                                         None,\n-                                         path,\n-                                         path_shape));\n+    let path_str = try_opt!(rewrite_path(context, PathContext::Expr, None, path, path_shape));\n \n     // Foo { a: Foo } - indent is +3, width is -5.\n     let h_shape = shape.sub_width(path_str.len() + 5);\n     let v_shape = match context.config.struct_lit_style {\n-        StructLitStyle::Visual => try_opt!(try_opt!(shape.shrink_left(path_str.len() + 3)).sub_width(2)),\n+        StructLitStyle::Visual => {\n+            try_opt!(try_opt!(shape.shrink_left(path_str.len() + 3)).sub_width(2))\n+        }\n         StructLitStyle::Block => {\n             let shape = shape.block_indent(context.config.tab_spaces);\n-            Shape { width: try_opt!(context.config.max_width.checked_sub(shape.indent.width())), ..shape }\n+            Shape {\n+                width: try_opt!(context.config.max_width.checked_sub(shape.indent.width())),\n+                ..shape\n+            }\n         }\n     };\n \n@@ -1706,13 +1710,12 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n                              |item| match *item {\n                                  StructLitField::Regular(field) => field.span.lo,\n                                  StructLitField::Base(expr) => {\n-                                     let last_field_hi = fields.last()\n-                                         .map_or(span.lo, |field| field.span.hi);\n-                                     let snippet =\n-                                         context.snippet(mk_sp(last_field_hi, expr.span.lo));\n-                                     let pos = snippet.find_uncommented(\"..\").unwrap();\n-                                     last_field_hi + BytePos(pos as u32)\n-                                 }\n+        let last_field_hi = fields.last()\n+            .map_or(span.lo, |field| field.span.hi);\n+        let snippet = context.snippet(mk_sp(last_field_hi, expr.span.lo));\n+        let pos = snippet.find_uncommented(\"..\").unwrap();\n+        last_field_hi + BytePos(pos as u32)\n+    }\n                              },\n                              |item| match *item {\n                                  StructLitField::Regular(field) => field.span.hi,\n@@ -1722,14 +1725,11 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n         match *item {\n             StructLitField::Regular(field) => {\n                 // The 1 taken from the v_budget is for the comma.\n-                rewrite_field(context,\n-                              field,\n-                              try_opt!(v_shape.sub_width(1)))\n+                rewrite_field(context, field, try_opt!(v_shape.sub_width(1)))\n             }\n             StructLitField::Base(expr) => {\n                 // 2 = ..\n-                expr.rewrite(context,\n-                             try_opt!(v_shape.shrink_left(2)))\n+                expr.rewrite(context, try_opt!(v_shape.shrink_left(2)))\n                     .map(|s| format!(\"..{}\", s))\n             }\n         }\n@@ -1827,8 +1827,8 @@ fn rewrite_field(context: &RewriteContext, field: &ast::Field, shape: Shape) ->\n                 let expr = field.expr\n                     .rewrite(context,\n                              Shape::legacy(try_opt!(context.config\n-                                               .max_width\n-                                               .checked_sub(expr_offset.width())),\n+                                                        .max_width\n+                                                        .checked_sub(expr_offset.width())),\n                                            expr_offset));\n                 expr.map(|s| format!(\"{}:\\n{}{}\", name, expr_offset.to_string(&context.config), s))\n             }\n@@ -1851,13 +1851,13 @@ pub fn rewrite_tuple<'a, I>(context: &RewriteContext,\n         // 3 = \"(\" + \",)\"\n         let nested_shape = try_opt!(shape.sub_width(3)).visual_indent(1);\n         return items.next()\n-            .unwrap()\n-            .rewrite(context, nested_shape)\n-            .map(|s| if context.config.spaces_within_parens {\n-                format!(\"( {}, )\", s)\n-            } else {\n-                format!(\"({},)\", s)\n-            });\n+                   .unwrap()\n+                   .rewrite(context, nested_shape)\n+                   .map(|s| if context.config.spaces_within_parens {\n+                            format!(\"( {}, )\", s)\n+                        } else {\n+                            format!(\"({},)\", s)\n+                        });\n     }\n \n     let list_lo = context.codemap.span_after(span, \"(\");\n@@ -1946,10 +1946,10 @@ pub fn rewrite_assign_rhs<S: Into<String>>(context: &RewriteContext,\n     let mut result = lhs.into();\n     let last_line_width = last_line_width(&result) -\n                           if result.contains('\\n') {\n-        shape.indent.width()\n-    } else {\n-        0\n-    };\n+                              shape.indent.width()\n+                          } else {\n+                              0\n+                          };\n     // 1 = space between operator and rhs.\n     let max_width = try_opt!(shape.width.checked_sub(last_line_width + 1));\n     let rhs = ex.rewrite(context,\n@@ -1972,7 +1972,7 @@ pub fn rewrite_assign_rhs<S: Into<String>>(context: &RewriteContext,\n             // if that works better.\n             let new_offset = shape.indent.block_indent(context.config);\n             let max_width = try_opt!((shape.width + shape.indent.width())\n-                .checked_sub(new_offset.width()));\n+                                         .checked_sub(new_offset.width()));\n             let new_rhs = ex.rewrite(context, Shape::legacy(max_width, new_offset));\n \n             // FIXME: DRY!"}, {"sha": "2bf54556d27d4eaf6626db491600ded7c919f485", "filename": "src/file_lines.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9eb78a33335b83073c90dd8b065c31f1fb958dcc/src%2Ffile_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb78a33335b83073c90dd8b065c31f1fb958dcc/src%2Ffile_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffile_lines.rs?ref=9eb78a33335b83073c90dd8b065c31f1fb958dcc", "patch": "@@ -120,8 +120,9 @@ impl FileLines {\n             Some(ref map) => map,\n         };\n \n-        match canonicalize_path_string(range.file_name())\n-            .and_then(|canonical| map.get_vec(&canonical).ok_or(())) {\n+        match canonicalize_path_string(range.file_name()).and_then(|canonical| {\n+            map.get_vec(&canonical).ok_or(())\n+        }) {\n             Ok(ranges) => ranges.iter().any(|r| r.contains(Range::from(range))),\n             Err(_) => false,\n         }\n@@ -182,8 +183,9 @@ impl JsonSpan {\n     // To allow `collect()`ing into a `MultiMap`.\n     fn into_tuple(self) -> Result<(String, Range), String> {\n         let (lo, hi) = self.range;\n-        let canonical = try!(canonicalize_path_string(&self.file)\n-            .map_err(|_| format!(\"Can't canonicalize {}\", &self.file)));\n+        let canonical = try!(canonicalize_path_string(&self.file).map_err(|_| {\n+            format!(\"Can't canonicalize {}\", &self.file)\n+        }));\n         Ok((canonical, Range::new(lo, hi)))\n     }\n }"}, {"sha": "a2cfa34f1abc485f964adfd927bb74056f73e19d", "filename": "src/imports.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9eb78a33335b83073c90dd8b065c31f1fb958dcc/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb78a33335b83073c90dd8b065c31f1fb958dcc/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=9eb78a33335b83073c90dd8b065c31f1fb958dcc", "patch": "@@ -142,9 +142,9 @@ impl Rewrite for ast::ViewPath {\n                 let path_str = if path.segments.last().unwrap().identifier.to_string() == \"self\" &&\n                                   path.segments.len() > 1 {\n                     let path = &ast::Path {\n-                        span: path.span.clone(),\n-                        segments: path.segments[..path.segments.len() - 1].to_owned(),\n-                    };\n+                                    span: path.span.clone(),\n+                                    segments: path.segments[..path.segments.len() - 1].to_owned(),\n+                                };\n                     try_opt!(rewrite_path(context,\n                                           PathContext::Import,\n                                           None,\n@@ -159,10 +159,10 @@ impl Rewrite for ast::ViewPath {\n                 };\n \n                 Some(if path.segments.last().unwrap().identifier == ident {\n-                    path_str\n-                } else {\n-                    format!(\"{} as {}\", path_str, ident_str)\n-                })\n+                         path_str\n+                     } else {\n+                         format!(\"{} as {}\", path_str, ident_str)\n+                     })\n             }\n         }\n     }\n@@ -348,10 +348,10 @@ pub fn rewrite_use_list(shape: Shape,\n     let list_str = try_opt!(write_list(&items[first_index..], &fmt));\n \n     Some(if path_str.is_empty() {\n-        format!(\"{{{}}}\", list_str)\n-    } else {\n-        format!(\"{}::{{{}}}\", path_str, list_str)\n-    })\n+             format!(\"{{{}}}\", list_str)\n+         } else {\n+             format!(\"{}::{{{}}}\", path_str, list_str)\n+         })\n }\n \n // Returns true when self item was found."}, {"sha": "e247aad67a0d90dbc486330cc94cab432f7a855b", "filename": "src/issues.rs", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/9eb78a33335b83073c90dd8b065c31f1fb958dcc/src%2Fissues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb78a33335b83073c90dd8b065c31f1fb958dcc/src%2Fissues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fissues.rs?ref=9eb78a33335b83073c90dd8b065c31f1fb958dcc", "patch": "@@ -128,16 +128,16 @@ impl BadIssueSeeker {\n             todo_idx += 1;\n             if todo_idx == TO_DO_CHARS.len() {\n                 return Seeking::Number {\n-                    issue: Issue {\n-                        issue_type: IssueType::Todo,\n-                        missing_number: if let ReportTactic::Unnumbered = self.report_todo {\n-                            true\n-                        } else {\n-                            false\n-                        },\n-                    },\n-                    part: NumberPart::OpenParen,\n-                };\n+                           issue: Issue {\n+                               issue_type: IssueType::Todo,\n+                               missing_number: if let ReportTactic::Unnumbered = self.report_todo {\n+                                   true\n+                               } else {\n+                                   false\n+                               },\n+                           },\n+                           part: NumberPart::OpenParen,\n+                       };\n             }\n             fixme_idx = 0;\n         } else if self.report_fixme.is_enabled() && c == FIX_ME_CHARS[fixme_idx] {\n@@ -146,16 +146,17 @@ impl BadIssueSeeker {\n             fixme_idx += 1;\n             if fixme_idx == FIX_ME_CHARS.len() {\n                 return Seeking::Number {\n-                    issue: Issue {\n-                        issue_type: IssueType::Fixme,\n-                        missing_number: if let ReportTactic::Unnumbered = self.report_fixme {\n-                            true\n-                        } else {\n-                            false\n-                        },\n-                    },\n-                    part: NumberPart::OpenParen,\n-                };\n+                           issue: Issue {\n+                               issue_type: IssueType::Fixme,\n+                               missing_number: if let ReportTactic::Unnumbered =\n+                    self.report_fixme {\n+                                   true\n+                               } else {\n+                                   false\n+                               },\n+                           },\n+                           part: NumberPart::OpenParen,\n+                       };\n             }\n             todo_idx = 0;\n         } else {\n@@ -178,10 +179,10 @@ impl BadIssueSeeker {\n             return IssueClassification::Bad(issue);\n         } else if c == ')' {\n             return if let NumberPart::CloseParen = part {\n-                IssueClassification::Good\n-            } else {\n-                IssueClassification::Bad(issue)\n-            };\n+                       IssueClassification::Good\n+                   } else {\n+                       IssueClassification::Bad(issue)\n+                   };\n         }\n \n         match part {\n@@ -268,9 +269,9 @@ fn find_issue() {\n fn issue_type() {\n     let mut seeker = BadIssueSeeker::new(ReportTactic::Always, ReportTactic::Never);\n     let expected = Some(Issue {\n-        issue_type: IssueType::Todo,\n-        missing_number: false,\n-    });\n+                            issue_type: IssueType::Todo,\n+                            missing_number: false,\n+                        });\n \n     assert_eq!(expected,\n                \"TODO(#100): more awesomeness\"\n@@ -281,9 +282,9 @@ fn issue_type() {\n \n     let mut seeker = BadIssueSeeker::new(ReportTactic::Never, ReportTactic::Unnumbered);\n     let expected = Some(Issue {\n-        issue_type: IssueType::Fixme,\n-        missing_number: true,\n-    });\n+                            issue_type: IssueType::Fixme,\n+                            missing_number: true,\n+                        });\n \n     assert_eq!(expected,\n                \"Test. FIXME: bad, bad, not good\""}, {"sha": "6b66d9ef2c98cc654ff947ee67935c1cee243ca0", "filename": "src/items.rs", "status": "modified", "additions": 67, "deletions": 57, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/9eb78a33335b83073c90dd8b065c31f1fb958dcc/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb78a33335b83073c90dd8b065c31f1fb958dcc/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=9eb78a33335b83073c90dd8b065c31f1fb958dcc", "patch": "@@ -41,7 +41,8 @@ impl Rewrite for ast::Local {\n         let pattern_width = try_opt!(shape.width.checked_sub(pattern_offset.width() + 1));\n \n         let pat_str = try_opt!(self.pat\n-            .rewrite(&context, Shape::legacy(pattern_width, pattern_offset)));\n+                                   .rewrite(&context,\n+                                            Shape::legacy(pattern_width, pattern_offset)));\n         result.push_str(&pat_str);\n \n         // String that is placed within the assignment pattern and expression.\n@@ -376,7 +377,7 @@ impl<'a> FmtVisitor<'a> {\n                                            self.block_indent,\n                                            self.block_indent.block_indent(self.config),\n                                            mk_sp(span.lo, body_start))\n-            .unwrap();\n+                .unwrap();\n         self.buffer.push_str(&generics_str);\n \n         self.last_pos = body_start;\n@@ -455,9 +456,11 @@ impl<'a> FmtVisitor<'a> {\n \n         let indent = self.block_indent;\n         let mut result = try_opt!(field.node\n-            .attrs\n-            .rewrite(&self.get_context(),\n-                     Shape::legacy(self.config.max_width - indent.width(), indent)));\n+                                      .attrs\n+                                      .rewrite(&self.get_context(),\n+                                               Shape::legacy(self.config.max_width -\n+                                                             indent.width(),\n+                                                             indent)));\n         if !result.is_empty() {\n             result.push('\\n');\n             result.push_str(&indent.to_string(self.config));\n@@ -782,8 +785,8 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n             };\n \n         let where_budget = try_opt!(context.config\n-            .max_width\n-            .checked_sub(last_line_width(&result)));\n+                                        .max_width\n+                                        .checked_sub(last_line_width(&result)));\n         let where_clause_str = try_opt!(rewrite_where_clause(context,\n                                                              &generics.where_clause,\n                                                              context.config,\n@@ -937,7 +940,7 @@ fn format_struct_struct(context: &RewriteContext,\n                      |field| field.rewrite(context, Shape::legacy(item_budget, item_indent)),\n                      context.codemap.span_after(span, \"{\"),\n                      span.hi)\n-            .collect::<Vec<_>>();\n+                .collect::<Vec<_>>();\n     // 1 = ,\n     let budget = context.config.max_width - offset.width() + context.config.tab_spaces - 1;\n \n@@ -998,8 +1001,8 @@ fn format_tuple_struct(context: &RewriteContext,\n             result.push_str(&generics_str);\n \n             let where_budget = try_opt!(context.config\n-                .max_width\n-                .checked_sub(last_line_width(&result)));\n+                                            .max_width\n+                                            .checked_sub(last_line_width(&result)));\n             try_opt!(rewrite_where_clause(context,\n                                           &generics.where_clause,\n                                           context.config,\n@@ -1058,7 +1061,7 @@ fn format_tuple_struct(context: &RewriteContext,\n         // know that earlier, so the where clause will not be indented properly.\n         result.push('\\n');\n         result.push_str(&(offset.block_only() + (context.config.tab_spaces - 1))\n-            .to_string(context.config));\n+                             .to_string(context.config));\n     }\n     result.push_str(&where_clause_str);\n \n@@ -1091,8 +1094,8 @@ pub fn rewrite_type_alias(context: &RewriteContext,\n     result.push_str(&generics_str);\n \n     let where_budget = try_opt!(context.config\n-        .max_width\n-        .checked_sub(last_line_width(&result)));\n+                                    .max_width\n+                                    .checked_sub(last_line_width(&result)));\n     let where_clause_str = try_opt!(rewrite_where_clause(context,\n                                                          &generics.where_clause,\n                                                          context.config,\n@@ -1115,19 +1118,19 @@ pub fn rewrite_type_alias(context: &RewriteContext,\n     let type_indent = indent + line_width;\n     // Try to fit the type on the same line\n     let ty_str = try_opt!(ty.rewrite(context, Shape::legacy(budget, type_indent))\n-        .or_else(|| {\n-            // The line was too short, try to put the type on the next line\n+                              .or_else(|| {\n+        // The line was too short, try to put the type on the next line\n \n-            // Remove the space after '='\n-            result.pop();\n-            let type_indent = indent.block_indent(context.config);\n-            result.push('\\n');\n-            result.push_str(&type_indent.to_string(context.config));\n-            let budget = try_opt!(context.config\n-                .max_width\n-                .checked_sub(type_indent.width() + \";\".len()));\n-            ty.rewrite(context, Shape::legacy(budget, type_indent))\n-        }));\n+        // Remove the space after '='\n+        result.pop();\n+        let type_indent = indent.block_indent(context.config);\n+        result.push('\\n');\n+        result.push_str(&type_indent.to_string(context.config));\n+        let budget = try_opt!(context.config\n+                                  .max_width\n+                                  .checked_sub(type_indent.width() + \";\".len()));\n+        ty.rewrite(context, Shape::legacy(budget, type_indent))\n+    }));\n     result.push_str(&ty_str);\n     result.push_str(\";\");\n     Some(result)\n@@ -1156,9 +1159,10 @@ impl Rewrite for ast::StructField {\n         let name = self.ident;\n         let vis = format_visibility(&self.vis);\n         let mut attr_str = try_opt!(self.attrs\n-            .rewrite(context,\n-                     Shape::legacy(context.config.max_width - shape.indent.width(),\n-                                   shape.indent)));\n+                                        .rewrite(context,\n+                                                 Shape::legacy(context.config.max_width -\n+                                                               shape.indent.width(),\n+                                                               shape.indent)));\n         if !attr_str.is_empty() {\n             attr_str.push('\\n');\n             attr_str.push_str(&shape.indent.to_string(context.config));\n@@ -1205,8 +1209,7 @@ pub fn rewrite_static(prefix: &str,\n                          type_annotation_spacing.1);\n     // 2 = \" =\".len()\n     let ty_str = try_opt!(ty.rewrite(context,\n-                                     Shape::legacy(context.config.max_width -\n-                                                   offset.block_indent -\n+                                     Shape::legacy(context.config.max_width - offset.block_indent -\n                                                    prefix.len() -\n                                                    2,\n                                                    offset.block_only())));\n@@ -1219,7 +1222,7 @@ pub fn rewrite_static(prefix: &str,\n                            lhs,\n                            expr,\n                            Shape::legacy(remaining_width, offset.block_only()))\n-            .map(|s| s + \";\")\n+                .map(|s| s + \";\")\n     } else {\n         let lhs = format!(\"{}{};\", prefix, ty_str);\n         Some(lhs)\n@@ -1237,11 +1240,11 @@ pub fn rewrite_associated_type(ident: ast::Ident,\n     let type_bounds_str = if let Some(ty_param_bounds) = ty_param_bounds_opt {\n         let bounds: &[_] = ty_param_bounds;\n         let bound_str = try_opt!(bounds.iter()\n-            .map(|ty_bound| {\n-                ty_bound.rewrite(context, Shape::legacy(context.config.max_width, indent))\n-            })\n-            .intersperse(Some(\" + \".to_string()))\n-            .collect::<Option<String>>());\n+                                     .map(|ty_bound| {\n+            ty_bound.rewrite(context, Shape::legacy(context.config.max_width, indent))\n+        })\n+                                     .intersperse(Some(\" + \".to_string()))\n+                                     .collect::<Option<String>>());\n         if bounds.len() > 0 {\n             format!(\": {}\", bound_str)\n         } else {\n@@ -1281,7 +1284,8 @@ impl Rewrite for ast::Arg {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         if is_named_arg(self) {\n             let mut result = try_opt!(self.pat\n-                .rewrite(context, Shape::legacy(shape.width, shape.indent)));\n+                                          .rewrite(context,\n+                                                   Shape::legacy(shape.width, shape.indent)));\n \n             if self.ty.node != ast::TyKind::Infer {\n                 if context.config.space_before_type_annotation {\n@@ -1314,7 +1318,8 @@ fn rewrite_explicit_self(explicit_self: &ast::ExplicitSelf,\n             let mut_str = format_mutability(m);\n             match lt {\n                 Some(ref l) => {\n-                    let lifetime_str = try_opt!(l.rewrite(context,\n+                    let lifetime_str =\n+                        try_opt!(l.rewrite(context,\n                                            Shape::legacy(usize::max_value(), Indent::empty())));\n                     Some(format!(\"&{} {}self\", lifetime_str, mut_str))\n                 }\n@@ -1325,8 +1330,8 @@ fn rewrite_explicit_self(explicit_self: &ast::ExplicitSelf,\n             assert!(!args.is_empty(), \"&[ast::Arg] shouldn't be empty.\");\n \n             let mutability = explicit_self_mutability(&args[0]);\n-            let type_str =\n-                try_opt!(ty.rewrite(context, Shape::legacy(usize::max_value(), Indent::empty())));\n+            let type_str = try_opt!(ty.rewrite(context,\n+                                               Shape::legacy(usize::max_value(), Indent::empty())));\n \n             Some(format!(\"{}self: {}\", format_mutability(mutability), type_str))\n         }\n@@ -1458,8 +1463,10 @@ fn rewrite_fn_base(context: &RewriteContext,\n     // Note that if the width and indent really matter, we'll re-layout the\n     // return type later anyway.\n     let ret_str = try_opt!(fd.output\n-        .rewrite(&context,\n-                 Shape::legacy(context.config.max_width - indent.width(), indent)));\n+                               .rewrite(&context,\n+                                        Shape::legacy(context.config.max_width -\n+                                                      indent.width(),\n+                                                      indent)));\n \n     let multi_line_ret_str = ret_str.contains('\\n');\n     let ret_str_len = if multi_line_ret_str { 0 } else { ret_str.len() };\n@@ -1662,18 +1669,21 @@ fn rewrite_args(context: &RewriteContext,\n                 variadic: bool)\n                 -> Option<String> {\n     let mut arg_item_strs = try_opt!(args.iter()\n-        .map(|arg| arg.rewrite(&context, Shape::legacy(multi_line_budget, arg_indent)))\n-        .collect::<Option<Vec<_>>>());\n+                                         .map(|arg| {\n+        arg.rewrite(&context, Shape::legacy(multi_line_budget, arg_indent))\n+    })\n+                                         .collect::<Option<Vec<_>>>());\n \n     // Account for sugary self.\n     // FIXME: the comment for the self argument is dropped. This is blocked\n     // on rust issue #27522.\n-    let min_args =\n-        explicit_self.and_then(|explicit_self| rewrite_explicit_self(explicit_self, args, context))\n-            .map_or(1, |self_str| {\n-                arg_item_strs[0] = self_str;\n-                2\n-            });\n+    let min_args = explicit_self.and_then(|explicit_self| {\n+            rewrite_explicit_self(explicit_self, args, context)\n+        })\n+        .map_or(1, |self_str| {\n+            arg_item_strs[0] = self_str;\n+            2\n+        });\n \n     // Comments between args.\n     let mut arg_items = Vec::new();\n@@ -1885,10 +1895,10 @@ fn rewrite_generics(context: &RewriteContext,\n         try_opt!(format_item_list(items, Shape::legacy(h_budget, offset), context.config));\n \n     Some(if context.config.spaces_within_angle_brackets {\n-        format!(\"< {} >\", list_str)\n-    } else {\n-        format!(\"<{}>\", list_str)\n-    })\n+             format!(\"< {} >\", list_str)\n+         } else {\n+             format!(\"<{}>\", list_str)\n+         })\n }\n \n fn rewrite_trait_bounds(context: &RewriteContext,\n@@ -1902,9 +1912,9 @@ fn rewrite_trait_bounds(context: &RewriteContext,\n     }\n \n     let bound_str = try_opt!(bounds.iter()\n-        .map(|ty_bound| ty_bound.rewrite(&context, shape))\n-        .intersperse(Some(\" + \".to_string()))\n-        .collect::<Option<String>>());\n+                                 .map(|ty_bound| ty_bound.rewrite(&context, shape))\n+                                 .intersperse(Some(\" + \".to_string()))\n+                                 .collect::<Option<String>>());\n \n     let mut result = String::new();\n     result.push_str(\": \");"}, {"sha": "b3f618395f44512c2a3deecd97f245348dc8f9ca", "filename": "src/lib.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9eb78a33335b83073c90dd8b065c31f1fb958dcc/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb78a33335b83073c90dd8b065c31f1fb958dcc/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=9eb78a33335b83073c90dd8b065c31f1fb958dcc", "patch": "@@ -256,7 +256,7 @@ impl Shape {\n             indent: indent,\n             offset: offset,\n         }\n-    }    \n+    }\n \n     pub fn visual_indent(&self, extra_width: usize) -> Shape {\n         let alignment = self.offset + extra_width;\n@@ -316,18 +316,18 @@ impl Shape {\n \n     pub fn sub_width(&self, width: usize) -> Option<Shape> {\n         Some(Shape {\n-            width: try_opt!(self.width.checked_sub(width)),\n-            indent: self.indent,\n-            offset: self.offset,\n-        })\n+                 width: try_opt!(self.width.checked_sub(width)),\n+                 indent: self.indent,\n+                 offset: self.offset,\n+             })\n     }\n \n     pub fn shrink_left(&self, width: usize) -> Option<Shape> {\n         Some(Shape {\n-            width: try_opt!(self.width.checked_sub(width)),\n-            indent: self.indent + width,\n-            offset: self.offset + width,\n-        })        \n+                 width: try_opt!(self.width.checked_sub(width)),\n+                 indent: self.indent + width,\n+                 offset: self.offset + width,\n+             })\n     }\n \n     pub fn used_width(&self) -> usize {\n@@ -477,9 +477,9 @@ fn format_lines(text: &mut StringBuffer, name: &str, config: &Config, report: &m\n         // Add warnings for bad todos/ fixmes\n         if let Some(issue) = issue_seeker.inspect(c) {\n             errors.push(FormattingError {\n-                line: cur_line,\n-                kind: ErrorKind::BadIssue(issue),\n-            });\n+                            line: cur_line,\n+                            kind: ErrorKind::BadIssue(issue),\n+                        });\n         }\n \n         if c == '\\n' {\n@@ -491,9 +491,9 @@ fn format_lines(text: &mut StringBuffer, name: &str, config: &Config, report: &m\n             // Check for any line width errors we couldn't correct.\n             if line_len > config.max_width {\n                 errors.push(FormattingError {\n-                    line: cur_line,\n-                    kind: ErrorKind::LineOverflow(line_len, config.max_width),\n-                });\n+                                line: cur_line,\n+                                kind: ErrorKind::LineOverflow(line_len, config.max_width),\n+                            });\n             }\n             line_len = 0;\n             cur_line += 1;\n@@ -520,9 +520,9 @@ fn format_lines(text: &mut StringBuffer, name: &str, config: &Config, report: &m\n \n     for &(l, _, _) in &trims {\n         errors.push(FormattingError {\n-            line: l,\n-            kind: ErrorKind::TrailingWhitespace,\n-        });\n+                        line: l,\n+                        kind: ErrorKind::TrailingWhitespace,\n+                    });\n     }\n \n     report.file_error_map.insert(name.to_owned(), errors);"}, {"sha": "8ba54ab4ccb9c2a184bd84fbe37d1d6814074dae", "filename": "src/lists.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9eb78a33335b83073c90dd8b065c31f1fb958dcc/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb78a33335b83073c90dd8b065c31f1fb958dcc/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=9eb78a33335b83073c90dd8b065c31f1fb958dcc", "patch": "@@ -260,8 +260,7 @@ pub fn write_list<I, T>(items: I, formatting: &ListFormatting) -> Option<String>\n         // Post-comments\n         if tactic != DefinitiveListTactic::Vertical && item.post_comment.is_some() {\n             let comment = item.post_comment.as_ref().unwrap();\n-            let formatted_comment =\n-                try_opt!(rewrite_comment(comment,\n+            let formatted_comment = try_opt!(rewrite_comment(comment,\n                                          true,\n                                          Shape::legacy(formatting.shape.width, Indent::empty()),\n                                          formatting.config));"}, {"sha": "607e743380a6aaa36646814cdea073b2fbd9a1cf", "filename": "src/macros.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9eb78a33335b83073c90dd8b065c31f1fb958dcc/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb78a33335b83073c90dd8b065c31f1fb958dcc/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=9eb78a33335b83073c90dd8b065c31f1fb958dcc", "patch": "@@ -92,13 +92,13 @@ pub fn rewrite_macro(mac: &ast::Mac,\n \n     if mac.node.tts.is_empty() && !contains_comment(&context.snippet(mac.span)) {\n         return match style {\n-            MacroStyle::Parens if position == MacroPosition::Item => {\n-                Some(format!(\"{}();\", macro_name))\n-            }\n-            MacroStyle::Parens => Some(format!(\"{}()\", macro_name)),\n-            MacroStyle::Brackets => Some(format!(\"{}[]\", macro_name)),\n-            MacroStyle::Braces => Some(format!(\"{}{{}}\", macro_name)),\n-        };\n+                   MacroStyle::Parens if position == MacroPosition::Item => {\n+                       Some(format!(\"{}();\", macro_name))\n+                   }\n+                   MacroStyle::Parens => Some(format!(\"{}()\", macro_name)),\n+                   MacroStyle::Brackets => Some(format!(\"{}[]\", macro_name)),\n+                   MacroStyle::Braces => Some(format!(\"{}{{}}\", macro_name)),\n+               };\n     }\n \n     let mut parser = tts_to_parser(context.parse_session, mac.node.tts.clone());\n@@ -181,11 +181,11 @@ pub fn convert_try_mac(mac: &ast::Mac, context: &RewriteContext) -> Option<ast::\n         let mut parser = tts_to_parser(context.parse_session, mac.node.tts.clone());\n \n         Some(ast::Expr {\n-            id: ast::NodeId::new(0), // dummy value\n-            node: ast::ExprKind::Try(try_opt!(parser.parse_expr().ok())),\n-            span: mac.span, // incorrect span, but shouldn't matter too much\n-            attrs: ThinVec::new(),\n-        })\n+                 id: ast::NodeId::new(0), // dummy value\n+                 node: ast::ExprKind::Try(try_opt!(parser.parse_expr().ok())),\n+                 span: mac.span, // incorrect span, but shouldn't matter too much\n+                 attrs: ThinVec::new(),\n+             })\n     } else {\n         None\n     }"}, {"sha": "61efbddeb1c0ebee48acbea19020fdbe9e6943bc", "filename": "src/missed_spans.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9eb78a33335b83073c90dd8b065c31f1fb958dcc/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb78a33335b83073c90dd8b065c31f1fb958dcc/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=9eb78a33335b83073c90dd8b065c31f1fb958dcc", "patch": "@@ -147,16 +147,16 @@ impl<'a> FmtVisitor<'a> {\n                                                           Shape::legacy(comment_width,\n                                                                         self.block_indent),\n                                                           self.config)\n-                        .unwrap());\n+                                                  .unwrap());\n \n                     last_wspace = None;\n                     line_start = offset + subslice.len();\n \n                     if let Some('/') = subslice.chars().skip(1).next() {\n                         // check that there are no contained block comments\n                         if !subslice.split('\\n')\n-                            .map(|s| s.trim_left())\n-                            .any(|s| s.len() > 2 && &s[0..2] == \"/*\") {\n+                                .map(|s| s.trim_left())\n+                                .any(|s| s.len() > 2 && &s[0..2] == \"/*\") {\n                             // Add a newline after line comments\n                             self.buffer.push_str(\"\\n\");\n                         }"}, {"sha": "ba642493bdd940fcc38639a84ef32525f7c0bb3b", "filename": "src/patterns.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/9eb78a33335b83073c90dd8b065c31f1fb958dcc/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb78a33335b83073c90dd8b065c31f1fb958dcc/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=9eb78a33335b83073c90dd8b065c31f1fb958dcc", "patch": "@@ -37,7 +37,9 @@ impl Rewrite for Pat {\n                     Some(ref p) => {\n                         // 3 - ` @ `.\n                         let width = try_opt!(shape.width\n-                            .checked_sub(prefix.len() + mut_infix.len() + id_str.len() + 3));\n+                                                 .checked_sub(prefix.len() + mut_infix.len() +\n+                                                              id_str.len() +\n+                                                              3));\n                         format!(\" @ {}\",\n                                 try_opt!(p.rewrite(context, Shape::legacy(width, shape.indent))))\n                     }\n@@ -81,8 +83,9 @@ impl Rewrite for Pat {\n             PatKind::Slice(ref prefix, ref slice_pat, ref suffix) => {\n                 // Rewrite all the sub-patterns.\n                 let prefix = prefix.iter().map(|p| p.rewrite(context, shape));\n-                let slice_pat = slice_pat.as_ref()\n-                    .map(|p| Some(format!(\"{}..\", try_opt!(p.rewrite(context, shape)))));\n+                let slice_pat =\n+                    slice_pat.as_ref()\n+                        .map(|p| Some(format!(\"{}..\", try_opt!(p.rewrite(context, shape)))));\n                 let suffix = suffix.iter().map(|p| p.rewrite(context, shape));\n \n                 // Munge them together.\n@@ -223,15 +226,14 @@ fn rewrite_tuple_pat(pats: &[ptr::P<ast::Pat>],\n         let nested_shape = try_opt!(shape.sub_width(path_len + if add_comma { 3 } else { 2 }));\n         // 1 = \"(\".len()\n         let nested_shape = nested_shape.visual_indent(path_len + 1);\n-        let mut items: Vec<_> =\n-            itemize_list(context.codemap,\n-                         pat_vec.iter(),\n-                         if add_comma { \",)\" } else { \")\" },\n-                         |item| item.span().lo,\n-                         |item| item.span().hi,\n-                         |item| item.rewrite(context, nested_shape),\n-                         context.codemap.span_after(span, \"(\"),\n-                         span.hi - BytePos(1))\n+        let mut items: Vec<_> = itemize_list(context.codemap,\n+                                             pat_vec.iter(),\n+                                             if add_comma { \",)\" } else { \")\" },\n+                                             |item| item.span().lo,\n+                                             |item| item.span().hi,\n+                                             |item| item.rewrite(context, nested_shape),\n+                                             context.codemap.span_after(span, \"(\"),\n+                                             span.hi - BytePos(1))\n                 .collect();\n \n         // Condense wildcard string suffix into a single ..\n@@ -244,26 +246,24 @@ fn rewrite_tuple_pat(pats: &[ptr::P<ast::Pat>],\n             let da_iter = items.into_iter().take(new_item_count);\n             try_opt!(format_item_list(da_iter, nested_shape, context.config))\n         } else {\n-            try_opt!(format_item_list(items.into_iter(),\n-                                      nested_shape,\n-                                      context.config))\n+            try_opt!(format_item_list(items.into_iter(), nested_shape, context.config))\n         };\n \n         match path_str {\n             Some(path_str) => {\n                 Some(if context.config.spaces_within_parens {\n-                    format!(\"{}( {} )\", path_str, list)\n-                } else {\n-                    format!(\"{}({})\", path_str, list)\n-                })\n+                         format!(\"{}( {} )\", path_str, list)\n+                     } else {\n+                         format!(\"{}({})\", path_str, list)\n+                     })\n             }\n             None => {\n                 let comma = if add_comma { \",\" } else { \"\" };\n                 Some(if context.config.spaces_within_parens {\n-                    format!(\"( {}{} )\", list, comma)\n-                } else {\n-                    format!(\"({}{})\", list, comma)\n-                })\n+                         format!(\"( {}{} )\", list, comma)\n+                     } else {\n+                         format!(\"({}{})\", list, comma)\n+                     })\n             }\n         }\n     }\n@@ -273,9 +273,10 @@ fn count_wildcard_suffix_len(items: &[ListItem]) -> usize {\n     let mut suffix_len = 0;\n \n     for item in items.iter().rev().take_while(|i| match i.item {\n-        Some(ref internal_string) if internal_string == \"_\" => true,\n-        _ => false,\n-    }) {\n+                                                  Some(ref internal_string) if internal_string ==\n+                                                                               \"_\" => true,\n+                                                  _ => false,\n+                                              }) {\n         suffix_len += 1;\n \n         if item.pre_comment.is_some() || item.post_comment.is_some() {"}, {"sha": "d8b3711040c24c3fba8f5ad7d3a42b491d9748eb", "filename": "src/string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9eb78a33335b83073c90dd8b065c31f1fb958dcc/src%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb78a33335b83073c90dd8b065c31f1fb958dcc/src%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring.rs?ref=9eb78a33335b83073c90dd8b065c31f1fb958dcc", "patch": "@@ -43,8 +43,8 @@ pub fn rewrite_string<'a>(orig: &str, fmt: &StringFormat<'a>) -> Option<String>\n     // `cur_start` is the position in `orig` of the start of the current line.\n     let mut cur_start = 0;\n     let mut result = String::with_capacity(stripped_str.len()\n-        .checked_next_power_of_two()\n-        .unwrap_or(usize::max_value()));\n+                                               .checked_next_power_of_two()\n+                                               .unwrap_or(usize::max_value()));\n     result.push_str(fmt.opener);\n \n     let ender_length = fmt.line_end.len();"}, {"sha": "574def6d7c47331d17d118e311886f9fe1149acf", "filename": "src/types.rs", "status": "modified", "additions": 76, "deletions": 69, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/9eb78a33335b83073c90dd8b065c31f1fb958dcc/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb78a33335b83073c90dd8b065c31f1fb958dcc/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=9eb78a33335b83073c90dd8b065c31f1fb958dcc", "patch": "@@ -162,8 +162,10 @@ impl<'a> Rewrite for SegmentParam<'a> {\n             SegmentParam::Binding(binding) => {\n                 let mut result = format!(\"{} = \", binding.ident);\n                 let budget = try_opt!(shape.width.checked_sub(result.len()));\n-                let rewrite = try_opt!(binding.ty\n-                    .rewrite(context, Shape::legacy(budget, shape.indent + result.len())));\n+                let rewrite =\n+                    try_opt!(binding.ty\n+                                 .rewrite(context,\n+                                          Shape::legacy(budget, shape.indent + result.len())));\n                 result.push_str(&rewrite);\n                 Some(result)\n             }\n@@ -215,7 +217,8 @@ fn rewrite_segment(path_context: PathContext,\n                 let extra_offset = 1 + separator.len();\n                 // 1 for >\n                 // TODO bad visual indent\n-                let list_shape = try_opt!(try_opt!(shape.shrink_left(extra_offset)).sub_width(1)).visual_indent(0);\n+                let list_shape = try_opt!(try_opt!(shape.shrink_left(extra_offset)).sub_width(1))\n+                    .visual_indent(0);\n \n                 let items = itemize_list(context.codemap,\n                                          param_list.into_iter(),\n@@ -331,10 +334,10 @@ fn format_function_type<'a, I>(inputs: I,\n     };\n \n     Some(if context.config.spaces_within_parens {\n-        format!(\"( {} ){}{}\", list_str, infix, output)\n-    } else {\n-        format!(\"({}){}{}\", list_str, infix, output)\n-    })\n+             format!(\"( {} ){}{}\", list_str, infix, output)\n+         } else {\n+             format!(\"({}){}{}\", list_str, infix, output)\n+         })\n }\n \n fn type_bound_colon(context: &RewriteContext) -> &'static str {\n@@ -411,7 +414,8 @@ impl Rewrite for ast::WherePredicate {\n                 let used_width = 3 + lhs_ty_str.len();\n                 let budget = try_opt!(shape.width.checked_sub(used_width));\n                 let rhs_ty_str = try_opt!(rhs_ty.rewrite(context,\n-                                            Shape::legacy(budget, shape.indent + used_width)));\n+                                                         Shape::legacy(budget,\n+                                                                       shape.indent + used_width)));\n                 format!(\"{} = {}\", lhs_ty_str, rhs_ty_str)\n             }\n         };\n@@ -439,8 +443,8 @@ fn rewrite_bounded_lifetime<'b, I>(lt: &ast::Lifetime,\n         Some(result)\n     } else {\n         let appendix: Vec<_> = try_opt!(bounds.into_iter()\n-            .map(|b| b.rewrite(context, shape))\n-            .collect());\n+                                            .map(|b| b.rewrite(context, shape))\n+                                            .collect());\n         let colon = type_bound_colon(context);\n         let result = format!(\"{}{}{}\", result, colon, appendix.join(\" + \"));\n         wrap_str(result, context.config.max_width, shape)\n@@ -479,8 +483,8 @@ impl Rewrite for ast::TyParamBounds {\n             TypeDensity::Wide => \" + \",\n         };\n         let strs: Vec<_> = try_opt!(self.iter()\n-            .map(|b| b.rewrite(context, shape))\n-            .collect());\n+                                        .map(|b| b.rewrite(context, shape))\n+                                        .collect());\n         wrap_str(strs.join(joiner), context.config.max_width, shape)\n     }\n }\n@@ -498,11 +502,12 @@ impl Rewrite for ast::TyParam {\n                 result.push_str(\" \");\n             }\n \n-            let bounds: String = try_opt!(self.bounds\n-                .iter()\n-                .map(|ty_bound| ty_bound.rewrite(context, shape))\n-                .intersperse(Some(\" + \".to_string()))\n-                .collect());\n+            let bounds: String =\n+                try_opt!(self.bounds\n+                             .iter()\n+                             .map(|ty_bound| ty_bound.rewrite(context, shape))\n+                             .intersperse(Some(\" + \".to_string()))\n+                             .collect());\n \n             result.push_str(&bounds);\n         }\n@@ -514,8 +519,8 @@ impl Rewrite for ast::TyParam {\n             };\n             result.push_str(eq_str);\n             let budget = try_opt!(shape.width.checked_sub(result.len()));\n-            let rewrite =\n-                try_opt!(def.rewrite(context, Shape::legacy(budget, shape.indent + result.len())));\n+            let rewrite = try_opt!(def.rewrite(context,\n+                                               Shape::legacy(budget, shape.indent + result.len())));\n             result.push_str(&rewrite);\n         }\n \n@@ -527,23 +532,24 @@ impl Rewrite for ast::PolyTraitRef {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         if !self.bound_lifetimes.is_empty() {\n             let lifetime_str: String = try_opt!(self.bound_lifetimes\n-                .iter()\n-                .map(|lt| lt.rewrite(context, shape))\n-                .intersperse(Some(\", \".to_string()))\n-                .collect());\n+                                                    .iter()\n+                                                    .map(|lt| lt.rewrite(context, shape))\n+                                                    .intersperse(Some(\", \".to_string()))\n+                                                    .collect());\n \n             // 6 is \"for<> \".len()\n             let extra_offset = lifetime_str.len() + 6;\n             let max_path_width = try_opt!(shape.width.checked_sub(extra_offset));\n             let path_str = try_opt!(self.trait_ref\n-                .rewrite(context,\n-                         Shape::legacy(max_path_width, shape.indent + extra_offset)));\n+                                        .rewrite(context,\n+                                                 Shape::legacy(max_path_width,\n+                                                               shape.indent + extra_offset)));\n \n             Some(if context.config.spaces_within_angle_brackets && lifetime_str.len() > 0 {\n-                format!(\"for< {} > {}\", lifetime_str, path_str)\n-            } else {\n-                format!(\"for<{}> {}\", lifetime_str, path_str)\n-            })\n+                     format!(\"for< {} > {}\", lifetime_str, path_str)\n+                 } else {\n+                     format!(\"for<{}> {}\", lifetime_str, path_str)\n+                 })\n         } else {\n             self.trait_ref.rewrite(context, shape)\n         }\n@@ -572,42 +578,43 @@ impl Rewrite for ast::Ty {\n                 let mut_str = format_mutability(mt.mutbl);\n                 let mut_len = mut_str.len();\n                 Some(match *lifetime {\n-                    Some(ref lifetime) => {\n-                        let lt_budget = try_opt!(shape.width.checked_sub(2 + mut_len));\n-                        let lt_str = try_opt!(lifetime.rewrite(context,\n-                                                               Shape::legacy(lt_budget,\n-                                                                             shape.indent + 2 +\n-                                                                             mut_len)));\n-                        let lt_len = lt_str.len();\n-                        let budget = try_opt!(shape.width.checked_sub(2 + mut_len + lt_len));\n-                        format!(\"&{} {}{}\",\n-                                lt_str,\n-                                mut_str,\n-                                try_opt!(mt.ty\n-                                    .rewrite(context,\n-                                             Shape::legacy(budget,\n-                                                           shape.indent + 2 + mut_len + lt_len))))\n-                    }\n-                    None => {\n-                        let budget = try_opt!(shape.width.checked_sub(1 + mut_len));\n-                        format!(\"&{}{}\",\n-                                mut_str,\n-                                try_opt!(mt.ty.rewrite(context,\n-                                                       Shape::legacy(budget,\n-                                                                     shape.indent + 1 + mut_len))))\n-                    }\n-                })\n+                         Some(ref lifetime) => {\n+                    let lt_budget = try_opt!(shape.width.checked_sub(2 + mut_len));\n+                    let lt_str = try_opt!(lifetime.rewrite(context,\n+                                                           Shape::legacy(lt_budget,\n+                                                                         shape.indent + 2 +\n+                                                                         mut_len)));\n+                    let lt_len = lt_str.len();\n+                    let budget = try_opt!(shape.width.checked_sub(2 + mut_len + lt_len));\n+                    format!(\"&{} {}{}\",\n+                            lt_str,\n+                            mut_str,\n+                            try_opt!(mt.ty\n+                                         .rewrite(context,\n+                                                  Shape::legacy(budget,\n+                                                                shape.indent + 2 + mut_len +\n+                                                                lt_len))))\n+                }\n+                         None => {\n+                    let budget = try_opt!(shape.width.checked_sub(1 + mut_len));\n+                    format!(\"&{}{}\",\n+                            mut_str,\n+                            try_opt!(mt.ty.rewrite(context,\n+                                                   Shape::legacy(budget,\n+                                                                 shape.indent + 1 + mut_len))))\n+                }\n+                     })\n             }\n             // FIXME: we drop any comments here, even though it's a silly place to put\n             // comments.\n             ast::TyKind::Paren(ref ty) => {\n                 let budget = try_opt!(shape.width.checked_sub(2));\n                 ty.rewrite(context, Shape::legacy(budget, shape.indent + 1))\n                     .map(|ty_str| if context.config.spaces_within_parens {\n-                        format!(\"( {} )\", ty_str)\n-                    } else {\n-                        format!(\"({})\", ty_str)\n-                    })\n+                             format!(\"( {} )\", ty_str)\n+                         } else {\n+                             format!(\"({})\", ty_str)\n+                         })\n             }\n             ast::TyKind::Slice(ref ty) => {\n                 let budget = if context.config.spaces_within_square_brackets {\n@@ -617,10 +624,10 @@ impl Rewrite for ast::Ty {\n                 };\n                 ty.rewrite(context, Shape::legacy(budget, shape.indent + 1))\n                     .map(|ty_str| if context.config.spaces_within_square_brackets {\n-                        format!(\"[ {} ]\", ty_str)\n-                    } else {\n-                        format!(\"[{}]\", ty_str)\n-                    })\n+                             format!(\"[ {} ]\", ty_str)\n+                         } else {\n+                             format!(\"[{}]\", ty_str)\n+                         })\n             }\n             ast::TyKind::Tup(ref items) => {\n                 rewrite_tuple(context, items.iter().map(|x| &**x), self.span, shape)\n@@ -666,13 +673,13 @@ fn rewrite_bare_fn(bare_fn: &ast::BareFnTy,\n         // This doesn't work out so nicely for mutliline situation with lots of\n         // rightward drift. If that is a problem, we could use the list stuff.\n         result.push_str(&try_opt!(bare_fn.lifetimes\n-            .iter()\n-            .map(|l| {\n-                l.rewrite(context,\n-                          Shape::legacy(try_opt!(shape.width.checked_sub(6)), shape.indent + 4))\n-            })\n-            .intersperse(Some(\", \".to_string()))\n-            .collect::<Option<String>>()));\n+                                      .iter()\n+                                      .map(|l| {\n+            l.rewrite(context,\n+                      Shape::legacy(try_opt!(shape.width.checked_sub(6)), shape.indent + 4))\n+        })\n+                                      .intersperse(Some(\", \".to_string()))\n+                                      .collect::<Option<String>>()));\n         result.push_str(\"> \");\n     }\n "}, {"sha": "634248f1b65a679c965e71866cc2328c1f0066b1", "filename": "src/visitor.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9eb78a33335b83073c90dd8b065c31f1fb958dcc/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb78a33335b83073c90dd8b065c31f1fb958dcc/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=9eb78a33335b83073c90dd8b065c31f1fb958dcc", "patch": "@@ -264,10 +264,10 @@ impl<'a> FmtVisitor<'a> {\n                                            item.span,\n                                            indent,\n                                            None)\n-                        .map(|s| match *def {\n-                            ast::VariantData::Tuple(..) => s + \";\",\n-                            _ => s,\n-                        })\n+                            .map(|s| match *def {\n+                                     ast::VariantData::Tuple(..) => s + \";\",\n+                                     _ => s,\n+                                 })\n                 };\n                 self.push_rewrite(item.span, rewrite);\n             }"}]}