{"sha": "b82d332c52dde1680b21c0281f08cc5f30edc082", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4MmQzMzJjNTJkZGUxNjgwYjIxYzAyODFmMDhjYzVmMzBlZGMwODI=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-07-14T11:23:15Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-07-16T10:53:01Z"}, "message": "Separate off BTreeMap support functions and loose their irrelevant bounds", "tree": {"sha": "5e0e3013dcc78977e7faee3f8e8b5cdcda94833d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e0e3013dcc78977e7faee3f8e8b5cdcda94833d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b82d332c52dde1680b21c0281f08cc5f30edc082", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b82d332c52dde1680b21c0281f08cc5f30edc082", "html_url": "https://github.com/rust-lang/rust/commit/b82d332c52dde1680b21c0281f08cc5f30edc082", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b82d332c52dde1680b21c0281f08cc5f30edc082/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca253cab3689c0d525dabda10e35c469839b2c4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca253cab3689c0d525dabda10e35c469839b2c4b", "html_url": "https://github.com/rust-lang/rust/commit/ca253cab3689c0d525dabda10e35c469839b2c4b"}], "stats": {"total": 120, "additions": 61, "deletions": 59}, "files": [{"sha": "bf5748739d470422e0d110770812baf6bc9a1bbc", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 61, "deletions": 59, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/b82d332c52dde1680b21c0281f08cc5f30edc082/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b82d332c52dde1680b21c0281f08cc5f30edc082/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=b82d332c52dde1680b21c0281f08cc5f30edc082", "patch": "@@ -1211,8 +1211,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n             }\n         }\n \n-        Self::fix_right_border(left_root);\n-        Self::fix_left_border(right_root);\n+        left_root.fix_right_border();\n+        right_root.fix_left_border();\n \n         if left_root.height() < right_root.height() {\n             self.recalc_length();\n@@ -1296,63 +1296,6 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n         self.length = dfs(self.root.as_ref().unwrap().as_ref());\n     }\n-\n-    /// Removes empty levels on the top.\n-    fn fix_top(root: &mut node::Root<K, V>) {\n-        while root.height() > 0 && root.as_ref().len() == 0 {\n-            root.pop_level();\n-        }\n-    }\n-\n-    fn fix_right_border(root: &mut node::Root<K, V>) {\n-        Self::fix_top(root);\n-\n-        {\n-            let mut cur_node = root.as_mut();\n-\n-            while let Internal(node) = cur_node.force() {\n-                let mut last_kv = node.last_kv();\n-\n-                if last_kv.can_merge() {\n-                    cur_node = last_kv.merge().descend();\n-                } else {\n-                    let right_len = last_kv.reborrow().right_edge().descend().len();\n-                    // `MINLEN + 1` to avoid readjust if merge happens on the next level.\n-                    if right_len < node::MIN_LEN + 1 {\n-                        last_kv.bulk_steal_left(node::MIN_LEN + 1 - right_len);\n-                    }\n-                    cur_node = last_kv.right_edge().descend();\n-                }\n-            }\n-        }\n-\n-        Self::fix_top(root);\n-    }\n-\n-    /// The symmetric clone of `fix_right_border`.\n-    fn fix_left_border(root: &mut node::Root<K, V>) {\n-        Self::fix_top(root);\n-\n-        {\n-            let mut cur_node = root.as_mut();\n-\n-            while let Internal(node) = cur_node.force() {\n-                let mut first_kv = node.first_kv();\n-\n-                if first_kv.can_merge() {\n-                    cur_node = first_kv.merge().descend();\n-                } else {\n-                    let left_len = first_kv.reborrow().left_edge().descend().len();\n-                    if left_len < node::MIN_LEN + 1 {\n-                        first_kv.bulk_steal_right(node::MIN_LEN + 1 - left_len);\n-                    }\n-                    cur_node = first_kv.left_edge().descend();\n-                }\n-            }\n-        }\n-\n-        Self::fix_top(root);\n-    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2814,6 +2757,65 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n     }\n }\n \n+impl<K, V> node::Root<K, V> {\n+    /// Removes empty levels on the top, but keep an empty leaf if the entire tree is empty.\n+    fn fix_top(&mut self) {\n+        while self.height() > 0 && self.as_ref().len() == 0 {\n+            self.pop_level();\n+        }\n+    }\n+\n+    fn fix_right_border(&mut self) {\n+        self.fix_top();\n+\n+        {\n+            let mut cur_node = self.as_mut();\n+\n+            while let Internal(node) = cur_node.force() {\n+                let mut last_kv = node.last_kv();\n+\n+                if last_kv.can_merge() {\n+                    cur_node = last_kv.merge().descend();\n+                } else {\n+                    let right_len = last_kv.reborrow().right_edge().descend().len();\n+                    // `MINLEN + 1` to avoid readjust if merge happens on the next level.\n+                    if right_len < node::MIN_LEN + 1 {\n+                        last_kv.bulk_steal_left(node::MIN_LEN + 1 - right_len);\n+                    }\n+                    cur_node = last_kv.right_edge().descend();\n+                }\n+            }\n+        }\n+\n+        self.fix_top();\n+    }\n+\n+    /// The symmetric clone of `fix_right_border`.\n+    fn fix_left_border(&mut self) {\n+        self.fix_top();\n+\n+        {\n+            let mut cur_node = self.as_mut();\n+\n+            while let Internal(node) = cur_node.force() {\n+                let mut first_kv = node.first_kv();\n+\n+                if first_kv.can_merge() {\n+                    cur_node = first_kv.merge().descend();\n+                } else {\n+                    let left_len = first_kv.reborrow().left_edge().descend().len();\n+                    if left_len < node::MIN_LEN + 1 {\n+                        first_kv.bulk_steal_right(node::MIN_LEN + 1 - left_len);\n+                    }\n+                    cur_node = first_kv.left_edge().descend();\n+                }\n+            }\n+        }\n+\n+        self.fix_top();\n+    }\n+}\n+\n enum UnderflowResult<'a, K, V> {\n     AtRoot,\n     Merged(Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::Edge>, bool, usize),"}]}