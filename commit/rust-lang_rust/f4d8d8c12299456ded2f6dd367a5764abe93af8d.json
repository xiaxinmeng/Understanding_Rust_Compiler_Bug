{"sha": "f4d8d8c12299456ded2f6dd367a5764abe93af8d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0ZDhkOGMxMjI5OTQ1NmRlZDJmNmRkMzY3YTU3NjRhYmU5M2FmOGQ=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-09-30T17:37:22Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-09-30T17:37:22Z"}, "message": "trans::build: Change @mut Block to &Block or &mut Block\n\nUse &mut Block and &Block references where possible in the builder\nfunctions in trans::build.\n\n@mut Block remains in a few functions where I could not (not yet at\nleast) track down the runtime borrowck failures.", "tree": {"sha": "007b8a61e229bab8ba188788ec5fce35951b6c9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/007b8a61e229bab8ba188788ec5fce35951b6c9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4d8d8c12299456ded2f6dd367a5764abe93af8d", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4d8d8c12299456ded2f6dd367a5764abe93af8d", "html_url": "https://github.com/rust-lang/rust/commit/f4d8d8c12299456ded2f6dd367a5764abe93af8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4d8d8c12299456ded2f6dd367a5764abe93af8d/comments", "author": null, "committer": null, "parents": [{"sha": "b88517ec93933ddefe28f793f90b072e9934c198", "url": "https://api.github.com/repos/rust-lang/rust/commits/b88517ec93933ddefe28f793f90b072e9934c198", "html_url": "https://github.com/rust-lang/rust/commit/b88517ec93933ddefe28f793f90b072e9934c198"}], "stats": {"total": 245, "additions": 129, "deletions": 116}, "files": [{"sha": "2af399f23d752a6d6b72b87b31efc137eb4860ff", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f4d8d8c12299456ded2f6dd367a5764abe93af8d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4d8d8c12299456ded2f6dd367a5764abe93af8d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=f4d8d8c12299456ded2f6dd367a5764abe93af8d", "patch": "@@ -1407,7 +1407,10 @@ pub fn cleanup_and_leave(bcx: @mut Block,\n     }\n     match leave {\n       Some(target) => Br(bcx, target),\n-      None => { Resume(bcx, Load(bcx, bcx.fcx.personality.unwrap())); }\n+      None => {\n+          let ll_load = Load(bcx, bcx.fcx.personality.unwrap());\n+          Resume(bcx, ll_load);\n+      }\n     }\n }\n "}, {"sha": "1cad4f8a93f0022135cbce642f3504ad691239a8", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 100, "deletions": 100, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/f4d8d8c12299456ded2f6dd367a5764abe93af8d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4d8d8c12299456ded2f6dd367a5764abe93af8d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=f4d8d8c12299456ded2f6dd367a5764abe93af8d", "patch": "@@ -23,17 +23,17 @@ use middle::trans::type_::Type;\n use std::cast;\n use std::libc::{c_uint, c_ulonglong, c_char};\n \n-pub fn terminate(cx: @mut Block, _: &str) {\n+pub fn terminate(cx: &mut Block, _: &str) {\n     cx.terminated = true;\n }\n \n-pub fn check_not_terminated(cx: @mut Block) {\n+pub fn check_not_terminated(cx: &Block) {\n     if cx.terminated {\n         fail!(\"already terminated!\");\n     }\n }\n \n-pub fn B(cx: @mut Block) -> Builder {\n+pub fn B(cx: &Block) -> Builder {\n     let b = cx.fcx.ccx.builder();\n     b.position_at_end(cx.llbb);\n     b\n@@ -47,7 +47,7 @@ pub fn B(cx: @mut Block) -> Builder {\n // for (fail/break/return statements, call to diverging functions, etc), and\n // further instructions to the block should simply be ignored.\n \n-pub fn RetVoid(cx: @mut Block) {\n+pub fn RetVoid(cx: &mut Block) {\n     if cx.unreachable { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"RetVoid\");\n@@ -83,7 +83,7 @@ pub fn CondBr(cx: @mut Block, If: ValueRef, Then: BasicBlockRef,\n     B(cx).cond_br(If, Then, Else);\n }\n \n-pub fn Switch(cx: @mut Block, V: ValueRef, Else: BasicBlockRef, NumCases: uint)\n+pub fn Switch(cx: &mut Block, V: ValueRef, Else: BasicBlockRef, NumCases: uint)\n     -> ValueRef {\n     if cx.unreachable { return _Undef(V); }\n     check_not_terminated(cx);\n@@ -98,7 +98,7 @@ pub fn AddCase(S: ValueRef, OnVal: ValueRef, Dest: BasicBlockRef) {\n     }\n }\n \n-pub fn IndirectBr(cx: @mut Block, Addr: ValueRef, NumDests: uint) {\n+pub fn IndirectBr(cx: &mut Block, Addr: ValueRef, NumDests: uint) {\n     if cx.unreachable { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"IndirectBr\");\n@@ -123,7 +123,7 @@ pub fn Invoke(cx: @mut Block,\n     B(cx).invoke(Fn, Args, Then, Catch, attributes)\n }\n \n-pub fn Unreachable(cx: @mut Block) {\n+pub fn Unreachable(cx: &mut Block) {\n     if cx.unreachable { return; }\n     cx.unreachable = true;\n     if !cx.terminated {\n@@ -138,177 +138,177 @@ pub fn _Undef(val: ValueRef) -> ValueRef {\n }\n \n /* Arithmetic */\n-pub fn Add(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn Add(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).add(LHS, RHS)\n }\n \n-pub fn NSWAdd(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn NSWAdd(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).nswadd(LHS, RHS)\n }\n \n-pub fn NUWAdd(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn NUWAdd(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).nuwadd(LHS, RHS)\n }\n \n-pub fn FAdd(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn FAdd(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).fadd(LHS, RHS)\n }\n \n-pub fn Sub(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn Sub(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).sub(LHS, RHS)\n }\n \n-pub fn NSWSub(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn NSWSub(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).nswsub(LHS, RHS)\n }\n \n-pub fn NUWSub(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn NUWSub(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).nuwsub(LHS, RHS)\n }\n \n-pub fn FSub(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn FSub(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).fsub(LHS, RHS)\n }\n \n-pub fn Mul(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn Mul(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).mul(LHS, RHS)\n }\n \n-pub fn NSWMul(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn NSWMul(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).nswmul(LHS, RHS)\n }\n \n-pub fn NUWMul(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn NUWMul(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).nuwmul(LHS, RHS)\n }\n \n-pub fn FMul(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn FMul(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).fmul(LHS, RHS)\n }\n \n-pub fn UDiv(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn UDiv(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).udiv(LHS, RHS)\n }\n \n-pub fn SDiv(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn SDiv(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).sdiv(LHS, RHS)\n }\n \n-pub fn ExactSDiv(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn ExactSDiv(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).exactsdiv(LHS, RHS)\n }\n \n-pub fn FDiv(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn FDiv(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).fdiv(LHS, RHS)\n }\n \n-pub fn URem(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn URem(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).urem(LHS, RHS)\n }\n \n-pub fn SRem(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn SRem(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).srem(LHS, RHS)\n }\n \n-pub fn FRem(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn FRem(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).frem(LHS, RHS)\n }\n \n-pub fn Shl(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn Shl(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).shl(LHS, RHS)\n }\n \n-pub fn LShr(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn LShr(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).lshr(LHS, RHS)\n }\n \n-pub fn AShr(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn AShr(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).ashr(LHS, RHS)\n }\n \n-pub fn And(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn And(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).and(LHS, RHS)\n }\n \n-pub fn Or(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn Or(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).or(LHS, RHS)\n }\n \n-pub fn Xor(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn Xor(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).xor(LHS, RHS)\n }\n \n-pub fn BinOp(cx: @mut Block, Op: Opcode, LHS: ValueRef, RHS: ValueRef)\n+pub fn BinOp(cx: &Block, Op: Opcode, LHS: ValueRef, RHS: ValueRef)\n           -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n     B(cx).binop(Op, LHS, RHS)\n }\n \n-pub fn Neg(cx: @mut Block, V: ValueRef) -> ValueRef {\n+pub fn Neg(cx: &Block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(V); }\n     B(cx).neg(V)\n }\n \n-pub fn NSWNeg(cx: @mut Block, V: ValueRef) -> ValueRef {\n+pub fn NSWNeg(cx: &Block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(V); }\n     B(cx).nswneg(V)\n }\n \n-pub fn NUWNeg(cx: @mut Block, V: ValueRef) -> ValueRef {\n+pub fn NUWNeg(cx: &Block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(V); }\n     B(cx).nuwneg(V)\n }\n-pub fn FNeg(cx: @mut Block, V: ValueRef) -> ValueRef {\n+pub fn FNeg(cx: &Block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(V); }\n     B(cx).fneg(V)\n }\n \n-pub fn Not(cx: @mut Block, V: ValueRef) -> ValueRef {\n+pub fn Not(cx: &Block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(V); }\n     B(cx).not(V)\n }\n \n /* Memory */\n-pub fn Malloc(cx: @mut Block, Ty: Type) -> ValueRef {\n+pub fn Malloc(cx: &Block, Ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n         B(cx).malloc(Ty)\n     }\n }\n \n-pub fn ArrayMalloc(cx: @mut Block, Ty: Type, Val: ValueRef) -> ValueRef {\n+pub fn ArrayMalloc(cx: &Block, Ty: Type, Val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n         B(cx).array_malloc(Ty, Val)\n     }\n }\n \n-pub fn Alloca(cx: @mut Block, Ty: Type, name: &str) -> ValueRef {\n+pub fn Alloca(cx: &Block, Ty: Type, name: &str) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }\n         let b = cx.fcx.ccx.builder();\n@@ -317,7 +317,7 @@ pub fn Alloca(cx: @mut Block, Ty: Type, name: &str) -> ValueRef {\n     }\n }\n \n-pub fn ArrayAlloca(cx: @mut Block, Ty: Type, Val: ValueRef) -> ValueRef {\n+pub fn ArrayAlloca(cx: &Block, Ty: Type, Val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }\n         let b = cx.fcx.ccx.builder();\n@@ -326,12 +326,12 @@ pub fn ArrayAlloca(cx: @mut Block, Ty: Type, Val: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn Free(cx: @mut Block, PointerVal: ValueRef) {\n+pub fn Free(cx: &Block, PointerVal: ValueRef) {\n     if cx.unreachable { return; }\n     B(cx).free(PointerVal)\n }\n \n-pub fn Load(cx: @mut Block, PointerVal: ValueRef) -> ValueRef {\n+pub fn Load(cx: &Block, PointerVal: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         if cx.unreachable {\n@@ -347,7 +347,7 @@ pub fn Load(cx: @mut Block, PointerVal: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn AtomicLoad(cx: @mut Block, PointerVal: ValueRef, order: AtomicOrdering) -> ValueRef {\n+pub fn AtomicLoad(cx: &Block, PointerVal: ValueRef, order: AtomicOrdering) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         if cx.unreachable {\n@@ -358,7 +358,7 @@ pub fn AtomicLoad(cx: @mut Block, PointerVal: ValueRef, order: AtomicOrdering) -\n }\n \n \n-pub fn LoadRangeAssert(cx: @mut Block, PointerVal: ValueRef, lo: c_ulonglong,\n+pub fn LoadRangeAssert(cx: &Block, PointerVal: ValueRef, lo: c_ulonglong,\n                        hi: c_ulonglong, signed: lib::llvm::Bool) -> ValueRef {\n     if cx.unreachable {\n         let ccx = cx.fcx.ccx;\n@@ -376,17 +376,17 @@ pub fn LoadRangeAssert(cx: @mut Block, PointerVal: ValueRef, lo: c_ulonglong,\n     }\n }\n \n-pub fn Store(cx: @mut Block, Val: ValueRef, Ptr: ValueRef) {\n+pub fn Store(cx: &Block, Val: ValueRef, Ptr: ValueRef) {\n     if cx.unreachable { return; }\n     B(cx).store(Val, Ptr)\n }\n \n-pub fn AtomicStore(cx: @mut Block, Val: ValueRef, Ptr: ValueRef, order: AtomicOrdering) {\n+pub fn AtomicStore(cx: &Block, Val: ValueRef, Ptr: ValueRef, order: AtomicOrdering) {\n     if cx.unreachable { return; }\n     B(cx).atomic_store(Val, Ptr, order)\n }\n \n-pub fn GEP(cx: @mut Block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n+pub fn GEP(cx: &Block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n         B(cx).gep(Pointer, Indices)\n@@ -396,170 +396,170 @@ pub fn GEP(cx: @mut Block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef\n // Simple wrapper around GEP that takes an array of ints and wraps them\n // in C_i32()\n #[inline]\n-pub fn GEPi(cx: @mut Block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n+pub fn GEPi(cx: &Block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n         B(cx).gepi(base, ixs)\n     }\n }\n \n-pub fn InBoundsGEP(cx: @mut Block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n+pub fn InBoundsGEP(cx: &Block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n         B(cx).inbounds_gep(Pointer, Indices)\n     }\n }\n \n-pub fn StructGEP(cx: @mut Block, Pointer: ValueRef, Idx: uint) -> ValueRef {\n+pub fn StructGEP(cx: &Block, Pointer: ValueRef, Idx: uint) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n         B(cx).struct_gep(Pointer, Idx)\n     }\n }\n \n-pub fn GlobalString(cx: @mut Block, _Str: *c_char) -> ValueRef {\n+pub fn GlobalString(cx: &Block, _Str: *c_char) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n         B(cx).global_string(_Str)\n     }\n }\n \n-pub fn GlobalStringPtr(cx: @mut Block, _Str: *c_char) -> ValueRef {\n+pub fn GlobalStringPtr(cx: &Block, _Str: *c_char) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n         B(cx).global_string_ptr(_Str)\n     }\n }\n \n /* Casts */\n-pub fn Trunc(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn Trunc(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).trunc(Val, DestTy)\n     }\n }\n \n-pub fn ZExt(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn ZExt(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).zext(Val, DestTy)\n     }\n }\n \n-pub fn SExt(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn SExt(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).sext(Val, DestTy)\n     }\n }\n \n-pub fn FPToUI(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn FPToUI(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).fptoui(Val, DestTy)\n     }\n }\n \n-pub fn FPToSI(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn FPToSI(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).fptosi(Val, DestTy)\n     }\n }\n \n-pub fn UIToFP(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn UIToFP(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).uitofp(Val, DestTy)\n     }\n }\n \n-pub fn SIToFP(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn SIToFP(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).sitofp(Val, DestTy)\n     }\n }\n \n-pub fn FPTrunc(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn FPTrunc(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).fptrunc(Val, DestTy)\n     }\n }\n \n-pub fn FPExt(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn FPExt(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).fpext(Val, DestTy)\n     }\n }\n \n-pub fn PtrToInt(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn PtrToInt(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).ptrtoint(Val, DestTy)\n     }\n }\n \n-pub fn IntToPtr(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn IntToPtr(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).inttoptr(Val, DestTy)\n     }\n }\n \n-pub fn BitCast(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn BitCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).bitcast(Val, DestTy)\n     }\n }\n \n-pub fn ZExtOrBitCast(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn ZExtOrBitCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).zext_or_bitcast(Val, DestTy)\n     }\n }\n \n-pub fn SExtOrBitCast(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn SExtOrBitCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).sext_or_bitcast(Val, DestTy)\n     }\n }\n \n-pub fn TruncOrBitCast(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn TruncOrBitCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).trunc_or_bitcast(Val, DestTy)\n     }\n }\n \n-pub fn Cast(cx: @mut Block, Op: Opcode, Val: ValueRef, DestTy: Type, _: *u8)\n+pub fn Cast(cx: &Block, Op: Opcode, Val: ValueRef, DestTy: Type, _: *u8)\n      -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).cast(Op, Val, DestTy)\n     }\n }\n \n-pub fn PointerCast(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn PointerCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).pointercast(Val, DestTy)\n     }\n }\n \n-pub fn IntCast(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn IntCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).intcast(Val, DestTy)\n     }\n }\n \n-pub fn FPCast(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn FPCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         B(cx).fpcast(Val, DestTy)\n@@ -568,15 +568,15 @@ pub fn FPCast(cx: @mut Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n \n \n /* Comparisons */\n-pub fn ICmp(cx: @mut Block, Op: IntPredicate, LHS: ValueRef, RHS: ValueRef)\n+pub fn ICmp(cx: &Block, Op: IntPredicate, LHS: ValueRef, RHS: ValueRef)\n      -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n         B(cx).icmp(Op, LHS, RHS)\n     }\n }\n \n-pub fn FCmp(cx: @mut Block, Op: RealPredicate, LHS: ValueRef, RHS: ValueRef)\n+pub fn FCmp(cx: &Block, Op: RealPredicate, LHS: ValueRef, RHS: ValueRef)\n      -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n@@ -585,14 +585,14 @@ pub fn FCmp(cx: @mut Block, Op: RealPredicate, LHS: ValueRef, RHS: ValueRef)\n }\n \n /* Miscellaneous instructions */\n-pub fn EmptyPhi(cx: @mut Block, Ty: Type) -> ValueRef {\n+pub fn EmptyPhi(cx: &Block, Ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.to_ref()); }\n         B(cx).empty_phi(Ty)\n     }\n }\n \n-pub fn Phi(cx: @mut Block, Ty: Type, vals: &[ValueRef], bbs: &[BasicBlockRef]) -> ValueRef {\n+pub fn Phi(cx: &Block, Ty: Type, vals: &[ValueRef], bbs: &[BasicBlockRef]) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.to_ref()); }\n         B(cx).phi(Ty, vals, bbs)\n@@ -608,7 +608,7 @@ pub fn AddIncomingToPhi(phi: ValueRef, val: ValueRef, bb: BasicBlockRef) {\n     }\n }\n \n-pub fn _UndefReturn(cx: @mut Block, Fn: ValueRef) -> ValueRef {\n+pub fn _UndefReturn(cx: &Block, Fn: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         let ty = val_ty(Fn);\n@@ -622,129 +622,129 @@ pub fn _UndefReturn(cx: @mut Block, Fn: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn add_span_comment(cx: @mut Block, sp: Span, text: &str) {\n+pub fn add_span_comment(cx: &Block, sp: Span, text: &str) {\n     B(cx).add_span_comment(sp, text)\n }\n \n-pub fn add_comment(cx: @mut Block, text: &str) {\n+pub fn add_comment(cx: &Block, text: &str) {\n     B(cx).add_comment(text)\n }\n \n-pub fn InlineAsmCall(cx: @mut Block, asm: *c_char, cons: *c_char,\n+pub fn InlineAsmCall(cx: &Block, asm: *c_char, cons: *c_char,\n                      inputs: &[ValueRef], output: Type,\n                      volatile: bool, alignstack: bool,\n                      dia: AsmDialect) -> ValueRef {\n     B(cx).inline_asm_call(asm, cons, inputs, output, volatile, alignstack, dia)\n }\n \n-pub fn Call(cx: @mut Block, Fn: ValueRef, Args: &[ValueRef],\n+pub fn Call(cx: &Block, Fn: ValueRef, Args: &[ValueRef],\n             attributes: &[(uint, lib::llvm::Attribute)]) -> ValueRef {\n     if cx.unreachable { return _UndefReturn(cx, Fn); }\n     B(cx).call(Fn, Args, attributes)\n }\n \n-pub fn CallWithConv(cx: @mut Block, Fn: ValueRef, Args: &[ValueRef], Conv: CallConv,\n+pub fn CallWithConv(cx: &Block, Fn: ValueRef, Args: &[ValueRef], Conv: CallConv,\n                     attributes: &[(uint, lib::llvm::Attribute)]) -> ValueRef {\n     if cx.unreachable { return _UndefReturn(cx, Fn); }\n     B(cx).call_with_conv(Fn, Args, Conv, attributes)\n }\n \n-pub fn AtomicFence(cx: @mut Block, order: AtomicOrdering) {\n+pub fn AtomicFence(cx: &Block, order: AtomicOrdering) {\n     if cx.unreachable { return; }\n     B(cx).atomic_fence(order)\n }\n \n-pub fn Select(cx: @mut Block, If: ValueRef, Then: ValueRef, Else: ValueRef) -> ValueRef {\n+pub fn Select(cx: &Block, If: ValueRef, Then: ValueRef, Else: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(Then); }\n     B(cx).select(If, Then, Else)\n }\n \n-pub fn VAArg(cx: @mut Block, list: ValueRef, Ty: Type) -> ValueRef {\n+pub fn VAArg(cx: &Block, list: ValueRef, Ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.to_ref()); }\n         B(cx).va_arg(list, Ty)\n     }\n }\n \n-pub fn ExtractElement(cx: @mut Block, VecVal: ValueRef, Index: ValueRef) -> ValueRef {\n+pub fn ExtractElement(cx: &Block, VecVal: ValueRef, Index: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         B(cx).extract_element(VecVal, Index)\n     }\n }\n \n-pub fn InsertElement(cx: @mut Block, VecVal: ValueRef, EltVal: ValueRef,\n+pub fn InsertElement(cx: &Block, VecVal: ValueRef, EltVal: ValueRef,\n                      Index: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         B(cx).insert_element(VecVal, EltVal, Index)\n     }\n }\n \n-pub fn ShuffleVector(cx: @mut Block, V1: ValueRef, V2: ValueRef,\n+pub fn ShuffleVector(cx: &Block, V1: ValueRef, V2: ValueRef,\n                      Mask: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         B(cx).shuffle_vector(V1, V2, Mask)\n     }\n }\n \n-pub fn VectorSplat(cx: @mut Block, NumElts: uint, EltVal: ValueRef) -> ValueRef {\n+pub fn VectorSplat(cx: &Block, NumElts: uint, EltVal: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         B(cx).vector_splat(NumElts, EltVal)\n     }\n }\n \n-pub fn ExtractValue(cx: @mut Block, AggVal: ValueRef, Index: uint) -> ValueRef {\n+pub fn ExtractValue(cx: &Block, AggVal: ValueRef, Index: uint) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         B(cx).extract_value(AggVal, Index)\n     }\n }\n \n-pub fn InsertValue(cx: @mut Block, AggVal: ValueRef, EltVal: ValueRef, Index: uint) -> ValueRef {\n+pub fn InsertValue(cx: &Block, AggVal: ValueRef, EltVal: ValueRef, Index: uint) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         B(cx).insert_value(AggVal, EltVal, Index)\n     }\n }\n \n-pub fn IsNull(cx: @mut Block, Val: ValueRef) -> ValueRef {\n+pub fn IsNull(cx: &Block, Val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n         B(cx).is_null(Val)\n     }\n }\n \n-pub fn IsNotNull(cx: @mut Block, Val: ValueRef) -> ValueRef {\n+pub fn IsNotNull(cx: &Block, Val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n         B(cx).is_not_null(Val)\n     }\n }\n \n-pub fn PtrDiff(cx: @mut Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn PtrDiff(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         if cx.unreachable { return llvm::LLVMGetUndef(ccx.int_type.to_ref()); }\n         B(cx).ptrdiff(LHS, RHS)\n     }\n }\n \n-pub fn Trap(cx: @mut Block) {\n+pub fn Trap(cx: &Block) {\n     if cx.unreachable { return; }\n     B(cx).trap();\n }\n \n-pub fn LandingPad(cx: @mut Block, Ty: Type, PersFn: ValueRef,\n+pub fn LandingPad(cx: &Block, Ty: Type, PersFn: ValueRef,\n                   NumClauses: uint) -> ValueRef {\n     check_not_terminated(cx);\n     assert!(!cx.unreachable);\n     B(cx).landing_pad(Ty, PersFn, NumClauses)\n }\n \n-pub fn SetCleanup(cx: @mut Block, LandingPad: ValueRef) {\n+pub fn SetCleanup(cx: &Block, LandingPad: ValueRef) {\n     B(cx).set_cleanup(LandingPad)\n }\n \n@@ -755,12 +755,12 @@ pub fn Resume(cx: @mut Block, Exn: ValueRef) -> ValueRef {\n }\n \n // Atomic Operations\n-pub fn AtomicCmpXchg(cx: @mut Block, dst: ValueRef,\n+pub fn AtomicCmpXchg(cx: &Block, dst: ValueRef,\n                      cmp: ValueRef, src: ValueRef,\n                      order: AtomicOrdering) -> ValueRef {\n     B(cx).atomic_cmpxchg(dst, cmp, src, order)\n }\n-pub fn AtomicRMW(cx: @mut Block, op: AtomicBinOp,\n+pub fn AtomicRMW(cx: &Block, op: AtomicBinOp,\n                  dst: ValueRef, src: ValueRef,\n                  order: AtomicOrdering) -> ValueRef {\n     B(cx).atomic_rmw(op, dst, src, order)"}, {"sha": "322050331a266765eb40933dfbacc4a5298b4ecf", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f4d8d8c12299456ded2f6dd367a5764abe93af8d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4d8d8c12299456ded2f6dd367a5764abe93af8d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=f4d8d8c12299456ded2f6dd367a5764abe93af8d", "patch": "@@ -550,7 +550,7 @@ pub fn revoke_clean(cx: @mut Block, val: ValueRef) {\n     }\n }\n \n-pub fn block_cleanups(bcx: @mut Block) -> ~[cleanup] {\n+pub fn block_cleanups(bcx: &mut Block) -> ~[cleanup] {\n     match bcx.scope {\n        None  => ~[],\n        Some(inf) => inf.cleanups.clone(),\n@@ -1061,7 +1061,7 @@ pub fn path_str(sess: session::Session, p: &[path_elt]) -> ~str {\n     r\n }\n \n-pub fn monomorphize_type(bcx: @mut Block, t: ty::t) -> ty::t {\n+pub fn monomorphize_type(bcx: &mut Block, t: ty::t) -> ty::t {\n     match bcx.fcx.param_substs {\n         Some(substs) => {\n             ty::subst_tps(bcx.tcx(), substs.tys, substs.self_ty, t)\n@@ -1074,23 +1074,23 @@ pub fn monomorphize_type(bcx: @mut Block, t: ty::t) -> ty::t {\n     }\n }\n \n-pub fn node_id_type(bcx: @mut Block, id: ast::NodeId) -> ty::t {\n+pub fn node_id_type(bcx: &mut Block, id: ast::NodeId) -> ty::t {\n     let tcx = bcx.tcx();\n     let t = ty::node_id_to_type(tcx, id);\n     monomorphize_type(bcx, t)\n }\n \n-pub fn expr_ty(bcx: @mut Block, ex: &ast::Expr) -> ty::t {\n+pub fn expr_ty(bcx: &mut Block, ex: &ast::Expr) -> ty::t {\n     node_id_type(bcx, ex.id)\n }\n \n-pub fn expr_ty_adjusted(bcx: @mut Block, ex: &ast::Expr) -> ty::t {\n+pub fn expr_ty_adjusted(bcx: &mut Block, ex: &ast::Expr) -> ty::t {\n     let tcx = bcx.tcx();\n     let t = ty::expr_ty_adjusted(tcx, ex);\n     monomorphize_type(bcx, t)\n }\n \n-pub fn node_id_type_params(bcx: @mut Block, id: ast::NodeId) -> ~[ty::t] {\n+pub fn node_id_type_params(bcx: &mut Block, id: ast::NodeId) -> ~[ty::t] {\n     let tcx = bcx.tcx();\n     let params = ty::node_id_to_type_params(tcx, id);\n "}, {"sha": "a10f53ebcbc846788a540f44783c9eac91e5dacc", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4d8d8c12299456ded2f6dd367a5764abe93af8d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4d8d8c12299456ded2f6dd367a5764abe93af8d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=f4d8d8c12299456ded2f6dd367a5764abe93af8d", "patch": "@@ -552,12 +552,14 @@ pub fn decr_refcnt_maybe_free(bcx: @mut Block, box_ptr: ValueRef,\n     let decr_bcx = sub_block(bcx, \"decr\");\n     let free_bcx = sub_block(decr_bcx, \"free\");\n     let next_bcx = sub_block(bcx, \"next\");\n-    CondBr(bcx, IsNotNull(bcx, box_ptr), decr_bcx.llbb, next_bcx.llbb);\n+    let llnotnull = IsNotNull(bcx, box_ptr);\n+    CondBr(bcx, llnotnull, decr_bcx.llbb, next_bcx.llbb);\n \n     let rc_ptr = GEPi(decr_bcx, box_ptr, [0u, abi::box_field_refcnt]);\n     let rc = Sub(decr_bcx, Load(decr_bcx, rc_ptr), C_int(ccx, 1));\n     Store(decr_bcx, rc, rc_ptr);\n-    CondBr(decr_bcx, IsNull(decr_bcx, rc), free_bcx.llbb, next_bcx.llbb);\n+    let llisnull = IsNull(decr_bcx, rc);\n+    CondBr(decr_bcx, llisnull, free_bcx.llbb, next_bcx.llbb);\n \n     let free_bcx = match box_ptr_ptr {\n         Some(p) => free_ty(free_bcx, p, t),"}, {"sha": "04ffb393b5e4ed595f15c69018e135015465f10b", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f4d8d8c12299456ded2f6dd367a5764abe93af8d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4d8d8c12299456ded2f6dd367a5764abe93af8d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=f4d8d8c12299456ded2f6dd367a5764abe93af8d", "patch": "@@ -49,7 +49,8 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             args[i] = get_param(bcx.fcx.llfn, first_real_arg + i);\n         }\n         let llfn = bcx.ccx().intrinsics.get_copy(&name);\n-        Ret(bcx, Call(bcx, llfn, args.slice(0, num_args), []));\n+        let llcall = Call(bcx, llfn, args.slice(0, num_args), []);\n+        Ret(bcx, llcall);\n     }\n \n     fn with_overflow_instrinsic(bcx: @mut Block, name: &'static str) {\n@@ -116,7 +117,8 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         let x = get_param(bcx.fcx.llfn, bcx.fcx.arg_pos(0u));\n         let y = C_i1(false);\n         let llfn = bcx.ccx().intrinsics.get_copy(&name);\n-        Ret(bcx, Call(bcx, llfn, [x, y], []));\n+        let llcall = Call(bcx, llfn, [x, y], []);\n+        Ret(bcx, llcall);\n     }\n \n     let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, item.id));\n@@ -324,14 +326,19 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                             (Pointer, other) | (other, Pointer) if other != Pointer => {\n                                 let tmp = Alloca(bcx, llouttype, \"\");\n                                 Store(bcx, llsrcval, PointerCast(bcx, tmp, llintype.ptr_to()));\n-                                Ret(bcx, Load(bcx, tmp));\n+                                let ll_load = Load(bcx, tmp);\n+                                Ret(bcx, ll_load);\n+                            }\n+                            _ => {\n+                                let llbitcast = BitCast(bcx, llsrcval, llouttype);\n+                                Ret(bcx, llbitcast)\n                             }\n-                            _ => Ret(bcx, BitCast(bcx, llsrcval, llouttype))\n                         }\n                     }\n                 } else if ty::type_is_immediate(ccx.tcx, out_type) {\n                     let llsrcptr = PointerCast(bcx, llsrcval, llouttype.ptr_to());\n-                    Ret(bcx, Load(bcx, llsrcptr));\n+                    let ll_load = Load(bcx, llsrcptr);\n+                    Ret(bcx, ll_load);\n                 } else {\n                     // NB: Do not use a Load and Store here. This causes massive\n                     // code bloat when `transmute` is used on large structural\n@@ -404,7 +411,8 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         \"offset\" => {\n             let ptr = get_param(decl, first_real_arg);\n             let offset = get_param(decl, first_real_arg + 1);\n-            Ret(bcx, InBoundsGEP(bcx, ptr, [offset]));\n+            let lladdr = InBoundsGEP(bcx, ptr, [offset]);\n+            Ret(bcx, lladdr);\n         }\n         \"memcpy32\" => memcpy_intrinsic(bcx, \"llvm.memcpy.p0i8.p0i8.i32\", substs.tys[0], 32),\n         \"memcpy64\" => memcpy_intrinsic(bcx, \"llvm.memcpy.p0i8.p0i8.i64\", substs.tys[0], 64),"}, {"sha": "7def799742dcd16c5f174578c9e62693dcecc5b4", "filename": "src/librustc/middle/trans/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4d8d8c12299456ded2f6dd367a5764abe93af8d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4d8d8c12299456ded2f6dd367a5764abe93af8d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs?ref=f4d8d8c12299456ded2f6dd367a5764abe93af8d", "patch": "@@ -49,7 +49,7 @@ impl Value {\n     /// This only performs a search for a trivially dominating store. The store\n     /// must be the only user of this value, and there must not be any conditional\n     /// branches between the store and the given block.\n-    pub fn get_dominating_store(self, bcx: @mut Block) -> Option<Value> {\n+    pub fn get_dominating_store(self, bcx: &mut Block) -> Option<Value> {\n         match self.get_single_user().and_then(|user| user.as_store_inst()) {\n             Some(store) => {\n                 do store.get_parent().and_then |store_bb| {"}]}