{"sha": "b86c5db96eecbf6f4b08cd3f29d5a5b4dae13aee", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4NmM1ZGI5NmVlY2JmNmY0YjA4Y2QzZjI5ZDVhNWI0ZGFlMTNhZWU=", "commit": {"author": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2021-02-04T07:12:31Z"}, "committer": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2021-02-16T03:00:25Z"}, "message": "Implement reborrow for closure captures", "tree": {"sha": "9a460ae26b0e84af8ccd72f785224a6355b0cafd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a460ae26b0e84af8ccd72f785224a6355b0cafd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b86c5db96eecbf6f4b08cd3f29d5a5b4dae13aee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b86c5db96eecbf6f4b08cd3f29d5a5b4dae13aee", "html_url": "https://github.com/rust-lang/rust/commit/b86c5db96eecbf6f4b08cd3f29d5a5b4dae13aee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b86c5db96eecbf6f4b08cd3f29d5a5b4dae13aee/comments", "author": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1206f950ffb76c76e1b74a19ae33c2b7d949454", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1206f950ffb76c76e1b74a19ae33c2b7d949454", "html_url": "https://github.com/rust-lang/rust/commit/d1206f950ffb76c76e1b74a19ae33c2b7d949454"}], "stats": {"total": 174, "additions": 121, "deletions": 53}, "files": [{"sha": "79c60ab3cfe0f0c4a50e541ed35caf05d8c3e1f3", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 62, "deletions": 41, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/b86c5db96eecbf6f4b08cd3f29d5a5b4dae13aee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86c5db96eecbf6f4b08cd3f29d5a5b4dae13aee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=b86c5db96eecbf6f4b08cd3f29d5a5b4dae13aee", "patch": "@@ -180,7 +180,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     debug!(\"seed place {:?}\", place);\n \n                     let upvar_id = ty::UpvarId::new(*var_hir_id, local_def_id);\n-                    let capture_kind = self.init_capture_kind(capture_clause, upvar_id, span);\n+                    let capture_kind =\n+                        self.init_capture_kind_for_place(&place, capture_clause, upvar_id, span);\n                     let fake_info = ty::CaptureInfo {\n                         capture_kind_expr_id: None,\n                         path_expr_id: None,\n@@ -449,7 +450,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 base => bug!(\"Expected upvar, found={:?}\", base),\n             };\n \n-            let place = restrict_capture_precision(place, capture_info.capture_kind);\n+            let place = restrict_capture_precision(place);\n \n             let min_cap_list = match root_var_min_capture_list.get_mut(&var_hir_id) {\n                 None => {\n@@ -897,15 +898,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn init_capture_kind(\n+    fn init_capture_kind_for_place(\n         &self,\n+        place: &Place<'tcx>,\n         capture_clause: hir::CaptureBy,\n         upvar_id: ty::UpvarId,\n         closure_span: Span,\n     ) -> ty::UpvarCapture<'tcx> {\n         match capture_clause {\n-            hir::CaptureBy::Value => ty::UpvarCapture::ByValue(None),\n-            hir::CaptureBy::Ref => {\n+            // In case of a move closure if the data is accessed through a reference we\n+            // want to capture by ref to allow precise capture using reborrows.\n+            //\n+            // If the data will be moved out of this place, then the place will be truncated\n+            // at the first Deref in `adjust_upvar_borrow_kind_for_consume` and then moved into\n+            // the closure.\n+            hir::CaptureBy::Value if !place.deref_tys().any(ty::TyS::is_ref) => {\n+                ty::UpvarCapture::ByValue(None)\n+            }\n+            hir::CaptureBy::Value | hir::CaptureBy::Ref => {\n                 let origin = UpvarRegion(upvar_id, closure_span);\n                 let upvar_region = self.next_region_var(origin);\n                 let upvar_borrow = ty::UpvarBorrow { kind: ty::ImmBorrow, region: upvar_region };\n@@ -1109,12 +1119,18 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n             place_with_id, diag_expr_id, mode\n         );\n \n-        // we only care about moves\n-        match mode {\n-            euv::Copy => {\n-                return;\n-            }\n-            euv::Move => {}\n+        let place = truncate_capture_for_move(place_with_id.place.clone());\n+        match (self.capture_clause, mode) {\n+            // In non-move closures, we only care about moves\n+            (hir::CaptureBy::Ref, euv::Copy) => return,\n+\n+            (hir::CaptureBy::Ref, euv::Move) | (hir::CaptureBy::Value, euv::Move | euv::Copy) => {}\n+        };\n+\n+        let place_with_id = PlaceWithHirId { place: place.clone(), hir_id: place_with_id.hir_id };\n+\n+        if !self.capture_information.contains_key(&place) {\n+            self.init_capture_info_for_place(&place_with_id, diag_expr_id);\n         }\n \n         let tcx = self.fcx.tcx;\n@@ -1128,13 +1144,15 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n \n         let usage_span = tcx.hir().span(diag_expr_id);\n \n-        // To move out of an upvar, this must be a FnOnce closure\n-        self.adjust_closure_kind(\n-            upvar_id.closure_expr_id,\n-            ty::ClosureKind::FnOnce,\n-            usage_span,\n-            place_with_id.place.clone(),\n-        );\n+        if matches!(mode, euv::Move) {\n+            // To move out of an upvar, this must be a FnOnce closure\n+            self.adjust_closure_kind(\n+                upvar_id.closure_expr_id,\n+                ty::ClosureKind::FnOnce,\n+                usage_span,\n+                place.clone(),\n+            );\n+        }\n \n         let capture_info = ty::CaptureInfo {\n             capture_kind_expr_id: Some(diag_expr_id),\n@@ -1317,8 +1335,12 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n             assert_eq!(self.closure_def_id.expect_local(), upvar_id.closure_expr_id);\n \n-            let capture_kind =\n-                self.fcx.init_capture_kind(self.capture_clause, upvar_id, self.closure_span);\n+            let capture_kind = self.fcx.init_capture_kind_for_place(\n+                &place_with_id.place,\n+                self.capture_clause,\n+                upvar_id,\n+                self.closure_span,\n+            );\n \n             let expr_id = Some(diag_expr_id);\n             let capture_info = ty::CaptureInfo {\n@@ -1392,15 +1414,10 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n }\n \n /// Truncate projections so that following rules are obeyed by the captured `place`:\n-///\n-/// - No Derefs in move closure, this will result in value behind a reference getting moved.\n /// - No projections are applied to raw pointers, since these require unsafe blocks. We capture\n ///   them completely.\n /// - No Index projections are captured, since arrays are captured completely.\n-fn restrict_capture_precision<'tcx>(\n-    mut place: Place<'tcx>,\n-    capture_kind: ty::UpvarCapture<'tcx>,\n-) -> Place<'tcx> {\n+fn restrict_capture_precision<'tcx>(mut place: Place<'tcx>) -> Place<'tcx> {\n     if place.projections.is_empty() {\n         // Nothing to do here\n         return place;\n@@ -1412,7 +1429,6 @@ fn restrict_capture_precision<'tcx>(\n     }\n \n     let mut truncated_length = usize::MAX;\n-    let mut first_deref_projection = usize::MAX;\n \n     for (i, proj) in place.projections.iter().enumerate() {\n         if proj.ty.is_unsafe_ptr() {\n@@ -1426,31 +1442,36 @@ fn restrict_capture_precision<'tcx>(\n                 truncated_length = truncated_length.min(i);\n                 break;\n             }\n-            ProjectionKind::Deref => {\n-                // We only drop Derefs in case of move closures\n-                // There might be an index projection or raw ptr ahead, so we don't stop here.\n-                first_deref_projection = first_deref_projection.min(i);\n-            }\n+            ProjectionKind::Deref => {}\n             ProjectionKind::Field(..) => {} // ignore\n             ProjectionKind::Subslice => {}  // We never capture this\n         }\n     }\n \n-    let length = place\n-        .projections\n-        .len()\n-        .min(truncated_length)\n-        // In case of capture `ByValue` we want to not capture derefs\n-        .min(match capture_kind {\n-            ty::UpvarCapture::ByValue(..) => first_deref_projection,\n-            ty::UpvarCapture::ByRef(..) => usize::MAX,\n-        });\n+    let length = place.projections.len().min(truncated_length);\n \n     place.projections.truncate(length);\n \n     place\n }\n \n+/// Truncates a place so that the resultant capture doesn't move data out of a reference\n+fn truncate_capture_for_move(mut place: Place<'tcx>) -> Place<'tcx> {\n+    for (i, proj) in place.projections.iter().enumerate() {\n+        match proj.kind {\n+            ProjectionKind::Deref => {\n+                // We only drop Derefs in case of move closures\n+                // There might be an index projection or raw ptr ahead, so we don't stop here.\n+                place.projections.truncate(i);\n+                return place;\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    place\n+}\n+\n fn construct_place_string(tcx: TyCtxt<'_>, place: &Place<'tcx>) -> String {\n     let variable_name = match place.base {\n         PlaceBase::Upvar(upvar_id) => var_name(tcx, upvar_id.var_path.hir_id).to_string(),"}, {"sha": "27c8fb1363f17a03144b1707cece124c012c1769", "filename": "src/test/ui/closures/2229_closure_analysis/by_value.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b86c5db96eecbf6f4b08cd3f29d5a5b4dae13aee/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86c5db96eecbf6f4b08cd3f29d5a5b4dae13aee/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.rs?ref=b86c5db96eecbf6f4b08cd3f29d5a5b4dae13aee", "patch": "@@ -26,7 +26,8 @@ fn big_box() {\n     //~^ First Pass analysis includes:\n     //~| Min Capture analysis includes:\n         let p = t.0.0;\n-        //~^ NOTE: Capturing t[(0, 0),Deref,(0, 0)] -> ByValue\n+        //~^ NOTE: Capturing t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n+        //~| NOTE: Capturing t[(0, 0)] -> ByValue\n         //~| NOTE: Min Capture t[(0, 0)] -> ByValue\n         println!(\"{} {:?}\", t.1, p);\n         //~^ NOTE: Capturing t[(1, 0)] -> ImmBorrow"}, {"sha": "944e4c40a78ef6707a21e7b35bf1f11544235829", "filename": "src/test/ui/closures/2229_closure_analysis/by_value.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b86c5db96eecbf6f4b08cd3f29d5a5b4dae13aee/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b86c5db96eecbf6f4b08cd3f29d5a5b4dae13aee/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.stderr?ref=b86c5db96eecbf6f4b08cd3f29d5a5b4dae13aee", "patch": "@@ -28,13 +28,18 @@ LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Capturing t[(0, 0),Deref,(0, 0)] -> ByValue\n+note: Capturing t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n+  --> $DIR/by_value.rs:28:17\n+   |\n+LL |         let p = t.0.0;\n+   |                 ^^^^^\n+note: Capturing t[(0, 0)] -> ByValue\n   --> $DIR/by_value.rs:28:17\n    |\n LL |         let p = t.0.0;\n    |                 ^^^^^\n note: Capturing t[(1, 0)] -> ImmBorrow\n-  --> $DIR/by_value.rs:31:29\n+  --> $DIR/by_value.rs:32:29\n    |\n LL |         println!(\"{} {:?}\", t.1, p);\n    |                             ^^^\n@@ -57,7 +62,7 @@ note: Min Capture t[(0, 0)] -> ByValue\n LL |         let p = t.0.0;\n    |                 ^^^^^\n note: Min Capture t[(1, 0)] -> ImmBorrow\n-  --> $DIR/by_value.rs:31:29\n+  --> $DIR/by_value.rs:32:29\n    |\n LL |         println!(\"{} {:?}\", t.1, p);\n    |                             ^^^"}, {"sha": "d57c2280438bac566f05679d55256d1f4883b747", "filename": "src/test/ui/closures/2229_closure_analysis/move_closure.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b86c5db96eecbf6f4b08cd3f29d5a5b4dae13aee/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86c5db96eecbf6f4b08cd3f29d5a5b4dae13aee/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.rs?ref=b86c5db96eecbf6f4b08cd3f29d5a5b4dae13aee", "patch": "@@ -18,8 +18,8 @@ fn simple_ref() {\n     //~^ ERROR: First Pass analysis includes:\n     //~| ERROR: Min Capture analysis includes:\n         *ref_s += 10;\n-        //~^ NOTE: Capturing ref_s[Deref] -> ByValue\n-        //~| NOTE: Min Capture ref_s[] -> ByValue\n+        //~^ NOTE: Capturing ref_s[Deref] -> UniqueImmBorrow\n+        //~| NOTE: Min Capture ref_s[Deref] -> UniqueImmBorrow\n     };\n     c();\n }\n@@ -39,8 +39,8 @@ fn struct_contains_ref_to_another_struct() {\n     //~^ ERROR: First Pass analysis includes:\n     //~| ERROR: Min Capture analysis includes:\n         t.0.0 = \"new s\".into();\n-        //~^ NOTE: Capturing t[(0, 0),Deref,(0, 0)] -> ByValue\n-        //~| NOTE: Min Capture t[(0, 0)] -> ByValue\n+        //~^ NOTE: Capturing t[(0, 0),Deref,(0, 0)] -> UniqueImmBorrow\n+        //~| NOTE: Min Capture t[(0, 0),Deref,(0, 0)] -> UniqueImmBorrow\n     };\n \n     c();"}, {"sha": "554dc11f6badb077efac952188caf5759b87866d", "filename": "src/test/ui/closures/2229_closure_analysis/move_closure.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b86c5db96eecbf6f4b08cd3f29d5a5b4dae13aee/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b86c5db96eecbf6f4b08cd3f29d5a5b4dae13aee/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.stderr?ref=b86c5db96eecbf6f4b08cd3f29d5a5b4dae13aee", "patch": "@@ -46,7 +46,7 @@ LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Capturing ref_s[Deref] -> ByValue\n+note: Capturing ref_s[Deref] -> UniqueImmBorrow\n   --> $DIR/move_closure.rs:20:9\n    |\n LL |         *ref_s += 10;\n@@ -64,7 +64,7 @@ LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Min Capture ref_s[] -> ByValue\n+note: Min Capture ref_s[Deref] -> UniqueImmBorrow\n   --> $DIR/move_closure.rs:20:9\n    |\n LL |         *ref_s += 10;\n@@ -82,7 +82,7 @@ LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Capturing t[(0, 0),Deref,(0, 0)] -> ByValue\n+note: Capturing t[(0, 0),Deref,(0, 0)] -> UniqueImmBorrow\n   --> $DIR/move_closure.rs:41:9\n    |\n LL |         t.0.0 = \"new s\".into();\n@@ -100,7 +100,7 @@ LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Min Capture t[(0, 0)] -> ByValue\n+note: Min Capture t[(0, 0),Deref,(0, 0)] -> UniqueImmBorrow\n   --> $DIR/move_closure.rs:41:9\n    |\n LL |         t.0.0 = \"new s\".into();"}, {"sha": "afaafbda018774feb36039447a98ec1feae56170", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/move_closure.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b86c5db96eecbf6f4b08cd3f29d5a5b4dae13aee/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmove_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86c5db96eecbf6f4b08cd3f29d5a5b4dae13aee/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmove_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmove_closure.rs?ref=b86c5db96eecbf6f4b08cd3f29d5a5b4dae13aee", "patch": "@@ -56,9 +56,50 @@ fn no_ref_nested() {\n     c();\n }\n \n+struct A<'a>(&'a mut String,  &'a mut String);\n+// Test that reborrowing works as expected for move closures\n+// by attempting a disjoint capture through a reference.\n+fn disjoint_via_ref() {\n+    let mut x = String::new();\n+    let mut y = String::new();\n+\n+    let mut a = A(&mut x, &mut y);\n+    let a = &mut a;\n+\n+    let mut c1 = move || {\n+        a.0.truncate(0);\n+    };\n+\n+    let mut c2 = move || {\n+        a.1.truncate(0);\n+    };\n+\n+    c1();\n+    c2();\n+}\n+\n+// Test that even if a path is moved into the closure, the closure is not FnOnce\n+// if the path is not moved by the closure call.\n+fn data_moved_but_not_fn_once() {\n+    let x = Box::new(10i32);\n+\n+    let c = move || {\n+        // *x has type i32 which is Copy. So even though the box `x` will be moved\n+        // into the closure, `x` is never moved when the closure is called, i.e. the\n+        // ownership stays with the closure and therefore we can call the function multiple times.\n+        let _x = *x;\n+    };\n+\n+    c();\n+    c();\n+}\n+\n fn main() {\n     simple_ref();\n     struct_contains_ref_to_another_struct();\n     no_ref();\n     no_ref_nested();\n+\n+    disjoint_via_ref();\n+    data_moved_but_not_fn_once();\n }"}]}