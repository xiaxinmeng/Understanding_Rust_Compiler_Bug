{"sha": "bc83a009f655dd3896be4a7cd33cac8032a605f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjODNhMDA5ZjY1NWRkMzg5NmJlNGE3Y2QzM2NhYzgwMzJhNjA1ZjI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-23T19:53:35Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-29T20:16:49Z"}, "message": "std: Second pass stabilization for `comm`\n\nThis commit is a second pass stabilization for the `std::comm` module,\nperforming the following actions:\n\n* The entire `std::comm` module was moved under `std::sync::mpsc`. This movement\n  reflects that channels are just yet another synchronization primitive, and\n  they don't necessarily deserve a special place outside of the other\n  concurrency primitives that the standard library offers.\n* The `send` and `recv` methods have all been removed.\n* The `send_opt` and `recv_opt` methods have been renamed to `send` and `recv`.\n  This means that all send/receive operations return a `Result` now indicating\n  whether the operation was successful or not.\n* The error type of `send` is now a `SendError` to implement a custom error\n  message and allow for `unwrap()`. The error type contains an `into_inner`\n  method to extract the value.\n* The error type of `recv` is now `RecvError` for the same reasons as `send`.\n* The `TryRecvError` and `TrySendError` types have had public reexports removed\n  of their variants and the variant names have been tweaked with enum\n  namespacing rules.\n* The `Messages` iterator is renamed to `Iter`\n\nThis functionality is now all `#[stable]`:\n\n* `Sender`\n* `SyncSender`\n* `Receiver`\n* `std::sync::mpsc`\n* `channel`\n* `sync_channel`\n* `Iter`\n* `Sender::send`\n* `Sender::clone`\n* `SyncSender::send`\n* `SyncSender::try_send`\n* `SyncSender::clone`\n* `Receiver::recv`\n* `Receiver::try_recv`\n* `Receiver::iter`\n* `SendError`\n* `RecvError`\n* `TrySendError::{mod, Full, Disconnected}`\n* `TryRecvError::{mod, Empty, Disconnected}`\n* `SendError::into_inner`\n* `TrySendError::into_inner`\n\nThis is a breaking change due to the modification of where this module is\nlocated, as well as the changing of the semantics of `send` and `recv`. Most\nprograms just need to rename imports of `std::comm` to `std::sync::mpsc` and\nadd calls to `unwrap` after a send or a receive operation.\n\n[breaking-change]", "tree": {"sha": "3acc8533031219690fe14fa56f4427cfa9297296", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3acc8533031219690fe14fa56f4427cfa9297296"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc83a009f655dd3896be4a7cd33cac8032a605f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc83a009f655dd3896be4a7cd33cac8032a605f2", "html_url": "https://github.com/rust-lang/rust/commit/bc83a009f655dd3896be4a7cd33cac8032a605f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc83a009f655dd3896be4a7cd33cac8032a605f2/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb8f4fc3b73918abd19d67be702f78e8f73d1874", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb8f4fc3b73918abd19d67be702f78e8f73d1874", "html_url": "https://github.com/rust-lang/rust/commit/bb8f4fc3b73918abd19d67be702f78e8f73d1874"}], "stats": {"total": 2381, "additions": 1175, "deletions": 1206}, "files": [{"sha": "9ac0acc38a73e8b61c47694177aee91c87c95f6e", "filename": "src/etc/licenseck.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Fetc%2Flicenseck.py", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Fetc%2Flicenseck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flicenseck.py?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -38,8 +38,8 @@\n     \"rt/isaac/randport.cpp\", # public domain\n     \"rt/isaac/rand.h\", # public domain\n     \"rt/isaac/standard.h\", # public domain\n-    \"libstd/comm/mpsc_queue.rs\", # BSD\n-    \"libstd/comm/spsc_queue.rs\", # BSD\n+    \"libstd/sync/mpsc/mpsc_queue.rs\", # BSD\n+    \"libstd/sync/mpsc/spsc_queue.rs\", # BSD\n     \"test/bench/shootout-binarytrees.rs\", # BSD\n     \"test/bench/shootout-chameneos-redux.rs\", # BSD\n     \"test/bench/shootout-fannkuch-redux.rs\", # BSD"}, {"sha": "b8c7bc74132e47d14468e8f661f551c3a9501e85", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -592,7 +592,7 @@ impl<T: Default + Sync + Send> Default for Arc<T> {\n #[allow(experimental)]\n mod tests {\n     use std::clone::Clone;\n-    use std::comm::channel;\n+    use std::sync::mpsc::channel;\n     use std::mem::drop;\n     use std::ops::Drop;\n     use std::option::Option;\n@@ -628,11 +628,11 @@ mod tests {\n         let (tx, rx) = channel();\n \n         task::spawn(move || {\n-            let arc_v: Arc<Vec<int>> = rx.recv();\n+            let arc_v: Arc<Vec<int>> = rx.recv().unwrap();\n             assert_eq!((*arc_v)[3], 4);\n         });\n \n-        tx.send(arc_v.clone());\n+        tx.send(arc_v.clone()).unwrap();\n \n         assert_eq!((*arc_v)[2], 3);\n         assert_eq!((*arc_v)[4], 5);"}, {"sha": "fe3267b6c35d91527e88a5c7acfd636d7ed4cba0", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -2452,7 +2452,7 @@ mod tests {\n \n #[cfg(test)]\n mod bitv_bench {\n-    use std::prelude::*;\n+    use std::prelude::v1::*;\n     use std::rand;\n     use std::rand::Rng;\n     use std::u32;\n@@ -2947,7 +2947,7 @@ mod bitv_set_test {\n \n #[cfg(test)]\n mod bitv_set_bench {\n-    use std::prelude::*;\n+    use std::prelude::v1::*;\n     use std::rand;\n     use std::rand::Rng;\n     use std::u32;"}, {"sha": "8b716a8431d886263b6ddc3b99235dd7df9acac3", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -55,10 +55,10 @@ use rustc::DIAGNOSTICS;\n \n use std::any::AnyRefExt;\n use std::cmp::Ordering::Equal;\n-use std::comm::channel;\n use std::io;\n use std::iter::repeat;\n use std::os;\n+use std::sync::mpsc::channel;\n use std::thread;\n \n use rustc::session::early_error;"}, {"sha": "55e6dfaebcd5110cc704fa4204b338e7b8e05403", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -23,14 +23,14 @@ use syntax::diagnostic;\n use syntax::diagnostic::{Emitter, Handler, Level, mk_handler};\n \n use std::c_str::{ToCStr, CString};\n-use std::comm::channel;\n use std::io::Command;\n use std::io::fs;\n use std::iter::Unfold;\n use std::ptr;\n use std::str;\n use std::mem;\n use std::sync::{Arc, Mutex};\n+use std::sync::mpsc::channel;\n use std::thread;\n use libc::{c_uint, c_int, c_void};\n \n@@ -929,13 +929,13 @@ fn run_work_multithreaded(sess: &Session,\n                 }\n             }\n \n-            tx.take().unwrap().send(());\n+            tx.take().unwrap().send(()).unwrap();\n         }).detach();\n     }\n \n     let mut panicked = false;\n     for rx in futures.into_iter() {\n-        match rx.recv_opt() {\n+        match rx.recv() {\n             Ok(()) => {},\n             Err(_) => {\n                 panicked = true;"}, {"sha": "e105a1f6a95f3c50d8cfa77ec1853171eb46f65f", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -1203,8 +1203,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                         let glob_map = &self.analysis.glob_map;\n                         let glob_map = glob_map.as_ref().unwrap();\n                         if glob_map.contains_key(&id) {\n-                            let names = glob_map.index(&id);\n-                            for n in names.iter() {\n+                            for n in glob_map[id].iter() {\n                                 if name_string.len() > 0 {\n                                     name_string.push_str(\", \");\n                                 }"}, {"sha": "a50bfbde0fea276c45f9692a0b555ec9225886a7", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::cell::RefCell;\n-use std::comm::channel;\n+use std::sync::mpsc::channel;\n use std::dynamic_lib::DynamicLibrary;\n use std::io::{Command, TempDir};\n use std::io;"}, {"sha": "4ec329de600e1457d83b6b453491e638884f427a", "filename": "src/libstd/bitflags.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -273,7 +273,6 @@ macro_rules! bitflags {\n mod tests {\n     use hash;\n     use option::Option::{Some, None};\n-    use ops::{BitOr, BitAnd, BitXor, Sub, Not};\n \n     bitflags! {\n         #[doc = \"> The first principle is that you must not fool yourself \u2014 and\"]"}, {"sha": "d096903f9c47d1c0a050a7a27ee07e70a262af4b", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -621,7 +621,7 @@ mod tests {\n     #[test]\n     fn test_unwrap() {\n         let c_str = \"hello\".to_c_str();\n-        unsafe { libc::free(c_str.unwrap() as *mut libc::c_void) }\n+        unsafe { libc::free(c_str.into_inner() as *mut libc::c_void) }\n     }\n \n     #[test]"}, {"sha": "a80659ed937e5c25edfe3671b047659e0909808a", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -228,7 +228,7 @@ mod tests {\n             let cv = CVec::new_with_dtor(1 as *mut int,\n                                          0,\n                                          move|:| panic!(\"Don't run this destructor!\"));\n-            let p = cv.unwrap();\n+            let p = cv.into_inner();\n             assert_eq!(p, 1 as *mut int);\n         }\n     }"}, {"sha": "8585b4ecf52ade988a0cc65740b371fa74a39333", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -1485,6 +1485,7 @@ mod test_map {\n \n     struct KindaIntLike(int);\n \n+    #[allow(deprecated)]\n     impl Equiv<int> for KindaIntLike {\n         fn equiv(&self, other: &int) -> bool {\n             let KindaIntLike(this) = *self;\n@@ -1812,7 +1813,7 @@ mod test_map {\n     }\n \n     #[test]\n-    #[allow(experimental)]\n+    #[allow(deprecated)]\n     fn test_pop_equiv() {\n         let mut m = HashMap::new();\n         m.insert(1i, 2i);"}, {"sha": "1679d2e552f22b8bcb02bc4b6459e12f90021917", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -533,7 +533,7 @@ mod test {\n         w.write(&[0, 1]).unwrap();\n         let a: &[_] = &[];\n         assert_eq!(a, w.get_ref()[]);\n-        let w = w.unwrap();\n+        let w = w.into_inner();\n         let a: &[_] = &[0, 1];\n         assert_eq!(a, w[]);\n     }"}, {"sha": "7b8513ce423b22f985e7fbb127271fc45be122c2", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -10,7 +10,7 @@\n \n use clone::Clone;\n use cmp;\n-use comm::{Sender, Receiver};\n+use sync::mpsc::{Sender, Receiver};\n use io;\n use option::Option::{None, Some};\n use result::Result::{Ok, Err};\n@@ -23,7 +23,7 @@ use vec::Vec;\n /// # Example\n ///\n /// ```\n-/// use std::comm::channel;\n+/// use std::sync::mpsc::channel;\n /// use std::io::ChanReader;\n ///\n /// let (tx, rx) = channel();\n@@ -59,11 +59,11 @@ impl Buffer for ChanReader {\n     fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n         if self.pos >= self.buf.len() {\n             self.pos = 0;\n-            match self.rx.recv_opt() {\n+            match self.rx.recv() {\n                 Ok(bytes) => {\n                     self.buf = bytes;\n                 },\n-                Err(()) => {\n+                Err(..) => {\n                     self.closed = true;\n                     self.buf = Vec::new();\n                 }\n@@ -115,7 +115,7 @@ impl Reader for ChanReader {\n ///\n /// ```\n /// # #![allow(unused_must_use)]\n-/// use std::comm::channel;\n+/// use std::sync::mpsc::channel;\n /// use std::io::ChanWriter;\n ///\n /// let (tx, rx) = channel();\n@@ -143,7 +143,7 @@ impl Clone for ChanWriter {\n \n impl Writer for ChanWriter {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.tx.send_opt(buf.to_vec()).map_err(|_| {\n+        self.tx.send(buf.to_vec()).map_err(|_| {\n             io::IoError {\n                 kind: io::BrokenPipe,\n                 desc: \"Pipe closed\",\n@@ -158,7 +158,7 @@ impl Writer for ChanWriter {\n mod test {\n     use prelude::v1::*;\n \n-    use comm::channel;\n+    use sync::mpsc::channel;\n     use super::*;\n     use io;\n     use thread::Thread;\n@@ -167,11 +167,11 @@ mod test {\n     fn test_rx_reader() {\n         let (tx, rx) = channel();\n         Thread::spawn(move|| {\n-          tx.send(vec![1u8, 2u8]);\n-          tx.send(vec![]);\n-          tx.send(vec![3u8, 4u8]);\n-          tx.send(vec![5u8, 6u8]);\n-          tx.send(vec![7u8, 8u8]);\n+          tx.send(vec![1u8, 2u8]).unwrap();\n+          tx.send(vec![]).unwrap();\n+          tx.send(vec![3u8, 4u8]).unwrap();\n+          tx.send(vec![5u8, 6u8]).unwrap();\n+          tx.send(vec![7u8, 8u8]).unwrap();\n         }).detach();\n \n         let mut reader = ChanReader::new(rx);\n@@ -209,12 +209,12 @@ mod test {\n     fn test_rx_buffer() {\n         let (tx, rx) = channel();\n         Thread::spawn(move|| {\n-          tx.send(b\"he\".to_vec());\n-          tx.send(b\"llo wo\".to_vec());\n-          tx.send(b\"\".to_vec());\n-          tx.send(b\"rld\\nhow \".to_vec());\n-          tx.send(b\"are you?\".to_vec());\n-          tx.send(b\"\".to_vec());\n+          tx.send(b\"he\".to_vec()).unwrap();\n+          tx.send(b\"llo wo\".to_vec()).unwrap();\n+          tx.send(b\"\".to_vec()).unwrap();\n+          tx.send(b\"rld\\nhow \".to_vec()).unwrap();\n+          tx.send(b\"are you?\".to_vec()).unwrap();\n+          tx.send(b\"\".to_vec()).unwrap();\n         }).detach();\n \n         let mut reader = ChanReader::new(rx);\n@@ -234,7 +234,7 @@ mod test {\n         writer.write_be_u32(42).unwrap();\n \n         let wanted = vec![0u8, 0u8, 0u8, 42u8];\n-        let got = match Thread::spawn(move|| { rx.recv() }).join() {\n+        let got = match Thread::spawn(move|| { rx.recv().unwrap() }).join() {\n             Ok(got) => got,\n             Err(_) => panic!(),\n         };"}, {"sha": "71c42273c22199a98b33c87e9d74b69e32632bce", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -402,8 +402,8 @@ mod test {\n     use prelude::v1::*;\n \n     use super::*;\n-    use io::*;\n     use io;\n+    use io::{SeekSet, SeekCur, SeekEnd};\n     use self::test_crate::Bencher;\n \n     #[test]"}, {"sha": "68f3a8e1836356bb494a575627309c125b2e2102", "filename": "src/libstd/io/net/pipe.rs", "status": "modified", "additions": 48, "deletions": 40, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -267,11 +267,13 @@ impl sys_common::AsInner<UnixAcceptorImp> for UnixAcceptor {\n mod tests {\n     use prelude::v1::*;\n \n-    use comm::channel;\n-    use io::*;\n     use io::fs::PathExtensions;\n+    use io::{EndOfFile, TimedOut, ShortWrite, IoError, ConnectionReset};\n+    use io::{NotConnected, BrokenPipe, FileNotFound, InvalidInput, OtherIoError};\n+    use io::{PermissionDenied, Acceptor, Listener};\n     use io::test::*;\n     use super::*;\n+    use sync::mpsc::channel;\n     use thread::Thread;\n     use time::Duration;\n \n@@ -431,18 +433,18 @@ mod tests {\n         let (tx2, rx2) = channel();\n         let _t = Thread::spawn(move|| {\n             let mut s2 = s2;\n-            rx1.recv();\n+            rx1.recv().unwrap();\n             debug!(\"writer writing\");\n             s2.write(&[1]).unwrap();\n             debug!(\"writer done\");\n-            tx2.send(());\n+            tx2.send(()).unwrap();\n         });\n-        tx1.send(());\n+        tx1.send(()).unwrap();\n         let mut buf = [0, 0];\n         debug!(\"reader reading\");\n         assert_eq!(s1.read(&mut buf), Ok(1));\n         debug!(\"reader done\");\n-        rx2.recv();\n+        rx2.recv().unwrap();\n     }\n \n     #[test]\n@@ -455,9 +457,9 @@ mod tests {\n         let _t = Thread::spawn(move|| {\n             let mut s = UnixStream::connect(&addr);\n             s.write(&[1]).unwrap();\n-            rx.recv();\n+            rx.recv().unwrap();\n             s.write(&[2]).unwrap();\n-            rx.recv();\n+            rx.recv().unwrap();\n         });\n \n         let mut s1 = acceptor.accept().unwrap();\n@@ -468,14 +470,14 @@ mod tests {\n             let mut s2 = s2;\n             let mut buf = [0, 0];\n             s2.read(&mut buf).unwrap();\n-            tx2.send(());\n-            done.send(());\n+            tx2.send(()).unwrap();\n+            done.send(()).unwrap();\n         });\n         let mut buf = [0, 0];\n         s1.read(&mut buf).unwrap();\n-        tx1.send(());\n+        tx1.send(()).unwrap();\n \n-        rx.recv();\n+        rx.recv().unwrap();\n     }\n \n     #[test]\n@@ -497,11 +499,11 @@ mod tests {\n         let _t = Thread::spawn(move|| {\n             let mut s2 = s2;\n             s2.write(&[1]).unwrap();\n-            tx.send(());\n+            tx.send(()).unwrap();\n         });\n         s1.write(&[2]).unwrap();\n \n-        rx.recv();\n+        rx.recv().unwrap();\n     }\n \n     #[cfg(not(windows))]\n@@ -542,9 +544,9 @@ mod tests {\n         let (tx, rx) = channel();\n         let addr2 = addr.clone();\n         let _t = Thread::spawn(move|| {\n-            tx.send(UnixStream::connect(&addr2).unwrap());\n+            tx.send(UnixStream::connect(&addr2).unwrap()).unwrap();\n         });\n-        let l = rx.recv();\n+        let l = rx.recv().unwrap();\n         for i in range(0u, 1001) {\n             match a.accept() {\n                 Ok(..) => break,\n@@ -600,7 +602,7 @@ mod tests {\n         Thread::spawn(move|| {\n             let mut a = a;\n             let _s = a.accept().unwrap();\n-            let _ = rx.recv_opt();\n+            let _ = rx.recv();\n         }).detach();\n \n         let mut b = [0];\n@@ -637,7 +639,7 @@ mod tests {\n         Thread::spawn(move|| {\n             let mut a = a;\n             let _s = a.accept().unwrap();\n-            let _ = rx.recv_opt();\n+            let _ = rx.recv();\n         }).detach();\n \n         let mut s = UnixStream::connect(&addr).unwrap();\n@@ -646,13 +648,13 @@ mod tests {\n         let _t = Thread::spawn(move|| {\n             let mut s2 = s2;\n             assert!(s2.read(&mut [0]).is_err());\n-            tx.send(());\n+            tx.send(()).unwrap();\n         });\n         // this should wake up the child task\n         s.close_read().unwrap();\n \n         // this test will never finish if the child doesn't wake up\n-        rx.recv();\n+        rx.recv().unwrap();\n     }\n \n     #[test]\n@@ -662,9 +664,9 @@ mod tests {\n         let (tx, rx) = channel::<()>();\n         Thread::spawn(move|| {\n             let mut s = UnixStream::connect(&addr).unwrap();\n-            rx.recv();\n+            rx.recv().unwrap();\n             assert!(s.write(&[0]).is_ok());\n-            let _ = rx.recv_opt();\n+            let _ = rx.recv();\n         }).detach();\n \n         let mut s = a.accept().unwrap();\n@@ -688,7 +690,7 @@ mod tests {\n             assert_eq!(s.write(&[0]).err().unwrap().kind, TimedOut);\n         }\n \n-        tx.send(());\n+        tx.send(()).unwrap();\n         s.set_timeout(None);\n         assert_eq!(s.read(&mut [0, 0]), Ok(1));\n     }\n@@ -700,23 +702,23 @@ mod tests {\n         let (tx, rx) = channel::<()>();\n         Thread::spawn(move|| {\n             let mut s = UnixStream::connect(&addr).unwrap();\n-            rx.recv();\n+            rx.recv().unwrap();\n             let mut amt = 0;\n             while amt < 100 * 128 * 1024 {\n                 match s.read(&mut [0, ..128 * 1024]) {\n                     Ok(n) => { amt += n; }\n                     Err(e) => panic!(\"{}\", e),\n                 }\n             }\n-            let _ = rx.recv_opt();\n+            let _ = rx.recv();\n         }).detach();\n \n         let mut s = a.accept().unwrap();\n         s.set_read_timeout(Some(20));\n         assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n         assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n \n-        tx.send(());\n+        tx.send(()).unwrap();\n         for _ in range(0u, 100) {\n             assert!(s.write(&[0, ..128 * 1024]).is_ok());\n         }\n@@ -729,9 +731,9 @@ mod tests {\n         let (tx, rx) = channel::<()>();\n         Thread::spawn(move|| {\n             let mut s = UnixStream::connect(&addr).unwrap();\n-            rx.recv();\n+            rx.recv().unwrap();\n             assert!(s.write(&[0]).is_ok());\n-            let _ = rx.recv_opt();\n+            let _ = rx.recv();\n         }).detach();\n \n         let mut s = a.accept().unwrap();\n@@ -745,7 +747,7 @@ mod tests {\n            if i == 1000 { panic!(\"should have filled up?!\"); }\n         }\n \n-        tx.send(());\n+        tx.send(()).unwrap();\n         assert!(s.read(&mut [0]).is_ok());\n     }\n \n@@ -756,9 +758,9 @@ mod tests {\n         let (tx, rx) = channel::<()>();\n         Thread::spawn(move|| {\n             let mut s = UnixStream::connect(&addr).unwrap();\n-            rx.recv();\n+            rx.recv().unwrap();\n             assert!(s.write(&[0]).is_ok());\n-            let _ = rx.recv_opt();\n+            let _ = rx.recv();\n         }).detach();\n \n         let mut s = a.accept().unwrap();\n@@ -767,14 +769,14 @@ mod tests {\n         let _t = Thread::spawn(move|| {\n             let mut s2 = s2;\n             assert!(s2.read(&mut [0]).is_ok());\n-            tx2.send(());\n+            tx2.send(()).unwrap();\n         });\n \n         s.set_read_timeout(Some(20));\n         assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n-        tx.send(());\n+        tx.send(()).unwrap();\n \n-        rx2.recv();\n+        rx2.recv().unwrap();\n     }\n \n     #[cfg(not(windows))]\n@@ -809,8 +811,14 @@ mod tests {\n         let (tx, rx) = channel();\n         let tx2 = tx.clone();\n \n-        let _t = Thread::spawn(move|| { let mut a = a; tx.send(a.accept()) });\n-        let _t = Thread::spawn(move|| { let mut a = a2; tx2.send(a.accept()) });\n+        let _t = Thread::spawn(move|| {\n+            let mut a = a;\n+            tx.send(a.accept()).unwrap()\n+        });\n+        let _t = Thread::spawn(move|| {\n+            let mut a = a2;\n+            tx2.send(a.accept()).unwrap()\n+        });\n \n         let addr2 = addr.clone();\n         let _t = Thread::spawn(move|| {\n@@ -820,8 +828,8 @@ mod tests {\n             let _ = UnixStream::connect(&addr);\n         });\n \n-        assert!(rx.recv().is_ok());\n-        assert!(rx.recv().is_ok());\n+        assert!(rx.recv().unwrap().is_ok());\n+        assert!(rx.recv().unwrap().is_ok());\n     }\n \n     #[test]\n@@ -844,10 +852,10 @@ mod tests {\n         let (tx, rx) = channel();\n         let _t = Thread::spawn(move|| {\n             let mut a = a;\n-            tx.send(a.accept());\n+            tx.send(a.accept()).unwrap();\n         });\n         a2.close_accept().unwrap();\n \n-        assert_eq!(rx.recv().err().unwrap().kind, EndOfFile);\n+        assert_eq!(rx.recv().unwrap().err().unwrap().kind, EndOfFile);\n     }\n }"}, {"sha": "57ffcfaad30a786c55b5cbfc2352c54c485f098b", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 67, "deletions": 58, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -484,12 +484,15 @@ impl sys_common::AsInner<TcpAcceptorImp> for TcpAcceptor {\n mod test {\n     use prelude::v1::*;\n \n-    use comm::channel;\n+    use sync::mpsc::channel;\n     use thread::Thread;\n     use io::net::tcp::*;\n     use io::net::ip::*;\n-    use io::*;\n     use io::test::*;\n+    use io::{EndOfFile, TimedOut, ShortWrite, IoError};\n+    use io::{ConnectionRefused, BrokenPipe, ConnectionAborted};\n+    use io::{ConnectionReset, NotConnected, PermissionDenied, OtherIoError};\n+    use io::{Acceptor, Listener};\n \n     // FIXME #11530 this fails on android because tests are run as root\n     #[cfg_attr(any(windows, target_os = \"android\"), ignore)]\n@@ -694,11 +697,11 @@ mod test {\n         let (tx, rx) = channel();\n         let _t = Thread::spawn(move|| {\n             drop(TcpStream::connect(addr));\n-            tx.send(());\n+            tx.send(()).unwrap();\n         });\n \n         let mut stream = acceptor.accept();\n-        rx.recv();\n+        rx.recv().unwrap();\n         let buf = [0];\n         match stream.write(&buf) {\n             Ok(..) => {}\n@@ -719,11 +722,11 @@ mod test {\n         let (tx, rx) = channel();\n         let _t = Thread::spawn(move|| {\n             drop(TcpStream::connect(addr));\n-            tx.send(());\n+            tx.send(()).unwrap();\n         });\n \n         let mut stream = acceptor.accept();\n-        rx.recv();\n+        rx.recv().unwrap();\n         let buf = [0];\n         match stream.write(&buf) {\n             Ok(..) => {}\n@@ -969,20 +972,20 @@ mod test {\n         let (tx, rx) = channel();\n         let _t = Thread::spawn(move|| {\n             let mut srv = TcpListener::bind(addr).listen().unwrap();\n-            tx.send(());\n+            tx.send(()).unwrap();\n             let mut cl = srv.accept().unwrap();\n             cl.write(&[10]).unwrap();\n             let mut b = [0];\n             cl.read(&mut b).unwrap();\n-            tx.send(());\n+            tx.send(()).unwrap();\n         });\n \n-        rx.recv();\n+        rx.recv().unwrap();\n         let mut c = TcpStream::connect(addr).unwrap();\n         let mut b = [0, ..10];\n         assert_eq!(c.read(&mut b), Ok(1));\n         c.write(&[1]).unwrap();\n-        rx.recv();\n+        rx.recv().unwrap();\n     }\n \n     #[test]\n@@ -1005,19 +1008,19 @@ mod test {\n         let (tx, rx) = channel();\n \n         let _t = Thread::spawn(move|| {\n-            rx.recv();\n+            rx.recv().unwrap();\n             let _stream = TcpStream::connect(addr).unwrap();\n             // Close\n-            rx.recv();\n+            rx.recv().unwrap();\n         });\n \n         {\n             let mut acceptor = TcpListener::bind(addr).listen();\n-            tx.send(());\n+            tx.send(()).unwrap();\n             {\n                 let _stream = acceptor.accept().unwrap();\n                 // Close client\n-                tx.send(());\n+                tx.send(()).unwrap();\n             }\n             // Close listener\n         }\n@@ -1044,14 +1047,14 @@ mod test {\n         let (tx2, rx2) = channel();\n         let _t = Thread::spawn(move|| {\n             let mut s2 = s2;\n-            rx1.recv();\n+            rx1.recv().unwrap();\n             s2.write(&[1]).unwrap();\n-            tx2.send(());\n+            tx2.send(()).unwrap();\n         });\n-        tx1.send(());\n+        tx1.send(()).unwrap();\n         let mut buf = [0, 0];\n         assert_eq!(s1.read(&mut buf), Ok(1));\n-        rx2.recv();\n+        rx2.recv().unwrap();\n     }\n \n     #[test]\n@@ -1064,9 +1067,9 @@ mod test {\n         let _t = Thread::spawn(move|| {\n             let mut s = TcpStream::connect(addr);\n             s.write(&[1]).unwrap();\n-            rx.recv();\n+            rx.recv().unwrap();\n             s.write(&[2]).unwrap();\n-            rx.recv();\n+            rx.recv().unwrap();\n         });\n \n         let mut s1 = acceptor.accept().unwrap();\n@@ -1077,14 +1080,14 @@ mod test {\n             let mut s2 = s2;\n             let mut buf = [0, 0];\n             s2.read(&mut buf).unwrap();\n-            tx2.send(());\n-            done.send(());\n+            tx2.send(()).unwrap();\n+            done.send(()).unwrap();\n         });\n         let mut buf = [0, 0];\n         s1.read(&mut buf).unwrap();\n-        tx1.send(());\n+        tx1.send(()).unwrap();\n \n-        rx.recv();\n+        rx.recv().unwrap();\n     }\n \n     #[test]\n@@ -1106,11 +1109,11 @@ mod test {\n         let _t = Thread::spawn(move|| {\n             let mut s2 = s2;\n             s2.write(&[1]).unwrap();\n-            done.send(());\n+            done.send(()).unwrap();\n         });\n         s1.write(&[2]).unwrap();\n \n-        rx.recv();\n+        rx.recv().unwrap();\n     }\n \n     #[test]\n@@ -1152,9 +1155,9 @@ mod test {\n         if !cfg!(target_os = \"freebsd\") {\n             let (tx, rx) = channel();\n             let _t = Thread::spawn(move|| {\n-                tx.send(TcpStream::connect(addr).unwrap());\n+                tx.send(TcpStream::connect(addr).unwrap()).unwrap();\n             });\n-            let _l = rx.recv();\n+            let _l = rx.recv().unwrap();\n             for i in range(0i, 1001) {\n                 match a.accept() {\n                     Ok(..) => break,\n@@ -1182,7 +1185,7 @@ mod test {\n         Thread::spawn(move|| {\n             let mut a = a;\n             let _s = a.accept().unwrap();\n-            let _ = rx.recv_opt();\n+            let _ = rx.recv().unwrap();\n         }).detach();\n \n         let mut b = [0];\n@@ -1219,7 +1222,7 @@ mod test {\n         Thread::spawn(move|| {\n             let mut a = a;\n             let _s = a.accept().unwrap();\n-            let _ = rx.recv_opt();\n+            let _ = rx.recv().unwrap();\n         }).detach();\n \n         let mut s = TcpStream::connect(addr).unwrap();\n@@ -1228,13 +1231,13 @@ mod test {\n         let _t = Thread::spawn(move|| {\n             let mut s2 = s2;\n             assert!(s2.read(&mut [0]).is_err());\n-            tx.send(());\n+            tx.send(()).unwrap();\n         });\n         // this should wake up the child task\n         s.close_read().unwrap();\n \n         // this test will never finish if the child doesn't wake up\n-        rx.recv();\n+        rx.recv().unwrap();\n     }\n \n     #[test]\n@@ -1244,9 +1247,9 @@ mod test {\n         let (tx, rx) = channel::<()>();\n         Thread::spawn(move|| {\n             let mut s = TcpStream::connect(addr).unwrap();\n-            rx.recv();\n+            rx.recv().unwrap();\n             assert!(s.write(&[0]).is_ok());\n-            let _ = rx.recv_opt();\n+            let _ = rx.recv();\n         }).detach();\n \n         let mut s = a.accept().unwrap();\n@@ -1265,7 +1268,7 @@ mod test {\n         }\n         assert_eq!(s.write(&[0]).err().unwrap().kind, TimedOut);\n \n-        tx.send(());\n+        tx.send(()).unwrap();\n         s.set_timeout(None);\n         assert_eq!(s.read(&mut [0, 0]), Ok(1));\n     }\n@@ -1277,23 +1280,23 @@ mod test {\n         let (tx, rx) = channel::<()>();\n         Thread::spawn(move|| {\n             let mut s = TcpStream::connect(addr).unwrap();\n-            rx.recv();\n+            rx.recv().unwrap();\n             let mut amt = 0;\n             while amt < 100 * 128 * 1024 {\n                 match s.read(&mut [0, ..128 * 1024]) {\n                     Ok(n) => { amt += n; }\n                     Err(e) => panic!(\"{}\", e),\n                 }\n             }\n-            let _ = rx.recv_opt();\n+            let _ = rx.recv();\n         }).detach();\n \n         let mut s = a.accept().unwrap();\n         s.set_read_timeout(Some(20));\n         assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n         assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n \n-        tx.send(());\n+        tx.send(()).unwrap();\n         for _ in range(0i, 100) {\n             assert!(s.write(&[0, ..128 * 1024]).is_ok());\n         }\n@@ -1306,9 +1309,9 @@ mod test {\n         let (tx, rx) = channel::<()>();\n         Thread::spawn(move|| {\n             let mut s = TcpStream::connect(addr).unwrap();\n-            rx.recv();\n+            rx.recv().unwrap();\n             assert!(s.write(&[0]).is_ok());\n-            let _ = rx.recv_opt();\n+            let _ = rx.recv();\n         }).detach();\n \n         let mut s = a.accept().unwrap();\n@@ -1323,7 +1326,7 @@ mod test {\n         }\n         assert_eq!(s.write(&[0]).err().unwrap().kind, TimedOut);\n \n-        tx.send(());\n+        tx.send(()).unwrap();\n         assert!(s.read(&mut [0]).is_ok());\n     }\n \n@@ -1334,9 +1337,9 @@ mod test {\n         let (tx, rx) = channel::<()>();\n         Thread::spawn(move|| {\n             let mut s = TcpStream::connect(addr).unwrap();\n-            rx.recv();\n+            rx.recv().unwrap();\n             assert_eq!(s.write(&[0]), Ok(()));\n-            let _ = rx.recv_opt();\n+            let _ = rx.recv();\n         }).detach();\n \n         let mut s = a.accept().unwrap();\n@@ -1345,14 +1348,14 @@ mod test {\n         let _t = Thread::spawn(move|| {\n             let mut s2 = s2;\n             assert_eq!(s2.read(&mut [0]), Ok(1));\n-            tx2.send(());\n+            tx2.send(()).unwrap();\n         });\n \n         s.set_read_timeout(Some(20));\n         assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n-        tx.send(());\n+        tx.send(()).unwrap();\n \n-        rx2.recv();\n+        rx2.recv().unwrap();\n     }\n \n     #[test]\n@@ -1367,9 +1370,9 @@ mod test {\n         let txdone2 = txdone.clone();\n         let _t = Thread::spawn(move|| {\n             let mut tcp = TcpStream::connect(addr).unwrap();\n-            rx.recv();\n+            rx.recv().unwrap();\n             tcp.write_u8(0).unwrap();\n-            txdone2.send(());\n+            txdone2.send(()).unwrap();\n         });\n \n         // Spawn off a reading clone\n@@ -1379,7 +1382,7 @@ mod test {\n         let _t = Thread::spawn(move|| {\n             let mut tcp2 = tcp2;\n             tcp2.read_u8().unwrap();\n-            txdone3.send(());\n+            txdone3.send(()).unwrap();\n         });\n \n         // Try to ensure that the reading clone is indeed reading\n@@ -1390,9 +1393,9 @@ mod test {\n         // clone the handle again while it's reading, then let it finish the\n         // read.\n         let _ = tcp.clone();\n-        tx.send(());\n-        rxdone.recv();\n-        rxdone.recv();\n+        tx.send(()).unwrap();\n+        rxdone.recv().unwrap();\n+        rxdone.recv().unwrap();\n     }\n \n     #[test]\n@@ -1423,8 +1426,14 @@ mod test {\n         let (tx, rx) = channel();\n         let tx2 = tx.clone();\n \n-        let _t = Thread::spawn(move|| { let mut a = a; tx.send(a.accept()) });\n-        let _t = Thread::spawn(move|| { let mut a = a2; tx2.send(a.accept()) });\n+        let _t = Thread::spawn(move|| {\n+            let mut a = a;\n+            tx.send(a.accept()).unwrap();\n+        });\n+        let _t = Thread::spawn(move|| {\n+            let mut a = a2;\n+            tx2.send(a.accept()).unwrap();\n+        });\n \n         let _t = Thread::spawn(move|| {\n             let _ = TcpStream::connect(addr);\n@@ -1433,8 +1442,8 @@ mod test {\n             let _ = TcpStream::connect(addr);\n         });\n \n-        assert!(rx.recv().is_ok());\n-        assert!(rx.recv().is_ok());\n+        assert!(rx.recv().unwrap().is_ok());\n+        assert!(rx.recv().unwrap().is_ok());\n     }\n \n     #[test]\n@@ -1457,10 +1466,10 @@ mod test {\n         let (tx, rx) = channel();\n         let _t = Thread::spawn(move|| {\n             let mut a = a;\n-            tx.send(a.accept());\n+            tx.send(a.accept()).unwrap();\n         });\n         a2.close_accept().unwrap();\n \n-        assert_eq!(rx.recv().err().unwrap().kind, EndOfFile);\n+        assert_eq!(rx.recv().unwrap().err().unwrap().kind, EndOfFile);\n     }\n }"}, {"sha": "d6c379cc9f7609f0f8b2b49e5a659abcb6edbe43", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -250,10 +250,10 @@ impl Writer for UdpStream {\n mod test {\n     use prelude::v1::*;\n \n-    use comm::channel;\n-    use io::*;\n+    use sync::mpsc::channel;\n     use io::net::ip::*;\n     use io::test::*;\n+    use io::{IoError, TimedOut, PermissionDenied, ShortWrite};\n     use super::*;\n     use thread::Thread;\n \n@@ -278,17 +278,17 @@ mod test {\n         let _t = Thread::spawn(move|| {\n             match UdpSocket::bind(client_ip) {\n                 Ok(ref mut client) => {\n-                    rx1.recv();\n+                    rx1.recv().unwrap();\n                     client.send_to(&[99], server_ip).unwrap()\n                 }\n                 Err(..) => panic!()\n             }\n-            tx2.send(());\n+            tx2.send(()).unwrap();\n         });\n \n         match UdpSocket::bind(server_ip) {\n             Ok(ref mut server) => {\n-                tx1.send(());\n+                tx1.send(()).unwrap();\n                 let mut buf = [0];\n                 match server.recv_from(&mut buf) {\n                     Ok((nread, src)) => {\n@@ -301,7 +301,7 @@ mod test {\n             }\n             Err(..) => panic!()\n         }\n-        rx2.recv();\n+        rx2.recv().unwrap();\n     }\n \n     #[test]\n@@ -313,7 +313,7 @@ mod test {\n         let _t = Thread::spawn(move|| {\n             match UdpSocket::bind(client_ip) {\n                 Ok(ref mut client) => {\n-                    rx.recv();\n+                    rx.recv().unwrap();\n                     client.send_to(&[99], server_ip).unwrap()\n                 }\n                 Err(..) => panic!()\n@@ -322,7 +322,7 @@ mod test {\n \n         match UdpSocket::bind(server_ip) {\n             Ok(ref mut server) => {\n-                tx.send(());\n+                tx.send(()).unwrap();\n                 let mut buf = [0];\n                 match server.recv_from(&mut buf) {\n                     Ok((nread, src)) => {\n@@ -357,17 +357,17 @@ mod test {\n                     Err(..) => panic!()\n                 }\n             };\n-            rx1.recv();\n+            rx1.recv().unwrap();\n             send_as(dummy_ip, &[98]);\n             send_as(client_ip, &[99]);\n-            tx2.send(());\n+            tx2.send(()).unwrap();\n         });\n \n         match UdpSocket::bind(server_ip) {\n             Ok(server) => {\n                 let server = box server;\n                 let mut stream = server.connect(client_ip);\n-                tx1.send(());\n+                tx1.send(()).unwrap();\n                 let mut buf = [0];\n                 match stream.read(&mut buf) {\n                     Ok(nread) => {\n@@ -379,7 +379,7 @@ mod test {\n             }\n             Err(..) => panic!()\n         }\n-        rx2.recv();\n+        rx2.recv().unwrap();\n     }\n \n     #[test]\n@@ -395,19 +395,19 @@ mod test {\n                 Ok(client) => {\n                     let client = box client;\n                     let mut stream = client.connect(server_ip);\n-                    rx1.recv();\n+                    rx1.recv().unwrap();\n                     stream.write(&[99]).unwrap();\n                 }\n                 Err(..) => panic!()\n             }\n-            tx2.send(());\n+            tx2.send(()).unwrap();\n         });\n \n         match UdpSocket::bind(server_ip) {\n             Ok(server) => {\n                 let server = box server;\n                 let mut stream = server.connect(client_ip);\n-                tx1.send(());\n+                tx1.send(()).unwrap();\n                 let mut buf = [0];\n                 match stream.read(&mut buf) {\n                     Ok(nread) => {\n@@ -419,7 +419,7 @@ mod test {\n             }\n             Err(..) => panic!()\n         }\n-        rx2.recv();\n+        rx2.recv().unwrap();\n     }\n \n     pub fn socket_name(addr: SocketAddr) {\n@@ -466,14 +466,14 @@ mod test {\n         let (tx2, rx2) = channel();\n         let _t = Thread::spawn(move|| {\n             let mut sock3 = sock3;\n-            rx1.recv();\n+            rx1.recv().unwrap();\n             sock3.send_to(&[1], addr2).unwrap();\n-            tx2.send(());\n+            tx2.send(()).unwrap();\n         });\n-        tx1.send(());\n+        tx1.send(()).unwrap();\n         let mut buf = [0, 0];\n         assert_eq!(sock1.recv_from(&mut buf), Ok((1, addr2)));\n-        rx2.recv();\n+        rx2.recv().unwrap();\n     }\n \n     #[test]\n@@ -488,9 +488,9 @@ mod test {\n         let _t = Thread::spawn(move|| {\n             let mut sock2 = sock2;\n             sock2.send_to(&[1], addr1).unwrap();\n-            rx.recv();\n+            rx.recv().unwrap();\n             sock2.send_to(&[2], addr1).unwrap();\n-            rx.recv();\n+            rx.recv().unwrap();\n         });\n \n         let sock3 = sock1.clone();\n@@ -500,14 +500,14 @@ mod test {\n             let mut sock3 = sock3;\n             let mut buf = [0, 0];\n             sock3.recv_from(&mut buf).unwrap();\n-            tx2.send(());\n-            done.send(());\n+            tx2.send(()).unwrap();\n+            done.send(()).unwrap();\n         });\n         let mut buf = [0, 0];\n         sock1.recv_from(&mut buf).unwrap();\n-        tx1.send(());\n+        tx1.send(()).unwrap();\n \n-        rx.recv();\n+        rx.recv().unwrap();\n     }\n \n     #[test]\n@@ -524,12 +524,12 @@ mod test {\n             let mut sock2 = sock2;\n             let mut buf = [0, 1];\n \n-            rx.recv();\n+            rx.recv().unwrap();\n             match sock2.recv_from(&mut buf) {\n                 Ok(..) => {}\n                 Err(e) => panic!(\"failed receive: {}\", e),\n             }\n-            serv_tx.send(());\n+            serv_tx.send(()).unwrap();\n         });\n \n         let sock3 = sock1.clone();\n@@ -539,19 +539,19 @@ mod test {\n         let _t = Thread::spawn(move|| {\n             let mut sock3 = sock3;\n             match sock3.send_to(&[1], addr2) {\n-                Ok(..) => { let _ = tx2.send_opt(()); }\n+                Ok(..) => { let _ = tx2.send(()); }\n                 Err(..) => {}\n             }\n-            done.send(());\n+            done.send(()).unwrap();\n         });\n         match sock1.send_to(&[2], addr2) {\n-            Ok(..) => { let _ = tx.send_opt(()); }\n+            Ok(..) => { let _ = tx.send(()); }\n             Err(..) => {}\n         }\n         drop(tx);\n \n-        rx.recv();\n-        serv_rx.recv();\n+        rx.recv().unwrap();\n+        serv_rx.recv().unwrap();\n     }\n \n     #[cfg(not(windows))] // FIXME #17553\n@@ -568,10 +568,10 @@ mod test {\n             let mut a = a2;\n             assert_eq!(a.recv_from(&mut [0]), Ok((1, addr1)));\n             assert_eq!(a.send_to(&[0], addr1), Ok(()));\n-            rx.recv();\n+            rx.recv().unwrap();\n             assert_eq!(a.send_to(&[0], addr1), Ok(()));\n \n-            tx2.send(());\n+            tx2.send(()).unwrap();\n         });\n \n         // Make sure that reads time out, but writes can continue\n@@ -586,11 +586,11 @@ mod test {\n \n         // Clearing the timeout should allow for receiving\n         a.set_timeout(None);\n-        tx.send(());\n+        tx.send(()).unwrap();\n         assert_eq!(a2.recv_from(&mut [0]), Ok((1, addr2)));\n \n         // Make sure the child didn't die\n-        rx2.recv();\n+        rx2.recv().unwrap();\n     }\n \n     #[test]"}, {"sha": "ee3766582838a0dcefa165f15b94d663bf956dc9", "filename": "src/libstd/io/pipe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fpipe.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -114,7 +114,7 @@ impl Writer for PipeStream {\n mod test {\n     use prelude::v1::*;\n \n-    use comm::channel;\n+    use sync::mpsc::channel;\n     use thread::Thread;\n \n     #[test]\n@@ -129,11 +129,11 @@ mod test {\n         let _t = Thread::spawn(move|| {\n             let mut out = out;\n             out.write(&[10]).unwrap();\n-            rx.recv(); // don't close the pipe until the other read has finished\n+            rx.recv().unwrap(); // don't close the pipe until the other read has finished\n         });\n \n         let mut buf = [0, ..10];\n         input.read(&mut buf).unwrap();\n-        tx.send(());\n+        tx.send(()).unwrap();\n     }\n }"}, {"sha": "1e008287a3167af4b5604c683f429514354897b5", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -20,7 +20,6 @@ use prelude::v1::*;\n \n use c_str::{CString, ToCStr};\n use collections::HashMap;\n-use comm::{channel, Receiver};\n use fmt;\n use hash::Hash;\n use io::pipe::{PipeStream, PipePair};\n@@ -29,6 +28,7 @@ use io;\n use libc;\n use os;\n use path::BytesContainer;\n+use sync::mpsc::{channel, Receiver};\n use sys::fs::FileDesc;\n use sys::process::Process as ProcessImp;\n use sys;\n@@ -693,10 +693,10 @@ impl Process {\n                 Some(stream) => {\n                     Thread::spawn(move |:| {\n                         let mut stream = stream;\n-                        tx.send(stream.read_to_end())\n+                        tx.send(stream.read_to_end()).unwrap();\n                     }).detach();\n                 }\n-                None => tx.send(Ok(Vec::new()))\n+                None => tx.send(Ok(Vec::new())).unwrap()\n             }\n             rx\n         }\n@@ -707,8 +707,8 @@ impl Process {\n \n         Ok(ProcessOutput {\n             status: status,\n-            output: stdout.recv().ok().unwrap_or(Vec::new()),\n-            error:  stderr.recv().ok().unwrap_or(Vec::new()),\n+            output: stdout.recv().unwrap().unwrap_or(Vec::new()),\n+            error:  stderr.recv().unwrap().unwrap_or(Vec::new()),\n         })\n     }\n \n@@ -743,13 +743,15 @@ impl Drop for Process {\n mod tests {\n     use prelude::v1::*;\n \n-    use comm::channel;\n-    use io::*;\n     use io::fs::PathExtensions;\n+    use io::process;\n     use io::timer::*;\n+    use io::{Truncate, Write, TimedOut, timer, FileNotFound};\n     use rt::running_on_valgrind;\n     use str;\n-    use super::*;\n+    use super::{CreatePipe};\n+    use super::{InheritFd, Process, PleaseExitSignal, Command, ProcessOutput};\n+    use sync::mpsc::channel;\n     use thread::Thread;\n     use time::Duration;\n \n@@ -1160,17 +1162,17 @@ mod tests {\n             p.set_timeout(Some(10));\n             assert_eq!(p.wait().err().unwrap().kind, TimedOut);\n             p.signal_kill().unwrap();\n-            tx.send(());\n+            tx.send(()).unwrap();\n         });\n         let _t = Thread::spawn(move|| {\n             let mut p = sleeper();\n             p.set_timeout(Some(10));\n             assert_eq!(p.wait().err().unwrap().kind, TimedOut);\n             p.signal_kill().unwrap();\n-            tx2.send(());\n+            tx2.send(()).unwrap();\n         });\n-        rx.recv();\n-        rx.recv();\n+        rx.recv().unwrap();\n+        rx.recv().unwrap();\n     }\n \n     #[test]"}, {"sha": "74b0930a1450040e0fb74af1e563bf09bdde5aad", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -543,7 +543,7 @@ mod tests {\n     use prelude::v1::*;\n \n     use super::*;\n-    use comm::channel;\n+    use sync::mpsc::channel;\n     use thread::Thread;\n \n     #[test]"}, {"sha": "e073f76af825ce77628696d262a99af136589f6b", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 43, "deletions": 45, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -15,7 +15,7 @@\n \n // FIXME: These functions take Durations but only pass ms to the backend impls.\n \n-use comm::{Receiver, Sender, channel};\n+use sync::mpsc::{Receiver, Sender, channel};\n use time::Duration;\n use io::IoResult;\n use sys::timer::Callback;\n@@ -40,11 +40,11 @@ use sys::timer::Timer as TimerImp;\n ///\n /// let timeout = timer.oneshot(Duration::milliseconds(10));\n /// // do some work\n-/// timeout.recv(); // wait for the timeout to expire\n+/// timeout.recv().unwrap(); // wait for the timeout to expire\n ///\n /// let periodic = timer.periodic(Duration::milliseconds(10));\n /// loop {\n-///     periodic.recv();\n+///     periodic.recv().unwrap();\n ///     // this loop is only executed once every 10ms\n /// }\n /// # }\n@@ -126,7 +126,7 @@ impl Timer {\n     /// for _ in range(0u, 100) { /* do work */ }\n     ///\n     /// // blocks until 10 ms after the `oneshot` call\n-    /// ten_milliseconds.recv();\n+    /// ten_milliseconds.recv().unwrap();\n     /// ```\n     ///\n     /// ```rust\n@@ -136,7 +136,7 @@ impl Timer {\n     /// // Incorrect, method chaining-style:\n     /// let mut five_ms = Timer::new().unwrap().oneshot(Duration::milliseconds(5));\n     /// // The timer object was destroyed, so this will always fail:\n-    /// // five_ms.recv()\n+    /// // five_ms.recv().unwrap()\n     /// ```\n     ///\n     /// When provided a zero or negative `duration`, the message will\n@@ -147,7 +147,7 @@ impl Timer {\n         if in_ms_u64(duration) != 0 {\n             self.inner.oneshot(in_ms_u64(duration), box TimerCallback { tx: tx });\n         } else {\n-            tx.send(());\n+            tx.send(()).unwrap();\n         }\n         return rx\n     }\n@@ -178,13 +178,13 @@ impl Timer {\n     /// for _ in range(0u, 100) { /* do work */ }\n     ///\n     /// // blocks until 10 ms after the `periodic` call\n-    /// ten_milliseconds.recv();\n+    /// ten_milliseconds.recv().unwrap();\n     ///\n     /// for _ in range(0u, 100) { /* do work */ }\n     ///\n     /// // blocks until 20 ms after the `periodic` call (*not* 10ms after the\n     /// // previous `recv`)\n-    /// ten_milliseconds.recv();\n+    /// ten_milliseconds.recv().unwrap();\n     /// ```\n     ///\n     /// ```rust\n@@ -194,7 +194,7 @@ impl Timer {\n     /// // Incorrect, method chaining-style.\n     /// let mut five_ms = Timer::new().unwrap().periodic(Duration::milliseconds(5));\n     /// // The timer object was destroyed, so this will always fail:\n-    /// // five_ms.recv()\n+    /// // five_ms.recv().unwrap()\n     /// ```\n     ///\n     /// When provided a zero or negative `duration`, the messages will\n@@ -213,7 +213,7 @@ impl Timer {\n \n impl Callback for TimerCallback {\n     fn call(&mut self) {\n-        let _ = self.tx.send_opt(());\n+        let _ = self.tx.send(());\n     }\n }\n \n@@ -225,8 +225,6 @@ fn in_ms_u64(d: Duration) -> u64 {\n \n #[cfg(test)]\n mod test {\n-    use prelude::v1::*;\n-\n     use super::Timer;\n     use thread::Thread;\n     use time::Duration;\n@@ -240,7 +238,7 @@ mod test {\n     #[test]\n     fn test_io_timer_sleep_oneshot() {\n         let mut timer = Timer::new().unwrap();\n-        timer.oneshot(Duration::milliseconds(1)).recv();\n+        timer.oneshot(Duration::milliseconds(1)).recv().unwrap();\n     }\n \n     #[test]\n@@ -254,8 +252,8 @@ mod test {\n         let mut timer = Timer::new().unwrap();\n         let rx1 = timer.oneshot(Duration::milliseconds(10000));\n         let rx = timer.oneshot(Duration::milliseconds(1));\n-        rx.recv();\n-        assert_eq!(rx1.recv_opt(), Err(()));\n+        rx.recv().unwrap();\n+        assert!(rx1.recv().is_err());\n     }\n \n     #[test]\n@@ -264,16 +262,16 @@ mod test {\n         let rx = timer.oneshot(Duration::milliseconds(100000000));\n         timer.sleep(Duration::milliseconds(1)); // this should invalidate rx\n \n-        assert_eq!(rx.recv_opt(), Err(()));\n+        assert!(rx.recv().is_err());\n     }\n \n     #[test]\n     fn test_io_timer_sleep_periodic() {\n         let mut timer = Timer::new().unwrap();\n         let rx = timer.periodic(Duration::milliseconds(1));\n-        rx.recv();\n-        rx.recv();\n-        rx.recv();\n+        rx.recv().unwrap();\n+        rx.recv().unwrap();\n+        rx.recv().unwrap();\n     }\n \n     #[test]\n@@ -292,12 +290,12 @@ mod test {\n         let mut timer = Timer::new().unwrap();\n \n         let rx = timer.oneshot(Duration::milliseconds(1));\n-        rx.recv();\n-        assert!(rx.recv_opt().is_err());\n+        rx.recv().unwrap();\n+        assert!(rx.recv().is_err());\n \n         let rx = timer.oneshot(Duration::milliseconds(1));\n-        rx.recv();\n-        assert!(rx.recv_opt().is_err());\n+        rx.recv().unwrap();\n+        assert!(rx.recv().is_err());\n     }\n \n     #[test]\n@@ -306,20 +304,20 @@ mod test {\n         let orx = timer.oneshot(Duration::milliseconds(100));\n         let prx = timer.periodic(Duration::milliseconds(100));\n         timer.sleep(Duration::milliseconds(1));\n-        assert_eq!(orx.recv_opt(), Err(()));\n-        assert_eq!(prx.recv_opt(), Err(()));\n-        timer.oneshot(Duration::milliseconds(1)).recv();\n+        assert!(orx.recv().is_err());\n+        assert!(prx.recv().is_err());\n+        timer.oneshot(Duration::milliseconds(1)).recv().unwrap();\n     }\n \n     #[test]\n     fn period() {\n         let mut timer = Timer::new().unwrap();\n         let rx = timer.periodic(Duration::milliseconds(1));\n-        rx.recv();\n-        rx.recv();\n+        rx.recv().unwrap();\n+        rx.recv().unwrap();\n         let rx2 = timer.periodic(Duration::milliseconds(1));\n-        rx2.recv();\n-        rx2.recv();\n+        rx2.recv().unwrap();\n+        rx2.recv().unwrap();\n     }\n \n     #[test]\n@@ -359,7 +357,7 @@ mod test {\n         let timer_rx = timer.periodic(Duration::milliseconds(1000));\n \n         Thread::spawn(move|| {\n-            let _ = timer_rx.recv_opt();\n+            let _ = timer_rx.recv();\n         }).detach();\n \n         // when we drop the TimerWatcher we're going to destroy the channel,\n@@ -373,7 +371,7 @@ mod test {\n         let timer_rx = timer.periodic(Duration::milliseconds(1000));\n \n         Thread::spawn(move|| {\n-            let _ = timer_rx.recv_opt();\n+            let _ = timer_rx.recv();\n         }).detach();\n \n         timer.oneshot(Duration::milliseconds(1));\n@@ -386,7 +384,7 @@ mod test {\n         let timer_rx = timer.periodic(Duration::milliseconds(1000));\n \n         Thread::spawn(move|| {\n-            let _ = timer_rx.recv_opt();\n+            let _ = timer_rx.recv();\n         }).detach();\n \n         timer.sleep(Duration::milliseconds(1));\n@@ -398,7 +396,7 @@ mod test {\n             let mut timer = Timer::new().unwrap();\n             timer.oneshot(Duration::milliseconds(1000))\n         };\n-        assert_eq!(rx.recv_opt(), Err(()));\n+        assert!(rx.recv().is_err());\n     }\n \n     #[test]\n@@ -407,7 +405,7 @@ mod test {\n             let mut timer = Timer::new().unwrap();\n             timer.periodic(Duration::milliseconds(1000))\n         };\n-        assert_eq!(rx.recv_opt(), Err(()));\n+        assert!(rx.recv().is_err());\n     }\n \n     #[test]\n@@ -446,34 +444,34 @@ mod test {\n     fn oneshot_zero() {\n         let mut timer = Timer::new().unwrap();\n         let rx = timer.oneshot(Duration::milliseconds(0));\n-        rx.recv();\n+        rx.recv().unwrap();\n     }\n \n     #[test]\n     fn oneshot_negative() {\n         let mut timer = Timer::new().unwrap();\n         let rx = timer.oneshot(Duration::milliseconds(-1000000));\n-        rx.recv();\n+        rx.recv().unwrap();\n     }\n \n     #[test]\n     fn periodic_zero() {\n         let mut timer = Timer::new().unwrap();\n         let rx = timer.periodic(Duration::milliseconds(0));\n-        rx.recv();\n-        rx.recv();\n-        rx.recv();\n-        rx.recv();\n+        rx.recv().unwrap();\n+        rx.recv().unwrap();\n+        rx.recv().unwrap();\n+        rx.recv().unwrap();\n     }\n \n     #[test]\n     fn periodic_negative() {\n         let mut timer = Timer::new().unwrap();\n         let rx = timer.periodic(Duration::milliseconds(-1000000));\n-        rx.recv();\n-        rx.recv();\n-        rx.recv();\n-        rx.recv();\n+        rx.recv().unwrap();\n+        rx.recv().unwrap();\n+        rx.recv().unwrap();\n+        rx.recv().unwrap();\n     }\n \n }"}, {"sha": "b22090e0f163adad16ef5f63a34417097d678372", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -384,7 +384,7 @@ mod test {\n         let mut r = TeeReader::new(MemReader::new(vec!(0, 1, 2)),\n                                    Vec::new());\n         assert_eq!(vec!(0, 1, 2), r.read_to_end().unwrap());\n-        let (_, w) = r.unwrap();\n+        let (_, w) = r.into_inner();\n         assert_eq!(vec!(0, 1, 2), w);\n     }\n "}, {"sha": "aa1a0add0681a7f12ba7eb2e1169777a512522e3", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -226,7 +226,6 @@ pub mod hash;\n pub mod task;\n pub mod thread;\n pub mod sync;\n-pub mod comm;\n \n #[cfg(unix)]\n #[path = \"sys/unix/mod.rs\"] mod sys;\n@@ -254,7 +253,7 @@ mod std {\n     pub use cmp;\n     pub use hash;\n \n-    pub use comm; // used for select!()\n+    pub use sync; // used for select!()\n     pub use error; // used for try!()\n     pub use fmt; // used for any formatting strings\n     pub use io; // used for println!()"}, {"sha": "51a0853687ebeae5438c3ad63b5d31d7745f9faa", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -474,7 +474,7 @@ macro_rules! vec {\n ///\n /// ```\n /// use std::thread::Thread;\n-/// use std::comm::channel;\n+/// use std::sync::mpsc::channel;\n ///\n /// let (tx1, rx1) = channel();\n /// let (tx2, rx2) = channel();\n@@ -485,21 +485,21 @@ macro_rules! vec {\n /// Thread::spawn(move|| { tx2.send(calculate_the_answer()) }).detach();\n ///\n /// select! (\n-///     () = rx1.recv() => println!(\"the long running task finished first\"),\n+///     _ = rx1.recv() => println!(\"the long running task finished first\"),\n ///     answer = rx2.recv() => {\n-///         println!(\"the answer was: {}\", answer);\n+///         println!(\"the answer was: {}\", answer.unwrap());\n ///     }\n /// )\n /// ```\n ///\n-/// For more information about select, see the `std::comm::Select` structure.\n+/// For more information about select, see the `std::sync::mpsc::Select` structure.\n #[macro_export]\n #[experimental]\n macro_rules! select {\n     (\n         $($name:pat = $rx:ident.$meth:ident() => $code:expr),+\n     ) => ({\n-        use std::comm::Select;\n+        use std::sync::mpsc::Select;\n         let sel = Select::new();\n         $( let mut $rx = sel.handle(&$rx); )+\n         unsafe {"}, {"sha": "f2a0419e39196f584bb44fa645e3e6886fbc8948", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -496,23 +496,25 @@ mod tests {\n \n     #[test]\n     fn test_real_consts() {\n-        let pi: f32 = Float::pi();\n-        let two_pi: f32 = Float::two_pi();\n-        let frac_pi_2: f32 = Float::frac_pi_2();\n-        let frac_pi_3: f32 = Float::frac_pi_3();\n-        let frac_pi_4: f32 = Float::frac_pi_4();\n-        let frac_pi_6: f32 = Float::frac_pi_6();\n-        let frac_pi_8: f32 = Float::frac_pi_8();\n-        let frac_1_pi: f32 = Float::frac_1_pi();\n-        let frac_2_pi: f32 = Float::frac_2_pi();\n-        let frac_2_sqrtpi: f32 = Float::frac_2_sqrtpi();\n-        let sqrt2: f32 = Float::sqrt2();\n-        let frac_1_sqrt2: f32 = Float::frac_1_sqrt2();\n-        let e: f32 = Float::e();\n-        let log2_e: f32 = Float::log2_e();\n-        let log10_e: f32 = Float::log10_e();\n-        let ln_2: f32 = Float::ln_2();\n-        let ln_10: f32 = Float::ln_10();\n+        use super::consts;\n+\n+        let pi: f32 = consts::PI;\n+        let two_pi: f32 = consts::PI_2;\n+        let frac_pi_2: f32 = consts::FRAC_PI_2;\n+        let frac_pi_3: f32 = consts::FRAC_PI_3;\n+        let frac_pi_4: f32 = consts::FRAC_PI_4;\n+        let frac_pi_6: f32 = consts::FRAC_PI_6;\n+        let frac_pi_8: f32 = consts::FRAC_PI_8;\n+        let frac_1_pi: f32 = consts::FRAC_1_PI;\n+        let frac_2_pi: f32 = consts::FRAC_2_PI;\n+        let frac_2_sqrtpi: f32 = consts::FRAC_2_SQRTPI;\n+        let sqrt2: f32 = consts::SQRT2;\n+        let frac_1_sqrt2: f32 = consts::FRAC_1_SQRT2;\n+        let e: f32 = consts::E;\n+        let log2_e: f32 = consts::LOG2_E;\n+        let log10_e: f32 = consts::LOG10_E;\n+        let ln_2: f32 = consts::LN_2;\n+        let ln_10: f32 = consts::LN_10;\n \n         assert_approx_eq!(two_pi, 2f32 * pi);\n         assert_approx_eq!(frac_pi_2, pi / 2f32);"}, {"sha": "105a8a23bd104596cf0889590f453a39775f3adc", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -499,23 +499,24 @@ mod tests {\n \n     #[test]\n     fn test_real_consts() {\n-        let pi: f64 = Float::pi();\n-        let two_pi: f64 = Float::two_pi();\n-        let frac_pi_2: f64 = Float::frac_pi_2();\n-        let frac_pi_3: f64 = Float::frac_pi_3();\n-        let frac_pi_4: f64 = Float::frac_pi_4();\n-        let frac_pi_6: f64 = Float::frac_pi_6();\n-        let frac_pi_8: f64 = Float::frac_pi_8();\n-        let frac_1_pi: f64 = Float::frac_1_pi();\n-        let frac_2_pi: f64 = Float::frac_2_pi();\n-        let frac_2_sqrtpi: f64 = Float::frac_2_sqrtpi();\n-        let sqrt2: f64 = Float::sqrt2();\n-        let frac_1_sqrt2: f64 = Float::frac_1_sqrt2();\n-        let e: f64 = Float::e();\n-        let log2_e: f64 = Float::log2_e();\n-        let log10_e: f64 = Float::log10_e();\n-        let ln_2: f64 = Float::ln_2();\n-        let ln_10: f64 = Float::ln_10();\n+        use super::consts;\n+        let pi: f64 = consts::PI;\n+        let two_pi: f64 = consts::PI_2;\n+        let frac_pi_2: f64 = consts::FRAC_PI_2;\n+        let frac_pi_3: f64 = consts::FRAC_PI_3;\n+        let frac_pi_4: f64 = consts::FRAC_PI_4;\n+        let frac_pi_6: f64 = consts::FRAC_PI_6;\n+        let frac_pi_8: f64 = consts::FRAC_PI_8;\n+        let frac_1_pi: f64 = consts::FRAC_1_PI;\n+        let frac_2_pi: f64 = consts::FRAC_2_PI;\n+        let frac_2_sqrtpi: f64 = consts::FRAC_2_SQRTPI;\n+        let sqrt2: f64 = consts::SQRT2;\n+        let frac_1_sqrt2: f64 = consts::FRAC_1_SQRT2;\n+        let e: f64 = consts::E;\n+        let log2_e: f64 = consts::LOG2_E;\n+        let log10_e: f64 = consts::LOG10_E;\n+        let ln_2: f64 = consts::LN_2;\n+        let ln_10: f64 = consts::LN_10;\n \n         assert_approx_eq!(two_pi, 2.0 * pi);\n         assert_approx_eq!(frac_pi_2, pi / 2f64);"}, {"sha": "754b13886af7eeb10f9e0e05f7e03563bb35e8eb", "filename": "src/libstd/os.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -1425,7 +1425,8 @@ mod arch_consts {\n #[cfg(test)]\n mod tests {\n     use prelude::v1::*;\n-    use option;\n+\n+    use iter::repeat;\n     use os::{env, getcwd, getenv, make_absolute};\n     use os::{split_paths, join_paths, setenv, unsetenv};\n     use os;\n@@ -1454,15 +1455,15 @@ mod tests {\n     fn test_setenv() {\n         let n = make_rand_name();\n         setenv(n.as_slice(), \"VALUE\");\n-        assert_eq!(getenv(n.as_slice()), option::Option::Some(\"VALUE\".to_string()));\n+        assert_eq!(getenv(n.as_slice()), Some(\"VALUE\".to_string()));\n     }\n \n     #[test]\n     fn test_unsetenv() {\n         let n = make_rand_name();\n         setenv(n.as_slice(), \"VALUE\");\n         unsetenv(n.as_slice());\n-        assert_eq!(getenv(n.as_slice()), option::Option::None);\n+        assert_eq!(getenv(n.as_slice()), None);\n     }\n \n     #[test]\n@@ -1471,9 +1472,9 @@ mod tests {\n         let n = make_rand_name();\n         setenv(n.as_slice(), \"1\");\n         setenv(n.as_slice(), \"2\");\n-        assert_eq!(getenv(n.as_slice()), option::Option::Some(\"2\".to_string()));\n+        assert_eq!(getenv(n.as_slice()), Some(\"2\".to_string()));\n         setenv(n.as_slice(), \"\");\n-        assert_eq!(getenv(n.as_slice()), option::Option::Some(\"\".to_string()));\n+        assert_eq!(getenv(n.as_slice()), Some(\"\".to_string()));\n     }\n \n     // Windows GetEnvironmentVariable requires some extra work to make sure\n@@ -1490,7 +1491,7 @@ mod tests {\n         let n = make_rand_name();\n         setenv(n.as_slice(), s.as_slice());\n         debug!(\"{}\", s.clone());\n-        assert_eq!(getenv(n.as_slice()), option::Option::Some(s));\n+        assert_eq!(getenv(n.as_slice()), Some(s));\n     }\n \n     #[test]\n@@ -1527,14 +1528,14 @@ mod tests {\n             // MingW seems to set some funky environment variables like\n             // \"=C:=C:\\MinGW\\msys\\1.0\\bin\" and \"!::=::\\\" that are returned\n             // from env() but not visible from getenv().\n-            assert!(v2.is_none() || v2 == option::Option::Some(v));\n+            assert!(v2.is_none() || v2 == Some(v));\n         }\n     }\n \n     #[test]\n     fn test_env_set_get_huge() {\n         let n = make_rand_name();\n-        let s = \"x\".repeat(10000).to_string();\n+        let s = repeat(\"x\").take(10000).collect::<String>();\n         setenv(n.as_slice(), s.as_slice());\n         assert_eq!(getenv(n.as_slice()), Some(s));\n         unsetenv(n.as_slice());\n@@ -1656,8 +1657,8 @@ mod tests {\n         path.push(\"mmap_file.tmp\");\n         let size = MemoryMap::granularity() * 2;\n         let mut file = File::open_mode(&path, Open, ReadWrite).unwrap();\n-        file.seek(size as i64, SeekSet);\n-        file.write_u8(0);\n+        file.seek(size as i64, SeekSet).unwrap();\n+        file.write_u8(0).unwrap();\n \n         let chunk = MemoryMap::new(size / 2, &[\n             MapOption::MapReadable,"}, {"sha": "5c415239c5e2fcbb34073f3d9703f3eb8ab63a03", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -449,7 +449,6 @@ static dot_dot_static: &'static [u8] = b\"..\";\n mod tests {\n     use prelude::v1::*;\n     use str;\n-    use super::*;\n \n     macro_rules! t {\n         (s: $path:expr, $exp:expr) => ("}, {"sha": "9117827ffc2b467f08015d47ccb7361ef214e363", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -1119,10 +1119,13 @@ fn prefix_len(p: Option<PathPrefix>) -> uint {\n \n #[cfg(test)]\n mod tests {\n-    use prelude::v1::*;\n-    use super::*;\n+    use prelude::v1::Option::{mod, Some, None};\n+    use prelude::v1::{Vec, Clone, AsSlice, SliceExt, CloneSliceExt, IteratorExt};\n+    use prelude::v1::{DoubleEndedIteratorExt, Str, ToString, GenericPath};\n+\n     use super::PathPrefix::*;\n     use super::parse_prefix;\n+    use super::*;\n \n     macro_rules! t {\n         (s: $path:expr, $exp:expr) => ("}, {"sha": "0a7b9d07636ad7710ed786e8c1735152e10bdfbe", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -337,7 +337,7 @@ mod imp {\n mod test {\n     use prelude::v1::*;\n \n-    use comm::channel;\n+    use sync::mpsc::channel;\n     use rand::Rng;\n     use super::OsRng;\n     use thread::Thread;\n@@ -363,7 +363,7 @@ mod test {\n \n             Thread::spawn(move|| {\n                 // wait until all the tasks are ready to go.\n-                rx.recv();\n+                rx.recv().unwrap();\n \n                 // deschedule to attempt to interleave things as much\n                 // as possible (XXX: is this a good test?)\n@@ -384,7 +384,7 @@ mod test {\n \n         // start all the tasks\n         for tx in txs.iter() {\n-            tx.send(())\n+            tx.send(()).unwrap();\n         }\n     }\n }"}, {"sha": "55d50af3b8365c4b1086c472feb72def995402b8", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -92,7 +92,7 @@ mod tests {\n     use prelude::v1::*;\n \n     use sync::{Arc, Barrier};\n-    use comm::{channel, Empty};\n+    use sync::mpsc::{channel, TryRecvError};\n     use thread::Thread;\n \n     #[test]\n@@ -105,21 +105,21 @@ mod tests {\n             let tx = tx.clone();\n             Thread::spawn(move|| {\n                 c.wait();\n-                tx.send(true);\n+                tx.send(true).unwrap();\n             }).detach();\n         }\n \n         // At this point, all spawned tasks should be blocked,\n         // so we shouldn't get anything from the port\n         assert!(match rx.try_recv() {\n-            Err(Empty) => true,\n+            Err(TryRecvError::Empty) => true,\n             _ => false,\n         });\n \n         barrier.wait();\n         // Now, the barrier is cleared and we should get data.\n         for _ in range(0u, 9) {\n-            rx.recv();\n+            rx.recv().unwrap();\n         }\n     }\n }"}, {"sha": "28960c1574e92cd75e9febc82a5e3b19fc4ce538", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -264,8 +264,8 @@ impl StaticCondvar {\n mod tests {\n     use prelude::v1::*;\n \n-    use comm::channel;\n     use super::{StaticCondvar, CONDVAR_INIT};\n+    use sync::mpsc::channel;\n     use sync::{StaticMutex, MUTEX_INIT, Condvar, Mutex, Arc};\n     use thread::Thread;\n     use time::Duration;\n@@ -314,25 +314,25 @@ mod tests {\n                 let mut cnt = lock.lock();\n                 *cnt += 1;\n                 if *cnt == N {\n-                    tx.send(());\n+                    tx.send(()).unwrap();\n                 }\n                 while *cnt != 0 {\n                     cond.wait(&cnt);\n                 }\n-                tx.send(());\n+                tx.send(()).unwrap();\n             }).detach();\n         }\n         drop(tx);\n \n         let &(ref lock, ref cond) = &*data;\n-        rx.recv();\n+        rx.recv().unwrap();\n         let mut cnt = lock.lock();\n         *cnt = 0;\n         cond.notify_all();\n         drop(cnt);\n \n         for _ in range(0, N) {\n-            rx.recv();\n+            rx.recv().unwrap();\n         }\n     }\n "}, {"sha": "e3620617d5735047ff4d39ef36f2f47f98d83205", "filename": "src/libstd/sync/future.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ffuture.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -28,7 +28,7 @@ use core::prelude::*;\n use core::mem::replace;\n \n use self::FutureState::*;\n-use comm::{Receiver, channel};\n+use sync::mpsc::{Receiver, channel};\n use thunk::{Thunk};\n use thread::Thread;\n \n@@ -122,8 +122,8 @@ impl<A:Send> Future<A> {\n          * waiting for the result to be received on the port.\n          */\n \n-        Future::from_fn(move|:| {\n-            rx.recv()\n+        Future::from_fn(move |:| {\n+            rx.recv().unwrap()\n         })\n     }\n \n@@ -141,7 +141,7 @@ impl<A:Send> Future<A> {\n \n         Thread::spawn(move |:| {\n             // Don't panic if the other end has hung up\n-            let _ = tx.send_opt(blk());\n+            let _ = tx.send(blk());\n         }).detach();\n \n         Future::from_receiver(rx)\n@@ -151,7 +151,7 @@ impl<A:Send> Future<A> {\n #[cfg(test)]\n mod test {\n     use prelude::v1::*;\n-    use comm::channel;\n+    use sync::mpsc::channel;\n     use sync::Future;\n     use thread::Thread;\n \n@@ -164,7 +164,7 @@ mod test {\n     #[test]\n     fn test_from_receiver() {\n         let (tx, rx) = channel();\n-        tx.send(\"whale\".to_string());\n+        tx.send(\"whale\".to_string()).unwrap();\n         let mut f = Future::from_receiver(rx);\n         assert_eq!(f.get(), \"whale\");\n     }\n@@ -184,7 +184,7 @@ mod test {\n     #[test]\n     fn test_interface_unwrap() {\n         let f = Future::from_value(\"fail\".to_string());\n-        assert_eq!(f.unwrap(), \"fail\");\n+        assert_eq!(f.into_inner(), \"fail\");\n     }\n \n     #[test]\n@@ -213,8 +213,8 @@ mod test {\n         let f = Future::spawn(move|| { expected });\n         let _t = Thread::spawn(move|| {\n             let mut f = f;\n-            tx.send(f.get());\n+            tx.send(f.get()).unwrap();\n         });\n-        assert_eq!(rx.recv(), expected);\n+        assert_eq!(rx.recv().unwrap(), expected);\n     }\n }"}, {"sha": "2b7311e4e982b147656ec38f62f1984b154c2346", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -32,6 +32,8 @@ pub use self::future::Future;\n pub use self::task_pool::TaskPool;\n \n pub mod atomic;\n+pub mod mpsc;\n+\n mod barrier;\n mod condvar;\n mod future;"}, {"sha": "412b7161305e68b12c2d9db7adc400ad1ad834fc", "filename": "src/libstd/sync/mpsc/blocking.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "previous_filename": "src/libstd/comm/blocking.rs"}, {"sha": "e2294906229dc2d1212ad7a40a34a578c258a23c", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "renamed", "additions": 432, "deletions": 486, "changes": 918, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -8,12 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Communication primitives for concurrent tasks\n-//!\n-//! Rust makes it very difficult to share data among tasks to prevent race\n-//! conditions and to improve parallelism, but there is often a need for\n-//! communication between concurrent tasks. The primitives defined in this\n-//! module are the building blocks for synchronization in rust.\n+//! Multi-producer, single-consumer communication primitives threads\n //!\n //! This module provides message-based communication over channels, concretely\n //! defined among three types:\n@@ -23,12 +18,10 @@\n //! * `Receiver`\n //!\n //! A `Sender` or `SyncSender` is used to send data to a `Receiver`. Both\n-//! senders are clone-able such that many tasks can send simultaneously to one\n-//! receiver.  These channels are *task blocking*, not *thread blocking*. This\n-//! means that if one task is blocked on a channel, other tasks can continue to\n-//! make progress.\n+//! senders are clone-able (multi-producer) such that many threads can send\n+//! simultaneously to one receiver (single-consumer).  These channels are\n //!\n-//! Rust channels come in one of two flavors:\n+//! These channels come in two flavors:\n //!\n //! 1. An asynchronous, infinitely buffered channel. The `channel()` function\n //!    will return a `(Sender, Receiver)` tuple where all sends will be\n@@ -43,38 +36,39 @@\n //!    \"rendezvous\" channel where each sender atomically hands off a message to\n //!    a receiver.\n //!\n-//! ## Panic Propagation\n+//! ## Disconnection\n //!\n-//! In addition to being a core primitive for communicating in rust, channels\n-//! are the points at which panics are propagated among tasks.  Whenever the one\n-//! half of channel is closed, the other half will have its next operation\n-//! `panic!`. The purpose of this is to allow propagation of panics among tasks\n-//! that are linked to one another via channels.\n+//! The send and receive operations on channels will all return a `Result`\n+//! indicating whether the operation succeeded or not. An unsuccessful operation\n+//! is normally indicative of the other half of a channel having \"hung up\" by\n+//! being dropped in its corresponding thread.\n //!\n-//! There are methods on both of senders and receivers to perform their\n-//! respective operations without panicking, however.\n+//! Once half of a channel has been deallocated, most operations can no longer\n+//! continue to make progress, so `Err` will be returned. Many applications will\n+//! continue to `unwrap()` the results returned from this module, instigating a\n+//! propagation of failure among threads if one unexpectedly dies.\n //!\n-//! # Example\n+//! # Examples\n //!\n //! Simple usage:\n //!\n //! ```\n //! use std::thread::Thread;\n-//! use std::comm::channel;\n+//! use std::sync::mpsc::channel;\n //!\n //! // Create a simple streaming channel\n //! let (tx, rx) = channel();\n //! Thread::spawn(move|| {\n-//!     tx.send(10i);\n+//!     tx.send(10i).unwrap();\n //! }).detach();\n-//! assert_eq!(rx.recv(), 10i);\n+//! assert_eq!(rx.recv().unwrap(), 10i);\n //! ```\n //!\n //! Shared usage:\n //!\n //! ```\n //! use std::thread::Thread;\n-//! use std::comm::channel;\n+//! use std::sync::mpsc::channel;\n //!\n //! // Create a shared channel that can be sent along from many threads\n //! // where tx is the sending half (tx for transmission), and rx is the receiving\n@@ -83,40 +77,40 @@\n //! for i in range(0i, 10i) {\n //!     let tx = tx.clone();\n //!     Thread::spawn(move|| {\n-//!         tx.send(i);\n+//!         tx.send(i).unwrap();\n //!     }).detach()\n //! }\n //!\n //! for _ in range(0i, 10i) {\n-//!     let j = rx.recv();\n+//!     let j = rx.recv().unwrap();\n //!     assert!(0 <= j && j < 10);\n //! }\n //! ```\n //!\n //! Propagating panics:\n //!\n-//! ```should_fail\n-//! use std::comm::channel;\n+//! ```\n+//! use std::sync::mpsc::channel;\n //!\n-//! // The call to recv() will panic!() because the channel has already hung\n-//! // up (or been deallocated)\n+//! // The call to recv() will return an error because the channel has already\n+//! // hung up (or been deallocated)\n //! let (tx, rx) = channel::<int>();\n //! drop(tx);\n-//! rx.recv();\n+//! assert!(rx.recv().is_err());\n //! ```\n //!\n //! Synchronous channels:\n //!\n //! ```\n //! use std::thread::Thread;\n-//! use std::comm::sync_channel;\n+//! use std::sync::mpsc::sync_channel;\n //!\n //! let (tx, rx) = sync_channel::<int>(0);\n //! Thread::spawn(move|| {\n //!     // This will wait for the parent task to start receiving\n-//!     tx.send(53);\n+//!     tx.send(53).unwrap();\n //! }).detach();\n-//! rx.recv();\n+//! rx.recv().unwrap();\n //! ```\n //!\n //! Reading from a channel with a timeout requires to use a Timer together\n@@ -125,7 +119,7 @@\n //! after 10 seconds no matter what:\n //!\n //! ```no_run\n-//! use std::comm::channel;\n+//! use std::sync::mpsc::channel;\n //! use std::io::timer::Timer;\n //! use std::time::Duration;\n //!\n@@ -135,8 +129,8 @@\n //!\n //! loop {\n //!     select! {\n-//!         val = rx.recv() => println!(\"Received {}\", val),\n-//!         () = timeout.recv() => {\n+//!         val = rx.recv() => println!(\"Received {}\", val.unwrap()),\n+//!         _ = timeout.recv() => {\n //!             println!(\"timed out, total time was more than 10 seconds\");\n //!             break;\n //!         }\n@@ -149,7 +143,7 @@\n //! has been inactive for 5 seconds:\n //!\n //! ```no_run\n-//! use std::comm::channel;\n+//! use std::sync::mpsc::channel;\n //! use std::io::timer::Timer;\n //! use std::time::Duration;\n //!\n@@ -160,8 +154,8 @@\n //!     let timeout = timer.oneshot(Duration::seconds(5));\n //!\n //!     select! {\n-//!         val = rx.recv() => println!(\"Received {}\", val),\n-//!         () = timeout.recv() => {\n+//!         val = rx.recv() => println!(\"Received {}\", val.unwrap()),\n+//!         _ = timeout.recv() => {\n //!             println!(\"timed out, no message received in 5 seconds\");\n //!             break;\n //!         }\n@@ -319,17 +313,13 @@\n // And now that you've seen all the races that I found and attempted to fix,\n // here's the code for you to find some more!\n \n-use core::prelude::*;\n+use prelude::v1::*;\n \n-pub use self::TryRecvError::*;\n-pub use self::TrySendError::*;\n-use self::Flavor::*;\n-\n-use alloc::arc::Arc;\n-use core::kinds;\n-use core::kinds::marker;\n-use core::mem;\n-use core::cell::UnsafeCell;\n+use sync::Arc;\n+use fmt;\n+use kinds::marker;\n+use mem;\n+use cell::UnsafeCell;\n \n pub use self::select::{Select, Handle};\n use self::select::StartResult;\n@@ -347,7 +337,7 @@ mod spsc_queue;\n \n /// The receiving-half of Rust's channel type. This half can only be owned by\n /// one task\n-#[unstable]\n+#[stable]\n pub struct Receiver<T> {\n     inner: UnsafeCell<Flavor<T>>,\n }\n@@ -359,14 +349,14 @@ unsafe impl<T:Send> Send for Receiver<T> { }\n /// An iterator over messages on a receiver, this iterator will block\n /// whenever `next` is called, waiting for a new message, and `None` will be\n /// returned when the corresponding channel has hung up.\n-#[unstable]\n-pub struct Messages<'a, T:'a> {\n+#[stable]\n+pub struct Iter<'a, T:'a> {\n     rx: &'a Receiver<T>\n }\n \n /// The sending-half of Rust's asynchronous channel type. This half can only be\n /// owned by one task, but it can be cloned to send to other tasks.\n-#[unstable]\n+#[stable]\n pub struct Sender<T> {\n     inner: UnsafeCell<Flavor<T>>,\n }\n@@ -377,41 +367,64 @@ unsafe impl<T:Send> Send for Sender<T> { }\n \n /// The sending-half of Rust's synchronous channel type. This half can only be\n /// owned by one task, but it can be cloned to send to other tasks.\n-#[unstable = \"this type may be renamed, but it will always exist\"]\n+#[stable]\n pub struct SyncSender<T> {\n     inner: Arc<RacyCell<sync::Packet<T>>>,\n     // can't share in an arc\n     _marker: marker::NoSync,\n }\n \n+/// An error returned from the `send` function on channels.\n+///\n+/// A `send` operation can only fail if the receiving end of a channel is\n+/// disconnected, implying that the data could never be received. The error\n+/// contains the data being sent as a payload so it can be recovered.\n+#[deriving(PartialEq, Eq)]\n+#[stable]\n+pub struct SendError<T>(pub T);\n+\n+/// An error returned from the `recv` function on a `Receiver`.\n+///\n+/// The `recv` operation can only fail if the sending half of a channel is\n+/// disconnected, implying that no further messages will ever be received.\n+#[deriving(PartialEq, Eq, Clone, Copy)]\n+#[stable]\n+pub struct RecvError;\n+\n /// This enumeration is the list of the possible reasons that try_recv could not\n /// return data when called.\n-#[deriving(PartialEq, Clone, Copy, Show)]\n-#[experimental = \"this is likely to be removed in changing try_recv()\"]\n+#[deriving(PartialEq, Clone, Copy)]\n+#[stable]\n pub enum TryRecvError {\n     /// This channel is currently empty, but the sender(s) have not yet\n     /// disconnected, so data may yet become available.\n+    #[stable]\n     Empty,\n+\n     /// This channel's sending half has become disconnected, and there will\n     /// never be any more data received on this channel\n+    #[stable]\n     Disconnected,\n }\n \n /// This enumeration is the list of the possible error outcomes for the\n /// `SyncSender::try_send` method.\n-#[deriving(PartialEq, Clone, Show)]\n-#[experimental = \"this is likely to be removed in changing try_send()\"]\n+#[deriving(PartialEq, Clone)]\n+#[stable]\n pub enum TrySendError<T> {\n     /// The data could not be sent on the channel because it would require that\n     /// the callee block to send the data.\n     ///\n     /// If this is a buffered channel, then the buffer is full at this time. If\n     /// this is not a buffered channel, then there is no receiver available to\n     /// acquire the data.\n+    #[stable]\n     Full(T),\n+\n     /// This channel's receiving half has disconnected, so the data could not be\n     /// sent. The data is returned back to the callee in this case.\n-    RecvDisconnected(T),\n+    #[stable]\n+    Disconnected(T),\n }\n \n enum Flavor<T> {\n@@ -450,7 +463,7 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n /// # Example\n ///\n /// ```\n-/// use std::comm::channel;\n+/// use std::sync::mpsc::channel;\n /// use std::thread::Thread;\n ///\n /// // tx is is the sending half (tx for transmission), and rx is the receiving\n@@ -460,18 +473,18 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n /// // Spawn off an expensive computation\n /// Thread::spawn(move|| {\n /// #   fn expensive_computation() {}\n-///     tx.send(expensive_computation());\n+///     tx.send(expensive_computation()).unwrap();\n /// }).detach();\n ///\n /// // Do some useful work for awhile\n ///\n /// // Let's see what that answer was\n-/// println!(\"{}\", rx.recv());\n+/// println!(\"{}\", rx.recv().unwrap());\n /// ```\n-#[unstable]\n+#[stable]\n pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n     let a = Arc::new(RacyCell::new(oneshot::Packet::new()));\n-    (Sender::new(Oneshot(a.clone())), Receiver::new(Oneshot(a)))\n+    (Sender::new(Flavor::Oneshot(a.clone())), Receiver::new(Flavor::Oneshot(a)))\n }\n \n /// Creates a new synchronous, bounded channel.\n@@ -492,27 +505,26 @@ pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n /// # Example\n ///\n /// ```\n-/// use std::comm::sync_channel;\n+/// use std::sync::mpsc::sync_channel;\n /// use std::thread::Thread;\n ///\n /// let (tx, rx) = sync_channel(1);\n ///\n /// // this returns immediately\n-/// tx.send(1i);\n+/// tx.send(1i).unwrap();\n ///\n /// Thread::spawn(move|| {\n ///     // this will block until the previous message has been received\n-///     tx.send(2i);\n+///     tx.send(2i).unwrap();\n /// }).detach();\n ///\n-/// assert_eq!(rx.recv(), 1i);\n-/// assert_eq!(rx.recv(), 2i);\n+/// assert_eq!(rx.recv().unwrap(), 1i);\n+/// assert_eq!(rx.recv().unwrap(), 2i);\n /// ```\n-#[unstable = \"this function may be renamed to more accurately reflect the type \\\n-              of channel that is is creating\"]\n+#[stable]\n pub fn sync_channel<T: Send>(bound: uint) -> (SyncSender<T>, Receiver<T>) {\n     let a = Arc::new(RacyCell::new(sync::Packet::new(bound)));\n-    (SyncSender::new(a.clone()), Receiver::new(Sync(a)))\n+    (SyncSender::new(a.clone()), Receiver::new(Flavor::Sync(a)))\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -526,33 +538,6 @@ impl<T: Send> Sender<T> {\n         }\n     }\n \n-    /// Sends a value along this channel to be received by the corresponding\n-    /// receiver.\n-    ///\n-    /// Rust channels are infinitely buffered so this method will never block.\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function will panic if the other end of the channel has hung up.\n-    /// This means that if the corresponding receiver has fallen out of scope,\n-    /// this function will trigger a panic message saying that a message is\n-    /// being sent on a closed channel.\n-    ///\n-    /// Note that if this function does *not* panic, it does not mean that the\n-    /// data will be successfully received. All sends are placed into a queue,\n-    /// so it is possible for a send to succeed (the other end is alive), but\n-    /// then the other end could immediately disconnect.\n-    ///\n-    /// The purpose of this functionality is to propagate panics among tasks.\n-    /// If a panic is not desired, then consider using the `send_opt` method\n-    #[experimental = \"this function is being considered candidate for removal \\\n-                      to adhere to the general guidelines of rust\"]\n-    pub fn send(&self, t: T) {\n-        if self.send_opt(t).is_err() {\n-            panic!(\"sending on a closed channel\");\n-        }\n-    }\n-\n     /// Attempts to send a value on this channel, returning it back if it could\n     /// not be sent.\n     ///\n@@ -564,39 +549,34 @@ impl<T: Send> Sender<T> {\n     /// will be received.  It is possible for the corresponding receiver to\n     /// hang up immediately after this function returns `Ok`.\n     ///\n-    /// Like `send`, this method will never block.\n-    ///\n-    /// # Panics\n-    ///\n-    /// This method will never panic, it will return the message back to the\n-    /// caller if the other end is disconnected\n+    /// This method will never block the current thread.\n     ///\n     /// # Example\n     ///\n     /// ```\n-    /// use std::comm::channel;\n+    /// use std::sync::mpsc::channel;\n     ///\n     /// let (tx, rx) = channel();\n     ///\n     /// // This send is always successful\n-    /// assert_eq!(tx.send_opt(1i), Ok(()));\n+    /// tx.send(1i).unwrap();\n     ///\n     /// // This send will fail because the receiver is gone\n     /// drop(rx);\n-    /// assert_eq!(tx.send_opt(1i), Err(1));\n+    /// assert_eq!(tx.send(1i).err().unwrap().0, 1);\n     /// ```\n-    #[unstable = \"this function may be renamed to send() in the future\"]\n-    pub fn send_opt(&self, t: T) -> Result<(), T> {\n+    pub fn send(&self, t: T) -> Result<(), SendError<T>> {\n         let (new_inner, ret) = match *unsafe { self.inner() } {\n-            Oneshot(ref p) => {\n+            Flavor::Oneshot(ref p) => {\n                 unsafe {\n                     let p = p.get();\n                     if !(*p).sent() {\n-                        return (*p).send(t);\n+                        return (*p).send(t).map_err(SendError);\n                     } else {\n                         let a =\n                             Arc::new(RacyCell::new(stream::Packet::new()));\n-                        match (*p).upgrade(Receiver::new(Stream(a.clone()))) {\n+                        let rx = Receiver::new(Flavor::Stream(a.clone()));\n+                        match (*p).upgrade(rx) {\n                             oneshot::UpSuccess => {\n                                 let ret = (*a.get()).send(t);\n                                 (a, ret)\n@@ -614,70 +594,76 @@ impl<T: Send> Sender<T> {\n                     }\n                 }\n             }\n-            Stream(ref p) => return unsafe { (*p.get()).send(t) },\n-            Shared(ref p) => return unsafe { (*p.get()).send(t) },\n-            Sync(..) => unreachable!(),\n+            Flavor::Stream(ref p) => return unsafe {\n+                (*p.get()).send(t).map_err(SendError)\n+            },\n+            Flavor::Shared(ref p) => return unsafe {\n+                (*p.get()).send(t).map_err(SendError)\n+            },\n+            Flavor::Sync(..) => unreachable!(),\n         };\n \n         unsafe {\n-            let tmp = Sender::new(Stream(new_inner));\n+            let tmp = Sender::new(Flavor::Stream(new_inner));\n             mem::swap(self.inner_mut(), tmp.inner_mut());\n         }\n-        return ret;\n+        ret.map_err(SendError)\n     }\n }\n \n #[stable]\n impl<T: Send> Clone for Sender<T> {\n     fn clone(&self) -> Sender<T> {\n         let (packet, sleeper, guard) = match *unsafe { self.inner() } {\n-            Oneshot(ref p) => {\n+            Flavor::Oneshot(ref p) => {\n                 let a = Arc::new(RacyCell::new(shared::Packet::new()));\n                 unsafe {\n                     let guard = (*a.get()).postinit_lock();\n-                    match (*p.get()).upgrade(Receiver::new(Shared(a.clone()))) {\n+                    let rx = Receiver::new(Flavor::Shared(a.clone()));\n+                    match (*p.get()).upgrade(rx) {\n                         oneshot::UpSuccess |\n                         oneshot::UpDisconnected => (a, None, guard),\n                         oneshot::UpWoke(task) => (a, Some(task), guard)\n                     }\n                 }\n             }\n-            Stream(ref p) => {\n+            Flavor::Stream(ref p) => {\n                 let a = Arc::new(RacyCell::new(shared::Packet::new()));\n                 unsafe {\n                     let guard = (*a.get()).postinit_lock();\n-                    match (*p.get()).upgrade(Receiver::new(Shared(a.clone()))) {\n+                    let rx = Receiver::new(Flavor::Shared(a.clone()));\n+                    match (*p.get()).upgrade(rx) {\n                         stream::UpSuccess |\n                         stream::UpDisconnected => (a, None, guard),\n                         stream::UpWoke(task) => (a, Some(task), guard),\n                     }\n                 }\n             }\n-            Shared(ref p) => {\n+            Flavor::Shared(ref p) => {\n                 unsafe { (*p.get()).clone_chan(); }\n-                return Sender::new(Shared(p.clone()));\n+                return Sender::new(Flavor::Shared(p.clone()));\n             }\n-            Sync(..) => unreachable!(),\n+            Flavor::Sync(..) => unreachable!(),\n         };\n \n         unsafe {\n             (*packet.get()).inherit_blocker(sleeper, guard);\n \n-            let tmp = Sender::new(Shared(packet.clone()));\n+            let tmp = Sender::new(Flavor::Shared(packet.clone()));\n             mem::swap(self.inner_mut(), tmp.inner_mut());\n         }\n-        Sender::new(Shared(packet))\n+        Sender::new(Flavor::Shared(packet))\n     }\n }\n \n #[unsafe_destructor]\n impl<T: Send> Drop for Sender<T> {\n     fn drop(&mut self) {\n         match *unsafe { self.inner_mut() } {\n-            Oneshot(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n-            Stream(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n-            Shared(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n-            Sync(..) => unreachable!(),\n+            Flavor::Oneshot(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n+            Flavor::Stream(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n+            Flavor::Shared(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n+            Flavor::Sync(..) => unreachable!(),\n         }\n     }\n }\n@@ -697,59 +683,29 @@ impl<T: Send> SyncSender<T> {\n     /// available or a receiver is available to hand off the message to.\n     ///\n     /// Note that a successful send does *not* guarantee that the receiver will\n-    /// ever see the data if there is a buffer on this channel. Messages may be\n+    /// ever see the data if there is a buffer on this channel. Items may be\n     /// enqueued in the internal buffer for the receiver to receive at a later\n     /// time. If the buffer size is 0, however, it can be guaranteed that the\n     /// receiver has indeed received the data if this function returns success.\n     ///\n-    /// # Panics\n-    ///\n-    /// Similarly to `Sender::send`, this function will panic if the\n-    /// corresponding `Receiver` for this channel has disconnected. This\n-    /// behavior is used to propagate panics among tasks.\n-    ///\n-    /// If a panic is not desired, you can achieve the same semantics with the\n-    /// `SyncSender::send_opt` method which will not panic if the receiver\n-    /// disconnects.\n-    #[experimental = \"this function is being considered candidate for removal \\\n-                      to adhere to the general guidelines of rust\"]\n-    pub fn send(&self, t: T) {\n-        if self.send_opt(t).is_err() {\n-            panic!(\"sending on a closed channel\");\n-        }\n-    }\n-\n-    /// Send a value on a channel, returning it back if the receiver\n-    /// disconnected\n-    ///\n-    /// This method will *block* to send the value `t` on the channel, but if\n-    /// the value could not be sent due to the receiver disconnecting, the value\n-    /// is returned back to the callee. This function is similar to `try_send`,\n-    /// except that it will block if the channel is currently full.\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function cannot panic.\n-    #[unstable = \"this function may be renamed to send() in the future\"]\n-    pub fn send_opt(&self, t: T) -> Result<(), T> {\n-        unsafe { (*self.inner.get()).send(t) }\n+    /// This function will never panic, but it may return `Err` if the\n+    /// `Receiver` has disconnected and is no longer able to receive\n+    /// information.\n+    #[stable]\n+    pub fn send(&self, t: T) -> Result<(), SendError<T>> {\n+        unsafe { (*self.inner.get()).send(t).map_err(SendError) }\n     }\n \n     /// Attempts to send a value on this channel without blocking.\n     ///\n-    /// This method differs from `send_opt` by returning immediately if the\n+    /// This method differs from `send` by returning immediately if the\n     /// channel's buffer is full or no receiver is waiting to acquire some\n-    /// data. Compared with `send_opt`, this function has two failure cases\n+    /// data. Compared with `send`, this function has two failure cases\n     /// instead of one (one for disconnection, one for a full buffer).\n     ///\n     /// See `SyncSender::send` for notes about guarantees of whether the\n     /// receiver has received the data or not if this function is successful.\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function cannot panic\n-    #[unstable = \"the return type of this function is candidate for \\\n-                  modification\"]\n+    #[stable]\n     pub fn try_send(&self, t: T) -> Result<(), TrySendError<T>> {\n         unsafe { (*self.inner.get()).try_send(t) }\n     }\n@@ -779,34 +735,6 @@ impl<T: Send> Receiver<T> {\n         Receiver { inner: UnsafeCell::new(inner) }\n     }\n \n-    /// Blocks waiting for a value on this receiver\n-    ///\n-    /// This function will block if necessary to wait for a corresponding send\n-    /// on the channel from its paired `Sender` structure. This receiver will\n-    /// be woken up when data is ready, and the data will be returned.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Similar to channels, this method will trigger a task panic if the\n-    /// other end of the channel has hung up (been deallocated). The purpose of\n-    /// this is to propagate panics among tasks.\n-    ///\n-    /// If a panic is not desired, then there are two options:\n-    ///\n-    /// * If blocking is still desired, the `recv_opt` method will return `None`\n-    ///   when the other end hangs up\n-    ///\n-    /// * If blocking is not desired, then the `try_recv` method will attempt to\n-    ///   peek at a value on this receiver.\n-    #[experimental = \"this function is being considered candidate for removal \\\n-                      to adhere to the general guidelines of rust\"]\n-    pub fn recv(&self) -> T {\n-        match self.recv_opt() {\n-            Ok(t) => t,\n-            Err(()) => panic!(\"receiving on a closed channel\"),\n-        }\n-    }\n-\n     /// Attempts to return a pending value on this receiver without blocking\n     ///\n     /// This method will never block the caller in order to wait for data to\n@@ -815,42 +743,46 @@ impl<T: Send> Receiver<T> {\n     ///\n     /// This is useful for a flavor of \"optimistic check\" before deciding to\n     /// block on a receiver.\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function cannot panic.\n-    #[unstable = \"the return type of this function may be altered\"]\n+    #[stable]\n     pub fn try_recv(&self) -> Result<T, TryRecvError> {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n-                Oneshot(ref p) => {\n+                Flavor::Oneshot(ref p) => {\n                     match unsafe { (*p.get()).try_recv() } {\n                         Ok(t) => return Ok(t),\n-                        Err(oneshot::Empty) => return Err(Empty),\n-                        Err(oneshot::Disconnected) => return Err(Disconnected),\n+                        Err(oneshot::Empty) => return Err(TryRecvError::Empty),\n+                        Err(oneshot::Disconnected) => {\n+                            return Err(TryRecvError::Disconnected)\n+                        }\n                         Err(oneshot::Upgraded(rx)) => rx,\n                     }\n                 }\n-                Stream(ref p) => {\n+                Flavor::Stream(ref p) => {\n                     match unsafe { (*p.get()).try_recv() } {\n                         Ok(t) => return Ok(t),\n-                        Err(stream::Empty) => return Err(Empty),\n-                        Err(stream::Disconnected) => return Err(Disconnected),\n+                        Err(stream::Empty) => return Err(TryRecvError::Empty),\n+                        Err(stream::Disconnected) => {\n+                            return Err(TryRecvError::Disconnected)\n+                        }\n                         Err(stream::Upgraded(rx)) => rx,\n                     }\n                 }\n-                Shared(ref p) => {\n+                Flavor::Shared(ref p) => {\n                     match unsafe { (*p.get()).try_recv() } {\n                         Ok(t) => return Ok(t),\n-                        Err(shared::Empty) => return Err(Empty),\n-                        Err(shared::Disconnected) => return Err(Disconnected),\n+                        Err(shared::Empty) => return Err(TryRecvError::Empty),\n+                        Err(shared::Disconnected) => {\n+                            return Err(TryRecvError::Disconnected)\n+                        }\n                     }\n                 }\n-                Sync(ref p) => {\n+                Flavor::Sync(ref p) => {\n                     match unsafe { (*p.get()).try_recv() } {\n                         Ok(t) => return Ok(t),\n-                        Err(sync::Empty) => return Err(Empty),\n-                        Err(sync::Disconnected) => return Err(Disconnected),\n+                        Err(sync::Empty) => return Err(TryRecvError::Empty),\n+                        Err(sync::Disconnected) => {\n+                            return Err(TryRecvError::Disconnected)\n+                        }\n                     }\n                 }\n             };\n@@ -861,46 +793,47 @@ impl<T: Send> Receiver<T> {\n         }\n     }\n \n-    /// Attempt to wait for a value on this receiver, but does not panic if the\n+    /// Attempt to wait for a value on this receiver, returning an error if the\n     /// corresponding channel has hung up.\n     ///\n-    /// This implementation of iterators for ports will always block if there is\n-    /// not data available on the receiver, but it will not panic in the case\n-    /// that the channel has been deallocated.\n-    ///\n-    /// In other words, this function has the same semantics as the `recv`\n-    /// method except for the panic aspect.\n+    /// This function will always block the current thread if there is no data\n+    /// available and it's possible for more data to be sent. Once a message is\n+    /// sent to the corresponding `Sender`, then this receiver will wake up and\n+    /// return that message.\n     ///\n-    /// If the channel has hung up, then `Err` is returned. Otherwise `Ok` of\n-    /// the value found on the receiver is returned.\n-    #[unstable = \"this function may be renamed to recv()\"]\n-    pub fn recv_opt(&self) -> Result<T, ()> {\n+    /// If the corresponding `Sender` has disconnected, or it disconnects while\n+    /// this call is blocking, this call will wake up and return `Err` to\n+    /// indicate that no more messages can ever be received on this channel.\n+    #[stable]\n+    pub fn recv(&self) -> Result<T, RecvError> {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n-                Oneshot(ref p) => {\n+                Flavor::Oneshot(ref p) => {\n                     match unsafe { (*p.get()).recv() } {\n                         Ok(t) => return Ok(t),\n                         Err(oneshot::Empty) => return unreachable!(),\n-                        Err(oneshot::Disconnected) => return Err(()),\n+                        Err(oneshot::Disconnected) => return Err(RecvError),\n                         Err(oneshot::Upgraded(rx)) => rx,\n                     }\n                 }\n-                Stream(ref p) => {\n+                Flavor::Stream(ref p) => {\n                     match unsafe { (*p.get()).recv() } {\n                         Ok(t) => return Ok(t),\n                         Err(stream::Empty) => return unreachable!(),\n-                        Err(stream::Disconnected) => return Err(()),\n+                        Err(stream::Disconnected) => return Err(RecvError),\n                         Err(stream::Upgraded(rx)) => rx,\n                     }\n                 }\n-                Shared(ref p) => {\n+                Flavor::Shared(ref p) => {\n                     match unsafe { (*p.get()).recv() } {\n                         Ok(t) => return Ok(t),\n                         Err(shared::Empty) => return unreachable!(),\n-                        Err(shared::Disconnected) => return Err(()),\n+                        Err(shared::Disconnected) => return Err(RecvError),\n                     }\n                 }\n-                Sync(ref p) => return unsafe { (*p.get()).recv() }\n+                Flavor::Sync(ref p) => return unsafe {\n+                    (*p.get()).recv().map_err(|()| RecvError)\n+                }\n             };\n             unsafe {\n                 mem::swap(self.inner_mut(), new_port.inner_mut());\n@@ -910,32 +843,32 @@ impl<T: Send> Receiver<T> {\n \n     /// Returns an iterator that will block waiting for messages, but never\n     /// `panic!`. It will return `None` when the channel has hung up.\n-    #[unstable]\n-    pub fn iter<'a>(&'a self) -> Messages<'a, T> {\n-        Messages { rx: self }\n+    #[stable]\n+    pub fn iter(&self) -> Iter<T> {\n+        Iter { rx: self }\n     }\n }\n \n impl<T: Send> select::Packet for Receiver<T> {\n     fn can_recv(&self) -> bool {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n-                Oneshot(ref p) => {\n+                Flavor::Oneshot(ref p) => {\n                     match unsafe { (*p.get()).can_recv() } {\n                         Ok(ret) => return ret,\n                         Err(upgrade) => upgrade,\n                     }\n                 }\n-                Stream(ref p) => {\n+                Flavor::Stream(ref p) => {\n                     match unsafe { (*p.get()).can_recv() } {\n                         Ok(ret) => return ret,\n                         Err(upgrade) => upgrade,\n                     }\n                 }\n-                Shared(ref p) => {\n+                Flavor::Shared(ref p) => {\n                     return unsafe { (*p.get()).can_recv() };\n                 }\n-                Sync(ref p) => {\n+                Flavor::Sync(ref p) => {\n                     return unsafe { (*p.get()).can_recv() };\n                 }\n             };\n@@ -949,24 +882,24 @@ impl<T: Send> select::Packet for Receiver<T> {\n     fn start_selection(&self, mut token: SignalToken) -> StartResult {\n         loop {\n             let (t, new_port) = match *unsafe { self.inner() } {\n-                Oneshot(ref p) => {\n+                Flavor::Oneshot(ref p) => {\n                     match unsafe { (*p.get()).start_selection(token) } {\n                         oneshot::SelSuccess => return Installed,\n                         oneshot::SelCanceled => return Abort,\n                         oneshot::SelUpgraded(t, rx) => (t, rx),\n                     }\n                 }\n-                Stream(ref p) => {\n+                Flavor::Stream(ref p) => {\n                     match unsafe { (*p.get()).start_selection(token) } {\n                         stream::SelSuccess => return Installed,\n                         stream::SelCanceled => return Abort,\n                         stream::SelUpgraded(t, rx) => (t, rx),\n                     }\n                 }\n-                Shared(ref p) => {\n+                Flavor::Shared(ref p) => {\n                     return unsafe { (*p.get()).start_selection(token) };\n                 }\n-                Sync(ref p) => {\n+                Flavor::Sync(ref p) => {\n                     return unsafe { (*p.get()).start_selection(token) };\n                 }\n             };\n@@ -981,14 +914,14 @@ impl<T: Send> select::Packet for Receiver<T> {\n         let mut was_upgrade = false;\n         loop {\n             let result = match *unsafe { self.inner() } {\n-                Oneshot(ref p) => unsafe { (*p.get()).abort_selection() },\n-                Stream(ref p) => unsafe {\n+                Flavor::Oneshot(ref p) => unsafe { (*p.get()).abort_selection() },\n+                Flavor::Stream(ref p) => unsafe {\n                     (*p.get()).abort_selection(was_upgrade)\n                 },\n-                Shared(ref p) => return unsafe {\n+                Flavor::Shared(ref p) => return unsafe {\n                     (*p.get()).abort_selection(was_upgrade)\n                 },\n-                Sync(ref p) => return unsafe {\n+                Flavor::Sync(ref p) => return unsafe {\n                     (*p.get()).abort_selection()\n                 },\n             };\n@@ -1003,18 +936,18 @@ impl<T: Send> select::Packet for Receiver<T> {\n }\n \n #[unstable]\n-impl<'a, T: Send> Iterator<T> for Messages<'a, T> {\n-    fn next(&mut self) -> Option<T> { self.rx.recv_opt().ok() }\n+impl<'a, T: Send> Iterator<T> for Iter<'a, T> {\n+    fn next(&mut self) -> Option<T> { self.rx.recv().ok() }\n }\n \n #[unsafe_destructor]\n impl<T: Send> Drop for Receiver<T> {\n     fn drop(&mut self) {\n         match *unsafe { self.inner_mut() } {\n-            Oneshot(ref mut p) => unsafe { (*p.get()).drop_port(); },\n-            Stream(ref mut p) => unsafe { (*p.get()).drop_port(); },\n-            Shared(ref mut p) => unsafe { (*p.get()).drop_port(); },\n-            Sync(ref mut p) => unsafe { (*p.get()).drop_port(); },\n+            Flavor::Oneshot(ref mut p) => unsafe { (*p.get()).drop_port(); },\n+            Flavor::Stream(ref mut p) => unsafe { (*p.get()).drop_port(); },\n+            Flavor::Shared(ref mut p) => unsafe { (*p.get()).drop_port(); },\n+            Flavor::Sync(ref mut p) => unsafe { (*p.get()).drop_port(); },\n         }\n     }\n }\n@@ -1037,8 +970,45 @@ impl<T> RacyCell<T> {\n \n unsafe impl<T:Send> Send for RacyCell<T> { }\n \n-unsafe impl<T> kinds::Sync for RacyCell<T> { } // Oh dear\n+unsafe impl<T> Sync for RacyCell<T> { } // Oh dear\n+\n+impl<T> fmt::Show for SendError<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        \"sending on a closed channel\".fmt(f)\n+    }\n+}\n+\n+impl<T> fmt::Show for TrySendError<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            TrySendError::Full(..) => {\n+                \"sending on a full channel\".fmt(f)\n+            }\n+            TrySendError::Disconnected(..) => {\n+                \"sending on a closed channel\".fmt(f)\n+            }\n+        }\n+    }\n+}\n+\n+impl fmt::Show for RecvError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        \"receiving on a closed channel\".fmt(f)\n+    }\n+}\n \n+impl fmt::Show for TryRecvError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            TryRecvError::Empty => {\n+                \"receiving on an empty channel\".fmt(f)\n+            }\n+            TryRecvError::Disconnected => {\n+                \"receiving on a closed channel\".fmt(f)\n+            }\n+        }\n+    }\n+}\n \n #[cfg(test)]\n mod test {\n@@ -1047,142 +1017,130 @@ mod test {\n     use os;\n     use super::*;\n     use thread::Thread;\n-    use str::from_str;\n \n     pub fn stress_factor() -> uint {\n         match os::getenv(\"RUST_TEST_STRESS\") {\n-            Some(val) => from_str::<uint>(val.as_slice()).unwrap(),\n+            Some(val) => val.parse().unwrap(),\n             None => 1,\n         }\n     }\n \n     #[test]\n     fn smoke() {\n         let (tx, rx) = channel::<int>();\n-        tx.send(1);\n-        assert_eq!(rx.recv(), 1);\n+        tx.send(1).unwrap();\n+        assert_eq!(rx.recv().unwrap(), 1);\n     }\n \n     #[test]\n     fn drop_full() {\n         let (tx, _rx) = channel();\n-        tx.send(box 1i);\n+        tx.send(box 1i).unwrap();\n     }\n \n     #[test]\n     fn drop_full_shared() {\n         let (tx, _rx) = channel();\n         drop(tx.clone());\n         drop(tx.clone());\n-        tx.send(box 1i);\n+        tx.send(box 1i).unwrap();\n     }\n \n     #[test]\n     fn smoke_shared() {\n         let (tx, rx) = channel::<int>();\n-        tx.send(1);\n-        assert_eq!(rx.recv(), 1);\n+        tx.send(1).unwrap();\n+        assert_eq!(rx.recv().unwrap(), 1);\n         let tx = tx.clone();\n-        tx.send(1);\n-        assert_eq!(rx.recv(), 1);\n+        tx.send(1).unwrap();\n+        assert_eq!(rx.recv().unwrap(), 1);\n     }\n \n     #[test]\n     fn smoke_threads() {\n         let (tx, rx) = channel::<int>();\n         let _t = Thread::spawn(move|| {\n-            tx.send(1);\n+            tx.send(1).unwrap();\n         });\n-        assert_eq!(rx.recv(), 1);\n+        assert_eq!(rx.recv().unwrap(), 1);\n     }\n \n     #[test]\n-    #[should_fail]\n     fn smoke_port_gone() {\n         let (tx, rx) = channel::<int>();\n         drop(rx);\n-        tx.send(1);\n+        assert!(tx.send(1).is_err());\n     }\n \n     #[test]\n-    #[should_fail]\n     fn smoke_shared_port_gone() {\n         let (tx, rx) = channel::<int>();\n         drop(rx);\n-        tx.send(1);\n+        assert!(tx.send(1).is_err())\n     }\n \n     #[test]\n-    #[should_fail]\n     fn smoke_shared_port_gone2() {\n         let (tx, rx) = channel::<int>();\n         drop(rx);\n         let tx2 = tx.clone();\n         drop(tx);\n-        tx2.send(1);\n+        assert!(tx2.send(1).is_err());\n     }\n \n     #[test]\n-    #[should_fail]\n     fn port_gone_concurrent() {\n         let (tx, rx) = channel::<int>();\n-        Thread::spawn(move|| {\n-            rx.recv();\n-        }).detach();\n-        loop { tx.send(1) }\n+        let _t = Thread::spawn(move|| {\n+            rx.recv().unwrap();\n+        });\n+        while tx.send(1).is_ok() {}\n     }\n \n     #[test]\n-    #[should_fail]\n     fn port_gone_concurrent_shared() {\n         let (tx, rx) = channel::<int>();\n         let tx2 = tx.clone();\n-        Thread::spawn(move|| {\n-            rx.recv();\n-        }).detach();\n-        loop {\n-            tx.send(1);\n-            tx2.send(1);\n-        }\n+        let _t = Thread::spawn(move|| {\n+            rx.recv().unwrap();\n+        });\n+        while tx.send(1).is_ok() && tx2.send(1).is_ok() {}\n     }\n \n     #[test]\n-    #[should_fail]\n     fn smoke_chan_gone() {\n         let (tx, rx) = channel::<int>();\n         drop(tx);\n-        rx.recv();\n+        assert!(rx.recv().is_err());\n     }\n \n     #[test]\n-    #[should_fail]\n     fn smoke_chan_gone_shared() {\n         let (tx, rx) = channel::<()>();\n         let tx2 = tx.clone();\n         drop(tx);\n         drop(tx2);\n-        rx.recv();\n+        assert!(rx.recv().is_err());\n     }\n \n     #[test]\n-    #[should_fail]\n     fn chan_gone_concurrent() {\n         let (tx, rx) = channel::<int>();\n-        Thread::spawn(move|| {\n-            tx.send(1);\n-            tx.send(1);\n-        }).detach();\n-        loop { rx.recv(); }\n+        let _t = Thread::spawn(move|| {\n+            tx.send(1).unwrap();\n+            tx.send(1).unwrap();\n+        });\n+        while rx.recv().is_ok() {}\n     }\n \n     #[test]\n     fn stress() {\n         let (tx, rx) = channel::<int>();\n         let t = Thread::spawn(move|| {\n-            for _ in range(0u, 10000) { tx.send(1i); }\n+            for _ in range(0u, 10000) { tx.send(1i).unwrap(); }\n         });\n         for _ in range(0u, 10000) {\n-            assert_eq!(rx.recv(), 1);\n+            assert_eq!(rx.recv().unwrap(), 1);\n         }\n         t.join().ok().unwrap();\n     }\n@@ -1195,7 +1153,7 @@ mod test {\n \n         let t = Thread::spawn(move|| {\n             for _ in range(0, AMT * NTHREADS) {\n-                assert_eq!(rx.recv(), 1);\n+                assert_eq!(rx.recv().unwrap(), 1);\n             }\n             match rx.try_recv() {\n                 Ok(..) => panic!(),\n@@ -1206,7 +1164,7 @@ mod test {\n         for _ in range(0, NTHREADS) {\n             let tx = tx.clone();\n             Thread::spawn(move|| {\n-                for _ in range(0, AMT) { tx.send(1); }\n+                for _ in range(0, AMT) { tx.send(1).unwrap(); }\n             }).detach();\n         }\n         drop(tx);\n@@ -1218,15 +1176,15 @@ mod test {\n         let (tx1, rx1) = channel::<()>();\n         let (tx2, rx2) = channel::<int>();\n         let t1 = Thread::spawn(move|| {\n-            tx1.send(());\n+            tx1.send(()).unwrap();\n             for _ in range(0i, 40) {\n-                assert_eq!(rx2.recv(), 1);\n+                assert_eq!(rx2.recv().unwrap(), 1);\n             }\n         });\n-        rx1.recv();\n+        rx1.recv().unwrap();\n         let t2 = Thread::spawn(move|| {\n             for _ in range(0i, 40) {\n-                tx2.send(1);\n+                tx2.send(1).unwrap();\n             }\n         });\n         t1.join().ok().unwrap();\n@@ -1238,11 +1196,11 @@ mod test {\n         let (tx, rx) = channel::<int>();\n         let t = Thread::spawn(move|| {\n             for _ in range(0i, 40) {\n-                assert_eq!(rx.recv(), 1);\n+                assert_eq!(rx.recv().unwrap(), 1);\n             }\n         });\n         for _ in range(0u, 40) {\n-            tx.send(1);\n+            tx.send(1).unwrap();\n         }\n         t.join().ok().unwrap();\n     }\n@@ -1252,12 +1210,12 @@ mod test {\n         let (tx1, rx1) = channel::<int>();\n         let (tx2, rx2) = channel::<int>();\n         let t1 = Thread::spawn(move|| {\n-            assert_eq!(rx1.recv(), 1);\n-            tx2.send(2);\n+            assert_eq!(rx1.recv().unwrap(), 1);\n+            tx2.send(2).unwrap();\n         });\n         let t2 = Thread::spawn(move|| {\n-            tx1.send(1);\n-            assert_eq!(rx2.recv(), 2);\n+            tx1.send(1).unwrap();\n+            assert_eq!(rx2.recv().unwrap(), 2);\n         });\n         t1.join().ok().unwrap();\n         t2.join().ok().unwrap();\n@@ -1278,12 +1236,11 @@ mod test {\n     }\n \n     #[test]\n-    #[should_fail]\n     fn oneshot_single_thread_send_port_close() {\n         // Testing that the sender cleans up the payload if receiver is closed\n         let (tx, rx) = channel::<Box<int>>();\n         drop(rx);\n-        tx.send(box 0);\n+        assert!(tx.send(box 0).is_err());\n     }\n \n     #[test]\n@@ -1292,7 +1249,7 @@ mod test {\n         let res = Thread::spawn(move|| {\n             let (tx, rx) = channel::<int>();\n             drop(tx);\n-            rx.recv();\n+            rx.recv().unwrap();\n         }).join();\n         // What is our res?\n         assert!(res.is_err());\n@@ -1301,68 +1258,68 @@ mod test {\n     #[test]\n     fn oneshot_single_thread_send_then_recv() {\n         let (tx, rx) = channel::<Box<int>>();\n-        tx.send(box 10);\n-        assert!(rx.recv() == box 10);\n+        tx.send(box 10).unwrap();\n+        assert!(rx.recv().unwrap() == box 10);\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_send_open() {\n         let (tx, rx) = channel::<int>();\n-        assert!(tx.send_opt(10).is_ok());\n-        assert!(rx.recv() == 10);\n+        assert!(tx.send(10).is_ok());\n+        assert!(rx.recv().unwrap() == 10);\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_send_closed() {\n         let (tx, rx) = channel::<int>();\n         drop(rx);\n-        assert!(tx.send_opt(10).is_err());\n+        assert!(tx.send(10).is_err());\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_recv_open() {\n         let (tx, rx) = channel::<int>();\n-        tx.send(10);\n-        assert!(rx.recv_opt() == Ok(10));\n+        tx.send(10).unwrap();\n+        assert!(rx.recv() == Ok(10));\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_recv_closed() {\n         let (tx, rx) = channel::<int>();\n         drop(tx);\n-        assert!(rx.recv_opt() == Err(()));\n+        assert!(rx.recv().is_err());\n     }\n \n     #[test]\n     fn oneshot_single_thread_peek_data() {\n         let (tx, rx) = channel::<int>();\n-        assert_eq!(rx.try_recv(), Err(Empty));\n-        tx.send(10);\n+        assert_eq!(rx.try_recv(), Err(TryRecvError::Empty));\n+        tx.send(10).unwrap();\n         assert_eq!(rx.try_recv(), Ok(10));\n     }\n \n     #[test]\n     fn oneshot_single_thread_peek_close() {\n         let (tx, rx) = channel::<int>();\n         drop(tx);\n-        assert_eq!(rx.try_recv(), Err(Disconnected));\n-        assert_eq!(rx.try_recv(), Err(Disconnected));\n+        assert_eq!(rx.try_recv(), Err(TryRecvError::Disconnected));\n+        assert_eq!(rx.try_recv(), Err(TryRecvError::Disconnected));\n     }\n \n     #[test]\n     fn oneshot_single_thread_peek_open() {\n         let (_tx, rx) = channel::<int>();\n-        assert_eq!(rx.try_recv(), Err(Empty));\n+        assert_eq!(rx.try_recv(), Err(TryRecvError::Empty));\n     }\n \n     #[test]\n     fn oneshot_multi_task_recv_then_send() {\n         let (tx, rx) = channel::<Box<int>>();\n         let _t = Thread::spawn(move|| {\n-            assert!(rx.recv() == box 10);\n+            assert!(rx.recv().unwrap() == box 10);\n         });\n \n-        tx.send(box 10);\n+        tx.send(box 10).unwrap();\n     }\n \n     #[test]\n@@ -1372,7 +1329,7 @@ mod test {\n             drop(tx);\n         });\n         let res = Thread::spawn(move|| {\n-            assert!(rx.recv() == box 10);\n+            assert!(rx.recv().unwrap() == box 10);\n         }).join();\n         assert!(res.is_err());\n     }\n@@ -1396,7 +1353,7 @@ mod test {\n                 drop(rx);\n             });\n             let _ = Thread::spawn(move|| {\n-                tx.send(1);\n+                tx.send(1).unwrap();\n             }).join();\n         }\n     }\n@@ -1407,7 +1364,7 @@ mod test {\n             let (tx, rx) = channel::<int>();\n             Thread::spawn(move|| {\n                 let res = Thread::spawn(move|| {\n-                    rx.recv();\n+                    rx.recv().unwrap();\n                 }).join();\n                 assert!(res.is_err());\n             }).detach();\n@@ -1424,9 +1381,9 @@ mod test {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = channel();\n             let _t = Thread::spawn(move|| {\n-                tx.send(box 10i);\n+                tx.send(box 10i).unwrap();\n             });\n-            assert!(rx.recv() == box 10i);\n+            assert!(rx.recv().unwrap() == box 10i);\n         }\n     }\n \n@@ -1442,7 +1399,7 @@ mod test {\n                 if i == 10 { return }\n \n                 Thread::spawn(move|| {\n-                    tx.send(box i);\n+                    tx.send(box i).unwrap();\n                     send(tx, i + 1);\n                 }).detach();\n             }\n@@ -1451,7 +1408,7 @@ mod test {\n                 if i == 10 { return }\n \n                 Thread::spawn(move|| {\n-                    assert!(rx.recv() == box i);\n+                    assert!(rx.recv().unwrap() == box i);\n                     recv(rx, i + 1);\n                 }).detach();\n             }\n@@ -1462,8 +1419,8 @@ mod test {\n     fn recv_a_lot() {\n         // Regression test that we don't run out of stack in scheduler context\n         let (tx, rx) = channel();\n-        for _ in range(0i, 10000) { tx.send(()); }\n-        for _ in range(0i, 10000) { rx.recv(); }\n+        for _ in range(0i, 10000) { tx.send(()).unwrap(); }\n+        for _ in range(0i, 10000) { rx.recv().unwrap(); }\n     }\n \n     #[test]\n@@ -1473,12 +1430,12 @@ mod test {\n         for _ in range(0, total) {\n             let tx = tx.clone();\n             Thread::spawn(move|| {\n-                tx.send(());\n+                tx.send(()).unwrap();\n             }).detach();\n         }\n \n         for _ in range(0, total) {\n-            rx.recv();\n+            rx.recv().unwrap();\n         }\n     }\n \n@@ -1492,14 +1449,14 @@ mod test {\n             for x in rx.iter() {\n                 acc += x;\n             }\n-            total_tx.send(acc);\n+            total_tx.send(acc).unwrap();\n         });\n \n-        tx.send(3);\n-        tx.send(1);\n-        tx.send(2);\n+        tx.send(3).unwrap();\n+        tx.send(1).unwrap();\n+        tx.send(2).unwrap();\n         drop(tx);\n-        assert_eq!(total_rx.recv(), 6);\n+        assert_eq!(total_rx.recv().unwrap(), 6);\n     }\n \n     #[test]\n@@ -1516,15 +1473,15 @@ mod test {\n                     count += x;\n                 }\n             }\n-            count_tx.send(count);\n+            count_tx.send(count).unwrap();\n         });\n \n-        tx.send(2);\n-        tx.send(2);\n-        tx.send(2);\n-        let _ = tx.send_opt(2);\n+        tx.send(2).unwrap();\n+        tx.send(2).unwrap();\n+        tx.send(2).unwrap();\n+        let _ = tx.send(2);\n         drop(tx);\n-        assert_eq!(count_rx.recv(), 4);\n+        assert_eq!(count_rx.recv().unwrap(), 4);\n     }\n \n     #[test]\n@@ -1533,22 +1490,22 @@ mod test {\n         let (tx2, rx2) = channel::<()>();\n         let (tx3, rx3) = channel::<()>();\n         let _t = Thread::spawn(move|| {\n-            rx2.recv();\n-            tx1.send(1);\n-            tx3.send(());\n-            rx2.recv();\n+            rx2.recv().unwrap();\n+            tx1.send(1).unwrap();\n+            tx3.send(()).unwrap();\n+            rx2.recv().unwrap();\n             drop(tx1);\n-            tx3.send(());\n+            tx3.send(()).unwrap();\n         });\n \n-        assert_eq!(rx1.try_recv(), Err(Empty));\n-        tx2.send(());\n-        rx3.recv();\n+        assert_eq!(rx1.try_recv(), Err(TryRecvError::Empty));\n+        tx2.send(()).unwrap();\n+        rx3.recv().unwrap();\n         assert_eq!(rx1.try_recv(), Ok(1));\n-        assert_eq!(rx1.try_recv(), Err(Empty));\n-        tx2.send(());\n-        rx3.recv();\n-        assert_eq!(rx1.try_recv(), Err(Disconnected));\n+        assert_eq!(rx1.try_recv(), Err(TryRecvError::Empty));\n+        tx2.send(()).unwrap();\n+        rx3.recv().unwrap();\n+        assert_eq!(rx1.try_recv(), Err(TryRecvError::Disconnected));\n     }\n \n     // This bug used to end up in a livelock inside of the Receiver destructor\n@@ -1558,149 +1515,139 @@ mod test {\n         let (tx, rx) = channel();\n         let (tx2, rx2) = channel();\n         let _t = Thread::spawn(move|| {\n-            rx.recv(); // wait on a oneshot\n+            rx.recv().unwrap(); // wait on a oneshot\n             drop(rx);  // destroy a shared\n-            tx2.send(());\n+            tx2.send(()).unwrap();\n         });\n         // make sure the other task has gone to sleep\n         for _ in range(0u, 5000) { Thread::yield_now(); }\n \n         // upgrade to a shared chan and send a message\n         let t = tx.clone();\n         drop(tx);\n-        t.send(());\n+        t.send(()).unwrap();\n \n         // wait for the child task to exit before we exit\n-        rx2.recv();\n+        rx2.recv().unwrap();\n     }\n }\n \n #[cfg(test)]\n mod sync_tests {\n     use prelude::v1::*;\n+\n     use os;\n     use thread::Thread;\n     use super::*;\n-    use str::from_str;\n \n     pub fn stress_factor() -> uint {\n         match os::getenv(\"RUST_TEST_STRESS\") {\n-            Some(val) => from_str::<uint>(val.as_slice()).unwrap(),\n+            Some(val) => val.parse().unwrap(),\n             None => 1,\n         }\n     }\n \n     #[test]\n     fn smoke() {\n         let (tx, rx) = sync_channel::<int>(1);\n-        tx.send(1);\n-        assert_eq!(rx.recv(), 1);\n+        tx.send(1).unwrap();\n+        assert_eq!(rx.recv().unwrap(), 1);\n     }\n \n     #[test]\n     fn drop_full() {\n         let (tx, _rx) = sync_channel(1);\n-        tx.send(box 1i);\n+        tx.send(box 1i).unwrap();\n     }\n \n     #[test]\n     fn smoke_shared() {\n         let (tx, rx) = sync_channel::<int>(1);\n-        tx.send(1);\n-        assert_eq!(rx.recv(), 1);\n+        tx.send(1).unwrap();\n+        assert_eq!(rx.recv().unwrap(), 1);\n         let tx = tx.clone();\n-        tx.send(1);\n-        assert_eq!(rx.recv(), 1);\n+        tx.send(1).unwrap();\n+        assert_eq!(rx.recv().unwrap(), 1);\n     }\n \n     #[test]\n     fn smoke_threads() {\n         let (tx, rx) = sync_channel::<int>(0);\n         let _t = Thread::spawn(move|| {\n-            tx.send(1);\n+            tx.send(1).unwrap();\n         });\n-        assert_eq!(rx.recv(), 1);\n+        assert_eq!(rx.recv().unwrap(), 1);\n     }\n \n     #[test]\n-    #[should_fail]\n     fn smoke_port_gone() {\n         let (tx, rx) = sync_channel::<int>(0);\n         drop(rx);\n-        tx.send(1);\n+        assert!(tx.send(1).is_err());\n     }\n \n     #[test]\n-    #[should_fail]\n     fn smoke_shared_port_gone2() {\n         let (tx, rx) = sync_channel::<int>(0);\n         drop(rx);\n         let tx2 = tx.clone();\n         drop(tx);\n-        tx2.send(1);\n+        assert!(tx2.send(1).is_err());\n     }\n \n     #[test]\n-    #[should_fail]\n     fn port_gone_concurrent() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        Thread::spawn(move|| {\n-            rx.recv();\n-        }).detach();\n-        loop { tx.send(1) }\n+        let _t = Thread::spawn(move|| {\n+            rx.recv().unwrap();\n+        });\n+        while tx.send(1).is_ok() {}\n     }\n \n     #[test]\n-    #[should_fail]\n     fn port_gone_concurrent_shared() {\n         let (tx, rx) = sync_channel::<int>(0);\n         let tx2 = tx.clone();\n-        Thread::spawn(move|| {\n-            rx.recv();\n-        }).detach();\n-        loop {\n-            tx.send(1);\n-            tx2.send(1);\n-        }\n+        let _t = Thread::spawn(move|| {\n+            rx.recv().unwrap();\n+        });\n+        while tx.send(1).is_ok() && tx2.send(1).is_ok() {}\n     }\n \n     #[test]\n-    #[should_fail]\n     fn smoke_chan_gone() {\n         let (tx, rx) = sync_channel::<int>(0);\n         drop(tx);\n-        rx.recv();\n+        assert!(rx.recv().is_err());\n     }\n \n     #[test]\n-    #[should_fail]\n     fn smoke_chan_gone_shared() {\n         let (tx, rx) = sync_channel::<()>(0);\n         let tx2 = tx.clone();\n         drop(tx);\n         drop(tx2);\n-        rx.recv();\n+        assert!(rx.recv().is_err());\n     }\n \n     #[test]\n-    #[should_fail]\n     fn chan_gone_concurrent() {\n         let (tx, rx) = sync_channel::<int>(0);\n         Thread::spawn(move|| {\n-            tx.send(1);\n-            tx.send(1);\n+            tx.send(1).unwrap();\n+            tx.send(1).unwrap();\n         }).detach();\n-        loop { rx.recv(); }\n+        while rx.recv().is_ok() {}\n     }\n \n     #[test]\n     fn stress() {\n         let (tx, rx) = sync_channel::<int>(0);\n         Thread::spawn(move|| {\n-            for _ in range(0u, 10000) { tx.send(1); }\n+            for _ in range(0u, 10000) { tx.send(1).unwrap(); }\n         }).detach();\n         for _ in range(0u, 10000) {\n-            assert_eq!(rx.recv(), 1);\n+            assert_eq!(rx.recv().unwrap(), 1);\n         }\n     }\n \n@@ -1713,23 +1660,23 @@ mod sync_tests {\n \n         Thread::spawn(move|| {\n             for _ in range(0, AMT * NTHREADS) {\n-                assert_eq!(rx.recv(), 1);\n+                assert_eq!(rx.recv().unwrap(), 1);\n             }\n             match rx.try_recv() {\n                 Ok(..) => panic!(),\n                 _ => {}\n             }\n-            dtx.send(());\n+            dtx.send(()).unwrap();\n         }).detach();\n \n         for _ in range(0, NTHREADS) {\n             let tx = tx.clone();\n             Thread::spawn(move|| {\n-                for _ in range(0, AMT) { tx.send(1); }\n+                for _ in range(0, AMT) { tx.send(1).unwrap(); }\n             }).detach();\n         }\n         drop(tx);\n-        drx.recv();\n+        drx.recv().unwrap();\n     }\n \n     #[test]\n@@ -1747,12 +1694,11 @@ mod sync_tests {\n     }\n \n     #[test]\n-    #[should_fail]\n     fn oneshot_single_thread_send_port_close() {\n         // Testing that the sender cleans up the payload if receiver is closed\n         let (tx, rx) = sync_channel::<Box<int>>(0);\n         drop(rx);\n-        tx.send(box 0);\n+        assert!(tx.send(box 0).is_err());\n     }\n \n     #[test]\n@@ -1761,7 +1707,7 @@ mod sync_tests {\n         let res = Thread::spawn(move|| {\n             let (tx, rx) = sync_channel::<int>(0);\n             drop(tx);\n-            rx.recv();\n+            rx.recv().unwrap();\n         }).join();\n         // What is our res?\n         assert!(res.is_err());\n@@ -1770,74 +1716,74 @@ mod sync_tests {\n     #[test]\n     fn oneshot_single_thread_send_then_recv() {\n         let (tx, rx) = sync_channel::<Box<int>>(1);\n-        tx.send(box 10);\n-        assert!(rx.recv() == box 10);\n+        tx.send(box 10).unwrap();\n+        assert!(rx.recv().unwrap() == box 10);\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_send_open() {\n         let (tx, rx) = sync_channel::<int>(1);\n         assert_eq!(tx.try_send(10), Ok(()));\n-        assert!(rx.recv() == 10);\n+        assert!(rx.recv().unwrap() == 10);\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_send_closed() {\n         let (tx, rx) = sync_channel::<int>(0);\n         drop(rx);\n-        assert_eq!(tx.try_send(10), Err(RecvDisconnected(10)));\n+        assert_eq!(tx.try_send(10), Err(TrySendError::Disconnected(10)));\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_send_closed2() {\n         let (tx, _rx) = sync_channel::<int>(0);\n-        assert_eq!(tx.try_send(10), Err(Full(10)));\n+        assert_eq!(tx.try_send(10), Err(TrySendError::Full(10)));\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_recv_open() {\n         let (tx, rx) = sync_channel::<int>(1);\n-        tx.send(10);\n-        assert!(rx.recv_opt() == Ok(10));\n+        tx.send(10).unwrap();\n+        assert!(rx.recv() == Ok(10));\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_recv_closed() {\n         let (tx, rx) = sync_channel::<int>(0);\n         drop(tx);\n-        assert!(rx.recv_opt() == Err(()));\n+        assert!(rx.recv().is_err());\n     }\n \n     #[test]\n     fn oneshot_single_thread_peek_data() {\n         let (tx, rx) = sync_channel::<int>(1);\n-        assert_eq!(rx.try_recv(), Err(Empty));\n-        tx.send(10);\n+        assert_eq!(rx.try_recv(), Err(TryRecvError::Empty));\n+        tx.send(10).unwrap();\n         assert_eq!(rx.try_recv(), Ok(10));\n     }\n \n     #[test]\n     fn oneshot_single_thread_peek_close() {\n         let (tx, rx) = sync_channel::<int>(0);\n         drop(tx);\n-        assert_eq!(rx.try_recv(), Err(Disconnected));\n-        assert_eq!(rx.try_recv(), Err(Disconnected));\n+        assert_eq!(rx.try_recv(), Err(TryRecvError::Disconnected));\n+        assert_eq!(rx.try_recv(), Err(TryRecvError::Disconnected));\n     }\n \n     #[test]\n     fn oneshot_single_thread_peek_open() {\n         let (_tx, rx) = sync_channel::<int>(0);\n-        assert_eq!(rx.try_recv(), Err(Empty));\n+        assert_eq!(rx.try_recv(), Err(TryRecvError::Empty));\n     }\n \n     #[test]\n     fn oneshot_multi_task_recv_then_send() {\n         let (tx, rx) = sync_channel::<Box<int>>(0);\n         let _t = Thread::spawn(move|| {\n-            assert!(rx.recv() == box 10);\n+            assert!(rx.recv().unwrap() == box 10);\n         });\n \n-        tx.send(box 10);\n+        tx.send(box 10).unwrap();\n     }\n \n     #[test]\n@@ -1847,7 +1793,7 @@ mod sync_tests {\n             drop(tx);\n         });\n         let res = Thread::spawn(move|| {\n-            assert!(rx.recv() == box 10);\n+            assert!(rx.recv().unwrap() == box 10);\n         }).join();\n         assert!(res.is_err());\n     }\n@@ -1871,7 +1817,7 @@ mod sync_tests {\n                 drop(rx);\n             });\n             let _ = Thread::spawn(move || {\n-                tx.send(1);\n+                tx.send(1).unwrap();\n             }).join();\n         }\n     }\n@@ -1882,7 +1828,7 @@ mod sync_tests {\n             let (tx, rx) = sync_channel::<int>(0);\n             let _t = Thread::spawn(move|| {\n                 let res = Thread::spawn(move|| {\n-                    rx.recv();\n+                    rx.recv().unwrap();\n                 }).join();\n                 assert!(res.is_err());\n             });\n@@ -1899,9 +1845,9 @@ mod sync_tests {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = sync_channel::<Box<int>>(0);\n             let _t = Thread::spawn(move|| {\n-                tx.send(box 10i);\n+                tx.send(box 10i).unwrap();\n             });\n-            assert!(rx.recv() == box 10i);\n+            assert!(rx.recv().unwrap() == box 10i);\n         }\n     }\n \n@@ -1917,7 +1863,7 @@ mod sync_tests {\n                 if i == 10 { return }\n \n                 Thread::spawn(move|| {\n-                    tx.send(box i);\n+                    tx.send(box i).unwrap();\n                     send(tx, i + 1);\n                 }).detach();\n             }\n@@ -1926,7 +1872,7 @@ mod sync_tests {\n                 if i == 10 { return }\n \n                 Thread::spawn(move|| {\n-                    assert!(rx.recv() == box i);\n+                    assert!(rx.recv().unwrap() == box i);\n                     recv(rx, i + 1);\n                 }).detach();\n             }\n@@ -1937,8 +1883,8 @@ mod sync_tests {\n     fn recv_a_lot() {\n         // Regression test that we don't run out of stack in scheduler context\n         let (tx, rx) = sync_channel(10000);\n-        for _ in range(0u, 10000) { tx.send(()); }\n-        for _ in range(0u, 10000) { rx.recv(); }\n+        for _ in range(0u, 10000) { tx.send(()).unwrap(); }\n+        for _ in range(0u, 10000) { rx.recv().unwrap(); }\n     }\n \n     #[test]\n@@ -1948,12 +1894,12 @@ mod sync_tests {\n         for _ in range(0, total) {\n             let tx = tx.clone();\n             Thread::spawn(move|| {\n-                tx.send(());\n+                tx.send(()).unwrap();\n             }).detach();\n         }\n \n         for _ in range(0, total) {\n-            rx.recv();\n+            rx.recv().unwrap();\n         }\n     }\n \n@@ -1967,14 +1913,14 @@ mod sync_tests {\n             for x in rx.iter() {\n                 acc += x;\n             }\n-            total_tx.send(acc);\n+            total_tx.send(acc).unwrap();\n         });\n \n-        tx.send(3);\n-        tx.send(1);\n-        tx.send(2);\n+        tx.send(3).unwrap();\n+        tx.send(1).unwrap();\n+        tx.send(2).unwrap();\n         drop(tx);\n-        assert_eq!(total_rx.recv(), 6);\n+        assert_eq!(total_rx.recv().unwrap(), 6);\n     }\n \n     #[test]\n@@ -1991,15 +1937,15 @@ mod sync_tests {\n                     count += x;\n                 }\n             }\n-            count_tx.send(count);\n+            count_tx.send(count).unwrap();\n         });\n \n-        tx.send(2);\n-        tx.send(2);\n-        tx.send(2);\n+        tx.send(2).unwrap();\n+        tx.send(2).unwrap();\n+        tx.send(2).unwrap();\n         let _ = tx.try_send(2);\n         drop(tx);\n-        assert_eq!(count_rx.recv(), 4);\n+        assert_eq!(count_rx.recv().unwrap(), 4);\n     }\n \n     #[test]\n@@ -2008,22 +1954,22 @@ mod sync_tests {\n         let (tx2, rx2) = sync_channel::<()>(1);\n         let (tx3, rx3) = sync_channel::<()>(1);\n         let _t = Thread::spawn(move|| {\n-            rx2.recv();\n-            tx1.send(1);\n-            tx3.send(());\n-            rx2.recv();\n+            rx2.recv().unwrap();\n+            tx1.send(1).unwrap();\n+            tx3.send(()).unwrap();\n+            rx2.recv().unwrap();\n             drop(tx1);\n-            tx3.send(());\n+            tx3.send(()).unwrap();\n         });\n \n-        assert_eq!(rx1.try_recv(), Err(Empty));\n-        tx2.send(());\n-        rx3.recv();\n+        assert_eq!(rx1.try_recv(), Err(TryRecvError::Empty));\n+        tx2.send(()).unwrap();\n+        rx3.recv().unwrap();\n         assert_eq!(rx1.try_recv(), Ok(1));\n-        assert_eq!(rx1.try_recv(), Err(Empty));\n-        tx2.send(());\n-        rx3.recv();\n-        assert_eq!(rx1.try_recv(), Err(Disconnected));\n+        assert_eq!(rx1.try_recv(), Err(TryRecvError::Empty));\n+        tx2.send(()).unwrap();\n+        rx3.recv().unwrap();\n+        assert_eq!(rx1.try_recv(), Err(TryRecvError::Disconnected));\n     }\n \n     // This bug used to end up in a livelock inside of the Receiver destructor\n@@ -2033,82 +1979,82 @@ mod sync_tests {\n         let (tx, rx) = sync_channel::<()>(0);\n         let (tx2, rx2) = sync_channel::<()>(0);\n         let _t = Thread::spawn(move|| {\n-            rx.recv(); // wait on a oneshot\n+            rx.recv().unwrap(); // wait on a oneshot\n             drop(rx);  // destroy a shared\n-            tx2.send(());\n+            tx2.send(()).unwrap();\n         });\n         // make sure the other task has gone to sleep\n         for _ in range(0u, 5000) { Thread::yield_now(); }\n \n         // upgrade to a shared chan and send a message\n         let t = tx.clone();\n         drop(tx);\n-        t.send(());\n+        t.send(()).unwrap();\n \n         // wait for the child task to exit before we exit\n-        rx2.recv();\n+        rx2.recv().unwrap();\n     }\n \n     #[test]\n-    fn send_opt1() {\n+    fn send1() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        let _t = Thread::spawn(move|| { rx.recv(); });\n-        assert_eq!(tx.send_opt(1), Ok(()));\n+        let _t = Thread::spawn(move|| { rx.recv().unwrap(); });\n+        assert_eq!(tx.send(1), Ok(()));\n     }\n \n     #[test]\n-    fn send_opt2() {\n+    fn send2() {\n         let (tx, rx) = sync_channel::<int>(0);\n         let _t = Thread::spawn(move|| { drop(rx); });\n-        assert_eq!(tx.send_opt(1), Err(1));\n+        assert!(tx.send(1).is_err());\n     }\n \n     #[test]\n-    fn send_opt3() {\n+    fn send3() {\n         let (tx, rx) = sync_channel::<int>(1);\n-        assert_eq!(tx.send_opt(1), Ok(()));\n-        let _t = Thread::spawn(move|| { drop(rx); });\n-        assert_eq!(tx.send_opt(1), Err(1));\n+        assert_eq!(tx.send(1), Ok(()));\n+        let _t =Thread::spawn(move|| { drop(rx); });\n+        assert!(tx.send(1).is_err());\n     }\n \n     #[test]\n-    fn send_opt4() {\n+    fn send4() {\n         let (tx, rx) = sync_channel::<int>(0);\n         let tx2 = tx.clone();\n         let (done, donerx) = channel();\n         let done2 = done.clone();\n         let _t = Thread::spawn(move|| {\n-            assert_eq!(tx.send_opt(1), Err(1));\n-            done.send(());\n+            assert!(tx.send(1).is_err());\n+            done.send(()).unwrap();\n         });\n         let _t = Thread::spawn(move|| {\n-            assert_eq!(tx2.send_opt(2), Err(2));\n-            done2.send(());\n+            assert!(tx2.send(2).is_err());\n+            done2.send(()).unwrap();\n         });\n         drop(rx);\n-        donerx.recv();\n-        donerx.recv();\n+        donerx.recv().unwrap();\n+        donerx.recv().unwrap();\n     }\n \n     #[test]\n     fn try_send1() {\n         let (tx, _rx) = sync_channel::<int>(0);\n-        assert_eq!(tx.try_send(1), Err(Full(1)));\n+        assert_eq!(tx.try_send(1), Err(TrySendError::Full(1)));\n     }\n \n     #[test]\n     fn try_send2() {\n         let (tx, _rx) = sync_channel::<int>(1);\n         assert_eq!(tx.try_send(1), Ok(()));\n-        assert_eq!(tx.try_send(1), Err(Full(1)));\n+        assert_eq!(tx.try_send(1), Err(TrySendError::Full(1)));\n     }\n \n     #[test]\n     fn try_send3() {\n         let (tx, rx) = sync_channel::<int>(1);\n         assert_eq!(tx.try_send(1), Ok(()));\n         drop(rx);\n-        assert_eq!(tx.try_send(1), Err(RecvDisconnected(1)));\n+        assert_eq!(tx.try_send(1), Err(TrySendError::Disconnected(1)));\n     }\n \n     #[test]\n@@ -2118,12 +2064,12 @@ mod sync_tests {\n             let (tx2, rx2) = sync_channel::<()>(3);\n \n             let _t = Thread::spawn(move|| {\n-                rx1.recv();\n+                rx1.recv().unwrap();\n                 tx2.try_send(()).unwrap();\n             });\n \n             tx1.try_send(()).unwrap();\n-            rx2.recv();\n+            rx2.recv().unwrap();\n         }\n \n         for _ in range(0u, 100) {", "previous_filename": "src/libstd/comm/mod.rs"}, {"sha": "8945233dac9cd90ebdf440690df4f08a5d104492", "filename": "src/libstd/sync/mpsc/mpsc_queue.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -155,7 +155,7 @@ impl<T: Send> Drop for Queue<T> {\n mod tests {\n     use prelude::v1::*;\n \n-    use comm::channel;\n+    use sync::mpsc::channel;\n     use super::{Queue, Data, Empty, Inconsistent};\n     use sync::Arc;\n     use thread::Thread;\n@@ -186,7 +186,7 @@ mod tests {\n                 for i in range(0, nmsgs) {\n                     q.push(i);\n                 }\n-                tx.send(());\n+                tx.send(()).unwrap();\n             }).detach();\n         }\n \n@@ -199,7 +199,7 @@ mod tests {\n         }\n         drop(tx);\n         for _ in range(0, nthreads) {\n-            rx.recv();\n+            rx.recv().unwrap();\n         }\n     }\n }", "previous_filename": "src/libstd/comm/mpsc_queue.rs"}, {"sha": "5f599752a46fcfbd5067c74b354da718574b4a27", "filename": "src/libstd/sync/mpsc/oneshot.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -39,8 +39,8 @@ use self::MyUpgrade::*;\n \n use core::prelude::*;\n \n-use comm::Receiver;\n-use comm::blocking::{mod, SignalToken};\n+use sync::mpsc::Receiver;\n+use sync::mpsc::blocking::{mod, SignalToken};\n use core::mem;\n use sync::atomic;\n ", "previous_filename": "src/libstd/comm/oneshot.rs"}, {"sha": "fc1e0b34977e4e764570f5b16a6bbcb9b4be94a4", "filename": "src/libstd/sync/mpsc/select.rs", "status": "renamed", "additions": 100, "deletions": 102, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -27,20 +27,20 @@\n //! # Example\n //!\n //! ```rust\n-//! use std::comm::channel;\n+//! use std::sync::mpsc::channel;\n //!\n //! let (tx1, rx1) = channel();\n //! let (tx2, rx2) = channel();\n //!\n-//! tx1.send(1i);\n-//! tx2.send(2i);\n+//! tx1.send(1i).unwrap();\n+//! tx2.send(2i).unwrap();\n //!\n //! select! {\n //!     val = rx1.recv() => {\n-//!         assert_eq!(val, 1i);\n+//!         assert_eq!(val.unwrap(), 1i);\n //!     },\n //!     val = rx2.recv() => {\n-//!         assert_eq!(val, 2i);\n+//!         assert_eq!(val.unwrap(), 2i);\n //!     }\n //! }\n //! ```\n@@ -61,8 +61,8 @@ use core::kinds::marker;\n use core::mem;\n use core::uint;\n \n-use comm::Receiver;\n-use comm::blocking::{mod, SignalToken};\n+use sync::mpsc::{Receiver, RecvError};\n+use sync::mpsc::blocking::{mod, SignalToken};\n \n /// The \"receiver set\" of the select interface. This structure is used to manage\n /// a set of receivers which are being selected over.\n@@ -247,13 +247,10 @@ impl<'rx, T: Send> Handle<'rx, T> {\n     #[inline]\n     pub fn id(&self) -> uint { self.id }\n \n-    /// Receive a value on the underlying receiver. Has the same semantics as\n-    /// `Receiver.recv`\n-    pub fn recv(&mut self) -> T { self.rx.recv() }\n     /// Block to receive a value on the underlying receiver, returning `Some` on\n     /// success or `None` if the channel disconnects. This function has the same\n-    /// semantics as `Receiver.recv_opt`\n-    pub fn recv_opt(&mut self) -> Result<T, ()> { self.rx.recv_opt() }\n+    /// semantics as `Receiver.recv`\n+    pub fn recv(&mut self) -> Result<T, RecvError> { self.rx.recv() }\n \n     /// Adds this handle to the receiver set that the handle was created from. This\n     /// method can be called multiple times, but it has no effect if `add` was\n@@ -339,17 +336,16 @@ impl Iterator<*mut Handle<'static, ()>> for Packets {\n mod test {\n     use prelude::v1::*;\n \n-    use super::*;\n-    use comm::*;\n     use thread::Thread;\n+    use super::*;\n+    use sync::mpsc::*;\n \n     // Don't use the libstd version so we can pull in the right Select structure\n     // (std::comm points at the wrong one)\n     macro_rules! select {\n         (\n             $($name:pat = $rx:ident.$meth:ident() => $code:expr),+\n         ) => ({\n-            use comm::Select;\n             let sel = Select::new();\n             $( let mut $rx = sel.handle(&$rx); )+\n             unsafe {\n@@ -365,24 +361,24 @@ mod test {\n     fn smoke() {\n         let (tx1, rx1) = channel::<int>();\n         let (tx2, rx2) = channel::<int>();\n-        tx1.send(1);\n+        tx1.send(1).unwrap();\n         select! {\n-            foo = rx1.recv() => { assert_eq!(foo, 1); },\n+            foo = rx1.recv() => { assert_eq!(foo.unwrap(), 1); },\n             _bar = rx2.recv() => { panic!() }\n         }\n-        tx2.send(2);\n+        tx2.send(2).unwrap();\n         select! {\n             _foo = rx1.recv() => { panic!() },\n-            bar = rx2.recv() => { assert_eq!(bar, 2) }\n+            bar = rx2.recv() => { assert_eq!(bar.unwrap(), 2) }\n         }\n         drop(tx1);\n         select! {\n-            foo = rx1.recv_opt() => { assert_eq!(foo, Err(())); },\n+            foo = rx1.recv() => { assert!(foo.is_err()); },\n             _bar = rx2.recv() => { panic!() }\n         }\n         drop(tx2);\n         select! {\n-            bar = rx2.recv_opt() => { assert_eq!(bar, Err(())); }\n+            bar = rx2.recv() => { assert!(bar.is_err()); }\n         }\n     }\n \n@@ -393,13 +389,13 @@ mod test {\n         let (_tx3, rx3) = channel::<int>();\n         let (_tx4, rx4) = channel::<int>();\n         let (tx5, rx5) = channel::<int>();\n-        tx5.send(4);\n+        tx5.send(4).unwrap();\n         select! {\n             _foo = rx1.recv() => { panic!(\"1\") },\n             _foo = rx2.recv() => { panic!(\"2\") },\n             _foo = rx3.recv() => { panic!(\"3\") },\n             _foo = rx4.recv() => { panic!(\"4\") },\n-            foo = rx5.recv() => { assert_eq!(foo, 4); }\n+            foo = rx5.recv() => { assert_eq!(foo.unwrap(), 4); }\n         }\n     }\n \n@@ -410,8 +406,8 @@ mod test {\n         drop(tx2);\n \n         select! {\n-            _a1 = rx1.recv_opt() => { panic!() },\n-            a2 = rx2.recv_opt() => { assert_eq!(a2, Err(())); }\n+            _a1 = rx1.recv() => { panic!() },\n+            a2 = rx2.recv() => { assert!(a2.is_err()); }\n         }\n     }\n \n@@ -423,18 +419,18 @@ mod test {\n \n         let _t = Thread::spawn(move|| {\n             for _ in range(0u, 20) { Thread::yield_now(); }\n-            tx1.send(1);\n-            rx3.recv();\n+            tx1.send(1).unwrap();\n+            rx3.recv().unwrap();\n             for _ in range(0u, 20) { Thread::yield_now(); }\n         });\n \n         select! {\n-            a = rx1.recv() => { assert_eq!(a, 1); },\n+            a = rx1.recv() => { assert_eq!(a.unwrap(), 1); },\n             _b = rx2.recv() => { panic!() }\n         }\n-        tx3.send(1);\n+        tx3.send(1).unwrap();\n         select! {\n-            a = rx1.recv_opt() => { assert_eq!(a, Err(())); },\n+            a = rx1.recv() => { assert!(a.is_err()) },\n             _b = rx2.recv() => { panic!() }\n         }\n     }\n@@ -447,22 +443,22 @@ mod test {\n \n         let _t = Thread::spawn(move|| {\n             for _ in range(0u, 20) { Thread::yield_now(); }\n-            tx1.send(1);\n-            tx2.send(2);\n-            rx3.recv();\n+            tx1.send(1).unwrap();\n+            tx2.send(2).unwrap();\n+            rx3.recv().unwrap();\n         });\n \n         select! {\n-            a = rx1.recv() => { assert_eq!(a, 1); },\n-            a = rx2.recv() => { assert_eq!(a, 2); }\n+            a = rx1.recv() => { assert_eq!(a.unwrap(), 1); },\n+            a = rx2.recv() => { assert_eq!(a.unwrap(), 2); }\n         }\n         select! {\n-            a = rx1.recv() => { assert_eq!(a, 1); },\n-            a = rx2.recv() => { assert_eq!(a, 2); }\n+            a = rx1.recv() => { assert_eq!(a.unwrap(), 1); },\n+            a = rx2.recv() => { assert_eq!(a.unwrap(), 2); }\n         }\n-        assert_eq!(rx1.try_recv(), Err(Empty));\n-        assert_eq!(rx2.try_recv(), Err(Empty));\n-        tx3.send(());\n+        assert_eq!(rx1.try_recv(), Err(TryRecvError::Empty));\n+        assert_eq!(rx2.try_recv(), Err(TryRecvError::Empty));\n+        tx3.send(()).unwrap();\n     }\n \n     #[test]\n@@ -475,20 +471,20 @@ mod test {\n         let _t = Thread::spawn(move|| {\n             for i in range(0, AMT) {\n                 if i % 2 == 0 {\n-                    tx1.send(i);\n+                    tx1.send(i).unwrap();\n                 } else {\n-                    tx2.send(i);\n+                    tx2.send(i).unwrap();\n                 }\n-                rx3.recv();\n+                rx3.recv().unwrap();\n             }\n         });\n \n         for i in range(0, AMT) {\n             select! {\n-                i1 = rx1.recv() => { assert!(i % 2 == 0 && i == i1); },\n-                i2 = rx2.recv() => { assert!(i % 2 == 1 && i == i2); }\n+                i1 = rx1.recv() => { assert!(i % 2 == 0 && i == i1.unwrap()); },\n+                i2 = rx2.recv() => { assert!(i % 2 == 1 && i == i2.unwrap()); }\n             }\n-            tx3.send(());\n+            tx3.send(()).unwrap();\n         }\n     }\n \n@@ -499,19 +495,19 @@ mod test {\n         let (tx3, rx3) = channel::<()>();\n \n         let _t = Thread::spawn(move|| {\n-            rx3.recv();\n+            rx3.recv().unwrap();\n             tx1.clone();\n-            assert_eq!(rx3.try_recv(), Err(Empty));\n-            tx1.send(2);\n-            rx3.recv();\n+            assert_eq!(rx3.try_recv(), Err(TryRecvError::Empty));\n+            tx1.send(2).unwrap();\n+            rx3.recv().unwrap();\n         });\n \n-        tx3.send(());\n+        tx3.send(()).unwrap();\n         select! {\n             _i1 = rx1.recv() => {},\n             _i2 = rx2.recv() => panic!()\n         }\n-        tx3.send(());\n+        tx3.send(()).unwrap();\n     }\n \n     #[test]\n@@ -521,19 +517,19 @@ mod test {\n         let (tx3, rx3) = channel::<()>();\n \n         let _t = Thread::spawn(move|| {\n-            rx3.recv();\n+            rx3.recv().unwrap();\n             tx1.clone();\n-            assert_eq!(rx3.try_recv(), Err(Empty));\n-            tx1.send(2);\n-            rx3.recv();\n+            assert_eq!(rx3.try_recv(), Err(TryRecvError::Empty));\n+            tx1.send(2).unwrap();\n+            rx3.recv().unwrap();\n         });\n \n-        tx3.send(());\n+        tx3.send(()).unwrap();\n         select! {\n             _i1 = rx1.recv() => {},\n             _i2 = rx2.recv() => panic!()\n         }\n-        tx3.send(());\n+        tx3.send(()).unwrap();\n     }\n \n     #[test]\n@@ -548,48 +544,48 @@ mod test {\n             unsafe { h2.add(); }\n             unsafe { h1.add(); }\n             assert_eq!(s.wait(), h2.id);\n-            tx3.send(());\n+            tx3.send(()).unwrap();\n         });\n \n         for _ in range(0u, 1000) { Thread::yield_now(); }\n         drop(tx1.clone());\n-        tx2.send(());\n-        rx3.recv();\n+        tx2.send(()).unwrap();\n+        rx3.recv().unwrap();\n     }\n \n     #[test]\n     fn preflight1() {\n         let (tx, rx) = channel();\n-        tx.send(());\n+        tx.send(()).unwrap();\n         select! {\n-            () = rx.recv() => {}\n+            _n = rx.recv() => {}\n         }\n     }\n \n     #[test]\n     fn preflight2() {\n         let (tx, rx) = channel();\n-        tx.send(());\n-        tx.send(());\n+        tx.send(()).unwrap();\n+        tx.send(()).unwrap();\n         select! {\n-            () = rx.recv() => {}\n+            _n = rx.recv() => {}\n         }\n     }\n \n     #[test]\n     fn preflight3() {\n         let (tx, rx) = channel();\n         drop(tx.clone());\n-        tx.send(());\n+        tx.send(()).unwrap();\n         select! {\n-            () = rx.recv() => {}\n+            _n = rx.recv() => {}\n         }\n     }\n \n     #[test]\n     fn preflight4() {\n         let (tx, rx) = channel();\n-        tx.send(());\n+        tx.send(()).unwrap();\n         let s = Select::new();\n         let mut h = s.handle(&rx);\n         unsafe { h.add(); }\n@@ -599,8 +595,8 @@ mod test {\n     #[test]\n     fn preflight5() {\n         let (tx, rx) = channel();\n-        tx.send(());\n-        tx.send(());\n+        tx.send(()).unwrap();\n+        tx.send(()).unwrap();\n         let s = Select::new();\n         let mut h = s.handle(&rx);\n         unsafe { h.add(); }\n@@ -611,7 +607,7 @@ mod test {\n     fn preflight6() {\n         let (tx, rx) = channel();\n         drop(tx.clone());\n-        tx.send(());\n+        tx.send(()).unwrap();\n         let s = Select::new();\n         let mut h = s.handle(&rx);\n         unsafe { h.add(); }\n@@ -631,9 +627,9 @@ mod test {\n     #[test]\n     fn preflight8() {\n         let (tx, rx) = channel();\n-        tx.send(());\n+        tx.send(()).unwrap();\n         drop(tx);\n-        rx.recv();\n+        rx.recv().unwrap();\n         let s = Select::new();\n         let mut h = s.handle(&rx);\n         unsafe { h.add(); }\n@@ -644,9 +640,9 @@ mod test {\n     fn preflight9() {\n         let (tx, rx) = channel();\n         drop(tx.clone());\n-        tx.send(());\n+        tx.send(()).unwrap();\n         drop(tx);\n-        rx.recv();\n+        rx.recv().unwrap();\n         let s = Select::new();\n         let mut h = s.handle(&rx);\n         unsafe { h.add(); }\n@@ -659,61 +655,61 @@ mod test {\n         let (tx2, rx2) = channel();\n         let _t = Thread::spawn(move|| {\n             select! {\n-                () = rx1.recv() => {}\n+                _n = rx1.recv() => {}\n             }\n-            tx2.send(());\n+            tx2.send(()).unwrap();\n         });\n \n         for _ in range(0u, 100) { Thread::yield_now() }\n-        tx1.send(());\n-        rx2.recv();\n+        tx1.send(()).unwrap();\n+        rx2.recv().unwrap();\n     }\n \n     #[test]\n     fn stream_data_waiting() {\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n-        tx1.send(());\n-        tx1.send(());\n-        rx1.recv();\n-        rx1.recv();\n+        tx1.send(()).unwrap();\n+        tx1.send(()).unwrap();\n+        rx1.recv().unwrap();\n+        rx1.recv().unwrap();\n         let _t = Thread::spawn(move|| {\n             select! {\n-                () = rx1.recv() => {}\n+                _n = rx1.recv() => {}\n             }\n-            tx2.send(());\n+            tx2.send(()).unwrap();\n         });\n \n         for _ in range(0u, 100) { Thread::yield_now() }\n-        tx1.send(());\n-        rx2.recv();\n+        tx1.send(()).unwrap();\n+        rx2.recv().unwrap();\n     }\n \n     #[test]\n     fn shared_data_waiting() {\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n         drop(tx1.clone());\n-        tx1.send(());\n-        rx1.recv();\n+        tx1.send(()).unwrap();\n+        rx1.recv().unwrap();\n         let _t = Thread::spawn(move|| {\n             select! {\n-                () = rx1.recv() => {}\n+                _n = rx1.recv() => {}\n             }\n-            tx2.send(());\n+            tx2.send(()).unwrap();\n         });\n \n         for _ in range(0u, 100) { Thread::yield_now() }\n-        tx1.send(());\n-        rx2.recv();\n+        tx1.send(()).unwrap();\n+        rx2.recv().unwrap();\n     }\n \n     #[test]\n     fn sync1() {\n         let (tx, rx) = sync_channel::<int>(1);\n-        tx.send(1);\n+        tx.send(1).unwrap();\n         select! {\n-            n = rx.recv() => { assert_eq!(n, 1); }\n+            n = rx.recv() => { assert_eq!(n.unwrap(), 1); }\n         }\n     }\n \n@@ -722,27 +718,29 @@ mod test {\n         let (tx, rx) = sync_channel::<int>(0);\n         let _t = Thread::spawn(move|| {\n             for _ in range(0u, 100) { Thread::yield_now() }\n-            tx.send(1);\n+            tx.send(1).unwrap();\n         });\n         select! {\n-            n = rx.recv() => { assert_eq!(n, 1); }\n+            n = rx.recv() => { assert_eq!(n.unwrap(), 1); }\n         }\n     }\n \n     #[test]\n     fn sync3() {\n         let (tx1, rx1) = sync_channel::<int>(0);\n         let (tx2, rx2): (Sender<int>, Receiver<int>) = channel();\n-        let _t = Thread::spawn(move|| { tx1.send(1); });\n-        let _t = Thread::spawn(move|| { tx2.send(2); });\n+        let _t = Thread::spawn(move|| { tx1.send(1).unwrap(); });\n+        let _t = Thread::spawn(move|| { tx2.send(2).unwrap(); });\n         select! {\n             n = rx1.recv() => {\n+                let n = n.unwrap();\n                 assert_eq!(n, 1);\n-                assert_eq!(rx2.recv(), 2);\n+                assert_eq!(rx2.recv().unwrap(), 2);\n             },\n             n = rx2.recv() => {\n+                let n = n.unwrap();\n                 assert_eq!(n, 2);\n-                assert_eq!(rx1.recv(), 1);\n+                assert_eq!(rx1.recv().unwrap(), 1);\n             }\n         }\n     }", "previous_filename": "src/libstd/comm/select.rs"}, {"sha": "e1606cb4317a1f3b2caeec3cae85eb3e9f9567ab", "filename": "src/libstd/sync/mpsc/shared.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -26,10 +26,10 @@ use core::cmp;\n use core::int;\n \n use sync::{atomic, Mutex, MutexGuard};\n-use comm::mpsc_queue as mpsc;\n-use comm::blocking::{mod, SignalToken};\n-use comm::select::StartResult;\n-use comm::select::StartResult::*;\n+use sync::mpsc::mpsc_queue as mpsc;\n+use sync::mpsc::blocking::{mod, SignalToken};\n+use sync::mpsc::select::StartResult;\n+use sync::mpsc::select::StartResult::*;\n use thread::Thread;\n \n const DISCONNECTED: int = int::MIN;", "previous_filename": "src/libstd/comm/shared.rs"}, {"sha": "15624601157fdb12898737bd72b3aeed2bc61f23", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -245,7 +245,7 @@ mod test {\n     use sync::Arc;\n     use super::Queue;\n     use thread::Thread;\n-    use comm::channel;\n+    use sync::mpsc::channel;\n \n     #[test]\n     fn smoke() {\n@@ -332,12 +332,12 @@ mod test {\n                         }\n                     }\n                 }\n-                tx.send(());\n+                tx.send(()).unwrap();\n             });\n             for _ in range(0i, 100000) {\n                 q.push(1);\n             }\n-            rx.recv();\n+            rx.recv().unwrap();\n         }\n     }\n }", "previous_filename": "src/libstd/comm/spsc_queue.rs"}, {"sha": "01b799283ee3b58f5679b6b059dbec9675060c0c", "filename": "src/libstd/sync/mpsc/stream.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -28,10 +28,10 @@ use core::cmp;\n use core::int;\n use thread::Thread;\n \n+use sync::mpsc::blocking::{mod, SignalToken};\n+use sync::mpsc::spsc_queue as spsc;\n+use sync::mpsc::Receiver;\n use sync::atomic;\n-use comm::spsc_queue as spsc;\n-use comm::Receiver;\n-use comm::blocking::{mod, SignalToken};\n \n const DISCONNECTED: int = int::MIN;\n #[cfg(test)]", "previous_filename": "src/libstd/comm/stream.rs"}, {"sha": "28005831d4f6b7b41ce45ea18b98103777e85e40", "filename": "src/libstd/sync/mpsc/sync.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -42,8 +42,8 @@ use vec::Vec;\n use core::mem;\n \n use sync::{atomic, Mutex, MutexGuard};\n-use comm::blocking::{mod, WaitToken, SignalToken};\n-use comm::select::StartResult::{mod, Installed, Abort};\n+use sync::mpsc::blocking::{mod, WaitToken, SignalToken};\n+use sync::mpsc::select::StartResult::{mod, Installed, Abort};\n \n pub struct Packet<T> {\n     /// Only field outside of the mutex. Just done for kicks, but mainly because\n@@ -204,14 +204,14 @@ impl<T: Send> Packet<T> {\n     pub fn try_send(&self, t: T) -> Result<(), super::TrySendError<T>> {\n         let mut guard = self.lock.lock();\n         if guard.disconnected {\n-            Err(super::RecvDisconnected(t))\n+            Err(super::TrySendError::Disconnected(t))\n         } else if guard.buf.size() == guard.buf.cap() {\n-            Err(super::Full(t))\n+            Err(super::TrySendError::Full(t))\n         } else if guard.cap == 0 {\n             // With capacity 0, even though we have buffer space we can't\n             // transfer the data unless there's a receiver waiting.\n             match mem::replace(&mut guard.blocker, NoneBlocked) {\n-                NoneBlocked => Err(super::Full(t)),\n+                NoneBlocked => Err(super::TrySendError::Full(t)),\n                 BlockedSender(..) => unreachable!(),\n                 BlockedReceiver(token) => {\n                     guard.buf.enqueue(t);", "previous_filename": "src/libstd/comm/sync.rs"}, {"sha": "1562031499fc86f4f736b492c308050be6da907f", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -37,7 +37,7 @@ use sys_common::mutex as sys;\n /// ```rust\n /// use std::sync::{Arc, Mutex};\n /// use std::thread::Thread;\n-/// use std::comm::channel;\n+/// use std::sync::mpsc::channel;\n ///\n /// const N: uint = 10;\n ///\n@@ -58,13 +58,13 @@ use sys_common::mutex as sys;\n ///         let mut data = data.lock();\n ///         *data += 1;\n ///         if *data == N {\n-///             tx.send(());\n+///             tx.send(()).unwrap();\n ///         }\n ///         // the lock is unlocked here when `data` goes out of scope.\n ///     }).detach();\n /// }\n ///\n-/// rx.recv();\n+/// rx.recv().unwrap();\n /// ```\n pub struct Mutex<T> {\n     // Note that this static mutex is in a *box*, not inlined into the struct\n@@ -284,7 +284,7 @@ impl Drop for StaticMutexGuard {\n mod test {\n     use prelude::v1::*;\n \n-    use comm::channel;\n+    use sync::mpsc::channel;\n     use sync::{Arc, Mutex, StaticMutex, MUTEX_INIT, Condvar};\n     use thread::Thread;\n \n@@ -329,14 +329,14 @@ mod test {\n         let (tx, rx) = channel();\n         for _ in range(0, K) {\n             let tx2 = tx.clone();\n-            Thread::spawn(move|| { inc(); tx2.send(()); }).detach();\n+            Thread::spawn(move|| { inc(); tx2.send(()).unwrap(); }).detach();\n             let tx2 = tx.clone();\n-            Thread::spawn(move|| { inc(); tx2.send(()); }).detach();\n+            Thread::spawn(move|| { inc(); tx2.send(()).unwrap(); }).detach();\n         }\n \n         drop(tx);\n         for _ in range(0, 2 * K) {\n-            rx.recv();\n+            rx.recv().unwrap();\n         }\n         assert_eq!(unsafe {CNT}, J * K * 2);\n         unsafe {\n@@ -357,7 +357,7 @@ mod test {\n         let (tx, rx) = channel();\n         let _t = Thread::spawn(move|| {\n             // wait until parent gets in\n-            rx.recv();\n+            rx.recv().unwrap();\n             let &(ref lock, ref cvar) = &*packet2.0;\n             let mut lock = lock.lock();\n             *lock = true;\n@@ -366,7 +366,7 @@ mod test {\n \n         let &(ref lock, ref cvar) = &*packet.0;\n         let lock = lock.lock();\n-        tx.send(());\n+        tx.send(()).unwrap();\n         assert!(!*lock);\n         while !*lock {\n             cvar.wait(&lock);\n@@ -381,7 +381,7 @@ mod test {\n         let (tx, rx) = channel();\n \n         let _t = Thread::spawn(move || -> () {\n-            rx.recv();\n+            rx.recv().unwrap();\n             let &(ref lock, ref cvar) = &*packet2.0;\n             let _g = lock.lock();\n             cvar.notify_one();\n@@ -391,7 +391,7 @@ mod test {\n \n         let &(ref lock, ref cvar) = &*packet.0;\n         let lock = lock.lock();\n-        tx.send(());\n+        tx.send(()).unwrap();\n         while *lock == 1 {\n             cvar.wait(&lock);\n         }\n@@ -421,9 +421,9 @@ mod test {\n             let lock = arc2.lock();\n             let lock2 = lock.lock();\n             assert_eq!(*lock2, 1);\n-            tx.send(());\n+            tx.send(()).unwrap();\n         });\n-        rx.recv();\n+        rx.recv().unwrap();\n     }\n \n     #[test]"}, {"sha": "17b7b70c301b9c0ab6a2a48c34c0a4fd3ad3db1a", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -126,7 +126,7 @@ mod test {\n \n     use thread::Thread;\n     use super::{ONCE_INIT, Once};\n-    use comm::channel;\n+    use sync::mpsc::channel;\n \n     #[test]\n     fn smoke_once() {\n@@ -155,7 +155,7 @@ mod test {\n                     });\n                     assert!(run);\n                 }\n-                tx.send(());\n+                tx.send(()).unwrap();\n             }).detach();\n         }\n \n@@ -168,7 +168,7 @@ mod test {\n         }\n \n         for _ in range(0u, 10) {\n-            rx.recv();\n+            rx.recv().unwrap();\n         }\n     }\n }"}, {"sha": "3c4283c72e2a08185ce4f87562662bd0aea70954", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -363,7 +363,7 @@ mod tests {\n     use prelude::v1::*;\n \n     use rand::{mod, Rng};\n-    use comm::channel;\n+    use sync::mpsc::channel;\n     use thread::Thread;\n     use sync::{Arc, RWLock, StaticRWLock, RWLOCK_INIT};\n \n@@ -408,7 +408,7 @@ mod tests {\n             }).detach();\n         }\n         drop(tx);\n-        let _ = rx.recv_opt();\n+        let _ = rx.recv();\n         unsafe { R.destroy(); }\n     }\n \n@@ -475,7 +475,7 @@ mod tests {\n                 Thread::yield_now();\n                 *lock = tmp + 1;\n             }\n-            tx.send(());\n+            tx.send(()).unwrap();\n         }).detach();\n \n         // Readers try to catch the writer in the act\n@@ -494,7 +494,7 @@ mod tests {\n         }\n \n         // Wait for writer to finish\n-        rx.recv();\n+        rx.recv().unwrap();\n         let lock = arc.read();\n         assert_eq!(*lock, 10);\n     }"}, {"sha": "784b173b99eb879210d70606d1acce209e1513c6", "filename": "src/libstd/sync/semaphore.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Fsemaphore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Fsemaphore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fsemaphore.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -108,7 +108,7 @@ mod tests {\n \n     use sync::Arc;\n     use super::Semaphore;\n-    use comm::channel;\n+    use sync::mpsc::channel;\n     use thread::Thread;\n \n     #[test]\n@@ -143,7 +143,7 @@ mod tests {\n         let s2 = s.clone();\n         let _t = Thread::spawn(move|| {\n             s2.acquire();\n-            tx.send(());\n+            tx.send(()).unwrap();\n         });\n         s.release();\n         let _ = rx.recv();\n@@ -157,7 +157,7 @@ mod tests {\n             let _ = rx.recv();\n         });\n         s.acquire();\n-        tx.send(());\n+        tx.send(()).unwrap();\n     }\n \n     #[test]\n@@ -171,11 +171,11 @@ mod tests {\n         let _t = Thread::spawn(move|| {\n             let _g = s2.access();\n             let _ = rx2.recv();\n-            tx1.send(());\n+            tx1.send(()).unwrap();\n         });\n         let _g = s.access();\n-        tx2.send(());\n-        let _ = rx1.recv();\n+        tx2.send(()).unwrap();\n+        rx1.recv().unwrap();\n     }\n \n     #[test]\n@@ -186,12 +186,12 @@ mod tests {\n         {\n             let _g = s.access();\n             Thread::spawn(move|| {\n-                tx.send(());\n+                tx.send(()).unwrap();\n                 drop(s2.access());\n-                tx.send(());\n+                tx.send(()).unwrap();\n             }).detach();\n-            rx.recv(); // wait for child to come alive\n+            rx.recv().unwrap(); // wait for child to come alive\n         }\n-        rx.recv(); // wait for child to be done\n+        rx.recv().unwrap(); // wait for child to be done\n     }\n }"}, {"sha": "b03259983582a239dec1def3a84f118141cc1156", "filename": "src/libstd/sync/task_pool.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -12,9 +12,9 @@\n \n use core::prelude::*;\n \n-use thread::Thread;\n-use comm::{channel, Sender, Receiver};\n use sync::{Arc, Mutex};\n+use sync::mpsc::{channel, Sender, Receiver};\n+use thread::Thread;\n use thunk::Thunk;\n \n struct Sentinel<'a> {\n@@ -55,15 +55,15 @@ impl<'a> Drop for Sentinel<'a> {\n /// ```rust\n /// use std::sync::TaskPool;\n /// use std::iter::AdditiveIterator;\n-/// use std::comm::channel;\n+/// use std::sync::mpsc::channel;\n ///\n /// let pool = TaskPool::new(4u);\n ///\n /// let (tx, rx) = channel();\n /// for _ in range(0, 8u) {\n ///     let tx = tx.clone();\n ///     pool.execute(move|| {\n-///         tx.send(1u);\n+///         tx.send(1u).unwrap();\n ///     });\n /// }\n ///\n@@ -101,7 +101,7 @@ impl TaskPool {\n     pub fn execute<F>(&self, job: F)\n         where F : FnOnce(), F : Send\n     {\n-        self.jobs.send(Thunk::new(job));\n+        self.jobs.send(Thunk::new(job)).unwrap();\n     }\n }\n \n@@ -115,7 +115,7 @@ fn spawn_in_pool(jobs: Arc<Mutex<Receiver<Thunk>>>) {\n                 // Only lock jobs for the time it takes\n                 // to get a job, not run it.\n                 let lock = jobs.lock();\n-                lock.recv_opt()\n+                lock.recv()\n             };\n \n             match message {\n@@ -134,7 +134,7 @@ fn spawn_in_pool(jobs: Arc<Mutex<Receiver<Thunk>>>) {\n mod test {\n     use prelude::v1::*;\n     use super::*;\n-    use comm::channel;\n+    use sync::mpsc::channel;\n \n     const TEST_TASKS: uint = 4u;\n \n@@ -148,7 +148,7 @@ mod test {\n         for _ in range(0, TEST_TASKS) {\n             let tx = tx.clone();\n             pool.execute(move|| {\n-                tx.send(1u);\n+                tx.send(1u).unwrap();\n             });\n         }\n \n@@ -177,7 +177,7 @@ mod test {\n         for _ in range(0, TEST_TASKS) {\n             let tx = tx.clone();\n             pool.execute(move|| {\n-                tx.send(1u);\n+                tx.send(1u).unwrap();\n             });\n         }\n "}, {"sha": "b9dc5f0e39845bd1a1f66c93b9de167b656aecf0", "filename": "src/libstd/sys/common/helper_thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -23,10 +23,10 @@\n use prelude::v1::*;\n \n use cell::UnsafeCell;\n-use comm::{channel, Sender, Receiver};\n use mem;\n use rt;\n use sync::{StaticMutex, StaticCondvar};\n+use sync::mpsc::{channel, Sender, Receiver};\n use sys::helper_signal;\n \n use thread::Thread;\n@@ -118,7 +118,7 @@ impl<M: Send> Helper<M> {\n             // message. Otherwise it could wake up and go to sleep before we\n             // send the message.\n             assert!(!self.chan.get().is_null());\n-            (**self.chan.get()).send(msg);\n+            (**self.chan.get()).send(msg).unwrap();\n             helper_signal::signal(*self.signal.get() as helper_signal::signal);\n         }\n     }"}, {"sha": "a11fe3487a8e422e3d741a3de58f1f7ae625ccdc", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -13,7 +13,6 @@ use self::Req::*;\n \n use c_str::{CString, ToCStr};\n use collections;\n-use comm::{channel, Sender, Receiver};\n use hash::Hash;\n use io::process::{ProcessExit, ExitStatus, ExitSignal};\n use io::{mod, IoResult, IoError, EndOfFile};\n@@ -22,6 +21,7 @@ use mem;\n use os;\n use path::BytesContainer;\n use ptr;\n+use sync::mpsc::{channel, Sender, Receiver};\n use sys::fs::FileDesc;\n use sys::{mod, retry, c, wouldblock, set_nonblocking, ms_to_timeval};\n use sys_common::helper_thread::Helper;\n@@ -277,8 +277,8 @@ impl Process {\n     }\n \n     pub fn wait(&self, deadline: u64) -> IoResult<ProcessExit> {\n-        use std::cmp;\n-        use std::comm;\n+        use cmp;\n+        use sync::mpsc::TryRecvError;\n \n         static mut WRITE_FD: libc::c_int = 0;\n \n@@ -337,9 +337,9 @@ impl Process {\n \n         let (tx, rx) = channel();\n         unsafe { HELPER.send(NewChild(self.pid, tx, deadline)); }\n-        return match rx.recv_opt() {\n+        return match rx.recv() {\n             Ok(e) => Ok(e),\n-            Err(()) => Err(timeout(\"wait timed out\")),\n+            Err(..) => Err(timeout(\"wait timed out\")),\n         };\n \n         // Register a new SIGCHLD handler, returning the reading half of the\n@@ -420,11 +420,11 @@ impl Process {\n                             Ok(NewChild(pid, tx, deadline)) => {\n                                 active.push((pid, tx, deadline));\n                             }\n-                            Err(comm::Disconnected) => {\n+                            Err(TryRecvError::Disconnected) => {\n                                 assert!(active.len() == 0);\n                                 break 'outer;\n                             }\n-                            Err(comm::Empty) => break,\n+                            Err(TryRecvError::Empty) => break,\n                         }\n                     }\n                 }\n@@ -460,7 +460,7 @@ impl Process {\n                     active.retain(|&(pid, ref tx, _)| {\n                         let pr = Process { pid: pid };\n                         match pr.try_wait() {\n-                            Some(msg) => { tx.send(msg); false }\n+                            Some(msg) => { tx.send(msg).unwrap(); false }\n                             None => true,\n                         }\n                     });"}, {"sha": "4afe13d87357d01676ee01110347511f8fc36d35", "filename": "src/libstd/sys/unix/timer.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -49,13 +49,13 @@\n use prelude::v1::*;\n use self::Req::*;\n \n-use comm::{mod, channel, Sender, Receiver};\n use io::IoResult;\n use libc;\n use mem;\n use os;\n use ptr;\n use sync::atomic;\n+use sync::mpsc::{channel, Sender, Receiver, TryRecvError};\n use sys::c;\n use sys::fs::FileDesc;\n use sys_common::helper_thread::Helper;\n@@ -168,7 +168,7 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n             1 => {\n                 loop {\n                     match messages.try_recv() {\n-                        Err(comm::Disconnected) => {\n+                        Err(TryRecvError::Disconnected) => {\n                             assert!(active.len() == 0);\n                             break 'outer;\n                         }\n@@ -179,15 +179,15 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n                             match dead.iter().position(|&(i, _)| id == i) {\n                                 Some(i) => {\n                                     let (_, i) = dead.remove(i).unwrap();\n-                                    ack.send(i);\n+                                    ack.send(i).unwrap();\n                                     continue\n                                 }\n                                 None => {}\n                             }\n                             let i = active.iter().position(|i| i.id == id);\n                             let i = i.expect(\"no timer found\");\n                             let t = active.remove(i).unwrap();\n-                            ack.send(t);\n+                            ack.send(t).unwrap();\n                         }\n                         Err(..) => break\n                     }\n@@ -271,7 +271,7 @@ impl Timer {\n             None => {\n                 let (tx, rx) = channel();\n                 HELPER.send(RemoveTimer(self.id, tx));\n-                rx.recv()\n+                rx.recv().unwrap()\n             }\n         }\n     }"}, {"sha": "5c9e6153afb41d777e2ea699f9800556ca55c4f1", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -443,7 +443,7 @@ mod test {\n \n     use any::{Any, AnyRefExt};\n     use boxed::BoxAny;\n-    use comm::{channel, Sender};\n+    use sync::mpsc::{channel, Sender};\n     use result;\n     use std::io::{ChanReader, ChanWriter};\n     use super::{Thread, Builder};\n@@ -470,9 +470,9 @@ mod test {\n     fn test_run_basic() {\n         let (tx, rx) = channel();\n         Thread::spawn(move|| {\n-            tx.send(());\n+            tx.send(()).unwrap();\n         }).detach();\n-        rx.recv();\n+        rx.recv().unwrap();\n     }\n \n     #[test]\n@@ -505,15 +505,15 @@ mod test {\n             let tx = tx.clone();\n             Thread::spawn(move|| {\n                 if i == 0 {\n-                    tx.send(());\n+                    tx.send(()).unwrap();\n                 } else {\n                     f(i - 1, tx);\n                 }\n             }).detach();\n \n         }\n         f(10, tx);\n-        rx.recv();\n+        rx.recv().unwrap();\n     }\n \n     #[test]\n@@ -522,11 +522,11 @@ mod test {\n \n         Thread::spawn(move|| {\n             Thread::spawn(move|| {\n-                tx.send(());\n+                tx.send(()).unwrap();\n             }).detach();\n         }).detach();\n \n-        rx.recv();\n+        rx.recv().unwrap();\n     }\n \n     fn avoid_copying_the_body<F>(spawnfn: F) where F: FnOnce(Thunk) {\n@@ -537,10 +537,10 @@ mod test {\n \n         spawnfn(Thunk::new(move|| {\n             let x_in_child = (&*x) as *const int as uint;\n-            tx.send(x_in_child);\n+            tx.send(x_in_child).unwrap();\n         }));\n \n-        let x_in_child = rx.recv();\n+        let x_in_child = rx.recv().unwrap();\n         assert_eq!(x_in_parent, x_in_child);\n     }\n "}, {"sha": "6cd26a366aef91ac1a5366df51afb60d1071be8a", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -471,7 +471,7 @@ mod imp {\n mod tests {\n     use prelude::v1::*;\n \n-    use comm::{channel, Sender};\n+    use sync::mpsc::{channel, Sender};\n     use cell::UnsafeCell;\n     use thread::Thread;\n \n@@ -480,7 +480,7 @@ mod tests {\n     impl Drop for Foo {\n         fn drop(&mut self) {\n             let Foo(ref s) = *self;\n-            s.send(());\n+            s.send(()).unwrap();\n         }\n     }\n \n@@ -497,9 +497,9 @@ mod tests {\n             FOO.with(|f| unsafe {\n                 assert_eq!(*f.get(), 1);\n             });\n-            tx.send(());\n+            tx.send(()).unwrap();\n         });\n-        rx.recv();\n+        rx.recv().unwrap();\n \n         FOO.with(|f| unsafe {\n             assert_eq!(*f.get(), 2);\n@@ -519,7 +519,7 @@ mod tests {\n                 *f.get() = Some(Foo(tx.take().unwrap()));\n             });\n         });\n-        rx.recv();\n+        rx.recv().unwrap();\n     }\n \n     #[test]\n@@ -610,7 +610,7 @@ mod tests {\n             let mut tx = Some(tx);\n             K1.with(|s| *s.get() = Some(S1(tx.take().unwrap())));\n         });\n-        rx.recv();\n+        rx.recv().unwrap();\n     }\n }\n "}, {"sha": "c70aa41c569cd0c8253c50659bd0ee27bdc5035b", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -59,7 +59,6 @@ use term::color::{Color, RED, YELLOW, GREEN, CYAN};\n use std::any::{Any, AnyRefExt};\n use std::cmp;\n use std::collections::BTreeMap;\n-use std::comm::{channel, Sender};\n use std::f64;\n use std::fmt::Show;\n use std::fmt;\n@@ -71,6 +70,7 @@ use std::iter::repeat;\n use std::num::{Float, FloatMath, Int};\n use std::os;\n use std::str::{FromStr, from_str};\n+use std::sync::mpsc::{channel, Sender};\n use std::thread::{mod, Thread};\n use std::thunk::{Thunk, Invoke};\n use std::time::Duration;\n@@ -1021,7 +1021,7 @@ fn run_tests<F>(opts: &TestOpts,\n             pending += 1;\n         }\n \n-        let (desc, result, stdout) = rx.recv();\n+        let (desc, result, stdout) = rx.recv().unwrap();\n         if concurrency != 1 {\n             try!(callback(TeWait(desc.clone(), PadNone)));\n         }\n@@ -1034,7 +1034,7 @@ fn run_tests<F>(opts: &TestOpts,\n     for b in filtered_benchs_and_metrics.into_iter() {\n         try!(callback(TeWait(b.desc.clone(), b.testfn.padding())));\n         run_test(opts, !opts.run_benchmarks, b, tx.clone());\n-        let (test, result, stdout) = rx.recv();\n+        let (test, result, stdout) = rx.recv().unwrap();\n         try!(callback(TeResult(test, result, stdout)));\n     }\n     Ok(())\n@@ -1111,7 +1111,7 @@ pub fn run_test(opts: &TestOpts,\n     let TestDescAndFn {desc, testfn} = test;\n \n     if force_ignore || desc.ignore {\n-        monitor_ch.send((desc, TrIgnored, Vec::new()));\n+        monitor_ch.send((desc, TrIgnored, Vec::new())).unwrap();\n         return;\n     }\n \n@@ -1138,31 +1138,31 @@ pub fn run_test(opts: &TestOpts,\n             let result_guard = cfg.spawn(move || { testfn.invoke(()) });\n             let stdout = reader.read_to_end().unwrap().into_iter().collect();\n             let test_result = calc_result(&desc, result_guard.join());\n-            monitor_ch.send((desc.clone(), test_result, stdout));\n+            monitor_ch.send((desc.clone(), test_result, stdout)).unwrap();\n         }).detach();\n     }\n \n     match testfn {\n         DynBenchFn(bencher) => {\n             let bs = ::bench::benchmark(|harness| bencher.run(harness));\n-            monitor_ch.send((desc, TrBench(bs), Vec::new()));\n+            monitor_ch.send((desc, TrBench(bs), Vec::new())).unwrap();\n             return;\n         }\n         StaticBenchFn(benchfn) => {\n             let bs = ::bench::benchmark(|harness| (benchfn.clone())(harness));\n-            monitor_ch.send((desc, TrBench(bs), Vec::new()));\n+            monitor_ch.send((desc, TrBench(bs), Vec::new())).unwrap();\n             return;\n         }\n         DynMetricFn(f) => {\n             let mut mm = MetricMap::new();\n             f.invoke(&mut mm);\n-            monitor_ch.send((desc, TrMetrics(mm), Vec::new()));\n+            monitor_ch.send((desc, TrMetrics(mm), Vec::new())).unwrap();\n             return;\n         }\n         StaticMetricFn(f) => {\n             let mut mm = MetricMap::new();\n             f(&mut mm);\n-            monitor_ch.send((desc, TrMetrics(mm), Vec::new()));\n+            monitor_ch.send((desc, TrMetrics(mm), Vec::new())).unwrap();\n             return;\n         }\n         DynTestFn(f) => run_test_inner(desc, monitor_ch, opts.nocapture, f),\n@@ -1466,7 +1466,7 @@ mod tests {\n                StaticTestName, DynTestName, DynTestFn, ShouldFail};\n     use std::io::TempDir;\n     use std::thunk::Thunk;\n-    use std::comm::channel;\n+    use std::sync::mpsc::channel;\n \n     #[test]\n     pub fn do_not_run_ignored_tests() {\n@@ -1481,7 +1481,7 @@ mod tests {\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n-        let (_, res, _) = rx.recv();\n+        let (_, res, _) = rx.recv().unwrap();\n         assert!(res != TrOk);\n     }\n \n@@ -1498,7 +1498,7 @@ mod tests {\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n-        let (_, res, _) = rx.recv();\n+        let (_, res, _) = rx.recv().unwrap();\n         assert!(res == TrIgnored);\n     }\n \n@@ -1515,7 +1515,7 @@ mod tests {\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n-        let (_, res, _) = rx.recv();\n+        let (_, res, _) = rx.recv().unwrap();\n         assert!(res == TrOk);\n     }\n \n@@ -1532,7 +1532,7 @@ mod tests {\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n-        let (_, res, _) = rx.recv();\n+        let (_, res, _) = rx.recv().unwrap();\n         assert!(res == TrOk);\n     }\n \n@@ -1549,7 +1549,7 @@ mod tests {\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n-        let (_, res, _) = rx.recv();\n+        let (_, res, _) = rx.recv().unwrap();\n         assert!(res == TrFailed);\n     }\n \n@@ -1566,7 +1566,7 @@ mod tests {\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n-        let (_, res, _) = rx.recv();\n+        let (_, res, _) = rx.recv().unwrap();\n         assert!(res == TrFailed);\n     }\n "}, {"sha": "ec470ddc21343fdd684691d95856e502c31a5089", "filename": "src/test/auxiliary/cci_capture_clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::task;\n-use std::comm::{Receiver, channel};\n+use std::sync::mpsc::{Receiver, channel};\n \n pub fn foo<T:Send + Clone>(x: T) -> Receiver<T> {\n     let (tx, rx) = channel();"}, {"sha": "bb6060f2543e2a846cead159de024b47647bc76e", "filename": "src/test/compile-fail/bind-by-move-no-guards.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -8,15 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::comm::channel;\n+use std::sync::mpsc::channel;\n \n fn main() {\n     let (tx, rx) = channel();\n     let x = Some(rx);\n     tx.send(false);\n     match x {\n-        Some(z) if z.recv() => { panic!() }, //~ ERROR cannot bind by-move into a pattern guard\n-        Some(z) => { assert!(!z.recv()); },\n+        Some(z) if z.recv().unwrap() => { panic!() },\n+            //~^ ERROR cannot bind by-move into a pattern guard\n+        Some(z) => { assert!(!z.recv().unwrap()); },\n         None => panic!()\n     }\n }"}, {"sha": "9826a5a0126f41351b7e73bc31a0f37b0776703e", "filename": "src/test/compile-fail/builtin-superkinds-self-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-self-type.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -11,7 +11,7 @@\n // Tests (negatively) the ability for the Self type in default methods\n // to use capabilities granted by builtin kinds as supertraits.\n \n-use std::comm::{channel, Sender};\n+use std::sync::mpsc::{channel, Sender};\n \n trait Foo : Sync+'static {\n     fn foo(self, mut chan: Sender<Self>) { }"}, {"sha": "2e535b3950938cbb2bdbf7e51ed303075d2d651b", "filename": "src/test/compile-fail/comm-not-freeze-receiver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Fcompile-fail%2Fcomm-not-freeze-receiver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Fcompile-fail%2Fcomm-not-freeze-receiver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcomm-not-freeze-receiver.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::comm::Receiver;\n+use std::sync::mpsc::Receiver;\n \n fn test<T: Sync>() {}\n "}, {"sha": "1b1c43e4793e339c42a7a623c3a93d201a398e3b", "filename": "src/test/compile-fail/comm-not-freeze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Fcompile-fail%2Fcomm-not-freeze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Fcompile-fail%2Fcomm-not-freeze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcomm-not-freeze.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::comm::Sender;\n+use std::sync::mpsc::Sender;\n \n fn test<T: Sync>() {}\n "}, {"sha": "094f6d64edc2ea10b2b71bff791cdcb81906d3dc", "filename": "src/test/compile-fail/issue-12041.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Fcompile-fail%2Fissue-12041.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Fcompile-fail%2Fissue-12041.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12041.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::comm::channel;\n+use std::sync::mpsc::channel;\n use std::thread::Thread;\n \n fn main() {"}, {"sha": "993df8e59f3e041e1b6de10f1381e657ea7f81a7", "filename": "src/test/compile-fail/unsendable-class.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::comm::channel;\n+use std::sync::mpsc::channel;\n \n // Test that a class with an unsendable field can't be\n // sent"}, {"sha": "b3c4802530ed3c9f7aa38a0ea43af498648f91d1", "filename": "src/test/run-pass/bool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbool.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -10,7 +10,7 @@\n \n // Basic boolean tests\n \n-use std::cmp::{Equal, Greater, Less};\n+use std::cmp::Ordering::{Equal, Greater, Less};\n use std::ops::{BitAnd, BitOr, BitXor};\n \n fn main() {"}, {"sha": "365670db6f928bf60b89c1d4df8e08a5396ff95c", "filename": "src/test/run-pass/builtin-superkinds-capabilities-transitive.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-transitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-transitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-transitive.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -14,7 +14,7 @@\n // a Send. Basically this just makes sure rustc is using\n // each_bound_trait_and_supertraits in type_contents correctly.\n \n-use std::comm::{channel, Sender};\n+use std::sync::mpsc::{channel, Sender};\n \n trait Bar : Send { }\n trait Foo : Bar { }\n@@ -23,11 +23,11 @@ impl <T: Send> Foo for T { }\n impl <T: Send> Bar for T { }\n \n fn foo<T: Foo>(val: T, chan: Sender<T>) {\n-    chan.send(val);\n+    chan.send(val).unwrap();\n }\n \n pub fn main() {\n     let (tx, rx) = channel();\n     foo(31337i, tx);\n-    assert!(rx.recv() == 31337i);\n+    assert!(rx.recv().unwrap() == 31337i);\n }"}, {"sha": "1f42076f6d6e1822c367428110f6d3f3153f387d", "filename": "src/test/run-pass/builtin-superkinds-capabilities-xc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-xc.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -16,7 +16,7 @@\n \n extern crate trait_superkinds_in_metadata;\n \n-use std::comm::{channel, Sender, Receiver};\n+use std::sync::mpsc::{channel, Sender, Receiver};\n use trait_superkinds_in_metadata::{RequiresRequiresShareAndSend, RequiresShare};\n \n #[deriving(PartialEq)]\n@@ -26,11 +26,11 @@ impl <T: Sync> RequiresShare for X<T> { }\n impl <T: Sync+Send> RequiresRequiresShareAndSend for X<T> { }\n \n fn foo<T: RequiresRequiresShareAndSend>(val: T, chan: Sender<T>) {\n-    chan.send(val);\n+    chan.send(val).unwrap();\n }\n \n pub fn main() {\n     let (tx, rx): (Sender<X<int>>, Receiver<X<int>>) = channel();\n     foo(X(31337i), tx);\n-    assert!(rx.recv() == X(31337i));\n+    assert!(rx.recv().unwrap() == X(31337i));\n }"}, {"sha": "7f4a2398f54ba06fc702575d07bd30c9ed0d7586", "filename": "src/test/run-pass/builtin-superkinds-capabilities.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -12,18 +12,18 @@\n // builtin-kinds, e.g., if a trait requires Send to implement, then\n // at usage site of that trait, we know we have the Send capability.\n \n-use std::comm::{channel, Sender, Receiver};\n+use std::sync::mpsc::{channel, Sender, Receiver};\n \n trait Foo : Send { }\n \n impl <T: Send> Foo for T { }\n \n fn foo<T: Foo>(val: T, chan: Sender<T>) {\n-    chan.send(val);\n+    chan.send(val).unwrap();\n }\n \n pub fn main() {\n     let (tx, rx): (Sender<int>, Receiver<int>) = channel();\n     foo(31337i, tx);\n-    assert!(rx.recv() == 31337i);\n+    assert!(rx.recv().unwrap() == 31337i);\n }"}, {"sha": "bf06bf8b8c65ae7f39b99322c795860066506e97", "filename": "src/test/run-pass/builtin-superkinds-self-type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-self-type.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -11,11 +11,11 @@\n // Tests the ability for the Self type in default methods to use\n // capabilities granted by builtin kinds as supertraits.\n \n-use std::comm::{Sender, channel};\n+use std::sync::mpsc::{Sender, channel};\n \n trait Foo : Send {\n     fn foo(self, tx: Sender<Self>) {\n-        tx.send(self);\n+        tx.send(self).unwrap();\n     }\n }\n \n@@ -24,5 +24,5 @@ impl <T: Send> Foo for T { }\n pub fn main() {\n     let (tx, rx) = channel();\n     1193182i.foo(tx);\n-    assert!(rx.recv() == 1193182i);\n+    assert!(rx.recv().unwrap() == 1193182i);\n }"}, {"sha": "3f6d6a02c79264d3d751a8fcf62d5ab1d1d06f61", "filename": "src/test/run-pass/capturing-logging.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -17,7 +17,7 @@\n extern crate log;\n \n use log::{set_logger, Logger, LogRecord};\n-use std::comm::channel;\n+use std::sync::mpsc::channel;\n use std::fmt;\n use std::io::{ChanReader, ChanWriter};\n use std::thread::Thread;"}, {"sha": "8b2947ba3eef03f4f94623648bc1b70d5db58747", "filename": "src/test/run-pass/cci_capture_clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fcci_capture_clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fcci_capture_clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_capture_clause.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -16,5 +16,5 @@\n extern crate cci_capture_clause;\n \n pub fn main() {\n-    cci_capture_clause::foo(()).recv()\n+    cci_capture_clause::foo(()).recv().unwrap();\n }"}, {"sha": "816b28c3a9ae1e3b8e074a9a9e5c491c6ca743f1", "filename": "src/test/run-pass/closure-bounds-can-capture-chan.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fclosure-bounds-can-capture-chan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fclosure-bounds-can-capture-chan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-bounds-can-capture-chan.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(unboxed_closures)]\n \n-use std::comm::channel;\n+use std::sync::mpsc::channel;\n \n fn foo<F:FnOnce()+Send>(blk: F) {\n     blk();\n@@ -19,7 +19,7 @@ fn foo<F:FnOnce()+Send>(blk: F) {\n pub fn main() {\n     let (tx, rx) = channel();\n     foo(move || {\n-        tx.send(());\n+        tx.send(()).unwrap();\n     });\n-    rx.recv();\n+    rx.recv().unwrap();\n }"}, {"sha": "5cfc692aae43dda50e4431a126b25efd78bbd495", "filename": "src/test/run-pass/comm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomm.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -9,19 +9,19 @@\n // except according to those terms.\n \n use std::task;\n-use std::comm::{channel, Sender};\n+use std::sync::mpsc::{channel, Sender};\n \n pub fn main() {\n     let (tx, rx) = channel();\n     let _t = task::spawn(move|| { child(&tx) });\n-    let y = rx.recv();\n+    let y = rx.recv().unwrap();\n     println!(\"received\");\n     println!(\"{}\", y);\n     assert_eq!(y, 10);\n }\n \n fn child(c: &Sender<int>) {\n     println!(\"sending\");\n-    c.send(10);\n+    c.send(10).unwrap();\n     println!(\"value sent\");\n }"}, {"sha": "c1db8a6eb13f4f27a39e0504b69f89cb2b893608", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -23,7 +23,7 @@ extern crate libc;\n use std::io::{Process, Command, timer};\n use std::time::Duration;\n use std::str;\n-use std::comm::channel;\n+use std::sync::mpsc::channel;\n use std::thread::Thread;\n \n macro_rules! succeed( ($e:expr) => (\n@@ -88,13 +88,13 @@ pub fn test_destroy_actually_kills(force: bool) {\n     let rx2 = t.oneshot(Duration::milliseconds(1000));\n     Thread::spawn(move|| {\n         select! {\n-            () = rx2.recv() => unsafe { libc::exit(1) },\n-            () = rx1.recv() => {}\n+            _ = rx2.recv() => unsafe { libc::exit(1) },\n+            _ = rx1.recv() => {}\n         }\n     }).detach();\n     match p.wait().unwrap() {\n         ExitStatus(..) => panic!(\"expected a signal\"),\n-        ExitSignal(..) => tx.send(()),\n+        ExitSignal(..) => tx.send(()).unwrap(),\n     }\n }\n "}, {"sha": "1ad0e87b6453e792786a28c964cf5c6ee2e95bcd", "filename": "src/test/run-pass/drop-trait-enum.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fdrop-trait-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fdrop-trait-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-trait-enum.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::task;\n-use std::comm::{channel, Sender};\n+use std::sync::mpsc::{channel, Sender};\n \n #[deriving(PartialEq, Show)]\n enum Message {\n@@ -23,7 +23,7 @@ struct SendOnDrop {\n \n impl Drop for SendOnDrop {\n     fn drop(&mut self) {\n-        self.sender.send(Message::Dropped);\n+        self.sender.send(Message::Dropped).unwrap();\n     }\n }\n \n@@ -37,10 +37,10 @@ impl Drop for Foo {\n     fn drop(&mut self) {\n         match self {\n             &Foo::SimpleVariant(ref mut sender) => {\n-                sender.send(Message::DestructorRan);\n+                sender.send(Message::DestructorRan).unwrap();\n             }\n             &Foo::NestedVariant(_, _, ref mut sender) => {\n-                sender.send(Message::DestructorRan);\n+                sender.send(Message::DestructorRan).unwrap();\n             }\n             &Foo::FailingVariant { .. } => {\n                 panic!(\"Failed\");\n@@ -54,23 +54,23 @@ pub fn main() {\n     {\n         let v = Foo::SimpleVariant(sender);\n     }\n-    assert_eq!(receiver.recv(), Message::DestructorRan);\n-    assert_eq!(receiver.recv_opt().ok(), None);\n+    assert_eq!(receiver.recv().unwrap(), Message::DestructorRan);\n+    assert_eq!(receiver.recv().ok(), None);\n \n     let (sender, receiver) = channel();\n     {\n         let v = Foo::NestedVariant(box 42u, SendOnDrop { sender: sender.clone() }, sender);\n     }\n-    assert_eq!(receiver.recv(), Message::DestructorRan);\n-    assert_eq!(receiver.recv(), Message::Dropped);\n-    assert_eq!(receiver.recv_opt().ok(), None);\n+    assert_eq!(receiver.recv().unwrap(), Message::DestructorRan);\n+    assert_eq!(receiver.recv().unwrap(), Message::Dropped);\n+    assert_eq!(receiver.recv().ok(), None);\n \n     let (sender, receiver) = channel();\n     task::spawn(move|| {\n         let v = Foo::FailingVariant { on_drop: SendOnDrop { sender: sender } };\n     });\n-    assert_eq!(receiver.recv(), Message::Dropped);\n-    assert_eq!(receiver.recv_opt().ok(), None);\n+    assert_eq!(receiver.recv().unwrap(), Message::Dropped);\n+    assert_eq!(receiver.recv().ok(), None);\n \n     let (sender, receiver) = channel();\n     {\n@@ -83,11 +83,11 @@ pub fn main() {\n             v = Foo::FailingVariant { on_drop: SendOnDrop { sender: sender } };\n         });\n     }\n-    assert_eq!(receiver.recv(), Message::DestructorRan);\n-    assert_eq!(receiver.recv(), Message::Dropped);\n-    assert_eq!(receiver.recv(), Message::DestructorRan);\n-    assert_eq!(receiver.recv(), Message::Dropped);\n-    assert_eq!(receiver.recv(), Message::DestructorRan);\n-    assert_eq!(receiver.recv(), Message::Dropped);\n-    assert_eq!(receiver.recv_opt().ok(), None);\n+    assert_eq!(receiver.recv().unwrap(), Message::DestructorRan);\n+    assert_eq!(receiver.recv().unwrap(), Message::Dropped);\n+    assert_eq!(receiver.recv().unwrap(), Message::DestructorRan);\n+    assert_eq!(receiver.recv().unwrap(), Message::Dropped);\n+    assert_eq!(receiver.recv().unwrap(), Message::DestructorRan);\n+    assert_eq!(receiver.recv().unwrap(), Message::Dropped);\n+    assert_eq!(receiver.recv().ok(), None);\n }"}, {"sha": "162d7f1025589f0d1a753a4393503d76800077ba", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -21,7 +21,7 @@ pub fn map(filename: String, emit: map_reduce::putter) {\n \n mod map_reduce {\n     use std::collections::HashMap;\n-    use std::comm::{channel, Sender};\n+    use std::sync::mpsc::{channel, Sender};\n     use std::str;\n     use std::task;\n \n@@ -50,16 +50,16 @@ mod map_reduce {\n             }\n             let (tx, rx) = channel();\n             println!(\"sending find_reducer\");\n-            ctrl.send(ctrl_proto::find_reducer(key.as_bytes().to_vec(), tx));\n+            ctrl.send(ctrl_proto::find_reducer(key.as_bytes().to_vec(), tx)).unwrap();\n             println!(\"receiving\");\n-            let c = rx.recv();\n+            let c = rx.recv().unwrap();\n             println!(\"{}\", c);\n             im.insert(key, c);\n         }\n \n         let ctrl_clone = ctrl.clone();\n         ::map(input, |a,b| emit(&mut intermediates, ctrl.clone(), a, b) );\n-        ctrl_clone.send(ctrl_proto::mapper_done);\n+        ctrl_clone.send(ctrl_proto::mapper_done).unwrap();\n     }\n \n     pub fn map_reduce(inputs: Vec<String>) {\n@@ -77,7 +77,7 @@ mod map_reduce {\n         let mut num_mappers = inputs.len() as int;\n \n         while num_mappers > 0 {\n-            match rx.recv() {\n+            match rx.recv().unwrap() {\n               ctrl_proto::mapper_done => { num_mappers -= 1; }\n               ctrl_proto::find_reducer(k, cc) => {\n                 let mut c;\n@@ -86,7 +86,7 @@ mod map_reduce {\n                   Some(&_c) => { c = _c; }\n                   None => { c = 0; }\n                 }\n-                cc.send(c);\n+                cc.send(c).unwrap();\n               }\n             }\n         }"}, {"sha": "b9339c1cc0d03ad030a746487036669e53b173bb", "filename": "src/test/run-pass/issue-13494.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fissue-13494.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fissue-13494.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13494.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -11,12 +11,12 @@\n // This test may not always fail, but it can be flaky if the race it used to\n // expose is still present.\n \n-use std::comm::{channel, Sender, Receiver};\n+use std::sync::mpsc::{channel, Sender, Receiver};\n use std::thread::Thread;\n \n fn helper(rx: Receiver<Sender<()>>) {\n     for tx in rx.iter() {\n-        let _ = tx.send_opt(());\n+        let _ = tx.send(());\n     }\n }\n \n@@ -25,11 +25,11 @@ fn main() {\n     let _t = Thread::spawn(move|| { helper(rx) }).detach();\n     let (snd, rcv) = channel::<int>();\n     for _ in range(1i, 100000i) {\n-        snd.send(1i);\n+        snd.send(1i).unwrap();\n         let (tx2, rx2) = channel();\n-        tx.send(tx2);\n+        tx.send(tx2).unwrap();\n         select! {\n-            () = rx2.recv() => (),\n+            _ = rx2.recv() => (),\n             _ = rcv.recv() => ()\n         }\n     }"}, {"sha": "a02dbb6035bfadff43dd21901ed6c602f96c8954", "filename": "src/test/run-pass/issue-3609.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3609.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -11,7 +11,7 @@\n #![feature(default_type_params)]\n \n use std::task;\n-use std::comm::Sender;\n+use std::sync::mpsc::Sender;\n use std::thunk::Invoke;\n \n type RingBuffer = Vec<f64> ;"}, {"sha": "30e1a14ecff8fc776f44862abb78e940be73911c", "filename": "src/test/run-pass/issue-4446.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fissue-4446.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fissue-4446.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4446.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -9,15 +9,15 @@\n // except according to those terms.\n \n use std::io::println;\n-use std::comm::channel;\n+use std::sync::mpsc::channel;\n use std::thread::Thread;\n \n pub fn main() {\n     let (tx, rx) = channel();\n \n-    tx.send(\"hello, world\");\n+    tx.send(\"hello, world\").unwrap();\n \n     Thread::spawn(move|| {\n-        println(rx.recv());\n+        println(rx.recv().unwrap());\n     }).join().ok().unwrap();\n }"}, {"sha": "7e53722726f2cef8d53b748ccd69ee0fb0085c60", "filename": "src/test/run-pass/issue-4448.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fissue-4448.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fissue-4448.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4448.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -8,15 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::task;\n-use std::comm::channel;\n+use std::sync::mpsc::channel;\n+use std::thread::Thread;\n \n pub fn main() {\n     let (tx, rx) = channel::<&'static str>();\n \n-    task::spawn(move|| {\n-        assert_eq!(rx.recv(), \"hello, world\");\n+    let t = Thread::spawn(move|| {\n+        assert_eq!(rx.recv().unwrap(), \"hello, world\");\n     });\n \n-    tx.send(\"hello, world\");\n+    tx.send(\"hello, world\").unwrap();\n+    t.join().ok().unwrap();\n }"}, {"sha": "39695a8339f08aa0017ff4baa150b8df4380b68d", "filename": "src/test/run-pass/issue-8827.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fissue-8827.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fissue-8827.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8827.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -9,19 +9,19 @@\n // except according to those terms.\n \n use std::thread::Thread;\n-use std::comm::{channel, Receiver};\n+use std::sync::mpsc::{channel, Receiver};\n \n fn periodical(n: int) -> Receiver<bool> {\n     let (chan, port) = channel();\n     Thread::spawn(move|| {\n         loop {\n             for _ in range(1, n) {\n-                match chan.send_opt(false) {\n+                match chan.send(false) {\n                     Ok(()) => {}\n                     Err(..) => break,\n                 }\n             }\n-            match chan.send_opt(true) {\n+            match chan.send(true) {\n                 Ok(()) => {}\n                 Err(..) => break\n             }\n@@ -35,7 +35,7 @@ fn integers() -> Receiver<int> {\n     Thread::spawn(move|| {\n         let mut i = 1;\n         loop {\n-            match chan.send_opt(i) {\n+            match chan.send(i) {\n                 Ok(()) => {}\n                 Err(..) => break,\n             }\n@@ -50,7 +50,7 @@ fn main() {\n     let threes = periodical(3);\n     let fives = periodical(5);\n     for _ in range(1i, 100i) {\n-        match (ints.recv(), threes.recv(), fives.recv()) {\n+        match (ints.recv().unwrap(), threes.recv().unwrap(), fives.recv().unwrap()) {\n             (_, true, true) => println!(\"FizzBuzz\"),\n             (_, true, false) => println!(\"Fizz\"),\n             (_, false, true) => println!(\"Buzz\"),"}, {"sha": "34bb50c5cf669844524b7c84a4899b74573be6db", "filename": "src/test/run-pass/issue-9396.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fissue-9396.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fissue-9396.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9396.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::comm::{mod, channel};\n+use std::sync::mpsc::{TryRecvError, channel};\n use std::io::timer::Timer;\n use std::thread::Thread;\n use std::time::Duration;\n@@ -18,13 +18,13 @@ pub fn main() {\n     let _t = Thread::spawn(move||{\n         let mut timer = Timer::new().unwrap();\n         timer.sleep(Duration::milliseconds(10));\n-        tx.send(());\n+        tx.send(()).unwrap();\n     });\n     loop {\n         match rx.try_recv() {\n             Ok(()) => break,\n-            Err(comm::Empty) => {}\n-            Err(comm::Disconnected) => unreachable!()\n+            Err(TryRecvError::Empty) => {}\n+            Err(TryRecvError::Disconnected) => unreachable!()\n         }\n     }\n }"}, {"sha": "a9a50b9ef25af6c44b729dac8fdebaad2690130d", "filename": "src/test/run-pass/ivec-tag.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fivec-tag.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -9,12 +9,12 @@\n // except according to those terms.\n \n use std::task;\n-use std::comm::{channel, Sender};\n+use std::sync::mpsc::{channel, Sender};\n \n fn producer(tx: &Sender<Vec<u8>>) {\n     tx.send(\n          vec!(1u8, 2u8, 3u8, 4u8, 5u8, 6u8, 7u8, 8u8, 9u8, 10u8, 11u8, 12u8,\n-          13u8));\n+          13u8)).unwrap();\n }\n \n pub fn main() {\n@@ -23,5 +23,5 @@ pub fn main() {\n         producer(&tx)\n     });\n \n-    let _data: Vec<u8> = rx.recv();\n+    let _data: Vec<u8> = rx.recv().unwrap();\n }"}, {"sha": "2612483ded486e8713b7cc4c95a3199f0f9ad18e", "filename": "src/test/run-pass/rust-log-filter.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Frust-log-filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Frust-log-filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frust-log-filter.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -14,7 +14,7 @@\n #[phase(plugin,link)]\n extern crate log;\n \n-use std::comm::{channel, Sender, Receiver};\n+use std::sync::mpsc::{channel, Sender, Receiver};\n use std::thread::Thread;\n \n pub struct ChannelLogger {\n@@ -30,7 +30,7 @@ impl ChannelLogger {\n \n impl log::Logger for ChannelLogger {\n     fn log(&mut self, record: &log::LogRecord) {\n-        self.tx.send(format!(\"{}\", record.args));\n+        self.tx.send(format!(\"{}\", record.args)).unwrap();\n     }\n }\n \n@@ -49,9 +49,9 @@ pub fn main() {\n         info!(\"f1o\");\n     });\n \n-    assert_eq!(rx.recv().as_slice(), \"foo\");\n-    assert_eq!(rx.recv().as_slice(), \"foo bar\");\n-    assert_eq!(rx.recv().as_slice(), \"bar foo\");\n-    assert_eq!(rx.recv().as_slice(), \"f1o\");\n-    assert!(rx.recv_opt().is_err());\n+    assert_eq!(rx.recv().unwrap().as_slice(), \"foo\");\n+    assert_eq!(rx.recv().unwrap().as_slice(), \"foo bar\");\n+    assert_eq!(rx.recv().unwrap().as_slice(), \"bar foo\");\n+    assert_eq!(rx.recv().unwrap().as_slice(), \"f1o\");\n+    assert!(rx.recv().is_err());\n }"}, {"sha": "7fd9706bd0fea88e056862837070494c0cf74832", "filename": "src/test/run-pass/send-resource.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fsend-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fsend-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-resource.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::task;\n-use std::comm::channel;\n+use std::sync::mpsc::channel;\n \n struct test {\n   f: int,\n@@ -30,10 +30,10 @@ pub fn main() {\n \n     task::spawn(move|| {\n         let (tx2, rx2) = channel();\n-        tx.send(tx2);\n+        tx.send(tx2).unwrap();\n \n-        let _r = rx2.recv();\n+        let _r = rx2.recv().unwrap();\n     });\n \n-    rx.recv().send(test(42));\n+    rx.recv().unwrap().send(test(42)).unwrap();\n }"}, {"sha": "ae992a0a358d11b51239398916e2f9b863743625", "filename": "src/test/run-pass/send-type-inference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::comm::{channel, Sender};\n+use std::sync::mpsc::{channel, Sender};\n \n // tests that ctrl's type gets inferred properly\n struct Command<K, V> {"}, {"sha": "8691d5e875bfc401fa3c0878b05a7d159b20a0b0", "filename": "src/test/run-pass/sendable-class.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fsendable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fsendable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsendable-class.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -10,7 +10,7 @@\n \n // Test that a class with only sendable fields can be sent\n \n-use std::comm::channel;\n+use std::sync::mpsc::channel;\n \n struct foo {\n   i: int,"}, {"sha": "1c86e3e6ea23678a607db4d4efdca67c7ab247dc", "filename": "src/test/run-pass/spawn-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-types.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -15,7 +15,7 @@\n  */\n \n use std::task;\n-use std::comm::{channel, Sender};\n+use std::sync::mpsc::{channel, Sender};\n \n type ctx = Sender<int>;\n "}, {"sha": "de077ffd19020da5b2ef451ce8dfc96bbc838cab", "filename": "src/test/run-pass/task-comm-0.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -9,27 +9,27 @@\n // except according to those terms.\n \n use std::task;\n-use std::comm::{channel, Sender};\n+use std::sync::mpsc::{channel, Sender};\n \n pub fn main() { test05(); }\n \n fn test05_start(tx : &Sender<int>) {\n-    tx.send(10);\n+    tx.send(10).unwrap();\n     println!(\"sent 10\");\n-    tx.send(20);\n+    tx.send(20).unwrap();\n     println!(\"sent 20\");\n-    tx.send(30);\n+    tx.send(30).unwrap();\n     println!(\"sent 30\");\n }\n \n fn test05() {\n     let (tx, rx) = channel();\n     task::spawn(move|| { test05_start(&tx) });\n-    let mut value: int = rx.recv();\n+    let mut value: int = rx.recv().unwrap();\n     println!(\"{}\", value);\n-    value = rx.recv();\n+    value = rx.recv().unwrap();\n     println!(\"{}\", value);\n-    value = rx.recv();\n+    value = rx.recv().unwrap();\n     println!(\"{}\", value);\n     assert_eq!(value, 30);\n }"}, {"sha": "93dca923b6b98d287a0cda5562cb26353cd9d62f", "filename": "src/test/run-pass/task-comm-10.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -9,18 +9,18 @@\n // except according to those terms.\n \n use std::task;\n-use std::comm::{channel, Sender};\n+use std::sync::mpsc::{channel, Sender};\n \n fn start(tx: &Sender<Sender<String>>) {\n     let (tx2, rx) = channel();\n-    tx.send(tx2);\n+    tx.send(tx2).unwrap();\n \n     let mut a;\n     let mut b;\n-    a = rx.recv();\n+    a = rx.recv().unwrap();\n     assert!(a == \"A\".to_string());\n     println!(\"{}\", a);\n-    b = rx.recv();\n+    b = rx.recv().unwrap();\n     assert!(b == \"B\".to_string());\n     println!(\"{}\", b);\n }\n@@ -29,8 +29,8 @@ pub fn main() {\n     let (tx, rx) = channel();\n     let _child = task::spawn(move|| { start(&tx) });\n \n-    let mut c = rx.recv();\n-    c.send(\"A\".to_string());\n-    c.send(\"B\".to_string());\n+    let mut c = rx.recv().unwrap();\n+    c.send(\"A\".to_string()).unwrap();\n+    c.send(\"B\".to_string()).unwrap();\n     task::deschedule();\n }"}, {"sha": "8168e84e42674a82faede730b9eb543da095967e", "filename": "src/test/run-pass/task-comm-11.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::comm::{channel, Sender};\n+use std::sync::mpsc::{channel, Sender};\n use std::task;\n \n fn start(tx: &Sender<Sender<int>>) {"}, {"sha": "bb92ef38728fa8509017574cf087b89d02707ce9", "filename": "src/test/run-pass/task-comm-13.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::comm::{channel, Sender};\n+use std::sync::mpsc::{channel, Sender};\n use std::task;\n \n fn start(tx: &Sender<int>, start: int, number_of_messages: int) {"}, {"sha": "d63cbd5c8ba17cb6b80d385cf304dec95f0d0c7e", "filename": "src/test/run-pass/task-comm-14.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::comm::{channel, Sender};\n+use std::sync::mpsc::{channel, Sender};\n use std::task;\n \n pub fn main() {"}, {"sha": "7c652ddc406fc9e5d53d46bd371ebf98faed3993", "filename": "src/test/run-pass/task-comm-15.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::comm::{channel, Sender};\n+use std::sync::mpsc::{channel, Sender};\n use std::task;\n \n fn start(tx: &Sender<int>, i0: int) {"}, {"sha": "b7098eb30a3beb708256c9f7afc781d9adfcca57", "filename": "src/test/run-pass/task-comm-16.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::comm::channel;\n+use std::sync::mpsc::channel;\n use std::cmp;\n \n // Tests of ports and channels on various types\n@@ -17,9 +17,9 @@ fn test_rec() {\n \n     let (tx, rx) = channel();\n     let r0: R = R {val0: 0, val1: 1u8, val2: '2'};\n-    tx.send(r0);\n+    tx.send(r0).unwrap();\n     let mut r1: R;\n-    r1 = rx.recv();\n+    r1 = rx.recv().unwrap();\n     assert_eq!(r1.val0, 0);\n     assert_eq!(r1.val1, 1u8);\n     assert_eq!(r1.val2, '2');\n@@ -28,8 +28,8 @@ fn test_rec() {\n fn test_vec() {\n     let (tx, rx) = channel();\n     let v0: Vec<int> = vec!(0, 1, 2);\n-    tx.send(v0);\n-    let v1 = rx.recv();\n+    tx.send(v0).unwrap();\n+    let v1 = rx.recv().unwrap();\n     assert_eq!(v1[0], 0);\n     assert_eq!(v1[1], 1);\n     assert_eq!(v1[2], 2);\n@@ -38,8 +38,8 @@ fn test_vec() {\n fn test_str() {\n     let (tx, rx) = channel();\n     let s0 = \"test\".to_string();\n-    tx.send(s0);\n-    let s1 = rx.recv();\n+    tx.send(s0).unwrap();\n+    let s1 = rx.recv().unwrap();\n     assert_eq!(s1.as_bytes()[0], 't' as u8);\n     assert_eq!(s1.as_bytes()[1], 'e' as u8);\n     assert_eq!(s1.as_bytes()[2], 's' as u8);\n@@ -82,28 +82,28 @@ impl cmp::PartialEq for t {\n \n fn test_tag() {\n     let (tx, rx) = channel();\n-    tx.send(t::tag1);\n-    tx.send(t::tag2(10));\n-    tx.send(t::tag3(10, 11u8, 'A'));\n+    tx.send(t::tag1).unwrap();\n+    tx.send(t::tag2(10)).unwrap();\n+    tx.send(t::tag3(10, 11u8, 'A')).unwrap();\n     let mut t1: t;\n-    t1 = rx.recv();\n+    t1 = rx.recv().unwrap();\n     assert_eq!(t1, t::tag1);\n-    t1 = rx.recv();\n+    t1 = rx.recv().unwrap();\n     assert_eq!(t1, t::tag2(10));\n-    t1 = rx.recv();\n+    t1 = rx.recv().unwrap();\n     assert_eq!(t1, t::tag3(10, 11u8, 'A'));\n }\n \n fn test_chan() {\n     let (tx1, rx1) = channel();\n     let (tx2, rx2) = channel();\n-    tx1.send(tx2);\n-    let tx2 = rx1.recv();\n+    tx1.send(tx2).unwrap();\n+    let tx2 = rx1.recv().unwrap();\n     // Does the transmitted channel still work?\n \n-    tx2.send(10);\n+    tx2.send(10).unwrap();\n     let mut i: int;\n-    i = rx2.recv();\n+    i = rx2.recv().unwrap();\n     assert_eq!(i, 10);\n }\n "}, {"sha": "a002a597481e42ee8a660694f223efa37716037c", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -11,7 +11,7 @@\n // no-pretty-expanded FIXME #15189\n \n use std::thread::Thread;\n-use std::comm::{channel, Sender};\n+use std::sync::mpsc::{channel, Sender};\n \n pub fn main() { println!(\"===== WITHOUT THREADS =====\"); test00(); }\n \n@@ -20,7 +20,7 @@ fn test00_start(ch: &Sender<int>, message: int, count: int) {\n     let mut i: int = 0;\n     while i < count {\n         println!(\"Sending Message\");\n-        ch.send(message + 0);\n+        ch.send(message + 0).unwrap();\n         i = i + 1;\n     }\n     println!(\"Ending test00_start\");\n@@ -54,7 +54,7 @@ fn test00() {\n     for _r in results.iter() {\n         i = 0;\n         while i < number_of_messages {\n-            let value = rx.recv();\n+            let value = rx.recv().unwrap();\n             sum += value;\n             i = i + 1;\n         }"}, {"sha": "1f1b750aa5727fd63ad51d39185a840a227df769", "filename": "src/test/run-pass/task-comm-4.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -10,44 +10,44 @@\n \n #![allow(dead_assignment)]\n \n-use std::comm::channel;\n+use std::sync::mpsc::channel;\n \n pub fn main() { test00(); }\n \n fn test00() {\n     let mut r: int = 0;\n     let mut sum: int = 0;\n     let (tx, rx) = channel();\n-    tx.send(1);\n-    tx.send(2);\n-    tx.send(3);\n-    tx.send(4);\n-    r = rx.recv();\n+    tx.send(1).unwrap();\n+    tx.send(2).unwrap();\n+    tx.send(3).unwrap();\n+    tx.send(4).unwrap();\n+    r = rx.recv().unwrap();\n     sum += r;\n     println!(\"{}\", r);\n-    r = rx.recv();\n+    r = rx.recv().unwrap();\n     sum += r;\n     println!(\"{}\", r);\n-    r = rx.recv();\n+    r = rx.recv().unwrap();\n     sum += r;\n     println!(\"{}\", r);\n-    r = rx.recv();\n+    r = rx.recv().unwrap();\n     sum += r;\n     println!(\"{}\", r);\n-    tx.send(5);\n-    tx.send(6);\n-    tx.send(7);\n-    tx.send(8);\n-    r = rx.recv();\n+    tx.send(5).unwrap();\n+    tx.send(6).unwrap();\n+    tx.send(7).unwrap();\n+    tx.send(8).unwrap();\n+    r = rx.recv().unwrap();\n     sum += r;\n     println!(\"{}\", r);\n-    r = rx.recv();\n+    r = rx.recv().unwrap();\n     sum += r;\n     println!(\"{}\", r);\n-    r = rx.recv();\n+    r = rx.recv().unwrap();\n     sum += r;\n     println!(\"{}\", r);\n-    r = rx.recv();\n+    r = rx.recv().unwrap();\n     sum += r;\n     println!(\"{}\", r);\n     assert_eq!(sum, 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8);"}, {"sha": "039308d5cfed736c903f87f5ff4bc4248e811bdc", "filename": "src/test/run-pass/task-comm-5.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftask-comm-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftask-comm-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-5.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::comm::channel;\n+use std::sync::mpsc::channel;\n \n pub fn main() { test00(); }\n \n@@ -18,8 +18,8 @@ fn test00() {\n     let (tx, rx) = channel();\n     let number_of_messages: int = 1000;\n     let mut i: int = 0;\n-    while i < number_of_messages { tx.send(i + 0); i += 1; }\n+    while i < number_of_messages { tx.send(i + 0).unwrap(); i += 1; }\n     i = 0;\n-    while i < number_of_messages { sum += rx.recv(); i += 1; }\n+    while i < number_of_messages { sum += rx.recv().unwrap(); i += 1; }\n     assert_eq!(sum, number_of_messages * (number_of_messages - 1) / 2);\n }"}, {"sha": "7cdfddcdeb113ff4fe3fd2c9ffca3d3aebad30a0", "filename": "src/test/run-pass/task-comm-6.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -10,7 +10,7 @@\n \n #![allow(dead_assignment)]\n \n-use std::comm::channel;\n+use std::sync::mpsc::channel;\n \n pub fn main() { test00(); }\n \n@@ -25,21 +25,21 @@ fn test00() {\n     let number_of_messages: int = 1000;\n     let mut i: int = 0;\n     while i < number_of_messages {\n-        tx0.send(i + 0);\n-        tx1.send(i + 0);\n-        tx2.send(i + 0);\n-        tx3.send(i + 0);\n+        tx0.send(i + 0).unwrap();\n+        tx1.send(i + 0).unwrap();\n+        tx2.send(i + 0).unwrap();\n+        tx3.send(i + 0).unwrap();\n         i += 1;\n     }\n     i = 0;\n     while i < number_of_messages {\n-        r = rx.recv();\n+        r = rx.recv().unwrap();\n         sum += r;\n-        r = rx.recv();\n+        r = rx.recv().unwrap();\n         sum += r;\n-        r = rx.recv();\n+        r = rx.recv().unwrap();\n         sum += r;\n-        r = rx.recv();\n+        r = rx.recv().unwrap();\n         sum += r;\n         i += 1;\n     }"}, {"sha": "054090eca390343a0bff0c9f8deaefe33bed4251", "filename": "src/test/run-pass/task-comm-7.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -10,15 +10,15 @@\n \n #![allow(dead_assignment)]\n \n-use std::comm::{channel, Sender};\n+use std::sync::mpsc::{channel, Sender};\n use std::task;\n \n pub fn main() { test00(); }\n \n fn test00_start(c: &Sender<int>, start: int,\n                 number_of_messages: int) {\n     let mut i: int = 0;\n-    while i < number_of_messages { c.send(start + i); i += 1; }\n+    while i < number_of_messages { c.send(start + i).unwrap(); i += 1; }\n }\n \n fn test00() {\n@@ -46,13 +46,13 @@ fn test00() {\n \n     let mut i: int = 0;\n     while i < number_of_messages {\n-        r = rx.recv();\n+        r = rx.recv().unwrap();\n         sum += r;\n-        r = rx.recv();\n+        r = rx.recv().unwrap();\n         sum += r;\n-        r = rx.recv();\n+        r = rx.recv().unwrap();\n         sum += r;\n-        r = rx.recv();\n+        r = rx.recv().unwrap();\n         sum += r;\n         i += 1;\n     }"}, {"sha": "d9faf6ee4e4b24a0a1dce1f2a43c41ae36b854ec", "filename": "src/test/run-pass/task-comm-9.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -9,13 +9,13 @@\n // except according to those terms.\n \n use std::thread::Thread;\n-use std::comm::{channel, Sender};\n+use std::sync::mpsc::{channel, Sender};\n \n pub fn main() { test00(); }\n \n fn test00_start(c: &Sender<int>, number_of_messages: int) {\n     let mut i: int = 0;\n-    while i < number_of_messages { c.send(i + 0); i += 1; }\n+    while i < number_of_messages { c.send(i + 0).unwrap(); i += 1; }\n }\n \n fn test00() {\n@@ -30,7 +30,7 @@ fn test00() {\n \n     let mut i: int = 0;\n     while i < number_of_messages {\n-        sum += rx.recv();\n+        sum += rx.recv().unwrap();\n         println!(\"{}\", r);\n         i += 1;\n     }"}, {"sha": "78a42632001d0dec1208b3c5022724e79982071f", "filename": "src/test/run-pass/task-comm-chan-nil.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -8,14 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::comm::channel;\n+use std::sync::mpsc::channel;\n \n // rustboot can't transmit nils across channels because they don't have\n // any size, but rustc currently can because they do have size. Whether\n // or not this is desirable I don't know, but here's a regression test.\n pub fn main() {\n     let (tx, rx) = channel();\n-    tx.send(());\n-    let n: () = rx.recv();\n+    tx.send(()).unwrap();\n+    let n: () = rx.recv().unwrap();\n     assert_eq!(n, ());\n }"}, {"sha": "623a30eda1a4bc54b737232575796b5e464290c1", "filename": "src/test/run-pass/task-spawn-move-and-copy.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::task;\n-use std::comm::channel;\n+use std::sync::mpsc::channel;\n \n pub fn main() {\n     let (tx, rx) = channel::<uint>();\n@@ -19,9 +19,9 @@ pub fn main() {\n \n     task::spawn(move || {\n         let x_in_child = &(*x) as *const int as uint;\n-        tx.send(x_in_child);\n+        tx.send(x_in_child).unwrap();\n     });\n \n-    let x_in_child = rx.recv();\n+    let x_in_child = rx.recv().unwrap();\n     assert_eq!(x_in_parent, x_in_child);\n }"}, {"sha": "a7eabe0edb3845468dc07836eb5f4086c82e4c62", "filename": "src/test/run-pass/task-stderr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftask-stderr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftask-stderr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-stderr.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::comm::channel;\n+use std::sync::mpsc::channel;\n use std::io::{ChanReader, ChanWriter};\n use std::thread;\n "}, {"sha": "07f71fe580e9fdd52c1244ca2b20e05e9ec2b700", "filename": "src/test/run-pass/tcp-accept-stress.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -13,7 +13,7 @@\n //              quite quickly and it takes a few seconds for the sockets to get\n //              recycled.\n \n-use std::comm::channel;\n+use std::sync::mpsc::channel;\n use std::io::{TcpListener, Listener, Acceptor, EndOfFile, TcpStream};\n use std::sync::{atomic, Arc};\n use std::thread::Thread;"}, {"sha": "c33bdcf86980118dfacf8bda2f43924e62036a1e", "filename": "src/test/run-pass/tcp-connect-timeouts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -27,7 +27,7 @@ use std::io::net::tcp::*;\n use std::io::test::*;\n use std::io;\n use std::time::Duration;\n-use std::comm::channel;\n+use std::sync::mpsc::channel;\n \n #[cfg_attr(target_os = \"freebsd\", ignore)]\n fn eventual_timeout() {\n@@ -37,10 +37,10 @@ fn eventual_timeout() {\n     let (_tx2, rx2) = channel::<()>();\n     std::task::spawn(move|| {\n         let _l = TcpListener::bind(addr).unwrap().listen();\n-        tx1.send(());\n-        let _ = rx2.recv_opt();\n+        tx1.send(()).unwrap();\n+        let _ = rx2.recv();\n     });\n-    rx1.recv();\n+    rx1.recv().unwrap();\n \n     let mut v = Vec::new();\n     for _ in range(0u, 10000) {"}, {"sha": "9e67095bb3031856e5faef1c83c67c08764d693f", "filename": "src/test/run-pass/tempfile.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftempfile.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -23,7 +23,7 @@ use std::io::{fs, TempDir};\n use std::io;\n use std::os;\n use std::task;\n-use std::comm::channel;\n+use std::sync::mpsc::channel;\n \n fn test_tempdir() {\n     let path = {\n@@ -39,11 +39,11 @@ fn test_rm_tempdir() {\n     let (tx, rx) = channel();\n     let f = move|:| -> () {\n         let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n-        tx.send(tmp.path().clone());\n+        tx.send(tmp.path().clone()).unwrap();\n         panic!(\"panic to unwind past `tmp`\");\n     };\n     task::try(f);\n-    let path = rx.recv();\n+    let path = rx.recv().unwrap();\n     assert!(!path.exists());\n \n     let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n@@ -80,12 +80,12 @@ fn test_rm_tempdir_close() {\n     let (tx, rx) = channel();\n     let f = move|:| -> () {\n         let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n-        tx.send(tmp.path().clone());\n+        tx.send(tmp.path().clone()).unwrap();\n         tmp.close();\n         panic!(\"panic when unwinding past `tmp`\");\n     };\n     task::try(f);\n-    let path = rx.recv();\n+    let path = rx.recv().unwrap();\n     assert!(!path.exists());\n \n     let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();"}, {"sha": "0d2cb60c213c112083226d27884a85339f6c040f", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -12,7 +12,7 @@\n // and shared between tasks as long as all types fulfill Send.\n \n use std::sync::Arc;\n-use std::comm::channel;\n+use std::sync::mpsc::channel;\n use std::task;\n \n trait Pet {"}, {"sha": "6bece8265c0066252f3f68752a86181b49d8dd0a", "filename": "src/test/run-pass/trivial-message.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftrivial-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Ftrivial-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrivial-message.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -13,7 +13,7 @@\n   message.\n  */\n \n-use std::comm::channel;\n+use std::sync::mpsc::channel;\n \n pub fn main() {\n     let (tx, rx) = channel();"}, {"sha": "f88c458f2ed76d235c480c01fbf4a00050573037", "filename": "src/test/run-pass/unique-send-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-send-2.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n use std::task;\n-use std::comm::{channel, Sender};\n+use std::sync::mpsc::{channel, Sender};\n \n fn child(tx: &Sender<Box<uint>>, i: uint) {\n-    tx.send(box i);\n+    tx.send(box i).unwrap();\n }\n \n pub fn main() {\n@@ -29,7 +29,7 @@ pub fn main() {\n \n     let mut actual = 0u;\n     for _ in range(0u, n) {\n-        let j = rx.recv();\n+        let j = rx.recv().unwrap();\n         actual += *j;\n     }\n "}, {"sha": "afafb204c1c9f7072e5093fc20cb335422928eba", "filename": "src/test/run-pass/unique-send.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Funique-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Funique-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-send.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::comm::channel;\n+use std::sync::mpsc::channel;\n \n pub fn main() {\n     let (tx, rx) = channel();\n-    tx.send(box 100i);\n-    let v = rx.recv();\n+    tx.send(box 100i).unwrap();\n+    let v = rx.recv().unwrap();\n     assert_eq!(v, box 100i);\n }"}, {"sha": "943b2d3edd12ee9be9e71c6ae48a883ba78a7b99", "filename": "src/test/run-pass/unwind-resource.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc83a009f655dd3896be4a7cd33cac8032a605f2/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-resource.rs?ref=bc83a009f655dd3896be4a7cd33cac8032a605f2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::comm::{channel, Sender};\n+use std::sync::mpsc::{channel, Sender};\n use std::task;\n \n struct complainer {\n@@ -18,7 +18,7 @@ struct complainer {\n impl Drop for complainer {\n     fn drop(&mut self) {\n         println!(\"About to send!\");\n-        self.tx.send(true);\n+        self.tx.send(true).unwrap();\n         println!(\"Sent!\");\n     }\n }\n@@ -39,5 +39,5 @@ pub fn main() {\n     let (tx, rx) = channel();\n     task::spawn(move|| f(tx.clone()));\n     println!(\"hiiiiiiiii\");\n-    assert!(rx.recv());\n+    assert!(rx.recv().unwrap());\n }"}]}