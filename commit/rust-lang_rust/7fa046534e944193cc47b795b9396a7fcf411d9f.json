{"sha": "7fa046534e944193cc47b795b9396a7fcf411d9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmYTA0NjUzNGU5NDQxOTNjYzQ3Yjc5NWI5Mzk2YTdmY2Y0MTFkOWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-04T11:22:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-04T11:22:26Z"}, "message": "Auto merge of #66275 - oli-obk:organize-intrinsics-promotion-checks, r=RalfJung\n\nOrganize intrinsics promotion checks\n\ncc @vertexclique\n\nsupersedes #61835\n\nr? @RalfJung", "tree": {"sha": "c2c5e15e4bf8b05dbe83717f5124269cf08d78fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2c5e15e4bf8b05dbe83717f5124269cf08d78fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7fa046534e944193cc47b795b9396a7fcf411d9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7fa046534e944193cc47b795b9396a7fcf411d9f", "html_url": "https://github.com/rust-lang/rust/commit/7fa046534e944193cc47b795b9396a7fcf411d9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7fa046534e944193cc47b795b9396a7fcf411d9f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca", "html_url": "https://github.com/rust-lang/rust/commit/5f1d6c44034ac143f7a3e56ae7ea8858dcbb61ca"}, {"sha": "5cef094a72f61966146338015f7e52874d57bcbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cef094a72f61966146338015f7e52874d57bcbd", "html_url": "https://github.com/rust-lang/rust/commit/5cef094a72f61966146338015f7e52874d57bcbd"}], "stats": {"total": 415, "additions": 248, "deletions": 167}, "files": [{"sha": "19928f30f2ea5907076ad43501fbb4b58c7fd86f", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7fa046534e944193cc47b795b9396a7fcf411d9f/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fa046534e944193cc47b795b9396a7fcf411d9f/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=7fa046534e944193cc47b795b9396a7fcf411d9f", "patch": "@@ -939,6 +939,7 @@ extern \"rust-intrinsic\" {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_unstable(feature = \"const_transmute\")]\n     pub fn transmute<T, U>(e: T) -> U;\n \n     /// Returns `true` if the actual type given as `T` requires drop"}, {"sha": "268015a56240e52290ecd360be42220da92a5108", "filename": "src/librustc/ty/constness.rs", "status": "modified", "additions": 112, "deletions": 3, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/7fa046534e944193cc47b795b9396a7fcf411d9f/src%2Flibrustc%2Fty%2Fconstness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fa046534e944193cc47b795b9396a7fcf411d9f/src%2Flibrustc%2Fty%2Fconstness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fconstness.rs?ref=7fa046534e944193cc47b795b9396a7fcf411d9f", "patch": "@@ -2,7 +2,8 @@ use crate::ty::query::Providers;\n use crate::hir::def_id::DefId;\n use crate::hir;\n use crate::ty::TyCtxt;\n-use syntax_pos::symbol::Symbol;\n+use syntax_pos::symbol::{sym, Symbol};\n+use rustc_target::spec::abi::Abi;\n use crate::hir::map::blocks::FnLikeNode;\n use syntax::attr;\n \n@@ -35,12 +36,51 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n+    /// Returns `true` if the `def_id` refers to an intrisic which we've whitelisted\n+    /// for being called from stable `const fn`s (`min_const_fn`).\n+    ///\n+    /// Adding more intrinsics requires sign-off from @rust-lang/lang.\n+    ///\n+    /// This list differs from the list in `is_const_intrinsic` in the sense that any item on this\n+    /// list must be on the `is_const_intrinsic` list, too, because if an intrinsic is callable from\n+    /// stable, it must be callable at all.\n+    fn is_intrinsic_min_const_fn(self, def_id: DefId) -> bool {\n+        match self.item_name(def_id) {\n+            | sym::size_of\n+            | sym::min_align_of\n+            | sym::needs_drop\n+            // Arithmetic:\n+            | sym::add_with_overflow // ~> .overflowing_add\n+            | sym::sub_with_overflow // ~> .overflowing_sub\n+            | sym::mul_with_overflow // ~> .overflowing_mul\n+            | sym::wrapping_add // ~> .wrapping_add\n+            | sym::wrapping_sub // ~> .wrapping_sub\n+            | sym::wrapping_mul // ~> .wrapping_mul\n+            | sym::saturating_add // ~> .saturating_add\n+            | sym::saturating_sub // ~> .saturating_sub\n+            | sym::unchecked_shl // ~> .wrapping_shl\n+            | sym::unchecked_shr // ~> .wrapping_shr\n+            | sym::rotate_left // ~> .rotate_left\n+            | sym::rotate_right // ~> .rotate_right\n+            | sym::ctpop // ~> .count_ones\n+            | sym::ctlz // ~> .leading_zeros\n+            | sym::cttz // ~> .trailing_zeros\n+            | sym::bswap // ~> .swap_bytes\n+            | sym::bitreverse // ~> .reverse_bits\n+            => true,\n+            _ => false,\n+        }\n+    }\n+\n     /// Returns `true` if this function must conform to `min_const_fn`\n     pub fn is_min_const_fn(self, def_id: DefId) -> bool {\n         // Bail out if the signature doesn't contain `const`\n         if !self.is_const_fn_raw(def_id) {\n             return false;\n         }\n+        if let Abi::RustIntrinsic = self.fn_sig(def_id).abi() {\n+            return self.is_intrinsic_min_const_fn(def_id);\n+        }\n \n         if self.features().staged_api {\n             // in order for a libstd function to be considered min_const_fn\n@@ -63,13 +103,82 @@ impl<'tcx> TyCtxt<'tcx> {\n \n \n pub fn provide(providers: &mut Providers<'_>) {\n-    /// only checks whether the function has a `const` modifier\n+    /// Const evaluability whitelist is here to check evaluability at the\n+    /// top level beforehand.\n+    fn is_const_intrinsic(tcx: TyCtxt<'_>, def_id: DefId) -> Option<bool> {\n+        match tcx.fn_sig(def_id).abi() {\n+            Abi::RustIntrinsic |\n+            Abi::PlatformIntrinsic => {\n+                // FIXME: deduplicate these two lists as much as possible\n+                match tcx.item_name(def_id) {\n+                    // Keep this list in the same order as the match patterns in\n+                    // `librustc_mir/interpret/intrinsics.rs`\n+\n+                    // This whitelist is a list of intrinsics that have a miri-engine implementation\n+                    // and can thus be called when enabling enough feature gates. The similar\n+                    // whitelist in `is_intrinsic_min_const_fn` (in this file), exists for allowing\n+                    // the intrinsics to be called by stable const fns.\n+                    | sym::caller_location\n+\n+                    | sym::min_align_of\n+                    | sym::pref_align_of\n+                    | sym::needs_drop\n+                    | sym::size_of\n+                    | sym::type_id\n+                    | sym::type_name\n+\n+                    | sym::ctpop\n+                    | sym::cttz\n+                    | sym::cttz_nonzero\n+                    | sym::ctlz\n+                    | sym::ctlz_nonzero\n+                    | sym::bswap\n+                    | sym::bitreverse\n+\n+                    | sym::wrapping_add\n+                    | sym::wrapping_sub\n+                    | sym::wrapping_mul\n+                    | sym::add_with_overflow\n+                    | sym::sub_with_overflow\n+                    | sym::mul_with_overflow\n+\n+                    | sym::saturating_add\n+                    | sym::saturating_sub\n+\n+                    | sym::unchecked_shl\n+                    | sym::unchecked_shr\n+\n+                    | sym::rotate_left\n+                    | sym::rotate_right\n+\n+                    | sym::ptr_offset_from\n+\n+                    | sym::transmute\n+\n+                    | sym::simd_insert\n+\n+                    | sym::simd_extract\n+\n+                    => Some(true),\n+\n+                    _ => Some(false)\n+                }\n+            }\n+            _ => None\n+        }\n+    }\n+\n+    /// Checks whether the function has a `const` modifier or, in case it is an intrinsic, whether\n+    /// said intrinsic is on the whitelist for being const callable.\n     fn is_const_fn_raw(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n         let hir_id = tcx.hir().as_local_hir_id(def_id)\n                               .expect(\"Non-local call to local provider is_const_fn\");\n \n         let node = tcx.hir().get(hir_id);\n-        if let Some(fn_like) = FnLikeNode::from_node(node) {\n+\n+        if let Some(whitelisted) = is_const_intrinsic(tcx, def_id) {\n+            whitelisted\n+        } else if let Some(fn_like) = FnLikeNode::from_node(node) {\n             fn_like.constness() == hir::Constness::Const\n         } else if let hir::Node::Ctor(_) = node {\n             true"}, {"sha": "fc880b9e9295114f5d7d953074f3a32ebbcc6aab", "filename": "src/librustc_feature/active.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fa046534e944193cc47b795b9396a7fcf411d9f/src%2Flibrustc_feature%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fa046534e944193cc47b795b9396a7fcf411d9f/src%2Flibrustc_feature%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Factive.rs?ref=7fa046534e944193cc47b795b9396a7fcf411d9f", "patch": "@@ -408,10 +408,6 @@ declare_features! (\n     /// Allows using `#[doc(keyword = \"...\")]`.\n     (active, doc_keyword, \"1.28.0\", Some(51315), None),\n \n-    /// Allows reinterpretation of the bits of a value of one type as another\n-    /// type during const eval.\n-    (active, const_transmute, \"1.29.0\", Some(53605), None),\n-\n     /// Allows using `try {...}` expressions.\n     (active, try_blocks, \"1.29.0\", Some(31436), None),\n "}, {"sha": "6edd17fe9abef21599890246898ef0911678a61e", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7fa046534e944193cc47b795b9396a7fcf411d9f/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fa046534e944193cc47b795b9396a7fcf411d9f/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=7fa046534e944193cc47b795b9396a7fcf411d9f", "patch": "@@ -1360,10 +1360,16 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n+    // This replicates some of the logic of the crate-local `is_const_fn_raw` query, because we\n+    // don't serialize constness for tuple variant and tuple struct constructors.\n     fn is_const_fn_raw(&self, id: DefIndex) -> bool {\n         let constness = match self.kind(id) {\n             EntryKind::Method(data) => data.decode(self).fn_data.constness,\n             EntryKind::Fn(data) => data.decode(self).constness,\n+            // Some intrinsics can be const fn. While we could recompute this (at least until we\n+            // stop having hardcoded whitelists and move to stability attributes), it seems cleaner\n+            // to treat all const fns equally.\n+            EntryKind::ForeignFn(data) => data.decode(self).constness,\n             EntryKind::Variant(..) | EntryKind::Struct(..) => hir::Constness::Const,\n             _ => hir::Constness::NotConst,\n         };"}, {"sha": "fb70e10c84f3dcef07b0976941aab4bd6bdf83c1", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7fa046534e944193cc47b795b9396a7fcf411d9f/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fa046534e944193cc47b795b9396a7fcf411d9f/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=7fa046534e944193cc47b795b9396a7fcf411d9f", "patch": "@@ -1525,7 +1525,11 @@ impl EncodeContext<'tcx> {\n             hir::ForeignItemKind::Fn(_, ref names, _) => {\n                 let data = FnData {\n                     asyncness: hir::IsAsync::NotAsync,\n-                    constness: hir::Constness::NotConst,\n+                    constness: if self.tcx.is_const_fn_raw(def_id) {\n+                        hir::Constness::Const\n+                    } else {\n+                        hir::Constness::NotConst\n+                    },\n                     param_names: self.encode_fn_param_names(names),\n                 };\n                 EntryKind::ForeignFn(self.lazy(data))"}, {"sha": "ad5df5aff1ac805f723404a04777daa7610b91b9", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 66, "deletions": 63, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/7fa046534e944193cc47b795b9396a7fcf411d9f/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fa046534e944193cc47b795b9396a7fcf411d9f/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=7fa046534e944193cc47b795b9396a7fcf411d9f", "patch": "@@ -2,7 +2,7 @@\n //! looking at their MIR. Intrinsics/functions supported here are shared by CTFE\n //! and miri.\n \n-use syntax::symbol::Symbol;\n+use syntax_pos::symbol::{sym, Symbol};\n use syntax_pos::Span;\n use rustc::ty;\n use rustc::ty::layout::{LayoutOf, Primitive, Size};\n@@ -22,7 +22,7 @@ mod caller_location;\n mod type_name;\n \n fn numeric_intrinsic<'tcx, Tag>(\n-    name: &str,\n+    name: Symbol,\n     bits: u128,\n     kind: Primitive,\n ) -> InterpResult<'tcx, Scalar<Tag>> {\n@@ -32,11 +32,11 @@ fn numeric_intrinsic<'tcx, Tag>(\n     };\n     let extra = 128 - size.bits() as u128;\n     let bits_out = match name {\n-        \"ctpop\" => bits.count_ones() as u128,\n-        \"ctlz\" => bits.leading_zeros() as u128 - extra,\n-        \"cttz\" => (bits << extra).trailing_zeros() as u128 - extra,\n-        \"bswap\" => (bits << extra).swap_bytes(),\n-        \"bitreverse\" => (bits << extra).reverse_bits(),\n+        sym::ctpop => bits.count_ones() as u128,\n+        sym::ctlz => bits.leading_zeros() as u128 - extra,\n+        sym::cttz => (bits << extra).trailing_zeros() as u128 - extra,\n+        sym::bswap => (bits << extra).swap_bytes(),\n+        sym::bitreverse => (bits << extra).reverse_bits(),\n         _ => bug!(\"not a numeric intrinsic: {}\", name),\n     };\n     Ok(Scalar::from_uint(bits_out, size))\n@@ -51,9 +51,9 @@ crate fn eval_nullary_intrinsic<'tcx>(\n     substs: SubstsRef<'tcx>,\n ) -> InterpResult<'tcx, &'tcx ty::Const<'tcx>> {\n     let tp_ty = substs.type_at(0);\n-    let name = &*tcx.item_name(def_id).as_str();\n+    let name = tcx.item_name(def_id);\n     Ok(match name {\n-        \"type_name\" => {\n+        sym::type_name => {\n             let alloc = type_name::alloc_type_name(tcx, tp_ty);\n             tcx.mk_const(ty::Const {\n                 val: ty::ConstKind::Value(ConstValue::Slice {\n@@ -64,20 +64,20 @@ crate fn eval_nullary_intrinsic<'tcx>(\n                 ty: tcx.mk_static_str(),\n             })\n         },\n-        \"needs_drop\" => ty::Const::from_bool(tcx, tp_ty.needs_drop(tcx, param_env)),\n-        \"size_of\" |\n-        \"min_align_of\" |\n-        \"pref_align_of\" => {\n+        sym::needs_drop => ty::Const::from_bool(tcx, tp_ty.needs_drop(tcx, param_env)),\n+        sym::size_of |\n+        sym::min_align_of |\n+        sym::pref_align_of => {\n             let layout = tcx.layout_of(param_env.and(tp_ty)).map_err(|e| err_inval!(Layout(e)))?;\n             let n = match name {\n-                \"pref_align_of\" => layout.align.pref.bytes(),\n-                \"min_align_of\" => layout.align.abi.bytes(),\n-                \"size_of\" => layout.size.bytes(),\n+                sym::pref_align_of => layout.align.pref.bytes(),\n+                sym::min_align_of => layout.align.abi.bytes(),\n+                sym::size_of => layout.size.bytes(),\n                 _ => bug!(),\n             };\n             ty::Const::from_usize(tcx, n)\n         },\n-        \"type_id\" => ty::Const::from_bits(\n+        sym::type_id => ty::Const::from_bits(\n             tcx,\n             tcx.type_id_hash(tp_ty).into(),\n             param_env.and(tcx.types.u64),\n@@ -96,30 +96,32 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ret: Option<(PlaceTy<'tcx, M::PointerTag>, mir::BasicBlock)>,\n     ) -> InterpResult<'tcx, bool> {\n         let substs = instance.substs;\n-        let intrinsic_name = &*self.tcx.item_name(instance.def_id()).as_str();\n+        let intrinsic_name = self.tcx.item_name(instance.def_id());\n \n         // We currently do not handle any intrinsics that are *allowed* to diverge,\n         // but `transmute` could lack a return place in case of UB.\n         let (dest, ret) = match ret {\n             Some(p) => p,\n             None => match intrinsic_name {\n-                \"transmute\" => throw_ub!(Unreachable),\n+                sym::transmute => throw_ub!(Unreachable),\n                 _ => return Ok(false),\n             }\n         };\n \n+        // Keep the patterns in this match ordered the same as the list in\n+        // `src/librustc/ty/constness.rs`\n         match intrinsic_name {\n-            \"caller_location\" => {\n+            sym::caller_location => {\n                 let location = self.alloc_caller_location_for_span(span);\n                 self.write_scalar(location.ptr, dest)?;\n             }\n \n-            \"min_align_of\" |\n-            \"pref_align_of\" |\n-            \"needs_drop\" |\n-            \"size_of\" |\n-            \"type_id\" |\n-            \"type_name\" => {\n+            sym::min_align_of |\n+            sym::pref_align_of |\n+            sym::needs_drop |\n+            sym::size_of |\n+            sym::type_id |\n+            sym::type_name => {\n                 let gid = GlobalId {\n                     instance,\n                     promoted: None,\n@@ -129,13 +131,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.copy_op(val, dest)?;\n             }\n \n-            | \"ctpop\"\n-            | \"cttz\"\n-            | \"cttz_nonzero\"\n-            | \"ctlz\"\n-            | \"ctlz_nonzero\"\n-            | \"bswap\"\n-            | \"bitreverse\" => {\n+            | sym::ctpop\n+            | sym::cttz\n+            | sym::cttz_nonzero\n+            | sym::ctlz\n+            | sym::ctlz_nonzero\n+            | sym::bswap\n+            | sym::bitreverse => {\n                 let ty = substs.type_at(0);\n                 let layout_of = self.layout_of(ty)?;\n                 let val = self.read_scalar(args[0])?.not_undef()?;\n@@ -144,31 +146,32 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     ty::layout::Abi::Scalar(ref scalar) => scalar.value,\n                     _ => throw_unsup!(TypeNotPrimitive(ty)),\n                 };\n-                let out_val = if intrinsic_name.ends_with(\"_nonzero\") {\n-                    if bits == 0 {\n-                        throw_ub_format!(\"`{}` called on 0\", intrinsic_name);\n-                    }\n-                    numeric_intrinsic(intrinsic_name.trim_end_matches(\"_nonzero\"), bits, kind)?\n-                } else {\n-                    numeric_intrinsic(intrinsic_name, bits, kind)?\n+                let (nonzero, intrinsic_name) = match intrinsic_name {\n+                    sym::cttz_nonzero => (true, sym::cttz),\n+                    sym::ctlz_nonzero => (true, sym::ctlz),\n+                    other => (false, other),\n                 };\n+                if nonzero && bits == 0 {\n+                    throw_ub_format!(\"`{}_nonzero` called on 0\", intrinsic_name);\n+                }\n+                let out_val = numeric_intrinsic(intrinsic_name, bits, kind)?;\n                 self.write_scalar(out_val, dest)?;\n             }\n-            | \"wrapping_add\"\n-            | \"wrapping_sub\"\n-            | \"wrapping_mul\"\n-            | \"add_with_overflow\"\n-            | \"sub_with_overflow\"\n-            | \"mul_with_overflow\" => {\n+            | sym::wrapping_add\n+            | sym::wrapping_sub\n+            | sym::wrapping_mul\n+            | sym::add_with_overflow\n+            | sym::sub_with_overflow\n+            | sym::mul_with_overflow => {\n                 let lhs = self.read_immediate(args[0])?;\n                 let rhs = self.read_immediate(args[1])?;\n                 let (bin_op, ignore_overflow) = match intrinsic_name {\n-                    \"wrapping_add\" => (BinOp::Add, true),\n-                    \"wrapping_sub\" => (BinOp::Sub, true),\n-                    \"wrapping_mul\" => (BinOp::Mul, true),\n-                    \"add_with_overflow\" => (BinOp::Add, false),\n-                    \"sub_with_overflow\" => (BinOp::Sub, false),\n-                    \"mul_with_overflow\" => (BinOp::Mul, false),\n+                    sym::wrapping_add => (BinOp::Add, true),\n+                    sym::wrapping_sub => (BinOp::Sub, true),\n+                    sym::wrapping_mul => (BinOp::Mul, true),\n+                    sym::add_with_overflow => (BinOp::Add, false),\n+                    sym::sub_with_overflow => (BinOp::Sub, false),\n+                    sym::mul_with_overflow => (BinOp::Mul, false),\n                     _ => bug!(\"Already checked for int ops\")\n                 };\n                 if ignore_overflow {\n@@ -177,10 +180,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     self.binop_with_overflow(bin_op, lhs, rhs, dest)?;\n                 }\n             }\n-            \"saturating_add\" | \"saturating_sub\" => {\n+            sym::saturating_add | sym::saturating_sub => {\n                 let l = self.read_immediate(args[0])?;\n                 let r = self.read_immediate(args[1])?;\n-                let is_add = intrinsic_name == \"saturating_add\";\n+                let is_add = intrinsic_name == sym::saturating_add;\n                 let (val, overflowed, _ty) = self.overflowing_binary_op(if is_add {\n                     BinOp::Add\n                 } else {\n@@ -220,12 +223,12 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 self.write_scalar(val, dest)?;\n             }\n-            \"unchecked_shl\" | \"unchecked_shr\" => {\n+            sym::unchecked_shl | sym::unchecked_shr => {\n                 let l = self.read_immediate(args[0])?;\n                 let r = self.read_immediate(args[1])?;\n                 let bin_op = match intrinsic_name {\n-                    \"unchecked_shl\" => BinOp::Shl,\n-                    \"unchecked_shr\" => BinOp::Shr,\n+                    sym::unchecked_shl => BinOp::Shl,\n+                    sym::unchecked_shr => BinOp::Shr,\n                     _ => bug!(\"Already checked for int ops\")\n                 };\n                 let (val, overflowed, _ty) = self.overflowing_binary_op(bin_op, l, r)?;\n@@ -236,7 +239,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n                 self.write_scalar(val, dest)?;\n             }\n-            \"rotate_left\" | \"rotate_right\" => {\n+            sym::rotate_left | sym::rotate_right => {\n                 // rotate_left: (X << (S % BW)) | (X >> ((BW - S) % BW))\n                 // rotate_right: (X << ((BW - S) % BW)) | (X >> (S % BW))\n                 let layout = self.layout_of(substs.type_at(0))?;\n@@ -247,7 +250,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let width_bits = layout.size.bits() as u128;\n                 let shift_bits = raw_shift_bits % width_bits;\n                 let inv_shift_bits = (width_bits - shift_bits) % width_bits;\n-                let result_bits = if intrinsic_name == \"rotate_left\" {\n+                let result_bits = if intrinsic_name == sym::rotate_left {\n                     (val_bits << shift_bits) | (val_bits >> inv_shift_bits)\n                 } else {\n                     (val_bits >> shift_bits) | (val_bits << inv_shift_bits)\n@@ -257,7 +260,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.write_scalar(result, dest)?;\n             }\n \n-            \"ptr_offset_from\" => {\n+            sym::ptr_offset_from => {\n                 let isize_layout = self.layout_of(self.tcx.types.isize)?;\n                 let a = self.read_immediate(args[0])?.to_scalar()?;\n                 let b = self.read_immediate(args[1])?.to_scalar()?;\n@@ -303,10 +306,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n             }\n \n-            \"transmute\" => {\n+            sym::transmute => {\n                 self.copy_op_transmute(args[0], dest)?;\n             }\n-            \"simd_insert\" => {\n+            sym::simd_insert => {\n                 let index = u64::from(self.read_scalar(args[1])?.to_u32()?);\n                 let elem = args[2];\n                 let input = args[0];\n@@ -337,7 +340,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     self.copy_op(value, place)?;\n                 }\n             }\n-            \"simd_extract\" => {\n+            sym::simd_extract => {\n                 let index = u64::from(self.read_scalar(args[1])?.to_u32()?);\n                 let (len, e_ty) = args[0].layout.ty.simd_size_and_type(self.tcx.tcx);\n                 assert!("}, {"sha": "aec3cf04a97ca195cec04325bc6b0108b71d96a4", "filename": "src/librustc_mir/transform/check_consts/ops.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7fa046534e944193cc47b795b9396a7fcf411d9f/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fa046534e944193cc47b795b9396a7fcf411d9f/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs?ref=7fa046534e944193cc47b795b9396a7fcf411d9f", "patch": "@@ -326,22 +326,6 @@ impl NonConstOp for ThreadLocalAccess {\n     }\n }\n \n-#[derive(Debug)]\n-pub struct Transmute;\n-impl NonConstOp for Transmute {\n-    fn feature_gate(tcx: TyCtxt<'_>) -> Option<bool> {\n-        Some(tcx.features().const_transmute)\n-    }\n-\n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n-        feature_err(\n-            &item.tcx.sess.parse_sess, sym::const_transmute, span,\n-            &format!(\"The use of std::mem::transmute() is gated in {}s\", item.const_kind())\n-        )\n-        .emit();\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct UnionAccess;\n impl NonConstOp for UnionAccess {"}, {"sha": "f44bac126f276c4a4752a2caff0b44c347c095ad", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7fa046534e944193cc47b795b9396a7fcf411d9f/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fa046534e944193cc47b795b9396a7fcf411d9f/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=7fa046534e944193cc47b795b9396a7fcf411d9f", "patch": "@@ -8,7 +8,6 @@ use rustc::traits::{self, TraitEngine};\n use rustc::ty::cast::CastTy;\n use rustc::ty::{self, TyCtxt};\n use rustc_index::bit_set::BitSet;\n-use rustc_target::spec::abi::Abi;\n use rustc_error_codes::*;\n use syntax::symbol::sym;\n use syntax_pos::Span;\n@@ -202,7 +201,7 @@ impl Validator<'a, 'mir, 'tcx> {\n         let Item { tcx, body, def_id, const_kind, ..  } = *self.item;\n \n         let use_min_const_fn_checks =\n-            tcx.is_min_const_fn(def_id)\n+            (const_kind == Some(ConstKind::ConstFn) && tcx.is_min_const_fn(def_id))\n             && !tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you;\n \n         if use_min_const_fn_checks {\n@@ -564,23 +563,6 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                 };\n \n                 // At this point, we are calling a function whose `DefId` is known...\n-\n-                if let Abi::RustIntrinsic | Abi::PlatformIntrinsic = self.tcx.fn_sig(def_id).abi() {\n-                    assert!(!self.tcx.is_const_fn(def_id));\n-\n-                    if self.tcx.item_name(def_id) == sym::transmute {\n-                        self.check_op(ops::Transmute);\n-                        return;\n-                    }\n-\n-                    // To preserve the current semantics, we return early, allowing all\n-                    // intrinsics (except `transmute`) to pass unchecked to miri.\n-                    //\n-                    // FIXME: We should keep a whitelist of allowed intrinsics (or at least a\n-                    // blacklist of unimplemented ones) and fail here instead.\n-                    return;\n-                }\n-\n                 if self.tcx.is_const_fn(def_id) {\n                     return;\n                 }"}, {"sha": "3030d2e646b8d494cb8b68a1bd9fe65eba7173a8", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 3, "deletions": 53, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7fa046534e944193cc47b795b9396a7fcf411d9f/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fa046534e944193cc47b795b9396a7fcf411d9f/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=7fa046534e944193cc47b795b9396a7fcf411d9f", "patch": "@@ -2,7 +2,6 @@ use rustc::hir::def_id::DefId;\n use rustc::hir;\n use rustc::mir::*;\n use rustc::ty::{self, Predicate, Ty, TyCtxt, adjustment::{PointerCast}};\n-use rustc_target::spec::abi;\n use std::borrow::Cow;\n use syntax_pos::Span;\n use syntax::symbol::{sym, Symbol};\n@@ -356,33 +355,16 @@ fn check_terminator(\n         } => {\n             let fn_ty = func.ty(body, tcx);\n             if let ty::FnDef(def_id, _) = fn_ty.kind {\n-\n-                // some intrinsics are waved through if called inside the\n-                // standard library. Users never need to call them directly\n-                match tcx.fn_sig(def_id).abi() {\n-                    abi::Abi::RustIntrinsic => if !is_intrinsic_whitelisted(tcx, def_id) {\n-                        return Err((\n-                            span,\n-                            \"can only call a curated list of intrinsics in `min_const_fn`\".into(),\n-                        ))\n-                    },\n-                    abi::Abi::Rust if tcx.is_min_const_fn(def_id) => {},\n-                    abi::Abi::Rust => return Err((\n+                if !tcx.is_min_const_fn(def_id) {\n+                    return Err((\n                         span,\n                         format!(\n                             \"can only call other `const fn` within a `const fn`, \\\n                              but `{:?}` is not stable as `const fn`\",\n                             func,\n                         )\n                         .into(),\n-                    )),\n-                    abi => return Err((\n-                        span,\n-                        format!(\n-                            \"cannot call functions with `{}` abi in `min_const_fn`\",\n-                            abi,\n-                        ).into(),\n-                    )),\n+                    ));\n                 }\n \n                 check_operand(tcx, func, span, def_id, body)?;\n@@ -409,35 +391,3 @@ fn check_terminator(\n         },\n     }\n }\n-\n-/// Returns `true` if the `def_id` refers to an intrisic which we've whitelisted\n-/// for being called from stable `const fn`s (`min_const_fn`).\n-///\n-/// Adding more intrinsics requires sign-off from @rust-lang/lang.\n-fn is_intrinsic_whitelisted(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n-    match &*tcx.item_name(def_id).as_str() {\n-        | \"size_of\"\n-        | \"min_align_of\"\n-        | \"needs_drop\"\n-        // Arithmetic:\n-        | \"add_with_overflow\" // ~> .overflowing_add\n-        | \"sub_with_overflow\" // ~> .overflowing_sub\n-        | \"mul_with_overflow\" // ~> .overflowing_mul\n-        | \"wrapping_add\" // ~> .wrapping_add\n-        | \"wrapping_sub\" // ~> .wrapping_sub\n-        | \"wrapping_mul\" // ~> .wrapping_mul\n-        | \"saturating_add\" // ~> .saturating_add\n-        | \"saturating_sub\" // ~> .saturating_sub\n-        | \"unchecked_shl\" // ~> .wrapping_shl\n-        | \"unchecked_shr\" // ~> .wrapping_shr\n-        | \"rotate_left\" // ~> .rotate_left\n-        | \"rotate_right\" // ~> .rotate_right\n-        | \"ctpop\" // ~> .count_ones\n-        | \"ctlz\" // ~> .leading_zeros\n-        | \"cttz\" // ~> .trailing_zeros\n-        | \"bswap\" // ~> .swap_bytes\n-        | \"bitreverse\" // ~> .reverse_bits\n-        => true,\n-        _ => false,\n-    }\n-}"}, {"sha": "2af66711d3cd0f271dffa717bc0594c9ddc1d567", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7fa046534e944193cc47b795b9396a7fcf411d9f/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fa046534e944193cc47b795b9396a7fcf411d9f/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=7fa046534e944193cc47b795b9396a7fcf411d9f", "patch": "@@ -121,6 +121,7 @@ symbols! {\n         abi_vectorcall,\n         abi_x86_interrupt,\n         aborts,\n+        add_with_overflow,\n         advanced_slice_patterns,\n         adx_target_feature,\n         alias,\n@@ -171,7 +172,10 @@ symbols! {\n         box_patterns,\n         box_syntax,\n         braced_empty_structs,\n+        bswap,\n+        bitreverse,\n         C,\n+        caller_location,\n         cdylib,\n         cfg,\n         cfg_attr,\n@@ -226,6 +230,11 @@ symbols! {\n         crate_name,\n         crate_type,\n         crate_visibility_modifier,\n+        ctpop,\n+        cttz,\n+        cttz_nonzero,\n+        ctlz,\n+        ctlz_nonzero,\n         custom_attribute,\n         custom_derive,\n         custom_inner_attributes,\n@@ -431,6 +440,7 @@ symbols! {\n         member_constraints,\n         message,\n         meta,\n+        min_align_of,\n         min_const_fn,\n         min_const_unsafe_fn,\n         mips_target_feature,\n@@ -440,11 +450,13 @@ symbols! {\n         more_struct_aliases,\n         move_val_init,\n         movbe_target_feature,\n+        mul_with_overflow,\n         must_use,\n         naked,\n         naked_functions,\n         name,\n         needs_allocator,\n+        needs_drop,\n         needs_panic_runtime,\n         negate_unsigned,\n         never,\n@@ -520,6 +532,7 @@ symbols! {\n         poll_with_tls_context,\n         powerpc_target_feature,\n         precise_pointer_size_matching,\n+        pref_align_of,\n         prelude,\n         prelude_import,\n         primitive,\n@@ -536,6 +549,7 @@ symbols! {\n         proc_macro_non_items,\n         proc_macro_path_invoc,\n         profiler_runtime,\n+        ptr_offset_from,\n         pub_restricted,\n         pushpop_unsafe,\n         quad_precision_float,\n@@ -571,6 +585,8 @@ symbols! {\n         Return,\n         rhs,\n         rlib,\n+        rotate_left,\n+        rotate_right,\n         rt,\n         rtm_target_feature,\n         rust,\n@@ -638,14 +654,19 @@ symbols! {\n         rvalue_static_promotion,\n         sanitize,\n         sanitizer_runtime,\n+        saturating_add,\n+        saturating_sub,\n         _Self,\n         self_in_typedefs,\n         self_struct_ctor,\n         should_panic,\n         simd,\n+        simd_extract,\n         simd_ffi,\n+        simd_insert,\n         since,\n         size,\n+        size_of,\n         slice_patterns,\n         slicing_syntax,\n         soft,\n@@ -673,6 +694,7 @@ symbols! {\n         structural_match,\n         struct_variant,\n         sty,\n+        sub_with_overflow,\n         suggestion,\n         target_feature,\n         target_has_atomic,\n@@ -708,6 +730,8 @@ symbols! {\n         Ty,\n         ty,\n         type_alias_impl_trait,\n+        type_id,\n+        type_name,\n         TyCtxt,\n         TyKind,\n         type_alias_enum_variants,\n@@ -720,6 +744,8 @@ symbols! {\n         u64,\n         u8,\n         unboxed_closures,\n+        unchecked_shl,\n+        unchecked_shr,\n         underscore_const_names,\n         underscore_imports,\n         underscore_lifetimes,\n@@ -753,6 +779,9 @@ symbols! {\n         while_let,\n         windows,\n         windows_subsystem,\n+        wrapping_add,\n+        wrapping_sub,\n+        wrapping_mul,\n         Yield,\n     }\n }"}, {"sha": "bdcf537859cc40d08364c1c3d4a2065e7f828315", "filename": "src/test/ui/consts/const-eval/const-eval-intrinsic-promotion.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7fa046534e944193cc47b795b9396a7fcf411d9f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-intrinsic-promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fa046534e944193cc47b795b9396a7fcf411d9f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-intrinsic-promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-intrinsic-promotion.rs?ref=7fa046534e944193cc47b795b9396a7fcf411d9f", "patch": "@@ -0,0 +1,6 @@\n+#![feature(core_intrinsics)]\n+fn main() {\n+    // Test that calls to intrinsics are never promoted\n+    let x: &'static usize =\n+        &std::intrinsics::size_of::<i32>(); //~ ERROR temporary value dropped while borrowed\n+}"}, {"sha": "78143042ece7bfc30aa3d714e4677d37571c448f", "filename": "src/test/ui/consts/const-eval/const-eval-intrinsic-promotion.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7fa046534e944193cc47b795b9396a7fcf411d9f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-intrinsic-promotion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fa046534e944193cc47b795b9396a7fcf411d9f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-intrinsic-promotion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-intrinsic-promotion.stderr?ref=7fa046534e944193cc47b795b9396a7fcf411d9f", "patch": "@@ -0,0 +1,13 @@\n+error[E0716]: temporary value dropped while borrowed\n+  --> $DIR/const-eval-intrinsic-promotion.rs:5:10\n+   |\n+LL |     let x: &'static usize =\n+   |            -------------- type annotation requires that borrow lasts for `'static`\n+LL |         &std::intrinsics::size_of::<i32>();\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ creates a temporary which is freed while still in use\n+LL | }\n+   | - temporary value is freed at the end of this statement\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0716`."}, {"sha": "6469a65700dad155a796c78c3bba5b1b71639780", "filename": "src/test/ui/consts/const-extern-fn/const-extern-fn-call-extern-fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fa046534e944193cc47b795b9396a7fcf411d9f/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-call-extern-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fa046534e944193cc47b795b9396a7fcf411d9f/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-call-extern-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-call-extern-fn.rs?ref=7fa046534e944193cc47b795b9396a7fcf411d9f", "patch": "@@ -7,7 +7,7 @@ extern \"C\" {\n const extern fn bar() {\n     unsafe {\n         regular_in_block();\n-        //~^ ERROR: cannot call functions with `\"C\"` abi in `min_const_fn`\n+        //~^ ERROR: can only call other `const fn` within a `const fn`\n     }\n }\n \n@@ -16,7 +16,7 @@ extern fn regular() {}\n const extern fn foo() {\n     unsafe {\n         regular();\n-        //~^ ERROR: cannot call functions with `\"C\"` abi in `min_const_fn`\n+        //~^ ERROR: can only call other `const fn` within a `const fn`\n     }\n }\n "}, {"sha": "eed279ecf75034b036bad7e456de753d049c74fb", "filename": "src/test/ui/consts/const-extern-fn/const-extern-fn-call-extern-fn.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fa046534e944193cc47b795b9396a7fcf411d9f/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-call-extern-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fa046534e944193cc47b795b9396a7fcf411d9f/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-call-extern-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-call-extern-fn.stderr?ref=7fa046534e944193cc47b795b9396a7fcf411d9f", "patch": "@@ -1,4 +1,4 @@\n-error[E0723]: cannot call functions with `\"C\"` abi in `min_const_fn`\n+error[E0723]: can only call other `const fn` within a `const fn`, but `const regular_in_block` is not stable as `const fn`\n   --> $DIR/const-extern-fn-call-extern-fn.rs:9:9\n    |\n LL |         regular_in_block();\n@@ -7,7 +7,7 @@ LL |         regular_in_block();\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n    = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n-error[E0723]: cannot call functions with `\"C\"` abi in `min_const_fn`\n+error[E0723]: can only call other `const fn` within a `const fn`, but `const regular` is not stable as `const fn`\n   --> $DIR/const-extern-fn-call-extern-fn.rs:18:9\n    |\n LL |         regular();"}, {"sha": "da532643d9457630088faef894324e6038542b11", "filename": "src/test/ui/feature-gates/feature-gate-const_transmute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fa046534e944193cc47b795b9396a7fcf411d9f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fa046534e944193cc47b795b9396a7fcf411d9f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_transmute.rs?ref=7fa046534e944193cc47b795b9396a7fcf411d9f", "patch": "@@ -4,6 +4,6 @@ use std::mem;\n struct Foo(u32);\n \n const TRANSMUTED_U32: u32 = unsafe { mem::transmute(Foo(3)) };\n-//~^ ERROR The use of std::mem::transmute() is gated in constants\n+//~^ ERROR `std::intrinsics::transmute` is not yet stable as a const fn\n \n fn main() {}"}, {"sha": "772e8d294781a0cd57fa1901bfb751236a090fde", "filename": "src/test/ui/feature-gates/feature-gate-const_transmute.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fa046534e944193cc47b795b9396a7fcf411d9f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_transmute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fa046534e944193cc47b795b9396a7fcf411d9f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_transmute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_transmute.stderr?ref=7fa046534e944193cc47b795b9396a7fcf411d9f", "patch": "@@ -1,12 +1,10 @@\n-error[E0658]: The use of std::mem::transmute() is gated in constants\n+error: `std::intrinsics::transmute` is not yet stable as a const fn\n   --> $DIR/feature-gate-const_transmute.rs:6:38\n    |\n LL | const TRANSMUTED_U32: u32 = unsafe { mem::transmute(Foo(3)) };\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/53605\n    = help: add `#![feature(const_transmute)]` to the crate attributes to enable\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0658`."}]}