{"sha": "51ea260ee7ee896701ef7296d7f63e7ef455b383", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxZWEyNjBlZTdlZTg5NjcwMWVmNzI5NmQ3ZjYzZTdlZjQ1NWIzODM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-02-09T00:39:14Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-03-15T21:13:40Z"}, "message": "rustc: don't resolve Instances which would produce malformed shims.", "tree": {"sha": "34b40c1331ed0025df47b915d55fead5e329c23b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34b40c1331ed0025df47b915d55fead5e329c23b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51ea260ee7ee896701ef7296d7f63e7ef455b383", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51ea260ee7ee896701ef7296d7f63e7ef455b383", "html_url": "https://github.com/rust-lang/rust/commit/51ea260ee7ee896701ef7296d7f63e7ef455b383", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51ea260ee7ee896701ef7296d7f63e7ef455b383/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0f5df017368dc3f7cb458fc6d5a5e0420e1d2e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0f5df017368dc3f7cb458fc6d5a5e0420e1d2e5", "html_url": "https://github.com/rust-lang/rust/commit/e0f5df017368dc3f7cb458fc6d5a5e0420e1d2e5"}], "stats": {"total": 118, "additions": 86, "deletions": 32}, "files": [{"sha": "07acb7abfdbb8eb2cee66ad191cf13a69e00f858", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/51ea260ee7ee896701ef7296d7f63e7ef455b383/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ea260ee7ee896701ef7296d7f63e7ef455b383/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=51ea260ee7ee896701ef7296d7f63e7ef455b383", "patch": "@@ -39,6 +39,11 @@ pub enum InstanceDef<'tcx> {\n \n     /// `<fn() as FnTrait>::call_*`\n     /// `DefId` is `FnTrait::call_*`.\n+    ///\n+    /// NB: the (`fn` pointer) type must be monomorphic for MIR shims to work.\n+    // FIXME(eddyb) support generating shims for a \"shallow type\",\n+    // e.g. `fn(_, _) -> _` instead of requiring a fully monomorphic\n+    // `fn(Foo, Bar) -> Baz` etc.\n     FnPtrShim(DefId, Ty<'tcx>),\n \n     /// `<dyn Trait as Trait>::fn`, \"direct calls\" of which are implicitly\n@@ -57,9 +62,19 @@ pub enum InstanceDef<'tcx> {\n     /// The `DefId` is for `core::ptr::drop_in_place`.\n     /// The `Option<Ty<'tcx>>` is either `Some(T)`, or `None` for empty drop\n     /// glue.\n+    ///\n+    /// NB: the type must be monomorphic for MIR shims to work.\n+    // FIXME(eddyb) support generating shims for a \"shallow type\",\n+    // e.g. `Foo<_>` or `[_]` instead of requiring a fully monomorphic\n+    // `Foo<Bar>` or `[String]` etc.\n     DropGlue(DefId, Option<Ty<'tcx>>),\n \n     ///`<T as Clone>::clone` shim.\n+    ///\n+    /// NB: the type must be monomorphic for MIR shims to work.\n+    // FIXME(eddyb) support generating shims for a \"shallow type\",\n+    // e.g. `Foo<_>` or `[_]` instead of requiring a fully monomorphic\n+    // `Foo<Bar>` or `[String]` etc.\n     CloneShim(DefId, Ty<'tcx>),\n }\n "}, {"sha": "c1d969a4b51633c37de4e4f6b40ad44490c555a8", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/51ea260ee7ee896701ef7296d7f63e7ef455b383/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ea260ee7ee896701ef7296d7f63e7ef455b383/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=51ea260ee7ee896701ef7296d7f63e7ef455b383", "patch": "@@ -2,13 +2,13 @@ use rustc::mir::*;\n use rustc::ty::layout::VariantIdx;\n use rustc::ty::query::Providers;\n use rustc::ty::subst::{InternalSubsts, Subst};\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n \n use rustc_index::vec::{Idx, IndexVec};\n \n-use rustc_span::{sym, Span};\n+use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n \n use std::fmt;\n@@ -39,6 +39,11 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx\n             None,\n         ),\n         ty::InstanceDef::FnPtrShim(def_id, ty) => {\n+            // FIXME(eddyb) support generating shims for a \"shallow type\",\n+            // e.g. `Foo<_>` or `[_]` instead of requiring a fully monomorphic\n+            // `Foo<Bar>` or `[String]` etc.\n+            assert!(!ty.needs_subst());\n+\n             let trait_ = tcx.trait_of_item(def_id).unwrap();\n             let adjustment = match tcx.fn_trait_kind_from_lang_item(trait_) {\n                 Some(ty::ClosureKind::FnOnce) => Adjustment::Identity,\n@@ -81,17 +86,21 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx\n                 None,\n             )\n         }\n-        ty::InstanceDef::DropGlue(def_id, ty) => build_drop_shim(tcx, def_id, ty),\n+        ty::InstanceDef::DropGlue(def_id, ty) => {\n+            // FIXME(eddyb) support generating shims for a \"shallow type\",\n+            // e.g. `Foo<_>` or `[_]` instead of requiring a fully monomorphic\n+            // `Foo<Bar>` or `[String]` etc.\n+            assert!(!ty.needs_subst());\n+\n+            build_drop_shim(tcx, def_id, ty)\n+        }\n         ty::InstanceDef::CloneShim(def_id, ty) => {\n-            let name = tcx.item_name(def_id);\n-            if name == sym::clone {\n-                build_clone_shim(tcx, def_id, ty)\n-            } else if name == sym::clone_from {\n-                debug!(\"make_shim({:?}: using default trait implementation\", instance);\n-                return tcx.optimized_mir(def_id);\n-            } else {\n-                bug!(\"builtin clone shim {:?} not supported\", instance)\n-            }\n+            // FIXME(eddyb) support generating shims for a \"shallow type\",\n+            // e.g. `Foo<_>` or `[_]` instead of requiring a fully monomorphic\n+            // `Foo<Bar>` or `[String]` etc.\n+            assert!(!ty.needs_subst());\n+\n+            build_clone_shim(tcx, def_id, ty)\n         }\n         ty::InstanceDef::Virtual(..) => {\n             bug!(\"InstanceDef::Virtual ({:?}) is for direct calls only\", instance)"}, {"sha": "a5abe7b6413cc23ceb6684237eeb731fbeb4b4ae", "filename": "src/librustc_ty/instance.rs", "status": "modified", "additions": 50, "deletions": 20, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/51ea260ee7ee896701ef7296d7f63e7ef455b383/src%2Flibrustc_ty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ea260ee7ee896701ef7296d7f63e7ef455b383/src%2Flibrustc_ty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Finstance.rs?ref=51ea260ee7ee896701ef7296d7f63e7ef455b383", "patch": "@@ -1,6 +1,7 @@\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Instance, TyCtxt, TypeFoldable};\n use rustc_hir::def_id::DefId;\n+use rustc_span::sym;\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits;\n \n@@ -31,21 +32,26 @@ pub fn resolve_instance<'tcx>(\n                 debug!(\" => intrinsic\");\n                 ty::InstanceDef::Intrinsic(def_id)\n             }\n-            _ => {\n-                if Some(def_id) == tcx.lang_items().drop_in_place_fn() {\n-                    let ty = substs.type_at(0);\n-                    if ty.needs_drop(tcx, param_env.with_reveal_all()) {\n-                        debug!(\" => nontrivial drop glue\");\n-                        ty::InstanceDef::DropGlue(def_id, Some(ty))\n-                    } else {\n-                        debug!(\" => trivial drop glue\");\n-                        ty::InstanceDef::DropGlue(def_id, None)\n+            ty::FnDef(def_id, substs) if Some(def_id) == tcx.lang_items().drop_in_place_fn() => {\n+                let ty = substs.type_at(0);\n+\n+                if ty.needs_drop(tcx, param_env) {\n+                    // `DropGlue` requires a monomorphic aka concrete type.\n+                    if ty.needs_subst() {\n+                        return None;\n                     }\n+\n+                    debug!(\" => nontrivial drop glue\");\n+                    ty::InstanceDef::DropGlue(def_id, Some(ty))\n                 } else {\n-                    debug!(\" => free item\");\n-                    ty::InstanceDef::Item(def_id)\n+                    debug!(\" => trivial drop glue\");\n+                    ty::InstanceDef::DropGlue(def_id, None)\n                 }\n             }\n+            _ => {\n+                debug!(\" => free item\");\n+                ty::InstanceDef::Item(def_id)\n+            }\n         };\n         Some(Instance { def, substs })\n     };\n@@ -113,20 +119,44 @@ fn resolve_associated_item<'tcx>(\n                 trait_closure_kind,\n             ))\n         }\n-        traits::VtableFnPointer(ref data) => Some(Instance {\n-            def: ty::InstanceDef::FnPtrShim(trait_item.def_id, data.fn_ty),\n-            substs: rcvr_substs,\n-        }),\n+        traits::VtableFnPointer(ref data) => {\n+            // `FnPtrShim` requires a monomorphic aka concrete type.\n+            if data.fn_ty.needs_subst() {\n+                return None;\n+            }\n+\n+            Some(Instance {\n+                def: ty::InstanceDef::FnPtrShim(trait_item.def_id, data.fn_ty),\n+                substs: rcvr_substs,\n+            })\n+        }\n         traits::VtableObject(ref data) => {\n             let index = traits::get_vtable_index_of_object_method(tcx, data, def_id);\n             Some(Instance { def: ty::InstanceDef::Virtual(def_id, index), substs: rcvr_substs })\n         }\n         traits::VtableBuiltin(..) => {\n-            if tcx.lang_items().clone_trait().is_some() {\n-                Some(Instance {\n-                    def: ty::InstanceDef::CloneShim(def_id, trait_ref.self_ty()),\n-                    substs: rcvr_substs,\n-                })\n+            if Some(trait_ref.def_id) == tcx.lang_items().clone_trait() {\n+                // FIXME(eddyb) use lang items for methods instead of names.\n+                let name = tcx.item_name(def_id);\n+                if name == sym::clone {\n+                    let self_ty = trait_ref.self_ty();\n+\n+                    // `CloneShim` requires a monomorphic aka concrete type.\n+                    if self_ty.needs_subst() {\n+                        return None;\n+                    }\n+\n+                    Some(Instance {\n+                        def: ty::InstanceDef::CloneShim(def_id, self_ty),\n+                        substs: rcvr_substs,\n+                    })\n+                } else {\n+                    assert_eq!(name, sym::clone_from);\n+\n+                    // Use the default `fn clone_from` from `trait Clone`.\n+                    let substs = tcx.erase_regions(&rcvr_substs);\n+                    Some(ty::Instance::new(def_id, substs))\n+                }\n             } else {\n                 None\n             }"}]}