{"sha": "76057dc518a17cc9418401d8c6dc2440bdaad947", "node_id": "C_kwDOAAsO6NoAKDc2MDU3ZGM1MThhMTdjYzk0MTg0MDFkOGM2ZGMyNDQwYmRhYWQ5NDc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-22T20:10:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-22T20:10:48Z"}, "message": "Auto merge of #1891 - ChrisDenton:win-args, r=RalfJung\n\nCorrect Windows argument handling\n\nPreviously the command line string would have been incorrectly constructed if argv[0] contained a doublequote (`\"`) or ended in a trailing backslash (`\\`). This is a very rare edge case because, by convention, argv[0] is the path to the application and Windows file names cannot contain doublequotes.\n\nFixes #1881", "tree": {"sha": "bb52379441a498d382dced5e8d5fe92c09bc3efd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb52379441a498d382dced5e8d5fe92c09bc3efd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76057dc518a17cc9418401d8c6dc2440bdaad947", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76057dc518a17cc9418401d8c6dc2440bdaad947", "html_url": "https://github.com/rust-lang/rust/commit/76057dc518a17cc9418401d8c6dc2440bdaad947", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76057dc518a17cc9418401d8c6dc2440bdaad947/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6cf851f6d43bff1e8ac1421cbf3c6a8d20f89560", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cf851f6d43bff1e8ac1421cbf3c6a8d20f89560", "html_url": "https://github.com/rust-lang/rust/commit/6cf851f6d43bff1e8ac1421cbf3c6a8d20f89560"}, {"sha": "cfd1316e60c901bd61f5ccc1006e32d75f3f7ab2", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfd1316e60c901bd61f5ccc1006e32d75f3f7ab2", "html_url": "https://github.com/rust-lang/rust/commit/cfd1316e60c901bd61f5ccc1006e32d75f3f7ab2"}], "stats": {"total": 115, "additions": 105, "deletions": 10}, "files": [{"sha": "c7ce51a83f4cc17bf00ad284097250b15f2ec0da", "filename": "src/eval.rs", "status": "modified", "additions": 105, "deletions": 10, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/76057dc518a17cc9418401d8c6dc2440bdaad947/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76057dc518a17cc9418401d8c6dc2440bdaad947/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=76057dc518a17cc9418401d8c6dc2440bdaad947", "patch": "@@ -2,6 +2,7 @@\n \n use std::convert::TryFrom;\n use std::ffi::OsStr;\n+use std::iter;\n \n use log::info;\n \n@@ -202,17 +203,8 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n         // Store command line as UTF-16 for Windows `GetCommandLineW`.\n         {\n             // Construct a command string with all the aguments.\n-            let mut cmd = String::new();\n-            for arg in config.args.iter() {\n-                if !cmd.is_empty() {\n-                    cmd.push(' ');\n-                }\n-                cmd.push_str(&*shell_escape::windows::escape(arg.as_str().into()));\n-            }\n-            // Don't forget `0` terminator.\n-            cmd.push(std::char::from_u32(0).unwrap());\n+            let cmd_utf16: Vec<u16> = args_to_utf16_command_string(config.args.iter());\n \n-            let cmd_utf16: Vec<u16> = cmd.encode_utf16().collect();\n             let cmd_type = tcx.mk_array(tcx.types.u16, u64::try_from(cmd_utf16.len()).unwrap());\n             let cmd_place =\n                 ecx.allocate(ecx.layout_of(cmd_type)?, MiriMemoryKind::Machine.into())?;\n@@ -353,3 +345,106 @@ pub fn eval_entry<'tcx>(\n         Err(e) => report_error(&ecx, e),\n     }\n }\n+\n+/// Turns an array of arguments into a Windows command line string.\n+///\n+/// The string will be UTF-16 encoded and NUL terminated.\n+///\n+/// Panics if the zeroth argument contains the `\"` character because doublequotes\n+/// in argv[0] cannot be encoded using the standard command line parsing rules.\n+///\n+/// Further reading:\n+/// * [Parsing C++ command-line arguments](https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args?view=msvc-160#parsing-c-command-line-arguments)\n+/// * [The C/C++ Parameter Parsing Rules](https://daviddeley.com/autohotkey/parameters/parameters.htm#WINCRULES)\n+fn args_to_utf16_command_string<I, T>(mut args: I) -> Vec<u16>\n+where\n+    I: Iterator<Item = T>,\n+    T: AsRef<str>,\n+{\n+    // Parse argv[0]. Slashes aren't escaped. Literal double quotes are not allowed.\n+    let mut cmd = {\n+        let arg0 = if let Some(arg0) = args.next() {\n+            arg0\n+        } else {\n+            return vec![0];\n+        };\n+        let arg0 = arg0.as_ref();\n+        if arg0.contains('\"') {\n+            panic!(\"argv[0] cannot contain a doublequote (\\\") character\");\n+        } else {\n+            // Always surround argv[0] with quotes.\n+            let mut s = String::new();\n+            s.push('\"');\n+            s.push_str(arg0);\n+            s.push('\"');\n+            s\n+        }\n+    };\n+\n+    // Build the other arguments.\n+    for arg in args {\n+        let arg = arg.as_ref();\n+        cmd.push(' ');\n+        if arg.is_empty() {\n+            cmd.push_str(\"\\\"\\\"\");\n+        } else if !arg.bytes().any(|c| matches!(c, b'\"' | b'\\t' | b' ')) {\n+            // No quote, tab, or space -- no escaping required.\n+            cmd.push_str(arg);\n+        } else {\n+            // Spaces and tabs are escaped by surrounding them in quotes.\n+            // Quotes are themselves escaped by using backslashes when in a\n+            // quoted block.\n+            // Backslashes only need to be escaped when one or more are directly\n+            // followed by a quote. Otherwise they are taken literally.\n+\n+            cmd.push('\"');\n+            let mut chars = arg.chars().peekable();\n+            loop {\n+                let mut nslashes = 0;\n+                while let Some(&'\\\\') = chars.peek() {\n+                    chars.next();\n+                    nslashes += 1;\n+                }\n+\n+                match chars.next() {\n+                    Some('\"') => {\n+                        cmd.extend(iter::repeat('\\\\').take(nslashes * 2 + 1));\n+                        cmd.push('\"');\n+                    }\n+                    Some(c) => {\n+                        cmd.extend(iter::repeat('\\\\').take(nslashes));\n+                        cmd.push(c);\n+                    }\n+                    None => {\n+                        cmd.extend(iter::repeat('\\\\').take(nslashes * 2));\n+                        break;\n+                    }\n+                }\n+            }\n+            cmd.push('\"');\n+        }\n+    }\n+\n+    if cmd.contains('\\0') {\n+        panic!(\"interior null in command line arguments\");\n+    }\n+    cmd.encode_utf16().chain(iter::once(0)).collect()\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    #[test]\n+    #[should_panic(expected = \"argv[0] cannot contain a doublequote (\\\") character\")]\n+    fn windows_argv0_panic_on_quote() {\n+        args_to_utf16_command_string([\"\\\"\"].iter());\n+    }\n+    #[test]\n+    fn windows_argv0_no_escape() {\n+        // Ensure that a trailing backslash in argv[0] is not escaped.\n+        let cmd = String::from_utf16_lossy(&args_to_utf16_command_string(\n+            [r\"C:\\Program Files\\\", \"arg1\"].iter(),\n+        ));\n+        assert_eq!(cmd.trim_end_matches(\"\\0\"), r#\"\"C:\\Program Files\\\" arg1\"#);\n+    }\n+}"}]}