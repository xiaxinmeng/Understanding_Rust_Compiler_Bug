{"sha": "c151bb4ac5b00ac57be421e7968be6b3a6c6e505", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxNTFiYjRhYzViMDBhYzU3YmU0MjFlNzk2OGJlNmIzYTZjNmU1MDU=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-07-19T13:23:20Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-07-19T13:23:20Z"}, "message": "Sync from rust 8df945c4717ffaf923b57bf30c473df6fc98bc85", "tree": {"sha": "829dbef30ac96767d8b5fe3c1069ac936d339858", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/829dbef30ac96767d8b5fe3c1069ac936d339858"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c151bb4ac5b00ac57be421e7968be6b3a6c6e505", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c151bb4ac5b00ac57be421e7968be6b3a6c6e505", "html_url": "https://github.com/rust-lang/rust/commit/c151bb4ac5b00ac57be421e7968be6b3a6c6e505", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c151bb4ac5b00ac57be421e7968be6b3a6c6e505/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd2f72f398fa6b609a005cea8ebe16e093937936", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd2f72f398fa6b609a005cea8ebe16e093937936", "html_url": "https://github.com/rust-lang/rust/commit/bd2f72f398fa6b609a005cea8ebe16e093937936"}, {"sha": "d7c3c45d685403e090d84956da9e4d1a82ca6666", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7c3c45d685403e090d84956da9e4d1a82ca6666", "html_url": "https://github.com/rust-lang/rust/commit/d7c3c45d685403e090d84956da9e4d1a82ca6666"}], "stats": {"total": 59, "additions": 49, "deletions": 10}, "files": [{"sha": "37ba55d8ef5bad9a78e61efa9d71f258ef7261aa", "filename": "src/constant.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c151bb4ac5b00ac57be421e7968be6b3a6c6e505/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c151bb4ac5b00ac57be421e7968be6b3a6c6e505/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=c151bb4ac5b00ac57be421e7968be6b3a6c6e505", "patch": "@@ -193,20 +193,21 @@ pub(crate) fn codegen_const_value<'tcx>(\n                     place.to_cvalue(fx)\n                 }\n             }\n-            Scalar::Ptr(ptr) => {\n-                let alloc_kind = fx.tcx.get_global_alloc(ptr.alloc_id);\n+            Scalar::Ptr(ptr, _size) => {\n+                let (alloc_id, offset) = ptr.into_parts(); // we know the `offset` is relative\n+                let alloc_kind = fx.tcx.get_global_alloc(alloc_id);\n                 let base_addr = match alloc_kind {\n                     Some(GlobalAlloc::Memory(alloc)) => {\n                         let data_id = data_id_for_alloc_id(\n                             &mut fx.constants_cx,\n                             fx.module,\n-                            ptr.alloc_id,\n+                            alloc_id,\n                             alloc.mutability,\n                         );\n                         let local_data_id =\n                             fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n                         if fx.clif_comments.enabled() {\n-                            fx.add_comment(local_data_id, format!(\"{:?}\", ptr.alloc_id));\n+                            fx.add_comment(local_data_id, format!(\"{:?}\", alloc_id));\n                         }\n                         fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n                     }\n@@ -226,10 +227,10 @@ pub(crate) fn codegen_const_value<'tcx>(\n                         }\n                         fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n                     }\n-                    None => bug!(\"missing allocation {:?}\", ptr.alloc_id),\n+                    None => bug!(\"missing allocation {:?}\", alloc_id),\n                 };\n-                let val = if ptr.offset.bytes() != 0 {\n-                    fx.bcx.ins().iadd_imm(base_addr, i64::try_from(ptr.offset.bytes()).unwrap())\n+                let val = if offset.bytes() != 0 {\n+                    fx.bcx.ins().iadd_imm(base_addr, i64::try_from(offset.bytes()).unwrap())\n                 } else {\n                     base_addr\n                 };\n@@ -406,7 +407,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n         let bytes = alloc.inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len()).to_vec();\n         data_ctx.define(bytes.into_boxed_slice());\n \n-        for &(offset, (_tag, reloc)) in alloc.relocations().iter() {\n+        for &(offset, alloc_id) in alloc.relocations().iter() {\n             let addend = {\n                 let endianness = tcx.data_layout.endian;\n                 let offset = offset.bytes() as usize;\n@@ -417,7 +418,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n                 read_target_uint(endianness, bytes).unwrap()\n             };\n \n-            let reloc_target_alloc = tcx.get_global_alloc(reloc).unwrap();\n+            let reloc_target_alloc = tcx.get_global_alloc(alloc_id).unwrap();\n             let data_id = match reloc_target_alloc {\n                 GlobalAlloc::Function(instance) => {\n                     assert_eq!(addend, 0);\n@@ -427,7 +428,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n                     continue;\n                 }\n                 GlobalAlloc::Memory(target_alloc) => {\n-                    data_id_for_alloc_id(cx, module, reloc, target_alloc.mutability)\n+                    data_id_for_alloc_id(cx, module, alloc_id, target_alloc.mutability)\n                 }\n                 GlobalAlloc::Static(def_id) => {\n                     if tcx.codegen_fn_attrs(def_id).flags.contains(CodegenFnAttrFlags::THREAD_LOCAL)"}, {"sha": "3979886e10cfc17997d1a30362860cdb85adf6c1", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c151bb4ac5b00ac57be421e7968be6b3a6c6e505/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c151bb4ac5b00ac57be421e7968be6b3a6c6e505/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=c151bb4ac5b00ac57be421e7968be6b3a6c6e505", "patch": "@@ -1115,6 +1115,40 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             );\n             ret.write_cvalue(fx, CValue::by_val(res, ret.layout()));\n         };\n+\n+        raw_eq, <T>(v lhs_ref, v rhs_ref) {\n+            fn type_by_size(size: Size) -> Option<Type> {\n+                Type::int(size.bits().try_into().ok()?)\n+            }\n+\n+            let size = fx.layout_of(T).layout.size;\n+            let is_eq_value =\n+                if size == Size::ZERO {\n+                    // No bytes means they're trivially equal\n+                    fx.bcx.ins().iconst(types::I8, 1)\n+                } else if let Some(clty) = type_by_size(size) {\n+                    // Can't use `trusted` for these loads; they could be unaligned.\n+                    let mut flags = MemFlags::new();\n+                    flags.set_notrap();\n+                    let lhs_val = fx.bcx.ins().load(clty, flags, lhs_ref, 0);\n+                    let rhs_val = fx.bcx.ins().load(clty, flags, rhs_ref, 0);\n+                    let eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_val, rhs_val);\n+                    fx.bcx.ins().bint(types::I8, eq)\n+                } else {\n+                    // Just call `memcmp` (like slices do in core) when the\n+                    // size is too large or it's not a power-of-two.\n+                    let ptr_ty = pointer_ty(fx.tcx);\n+                    let signed_bytes = i64::try_from(size.bytes()).unwrap();\n+                    let bytes_val = fx.bcx.ins().iconst(ptr_ty, signed_bytes);\n+                    let params = vec![AbiParam::new(ptr_ty); 3];\n+                    let returns = vec![AbiParam::new(types::I32)];\n+                    let args = &[lhs_ref, rhs_ref, bytes_val];\n+                    let cmp = fx.lib_call(\"memcmp\", params, returns, args)[0];\n+                    let eq = fx.bcx.ins().icmp_imm(IntCC::Equal, cmp, 0);\n+                    fx.bcx.ins().bint(types::I8, eq)\n+                };\n+            ret.write_cvalue(fx, CValue::by_val(is_eq_value, ret.layout()));\n+        };\n     }\n \n     if let Some((_, dest)) = destination {"}, {"sha": "ae8ccc626b47089e09a8f75672c9893659ef21fa", "filename": "src/value_and_place.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c151bb4ac5b00ac57be421e7968be6b3a6c6e505/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c151bb4ac5b00ac57be421e7968be6b3a6c6e505/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=c151bb4ac5b00ac57be421e7968be6b3a6c6e505", "patch": "@@ -453,6 +453,10 @@ impl<'tcx> CPlace<'tcx> {\n                     ptr.store(fx, data, MemFlags::trusted());\n                     ptr.load(fx, dst_ty, MemFlags::trusted())\n                 }\n+\n+                // `CValue`s should never contain SSA-only types, so if you ended\n+                // up here having seen an error like `B1 -> I8`, then before\n+                // calling `write_cvalue` you need to add a `bint` instruction.\n                 _ => unreachable!(\"write_cvalue_transmute: {:?} -> {:?}\", src_ty, dst_ty),\n             };\n             //fx.bcx.set_val_label(data, cranelift_codegen::ir::ValueLabel::new(var.index()));"}]}