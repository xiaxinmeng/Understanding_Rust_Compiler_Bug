{"sha": "dc50a633f3260a3aeb79a4ca9800587be7f732e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjNTBhNjMzZjMyNjBhM2FlYjc5YTRjYTk4MDA1ODdiZTdmNzMyZTc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2019-07-19T19:02:34Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2019-07-25T18:17:07Z"}, "message": "std: Use native `#[thread_local]` TLS on wasm\n\nThis commit moves `thread_local!` on WebAssembly targets to using the\n`#[thread_local]` attribute in LLVM. This was recently implemented\nupstream and is [in the process of being documented][dox]. This change\nonly takes affect if modules are compiled with `+atomics` which is\ncurrently unstable and a pretty esoteric method of compiling wasm\nartifacts.\n\nThis \"new power\" of the wasm toolchain means that the old\n`wasm-bindgen-threads` feature of the standard library can be removed\nsince it should now be possible to create a fully functioning threaded\nwasm module without intrusively dealing with libstd symbols or\nintrinsics. Yay!\n\n[dox]: https://github.com/WebAssembly/tool-conventions/pull/116", "tree": {"sha": "ca574585e42fc3c93a931f306e19fa2f95a3b7f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca574585e42fc3c93a931f306e19fa2f95a3b7f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc50a633f3260a3aeb79a4ca9800587be7f732e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc50a633f3260a3aeb79a4ca9800587be7f732e7", "html_url": "https://github.com/rust-lang/rust/commit/dc50a633f3260a3aeb79a4ca9800587be7f732e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc50a633f3260a3aeb79a4ca9800587be7f732e7/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a120caf8b4f8e77168378e6ad2b85d077baaa27b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a120caf8b4f8e77168378e6ad2b85d077baaa27b", "html_url": "https://github.com/rust-lang/rust/commit/a120caf8b4f8e77168378e6ad2b85d077baaa27b"}], "stats": {"total": 207, "additions": 72, "deletions": 135}, "files": [{"sha": "5aa0e20d8308debfc29f38f0102e090a0b9e19d0", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dc50a633f3260a3aeb79a4ca9800587be7f732e7/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc50a633f3260a3aeb79a4ca9800587be7f732e7/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=dc50a633f3260a3aeb79a4ca9800587be7f732e7", "patch": "@@ -904,6 +904,9 @@ impl<'a> WasmLd<'a> {\n         //   linker will synthesize this function, and so we need to make sure\n         //   that our usage of `--export` below won't accidentally cause this\n         //   function to get deleted.\n+        //\n+        // * `--export=*tls*` - when `#[thread_local]` symbols are used these\n+        //   symbols are how the TLS segments are initialized and configured.\n         let atomics = sess.opts.cg.target_feature.contains(\"+atomics\") ||\n             sess.target.target.options.features.contains(\"+atomics\");\n         if atomics {\n@@ -912,6 +915,10 @@ impl<'a> WasmLd<'a> {\n             cmd.arg(\"--import-memory\");\n             cmd.arg(\"--passive-segments\");\n             cmd.arg(\"--export=__wasm_init_memory\");\n+            cmd.arg(\"--export=__wasm_init_tls\");\n+            cmd.arg(\"--export=__tls_size\");\n+            cmd.arg(\"--export=__tls_align\");\n+            cmd.arg(\"--export=__tls_base\");\n         }\n         WasmLd { cmd, sess, info }\n     }"}, {"sha": "6f00245b009411e738c31a597efa6483ce025d06", "filename": "src/librustc_target/spec/wasm32_base.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc50a633f3260a3aeb79a4ca9800587be7f732e7/src%2Flibrustc_target%2Fspec%2Fwasm32_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc50a633f3260a3aeb79a4ca9800587be7f732e7/src%2Flibrustc_target%2Fspec%2Fwasm32_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fwasm32_base.rs?ref=dc50a633f3260a3aeb79a4ca9800587be7f732e7", "patch": "@@ -132,6 +132,14 @@ pub fn options() -> TargetOptions {\n         // non-relative calls and such later on).\n         relocation_model: \"static\".to_string(),\n \n+        // When the atomics feature is activated then these two keys matter,\n+        // otherwise they're basically ignored by the standard library. In this\n+        // mode, however, the `#[thread_local]` attribute works (i.e.\n+        // `has_elf_tls`) and we need to get it to work by specifying\n+        // `local-exec` as that's all that's implemented in LLVM today for wasm.\n+        has_elf_tls: true,\n+        tls_model: \"local-exec\".to_string(),\n+\n         .. Default::default()\n     }\n }"}, {"sha": "2e0da0409eb09766c9594455fb7a51484ec8ef73", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dc50a633f3260a3aeb79a4ca9800587be7f732e7/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dc50a633f3260a3aeb79a4ca9800587be7f732e7/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=dc50a633f3260a3aeb79a4ca9800587be7f732e7", "patch": "@@ -75,11 +75,6 @@ panic_immediate_abort = [\"core/panic_immediate_abort\"]\n # requires rebuilding the standard library to use it.\n wasm_syscall = []\n \n-# An off-by-default features to enable libstd to assume that wasm-bindgen is in\n-# the environment for hooking up some thread-related information like the\n-# current thread id and accessing/getting the current thread's TCB\n-wasm-bindgen-threads = []\n-\n # Enable std_detect default features for stdarch/crates/std_detect:\n # https://github.com/rust-lang/stdarch/blob/master/crates/std_detect/Cargo.toml\n std_detect_file_io = []"}, {"sha": "f842869e08ee69e0c628a99dccceb7f662e5df38", "filename": "src/libstd/sys/wasi/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc50a633f3260a3aeb79a4ca9800587be7f732e7/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc50a633f3260a3aeb79a4ca9800587be7f732e7/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs?ref=dc50a633f3260a3aeb79a4ca9800587be7f732e7", "patch": "@@ -47,6 +47,8 @@ pub mod stdio;\n pub mod thread;\n #[path = \"../wasm/thread_local.rs\"]\n pub mod thread_local;\n+#[path = \"../wasm/fast_thread_local.rs\"]\n+pub mod fast_thread_local;\n pub mod time;\n pub mod ext;\n "}, {"sha": "ff2198175f0a9682b7c6d6c9773aa9e1e4dbc8e2", "filename": "src/libstd/sys/wasm/fast_thread_local.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dc50a633f3260a3aeb79a4ca9800587be7f732e7/src%2Flibstd%2Fsys%2Fwasm%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc50a633f3260a3aeb79a4ca9800587be7f732e7/src%2Flibstd%2Fsys%2Fwasm%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Ffast_thread_local.rs?ref=dc50a633f3260a3aeb79a4ca9800587be7f732e7", "patch": "@@ -0,0 +1,9 @@\n+#![unstable(feature = \"thread_local_internals\", issue = \"0\")]\n+\n+pub unsafe fn register_dtor(_t: *mut u8, _dtor: unsafe extern fn(*mut u8)) {\n+    // FIXME: right now there is no concept of \"thread exit\", but this is likely\n+    // going to show up at some point in the form of an exported symbol that the\n+    // wasm runtime is oging to be expected to call. For now we basically just\n+    // ignore the arguments, but if such a function starts to exist it will\n+    // likely look like the OSX implementation in `unix/fast_thread_local.rs`\n+}"}, {"sha": "56cbafcfdb8a2af1196c8d38ae24c61ce695d646", "filename": "src/libstd/sys/wasm/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dc50a633f3260a3aeb79a4ca9800587be7f732e7/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc50a633f3260a3aeb79a4ca9800587be7f732e7/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs?ref=dc50a633f3260a3aeb79a4ca9800587be7f732e7", "patch": "@@ -37,6 +37,8 @@ pub mod stack_overflow;\n pub mod thread;\n pub mod time;\n pub mod stdio;\n+pub mod thread_local;\n+pub mod fast_thread_local;\n \n pub use crate::sys_common::os_str_bytes as os_str;\n \n@@ -48,13 +50,10 @@ cfg_if::cfg_if! {\n         pub mod mutex;\n         #[path = \"rwlock_atomics.rs\"]\n         pub mod rwlock;\n-        #[path = \"thread_local_atomics.rs\"]\n-        pub mod thread_local;\n     } else {\n         pub mod condvar;\n         pub mod mutex;\n         pub mod rwlock;\n-        pub mod thread_local;\n     }\n }\n "}, {"sha": "d06965f3278498eda3a5924a0cb3e60251855a3e", "filename": "src/libstd/sys/wasm/thread.rs", "status": "modified", "additions": 34, "deletions": 42, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/dc50a633f3260a3aeb79a4ca9800587be7f732e7/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc50a633f3260a3aeb79a4ca9800587be7f732e7/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs?ref=dc50a633f3260a3aeb79a4ca9800587be7f732e7", "patch": "@@ -59,48 +59,40 @@ pub mod guard {\n     pub unsafe fn init() -> Option<Guard> { None }\n }\n \n-cfg_if::cfg_if! {\n-    if #[cfg(all(target_feature = \"atomics\", feature = \"wasm-bindgen-threads\"))] {\n-        #[link(wasm_import_module = \"__wbindgen_thread_xform__\")]\n-        extern {\n-            fn __wbindgen_current_id() -> u32;\n-            fn __wbindgen_tcb_get() -> u32;\n-            fn __wbindgen_tcb_set(ptr: u32);\n+// This is only used by atomics primitives when the `atomics` feature is\n+// enabled. In that mode we currently just use our own thread-local to store our\n+// current thread's ID, and then we lazily initialize it to something allocated\n+// from a global counter.\n+#[cfg(target_feature = \"atomics\")]\n+pub fn my_id() -> u32 {\n+    use crate::sync::atomic::{AtomicU32, Ordering::SeqCst};\n+\n+    static NEXT_ID: AtomicU32 = AtomicU32::new(0);\n+\n+    #[thread_local]\n+    static mut MY_ID: u32 = 0;\n+\n+    unsafe {\n+        // If our thread ID isn't set yet then we need to allocate one. Do so\n+        // with with a simple \"atomically add to a global counter\" strategy.\n+        // This strategy doesn't handled what happens when the counter\n+        // overflows, however, so just abort everything once the counter\n+        // overflows and eventually we could have some sort of recycling scheme\n+        // (or maybe this is all totally irrelevant by that point!). In any case\n+        // though we're using a CAS loop instead of a `fetch_add` to ensure that\n+        // the global counter never overflows.\n+        if MY_ID == 0 {\n+            let mut cur = NEXT_ID.load(SeqCst);\n+            MY_ID = loop {\n+                let next = cur.checked_add(1).unwrap_or_else(|| {\n+                    crate::arch::wasm32::unreachable()\n+                });\n+                match NEXT_ID.compare_exchange(cur, next, SeqCst, SeqCst) {\n+                    Ok(_) => break next,\n+                    Err(i) => cur = i,\n+                }\n+            };\n         }\n-        pub fn my_id() -> u32 {\n-            unsafe { __wbindgen_current_id() }\n-        }\n-\n-        // These are currently only ever used in `thread_local_atomics.rs`, if\n-        // you'd like to use them be sure to update that and make sure everyone\n-        // agrees what's what.\n-        pub fn tcb_get() -> *mut u8 {\n-            use crate::mem;\n-            assert_eq!(mem::size_of::<*mut u8>(), mem::size_of::<u32>());\n-            unsafe { __wbindgen_tcb_get() as *mut u8 }\n-        }\n-\n-        pub fn tcb_set(ptr: *mut u8) {\n-            unsafe { __wbindgen_tcb_set(ptr as u32); }\n-        }\n-\n-        // FIXME: still need something for hooking exiting a thread to free\n-        // data...\n-\n-    } else if #[cfg(target_feature = \"atomics\")] {\n-        pub fn my_id() -> u32 {\n-            panic!(\"thread ids not implemented on wasm with atomics yet\")\n-        }\n-\n-        pub fn tcb_get() -> *mut u8 {\n-            panic!(\"thread local data not implemented on wasm with atomics yet\")\n-        }\n-\n-        pub fn tcb_set(_ptr: *mut u8) {\n-            panic!(\"thread local data not implemented on wasm with atomics yet\")\n-        }\n-    } else {\n-        // stubbed out because no functions actually access these intrinsics\n-        // unless atomics are enabled\n+        MY_ID\n     }\n }"}, {"sha": "8a0ca6f3d25a8f47cf88ab90c19d9a04a2d42037", "filename": "src/libstd/sys/wasm/thread_local.rs", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/dc50a633f3260a3aeb79a4ca9800587be7f732e7/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc50a633f3260a3aeb79a4ca9800587be7f732e7/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local.rs?ref=dc50a633f3260a3aeb79a4ca9800587be7f732e7", "patch": "@@ -1,40 +1,26 @@\n-use crate::boxed::Box;\n-use crate::ptr;\n-\n pub type Key = usize;\n \n-struct Allocated {\n-    value: *mut u8,\n-    dtor: Option<unsafe extern fn(*mut u8)>,\n-}\n-\n #[inline]\n-pub unsafe fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n-    Box::into_raw(Box::new(Allocated {\n-        value: ptr::null_mut(),\n-        dtor,\n-    })) as usize\n+pub unsafe fn create(_dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n+    panic!(\"should not be used on the wasm target\");\n }\n \n #[inline]\n-pub unsafe fn set(key: Key, value: *mut u8) {\n-    (*(key as *mut Allocated)).value = value;\n+pub unsafe fn set(_key: Key, _value: *mut u8) {\n+    panic!(\"should not be used on the wasm target\");\n }\n \n #[inline]\n-pub unsafe fn get(key: Key) -> *mut u8 {\n-    (*(key as *mut Allocated)).value\n+pub unsafe fn get(_key: Key) -> *mut u8 {\n+    panic!(\"should not be used on the wasm target\");\n }\n \n #[inline]\n-pub unsafe fn destroy(key: Key) {\n-    let key = Box::from_raw(key as *mut Allocated);\n-    if let Some(f) = key.dtor {\n-        f(key.value);\n-    }\n+pub unsafe fn destroy(_key: Key) {\n+    panic!(\"should not be used on the wasm target\");\n }\n \n #[inline]\n pub fn requires_synchronized_create() -> bool {\n-    false\n+    panic!(\"should not be used on the wasm target\");\n }"}, {"sha": "3dc0bb24553fd644450b36c29a148d26a30fdbad", "filename": "src/libstd/sys/wasm/thread_local_atomics.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/a120caf8b4f8e77168378e6ad2b85d077baaa27b/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local_atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a120caf8b4f8e77168378e6ad2b85d077baaa27b/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local_atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local_atomics.rs?ref=a120caf8b4f8e77168378e6ad2b85d077baaa27b", "patch": "@@ -1,61 +0,0 @@\n-use crate::sys::thread;\n-use crate::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n-\n-const MAX_KEYS: usize = 128;\n-static NEXT_KEY: AtomicUsize = AtomicUsize::new(0);\n-\n-struct ThreadControlBlock {\n-    keys: [*mut u8; MAX_KEYS],\n-}\n-\n-impl ThreadControlBlock {\n-    fn new() -> ThreadControlBlock {\n-        ThreadControlBlock {\n-            keys: [core::ptr::null_mut(); MAX_KEYS],\n-        }\n-    }\n-\n-    fn get() -> *mut ThreadControlBlock {\n-        let ptr = thread::tcb_get();\n-        if !ptr.is_null() {\n-            return ptr as *mut ThreadControlBlock\n-        }\n-        let tcb = Box::into_raw(Box::new(ThreadControlBlock::new()));\n-        thread::tcb_set(tcb as *mut u8);\n-        tcb\n-    }\n-}\n-\n-pub type Key = usize;\n-\n-pub unsafe fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n-    drop(dtor); // FIXME: need to figure out how to hook thread exit to run this\n-    let key = NEXT_KEY.fetch_add(1, SeqCst);\n-    if key >= MAX_KEYS {\n-        NEXT_KEY.store(MAX_KEYS, SeqCst);\n-        panic!(\"cannot allocate space for more TLS keys\");\n-    }\n-    // offset by 1 so we never hand out 0. This is currently required by\n-    // `sys_common/thread_local.rs` where it can't cope with keys of value 0\n-    // because it messes up the atomic management.\n-    return key + 1\n-}\n-\n-pub unsafe fn set(key: Key, value: *mut u8) {\n-    (*ThreadControlBlock::get()).keys[key - 1] = value;\n-}\n-\n-pub unsafe fn get(key: Key) -> *mut u8 {\n-    (*ThreadControlBlock::get()).keys[key - 1]\n-}\n-\n-pub unsafe fn destroy(_key: Key) {\n-    // FIXME: should implement this somehow, this isn't typically called but it\n-    // can be called if two threads race to initialize a TLS slot and one ends\n-    // up not being needed.\n-}\n-\n-#[inline]\n-pub fn requires_synchronized_create() -> bool {\n-    false\n-}"}, {"sha": "9b64ca5b7e1e3583978f9ac8af6d93b220a13d90", "filename": "src/llvm-project", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm-project?ref=dc50a633f3260a3aeb79a4ca9800587be7f732e7", "patch": "@@ -1 +1 @@\n-Subproject commit f6446fa8e9629ffb1861303f17930c3aa83ef660\n+Subproject commit 9b64ca5b7e1e3583978f9ac8af6d93b220a13d90"}]}