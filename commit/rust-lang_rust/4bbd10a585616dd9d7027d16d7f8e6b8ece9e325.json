{"sha": "4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiYmQxMGE1ODU2MTZkZDlkNzAyN2QxNmQ3ZjhlNmI4ZWNlOWUzMjU=", "commit": {"author": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2019-09-27T15:16:06Z"}, "committer": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2019-09-27T15:21:20Z"}, "message": "Rustup to rust-lang/rust#64813", "tree": {"sha": "32011de1081ec6781c25f56e7cfb9b2e3302d11d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32011de1081ec6781c25f56e7cfb9b2e3302d11d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZxoS6lESXlRGMHWcaTCGhp1QZjcFAl2OKPAACgkQaTCGhp1Q\nZjf/Ow//Y5/tz2kDFyZ5vZlCk49PfpwgLPfFrtaMITkTzaVmae2eM9qKz4JelvNf\nIwHddbcF/lu11BUw3qWakC0MlnMf7jt/BKJMORPVWNCZNl8BHEAuE/r7UddLRo8h\nB/84x50JCBaUIsuH+6Q+9r0n+eqijdTW+Y7FQvAdHlw82xg1IWHlJYYmSSEe1mfv\n0bopfq74xoDThSLUALnuVUMTL51cs4dZbUZ7HN7Vlg7WEsyfDzJT+Y9La/K8MikN\nhPTeBXYTG1H5t/cLpfQ8bByPQU/vZbUNR/qcwNQOP7L4E5O5Cy3RUJ0QHDWJH5qp\nMPpxYK9CKQL2Sr+ltwE51whZ9pot1jwRTRkN7KnXNhmFzAprmesZWSpneMIKL1hK\n9PvFZBgTWid/ot99Ohp37HZcAoHw/uWFXtQogFLpHOBYfxJYij3GRY+GRpTiB3QY\nHguDkwmo6nzv446PkjgBPe436DRLP0V5Fu3FEuRIJ/mUaKq0sCBgpni+zXQLec6G\nzJxHFvDIgo7GkuEsW5ukZC1qDzob76/HaskRunhy7H1s2OQFdScr2wDY9g5CUFqX\nvGmNTn5d/NJfr3m7vD4p2dNI9CYeRE7jMojN58EyoRlYvMpMEsYab4POu9gUr4QN\nORqWWckGJiFx6bgj/XFeSDaXaL2ggVBcbEx5BqR+eBZUx7vZSQo=\n=pEqI\n-----END PGP SIGNATURE-----", "payload": "tree 32011de1081ec6781c25f56e7cfb9b2e3302d11d\nparent bca08a65df9635482c21c66dfc9af79abd4b4946\nauthor flip1995 <hello@philkrones.com> 1569597366 +0200\ncommitter flip1995 <hello@philkrones.com> 1569597680 +0200\n\nRustup to rust-lang/rust#64813\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "html_url": "https://github.com/rust-lang/rust/commit/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bca08a65df9635482c21c66dfc9af79abd4b4946", "url": "https://api.github.com/repos/rust-lang/rust/commits/bca08a65df9635482c21c66dfc9af79abd4b4946", "html_url": "https://github.com/rust-lang/rust/commit/bca08a65df9635482c21c66dfc9af79abd4b4946"}], "stats": {"total": 1820, "additions": 910, "deletions": 910}, "files": [{"sha": "7578b5fffe1ae555427124c54702ea288a583550", "filename": "clippy_lints/src/approx_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fapprox_const.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -54,7 +54,7 @@ declare_lint_pass!(ApproxConstant => [APPROX_CONSTANT]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ApproxConstant {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprKind::Lit(lit) = &e.node {\n+        if let ExprKind::Lit(lit) = &e.kind {\n             check_lit(cx, &lit.node, e);\n         }\n     }"}, {"sha": "1cca897e73900b9eaa11fde39574f522d2585387", "filename": "clippy_lints/src/arithmetic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farithmetic.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -63,7 +63,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Arithmetic {\n                 return;\n             }\n         }\n-        match &expr.node {\n+        match &expr.kind {\n             hir::ExprKind::Binary(op, l, r) | hir::ExprKind::AssignOp(op, l, r) => {\n                 match op.node {\n                     hir::BinOpKind::And"}, {"sha": "d1be15ba16636c5192eed3cd47aaa3b0c353f956", "filename": "clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -32,7 +32,7 @@ declare_lint_pass!(AssertionsOnConstants => [ASSERTIONS_ON_CONSTANTS]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssertionsOnConstants {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         let lint_assert_cb = |is_debug_assert: bool| {\n-            if let ExprKind::Unary(_, ref lit) = e.node {\n+            if let ExprKind::Unary(_, ref lit) = e.kind {\n                 if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.tables, lit) {\n                     if is_true {\n                         span_help_and_lint("}, {"sha": "a16c4575e703707b2a0ea4cb626c11879f5ff8e7", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -59,9 +59,9 @@ declare_lint_pass!(AssignOps => [ASSIGN_OP_PATTERN, MISREFACTORED_ASSIGN_OP]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n     #[allow(clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n-        match &expr.node {\n+        match &expr.kind {\n             hir::ExprKind::AssignOp(op, lhs, rhs) => {\n-                if let hir::ExprKind::Binary(binop, l, r) = &rhs.node {\n+                if let hir::ExprKind::Binary(binop, l, r) = &rhs.kind {\n                     if op.node != binop.node {\n                         return;\n                     }\n@@ -76,7 +76,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                 }\n             },\n             hir::ExprKind::Assign(assignee, e) => {\n-                if let hir::ExprKind::Binary(op, l, r) = &e.node {\n+                if let hir::ExprKind::Binary(op, l, r) = &e.kind {\n                     #[allow(clippy::cognitive_complexity)]\n                     let lint = |assignee: &hir::Expr, rhs: &hir::Expr| {\n                         let ty = cx.tables.expr_ty(assignee);"}, {"sha": "2324693cdc984b8962a58d8f6ecc0a6f4bd8e4d6", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -212,7 +212,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Attributes {\n                 for item in items {\n                     if_chain! {\n                         if let NestedMetaItem::MetaItem(mi) = &item;\n-                        if let MetaItemKind::NameValue(lit) = &mi.node;\n+                        if let MetaItemKind::NameValue(lit) = &mi.kind;\n                         if mi.check_name(sym!(since));\n                         then {\n                             check_semver(cx, item.span(), lit);\n@@ -227,7 +227,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Attributes {\n         if is_relevant_item(cx, item) {\n             check_attrs(cx, item.span, item.ident.name, &item.attrs)\n         }\n-        match item.node {\n+        match item.kind {\n             ItemKind::ExternCrate(..) | ItemKind::Use(..) => {\n                 let skip_unused_imports = item.attrs.iter().any(|attr| attr.check_name(sym!(macro_use)));\n \n@@ -242,7 +242,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Attributes {\n                                     // whitelist `unused_imports`, `deprecated` and `unreachable_pub` for `use` items\n                                     // and `unused_imports` for `extern crate` items with `macro_use`\n                                     for lint in lint_list {\n-                                        match item.node {\n+                                        match item.kind {\n                                             ItemKind::Use(..) => {\n                                                 if is_word(lint, sym!(unused_imports))\n                                                     || is_word(lint, sym!(deprecated))\n@@ -355,22 +355,22 @@ fn check_clippy_lint_names(cx: &LateContext<'_, '_>, items: &[NestedMetaItem]) {\n }\n \n fn is_relevant_item(cx: &LateContext<'_, '_>, item: &Item) -> bool {\n-    if let ItemKind::Fn(_, _, _, eid) = item.node {\n+    if let ItemKind::Fn(_, _, _, eid) = item.kind {\n         is_relevant_expr(cx, cx.tcx.body_tables(eid), &cx.tcx.hir().body(eid).value)\n     } else {\n         true\n     }\n }\n \n fn is_relevant_impl(cx: &LateContext<'_, '_>, item: &ImplItem) -> bool {\n-    match item.node {\n+    match item.kind {\n         ImplItemKind::Method(_, eid) => is_relevant_expr(cx, cx.tcx.body_tables(eid), &cx.tcx.hir().body(eid).value),\n         _ => false,\n     }\n }\n \n fn is_relevant_trait(cx: &LateContext<'_, '_>, item: &TraitItem) -> bool {\n-    match item.node {\n+    match item.kind {\n         TraitItemKind::Method(_, TraitMethod::Required(_)) => true,\n         TraitItemKind::Method(_, TraitMethod::Provided(eid)) => {\n             is_relevant_expr(cx, cx.tcx.body_tables(eid), &cx.tcx.hir().body(eid).value)\n@@ -381,7 +381,7 @@ fn is_relevant_trait(cx: &LateContext<'_, '_>, item: &TraitItem) -> bool {\n \n fn is_relevant_block(cx: &LateContext<'_, '_>, tables: &ty::TypeckTables<'_>, block: &Block) -> bool {\n     if let Some(stmt) = block.stmts.first() {\n-        match &stmt.node {\n+        match &stmt.kind {\n             StmtKind::Local(_) => true,\n             StmtKind::Expr(expr) | StmtKind::Semi(expr) => is_relevant_expr(cx, tables, expr),\n             _ => false,\n@@ -392,12 +392,12 @@ fn is_relevant_block(cx: &LateContext<'_, '_>, tables: &ty::TypeckTables<'_>, bl\n }\n \n fn is_relevant_expr(cx: &LateContext<'_, '_>, tables: &ty::TypeckTables<'_>, expr: &Expr) -> bool {\n-    match &expr.node {\n+    match &expr.kind {\n         ExprKind::Block(block, _) => is_relevant_block(cx, tables, block),\n         ExprKind::Ret(Some(e)) => is_relevant_expr(cx, tables, e),\n         ExprKind::Ret(None) | ExprKind::Break(_, None) => false,\n         ExprKind::Call(path_expr, _) => {\n-            if let ExprKind::Path(qpath) = &path_expr.node {\n+            if let ExprKind::Path(qpath) = &path_expr.kind {\n                 if let Some(fun_id) = tables.qpath_res(qpath, path_expr.hir_id).opt_def_id() {\n                     !match_def_path(cx, fun_id, &paths::BEGIN_PANIC)\n                 } else {\n@@ -464,7 +464,7 @@ fn check_attrs(cx: &LateContext<'_, '_>, span: Span, name: Name, attrs: &[Attrib\n }\n \n fn check_semver(cx: &LateContext<'_, '_>, span: Span, lit: &Lit) {\n-    if let LitKind::Str(is, _) = lit.node {\n+    if let LitKind::Str(is, _) = lit.kind {\n         if Version::parse(&is.as_str()).is_ok() {\n             return;\n         }"}, {"sha": "e27b5269ef44b744d818487b71b884f0bf19295a", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -111,7 +111,7 @@ impl_lint_pass!(BitMask => [BAD_BIT_MASK, INEFFECTIVE_BIT_MASK, VERBOSE_BIT_MASK\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BitMask {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprKind::Binary(cmp, left, right) = &e.node {\n+        if let ExprKind::Binary(cmp, left, right) = &e.kind {\n             if cmp.node.is_comparison() {\n                 if let Some(cmp_opt) = fetch_int_literal(cx, right) {\n                     check_compare(cx, left, cmp.node, cmp_opt, e.span)\n@@ -121,13 +121,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BitMask {\n             }\n         }\n         if_chain! {\n-            if let ExprKind::Binary(op, left, right) = &e.node;\n+            if let ExprKind::Binary(op, left, right) = &e.kind;\n             if BinOpKind::Eq == op.node;\n-            if let ExprKind::Binary(op1, left1, right1) = &left.node;\n+            if let ExprKind::Binary(op1, left1, right1) = &left.kind;\n             if BinOpKind::BitAnd == op1.node;\n-            if let ExprKind::Lit(lit) = &right1.node;\n+            if let ExprKind::Lit(lit) = &right1.kind;\n             if let LitKind::Int(n, _) = lit.node;\n-            if let ExprKind::Lit(lit1) = &right.node;\n+            if let ExprKind::Lit(lit1) = &right.kind;\n             if let LitKind::Int(0, _) = lit1.node;\n             if n.leading_zeros() == n.count_zeros();\n             if n > u128::from(self.verbose_bit_mask_threshold);\n@@ -163,7 +163,7 @@ fn invert_cmp(cmp: BinOpKind) -> BinOpKind {\n }\n \n fn check_compare(cx: &LateContext<'_, '_>, bit_op: &Expr, cmp_op: BinOpKind, cmp_value: u128, span: Span) {\n-    if let ExprKind::Binary(op, left, right) = &bit_op.node {\n+    if let ExprKind::Binary(op, left, right) = &bit_op.kind {\n         if op.node != BinOpKind::BitAnd && op.node != BinOpKind::BitOr {\n             return;\n         }"}, {"sha": "986de32ddaf57313a61adf2caa309b1391c70e84", "filename": "clippy_lints/src/blacklisted_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblacklisted_name.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -37,7 +37,7 @@ impl_lint_pass!(BlacklistedName => [BLACKLISTED_NAME]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlacklistedName {\n     fn check_pat(&mut self, cx: &LateContext<'a, 'tcx>, pat: &'tcx Pat) {\n-        if let PatKind::Binding(.., ident, _) = pat.node {\n+        if let PatKind::Binding(.., ident, _) = pat.kind {\n             if self.blacklist.contains(&ident.name.to_string()) {\n                 span_lint(\n                     cx,"}, {"sha": "4fa7048cdedc3dffc2432f336b6eebb049085483", "filename": "clippy_lints/src/block_in_if_condition.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -51,10 +51,10 @@ struct ExVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for ExVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n-        if let ExprKind::Closure(_, _, eid, _, _) = expr.node {\n+        if let ExprKind::Closure(_, _, eid, _, _) = expr.kind {\n             let body = self.cx.tcx.hir().body(eid);\n             let ex = &body.value;\n-            if matches!(ex.node, ExprKind::Block(_, _)) && !body.value.span.from_expansion() {\n+            if matches!(ex.kind, ExprKind::Block(_, _)) && !body.value.span.from_expansion() {\n                 self.found_block = Some(ex);\n                 return;\n             }\n@@ -76,7 +76,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlockInIfCondition {\n             return;\n         }\n         if let Some((check, then, _)) = higher::if_block(&expr) {\n-            if let ExprKind::Block(block, _) = &check.node {\n+            if let ExprKind::Block(block, _) = &check.kind {\n                 if block.rules == DefaultBlock {\n                     if block.stmts.is_empty() {\n                         if let Some(ex) = &block.expr {"}, {"sha": "4309eaa78797c0c68e7d5bfcaa6577c52b0fff5a", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -81,7 +81,7 @@ struct Hir2Qmm<'a, 'tcx, 'v> {\n impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n     fn extract(&mut self, op: BinOpKind, a: &[&'v Expr], mut v: Vec<Bool>) -> Result<Vec<Bool>, String> {\n         for a in a {\n-            if let ExprKind::Binary(binop, lhs, rhs) = &a.node {\n+            if let ExprKind::Binary(binop, lhs, rhs) = &a.kind {\n                 if binop.node == op {\n                     v = self.extract(op, &[lhs, rhs], v)?;\n                     continue;\n@@ -107,7 +107,7 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n \n         // prevent folding of `cfg!` macros and the like\n         if !e.span.from_expansion() {\n-            match &e.node {\n+            match &e.kind {\n                 ExprKind::Unary(UnNot, inner) => return Ok(Bool::Not(box self.run(inner)?)),\n                 ExprKind::Binary(binop, lhs, rhs) => match &binop.node {\n                     BinOpKind::Or => return Ok(Bool::Or(self.extract(BinOpKind::Or, &[lhs, rhs], Vec::new())?)),\n@@ -129,9 +129,9 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n             }\n \n             if_chain! {\n-                if let ExprKind::Binary(e_binop, e_lhs, e_rhs) = &e.node;\n+                if let ExprKind::Binary(e_binop, e_lhs, e_rhs) = &e.kind;\n                 if implements_ord(self.cx, e_lhs);\n-                if let ExprKind::Binary(expr_binop, expr_lhs, expr_rhs) = &expr.node;\n+                if let ExprKind::Binary(expr_binop, expr_lhs, expr_rhs) = &expr.kind;\n                 if negate(e_binop.node) == Some(expr_binop.node);\n                 if SpanlessEq::new(self.cx).ignore_fn().eq_expr(e_lhs, expr_lhs);\n                 if SpanlessEq::new(self.cx).ignore_fn().eq_expr(e_rhs, expr_rhs);\n@@ -222,7 +222,7 @@ impl<'a, 'tcx, 'v> SuggestContext<'a, 'tcx, 'v> {\n }\n \n fn simplify_not(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<String> {\n-    match &expr.node {\n+    match &expr.kind {\n         ExprKind::Binary(binop, lhs, rhs) => {\n             if !implements_ord(cx, lhs) {\n                 return None;\n@@ -437,7 +437,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NonminimalBoolVisitor<'a, 'tcx> {\n         if in_macro(e.span) {\n             return;\n         }\n-        match &e.node {\n+        match &e.kind {\n             ExprKind::Binary(binop, _, _) if binop.node == BinOpKind::Or || binop.node == BinOpKind::And => {\n                 self.bool_expr(e)\n             },\n@@ -467,7 +467,7 @@ struct NotSimplificationVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for NotSimplificationVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n-        if let ExprKind::Unary(UnNot, inner) = &expr.node {\n+        if let ExprKind::Unary(UnNot, inner) = &expr.kind {\n             if let Some(suggestion) = simplify_not(self.cx, inner) {\n                 span_lint_and_sugg(\n                     self.cx,"}, {"sha": "540bffa097d70c986c81f01e5ad4e4e1bfabdc8b", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -37,19 +37,19 @@ declare_lint_pass!(ByteCount => [NAIVE_BYTECOUNT]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ByteCount {\n     fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &Expr) {\n         if_chain! {\n-            if let ExprKind::MethodCall(ref count, _, ref count_args) = expr.node;\n+            if let ExprKind::MethodCall(ref count, _, ref count_args) = expr.kind;\n             if count.ident.name == sym!(count);\n             if count_args.len() == 1;\n-            if let ExprKind::MethodCall(ref filter, _, ref filter_args) = count_args[0].node;\n+            if let ExprKind::MethodCall(ref filter, _, ref filter_args) = count_args[0].kind;\n             if filter.ident.name == sym!(filter);\n             if filter_args.len() == 2;\n-            if let ExprKind::Closure(_, _, body_id, _, _) = filter_args[1].node;\n+            if let ExprKind::Closure(_, _, body_id, _, _) = filter_args[1].kind;\n             then {\n                 let body = cx.tcx.hir().body(body_id);\n                 if_chain! {\n                     if body.params.len() == 1;\n                     if let Some(argname) = get_pat_name(&body.params[0].pat);\n-                    if let ExprKind::Binary(ref op, ref l, ref r) = body.value.node;\n+                    if let ExprKind::Binary(ref op, ref l, ref r) = body.value.kind;\n                     if op.node == BinOpKind::Eq;\n                     if match_type(cx,\n                                walk_ptrs_ty(cx.tables.expr_ty(&filter_args[0])),\n@@ -66,7 +66,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ByteCount {\n                             return;\n                         }\n                         let haystack = if let ExprKind::MethodCall(ref path, _, ref args) =\n-                                filter_args[0].node {\n+                                filter_args[0].kind {\n                             let p = path.ident.name;\n                             if (p == sym!(iter) || p == sym!(iter_mut)) && args.len() == 1 {\n                                 &args[0]\n@@ -100,7 +100,7 @@ fn check_arg(name: Name, arg: Name, needle: &Expr) -> bool {\n }\n \n fn get_path_name(expr: &Expr) -> Option<Name> {\n-    match expr.node {\n+    match expr.kind {\n         ExprKind::Box(ref e) | ExprKind::AddrOf(_, ref e) | ExprKind::Unary(UnOp::UnDeref, ref e) => get_path_name(e),\n         ExprKind::Block(ref b, _) => {\n             if b.stmts.is_empty() {"}, {"sha": "d1d725678b7b47575ba92a7fadc1f9c577118262", "filename": "clippy_lints/src/checked_conversions.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fchecked_conversions.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -44,7 +44,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CheckedConversions {\n     fn check_expr(&mut self, cx: &LateContext<'_, '_>, item: &Expr) {\n         let result = if_chain! {\n             if !in_external_macro(cx.sess(), item.span);\n-            if let ExprKind::Binary(op, ref left, ref right) = &item.node;\n+            if let ExprKind::Binary(op, ref left, ref right) = &item.kind;\n \n             then {\n                 match op.node {\n@@ -180,7 +180,7 @@ impl ConversionType {\n /// Check for `expr <= (to_type::max_value() as from_type)`\n fn check_upper_bound(expr: &Expr) -> Option<Conversion<'_>> {\n     if_chain! {\n-         if let ExprKind::Binary(ref op, ref left, ref right) = &expr.node;\n+         if let ExprKind::Binary(ref op, ref left, ref right) = &expr.kind;\n          if let Some((candidate, check)) = normalize_le_ge(op, left, right);\n          if let Some((from, to)) = get_types_from_cast(check, MAX_VALUE, INTS);\n \n@@ -199,7 +199,7 @@ fn check_lower_bound(expr: &Expr) -> Option<Conversion<'_>> {\n     }\n \n     // First of we need a binary containing the expression & the cast\n-    if let ExprKind::Binary(ref op, ref left, ref right) = &expr.node {\n+    if let ExprKind::Binary(ref op, ref left, ref right) = &expr.kind {\n         normalize_le_ge(op, right, left).and_then(|(l, r)| check_function(l, r))\n     } else {\n         None\n@@ -209,7 +209,7 @@ fn check_lower_bound(expr: &Expr) -> Option<Conversion<'_>> {\n /// Check for `expr >= 0`\n fn check_lower_bound_zero<'a>(candidate: &'a Expr, check: &'a Expr) -> Option<Conversion<'a>> {\n     if_chain! {\n-        if let ExprKind::Lit(ref lit) = &check.node;\n+        if let ExprKind::Lit(ref lit) = &check.kind;\n         if let LitKind::Int(0, _) = &lit.node;\n \n         then {\n@@ -234,8 +234,8 @@ fn get_types_from_cast<'a>(expr: &'a Expr, func: &'a str, types: &'a [&str]) ->\n     // `to_type::maxmin_value() as from_type`\n     let call_from_cast: Option<(&Expr, &str)> = if_chain! {\n         // to_type::maxmin_value(), from_type\n-        if let ExprKind::Cast(ref limit, ref from_type) = &expr.node;\n-        if let TyKind::Path(ref from_type_path) = &from_type.node;\n+        if let ExprKind::Cast(ref limit, ref from_type) = &expr.kind;\n+        if let TyKind::Path(ref from_type_path) = &from_type.kind;\n         if let Some(from_sym) = int_ty_to_sym(from_type_path);\n \n         then {\n@@ -249,12 +249,12 @@ fn get_types_from_cast<'a>(expr: &'a Expr, func: &'a str, types: &'a [&str]) ->\n     let limit_from: Option<(&Expr, &str)> = call_from_cast.or_else(|| {\n         if_chain! {\n             // `from_type::from, to_type::maxmin_value()`\n-            if let ExprKind::Call(ref from_func, ref args) = &expr.node;\n+            if let ExprKind::Call(ref from_func, ref args) = &expr.kind;\n             // `to_type::maxmin_value()`\n             if args.len() == 1;\n             if let limit = &args[0];\n             // `from_type::from`\n-            if let ExprKind::Path(ref path) = &from_func.node;\n+            if let ExprKind::Path(ref path) = &from_func.kind;\n             if let Some(from_sym) = get_implementing_type(path, INTS, FROM);\n \n             then {\n@@ -267,9 +267,9 @@ fn get_types_from_cast<'a>(expr: &'a Expr, func: &'a str, types: &'a [&str]) ->\n \n     if let Some((limit, from_type)) = limit_from {\n         if_chain! {\n-            if let ExprKind::Call(ref fun_name, _) = &limit.node;\n+            if let ExprKind::Call(ref fun_name, _) = &limit.kind;\n             // `to_type, maxmin_value`\n-            if let ExprKind::Path(ref path) = &fun_name.node;\n+            if let ExprKind::Path(ref path) = &fun_name.kind;\n             // `to_type`\n             if let Some(to_type) = get_implementing_type(path, types, func);\n \n@@ -289,7 +289,7 @@ fn get_implementing_type<'a>(path: &QPath, candidates: &'a [&str], function: &st\n     if_chain! {\n         if let QPath::TypeRelative(ref ty, ref path) = &path;\n         if path.ident.name.as_str() == function;\n-        if let TyKind::Path(QPath::Resolved(None, ref tp)) = &ty.node;\n+        if let TyKind::Path(QPath::Resolved(None, ref tp)) = &ty.kind;\n         if let [int] = &*tp.segments;\n         let name = &int.ident.name.as_str();\n "}, {"sha": "d869427467c31460a4970550479faa48b13514a1", "filename": "clippy_lints/src/cognitive_complexity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcognitive_complexity.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -110,7 +110,7 @@ struct CCHelper {\n impl<'tcx> Visitor<'tcx> for CCHelper {\n     fn visit_expr(&mut self, e: &'tcx Expr) {\n         walk_expr(self, e);\n-        match e.node {\n+        match e.kind {\n             ExprKind::Match(_, ref arms, _) => {\n                 if arms.len() > 1 {\n                     self.cc += 1;"}, {"sha": "6a9d6d04650b7fd0c6a262f58e0517a3b54e1c59", "filename": "clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -82,10 +82,10 @@ impl EarlyLintPass for CollapsibleIf {\n }\n \n fn check_if(cx: &EarlyContext<'_>, expr: &ast::Expr) {\n-    if let ast::ExprKind::If(check, then, else_) = &expr.node {\n+    if let ast::ExprKind::If(check, then, else_) = &expr.kind {\n         if let Some(else_) = else_ {\n             check_collapsible_maybe_if_let(cx, else_);\n-        } else if let ast::ExprKind::Let(..) = check.node {\n+        } else if let ast::ExprKind::Let(..) = check.kind {\n             // Prevent triggering on `if let a = b { if c { .. } }`.\n         } else {\n             check_collapsible_no_if_let(cx, expr, check, then);\n@@ -103,11 +103,11 @@ fn block_starts_with_comment(cx: &EarlyContext<'_>, expr: &ast::Block) -> bool {\n \n fn check_collapsible_maybe_if_let(cx: &EarlyContext<'_>, else_: &ast::Expr) {\n     if_chain! {\n-        if let ast::ExprKind::Block(ref block, _) = else_.node;\n+        if let ast::ExprKind::Block(ref block, _) = else_.kind;\n         if !block_starts_with_comment(cx, block);\n         if let Some(else_) = expr_block(block);\n         if !else_.span.from_expansion();\n-        if let ast::ExprKind::If(..) = else_.node;\n+        if let ast::ExprKind::If(..) = else_.kind;\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n             span_lint_and_sugg(\n@@ -127,9 +127,9 @@ fn check_collapsible_no_if_let(cx: &EarlyContext<'_>, expr: &ast::Expr, check: &\n     if_chain! {\n         if !block_starts_with_comment(cx, then);\n         if let Some(inner) = expr_block(then);\n-        if let ast::ExprKind::If(ref check_inner, ref content, None) = inner.node;\n+        if let ast::ExprKind::If(ref check_inner, ref content, None) = inner.kind;\n         then {\n-            if let ast::ExprKind::Let(..) = check_inner.node {\n+            if let ast::ExprKind::Let(..) = check_inner.kind {\n                 // Prevent triggering on `if c { if let a = b { .. } }`.\n                 return;\n             }\n@@ -160,7 +160,7 @@ fn expr_block(block: &ast::Block) -> Option<&ast::Expr> {\n     let mut it = block.stmts.iter();\n \n     if let (Some(stmt), None) = (it.next(), it.next()) {\n-        match stmt.node {\n+        match stmt.kind {\n             ast::StmtKind::Expr(ref expr) | ast::StmtKind::Semi(ref expr) => Some(expr),\n             _ => None,\n         }"}, {"sha": "6968d8f655996134702d047074f56c92bcf96115", "filename": "clippy_lints/src/comparison_chain.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcomparison_chain.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -71,7 +71,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ComparisonChain {\n             if let (\n                 &ExprKind::Binary(ref kind1, ref lhs1, ref rhs1),\n                 &ExprKind::Binary(ref kind2, ref lhs2, ref rhs2),\n-            ) = (&cond[0].node, &cond[1].node)\n+            ) = (&cond[0].kind, &cond[1].kind)\n             {\n                 if !kind_is_cmp(kind1.node) || !kind_is_cmp(kind2.node) {\n                     return;"}, {"sha": "eadadaa1932a535be67cbf4eb062f59aea8b0a4b", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -222,7 +222,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n         if let Some((ref cond, ref then, otherwise)) = higher::if_block(&e) {\n             return self.ifthenelse(cond, then, otherwise);\n         }\n-        match e.node {\n+        match e.kind {\n             ExprKind::Path(ref qpath) => self.fetch_path(qpath, e.hir_id),\n             ExprKind::Block(ref block, _) => self.block(block),\n             ExprKind::Lit(ref lit) => Some(lit_to_constant(&lit.node, self.tables.expr_ty(e))),\n@@ -245,7 +245,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n                 // We only handle a few const functions for now.\n                 if_chain! {\n                     if args.is_empty();\n-                    if let ExprKind::Path(qpath) = &callee.node;\n+                    if let ExprKind::Path(qpath) = &callee.kind;\n                     let res = self.tables.qpath_res(qpath, callee.hir_id);\n                     if let Some(def_id) = res.opt_def_id();\n                     let get_def_path = self.lcx.get_def_path(def_id, );"}, {"sha": "f514068fb10efda060adb1e25ff6105c8c9cfac9", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -176,7 +176,7 @@ fn lint_match_arms<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &Expr) {\n                 .all(|(name, l_ty)| rhs.get(name).map_or(false, |r_ty| same_tys(cx, l_ty, r_ty)))\n     }\n \n-    if let ExprKind::Match(_, ref arms, MatchSource::Normal) = expr.node {\n+    if let ExprKind::Match(_, ref arms, MatchSource::Normal) = expr.kind {\n         let hash = |&(_, arm): &(usize, &Arm)| -> u64 {\n             let mut h = SpanlessHash::new(cx, cx.tables);\n             h.hash_expr(&arm.body);\n@@ -215,7 +215,7 @@ fn lint_match_arms<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &Expr) {\n                     let lhs = snippet(cx, i.pat.span, \"<pat1>\");\n                     let rhs = snippet(cx, j.pat.span, \"<pat2>\");\n \n-                    if let PatKind::Wild = j.pat.node {\n+                    if let PatKind::Wild = j.pat.kind {\n                         // if the last arm is _, then i could be integrated into _\n                         // note that i.pat cannot be _, because that would mean that we're\n                         // hiding all the subsequent arms, and rust won't compile\n@@ -238,7 +238,7 @@ fn lint_match_arms<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &Expr) {\n /// Returns the list of bindings in a pattern.\n fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> FxHashMap<Symbol, Ty<'tcx>> {\n     fn bindings_impl<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat, map: &mut FxHashMap<Symbol, Ty<'tcx>>) {\n-        match pat.node {\n+        match pat.kind {\n             PatKind::Box(ref pat) | PatKind::Ref(ref pat, _) => bindings_impl(cx, pat, map),\n             PatKind::TupleStruct(_, ref pats, _) => {\n                 for pat in pats {"}, {"sha": "73de8add32d315e738683b0f47a7a52a174cb8ec", "filename": "clippy_lints/src/copy_iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fcopy_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fcopy_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopy_iterator.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -33,7 +33,7 @@ declare_lint_pass!(CopyIterator => [COPY_ITERATOR]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CopyIterator {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if let ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, _) = item.node {\n+        if let ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, _) = item.kind {\n             let ty = cx.tcx.type_of(cx.tcx.hir().local_def_id(item.hir_id));\n \n             if is_copy(cx, ty) && match_path(&trait_ref.path, &paths::ITERATOR) {"}, {"sha": "350e6c677b489950cac2f1e6d7fd7fa5d169fbcc", "filename": "clippy_lints/src/default_trait_access.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_trait_access.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -33,9 +33,9 @@ declare_lint_pass!(DefaultTraitAccess => [DEFAULT_TRAIT_ACCESS]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DefaultTraitAccess {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n-            if let ExprKind::Call(ref path, ..) = expr.node;\n+            if let ExprKind::Call(ref path, ..) = expr.kind;\n             if !any_parent_is_automatically_derived(cx.tcx, expr.hir_id);\n-            if let ExprKind::Path(ref qpath) = path.node;\n+            if let ExprKind::Path(ref qpath) = path.kind;\n             if let Some(def_id) = cx.tables.qpath_res(qpath, path.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::DEFAULT_TRAIT_METHOD);\n             then {\n@@ -44,8 +44,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DefaultTraitAccess {\n                         if_chain! {\n                             // Detect and ignore <Foo as Default>::default() because these calls do\n                             // explicitly name the type.\n-                            if let ExprKind::Call(ref method, ref _args) = expr.node;\n-                            if let ExprKind::Path(ref p) = method.node;\n+                            if let ExprKind::Call(ref method, ref _args) = expr.kind;\n+                            if let ExprKind::Path(ref p) = method.kind;\n                             if let QPath::Resolved(Some(_ty), _path) = p;\n                             then {\n                                 return;"}, {"sha": "fa981ce78d9a2b5c568e69cc95de9afc17a794e3", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -66,7 +66,7 @@ declare_lint_pass!(Derive => [EXPL_IMPL_CLONE_ON_COPY, DERIVE_HASH_XOR_EQ]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Derive {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if let ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, _) = item.node {\n+        if let ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, _) = item.kind {\n             let ty = cx.tcx.type_of(cx.tcx.hir().local_def_id(item.hir_id));\n             let is_automatically_derived = is_automatically_derived(&*item.attrs);\n "}, {"sha": "59cb282a9954d3159b4d079c18acb3dcb11d1db1", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -92,7 +92,7 @@ impl EarlyLintPass for DocMarkdown {\n             return;\n         }\n         // no safety header\n-        if let ast::ItemKind::Fn(_, ref header, ..) = item.node {\n+        if let ast::ItemKind::Fn(_, ref header, ..) = item.kind {\n             if item.vis.node.is_pub() && header.unsafety == ast::Unsafety::Unsafe {\n                 span_lint(\n                     cx,"}, {"sha": "48d2fd341f81b22ba4dd1b9063d0c770f321aadf", "filename": "clippy_lints/src/double_comparison.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_comparison.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -40,7 +40,7 @@ declare_lint_pass!(DoubleComparisons => [DOUBLE_COMPARISONS]);\n impl<'a, 'tcx> DoubleComparisons {\n     #[allow(clippy::similar_names)]\n     fn check_binop(self, cx: &LateContext<'a, 'tcx>, op: BinOpKind, lhs: &'tcx Expr, rhs: &'tcx Expr, span: Span) {\n-        let (lkind, llhs, lrhs, rkind, rlhs, rrhs) = match (&lhs.node, &rhs.node) {\n+        let (lkind, llhs, lrhs, rkind, rlhs, rrhs) = match (&lhs.kind, &rhs.kind) {\n             (ExprKind::Binary(lb, llhs, lrhs), ExprKind::Binary(rb, rlhs, rrhs)) => {\n                 (lb.node, llhs, lrhs, rb.node, rlhs, rrhs)\n             },\n@@ -88,7 +88,7 @@ impl<'a, 'tcx> DoubleComparisons {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DoubleComparisons {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprKind::Binary(ref kind, ref lhs, ref rhs) = expr.node {\n+        if let ExprKind::Binary(ref kind, ref lhs, ref rhs) = expr.kind {\n             self.check_binop(cx, kind.node, lhs, rhs, expr.span);\n         }\n     }"}, {"sha": "3bdebbeae4927a612d472a7af39fdea6772c163a", "filename": "clippy_lints/src/double_parens.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fdouble_parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fdouble_parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_parens.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -31,8 +31,8 @@ impl EarlyLintPass for DoubleParens {\n             return;\n         }\n \n-        match expr.node {\n-            ExprKind::Paren(ref in_paren) => match in_paren.node {\n+        match expr.kind {\n+            ExprKind::Paren(ref in_paren) => match in_paren.kind {\n                 ExprKind::Paren(_) | ExprKind::Tup(_) => {\n                     span_lint(\n                         cx,\n@@ -46,7 +46,7 @@ impl EarlyLintPass for DoubleParens {\n             ExprKind::Call(_, ref params) => {\n                 if params.len() == 1 {\n                     let param = &params[0];\n-                    if let ExprKind::Paren(_) = param.node {\n+                    if let ExprKind::Paren(_) = param.kind {\n                         span_lint(\n                             cx,\n                             DOUBLE_PARENS,\n@@ -59,7 +59,7 @@ impl EarlyLintPass for DoubleParens {\n             ExprKind::MethodCall(_, ref params) => {\n                 if params.len() == 2 {\n                     let param = &params[1];\n-                    if let ExprKind::Paren(_) = param.node {\n+                    if let ExprKind::Paren(_) = param.kind {\n                         span_lint(\n                             cx,\n                             DOUBLE_PARENS,"}, {"sha": "13a2be6b3fa544faaa849e321d6ff6649ad0e3d3", "filename": "clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -111,8 +111,8 @@ declare_lint_pass!(DropForgetRef => [DROP_REF, FORGET_REF, DROP_COPY, FORGET_COP\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DropForgetRef {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n-            if let ExprKind::Call(ref path, ref args) = expr.node;\n-            if let ExprKind::Path(ref qpath) = path.node;\n+            if let ExprKind::Call(ref path, ref args) = expr.kind;\n+            if let ExprKind::Path(ref qpath) = path.kind;\n             if args.len() == 1;\n             if let Some(def_id) = qpath_res(cx, qpath, path.hir_id).opt_def_id();\n             then {"}, {"sha": "119328cbaba1916e58142c53c82a3ceca6be39f8", "filename": "clippy_lints/src/duration_subsec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fduration_subsec.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -35,8 +35,8 @@ declare_lint_pass!(DurationSubsec => [DURATION_SUBSEC]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DurationSubsec {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n-            if let ExprKind::Binary(Spanned { node: BinOpKind::Div, .. }, ref left, ref right) = expr.node;\n-            if let ExprKind::MethodCall(ref method_path, _ , ref args) = left.node;\n+            if let ExprKind::Binary(Spanned { node: BinOpKind::Div, .. }, ref left, ref right) = expr.kind;\n+            if let ExprKind::MethodCall(ref method_path, _ , ref args) = left.kind;\n             if match_type(cx, walk_ptrs_ty(cx.tables.expr_ty(&args[0])), &paths::DURATION);\n             if let Some((Constant::Int(divisor), _)) = constant(cx, cx.tables, right);\n             then {"}, {"sha": "e6d7fe4841b881ba15aa0f46917eeb3a9f5297a5", "filename": "clippy_lints/src/else_if_without_else.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Felse_if_without_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Felse_if_without_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Felse_if_without_else.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -53,8 +53,8 @@ impl EarlyLintPass for ElseIfWithoutElse {\n             return;\n         }\n \n-        while let ExprKind::If(_, _, Some(ref els)) = item.node {\n-            if let ExprKind::If(_, _, None) = els.node {\n+        while let ExprKind::If(_, _, Some(ref els)) = item.kind {\n+            if let ExprKind::If(_, _, None) = els.kind {\n                 span_help_and_lint(\n                     cx,\n                     ELSE_IF_WITHOUT_ELSE,"}, {"sha": "cfb908cf33d576e921c14d598bcb3adb3e01fecb", "filename": "clippy_lints/src/empty_enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fempty_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fempty_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fempty_enum.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -28,7 +28,7 @@ declare_lint_pass!(EmptyEnum => [EMPTY_ENUM]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EmptyEnum {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &Item) {\n         let did = cx.tcx.hir().local_def_id(item.hir_id);\n-        if let ItemKind::Enum(..) = item.node {\n+        if let ItemKind::Enum(..) = item.kind {\n             let ty = cx.tcx.type_of(did);\n             let adt = ty.ty_adt_def().expect(\"already checked whether this is an enum\");\n             if adt.variants.is_empty() {"}, {"sha": "7acac4dbb686c509d7bf7ba6ef0102bd516745b4", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -54,13 +54,13 @@ declare_lint_pass!(HashMapPass => [MAP_ENTRY]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for HashMapPass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let Some((ref check, ref then_block, ref else_block)) = higher::if_block(&expr) {\n-            if let ExprKind::Unary(UnOp::UnNot, ref check) = check.node {\n+            if let ExprKind::Unary(UnOp::UnNot, ref check) = check.kind {\n                 if let Some((ty, map, key)) = check_cond(cx, check) {\n                     // in case of `if !m.contains_key(&k) { m.insert(k, v); }`\n                     // we can give a better error message\n                     let sole_expr = {\n                         else_block.is_none()\n-                            && if let ExprKind::Block(ref then_block, _) = then_block.node {\n+                            && if let ExprKind::Block(ref then_block, _) = then_block.kind {\n                                 (then_block.expr.is_some() as usize) + then_block.stmts.len() == 1\n                             } else {\n                                 true\n@@ -102,10 +102,10 @@ fn check_cond<'a, 'tcx, 'b>(\n     check: &'b Expr,\n ) -> Option<(&'static str, &'b Expr, &'b Expr)> {\n     if_chain! {\n-        if let ExprKind::MethodCall(ref path, _, ref params) = check.node;\n+        if let ExprKind::MethodCall(ref path, _, ref params) = check.kind;\n         if params.len() >= 2;\n         if path.ident.name == sym!(contains_key);\n-        if let ExprKind::AddrOf(_, ref key) = params[1].node;\n+        if let ExprKind::AddrOf(_, ref key) = params[1].kind;\n         then {\n             let map = &params[0];\n             let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(map));\n@@ -137,7 +137,7 @@ struct InsertVisitor<'a, 'tcx, 'b> {\n impl<'a, 'tcx, 'b> Visitor<'tcx> for InsertVisitor<'a, 'tcx, 'b> {\n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if_chain! {\n-            if let ExprKind::MethodCall(ref path, _, ref params) = expr.node;\n+            if let ExprKind::MethodCall(ref path, _, ref params) = expr.kind;\n             if params.len() == 3;\n             if path.ident.name == sym!(insert);\n             if get_item_name(self.cx, self.map) == get_item_name(self.cx, &params[0]);"}, {"sha": "e1e20c904374111e9ebba437c30b43434d7691ad", "filename": "clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_clike.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -43,7 +43,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnportableVariant {\n         if cx.tcx.data_layout.pointer_size.bits() != 64 {\n             return;\n         }\n-        if let ItemKind::Enum(def, _) = &item.node {\n+        if let ItemKind::Enum(def, _) = &item.kind {\n             for var in &def.variants {\n                 if let Some(anon_const) = &var.disr_expr {\n                     let param_env = ty::ParamEnv::empty();"}, {"sha": "bb71bb54472d0ad3f8e721a766471059db0ad5c0", "filename": "clippy_lints/src/enum_glob_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_glob_use.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -42,7 +42,7 @@ impl EnumGlobUse {\n         if item.vis.node.is_pub() {\n             return; // re-exports are fine\n         }\n-        if let ItemKind::Use(ref path, UseKind::Glob) = item.node {\n+        if let ItemKind::Use(ref path, UseKind::Glob) = item.kind {\n             if let Res::Def(DefKind::Enum, _) = path.res {\n                 span_lint(cx, ENUM_GLOB_USE, item.span, \"don't use glob imports for enum variants\");\n             }"}, {"sha": "e64eed3834080253fe8603aa7ca851ae32018059", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -249,7 +249,7 @@ impl EarlyLintPass for EnumVariantNames {\n                 // constants don't have surrounding modules\n                 if !mod_camel.is_empty() {\n                     if mod_name == &item.ident.name {\n-                        if let ItemKind::Mod(..) = item.node {\n+                        if let ItemKind::Mod(..) = item.kind {\n                             span_lint(\n                                 cx,\n                                 MODULE_INCEPTION,\n@@ -288,7 +288,7 @@ impl EarlyLintPass for EnumVariantNames {\n                 }\n             }\n         }\n-        if let ItemKind::Enum(ref def, _) = item.node {\n+        if let ItemKind::Enum(ref def, _) = item.kind {\n             let lint = match item.vis.node {\n                 VisibilityKind::Public => PUB_ENUM_VARIANT_NAMES,\n                 _ => ENUM_VARIANT_NAMES,"}, {"sha": "80e68f04673acf8f23794c0214eb1918b2896c62", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -49,7 +49,7 @@ declare_lint_pass!(EqOp => [EQ_OP, OP_REF]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n     #[allow(clippy::similar_names, clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprKind::Binary(op, ref left, ref right) = e.node {\n+        if let ExprKind::Binary(op, ref left, ref right) = e.kind {\n             if e.span.from_expansion() {\n                 return;\n             }\n@@ -82,7 +82,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n             };\n             if let Some(trait_id) = trait_id {\n                 #[allow(clippy::match_same_arms)]\n-                match (&left.node, &right.node) {\n+                match (&left.kind, &right.kind) {\n                     // do not suggest to dereference literals\n                     (&ExprKind::Lit(..), _) | (_, &ExprKind::Lit(..)) => {},\n                     // &foo == &bar"}, {"sha": "5fa52d8030c65797802063c3c4f803bf56f9b780", "filename": "clippy_lints/src/erasing_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Ferasing_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Ferasing_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ferasing_op.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -34,7 +34,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ErasingOp {\n         if e.span.from_expansion() {\n             return;\n         }\n-        if let ExprKind::Binary(ref cmp, ref left, ref right) = e.node {\n+        if let ExprKind::Binary(ref cmp, ref left, ref right) = e.kind {\n             match cmp.node {\n                 BinOpKind::Mul | BinOpKind::BitAnd => {\n                     check(cx, left, e.span);"}, {"sha": "5b890f6abe08f8831b4e22f81c4fd061a9d83535", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -65,7 +65,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxedLocal {\n         let parent_node = cx.tcx.hir().find(parent_id);\n \n         if let Some(Node::Item(item)) = parent_node {\n-            if let ItemKind::Impl(_, _, _, _, Some(..), _, _) = item.node {\n+            if let ItemKind::Impl(_, _, _, _, Some(..), _, _) = item.kind {\n                 return;\n             }\n         }\n@@ -139,9 +139,9 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n         }\n         if let Categorization::Rvalue(..) = cmt.cat {\n             if let Some(Node::Stmt(st)) = map.find(map.get_parent_node(cmt.hir_id)) {\n-                if let StmtKind::Local(ref loc) = st.node {\n+                if let StmtKind::Local(ref loc) = st.kind {\n                     if let Some(ref ex) = loc.init {\n-                        if let ExprKind::Box(..) = ex.node {\n+                        if let ExprKind::Box(..) = ex.kind {\n                             if is_non_trait_box(cmt.ty) && !self.is_large_box(cmt.ty) {\n                                 // let x = box (...)\n                                 self.set.insert(consume_pat.hir_id);"}, {"sha": "d22ae970d3572edc1c3d7c68da20d9a65acbbb99", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -65,7 +65,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EtaReduction {\n             return;\n         }\n \n-        match expr.node {\n+        match expr.kind {\n             ExprKind::Call(_, ref args) | ExprKind::MethodCall(_, _, ref args) => {\n                 for arg in args {\n                     check_closure(cx, arg)\n@@ -77,14 +77,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EtaReduction {\n }\n \n fn check_closure(cx: &LateContext<'_, '_>, expr: &Expr) {\n-    if let ExprKind::Closure(_, ref decl, eid, _, _) = expr.node {\n+    if let ExprKind::Closure(_, ref decl, eid, _, _) = expr.kind {\n         let body = cx.tcx.hir().body(eid);\n         let ex = &body.value;\n \n         if_chain!(\n-            if let ExprKind::Call(ref caller, ref args) = ex.node;\n+            if let ExprKind::Call(ref caller, ref args) = ex.kind;\n \n-            if let ExprKind::Path(_) = caller.node;\n+            if let ExprKind::Path(_) = caller.kind;\n \n             // Not the same number of arguments, there is no way the closure is the same as the function return;\n             if args.len() == decl.inputs.len();\n@@ -115,7 +115,7 @@ fn check_closure(cx: &LateContext<'_, '_>, expr: &Expr) {\n         );\n \n         if_chain!(\n-            if let ExprKind::MethodCall(ref path, _, ref args) = ex.node;\n+            if let ExprKind::MethodCall(ref path, _, ref args) = ex.kind;\n \n             // Not the same number of arguments, there is no way the closure is the same as the function return;\n             if args.len() == decl.inputs.len();\n@@ -207,9 +207,9 @@ fn compare_inputs(\n     call_args: &mut dyn Iterator<Item = &Expr>,\n ) -> bool {\n     for (closure_input, function_arg) in closure_inputs.zip(call_args) {\n-        if let PatKind::Binding(_, _, ident, _) = closure_input.pat.node {\n+        if let PatKind::Binding(_, _, ident, _) = closure_input.pat.kind {\n             // XXXManishearth Should I be checking the binding mode here?\n-            if let ExprKind::Path(QPath::Resolved(None, ref p)) = function_arg.node {\n+            if let ExprKind::Path(QPath::Resolved(None, ref p)) = function_arg.kind {\n                 if p.segments.len() != 1 {\n                     // If it's a proper path, it can't be a local variable\n                     return false;"}, {"sha": "84c0110f11113402c0b5141a08e8d72fdc6ca18e", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -60,9 +60,9 @@ declare_lint_pass!(EvalOrderDependence => [EVAL_ORDER_DEPENDENCE, DIVERGING_SUB_\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EvalOrderDependence {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // Find a write to a local variable.\n-        match expr.node {\n+        match expr.kind {\n             ExprKind::Assign(ref lhs, _) | ExprKind::AssignOp(_, ref lhs, _) => {\n-                if let ExprKind::Path(ref qpath) = lhs.node {\n+                if let ExprKind::Path(ref qpath) = lhs.kind {\n                     if let QPath::Resolved(_, ref path) = *qpath {\n                         if path.segments.len() == 1 {\n                             if let def::Res::Local(var) = cx.tables.qpath_res(qpath, lhs.hir_id) {\n@@ -82,7 +82,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EvalOrderDependence {\n         }\n     }\n     fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n-        match stmt.node {\n+        match stmt.kind {\n             StmtKind::Local(ref local) => {\n                 if let Local { init: Some(ref e), .. } = **local {\n                     DivergenceVisitor { cx }.visit_expr(e);\n@@ -100,7 +100,7 @@ struct DivergenceVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> DivergenceVisitor<'a, 'tcx> {\n     fn maybe_walk_expr(&mut self, e: &'tcx Expr) {\n-        match e.node {\n+        match e.kind {\n             ExprKind::Closure(..) => {},\n             ExprKind::Match(ref e, ref arms, _) => {\n                 self.visit_expr(e);\n@@ -124,7 +124,7 @@ impl<'a, 'tcx> DivergenceVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, e: &'tcx Expr) {\n-        match e.node {\n+        match e.kind {\n             ExprKind::Continue(_) | ExprKind::Break(_, _) | ExprKind::Ret(_) => self.report_diverging_sub_expr(e),\n             ExprKind::Call(ref func, _) => {\n                 let typ = self.cx.tables.expr_ty(func);\n@@ -218,7 +218,7 @@ fn check_expr<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, expr: &'tcx Expr) -> St\n         return StopEarly::KeepGoing;\n     }\n \n-    match expr.node {\n+    match expr.kind {\n         ExprKind::Array(_)\n         | ExprKind::Tup(_)\n         | ExprKind::MethodCall(..)\n@@ -261,7 +261,7 @@ fn check_expr<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, expr: &'tcx Expr) -> St\n }\n \n fn check_stmt<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, stmt: &'tcx Stmt) -> StopEarly {\n-    match stmt.node {\n+    match stmt.kind {\n         StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => check_expr(vis, expr),\n         // If the declaration is of a local variable, check its initializer\n         // expression if it has one. Otherwise, keep going.\n@@ -292,7 +292,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n             return;\n         }\n \n-        match expr.node {\n+        match expr.kind {\n             ExprKind::Path(ref qpath) => {\n                 if_chain! {\n                     if let QPath::Resolved(None, ref path) = *qpath;\n@@ -344,7 +344,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n /// Returns `true` if `expr` is the LHS of an assignment, like `expr = ...`.\n fn is_in_assignment_position(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     if let Some(parent) = get_parent_expr(cx, expr) {\n-        if let ExprKind::Assign(ref lhs, _) = parent.node {\n+        if let ExprKind::Assign(ref lhs, _) = parent.kind {\n             return lhs.hir_id == expr.hir_id;\n         }\n     }"}, {"sha": "ae9681134ffa7c8a633012856ea6cc4454de50fa", "filename": "clippy_lints/src/excessive_precision.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexcessive_precision.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -42,7 +42,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExcessivePrecision {\n         if_chain! {\n             let ty = cx.tables.expr_ty(expr);\n             if let ty::Float(fty) = ty.kind;\n-            if let hir::ExprKind::Lit(ref lit) = expr.node;\n+            if let hir::ExprKind::Lit(ref lit) = expr.kind;\n             if let LitKind::Float(sym, _) | LitKind::FloatUnsuffixed(sym) = lit.node;\n             if let Some(sugg) = self.check(sym, fty);\n             then {"}, {"sha": "92668046742873e652bcd27a987cef59d4d801f9", "filename": "clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexplicit_write.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -32,17 +32,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitWrite {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n             // match call to unwrap\n-            if let ExprKind::MethodCall(ref unwrap_fun, _, ref unwrap_args) = expr.node;\n+            if let ExprKind::MethodCall(ref unwrap_fun, _, ref unwrap_args) = expr.kind;\n             if unwrap_fun.ident.name == sym!(unwrap);\n             // match call to write_fmt\n             if unwrap_args.len() > 0;\n             if let ExprKind::MethodCall(ref write_fun, _, ref write_args) =\n-                unwrap_args[0].node;\n+                unwrap_args[0].kind;\n             if write_fun.ident.name == sym!(write_fmt);\n             // match calls to std::io::stdout() / std::io::stderr ()\n             if write_args.len() > 0;\n-            if let ExprKind::Call(ref dest_fun, _) = write_args[0].node;\n-            if let ExprKind::Path(ref qpath) = dest_fun.node;\n+            if let ExprKind::Call(ref dest_fun, _) = write_args[0].kind;\n+            if let ExprKind::Path(ref qpath) = dest_fun.kind;\n             if let Some(dest_fun_id) = resolve_node(cx, qpath, dest_fun.hir_id).opt_def_id();\n             if let Some(dest_name) = if match_def_path(cx, dest_fun_id, &paths::STDOUT) {\n                 Some(\"stdout\")\n@@ -136,13 +136,13 @@ fn write_output_string(write_args: &HirVec<Expr>) -> Option<String> {\n     if_chain! {\n         // Obtain the string that should be printed\n         if write_args.len() > 1;\n-        if let ExprKind::Call(_, ref output_args) = write_args[1].node;\n+        if let ExprKind::Call(_, ref output_args) = write_args[1].kind;\n         if output_args.len() > 0;\n-        if let ExprKind::AddrOf(_, ref output_string_expr) = output_args[0].node;\n-        if let ExprKind::Array(ref string_exprs) = output_string_expr.node;\n+        if let ExprKind::AddrOf(_, ref output_string_expr) = output_args[0].kind;\n+        if let ExprKind::Array(ref string_exprs) = output_string_expr.kind;\n         // we only want to provide an automatic suggestion for simple (non-format) strings\n         if string_exprs.len() == 1;\n-        if let ExprKind::Lit(ref lit) = string_exprs[0].node;\n+        if let ExprKind::Lit(ref lit) = string_exprs[0].kind;\n         if let LitKind::Str(ref write_output, _) = lit.node;\n         then {\n             return Some(write_output.to_string())"}, {"sha": "10db2bdef9a707f3ecc1735362db6045bd04c7fa", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -35,7 +35,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FallibleImplFrom {\n         // check for `impl From<???> for ..`\n         let impl_def_id = cx.tcx.hir().local_def_id(item.hir_id);\n         if_chain! {\n-            if let hir::ItemKind::Impl(.., ref impl_items) = item.node;\n+            if let hir::ItemKind::Impl(.., ref impl_items) = item.kind;\n             if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(impl_def_id);\n             if match_def_path(cx, impl_trait_ref.def_id, &FROM_TRAIT);\n             then {\n@@ -59,8 +59,8 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n         fn visit_expr(&mut self, expr: &'tcx Expr) {\n             // check for `begin_panic`\n             if_chain! {\n-                if let ExprKind::Call(ref func_expr, _) = expr.node;\n-                if let ExprKind::Path(QPath::Resolved(_, ref path)) = func_expr.node;\n+                if let ExprKind::Call(ref func_expr, _) = expr.kind;\n+                if let ExprKind::Path(QPath::Resolved(_, ref path)) = func_expr.kind;\n                 if let Some(path_def_id) = path.res.opt_def_id();\n                 if match_def_path(self.lcx, path_def_id, &BEGIN_PANIC) ||\n                     match_def_path(self.lcx, path_def_id, &BEGIN_PANIC_FMT);\n@@ -91,7 +91,7 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n         if_chain! {\n             if impl_item.ident.name == sym!(from);\n             if let ImplItemKind::Method(_, body_id) =\n-                cx.tcx.hir().impl_item(impl_item.id).node;\n+                cx.tcx.hir().impl_item(impl_item.id).kind;\n             then {\n                 // check the body for `begin_panic` or `unwrap`\n                 let body = cx.tcx.hir().body(body_id);"}, {"sha": "db6bba673fcaf1c9441df0439cf9507e5b50feb9", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -72,37 +72,37 @@ fn span_useless_format<T: LintContext>(cx: &T, span: Span, help: &str, mut sugg:\n \n fn on_argumentv1_new<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, arms: &'a [Arm]) -> Option<String> {\n     if_chain! {\n-        if let ExprKind::AddrOf(_, ref format_args) = expr.node;\n-        if let ExprKind::Array(ref elems) = arms[0].body.node;\n+        if let ExprKind::AddrOf(_, ref format_args) = expr.kind;\n+        if let ExprKind::Array(ref elems) = arms[0].body.kind;\n         if elems.len() == 1;\n-        if let ExprKind::Call(ref fun, ref args) = elems[0].node;\n-        if let ExprKind::Path(ref qpath) = fun.node;\n+        if let ExprKind::Call(ref fun, ref args) = elems[0].kind;\n+        if let ExprKind::Path(ref qpath) = fun.kind;\n         if let Some(did) = resolve_node(cx, qpath, fun.hir_id).opt_def_id();\n         if match_def_path(cx, did, &paths::FMT_ARGUMENTV1_NEW);\n         // matches `core::fmt::Display::fmt`\n         if args.len() == 2;\n-        if let ExprKind::Path(ref qpath) = args[1].node;\n+        if let ExprKind::Path(ref qpath) = args[1].kind;\n         if let Some(did) = resolve_node(cx, qpath, args[1].hir_id).opt_def_id();\n         if match_def_path(cx, did, &paths::DISPLAY_FMT_METHOD);\n         // check `(arg0,)` in match block\n-        if let PatKind::Tuple(ref pats, None) = arms[0].pat.node;\n+        if let PatKind::Tuple(ref pats, None) = arms[0].pat.kind;\n         if pats.len() == 1;\n         then {\n             let ty = walk_ptrs_ty(cx.tables.pat_ty(&pats[0]));\n             if ty.kind != rustc::ty::Str && !match_type(cx, ty, &paths::STRING) {\n                 return None;\n             }\n-            if let ExprKind::Lit(ref lit) = format_args.node {\n+            if let ExprKind::Lit(ref lit) = format_args.kind {\n                 if let LitKind::Str(ref s, _) = lit.node {\n                     return Some(format!(\"{:?}.to_string()\", s.as_str()));\n                 }\n             } else {\n                 let snip = snippet(cx, format_args.span, \"<arg>\");\n-                if let ExprKind::MethodCall(ref path, _, _) = format_args.node {\n+                if let ExprKind::MethodCall(ref path, _, _) = format_args.kind {\n                     if path.ident.name == sym!(to_string) {\n                         return Some(format!(\"{}\", snip));\n                     }\n-                } else if let ExprKind::Binary(..) = format_args.node {\n+                } else if let ExprKind::Binary(..) = format_args.kind {\n                     return Some(format!(\"{}\", snip));\n                 }\n                 return Some(format!(\"{}.to_string()\", snip));\n@@ -114,22 +114,22 @@ fn on_argumentv1_new<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, arm\n \n fn on_new_v1<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> Option<String> {\n     if_chain! {\n-        if let ExprKind::Call(ref fun, ref args) = expr.node;\n+        if let ExprKind::Call(ref fun, ref args) = expr.kind;\n         if args.len() == 2;\n-        if let ExprKind::Path(ref qpath) = fun.node;\n+        if let ExprKind::Path(ref qpath) = fun.kind;\n         if let Some(did) = resolve_node(cx, qpath, fun.hir_id).opt_def_id();\n         if match_def_path(cx, did, &paths::FMT_ARGUMENTS_NEW_V1);\n         // Argument 1 in `new_v1()`\n-        if let ExprKind::AddrOf(_, ref arr) = args[0].node;\n-        if let ExprKind::Array(ref pieces) = arr.node;\n+        if let ExprKind::AddrOf(_, ref arr) = args[0].kind;\n+        if let ExprKind::Array(ref pieces) = arr.kind;\n         if pieces.len() == 1;\n-        if let ExprKind::Lit(ref lit) = pieces[0].node;\n+        if let ExprKind::Lit(ref lit) = pieces[0].kind;\n         if let LitKind::Str(ref s, _) = lit.node;\n         // Argument 2 in `new_v1()`\n-        if let ExprKind::AddrOf(_, ref arg1) = args[1].node;\n-        if let ExprKind::Match(ref matchee, ref arms, MatchSource::Normal) = arg1.node;\n+        if let ExprKind::AddrOf(_, ref arg1) = args[1].kind;\n+        if let ExprKind::Match(ref matchee, ref arms, MatchSource::Normal) = arg1.kind;\n         if arms.len() == 1;\n-        if let ExprKind::Tup(ref tup) = matchee.node;\n+        if let ExprKind::Tup(ref tup) = matchee.kind;\n         then {\n             // `format!(\"foo\")` expansion contains `match () { () => [], }`\n             if tup.is_empty() {\n@@ -144,23 +144,23 @@ fn on_new_v1<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> Option<S\n \n fn on_new_v1_fmt<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> Option<String> {\n     if_chain! {\n-        if let ExprKind::Call(ref fun, ref args) = expr.node;\n+        if let ExprKind::Call(ref fun, ref args) = expr.kind;\n         if args.len() == 3;\n-        if let ExprKind::Path(ref qpath) = fun.node;\n+        if let ExprKind::Path(ref qpath) = fun.kind;\n         if let Some(did) = resolve_node(cx, qpath, fun.hir_id).opt_def_id();\n         if match_def_path(cx, did, &paths::FMT_ARGUMENTS_NEW_V1_FORMATTED);\n         if check_unformatted(&args[2]);\n         // Argument 1 in `new_v1_formatted()`\n-        if let ExprKind::AddrOf(_, ref arr) = args[0].node;\n-        if let ExprKind::Array(ref pieces) = arr.node;\n+        if let ExprKind::AddrOf(_, ref arr) = args[0].kind;\n+        if let ExprKind::Array(ref pieces) = arr.kind;\n         if pieces.len() == 1;\n-        if let ExprKind::Lit(ref lit) = pieces[0].node;\n+        if let ExprKind::Lit(ref lit) = pieces[0].kind;\n         if let LitKind::Str(..) = lit.node;\n         // Argument 2 in `new_v1_formatted()`\n-        if let ExprKind::AddrOf(_, ref arg1) = args[1].node;\n-        if let ExprKind::Match(ref matchee, ref arms, MatchSource::Normal) = arg1.node;\n+        if let ExprKind::AddrOf(_, ref arg1) = args[1].kind;\n+        if let ExprKind::Match(ref matchee, ref arms, MatchSource::Normal) = arg1.kind;\n         if arms.len() == 1;\n-        if let ExprKind::Tup(ref tup) = matchee.node;\n+        if let ExprKind::Tup(ref tup) = matchee.kind;\n         then {\n             return on_argumentv1_new(cx, &tup[0], arms);\n         }\n@@ -181,19 +181,19 @@ fn on_new_v1_fmt<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> Opti\n /// ```\n fn check_unformatted(expr: &Expr) -> bool {\n     if_chain! {\n-        if let ExprKind::AddrOf(_, ref expr) = expr.node;\n-        if let ExprKind::Array(ref exprs) = expr.node;\n+        if let ExprKind::AddrOf(_, ref expr) = expr.kind;\n+        if let ExprKind::Array(ref exprs) = expr.kind;\n         if exprs.len() == 1;\n         // struct `core::fmt::rt::v1::Argument`\n-        if let ExprKind::Struct(_, ref fields, _) = exprs[0].node;\n+        if let ExprKind::Struct(_, ref fields, _) = exprs[0].kind;\n         if let Some(format_field) = fields.iter().find(|f| f.ident.name == sym!(format));\n         // struct `core::fmt::rt::v1::FormatSpec`\n-        if let ExprKind::Struct(_, ref fields, _) = format_field.expr.node;\n+        if let ExprKind::Struct(_, ref fields, _) = format_field.expr.kind;\n         if let Some(precision_field) = fields.iter().find(|f| f.ident.name == sym!(precision));\n-        if let ExprKind::Path(ref precision_path) = precision_field.expr.node;\n+        if let ExprKind::Path(ref precision_path) = precision_field.expr.kind;\n         if last_path_segment(precision_path).ident.name == sym!(Implied);\n         if let Some(width_field) = fields.iter().find(|f| f.ident.name == sym!(width));\n-        if let ExprKind::Path(ref width_qpath) = width_field.expr.node;\n+        if let ExprKind::Path(ref width_qpath) = width_field.expr.kind;\n         if last_path_segment(width_qpath).ident.name == sym!(Implied);\n         then {\n             return true;"}, {"sha": "52ebaa4af7d0e9f7d9bfd70c2d17c75255d06a8b", "filename": "clippy_lints/src/formatting.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformatting.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -87,7 +87,7 @@ declare_lint_pass!(Formatting => [\n impl EarlyLintPass for Formatting {\n     fn check_block(&mut self, cx: &EarlyContext<'_>, block: &Block) {\n         for w in block.stmts.windows(2) {\n-            match (&w[0].node, &w[1].node) {\n+            match (&w[0].kind, &w[1].kind) {\n                 (&StmtKind::Expr(ref first), &StmtKind::Expr(ref second))\n                 | (&StmtKind::Expr(ref first), &StmtKind::Semi(ref second)) => {\n                     check_missing_else(cx, first, second);\n@@ -106,10 +106,10 @@ impl EarlyLintPass for Formatting {\n \n /// Implementation of the `SUSPICIOUS_ASSIGNMENT_FORMATTING` lint.\n fn check_assign(cx: &EarlyContext<'_>, expr: &Expr) {\n-    if let ExprKind::Assign(ref lhs, ref rhs) = expr.node {\n+    if let ExprKind::Assign(ref lhs, ref rhs) = expr.kind {\n         if !differing_macro_contexts(lhs.span, rhs.span) && !lhs.span.from_expansion() {\n             let eq_span = lhs.span.between(rhs.span);\n-            if let ExprKind::Unary(op, ref sub_rhs) = rhs.node {\n+            if let ExprKind::Unary(op, ref sub_rhs) = rhs.kind {\n                 if let Some(eq_snippet) = snippet_opt(cx, eq_span) {\n                     let op = UnOp::to_string(op);\n                     let eqop_span = lhs.span.between(sub_rhs.span);\n@@ -136,7 +136,7 @@ fn check_assign(cx: &EarlyContext<'_>, expr: &Expr) {\n /// Implementation of the `SUSPICIOUS_ELSE_FORMATTING` lint for weird `else`.\n fn check_else(cx: &EarlyContext<'_>, expr: &Expr) {\n     if_chain! {\n-        if let ExprKind::If(_, then, Some(else_)) = &expr.node;\n+        if let ExprKind::If(_, then, Some(else_)) = &expr.kind;\n         if is_block(else_) || is_if(else_);\n         if !differing_macro_contexts(then.span, else_.span);\n         if !then.span.from_expansion() && !in_external_macro(cx.sess, expr.span);\n@@ -179,9 +179,9 @@ fn has_unary_equivalent(bin_op: BinOpKind) -> bool {\n \n /// Implementation of the `POSSIBLE_MISSING_COMMA` lint for array\n fn check_array(cx: &EarlyContext<'_>, expr: &Expr) {\n-    if let ExprKind::Array(ref array) = expr.node {\n+    if let ExprKind::Array(ref array) = expr.kind {\n         for element in array {\n-            if let ExprKind::Binary(ref op, ref lhs, _) = element.node {\n+            if let ExprKind::Binary(ref op, ref lhs, _) = element.kind {\n                 if has_unary_equivalent(op.node) && !differing_macro_contexts(lhs.span, op.span) {\n                     let space_span = lhs.span.between(op.span);\n                     if let Some(space_snippet) = snippet_opt(cx, space_span) {\n@@ -237,7 +237,7 @@ fn check_missing_else(cx: &EarlyContext<'_>, first: &Expr, second: &Expr) {\n }\n \n fn is_block(expr: &Expr) -> bool {\n-    if let ExprKind::Block(..) = expr.node {\n+    if let ExprKind::Block(..) = expr.kind {\n         true\n     } else {\n         false\n@@ -246,7 +246,7 @@ fn is_block(expr: &Expr) -> bool {\n \n /// Check if the expression is an `if` or `if let`\n fn is_if(expr: &Expr) -> bool {\n-    if let ExprKind::If(..) = expr.node {\n+    if let ExprKind::If(..) = expr.kind {\n         true\n     } else {\n         false"}, {"sha": "7b6c8c7cea6d94d19fa6c9103fd832be3915cae7", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -109,7 +109,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n         hir_id: hir::HirId,\n     ) {\n         let is_impl = if let Some(hir::Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(hir_id)) {\n-            matches!(item.node, hir::ItemKind::Impl(_, _, _, _, Some(_), _, _))\n+            matches!(item.kind, hir::ItemKind::Impl(_, _, _, _, Some(_), _, _))\n         } else {\n             false\n         };\n@@ -145,7 +145,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::TraitItem) {\n-        if let hir::TraitItemKind::Method(ref sig, ref eid) = item.node {\n+        if let hir::TraitItemKind::Method(ref sig, ref eid) = item.kind {\n             // don't lint extern functions decls, it's not their fault\n             if sig.header.abi == Abi::Rust {\n                 self.check_arg_number(cx, &sig.decl, item.span);\n@@ -269,7 +269,7 @@ impl<'a, 'tcx> Functions {\n }\n \n fn raw_ptr_arg(arg: &hir::Param, ty: &hir::Ty) -> Option<hir::HirId> {\n-    if let (&hir::PatKind::Binding(_, id, _, _), &hir::TyKind::Ptr(_)) = (&arg.pat.node, &ty.node) {\n+    if let (&hir::PatKind::Binding(_, id, _, _), &hir::TyKind::Ptr(_)) = (&arg.pat.kind, &ty.kind) {\n         Some(id)\n     } else {\n         None\n@@ -284,7 +284,7 @@ struct DerefVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        match expr.node {\n+        match expr.kind {\n             hir::ExprKind::Call(ref f, ref args) => {\n                 let ty = self.tables.expr_ty(f);\n \n@@ -317,7 +317,7 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> DerefVisitor<'a, 'tcx> {\n     fn check_arg(&self, ptr: &hir::Expr) {\n-        if let hir::ExprKind::Path(ref qpath) = ptr.node {\n+        if let hir::ExprKind::Path(ref qpath) = ptr.kind {\n             if let Res::Local(id) = qpath_res(self.cx, qpath, ptr.hir_id) {\n                 if self.ptrs.contains(&id) {\n                     span_lint("}, {"sha": "9910fa8820a1b8aba496f595ec4d279bb472ce5c", "filename": "clippy_lints/src/get_last_with_len.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fget_last_with_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fget_last_with_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fget_last_with_len.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -48,7 +48,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for GetLastWithLen {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n             // Is a method call\n-            if let ExprKind::MethodCall(ref path, _, ref args) = expr.node;\n+            if let ExprKind::MethodCall(ref path, _, ref args) = expr.kind;\n \n             // Method name is \"get\"\n             if path.ident.name == Symbol::intern(\"get\");\n@@ -67,18 +67,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for GetLastWithLen {\n                 },\n                 lhs,\n                 rhs,\n-            ) = &get_index_arg.node;\n+            ) = &get_index_arg.kind;\n \n             // LHS of subtraction is \"x.len()\"\n-            if let ExprKind::MethodCall(arg_lhs_path, _, lhs_args) = &lhs.node;\n+            if let ExprKind::MethodCall(arg_lhs_path, _, lhs_args) = &lhs.kind;\n             if arg_lhs_path.ident.name == Symbol::intern(\"len\");\n             if let Some(arg_lhs_struct) = lhs_args.get(0);\n \n             // The two vectors referenced (x in x.get(...) and in x.len())\n             if SpanlessEq::new(cx).eq_expr(struct_calling_on, arg_lhs_struct);\n \n             // RHS of subtraction is 1\n-            if let ExprKind::Lit(rhs_lit) = &rhs.node;\n+            if let ExprKind::Lit(rhs_lit) = &rhs.kind;\n             if let LitKind::Int(rhs_value, ..) = rhs_lit.node;\n             if rhs_value == 1;\n "}, {"sha": "685c1a4caca0656344f960d327691621fb19aa97", "filename": "clippy_lints/src/identity_conversion.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fidentity_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fidentity_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_conversion.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -41,13 +41,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityConversion {\n             return;\n         }\n \n-        match e.node {\n+        match e.kind {\n             ExprKind::Match(_, ref arms, MatchSource::TryDesugar) => {\n-                let e = match arms[0].body.node {\n+                let e = match arms[0].body.kind {\n                     ExprKind::Ret(Some(ref e)) | ExprKind::Break(_, Some(ref e)) => e,\n                     _ => return,\n                 };\n-                if let ExprKind::Call(_, ref args) = e.node {\n+                if let ExprKind::Call(_, ref args) = e.kind {\n                     self.try_desugar_arm.push(args[0].hir_id);\n                 }\n             },\n@@ -87,7 +87,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityConversion {\n             },\n \n             ExprKind::Call(ref path, ref args) => {\n-                if let ExprKind::Path(ref qpath) = path.node {\n+                if let ExprKind::Path(ref qpath) = path.kind {\n                     if let Some(def_id) = resolve_node(cx, qpath, path.hir_id).opt_def_id() {\n                         if match_def_path(cx, def_id, &paths::FROM_FROM) {\n                             let a = cx.tables.expr_ty(e);"}, {"sha": "58f5740bf47cee35fbe714587a8e7771363c4416", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -32,7 +32,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityOp {\n         if e.span.from_expansion() {\n             return;\n         }\n-        if let ExprKind::Binary(ref cmp, ref left, ref right) = e.node {\n+        if let ExprKind::Binary(ref cmp, ref left, ref right) = e.kind {\n             match cmp.node {\n                 BinOpKind::Add | BinOpKind::BitOr | BinOpKind::BitXor => {\n                     check(cx, left, 0, e.span, right.span);"}, {"sha": "74f98d6342fa238ce5033fce548c5636881be582", "filename": "clippy_lints/src/if_not_else.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fif_not_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fif_not_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_not_else.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -51,9 +51,9 @@ impl EarlyLintPass for IfNotElse {\n         if in_external_macro(cx.sess(), item.span) {\n             return;\n         }\n-        if let ExprKind::If(ref cond, _, Some(ref els)) = item.node {\n-            if let ExprKind::Block(..) = els.node {\n-                match cond.node {\n+        if let ExprKind::If(ref cond, _, Some(ref els)) = item.kind {\n+            if let ExprKind::Block(..) = els.kind {\n+                match cond.kind {\n                     ExprKind::Unary(UnOp::Not, _) => {\n                         span_help_and_lint(\n                             cx,"}, {"sha": "722dccf013d5b8d08dd5693781f668820b11fdca", "filename": "clippy_lints/src/implicit_return.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_return.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -62,7 +62,7 @@ fn lint(cx: &LateContext<'_, '_>, outer_span: Span, inner_span: Span, msg: &str)\n }\n \n fn expr_match(cx: &LateContext<'_, '_>, expr: &Expr) {\n-    match &expr.node {\n+    match &expr.kind {\n         // loops could be using `break` instead of `return`\n         ExprKind::Block(block, ..) | ExprKind::Loop(block, ..) => {\n             if let Some(expr) = &block.expr {\n@@ -71,9 +71,9 @@ fn expr_match(cx: &LateContext<'_, '_>, expr: &Expr) {\n             // only needed in the case of `break` with `;` at the end\n             else if let Some(stmt) = block.stmts.last() {\n                 if_chain! {\n-                    if let StmtKind::Semi(expr, ..) = &stmt.node;\n+                    if let StmtKind::Semi(expr, ..) = &stmt.kind;\n                     // make sure it's a break, otherwise we want to skip\n-                    if let ExprKind::Break(.., break_expr) = &expr.node;\n+                    if let ExprKind::Break(.., break_expr) = &expr.kind;\n                     if let Some(break_expr) = break_expr;\n                     then {\n                             lint(cx, expr.span, break_expr.span, LINT_BREAK);\n@@ -108,7 +108,7 @@ fn expr_match(cx: &LateContext<'_, '_>, expr: &Expr) {\n         // make sure it's not a call that panics\n         ExprKind::Call(expr, ..) => {\n             if_chain! {\n-                if let ExprKind::Path(qpath) = &expr.node;\n+                if let ExprKind::Path(qpath) = &expr.kind;\n                 if let Some(path_def_id) = resolve_node(cx, qpath, expr.hir_id).opt_def_id();\n                 if match_def_path(cx, path_def_id, &BEGIN_PANIC) ||\n                     match_def_path(cx, path_def_id, &BEGIN_PANIC_FMT);"}, {"sha": "a2dbd09d8df4342c90779ea95e949e228fd66c74", "filename": "clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Findexing_slicing.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -89,7 +89,7 @@ declare_lint_pass!(IndexingSlicing => [INDEXING_SLICING, OUT_OF_BOUNDS_INDEXING]\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IndexingSlicing {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprKind::Index(ref array, ref index) = &expr.node {\n+        if let ExprKind::Index(ref array, ref index) = &expr.kind {\n             let ty = cx.tables.expr_ty(array);\n             if let Some(range) = higher::range(cx, index) {\n                 // Ranged indexes, i.e., &x[n..m], &x[n..], &x[..n] and &x[..]"}, {"sha": "015251a4feb039897737342d7d2a27b2de1a396f", "filename": "clippy_lints/src/infallible_destructuring_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -46,9 +46,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InfallibleDestructingMatch {\n     fn check_local(&mut self, cx: &LateContext<'a, 'tcx>, local: &'tcx Local) {\n         if_chain! {\n             if let Some(ref expr) = local.init;\n-            if let ExprKind::Match(ref target, ref arms, MatchSource::Normal) = expr.node;\n+            if let ExprKind::Match(ref target, ref arms, MatchSource::Normal) = expr.kind;\n             if arms.len() == 1 && arms[0].guard.is_none();\n-            if let PatKind::TupleStruct(QPath::Resolved(None, ref variant_name), ref args, _) = arms[0].pat.node;\n+            if let PatKind::TupleStruct(QPath::Resolved(None, ref variant_name), ref args, _) = arms[0].pat.kind;\n             if args.len() == 1;\n             if let Some(arg) = get_arg_name(&args[0]);\n             let body = remove_blocks(&arms[0].body);"}, {"sha": "adda6ae0c1133a06b357615ba9d2e660798c1d8c", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -138,7 +138,7 @@ const HEURISTICS: [(&str, usize, Heuristic, Finiteness); 19] = [\n ];\n \n fn is_infinite(cx: &LateContext<'_, '_>, expr: &Expr) -> Finiteness {\n-    match expr.node {\n+    match expr.kind {\n         ExprKind::MethodCall(ref method, _, ref args) => {\n             for &(name, len, heuristic, cap) in &HEURISTICS {\n                 if method.ident.name.as_str() == name && args.len() == len {\n@@ -152,7 +152,7 @@ fn is_infinite(cx: &LateContext<'_, '_>, expr: &Expr) -> Finiteness {\n                 }\n             }\n             if method.ident.name == sym!(flat_map) && args.len() == 2 {\n-                if let ExprKind::Closure(_, _, body_id, _, _) = args[1].node {\n+                if let ExprKind::Closure(_, _, body_id, _, _) = args[1].kind {\n                     let body = cx.tcx.hir().body(body_id);\n                     return is_infinite(cx, &body.value);\n                 }\n@@ -162,7 +162,7 @@ fn is_infinite(cx: &LateContext<'_, '_>, expr: &Expr) -> Finiteness {\n         ExprKind::Block(ref block, _) => block.expr.as_ref().map_or(Finite, |e| is_infinite(cx, e)),\n         ExprKind::Box(ref e) | ExprKind::AddrOf(_, ref e) => is_infinite(cx, e),\n         ExprKind::Call(ref path, _) => {\n-            if let ExprKind::Path(ref qpath) = path.node {\n+            if let ExprKind::Path(ref qpath) = path.kind {\n                 match_qpath(qpath, &paths::REPEAT).into()\n             } else {\n                 Finite\n@@ -214,7 +214,7 @@ const INFINITE_COLLECTORS: [&[&str]; 8] = [\n ];\n \n fn complete_infinite_iter(cx: &LateContext<'_, '_>, expr: &Expr) -> Finiteness {\n-    match expr.node {\n+    match expr.kind {\n         ExprKind::MethodCall(ref method, _, ref args) => {\n             for &(name, len) in &COMPLETING_METHODS {\n                 if method.ident.name.as_str() == name && args.len() == len {"}, {"sha": "0eaff14b7bd35d00832625c3d528e1b08ea77775", "filename": "clippy_lints/src/inherent_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Finherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Finherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finherent_impl.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -49,7 +49,7 @@ impl_lint_pass!(MultipleInherentImpl => [MULTIPLE_INHERENT_IMPL]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MultipleInherentImpl {\n     fn check_item(&mut self, _: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if let ItemKind::Impl(_, _, _, ref generics, None, _, _) = item.node {\n+        if let ItemKind::Impl(_, _, _, ref generics, None, _, _) = item.kind {\n             // Remember for each inherent implementation encoutered its span and generics\n             // but filter out implementations that have generic params (type or lifetime)\n             if generics.params.len() == 0 {"}, {"sha": "b92a99488f9de80ed4f95fb70e431d7d21c01b50", "filename": "clippy_lints/src/inherent_to_string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Finherent_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Finherent_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finherent_to_string.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -100,7 +100,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InherentToString {\n \n         if_chain! {\n             // Check if item is a method, called to_string and has a parameter 'self'\n-            if let ImplItemKind::Method(ref signature, _) = impl_item.node;\n+            if let ImplItemKind::Method(ref signature, _) = impl_item.kind;\n             if impl_item.ident.name.as_str() == \"to_string\";\n             let decl = &signature.decl;\n             if decl.implicit_self.has_implicit_self();"}, {"sha": "8c848f697c97b2bacb9cf468e48354976e72579f", "filename": "clippy_lints/src/inline_fn_without_body.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Finline_fn_without_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Finline_fn_without_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finline_fn_without_body.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -32,7 +32,7 @@ declare_lint_pass!(InlineFnWithoutBody => [INLINE_FN_WITHOUT_BODY]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InlineFnWithoutBody {\n     fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n-        if let TraitItemKind::Method(_, TraitMethod::Required(_)) = item.node {\n+        if let TraitItemKind::Method(_, TraitMethod::Required(_)) = item.kind {\n             check_attrs(cx, item.ident.name, &item.attrs);\n         }\n     }"}, {"sha": "4d588f253e89e1c9de8db4190488a10a7fe58edc", "filename": "clippy_lints/src/int_plus_one.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fint_plus_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fint_plus_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fint_plus_one.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -54,17 +54,17 @@ enum Side {\n impl IntPlusOne {\n     #[allow(clippy::cast_sign_loss)]\n     fn check_lit(self, lit: &Lit, target_value: i128) -> bool {\n-        if let LitKind::Int(value, ..) = lit.node {\n+        if let LitKind::Int(value, ..) = lit.kind {\n             return value == (target_value as u128);\n         }\n         false\n     }\n \n     fn check_binop(self, cx: &EarlyContext<'_>, binop: BinOpKind, lhs: &Expr, rhs: &Expr) -> Option<String> {\n-        match (binop, &lhs.node, &rhs.node) {\n+        match (binop, &lhs.kind, &rhs.kind) {\n             // case where `x - 1 >= ...` or `-1 + x >= ...`\n             (BinOpKind::Ge, &ExprKind::Binary(ref lhskind, ref lhslhs, ref lhsrhs), _) => {\n-                match (lhskind.node, &lhslhs.node, &lhsrhs.node) {\n+                match (lhskind.node, &lhslhs.kind, &lhsrhs.kind) {\n                     // `-1 + x`\n                     (BinOpKind::Add, &ExprKind::Lit(ref lit), _) if self.check_lit(lit, -1) => {\n                         self.generate_recommendation(cx, binop, lhsrhs, rhs, Side::LHS)\n@@ -80,7 +80,7 @@ impl IntPlusOne {\n             (BinOpKind::Ge, _, &ExprKind::Binary(ref rhskind, ref rhslhs, ref rhsrhs))\n                 if rhskind.node == BinOpKind::Add =>\n             {\n-                match (&rhslhs.node, &rhsrhs.node) {\n+                match (&rhslhs.kind, &rhsrhs.kind) {\n                     // `y + 1` and `1 + y`\n                     (&ExprKind::Lit(ref lit), _) if self.check_lit(lit, 1) => {\n                         self.generate_recommendation(cx, binop, rhsrhs, lhs, Side::RHS)\n@@ -95,7 +95,7 @@ impl IntPlusOne {\n             (BinOpKind::Le, &ExprKind::Binary(ref lhskind, ref lhslhs, ref lhsrhs), _)\n                 if lhskind.node == BinOpKind::Add =>\n             {\n-                match (&lhslhs.node, &lhsrhs.node) {\n+                match (&lhslhs.kind, &lhsrhs.kind) {\n                     // `1 + x` and `x + 1`\n                     (&ExprKind::Lit(ref lit), _) if self.check_lit(lit, 1) => {\n                         self.generate_recommendation(cx, binop, lhsrhs, rhs, Side::LHS)\n@@ -108,7 +108,7 @@ impl IntPlusOne {\n             }\n             // case where `... >= y - 1` or `... >= -1 + y`\n             (BinOpKind::Le, _, &ExprKind::Binary(ref rhskind, ref rhslhs, ref rhsrhs)) => {\n-                match (rhskind.node, &rhslhs.node, &rhsrhs.node) {\n+                match (rhskind.node, &rhslhs.kind, &rhsrhs.kind) {\n                     // `-1 + y`\n                     (BinOpKind::Add, &ExprKind::Lit(ref lit), _) if self.check_lit(lit, -1) => {\n                         self.generate_recommendation(cx, binop, rhsrhs, lhs, Side::RHS)\n@@ -169,7 +169,7 @@ impl IntPlusOne {\n \n impl EarlyLintPass for IntPlusOne {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, item: &Expr) {\n-        if let ExprKind::Binary(ref kind, ref lhs, ref rhs) = item.node {\n+        if let ExprKind::Binary(ref kind, ref lhs, ref rhs) = item.kind {\n             if let Some(ref rec) = self.check_binop(cx, kind.node, lhs, rhs) {\n                 self.emit_warning(cx, item, rec.clone());\n             }"}, {"sha": "efdd1b6a7a9c88d2ab55e75826d7845088e8c5f1", "filename": "clippy_lints/src/integer_division.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Finteger_division.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Finteger_division.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finteger_division.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -43,7 +43,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IntegerDivision {\n \n fn is_integer_division<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) -> bool {\n     if_chain! {\n-        if let hir::ExprKind::Binary(binop, left, right) = &expr.node;\n+        if let hir::ExprKind::Binary(binop, left, right) = &expr.kind;\n         if let hir::BinOpKind::Div = &binop.node;\n         then {\n             let (left_ty, right_ty) = (cx.tables.expr_ty(left), cx.tables.expr_ty(right));"}, {"sha": "a0a7e58ac2d5b2f50451a2ec95ac548599ccf124", "filename": "clippy_lints/src/items_after_statements.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fitems_after_statements.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -46,7 +46,7 @@ impl EarlyLintPass for ItemsAfterStatements {\n         let stmts = item\n             .stmts\n             .iter()\n-            .map(|stmt| &stmt.node)\n+            .map(|stmt| &stmt.kind)\n             .skip_while(|s| matches!(**s, StmtKind::Item(..)));\n \n         // lint on all further items\n@@ -55,7 +55,7 @@ impl EarlyLintPass for ItemsAfterStatements {\n                 if it.span.from_expansion() {\n                     return;\n                 }\n-                if let ItemKind::MacroDef(..) = it.node {\n+                if let ItemKind::MacroDef(..) = it.kind {\n                     // do not lint `macro_rules`, but continue processing further statements\n                     continue;\n                 }"}, {"sha": "d5c1318f67767eeabd65638da4a6dabc0f9e4574", "filename": "clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -47,7 +47,7 @@ impl_lint_pass!(LargeEnumVariant => [LARGE_ENUM_VARIANT]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LargeEnumVariant {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &Item) {\n         let did = cx.tcx.hir().local_def_id(item.hir_id);\n-        if let ItemKind::Enum(ref def, _) = item.node {\n+        if let ItemKind::Enum(ref def, _) = item.kind {\n             let ty = cx.tcx.type_of(did);\n             let adt = ty.ty_adt_def().expect(\"already checked whether this is an enum\");\n "}, {"sha": "df4aacf75e18a4b85078c422948b86a552553b63", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -77,7 +77,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LenZero {\n             return;\n         }\n \n-        match item.node {\n+        match item.kind {\n             ItemKind::Trait(_, _, _, _, ref trait_items) => check_trait_items(cx, item, trait_items),\n             ItemKind::Impl(_, _, _, _, None, _, ref impl_items) => check_impl_items(cx, item, impl_items),\n             _ => (),\n@@ -89,7 +89,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LenZero {\n             return;\n         }\n \n-        if let ExprKind::Binary(Spanned { node: cmp, .. }, ref left, ref right) = expr.node {\n+        if let ExprKind::Binary(Spanned { node: cmp, .. }, ref left, ref right) = expr.kind {\n             match cmp {\n                 BinOpKind::Eq => {\n                     check_cmp(cx, expr.span, left, right, \"\", 0); // len == 0\n@@ -208,7 +208,7 @@ fn check_impl_items(cx: &LateContext<'_, '_>, item: &Item, impl_items: &[ImplIte\n }\n \n fn check_cmp(cx: &LateContext<'_, '_>, span: Span, method: &Expr, lit: &Expr, op: &str, compare_to: u32) {\n-    if let (&ExprKind::MethodCall(ref method_path, _, ref args), &ExprKind::Lit(ref lit)) = (&method.node, &lit.node) {\n+    if let (&ExprKind::MethodCall(ref method_path, _, ref args), &ExprKind::Lit(ref lit)) = (&method.kind, &lit.kind) {\n         // check if we are in an is_empty() method\n         if let Some(name) = get_item_name(cx, method) {\n             if name.as_str() == \"is_empty\" {"}, {"sha": "541c25ae605078d6ce1e32482d1ca86a35f0422a", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -60,12 +60,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetIfSeq {\n         while let Some(stmt) = it.next() {\n             if_chain! {\n                 if let Some(expr) = it.peek();\n-                if let hir::StmtKind::Local(ref local) = stmt.node;\n-                if let hir::PatKind::Binding(mode, canonical_id, ident, None) = local.pat.node;\n-                if let hir::StmtKind::Expr(ref if_) = expr.node;\n+                if let hir::StmtKind::Local(ref local) = stmt.kind;\n+                if let hir::PatKind::Binding(mode, canonical_id, ident, None) = local.pat.kind;\n+                if let hir::StmtKind::Expr(ref if_) = expr.kind;\n                 if let Some((ref cond, ref then, ref else_)) = higher::if_block(&if_);\n                 if !used_in_expr(cx, canonical_id, cond);\n-                if let hir::ExprKind::Block(ref then, _) = then.node;\n+                if let hir::ExprKind::Block(ref then, _) = then.kind;\n                 if let Some(value) = check_assign(cx, canonical_id, &*then);\n                 if !used_in_expr(cx, canonical_id, value);\n                 then {\n@@ -79,7 +79,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetIfSeq {\n                     if has_interior_mutability { return; }\n \n                     let (default_multi_stmts, default) = if let Some(ref else_) = *else_ {\n-                        if let hir::ExprKind::Block(ref else_, _) = else_.node {\n+                        if let hir::ExprKind::Block(ref else_, _) = else_.kind {\n                             if let Some(default) = check_assign(cx, canonical_id, else_) {\n                                 (else_.stmts.len() > 1, default)\n                             } else if let Some(ref default) = local.init {\n@@ -144,7 +144,7 @@ struct UsedVisitor<'a, 'tcx> {\n impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UsedVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         if_chain! {\n-            if let hir::ExprKind::Path(ref qpath) = expr.node;\n+            if let hir::ExprKind::Path(ref qpath) = expr.kind;\n             if let Res::Local(local_id) = qpath_res(self.cx, qpath, expr.hir_id);\n             if self.id == local_id;\n             then {\n@@ -167,9 +167,9 @@ fn check_assign<'a, 'tcx>(\n     if_chain! {\n         if block.expr.is_none();\n         if let Some(expr) = block.stmts.iter().last();\n-        if let hir::StmtKind::Semi(ref expr) = expr.node;\n-        if let hir::ExprKind::Assign(ref var, ref value) = expr.node;\n-        if let hir::ExprKind::Path(ref qpath) = var.node;\n+        if let hir::StmtKind::Semi(ref expr) = expr.kind;\n+        if let hir::ExprKind::Assign(ref var, ref value) = expr.kind;\n+        if let hir::ExprKind::Path(ref qpath) = var.kind;\n         if let Res::Local(local_id) = qpath_res(cx, qpath, var.hir_id);\n         if decl == local_id;\n         then {"}, {"sha": "88d393c84ee60d8698d55b208d268c9f7cd77bab", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -59,13 +59,13 @@ declare_lint_pass!(Lifetimes => [NEEDLESS_LIFETIMES, EXTRA_UNUSED_LIFETIMES]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Lifetimes {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if let ItemKind::Fn(ref decl, _, ref generics, id) = item.node {\n+        if let ItemKind::Fn(ref decl, _, ref generics, id) = item.kind {\n             check_fn_inner(cx, decl, Some(id), generics, item.span, true);\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n-        if let ImplItemKind::Method(ref sig, id) = item.node {\n+        if let ImplItemKind::Method(ref sig, id) = item.kind {\n             let report_extra_lifetimes = trait_ref_of_method(cx, item.hir_id).is_none();\n             check_fn_inner(\n                 cx,\n@@ -79,7 +79,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Lifetimes {\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n-        if let TraitItemKind::Method(ref sig, ref body) = item.node {\n+        if let TraitItemKind::Method(ref sig, ref body) = item.kind {\n             let body = match *body {\n                 TraitMethod::Required(_) => None,\n                 TraitMethod::Provided(id) => Some(id),\n@@ -350,7 +350,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, ty: &'tcx Ty) {\n-        match ty.node {\n+        match ty.kind {\n             TyKind::Rptr(ref lt, _) if lt.is_elided() => {\n                 self.record(&None);\n             },\n@@ -359,7 +359,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n             },\n             TyKind::Def(item, _) => {\n                 let map = self.cx.tcx.hir();\n-                if let ItemKind::OpaqueTy(ref exist_ty) = map.expect_item(item.id).node {\n+                if let ItemKind::OpaqueTy(ref exist_ty) = map.expect_item(item.id).kind {\n                     for bound in &exist_ty.bounds {\n                         if let GenericBound::Outlives(_) = *bound {\n                             self.record(&None);"}, {"sha": "65a266b2eafe37214e07eea0e72c7c28a6d5e537", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -347,7 +347,7 @@ impl EarlyLintPass for LiteralDigitGrouping {\n             return;\n         }\n \n-        if let ExprKind::Lit(ref lit) = expr.node {\n+        if let ExprKind::Lit(ref lit) = expr.kind {\n             self.check_lit(cx, lit)\n         }\n     }\n@@ -356,7 +356,7 @@ impl EarlyLintPass for LiteralDigitGrouping {\n impl LiteralDigitGrouping {\n     fn check_lit(self, cx: &EarlyContext<'_>, lit: &Lit) {\n         let in_macro = in_macro(lit.span);\n-        match lit.node {\n+        match lit.kind {\n             LitKind::Int(..) => {\n                 // Lint integral literals.\n                 if_chain! {\n@@ -492,7 +492,7 @@ impl EarlyLintPass for DecimalLiteralRepresentation {\n             return;\n         }\n \n-        if let ExprKind::Lit(ref lit) = expr.node {\n+        if let ExprKind::Lit(ref lit) = expr.kind {\n             self.check_lit(cx, lit)\n         }\n     }\n@@ -505,7 +505,7 @@ impl DecimalLiteralRepresentation {\n     fn check_lit(self, cx: &EarlyContext<'_>, lit: &Lit) {\n         // Lint integral literals.\n         if_chain! {\n-            if let LitKind::Int(..) = lit.node;\n+            if let LitKind::Int(..) = lit.kind;\n             if let Some(src) = snippet_opt(cx, lit.span);\n             if let Some(firstch) = src.chars().next();\n             if char::to_digit(firstch, 10).is_some();"}, {"sha": "9629f94c75d2a32e52c8da4582710732f389266b", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -486,7 +486,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Loops {\n         }\n \n         // check for never_loop\n-        if let ExprKind::Loop(ref block, _, _) = expr.node {\n+        if let ExprKind::Loop(ref block, _, _) = expr.kind {\n             match never_loop_block(block, expr.hir_id) {\n                 NeverLoopResult::AlwaysBreak => span_lint(cx, NEVER_LOOP, expr.span, \"this loop never actually loops\"),\n                 NeverLoopResult::MayContinueMainLoop | NeverLoopResult::Otherwise => (),\n@@ -496,7 +496,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Loops {\n         // check for `loop { if let {} else break }` that could be `while let`\n         // (also matches an explicit \"match\" instead of \"if let\")\n         // (even if the \"match\" or \"if let\" is used for declaration)\n-        if let ExprKind::Loop(ref block, _, LoopSource::Loop) = expr.node {\n+        if let ExprKind::Loop(ref block, _, LoopSource::Loop) = expr.kind {\n             // also check for empty `loop {}` statements\n             if block.stmts.is_empty() && block.expr.is_none() {\n                 span_lint(\n@@ -512,7 +512,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Loops {\n             let inner_stmt_expr = extract_expr_from_first_stmt(block);\n             // or extract the first expression (if any) from the block\n             if let Some(inner) = inner_stmt_expr.or_else(|| extract_first_expr(block)) {\n-                if let ExprKind::Match(ref matchexpr, ref arms, ref source) = inner.node {\n+                if let ExprKind::Match(ref matchexpr, ref arms, ref source) = inner.kind {\n                     // ensure \"if let\" compatible match structure\n                     match *source {\n                         MatchSource::Normal | MatchSource::IfLetDesugar { .. } => {\n@@ -551,12 +551,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Loops {\n                 }\n             }\n         }\n-        if let ExprKind::Match(ref match_expr, ref arms, MatchSource::WhileLetDesugar) = expr.node {\n-            let pat = &arms[0].pat.node;\n+        if let ExprKind::Match(ref match_expr, ref arms, MatchSource::WhileLetDesugar) = expr.kind {\n+            let pat = &arms[0].pat.kind;\n             if let (\n                 &PatKind::TupleStruct(ref qpath, ref pat_args, _),\n                 &ExprKind::MethodCall(ref method_path, _, ref method_args),\n-            ) = (pat, &match_expr.node)\n+            ) = (pat, &match_expr.kind)\n             {\n                 let iter_expr = &method_args[0];\n                 let lhs_constructor = last_path_segment(qpath);\n@@ -649,15 +649,15 @@ fn never_loop_block(block: &Block, main_loop_id: HirId) -> NeverLoopResult {\n }\n \n fn stmt_to_expr(stmt: &Stmt) -> Option<&Expr> {\n-    match stmt.node {\n+    match stmt.kind {\n         StmtKind::Semi(ref e, ..) | StmtKind::Expr(ref e, ..) => Some(e),\n         StmtKind::Local(ref local) => local.init.as_ref().map(|p| &**p),\n         _ => None,\n     }\n }\n \n fn never_loop_expr(expr: &Expr, main_loop_id: HirId) -> NeverLoopResult {\n-    match expr.node {\n+    match expr.kind {\n         ExprKind::Box(ref e)\n         | ExprKind::Unary(_, ref e)\n         | ExprKind::Cast(ref e, _)\n@@ -749,7 +749,7 @@ fn check_for_loop<'a, 'tcx>(\n \n fn same_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var: HirId) -> bool {\n     if_chain! {\n-        if let ExprKind::Path(ref qpath) = expr.node;\n+        if let ExprKind::Path(ref qpath) = expr.kind;\n         if let QPath::Resolved(None, ref path) = *qpath;\n         if path.segments.len() == 1;\n         if let Res::Local(local_id) = qpath_res(cx, qpath, expr.hir_id);\n@@ -798,7 +798,7 @@ fn is_slice_like<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'_>) -> bool {\n \n fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var: HirId) -> Option<FixedOffsetVar> {\n     fn extract_offset<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, e: &Expr, var: HirId) -> Option<String> {\n-        match e.node {\n+        match e.kind {\n             ExprKind::Lit(ref l) => match l.node {\n                 ast::LitKind::Int(x, _ty) => Some(x.to_string()),\n                 _ => None,\n@@ -808,13 +808,13 @@ fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var:\n         }\n     }\n \n-    if let ExprKind::Index(ref seqexpr, ref idx) = expr.node {\n+    if let ExprKind::Index(ref seqexpr, ref idx) = expr.kind {\n         let ty = cx.tables.expr_ty(seqexpr);\n         if !is_slice_like(cx, ty) {\n             return None;\n         }\n \n-        let offset = match idx.node {\n+        let offset = match idx.kind {\n             ExprKind::Binary(op, ref lhs, ref rhs) => match op.node {\n                 BinOpKind::Add => {\n                     let offset_opt = if same_var(cx, lhs, var) {\n@@ -855,7 +855,7 @@ fn fetch_cloned_fixed_offset_var<'a, 'tcx>(\n     var: HirId,\n ) -> Option<FixedOffsetVar> {\n     if_chain! {\n-        if let ExprKind::MethodCall(ref method, _, ref args) = expr.node;\n+        if let ExprKind::MethodCall(ref method, _, ref args) = expr.kind;\n         if method.ident.name == sym!(clone);\n         if args.len() == 1;\n         if let Some(arg) = args.get(0);\n@@ -877,7 +877,7 @@ fn get_indexed_assignments<'a, 'tcx>(\n         e: &Expr,\n         var: HirId,\n     ) -> Option<(FixedOffsetVar, FixedOffsetVar)> {\n-        if let ExprKind::Assign(ref lhs, ref rhs) = e.node {\n+        if let ExprKind::Assign(ref lhs, ref rhs) = e.kind {\n             match (\n                 get_fixed_offset_var(cx, lhs, var),\n                 fetch_cloned_fixed_offset_var(cx, rhs, var),\n@@ -897,14 +897,14 @@ fn get_indexed_assignments<'a, 'tcx>(\n         }\n     }\n \n-    if let ExprKind::Block(ref b, _) = body.node {\n+    if let ExprKind::Block(ref b, _) = body.kind {\n         let Block {\n             ref stmts, ref expr, ..\n         } = **b;\n \n         stmts\n             .iter()\n-            .map(|stmt| match stmt.node {\n+            .map(|stmt| match stmt.kind {\n                 StmtKind::Local(..) | StmtKind::Item(..) => None,\n                 StmtKind::Expr(ref e) | StmtKind::Semi(ref e) => Some(get_assignment(cx, e, var)),\n             })\n@@ -933,7 +933,7 @@ fn detect_manual_memcpy<'a, 'tcx>(\n     }) = higher::range(cx, arg)\n     {\n         // the var must be a single name\n-        if let PatKind::Binding(_, canonical_id, _, _) = pat.node {\n+        if let PatKind::Binding(_, canonical_id, _, _) = pat.kind {\n             let print_sum = |arg1: &Offset, arg2: &Offset| -> String {\n                 match (&arg1.value[..], arg1.negate, &arg2.value[..], arg2.negate) {\n                     (\"0\", _, \"0\", _) => \"\".into(),\n@@ -961,7 +961,7 @@ fn detect_manual_memcpy<'a, 'tcx>(\n             let print_limit = |end: &Option<&Expr>, offset: Offset, var_name: &str| {\n                 if let Some(end) = *end {\n                     if_chain! {\n-                        if let ExprKind::MethodCall(ref method, _, ref len_args) = end.node;\n+                        if let ExprKind::MethodCall(ref method, _, ref len_args) = end.kind;\n                         if method.ident.name == sym!(len);\n                         if len_args.len() == 1;\n                         if let Some(arg) = len_args.get(0);\n@@ -1050,7 +1050,7 @@ fn check_for_loop_range<'a, 'tcx>(\n     }) = higher::range(cx, arg)\n     {\n         // the var must be a single name\n-        if let PatKind::Binding(_, canonical_id, ident, _) = pat.node {\n+        if let PatKind::Binding(_, canonical_id, ident, _) = pat.kind {\n             let mut visitor = VarVisitor {\n                 cx,\n                 var: canonical_id,\n@@ -1107,7 +1107,7 @@ fn check_for_loop_range<'a, 'tcx>(\n                 let take = if let Some(end) = *end {\n                     let mut take_expr = end;\n \n-                    if let ExprKind::Binary(ref op, ref left, ref right) = end.node {\n+                    if let ExprKind::Binary(ref op, ref left, ref right) = end.kind {\n                         if let BinOpKind::Add = op.node {\n                             let start_equal_left = SpanlessEq::new(cx).eq_expr(start, left);\n                             let start_equal_right = SpanlessEq::new(cx).eq_expr(start, right);\n@@ -1202,10 +1202,10 @@ fn check_for_loop_range<'a, 'tcx>(\n \n fn is_len_call(expr: &Expr, var: Name) -> bool {\n     if_chain! {\n-        if let ExprKind::MethodCall(ref method, _, ref len_args) = expr.node;\n+        if let ExprKind::MethodCall(ref method, _, ref len_args) = expr.kind;\n         if len_args.len() == 1;\n         if method.ident.name == sym!(len);\n-        if let ExprKind::Path(QPath::Resolved(_, ref path)) = len_args[0].node;\n+        if let ExprKind::Path(QPath::Resolved(_, ref path)) = len_args[0].kind;\n         if path.segments.len() == 1;\n         if path.segments[0].ident.name == var;\n         then {\n@@ -1223,7 +1223,7 @@ fn is_end_eq_array_len<'tcx>(\n     indexed_ty: Ty<'tcx>,\n ) -> bool {\n     if_chain! {\n-        if let ExprKind::Lit(ref lit) = end.node;\n+        if let ExprKind::Lit(ref lit) = end.kind;\n         if let ast::LitKind::Int(end_int, _) = lit.node;\n         if let ty::Array(_, arr_len_const) = indexed_ty.kind;\n         if let Some(arr_len) = arr_len_const.try_eval_usize(cx.tcx, cx.param_env);\n@@ -1328,7 +1328,7 @@ fn lint_iter_method(cx: &LateContext<'_, '_>, args: &[Expr], arg: &Expr, method_\n \n fn check_for_loop_arg(cx: &LateContext<'_, '_>, pat: &Pat, arg: &Expr, expr: &Expr) {\n     let mut next_loop_linted = false; // whether or not ITER_NEXT_LOOP lint was used\n-    if let ExprKind::MethodCall(ref method, _, ref args) = arg.node {\n+    if let ExprKind::MethodCall(ref method, _, ref args) = arg.kind {\n         // just the receiver, no arguments\n         if args.len() == 1 {\n             let method_name = &*method.ident.as_str();\n@@ -1494,11 +1494,11 @@ fn check_for_loop_over_map_kv<'a, 'tcx>(\n ) {\n     let pat_span = pat.span;\n \n-    if let PatKind::Tuple(ref pat, _) = pat.node {\n+    if let PatKind::Tuple(ref pat, _) = pat.kind {\n         if pat.len() == 2 {\n             let arg_span = arg.span;\n             let (new_pat_span, kind, ty, mutbl) = match cx.tables.expr_ty(arg).kind {\n-                ty::Ref(_, ty, mutbl) => match (&pat[0].node, &pat[1].node) {\n+                ty::Ref(_, ty, mutbl) => match (&pat[0].kind, &pat[1].kind) {\n                     (key, _) if pat_is_wild(key, body) => (pat[1].span, \"value\", ty, mutbl),\n                     (_, value) if pat_is_wild(value, body) => (pat[0].span, \"key\", ty, MutImmutable),\n                     _ => return,\n@@ -1509,7 +1509,7 @@ fn check_for_loop_over_map_kv<'a, 'tcx>(\n                 MutImmutable => \"\",\n                 MutMutable => \"_mut\",\n             };\n-            let arg = match arg.node {\n+            let arg = match arg.kind {\n                 ExprKind::AddrOf(_, ref expr) => &**expr,\n                 _ => arg,\n             };\n@@ -1613,15 +1613,15 @@ fn mut_warn_with_span(cx: &LateContext<'_, '_>, span: Option<Span>) {\n \n fn check_for_mutability(cx: &LateContext<'_, '_>, bound: &Expr) -> Option<HirId> {\n     if_chain! {\n-        if let ExprKind::Path(ref qpath) = bound.node;\n+        if let ExprKind::Path(ref qpath) = bound.kind;\n         if let QPath::Resolved(None, _) = *qpath;\n         then {\n             let res = qpath_res(cx, qpath, bound.hir_id);\n             if let Res::Local(node_id) = res {\n                 let node_str = cx.tcx.hir().get(node_id);\n                 if_chain! {\n                     if let Node::Binding(pat) = node_str;\n-                    if let PatKind::Binding(bind_ann, ..) = pat.node;\n+                    if let PatKind::Binding(bind_ann, ..) = pat.kind;\n                     if let BindingAnnotation::Mutable = bind_ann;\n                     then {\n                         return Some(node_id);\n@@ -1741,7 +1741,7 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n     fn check(&mut self, idx: &'tcx Expr, seqexpr: &'tcx Expr, expr: &'tcx Expr) -> bool {\n         if_chain! {\n             // the indexed container is referenced by a name\n-            if let ExprKind::Path(ref seqpath) = seqexpr.node;\n+            if let ExprKind::Path(ref seqpath) = seqexpr.kind;\n             if let QPath::Resolved(None, ref seqvar) = *seqpath;\n             if seqvar.segments.len() == 1;\n             then {\n@@ -1802,7 +1802,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if_chain! {\n             // a range index op\n-            if let ExprKind::MethodCall(ref meth, _, ref args) = expr.node;\n+            if let ExprKind::MethodCall(ref meth, _, ref args) = expr.kind;\n             if (meth.ident.name == sym!(index) && match_trait_method(self.cx, expr, &paths::INDEX))\n                 || (meth.ident.name == sym!(index_mut) && match_trait_method(self.cx, expr, &paths::INDEX_MUT));\n             if !self.check(&args[1], &args[0], expr);\n@@ -1811,14 +1811,14 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n \n         if_chain! {\n             // an index op\n-            if let ExprKind::Index(ref seqexpr, ref idx) = expr.node;\n+            if let ExprKind::Index(ref seqexpr, ref idx) = expr.kind;\n             if !self.check(idx, seqexpr, expr);\n             then { return }\n         }\n \n         if_chain! {\n             // directly using a variable\n-            if let ExprKind::Path(ref qpath) = expr.node;\n+            if let ExprKind::Path(ref qpath) = expr.kind;\n             if let QPath::Resolved(None, ref path) = *qpath;\n             if path.segments.len() == 1;\n             then {\n@@ -1834,7 +1834,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n         }\n \n         let old = self.prefer_mutable;\n-        match expr.node {\n+        match expr.kind {\n             ExprKind::AssignOp(_, ref lhs, ref rhs) | ExprKind::Assign(ref lhs, ref rhs) => {\n                 self.prefer_mutable = true;\n                 self.visit_expr(lhs);\n@@ -1972,7 +1972,7 @@ fn extract_expr_from_first_stmt(block: &Block) -> Option<&Expr> {\n     if block.stmts.is_empty() {\n         return None;\n     }\n-    if let StmtKind::Local(ref local) = block.stmts[0].node {\n+    if let StmtKind::Local(ref local) = block.stmts[0].kind {\n         if let Some(ref expr) = local.init {\n             Some(expr)\n         } else {\n@@ -1987,7 +1987,7 @@ fn extract_expr_from_first_stmt(block: &Block) -> Option<&Expr> {\n fn extract_first_expr(block: &Block) -> Option<&Expr> {\n     match block.expr {\n         Some(ref expr) if block.stmts.is_empty() => Some(expr),\n-        None if !block.stmts.is_empty() => match block.stmts[0].node {\n+        None if !block.stmts.is_empty() => match block.stmts[0].kind {\n             StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => Some(expr),\n             StmtKind::Local(..) | StmtKind::Item(..) => None,\n         },\n@@ -1999,7 +1999,7 @@ fn extract_first_expr(block: &Block) -> Option<&Expr> {\n /// and\n /// passed expression. The expression may be within a block.\n fn is_simple_break_expr(expr: &Expr) -> bool {\n-    match expr.node {\n+    match expr.kind {\n         ExprKind::Break(dest, ref passed_expr) if dest.label.is_none() && passed_expr.is_none() => true,\n         ExprKind::Block(ref b, _) => extract_first_expr(b).map_or(false, |subexpr| is_simple_break_expr(subexpr)),\n         _ => false,\n@@ -2037,7 +2037,7 @@ impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n             if let Some(parent) = get_parent_expr(self.cx, expr) {\n                 let state = self.states.entry(def_id).or_insert(VarState::Initial);\n \n-                match parent.node {\n+                match parent.kind {\n                     ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n                         if lhs.hir_id == expr.hir_id {\n                             if op.node == BinOpKind::Add && is_integer_const(self.cx, rhs, 1) {\n@@ -2061,7 +2061,7 @@ impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n             walk_expr(self, expr);\n             self.depth -= 1;\n             return;\n-        } else if let ExprKind::Continue(_) = expr.node {\n+        } else if let ExprKind::Continue(_) = expr.kind {\n             self.done = true;\n             return;\n         }\n@@ -2086,9 +2086,9 @@ struct InitializeVisitor<'a, 'tcx> {\n impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n     fn visit_stmt(&mut self, stmt: &'tcx Stmt) {\n         // Look for declarations of the variable\n-        if let StmtKind::Local(ref local) = stmt.node {\n+        if let StmtKind::Local(ref local) = stmt.kind {\n             if local.pat.hir_id == self.var_id {\n-                if let PatKind::Binding(.., ident, _) = local.pat.node {\n+                if let PatKind::Binding(.., ident, _) = local.pat.kind {\n                     self.name = Some(ident.name);\n \n                     self.state = if let Some(ref init) = local.init {\n@@ -2123,7 +2123,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n         // If node is the desired variable, see how it's used\n         if var_def_id(self.cx, expr) == Some(self.var_id) {\n             if let Some(parent) = get_parent_expr(self.cx, expr) {\n-                match parent.node {\n+                match parent.kind {\n                     ExprKind::AssignOp(_, ref lhs, _) if lhs.hir_id == expr.hir_id => {\n                         self.state = VarState::DontWarn;\n                     },\n@@ -2160,7 +2160,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n }\n \n fn var_def_id(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<HirId> {\n-    if let ExprKind::Path(ref qpath) = expr.node {\n+    if let ExprKind::Path(ref qpath) = expr.kind {\n         let path_res = qpath_res(cx, qpath, expr.hir_id);\n         if let Res::Local(node_id) = path_res {\n             return Some(node_id);\n@@ -2170,14 +2170,14 @@ fn var_def_id(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<HirId> {\n }\n \n fn is_loop(expr: &Expr) -> bool {\n-    match expr.node {\n+    match expr.kind {\n         ExprKind::Loop(..) => true,\n         _ => false,\n     }\n }\n \n fn is_conditional(expr: &Expr) -> bool {\n-    match expr.node {\n+    match expr.kind {\n         ExprKind::Match(..) => true,\n         _ => false,\n     }\n@@ -2209,7 +2209,7 @@ fn is_loop_nested(cx: &LateContext<'_, '_>, loop_expr: &Expr, iter_expr: &Expr)\n         }\n         match cx.tcx.hir().find(parent) {\n             Some(Node::Expr(expr)) => {\n-                if let ExprKind::Loop(..) = expr.node {\n+                if let ExprKind::Loop(..) = expr.kind {\n                     return true;\n                 };\n             },\n@@ -2265,7 +2265,7 @@ impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n             self.nesting = LookFurther;\n             return;\n         }\n-        match expr.node {\n+        match expr.kind {\n             ExprKind::Assign(ref path, _) | ExprKind::AssignOp(_, ref path, _) => {\n                 if match_var(path, self.iterator) {\n                     self.nesting = RuledOut;\n@@ -2279,7 +2279,7 @@ impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n         if self.nesting != Unknown {\n             return;\n         }\n-        if let PatKind::Binding(.., span_name, _) = pat.node {\n+        if let PatKind::Binding(.., span_name, _) = pat.kind {\n             if self.iterator == span_name.name {\n                 self.nesting = RuledOut;\n                 return;\n@@ -2294,7 +2294,7 @@ impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n }\n \n fn path_name(e: &Expr) -> Option<Name> {\n-    if let ExprKind::Path(QPath::Resolved(_, ref path)) = e.node {\n+    if let ExprKind::Path(QPath::Resolved(_, ref path)) = e.kind {\n         let segments = &path.segments;\n         if segments.len() == 1 {\n             return Some(segments[0].ident.name);\n@@ -2351,7 +2351,7 @@ struct VarCollectorVisitor<'a, 'tcx> {\n impl<'a, 'tcx> VarCollectorVisitor<'a, 'tcx> {\n     fn insert_def_id(&mut self, ex: &'tcx Expr) {\n         if_chain! {\n-            if let ExprKind::Path(ref qpath) = ex.node;\n+            if let ExprKind::Path(ref qpath) = ex.kind;\n             if let QPath::Resolved(None, _) = *qpath;\n             let res = qpath_res(self.cx, qpath, ex.hir_id);\n             then {\n@@ -2372,7 +2372,7 @@ impl<'a, 'tcx> VarCollectorVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for VarCollectorVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &'tcx Expr) {\n-        match ex.node {\n+        match ex.kind {\n             ExprKind::Path(_) => self.insert_def_id(ex),\n             // If there is any function/method call\u2026 we just stop analysis\n             ExprKind::Call(..) | ExprKind::MethodCall(..) => self.skip = true,\n@@ -2390,8 +2390,8 @@ const NEEDLESS_COLLECT_MSG: &str = \"avoid using `collect()` when not needed\";\n \n fn check_needless_collect<'a, 'tcx>(expr: &'tcx Expr, cx: &LateContext<'a, 'tcx>) {\n     if_chain! {\n-        if let ExprKind::MethodCall(ref method, _, ref args) = expr.node;\n-        if let ExprKind::MethodCall(ref chain_method, _, _) = args[0].node;\n+        if let ExprKind::MethodCall(ref method, _, ref args) = expr.kind;\n+        if let ExprKind::MethodCall(ref chain_method, _, _) = args[0].kind;\n         if chain_method.ident.name == sym!(collect) && match_trait_method(cx, &args[0], &paths::ITERATOR);\n         if let Some(ref generic_args) = chain_method.args;\n         if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n@@ -2450,8 +2450,8 @@ fn check_needless_collect<'a, 'tcx>(expr: &'tcx Expr, cx: &LateContext<'a, 'tcx>\n \n fn shorten_needless_collect_span(expr: &Expr) -> Span {\n     if_chain! {\n-        if let ExprKind::MethodCall(_, _, ref args) = expr.node;\n-        if let ExprKind::MethodCall(_, ref span, _) = args[0].node;\n+        if let ExprKind::MethodCall(_, _, ref args) = expr.kind;\n+        if let ExprKind::MethodCall(_, ref span, _) = args[0].kind;\n         then {\n             return expr.span.with_lo(span.lo() - BytePos(1));\n         }"}, {"sha": "2c3a348b5f7bafe7e429637778c8e71dbc5f11a1", "filename": "clippy_lints/src/main_recursion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fmain_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fmain_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmain_recursion.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -43,8 +43,8 @@ impl LateLintPass<'_, '_> for MainRecursion {\n         }\n \n         if_chain! {\n-            if let ExprKind::Call(func, _) = &expr.node;\n-            if let ExprKind::Path(path) = &func.node;\n+            if let ExprKind::Call(func, _) = &expr.kind;\n+            if let ExprKind::Path(path) = &func.kind;\n             if let QPath::Resolved(_, path) = &path;\n             if let Some(def_id) = path.res.opt_def_id();\n             if is_entrypoint_fn(cx, def_id);"}, {"sha": "1893f4ed262c44ff16fdd1380e01e268fa2e0f17", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -48,25 +48,25 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MapClone {\n         }\n \n         if_chain! {\n-            if let hir::ExprKind::MethodCall(ref method, _, ref args) = e.node;\n+            if let hir::ExprKind::MethodCall(ref method, _, ref args) = e.kind;\n             if args.len() == 2;\n             if method.ident.as_str() == \"map\";\n             let ty = cx.tables.expr_ty(&args[0]);\n             if match_type(cx, ty, &paths::OPTION) || match_trait_method(cx, e, &paths::ITERATOR);\n-            if let hir::ExprKind::Closure(_, _, body_id, _, _) = args[1].node;\n+            if let hir::ExprKind::Closure(_, _, body_id, _, _) = args[1].kind;\n             let closure_body = cx.tcx.hir().body(body_id);\n             let closure_expr = remove_blocks(&closure_body.value);\n             then {\n-                match closure_body.params[0].pat.node {\n+                match closure_body.params[0].pat.kind {\n                     hir::PatKind::Ref(ref inner, _) => if let hir::PatKind::Binding(\n                         hir::BindingAnnotation::Unannotated, .., name, None\n-                    ) = inner.node {\n+                    ) = inner.kind {\n                         if ident_eq(name, closure_expr) {\n                             lint(cx, e.span, args[0].span, true);\n                         }\n                     },\n                     hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, .., name, None) => {\n-                        match closure_expr.node {\n+                        match closure_expr.kind {\n                             hir::ExprKind::Unary(hir::UnOp::UnDeref, ref inner) => {\n                                 if ident_eq(name, inner) && !cx.tables.expr_ty(inner).is_box() {\n                                     lint(cx, e.span, args[0].span, true);\n@@ -96,7 +96,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MapClone {\n }\n \n fn ident_eq(name: Ident, path: &hir::Expr) -> bool {\n-    if let hir::ExprKind::Path(hir::QPath::Resolved(None, ref path)) = path.node {\n+    if let hir::ExprKind::Path(hir::QPath::Resolved(None, ref path)) = path.kind {\n         path.segments.len() == 1 && path.segments[0].ident == name\n     } else {\n         false"}, {"sha": "70f324a5081ed1ef691edf36bc512b571d2bf860", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -125,7 +125,7 @@ fn reduce_unit_expression<'a>(cx: &LateContext<'_, '_>, expr: &'a hir::Expr) ->\n         return None;\n     }\n \n-    match expr.node {\n+    match expr.kind {\n         hir::ExprKind::Call(_, _) | hir::ExprKind::MethodCall(_, _, _) => {\n             // Calls can't be reduced any more\n             Some(expr.span)\n@@ -140,7 +140,7 @@ fn reduce_unit_expression<'a>(cx: &LateContext<'_, '_>, expr: &'a hir::Expr) ->\n                 (&[ref inner_stmt], None) => {\n                     // If block only contains statements,\n                     // reduce `{ X; }` to `X` or `X;`\n-                    match inner_stmt.node {\n+                    match inner_stmt.kind {\n                         hir::StmtKind::Local(ref local) => Some(local.span),\n                         hir::StmtKind::Expr(ref e) => Some(e.span),\n                         hir::StmtKind::Semi(..) => Some(inner_stmt.span),\n@@ -165,7 +165,7 @@ fn unit_closure<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     expr: &'a hir::Expr,\n ) -> Option<(&'tcx hir::Param, &'a hir::Expr)> {\n-    if let hir::ExprKind::Closure(_, ref decl, inner_expr_id, _, _) = expr.node {\n+    if let hir::ExprKind::Closure(_, ref decl, inner_expr_id, _, _) = expr.kind {\n         let body = cx.tcx.hir().body(inner_expr_id);\n         let body_expr = &body.value;\n \n@@ -188,7 +188,7 @@ fn unit_closure<'a, 'tcx>(\n ///\n /// Anything else will return `_`.\n fn let_binding_name(cx: &LateContext<'_, '_>, var_arg: &hir::Expr) -> String {\n-    match &var_arg.node {\n+    match &var_arg.kind {\n         hir::ExprKind::Field(_, _) => snippet(cx, var_arg.span, \"_\").replace(\".\", \"_\"),\n         hir::ExprKind::Path(_) => format!(\"_{}\", snippet(cx, var_arg.span, \"\")),\n         _ => \"_\".to_string(),\n@@ -264,7 +264,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MapUnit {\n             return;\n         }\n \n-        if let hir::StmtKind::Semi(ref expr) = stmt.node {\n+        if let hir::StmtKind::Semi(ref expr) = stmt.kind {\n             if let Some(arglists) = method_chain_args(expr, &[\"map\"]) {\n                 lint_map_unit_fn(cx, stmt, expr, arglists[0]);\n             }"}, {"sha": "569b189180c68ace9bbb53dd53ad8899bab95e87", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -238,15 +238,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Matches {\n         if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n-        if let ExprKind::Match(ref ex, ref arms, MatchSource::Normal) = expr.node {\n+        if let ExprKind::Match(ref ex, ref arms, MatchSource::Normal) = expr.kind {\n             check_single_match(cx, ex, arms, expr);\n             check_match_bool(cx, ex, arms, expr);\n             check_overlapping_arms(cx, ex, arms);\n             check_wild_err_arm(cx, ex, arms);\n             check_wild_enum_match(cx, ex, arms);\n             check_match_as_ref(cx, ex, arms, expr);\n         }\n-        if let ExprKind::Match(ref ex, ref arms, _) = expr.node {\n+        if let ExprKind::Match(ref ex, ref arms, _) = expr.kind {\n             check_match_ref_pats(cx, ex, arms, expr);\n         }\n     }\n@@ -255,15 +255,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Matches {\n #[rustfmt::skip]\n fn check_single_match(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     if arms.len() == 2 && arms[0].guard.is_none() && arms[1].guard.is_none() {\n-        if let PatKind::Or(..) = arms[0].pat.node {\n+        if let PatKind::Or(..) = arms[0].pat.kind {\n             // don't lint for or patterns for now, this makes\n             // the lint noisy in unnecessary situations\n             return;\n         }\n         let els = remove_blocks(&arms[1].body);\n         let els = if is_unit_expr(els) {\n             None\n-        } else if let ExprKind::Block(_, _) = els.node {\n+        } else if let ExprKind::Block(_, _) = els.kind {\n             // matches with blocks that contain statements are prettier as `if let + else`\n             Some(els)\n         } else {\n@@ -338,7 +338,7 @@ fn check_single_match_opt_like(\n         (&paths::RESULT, \"Ok\"),\n     ];\n \n-    let path = match arms[1].pat.node {\n+    let path = match arms[1].pat.kind {\n         PatKind::TupleStruct(ref path, ref inner, _) => {\n             // Contains any non wildcard patterns (e.g., `Err(err)`)?\n             if !inner.iter().all(is_wild) {\n@@ -369,8 +369,8 @@ fn check_match_bool(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Ex\n             move |db| {\n                 if arms.len() == 2 {\n                     // no guards\n-                    let exprs = if let PatKind::Lit(ref arm_bool) = arms[0].pat.node {\n-                        if let ExprKind::Lit(ref lit) = arm_bool.node {\n+                    let exprs = if let PatKind::Lit(ref arm_bool) = arms[0].pat.kind {\n+                        if let ExprKind::Lit(ref lit) = arm_bool.kind {\n                             match lit.node {\n                                 LitKind::Bool(true) => Some((&*arms[0].body, &*arms[1].body)),\n                                 LitKind::Bool(false) => Some((&*arms[1].body, &*arms[0].body)),\n@@ -438,7 +438,7 @@ fn check_overlapping_arms<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ex: &'tcx Expr,\n }\n \n fn is_wild(pat: &impl std::ops::Deref<Target = Pat>) -> bool {\n-    match pat.node {\n+    match pat.kind {\n         PatKind::Wild => true,\n         _ => false,\n     }\n@@ -448,12 +448,12 @@ fn check_wild_err_arm(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm]) {\n     let ex_ty = walk_ptrs_ty(cx.tables.expr_ty(ex));\n     if match_type(cx, ex_ty, &paths::RESULT) {\n         for arm in arms {\n-            if let PatKind::TupleStruct(ref path, ref inner, _) = arm.pat.node {\n+            if let PatKind::TupleStruct(ref path, ref inner, _) = arm.pat.kind {\n                 let path_str = print::to_string(print::NO_ANN, |s| s.print_qpath(path, false));\n                 if_chain! {\n                     if path_str == \"Err\";\n                     if inner.iter().any(is_wild);\n-                    if let ExprKind::Block(ref block, _) = arm.body.node;\n+                    if let ExprKind::Block(ref block, _) = arm.body.kind;\n                     if is_panic_block(block);\n                     then {\n                         // `Err(_)` arm with `panic!` found\n@@ -484,9 +484,9 @@ fn check_wild_enum_match(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm]) {\n     let mut wildcard_span = None;\n     let mut wildcard_ident = None;\n     for arm in arms {\n-        if let PatKind::Wild = arm.pat.node {\n+        if let PatKind::Wild = arm.pat.kind {\n             wildcard_span = Some(arm.pat.span);\n-        } else if let PatKind::Binding(_, _, ident, None) = arm.pat.node {\n+        } else if let PatKind::Binding(_, _, ident, None) = arm.pat.kind {\n             wildcard_span = Some(arm.pat.span);\n             wildcard_ident = Some(ident);\n         }\n@@ -510,11 +510,11 @@ fn check_wild_enum_match(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm]) {\n                 // covered by the set of guards that cover it, but that's really hard to do.\n                 continue;\n             }\n-            if let PatKind::Path(ref path) = arm.pat.node {\n+            if let PatKind::Path(ref path) = arm.pat.kind {\n                 if let QPath::Resolved(_, p) = path {\n                     missing_variants.retain(|e| e.ctor_def_id != Some(p.res.def_id()));\n                 }\n-            } else if let PatKind::TupleStruct(ref path, ..) = arm.pat.node {\n+            } else if let PatKind::TupleStruct(ref path, ..) = arm.pat.kind {\n                 if let QPath::Resolved(_, p) = path {\n                     missing_variants.retain(|e| e.ctor_def_id != Some(p.res.def_id()));\n                 }\n@@ -570,7 +570,7 @@ fn is_panic_block(block: &Block) -> bool {\n fn check_match_ref_pats(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     if has_only_ref_pats(arms) {\n         let mut suggs = Vec::new();\n-        let (title, msg) = if let ExprKind::AddrOf(Mutability::MutImmutable, ref inner) = ex.node {\n+        let (title, msg) = if let ExprKind::AddrOf(Mutability::MutImmutable, ref inner) = ex.kind {\n             let span = ex.span.source_callsite();\n             suggs.push((span, Sugg::hir_with_macro_callsite(cx, inner, \"..\").to_string()));\n             (\n@@ -587,7 +587,7 @@ fn check_match_ref_pats(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr:\n         };\n \n         suggs.extend(arms.iter().filter_map(|a| {\n-            if let PatKind::Ref(ref refp, _) = a.pat.node {\n+            if let PatKind::Ref(ref refp, _) = a.pat.kind {\n                 Some((a.pat.span, snippet(cx, refp.span, \"..\").to_string()))\n             } else {\n                 None\n@@ -662,7 +662,7 @@ fn all_ranges<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arms: &'tcx [Arm]) -> Vec<Sp\n                 ref pat, guard: None, ..\n             } = *arm\n             {\n-                if let PatKind::Range(ref lhs, ref rhs, ref range_end) = pat.node {\n+                if let PatKind::Range(ref lhs, ref rhs, ref range_end) = pat.kind {\n                     let lhs = constant(cx, cx.tables, lhs)?.0;\n                     let rhs = constant(cx, cx.tables, rhs)?.0;\n                     let rhs = match *range_end {\n@@ -675,7 +675,7 @@ fn all_ranges<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arms: &'tcx [Arm]) -> Vec<Sp\n                     });\n                 }\n \n-                if let PatKind::Lit(ref value) = pat.node {\n+                if let PatKind::Lit(ref value) = pat.kind {\n                     let value = constant(cx, cx.tables, value)?.0;\n                     return Some(SpannedRange {\n                         span: pat.span,\n@@ -721,7 +721,7 @@ fn type_ranges(ranges: &[SpannedRange<Constant>]) -> TypedRanges {\n }\n \n fn is_unit_expr(expr: &Expr) -> bool {\n-    match expr.node {\n+    match expr.kind {\n         ExprKind::Tup(ref v) if v.is_empty() => true,\n         ExprKind::Block(ref b, _) if b.stmts.is_empty() && b.expr.is_none() => true,\n         _ => false,\n@@ -730,7 +730,7 @@ fn is_unit_expr(expr: &Expr) -> bool {\n \n // Checks if arm has the form `None => None`\n fn is_none_arm(arm: &Arm) -> bool {\n-    match arm.pat.node {\n+    match arm.pat.kind {\n         PatKind::Path(ref path) if match_qpath(path, &paths::OPTION_NONE) => true,\n         _ => false,\n     }\n@@ -739,14 +739,14 @@ fn is_none_arm(arm: &Arm) -> bool {\n // Checks if arm has the form `Some(ref v) => Some(v)` (checks for `ref` and `ref mut`)\n fn is_ref_some_arm(arm: &Arm) -> Option<BindingAnnotation> {\n     if_chain! {\n-        if let PatKind::TupleStruct(ref path, ref pats, _) = arm.pat.node;\n+        if let PatKind::TupleStruct(ref path, ref pats, _) = arm.pat.kind;\n         if pats.len() == 1 && match_qpath(path, &paths::OPTION_SOME);\n-        if let PatKind::Binding(rb, .., ident, _) = pats[0].node;\n+        if let PatKind::Binding(rb, .., ident, _) = pats[0].kind;\n         if rb == BindingAnnotation::Ref || rb == BindingAnnotation::RefMut;\n-        if let ExprKind::Call(ref e, ref args) = remove_blocks(&arm.body).node;\n-        if let ExprKind::Path(ref some_path) = e.node;\n+        if let ExprKind::Call(ref e, ref args) = remove_blocks(&arm.body).kind;\n+        if let ExprKind::Path(ref some_path) = e.kind;\n         if match_qpath(some_path, &paths::OPTION_SOME) && args.len() == 1;\n-        if let ExprKind::Path(ref qpath) = args[0].node;\n+        if let ExprKind::Path(ref qpath) = args[0].kind;\n         if let &QPath::Resolved(_, ref path2) = qpath;\n         if path2.segments.len() == 1 && ident.name == path2.segments[0].ident.name;\n         then {\n@@ -760,7 +760,7 @@ fn has_only_ref_pats(arms: &[Arm]) -> bool {\n     let mapped = arms\n         .iter()\n         .map(|a| {\n-            match a.pat.node {\n+            match a.pat.kind {\n                 PatKind::Ref(..) => Some(true), // &-patterns\n                 PatKind::Wild => Some(false),   // an \"anything\" wildcard is also fine\n                 _ => None,                      // any other pattern is not fine"}, {"sha": "1d18a312020e24c063e8ff0543ffb8b6dbe8c662", "filename": "clippy_lints/src/mem_discriminant.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fmem_discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fmem_discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_discriminant.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -32,9 +32,9 @@ declare_lint_pass!(MemDiscriminant => [MEM_DISCRIMINANT_NON_ENUM]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemDiscriminant {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n-            if let ExprKind::Call(ref func, ref func_args) = expr.node;\n+            if let ExprKind::Call(ref func, ref func_args) = expr.kind;\n             // is `mem::discriminant`\n-            if let ExprKind::Path(ref func_qpath) = func.node;\n+            if let ExprKind::Path(ref func_qpath) = func.kind;\n             if let Some(def_id) = cx.tables.qpath_res(func_qpath, func.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::MEM_DISCRIMINANT);\n             // type is non-enum\n@@ -57,7 +57,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemDiscriminant {\n                             let mut derefs_needed = ptr_depth;\n                             let mut cur_expr = param;\n                             while derefs_needed > 0  {\n-                                if let ExprKind::AddrOf(_, ref inner_expr) = cur_expr.node {\n+                                if let ExprKind::AddrOf(_, ref inner_expr) = cur_expr.kind {\n                                     derefs_needed -= 1;\n                                     cur_expr = inner_expr;\n                                 } else {"}, {"sha": "fb98be92a07befc9f60cb9d2533bba0e89eb0460", "filename": "clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_forget.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -27,8 +27,8 @@ declare_lint_pass!(MemForget => [MEM_FORGET]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemForget {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprKind::Call(ref path_expr, ref args) = e.node {\n-            if let ExprKind::Path(ref qpath) = path_expr.node {\n+        if let ExprKind::Call(ref path_expr, ref args) = e.kind {\n+            if let ExprKind::Path(ref qpath) = path_expr.kind {\n                 if let Some(def_id) = qpath_res(cx, qpath, path_expr.hir_id).opt_def_id() {\n                     if match_def_path(cx, def_id, &paths::MEM_FORGET) {\n                         let forgot_ty = cx.tables.expr_ty(&args[0]);"}, {"sha": "23bc4412717ebd4acbbbed719e7180f571eb7e01", "filename": "clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_replace.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -73,25 +73,25 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemReplace {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n             // Check that `expr` is a call to `mem::replace()`\n-            if let ExprKind::Call(ref func, ref func_args) = expr.node;\n+            if let ExprKind::Call(ref func, ref func_args) = expr.kind;\n             if func_args.len() == 2;\n-            if let ExprKind::Path(ref func_qpath) = func.node;\n+            if let ExprKind::Path(ref func_qpath) = func.kind;\n             if let Some(def_id) = cx.tables.qpath_res(func_qpath, func.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::MEM_REPLACE);\n \n             // Check that second argument is `Option::None`\n             then {\n-                if let ExprKind::Path(ref replacement_qpath) = func_args[1].node {\n+                if let ExprKind::Path(ref replacement_qpath) = func_args[1].kind {\n                     if match_qpath(replacement_qpath, &paths::OPTION_NONE) {\n \n                         // Since this is a late pass (already type-checked),\n                         // and we already know that the second argument is an\n                         // `Option`, we do not need to check the first\n                         // argument's type. All that's left is to get\n                         // replacee's path.\n-                        let replaced_path = match func_args[0].node {\n+                        let replaced_path = match func_args[0].kind {\n                             ExprKind::AddrOf(MutMutable, ref replaced) => {\n-                                if let ExprKind::Path(QPath::Resolved(None, ref replaced_path)) = replaced.node {\n+                                if let ExprKind::Path(QPath::Resolved(None, ref replaced_path)) = replaced.kind {\n                                     replaced_path\n                                 } else {\n                                     return\n@@ -113,10 +113,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemReplace {\n                         );\n                     }\n                 }\n-                if let ExprKind::Call(ref repl_func, ref repl_args) = func_args[1].node {\n+                if let ExprKind::Call(ref repl_func, ref repl_args) = func_args[1].kind {\n                     if_chain! {\n                         if repl_args.is_empty();\n-                        if let ExprKind::Path(ref repl_func_qpath) = repl_func.node;\n+                        if let ExprKind::Path(ref repl_func_qpath) = repl_func.kind;\n                         if let Some(repl_def_id) = cx.tables.qpath_res(repl_func_qpath, repl_func.hir_id).opt_def_id();\n                         then {\n                             if match_def_path(cx, repl_def_id, &paths::MEM_UNINITIALIZED) {"}, {"sha": "075039954bd2ec6dabc9af36370f1fecd3dc5831", "filename": "clippy_lints/src/methods/manual_saturating_arithmetic.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -85,9 +85,9 @@ enum MinMax {\n fn is_min_or_max<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &hir::Expr) -> Option<MinMax> {\n     // `T::max_value()` `T::min_value()` inherent methods\n     if_chain! {\n-        if let hir::ExprKind::Call(func, args) = &expr.node;\n+        if let hir::ExprKind::Call(func, args) = &expr.kind;\n         if args.is_empty();\n-        if let hir::ExprKind::Path(path) = &func.node;\n+        if let hir::ExprKind::Path(path) = &func.kind;\n         if let hir::QPath::TypeRelative(_, segment) = path;\n         then {\n             match &*segment.ident.as_str() {\n@@ -102,7 +102,7 @@ fn is_min_or_max<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &hir::Expr) -> Option<M\n     let ty_str = ty.to_string();\n \n     // `std::T::MAX` `std::T::MIN` constants\n-    if let hir::ExprKind::Path(path) = &expr.node {\n+    if let hir::ExprKind::Path(path) = &expr.kind {\n         if match_qpath(path, &[\"core\", &ty_str, \"MAX\"][..]) {\n             return Some(MinMax::Max);\n         }\n@@ -126,7 +126,7 @@ fn is_min_or_max<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &hir::Expr) -> Option<M\n     };\n \n     let check_lit = |expr: &hir::Expr, check_min: bool| {\n-        if let hir::ExprKind::Lit(lit) = &expr.node {\n+        if let hir::ExprKind::Lit(lit) = &expr.kind {\n             if let ast::LitKind::Int(value, _) = lit.node {\n                 if value == maxval {\n                     return Some(MinMax::Max);\n@@ -146,7 +146,7 @@ fn is_min_or_max<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &hir::Expr) -> Option<M\n     }\n \n     if ty.is_signed() {\n-        if let hir::ExprKind::Unary(hir::UnNeg, val) = &expr.node {\n+        if let hir::ExprKind::Unary(hir::UnNeg, val) = &expr.kind {\n             return check_lit(val, true);\n         }\n     }\n@@ -161,11 +161,11 @@ enum Sign {\n }\n \n fn lit_sign(expr: &hir::Expr) -> Option<Sign> {\n-    if let hir::ExprKind::Unary(hir::UnNeg, inner) = &expr.node {\n-        if let hir::ExprKind::Lit(..) = &inner.node {\n+    if let hir::ExprKind::Unary(hir::UnNeg, inner) = &expr.kind {\n+        if let hir::ExprKind::Lit(..) = &inner.kind {\n             return Some(Sign::Neg);\n         }\n-    } else if let hir::ExprKind::Lit(..) = &expr.node {\n+    } else if let hir::ExprKind::Lit(..) = &expr.kind {\n         return Some(Sign::Pos);\n     }\n "}, {"sha": "be233c6e69adbdaddad90df3560897a00d51bcb6", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -1112,7 +1112,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n             _ => {},\n         }\n \n-        match expr.node {\n+        match expr.kind {\n             hir::ExprKind::MethodCall(ref method_call, ref method_span, ref args) => {\n                 lint_or_fun_call(cx, expr, *method_span, &method_call.ident.as_str(), args);\n                 lint_expect_fun_call(cx, expr, *method_span, &method_call.ident.as_str(), args);\n@@ -1162,9 +1162,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n         let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n         let ty = cx.tcx.type_of(def_id);\n         if_chain! {\n-            if let hir::ImplItemKind::Method(ref sig, id) = impl_item.node;\n+            if let hir::ImplItemKind::Method(ref sig, id) = impl_item.kind;\n             if let Some(first_arg) = iter_input_pats(&sig.decl, cx.tcx.hir().body(id)).next();\n-            if let hir::ItemKind::Impl(_, _, _, _, None, _, _) = item.node;\n+            if let hir::ItemKind::Impl(_, _, _, _, None, _, _) = item.kind;\n \n             let method_def_id = cx.tcx.hir().local_def_id(impl_item.hir_id);\n             let method_sig = cx.tcx.fn_sig(method_def_id);\n@@ -1221,7 +1221,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n             }\n         }\n \n-        if let hir::ImplItemKind::Method(_, _) = impl_item.node {\n+        if let hir::ImplItemKind::Method(_, _) = impl_item.kind {\n             let ret_ty = return_ty(cx, impl_item.hir_id);\n \n             // walk the return type and check for Self (this does not check associated types)\n@@ -1279,7 +1279,7 @@ fn lint_or_fun_call<'a, 'tcx>(\n \n     impl<'a, 'tcx> intravisit::Visitor<'tcx> for FunCallFinder<'a, 'tcx> {\n         fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-            let call_found = match &expr.node {\n+            let call_found = match &expr.kind {\n                 // ignore enum and struct constructors\n                 hir::ExprKind::Call(..) => !is_ctor_function(self.cx, expr),\n                 hir::ExprKind::MethodCall(..) => true,\n@@ -1322,7 +1322,7 @@ fn lint_or_fun_call<'a, 'tcx>(\n         if_chain! {\n             if !or_has_args;\n             if name == \"unwrap_or\";\n-            if let hir::ExprKind::Path(ref qpath) = fun.node;\n+            if let hir::ExprKind::Path(ref qpath) = fun.kind;\n             let path = &*last_path_segment(qpath).ident.as_str();\n             if [\"default\", \"new\"].contains(&path);\n             let arg_ty = cx.tables.expr_ty(arg);\n@@ -1406,7 +1406,7 @@ fn lint_or_fun_call<'a, 'tcx>(\n     }\n \n     if args.len() == 2 {\n-        match args[1].node {\n+        match args[1].kind {\n             hir::ExprKind::Call(ref fun, ref or_args) => {\n                 let or_has_args = !or_args.is_empty();\n                 if !check_unwrap_or_default(cx, name, fun, &args[0], &args[1], or_has_args, expr.span) {\n@@ -1445,7 +1445,7 @@ fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span:\n     fn get_arg_root<'a>(cx: &LateContext<'_, '_>, arg: &'a hir::Expr) -> &'a hir::Expr {\n         let mut arg_root = arg;\n         loop {\n-            arg_root = match &arg_root.node {\n+            arg_root = match &arg_root.kind {\n                 hir::ExprKind::AddrOf(_, expr) => expr,\n                 hir::ExprKind::MethodCall(method_name, _, call_args) => {\n                     if call_args.len() == 1\n@@ -1488,9 +1488,9 @@ fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span:\n         applicability: &mut Applicability,\n     ) -> Vec<String> {\n         if_chain! {\n-            if let hir::ExprKind::AddrOf(_, ref format_arg) = a.node;\n-            if let hir::ExprKind::Match(ref format_arg_expr, _, _) = format_arg.node;\n-            if let hir::ExprKind::Tup(ref format_arg_expr_tup) = format_arg_expr.node;\n+            if let hir::ExprKind::AddrOf(_, ref format_arg) = a.kind;\n+            if let hir::ExprKind::Match(ref format_arg_expr, _, _) = format_arg.kind;\n+            if let hir::ExprKind::Tup(ref format_arg_expr_tup) = format_arg_expr.kind;\n \n             then {\n                 format_arg_expr_tup\n@@ -1506,7 +1506,7 @@ fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span:\n     fn is_call(node: &hir::ExprKind) -> bool {\n         match node {\n             hir::ExprKind::AddrOf(_, expr) => {\n-                is_call(&expr.node)\n+                is_call(&expr.kind)\n             },\n             hir::ExprKind::Call(..)\n             | hir::ExprKind::MethodCall(..)\n@@ -1517,7 +1517,7 @@ fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span:\n         }\n     }\n \n-    if args.len() != 2 || name != \"expect\" || !is_call(&args[1].node) {\n+    if args.len() != 2 || name != \"expect\" || !is_call(&args[1].kind) {\n         return;\n     }\n \n@@ -1537,9 +1537,9 @@ fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span:\n     let mut applicability = Applicability::MachineApplicable;\n \n     //Special handling for `format!` as arg_root\n-    if let hir::ExprKind::Call(ref inner_fun, ref inner_args) = arg_root.node {\n+    if let hir::ExprKind::Call(ref inner_fun, ref inner_args) = arg_root.kind {\n         if is_expn_of(inner_fun.span, \"format\").is_some() && inner_args.len() == 1 {\n-            if let hir::ExprKind::Call(_, format_args) = &inner_args[0].node {\n+            if let hir::ExprKind::Call(_, format_args) = &inner_args[0].kind {\n                 let fmt_spec = &format_args[0];\n                 let fmt_args = &format_args[1];\n \n@@ -1626,16 +1626,16 @@ fn lint_clone_on_copy(cx: &LateContext<'_, '_>, expr: &hir::Expr, arg: &hir::Exp\n         if let Some(snippet) = sugg::Sugg::hir_opt(cx, arg) {\n             let parent = cx.tcx.hir().get_parent_node(expr.hir_id);\n             match &cx.tcx.hir().get(parent) {\n-                hir::Node::Expr(parent) => match parent.node {\n+                hir::Node::Expr(parent) => match parent.kind {\n                     // &*x is a nop, &x.clone() is not\n                     hir::ExprKind::AddrOf(..) |\n                     // (*x).func() is useless, x.clone().func() can work in case func borrows mutably\n                     hir::ExprKind::MethodCall(..) => return,\n                     _ => {},\n                 },\n                 hir::Node::Stmt(stmt) => {\n-                    if let hir::StmtKind::Local(ref loc) = stmt.node {\n-                        if let hir::PatKind::Ref(..) = loc.pat.node {\n+                    if let hir::StmtKind::Local(ref loc) = stmt.kind {\n+                        if let hir::PatKind::Ref(..) = loc.pat.kind {\n                             // let ref y = *x borrows x, let ref y = x.clone() does not\n                             return;\n                         }\n@@ -1796,12 +1796,12 @@ fn lint_unnecessary_fold(cx: &LateContext<'_, '_>, expr: &hir::Expr, fold_args:\n     ) {\n         if_chain! {\n             // Extract the body of the closure passed to fold\n-            if let hir::ExprKind::Closure(_, _, body_id, _, _) = fold_args[2].node;\n+            if let hir::ExprKind::Closure(_, _, body_id, _, _) = fold_args[2].kind;\n             let closure_body = cx.tcx.hir().body(body_id);\n             let closure_expr = remove_blocks(&closure_body.value);\n \n             // Check if the closure body is of the form `acc <op> some_expr(x)`\n-            if let hir::ExprKind::Binary(ref bin_op, ref left_expr, ref right_expr) = closure_expr.node;\n+            if let hir::ExprKind::Binary(ref bin_op, ref left_expr, ref right_expr) = closure_expr.kind;\n             if bin_op.node == op;\n \n             // Extract the names of the two arguments to the closure\n@@ -1852,7 +1852,7 @@ fn lint_unnecessary_fold(cx: &LateContext<'_, '_>, expr: &hir::Expr, fold_args:\n     );\n \n     // Check if the first argument to .fold is a suitable literal\n-    if let hir::ExprKind::Lit(ref lit) = fold_args[1].node {\n+    if let hir::ExprKind::Lit(ref lit) = fold_args[1].kind {\n         match lit.node {\n             ast::LitKind::Bool(false) => {\n                 check_fold_with_op(cx, expr, fold_args, fold_span, hir::BinOpKind::Or, \"any\", true)\n@@ -1932,7 +1932,7 @@ fn lint_get_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &hir::Expr, get_a\n     if_chain! {\n         if needs_ref;\n         if let Some(parent) = get_parent_expr(cx, expr);\n-        if let hir::ExprKind::Unary(hir::UnOp::UnDeref, _) = parent.node;\n+        if let hir::ExprKind::Unary(hir::UnOp::UnDeref, _) = parent.kind;\n         then {\n             needs_ref = false;\n             span = parent.span;\n@@ -1995,7 +1995,7 @@ fn derefs_to_slice<'a, 'tcx>(\n         }\n     }\n \n-    if let hir::ExprKind::MethodCall(ref path, _, ref args) = expr.node {\n+    if let hir::ExprKind::MethodCall(ref path, _, ref args) = expr.kind {\n         if path.ident.name == sym!(iter) && may_slice(cx, cx.tables.expr_ty(&args[0])) {\n             Some(&args[0])\n         } else {\n@@ -2160,7 +2160,7 @@ fn lint_map_unwrap_or_else<'a, 'tcx>(\n fn lint_map_or_none<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, map_or_args: &'tcx [hir::Expr]) {\n     if match_type(cx, cx.tables.expr_ty(&map_or_args[0]), &paths::OPTION) {\n         // check if the first non-self argument to map_or() is None\n-        let map_or_arg_is_none = if let hir::ExprKind::Path(ref qpath) = map_or_args[1].node {\n+        let map_or_arg_is_none = if let hir::ExprKind::Path(ref qpath) = map_or_args[1].kind {\n             match_qpath(qpath, &paths::OPTION_NONE)\n         } else {\n             false\n@@ -2195,13 +2195,13 @@ fn lint_option_and_then_some(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &\n         return;\n     }\n \n-    match args[1].node {\n+    match args[1].kind {\n         hir::ExprKind::Closure(_, _, body_id, closure_args_span, _) => {\n             let closure_body = cx.tcx.hir().body(body_id);\n             let closure_expr = remove_blocks(&closure_body.value);\n             if_chain! {\n-                if let hir::ExprKind::Call(ref some_expr, ref some_args) = closure_expr.node;\n-                if let hir::ExprKind::Path(ref qpath) = some_expr.node;\n+                if let hir::ExprKind::Call(ref some_expr, ref some_args) = closure_expr.kind;\n+                if let hir::ExprKind::Path(ref qpath) = some_expr.kind;\n                 if match_qpath(qpath, &paths::OPTION_SOME);\n                 if some_args.len() == 1;\n                 then {\n@@ -2381,7 +2381,7 @@ fn lint_flat_map_identity<'a, 'tcx>(\n     flat_map_span: Span,\n ) {\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n-        let arg_node = &flat_map_args[1].node;\n+        let arg_node = &flat_map_args[1].kind;\n \n         let apply_lint = |message: &str| {\n             span_lint_and_sugg(\n@@ -2399,8 +2399,8 @@ fn lint_flat_map_identity<'a, 'tcx>(\n             if let hir::ExprKind::Closure(_, _, body_id, _, _) = arg_node;\n             let body = cx.tcx.hir().body(*body_id);\n \n-            if let hir::PatKind::Binding(_, _, binding_ident, _) = body.params[0].pat.node;\n-            if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = body.value.node;\n+            if let hir::PatKind::Binding(_, _, binding_ident, _) = body.params[0].pat.kind;\n+            if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = body.value.kind;\n \n             if path.segments.len() == 1;\n             if path.segments[0].ident.as_str() == binding_ident.as_str();\n@@ -2444,11 +2444,11 @@ fn lint_search_is_some<'a, 'tcx>(\n             // suggest `any(|..| *..)` instead of `any(|..| **..)` for `find(|..| **..).is_some()`\n             let any_search_snippet = if_chain! {\n                 if search_method == \"find\";\n-                if let hir::ExprKind::Closure(_, _, body_id, ..) = search_args[1].node;\n+                if let hir::ExprKind::Closure(_, _, body_id, ..) = search_args[1].kind;\n                 let closure_body = cx.tcx.hir().body(body_id);\n                 if let Some(closure_arg) = closure_body.params.get(0);\n                 then {\n-                    if let hir::PatKind::Ref(..) = closure_arg.pat.node {\n+                    if let hir::PatKind::Ref(..) = closure_arg.pat.kind {\n                         Some(search_snippet.replacen('&', \"\", 1))\n                     } else if let Some(name) = get_arg_name(&closure_arg.pat) {\n                         Some(search_snippet.replace(&format!(\"*{}\", name), &name.as_str()))\n@@ -2516,9 +2516,9 @@ fn lint_chars_cmp(\n ) -> bool {\n     if_chain! {\n         if let Some(args) = method_chain_args(info.chain, chain_methods);\n-        if let hir::ExprKind::Call(ref fun, ref arg_char) = info.other.node;\n+        if let hir::ExprKind::Call(ref fun, ref arg_char) = info.other.kind;\n         if arg_char.len() == 1;\n-        if let hir::ExprKind::Path(ref qpath) = fun.node;\n+        if let hir::ExprKind::Path(ref qpath) = fun.kind;\n         if let Some(segment) = single_segment_path(qpath);\n         if segment.ident.name == sym!(Some);\n         then {\n@@ -2574,7 +2574,7 @@ fn lint_chars_cmp_with_unwrap<'a, 'tcx>(\n ) -> bool {\n     if_chain! {\n         if let Some(args) = method_chain_args(info.chain, chain_methods);\n-        if let hir::ExprKind::Lit(ref lit) = info.other.node;\n+        if let hir::ExprKind::Lit(ref lit) = info.other.kind;\n         if let ast::LitKind::Char(c) = lit.node;\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n@@ -2616,7 +2616,7 @@ fn lint_chars_last_cmp_with_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &\n /// lint for length-1 `str`s for methods in `PATTERN_METHODS`\n fn lint_single_char_pattern<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, _expr: &'tcx hir::Expr, arg: &'tcx hir::Expr) {\n     if_chain! {\n-        if let hir::ExprKind::Lit(lit) = &arg.node;\n+        if let hir::ExprKind::Lit(lit) = &arg.kind;\n         if let ast::LitKind::Str(r, style) = lit.node;\n         if r.as_str().len() == 1;\n         then {\n@@ -2659,7 +2659,7 @@ fn lint_asref(cx: &LateContext<'_, '_>, expr: &hir::Expr, call_name: &str, as_re\n             // allow the `as_ref` or `as_mut` if it is followed by another method call\n             if_chain! {\n                 if let Some(parent) = get_parent_expr(cx, expr);\n-                if let hir::ExprKind::MethodCall(_, ref span, _) = parent.node;\n+                if let hir::ExprKind::MethodCall(_, ref span, _) = parent.kind;\n                 if span != &expr.span;\n                 then {\n                     return;\n@@ -2725,9 +2725,9 @@ fn lint_into_iter(cx: &LateContext<'_, '_>, expr: &hir::Expr, self_ref_ty: Ty<'_\n /// lint for `MaybeUninit::uninit().assume_init()` (we already have the latter)\n fn lint_maybe_uninit(cx: &LateContext<'_, '_>, expr: &hir::Expr, outer: &hir::Expr) {\n     if_chain! {\n-        if let hir::ExprKind::Call(ref callee, ref args) = expr.node;\n+        if let hir::ExprKind::Call(ref callee, ref args) = expr.kind;\n         if args.is_empty();\n-        if let hir::ExprKind::Path(ref path) = callee.node;\n+        if let hir::ExprKind::Path(ref path) = callee.kind;\n         if match_qpath(path, &paths::MEM_MAYBEUNINIT_UNINIT);\n         if !is_maybe_uninit_ty_valid(cx, cx.tables.expr_ty_adjusted(outer));\n         then {\n@@ -2945,20 +2945,20 @@ enum OutType {\n \n impl OutType {\n     fn matches(self, cx: &LateContext<'_, '_>, ty: &hir::FunctionRetTy) -> bool {\n-        let is_unit = |ty: &hir::Ty| SpanlessEq::new(cx).eq_ty_kind(&ty.node, &hir::TyKind::Tup(vec![].into()));\n+        let is_unit = |ty: &hir::Ty| SpanlessEq::new(cx).eq_ty_kind(&ty.kind, &hir::TyKind::Tup(vec![].into()));\n         match (self, ty) {\n             (Self::Unit, &hir::DefaultReturn(_)) => true,\n             (Self::Unit, &hir::Return(ref ty)) if is_unit(ty) => true,\n             (Self::Bool, &hir::Return(ref ty)) if is_bool(ty) => true,\n             (Self::Any, &hir::Return(ref ty)) if !is_unit(ty) => true,\n-            (Self::Ref, &hir::Return(ref ty)) => matches!(ty.node, hir::TyKind::Rptr(_, _)),\n+            (Self::Ref, &hir::Return(ref ty)) => matches!(ty.kind, hir::TyKind::Rptr(_, _)),\n             _ => false,\n         }\n     }\n }\n \n fn is_bool(ty: &hir::Ty) -> bool {\n-    if let hir::TyKind::Path(ref p) = ty.node {\n+    if let hir::TyKind::Path(ref p) = ty.kind {\n         match_qpath(p, &[\"bool\"])\n     } else {\n         false\n@@ -2976,7 +2976,7 @@ fn contains_return(expr: &hir::Expr) -> bool {\n             if self.found {\n                 return;\n             }\n-            if let hir::ExprKind::Ret(..) = &expr.node {\n+            if let hir::ExprKind::Ret(..) = &expr.kind {\n                 self.found = true;\n             } else {\n                 intravisit::walk_expr(self, expr);"}, {"sha": "abcdc35cd888cbf2a2a1fb9c848ea11582f64e64", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -15,7 +15,7 @@ pub(super) fn lint(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::Expr\n         return;\n     }\n \n-    if let hir::ExprKind::Closure(_, _, body_id, ..) = args[1].node {\n+    if let hir::ExprKind::Closure(_, _, body_id, ..) = args[1].kind {\n         let body = cx.tcx.hir().body(body_id);\n         let arg_id = body.params[0].pat.hir_id;\n         let mutates_arg =\n@@ -56,14 +56,14 @@ fn check_expression<'a, 'tcx>(\n     arg_id: hir::HirId,\n     expr: &'tcx hir::Expr,\n ) -> (bool, bool) {\n-    match &expr.node {\n+    match &expr.kind {\n         hir::ExprKind::Call(ref func, ref args) => {\n             if_chain! {\n-                if let hir::ExprKind::Path(ref path) = func.node;\n+                if let hir::ExprKind::Path(ref path) = func.kind;\n                 then {\n                     if match_qpath(path, &paths::OPTION_SOME) {\n                         if_chain! {\n-                            if let hir::ExprKind::Path(path) = &args[0].node;\n+                            if let hir::ExprKind::Path(path) = &args[0].kind;\n                             if let Res::Local(ref local) = cx.tables.qpath_res(path, args[0].hir_id);\n                             then {\n                                 if arg_id == *local {\n@@ -124,7 +124,7 @@ impl<'a, 'tcx> ReturnVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for ReturnVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        if let hir::ExprKind::Ret(Some(expr)) = &expr.node {\n+        if let hir::ExprKind::Ret(Some(expr)) = &expr.kind {\n             let (found_mapping, found_filtering) = check_expression(self.cx, self.arg_id, expr);\n             self.found_mapping |= found_mapping;\n             self.found_filtering |= found_filtering;"}, {"sha": "7b2d73a3b5d821f111a6543d474884a2418e2d98", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -60,8 +60,8 @@ enum MinMax {\n }\n \n fn min_max<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option<(MinMax, Constant, &'a Expr)> {\n-    if let ExprKind::Call(ref path, ref args) = expr.node {\n-        if let ExprKind::Path(ref qpath) = path.node {\n+    if let ExprKind::Call(ref path, ref args) = expr.kind {\n+        if let ExprKind::Path(ref qpath) = path.kind {\n             cx.tables.qpath_res(qpath, path.hir_id).opt_def_id().and_then(|def_id| {\n                 if match_def_path(cx, def_id, &paths::CMP_MIN) {\n                     fetch_const(cx, args, MinMax::Min)"}, {"sha": "437114066cdf461f17822a45f9abc852d529e413", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -246,7 +246,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MiscLints {\n             return;\n         }\n         for arg in iter_input_pats(decl, body) {\n-            match arg.pat.node {\n+            match arg.pat.kind {\n                 PatKind::Binding(BindingAnnotation::Ref, ..) | PatKind::Binding(BindingAnnotation::RefMut, ..) => {\n                     span_lint(\n                         cx,\n@@ -263,8 +263,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MiscLints {\n \n     fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n         if_chain! {\n-            if let StmtKind::Local(ref local) = stmt.node;\n-            if let PatKind::Binding(an, .., name, None) = local.pat.node;\n+            if let StmtKind::Local(ref local) = stmt.kind;\n+            if let PatKind::Binding(an, .., name, None) = local.pat.kind;\n             if let Some(ref init) = local.init;\n             then {\n                 if an == BindingAnnotation::Ref || an == BindingAnnotation::RefMut {\n@@ -307,8 +307,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MiscLints {\n             }\n         };\n         if_chain! {\n-            if let StmtKind::Semi(ref expr) = stmt.node;\n-            if let ExprKind::Binary(ref binop, ref a, ref b) = expr.node;\n+            if let StmtKind::Semi(ref expr) = stmt.kind;\n+            if let ExprKind::Binary(ref binop, ref a, ref b) = expr.kind;\n             if binop.node == BinOpKind::And || binop.node == BinOpKind::Or;\n             if let Some(sugg) = Sugg::hir_opt(cx, a);\n             then {\n@@ -334,18 +334,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MiscLints {\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        match expr.node {\n+        match expr.kind {\n             ExprKind::Cast(ref e, ref ty) => {\n                 check_cast(cx, expr.span, e, ty);\n                 return;\n             },\n             ExprKind::Binary(ref cmp, ref left, ref right) => {\n                 let op = cmp.node;\n                 if op.is_comparison() {\n-                    if let ExprKind::Path(QPath::Resolved(_, ref path)) = left.node {\n+                    if let ExprKind::Path(QPath::Resolved(_, ref path)) = left.kind {\n                         check_nan(cx, path, expr);\n                     }\n-                    if let ExprKind::Path(QPath::Resolved(_, ref path)) = right.node {\n+                    if let ExprKind::Path(QPath::Resolved(_, ref path)) = right.kind {\n                         check_nan(cx, path, expr);\n                     }\n                     check_to_owned(cx, left, right);\n@@ -403,7 +403,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MiscLints {\n             // Don't lint things expanded by #[derive(...)], etc\n             return;\n         }\n-        let binding = match expr.node {\n+        let binding = match expr.kind {\n             ExprKind::Path(ref qpath) => {\n                 let binding = last_path_segment(qpath).ident.as_str();\n                 if binding.starts_with('_') &&\n@@ -477,12 +477,12 @@ fn is_allowed<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> bool {\n // Return true if `expr` is the result of `signum()` invoked on a float value.\n fn is_signum(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     // The negation of a signum is still a signum\n-    if let ExprKind::Unary(UnNeg, ref child_expr) = expr.node {\n+    if let ExprKind::Unary(UnNeg, ref child_expr) = expr.kind {\n         return is_signum(cx, &child_expr);\n     }\n \n     if_chain! {\n-        if let ExprKind::MethodCall(ref method_name, _, ref expressions) = expr.node;\n+        if let ExprKind::MethodCall(ref method_name, _, ref expressions) = expr.kind;\n         if sym!(signum) == method_name.ident.name;\n         // Check that the receiver of the signum() is a float (expressions[0] is the receiver of\n         // the method call)\n@@ -498,7 +498,7 @@ fn is_float(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n }\n \n fn check_to_owned(cx: &LateContext<'_, '_>, expr: &Expr, other: &Expr) {\n-    let (arg_ty, snip) = match expr.node {\n+    let (arg_ty, snip) = match expr.kind {\n         ExprKind::MethodCall(.., ref args) if args.len() == 1 => {\n             if match_trait_method(cx, expr, &paths::TO_STRING) || match_trait_method(cx, expr, &paths::TO_OWNED) {\n                 (cx.tables.expr_ty_adjusted(&args[0]), snippet(cx, args[0].span, \"..\"))\n@@ -507,7 +507,7 @@ fn check_to_owned(cx: &LateContext<'_, '_>, expr: &Expr, other: &Expr) {\n             }\n         },\n         ExprKind::Call(ref path, ref v) if v.len() == 1 => {\n-            if let ExprKind::Path(ref path) = path.node {\n+            if let ExprKind::Path(ref path) = path.kind {\n                 if match_qpath(path, &[\"String\", \"from_str\"]) || match_qpath(path, &[\"String\", \"from\"]) {\n                     (cx.tables.expr_ty_adjusted(&v[0]), snippet(cx, v[0].span, \"..\"))\n                 } else {\n@@ -538,7 +538,7 @@ fn check_to_owned(cx: &LateContext<'_, '_>, expr: &Expr, other: &Expr) {\n         return;\n     }\n \n-    let other_gets_derefed = match other.node {\n+    let other_gets_derefed = match other.kind {\n         ExprKind::Unary(UnDeref, _) => true,\n         _ => false,\n     };\n@@ -584,7 +584,7 @@ fn check_to_owned(cx: &LateContext<'_, '_>, expr: &Expr, other: &Expr) {\n /// of what it means for an expression to be \"used\".\n fn is_used(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     if let Some(parent) = get_parent_expr(cx, expr) {\n-        match parent.node {\n+        match parent.kind {\n             ExprKind::Assign(_, ref rhs) | ExprKind::AssignOp(_, _, ref rhs) => SpanlessEq::new(cx).eq_expr(rhs, expr),\n             _ => is_used(cx, parent),\n         }\n@@ -621,8 +621,8 @@ fn non_macro_local(cx: &LateContext<'_, '_>, res: def::Res) -> bool {\n \n fn check_cast(cx: &LateContext<'_, '_>, span: Span, e: &Expr, ty: &Ty) {\n     if_chain! {\n-        if let TyKind::Ptr(MutTy { mutbl, .. }) = ty.node;\n-        if let ExprKind::Lit(ref lit) = e.node;\n+        if let TyKind::Ptr(MutTy { mutbl, .. }) = ty.kind;\n+        if let ExprKind::Lit(ref lit) = e.kind;\n         if let LitKind::Int(value, ..) = lit.node;\n         if value == 0;\n         if !in_constant(cx, e.hir_id);"}, {"sha": "43a5e5c1b4b1b6e4942ab8d6f9a50c0e77b086ee", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -260,9 +260,9 @@ impl ReturnVisitor {\n \n impl<'ast> Visitor<'ast> for ReturnVisitor {\n     fn visit_expr(&mut self, ex: &'ast Expr) {\n-        if let ExprKind::Ret(_) = ex.node {\n+        if let ExprKind::Ret(_) = ex.kind {\n             self.found_return = true;\n-        } else if let ExprKind::Try(_) = ex.node {\n+        } else if let ExprKind::Try(_) = ex.kind {\n             self.found_return = true;\n         }\n \n@@ -288,7 +288,7 @@ impl EarlyLintPass for MiscEarlyLints {\n     }\n \n     fn check_pat(&mut self, cx: &EarlyContext<'_>, pat: &Pat) {\n-        if let PatKind::Struct(ref npat, ref pfields, _) = pat.node {\n+        if let PatKind::Struct(ref npat, ref pfields, _) = pat.kind {\n             let mut wilds = 0;\n             let type_name = npat\n                 .segments\n@@ -298,7 +298,7 @@ impl EarlyLintPass for MiscEarlyLints {\n                 .name;\n \n             for field in pfields {\n-                if let PatKind::Wild = field.pat.node {\n+                if let PatKind::Wild = field.pat.kind {\n                     wilds += 1;\n                 }\n             }\n@@ -316,7 +316,7 @@ impl EarlyLintPass for MiscEarlyLints {\n                 let mut normal = vec![];\n \n                 for field in pfields {\n-                    match field.pat.node {\n+                    match field.pat.kind {\n                         PatKind::Wild => {},\n                         _ => {\n                             if let Ok(n) = cx.sess().source_map().span_to_snippet(field.span) {\n@@ -326,7 +326,7 @@ impl EarlyLintPass for MiscEarlyLints {\n                     }\n                 }\n                 for field in pfields {\n-                    if let PatKind::Wild = field.pat.node {\n+                    if let PatKind::Wild = field.pat.kind {\n                         wilds -= 1;\n                         if wilds > 0 {\n                             span_lint(\n@@ -350,8 +350,8 @@ impl EarlyLintPass for MiscEarlyLints {\n             }\n         }\n \n-        if let PatKind::Ident(_, ident, Some(ref right)) = pat.node {\n-            if let PatKind::Wild = right.node {\n+        if let PatKind::Ident(_, ident, Some(ref right)) = pat.kind {\n+            if let PatKind::Wild = right.kind {\n                 span_lint_and_sugg(\n                     cx,\n                     REDUNDANT_PATTERN,\n@@ -374,7 +374,7 @@ impl EarlyLintPass for MiscEarlyLints {\n         let mut registered_names: FxHashMap<String, Span> = FxHashMap::default();\n \n         for arg in &decl.inputs {\n-            if let PatKind::Ident(_, ident, None) = arg.pat.node {\n+            if let PatKind::Ident(_, ident, None) = arg.pat.kind {\n                 let arg_name = ident.to_string();\n \n                 if arg_name.starts_with('_') {\n@@ -401,10 +401,10 @@ impl EarlyLintPass for MiscEarlyLints {\n         if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n-        match expr.node {\n+        match expr.kind {\n             ExprKind::Call(ref paren, _) => {\n-                if let ExprKind::Paren(ref closure) = paren.node {\n-                    if let ExprKind::Closure(_, _, _, ref decl, ref block, _) = closure.node {\n+                if let ExprKind::Paren(ref closure) = paren.kind {\n+                    if let ExprKind::Closure(_, _, _, ref decl, ref block, _) = closure.kind {\n                         let mut visitor = ReturnVisitor::new();\n                         visitor.visit_expr(block);\n                         if !visitor.found_return {\n@@ -427,7 +427,7 @@ impl EarlyLintPass for MiscEarlyLints {\n                 }\n             },\n             ExprKind::Unary(UnOp::Neg, ref inner) => {\n-                if let ExprKind::Unary(UnOp::Neg, _) = inner.node {\n+                if let ExprKind::Unary(UnOp::Neg, _) = inner.kind {\n                     span_lint(\n                         cx,\n                         DOUBLE_NEG,\n@@ -444,14 +444,14 @@ impl EarlyLintPass for MiscEarlyLints {\n     fn check_block(&mut self, cx: &EarlyContext<'_>, block: &Block) {\n         for w in block.stmts.windows(2) {\n             if_chain! {\n-                if let StmtKind::Local(ref local) = w[0].node;\n+                if let StmtKind::Local(ref local) = w[0].kind;\n                 if let Option::Some(ref t) = local.init;\n-                if let ExprKind::Closure(..) = t.node;\n-                if let PatKind::Ident(_, ident, _) = local.pat.node;\n-                if let StmtKind::Semi(ref second) = w[1].node;\n-                if let ExprKind::Assign(_, ref call) = second.node;\n-                if let ExprKind::Call(ref closure, _) = call.node;\n-                if let ExprKind::Path(_, ref path) = closure.node;\n+                if let ExprKind::Closure(..) = t.kind;\n+                if let PatKind::Ident(_, ident, _) = local.pat.kind;\n+                if let StmtKind::Semi(ref second) = w[1].kind;\n+                if let ExprKind::Assign(_, ref call) = second.kind;\n+                if let ExprKind::Call(ref closure, _) = call.kind;\n+                if let ExprKind::Path(_, ref path) = closure.kind;\n                 then {\n                     if ident == path.segments[0].ident {\n                         span_lint(\n@@ -479,7 +479,7 @@ impl MiscEarlyLints {\n             _ => return,\n         };\n \n-        if let LitKind::Int(value, lit_int_type) = lit.node {\n+        if let LitKind::Int(value, lit_int_type) = lit.kind {\n             let suffix = match lit_int_type {\n                 LitIntType::Signed(ty) => ty.ty_to_string(),\n                 LitIntType::Unsigned(ty) => ty.ty_to_string(),\n@@ -542,7 +542,7 @@ impl MiscEarlyLints {\n                     },\n                 );\n             }\n-        } else if let LitKind::Float(_, float_ty) = lit.node {\n+        } else if let LitKind::Float(_, float_ty) = lit.kind {\n             let suffix = float_ty.ty_to_string();\n             let maybe_last_sep_idx = lit_snip.len() - suffix.len() - 1;\n             if lit_snip.as_bytes()[maybe_last_sep_idx] != b'_' {\n@@ -561,7 +561,7 @@ impl MiscEarlyLints {\n }\n \n fn check_unneeded_wildcard_pattern(cx: &EarlyContext<'_>, pat: &Pat) {\n-    if let PatKind::TupleStruct(_, ref patterns) | PatKind::Tuple(ref patterns) = pat.node {\n+    if let PatKind::TupleStruct(_, ref patterns) | PatKind::Tuple(ref patterns) = pat.kind {\n         fn span_lint(cx: &EarlyContext<'_>, span: Span, only_one: bool) {\n             span_lint_and_sugg(\n                 cx,\n@@ -580,7 +580,7 @@ fn check_unneeded_wildcard_pattern(cx: &EarlyContext<'_>, pat: &Pat) {\n \n         #[allow(clippy::trivially_copy_pass_by_ref)]\n         fn is_wild<P: std::ops::Deref<Target = Pat>>(pat: &&P) -> bool {\n-            if let PatKind::Wild = pat.node {\n+            if let PatKind::Wild = pat.kind {\n                 true\n             } else {\n                 false"}, {"sha": "f09a864240ba2a214a50f4ce5945816e47c27fe8", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -56,7 +56,7 @@ impl MissingDoc {\n     fn has_include(meta: Option<MetaItem>) -> bool {\n         if_chain! {\n             if let Some(meta) = meta;\n-            if let MetaItemKind::List(list) = meta.node;\n+            if let MetaItemKind::List(list) = meta.kind;\n             if let Some(meta) = list.get(0);\n             if let Some(name) = meta.ident();\n             then {\n@@ -127,7 +127,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n     }\n \n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, it: &'tcx hir::Item) {\n-        let desc = match it.node {\n+        let desc = match it.kind {\n             hir::ItemKind::Const(..) => \"a constant\",\n             hir::ItemKind::Enum(..) => \"an enum\",\n             hir::ItemKind::Fn(..) => {\n@@ -160,7 +160,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, trait_item: &'tcx hir::TraitItem) {\n-        let desc = match trait_item.node {\n+        let desc = match trait_item.kind {\n             hir::TraitItemKind::Const(..) => \"an associated constant\",\n             hir::TraitItemKind::Method(..) => \"a trait method\",\n             hir::TraitItemKind::Type(..) => \"an associated type\",\n@@ -181,7 +181,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             },\n         }\n \n-        let desc = match impl_item.node {\n+        let desc = match impl_item.kind {\n             hir::ImplItemKind::Const(..) => \"an associated constant\",\n             hir::ImplItemKind::Method(..) => \"a method\",\n             hir::ImplItemKind::TyAlias(_) => \"an associated type\","}, {"sha": "d9cd78dcd41d0cedaa6db5662c834da67c8ca872", "filename": "clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_inline.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -88,7 +88,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingInline {\n         if !cx.access_levels.is_exported(it.hir_id) {\n             return;\n         }\n-        match it.node {\n+        match it.kind {\n             hir::ItemKind::Fn(..) => {\n                 let desc = \"a function\";\n                 check_missing_inline_attrs(cx, &it.attrs, it.span, desc);\n@@ -98,7 +98,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingInline {\n                 // `LateLintPass::check_trait_item` here.\n                 for tit in trait_items {\n                     let tit_ = cx.tcx.hir().trait_item(tit.id);\n-                    match tit_.node {\n+                    match tit_.kind {\n                         hir::TraitItemKind::Const(..) | hir::TraitItemKind::Type(..) => {},\n                         hir::TraitItemKind::Method(..) => {\n                             if tit.defaultness.has_value() {\n@@ -140,7 +140,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingInline {\n             return;\n         }\n \n-        let desc = match impl_item.node {\n+        let desc = match impl_item.kind {\n             hir::ImplItemKind::Method(..) => \"a method\",\n             hir::ImplItemKind::Const(..) | hir::ImplItemKind::TyAlias(_) | hir::ImplItemKind::OpaqueTy(_) => return,\n         };"}, {"sha": "37f9197549d183835d1a9be41fda3144bc180def", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -57,8 +57,8 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n             // Let's ignore the generated code.\n             intravisit::walk_expr(self, arg);\n             intravisit::walk_expr(self, body);\n-        } else if let hir::ExprKind::AddrOf(hir::MutMutable, ref e) = expr.node {\n-            if let hir::ExprKind::AddrOf(hir::MutMutable, _) = e.node {\n+        } else if let hir::ExprKind::AddrOf(hir::MutMutable, ref e) = expr.kind {\n+            if let hir::ExprKind::AddrOf(hir::MutMutable, _) = e.kind {\n                 span_lint(\n                     self.cx,\n                     MUT_MUT,\n@@ -83,14 +83,14 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n                 ty: ref pty,\n                 mutbl: hir::MutMutable,\n             },\n-        ) = ty.node\n+        ) = ty.kind\n         {\n             if let hir::TyKind::Rptr(\n                 _,\n                 hir::MutTy {\n                     mutbl: hir::MutMutable, ..\n                 },\n-            ) = pty.node\n+            ) = pty.kind\n             {\n                 span_lint(\n                     self.cx,"}, {"sha": "798699eeea665371f4b8b858b4d83caf880c4f0c", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -27,9 +27,9 @@ declare_lint_pass!(UnnecessaryMutPassed => [UNNECESSARY_MUT_PASSED]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnecessaryMutPassed {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        match e.node {\n+        match e.kind {\n             ExprKind::Call(ref fn_expr, ref arguments) => {\n-                if let ExprKind::Path(ref path) = fn_expr.node {\n+                if let ExprKind::Path(ref path) = fn_expr.kind {\n                     check_arguments(\n                         cx,\n                         arguments,\n@@ -59,7 +59,7 @@ fn check_arguments<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arguments: &[Expr], typ\n                     | ty::RawPtr(ty::TypeAndMut {\n                         mutbl: MutImmutable, ..\n                     }) => {\n-                        if let ExprKind::AddrOf(MutMutable, _) = argument.node {\n+                        if let ExprKind::AddrOf(MutMutable, _) = argument.kind {\n                             span_lint(\n                                 cx,\n                                 UNNECESSARY_MUT_PASSED,"}, {"sha": "dffce2215dce74cf9c8d43198a186503845b6776", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -87,7 +87,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBool {\n                     applicability,\n                 );\n             };\n-            if let ExprKind::Block(ref then_block, _) = then_block.node {\n+            if let ExprKind::Block(ref then_block, _) = then_block.kind {\n                 match (fetch_bool_block(then_block), fetch_bool_expr(else_expr)) {\n                     (RetBool(true), RetBool(true)) | (Bool(true), Bool(true)) => {\n                         span_lint(\n@@ -126,7 +126,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoolComparison {\n             return;\n         }\n \n-        if let ExprKind::Binary(Spanned { node, .. }, ..) = e.node {\n+        if let ExprKind::Binary(Spanned { node, .. }, ..) = e.kind {\n             let ignore_case = None::<(fn(_) -> _, &str)>;\n             let ignore_no_literal = None::<(fn(_, _) -> _, &str)>;\n             match node {\n@@ -193,7 +193,7 @@ fn check_comparison<'a, 'tcx>(\n ) {\n     use self::Expression::*;\n \n-    if let ExprKind::Binary(_, ref left_side, ref right_side) = e.node {\n+    if let ExprKind::Binary(_, ref left_side, ref right_side) = e.kind {\n         let (l_ty, r_ty) = (cx.tables.expr_ty(left_side), cx.tables.expr_ty(right_side));\n         if l_ty.is_bool() && r_ty.is_bool() {\n             let mut applicability = Applicability::MachineApplicable;\n@@ -259,8 +259,8 @@ fn fetch_bool_block(block: &Block) -> Expression {\n     match (&*block.stmts, block.expr.as_ref()) {\n         (&[], Some(e)) => fetch_bool_expr(&**e),\n         (&[ref e], None) => {\n-            if let StmtKind::Semi(ref e) = e.node {\n-                if let ExprKind::Ret(_) = e.node {\n+            if let StmtKind::Semi(ref e) = e.kind {\n+                if let ExprKind::Ret(_) = e.kind {\n                     fetch_bool_expr(&**e)\n                 } else {\n                     Expression::Other\n@@ -274,7 +274,7 @@ fn fetch_bool_block(block: &Block) -> Expression {\n }\n \n fn fetch_bool_expr(expr: &Expr) -> Expression {\n-    match expr.node {\n+    match expr.kind {\n         ExprKind::Block(ref block, _) => fetch_bool_block(block),\n         ExprKind::Lit(ref lit_ptr) => {\n             if let LitKind::Bool(value) = lit_ptr.node {"}, {"sha": "8093a06ab6fec203389ec45b3dac36e1d91e2f07", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -41,7 +41,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n         if e.span.from_expansion() || self.derived_item.is_some() {\n             return;\n         }\n-        if let ExprKind::AddrOf(MutImmutable, ref inner) = e.node {\n+        if let ExprKind::AddrOf(MutImmutable, ref inner) = e.kind {\n             if let ty::Ref(..) = cx.tables.expr_ty(inner).kind {\n                 for adj3 in cx.tables.expr_adjustments(e).windows(3) {\n                     if let [Adjustment {\n@@ -80,7 +80,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n             return;\n         }\n         if_chain! {\n-            if let PatKind::Binding(BindingAnnotation::Ref, .., name, _) = pat.node;\n+            if let PatKind::Binding(BindingAnnotation::Ref, .., name, _) = pat.kind;\n             if let ty::Ref(_, tam, mutbl) = cx.tables.pat_ty(pat).kind;\n             if mutbl == MutImmutable;\n             if let ty::Ref(_, _, mutbl) = tam.kind;"}, {"sha": "2c4c5461ae1f598577f7c15053be19bfe6ad80e4", "filename": "clippy_lints/src/needless_borrowed_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -61,10 +61,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrowedRef {\n \n         if_chain! {\n             // Only lint immutable refs, because `&mut ref T` may be useful.\n-            if let PatKind::Ref(ref sub_pat, MutImmutable) = pat.node;\n+            if let PatKind::Ref(ref sub_pat, MutImmutable) = pat.kind;\n \n             // Check sub_pat got a `ref` keyword (excluding `ref mut`).\n-            if let PatKind::Binding(BindingAnnotation::Ref, .., spanned_name, _) = sub_pat.node;\n+            if let PatKind::Binding(BindingAnnotation::Ref, .., spanned_name, _) = sub_pat.kind;\n             let parent_id = cx.tcx.hir().get_parent_node(pat.hir_id);\n             if let Some(parent_node) = cx.tcx.hir().find(parent_id);\n             then {"}, {"sha": "bd9d1583493cc0501dda1deae0d0a3c412872632", "filename": "clippy_lints/src/needless_continue.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fneedless_continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fneedless_continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_continue.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -181,17 +181,17 @@ impl EarlyLintPass for NeedlessContinue {\n /// - The expression node is a block with the first statement being a\n /// `continue`.\n fn needless_continue_in_else(else_expr: &ast::Expr, label: Option<&ast::Label>) -> bool {\n-    match else_expr.node {\n+    match else_expr.kind {\n         ast::ExprKind::Block(ref else_block, _) => is_first_block_stmt_continue(else_block, label),\n         ast::ExprKind::Continue(l) => compare_labels(label, l.as_ref()),\n         _ => false,\n     }\n }\n \n fn is_first_block_stmt_continue(block: &ast::Block, label: Option<&ast::Label>) -> bool {\n-    block.stmts.get(0).map_or(false, |stmt| match stmt.node {\n+    block.stmts.get(0).map_or(false, |stmt| match stmt.kind {\n         ast::StmtKind::Semi(ref e) | ast::StmtKind::Expr(ref e) => {\n-            if let ast::ExprKind::Continue(ref l) = e.node {\n+            if let ast::ExprKind::Continue(ref l) = e.kind {\n                 compare_labels(label, l.as_ref())\n             } else {\n                 false\n@@ -221,7 +221,7 @@ where\n {\n     if let ast::ExprKind::While(_, loop_block, label)\n     | ast::ExprKind::ForLoop(_, _, loop_block, label)\n-    | ast::ExprKind::Loop(loop_block, label) = &expr.node\n+    | ast::ExprKind::Loop(loop_block, label) = &expr.kind\n     {\n         func(loop_block, label.as_ref());\n     }\n@@ -239,9 +239,9 @@ fn with_if_expr<F>(stmt: &ast::Stmt, mut func: F)\n where\n     F: FnMut(&ast::Expr, &ast::Expr, &ast::Block, &ast::Expr),\n {\n-    match stmt.node {\n+    match stmt.kind {\n         ast::StmtKind::Semi(ref e) | ast::StmtKind::Expr(ref e) => {\n-            if let ast::ExprKind::If(ref cond, ref if_block, Some(ref else_expr)) = e.node {\n+            if let ast::ExprKind::If(ref cond, ref if_block, Some(ref else_expr)) = e.kind {\n                 func(e, cond, if_block, else_expr);\n             }\n         },"}, {"sha": "e2ac39f826288ef55e8b4ef98af7b0aa653532c7", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -92,7 +92,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n \n         // Exclude non-inherent impls\n         if let Some(Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(hir_id)) {\n-            if matches!(item.node, ItemKind::Impl(_, _, _, _, Some(_), _, _) |\n+            if matches!(item.kind, ItemKind::Impl(_, _, _, _, Some(_), _, _) |\n                 ItemKind::Trait(..))\n             {\n                 return;\n@@ -160,7 +160,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n \n             // Ignore `self`s.\n             if idx == 0 {\n-                if let PatKind::Binding(.., ident, _) = arg.pat.node {\n+                if let PatKind::Binding(.., ident, _) = arg.pat.kind {\n                     if ident.as_str() == \"self\" {\n                         continue;\n                     }\n@@ -202,7 +202,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                 if !implements_borrow_trait;\n                 if !all_borrowable_trait;\n \n-                if let PatKind::Binding(mode, canonical_id, ..) = arg.pat.node;\n+                if let PatKind::Binding(mode, canonical_id, ..) = arg.pat.kind;\n                 if !moved_vars.contains(&canonical_id);\n                 then {\n                     if mode == BindingAnnotation::Mutable || mode == BindingAnnotation::RefMut {\n@@ -224,7 +224,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                             if is_type_diagnostic_item(cx, ty, Symbol::intern(\"vec_type\"));\n                             if let Some(clone_spans) =\n                                 get_spans(cx, Some(body.id()), idx, &[(\"clone\", \".to_owned()\")]);\n-                            if let TyKind::Path(QPath::Resolved(_, ref path)) = input.node;\n+                            if let TyKind::Path(QPath::Resolved(_, ref path)) = input.kind;\n                             if let Some(elem_ty) = path.segments.iter()\n                                 .find(|seg| seg.ident.name == sym!(Vec))\n                                 .and_then(|ps| ps.args.as_ref())\n@@ -367,7 +367,7 @@ impl<'a, 'tcx> MovedVariablesCtxt<'a, 'tcx> {\n                     match node {\n                         Node::Expr(e) => {\n                             // `match` and `if let`\n-                            if let ExprKind::Match(ref c, ..) = e.node {\n+                            if let ExprKind::Match(ref c, ..) = e.kind {\n                                 self.spans_need_deref\n                                     .entry(vid)\n                                     .or_insert_with(FxHashSet::default)\n@@ -378,7 +378,7 @@ impl<'a, 'tcx> MovedVariablesCtxt<'a, 'tcx> {\n                         Node::Stmt(s) => {\n                             // `let <pat> = x;`\n                             if_chain! {\n-                                if let StmtKind::Local(ref local) = s.node;\n+                                if let StmtKind::Local(ref local) = s.kind;\n                                 then {\n                                     self.spans_need_deref\n                                         .entry(vid)"}, {"sha": "a92523eb5523b39777b750fe42d35c40bd6f7fbb", "filename": "clippy_lints/src/needless_update.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_update.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -36,7 +36,7 @@ declare_lint_pass!(NeedlessUpdate => [NEEDLESS_UPDATE]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessUpdate {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprKind::Struct(_, ref fields, Some(ref base)) = expr.node {\n+        if let ExprKind::Struct(_, ref fields, Some(ref base)) = expr.kind {\n             let ty = cx.tables.expr_ty(expr);\n             if let ty::Adt(def, _) = ty.kind {\n                 if fields.len() == def.non_enum_variant().fields.len() {"}, {"sha": "f25a00ca6927150cdb1987a7f57024c715b788a2", "filename": "clippy_lints/src/neg_cmp_op_on_partial_ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -49,8 +49,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NoNegCompOpForPartialOrd {\n         if_chain! {\n \n             if !in_external_macro(cx.sess(), expr.span);\n-            if let ExprKind::Unary(UnOp::UnNot, ref inner) = expr.node;\n-            if let ExprKind::Binary(ref op, ref left, _) = inner.node;\n+            if let ExprKind::Unary(UnOp::UnNot, ref inner) = expr.kind;\n+            if let ExprKind::Binary(ref op, ref left, _) = inner.kind;\n             if let BinOpKind::Le | BinOpKind::Ge | BinOpKind::Lt | BinOpKind::Gt = op.node;\n \n             then {"}, {"sha": "b4901cd3ffdb0fdc3bb2b265e04bb6c273b8f314", "filename": "clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_multiply.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -34,9 +34,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NegMultiply {\n             },\n             ref l,\n             ref r,\n-        ) = e.node\n+        ) = e.kind\n         {\n-            match (&l.node, &r.node) {\n+            match (&l.kind, &r.kind) {\n                 (&ExprKind::Unary(..), &ExprKind::Unary(..)) => (),\n                 (&ExprKind::Unary(UnNeg, ref lit), _) => check_mul(cx, e.span, lit, r),\n                 (_, &ExprKind::Unary(UnNeg, ref lit)) => check_mul(cx, e.span, lit, l),\n@@ -48,7 +48,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NegMultiply {\n \n fn check_mul(cx: &LateContext<'_, '_>, span: Span, lit: &Expr, exp: &Expr) {\n     if_chain! {\n-        if let ExprKind::Lit(ref l) = lit.node;\n+        if let ExprKind::Lit(ref l) = lit.kind;\n         if let Constant::Int(val) = consts::lit_to_constant(&l.node, cx.tables.expr_ty(lit));\n         if val == 1;\n         if cx.tables.expr_ty(exp).is_integral();"}, {"sha": "f6bb2e4cf56708c8d4f1c8101309fab829922e2c", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -93,14 +93,14 @@ impl_lint_pass!(NewWithoutDefault => [NEW_WITHOUT_DEFAULT]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item) {\n-        if let hir::ItemKind::Impl(_, _, _, _, None, _, ref items) = item.node {\n+        if let hir::ItemKind::Impl(_, _, _, _, None, _, ref items) = item.kind {\n             for assoc_item in items {\n                 if let hir::AssocItemKind::Method { has_self: false } = assoc_item.kind {\n                     let impl_item = cx.tcx.hir().impl_item(assoc_item.id);\n                     if in_external_macro(cx.sess(), impl_item.span) {\n                         return;\n                     }\n-                    if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n+                    if let hir::ImplItemKind::Method(ref sig, _) = impl_item.kind {\n                         let name = impl_item.ident.name;\n                         let id = impl_item.hir_id;\n                         if sig.header.constness == hir::Constness::Const {"}, {"sha": "f8cbfc434fec7c2f1fce1d6255fa19244b97a06c", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -46,7 +46,7 @@ fn has_no_effect(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     if expr.span.from_expansion() {\n         return false;\n     }\n-    match expr.node {\n+    match expr.kind {\n         ExprKind::Lit(..) | ExprKind::Closure(..) => true,\n         ExprKind::Path(..) => !has_drop(cx, cx.tables.expr_ty(expr)),\n         ExprKind::Index(ref a, ref b) | ExprKind::Binary(_, ref a, ref b) => {\n@@ -66,7 +66,7 @@ fn has_no_effect(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n                 && base.as_ref().map_or(true, |base| has_no_effect(cx, base))\n         },\n         ExprKind::Call(ref callee, ref args) => {\n-            if let ExprKind::Path(ref qpath) = callee.node {\n+            if let ExprKind::Path(ref qpath) = callee.kind {\n                 let res = qpath_res(cx, qpath, callee.hir_id);\n                 match res {\n                     Res::Def(DefKind::Struct, ..) | Res::Def(DefKind::Variant, ..) | Res::Def(DefKind::Ctor(..), _) => {\n@@ -89,7 +89,7 @@ declare_lint_pass!(NoEffect => [NO_EFFECT, UNNECESSARY_OPERATION]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NoEffect {\n     fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n-        if let StmtKind::Semi(ref expr) = stmt.node {\n+        if let StmtKind::Semi(ref expr) = stmt.kind {\n             if has_no_effect(cx, expr) {\n                 span_lint(cx, NO_EFFECT, stmt.span, \"statement with no effect\");\n             } else if let Some(reduced) = reduce_expression(cx, expr) {\n@@ -123,7 +123,7 @@ fn reduce_expression<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option<Vec\n     if expr.span.from_expansion() {\n         return None;\n     }\n-    match expr.node {\n+    match expr.kind {\n         ExprKind::Index(ref a, ref b) => Some(vec![&**a, &**b]),\n         ExprKind::Binary(ref binop, ref a, ref b) if binop.node != BinOpKind::And && binop.node != BinOpKind::Or => {\n             Some(vec![&**a, &**b])\n@@ -144,7 +144,7 @@ fn reduce_expression<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option<Vec\n             }\n         },\n         ExprKind::Call(ref callee, ref args) => {\n-            if let ExprKind::Path(ref qpath) = callee.node {\n+            if let ExprKind::Path(ref qpath) = callee.kind {\n                 let res = qpath_res(cx, qpath, callee.hir_id);\n                 match res {\n                     Res::Def(DefKind::Struct, ..) | Res::Def(DefKind::Variant, ..) | Res::Def(DefKind::Ctor(..), _)"}, {"sha": "33f1dde98728cce07137e28a5ad4eed8cb7b80d3", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -142,14 +142,14 @@ declare_lint_pass!(NonCopyConst => [DECLARE_INTERIOR_MUTABLE_CONST, BORROW_INTER\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, it: &'tcx Item) {\n-        if let ItemKind::Const(hir_ty, ..) = &it.node {\n+        if let ItemKind::Const(hir_ty, ..) = &it.kind {\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n             verify_ty_bound(cx, ty, Source::Item { item: it.span });\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, trait_item: &'tcx TraitItem) {\n-        if let TraitItemKind::Const(hir_ty, ..) = &trait_item.node {\n+        if let TraitItemKind::Const(hir_ty, ..) = &trait_item.kind {\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n             verify_ty_bound(\n                 cx,\n@@ -163,11 +163,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, impl_item: &'tcx ImplItem) {\n-        if let ImplItemKind::Const(hir_ty, ..) = &impl_item.node {\n+        if let ImplItemKind::Const(hir_ty, ..) = &impl_item.kind {\n             let item_hir_id = cx.tcx.hir().get_parent_node(impl_item.hir_id);\n             let item = cx.tcx.hir().expect_item(item_hir_id);\n             // Ensure the impl is an inherent impl.\n-            if let ItemKind::Impl(_, _, _, _, None, _, _) = item.node {\n+            if let ItemKind::Impl(_, _, _, _, None, _, _) = item.kind {\n                 let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n                 verify_ty_bound(\n                     cx,\n@@ -182,7 +182,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprKind::Path(qpath) = &expr.node {\n+        if let ExprKind::Path(qpath) = &expr.kind {\n             // Only lint if we use the const item inside a function.\n             if in_constant(cx, expr.hir_id) {\n                 return;\n@@ -204,7 +204,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n                     break;\n                 }\n                 if let Some(Node::Expr(parent_expr)) = cx.tcx.hir().find(parent_id) {\n-                    match &parent_expr.node {\n+                    match &parent_expr.kind {\n                         ExprKind::AddrOf(..) => {\n                             // `&e` => `e` must be referenced.\n                             needs_check_adjustment = false;"}, {"sha": "25e8efe3cad64362e68b2a595af4974aaff935a2", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -128,7 +128,7 @@ struct SimilarNamesNameVisitor<'a, 'tcx, 'b>(&'b mut SimilarNamesLocalVisitor<'a\n \n impl<'a, 'tcx, 'b> Visitor<'tcx> for SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n     fn visit_pat(&mut self, pat: &'tcx Pat) {\n-        match pat.node {\n+        match pat.kind {\n             PatKind::Ident(_, ident, _) => self.check_ident(ident),\n             PatKind::Struct(_, ref fields, _) => {\n                 for field in fields {\n@@ -350,13 +350,13 @@ impl<'a, 'tcx> Visitor<'tcx> for SimilarNamesLocalVisitor<'a, 'tcx> {\n \n impl EarlyLintPass for NonExpressiveNames {\n     fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n-        if let ItemKind::Fn(ref decl, _, _, ref blk) = item.node {\n+        if let ItemKind::Fn(ref decl, _, _, ref blk) = item.kind {\n             do_check(self, cx, &item.attrs, decl, blk);\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &EarlyContext<'_>, item: &ImplItem) {\n-        if let ImplItemKind::Method(ref sig, ref blk) = item.node {\n+        if let ImplItemKind::Method(ref sig, ref blk) = item.kind {\n             do_check(self, cx, &item.attrs, &sig.decl, blk);\n         }\n     }"}, {"sha": "6973909b70d6c470aa75687d8db8f6c7fb617132", "filename": "clippy_lints/src/ok_if_let.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fok_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fok_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fok_if_let.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -39,10 +39,10 @@ declare_lint_pass!(OkIfLet => [IF_LET_SOME_RESULT]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OkIfLet {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! { //begin checking variables\n-            if let ExprKind::Match(ref op, ref body, ref source) = expr.node; //test if expr is a match\n+            if let ExprKind::Match(ref op, ref body, ref source) = expr.kind; //test if expr is a match\n             if let MatchSource::IfLetDesugar { .. } = *source; //test if it is an If Let\n-            if let ExprKind::MethodCall(_, _, ref result_types) = op.node; //check is expr.ok() has type Result<T,E>.ok()\n-            if let PatKind::TupleStruct(QPath::Resolved(_, ref x), ref y, _)  = body[0].pat.node; //get operation\n+            if let ExprKind::MethodCall(_, _, ref result_types) = op.kind; //check is expr.ok() has type Result<T,E>.ok()\n+            if let PatKind::TupleStruct(QPath::Resolved(_, ref x), ref y, _)  = body[0].pat.kind; //get operation\n             if method_chain_args(op, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;\n \n             then {"}, {"sha": "cc8d17e281474da408537c3cc1636048b4ef9b98", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -29,7 +29,7 @@ declare_lint_pass!(OpenOptions => [NONSENSICAL_OPEN_OPTIONS]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OpenOptions {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprKind::MethodCall(ref path, _, ref arguments) = e.node {\n+        if let ExprKind::MethodCall(ref path, _, ref arguments) = e.kind {\n             let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&arguments[0]));\n             if path.ident.name == sym!(open) && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n                 let mut options = Vec::new();\n@@ -57,12 +57,12 @@ enum OpenOption {\n }\n \n fn get_open_options(cx: &LateContext<'_, '_>, argument: &Expr, options: &mut Vec<(OpenOption, Argument)>) {\n-    if let ExprKind::MethodCall(ref path, _, ref arguments) = argument.node {\n+    if let ExprKind::MethodCall(ref path, _, ref arguments) = argument.kind {\n         let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&arguments[0]));\n \n         // Only proceed if this is a call on some object of type std::fs::OpenOptions\n         if match_type(cx, obj_ty, &paths::OPEN_OPTIONS) && arguments.len() >= 2 {\n-            let argument_option = match arguments[1].node {\n+            let argument_option = match arguments[1].kind {\n                 ExprKind::Lit(ref span) => {\n                     if let Spanned {\n                         node: LitKind::Bool(lit),"}, {"sha": "b14f04d0ae0c6176cfd2c449bd8b4c2d5ef719dc", "filename": "clippy_lints/src/overflow_check_conditional.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -30,11 +30,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OverflowCheckConditional {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         let eq = |l, r| SpanlessEq::new(cx).eq_path_segment(l, r);\n         if_chain! {\n-            if let ExprKind::Binary(ref op, ref first, ref second) = expr.node;\n-            if let ExprKind::Binary(ref op2, ref ident1, ref ident2) = first.node;\n-            if let ExprKind::Path(QPath::Resolved(_, ref path1)) = ident1.node;\n-            if let ExprKind::Path(QPath::Resolved(_, ref path2)) = ident2.node;\n-            if let ExprKind::Path(QPath::Resolved(_, ref path3)) = second.node;\n+            if let ExprKind::Binary(ref op, ref first, ref second) = expr.kind;\n+            if let ExprKind::Binary(ref op2, ref ident1, ref ident2) = first.kind;\n+            if let ExprKind::Path(QPath::Resolved(_, ref path1)) = ident1.kind;\n+            if let ExprKind::Path(QPath::Resolved(_, ref path2)) = ident2.kind;\n+            if let ExprKind::Path(QPath::Resolved(_, ref path3)) = second.kind;\n             if eq(&path1.segments[0], &path3.segments[0]) || eq(&path2.segments[0], &path3.segments[0]);\n             if cx.tables.expr_ty(ident1).is_integral();\n             if cx.tables.expr_ty(ident2).is_integral();\n@@ -55,11 +55,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OverflowCheckConditional {\n         }\n \n         if_chain! {\n-            if let ExprKind::Binary(ref op, ref first, ref second) = expr.node;\n-            if let ExprKind::Binary(ref op2, ref ident1, ref ident2) = second.node;\n-            if let ExprKind::Path(QPath::Resolved(_, ref path1)) = ident1.node;\n-            if let ExprKind::Path(QPath::Resolved(_, ref path2)) = ident2.node;\n-            if let ExprKind::Path(QPath::Resolved(_, ref path3)) = first.node;\n+            if let ExprKind::Binary(ref op, ref first, ref second) = expr.kind;\n+            if let ExprKind::Binary(ref op2, ref ident1, ref ident2) = second.kind;\n+            if let ExprKind::Path(QPath::Resolved(_, ref path1)) = ident1.kind;\n+            if let ExprKind::Path(QPath::Resolved(_, ref path2)) = ident2.kind;\n+            if let ExprKind::Path(QPath::Resolved(_, ref path3)) = first.kind;\n             if eq(&path1.segments[0], &path3.segments[0]) || eq(&path2.segments[0], &path3.segments[0]);\n             if cx.tables.expr_ty(ident1).is_integral();\n             if cx.tables.expr_ty(ident2).is_integral();"}, {"sha": "4b0fbc5e15b423d16f068925a07371278d282ae2", "filename": "clippy_lints/src/panic_unimplemented.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -47,10 +47,10 @@ declare_lint_pass!(PanicUnimplemented => [PANIC_PARAMS, UNIMPLEMENTED]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PanicUnimplemented {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n-            if let ExprKind::Block(ref block, _) = expr.node;\n+            if let ExprKind::Block(ref block, _) = expr.kind;\n             if let Some(ref ex) = block.expr;\n-            if let ExprKind::Call(ref fun, ref params) = ex.node;\n-            if let ExprKind::Path(ref qpath) = fun.node;\n+            if let ExprKind::Call(ref fun, ref params) = ex.kind;\n+            if let ExprKind::Path(ref qpath) = fun.kind;\n             if let Some(fun_def_id) = resolve_node(cx, qpath, fun.hir_id).opt_def_id();\n             if match_def_path(cx, fun_def_id, &paths::BEGIN_PANIC);\n             if params.len() == 2;\n@@ -83,7 +83,7 @@ fn get_outer_span(expr: &Expr) -> Span {\n \n fn match_panic(params: &P<[Expr]>, expr: &Expr, cx: &LateContext<'_, '_>) {\n     if_chain! {\n-        if let ExprKind::Lit(ref lit) = params[0].node;\n+        if let ExprKind::Lit(ref lit) = params[0].kind;\n         if is_direct_expn_of(expr.span, \"panic\").is_some();\n         if let LitKind::Str(ref string, _) = lit.node;\n         let string = string.as_str().replace(\"{{\", \"\").replace(\"}}\", \"\");"}, {"sha": "ad046edf29e4e45d278451465bb29fd730827ce1", "filename": "clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -33,7 +33,7 @@ declare_lint_pass!(PartialEqNeImpl => [PARTIALEQ_NE_IMPL]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PartialEqNeImpl {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if_chain! {\n-            if let ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, ref impl_items) = item.node;\n+            if let ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, ref impl_items) = item.kind;\n             if !is_automatically_derived(&*item.attrs);\n             if let Some(eq_trait) = cx.tcx.lang_items().eq_trait();\n             if trait_ref.path.res.def_id() == eq_trait;"}, {"sha": "464845c3c741838aac965c08ac2d00a0a4bcdd20", "filename": "clippy_lints/src/path_buf_push_overwrite.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -43,12 +43,12 @@ declare_lint_pass!(PathBufPushOverwrite => [PATH_BUF_PUSH_OVERWRITE]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PathBufPushOverwrite {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n-            if let ExprKind::MethodCall(ref path, _, ref args) = expr.node;\n+            if let ExprKind::MethodCall(ref path, _, ref args) = expr.kind;\n             if path.ident.name == sym!(push);\n             if args.len() == 2;\n             if match_type(cx, walk_ptrs_ty(cx.tables.expr_ty(&args[0])), &paths::PATH_BUF);\n             if let Some(get_index_arg) = args.get(1);\n-            if let ExprKind::Lit(ref lit) = get_index_arg.node;\n+            if let ExprKind::Lit(ref lit) = get_index_arg.kind;\n             if let LitKind::Str(ref path_lit, _) = lit.node;\n             if let pushed_path = Path::new(&path_lit.as_str());\n             if let Some(pushed_path_lit) = pushed_path.to_str();"}, {"sha": "b00062cd55a146ebcc2376ec7b2fbe892ace7b9f", "filename": "clippy_lints/src/precedence.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprecedence.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -36,7 +36,7 @@ impl EarlyLintPass for Precedence {\n             return;\n         }\n \n-        if let ExprKind::Binary(Spanned { node: op, .. }, ref left, ref right) = expr.node {\n+        if let ExprKind::Binary(Spanned { node: op, .. }, ref left, ref right) = expr.kind {\n             let span_sugg = |expr: &Expr, sugg, appl| {\n                 span_lint_and_sugg(\n                     cx,\n@@ -85,11 +85,11 @@ impl EarlyLintPass for Precedence {\n             }\n         }\n \n-        if let ExprKind::Unary(UnOp::Neg, ref rhs) = expr.node {\n-            if let ExprKind::MethodCall(_, ref args) = rhs.node {\n+        if let ExprKind::Unary(UnOp::Neg, ref rhs) = expr.kind {\n+            if let ExprKind::MethodCall(_, ref args) = rhs.kind {\n                 if let Some(slf) = args.first() {\n-                    if let ExprKind::Lit(ref lit) = slf.node {\n-                        match lit.node {\n+                    if let ExprKind::Lit(ref lit) = slf.kind {\n+                        match lit.kind {\n                             LitKind::Int(..) | LitKind::Float(..) | LitKind::FloatUnsuffixed(..) => {\n                                 let mut applicability = Applicability::MachineApplicable;\n                                 span_lint_and_sugg(\n@@ -115,7 +115,7 @@ impl EarlyLintPass for Precedence {\n }\n \n fn is_arith_expr(expr: &Expr) -> bool {\n-    match expr.node {\n+    match expr.kind {\n         ExprKind::Binary(Spanned { node: op, .. }, _, _) => is_arith_op(op),\n         _ => false,\n     }"}, {"sha": "8b9e39e342778802f6a708c24e5bf84b7ca250a7", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -101,16 +101,16 @@ declare_lint_pass!(Ptr => [PTR_ARG, CMP_NULL, MUT_FROM_REF]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Ptr {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if let ItemKind::Fn(ref decl, _, _, body_id) = item.node {\n+        if let ItemKind::Fn(ref decl, _, _, body_id) = item.kind {\n             check_fn(cx, decl, item.hir_id, Some(body_id));\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n-        if let ImplItemKind::Method(ref sig, body_id) = item.node {\n+        if let ImplItemKind::Method(ref sig, body_id) = item.kind {\n             let parent_item = cx.tcx.hir().get_parent_item(item.hir_id);\n             if let Some(Node::Item(it)) = cx.tcx.hir().find(parent_item) {\n-                if let ItemKind::Impl(_, _, _, _, Some(_), _, _) = it.node {\n+                if let ItemKind::Impl(_, _, _, _, Some(_), _, _) = it.kind {\n                     return; // ignore trait impls\n                 }\n             }\n@@ -119,7 +119,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Ptr {\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n-        if let TraitItemKind::Method(ref sig, ref trait_method) = item.node {\n+        if let TraitItemKind::Method(ref sig, ref trait_method) = item.kind {\n             let body_id = if let TraitMethod::Provided(b) = *trait_method {\n                 Some(b)\n             } else {\n@@ -130,7 +130,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Ptr {\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprKind::Binary(ref op, ref l, ref r) = expr.node {\n+        if let ExprKind::Binary(ref op, ref l, ref r) = expr.kind {\n             if (op.node == BinOpKind::Eq || op.node == BinOpKind::Ne) && (is_null_path(l) || is_null_path(r)) {\n                 span_lint(\n                     cx,\n@@ -154,7 +154,7 @@ fn check_fn(cx: &LateContext<'_, '_>, decl: &FnDecl, fn_id: HirId, opt_body_id:\n             if is_type_diagnostic_item(cx, ty, Symbol::intern(\"vec_type\")) {\n                 let mut ty_snippet = None;\n                 if_chain! {\n-                    if let TyKind::Path(QPath::Resolved(_, ref path)) = walk_ptrs_hir_ty(arg).node;\n+                    if let TyKind::Path(QPath::Resolved(_, ref path)) = walk_ptrs_hir_ty(arg).kind;\n                     if let Some(&PathSegment{args: Some(ref parameters), ..}) = path.segments.last();\n                     then {\n                         let types: Vec<_> = parameters.args.iter().filter_map(|arg| match arg {\n@@ -219,8 +219,8 @@ fn check_fn(cx: &LateContext<'_, '_>, decl: &FnDecl, fn_id: HirId, opt_body_id:\n                 }\n             } else if match_type(cx, ty, &paths::COW) {\n                 if_chain! {\n-                    if let TyKind::Rptr(_, MutTy { ref ty, ..} ) = arg.node;\n-                    if let TyKind::Path(ref path) = ty.node;\n+                    if let TyKind::Rptr(_, MutTy { ref ty, ..} ) = arg.kind;\n+                    if let TyKind::Path(ref path) = ty.kind;\n                     if let QPath::Resolved(None, ref pp) = *path;\n                     if let [ref bx] = *pp.segments;\n                     if let Some(ref params) = bx.args;\n@@ -285,17 +285,17 @@ fn check_fn(cx: &LateContext<'_, '_>, decl: &FnDecl, fn_id: HirId, opt_body_id:\n }\n \n fn get_rptr_lm(ty: &Ty) -> Option<(&Lifetime, Mutability, Span)> {\n-    if let TyKind::Rptr(ref lt, ref m) = ty.node {\n+    if let TyKind::Rptr(ref lt, ref m) = ty.kind {\n         Some((lt, m.mutbl, ty.span))\n     } else {\n         None\n     }\n }\n \n fn is_null_path(expr: &Expr) -> bool {\n-    if let ExprKind::Call(ref pathexp, ref args) = expr.node {\n+    if let ExprKind::Call(ref pathexp, ref args) = expr.kind {\n         if args.is_empty() {\n-            if let ExprKind::Path(ref path) = pathexp.node {\n+            if let ExprKind::Path(ref path) = pathexp.kind {\n                 return match_qpath(path, &paths::PTR_NULL) || match_qpath(path, &paths::PTR_NULL_MUT);\n             }\n         }"}, {"sha": "d2e48e1d798452755aeae5382bd7a43fc76b726f", "filename": "clippy_lints/src/ptr_offset_with_cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -76,7 +76,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PtrOffsetWithCast {\n \n // If the given expression is a cast from a usize, return the lhs of the cast\n fn expr_as_cast_from_usize<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> Option<&'tcx Expr> {\n-    if let ExprKind::Cast(ref cast_lhs_expr, _) = expr.node {\n+    if let ExprKind::Cast(ref cast_lhs_expr, _) = expr.kind {\n         if is_expr_ty_usize(cx, &cast_lhs_expr) {\n             return Some(cast_lhs_expr);\n         }\n@@ -90,7 +90,7 @@ fn expr_as_ptr_offset_call<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     expr: &'tcx Expr,\n ) -> Option<(&'tcx Expr, &'tcx Expr, Method)> {\n-    if let ExprKind::MethodCall(ref path_segment, _, ref args) = expr.node {\n+    if let ExprKind::MethodCall(ref path_segment, _, ref args) = expr.kind {\n         if is_expr_ty_raw_ptr(cx, &args[0]) {\n             if path_segment.ident.name == sym!(offset) {\n                 return Some((&args[0], &args[1], Method::Offset));"}, {"sha": "fd8133066e4f2748c85c074525276785afaa0a93", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -49,7 +49,7 @@ impl QuestionMark {\n     fn check_is_none_and_early_return_none(cx: &LateContext<'_, '_>, expr: &Expr) {\n         if_chain! {\n             if let Some((if_expr, body, else_)) = higher::if_block(&expr);\n-            if let ExprKind::MethodCall(segment, _, args) = &if_expr.node;\n+            if let ExprKind::MethodCall(segment, _, args) = &if_expr.kind;\n             if segment.ident.name == sym!(is_none);\n             if Self::expression_returns_none(cx, body);\n             if let Some(subject) = args.get(0);\n@@ -60,7 +60,7 @@ impl QuestionMark {\n                 let mut replacement: Option<String> = None;\n                 if let Some(else_) = else_ {\n                     if_chain! {\n-                        if let ExprKind::Block(block, None) = &else_.node;\n+                        if let ExprKind::Block(block, None) = &else_.kind;\n                         if block.stmts.len() == 0;\n                         if let Some(block_expr) = &block.expr;\n                         if SpanlessEq::new(cx).ignore_fn().eq_expr(subject, block_expr);\n@@ -107,7 +107,7 @@ impl QuestionMark {\n     }\n \n     fn expression_returns_none(cx: &LateContext<'_, '_>, expression: &Expr) -> bool {\n-        match expression.node {\n+        match expression.kind {\n             ExprKind::Block(ref block, _) => {\n                 if let Some(return_expression) = Self::return_expression(block) {\n                     return Self::expression_returns_none(cx, &return_expression);\n@@ -134,8 +134,8 @@ impl QuestionMark {\n         if_chain! {\n             if block.stmts.len() == 1;\n             if let Some(expr) = block.stmts.iter().last();\n-            if let StmtKind::Semi(ref expr) = expr.node;\n-            if let ExprKind::Ret(ref ret_expr) = expr.node;\n+            if let StmtKind::Semi(ref expr) = expr.kind;\n+            if let ExprKind::Ret(ref ret_expr) = expr.kind;\n             if let &Some(ref ret_expr) = ret_expr;\n \n             then {\n@@ -146,7 +146,7 @@ impl QuestionMark {\n         // Check for `return` without a semicolon.\n         if_chain! {\n             if block.stmts.len() == 0;\n-            if let Some(ExprKind::Ret(Some(ret_expr))) = block.expr.as_ref().map(|e| &e.node);\n+            if let Some(ExprKind::Ret(Some(ret_expr))) = block.expr.as_ref().map(|e| &e.kind);\n             then {\n                 return Some(ret_expr);\n             }"}, {"sha": "03a969c9e0c74158b0e7d444e778c59f332beff9", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -109,7 +109,7 @@ declare_lint_pass!(Ranges => [\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Ranges {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprKind::MethodCall(ref path, _, ref args) = expr.node {\n+        if let ExprKind::MethodCall(ref path, _, ref args) = expr.kind {\n             let name = path.ident.as_str();\n \n             // Range with step_by(0).\n@@ -124,7 +124,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Ranges {\n                     );\n                 }\n             } else if name == \"zip\" && args.len() == 2 {\n-                let iter = &args[0].node;\n+                let iter = &args[0].kind;\n                 let zip_arg = &args[1];\n                 if_chain! {\n                     // `.iter()` call\n@@ -134,11 +134,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Ranges {\n                     if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(cx, zip_arg);\n                     if is_integer_const(cx, start, 0);\n                     // `.len()` call\n-                    if let ExprKind::MethodCall(ref len_path, _, ref len_args) = end.node;\n+                    if let ExprKind::MethodCall(ref len_path, _, ref len_args) = end.kind;\n                     if len_path.ident.name == sym!(len) && len_args.len() == 1;\n                     // `.iter()` and `.len()` called on same `Path`\n-                    if let ExprKind::Path(QPath::Resolved(_, ref iter_path)) = iter_args[0].node;\n-                    if let ExprKind::Path(QPath::Resolved(_, ref len_path)) = len_args[0].node;\n+                    if let ExprKind::Path(QPath::Resolved(_, ref iter_path)) = iter_args[0].kind;\n+                    if let ExprKind::Path(QPath::Resolved(_, ref len_path)) = len_args[0].kind;\n                     if SpanlessEq::new(cx).eq_path_segments(&iter_path.segments, &len_path.segments);\n                      then {\n                          span_lint(cx,\n@@ -240,7 +240,7 @@ fn has_step_by(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n }\n \n fn y_plus_one<'t>(cx: &LateContext<'_, '_>, expr: &'t Expr) -> Option<&'t Expr> {\n-    match expr.node {\n+    match expr.kind {\n         ExprKind::Binary(\n             Spanned {\n                 node: BinOpKind::Add, ..\n@@ -261,7 +261,7 @@ fn y_plus_one<'t>(cx: &LateContext<'_, '_>, expr: &'t Expr) -> Option<&'t Expr>\n }\n \n fn y_minus_one<'t>(cx: &LateContext<'_, '_>, expr: &'t Expr) -> Option<&'t Expr> {\n-    match expr.node {\n+    match expr.kind {\n         ExprKind::Binary(\n             Spanned {\n                 node: BinOpKind::Sub, .."}, {"sha": "c666ca93649b9614aefab990bba5cd6fb72b3557", "filename": "clippy_lints/src/redundant_field_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fredundant_field_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fredundant_field_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_field_names.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -36,12 +36,12 @@ declare_lint_pass!(RedundantFieldNames => [REDUNDANT_FIELD_NAMES]);\n \n impl EarlyLintPass for RedundantFieldNames {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n-        if let ExprKind::Struct(_, ref fields, _) = expr.node {\n+        if let ExprKind::Struct(_, ref fields, _) = expr.kind {\n             for field in fields {\n                 if field.is_shorthand {\n                     continue;\n                 }\n-                if let ExprKind::Path(None, path) = &field.expr.node {\n+                if let ExprKind::Path(None, path) = &field.expr.kind {\n                     if path.segments.len() == 1\n                         && path.segments[0].ident == field.ident\n                         && path.segments[0].args.is_none()"}, {"sha": "2af3634be432d153905bc964eb23cc91a868d182", "filename": "clippy_lints/src/redundant_pattern_matching.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fredundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fredundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_pattern_matching.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -46,7 +46,7 @@ declare_lint_pass!(RedundantPatternMatching => [REDUNDANT_PATTERN_MATCHING]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantPatternMatching {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprKind::Match(ref op, ref arms, ref match_source) = expr.node {\n+        if let ExprKind::Match(ref op, ref arms, ref match_source) = expr.kind {\n             match match_source {\n                 MatchSource::Normal => find_sugg_for_match(cx, expr, op, arms),\n                 MatchSource::IfLetDesugar { contains_else_clause } => {\n@@ -65,9 +65,9 @@ fn find_sugg_for_if_let<'a, 'tcx>(\n     arms: &HirVec<Arm>,\n     has_else: bool,\n ) {\n-    let good_method = match arms[0].pat.node {\n+    let good_method = match arms[0].pat.kind {\n         PatKind::TupleStruct(ref path, ref patterns, _) if patterns.len() == 1 => {\n-            if let PatKind::Wild = patterns[0].node {\n+            if let PatKind::Wild = patterns[0].kind {\n                 if match_qpath(path, &paths::RESULT_OK) {\n                     \"is_ok()\"\n                 } else if match_qpath(path, &paths::RESULT_ERR) {\n@@ -108,14 +108,14 @@ fn find_sugg_for_if_let<'a, 'tcx>(\n \n fn find_sugg_for_match<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, op: &P<Expr>, arms: &HirVec<Arm>) {\n     if arms.len() == 2 {\n-        let node_pair = (&arms[0].pat.node, &arms[1].pat.node);\n+        let node_pair = (&arms[0].pat.kind, &arms[1].pat.kind);\n \n         let found_good_method = match node_pair {\n             (\n                 PatKind::TupleStruct(ref path_left, ref patterns_left, _),\n                 PatKind::TupleStruct(ref path_right, ref patterns_right, _),\n             ) if patterns_left.len() == 1 && patterns_right.len() == 1 => {\n-                if let (PatKind::Wild, PatKind::Wild) = (&patterns_left[0].node, &patterns_right[0].node) {\n+                if let (PatKind::Wild, PatKind::Wild) = (&patterns_left[0].kind, &patterns_right[0].kind) {\n                     find_good_method_for_match(\n                         arms,\n                         path_left,\n@@ -133,7 +133,7 @@ fn find_sugg_for_match<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, o\n             | (PatKind::Path(ref path_left), PatKind::TupleStruct(ref path_right, ref patterns, _))\n                 if patterns.len() == 1 =>\n             {\n-                if let PatKind::Wild = patterns[0].node {\n+                if let PatKind::Wild = patterns[0].kind {\n                     find_good_method_for_match(\n                         arms,\n                         path_left,\n@@ -180,9 +180,9 @@ fn find_good_method_for_match<'a>(\n     should_be_right: &'a str,\n ) -> Option<&'a str> {\n     let body_node_pair = if match_qpath(path_left, expected_left) && match_qpath(path_right, expected_right) {\n-        (&(*arms[0].body).node, &(*arms[1].body).node)\n+        (&(*arms[0].body).kind, &(*arms[1].body).kind)\n     } else if match_qpath(path_right, expected_left) && match_qpath(path_left, expected_right) {\n-        (&(*arms[1].body).node, &(*arms[0].body).node)\n+        (&(*arms[1].body).kind, &(*arms[0].body).kind)\n     } else {\n         return None;\n     };"}, {"sha": "06af5f9ecc1a6bfa3d74da9f4c074d2a1f59c423", "filename": "clippy_lints/src/redundant_static_lifetimes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -34,7 +34,7 @@ declare_lint_pass!(RedundantStaticLifetimes => [REDUNDANT_STATIC_LIFETIMES]);\n impl RedundantStaticLifetimes {\n     // Recursively visit types\n     fn visit_type(&mut self, ty: &Ty, cx: &EarlyContext<'_>, reason: &str) {\n-        match ty.node {\n+        match ty.kind {\n             // Be careful of nested structures (arrays and tuples)\n             TyKind::Array(ref ty, _) => {\n                 self.visit_type(&*ty, cx, reason);\n@@ -48,7 +48,7 @@ impl RedundantStaticLifetimes {\n             TyKind::Rptr(ref optional_lifetime, ref borrow_type) => {\n                 // Match the 'static lifetime\n                 if let Some(lifetime) = *optional_lifetime {\n-                    match borrow_type.ty.node {\n+                    match borrow_type.ty.kind {\n                         TyKind::Path(..) | TyKind::Slice(..) | TyKind::Array(..) | TyKind::Tup(..) => {\n                             if lifetime.ident.name == syntax::symbol::kw::StaticLifetime {\n                                 let snip = snippet(cx, borrow_type.ty.span, \"<type>\");\n@@ -79,13 +79,13 @@ impl RedundantStaticLifetimes {\n impl EarlyLintPass for RedundantStaticLifetimes {\n     fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n         if !item.span.from_expansion() {\n-            if let ItemKind::Const(ref var_type, _) = item.node {\n+            if let ItemKind::Const(ref var_type, _) = item.kind {\n                 self.visit_type(var_type, cx, \"Constants have by default a `'static` lifetime\");\n                 // Don't check associated consts because `'static` cannot be elided on those (issue\n                 // #2438)\n             }\n \n-            if let ItemKind::Static(ref var_type, _, _) = item.node {\n+            if let ItemKind::Static(ref var_type, _, _) = item.kind {\n                 self.visit_type(var_type, cx, \"Statics have by default a `'static` lifetime\");\n             }\n         }"}, {"sha": "d9628558697a14b5884a8a02c1de0d26393243df", "filename": "clippy_lints/src/reference.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freference.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -27,7 +27,7 @@ declare_clippy_lint! {\n declare_lint_pass!(DerefAddrOf => [DEREF_ADDROF]);\n \n fn without_parens(mut e: &Expr) -> &Expr {\n-    while let ExprKind::Paren(ref child_e) = e.node {\n+    while let ExprKind::Paren(ref child_e) = e.kind {\n         e = child_e;\n     }\n     e\n@@ -36,8 +36,8 @@ fn without_parens(mut e: &Expr) -> &Expr {\n impl EarlyLintPass for DerefAddrOf {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &Expr) {\n         if_chain! {\n-            if let ExprKind::Unary(UnOp::Deref, ref deref_target) = e.node;\n-            if let ExprKind::AddrOf(_, ref addrof_target) = without_parens(deref_target).node;\n+            if let ExprKind::Unary(UnOp::Deref, ref deref_target) = e.kind;\n+            if let ExprKind::AddrOf(_, ref addrof_target) = without_parens(deref_target).kind;\n             if !in_macro(addrof_target.span);\n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n@@ -78,9 +78,9 @@ declare_lint_pass!(RefInDeref => [REF_IN_DEREF]);\n impl EarlyLintPass for RefInDeref {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &Expr) {\n         if_chain! {\n-            if let ExprKind::Field(ref object, _) = e.node;\n-            if let ExprKind::Paren(ref parened) = object.node;\n-            if let ExprKind::AddrOf(_, ref inner) = parened.node;\n+            if let ExprKind::Field(ref object, _) = e.kind;\n+            if let ExprKind::Paren(ref parened) = object.kind;\n+            if let ExprKind::AddrOf(_, ref inner) = parened.kind;\n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n                 span_lint_and_sugg("}, {"sha": "22c4b107f0067620932c30e06e87df890daa9ed4", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -107,8 +107,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Regex {\n \n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n-            if let ExprKind::Call(ref fun, ref args) = expr.node;\n-            if let ExprKind::Path(ref qpath) = fun.node;\n+            if let ExprKind::Call(ref fun, ref args) = expr.kind;\n+            if let ExprKind::Path(ref qpath) = fun.kind;\n             if args.len() == 1;\n             if let Some(def_id) = cx.tables.qpath_res(qpath, fun.hir_id).opt_def_id();\n             then {\n@@ -185,8 +185,8 @@ fn is_trivial_regex(s: &regex_syntax::hir::Hir) -> Option<&'static str> {\n \n fn check_set<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, utf8: bool) {\n     if_chain! {\n-        if let ExprKind::AddrOf(_, ref expr) = expr.node;\n-        if let ExprKind::Array(ref exprs) = expr.node;\n+        if let ExprKind::AddrOf(_, ref expr) = expr.kind;\n+        if let ExprKind::Array(ref exprs) = expr.kind;\n         then {\n             for expr in exprs {\n                 check_regex(cx, expr, utf8);\n@@ -201,7 +201,7 @@ fn check_regex<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, utf8: boo\n         .allow_invalid_utf8(!utf8)\n         .build();\n \n-    if let ExprKind::Lit(ref lit) = expr.node {\n+    if let ExprKind::Lit(ref lit) = expr.kind {\n         if let LitKind::Str(ref r, style) = lit.node {\n             let r = &r.as_str();\n             let offset = if let StrStyle::Raw(n) = style { 2 + n } else { 1 };"}, {"sha": "d3dd4cb9041fa79c98f1162ab72d30a08d7d94aa", "filename": "clippy_lints/src/replace_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Freplace_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Freplace_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freplace_consts.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -36,7 +36,7 @@ declare_lint_pass!(ReplaceConsts => [REPLACE_CONSTS]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ReplaceConsts {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n         if_chain! {\n-            if let hir::ExprKind::Path(ref qp) = expr.node;\n+            if let hir::ExprKind::Path(ref qp) = expr.kind;\n             if let Res::Def(DefKind::Const, def_id) = cx.tables.qpath_res(qp, expr.hir_id);\n             then {\n                 for (const_path, repl_snip) in &REPLACEMENTS {"}, {"sha": "47fdc226e9920e572936089c495fca7f187ec282", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -95,7 +95,7 @@ impl Return {\n     // Check the final stmt or expr in a block for unnecessary return.\n     fn check_block_return(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n         if let Some(stmt) = block.stmts.last() {\n-            match stmt.node {\n+            match stmt.kind {\n                 ast::StmtKind::Expr(ref expr) | ast::StmtKind::Semi(ref expr) => {\n                     self.check_final_expr(cx, expr, Some(stmt.span), RetReplacement::Empty);\n                 },\n@@ -112,7 +112,7 @@ impl Return {\n         span: Option<Span>,\n         replacement: RetReplacement,\n     ) {\n-        match expr.node {\n+        match expr.kind {\n             // simple return is always \"bad\"\n             ast::ExprKind::Ret(ref inner) => {\n                 // allow `#[cfg(a)] return a; #[cfg(b)] return b;`\n@@ -197,15 +197,15 @@ impl Return {\n         // we need both a let-binding stmt and an expr\n         if_chain! {\n             if let Some(retexpr) = it.next_back();\n-            if let ast::StmtKind::Expr(ref retexpr) = retexpr.node;\n+            if let ast::StmtKind::Expr(ref retexpr) = retexpr.kind;\n             if let Some(stmt) = it.next_back();\n-            if let ast::StmtKind::Local(ref local) = stmt.node;\n+            if let ast::StmtKind::Local(ref local) = stmt.kind;\n             // don't lint in the presence of type inference\n             if local.ty.is_none();\n             if local.attrs.is_empty();\n             if let Some(ref initexpr) = local.init;\n-            if let ast::PatKind::Ident(_, ident, _) = local.pat.node;\n-            if let ast::ExprKind::Path(_, ref path) = retexpr.node;\n+            if let ast::PatKind::Ident(_, ident, _) = local.pat.kind;\n+            if let ast::ExprKind::Path(_, ref path) = retexpr.kind;\n             if match_path_ast(path, &[&*ident.name.as_str()]);\n             if !in_external_macro(cx.sess(), initexpr.span);\n             if !in_external_macro(cx.sess(), retexpr.span);\n@@ -246,7 +246,7 @@ impl EarlyLintPass for Return {\n         }\n         if_chain! {\n             if let ast::FunctionRetTy::Ty(ref ty) = decl.output;\n-            if let ast::TyKind::Tup(ref vals) = ty.node;\n+            if let ast::TyKind::Tup(ref vals) = ty.kind;\n             if vals.is_empty() && !ty.span.from_expansion() && get_def(span) == get_def(ty.span);\n             then {\n                 let (rspan, appl) = if let Ok(fn_source) =\n@@ -278,7 +278,7 @@ impl EarlyLintPass for Return {\n         self.check_let_return(cx, block);\n         if_chain! {\n             if let Some(ref stmt) = block.stmts.last();\n-            if let ast::StmtKind::Expr(ref expr) = stmt.node;\n+            if let ast::StmtKind::Expr(ref expr) = stmt.kind;\n             if is_unit_expr(expr) && !stmt.span.from_expansion();\n             then {\n                 let sp = expr.span;\n@@ -295,7 +295,7 @@ impl EarlyLintPass for Return {\n     }\n \n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n-        match e.node {\n+        match e.kind {\n             ast::ExprKind::Ret(Some(ref expr)) | ast::ExprKind::Break(_, Some(ref expr)) => {\n                 if is_unit_expr(expr) && !expr.span.from_expansion() {\n                     span_lint_and_then(cx, UNUSED_UNIT, expr.span, \"unneeded `()`\", |db| {\n@@ -328,7 +328,7 @@ fn get_def(span: Span) -> Option<Span> {\n \n // is this expr a `()` unit?\n fn is_unit_expr(expr: &ast::Expr) -> bool {\n-    if let ast::ExprKind::Tup(ref vals) = expr.node {\n+    if let ast::ExprKind::Tup(ref vals) = expr.kind {\n         vals.is_empty()\n     } else {\n         false"}, {"sha": "a71a7fdaba18a5114a64ad7baeb52f889313bcc3", "filename": "clippy_lints/src/serde_api.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fserde_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fserde_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fserde_api.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -22,7 +22,7 @@ declare_lint_pass!(SerdeAPI => [SERDE_API_MISUSE]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SerdeAPI {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if let ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, ref items) = item.node {\n+        if let ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, ref items) = item.kind {\n             let did = trait_ref.path.res.def_id();\n             if let Some(visit_did) = get_trait_def_id(cx, &paths::SERDE_DE_VISITOR) {\n                 if did == visit_did {"}, {"sha": "4797b701efa0cb2f3ef79d40ac38747cb6a19b0e", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -102,7 +102,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Shadow {\n fn check_fn<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, decl: &'tcx FnDecl, body: &'tcx Body) {\n     let mut bindings = Vec::new();\n     for arg in iter_input_pats(decl, body) {\n-        if let PatKind::Binding(.., ident, _) = arg.pat.node {\n+        if let PatKind::Binding(.., ident, _) = arg.pat.kind {\n             bindings.push((ident.name, ident.span))\n         }\n     }\n@@ -112,7 +112,7 @@ fn check_fn<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, decl: &'tcx FnDecl, body: &'tc\n fn check_block<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, block: &'tcx Block, bindings: &mut Vec<(Name, Span)>) {\n     let len = bindings.len();\n     for stmt in &block.stmts {\n-        match stmt.node {\n+        match stmt.kind {\n             StmtKind::Local(ref local) => check_local(cx, local, bindings),\n             StmtKind::Expr(ref e) | StmtKind::Semi(ref e) => check_expr(cx, e, bindings),\n             StmtKind::Item(..) => {},\n@@ -165,7 +165,7 @@ fn check_pat<'a, 'tcx>(\n     bindings: &mut Vec<(Name, Span)>,\n ) {\n     // TODO: match more stuff / destructuring\n-    match pat.node {\n+    match pat.kind {\n         PatKind::Binding(.., ident, ref inner) => {\n             let name = ident.name;\n             if is_binding(cx, pat.hir_id) {\n@@ -188,7 +188,7 @@ fn check_pat<'a, 'tcx>(\n         },\n         PatKind::Struct(_, ref pfields, _) => {\n             if let Some(init_struct) = init {\n-                if let ExprKind::Struct(_, ref efields, _) = init_struct.node {\n+                if let ExprKind::Struct(_, ref efields, _) = init_struct.kind {\n                     for field in pfields {\n                         let name = field.ident.name;\n                         let efield = efields\n@@ -209,7 +209,7 @@ fn check_pat<'a, 'tcx>(\n         },\n         PatKind::Tuple(ref inner, _) => {\n             if let Some(init_tup) = init {\n-                if let ExprKind::Tup(ref tup) = init_tup.node {\n+                if let ExprKind::Tup(ref tup) = init_tup.kind {\n                     for (i, p) in inner.iter().enumerate() {\n                         check_pat(cx, p, Some(&tup[i]), p.span, bindings);\n                     }\n@@ -226,7 +226,7 @@ fn check_pat<'a, 'tcx>(\n         },\n         PatKind::Box(ref inner) => {\n             if let Some(initp) = init {\n-                if let ExprKind::Box(ref inner_init) = initp.node {\n+                if let ExprKind::Box(ref inner_init) = initp.kind {\n                     check_pat(cx, inner, Some(&**inner_init), span, bindings);\n                 } else {\n                     check_pat(cx, inner, init, span, bindings);\n@@ -312,7 +312,7 @@ fn check_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, bindings:\n     if in_external_macro(cx.sess(), expr.span) {\n         return;\n     }\n-    match expr.node {\n+    match expr.kind {\n         ExprKind::Unary(_, ref e) | ExprKind::Field(ref e, _) | ExprKind::AddrOf(_, ref e) | ExprKind::Box(ref e) => {\n             check_expr(cx, e, bindings)\n         },\n@@ -344,7 +344,7 @@ fn check_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, bindings:\n }\n \n fn check_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: &'tcx Ty, bindings: &mut Vec<(Name, Span)>) {\n-    match ty.node {\n+    match ty.kind {\n         TyKind::Slice(ref sty) => check_ty(cx, sty, bindings),\n         TyKind::Array(ref fty, ref anon_const) => {\n             check_ty(cx, fty, bindings);\n@@ -364,7 +364,7 @@ fn check_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: &'tcx Ty, bindings: &mut V\n }\n \n fn is_self_shadow(name: Name, expr: &Expr) -> bool {\n-    match expr.node {\n+    match expr.kind {\n         ExprKind::Box(ref inner) | ExprKind::AddrOf(_, ref inner) => is_self_shadow(name, inner),\n         ExprKind::Block(ref block, _) => {\n             block.stmts.is_empty() && block.expr.as_ref().map_or(false, |e| is_self_shadow(name, e))"}, {"sha": "3b9985a42451e5a9e35ff82989cd5d4d696fb86a", "filename": "clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -62,10 +62,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SlowVectorInit {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // Matches initialization on reassignements. For example: `vec = Vec::with_capacity(100)`\n         if_chain! {\n-            if let ExprKind::Assign(ref left, ref right) = expr.node;\n+            if let ExprKind::Assign(ref left, ref right) = expr.kind;\n \n             // Extract variable name\n-            if let ExprKind::Path(QPath::Resolved(_, ref path)) = left.node;\n+            if let ExprKind::Path(QPath::Resolved(_, ref path)) = left.kind;\n             if let Some(variable_name) = path.segments.get(0);\n \n             // Extract len argument\n@@ -86,8 +86,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SlowVectorInit {\n     fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n         // Matches statements which initializes vectors. For example: `let mut vec = Vec::with_capacity(10)`\n         if_chain! {\n-            if let StmtKind::Local(ref local) = stmt.node;\n-            if let PatKind::Binding(BindingAnnotation::Mutable, .., variable_name, None) = local.pat.node;\n+            if let StmtKind::Local(ref local) = stmt.kind;\n+            if let PatKind::Binding(BindingAnnotation::Mutable, .., variable_name, None) = local.pat.kind;\n             if let Some(ref init) = local.init;\n             if let Some(ref len_arg) = Self::is_vec_with_capacity(init);\n \n@@ -109,8 +109,8 @@ impl SlowVectorInit {\n     /// of the first argument of `with_capacity` call if it matches or `None` if it does not.\n     fn is_vec_with_capacity(expr: &Expr) -> Option<&Expr> {\n         if_chain! {\n-            if let ExprKind::Call(ref func, ref args) = expr.node;\n-            if let ExprKind::Path(ref path) = func.node;\n+            if let ExprKind::Call(ref func, ref args) = expr.kind;\n+            if let ExprKind::Path(ref path) = func.kind;\n             if match_qpath(path, &[\"Vec\", \"with_capacity\"]);\n             if args.len() == 1;\n \n@@ -200,8 +200,8 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     fn search_slow_extend_filling(&mut self, expr: &'tcx Expr) {\n         if_chain! {\n             if self.initialization_found;\n-            if let ExprKind::MethodCall(ref path, _, ref args) = expr.node;\n-            if let ExprKind::Path(ref qpath_subj) = args[0].node;\n+            if let ExprKind::MethodCall(ref path, _, ref args) = expr.kind;\n+            if let ExprKind::Path(ref qpath_subj) = args[0].kind;\n             if match_qpath(&qpath_subj, &[&*self.vec_alloc.variable_name.as_str()]);\n             if path.ident.name == sym!(extend);\n             if let Some(ref extend_arg) = args.get(1);\n@@ -217,14 +217,14 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     fn search_slow_resize_filling(&mut self, expr: &'tcx Expr) {\n         if_chain! {\n             if self.initialization_found;\n-            if let ExprKind::MethodCall(ref path, _, ref args) = expr.node;\n-            if let ExprKind::Path(ref qpath_subj) = args[0].node;\n+            if let ExprKind::MethodCall(ref path, _, ref args) = expr.kind;\n+            if let ExprKind::Path(ref qpath_subj) = args[0].kind;\n             if match_qpath(&qpath_subj, &[&*self.vec_alloc.variable_name.as_str()]);\n             if path.ident.name == sym!(resize);\n             if let (Some(ref len_arg), Some(fill_arg)) = (args.get(1), args.get(2));\n \n             // Check that is filled with 0\n-            if let ExprKind::Lit(ref lit) = fill_arg.node;\n+            if let ExprKind::Lit(ref lit) = fill_arg.kind;\n             if let LitKind::Int(0, _) = lit.node;\n \n             // Check that len expression is equals to `with_capacity` expression\n@@ -239,7 +239,7 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     /// Returns `true` if give expression is `repeat(0).take(...)`\n     fn is_repeat_take(&self, expr: &Expr) -> bool {\n         if_chain! {\n-            if let ExprKind::MethodCall(ref take_path, _, ref take_args) = expr.node;\n+            if let ExprKind::MethodCall(ref take_path, _, ref take_args) = expr.kind;\n             if take_path.ident.name == sym!(take);\n \n             // Check that take is applied to `repeat(0)`\n@@ -261,11 +261,11 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     /// Returns `true` if given expression is `repeat(0)`\n     fn is_repeat_zero(&self, expr: &Expr) -> bool {\n         if_chain! {\n-            if let ExprKind::Call(ref fn_expr, ref repeat_args) = expr.node;\n-            if let ExprKind::Path(ref qpath_repeat) = fn_expr.node;\n+            if let ExprKind::Call(ref fn_expr, ref repeat_args) = expr.kind;\n+            if let ExprKind::Path(ref qpath_repeat) = fn_expr.kind;\n             if match_qpath(&qpath_repeat, &[\"repeat\"]);\n             if let Some(ref repeat_arg) = repeat_args.get(0);\n-            if let ExprKind::Lit(ref lit) = repeat_arg.node;\n+            if let ExprKind::Lit(ref lit) = repeat_arg.kind;\n             if let LitKind::Int(0, _) = lit.node;\n \n             then {\n@@ -280,7 +280,7 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n impl<'a, 'tcx> Visitor<'tcx> for VectorInitializationVisitor<'a, 'tcx> {\n     fn visit_stmt(&mut self, stmt: &'tcx Stmt) {\n         if self.initialization_found {\n-            match stmt.node {\n+            match stmt.kind {\n                 StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => {\n                     self.search_slow_extend_filling(expr);\n                     self.search_slow_resize_filling(expr);"}, {"sha": "fca70fe8dbde39a64752a78bb409388553f9f41a", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -83,13 +83,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringAdd {\n             },\n             ref left,\n             _,\n-        ) = e.node\n+        ) = e.kind\n         {\n             if is_string(cx, left) {\n                 if !is_allowed(cx, STRING_ADD_ASSIGN, e.hir_id) {\n                     let parent = get_parent_expr(cx, e);\n                     if let Some(p) = parent {\n-                        if let ExprKind::Assign(ref target, _) = p.node {\n+                        if let ExprKind::Assign(ref target, _) = p.kind {\n                             // avoid duplicate matches\n                             if SpanlessEq::new(cx).eq_expr(target, left) {\n                                 return;\n@@ -104,7 +104,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringAdd {\n                     \"you added something to a string. Consider using `String::push_str()` instead\",\n                 );\n             }\n-        } else if let ExprKind::Assign(ref target, ref src) = e.node {\n+        } else if let ExprKind::Assign(ref target, ref src) = e.kind {\n             if is_string(cx, target) && is_add(cx, src, target) {\n                 span_lint(\n                     cx,\n@@ -123,7 +123,7 @@ fn is_string(cx: &LateContext<'_, '_>, e: &Expr) -> bool {\n }\n \n fn is_add(cx: &LateContext<'_, '_>, src: &Expr, target: &Expr) -> bool {\n-    match src.node {\n+    match src.kind {\n         ExprKind::Binary(\n             Spanned {\n                 node: BinOpKind::Add, ..\n@@ -148,9 +148,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringLitAsBytes {\n         use crate::utils::{snippet, snippet_with_applicability};\n         use syntax::ast::{LitKind, StrStyle};\n \n-        if let ExprKind::MethodCall(ref path, _, ref args) = e.node {\n+        if let ExprKind::MethodCall(ref path, _, ref args) = e.kind {\n             if path.ident.name == sym!(as_bytes) {\n-                if let ExprKind::Lit(ref lit) = args[0].node {\n+                if let ExprKind::Lit(ref lit) = args[0].kind {\n                     if let LitKind::Str(ref lit_content, style) = lit.node {\n                         let callsite = snippet(cx, args[0].span.source_callsite(), r#\"\"foo\"\"#);\n                         let expanded = if let StrStyle::Raw(n) = style {"}, {"sha": "c91768be6d8a0aad7ea252eb22b4da104ed4cf51", "filename": "clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -53,7 +53,7 @@ declare_lint_pass!(SuspiciousImpl => [SUSPICIOUS_ARITHMETIC_IMPL, SUSPICIOUS_OP_\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n-        if let hir::ExprKind::Binary(binop, _, _) = expr.node {\n+        if let hir::ExprKind::Binary(binop, _, _) = expr.kind {\n             match binop.node {\n                 hir::BinOpKind::Eq\n                 | hir::BinOpKind::Lt\n@@ -68,7 +68,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n             let mut parent_expr = cx.tcx.hir().get_parent_node(expr.hir_id);\n             while parent_expr != hir::CRATE_HIR_ID {\n                 if let hir::Node::Expr(e) = cx.tcx.hir().get(parent_expr) {\n-                    match e.node {\n+                    match e.kind {\n                         hir::ExprKind::Binary(..)\n                         | hir::ExprKind::Unary(hir::UnOp::UnNot, _)\n                         | hir::ExprKind::Unary(hir::UnOp::UnNeg, _) => return,\n@@ -185,7 +185,7 @@ struct BinaryExprVisitor {\n \n impl<'a, 'tcx> Visitor<'tcx> for BinaryExprVisitor {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        match expr.node {\n+        match expr.kind {\n             hir::ExprKind::Binary(..)\n             | hir::ExprKind::Unary(hir::UnOp::UnNot, _)\n             | hir::ExprKind::Unary(hir::UnOp::UnNeg, _) => self.in_binary_expr = true,"}, {"sha": "b278171abceb6f61abd7110cdcea9acebb3099f5", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -79,18 +79,18 @@ fn check_manual_swap(cx: &LateContext<'_, '_>, block: &Block) {\n     for w in block.stmts.windows(3) {\n         if_chain! {\n             // let t = foo();\n-            if let StmtKind::Local(ref tmp) = w[0].node;\n+            if let StmtKind::Local(ref tmp) = w[0].kind;\n             if let Some(ref tmp_init) = tmp.init;\n-            if let PatKind::Binding(.., ident, None) = tmp.pat.node;\n+            if let PatKind::Binding(.., ident, None) = tmp.pat.kind;\n \n             // foo() = bar();\n-            if let StmtKind::Semi(ref first) = w[1].node;\n-            if let ExprKind::Assign(ref lhs1, ref rhs1) = first.node;\n+            if let StmtKind::Semi(ref first) = w[1].kind;\n+            if let ExprKind::Assign(ref lhs1, ref rhs1) = first.kind;\n \n             // bar() = t;\n-            if let StmtKind::Semi(ref second) = w[2].node;\n-            if let ExprKind::Assign(ref lhs2, ref rhs2) = second.node;\n-            if let ExprKind::Path(QPath::Resolved(None, ref rhs2)) = rhs2.node;\n+            if let StmtKind::Semi(ref second) = w[2].kind;\n+            if let ExprKind::Assign(ref lhs2, ref rhs2) = second.kind;\n+            if let ExprKind::Path(QPath::Resolved(None, ref rhs2)) = rhs2.kind;\n             if rhs2.segments.len() == 1;\n \n             if ident.as_str() == rhs2.segments[0].ident.as_str();\n@@ -102,8 +102,8 @@ fn check_manual_swap(cx: &LateContext<'_, '_>, block: &Block) {\n                     lhs1: &'a Expr,\n                     lhs2: &'a Expr,\n                 ) -> Option<(&'a Expr, &'a Expr, &'a Expr)> {\n-                    if let ExprKind::Index(ref lhs1, ref idx1) = lhs1.node {\n-                        if let ExprKind::Index(ref lhs2, ref idx2) = lhs2.node {\n+                    if let ExprKind::Index(ref lhs1, ref idx1) = lhs1.kind {\n+                        if let ExprKind::Index(ref lhs2, ref idx2) = lhs2.kind {\n                             if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, lhs2) {\n                                 let ty = walk_ptrs_ty(cx.tables.expr_ty(lhs1));\n \n@@ -120,8 +120,8 @@ fn check_manual_swap(cx: &LateContext<'_, '_>, block: &Block) {\n                     None\n                 }\n \n-                if let ExprKind::Field(ref lhs1, _) = lhs1.node {\n-                    if let ExprKind::Field(ref lhs2, _) = lhs2.node {\n+                if let ExprKind::Field(ref lhs1, _) = lhs1.kind {\n+                    if let ExprKind::Field(ref lhs2, _) = lhs2.kind {\n                         if lhs1.hir_id.owner_def_id() == lhs2.hir_id.owner_def_id() {\n                             return;\n                         }\n@@ -175,11 +175,11 @@ fn check_manual_swap(cx: &LateContext<'_, '_>, block: &Block) {\n fn check_suspicious_swap(cx: &LateContext<'_, '_>, block: &Block) {\n     for w in block.stmts.windows(2) {\n         if_chain! {\n-            if let StmtKind::Semi(ref first) = w[0].node;\n-            if let StmtKind::Semi(ref second) = w[1].node;\n+            if let StmtKind::Semi(ref first) = w[0].kind;\n+            if let StmtKind::Semi(ref second) = w[1].kind;\n             if !differing_macro_contexts(first.span, second.span);\n-            if let ExprKind::Assign(ref lhs0, ref rhs0) = first.node;\n-            if let ExprKind::Assign(ref lhs1, ref rhs1) = second.node;\n+            if let ExprKind::Assign(ref lhs0, ref rhs0) = first.kind;\n+            if let ExprKind::Assign(ref lhs1, ref rhs1) = second.kind;\n             if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs0, rhs1);\n             if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, rhs0);\n             then {"}, {"sha": "72d1e982d64ac821ff5b290e5ae6749e9d0a1863", "filename": "clippy_lints/src/temporary_assignment.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftemporary_assignment.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -24,7 +24,7 @@ declare_clippy_lint! {\n }\n \n fn is_temporary(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n-    match &expr.node {\n+    match &expr.kind {\n         ExprKind::Struct(..) | ExprKind::Tup(..) => true,\n         ExprKind::Path(qpath) => {\n             if let Res::Def(DefKind::Const, ..) = cx.tables.qpath_res(qpath, expr.hir_id) {\n@@ -41,9 +41,9 @@ declare_lint_pass!(TemporaryAssignment => [TEMPORARY_ASSIGNMENT]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TemporaryAssignment {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprKind::Assign(target, _) = &expr.node {\n+        if let ExprKind::Assign(target, _) = &expr.kind {\n             let mut base = target;\n-            while let ExprKind::Field(f, _) | ExprKind::Index(f, _) = &base.node {\n+            while let ExprKind::Field(f, _) | ExprKind::Index(f, _) = &base.kind {\n                 base = f;\n             }\n             if is_temporary(cx, base) && !is_adjusted(cx, base) {"}, {"sha": "1f029491df42a4f92715b06073a4ca9ed5814382", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -231,8 +231,8 @@ declare_lint_pass!(Transmute => [\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n     #[allow(clippy::similar_names, clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprKind::Call(ref path_expr, ref args) = e.node {\n-            if let ExprKind::Path(ref qpath) = path_expr.node {\n+        if let ExprKind::Call(ref path_expr, ref args) = e.kind {\n+            if let ExprKind::Path(ref qpath) = path_expr.kind {\n                 if let Some(def_id) = cx.tables.qpath_res(qpath, path_expr.hir_id).opt_def_id() {\n                     if match_def_path(cx, def_id, &paths::TRANSMUTE) {\n                         let from_ty = cx.tables.expr_ty(&args[0]);\n@@ -502,7 +502,7 @@ fn get_type_snippet(cx: &LateContext<'_, '_>, path: &QPath, to_ref_ty: Ty<'_>) -\n             GenericArg::Type(ty) => Some(ty),\n             _ => None,\n         }).nth(1);\n-        if let TyKind::Rptr(_, ref to_ty) = to_ty.node;\n+        if let TyKind::Rptr(_, ref to_ty) = to_ty.kind;\n         then {\n             return snippet(cx, to_ty.ty.span, &to_ref_ty.to_string()).to_string();\n         }"}, {"sha": "ed0be2f669ae6f834299836223931fe87d772821", "filename": "clippy_lints/src/transmuting_null.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Ftransmuting_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Ftransmuting_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmuting_null.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -35,8 +35,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TransmutingNull {\n         }\n \n         if_chain! {\n-            if let ExprKind::Call(ref func, ref args) = expr.node;\n-            if let ExprKind::Path(ref path) = func.node;\n+            if let ExprKind::Call(ref func, ref args) = expr.kind;\n+            if let ExprKind::Path(ref path) = func.kind;\n             if match_qpath(path, &paths::STD_MEM_TRANSMUTE);\n             if args.len() == 1;\n \n@@ -45,7 +45,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TransmutingNull {\n                 // Catching transmute over constants that resolve to `null`.\n                 let mut const_eval_context = constant_context(cx, cx.tables);\n                 if_chain! {\n-                    if let ExprKind::Path(ref _qpath) = args[0].node;\n+                    if let ExprKind::Path(ref _qpath) = args[0].kind;\n                     let x = const_eval_context.expr(&args[0]);\n                     if let Some(constant) = x;\n                     if let Constant::RawPtr(ptr_value) = constant;\n@@ -62,8 +62,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TransmutingNull {\n                 // Catching:\n                 // `std::mem::transmute(0 as *const i32)`\n                 if_chain! {\n-                    if let ExprKind::Cast(ref inner_expr, ref _cast_ty) = args[0].node;\n-                    if let ExprKind::Lit(ref lit) = inner_expr.node;\n+                    if let ExprKind::Cast(ref inner_expr, ref _cast_ty) = args[0].kind;\n+                    if let ExprKind::Lit(ref lit) = inner_expr.kind;\n                     if let LitKind::Int(0, _) = lit.node;\n                     then {\n                         span_lint(\n@@ -77,8 +77,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TransmutingNull {\n                 // Catching:\n                 // `std::mem::transmute(std::ptr::null::<i32>())`\n                 if_chain! {\n-                    if let ExprKind::Call(ref func1, ref args1) = args[0].node;\n-                    if let ExprKind::Path(ref path1) = func1.node;\n+                    if let ExprKind::Call(ref func1, ref args1) = args[0].kind;\n+                    if let ExprKind::Path(ref path1) = func1.kind;\n                     if match_qpath(path1, &paths::STD_PTR_NULL);\n                     if args1.len() == 0;\n                     then {"}, {"sha": "bdc679c902afad4bd51c38afc7af547ea9fdb4db", "filename": "clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -101,7 +101,7 @@ impl<'a, 'tcx> TriviallyCopyPassByRef {\n                 if is_copy(cx, ty);\n                 if let Some(size) = cx.layout_of(ty).ok().map(|l| l.size.bytes());\n                 if size <= self.limit;\n-                if let hir::TyKind::Rptr(_, MutTy { ty: ref decl_ty, .. }) = input.node;\n+                if let hir::TyKind::Rptr(_, MutTy { ty: ref decl_ty, .. }) = input.kind;\n                 then {\n                     let value_type = if is_self_ty(decl_ty) {\n                         \"self\".into()\n@@ -131,7 +131,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TriviallyCopyPassByRef {\n             return;\n         }\n \n-        if let hir::TraitItemKind::Method(method_sig, _) = &item.node {\n+        if let hir::TraitItemKind::Method(method_sig, _) = &item.kind {\n             self.check_poly_fn(cx, item.hir_id, &*method_sig.decl, None);\n         }\n     }\n@@ -166,7 +166,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TriviallyCopyPassByRef {\n \n         // Exclude non-inherent impls\n         if let Some(Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(hir_id)) {\n-            if matches!(item.node, ItemKind::Impl(_, _, _, _, Some(_), _, _) |\n+            if matches!(item.kind, ItemKind::Impl(_, _, _, _, Some(_), _, _) |\n                 ItemKind::Trait(..))\n             {\n                 return;"}, {"sha": "35592a1ce50309e34f074156fb1d1c5fb7ddeb76", "filename": "clippy_lints/src/try_err.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftry_err.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -54,16 +54,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TryErr {\n         //         val,\n         // };\n         if_chain! {\n-            if let ExprKind::Match(ref match_arg, _, MatchSource::TryDesugar) = expr.node;\n-            if let ExprKind::Call(ref match_fun, ref try_args) = match_arg.node;\n-            if let ExprKind::Path(ref match_fun_path) = match_fun.node;\n+            if let ExprKind::Match(ref match_arg, _, MatchSource::TryDesugar) = expr.kind;\n+            if let ExprKind::Call(ref match_fun, ref try_args) = match_arg.kind;\n+            if let ExprKind::Path(ref match_fun_path) = match_fun.kind;\n             if match_qpath(match_fun_path, &paths::TRY_INTO_RESULT);\n             if let Some(ref try_arg) = try_args.get(0);\n-            if let ExprKind::Call(ref err_fun, ref err_args) = try_arg.node;\n+            if let ExprKind::Call(ref err_fun, ref err_args) = try_arg.kind;\n             if let Some(ref err_arg) = err_args.get(0);\n-            if let ExprKind::Path(ref err_fun_path) = err_fun.node;\n+            if let ExprKind::Path(ref err_fun_path) = err_fun.kind;\n             if match_qpath(err_fun_path, &paths::RESULT_ERR);\n-            if let Some(return_type) = find_err_return_type(cx, &expr.node);\n+            if let Some(return_type) = find_err_return_type(cx, &expr.kind);\n \n             then {\n                 let err_type = cx.tables.expr_ty(err_arg);\n@@ -106,9 +106,9 @@ fn find_err_return_type<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx ExprKi\n // Check for From::from in one of the match arms.\n fn find_err_return_type_arm<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arm: &'tcx Arm) -> Option<Ty<'tcx>> {\n     if_chain! {\n-        if let ExprKind::Ret(Some(ref err_ret)) = arm.body.node;\n-        if let ExprKind::Call(ref from_error_path, ref from_error_args) = err_ret.node;\n-        if let ExprKind::Path(ref from_error_fn) = from_error_path.node;\n+        if let ExprKind::Ret(Some(ref err_ret)) = arm.body.kind;\n+        if let ExprKind::Call(ref from_error_path, ref from_error_args) = err_ret.kind;\n+        if let ExprKind::Path(ref from_error_fn) = from_error_path.kind;\n         if match_qpath(from_error_fn, &paths::TRY_FROM_ERROR);\n         if let Some(from_error_arg) = from_error_args.get(0);\n         then {"}, {"sha": "e976b055791de15be852a701fa8981e30d11413e", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -170,7 +170,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Types {\n     fn check_fn(&mut self, cx: &LateContext<'_, '_>, _: FnKind<'_>, decl: &FnDecl, _: &Body, _: Span, id: HirId) {\n         // Skip trait implementations; see issue #605.\n         if let Some(hir::Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_item(id)) {\n-            if let ItemKind::Impl(_, _, _, _, Some(..), _, _) = item.node {\n+            if let ItemKind::Impl(_, _, _, _, Some(..), _, _) = item.kind {\n                 return;\n             }\n         }\n@@ -183,7 +183,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Types {\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'_, '_>, item: &TraitItem) {\n-        match item.node {\n+        match item.kind {\n             TraitItemKind::Const(ref ty, _) | TraitItemKind::Type(_, Some(ref ty)) => check_ty(cx, ty, false),\n             TraitItemKind::Method(ref sig, _) => check_fn_decl(cx, &sig.decl),\n             _ => (),\n@@ -217,7 +217,7 @@ fn match_type_parameter(cx: &LateContext<'_, '_>, qpath: &QPath, path: &[&str])\n             GenericArg::Type(ty) => Some(ty),\n             _ => None,\n         });\n-        if let TyKind::Path(ref qpath) = ty.node;\n+        if let TyKind::Path(ref qpath) = ty.kind;\n         if let Some(did) = qpath_res(cx, qpath, ty.hir_id).opt_def_id();\n         if match_def_path(cx, did, path);\n         then {\n@@ -237,7 +237,7 @@ fn check_ty(cx: &LateContext<'_, '_>, hir_ty: &hir::Ty, is_local: bool) {\n     if hir_ty.span.from_expansion() {\n         return;\n     }\n-    match hir_ty.node {\n+    match hir_ty.kind {\n         TyKind::Path(ref qpath) if !is_local => {\n             let hir_id = hir_ty.hir_id;\n             let res = qpath_res(cx, qpath, hir_id);\n@@ -262,7 +262,7 @@ fn check_ty(cx: &LateContext<'_, '_>, hir_ty: &hir::Ty, is_local: bool) {\n                             _ => None,\n                         });\n                         // ty is now _ at this point\n-                        if let TyKind::Path(ref ty_qpath) = ty.node;\n+                        if let TyKind::Path(ref ty_qpath) = ty.kind;\n                         let res = qpath_res(cx, ty_qpath, ty.hir_id);\n                         if let Some(def_id) = res.opt_def_id();\n                         if Some(def_id) == cx.tcx.lang_items().owned_box();\n@@ -366,7 +366,7 @@ fn check_ty(cx: &LateContext<'_, '_>, hir_ty: &hir::Ty, is_local: bool) {\n }\n \n fn check_ty_rptr(cx: &LateContext<'_, '_>, hir_ty: &hir::Ty, is_local: bool, lt: &Lifetime, mut_ty: &MutTy) {\n-    match mut_ty.ty.node {\n+    match mut_ty.ty.kind {\n         TyKind::Path(ref qpath) => {\n             let hir_id = mut_ty.ty.hir_id;\n             let def = qpath_res(cx, qpath, hir_id);\n@@ -424,7 +424,7 @@ fn check_ty_rptr(cx: &LateContext<'_, '_>, hir_ty: &hir::Ty, is_local: bool, lt:\n // Returns true if given type is `Any` trait.\n fn is_any_trait(t: &hir::Ty) -> bool {\n     if_chain! {\n-        if let TyKind::TraitObject(ref traits, _) = t.node;\n+        if let TyKind::TraitObject(ref traits, _) = t.kind;\n         if traits.len() >= 1;\n         // Only Send/Sync can be used as additional traits, so it is enough to\n         // check only the first trait.\n@@ -460,7 +460,7 @@ declare_lint_pass!(LetUnitValue => [LET_UNIT_VALUE]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetUnitValue {\n     fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n-        if let StmtKind::Local(ref local) = stmt.node {\n+        if let StmtKind::Local(ref local) = stmt.kind {\n             if is_unit(cx.tables.pat_ty(&local.pat)) {\n                 if in_external_macro(cx.sess(), stmt.span) || local.pat.span.from_expansion() {\n                     return;\n@@ -529,7 +529,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitCmp {\n         if expr.span.from_expansion() {\n             return;\n         }\n-        if let ExprKind::Binary(ref cmp, ref left, _) = expr.node {\n+        if let ExprKind::Binary(ref cmp, ref left, _) = expr.kind {\n             let op = cmp.node;\n             if op.is_comparison() && is_unit(cx.tables.expr_ty(left)) {\n                 let result = match op {\n@@ -596,11 +596,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitArg {\n             }\n         }\n \n-        match expr.node {\n+        match expr.kind {\n             ExprKind::Call(_, ref args) | ExprKind::MethodCall(_, _, ref args) => {\n                 for arg in args {\n                     if is_unit(cx.tables.expr_ty(arg)) && !is_unit_literal(arg) {\n-                        if let ExprKind::Match(.., match_source) = &arg.node {\n+                        if let ExprKind::Match(.., match_source) = &arg.kind {\n                             if *match_source == MatchSource::TryDesugar {\n                                 continue;\n                             }\n@@ -625,7 +625,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitArg {\n \n fn is_questionmark_desugar_marked_call(expr: &Expr) -> bool {\n     use syntax_pos::hygiene::DesugaringKind;\n-    if let ExprKind::Call(ref callee, _) = expr.node {\n+    if let ExprKind::Call(ref callee, _) = expr.kind {\n         callee.span.is_desugaring(DesugaringKind::QuestionMark)\n     } else {\n         false\n@@ -640,7 +640,7 @@ fn is_unit(ty: Ty<'_>) -> bool {\n }\n \n fn is_unit_literal(expr: &Expr) -> bool {\n-    match expr.node {\n+    match expr.kind {\n         ExprKind::Tup(ref slice) if slice.is_empty() => true,\n         _ => false,\n     }\n@@ -921,7 +921,7 @@ fn span_precision_loss_lint(cx: &LateContext<'_, '_>, expr: &Expr, cast_from: Ty\n }\n \n fn should_strip_parens(op: &Expr, snip: &str) -> bool {\n-    if let ExprKind::Binary(_, _, _) = op.node {\n+    if let ExprKind::Binary(_, _, _) = op.kind {\n         if snip.starts_with('(') && snip.ends_with(')') {\n             return true;\n         }\n@@ -1118,10 +1118,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Casts {\n         if expr.span.from_expansion() {\n             return;\n         }\n-        if let ExprKind::Cast(ref ex, _) = expr.node {\n+        if let ExprKind::Cast(ref ex, _) = expr.kind {\n             let (cast_from, cast_to) = (cx.tables.expr_ty(ex), cx.tables.expr_ty(expr));\n             lint_fn_to_numeric_cast(cx, expr, ex, cast_from, cast_to);\n-            if let ExprKind::Lit(ref lit) = ex.node {\n+            if let ExprKind::Lit(ref lit) = ex.kind {\n                 if let LitKind::Int(n, _) = lit.node {\n                     if cast_to.is_floating_point() {\n                         let from_nbits = 128 - n.leading_zeros();\n@@ -1352,15 +1352,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeComplexity {\n     }\n \n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        match item.node {\n+        match item.kind {\n             ItemKind::Static(ref ty, _, _) | ItemKind::Const(ref ty, _) => self.check_type(cx, ty),\n             // functions, enums, structs, impls and traits are covered\n             _ => (),\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n-        match item.node {\n+        match item.kind {\n             TraitItemKind::Const(ref ty, _) | TraitItemKind::Type(_, Some(ref ty)) => self.check_type(cx, ty),\n             TraitItemKind::Method(MethodSig { ref decl, .. }, TraitMethod::Required(_)) => self.check_fndecl(cx, decl),\n             // methods with default impl are covered by check_fn\n@@ -1369,7 +1369,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeComplexity {\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n-        match item.node {\n+        match item.kind {\n             ImplItemKind::Const(ref ty, _) | ImplItemKind::TyAlias(ref ty) => self.check_type(cx, ty),\n             // methods are covered by check_fn\n             _ => (),\n@@ -1424,7 +1424,7 @@ struct TypeComplexityVisitor {\n \n impl<'tcx> Visitor<'tcx> for TypeComplexityVisitor {\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        let (add_score, sub_nest) = match ty.node {\n+        let (add_score, sub_nest) = match ty.kind {\n             // _, &x and *x have only small overhead; don't mess with nesting level\n             TyKind::Infer | TyKind::Ptr(..) | TyKind::Rptr(..) => (1, 0),\n \n@@ -1495,8 +1495,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CharLitAsU8 {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n             if !expr.span.from_expansion();\n-            if let ExprKind::Cast(e, _) = &expr.node;\n-            if let ExprKind::Lit(l) = &e.node;\n+            if let ExprKind::Cast(e, _) = &expr.kind;\n+            if let ExprKind::Lit(l) = &e.kind;\n             if let LitKind::Char(c) = l.node;\n             if ty::Uint(UintTy::U8) == cx.tables.expr_ty(expr).kind;\n             then {\n@@ -1573,7 +1573,7 @@ enum AbsurdComparisonResult {\n }\n \n fn is_cast_between_fixed_and_target<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> bool {\n-    if let ExprKind::Cast(ref cast_exp, _) = expr.node {\n+    if let ExprKind::Cast(ref cast_exp, _) = expr.kind {\n         let precast_ty = cx.tables.expr_ty(cast_exp);\n         let cast_ty = cx.tables.expr_ty(expr);\n \n@@ -1668,7 +1668,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AbsurdExtremeComparisons {\n         use crate::types::AbsurdComparisonResult::*;\n         use crate::types::ExtremeType::*;\n \n-        if let ExprKind::Binary(ref cmp, ref lhs, ref rhs) = expr.node {\n+        if let ExprKind::Binary(ref cmp, ref lhs, ref rhs) = expr.kind {\n             if let Some((culprit, result)) = detect_absurd_comparison(cx, cmp.node, lhs, rhs) {\n                 if !expr.span.from_expansion() {\n                     let msg = \"this comparison involving the minimum or maximum element for this \\\n@@ -1771,7 +1771,7 @@ impl Ord for FullInt {\n fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option<(FullInt, FullInt)> {\n     use std::*;\n \n-    if let ExprKind::Cast(ref cast_exp, _) = expr.node {\n+    if let ExprKind::Cast(ref cast_exp, _) = expr.kind {\n         let pre_cast_ty = cx.tables.expr_ty(cast_exp);\n         let cast_ty = cx.tables.expr_ty(expr);\n         // if it's a cast from i32 to u32 wrapping will invalidate all these checks\n@@ -1846,7 +1846,7 @@ fn node_as_const_fullint<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr)\n }\n \n fn err_upcast_comparison(cx: &LateContext<'_, '_>, span: Span, expr: &Expr, always: bool) {\n-    if let ExprKind::Cast(ref cast_val, _) = expr.node {\n+    if let ExprKind::Cast(ref cast_val, _) = expr.kind {\n         span_lint(\n             cx,\n             INVALID_UPCAST_COMPARISONS,\n@@ -1920,7 +1920,7 @@ fn upcast_comparison_bounds_err<'a, 'tcx>(\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidUpcastComparisons {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprKind::Binary(ref cmp, ref lhs, ref rhs) = expr.node {\n+        if let ExprKind::Binary(ref cmp, ref lhs, ref rhs) = expr.kind {\n             let normalized = comparisons::normalize_comparison(cmp.node, lhs, rhs);\n             let (rel, normalized_lhs, normalized_rhs) = if let Some(val) = normalized {\n                 val\n@@ -2029,7 +2029,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplicitHasher {\n             return;\n         }\n \n-        match item.node {\n+        match item.kind {\n             ItemKind::Impl(_, _, _, ref generics, _, ref ty, ref items) => {\n                 let mut vis = ImplicitHasherTypeVisitor::new(cx);\n                 vis.visit_ty(ty);\n@@ -2120,7 +2120,7 @@ enum ImplicitHasherType<'tcx> {\n impl<'tcx> ImplicitHasherType<'tcx> {\n     /// Checks that `ty` is a target type without a BuildHasher.\n     fn new<'a>(cx: &LateContext<'a, 'tcx>, hir_ty: &hir::Ty) -> Option<Self> {\n-        if let TyKind::Path(QPath::Resolved(None, ref path)) = hir_ty.node {\n+        if let TyKind::Path(QPath::Resolved(None, ref path)) = hir_ty.kind {\n             let params: Vec<_> = path\n                 .segments\n                 .last()\n@@ -2240,9 +2240,9 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'a, 'b, 't\n \n     fn visit_expr(&mut self, e: &'tcx Expr) {\n         if_chain! {\n-            if let ExprKind::Call(ref fun, ref args) = e.node;\n-            if let ExprKind::Path(QPath::TypeRelative(ref ty, ref method)) = fun.node;\n-            if let TyKind::Path(QPath::Resolved(None, ref ty_path)) = ty.node;\n+            if let ExprKind::Call(ref fun, ref args) = e.kind;\n+            if let ExprKind::Path(QPath::TypeRelative(ref ty, ref method)) = fun.kind;\n+            if let TyKind::Path(QPath::Resolved(None, ref ty_path)) = ty.kind;\n             then {\n                 if !same_tys(self.cx, self.target.ty(), self.body.expr_ty(e)) {\n                     return;\n@@ -2325,11 +2325,11 @@ declare_lint_pass!(RefToMut => [CAST_REF_TO_MUT]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RefToMut {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n-            if let ExprKind::Unary(UnOp::UnDeref, e) = &expr.node;\n-            if let ExprKind::Cast(e, t) = &e.node;\n-            if let TyKind::Ptr(MutTy { mutbl: Mutability::MutMutable, .. }) = t.node;\n-            if let ExprKind::Cast(e, t) = &e.node;\n-            if let TyKind::Ptr(MutTy { mutbl: Mutability::MutImmutable, .. }) = t.node;\n+            if let ExprKind::Unary(UnOp::UnDeref, e) = &expr.kind;\n+            if let ExprKind::Cast(e, t) = &e.kind;\n+            if let TyKind::Ptr(MutTy { mutbl: Mutability::MutMutable, .. }) = t.kind;\n+            if let ExprKind::Cast(e, t) = &e.kind;\n+            if let TyKind::Ptr(MutTy { mutbl: Mutability::MutImmutable, .. }) = t.kind;\n             if let ty::Ref(..) = cx.tables.node_type(e.hir_id).kind;\n             then {\n                 span_lint("}, {"sha": "7726b05a2c8debdf5b39b1207eb05ce6623d5e6f", "filename": "clippy_lints/src/unicode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funicode.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -67,7 +67,7 @@ declare_lint_pass!(Unicode => [ZERO_WIDTH_SPACE, NON_ASCII_LITERAL, UNICODE_NOT_\n \n impl LateLintPass<'_, '_> for Unicode {\n     fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &'_ Expr) {\n-        if let ExprKind::Lit(ref lit) = expr.node {\n+        if let ExprKind::Lit(ref lit) = expr.kind {\n             if let LitKind::Str(_, _) = lit.node {\n                 check_str(cx, lit.span, expr.hir_id)\n             }"}, {"sha": "29c8015edcff4900d0980c55f8e1a8e5baa1b997", "filename": "clippy_lints/src/unsafe_removed_from_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -30,7 +30,7 @@ declare_lint_pass!(UnsafeNameRemoval => [UNSAFE_REMOVED_FROM_NAME]);\n \n impl EarlyLintPass for UnsafeNameRemoval {\n     fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n-        if let ItemKind::Use(ref use_tree) = item.node {\n+        if let ItemKind::Use(ref use_tree) = item.kind {\n             check_use_tree(use_tree, cx, item.span);\n         }\n     }"}, {"sha": "6f02d56b8ea0db26422e46f5294c939ba102c032", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -34,15 +34,15 @@ declare_lint_pass!(UnusedIoAmount => [UNUSED_IO_AMOUNT]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n     fn check_stmt(&mut self, cx: &LateContext<'_, '_>, s: &hir::Stmt) {\n-        let expr = match s.node {\n+        let expr = match s.kind {\n             hir::StmtKind::Semi(ref expr) | hir::StmtKind::Expr(ref expr) => &**expr,\n             _ => return,\n         };\n \n-        match expr.node {\n+        match expr.kind {\n             hir::ExprKind::Match(ref res, _, _) if is_try(expr).is_some() => {\n-                if let hir::ExprKind::Call(ref func, ref args) = res.node {\n-                    if let hir::ExprKind::Path(ref path) = func.node {\n+                if let hir::ExprKind::Call(ref func, ref args) = res.kind {\n+                    if let hir::ExprKind::Path(ref path) = func.kind {\n                         if match_qpath(path, &paths::TRY_INTO_RESULT) && args.len() == 1 {\n                             check_method_call(cx, &args[0], expr);\n                         }\n@@ -65,7 +65,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n }\n \n fn check_method_call(cx: &LateContext<'_, '_>, call: &hir::Expr, expr: &hir::Expr) {\n-    if let hir::ExprKind::MethodCall(ref path, _, _) = call.node {\n+    if let hir::ExprKind::MethodCall(ref path, _, _) = call.kind {\n         let symbol = &*path.ident.as_str();\n         if match_trait_method(cx, call, &paths::IO_READ) && symbol == \"read\" {\n             span_lint("}, {"sha": "721458e1d9a19ffcb852baa21f266a2dcf31747a", "filename": "clippy_lints/src/unused_label.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Funused_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Funused_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_label.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -62,7 +62,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedLabel {\n \n impl<'a, 'tcx> Visitor<'tcx> for UnusedLabelVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        match expr.node {\n+        match expr.kind {\n             hir::ExprKind::Break(destination, _) | hir::ExprKind::Continue(destination) => {\n                 if let Some(label) = destination.label {\n                     self.labels.remove(&label.ident.name);"}, {"sha": "39d3ee18452d002047fa07381d4fa83d12cfa46b", "filename": "clippy_lints/src/unwrap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -83,7 +83,7 @@ fn collect_unwrap_info<'a, 'tcx>(\n     expr: &'tcx Expr,\n     invert: bool,\n ) -> Vec<UnwrapInfo<'tcx>> {\n-    if let ExprKind::Binary(op, left, right) = &expr.node {\n+    if let ExprKind::Binary(op, left, right) = &expr.kind {\n         match (invert, op.node) {\n             (false, BinOpKind::And) | (false, BinOpKind::BitAnd) | (true, BinOpKind::Or) | (true, BinOpKind::BitOr) => {\n                 let mut unwrap_info = collect_unwrap_info(cx, left, invert);\n@@ -92,12 +92,12 @@ fn collect_unwrap_info<'a, 'tcx>(\n             },\n             _ => (),\n         }\n-    } else if let ExprKind::Unary(UnNot, expr) = &expr.node {\n+    } else if let ExprKind::Unary(UnNot, expr) = &expr.kind {\n         return collect_unwrap_info(cx, expr, !invert);\n     } else {\n         if_chain! {\n-            if let ExprKind::MethodCall(method_name, _, args) = &expr.node;\n-            if let ExprKind::Path(QPath::Resolved(None, path)) = &args[0].node;\n+            if let ExprKind::MethodCall(method_name, _, args) = &expr.kind;\n+            if let ExprKind::Path(QPath::Resolved(None, path)) = &args[0].kind;\n             let ty = cx.tables.expr_ty(&args[0]);\n             if match_type(cx, ty, &paths::OPTION) || match_type(cx, ty, &paths::RESULT);\n             let name = method_name.ident.as_str();\n@@ -145,8 +145,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n         } else {\n             // find `unwrap[_err]()` calls:\n             if_chain! {\n-                if let ExprKind::MethodCall(ref method_name, _, ref args) = expr.node;\n-                if let ExprKind::Path(QPath::Resolved(None, ref path)) = args[0].node;\n+                if let ExprKind::MethodCall(ref method_name, _, ref args) = expr.kind;\n+                if let ExprKind::Path(QPath::Resolved(None, ref path)) = args[0].kind;\n                 if [sym!(unwrap), sym!(unwrap_err)].contains(&method_name.ident.name);\n                 let call_to_unwrap = method_name.ident.name == sym!(unwrap);\n                 if let Some(unwrappable) = self.unwrappables.iter()"}, {"sha": "b092573770232fa5f05dc9fefd5130ffadcbba35", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -83,7 +83,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TraitImplTyVisitor<'a, 'tcx> {\n         let impl_ty = self.impl_type_walker.next();\n \n         if_chain! {\n-            if let TyKind::Path(QPath::Resolved(_, path)) = &t.node;\n+            if let TyKind::Path(QPath::Resolved(_, path)) = &t.kind;\n \n             // The implementation and trait types don't match which means that\n             // the concrete type was specified by the implementation\n@@ -164,8 +164,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UseSelf {\n             return;\n         }\n         if_chain! {\n-            if let ItemKind::Impl(.., ref item_type, ref refs) = item.node;\n-            if let TyKind::Path(QPath::Resolved(_, ref item_path)) = item_type.node;\n+            if let ItemKind::Impl(.., ref item_type, ref refs) = item.kind;\n+            if let TyKind::Path(QPath::Resolved(_, ref item_path)) = item_type.kind;\n             then {\n                 let parameters = &item_path.segments.last().expect(SEGMENTS_MSG).args;\n                 let should_check = if let Some(ref params) = *parameters {\n@@ -189,7 +189,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UseSelf {\n                         for impl_item_ref in refs {\n                             let impl_item = cx.tcx.hir().impl_item(impl_item_ref.id);\n                             if let ImplItemKind::Method(MethodSig{ decl: impl_decl, .. }, impl_body_id)\n-                                    = &impl_item.node {\n+                                    = &impl_item.kind {\n                                 let item_type = cx.tcx.type_of(impl_def_id);\n                                 check_trait_method_impl_decl(cx, item_type, impl_item, impl_decl, &impl_trait_ref);\n \n@@ -250,7 +250,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UseSelfVisitor<'a, 'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx Item) {\n-        match item.node {\n+        match item.kind {\n             ItemKind::Use(..)\n             | ItemKind::Static(..)\n             | ItemKind::Enum(..)"}, {"sha": "664bcc5a7441b9b65c05258e8bd41d4b7c6f8d63", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -34,11 +34,11 @@ declare_clippy_lint! {\n     /// ```rust,ignore\n     /// // ./tests/ui/new_lint.stdout\n     /// if_chain! {\n-    ///     if let ExprKind::If(ref cond, ref then, None) = item.node,\n-    ///     if let ExprKind::Binary(BinOp::Eq, ref left, ref right) = cond.node,\n-    ///     if let ExprKind::Path(ref path) = left.node,\n-    ///     if let ExprKind::Lit(ref lit) = right.node,\n-    ///     if let LitKind::Int(42, _) = lit.node,\n+    ///     if let ExprKind::If(ref cond, ref then, None) = item.kind,\n+    ///     if let ExprKind::Binary(BinOp::Eq, ref left, ref right) = cond.kind,\n+    ///     if let ExprKind::Path(ref path) = left.kind,\n+    ///     if let ExprKind::Lit(ref lit) = right.kind,\n+    ///     if let LitKind::Int(42, _) = lit.kind,\n     ///     then {\n     ///         // report your lint here\n     ///     }\n@@ -127,7 +127,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Author {\n     }\n \n     fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx hir::Stmt) {\n-        if !has_attr(cx.sess(), stmt.node.attrs()) {\n+        if !has_attr(cx.sess(), stmt.kind.attrs()) {\n             return;\n         }\n         prelude();\n@@ -215,8 +215,8 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n         }\n \n         print!(\"    if let ExprKind::\");\n-        let current = format!(\"{}.node\", self.current);\n-        match expr.node {\n+        let current = format!(\"{}.kind\", self.current);\n+        match expr.kind {\n             ExprKind::Box(ref inner) => {\n                 let inner_pat = self.next(\"inner\");\n                 println!(\"Box(ref {}) = {};\", inner_pat, current);\n@@ -309,8 +309,8 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 let qp_label = self.next(\"qp\");\n \n                 println!(\"Cast(ref {}, ref {}) = {};\", cast_pat, cast_ty, current);\n-                if let TyKind::Path(ref qp) = ty.node {\n-                    println!(\"    if let TyKind::Path(ref {}) = {}.node;\", qp_label, cast_ty);\n+                if let TyKind::Path(ref qp) = ty.kind {\n+                    println!(\"    if let TyKind::Path(ref {}) = {}.kind;\", qp_label, cast_ty);\n                     self.current = qp_label;\n                     self.print_qpath(qp);\n                 }\n@@ -401,7 +401,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 let obj_pat = self.next(\"object\");\n                 let field_name_pat = self.next(\"field_name\");\n                 println!(\"Field(ref {}, ref {}) = {};\", obj_pat, field_name_pat, current);\n-                println!(\"    if {}.node.as_str() == {:?}\", field_name_pat, field_ident.as_str());\n+                println!(\"    if {}.kind.as_str() == {:?}\", field_name_pat, field_ident.as_str());\n                 self.current = obj_pat;\n                 self.visit_expr(object);\n             },\n@@ -510,8 +510,8 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n     #[allow(clippy::too_many_lines)]\n     fn visit_pat(&mut self, pat: &Pat) {\n         print!(\"    if let PatKind::\");\n-        let current = format!(\"{}.node\", self.current);\n-        match pat.node {\n+        let current = format!(\"{}.kind\", self.current);\n+        match pat.kind {\n             PatKind::Wild => println!(\"Wild = {};\", current),\n             PatKind::Binding(anno, .., ident, ref sub) => {\n                 let anno_pat = match anno {\n@@ -532,7 +532,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 } else {\n                     println!(\"Binding({}, _, {}, None) = {};\", anno_pat, name_pat, current);\n                 }\n-                println!(\"    if {}.node.as_str() == \\\"{}\\\";\", name_pat, ident.as_str());\n+                println!(\"    if {}.kind.as_str() == \\\"{}\\\";\", name_pat, ident.as_str());\n             },\n             PatKind::Struct(ref path, ref fields, ignore) => {\n                 let path_pat = self.next(\"path\");\n@@ -636,8 +636,8 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n \n     fn visit_stmt(&mut self, s: &Stmt) {\n         print!(\"    if let StmtKind::\");\n-        let current = format!(\"{}.node\", self.current);\n-        match s.node {\n+        let current = format!(\"{}.kind\", self.current);\n+        match s.kind {\n             // A local (let) binding:\n             StmtKind::Local(ref local) => {\n                 let local_pat = self.next(\"local\");\n@@ -723,7 +723,7 @@ fn print_path(path: &QPath, first: &mut bool) {\n                 print!(\"{:?}\", segment.ident.as_str());\n             }\n         },\n-        QPath::TypeRelative(ref ty, ref segment) => match ty.node {\n+        QPath::TypeRelative(ref ty, ref segment) => match ty.kind {\n             hir::TyKind::Path(ref inner_path) => {\n                 print_path(inner_path, first);\n                 if *first {"}, {"sha": "4595819f55784fb6cf3bdf367aa80e36b6f048c1", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -14,12 +14,12 @@ use toml;\n pub fn file_from_args(args: &[ast::NestedMetaItem]) -> Result<Option<path::PathBuf>, (&'static str, source_map::Span)> {\n     for arg in args.iter().filter_map(syntax::ast::NestedMetaItem::meta_item) {\n         if arg.check_name(sym!(conf_file)) {\n-            return match arg.node {\n+            return match arg.kind {\n                 ast::MetaItemKind::Word | ast::MetaItemKind::List(_) => {\n                     Err((\"`conf_file` must be a named value\", arg.span))\n                 },\n                 ast::MetaItemKind::NameValue(ref value) => {\n-                    if let ast::LitKind::Str(ref file, _) = value.node {\n+                    if let ast::LitKind::Str(ref file, _) = value.kind {\n                         Ok(Some(file.to_string().into()))\n                     } else {\n                         Err((\"`conf_file` value must be a string\", value.span))"}, {"sha": "4fea47b37b561fe7e36a51b930fd88ce355dd09c", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -86,7 +86,7 @@ pub fn range<'a, 'b, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'b hir::Expr) -> O\n     // depending on\n     // `#[no_std]`. Testing both instead of resolving the paths.\n \n-    match expr.node {\n+    match expr.kind {\n         hir::ExprKind::Path(ref path) => {\n             if match_qpath(path, &paths::RANGE_FULL_STD) || match_qpath(path, &paths::RANGE_FULL) {\n                 Some(Range {\n@@ -99,7 +99,7 @@ pub fn range<'a, 'b, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'b hir::Expr) -> O\n             }\n         },\n         hir::ExprKind::Call(ref path, ref args) => {\n-            if let hir::ExprKind::Path(ref path) = path.node {\n+            if let hir::ExprKind::Path(ref path) = path.kind {\n                 if match_qpath(path, &paths::RANGE_INCLUSIVE_STD_NEW) || match_qpath(path, &paths::RANGE_INCLUSIVE_NEW)\n                 {\n                     Some(Range {\n@@ -159,7 +159,7 @@ pub fn is_from_for_desugar(local: &hir::Local) -> bool {\n     // ```\n     if_chain! {\n         if let Some(ref expr) = local.init;\n-        if let hir::ExprKind::Match(_, _, hir::MatchSource::ForLoopDesugar) = expr.node;\n+        if let hir::ExprKind::Match(_, _, hir::MatchSource::ForLoopDesugar) = expr.kind;\n         then {\n             return true;\n         }\n@@ -184,14 +184,14 @@ pub fn is_from_for_desugar(local: &hir::Local) -> bool {\n /// `for pat in arg { body }` becomes `(pat, arg, body)`.\n pub fn for_loop(expr: &hir::Expr) -> Option<(&hir::Pat, &hir::Expr, &hir::Expr)> {\n     if_chain! {\n-        if let hir::ExprKind::Match(ref iterexpr, ref arms, hir::MatchSource::ForLoopDesugar) = expr.node;\n-        if let hir::ExprKind::Call(_, ref iterargs) = iterexpr.node;\n+        if let hir::ExprKind::Match(ref iterexpr, ref arms, hir::MatchSource::ForLoopDesugar) = expr.kind;\n+        if let hir::ExprKind::Call(_, ref iterargs) = iterexpr.kind;\n         if iterargs.len() == 1 && arms.len() == 1 && arms[0].guard.is_none();\n-        if let hir::ExprKind::Loop(ref block, _, _) = arms[0].body.node;\n+        if let hir::ExprKind::Loop(ref block, _, _) = arms[0].body.kind;\n         if block.expr.is_none();\n         if let [ _, _, ref let_stmt, ref body ] = *block.stmts;\n-        if let hir::StmtKind::Local(ref local) = let_stmt.node;\n-        if let hir::StmtKind::Expr(ref expr) = body.node;\n+        if let hir::StmtKind::Local(ref local) = let_stmt.kind;\n+        if let hir::StmtKind::Expr(ref expr) = body.kind;\n         then {\n             return Some((&*local.pat, &iterargs[0], expr));\n         }\n@@ -203,10 +203,10 @@ pub fn for_loop(expr: &hir::Expr) -> Option<(&hir::Pat, &hir::Expr, &hir::Expr)>\n /// `while cond { body }` becomes `(cond, body)`.\n pub fn while_loop(expr: &hir::Expr) -> Option<(&hir::Expr, &hir::Expr)> {\n     if_chain! {\n-        if let hir::ExprKind::Loop(block, _, hir::LoopSource::While) = &expr.node;\n+        if let hir::ExprKind::Loop(block, _, hir::LoopSource::While) = &expr.kind;\n         if let hir::Block { expr: Some(expr), .. } = &**block;\n-        if let hir::ExprKind::Match(cond, arms, hir::MatchSource::WhileDesugar) = &expr.node;\n-        if let hir::ExprKind::DropTemps(cond) = &cond.node;\n+        if let hir::ExprKind::Match(cond, arms, hir::MatchSource::WhileDesugar) = &expr.kind;\n+        if let hir::ExprKind::DropTemps(cond) = &cond.kind;\n         if let [arm, ..] = &arms[..];\n         if let hir::Arm { body, .. } = arm;\n         then {\n@@ -219,8 +219,8 @@ pub fn while_loop(expr: &hir::Expr) -> Option<(&hir::Expr, &hir::Expr)> {\n /// Recover the essential nodes of a desugared if block\n /// `if cond { then } else { els }` becomes `(cond, then, Some(els))`\n pub fn if_block(expr: &hir::Expr) -> Option<(&hir::Expr, &hir::Expr, Option<&hir::Expr>)> {\n-    if let hir::ExprKind::Match(ref cond, ref arms, hir::MatchSource::IfDesugar { contains_else_clause }) = expr.node {\n-        let cond = if let hir::ExprKind::DropTemps(ref cond) = cond.node {\n+    if let hir::ExprKind::Match(ref cond, ref arms, hir::MatchSource::IfDesugar { contains_else_clause }) = expr.kind {\n+        let cond = if let hir::ExprKind::DropTemps(ref cond) = cond.kind {\n             cond\n         } else {\n             panic!(\"If block desugar must contain DropTemps\");\n@@ -249,8 +249,8 @@ pub enum VecArgs<'a> {\n /// from `vec!`.\n pub fn vec_macro<'e>(cx: &LateContext<'_, '_>, expr: &'e hir::Expr) -> Option<VecArgs<'e>> {\n     if_chain! {\n-        if let hir::ExprKind::Call(ref fun, ref args) = expr.node;\n-        if let hir::ExprKind::Path(ref path) = fun.node;\n+        if let hir::ExprKind::Call(ref fun, ref args) = expr.kind;\n+        if let hir::ExprKind::Path(ref path) = fun.kind;\n         if is_expn_of(fun.span, \"vec\").is_some();\n         if let Some(fun_def_id) = resolve_node(cx, path, fun.hir_id).opt_def_id();\n         then {\n@@ -261,8 +261,8 @@ pub fn vec_macro<'e>(cx: &LateContext<'_, '_>, expr: &'e hir::Expr) -> Option<Ve\n             else if match_def_path(cx, fun_def_id, &paths::SLICE_INTO_VEC) && args.len() == 1 {\n                 // `vec![a, b, c]` case\n                 if_chain! {\n-                    if let hir::ExprKind::Box(ref boxed) = args[0].node;\n-                    if let hir::ExprKind::Array(ref args) = boxed.node;\n+                    if let hir::ExprKind::Box(ref boxed) = args[0].kind;\n+                    if let hir::ExprKind::Array(ref args) = boxed.kind;\n                     then {\n                         return Some(VecArgs::Vec(&*args));\n                     }"}, {"sha": "c884544f96766836c13bc1f1f3b042abb2768290", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -42,7 +42,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n \n     /// Checks whether two statements are the same.\n     pub fn eq_stmt(&mut self, left: &Stmt, right: &Stmt) -> bool {\n-        match (&left.node, &right.node) {\n+        match (&left.kind, &right.kind) {\n             (&StmtKind::Local(ref l), &StmtKind::Local(ref r)) => {\n                 self.eq_pat(&l.pat, &r.pat)\n                     && both(&l.ty, &r.ty, |l, r| self.eq_ty(l, r))\n@@ -76,7 +76,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n             }\n         }\n \n-        match (&left.node, &right.node) {\n+        match (&left.kind, &right.kind) {\n             (&ExprKind::AddrOf(l_mut, ref le), &ExprKind::AddrOf(r_mut, ref re)) => {\n                 l_mut == r_mut && self.eq_expr(le, re)\n             },\n@@ -181,7 +181,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n \n     /// Checks whether two patterns are the same.\n     pub fn eq_pat(&mut self, left: &Pat, right: &Pat) -> bool {\n-        match (&left.node, &right.node) {\n+        match (&left.kind, &right.kind) {\n             (&PatKind::Box(ref l), &PatKind::Box(ref r)) => self.eq_pat(l, r),\n             (&PatKind::TupleStruct(ref lp, ref la, ls), &PatKind::TupleStruct(ref rp, ref ra, rs)) => {\n                 self.eq_qpath(lp, rp) && over(la, ra, |l, r| self.eq_pat(l, r)) && ls == rs\n@@ -258,7 +258,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n     }\n \n     pub fn eq_ty(&mut self, left: &Ty, right: &Ty) -> bool {\n-        self.eq_ty_kind(&left.node, &right.node)\n+        self.eq_ty_kind(&left.kind, &right.kind)\n     }\n \n     #[allow(clippy::similar_names)]\n@@ -394,9 +394,9 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n             return e.hash(&mut self.s);\n         }\n \n-        std::mem::discriminant(&e.node).hash(&mut self.s);\n+        std::mem::discriminant(&e.kind).hash(&mut self.s);\n \n-        match e.node {\n+        match e.kind {\n             ExprKind::AddrOf(m, ref e) => {\n                 m.hash(&mut self.s);\n                 self.hash_expr(e);\n@@ -555,9 +555,9 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n     }\n \n     pub fn hash_stmt(&mut self, b: &Stmt) {\n-        std::mem::discriminant(&b.node).hash(&mut self.s);\n+        std::mem::discriminant(&b.kind).hash(&mut self.s);\n \n-        match &b.node {\n+        match &b.kind {\n             StmtKind::Local(local) => {\n                 if let Some(ref init) = local.init {\n                     self.hash_expr(init);\n@@ -595,7 +595,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n     }\n \n     pub fn hash_ty(&mut self, ty: &Ty) {\n-        self.hash_tykind(&ty.node);\n+        self.hash_tykind(&ty.kind);\n     }\n \n     pub fn hash_tykind(&mut self, ty: &TyKind) {"}, {"sha": "846e47cee37460e1ee3b07009d540a521644faf4", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -57,7 +57,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DeepCodeInspector {\n         if item.defaultness.is_default() {\n             println!(\"default\");\n         }\n-        match item.node {\n+        match item.kind {\n             hir::ImplItemKind::Const(_, body_id) => {\n                 println!(\"associated constant\");\n                 print_expr(cx, &cx.tcx.hir().body(body_id).value, 1);\n@@ -111,10 +111,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DeepCodeInspector {\n     }\n \n     fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx hir::Stmt) {\n-        if !has_attr(cx.sess(), stmt.node.attrs()) {\n+        if !has_attr(cx.sess(), stmt.kind.attrs()) {\n             return;\n         }\n-        match stmt.node {\n+        match stmt.kind {\n             hir::StmtKind::Local(ref local) => {\n                 println!(\"local variable of type {}\", cx.tables.node_type(local.hir_id));\n                 println!(\"pattern:\");\n@@ -148,7 +148,7 @@ fn print_expr(cx: &LateContext<'_, '_>, expr: &hir::Expr, indent: usize) {\n     println!(\"{}+\", ind);\n     println!(\"{}ty: {}\", ind, cx.tables.expr_ty(expr));\n     println!(\"{}adjustments: {:?}\", ind, cx.tables.adjustments().get(expr.hir_id));\n-    match expr.node {\n+    match expr.kind {\n         hir::ExprKind::Box(ref e) => {\n             println!(\"{}Box\", ind);\n             print_expr(cx, e, indent + 1);\n@@ -334,7 +334,7 @@ fn print_item(cx: &LateContext<'_, '_>, item: &hir::Item) {\n         ),\n         hir::VisibilityKind::Inherited => println!(\"visibility inherited from outer item\"),\n     }\n-    match item.node {\n+    match item.kind {\n         hir::ItemKind::ExternCrate(ref _renamed_from) => {\n             let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n             if let Some(crate_id) = cx.tcx.extern_mod_stmt_cnum(def_id) {\n@@ -399,7 +399,7 @@ fn print_item(cx: &LateContext<'_, '_>, item: &hir::Item) {\n fn print_pat(cx: &LateContext<'_, '_>, pat: &hir::Pat, indent: usize) {\n     let ind = \"  \".repeat(indent);\n     println!(\"{}+\", ind);\n-    match pat.node {\n+    match pat.kind {\n         hir::PatKind::Wild => println!(\"{}Wild\", ind),\n         hir::PatKind::Binding(ref mode, .., ident, ref inner) => {\n             println!(\"{}Binding\", ind);"}, {"sha": "1ec89cb93f1703d516d9b524216a50fd3fb7a3ea", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -108,9 +108,9 @@ impl EarlyLintPass for ClippyLintsInternal {\n             .iter()\n             .find(|item| item.ident.name.as_str() == \"utils\")\n         {\n-            if let ItemKind::Mod(ref utils_mod) = utils.node {\n+            if let ItemKind::Mod(ref utils_mod) = utils.kind {\n                 if let Some(paths) = utils_mod.items.iter().find(|item| item.ident.name.as_str() == \"paths\") {\n-                    if let ItemKind::Mod(ref paths_mod) = paths.node {\n+                    if let ItemKind::Mod(ref paths_mod) = paths.kind {\n                         let mut last_name: Option<LocalInternedString> = None;\n                         for item in &*paths_mod.items {\n                             let name = item.ident.as_str();\n@@ -144,11 +144,11 @@ impl_lint_pass!(LintWithoutLintPass => [LINT_WITHOUT_LINT_PASS]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LintWithoutLintPass {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if let hir::ItemKind::Static(ref ty, MutImmutable, _) = item.node {\n+        if let hir::ItemKind::Static(ref ty, MutImmutable, _) = item.kind {\n             if is_lint_ref_type(cx, ty) {\n                 self.declared_lints.insert(item.ident.name, item.span);\n             }\n-        } else if let hir::ItemKind::Impl(.., Some(ref trait_ref), _, ref impl_item_refs) = item.node {\n+        } else if let hir::ItemKind::Impl(.., Some(ref trait_ref), _, ref impl_item_refs) = item.kind {\n             if_chain! {\n                 if let hir::TraitRef{path, ..} = trait_ref;\n                 if let Res::Def(DefKind::Trait, def_id) = path.res;\n@@ -201,9 +201,9 @@ fn is_lint_ref_type<'tcx>(cx: &LateContext<'_, 'tcx>, ty: &Ty) -> bool {\n             ty: ref inner,\n             mutbl: MutImmutable,\n         },\n-    ) = ty.node\n+    ) = ty.kind\n     {\n-        if let TyKind::Path(ref path) = inner.node {\n+        if let TyKind::Path(ref path) = inner.kind {\n             if let Res::Def(DefKind::Struct, def_id) = cx.tables.qpath_res(path, inner.hir_id) {\n                 return match_def_path(cx, def_id, &paths::LINT);\n             }\n@@ -255,7 +255,7 @@ impl_lint_pass!(CompilerLintFunctions => [COMPILER_LINT_FUNCTIONS]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CompilerLintFunctions {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n-            if let ExprKind::MethodCall(ref path, _, ref args) = expr.node;\n+            if let ExprKind::MethodCall(ref path, _, ref args) = expr.kind;\n             let fn_name = path.ident;\n             if let Some(sugg) = self.map.get(&*fn_name.as_str());\n             let ty = walk_ptrs_ty(cx.tables.expr_ty(&args[0]));"}, {"sha": "ffeb90e1cad52bc8507a1a81e46f103542b6adfb", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -69,28 +69,28 @@ pub fn in_constant(cx: &LateContext<'_, '_>, id: HirId) -> bool {\n     let parent_id = cx.tcx.hir().get_parent_item(id);\n     match cx.tcx.hir().get(parent_id) {\n         Node::Item(&Item {\n-            node: ItemKind::Const(..),\n+            kind: ItemKind::Const(..),\n             ..\n         })\n         | Node::TraitItem(&TraitItem {\n-            node: TraitItemKind::Const(..),\n+            kind: TraitItemKind::Const(..),\n             ..\n         })\n         | Node::ImplItem(&ImplItem {\n-            node: ImplItemKind::Const(..),\n+            kind: ImplItemKind::Const(..),\n             ..\n         })\n         | Node::AnonConst(_)\n         | Node::Item(&Item {\n-            node: ItemKind::Static(..),\n+            kind: ItemKind::Static(..),\n             ..\n         }) => true,\n         Node::Item(&Item {\n-            node: ItemKind::Fn(_, header, ..),\n+            kind: ItemKind::Fn(_, header, ..),\n             ..\n         }) => header.constness == Constness::Const,\n         Node::ImplItem(&ImplItem {\n-            node: ImplItemKind::Method(ref sig, _),\n+            kind: ImplItemKind::Method(ref sig, _),\n             ..\n         }) => sig.header.constness == Constness::Const,\n         _ => false,\n@@ -152,7 +152,7 @@ pub fn match_trait_method(cx: &LateContext<'_, '_>, expr: &Expr, path: &[&str])\n \n /// Checks if an expression references a variable of the given name.\n pub fn match_var(expr: &Expr, var: Name) -> bool {\n-    if let ExprKind::Path(QPath::Resolved(None, ref path)) = expr.node {\n+    if let ExprKind::Path(QPath::Resolved(None, ref path)) = expr.kind {\n         if path.segments.len() == 1 && path.segments[0].ident.name == var {\n             return true;\n         }\n@@ -187,7 +187,7 @@ pub fn single_segment_path(path: &QPath) -> Option<&PathSegment> {\n pub fn match_qpath(path: &QPath, segments: &[&str]) -> bool {\n     match *path {\n         QPath::Resolved(_, ref path) => match_path(path, segments),\n-        QPath::TypeRelative(ref ty, ref segment) => match ty.node {\n+        QPath::TypeRelative(ref ty, ref segment) => match ty.kind {\n             TyKind::Path(ref inner_path) => {\n                 !segments.is_empty()\n                     && match_qpath(inner_path, &segments[..(segments.len() - 1)])\n@@ -344,7 +344,7 @@ pub fn trait_ref_of_method<'tcx>(cx: &LateContext<'_, 'tcx>, hir_id: HirId) -> O\n     if_chain! {\n         if parent_impl != hir::CRATE_HIR_ID;\n         if let hir::Node::Item(item) = cx.tcx.hir().get(parent_impl);\n-        if let hir::ItemKind::Impl(_, _, _, _, trait_ref, _, _) = &item.node;\n+        if let hir::ItemKind::Impl(_, _, _, _, trait_ref, _, _) = &item.kind;\n         then { return trait_ref.as_ref(); }\n     }\n     None\n@@ -372,7 +372,7 @@ pub fn method_calls(expr: &Expr, max_depth: usize) -> (Vec<Symbol>, Vec<&[Expr]>\n \n     let mut current = expr;\n     for _ in 0..max_depth {\n-        if let ExprKind::MethodCall(path, span, args) = &current.node {\n+        if let ExprKind::MethodCall(path, span, args) = &current.kind {\n             if args.iter().any(|e| e.span.from_expansion()) {\n                 break;\n             }\n@@ -399,7 +399,7 @@ pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a\n     let mut matched = Vec::with_capacity(methods.len());\n     for method_name in methods.iter().rev() {\n         // method chains are stored last -> first\n-        if let ExprKind::MethodCall(ref path, _, ref args) = current.node {\n+        if let ExprKind::MethodCall(ref path, _, ref args) = current.kind {\n             if path.ident.name.as_str() == *method_name {\n                 if args.iter().any(|e| e.span.from_expansion()) {\n                     return None;\n@@ -439,7 +439,7 @@ pub fn get_item_name(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<Name> {\n \n /// Gets the name of a `Pat`, if any.\n pub fn get_pat_name(pat: &Pat) -> Option<Name> {\n-    match pat.node {\n+    match pat.kind {\n         PatKind::Binding(.., ref spname, _) => Some(spname.name),\n         PatKind::Path(ref qpath) => single_segment_path(qpath).map(|ps| ps.ident.name),\n         PatKind::Box(ref p) | PatKind::Ref(ref p, _) => get_pat_name(&*p),\n@@ -562,7 +562,7 @@ pub fn expr_block<'a, T: LintContext>(cx: &T, expr: &Expr, option: Option<String\n     let string = option.unwrap_or_default();\n     if expr.span.from_expansion() {\n         Cow::Owned(format!(\"{{ {} }}\", snippet_with_macro_callsite(cx, expr.span, default)))\n-    } else if let ExprKind::Block(_, _) = expr.node {\n+    } else if let ExprKind::Block(_, _) = expr.kind {\n         Cow::Owned(format!(\"{}{}\", code, string))\n     } else if string.is_empty() {\n         Cow::Owned(format!(\"{{ {} }}\", code))\n@@ -638,13 +638,13 @@ pub fn get_enclosing_block<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, hir_id: HirId)\n         match node {\n             Node::Block(block) => Some(block),\n             Node::Item(&Item {\n-                node: ItemKind::Fn(_, _, _, eid),\n+                kind: ItemKind::Fn(_, _, _, eid),\n                 ..\n             })\n             | Node::ImplItem(&ImplItem {\n-                node: ImplItemKind::Method(_, eid),\n+                kind: ImplItemKind::Method(_, eid),\n                 ..\n-            }) => match cx.tcx.hir().body(eid).value.node {\n+            }) => match cx.tcx.hir().body(eid).value.kind {\n                 ExprKind::Block(ref block, _) => Some(block),\n                 _ => None,\n             },\n@@ -657,7 +657,7 @@ pub fn get_enclosing_block<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, hir_id: HirId)\n \n /// Returns the base type for HIR references and pointers.\n pub fn walk_ptrs_hir_ty(ty: &hir::Ty) -> &hir::Ty {\n-    match ty.node {\n+    match ty.kind {\n         TyKind::Ptr(ref mut_ty) | TyKind::Rptr(_, ref mut_ty) => walk_ptrs_hir_ty(&mut_ty.ty),\n         _ => ty,\n     }\n@@ -704,7 +704,7 @@ pub fn is_integer_const(cx: &LateContext<'_, '_>, e: &Expr, value: u128) -> bool\n /// Checks whether the given expression is a constant literal of the given value.\n pub fn is_integer_literal(expr: &Expr, value: u128) -> bool {\n     // FIXME: use constant folding\n-    if let ExprKind::Lit(ref spanned) = expr.node {\n+    if let ExprKind::Lit(ref spanned) = expr.kind {\n         if let LitKind::Int(v, _) = spanned.node {\n             return v == value;\n         }\n@@ -804,8 +804,8 @@ pub fn is_copy<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n \n /// Checks if an expression is constructing a tuple-like enum variant or struct\n pub fn is_ctor_function(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n-    if let ExprKind::Call(ref fun, _) = expr.node {\n-        if let ExprKind::Path(ref qp) = fun.node {\n+    if let ExprKind::Call(ref fun, _) = expr.kind {\n+        if let ExprKind::Path(ref qp) = fun.kind {\n             return matches!(\n                 cx.tables.qpath_res(qp, fun.hir_id),\n                 def::Res::Def(DefKind::Variant, ..) | Res::Def(DefKind::Ctor(..), _)\n@@ -828,7 +828,7 @@ pub fn is_refutable(cx: &LateContext<'_, '_>, pat: &Pat) -> bool {\n         i.any(|pat| is_refutable(cx, pat))\n     }\n \n-    match pat.node {\n+    match pat.kind {\n         PatKind::Binding(..) | PatKind::Wild => false,\n         PatKind::Box(ref pat) | PatKind::Ref(ref pat, _) => is_refutable(cx, pat),\n         PatKind::Lit(..) | PatKind::Range(..) => true,\n@@ -865,7 +865,7 @@ pub fn is_automatically_derived(attrs: &[ast::Attribute]) -> bool {\n /// Ie. `x`, `{ x }` and `{{{{ x }}}}` all give `x`. `{ x; y }` and `{}` return\n /// themselves.\n pub fn remove_blocks(expr: &Expr) -> &Expr {\n-    if let ExprKind::Block(ref block, _) = expr.node {\n+    if let ExprKind::Block(ref block, _) = expr.kind {\n         if block.stmts.is_empty() {\n             if let Some(ref expr) = block.expr {\n                 remove_blocks(expr)\n@@ -881,7 +881,7 @@ pub fn remove_blocks(expr: &Expr) -> &Expr {\n }\n \n pub fn is_self(slf: &Param) -> bool {\n-    if let PatKind::Binding(.., name, _) = slf.pat.node {\n+    if let PatKind::Binding(.., name, _) = slf.pat.kind {\n         name.name == kw::SelfLower\n     } else {\n         false\n@@ -890,7 +890,7 @@ pub fn is_self(slf: &Param) -> bool {\n \n pub fn is_self_ty(slf: &hir::Ty) -> bool {\n     if_chain! {\n-        if let TyKind::Path(ref qp) = slf.node;\n+        if let TyKind::Path(ref qp) = slf.kind;\n         if let QPath::Resolved(None, ref path) = *qp;\n         if let Res::SelfTy(..) = path.res;\n         then {\n@@ -909,10 +909,10 @@ pub fn iter_input_pats<'tcx>(decl: &FnDecl, body: &'tcx Body) -> impl Iterator<I\n pub fn is_try(expr: &Expr) -> Option<&Expr> {\n     fn is_ok(arm: &Arm) -> bool {\n         if_chain! {\n-            if let PatKind::TupleStruct(ref path, ref pat, None) = arm.pat.node;\n+            if let PatKind::TupleStruct(ref path, ref pat, None) = arm.pat.kind;\n             if match_qpath(path, &paths::RESULT_OK[1..]);\n-            if let PatKind::Binding(_, hir_id, _, None) = pat[0].node;\n-            if let ExprKind::Path(QPath::Resolved(None, ref path)) = arm.body.node;\n+            if let PatKind::Binding(_, hir_id, _, None) = pat[0].kind;\n+            if let ExprKind::Path(QPath::Resolved(None, ref path)) = arm.body.kind;\n             if let Res::Local(lid) = path.res;\n             if lid == hir_id;\n             then {\n@@ -923,14 +923,14 @@ pub fn is_try(expr: &Expr) -> Option<&Expr> {\n     }\n \n     fn is_err(arm: &Arm) -> bool {\n-        if let PatKind::TupleStruct(ref path, _, _) = arm.pat.node {\n+        if let PatKind::TupleStruct(ref path, _, _) = arm.pat.kind {\n             match_qpath(path, &paths::RESULT_ERR[1..])\n         } else {\n             false\n         }\n     }\n \n-    if let ExprKind::Match(_, ref arms, ref source) = expr.node {\n+    if let ExprKind::Match(_, ref arms, ref source) = expr.kind {\n         // desugared from a `?` operator\n         if let MatchSource::TryDesugar = *source {\n             return Some(expr);\n@@ -959,7 +959,7 @@ pub fn is_allowed(cx: &LateContext<'_, '_>, lint: &'static Lint, id: HirId) -> b\n }\n \n pub fn get_arg_name(pat: &Pat) -> Option<ast::Name> {\n-    match pat.node {\n+    match pat.kind {\n         PatKind::Binding(.., ident, None) => Some(ident.name),\n         PatKind::Ref(ref subpat, _) => get_arg_name(subpat),\n         _ => None,\n@@ -1179,7 +1179,7 @@ pub fn if_sequence(mut expr: &Expr) -> (SmallVec<[&Expr; 1]>, SmallVec<[&Block;\n \n     while let Some((ref cond, ref then_expr, ref else_expr)) = higher::if_block(&expr) {\n         conds.push(&**cond);\n-        if let ExprKind::Block(ref block, _) = then_expr.node {\n+        if let ExprKind::Block(ref block, _) = then_expr.kind {\n             blocks.push(block);\n         } else {\n             panic!(\"ExprKind::If node is not an ExprKind::Block\");\n@@ -1194,7 +1194,7 @@ pub fn if_sequence(mut expr: &Expr) -> (SmallVec<[&Expr; 1]>, SmallVec<[&Block;\n \n     // final `else {..}`\n     if !blocks.is_empty() {\n-        if let ExprKind::Block(ref block, _) = expr.node {\n+        if let ExprKind::Block(ref block, _) = expr.kind {\n             blocks.push(&**block);\n         }\n     }"}, {"sha": "32ec4d6c54869d429e5f6e8eee9403bda820fcd3", "filename": "clippy_lints/src/utils/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Futils%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Futils%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fptr.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -56,7 +56,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PtrCloneVisitor<'a, 'tcx> {\n         if self.abort {\n             return;\n         }\n-        if let ExprKind::MethodCall(ref seg, _, ref args) = expr.node {\n+        if let ExprKind::MethodCall(ref seg, _, ref args) = expr.kind {\n             if args.len() == 1 && match_var(&args[0], self.name) {\n                 if seg.ident.name.as_str() == \"capacity\" {\n                     self.abort = true;"}, {"sha": "3c31067f7f8ae6be4c7d886b4c4729b2b9ca5344", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -90,7 +90,7 @@ impl<'a> Sugg<'a> {\n     /// Generate a suggestion for an expression with the given snippet. This is used by the `hir_*`\n     /// function variants of `Sugg`, since these use different snippet functions.\n     fn hir_from_snippet(expr: &hir::Expr, snippet: Cow<'a, str>) -> Self {\n-        match expr.node {\n+        match expr.kind {\n             hir::ExprKind::AddrOf(..)\n             | hir::ExprKind::Box(..)\n             | hir::ExprKind::Closure(..)\n@@ -129,7 +129,7 @@ impl<'a> Sugg<'a> {\n \n         let snippet = snippet(cx, expr.span, default);\n \n-        match expr.node {\n+        match expr.kind {\n             ast::ExprKind::AddrOf(..)\n             | ast::ExprKind::Box(..)\n             | ast::ExprKind::Closure(..)"}, {"sha": "af874ad1e50624ea0579fc6598bea54f83f8e3b2", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -33,7 +33,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UselessVec {\n         if_chain! {\n             if let ty::Ref(_, ty, _) = cx.tables.expr_ty_adjusted(expr).kind;\n             if let ty::Slice(..) = ty.kind;\n-            if let ExprKind::AddrOf(_, ref addressee) = expr.node;\n+            if let ExprKind::AddrOf(_, ref addressee) = expr.kind;\n             if let Some(vec_args) = higher::vec_macro(cx, addressee);\n             then {\n                 check_vec_macro(cx, &vec_args, expr.span);"}, {"sha": "989d2f374a84bfb5066e1af771a813a1765343dd", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -393,7 +393,7 @@ fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &TokenStream, is_write: bool) -> (O\n                 None,\n             );\n         };\n-        match &token_expr.node {\n+        match &token_expr.kind {\n             ExprKind::Lit(_) => {\n                 let mut all_simple = true;\n                 let mut seen = false;\n@@ -414,8 +414,8 @@ fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &TokenStream, is_write: bool) -> (O\n                 idx += 1;\n             },\n             ExprKind::Assign(lhs, rhs) => {\n-                if let ExprKind::Lit(_) = rhs.node {\n-                    if let ExprKind::Path(_, p) = &lhs.node {\n+                if let ExprKind::Lit(_) = rhs.kind {\n+                    if let ExprKind::Path(_, p) = &lhs.kind {\n                         let mut all_simple = true;\n                         let mut seen = false;\n                         for arg in &args {"}, {"sha": "f866d76a3819b54b6a5e7e634db33b9ac8c35c18", "filename": "clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -28,7 +28,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ZeroDiv {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // check for instances of 0.0/0.0\n         if_chain! {\n-            if let ExprKind::Binary(ref op, ref left, ref right) = expr.node;\n+            if let ExprKind::Binary(ref op, ref left, ref right) = expr.kind;\n             if let BinOpKind::Div = op.node;\n             // TODO - constant_simple does not fold many operations involving floats.\n             // That's probably fine for this lint - it's pretty unlikely that someone would"}, {"sha": "72f27d893093f722b33b011219a7f4ba4591780d", "filename": "tests/ui/author.stdout", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/tests%2Fui%2Fauthor.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/tests%2Fui%2Fauthor.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor.stdout?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -1,13 +1,13 @@\n if_chain! {\n-    if let StmtKind::Local(ref local) = stmt.node;\n+    if let StmtKind::Local(ref local) = stmt.kind;\n     if let Some(ref init) = local.init;\n-    if let ExprKind::Cast(ref expr, ref cast_ty) = init.node;\n-    if let TyKind::Path(ref qp) = cast_ty.node;\n+    if let ExprKind::Cast(ref expr, ref cast_ty) = init.kind;\n+    if let TyKind::Path(ref qp) = cast_ty.kind;\n     if match_qpath(qp, &[\"char\"]);\n-    if let ExprKind::Lit(ref lit) = expr.node;\n+    if let ExprKind::Lit(ref lit) = expr.kind;\n     if let LitKind::Int(69, _) = lit.node;\n-    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = local.pat.node;\n-    if name.node.as_str() == \"x\";\n+    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = local.pat.kind;\n+    if name.kind.as_str() == \"x\";\n     then {\n         // report your lint here\n     }"}, {"sha": "c7127db904a3806b7da722b2d7a62651cf12c0a1", "filename": "tests/ui/author/blocks.stdout", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/tests%2Fui%2Fauthor%2Fblocks.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/tests%2Fui%2Fauthor%2Fblocks.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fblocks.stdout?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -1,9 +1,9 @@\n if_chain! {\n-    if let ExprKind::Block(ref block) = expr.node;\n+    if let ExprKind::Block(ref block) = expr.kind;\n     if let Some(trailing_expr) = &block.expr;\n     if block.stmts.len() == 1;\n-    if let StmtKind::Semi(ref e, _) = block.stmts[0].node\n-    if let ExprKind::Tup(ref elements) = e.node;\n+    if let StmtKind::Semi(ref e, _) = block.stmts[0].kind\n+    if let ExprKind::Tup(ref elements) = e.kind;\n     if elements.len() == 0;\n     then {\n         // report your lint here"}, {"sha": "4dccf666631a928a15e4beb142dde1eaedd36135", "filename": "tests/ui/author/call.stdout", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/tests%2Fui%2Fauthor%2Fcall.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/tests%2Fui%2Fauthor%2Fcall.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fcall.stdout?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -1,15 +1,15 @@\n if_chain! {\n-    if let StmtKind::Local(ref local) = stmt.node;\n+    if let StmtKind::Local(ref local) = stmt.kind;\n     if let Some(ref init) = local.init;\n-    if let ExprKind::Call(ref func, ref args) = init.node;\n-    if let ExprKind::Path(ref path) = func.node;\n+    if let ExprKind::Call(ref func, ref args) = init.kind;\n+    if let ExprKind::Path(ref path) = func.kind;\n     if match_qpath(path, &[\"{{root}}\", \"std\", \"cmp\", \"min\"]);\n     if args.len() == 2;\n-    if let ExprKind::Lit(ref lit) = args[0].node;\n+    if let ExprKind::Lit(ref lit) = args[0].kind;\n     if let LitKind::Int(3, _) = lit.node;\n-    if let ExprKind::Lit(ref lit1) = args[1].node;\n+    if let ExprKind::Lit(ref lit1) = args[1].kind;\n     if let LitKind::Int(4, _) = lit1.node;\n-    if let PatKind::Wild = local.pat.node;\n+    if let PatKind::Wild = local.pat.kind;\n     then {\n         // report your lint here\n     }"}, {"sha": "eb724dda88b6224f42ba86b8f42fa87eebd27251", "filename": "tests/ui/author/for_loop.stdout", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/tests%2Fui%2Fauthor%2Ffor_loop.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/tests%2Fui%2Fauthor%2Ffor_loop.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Ffor_loop.stdout?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -1,61 +1,61 @@\n if_chain! {\n-    if let ExprKind::DropTemps(ref expr) = expr.node;\n-    if let ExprKind::Match(ref expr1, ref arms, MatchSource::ForLoopDesugar) = expr.node;\n-    if let ExprKind::Call(ref func, ref args) = expr1.node;\n-    if let ExprKind::Path(ref path) = func.node;\n+    if let ExprKind::DropTemps(ref expr) = expr.kind;\n+    if let ExprKind::Match(ref expr1, ref arms, MatchSource::ForLoopDesugar) = expr.kind;\n+    if let ExprKind::Call(ref func, ref args) = expr1.kind;\n+    if let ExprKind::Path(ref path) = func.kind;\n     if match_qpath(path, &[\"{{root}}\", \"std\", \"iter\", \"IntoIterator\", \"into_iter\"]);\n     if args.len() == 1;\n-    if let ExprKind::Struct(ref path1, ref fields, None) = args[0].node;\n+    if let ExprKind::Struct(ref path1, ref fields, None) = args[0].kind;\n     if match_qpath(path1, &[\"{{root}}\", \"std\", \"ops\", \"Range\"]);\n     if fields.len() == 2;\n     // unimplemented: field checks\n     if arms.len() == 1;\n-    if let ExprKind::Loop(ref body, ref label, LoopSource::ForLoop) = arms[0].body.node;\n+    if let ExprKind::Loop(ref body, ref label, LoopSource::ForLoop) = arms[0].body.kind;\n     if let Some(trailing_expr) = &body.expr;\n     if body.stmts.len() == 4;\n-    if let StmtKind::Local(ref local) = body.stmts[0].node;\n-    if let PatKind::Binding(BindingAnnotation::Mutable, _, name, None) = local.pat.node;\n-    if name.node.as_str() == \"__next\";\n-    if let StmtKind::Expr(ref e, _) = body.stmts[1].node\n-    if let ExprKind::Match(ref expr2, ref arms1, MatchSource::ForLoopDesugar) = e.node;\n-    if let ExprKind::Call(ref func1, ref args1) = expr2.node;\n-    if let ExprKind::Path(ref path2) = func1.node;\n+    if let StmtKind::Local(ref local) = body.stmts[0].kind;\n+    if let PatKind::Binding(BindingAnnotation::Mutable, _, name, None) = local.pat.kind;\n+    if name.kind.as_str() == \"__next\";\n+    if let StmtKind::Expr(ref e, _) = body.stmts[1].kind\n+    if let ExprKind::Match(ref expr2, ref arms1, MatchSource::ForLoopDesugar) = e.kind;\n+    if let ExprKind::Call(ref func1, ref args1) = expr2.kind;\n+    if let ExprKind::Path(ref path2) = func1.kind;\n     if match_qpath(path2, &[\"{{root}}\", \"std\", \"iter\", \"Iterator\", \"next\"]);\n     if args1.len() == 1;\n-    if let ExprKind::AddrOf(MutMutable, ref inner) = args1[0].node;\n-    if let ExprKind::Path(ref path3) = inner.node;\n+    if let ExprKind::AddrOf(MutMutable, ref inner) = args1[0].kind;\n+    if let ExprKind::Path(ref path3) = inner.kind;\n     if match_qpath(path3, &[\"iter\"]);\n     if arms1.len() == 2;\n-    if let ExprKind::Assign(ref target, ref value) = arms1[0].body.node;\n-    if let ExprKind::Path(ref path4) = target.node;\n+    if let ExprKind::Assign(ref target, ref value) = arms1[0].body.kind;\n+    if let ExprKind::Path(ref path4) = target.kind;\n     if match_qpath(path4, &[\"__next\"]);\n-    if let ExprKind::Path(ref path5) = value.node;\n+    if let ExprKind::Path(ref path5) = value.kind;\n     if match_qpath(path5, &[\"val\"]);\n-    if let PatKind::TupleStruct(ref path6, ref fields1, None) = arms1[0].pat.node;\n+    if let PatKind::TupleStruct(ref path6, ref fields1, None) = arms1[0].pat.kind;\n     if match_qpath(path6, &[\"{{root}}\", \"std\", \"option\", \"Option\", \"Some\"]);\n     if fields1.len() == 1;\n     // unimplemented: field checks\n-    if let ExprKind::Break(ref destination, None) = arms1[1].body.node;\n-    if let PatKind::Path(ref path7) = arms1[1].pat.node;\n+    if let ExprKind::Break(ref destination, None) = arms1[1].body.kind;\n+    if let PatKind::Path(ref path7) = arms1[1].pat.kind;\n     if match_qpath(path7, &[\"{{root}}\", \"std\", \"option\", \"Option\", \"None\"]);\n-    if let StmtKind::Local(ref local1) = body.stmts[2].node;\n+    if let StmtKind::Local(ref local1) = body.stmts[2].kind;\n     if let Some(ref init) = local1.init;\n-    if let ExprKind::Path(ref path8) = init.node;\n+    if let ExprKind::Path(ref path8) = init.kind;\n     if match_qpath(path8, &[\"__next\"]);\n-    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name1, None) = local1.pat.node;\n-    if name1.node.as_str() == \"y\";\n-    if let StmtKind::Expr(ref e1, _) = body.stmts[3].node\n-    if let ExprKind::Block(ref block) = e1.node;\n+    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name1, None) = local1.pat.kind;\n+    if name1.kind.as_str() == \"y\";\n+    if let StmtKind::Expr(ref e1, _) = body.stmts[3].kind\n+    if let ExprKind::Block(ref block) = e1.kind;\n     if let Some(trailing_expr1) = &block.expr;\n     if block.stmts.len() == 1;\n-    if let StmtKind::Local(ref local2) = block.stmts[0].node;\n+    if let StmtKind::Local(ref local2) = block.stmts[0].kind;\n     if let Some(ref init1) = local2.init;\n-    if let ExprKind::Path(ref path9) = init1.node;\n+    if let ExprKind::Path(ref path9) = init1.kind;\n     if match_qpath(path9, &[\"y\"]);\n-    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name2, None) = local2.pat.node;\n-    if name2.node.as_str() == \"z\";\n-    if let PatKind::Binding(BindingAnnotation::Mutable, _, name3, None) = arms[0].pat.node;\n-    if name3.node.as_str() == \"iter\";\n+    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name2, None) = local2.pat.kind;\n+    if name2.kind.as_str() == \"z\";\n+    if let PatKind::Binding(BindingAnnotation::Mutable, _, name3, None) = arms[0].pat.kind;\n+    if name3.kind.as_str() == \"iter\";\n     then {\n         // report your lint here\n     }"}, {"sha": "c18d035953e539b97fea337b2f9bb9a866d94761", "filename": "tests/ui/author/if.stdout", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/tests%2Fui%2Fauthor%2Fif.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/tests%2Fui%2Fauthor%2Fif.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fif.stdout?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -1,30 +1,30 @@\n if_chain! {\n-    if let StmtKind::Local(ref local) = stmt.node;\n+    if let StmtKind::Local(ref local) = stmt.kind;\n     if let Some(ref init) = local.init;\n     if let Some((ref cond, ref then, Some(else_))) = higher::if_block(&init);\n-    if let ExprKind::Block(ref block) = else_.node;\n+    if let ExprKind::Block(ref block) = else_.kind;\n     if let Some(trailing_expr) = &block.expr;\n     if block.stmts.len() == 1;\n-    if let StmtKind::Semi(ref e, _) = block.stmts[0].node\n-    if let ExprKind::Binary(ref op, ref left, ref right) = e.node;\n+    if let StmtKind::Semi(ref e, _) = block.stmts[0].kind\n+    if let ExprKind::Binary(ref op, ref left, ref right) = e.kind;\n     if BinOpKind::Eq == op.node;\n-    if let ExprKind::Lit(ref lit) = left.node;\n+    if let ExprKind::Lit(ref lit) = left.kind;\n     if let LitKind::Int(2, _) = lit.node;\n-    if let ExprKind::Lit(ref lit1) = right.node;\n+    if let ExprKind::Lit(ref lit1) = right.kind;\n     if let LitKind::Int(2, _) = lit1.node;\n-    if let ExprKind::Lit(ref lit2) = cond.node;\n+    if let ExprKind::Lit(ref lit2) = cond.kind;\n     if let LitKind::Bool(true) = lit2.node;\n-    if let ExprKind::Block(ref block1) = then.node;\n+    if let ExprKind::Block(ref block1) = then.kind;\n     if let Some(trailing_expr1) = &block1.expr;\n     if block1.stmts.len() == 1;\n-    if let StmtKind::Semi(ref e1, _) = block1.stmts[0].node\n-    if let ExprKind::Binary(ref op1, ref left1, ref right1) = e1.node;\n+    if let StmtKind::Semi(ref e1, _) = block1.stmts[0].kind\n+    if let ExprKind::Binary(ref op1, ref left1, ref right1) = e1.kind;\n     if BinOpKind::Eq == op1.node;\n-    if let ExprKind::Lit(ref lit3) = left1.node;\n+    if let ExprKind::Lit(ref lit3) = left1.kind;\n     if let LitKind::Int(1, _) = lit3.node;\n-    if let ExprKind::Lit(ref lit4) = right1.node;\n+    if let ExprKind::Lit(ref lit4) = right1.kind;\n     if let LitKind::Int(1, _) = lit4.node;\n-    if let PatKind::Wild = local.pat.node;\n+    if let PatKind::Wild = local.pat.kind;\n     then {\n         // report your lint here\n     }"}, {"sha": "a83754125fb5b85a8c8e334d3c50ea6084dc5c19", "filename": "tests/ui/author/matches.stout", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/tests%2Fui%2Fauthor%2Fmatches.stout", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/tests%2Fui%2Fauthor%2Fmatches.stout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fmatches.stout?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -1,37 +1,37 @@\n if_chain! {\n-    if let StmtKind::Decl(ref decl, _) = stmt.node\n-    if let DeclKind::Local(ref local) = decl.node;\n+    if let StmtKind::Decl(ref decl, _) = stmt.kind\n+    if let DeclKind::Local(ref local) = decl.kind;\n     if let Some(ref init) = local.init;\n-    if let ExprKind::Match(ref expr, ref arms, MatchSource::Normal) = init.node;\n-    if let ExprKind::Lit(ref lit) = expr.node;\n-    if let LitKind::Int(42, _) = lit.node;\n+    if let ExprKind::Match(ref expr, ref arms, MatchSource::Normal) = init.kind;\n+    if let ExprKind::Lit(ref lit) = expr.kind;\n+    if let LitKind::Int(42, _) = lit.kind;\n     if arms.len() == 3;\n-    if let ExprKind::Lit(ref lit1) = arms[0].body.node;\n-    if let LitKind::Int(5, _) = lit1.node;\n+    if let ExprKind::Lit(ref lit1) = arms[0].body.kind;\n+    if let LitKind::Int(5, _) = lit1.kind;\n     if arms[0].pats.len() == 1;\n-    if let PatKind::Lit(ref lit_expr) = arms[0].pats[0].node\n-    if let ExprKind::Lit(ref lit2) = lit_expr.node;\n-    if let LitKind::Int(16, _) = lit2.node;\n-    if let ExprKind::Block(ref block) = arms[1].body.node;\n-    if let StmtKind::Decl(ref decl1, _) = block.node\n-    if let DeclKind::Local(ref local1) = decl1.node;\n+    if let PatKind::Lit(ref lit_expr) = arms[0].pats[0].kind\n+    if let ExprKind::Lit(ref lit2) = lit_expr.kind;\n+    if let LitKind::Int(16, _) = lit2.kind;\n+    if let ExprKind::Block(ref block) = arms[1].body.kind;\n+    if let StmtKind::Decl(ref decl1, _) = block.kind\n+    if let DeclKind::Local(ref local1) = decl1.kind;\n     if let Some(ref init1) = local1.init\n-    if let ExprKind::Lit(ref lit3) = init1.node;\n-    if let LitKind::Int(3, _) = lit3.node;\n-    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = local1.pat.node;\n-    if name.node.as_str() == \"x\";\n-    if let ExprKind::Path(ref path) = local1.pat.node;\n+    if let ExprKind::Lit(ref lit3) = init1.kind;\n+    if let LitKind::Int(3, _) = lit3.kind;\n+    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = local1.pat.kind;\n+    if name.kind.as_str() == \"x\";\n+    if let ExprKind::Path(ref path) = local1.pat.kind;\n     if match_qpath(path, &[\"x\"]);\n     if arms[1].pats.len() == 1;\n-    if let PatKind::Lit(ref lit_expr1) = arms[1].pats[0].node\n-    if let ExprKind::Lit(ref lit4) = lit_expr1.node;\n-    if let LitKind::Int(17, _) = lit4.node;\n-    if let ExprKind::Lit(ref lit5) = arms[2].body.node;\n-    if let LitKind::Int(1, _) = lit5.node;\n+    if let PatKind::Lit(ref lit_expr1) = arms[1].pats[0].kind\n+    if let ExprKind::Lit(ref lit4) = lit_expr1.kind;\n+    if let LitKind::Int(17, _) = lit4.kind;\n+    if let ExprKind::Lit(ref lit5) = arms[2].body.kind;\n+    if let LitKind::Int(1, _) = lit5.kind;\n     if arms[2].pats.len() == 1;\n-    if let PatKind::Wild = arms[2].pats[0].node;\n-    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name1, None) = local.pat.node;\n-    if name1.node.as_str() == \"a\";\n+    if let PatKind::Wild = arms[2].pats[0].kind;\n+    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name1, None) = local.pat.kind;\n+    if name1.kind.as_str() == \"a\";\n     then {\n         // report your lint here\n     }"}, {"sha": "65f93f3cdc06b9aa4385f611f3342867cbc4a94b", "filename": "tests/ui/issue_3849.stdout", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/tests%2Fui%2Fissue_3849.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/tests%2Fui%2Fissue_3849.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissue_3849.stdout?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -1,13 +1,13 @@\n if_chain! {\n-    if let StmtKind::Local(ref local) = stmt.node;\n+    if let StmtKind::Local(ref local) = stmt.kind;\n     if let Some(ref init) = local.init;\n-    if let ExprKind::Call(ref func, ref args) = init.node;\n-    if let ExprKind::Path(ref path) = func.node;\n+    if let ExprKind::Call(ref func, ref args) = init.kind;\n+    if let ExprKind::Path(ref path) = func.kind;\n     if match_qpath(path, &[\"std\", \"mem\", \"transmute\"]);\n     if args.len() == 1;\n-    if let ExprKind::Path(ref path1) = args[0].node;\n+    if let ExprKind::Path(ref path1) = args[0].kind;\n     if match_qpath(path1, &[\"ZPTR\"]);\n-    if let PatKind::Wild = local.pat.node;\n+    if let PatKind::Wild = local.pat.kind;\n     then {\n         // report your lint here\n     }"}, {"sha": "eccad22c47f623d8665c7fe04e77aff48a18a56c", "filename": "tests/ui/trailing_zeros.stdout", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/tests%2Fui%2Ftrailing_zeros.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/4bbd10a585616dd9d7027d16d7f8e6b8ece9e325/tests%2Fui%2Ftrailing_zeros.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrailing_zeros.stdout?ref=4bbd10a585616dd9d7027d16d7f8e6b8ece9e325", "patch": "@@ -1,13 +1,13 @@\n if_chain! {\n-    if let ExprKind::Binary(ref op, ref left, ref right) = expr.node;\n+    if let ExprKind::Binary(ref op, ref left, ref right) = expr.kind;\n     if BinOpKind::Eq == op.node;\n-    if let ExprKind::Binary(ref op1, ref left1, ref right1) = left.node;\n+    if let ExprKind::Binary(ref op1, ref left1, ref right1) = left.kind;\n     if BinOpKind::BitAnd == op1.node;\n-    if let ExprKind::Path(ref path) = left1.node;\n+    if let ExprKind::Path(ref path) = left1.kind;\n     if match_qpath(path, &[\"x\"]);\n-    if let ExprKind::Lit(ref lit) = right1.node;\n+    if let ExprKind::Lit(ref lit) = right1.kind;\n     if let LitKind::Int(15, _) = lit.node;\n-    if let ExprKind::Lit(ref lit1) = right.node;\n+    if let ExprKind::Lit(ref lit1) = right.kind;\n     if let LitKind::Int(0, _) = lit1.node;\n     then {\n         // report your lint here"}]}