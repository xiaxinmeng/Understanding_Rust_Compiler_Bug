{"sha": "3ac605e6876056fa56098231cc2f96553faab8f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhYzYwNWU2ODc2MDU2ZmE1NjA5ODIzMWNjMmY5NjU1M2ZhYWI4ZjA=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2018-12-20T20:56:28Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2018-12-23T12:48:04Z"}, "message": "Add beginnings of type infrastructure", "tree": {"sha": "82294448f696bae2ba640c4fb74dac9b929265a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82294448f696bae2ba640c4fb74dac9b929265a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ac605e6876056fa56098231cc2f96553faab8f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ac605e6876056fa56098231cc2f96553faab8f0", "html_url": "https://github.com/rust-lang/rust/commit/3ac605e6876056fa56098231cc2f96553faab8f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ac605e6876056fa56098231cc2f96553faab8f0/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d77520fde3c953968beb09a3da80a0e7b17bbc04", "url": "https://api.github.com/repos/rust-lang/rust/commits/d77520fde3c953968beb09a3da80a0e7b17bbc04", "html_url": "https://github.com/rust-lang/rust/commit/d77520fde3c953968beb09a3da80a0e7b17bbc04"}], "stats": {"total": 704, "additions": 689, "deletions": 15}, "files": [{"sha": "f26c498873ddf9a2d10cb05368e2bdfd573af3ef", "filename": "crates/ra_analysis/src/db.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3ac605e6876056fa56098231cc2f96553faab8f0/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac605e6876056fa56098231cc2f96553faab8f0/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdb.rs?ref=3ac605e6876056fa56098231cc2f96553faab8f0", "patch": "@@ -93,6 +93,7 @@ salsa::database_storage! {\n             fn item_map() for hir::db::ItemMapQuery;\n             fn fn_syntax() for hir::db::FnSyntaxQuery;\n             fn submodules() for hir::db::SubmodulesQuery;\n+            fn infer() for hir::db::InferQuery;\n         }\n     }\n }"}, {"sha": "f0bff3c02a4589da713847f3a28acbf05768b36b", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ac605e6876056fa56098231cc2f96553faab8f0/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac605e6876056fa56098231cc2f96553faab8f0/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=3ac605e6876056fa56098231cc2f96553faab8f0", "patch": "@@ -14,6 +14,7 @@ use crate::{\n     function::FnId,\n     module::{ModuleId, ModuleTree, ModuleSource,\n     nameres::{ItemMap, InputModuleItems}},\n+    ty::InferenceResult,\n };\n \n salsa::query_group! {\n@@ -30,6 +31,11 @@ pub trait HirDatabase: SyntaxDatabase\n         use fn query_definitions::fn_syntax;\n     }\n \n+    fn infer(fn_id: FnId) -> Arc<InferenceResult> {\n+        type InferQuery;\n+        use fn query_definitions::infer;\n+    }\n+\n     fn file_items(file_id: FileId) -> Arc<SourceFileItems> {\n         type SourceFileItemsQuery;\n         use fn query_definitions::file_items;"}, {"sha": "360e9e9a04ec47bb72b23ac999df95ad3ee792e0", "filename": "crates/ra_hir/src/function.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ac605e6876056fa56098231cc2f96553faab8f0/crates%2Fra_hir%2Fsrc%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac605e6876056fa56098231cc2f96553faab8f0/crates%2Fra_hir%2Fsrc%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffunction.rs?ref=3ac605e6876056fa56098231cc2f96553faab8f0", "patch": "@@ -10,7 +10,7 @@ use ra_syntax::{\n     ast::{self, AstNode, DocCommentsOwner, NameOwner},\n };\n \n-use crate::{ DefId, HirDatabase };\n+use crate::{ DefId, HirDatabase, ty::InferenceResult };\n \n pub use self::scope::FnScopes;\n \n@@ -35,6 +35,10 @@ impl Function {\n         let syntax = db.fn_syntax(self.fn_id);\n         FnSignatureInfo::new(syntax.borrowed())\n     }\n+\n+    pub fn infer(&self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n+        db.infer(self.fn_id)\n+    }\n }\n \n #[derive(Debug, Clone)]"}, {"sha": "e84f44675a75eca0b76eec555fa8b2611bfec5f3", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3ac605e6876056fa56098231cc2f96553faab8f0/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac605e6876056fa56098231cc2f96553faab8f0/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=3ac605e6876056fa56098231cc2f96553faab8f0", "patch": "@@ -25,6 +25,7 @@ pub mod source_binder;\n mod krate;\n mod module;\n mod function;\n+mod ty;\n \n use std::ops::Index;\n "}, {"sha": "a9fa540d58de9b0393f93cd6a9a2a09f95e26931", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3ac605e6876056fa56098231cc2f96553faab8f0/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac605e6876056fa56098231cc2f96553faab8f0/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=3ac605e6876056fa56098231cc2f96553faab8f0", "patch": "@@ -8,7 +8,7 @@ use test_utils::{parse_fixture, CURSOR_MARKER, extract_offset};\n \n use crate::{db, DefId, DefLoc};\n \n-const WORKSPACE: SourceRootId = SourceRootId(0);\n+pub const WORKSPACE: SourceRootId = SourceRootId(0);\n \n #[derive(Debug)]\n pub(crate) struct MockDatabase {\n@@ -182,6 +182,7 @@ salsa::database_storage! {\n             fn item_map() for db::ItemMapQuery;\n             fn fn_syntax() for db::FnSyntaxQuery;\n             fn submodules() for db::SubmodulesQuery;\n+            fn infer() for db::InferQuery;\n         }\n     }\n }"}, {"sha": "ccbfdf02832f32dfb843932b0ffc63bbeabcc926", "filename": "crates/ra_hir/src/query_definitions.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ac605e6876056fa56098231cc2f96553faab8f0/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac605e6876056fa56098231cc2f96553faab8f0/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs?ref=3ac605e6876056fa56098231cc2f96553faab8f0", "patch": "@@ -19,6 +19,7 @@ use crate::{\n         imp::Submodule,\n         nameres::{InputModuleItems, ItemMap, Resolver},\n     },\n+    ty::{self, InferenceResult}\n };\n \n /// Resolve `FnId` to the corresponding `SyntaxNode`\n@@ -35,6 +36,13 @@ pub(super) fn fn_scopes(db: &impl HirDatabase, fn_id: FnId) -> Arc<FnScopes> {\n     Arc::new(res)\n }\n \n+pub(super) fn infer(db: &impl HirDatabase, fn_id: FnId) -> Arc<InferenceResult> {\n+    let syntax = db.fn_syntax(fn_id);\n+    let scopes = db.fn_scopes(fn_id);\n+    let res = ty::infer(db, syntax.borrowed(), scopes);\n+    Arc::new(res)\n+}\n+\n pub(super) fn file_items(db: &impl HirDatabase, file_id: FileId) -> Arc<SourceFileItems> {\n     let mut res = SourceFileItems::new(file_id);\n     let source_file = db.source_file(file_id);"}, {"sha": "36dc5d137ca0599904b015a042f7b4ce46f735c2", "filename": "crates/ra_hir/src/ty.rs", "status": "added", "additions": 478, "deletions": 0, "changes": 478, "blob_url": "https://github.com/rust-lang/rust/blob/3ac605e6876056fa56098231cc2f96553faab8f0/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac605e6876056fa56098231cc2f96553faab8f0/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=3ac605e6876056fa56098231cc2f96553faab8f0", "patch": "@@ -0,0 +1,478 @@\n+mod primitive;\n+#[cfg(test)]\n+mod tests;\n+\n+use rustc_hash::{FxHashMap, FxHashSet};\n+\n+use std::sync::Arc;\n+use std::collections::HashMap;\n+\n+use ra_db::LocalSyntaxPtr;\n+use ra_syntax::{\n+    TextRange, TextUnit,\n+    algo::visit::{visitor, Visitor},\n+    ast::{self, AstNode, DocCommentsOwner, NameOwner, LoopBodyOwner, ArgListOwner},\n+    SyntaxNodeRef\n+};\n+\n+use crate::{\n+    FnScopes,\n+    db::HirDatabase,\n+    arena::{Arena, Id},\n+};\n+\n+// pub(crate) type TypeId = Id<Ty>;\n+\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+pub enum Ty {\n+    /// The primitive boolean type. Written as `bool`.\n+    Bool,\n+\n+    /// The primitive character type; holds a Unicode scalar value\n+    /// (a non-surrogate code point).  Written as `char`.\n+    Char,\n+\n+    /// A primitive signed integer type. For example, `i32`.\n+    Int(primitive::IntTy),\n+\n+    /// A primitive unsigned integer type. For example, `u32`.\n+    Uint(primitive::UintTy),\n+\n+    /// A primitive floating-point type. For example, `f64`.\n+    Float(primitive::FloatTy),\n+\n+    /// Structures, enumerations and unions.\n+    ///\n+    /// Substs here, possibly against intuition, *may* contain `Param`s.\n+    /// That is, even after substitution it is possible that there are type\n+    /// variables. This happens when the `Adt` corresponds to an ADT\n+    /// definition and not a concrete use of it.\n+    // Adt(&'tcx AdtDef, &'tcx Substs<'tcx>),\n+\n+    // Foreign(DefId),\n+\n+    /// The pointee of a string slice. Written as `str`.\n+    Str,\n+\n+    /// An array with the given length. Written as `[T; n]`.\n+    // Array(Ty<'tcx>, &'tcx ty::Const<'tcx>),\n+\n+    /// The pointee of an array slice.  Written as `[T]`.\n+    Slice(TyRef),\n+\n+    /// A raw pointer. Written as `*mut T` or `*const T`\n+    // RawPtr(TypeAndMut<'tcx>),\n+\n+    /// A reference; a pointer with an associated lifetime. Written as\n+    /// `&'a mut T` or `&'a T`.\n+    // Ref(Region<'tcx>, Ty<'tcx>, hir::Mutability),\n+\n+    /// The anonymous type of a function declaration/definition. Each\n+    /// function has a unique type, which is output (for a function\n+    /// named `foo` returning an `i32`) as `fn() -> i32 {foo}`.\n+    ///\n+    /// For example the type of `bar` here:\n+    ///\n+    /// ```rust\n+    /// fn foo() -> i32 { 1 }\n+    /// let bar = foo; // bar: fn() -> i32 {foo}\n+    /// ```\n+    // FnDef(DefId, &'tcx Substs<'tcx>),\n+\n+    /// A pointer to a function.  Written as `fn() -> i32`.\n+    ///\n+    /// For example the type of `bar` here:\n+    ///\n+    /// ```rust\n+    /// fn foo() -> i32 { 1 }\n+    /// let bar: fn() -> i32 = foo;\n+    /// ```\n+    // FnPtr(PolyFnSig<'tcx>),\n+\n+    /// A trait, defined with `trait`.\n+    // Dynamic(Binder<&'tcx List<ExistentialPredicate<'tcx>>>, ty::Region<'tcx>),\n+\n+    /// The anonymous type of a closure. Used to represent the type of\n+    /// `|a| a`.\n+    // Closure(DefId, ClosureSubsts<'tcx>),\n+\n+    /// The anonymous type of a generator. Used to represent the type of\n+    /// `|a| yield a`.\n+    // Generator(DefId, GeneratorSubsts<'tcx>, hir::GeneratorMovability),\n+\n+    /// A type representin the types stored inside a generator.\n+    /// This should only appear in GeneratorInteriors.\n+    // GeneratorWitness(Binder<&'tcx List<Ty<'tcx>>>),\n+\n+    /// The never type `!`\n+    Never,\n+\n+    /// A tuple type.  For example, `(i32, bool)`.\n+    Tuple(Vec<Ty>),\n+\n+    /// The projection of an associated type.  For example,\n+    /// `<T as Trait<..>>::N`.\n+    // Projection(ProjectionTy<'tcx>),\n+\n+    /// Opaque (`impl Trait`) type found in a return type.\n+    /// The `DefId` comes either from\n+    /// * the `impl Trait` ast::Ty node,\n+    /// * or the `existential type` declaration\n+    /// The substitutions are for the generics of the function in question.\n+    /// After typeck, the concrete type can be found in the `types` map.\n+    // Opaque(DefId, &'tcx Substs<'tcx>),\n+\n+    /// A type parameter; for example, `T` in `fn f<T>(x: T) {}\n+    // Param(ParamTy),\n+\n+    /// Bound type variable, used only when preparing a trait query.\n+    // Bound(ty::DebruijnIndex, BoundTy),\n+\n+    /// A placeholder type - universally quantified higher-ranked type.\n+    // Placeholder(ty::PlaceholderType),\n+\n+    /// A type variable used during type checking.\n+    // Infer(InferTy),\n+\n+    /// A placeholder for a type which could not be computed; this is\n+    /// propagated to avoid useless error messages.\n+    Unknown,\n+}\n+\n+type TyRef = Arc<Ty>;\n+\n+impl Ty {\n+    pub fn new(node: ast::TypeRef) -> Self {\n+        use ra_syntax::ast::TypeRef::*;\n+        match node {\n+            ParenType(_inner) => Ty::Unknown, // TODO\n+            TupleType(_inner) => Ty::Unknown, // TODO\n+            NeverType(..) => Ty::Never,\n+            PathType(_inner) => Ty::Unknown, // TODO\n+            PointerType(_inner) => Ty::Unknown, // TODO\n+            ArrayType(_inner) => Ty::Unknown, // TODO\n+            SliceType(_inner) => Ty::Unknown, // TODO\n+            ReferenceType(_inner) => Ty::Unknown, // TODO\n+            PlaceholderType(_inner) => Ty::Unknown, // TODO\n+            FnPointerType(_inner) => Ty::Unknown, // TODO\n+            ForType(_inner) => Ty::Unknown, // TODO\n+            ImplTraitType(_inner) => Ty::Unknown, // TODO\n+            DynTraitType(_inner) => Ty::Unknown, // TODO\n+        }\n+    }\n+\n+    pub fn unit() -> Self {\n+        Ty::Tuple(Vec::new())\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct InferenceResult {\n+    type_for: FxHashMap<LocalSyntaxPtr, Ty>,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct InferenceContext {\n+    scopes: Arc<FnScopes>,\n+    // TODO unification tables...\n+    type_for: FxHashMap<LocalSyntaxPtr, Ty>,\n+}\n+\n+impl InferenceContext {\n+    fn new(scopes: Arc<FnScopes>) -> Self {\n+        InferenceContext {\n+            type_for: FxHashMap::default(),\n+            scopes\n+        }\n+    }\n+\n+    fn write_ty(&mut self, node: SyntaxNodeRef, ty: Ty) {\n+        self.type_for.insert(LocalSyntaxPtr::new(node), ty);\n+    }\n+\n+    fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n+        unimplemented!()\n+    }\n+\n+    fn infer_expr(&mut self, expr: ast::Expr) -> Ty {\n+        let ty = match expr {\n+            ast::Expr::IfExpr(e) => {\n+                if let Some(condition) = e.condition() {\n+                    if let Some(e) = condition.expr() {\n+                        // TODO if no pat, this should be bool\n+                        self.infer_expr(e);\n+                    }\n+                    // TODO write type for pat\n+                };\n+                let if_ty = if let Some(block) = e.then_branch() {\n+                    self.infer_block(block)\n+                } else {\n+                    Ty::Unknown\n+                };\n+                let else_ty = if let Some(block) = e.else_branch() {\n+                    self.infer_block(block)\n+                } else {\n+                    Ty::Unknown\n+                };\n+                if self.unify(&if_ty, &else_ty) {\n+                    // TODO actually, need to take the 'more specific' type (not unknown, never, ...)\n+                    if_ty\n+                } else {\n+                    // TODO report diagnostic\n+                    Ty::Unknown\n+                }\n+            }\n+            ast::Expr::BlockExpr(e) => {\n+                if let Some(block) = e.block() {\n+                    self.infer_block(block)\n+                } else {\n+                    Ty::Unknown\n+                }\n+            }\n+            ast::Expr::LoopExpr(e) => {\n+                if let Some(block) = e.loop_body() {\n+                    self.infer_block(block);\n+                };\n+                // TODO never, or the type of the break param\n+                Ty::Unknown\n+            }\n+            ast::Expr::WhileExpr(e) => {\n+                if let Some(condition) = e.condition() {\n+                    if let Some(e) = condition.expr() {\n+                        // TODO if no pat, this should be bool\n+                        self.infer_expr(e);\n+                    }\n+                    // TODO write type for pat\n+                };\n+                if let Some(block) = e.loop_body() {\n+                    // TODO\n+                    self.infer_block(block);\n+                };\n+                // TODO always unit?\n+                Ty::Unknown\n+            }\n+            ast::Expr::ForExpr(e) => {\n+                if let Some(expr) = e.iterable() {\n+                    self.infer_expr(expr);\n+                }\n+                if let Some(pat) = e.pat() {\n+                    // TODO write type for pat\n+                }\n+                if let Some(block) = e.loop_body() {\n+                    self.infer_block(block);\n+                }\n+                // TODO always unit?\n+                Ty::Unknown\n+            }\n+            ast::Expr::LambdaExpr(e) => {\n+                let body_ty = if let Some(body) = e.body() {\n+                    self.infer_expr(body)\n+                } else {\n+                    Ty::Unknown\n+                };\n+                Ty::Unknown\n+            }\n+            ast::Expr::CallExpr(e) => {\n+                if let Some(arg_list) = e.arg_list() {\n+                    for arg in arg_list.args() {\n+                        // TODO unify / expect argument type\n+                        self.infer_expr(arg);\n+                    }\n+                }\n+                Ty::Unknown\n+            }\n+            ast::Expr::MethodCallExpr(e) => {\n+                if let Some(arg_list) = e.arg_list() {\n+                    for arg in arg_list.args() {\n+                        // TODO unify / expect argument type\n+                        self.infer_expr(arg);\n+                    }\n+                }\n+                Ty::Unknown\n+            }\n+            ast::Expr::MatchExpr(e) => {\n+                let ty = if let Some(match_expr) = e.expr() {\n+                    self.infer_expr(match_expr)\n+                } else {\n+                    Ty::Unknown\n+                };\n+                if let Some(match_arm_list) = e.match_arm_list() {\n+                    for arm in match_arm_list.arms() {\n+                        // TODO type the bindings in pat\n+                        // TODO type the guard\n+                        let ty = if let Some(e) = arm.expr() {\n+                            self.infer_expr(e)\n+                        } else {\n+                            Ty::Unknown\n+                        };\n+                    }\n+                    // TODO unify all the match arm types\n+                    Ty::Unknown\n+                } else {\n+                    Ty::Unknown\n+                }\n+            }\n+            ast::Expr::TupleExpr(e) => {\n+                Ty::Unknown\n+            }\n+            ast::Expr::ArrayExpr(e) => {\n+                Ty::Unknown\n+            }\n+            ast::Expr::PathExpr(e) => {\n+                if let Some(p) = e.path() {\n+                    if p.qualifier().is_none() {\n+                        if let Some(name) = p.segment().and_then(|s| s.name_ref()) {\n+                            let s = self.scopes.resolve_local_name(name);\n+                            if let Some(scope_entry) = s {\n+                                if let Some(ty) = self.type_for.get(&scope_entry.ptr()) {\n+                                    ty.clone()\n+                                } else {\n+                                    // TODO introduce type variable?\n+                                    Ty::Unknown\n+                                }\n+                            } else {\n+                                Ty::Unknown\n+                            }\n+                        } else {\n+                            Ty::Unknown\n+                        }\n+                    } else {\n+                        // TODO resolve path\n+                        Ty::Unknown\n+                    }\n+                } else {\n+                    Ty::Unknown\n+                }\n+            }\n+            ast::Expr::ContinueExpr(e) => {\n+                Ty::Never\n+            }\n+            ast::Expr::BreakExpr(e) => {\n+                Ty::Never\n+            }\n+            ast::Expr::ParenExpr(e) => {\n+                if let Some(e) = e.expr() {\n+                    self.infer_expr(e)\n+                } else {\n+                    Ty::Unknown\n+                }\n+            }\n+            ast::Expr::Label(e) => {\n+                Ty::Unknown\n+            }\n+            ast::Expr::ReturnExpr(e) => {\n+                if let Some(e) = e.expr() {\n+                    // TODO unify with return type\n+                    self.infer_expr(e);\n+                };\n+                Ty::Never\n+            }\n+            ast::Expr::MatchArmList(_) | ast::Expr::MatchArm(_) | ast::Expr::MatchGuard(_) => {\n+                // Can this even occur outside of a match expression?\n+                Ty::Unknown\n+            }\n+            ast::Expr::StructLit(e) => {\n+                Ty::Unknown\n+            }\n+            ast::Expr::NamedFieldList(_) | ast::Expr::NamedField(_) => {\n+                // Can this even occur outside of a struct literal?\n+                Ty::Unknown\n+            }\n+            ast::Expr::IndexExpr(e) => {\n+                Ty::Unknown\n+            }\n+            ast::Expr::FieldExpr(e) => {\n+                Ty::Unknown\n+            }\n+            ast::Expr::TryExpr(e) => {\n+                let inner_ty = if let Some(e) = e.expr() {\n+                    self.infer_expr(e)\n+                } else {\n+                    Ty::Unknown\n+                };\n+                Ty::Unknown\n+            }\n+            ast::Expr::CastExpr(e) => {\n+                let inner_ty = if let Some(e) = e.expr() {\n+                    self.infer_expr(e)\n+                } else {\n+                    Ty::Unknown\n+                };\n+                let cast_ty = e.type_ref().map(Ty::new).unwrap_or(Ty::Unknown);\n+                // TODO do the coercion...\n+                cast_ty\n+            }\n+            ast::Expr::RefExpr(e) => {\n+                let inner_ty = if let Some(e) = e.expr() {\n+                    self.infer_expr(e)\n+                } else {\n+                    Ty::Unknown\n+                };\n+                Ty::Unknown\n+            }\n+            ast::Expr::PrefixExpr(e) => {\n+                let inner_ty = if let Some(e) = e.expr() {\n+                    self.infer_expr(e)\n+                } else {\n+                    Ty::Unknown\n+                };\n+                Ty::Unknown\n+            }\n+            ast::Expr::RangeExpr(e) => {\n+                Ty::Unknown\n+            }\n+            ast::Expr::BinExpr(e) => {\n+                Ty::Unknown\n+            }\n+            ast::Expr::Literal(e) => {\n+                Ty::Unknown\n+            }\n+        };\n+        self.write_ty(expr.syntax(), ty.clone());\n+        ty\n+    }\n+\n+    fn infer_block(&mut self, node: ast::Block) -> Ty {\n+        for stmt in node.statements() {\n+            match stmt {\n+                ast::Stmt::LetStmt(stmt) => {\n+                    if let Some(expr) = stmt.initializer() {\n+                        self.infer_expr(expr);\n+                    }\n+                }\n+                ast::Stmt::ExprStmt(expr_stmt) => {\n+                    if let Some(expr) = expr_stmt.expr() {\n+                        self.infer_expr(expr);\n+                    }\n+                }\n+            }\n+        }\n+        let ty = if let Some(expr) = node.expr() {\n+            self.infer_expr(expr)\n+        } else {\n+            Ty::unit()\n+        };\n+        self.write_ty(node.syntax(), ty.clone());\n+        ty\n+    }\n+}\n+\n+pub fn infer(db: &impl HirDatabase, node: ast::FnDef, scopes: Arc<FnScopes>) -> InferenceResult {\n+    let mut ctx = InferenceContext::new(scopes);\n+\n+    for param in node.param_list().unwrap().params() {\n+        let pat = param.pat().unwrap();\n+        let type_ref = param.type_ref().unwrap();\n+        let ty = Ty::new(type_ref);\n+        ctx.type_for.insert(LocalSyntaxPtr::new(pat.syntax()), ty);\n+    }\n+\n+    // TODO get Ty for node.ret_type() and pass that to infer_block as expectation\n+    // (see Expectation in rustc_typeck)\n+\n+    ctx.infer_block(node.body().unwrap());\n+\n+    // TODO 'resolve' the types: replace inference variables by their inferred results\n+\n+    InferenceResult { type_for: ctx.type_for }\n+}"}, {"sha": "4a5ce5a97ba9b7d036eaf7f3b9d82b45926f8ca5", "filename": "crates/ra_hir/src/ty/primitive.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/3ac605e6876056fa56098231cc2f96553faab8f0/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac605e6876056fa56098231cc2f96553faab8f0/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs?ref=3ac605e6876056fa56098231cc2f96553faab8f0", "patch": "@@ -0,0 +1,98 @@\n+use std::fmt;\n+\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Copy)]\n+pub enum IntTy {\n+    Isize,\n+    I8,\n+    I16,\n+    I32,\n+    I64,\n+    I128,\n+}\n+\n+impl fmt::Debug for IntTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::Display for IntTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.ty_to_string())\n+    }\n+}\n+\n+impl IntTy {\n+    pub fn ty_to_string(&self) -> &'static str {\n+        match *self {\n+            IntTy::Isize => \"isize\",\n+            IntTy::I8 => \"i8\",\n+            IntTy::I16 => \"i16\",\n+            IntTy::I32 => \"i32\",\n+            IntTy::I64 => \"i64\",\n+            IntTy::I128 => \"i128\",\n+        }\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Copy)]\n+pub enum UintTy {\n+    Usize,\n+    U8,\n+    U16,\n+    U32,\n+    U64,\n+    U128,\n+}\n+\n+impl UintTy {\n+    pub fn ty_to_string(&self) -> &'static str {\n+        match *self {\n+            UintTy::Usize => \"usize\",\n+            UintTy::U8 => \"u8\",\n+            UintTy::U16 => \"u16\",\n+            UintTy::U32 => \"u32\",\n+            UintTy::U64 => \"u64\",\n+            UintTy::U128 => \"u128\",\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for UintTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::Display for UintTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.ty_to_string())\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Hash, Copy, PartialOrd, Ord)]\n+pub enum FloatTy {\n+    F32,\n+    F64,\n+}\n+\n+impl fmt::Debug for FloatTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::Display for FloatTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.ty_to_string())\n+    }\n+}\n+\n+impl FloatTy {\n+    pub fn ty_to_string(self) -> &'static str {\n+        match self {\n+            FloatTy::F32 => \"f32\",\n+            FloatTy::F64 => \"f64\",\n+        }\n+    }\n+}"}, {"sha": "f2466dd517eb5dfb206e2a134f5036cb82ce55c4", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3ac605e6876056fa56098231cc2f96553faab8f0/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac605e6876056fa56098231cc2f96553faab8f0/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=3ac605e6876056fa56098231cc2f96553faab8f0", "patch": "@@ -0,0 +1,45 @@\n+use std::sync::Arc;\n+\n+use salsa::Database;\n+use ra_db::{FilesDatabase, CrateGraph, SyntaxDatabase};\n+use ra_syntax::{SmolStr, algo::visit::{visitor, Visitor}, ast::{self, AstNode}};\n+use relative_path::RelativePath;\n+\n+use crate::{source_binder, mock::WORKSPACE, module::ModuleSourceNode};\n+\n+use crate::{\n+    self as hir,\n+    db::HirDatabase,\n+    mock::MockDatabase,\n+};\n+\n+fn infer_all_fns(fixture: &str) -> () {\n+    let (db, source_root) = MockDatabase::with_files(fixture);\n+    for &file_id in source_root.files.values() {\n+        let source_file = db.source_file(file_id);\n+        for fn_def in source_file.syntax().descendants().filter_map(ast::FnDef::cast) {\n+            let func = source_binder::function_from_source(&db, file_id, fn_def).unwrap().unwrap();\n+            let inference_result = func.infer(&db);\n+            for (syntax_ptr, ty) in &inference_result.type_for {\n+                let node = syntax_ptr.resolve(&source_file);\n+                eprintln!(\"{} '{}': {:?}\", syntax_ptr.range(), node.text(), ty);\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn infer_smoke_test() {\n+    let text = \"\n+        //- /lib.rs\n+        fn foo(x: u32, y: !) -> i128 {\n+            x;\n+            y;\n+            return 1;\n+            \\\"hello\\\";\n+            0\n+        }\n+    \";\n+\n+    infer_all_fns(text);\n+}"}, {"sha": "91f27fb26ec9ddbdb59f777c9ef75379aa630b24", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3ac605e6876056fa56098231cc2f96553faab8f0/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac605e6876056fa56098231cc2f96553faab8f0/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=3ac605e6876056fa56098231cc2f96553faab8f0", "patch": "@@ -523,7 +523,15 @@ impl<R: TreeRoot<RaTypes>> CastExprNode<R> {\n }\n \n \n-impl<'a> CastExpr<'a> {}\n+impl<'a> CastExpr<'a> {\n+    pub fn expr(self) -> Option<Expr<'a>> {\n+        super::child_opt(self)\n+    }\n+\n+    pub fn type_ref(self) -> Option<TypeRef<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n \n // Char\n #[derive(Debug, Clone, Copy,)]\n@@ -2312,6 +2320,10 @@ impl<'a> Param<'a> {\n     pub fn pat(self) -> Option<Pat<'a>> {\n         super::child_opt(self)\n     }\n+\n+    pub fn type_ref(self) -> Option<TypeRef<'a>> {\n+        super::child_opt(self)\n+    }\n }\n \n // ParamList\n@@ -2394,7 +2406,11 @@ impl<R: TreeRoot<RaTypes>> ParenExprNode<R> {\n }\n \n \n-impl<'a> ParenExpr<'a> {}\n+impl<'a> ParenExpr<'a> {\n+    pub fn expr(self) -> Option<Expr<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n \n // ParenType\n #[derive(Debug, Clone, Copy,)]\n@@ -2829,7 +2845,11 @@ impl<R: TreeRoot<RaTypes>> PrefixExprNode<R> {\n }\n \n \n-impl<'a> PrefixExpr<'a> {}\n+impl<'a> PrefixExpr<'a> {\n+    pub fn expr(self) -> Option<Expr<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n \n // RangeExpr\n #[derive(Debug, Clone, Copy,)]\n@@ -2940,7 +2960,11 @@ impl<R: TreeRoot<RaTypes>> RefExprNode<R> {\n }\n \n \n-impl<'a> RefExpr<'a> {}\n+impl<'a> RefExpr<'a> {\n+    pub fn expr(self) -> Option<Expr<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n \n // RefPat\n #[derive(Debug, Clone, Copy,)]\n@@ -3088,7 +3112,11 @@ impl<R: TreeRoot<RaTypes>> ReturnExprNode<R> {\n }\n \n \n-impl<'a> ReturnExpr<'a> {}\n+impl<'a> ReturnExpr<'a> {\n+    pub fn expr(self) -> Option<Expr<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n \n // SelfParam\n #[derive(Debug, Clone, Copy,)]\n@@ -3578,7 +3606,11 @@ impl<R: TreeRoot<RaTypes>> TryExprNode<R> {\n }\n \n \n-impl<'a> TryExpr<'a> {}\n+impl<'a> TryExpr<'a> {\n+    pub fn expr(self) -> Option<Expr<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n \n // TupleExpr\n #[derive(Debug, Clone, Copy,)]"}, {"sha": "c43db51b6863e73b73a10dd40a9e39a96d9aaca7", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3ac605e6876056fa56098231cc2f96553faab8f0/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/3ac605e6876056fa56098231cc2f96553faab8f0/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=3ac605e6876056fa56098231cc2f96553faab8f0", "patch": "@@ -346,7 +346,7 @@ Grammar(\n \n         \"TupleExpr\": (),\n         \"ArrayExpr\": (),\n-        \"ParenExpr\": (),\n+        \"ParenExpr\": (options: [\"Expr\"]),\n         \"PathExpr\": (options: [\"Path\"]),\n         \"LambdaExpr\": (\n             options: [\n@@ -377,7 +377,7 @@ Grammar(\n         \"BlockExpr\": (\n             options: [ \"Block\" ]\n         ),\n-        \"ReturnExpr\": (),\n+        \"ReturnExpr\": (options: [\"Expr\"]),\n         \"MatchExpr\": (\n             options: [ \"Expr\", \"MatchArmList\" ],\n         ),\n@@ -405,10 +405,10 @@ Grammar(\n         ),\n         \"IndexExpr\": (),\n         \"FieldExpr\": (),\n-        \"TryExpr\": (),\n-        \"CastExpr\": (),\n-        \"RefExpr\": (),\n-        \"PrefixExpr\": (),\n+        \"TryExpr\": (options: [\"Expr\"]),\n+        \"CastExpr\": (options: [\"Expr\", \"TypeRef\"]),\n+        \"RefExpr\": (options: [\"Expr\"]),\n+        \"PrefixExpr\": (options: [\"Expr\"]),\n         \"RangeExpr\": (),\n         \"BinExpr\": (),\n         \"String\": (),\n@@ -521,7 +521,7 @@ Grammar(\n         ),\n         \"SelfParam\": (),\n         \"Param\": (\n-            options: [ \"Pat\" ],\n+            options: [ \"Pat\", \"TypeRef\" ],\n         ),\n         \"UseItem\": (\n             options: [ \"UseTree\" ]"}]}