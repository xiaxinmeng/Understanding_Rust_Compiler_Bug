{"sha": "8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "node_id": "C_kwDOAAsO6NoAKDhmYTVkNzRhN2NiMDFjZWFmMWEwN2FhNmZjYWY0MjEzN2Q4YmRhNTg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-04T02:53:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-04T02:53:40Z"}, "message": "Auto merge of #94588 - Dylan-DPC:rollup-7pxd0i3, r=Dylan-DPC\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #88805 (Clarification of default socket flags)\n - #93418 (rustdoc & doc: no `shortcut` for `rel=\"icon\"`)\n - #93913 (Remove the everybody loops pass)\n - #93965 (Make regular stdio lock() return 'static handles)\n - #94339 (ARM: Only allow using d16-d31 with asm! when supported by the target)\n - #94404 (Make Ord and PartialOrd opt-out in `newtype_index`)\n - #94466 (bootstrap: correct reading of flags for llvm)\n - #94572 (Use `HandleOrNull` and `HandleOrInvalid` in the Windows FFI bindings.)\n - #94575 (CTFE SwitchInt: update comment)\n - #94582 (Fix a bug in `x.py fmt` that prevents some files being formatted.)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "3392ba5314bbc3ef99a69a9f7a38a5d4d9f39ce6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3392ba5314bbc3ef99a69a9f7a38a5d4d9f39ce6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "html_url": "https://github.com/rust-lang/rust/commit/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d7684101a51f1c375ec84aef5d2fbdeb214bbc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2", "html_url": "https://github.com/rust-lang/rust/commit/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2"}, {"sha": "733a1a8ca42347a19c0d8a143fb090a9f0c2b810", "url": "https://api.github.com/repos/rust-lang/rust/commits/733a1a8ca42347a19c0d8a143fb090a9f0c2b810", "html_url": "https://github.com/rust-lang/rust/commit/733a1a8ca42347a19c0d8a143fb090a9f0c2b810"}], "stats": {"total": 804, "additions": 190, "deletions": 614}, "files": [{"sha": "df011d6ca5fab6e4989d63b3e19eb7c5190b6fca", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -39,6 +39,7 @@ const ARM_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     // #[target_feature].\n     (\"thumb-mode\", Some(sym::arm_target_feature)),\n     (\"thumb2\", Some(sym::arm_target_feature)),\n+    (\"d32\", Some(sym::arm_target_feature)),\n ];\n \n const AARCH64_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &["}, {"sha": "d2fbd6a9654f90d66c20ab41cd0d6e047b687acc", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -39,7 +39,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let mut target_block = targets.otherwise();\n \n                 for (const_int, target) in targets.iter() {\n-                    // Compare using binary_op, to also support pointer values\n+                    // Compare using MIR BinOp::Eq, to also support pointer values.\n+                    // (Avoiding `self.binary_op` as that does some redundant layout computation.)\n                     let res = self\n                         .overflowing_binary_op(\n                             mir::BinOp::Eq,"}, {"sha": "12bac956adb557048145a6513db63bee7bf32867", "filename": "compiler/rustc_driver/src/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -42,7 +42,7 @@ where\n     F: FnOnce(&dyn PrinterSupport) -> A,\n {\n     match *ppmode {\n-        Normal | EveryBodyLoops | Expanded => {\n+        Normal | Expanded => {\n             let annotation = NoAnn { sess, tcx };\n             f(&annotation)\n         }"}, {"sha": "35688a6591239794ab0a11ffb5cc5544015ff820", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -3,7 +3,6 @@ use crate::proc_macro_decls;\n use crate::util;\n \n use ast::CRATE_NODE_ID;\n-use rustc_ast::mut_visit::MutVisitor;\n use rustc_ast::{self as ast, visit};\n use rustc_borrowck as mir_borrowck;\n use rustc_codegen_ssa::back::link::emit_metadata;\n@@ -29,7 +28,7 @@ use rustc_plugin_impl as plugin;\n use rustc_query_impl::{OnDiskCache, Queries as TcxQueries};\n use rustc_resolve::{Resolver, ResolverArenas};\n use rustc_serialize::json;\n-use rustc_session::config::{CrateType, Input, OutputFilenames, OutputType, PpMode, PpSourceMode};\n+use rustc_session::config::{CrateType, Input, OutputFilenames, OutputType};\n use rustc_session::cstore::{MetadataLoader, MetadataLoaderDyn};\n use rustc_session::lint;\n use rustc_session::output::{filename_for_input, filename_for_metadata};\n@@ -384,11 +383,6 @@ pub fn configure_and_expand(\n         rustc_builtin_macros::test_harness::inject(sess, resolver, &mut krate)\n     });\n \n-    if let Some(PpMode::Source(PpSourceMode::EveryBodyLoops)) = sess.opts.pretty {\n-        tracing::debug!(\"replacing bodies with loop {{}}\");\n-        util::ReplaceBodyWithLoop::new(resolver).visit_crate(&mut krate);\n-    }\n-\n     let has_proc_macro_decls = sess.time(\"AST_validation\", || {\n         rustc_ast_passes::ast_validation::check_crate(sess, &krate, resolver.lint_buffer())\n     });\n@@ -457,18 +451,12 @@ pub fn configure_and_expand(\n     });\n \n     // Add all buffered lints from the `ParseSess` to the `Session`.\n-    // The ReplaceBodyWithLoop pass may have deleted some AST nodes, potentially\n-    // causing a delay_span_bug later if a buffered lint refers to such a deleted\n-    // AST node (issue #87308). Since everybody_loops is for pretty-printing only,\n-    // anyway, we simply skip all buffered lints here.\n-    if !matches!(sess.opts.pretty, Some(PpMode::Source(PpSourceMode::EveryBodyLoops))) {\n-        sess.parse_sess.buffered_lints.with_lock(|buffered_lints| {\n-            info!(\"{} parse sess buffered_lints\", buffered_lints.len());\n-            for early_lint in buffered_lints.drain(..) {\n-                resolver.lint_buffer().add_early_lint(early_lint);\n-            }\n-        });\n-    }\n+    sess.parse_sess.buffered_lints.with_lock(|buffered_lints| {\n+        info!(\"{} parse sess buffered_lints\", buffered_lints.len());\n+        for early_lint in buffered_lints.drain(..) {\n+            resolver.lint_buffer().add_early_lint(early_lint);\n+        }\n+    });\n \n     // Gate identifiers containing invalid Unicode codepoints that were recovered during lexing.\n     sess.parse_sess.bad_unicode_identifiers.with_lock(|identifiers| {"}, {"sha": "592cf60e6c3bb30b3bb1fa20d8cb4915dfb035c4", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 1, "deletions": 214, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -1,7 +1,5 @@\n use libloading::Library;\n-use rustc_ast::mut_visit::{visit_clobber, MutVisitor, *};\n-use rustc_ast::ptr::P;\n-use rustc_ast::{self as ast, AttrVec, BlockCheckMode, Term};\n+use rustc_ast as ast;\n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n #[cfg(parallel_compiler)]\n@@ -13,7 +11,6 @@ use rustc_middle::ty::tls;\n use rustc_parse::validate_attr;\n #[cfg(parallel_compiler)]\n use rustc_query_impl::QueryCtxt;\n-use rustc_resolve::{self, Resolver};\n use rustc_session as session;\n use rustc_session::config::CheckCfg;\n use rustc_session::config::{self, CrateType};\n@@ -25,12 +22,10 @@ use rustc_span::edition::Edition;\n use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::FileLoader;\n use rustc_span::symbol::{sym, Symbol};\n-use smallvec::SmallVec;\n use std::env;\n use std::env::consts::{DLL_PREFIX, DLL_SUFFIX};\n use std::lazy::SyncOnceCell;\n use std::mem;\n-use std::ops::DerefMut;\n #[cfg(not(parallel_compiler))]\n use std::panic;\n use std::path::{Path, PathBuf};\n@@ -664,214 +659,6 @@ pub fn non_durable_rename(src: &Path, dst: &Path) -> std::io::Result<()> {\n     std::fs::rename(src, dst)\n }\n \n-/// Replaces function bodies with `loop {}` (an infinite loop). This gets rid of\n-/// all semantic errors in the body while still satisfying the return type,\n-/// except in certain cases, see below for more.\n-///\n-/// This pass is known as `everybody_loops`. Very punny.\n-///\n-/// As of March 2021, `everybody_loops` is only used for the\n-/// `-Z unpretty=everybody_loops` debugging option.\n-///\n-/// FIXME: Currently the `everybody_loops` transformation is not applied to:\n-///  * `const fn`; support could be added, but hasn't. Originally `const fn`\n-///    was skipped due to issue #43636 that `loop` was not supported for\n-///    const evaluation.\n-///  * `impl Trait`, due to issue #43869 that functions returning impl Trait cannot be diverging.\n-///    Solving this may require `!` to implement every trait, which relies on the an even more\n-///    ambitious form of the closed RFC #1637. See also [#34511].\n-///\n-/// [#34511]: https://github.com/rust-lang/rust/issues/34511#issuecomment-322340401\n-pub struct ReplaceBodyWithLoop<'a, 'b> {\n-    within_static_or_const: bool,\n-    nested_blocks: Option<Vec<ast::Block>>,\n-    resolver: &'a mut Resolver<'b>,\n-}\n-\n-impl<'a, 'b> ReplaceBodyWithLoop<'a, 'b> {\n-    pub fn new(resolver: &'a mut Resolver<'b>) -> ReplaceBodyWithLoop<'a, 'b> {\n-        ReplaceBodyWithLoop { within_static_or_const: false, nested_blocks: None, resolver }\n-    }\n-\n-    fn run<R, F: FnOnce(&mut Self) -> R>(&mut self, is_const: bool, action: F) -> R {\n-        let old_const = mem::replace(&mut self.within_static_or_const, is_const);\n-        let old_blocks = self.nested_blocks.take();\n-        let ret = action(self);\n-        self.within_static_or_const = old_const;\n-        self.nested_blocks = old_blocks;\n-        ret\n-    }\n-\n-    fn should_ignore_fn(ret_ty: &ast::FnRetTy) -> bool {\n-        let ast::FnRetTy::Ty(ref ty) = ret_ty else {\n-            return false;\n-        };\n-        fn involves_impl_trait(ty: &ast::Ty) -> bool {\n-            match ty.kind {\n-                ast::TyKind::ImplTrait(..) => true,\n-                ast::TyKind::Slice(ref subty)\n-                | ast::TyKind::Array(ref subty, _)\n-                | ast::TyKind::Ptr(ast::MutTy { ty: ref subty, .. })\n-                | ast::TyKind::Rptr(_, ast::MutTy { ty: ref subty, .. })\n-                | ast::TyKind::Paren(ref subty) => involves_impl_trait(subty),\n-                ast::TyKind::Tup(ref tys) => any_involves_impl_trait(tys.iter()),\n-                ast::TyKind::Path(_, ref path) => {\n-                    path.segments.iter().any(|seg| match seg.args.as_deref() {\n-                        None => false,\n-                        Some(&ast::GenericArgs::AngleBracketed(ref data)) => {\n-                            data.args.iter().any(|arg| match arg {\n-                                ast::AngleBracketedArg::Arg(arg) => match arg {\n-                                    ast::GenericArg::Type(ty) => involves_impl_trait(ty),\n-                                    ast::GenericArg::Lifetime(_) | ast::GenericArg::Const(_) => {\n-                                        false\n-                                    }\n-                                },\n-                                ast::AngleBracketedArg::Constraint(c) => match c.kind {\n-                                    ast::AssocConstraintKind::Bound { .. } => true,\n-                                    ast::AssocConstraintKind::Equality { ref term } => {\n-                                        match term {\n-                                            Term::Ty(ty) => involves_impl_trait(ty),\n-                                            // FIXME(...): This should check if the constant\n-                                            // involves a trait impl, but for now ignore.\n-                                            Term::Const(_) => false,\n-                                        }\n-                                    }\n-                                },\n-                            })\n-                        }\n-                        Some(&ast::GenericArgs::Parenthesized(ref data)) => {\n-                            any_involves_impl_trait(data.inputs.iter())\n-                                || ReplaceBodyWithLoop::should_ignore_fn(&data.output)\n-                        }\n-                    })\n-                }\n-                _ => false,\n-            }\n-        }\n-\n-        fn any_involves_impl_trait<'a, I: Iterator<Item = &'a P<ast::Ty>>>(mut it: I) -> bool {\n-            it.any(|subty| involves_impl_trait(subty))\n-        }\n-\n-        involves_impl_trait(ty)\n-    }\n-\n-    fn is_sig_const(sig: &ast::FnSig) -> bool {\n-        matches!(sig.header.constness, ast::Const::Yes(_))\n-            || ReplaceBodyWithLoop::should_ignore_fn(&sig.decl.output)\n-    }\n-}\n-\n-impl<'a> MutVisitor for ReplaceBodyWithLoop<'a, '_> {\n-    fn visit_item_kind(&mut self, i: &mut ast::ItemKind) {\n-        let is_const = match i {\n-            ast::ItemKind::Static(..) | ast::ItemKind::Const(..) => true,\n-            ast::ItemKind::Fn(box ast::Fn { ref sig, .. }) => Self::is_sig_const(sig),\n-            _ => false,\n-        };\n-        self.run(is_const, |s| noop_visit_item_kind(i, s))\n-    }\n-\n-    fn flat_map_trait_item(&mut self, i: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n-        let is_const = match i.kind {\n-            ast::AssocItemKind::Const(..) => true,\n-            ast::AssocItemKind::Fn(box ast::Fn { ref sig, .. }) => Self::is_sig_const(sig),\n-            _ => false,\n-        };\n-        self.run(is_const, |s| noop_flat_map_assoc_item(i, s))\n-    }\n-\n-    fn flat_map_impl_item(&mut self, i: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n-        self.flat_map_trait_item(i)\n-    }\n-\n-    fn visit_anon_const(&mut self, c: &mut ast::AnonConst) {\n-        self.run(true, |s| noop_visit_anon_const(c, s))\n-    }\n-\n-    fn visit_block(&mut self, b: &mut P<ast::Block>) {\n-        fn stmt_to_block(\n-            rules: ast::BlockCheckMode,\n-            s: Option<ast::Stmt>,\n-            resolver: &mut Resolver<'_>,\n-        ) -> ast::Block {\n-            ast::Block {\n-                stmts: s.into_iter().collect(),\n-                rules,\n-                id: resolver.next_node_id(),\n-                span: rustc_span::DUMMY_SP,\n-                tokens: None,\n-                could_be_bare_literal: false,\n-            }\n-        }\n-\n-        fn block_to_stmt(b: ast::Block, resolver: &mut Resolver<'_>) -> ast::Stmt {\n-            let expr = P(ast::Expr {\n-                id: resolver.next_node_id(),\n-                kind: ast::ExprKind::Block(P(b), None),\n-                span: rustc_span::DUMMY_SP,\n-                attrs: AttrVec::new(),\n-                tokens: None,\n-            });\n-\n-            ast::Stmt {\n-                id: resolver.next_node_id(),\n-                kind: ast::StmtKind::Expr(expr),\n-                span: rustc_span::DUMMY_SP,\n-            }\n-        }\n-\n-        let empty_block = stmt_to_block(BlockCheckMode::Default, None, self.resolver);\n-        let loop_expr = P(ast::Expr {\n-            kind: ast::ExprKind::Loop(P(empty_block), None),\n-            id: self.resolver.next_node_id(),\n-            span: rustc_span::DUMMY_SP,\n-            attrs: AttrVec::new(),\n-            tokens: None,\n-        });\n-\n-        let loop_stmt = ast::Stmt {\n-            id: self.resolver.next_node_id(),\n-            span: rustc_span::DUMMY_SP,\n-            kind: ast::StmtKind::Expr(loop_expr),\n-        };\n-\n-        if self.within_static_or_const {\n-            noop_visit_block(b, self)\n-        } else {\n-            visit_clobber(b.deref_mut(), |b| {\n-                let mut stmts = vec![];\n-                for s in b.stmts {\n-                    let old_blocks = self.nested_blocks.replace(vec![]);\n-\n-                    stmts.extend(self.flat_map_stmt(s).into_iter().filter(|s| s.is_item()));\n-\n-                    // we put a Some in there earlier with that replace(), so this is valid\n-                    let new_blocks = self.nested_blocks.take().unwrap();\n-                    self.nested_blocks = old_blocks;\n-                    stmts.extend(new_blocks.into_iter().map(|b| block_to_stmt(b, self.resolver)));\n-                }\n-\n-                let mut new_block = ast::Block { stmts, ..b };\n-\n-                if let Some(old_blocks) = self.nested_blocks.as_mut() {\n-                    //push our fresh block onto the cache and yield an empty block with `loop {}`\n-                    if !new_block.stmts.is_empty() {\n-                        old_blocks.push(new_block);\n-                    }\n-\n-                    stmt_to_block(b.rules, Some(loop_stmt), &mut self.resolver)\n-                } else {\n-                    //push `loop {}` onto the end of our fresh block and yield that\n-                    new_block.stmts.push(loop_stmt);\n-\n-                    new_block\n-                }\n-            })\n-        }\n-    }\n-}\n-\n /// Returns a version string such as \"1.46.0 (04488afe3 2020-08-24)\"\n pub fn version_str() -> Option<&'static str> {\n     option_env!(\"CFG_VERSION\")"}, {"sha": "f5968a8a7ea73ce15c9b7f1ffb0c1a42c0b98019", "filename": "compiler/rustc_macros/src/newtype.rs", "status": "modified", "additions": 46, "deletions": 24, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/compiler%2Frustc_macros%2Fsrc%2Fnewtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/compiler%2Frustc_macros%2Fsrc%2Fnewtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fnewtype.rs?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -10,6 +10,7 @@ mod kw {\n     syn::custom_keyword!(MAX);\n     syn::custom_keyword!(ENCODABLE);\n     syn::custom_keyword!(custom);\n+    syn::custom_keyword!(ORD_IMPL);\n }\n \n #[derive(Debug)]\n@@ -42,6 +43,7 @@ impl Parse for Newtype {\n         let mut max = None;\n         let mut consts = Vec::new();\n         let mut encodable = true;\n+        let mut ord = true;\n \n         // Parse an optional trailing comma\n         let try_comma = || -> Result<()> {\n@@ -99,13 +101,20 @@ impl Parse for Newtype {\n                     encodable = false;\n                     continue;\n                 }\n+                if body.lookahead1().peek(kw::ORD_IMPL) {\n+                    body.parse::<kw::ORD_IMPL>()?;\n+                    body.parse::<Token![=]>()?;\n+                    body.parse::<kw::custom>()?;\n+                    ord = false;\n+                    continue;\n+                }\n \n                 // We've parsed everything that the user provided, so we're done\n                 if body.is_empty() {\n                     break;\n                 }\n \n-                // Otherwise, we are parsng a user-defined constant\n+                // Otherwise, we are parsing a user-defined constant\n                 let const_attrs = body.call(Attribute::parse_outer)?;\n                 body.parse::<Token![const]>()?;\n                 let const_name: Ident = body.parse()?;\n@@ -137,6 +146,40 @@ impl Parse for Newtype {\n             quote! {}\n         };\n \n+        if ord {\n+            derive_paths.push(parse_quote!(Ord));\n+            derive_paths.push(parse_quote!(PartialOrd));\n+        }\n+\n+        let step = if ord {\n+            quote! {\n+                impl ::std::iter::Step for #name {\n+                    #[inline]\n+                    fn steps_between(start: &Self, end: &Self) -> Option<usize> {\n+                        <usize as ::std::iter::Step>::steps_between(\n+                            &Self::index(*start),\n+                            &Self::index(*end),\n+                        )\n+                    }\n+\n+                    #[inline]\n+                    fn forward_checked(start: Self, u: usize) -> Option<Self> {\n+                        Self::index(start).checked_add(u).map(Self::from_usize)\n+                    }\n+\n+                    #[inline]\n+                    fn backward_checked(start: Self, u: usize) -> Option<Self> {\n+                        Self::index(start).checked_sub(u).map(Self::from_usize)\n+                    }\n+                }\n+\n+                // Safety: The implementation of `Step` upholds all invariants.\n+                unsafe impl ::std::iter::TrustedStep for #name {}\n+            }\n+        } else {\n+            quote! {}\n+        };\n+\n         let debug_impl = match debug_format {\n             DebugFormat::Custom => quote! {},\n             DebugFormat::Format(format) => {\n@@ -152,7 +195,7 @@ impl Parse for Newtype {\n \n         Ok(Self(quote! {\n             #(#attrs)*\n-            #[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord, #(#derive_paths),*)]\n+            #[derive(Clone, Copy, PartialEq, Eq, Hash, #(#derive_paths),*)]\n             #[rustc_layout_scalar_valid_range_end(#max)]\n             #vis struct #name {\n                 private: u32,\n@@ -247,28 +290,7 @@ impl Parse for Newtype {\n                 }\n             }\n \n-            impl ::std::iter::Step for #name {\n-                #[inline]\n-                fn steps_between(start: &Self, end: &Self) -> Option<usize> {\n-                    <usize as ::std::iter::Step>::steps_between(\n-                        &Self::index(*start),\n-                        &Self::index(*end),\n-                    )\n-                }\n-\n-                #[inline]\n-                fn forward_checked(start: Self, u: usize) -> Option<Self> {\n-                    Self::index(start).checked_add(u).map(Self::from_usize)\n-                }\n-\n-                #[inline]\n-                fn backward_checked(start: Self, u: usize) -> Option<Self> {\n-                    Self::index(start).checked_sub(u).map(Self::from_usize)\n-                }\n-            }\n-\n-            // Safety: The implementation of `Step` upholds all invariants.\n-            unsafe impl ::std::iter::TrustedStep for #name {}\n+            #step\n \n             impl From<#name> for u32 {\n                 #[inline]"}, {"sha": "d1cab6280153de0b13c421ea8fd11c06752dadf9", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -2509,7 +2509,6 @@ fn parse_pretty(debugging_opts: &DebuggingOptions, efmt: ErrorOutputType) -> Opt\n     let first = match debugging_opts.unpretty.as_deref()? {\n         \"normal\" => Source(PpSourceMode::Normal),\n         \"identified\" => Source(PpSourceMode::Identified),\n-        \"everybody_loops\" => Source(PpSourceMode::EveryBodyLoops),\n         \"expanded\" => Source(PpSourceMode::Expanded),\n         \"expanded,identified\" => Source(PpSourceMode::ExpandedIdentified),\n         \"expanded,hygiene\" => Source(PpSourceMode::ExpandedHygiene),\n@@ -2645,8 +2644,6 @@ impl fmt::Display for CrateType {\n pub enum PpSourceMode {\n     /// `-Zunpretty=normal`\n     Normal,\n-    /// `-Zunpretty=everybody_loops`\n-    EveryBodyLoops,\n     /// `-Zunpretty=expanded`\n     Expanded,\n     /// `-Zunpretty=identified`\n@@ -2678,7 +2675,7 @@ pub enum PpHirMode {\n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum PpMode {\n     /// Options that print the source code, i.e.\n-    /// `-Zunpretty=normal` and `-Zunpretty=everybody_loops`\n+    /// `-Zunpretty=normal` and `-Zunpretty=expanded`\n     Source(PpSourceMode),\n     AstTree(PpAstTreeMode),\n     /// Options that print the HIR, i.e. `-Zunpretty=hir`\n@@ -2700,7 +2697,7 @@ impl PpMode {\n         match *self {\n             Source(Normal | Identified) | AstTree(PpAstTreeMode::Normal) => false,\n \n-            Source(Expanded | EveryBodyLoops | ExpandedIdentified | ExpandedHygiene)\n+            Source(Expanded | ExpandedIdentified | ExpandedHygiene)\n             | AstTree(PpAstTreeMode::Expanded)\n             | Hir(_)\n             | HirTree"}, {"sha": "17eec333e0980694a871c525ee533e3a6ecf757c", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -1491,7 +1491,6 @@ options! {\n         `normal`, `identified`,\n         `expanded`, `expanded,identified`,\n         `expanded,hygiene` (with internal representations),\n-        `everybody_loops` (all function bodies replaced with `loop {}`),\n         `ast-tree` (raw AST before expansion),\n         `ast-tree,expanded` (raw AST after expansion),\n         `hir` (the HIR), `hir,identified`,"}, {"sha": "9d452131fa6ac5e5b4351b2585b33c8c8839fdc9", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -539,6 +539,7 @@ symbols! {\n         custom_inner_attributes,\n         custom_test_frameworks,\n         d,\n+        d32,\n         dbg_macro,\n         dead_code,\n         dealloc,"}, {"sha": "aaa632333db3808b993e4d714baa66425f771207", "filename": "compiler/rustc_target/src/asm/arm.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/compiler%2Frustc_target%2Fsrc%2Fasm%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/compiler%2Frustc_target%2Fsrc%2Fasm%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Farm.rs?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -50,9 +50,12 @@ impl ArmInlineAsmRegClass {\n         match self {\n             Self::reg => types! { _: I8, I16, I32, F32; },\n             Self::sreg | Self::sreg_low16 => types! { vfp2: I32, F32; },\n-            Self::dreg | Self::dreg_low16 | Self::dreg_low8 => types! {\n+            Self::dreg_low16 | Self::dreg_low8 => types! {\n                 vfp2: I64, F64, VecI8(8), VecI16(4), VecI32(2), VecI64(1), VecF32(2);\n             },\n+            Self::dreg => types! {\n+                d32: I64, F64, VecI8(8), VecI16(4), VecI32(2), VecI64(1), VecF32(2);\n+            },\n             Self::qreg | Self::qreg_low8 | Self::qreg_low4 => types! {\n                 neon: VecI8(16), VecI16(8), VecI32(4), VecI64(2), VecF32(4);\n             },"}, {"sha": "1826c3f5f7fa506ea806d7546b90b3c881b7b35f", "filename": "compiler/rustc_typeck/src/check_unused.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -82,8 +82,7 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n             // The `def_id` here actually was calculated during resolution (at least\n             // at the time of this writing) and is being shipped to us via a side\n             // channel of the tcx. There may have been extra expansion phases,\n-            // however, which ended up removing the `def_id` *after* expansion such\n-            // as the `ReplaceBodyWithLoop` pass (which is a bit of a hack, but hey)\n+            // however, which ended up removing the `def_id` *after* expansion.\n             //\n             // As a result we need to verify that `def_id` is indeed still valid for\n             // our AST and actually present in the HIR map. If it's not there then"}, {"sha": "3fa965d08e6981b629f39fa4e6a4fdba30287eb5", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -268,8 +268,6 @@ pub use self::buffered::WriterPanicked;\n pub use self::stdio::set_output_capture;\n #[unstable(feature = \"print_internals\", issue = \"none\")]\n pub use self::stdio::{_eprint, _print};\n-#[unstable(feature = \"stdio_locked\", issue = \"86845\")]\n-pub use self::stdio::{stderr_locked, stdin_locked, stdout_locked};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::{\n     buffered::{BufReader, BufWriter, IntoInnerError, LineWriter},"}, {"sha": "5414ff648d4d5f5051ccf64d5a71e0aa3b5ed239", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 15, "deletions": 223, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -307,48 +307,6 @@ pub fn stdin() -> Stdin {\n     }\n }\n \n-/// Constructs a new locked handle to the standard input of the current\n-/// process.\n-///\n-/// Each handle returned is a guard granting locked access to a shared\n-/// global buffer whose access is synchronized via a mutex. If you need\n-/// more explicit control over locking, for example, in a multi-threaded\n-/// program, use the [`io::stdin`] function to obtain an unlocked handle,\n-/// along with the [`Stdin::lock`] method.\n-///\n-/// The lock is released when the returned guard goes out of scope. The\n-/// returned guard also implements the [`Read`] and [`BufRead`] traits for\n-/// accessing the underlying data.\n-///\n-/// **Note**: The mutex locked by this handle is not reentrant. Even in a\n-/// single-threaded program, calling other code that accesses [`Stdin`]\n-/// could cause a deadlock or panic, if this locked handle is held across\n-/// that call.\n-///\n-/// ### Note: Windows Portability Consideration\n-/// When operating in a console, the Windows implementation of this stream does not support\n-/// non-UTF-8 byte sequences. Attempting to read bytes that are not valid UTF-8 will return\n-/// an error.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// #![feature(stdio_locked)]\n-/// use std::io::{self, BufRead};\n-///\n-/// fn main() -> io::Result<()> {\n-///     let mut buffer = String::new();\n-///     let mut handle = io::stdin_locked();\n-///\n-///     handle.read_line(&mut buffer)?;\n-///     Ok(())\n-/// }\n-/// ```\n-#[unstable(feature = \"stdio_locked\", issue = \"86845\")]\n-pub fn stdin_locked() -> StdinLock<'static> {\n-    stdin().into_locked()\n-}\n-\n impl Stdin {\n     /// Locks this handle to the standard input stream, returning a readable\n     /// guard.\n@@ -372,8 +330,10 @@ impl Stdin {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn lock(&self) -> StdinLock<'_> {\n-        self.lock_any()\n+    pub fn lock(&self) -> StdinLock<'static> {\n+        // Locks this handle with 'static lifetime. This depends on the\n+        // implementation detail that the underlying `Mutex` is static.\n+        StdinLock { inner: self.inner.lock().unwrap_or_else(|e| e.into_inner()) }\n     }\n \n     /// Locks this handle and reads a line of input, appending it to the specified buffer.\n@@ -407,43 +367,6 @@ impl Stdin {\n         self.lock().read_line(buf)\n     }\n \n-    // Locks this handle with any lifetime. This depends on the\n-    // implementation detail that the underlying `Mutex` is static.\n-    fn lock_any<'a>(&self) -> StdinLock<'a> {\n-        StdinLock { inner: self.inner.lock().unwrap_or_else(|e| e.into_inner()) }\n-    }\n-\n-    /// Consumes this handle to the standard input stream, locking the\n-    /// shared global buffer associated with the stream and returning a\n-    /// readable guard.\n-    ///\n-    /// The lock is released when the returned guard goes out of scope. The\n-    /// returned guard also implements the [`Read`] and [`BufRead`] traits\n-    /// for accessing the underlying data.\n-    ///\n-    /// It is often simpler to directly get a locked handle using the\n-    /// [`stdin_locked`] function instead, unless nearby code also needs to\n-    /// use an unlocked handle.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// #![feature(stdio_locked)]\n-    /// use std::io::{self, BufRead};\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let mut buffer = String::new();\n-    ///     let mut handle = io::stdin().into_locked();\n-    ///\n-    ///     handle.read_line(&mut buffer)?;\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"stdio_locked\", issue = \"86845\")]\n-    pub fn into_locked(self) -> StdinLock<'static> {\n-        self.lock_any()\n-    }\n-\n     /// Consumes this handle and returns an iterator over input lines.\n     ///\n     /// For detailed semantics of this method, see the documentation on\n@@ -463,7 +386,7 @@ impl Stdin {\n     #[must_use = \"`self` will be dropped if the result is not used\"]\n     #[unstable(feature = \"stdin_forwarders\", issue = \"87096\")]\n     pub fn lines(self) -> Lines<StdinLock<'static>> {\n-        self.into_locked().lines()\n+        self.lock().lines()\n     }\n }\n \n@@ -649,42 +572,6 @@ pub fn stdout() -> Stdout {\n     }\n }\n \n-/// Constructs a new locked handle to the standard output of the current\n-/// process.\n-///\n-/// Each handle returned is a guard granting locked access to a shared\n-/// global buffer whose access is synchronized via a mutex. If you need\n-/// more explicit control over locking, for example, in a multi-threaded\n-/// program, use the [`io::stdout`] function to obtain an unlocked handle,\n-/// along with the [`Stdout::lock`] method.\n-///\n-/// The lock is released when the returned guard goes out of scope. The\n-/// returned guard also implements the [`Write`] trait for writing data.\n-///\n-/// ### Note: Windows Portability Consideration\n-/// When operating in a console, the Windows implementation of this stream does not support\n-/// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n-/// an error.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// #![feature(stdio_locked)]\n-/// use std::io::{self, Write};\n-///\n-/// fn main() -> io::Result<()> {\n-///     let mut handle = io::stdout_locked();\n-///\n-///     handle.write_all(b\"hello world\")?;\n-///\n-///     Ok(())\n-/// }\n-/// ```\n-#[unstable(feature = \"stdio_locked\", issue = \"86845\")]\n-pub fn stdout_locked() -> StdoutLock<'static> {\n-    stdout().into_locked()\n-}\n-\n pub fn cleanup() {\n     if let Some(instance) = STDOUT.get() {\n         // Flush the data and disable buffering during shutdown\n@@ -712,55 +599,20 @@ impl Stdout {\n     /// use std::io::{self, Write};\n     ///\n     /// fn main() -> io::Result<()> {\n-    ///     let stdout = io::stdout();\n-    ///     let mut handle = stdout.lock();\n+    ///     let mut stdout = io::stdout().lock();\n     ///\n-    ///     handle.write_all(b\"hello world\")?;\n+    ///     stdout.write_all(b\"hello world\")?;\n     ///\n     ///     Ok(())\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn lock(&self) -> StdoutLock<'_> {\n-        self.lock_any()\n-    }\n-\n-    // Locks this handle with any lifetime. This depends on the\n-    // implementation detail that the underlying `ReentrantMutex` is\n-    // static.\n-    fn lock_any<'a>(&self) -> StdoutLock<'a> {\n+    pub fn lock(&self) -> StdoutLock<'static> {\n+        // Locks this handle with 'static lifetime. This depends on the\n+        // implementation detail that the underlying `ReentrantMutex` is\n+        // static.\n         StdoutLock { inner: self.inner.lock() }\n     }\n-\n-    /// Consumes this handle to the standard output stream, locking the\n-    /// shared global buffer associated with the stream and returning a\n-    /// writable guard.\n-    ///\n-    /// The lock is released when the returned lock goes out of scope. The\n-    /// returned guard also implements the [`Write`] trait for writing data.\n-    ///\n-    /// It is often simpler to directly get a locked handle using the\n-    /// [`io::stdout_locked`] function instead, unless nearby code also\n-    /// needs to use an unlocked handle.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// #![feature(stdio_locked)]\n-    /// use std::io::{self, Write};\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let mut handle = io::stdout().into_locked();\n-    ///\n-    ///     handle.write_all(b\"hello world\")?;\n-    ///\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"stdio_locked\", issue = \"86845\")]\n-    pub fn into_locked(self) -> StdoutLock<'static> {\n-        self.lock_any()\n-    }\n }\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n@@ -935,35 +787,6 @@ pub fn stderr() -> Stderr {\n     }\n }\n \n-/// Constructs a new locked handle to the standard error of the current\n-/// process.\n-///\n-/// This handle is not buffered.\n-///\n-/// ### Note: Windows Portability Consideration\n-/// When operating in a console, the Windows implementation of this stream does not support\n-/// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n-/// an error.\n-///\n-/// # Example\n-///\n-/// ```no_run\n-/// #![feature(stdio_locked)]\n-/// use std::io::{self, Write};\n-///\n-/// fn main() -> io::Result<()> {\n-///     let mut handle = io::stderr_locked();\n-///\n-///     handle.write_all(b\"hello world\")?;\n-///\n-///     Ok(())\n-/// }\n-/// ```\n-#[unstable(feature = \"stdio_locked\", issue = \"86845\")]\n-pub fn stderr_locked() -> StderrLock<'static> {\n-    stderr().into_locked()\n-}\n-\n impl Stderr {\n     /// Locks this handle to the standard error stream, returning a writable\n     /// guard.\n@@ -986,43 +809,12 @@ impl Stderr {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn lock(&self) -> StderrLock<'_> {\n-        self.lock_any()\n-    }\n-\n-    // Locks this handle with any lifetime. This depends on the\n-    // implementation detail that the underlying `ReentrantMutex` is\n-    // static.\n-    fn lock_any<'a>(&self) -> StderrLock<'a> {\n+    pub fn lock(&self) -> StderrLock<'static> {\n+        // Locks this handle with 'static lifetime. This depends on the\n+        // implementation detail that the underlying `ReentrantMutex` is\n+        // static.\n         StderrLock { inner: self.inner.lock() }\n     }\n-\n-    /// Locks and consumes this handle to the standard error stream,\n-    /// returning a writable guard.\n-    ///\n-    /// The lock is released when the returned guard goes out of scope. The\n-    /// returned guard also implements the [`Write`] trait for writing\n-    /// data.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(stdio_locked)]\n-    /// use std::io::{self, Write};\n-    ///\n-    /// fn foo() -> io::Result<()> {\n-    ///     let stderr = io::stderr();\n-    ///     let mut handle = stderr.into_locked();\n-    ///\n-    ///     handle.write_all(b\"hello world\")?;\n-    ///\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"stdio_locked\", issue = \"86845\")]\n-    pub fn into_locked(self) -> StderrLock<'static> {\n-        self.lock_any()\n-    }\n }\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]"}, {"sha": "f89fd27ce6c23b2ed6ae874b61daa2f6f81b7616", "filename": "library/std/src/io/stdio/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/library%2Fstd%2Fsrc%2Fio%2Fstdio%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/library%2Fstd%2Fsrc%2Fio%2Fstdio%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio%2Ftests.rs?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -50,17 +50,17 @@ fn panic_doesnt_poison() {\n #[test]\n #[cfg_attr(target_os = \"emscripten\", ignore)]\n fn test_lock_stderr() {\n-    test_lock(stderr, stderr_locked);\n+    test_lock(stderr, || stderr().lock());\n }\n #[test]\n #[cfg_attr(target_os = \"emscripten\", ignore)]\n fn test_lock_stdin() {\n-    test_lock(stdin, stdin_locked);\n+    test_lock(stdin, || stdin().lock());\n }\n #[test]\n #[cfg_attr(target_os = \"emscripten\", ignore)]\n fn test_lock_stdout() {\n-    test_lock(stdout, stdout_locked);\n+    test_lock(stdout, || stdout().lock());\n }\n \n // Helper trait to make lock testing function generic."}, {"sha": "9ed4a98f943cdb71f3a2a7131e52cb3e2ed71103", "filename": "library/std/src/net/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/library%2Fstd%2Fsrc%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/library%2Fstd%2Fsrc%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fmod.rs?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -14,6 +14,10 @@\n //! * [`ToSocketAddrs`] is a trait that used for generic address resolution when interacting\n //!   with networking objects like [`TcpListener`], [`TcpStream`] or [`UdpSocket`]\n //! * Other types are return or parameter types for various methods in this module\n+//!\n+//! Rust disables inheritance of socket objects to child processes by default when possible.  For\n+//! example, through the use of the `CLOEXEC` flag in UNIX systems or the `HANDLE_FLAG_INHERIT`\n+//! flag on Windows.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "14b94d8dcdf92e889d2921362eee551949229365", "filename": "library/std/src/os/windows/io/handle.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -59,6 +59,7 @@ pub struct BorrowedHandle<'handle> {\n /// [`RegCloseKey`]: https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regclosekey\n ///\n /// [here]: https://devblogs.microsoft.com/oldnewthing/20040302-00/?p=40443\n+#[repr(transparent)]\n #[unstable(feature = \"io_safety\", issue = \"87074\")]\n pub struct OwnedHandle {\n     handle: RawHandle,"}, {"sha": "9b61b2476d5bbdd55c811b00d9493b098215cb5b", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -6,6 +6,7 @@\n \n use crate::mem;\n use crate::os::raw::{c_char, c_int, c_long, c_longlong, c_uint, c_ulong, c_ushort};\n+use crate::os::windows::io::{BorrowedHandle, HandleOrInvalid, HandleOrNull};\n use crate::ptr;\n use core::ffi::NonZero_c_ulong;\n \n@@ -886,7 +887,7 @@ extern \"system\" {\n         lpParameter: LPVOID,\n         dwCreationFlags: DWORD,\n         lpThreadId: LPDWORD,\n-    ) -> HANDLE;\n+    ) -> HandleOrNull;\n     pub fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;\n     pub fn SwitchToThread() -> BOOL;\n     pub fn Sleep(dwMilliseconds: DWORD);\n@@ -950,14 +951,14 @@ extern \"system\" {\n         dwOptions: DWORD,\n     ) -> BOOL;\n     pub fn ReadFile(\n-        hFile: HANDLE,\n+        hFile: BorrowedHandle<'_>,\n         lpBuffer: LPVOID,\n         nNumberOfBytesToRead: DWORD,\n         lpNumberOfBytesRead: LPDWORD,\n         lpOverlapped: LPOVERLAPPED,\n     ) -> BOOL;\n     pub fn WriteFile(\n-        hFile: HANDLE,\n+        hFile: BorrowedHandle<'_>,\n         lpBuffer: LPVOID,\n         nNumberOfBytesToWrite: DWORD,\n         lpNumberOfBytesWritten: LPDWORD,\n@@ -981,7 +982,7 @@ extern \"system\" {\n         dwCreationDisposition: DWORD,\n         dwFlagsAndAttributes: DWORD,\n         hTemplateFile: HANDLE,\n-    ) -> HANDLE;\n+    ) -> HandleOrInvalid;\n \n     pub fn FindFirstFileW(fileName: LPCWSTR, findFileData: LPWIN32_FIND_DATAW) -> HANDLE;\n     pub fn FindNextFileW(findFile: HANDLE, findFileData: LPWIN32_FIND_DATAW) -> BOOL;"}, {"sha": "d6c40a15329a96a9091aa9c6936d1fed7e1ad79c", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -1,5 +1,6 @@\n use crate::os::windows::prelude::*;\n \n+use crate::convert::TryInto;\n use crate::ffi::OsString;\n use crate::fmt;\n use crate::io::{self, Error, IoSlice, IoSliceMut, ReadBuf, SeekFrom};\n@@ -294,10 +295,10 @@ impl File {\n                 ptr::null_mut(),\n             )\n         };\n-        if handle == c::INVALID_HANDLE_VALUE {\n-            Err(Error::last_os_error())\n+        if let Ok(handle) = handle.try_into() {\n+            Ok(File { handle: Handle::from_inner(handle) })\n         } else {\n-            unsafe { Ok(File { handle: Handle::from_raw_handle(handle) }) }\n+            Err(Error::last_os_error())\n         }\n     }\n "}, {"sha": "e5c9567957bc1db5c5e52c9eb0bd5fde8de807aa", "filename": "library/std/src/sys/windows/handle.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -78,7 +78,7 @@ impl Handle {\n         let len = cmp::min(buf.len(), <c::DWORD>::MAX as usize) as c::DWORD;\n         let res = cvt(unsafe {\n             c::ReadFile(\n-                self.as_raw_handle(),\n+                self.as_handle(),\n                 buf.as_mut_ptr() as c::LPVOID,\n                 len,\n                 &mut read,\n@@ -116,7 +116,7 @@ impl Handle {\n             overlapped.Offset = offset as u32;\n             overlapped.OffsetHigh = (offset >> 32) as u32;\n             cvt(c::ReadFile(\n-                self.as_raw_handle(),\n+                self.as_handle(),\n                 buf.as_mut_ptr() as c::LPVOID,\n                 len,\n                 &mut read,\n@@ -135,7 +135,7 @@ impl Handle {\n         let len = cmp::min(buf.remaining(), <c::DWORD>::MAX as usize) as c::DWORD;\n         let res = cvt(unsafe {\n             c::ReadFile(\n-                self.as_raw_handle(),\n+                self.as_handle(),\n                 buf.unfilled_mut().as_mut_ptr() as c::LPVOID,\n                 len,\n                 &mut read,\n@@ -171,7 +171,7 @@ impl Handle {\n         let len = cmp::min(buf.len(), <c::DWORD>::MAX as usize) as c::DWORD;\n         let mut amt = 0;\n         let res = cvt(c::ReadFile(\n-            self.as_raw_handle(),\n+            self.as_handle(),\n             buf.as_ptr() as c::LPVOID,\n             len,\n             &mut amt,\n@@ -225,7 +225,7 @@ impl Handle {\n         let len = cmp::min(buf.len(), <c::DWORD>::MAX as usize) as c::DWORD;\n         cvt(unsafe {\n             c::WriteFile(\n-                self.as_raw_handle(),\n+                self.as_handle(),\n                 buf.as_ptr() as c::LPVOID,\n                 len,\n                 &mut amt,\n@@ -252,7 +252,7 @@ impl Handle {\n             overlapped.Offset = offset as u32;\n             overlapped.OffsetHigh = (offset >> 32) as u32;\n             cvt(c::WriteFile(\n-                self.as_raw_handle(),\n+                self.as_handle(),\n                 buf.as_ptr() as c::LPVOID,\n                 len,\n                 &mut written,"}, {"sha": "bd304dc57371dda02bfc4250f71f279e5f7ad318", "filename": "library/std/src/sys/windows/thread.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread.rs?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -1,11 +1,13 @@\n+use crate::convert::TryInto;\n use crate::ffi::CStr;\n use crate::io;\n use crate::num::NonZeroUsize;\n-use crate::os::windows::io::{AsRawHandle, FromRawHandle};\n+use crate::os::windows::io::AsRawHandle;\n use crate::ptr;\n use crate::sys::c;\n use crate::sys::handle::Handle;\n use crate::sys::stack_overflow;\n+use crate::sys_common::FromInner;\n use crate::time::Duration;\n \n use libc::c_void;\n@@ -40,13 +42,13 @@ impl Thread {\n             ptr::null_mut(),\n         );\n \n-        return if ret as usize == 0 {\n+        return if let Ok(handle) = ret.try_into() {\n+            Ok(Thread { handle: Handle::from_inner(handle) })\n+        } else {\n             // The thread failed to start and as a result p was not consumed. Therefore, it is\n             // safe to reconstruct the box so that it gets deallocated.\n             drop(Box::from_raw(p));\n             Err(io::Error::last_os_error())\n-        } else {\n-            Ok(Thread { handle: Handle::from_raw_handle(ret) })\n         };\n \n         extern \"system\" fn thread_start(main: *mut c_void) -> c::DWORD {"}, {"sha": "0d387ff1e37c20f2e111b482a6da6b6c8e1ad33d", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -26,7 +26,7 @@ use crate::run;\n use crate::test;\n use crate::tool::{self, SourceType};\n use crate::util::{self, add_dylib_path, add_link_lib_path, exe, libdir};\n-use crate::{Build, DocTests, GitRepo, Mode};\n+use crate::{Build, CLang, DocTests, GitRepo, Mode};\n \n pub use crate::Compiler;\n // FIXME: replace with std::lazy after it gets stabilized and reaches beta\n@@ -1511,7 +1511,7 @@ impl<'a> Builder<'a> {\n             let cc = ccacheify(&self.cc(target));\n             cargo.env(format!(\"CC_{}\", target.triple), &cc);\n \n-            let cflags = self.cflags(target, GitRepo::Rustc).join(\" \");\n+            let cflags = self.cflags(target, GitRepo::Rustc, CLang::C).join(\" \");\n             cargo.env(format!(\"CFLAGS_{}\", target.triple), &cflags);\n \n             if let Some(ar) = self.ar(target) {\n@@ -1523,9 +1523,10 @@ impl<'a> Builder<'a> {\n \n             if let Ok(cxx) = self.cxx(target) {\n                 let cxx = ccacheify(&cxx);\n+                let cxxflags = self.cflags(target, GitRepo::Rustc, CLang::Cxx).join(\" \");\n                 cargo\n                     .env(format!(\"CXX_{}\", target.triple), &cxx)\n-                    .env(format!(\"CXXFLAGS_{}\", target.triple), cflags);\n+                    .env(format!(\"CXXFLAGS_{}\", target.triple), cxxflags);\n             }\n         }\n "}, {"sha": "8c47f625d732bc3868c5018828d9371f0626435f", "filename": "src/bootstrap/cc_detect.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/src%2Fbootstrap%2Fcc_detect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/src%2Fbootstrap%2Fcc_detect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc_detect.rs?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -29,7 +29,7 @@ use std::{env, iter};\n use build_helper::output;\n \n use crate::config::{Target, TargetSelection};\n-use crate::{Build, GitRepo};\n+use crate::{Build, CLang, GitRepo};\n \n // The `cc` crate doesn't provide a way to obtain a path to the detected archiver,\n // so use some simplified logic here. First we respect the environment variable `AR`, then\n@@ -109,7 +109,7 @@ pub fn find(build: &mut Build) {\n         };\n \n         build.cc.insert(target, compiler.clone());\n-        let cflags = build.cflags(target, GitRepo::Rustc);\n+        let cflags = build.cflags(target, GitRepo::Rustc, CLang::C);\n \n         // If we use llvm-libunwind, we will need a C++ compiler as well for all targets\n         // We'll need one anyways if the target triple is also a host triple\n@@ -142,8 +142,9 @@ pub fn find(build: &mut Build) {\n         build.verbose(&format!(\"CC_{} = {:?}\", &target.triple, build.cc(target)));\n         build.verbose(&format!(\"CFLAGS_{} = {:?}\", &target.triple, cflags));\n         if let Ok(cxx) = build.cxx(target) {\n+            let cxxflags = build.cflags(target, GitRepo::Rustc, CLang::Cxx);\n             build.verbose(&format!(\"CXX_{} = {:?}\", &target.triple, cxx));\n-            build.verbose(&format!(\"CXXFLAGS_{} = {:?}\", &target.triple, cflags));\n+            build.verbose(&format!(\"CXXFLAGS_{} = {:?}\", &target.triple, cxxflags));\n         }\n         if let Some(ar) = ar {\n             build.verbose(&format!(\"AR_{} = {:?}\", &target.triple, ar));"}, {"sha": "99717780346014a60d086e8ef4f95a77aed66e82", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -28,7 +28,7 @@ use crate::native;\n use crate::tool::SourceType;\n use crate::util::{exe, is_debug_info, is_dylib, symlink_dir};\n use crate::LLVM_TOOLS;\n-use crate::{Compiler, DependencyType, GitRepo, Mode};\n+use crate::{CLang, Compiler, DependencyType, GitRepo, Mode};\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Std {\n@@ -249,7 +249,7 @@ fn copy_self_contained_objects(\n         }\n     } else if target.contains(\"windows-gnu\") {\n         for obj in [\"crt2.o\", \"dllcrt2.o\"].iter() {\n-            let src = compiler_file(builder, builder.cc(target), target, obj);\n+            let src = compiler_file(builder, builder.cc(target), target, CLang::C, obj);\n             let target = libdir_self_contained.join(obj);\n             builder.copy(&src, &target);\n             target_deps.push((target, DependencyType::TargetSelfContained));\n@@ -727,7 +727,13 @@ pub fn rustc_cargo_env(builder: &Builder<'_>, cargo: &mut Cargo, target: TargetS\n             && !target.contains(\"msvc\")\n             && !target.contains(\"apple\")\n         {\n-            let file = compiler_file(builder, builder.cxx(target).unwrap(), target, \"libstdc++.a\");\n+            let file = compiler_file(\n+                builder,\n+                builder.cxx(target).unwrap(),\n+                target,\n+                CLang::Cxx,\n+                \"libstdc++.a\",\n+            );\n             cargo.env(\"LLVM_STATIC_STDCPP\", file);\n         }\n         if builder.config.llvm_link_shared {\n@@ -948,10 +954,11 @@ pub fn compiler_file(\n     builder: &Builder<'_>,\n     compiler: &Path,\n     target: TargetSelection,\n+    c: CLang,\n     file: &str,\n ) -> PathBuf {\n     let mut cmd = Command::new(compiler);\n-    cmd.args(builder.cflags(target, GitRepo::Rustc));\n+    cmd.args(builder.cflags(target, GitRepo::Rustc, c));\n     cmd.arg(format!(\"-print-file-name={}\", file));\n     let out = output(&mut cmd);\n     PathBuf::from(out.trim())"}, {"sha": "530cc829320d165ba1b4eb03d0e91b55225e5110", "filename": "src/bootstrap/format.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/src%2Fbootstrap%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/src%2Fbootstrap%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fformat.rs?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -97,7 +97,12 @@ pub fn format(build: &Build, check: bool, paths: &[PathBuf]) {\n                 });\n             for untracked_path in untracked_paths {\n                 eprintln!(\"skip untracked path {} during rustfmt invocations\", untracked_path);\n-                ignore_fmt.add(&format!(\"!{}\", untracked_path)).expect(&untracked_path);\n+                // The leading `/` makes it an exact match against the\n+                // repository root, rather than a glob. Without that, if you\n+                // have `foo.rs` in the repository root it will also match\n+                // against anything like `compiler/rustc_foo/src/foo.rs`,\n+                // preventing the latter from being formatted.\n+                ignore_fmt.add(&format!(\"!/{}\", untracked_path)).expect(&untracked_path);\n             }\n         } else {\n             eprintln!(\"Not in git tree. Skipping git-aware format checks\");"}, {"sha": "abfac2a5897939499ab2ce8ef92024e4a26d3cce", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -339,6 +339,11 @@ impl Mode {\n     }\n }\n \n+pub enum CLang {\n+    C,\n+    Cxx,\n+}\n+\n impl Build {\n     /// Creates a new set of build configuration from the `flags` on the command\n     /// line and the filesystem `config`.\n@@ -941,10 +946,15 @@ impl Build {\n \n     /// Returns a list of flags to pass to the C compiler for the target\n     /// specified.\n-    fn cflags(&self, target: TargetSelection, which: GitRepo) -> Vec<String> {\n+    fn cflags(&self, target: TargetSelection, which: GitRepo, c: CLang) -> Vec<String> {\n+        let base = match c {\n+            CLang::C => &self.cc[&target],\n+            CLang::Cxx => &self.cxx[&target],\n+        };\n+\n         // Filter out -O and /O (the optimization flags) that we picked up from\n         // cc-rs because the build scripts will determine that for themselves.\n-        let mut base = self.cc[&target]\n+        let mut base = base\n             .args()\n             .iter()\n             .map(|s| s.to_string_lossy().into_owned())"}, {"sha": "a751a6e3ece7f918ab2df0860c190daca1c5f915", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -21,7 +21,7 @@ use build_helper::{output, t};\n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n use crate::config::TargetSelection;\n use crate::util::{self, exe};\n-use crate::GitRepo;\n+use crate::{CLang, GitRepo};\n use build_helper::up_to_date;\n \n pub struct Meta {\n@@ -529,7 +529,7 @@ fn configure_cmake(\n     }\n \n     cfg.build_arg(\"-j\").build_arg(builder.jobs().to_string());\n-    let mut cflags: OsString = builder.cflags(target, GitRepo::Llvm).join(\" \").into();\n+    let mut cflags: OsString = builder.cflags(target, GitRepo::Llvm, CLang::C).join(\" \").into();\n     if let Some(ref s) = builder.config.llvm_cflags {\n         cflags.push(\" \");\n         cflags.push(s);\n@@ -545,23 +545,15 @@ fn configure_cmake(\n     if builder.config.llvm_clang_cl.is_some() {\n         cflags.push(&format!(\" --target={}\", target));\n     }\n-    if let Some(flags) = env::var_os(\"CFLAGS\") {\n-        cflags.push(\" \");\n-        cflags.push(flags);\n-    }\n     cfg.define(\"CMAKE_C_FLAGS\", cflags);\n-    let mut cxxflags: OsString = builder.cflags(target, GitRepo::Llvm).join(\" \").into();\n+    let mut cxxflags: OsString = builder.cflags(target, GitRepo::Llvm, CLang::Cxx).join(\" \").into();\n     if let Some(ref s) = builder.config.llvm_cxxflags {\n         cxxflags.push(\" \");\n         cxxflags.push(s);\n     }\n     if builder.config.llvm_clang_cl.is_some() {\n         cxxflags.push(&format!(\" --target={}\", target));\n     }\n-    if let Some(flags) = env::var_os(\"CXXFLAGS\") {\n-        cxxflags.push(\" \");\n-        cxxflags.push(flags);\n-    }\n     cfg.define(\"CMAKE_CXX_FLAGS\", cxxflags);\n     if let Some(ar) = builder.ar(target) {\n         if ar.is_absolute() {\n@@ -583,7 +575,7 @@ fn configure_cmake(\n         ldflags.push_all(flags);\n     }\n \n-    if let Some(flags) = env::var_os(\"LDFLAGS\") {\n+    if let Some(flags) = get_var(\"LDFLAGS\", &builder.config.build.triple, &target.triple) {\n         ldflags.push_all(&flags);\n     }\n \n@@ -596,6 +588,16 @@ fn configure_cmake(\n     }\n }\n \n+// Adapted from https://github.com/alexcrichton/cc-rs/blob/fba7feded71ee4f63cfe885673ead6d7b4f2f454/src/lib.rs#L2347-L2365\n+fn get_var(var_base: &str, host: &str, target: &str) -> Option<OsString> {\n+    let kind = if host == target { \"HOST\" } else { \"TARGET\" };\n+    let target_u = target.replace(\"-\", \"_\");\n+    env::var_os(&format!(\"{}_{}\", var_base, target))\n+        .or_else(|| env::var_os(&format!(\"{}_{}\", var_base, target_u)))\n+        .or_else(|| env::var_os(&format!(\"{}_{}\", kind, var_base)))\n+        .or_else(|| env::var_os(var_base))\n+}\n+\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Lld {\n     pub target: TargetSelection,"}, {"sha": "19d98df3ce9023a2fb91b1d326b3f4d3c5a6d3cc", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -24,7 +24,7 @@ use crate::tool::{self, SourceType, Tool};\n use crate::toolstate::ToolState;\n use crate::util::{self, add_link_lib_path, dylib_path, dylib_path_var};\n use crate::Crate as CargoCrate;\n-use crate::{envify, DocTests, GitRepo, Mode};\n+use crate::{envify, CLang, DocTests, GitRepo, Mode};\n \n const ADB_TEST_DIR: &str = \"/data/tmp/work\";\n \n@@ -1509,7 +1509,9 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n                 .arg(\"--cxx\")\n                 .arg(builder.cxx(target).unwrap())\n                 .arg(\"--cflags\")\n-                .arg(builder.cflags(target, GitRepo::Rustc).join(\" \"));\n+                .arg(builder.cflags(target, GitRepo::Rustc, CLang::C).join(\" \"))\n+                .arg(\"--cxxflags\")\n+                .arg(builder.cflags(target, GitRepo::Rustc, CLang::Cxx).join(\" \"));\n             copts_passed = true;\n             if let Some(ar) = builder.ar(target) {\n                 cmd.arg(\"--ar\").arg(ar);\n@@ -1520,7 +1522,14 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n             cmd.arg(\"--llvm-components\").arg(\"\");\n         }\n         if !copts_passed {\n-            cmd.arg(\"--cc\").arg(\"\").arg(\"--cxx\").arg(\"\").arg(\"--cflags\").arg(\"\");\n+            cmd.arg(\"--cc\")\n+                .arg(\"\")\n+                .arg(\"--cxx\")\n+                .arg(\"\")\n+                .arg(\"--cflags\")\n+                .arg(\"\")\n+                .arg(\"--cxxflags\")\n+                .arg(\"\");\n         }\n \n         if builder.remote_tested(target) {"}, {"sha": "9c330685209beb2faa0a31a517ddabe901c3ca78", "filename": "src/doc/favicon.inc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/src%2Fdoc%2Ffavicon.inc", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/src%2Fdoc%2Ffavicon.inc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ffavicon.inc?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -1 +1 @@\n-<link rel=\"shortcut icon\" href=\"https://www.rust-lang.org/favicon.ico\">\n+<link rel=\"icon\" href=\"https://www.rust-lang.org/favicon.ico\">"}, {"sha": "2fb44be014515b28bbaf8b8b38af7c299902b1aa", "filename": "src/doc/redirect.inc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/src%2Fdoc%2Fredirect.inc", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/src%2Fdoc%2Fredirect.inc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fredirect.inc?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -1,2 +1,2 @@\n <meta name=\"robots\" content=\"noindex,follow\">\n-<link rel=\"shortcut icon\" href=\"https://www.rust-lang.org/favicon.ico\">\n+<link rel=\"icon\" href=\"https://www.rust-lang.org/favicon.ico\">"}, {"sha": "c5cc84022e389db657b14b5cfea0e0ad63796a59", "filename": "src/doc/rustdoc/src/the-doc-attribute.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/src%2Fdoc%2Frustdoc%2Fsrc%2Fthe-doc-attribute.md", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/src%2Fdoc%2Frustdoc%2Fsrc%2Fthe-doc-attribute.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fthe-doc-attribute.md?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -59,7 +59,7 @@ This form of the `doc` attribute lets you control the favicon of your docs.\n #![doc(html_favicon_url = \"https://example.com/favicon.ico\")]\n ```\n \n-This will put `<link rel=\"shortcut icon\" href=\"{}\">` into your docs, where\n+This will put `<link rel=\"icon\" href=\"{}\">` into your docs, where\n the string for the attribute goes into the `{}`.\n \n If you don't use this attribute, there will be no favicon."}, {"sha": "564731ab7354b1ad7ea7e25b5d130f2b485582da", "filename": "src/librustdoc/html/templates/page.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fpage.html", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fpage.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fpage.html?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -54,7 +54,7 @@\n             href=\"{{static_root_path|safe}}theme{{page.resource_suffix}}.css\"> {#- -#}\n     {%- endif -%}\n     {%- if !layout.favicon.is_empty() -%}\n-        <link rel=\"shortcut icon\" href=\"{{layout.favicon}}\"> {#- -#}\n+        <link rel=\"icon\" href=\"{{layout.favicon}}\"> {#- -#}\n     {%- else -%}\n         <link rel=\"alternate icon\" type=\"image/png\" {# -#}\n             href=\"{{static_root_path|safe}}favicon-16x16{{page.resource_suffix}}.png\"> {#- -#}"}, {"sha": "48fbb2a0139f050abd67bea238904063c00e3eae", "filename": "src/test/ui/lint/issue-87308.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Ftest%2Fui%2Flint%2Fissue-87308.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Ftest%2Fui%2Flint%2Fissue-87308.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-87308.rs?ref=6d7684101a51f1c375ec84aef5d2fbdeb214bbc2", "patch": "@@ -1,12 +0,0 @@\n-// Regression test for issue #87308.\n-\n-// compile-flags: -Zunpretty=everybody_loops\n-// check-pass\n-\n-macro_rules! foo {\n-    () => { break 'x; }\n-}\n-\n-pub fn main() {\n-    'x: loop { foo!() }\n-}"}, {"sha": "4f81ee8b7e6bb59422b2849ace99552762492020", "filename": "src/test/ui/lint/issue-87308.stdout", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Ftest%2Fui%2Flint%2Fissue-87308.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Ftest%2Fui%2Flint%2Fissue-87308.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-87308.stdout?ref=6d7684101a51f1c375ec84aef5d2fbdeb214bbc2", "patch": "@@ -1,14 +0,0 @@\n-#![feature(prelude_import)]\n-#![no_std]\n-#[prelude_import]\n-use ::std::prelude::rust_2015::*;\n-#[macro_use]\n-extern crate std;\n-// Regression test for issue #87308.\n-\n-// compile-flags: -Zunpretty=everybody_loops\n-// check-pass\n-\n-macro_rules! foo { () => { break 'x ; } }\n-\n-pub fn main() { loop {} }"}, {"sha": "6b7e831ed2f7a47c54e83713ddfbb2194e094d21", "filename": "src/test/ui/repr/issue-83921-pretty.normal.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Ftest%2Fui%2Frepr%2Fissue-83921-pretty.normal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Ftest%2Fui%2Frepr%2Fissue-83921-pretty.normal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frepr%2Fissue-83921-pretty.normal.stderr?ref=6d7684101a51f1c375ec84aef5d2fbdeb214bbc2", "patch": "@@ -1,9 +0,0 @@\n-error[E0565]: meta item in `repr` must be an identifier\n-  --> $DIR/issue-83921-pretty.rs:10:8\n-   |\n-LL | #[repr(\"C\")]\n-   |        ^^^\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0565`."}, {"sha": "aaf3993538acf1c7fecd52ab8d6ba76c76a0e79e", "filename": "src/test/ui/repr/issue-83921-pretty.pretty.stdout", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Ftest%2Fui%2Frepr%2Fissue-83921-pretty.pretty.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Ftest%2Fui%2Frepr%2Fissue-83921-pretty.pretty.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frepr%2Fissue-83921-pretty.pretty.stdout?ref=6d7684101a51f1c375ec84aef5d2fbdeb214bbc2", "patch": "@@ -1,18 +0,0 @@\n-#![feature(prelude_import)]\n-#![no_std]\n-#[prelude_import]\n-use ::std::prelude::rust_2015::*;\n-#[macro_use]\n-extern crate std;\n-// Regression test for #83921. A `delay_span_bug()` call was issued, but the\n-// error was never reported because the pass responsible for detecting and\n-// reporting the error does not run in certain modes of pretty-printing.\n-\n-// Make sure the error is reported if we do not just pretty-print:\n-// revisions: pretty normal\n-// [pretty]compile-flags: -Zunpretty=everybody_loops\n-// [pretty]check-pass\n-#[repr(\"C\")]\n-struct A {}\n-\n-fn main() { loop {} }"}, {"sha": "d5d36470f11acf62ffab868ecc4904df556fde62", "filename": "src/test/ui/repr/issue-83921-pretty.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Ftest%2Fui%2Frepr%2Fissue-83921-pretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d7684101a51f1c375ec84aef5d2fbdeb214bbc2/src%2Ftest%2Fui%2Frepr%2Fissue-83921-pretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frepr%2Fissue-83921-pretty.rs?ref=6d7684101a51f1c375ec84aef5d2fbdeb214bbc2", "patch": "@@ -1,14 +0,0 @@\n-// Regression test for #83921. A `delay_span_bug()` call was issued, but the\n-// error was never reported because the pass responsible for detecting and\n-// reporting the error does not run in certain modes of pretty-printing.\n-\n-// Make sure the error is reported if we do not just pretty-print:\n-// revisions: pretty normal\n-// [pretty]compile-flags: -Zunpretty=everybody_loops\n-// [pretty]check-pass\n-\n-#[repr(\"C\")]\n-//[normal]~^ ERROR: meta item in `repr` must be an identifier [E0565]\n-struct A {}\n-\n-fn main() {}"}, {"sha": "1bf6e6d011e5c125a2be7e7f64c5c3c54cbc15e5", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -357,6 +357,7 @@ pub struct Config {\n     pub cc: String,\n     pub cxx: String,\n     pub cflags: String,\n+    pub cxxflags: String,\n     pub ar: String,\n     pub linker: Option<String>,\n     pub llvm_components: String,"}, {"sha": "5b144a1020f4c3e0f9baeb51299b3875c8e0a0af", "filename": "src/tools/compiletest/src/header/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Ftests.rs?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -52,6 +52,7 @@ fn config() -> Config {\n         \"--cc=c\",\n         \"--cxx=c++\",\n         \"--cflags=\",\n+        \"--cxxflags=\",\n         \"--llvm-components=\",\n         \"--android-cross-path=\",\n         \"--target=x86_64-unknown-linux-gnu\","}, {"sha": "3f2cd3ae232ba5822452816d8dd8524fecea1e00", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -126,6 +126,7 @@ pub fn parse_config(args: Vec<String>) -> Config {\n         .reqopt(\"\", \"cc\", \"path to a C compiler\", \"PATH\")\n         .reqopt(\"\", \"cxx\", \"path to a C++ compiler\", \"PATH\")\n         .reqopt(\"\", \"cflags\", \"flags for the C compiler\", \"FLAGS\")\n+        .reqopt(\"\", \"cxxflags\", \"flags for the CXX compiler\", \"FLAGS\")\n         .optopt(\"\", \"ar\", \"path to an archiver\", \"PATH\")\n         .optopt(\"\", \"linker\", \"path to a linker\", \"PATH\")\n         .reqopt(\"\", \"llvm-components\", \"list of LLVM components built in\", \"LIST\")\n@@ -288,6 +289,7 @@ pub fn parse_config(args: Vec<String>) -> Config {\n         cc: matches.opt_str(\"cc\").unwrap(),\n         cxx: matches.opt_str(\"cxx\").unwrap(),\n         cflags: matches.opt_str(\"cflags\").unwrap(),\n+        cxxflags: matches.opt_str(\"cxxflags\").unwrap(),\n         ar: matches.opt_str(\"ar\").unwrap_or_else(|| String::from(\"ar\")),\n         linker: matches.opt_str(\"linker\"),\n         llvm_components: matches.opt_str(\"llvm-components\").unwrap(),"}, {"sha": "8431aa7b818df7b71b1dcd1ea1e4afd9c6872c5a", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=8fa5d74a7cb01ceaf1a07aa6fcaf42137d8bda58", "patch": "@@ -2919,15 +2919,22 @@ impl<'test> TestCx<'test> {\n                 .map(|s| s.replace(\"/\", \"-\"))\n                 .collect::<Vec<_>>()\n                 .join(\" \");\n+            let cxxflags = self\n+                .config\n+                .cxxflags\n+                .split(' ')\n+                .map(|s| s.replace(\"/\", \"-\"))\n+                .collect::<Vec<_>>()\n+                .join(\" \");\n \n             cmd.env(\"IS_MSVC\", \"1\")\n                 .env(\"IS_WINDOWS\", \"1\")\n                 .env(\"MSVC_LIB\", format!(\"'{}' -nologo\", lib.display()))\n                 .env(\"CC\", format!(\"'{}' {}\", self.config.cc, cflags))\n-                .env(\"CXX\", format!(\"'{}'\", &self.config.cxx));\n+                .env(\"CXX\", format!(\"'{}' {}\", &self.config.cxx, cxxflags));\n         } else {\n             cmd.env(\"CC\", format!(\"{} {}\", self.config.cc, self.config.cflags))\n-                .env(\"CXX\", format!(\"{} {}\", self.config.cxx, self.config.cflags))\n+                .env(\"CXX\", format!(\"{} {}\", self.config.cxx, self.config.cxxflags))\n                 .env(\"AR\", &self.config.ar);\n \n             if self.config.target.contains(\"windows\") {"}]}