{"sha": "d620ae10709ca3669cda89db8b29afcd9accc188", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2MjBhZTEwNzA5Y2EzNjY5Y2RhODlkYjhiMjlhZmNkOWFjY2MxODg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-06T04:41:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-06T04:41:20Z"}, "message": "Auto merge of #84266 - QuiltOS:statically-disallow-global-oom-handling, r=Mark-Simulacrum\n\nalloc: Add unstable Cfg feature `no-global_oom_handling\n\nFor certain sorts of systems, programming, it's deemed essential that\nall allocation failures be explicitly handled where they occur. For\nexample, see Linus Torvald's opinion in [1]. Merely not calling global\npanic handlers, or always `try_reserving` first (for vectors), is not\ndeemed good enough, because the mere presence of the global OOM handlers\nis burdens static analysis.\n\nOne option for these projects to use rust would just be to skip `alloc`,\nrolling their own allocation abstractions.  But this would, in my\nopinion be a real shame. `alloc` has a few `try_*` methods already, and\nwe could easily have more. Features like custom allocator support also\ndemonstrate and existing to support diverse use-cases with the same\nabstractions.\n\nA natural way to add such a feature flag would a Cargo feature, but\nthere are currently uncertainties around how std library crate's Cargo\nfeatures may or not be stable, so to avoid any risk of stabilizing by\nmistake we are going with a more low-level \"raw cfg\" token, which\ncannot be interacted with via Cargo alone.\n\nNote also that since there is no notion of \"default cfg tokens\" outside\nof Cargo features, we have to invert the condition from\n`global_oom_handling` to to `not(no_global_oom_handling)`. This breaks\nthe monotonicity that would be important for a Cargo feature (i.e.\nturning on more features should never break compatibility), but it\ndoesn't matter for raw cfg tokens which are not intended to be\n\"constraint solved\" by Cargo or anything else.\n\nTo support this use-case we create a new feature, \"global-oom-handling\",\non by default, and put the global OOM handler infra and everything else\nit that depends on it behind it. By default, nothing is changed, but\nusers concerned about global handling can make sure it is disabled, and\nbe confident that all OOM handling is local and explicit.\n\nFor this first iteration, non-flat collections are outright disabled.\n`Vec` and `String` don't yet have `try_*` allocation methods, but are\nkept anyways since they can be oom-safely created \"from parts\", and we\nhope to add those `try_` methods in the future.\n\n[1]: https://lore.kernel.org/lkml/CAHk-=wh_sNLoz84AUUzuqXEsYH35u=8HV3vK-jbRbJ_B-JjGrg@mail.gmail.com/", "tree": {"sha": "6c6207c1b91ef951dd965701aa38c88c1feca5da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c6207c1b91ef951dd965701aa38c88c1feca5da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d620ae10709ca3669cda89db8b29afcd9accc188", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d620ae10709ca3669cda89db8b29afcd9accc188", "html_url": "https://github.com/rust-lang/rust/commit/d620ae10709ca3669cda89db8b29afcd9accc188", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d620ae10709ca3669cda89db8b29afcd9accc188/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bacf770f2983a52f31e3537db5f0fe1ef2eaa874", "url": "https://api.github.com/repos/rust-lang/rust/commits/bacf770f2983a52f31e3537db5f0fe1ef2eaa874", "html_url": "https://github.com/rust-lang/rust/commit/bacf770f2983a52f31e3537db5f0fe1ef2eaa874"}, {"sha": "19be438cda610232be5ca84e08c74925a481c465", "url": "https://api.github.com/repos/rust-lang/rust/commits/19be438cda610232be5ca84e08c74925a481c465", "html_url": "https://github.com/rust-lang/rust/commit/19be438cda610232be5ca84e08c74925a481c465"}], "stats": {"total": 383, "additions": 326, "deletions": 57}, "files": [{"sha": "a10a027ffda71002f6b63a3407df750e7b1c4e82", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d620ae10709ca3669cda89db8b29afcd9accc188/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d620ae10709ca3669cda89db8b29afcd9accc188/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=d620ae10709ca3669cda89db8b29afcd9accc188", "patch": "@@ -308,7 +308,7 @@ unsafe impl Allocator for Global {\n \n /// The allocator for unique pointers.\n // This function must not unwind. If it does, MIR codegen will fail.\n-#[cfg(not(test))]\n+#[cfg(all(not(no_global_oom_handling), not(test)))]\n #[lang = \"exchange_malloc\"]\n #[inline]\n unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n@@ -337,6 +337,7 @@ pub(crate) unsafe fn box_free<T: ?Sized, A: Allocator>(ptr: Unique<T>, alloc: A)\n \n // # Allocation error handler\n \n+#[cfg(not(no_global_oom_handling))]\n extern \"Rust\" {\n     // This is the magic symbol to call the global alloc error handler.  rustc generates\n     // it to call `__rg_oom` if there is a `#[alloc_error_handler]`, or to call the\n@@ -358,7 +359,7 @@ extern \"Rust\" {\n /// [`set_alloc_error_hook`]: ../../std/alloc/fn.set_alloc_error_hook.html\n /// [`take_alloc_error_hook`]: ../../std/alloc/fn.take_alloc_error_hook.html\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n-#[cfg(not(test))]\n+#[cfg(all(not(no_global_oom_handling), not(test)))]\n #[rustc_allocator_nounwind]\n #[cold]\n pub fn handle_alloc_error(layout: Layout) -> ! {\n@@ -368,10 +369,10 @@ pub fn handle_alloc_error(layout: Layout) -> ! {\n }\n \n // For alloc test `std::alloc::handle_alloc_error` can be used directly.\n-#[cfg(test)]\n+#[cfg(all(not(no_global_oom_handling), test))]\n pub use std::alloc::handle_alloc_error;\n \n-#[cfg(not(any(target_os = \"hermit\", test)))]\n+#[cfg(all(not(no_global_oom_handling), not(any(target_os = \"hermit\", test))))]\n #[doc(hidden)]\n #[allow(unused_attributes)]\n #[unstable(feature = \"alloc_internals\", issue = \"none\")]"}, {"sha": "9d61b3684b82c4cd10b93ddf10e4790efd0aac07", "filename": "library/alloc/src/borrow.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d620ae10709ca3669cda89db8b29afcd9accc188/library%2Falloc%2Fsrc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d620ae10709ca3669cda89db8b29afcd9accc188/library%2Falloc%2Fsrc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fborrow.rs?ref=d620ae10709ca3669cda89db8b29afcd9accc188", "patch": "@@ -4,12 +4,15 @@\n \n use core::cmp::Ordering;\n use core::hash::{Hash, Hasher};\n-use core::ops::{Add, AddAssign, Deref};\n+use core::ops::Deref;\n+#[cfg(not(no_global_oom_handling))]\n+use core::ops::{Add, AddAssign};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::borrow::{Borrow, BorrowMut};\n \n use crate::fmt;\n+#[cfg(not(no_global_oom_handling))]\n use crate::string::String;\n \n use Cow::*;\n@@ -429,6 +432,7 @@ impl<T: ?Sized + ToOwned> AsRef<T> for Cow<'_, T> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"cow_add\", since = \"1.14.0\")]\n impl<'a> Add<&'a str> for Cow<'a, str> {\n     type Output = Cow<'a, str>;\n@@ -440,6 +444,7 @@ impl<'a> Add<&'a str> for Cow<'a, str> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"cow_add\", since = \"1.14.0\")]\n impl<'a> Add<Cow<'a, str>> for Cow<'a, str> {\n     type Output = Cow<'a, str>;\n@@ -451,6 +456,7 @@ impl<'a> Add<Cow<'a, str>> for Cow<'a, str> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"cow_add\", since = \"1.14.0\")]\n impl<'a> AddAssign<&'a str> for Cow<'a, str> {\n     fn add_assign(&mut self, rhs: &'a str) {\n@@ -467,6 +473,7 @@ impl<'a> AddAssign<&'a str> for Cow<'a, str> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"cow_add\", since = \"1.14.0\")]\n impl<'a> AddAssign<Cow<'a, str>> for Cow<'a, str> {\n     fn add_assign(&mut self, rhs: Cow<'a, str>) {"}, {"sha": "eb91af8c61cbc289f66c2768a852b01bfb94b369", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d620ae10709ca3669cda89db8b29afcd9accc188/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d620ae10709ca3669cda89db8b29afcd9accc188/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=d620ae10709ca3669cda89db8b29afcd9accc188", "patch": "@@ -139,7 +139,9 @@ use core::convert::{From, TryFrom};\n use core::fmt;\n use core::future::Future;\n use core::hash::{Hash, Hasher};\n-use core::iter::{FromIterator, FusedIterator, Iterator};\n+#[cfg(not(no_global_oom_handling))]\n+use core::iter::FromIterator;\n+use core::iter::{FusedIterator, Iterator};\n use core::marker::{Unpin, Unsize};\n use core::mem;\n use core::ops::{\n@@ -150,10 +152,16 @@ use core::ptr::{self, Unique};\n use core::stream::Stream;\n use core::task::{Context, Poll};\n \n-use crate::alloc::{handle_alloc_error, AllocError, Allocator, Global, Layout, WriteCloneIntoRaw};\n+#[cfg(not(no_global_oom_handling))]\n+use crate::alloc::{handle_alloc_error, WriteCloneIntoRaw};\n+use crate::alloc::{AllocError, Allocator, Global, Layout};\n+#[cfg(not(no_global_oom_handling))]\n use crate::borrow::Cow;\n+#[cfg(not(no_global_oom_handling))]\n use crate::raw_vec::RawVec;\n+#[cfg(not(no_global_oom_handling))]\n use crate::str::from_boxed_utf8_unchecked;\n+#[cfg(not(no_global_oom_handling))]\n use crate::vec::Vec;\n \n /// A pointer type for heap allocation.\n@@ -177,6 +185,7 @@ impl<T> Box<T> {\n     /// ```\n     /// let five = Box::new(5);\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[inline(always)]\n     #[doc(alias = \"alloc\")]\n     #[doc(alias = \"malloc\")]\n@@ -203,6 +212,7 @@ impl<T> Box<T> {\n     ///\n     /// assert_eq!(*five, 5)\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     #[inline]\n     pub fn new_uninit() -> Box<mem::MaybeUninit<T>> {\n@@ -227,6 +237,7 @@ impl<T> Box<T> {\n     /// ```\n     ///\n     /// [zeroed]: mem::MaybeUninit::zeroed\n+    #[cfg(not(no_global_oom_handling))]\n     #[inline]\n     #[doc(alias = \"calloc\")]\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n@@ -236,6 +247,7 @@ impl<T> Box<T> {\n \n     /// Constructs a new `Pin<Box<T>>`. If `T` does not implement `Unpin`, then\n     /// `x` will be pinned in memory and unable to be moved.\n+    #[cfg(not(no_global_oom_handling))]\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn pin(x: T) -> Pin<Box<T>> {\n@@ -329,6 +341,7 @@ impl<T, A: Allocator> Box<T, A> {\n     ///\n     /// let five = Box::new_in(5, System);\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     #[inline]\n     pub fn new_in(x: T, alloc: A) -> Self {\n@@ -385,6 +398,7 @@ impl<T, A: Allocator> Box<T, A> {\n     /// assert_eq!(*five, 5)\n     /// ```\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[cfg(not(no_global_oom_handling))]\n     // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit_in(alloc: A) -> Box<mem::MaybeUninit<T>, A> {\n         let layout = Layout::new::<mem::MaybeUninit<T>>();\n@@ -447,6 +461,7 @@ impl<T, A: Allocator> Box<T, A> {\n     ///\n     /// [zeroed]: mem::MaybeUninit::zeroed\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[cfg(not(no_global_oom_handling))]\n     // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_zeroed_in(alloc: A) -> Box<mem::MaybeUninit<T>, A> {\n         let layout = Layout::new::<mem::MaybeUninit<T>>();\n@@ -490,6 +505,7 @@ impl<T, A: Allocator> Box<T, A> {\n \n     /// Constructs a new `Pin<Box<T, A>>`. If `T` does not implement `Unpin`, then\n     /// `x` will be pinned in memory and unable to be moved.\n+    #[cfg(not(no_global_oom_handling))]\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     #[inline(always)]\n     pub fn pin_in(x: T, alloc: A) -> Pin<Self>\n@@ -547,6 +563,7 @@ impl<T> Box<[T]> {\n     ///\n     /// assert_eq!(*values, [1, 2, 3])\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit_slice(len: usize) -> Box<[mem::MaybeUninit<T>]> {\n         unsafe { RawVec::with_capacity(len).into_box(len) }\n@@ -570,6 +587,7 @@ impl<T> Box<[T]> {\n     /// ```\n     ///\n     /// [zeroed]: mem::MaybeUninit::zeroed\n+    #[cfg(not(no_global_oom_handling))]\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_zeroed_slice(len: usize) -> Box<[mem::MaybeUninit<T>]> {\n         unsafe { RawVec::with_capacity_zeroed(len).into_box(len) }\n@@ -599,6 +617,7 @@ impl<T, A: Allocator> Box<[T], A> {\n     ///\n     /// assert_eq!(*values, [1, 2, 3])\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit_slice_in(len: usize, alloc: A) -> Box<[mem::MaybeUninit<T>], A> {\n@@ -625,6 +644,7 @@ impl<T, A: Allocator> Box<[T], A> {\n     /// ```\n     ///\n     /// [zeroed]: mem::MaybeUninit::zeroed\n+    #[cfg(not(no_global_oom_handling))]\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_zeroed_slice_in(len: usize, alloc: A) -> Box<[mem::MaybeUninit<T>], A> {\n@@ -1013,20 +1033,23 @@ impl<T: Default> Default for Box<T> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for Box<[T]> {\n     fn default() -> Self {\n         Box::<[T; 0]>::new([])\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"default_box_extra\", since = \"1.17.0\")]\n impl Default for Box<str> {\n     fn default() -> Self {\n         unsafe { from_boxed_utf8_unchecked(Default::default()) }\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone, A: Allocator + Clone> Clone for Box<T, A> {\n     /// Returns a new box with a `clone()` of this box's contents.\n@@ -1076,6 +1099,7 @@ impl<T: Clone, A: Allocator + Clone> Clone for Box<T, A> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"box_slice_clone\", since = \"1.3.0\")]\n impl Clone for Box<str> {\n     fn clone(&self) -> Self {\n@@ -1182,6 +1206,7 @@ impl<T: ?Sized + Hasher, A: Allocator> Hasher for Box<T, A> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"from_for_ptrs\", since = \"1.6.0\")]\n impl<T> From<T> for Box<T> {\n     /// Converts a generic type `T` into a `Box<T>`\n@@ -1214,6 +1239,7 @@ where\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"box_from_slice\", since = \"1.17.0\")]\n impl<T: Copy> From<&[T]> for Box<[T]> {\n     /// Converts a `&[T]` into a `Box<[T]>`\n@@ -1239,6 +1265,7 @@ impl<T: Copy> From<&[T]> for Box<[T]> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"box_from_cow\", since = \"1.45.0\")]\n impl<T: Copy> From<Cow<'_, [T]>> for Box<[T]> {\n     #[inline]\n@@ -1250,6 +1277,7 @@ impl<T: Copy> From<Cow<'_, [T]>> for Box<[T]> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"box_from_slice\", since = \"1.17.0\")]\n impl From<&str> for Box<str> {\n     /// Converts a `&str` into a `Box<str>`\n@@ -1268,6 +1296,7 @@ impl From<&str> for Box<str> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"box_from_cow\", since = \"1.45.0\")]\n impl From<Cow<'_, str>> for Box<str> {\n     #[inline]\n@@ -1567,13 +1596,15 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized, A: Allocator> CoerceUnsized<Box<U, A>> fo\n #[unstable(feature = \"dispatch_from_dyn\", issue = \"none\")]\n impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Box<U>> for Box<T, Global> {}\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"boxed_slice_from_iter\", since = \"1.32.0\")]\n impl<I> FromIterator<I> for Box<[I]> {\n     fn from_iter<T: IntoIterator<Item = I>>(iter: T) -> Self {\n         iter.into_iter().collect::<Vec<_>>().into_boxed_slice()\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"box_slice_clone\", since = \"1.3.0\")]\n impl<T: Clone, A: Allocator + Clone> Clone for Box<[T], A> {\n     fn clone(&self) -> Self {"}, {"sha": "b9b3d650ea204dae0a5b040ad41a93edc2933c23", "filename": "library/alloc/src/collections/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d620ae10709ca3669cda89db8b29afcd9accc188/library%2Falloc%2Fsrc%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d620ae10709ca3669cda89db8b29afcd9accc188/library%2Falloc%2Fsrc%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fmod.rs?ref=d620ae10709ca3669cda89db8b29afcd9accc188", "patch": "@@ -2,41 +2,52 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+#[cfg(not(no_global_oom_handling))]\n pub mod binary_heap;\n+#[cfg(not(no_global_oom_handling))]\n mod btree;\n+#[cfg(not(no_global_oom_handling))]\n pub mod linked_list;\n+#[cfg(not(no_global_oom_handling))]\n pub mod vec_deque;\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod btree_map {\n     //! A map based on a B-Tree.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub use super::btree::map::*;\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod btree_set {\n     //! A set based on a B-Tree.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub use super::btree::set::*;\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n pub use binary_heap::BinaryHeap;\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n pub use btree_map::BTreeMap;\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n pub use btree_set::BTreeSet;\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n pub use linked_list::LinkedList;\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n pub use vec_deque::VecDeque;"}, {"sha": "fd5ee189fbf7cdc05c23de9d53752e39d49770ea", "filename": "library/alloc/src/fmt.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d620ae10709ca3669cda89db8b29afcd9accc188/library%2Falloc%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d620ae10709ca3669cda89db8b29afcd9accc188/library%2Falloc%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Ffmt.rs?ref=d620ae10709ca3669cda89db8b29afcd9accc188", "patch": "@@ -546,6 +546,7 @@ pub use core::fmt::{LowerExp, UpperExp};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::fmt::{LowerHex, Pointer, UpperHex};\n \n+#[cfg(not(no_global_oom_handling))]\n use crate::string;\n \n /// The `format` function takes an [`Arguments`] struct and returns the resulting\n@@ -574,6 +575,7 @@ use crate::string;\n ///\n /// [`format_args!`]: core::format_args\n /// [`format!`]: crate::format\n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn format(args: Arguments<'_>) -> string::String {\n     let capacity = args.estimated_capacity();"}, {"sha": "66b1036f2ab0b8e16073fa74201727ef0fcd27b1", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d620ae10709ca3669cda89db8b29afcd9accc188/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d620ae10709ca3669cda89db8b29afcd9accc188/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=d620ae10709ca3669cda89db8b29afcd9accc188", "patch": "@@ -87,7 +87,7 @@\n #![feature(cfg_sanitize)]\n #![feature(cfg_target_has_atomic)]\n #![feature(coerce_unsized)]\n-#![feature(const_btree_new)]\n+#![cfg_attr(not(no_global_oom_handling), feature(const_btree_new))]\n #![cfg_attr(bootstrap, feature(const_fn))]\n #![cfg_attr(not(bootstrap), feature(const_fn_trait_bound))]\n #![feature(cow_is_borrowed)]\n@@ -183,7 +183,7 @@ pub mod str;\n pub mod string;\n #[cfg(target_has_atomic = \"ptr\")]\n pub mod sync;\n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(all(not(no_global_oom_handling), target_has_atomic = \"ptr\"))]\n pub mod task;\n #[cfg(test)]\n mod tests;"}, {"sha": "2e2c9b76bd4ba6a1d74d73f6935b8961adfaad8f", "filename": "library/alloc/src/raw_vec.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d620ae10709ca3669cda89db8b29afcd9accc188/library%2Falloc%2Fsrc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d620ae10709ca3669cda89db8b29afcd9accc188/library%2Falloc%2Fsrc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fraw_vec.rs?ref=d620ae10709ca3669cda89db8b29afcd9accc188", "patch": "@@ -9,13 +9,16 @@ use core::ops::Drop;\n use core::ptr::{self, NonNull, Unique};\n use core::slice;\n \n-use crate::alloc::{handle_alloc_error, Allocator, Global, Layout};\n+#[cfg(not(no_global_oom_handling))]\n+use crate::alloc::handle_alloc_error;\n+use crate::alloc::{Allocator, Global, Layout};\n use crate::boxed::Box;\n use crate::collections::TryReserveError::{self, *};\n \n #[cfg(test)]\n mod tests;\n \n+#[cfg(not(no_global_oom_handling))]\n enum AllocInit {\n     /// The contents of the new memory are uninitialized.\n     Uninitialized,\n@@ -82,12 +85,14 @@ impl<T> RawVec<T, Global> {\n     /// # Aborts\n     ///\n     /// Aborts on OOM.\n+    #[cfg(not(no_global_oom_handling))]\n     #[inline]\n     pub fn with_capacity(capacity: usize) -> Self {\n         Self::with_capacity_in(capacity, Global)\n     }\n \n     /// Like `with_capacity`, but guarantees the buffer is zeroed.\n+    #[cfg(not(no_global_oom_handling))]\n     #[inline]\n     pub fn with_capacity_zeroed(capacity: usize) -> Self {\n         Self::with_capacity_zeroed_in(capacity, Global)\n@@ -131,13 +136,15 @@ impl<T, A: Allocator> RawVec<T, A> {\n \n     /// Like `with_capacity`, but parameterized over the choice of\n     /// allocator for the returned `RawVec`.\n+    #[cfg(not(no_global_oom_handling))]\n     #[inline]\n     pub fn with_capacity_in(capacity: usize, alloc: A) -> Self {\n         Self::allocate_in(capacity, AllocInit::Uninitialized, alloc)\n     }\n \n     /// Like `with_capacity_zeroed`, but parameterized over the choice\n     /// of allocator for the returned `RawVec`.\n+    #[cfg(not(no_global_oom_handling))]\n     #[inline]\n     pub fn with_capacity_zeroed_in(capacity: usize, alloc: A) -> Self {\n         Self::allocate_in(capacity, AllocInit::Zeroed, alloc)\n@@ -177,6 +184,7 @@ impl<T, A: Allocator> RawVec<T, A> {\n         }\n     }\n \n+    #[cfg(not(no_global_oom_handling))]\n     fn allocate_in(capacity: usize, init: AllocInit, alloc: A) -> Self {\n         if mem::size_of::<T>() == 0 {\n             Self::new_in(alloc)\n@@ -309,6 +317,7 @@ impl<T, A: Allocator> RawVec<T, A> {\n     /// #   vector.push_all(&[1, 3, 5, 7, 9]);\n     /// # }\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[inline]\n     pub fn reserve(&mut self, len: usize, additional: usize) {\n         // Callers expect this function to be very cheap when there is already sufficient capacity.\n@@ -355,6 +364,7 @@ impl<T, A: Allocator> RawVec<T, A> {\n     /// # Aborts\n     ///\n     /// Aborts on OOM.\n+    #[cfg(not(no_global_oom_handling))]\n     pub fn reserve_exact(&mut self, len: usize, additional: usize) {\n         handle_reserve(self.try_reserve_exact(len, additional));\n     }\n@@ -378,6 +388,7 @@ impl<T, A: Allocator> RawVec<T, A> {\n     /// # Aborts\n     ///\n     /// Aborts on OOM.\n+    #[cfg(not(no_global_oom_handling))]\n     pub fn shrink_to_fit(&mut self, amount: usize) {\n         handle_reserve(self.shrink(amount));\n     }\n@@ -452,6 +463,7 @@ impl<T, A: Allocator> RawVec<T, A> {\n         Ok(())\n     }\n \n+    #[cfg(not(no_global_oom_handling))]\n     fn shrink(&mut self, amount: usize) -> Result<(), TryReserveError> {\n         assert!(amount <= self.capacity(), \"Tried to shrink to a larger capacity\");\n \n@@ -512,6 +524,7 @@ unsafe impl<#[may_dangle] T, A: Allocator> Drop for RawVec<T, A> {\n }\n \n // Central function for reserve error handling.\n+#[cfg(not(no_global_oom_handling))]\n #[inline]\n fn handle_reserve(result: Result<(), TryReserveError>) {\n     match result {\n@@ -542,6 +555,7 @@ fn alloc_guard(alloc_size: usize) -> Result<(), TryReserveError> {\n // One central function responsible for reporting capacity overflows. This'll\n // ensure that the code generation related to these panics is minimal as there's\n // only one location which panics rather than a bunch throughout the module.\n+#[cfg(not(no_global_oom_handling))]\n fn capacity_overflow() -> ! {\n     panic!(\"capacity overflow\");\n }"}, {"sha": "964169a227f6497d8b94c40e191e64ca4a3a2d02", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d620ae10709ca3669cda89db8b29afcd9accc188/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d620ae10709ca3669cda89db8b29afcd9accc188/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=d620ae10709ca3669cda89db8b29afcd9accc188", "patch": "@@ -255,19 +255,27 @@ use core::convert::{From, TryFrom};\n use core::fmt;\n use core::hash::{Hash, Hasher};\n use core::intrinsics::abort;\n+#[cfg(not(no_global_oom_handling))]\n use core::iter;\n use core::marker::{self, PhantomData, Unpin, Unsize};\n-use core::mem::{self, align_of_val_raw, forget, size_of_val};\n+#[cfg(not(no_global_oom_handling))]\n+use core::mem::size_of_val;\n+use core::mem::{self, align_of_val_raw, forget};\n use core::ops::{CoerceUnsized, Deref, DispatchFromDyn, Receiver};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n+#[cfg(not(no_global_oom_handling))]\n use core::slice::from_raw_parts_mut;\n \n-use crate::alloc::{\n-    box_free, handle_alloc_error, AllocError, Allocator, Global, Layout, WriteCloneIntoRaw,\n-};\n+#[cfg(not(no_global_oom_handling))]\n+use crate::alloc::handle_alloc_error;\n+#[cfg(not(no_global_oom_handling))]\n+use crate::alloc::{box_free, WriteCloneIntoRaw};\n+use crate::alloc::{AllocError, Allocator, Global, Layout};\n use crate::borrow::{Cow, ToOwned};\n+#[cfg(not(no_global_oom_handling))]\n use crate::string::String;\n+#[cfg(not(no_global_oom_handling))]\n use crate::vec::Vec;\n \n #[cfg(test)]\n@@ -434,6 +442,7 @@ impl<T> Rc<T> {\n     ///\n     /// assert_eq!(*five, 5)\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit() -> Rc<mem::MaybeUninit<T>> {\n         unsafe {\n@@ -465,6 +474,7 @@ impl<T> Rc<T> {\n     /// ```\n     ///\n     /// [zeroed]: mem::MaybeUninit::zeroed\n+    #[cfg(not(no_global_oom_handling))]\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_zeroed() -> Rc<mem::MaybeUninit<T>> {\n         unsafe {\n@@ -637,6 +647,7 @@ impl<T> Rc<[T]> {\n     ///\n     /// assert_eq!(*values, [1, 2, 3])\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit_slice(len: usize) -> Rc<[mem::MaybeUninit<T>]> {\n         unsafe { Rc::from_ptr(Rc::allocate_for_slice(len)) }\n@@ -662,6 +673,7 @@ impl<T> Rc<[T]> {\n     /// ```\n     ///\n     /// [zeroed]: mem::MaybeUninit::zeroed\n+    #[cfg(not(no_global_oom_handling))]\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_zeroed_slice(len: usize) -> Rc<[mem::MaybeUninit<T>]> {\n         unsafe {\n@@ -1122,6 +1134,7 @@ impl<T: Clone> Rc<T> {\n     /// assert!(76 == *data);\n     /// assert!(weak.upgrade().is_none());\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[inline]\n     #[stable(feature = \"rc_unique\", since = \"1.4.0\")]\n     pub fn make_mut(this: &mut Self) -> &mut T {\n@@ -1195,6 +1208,7 @@ impl<T: ?Sized> Rc<T> {\n     ///\n     /// The function `mem_to_rcbox` is called with the data pointer\n     /// and must return back a (potentially fat)-pointer for the `RcBox<T>`.\n+    #[cfg(not(no_global_oom_handling))]\n     unsafe fn allocate_for_layout(\n         value_layout: Layout,\n         allocate: impl FnOnce(Layout) -> Result<NonNull<[u8]>, AllocError>,\n@@ -1245,6 +1259,7 @@ impl<T: ?Sized> Rc<T> {\n     }\n \n     /// Allocates an `RcBox<T>` with sufficient space for an unsized inner value\n+    #[cfg(not(no_global_oom_handling))]\n     unsafe fn allocate_for_ptr(ptr: *const T) -> *mut RcBox<T> {\n         // Allocate for the `RcBox<T>` using the given value.\n         unsafe {\n@@ -1256,6 +1271,7 @@ impl<T: ?Sized> Rc<T> {\n         }\n     }\n \n+    #[cfg(not(no_global_oom_handling))]\n     fn from_box(v: Box<T>) -> Rc<T> {\n         unsafe {\n             let (box_unique, alloc) = Box::into_unique(v);\n@@ -1281,6 +1297,7 @@ impl<T: ?Sized> Rc<T> {\n \n impl<T> Rc<[T]> {\n     /// Allocates an `RcBox<[T]>` with the given length.\n+    #[cfg(not(no_global_oom_handling))]\n     unsafe fn allocate_for_slice(len: usize) -> *mut RcBox<[T]> {\n         unsafe {\n             Self::allocate_for_layout(\n@@ -1294,6 +1311,7 @@ impl<T> Rc<[T]> {\n     /// Copy elements from slice into newly allocated Rc<\\[T\\]>\n     ///\n     /// Unsafe because the caller must either take ownership or bind `T: Copy`\n+    #[cfg(not(no_global_oom_handling))]\n     unsafe fn copy_from_slice(v: &[T]) -> Rc<[T]> {\n         unsafe {\n             let ptr = Self::allocate_for_slice(v.len());\n@@ -1305,6 +1323,7 @@ impl<T> Rc<[T]> {\n     /// Constructs an `Rc<[T]>` from an iterator known to be of a certain size.\n     ///\n     /// Behavior is undefined should the size be wrong.\n+    #[cfg(not(no_global_oom_handling))]\n     unsafe fn from_iter_exact(iter: impl iter::Iterator<Item = T>, len: usize) -> Rc<[T]> {\n         // Panic guard while cloning T elements.\n         // In the event of a panic, elements that have been written\n@@ -1356,13 +1375,15 @@ trait RcFromSlice<T> {\n     fn from_slice(slice: &[T]) -> Self;\n }\n \n+#[cfg(not(no_global_oom_handling))]\n impl<T: Clone> RcFromSlice<T> for Rc<[T]> {\n     #[inline]\n     default fn from_slice(v: &[T]) -> Self {\n         unsafe { Self::from_iter_exact(v.iter().cloned(), v.len()) }\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n impl<T: Copy> RcFromSlice<T> for Rc<[T]> {\n     #[inline]\n     fn from_slice(v: &[T]) -> Self {\n@@ -1717,6 +1738,7 @@ impl<T> From<T> for Rc<T> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n impl<T: Clone> From<&[T]> for Rc<[T]> {\n     /// Allocate a reference-counted slice and fill it by cloning `v`'s items.\n@@ -1735,6 +1757,7 @@ impl<T: Clone> From<&[T]> for Rc<[T]> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n impl From<&str> for Rc<str> {\n     /// Allocate a reference-counted string slice and copy `v` into it.\n@@ -1753,6 +1776,7 @@ impl From<&str> for Rc<str> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n impl From<String> for Rc<str> {\n     /// Allocate a reference-counted string slice and copy `v` into it.\n@@ -1771,6 +1795,7 @@ impl From<String> for Rc<str> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n impl<T: ?Sized> From<Box<T>> for Rc<T> {\n     /// Move a boxed object to a new, reference counted, allocation.\n@@ -1789,6 +1814,7 @@ impl<T: ?Sized> From<Box<T>> for Rc<T> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n impl<T> From<Vec<T>> for Rc<[T]> {\n     /// Allocate a reference-counted slice and move `v`'s items into it.\n@@ -1842,6 +1868,7 @@ impl<T, const N: usize> TryFrom<Rc<[T]>> for Rc<[T; N]> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"shared_from_iter\", since = \"1.37.0\")]\n impl<T> iter::FromIterator<T> for Rc<[T]> {\n     /// Takes each element in the `Iterator` and collects it into an `Rc<[T]>`.\n@@ -1888,16 +1915,19 @@ impl<T> iter::FromIterator<T> for Rc<[T]> {\n }\n \n /// Specialization trait used for collecting into `Rc<[T]>`.\n+#[cfg(not(no_global_oom_handling))]\n trait ToRcSlice<T>: Iterator<Item = T> + Sized {\n     fn to_rc_slice(self) -> Rc<[T]>;\n }\n \n+#[cfg(not(no_global_oom_handling))]\n impl<T, I: Iterator<Item = T>> ToRcSlice<T> for I {\n     default fn to_rc_slice(self) -> Rc<[T]> {\n         self.collect::<Vec<T>>().into()\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n impl<T, I: iter::TrustedLen<Item = T>> ToRcSlice<T> for I {\n     fn to_rc_slice(self) -> Rc<[T]> {\n         // This is the case for a `TrustedLen` iterator."}, {"sha": "dcd64899204925fdaed1c9cf3618c30dd13b9a70", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d620ae10709ca3669cda89db8b29afcd9accc188/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d620ae10709ca3669cda89db8b29afcd9accc188/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=d620ae10709ca3669cda89db8b29afcd9accc188", "patch": "@@ -83,11 +83,19 @@\n #![cfg_attr(test, allow(unused_imports, dead_code))]\n \n use core::borrow::{Borrow, BorrowMut};\n+#[cfg(not(no_global_oom_handling))]\n use core::cmp::Ordering::{self, Less};\n-use core::mem::{self, size_of};\n+#[cfg(not(no_global_oom_handling))]\n+use core::mem;\n+#[cfg(not(no_global_oom_handling))]\n+use core::mem::size_of;\n+#[cfg(not(no_global_oom_handling))]\n use core::ptr;\n \n-use crate::alloc::{Allocator, Global};\n+use crate::alloc::Allocator;\n+#[cfg(not(no_global_oom_handling))]\n+use crate::alloc::Global;\n+#[cfg(not(no_global_oom_handling))]\n use crate::borrow::ToOwned;\n use crate::boxed::Box;\n use crate::vec::Vec;\n@@ -158,17 +166,20 @@ mod hack {\n         }\n     }\n \n+    #[cfg(not(no_global_oom_handling))]\n     #[inline]\n     pub fn to_vec<T: ConvertVec, A: Allocator>(s: &[T], alloc: A) -> Vec<T, A> {\n         T::to_vec(s, alloc)\n     }\n \n+    #[cfg(not(no_global_oom_handling))]\n     pub trait ConvertVec {\n         fn to_vec<A: Allocator>(s: &[Self], alloc: A) -> Vec<Self, A>\n         where\n             Self: Sized;\n     }\n \n+    #[cfg(not(no_global_oom_handling))]\n     impl<T: Clone> ConvertVec for T {\n         #[inline]\n         default fn to_vec<A: Allocator>(s: &[Self], alloc: A) -> Vec<Self, A> {\n@@ -205,6 +216,7 @@ mod hack {\n         }\n     }\n \n+    #[cfg(not(no_global_oom_handling))]\n     impl<T: Copy> ConvertVec for T {\n         #[inline]\n         fn to_vec<A: Allocator>(s: &[Self], alloc: A) -> Vec<Self, A> {\n@@ -250,6 +262,7 @@ impl<T> [T] {\n     /// v.sort();\n     /// assert!(v == [-5, -3, 1, 2, 4]);\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn sort(&mut self)\n@@ -304,6 +317,7 @@ impl<T> [T] {\n     /// v.sort_by(|a, b| b.cmp(a));\n     /// assert!(v == [5, 4, 3, 2, 1]);\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn sort_by<F>(&mut self, mut compare: F)\n@@ -344,6 +358,7 @@ impl<T> [T] {\n     /// v.sort_by_key(|k| k.abs());\n     /// assert!(v == [1, 2, -3, 4, -5]);\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[stable(feature = \"slice_sort_by_key\", since = \"1.7.0\")]\n     #[inline]\n     pub fn sort_by_key<K, F>(&mut self, mut f: F)\n@@ -386,6 +401,7 @@ impl<T> [T] {\n     /// ```\n     ///\n     /// [pdqsort]: https://github.com/orlp/pdqsort\n+    #[cfg(not(no_global_oom_handling))]\n     #[stable(feature = \"slice_sort_by_cached_key\", since = \"1.34.0\")]\n     #[inline]\n     pub fn sort_by_cached_key<K, F>(&mut self, f: F)\n@@ -443,6 +459,7 @@ impl<T> [T] {\n     /// let x = s.to_vec();\n     /// // Here, `s` and `x` can be modified independently.\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[rustc_conversion_suggestion]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -466,6 +483,7 @@ impl<T> [T] {\n     /// let x = s.to_vec_in(System);\n     /// // Here, `s` and `x` can be modified independently.\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[inline]\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     pub fn to_vec_in<A: Allocator>(&self, alloc: A) -> Vec<T, A>\n@@ -517,6 +535,7 @@ impl<T> [T] {\n     /// // this will panic at runtime\n     /// b\"0123456789abcdef\".repeat(usize::MAX);\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[stable(feature = \"repeat_generic_slice\", since = \"1.40.0\")]\n     pub fn repeat(&self, n: usize) -> Vec<T>\n     where\n@@ -642,6 +661,7 @@ impl [u8] {\n     /// To uppercase the value in-place, use [`make_ascii_uppercase`].\n     ///\n     /// [`make_ascii_uppercase`]: slice::make_ascii_uppercase\n+    #[cfg(not(no_global_oom_handling))]\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]\n     pub fn to_ascii_uppercase(&self) -> Vec<u8> {\n@@ -659,6 +679,7 @@ impl [u8] {\n     /// To lowercase the value in-place, use [`make_ascii_lowercase`].\n     ///\n     /// [`make_ascii_lowercase`]: slice::make_ascii_lowercase\n+    #[cfg(not(no_global_oom_handling))]\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]\n     pub fn to_ascii_lowercase(&self) -> Vec<u8> {\n@@ -724,6 +745,7 @@ pub trait Join<Separator> {\n     fn join(slice: &Self, sep: Separator) -> Self::Output;\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\n impl<T: Clone, V: Borrow<[T]>> Concat<T> for [V] {\n     type Output = Vec<T>;\n@@ -738,6 +760,7 @@ impl<T: Clone, V: Borrow<[T]>> Concat<T> for [V] {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\n impl<T: Clone, V: Borrow<[T]>> Join<&T> for [V] {\n     type Output = Vec<T>;\n@@ -760,6 +783,7 @@ impl<T: Clone, V: Borrow<[T]>> Join<&T> for [V] {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\n impl<T: Clone, V: Borrow<[T]>> Join<&[T]> for [V] {\n     type Output = Vec<T>;\n@@ -801,6 +825,7 @@ impl<T> BorrowMut<[T]> for Vec<T> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> ToOwned for [T] {\n     type Owned = Vec<T>;\n@@ -835,6 +860,7 @@ impl<T: Clone> ToOwned for [T] {\n /// Inserts `v[0]` into pre-sorted sequence `v[1..]` so that whole `v[..]` becomes sorted.\n ///\n /// This is the integral subroutine of insertion sort.\n+#[cfg(not(no_global_oom_handling))]\n fn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n where\n     F: FnMut(&T, &T) -> bool,\n@@ -906,6 +932,7 @@ where\n ///\n /// The two slices must be non-empty and `mid` must be in bounds. Buffer `buf` must be long enough\n /// to hold a copy of the shorter slice. Also, `T` must not be a zero-sized type.\n+#[cfg(not(no_global_oom_handling))]\n unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n where\n     F: FnMut(&T, &T) -> bool,\n@@ -1026,6 +1053,7 @@ where\n /// 2. for every `i` in `2..runs.len()`: `runs[i - 2].len > runs[i - 1].len + runs[i].len`\n ///\n /// The invariants ensure that the total running time is *O*(*n* \\* log(*n*)) worst-case.\n+#[cfg(not(no_global_oom_handling))]\n fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n where\n     F: FnMut(&T, &T) -> bool,"}, {"sha": "57279e81a9578d0c16ff0c55ec7581d7923d77a6", "filename": "library/alloc/src/str.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d620ae10709ca3669cda89db8b29afcd9accc188/library%2Falloc%2Fsrc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d620ae10709ca3669cda89db8b29afcd9accc188/library%2Falloc%2Fsrc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstr.rs?ref=d620ae10709ca3669cda89db8b29afcd9accc188", "patch": "@@ -74,6 +74,7 @@ pub use core::str::{RSplitTerminator, SplitTerminator};\n \n /// Note: `str` in `Concat<str>` is not meaningful here.\n /// This type parameter of the trait only exists to enable another impl.\n+#[cfg(not(no_global_oom_handling))]\n #[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\n impl<S: Borrow<str>> Concat<str> for [S] {\n     type Output = String;\n@@ -83,6 +84,7 @@ impl<S: Borrow<str>> Concat<str> for [S] {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\n impl<S: Borrow<str>> Join<&str> for [S] {\n     type Output = String;\n@@ -92,6 +94,7 @@ impl<S: Borrow<str>> Join<&str> for [S] {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n macro_rules! specialize_for_lengths {\n     ($separator:expr, $target:expr, $iter:expr; $($num:expr),*) => {{\n         let mut target = $target;\n@@ -122,6 +125,7 @@ macro_rules! specialize_for_lengths {\n     }}\n }\n \n+#[cfg(not(no_global_oom_handling))]\n macro_rules! copy_slice_and_advance {\n     ($target:expr, $bytes:expr) => {\n         let len = $bytes.len();\n@@ -139,6 +143,7 @@ macro_rules! copy_slice_and_advance {\n // the bounds for String-join are S: Borrow<str> and for Vec-join Borrow<[T]>\n // [T] and str both impl AsRef<[T]> for some T\n // => s.borrow().as_ref() and we always have slices\n+#[cfg(not(no_global_oom_handling))]\n fn join_generic_copy<B, T, S>(slice: &[S], sep: &[T]) -> Vec<T>\n where\n     T: Copy,\n@@ -205,6 +210,7 @@ impl BorrowMut<str> for String {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ToOwned for str {\n     type Owned = String;\n@@ -264,6 +270,7 @@ impl str {\n     /// let s = \"this is old\";\n     /// assert_eq!(s, s.replace(\"cookie monster\", \"little lamb\"));\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[must_use = \"this returns the replaced string as a new allocation, \\\n                   without modifying the original\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -303,6 +310,7 @@ impl str {\n     /// let s = \"this is old\";\n     /// assert_eq!(s, s.replacen(\"cookie monster\", \"little lamb\", 10));\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[must_use = \"this returns the replaced string as a new allocation, \\\n                   without modifying the original\"]\n     #[stable(feature = \"str_replacen\", since = \"1.16.0\")]\n@@ -358,6 +366,7 @@ impl str {\n     ///\n     /// assert_eq!(new_year, new_year.to_lowercase());\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n     pub fn to_lowercase(&self) -> String {\n         let mut s = String::with_capacity(self.len());\n@@ -437,6 +446,7 @@ impl str {\n     ///\n     /// assert_eq!(\"TSCH\u00dcSS\", s.to_uppercase());\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n     pub fn to_uppercase(&self) -> String {\n         let mut s = String::with_capacity(self.len());\n@@ -496,6 +506,7 @@ impl str {\n     /// // this will panic at runtime\n     /// \"0123456789abcdef\".repeat(usize::MAX);\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[stable(feature = \"repeat_str\", since = \"1.16.0\")]\n     pub fn repeat(&self, n: usize) -> String {\n         unsafe { String::from_utf8_unchecked(self.as_bytes().repeat(n)) }\n@@ -522,6 +533,7 @@ impl str {\n     ///\n     /// [`make_ascii_uppercase`]: str::make_ascii_uppercase\n     /// [`to_uppercase`]: #method.to_uppercase\n+    #[cfg(not(no_global_oom_handling))]\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]\n     pub fn to_ascii_uppercase(&self) -> String {\n@@ -552,6 +564,7 @@ impl str {\n     ///\n     /// [`make_ascii_lowercase`]: str::make_ascii_lowercase\n     /// [`to_lowercase`]: #method.to_lowercase\n+    #[cfg(not(no_global_oom_handling))]\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]\n     pub fn to_ascii_lowercase(&self) -> String {"}, {"sha": "e62524524708649af454e8fc48e4a91c9c09ac2b", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 75, "deletions": 5, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/d620ae10709ca3669cda89db8b29afcd9accc188/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d620ae10709ca3669cda89db8b29afcd9accc188/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=d620ae10709ca3669cda89db8b29afcd9accc188", "patch": "@@ -42,20 +42,33 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+#[cfg(not(no_global_oom_handling))]\n use core::char::{decode_utf16, REPLACEMENT_CHARACTER};\n use core::fmt;\n use core::hash;\n-use core::iter::{FromIterator, FusedIterator};\n+#[cfg(not(no_global_oom_handling))]\n+use core::iter::FromIterator;\n+use core::iter::FusedIterator;\n+#[cfg(not(no_global_oom_handling))]\n+use core::ops::Add;\n+#[cfg(not(no_global_oom_handling))]\n+use core::ops::AddAssign;\n+#[cfg(not(no_global_oom_handling))]\n use core::ops::Bound::{Excluded, Included, Unbounded};\n-use core::ops::{self, Add, AddAssign, Index, IndexMut, Range, RangeBounds};\n+use core::ops::{self, Index, IndexMut, Range, RangeBounds};\n use core::ptr;\n use core::slice;\n-use core::str::{lossy, pattern::Pattern};\n+#[cfg(not(no_global_oom_handling))]\n+use core::str::lossy;\n+use core::str::pattern::Pattern;\n \n+#[cfg(not(no_global_oom_handling))]\n use crate::borrow::{Cow, ToOwned};\n use crate::boxed::Box;\n use crate::collections::TryReserveError;\n-use crate::str::{self, from_boxed_utf8_unchecked, Chars, FromStr, Utf8Error};\n+use crate::str::{self, Chars, Utf8Error};\n+#[cfg(not(no_global_oom_handling))]\n+use crate::str::{from_boxed_utf8_unchecked, FromStr};\n use crate::vec::Vec;\n \n /// A UTF-8\u2013encoded, growable string.\n@@ -314,7 +327,8 @@ pub struct String {\n /// assert_eq!(vec![0, 159], value.unwrap_err().into_bytes());\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Debug, Clone, PartialEq, Eq)]\n+#[cfg_attr(not(no_global_oom_handling), derive(Clone))]\n+#[derive(Debug, PartialEq, Eq)]\n pub struct FromUtf8Error {\n     bytes: Vec<u8>,\n     error: Utf8Error,\n@@ -403,6 +417,7 @@ impl String {\n     /// // ...but this may make the string reallocate\n     /// s.push('a');\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[inline]\n     #[doc(alias = \"alloc\")]\n     #[doc(alias = \"malloc\")]\n@@ -535,6 +550,7 @@ impl String {\n     ///\n     /// assert_eq!(\"Hello \ufffdWorld\", output);\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf8_lossy(v: &[u8]) -> Cow<'_, str> {\n         let mut iter = lossy::Utf8Lossy::from_bytes(v).chunks();\n@@ -587,6 +603,7 @@ impl String {\n     ///           0xD800, 0x0069, 0x0063];\n     /// assert!(String::from_utf16(v).is_err());\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf16(v: &[u16]) -> Result<String, FromUtf16Error> {\n         // This isn't done via collect::<Result<_, _>>() for performance reasons.\n@@ -626,6 +643,7 @@ impl String {\n     /// assert_eq!(String::from(\"\ud834\udd1emus\\u{FFFD}ic\\u{FFFD}\"),\n     ///            String::from_utf16_lossy(v));\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf16_lossy(v: &[u16]) -> String {\n@@ -818,6 +836,7 @@ impl String {\n     ///\n     /// assert_eq!(\"foobar\", s);\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_str(&mut self, string: &str) {\n@@ -885,6 +904,7 @@ impl String {\n     /// // ... doesn't actually increase.\n     /// assert_eq!(10, s.capacity());\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: usize) {\n@@ -932,6 +952,7 @@ impl String {\n     /// // ... doesn't actually increase.\n     /// assert_eq!(10, s.capacity());\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_exact(&mut self, additional: usize) {\n@@ -1026,6 +1047,7 @@ impl String {\n     /// s.shrink_to_fit();\n     /// assert_eq!(3, s.capacity());\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n@@ -1053,6 +1075,7 @@ impl String {\n     /// s.shrink_to(0);\n     /// assert!(s.capacity() >= 3);\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[inline]\n     #[unstable(feature = \"shrink_to\", reason = \"new API\", issue = \"56431\")]\n     pub fn shrink_to(&mut self, min_capacity: usize) {\n@@ -1074,6 +1097,7 @@ impl String {\n     ///\n     /// assert_eq!(\"abc123\", s);\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push(&mut self, ch: char) {\n@@ -1222,6 +1246,7 @@ impl String {\n     /// s.remove_matches(\"ana\");\n     /// assert_eq!(\"bna\", s);\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[unstable(feature = \"string_remove_matches\", reason = \"new API\", issue = \"72826\")]\n     pub fn remove_matches<'a, P>(&'a mut self, pat: P)\n     where\n@@ -1352,6 +1377,7 @@ impl String {\n     ///\n     /// assert_eq!(\"foo\", s);\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, idx: usize, ch: char) {\n@@ -1364,6 +1390,7 @@ impl String {\n         }\n     }\n \n+    #[cfg(not(no_global_oom_handling))]\n     unsafe fn insert_bytes(&mut self, idx: usize, bytes: &[u8]) {\n         let len = self.len();\n         let amt = bytes.len();\n@@ -1397,6 +1424,7 @@ impl String {\n     ///\n     /// assert_eq!(\"foobar\", s);\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[inline]\n     #[stable(feature = \"insert_str\", since = \"1.16.0\")]\n     pub fn insert_str(&mut self, idx: usize, string: &str) {\n@@ -1502,6 +1530,7 @@ impl String {\n     /// assert_eq!(world, \"World!\");\n     /// # }\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[inline]\n     #[stable(feature = \"string_split_off\", since = \"1.16.0\")]\n     #[must_use = \"use `.truncate()` if you don't need the other half\"]\n@@ -1608,6 +1637,7 @@ impl String {\n     /// s.replace_range(..beta_offset, \"\u0391 is capital alpha; \");\n     /// assert_eq!(s, \"\u0391 is capital alpha; \u03b2 is beta\");\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[stable(feature = \"splice\", since = \"1.27.0\")]\n     pub fn replace_range<R>(&mut self, range: R, replace_with: &str)\n     where\n@@ -1654,6 +1684,7 @@ impl String {\n     ///\n     /// let b = s.into_boxed_str();\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[stable(feature = \"box_str\", since = \"1.4.0\")]\n     #[inline]\n     pub fn into_boxed_str(self) -> Box<str> {\n@@ -1748,6 +1779,7 @@ impl fmt::Display for FromUtf16Error {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Clone for String {\n     fn clone(&self) -> Self {\n@@ -1759,6 +1791,7 @@ impl Clone for String {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromIterator<char> for String {\n     fn from_iter<I: IntoIterator<Item = char>>(iter: I) -> String {\n@@ -1768,6 +1801,7 @@ impl FromIterator<char> for String {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"string_from_iter_by_ref\", since = \"1.17.0\")]\n impl<'a> FromIterator<&'a char> for String {\n     fn from_iter<I: IntoIterator<Item = &'a char>>(iter: I) -> String {\n@@ -1777,6 +1811,7 @@ impl<'a> FromIterator<&'a char> for String {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> FromIterator<&'a str> for String {\n     fn from_iter<I: IntoIterator<Item = &'a str>>(iter: I) -> String {\n@@ -1786,6 +1821,7 @@ impl<'a> FromIterator<&'a str> for String {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"extend_string\", since = \"1.4.0\")]\n impl FromIterator<String> for String {\n     fn from_iter<I: IntoIterator<Item = String>>(iter: I) -> String {\n@@ -1804,6 +1840,7 @@ impl FromIterator<String> for String {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"box_str2\", since = \"1.45.0\")]\n impl FromIterator<Box<str>> for String {\n     fn from_iter<I: IntoIterator<Item = Box<str>>>(iter: I) -> String {\n@@ -1813,6 +1850,7 @@ impl FromIterator<Box<str>> for String {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"herd_cows\", since = \"1.19.0\")]\n impl<'a> FromIterator<Cow<'a, str>> for String {\n     fn from_iter<I: IntoIterator<Item = Cow<'a, str>>>(iter: I) -> String {\n@@ -1832,6 +1870,7 @@ impl<'a> FromIterator<Cow<'a, str>> for String {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Extend<char> for String {\n     fn extend<I: IntoIterator<Item = char>>(&mut self, iter: I) {\n@@ -1852,6 +1891,7 @@ impl Extend<char> for String {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a> Extend<&'a char> for String {\n     fn extend<I: IntoIterator<Item = &'a char>>(&mut self, iter: I) {\n@@ -1869,6 +1909,7 @@ impl<'a> Extend<&'a char> for String {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Extend<&'a str> for String {\n     fn extend<I: IntoIterator<Item = &'a str>>(&mut self, iter: I) {\n@@ -1881,13 +1922,15 @@ impl<'a> Extend<&'a str> for String {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"box_str2\", since = \"1.45.0\")]\n impl Extend<Box<str>> for String {\n     fn extend<I: IntoIterator<Item = Box<str>>>(&mut self, iter: I) {\n         iter.into_iter().for_each(move |s| self.push_str(&s));\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"extend_string\", since = \"1.4.0\")]\n impl Extend<String> for String {\n     fn extend<I: IntoIterator<Item = String>>(&mut self, iter: I) {\n@@ -1900,6 +1943,7 @@ impl Extend<String> for String {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"herd_cows\", since = \"1.19.0\")]\n impl<'a> Extend<Cow<'a, str>> for String {\n     fn extend<I: IntoIterator<Item = Cow<'a, str>>>(&mut self, iter: I) {\n@@ -2001,8 +2045,11 @@ macro_rules! impl_eq {\n \n impl_eq! { String, str }\n impl_eq! { String, &'a str }\n+#[cfg(not(no_global_oom_handling))]\n impl_eq! { Cow<'a, str>, str }\n+#[cfg(not(no_global_oom_handling))]\n impl_eq! { Cow<'a, str>, &'b str }\n+#[cfg(not(no_global_oom_handling))]\n impl_eq! { Cow<'a, str>, String }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2075,6 +2122,7 @@ impl hash::Hash for String {\n /// let b = \" world\";\n /// let c = a.to_string() + b;\n /// ```\n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Add<&str> for String {\n     type Output = String;\n@@ -2089,6 +2137,7 @@ impl Add<&str> for String {\n /// Implements the `+=` operator for appending to a `String`.\n ///\n /// This has the same behavior as the [`push_str`][String::push_str] method.\n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"stringaddassign\", since = \"1.12.0\")]\n impl AddAssign<&str> for String {\n     #[inline]\n@@ -2221,6 +2270,7 @@ impl ops::DerefMut for String {\n #[stable(feature = \"str_parse_error\", since = \"1.5.0\")]\n pub type ParseError = core::convert::Infallible;\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromStr for String {\n     type Err = core::convert::Infallible;\n@@ -2264,6 +2314,7 @@ pub trait ToString {\n /// if the `Display` implementation returns an error.\n /// This indicates an incorrect `Display` implementation\n /// since `fmt::Write for String` never returns an error itself.\n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Display + ?Sized> ToString for T {\n     // A common guideline is to not inline generic functions. However,\n@@ -2280,6 +2331,7 @@ impl<T: fmt::Display + ?Sized> ToString for T {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"char_to_string_specialization\", since = \"1.46.0\")]\n impl ToString for char {\n     #[inline]\n@@ -2288,6 +2340,7 @@ impl ToString for char {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"u8_to_string_specialization\", since = \"1.54.0\")]\n impl ToString for u8 {\n     #[inline]\n@@ -2307,6 +2360,7 @@ impl ToString for u8 {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"i8_to_string_specialization\", since = \"1.54.0\")]\n impl ToString for i8 {\n     #[inline]\n@@ -2329,6 +2383,7 @@ impl ToString for i8 {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"str_to_string_specialization\", since = \"1.9.0\")]\n impl ToString for str {\n     #[inline]\n@@ -2337,6 +2392,7 @@ impl ToString for str {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"cow_str_to_string_specialization\", since = \"1.17.0\")]\n impl ToString for Cow<'_, str> {\n     #[inline]\n@@ -2345,6 +2401,7 @@ impl ToString for Cow<'_, str> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"string_to_string_specialization\", since = \"1.17.0\")]\n impl ToString for String {\n     #[inline]\n@@ -2377,6 +2434,7 @@ impl AsRef<[u8]> for String {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl From<&str> for String {\n     #[inline]\n@@ -2385,6 +2443,7 @@ impl From<&str> for String {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"from_mut_str_for_string\", since = \"1.44.0\")]\n impl From<&mut str> for String {\n     /// Converts a `&mut str` into a `String`.\n@@ -2396,6 +2455,7 @@ impl From<&mut str> for String {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"from_ref_string\", since = \"1.35.0\")]\n impl From<&String> for String {\n     #[inline]\n@@ -2427,6 +2487,7 @@ impl From<Box<str>> for String {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"box_from_str\", since = \"1.20.0\")]\n impl From<String> for Box<str> {\n     /// Converts the given `String` to a boxed `str` slice that is owned.\n@@ -2447,13 +2508,15 @@ impl From<String> for Box<str> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"string_from_cow_str\", since = \"1.14.0\")]\n impl<'a> From<Cow<'a, str>> for String {\n     fn from(s: Cow<'a, str>) -> String {\n         s.into_owned()\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> From<&'a str> for Cow<'a, str> {\n     /// Converts a string slice into a Borrowed variant.\n@@ -2472,6 +2535,7 @@ impl<'a> From<&'a str> for Cow<'a, str> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> From<String> for Cow<'a, str> {\n     /// Converts a String into an Owned variant.\n@@ -2492,6 +2556,7 @@ impl<'a> From<String> for Cow<'a, str> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"cow_from_string_ref\", since = \"1.28.0\")]\n impl<'a> From<&'a String> for Cow<'a, str> {\n     /// Converts a String reference into a Borrowed variant.\n@@ -2511,20 +2576,23 @@ impl<'a> From<&'a String> for Cow<'a, str> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"cow_str_from_iter\", since = \"1.12.0\")]\n impl<'a> FromIterator<char> for Cow<'a, str> {\n     fn from_iter<I: IntoIterator<Item = char>>(it: I) -> Cow<'a, str> {\n         Cow::Owned(FromIterator::from_iter(it))\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"cow_str_from_iter\", since = \"1.12.0\")]\n impl<'a, 'b> FromIterator<&'b str> for Cow<'a, str> {\n     fn from_iter<I: IntoIterator<Item = &'b str>>(it: I) -> Cow<'a, str> {\n         Cow::Owned(FromIterator::from_iter(it))\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"cow_str_from_iter\", since = \"1.12.0\")]\n impl<'a> FromIterator<String> for Cow<'a, str> {\n     fn from_iter<I: IntoIterator<Item = String>>(it: I) -> Cow<'a, str> {\n@@ -2553,6 +2621,7 @@ impl From<String> for Vec<u8> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Write for String {\n     #[inline]\n@@ -2676,6 +2745,7 @@ impl DoubleEndedIterator for Drain<'_> {\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl FusedIterator for Drain<'_> {}\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"from_char_for_string\", since = \"1.46.0\")]\n impl From<char> for String {\n     #[inline]"}, {"sha": "17927f5f5fdc4f054daeebc6ad9e4b996211aadf", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d620ae10709ca3669cda89db8b29afcd9accc188/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d620ae10709ca3669cda89db8b29afcd9accc188/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=d620ae10709ca3669cda89db8b29afcd9accc188", "patch": "@@ -12,23 +12,31 @@ use core::fmt;\n use core::hash::{Hash, Hasher};\n use core::hint;\n use core::intrinsics::abort;\n+#[cfg(not(no_global_oom_handling))]\n use core::iter;\n use core::marker::{PhantomData, Unpin, Unsize};\n-use core::mem::{self, align_of_val_raw, size_of_val};\n+#[cfg(not(no_global_oom_handling))]\n+use core::mem::size_of_val;\n+use core::mem::{self, align_of_val_raw};\n use core::ops::{CoerceUnsized, Deref, DispatchFromDyn, Receiver};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n+#[cfg(not(no_global_oom_handling))]\n use core::slice::from_raw_parts_mut;\n use core::sync::atomic;\n use core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\n \n-use crate::alloc::{\n-    box_free, handle_alloc_error, AllocError, Allocator, Global, Layout, WriteCloneIntoRaw,\n-};\n+#[cfg(not(no_global_oom_handling))]\n+use crate::alloc::handle_alloc_error;\n+#[cfg(not(no_global_oom_handling))]\n+use crate::alloc::{box_free, WriteCloneIntoRaw};\n+use crate::alloc::{AllocError, Allocator, Global, Layout};\n use crate::borrow::{Cow, ToOwned};\n use crate::boxed::Box;\n use crate::rc::is_dangling;\n+#[cfg(not(no_global_oom_handling))]\n use crate::string::String;\n+#[cfg(not(no_global_oom_handling))]\n use crate::vec::Vec;\n \n #[cfg(test)]\n@@ -431,6 +439,7 @@ impl<T> Arc<T> {\n     ///\n     /// assert_eq!(*five, 5)\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit() -> Arc<mem::MaybeUninit<T>> {\n         unsafe {\n@@ -462,6 +471,7 @@ impl<T> Arc<T> {\n     /// ```\n     ///\n     /// [zeroed]: ../../std/mem/union.MaybeUninit.html#method.zeroed\n+    #[cfg(not(no_global_oom_handling))]\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_zeroed() -> Arc<mem::MaybeUninit<T>> {\n         unsafe {\n@@ -635,6 +645,7 @@ impl<T> Arc<[T]> {\n     ///\n     /// assert_eq!(*values, [1, 2, 3])\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit_slice(len: usize) -> Arc<[mem::MaybeUninit<T>]> {\n         unsafe { Arc::from_ptr(Arc::allocate_for_slice(len)) }\n@@ -660,6 +671,7 @@ impl<T> Arc<[T]> {\n     /// ```\n     ///\n     /// [zeroed]: ../../std/mem/union.MaybeUninit.html#method.zeroed\n+    #[cfg(not(no_global_oom_handling))]\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_zeroed_slice(len: usize) -> Arc<[mem::MaybeUninit<T>]> {\n         unsafe {\n@@ -1072,6 +1084,7 @@ impl<T: ?Sized> Arc<T> {\n     ///\n     /// The function `mem_to_arcinner` is called with the data pointer\n     /// and must return back a (potentially fat)-pointer for the `ArcInner<T>`.\n+    #[cfg(not(no_global_oom_handling))]\n     unsafe fn allocate_for_layout(\n         value_layout: Layout,\n         allocate: impl FnOnce(Layout) -> Result<NonNull<[u8]>, AllocError>,\n@@ -1120,6 +1133,7 @@ impl<T: ?Sized> Arc<T> {\n     }\n \n     /// Allocates an `ArcInner<T>` with sufficient space for an unsized inner value.\n+    #[cfg(not(no_global_oom_handling))]\n     unsafe fn allocate_for_ptr(ptr: *const T) -> *mut ArcInner<T> {\n         // Allocate for the `ArcInner<T>` using the given value.\n         unsafe {\n@@ -1131,6 +1145,7 @@ impl<T: ?Sized> Arc<T> {\n         }\n     }\n \n+    #[cfg(not(no_global_oom_handling))]\n     fn from_box(v: Box<T>) -> Arc<T> {\n         unsafe {\n             let (box_unique, alloc) = Box::into_unique(v);\n@@ -1156,6 +1171,7 @@ impl<T: ?Sized> Arc<T> {\n \n impl<T> Arc<[T]> {\n     /// Allocates an `ArcInner<[T]>` with the given length.\n+    #[cfg(not(no_global_oom_handling))]\n     unsafe fn allocate_for_slice(len: usize) -> *mut ArcInner<[T]> {\n         unsafe {\n             Self::allocate_for_layout(\n@@ -1169,6 +1185,7 @@ impl<T> Arc<[T]> {\n     /// Copy elements from slice into newly allocated Arc<\\[T\\]>\n     ///\n     /// Unsafe because the caller must either take ownership or bind `T: Copy`.\n+    #[cfg(not(no_global_oom_handling))]\n     unsafe fn copy_from_slice(v: &[T]) -> Arc<[T]> {\n         unsafe {\n             let ptr = Self::allocate_for_slice(v.len());\n@@ -1182,6 +1199,7 @@ impl<T> Arc<[T]> {\n     /// Constructs an `Arc<[T]>` from an iterator known to be of a certain size.\n     ///\n     /// Behavior is undefined should the size be wrong.\n+    #[cfg(not(no_global_oom_handling))]\n     unsafe fn from_iter_exact(iter: impl iter::Iterator<Item = T>, len: usize) -> Arc<[T]> {\n         // Panic guard while cloning T elements.\n         // In the event of a panic, elements that have been written\n@@ -1229,17 +1247,20 @@ impl<T> Arc<[T]> {\n }\n \n /// Specialization trait used for `From<&[T]>`.\n+#[cfg(not(no_global_oom_handling))]\n trait ArcFromSlice<T> {\n     fn from_slice(slice: &[T]) -> Self;\n }\n \n+#[cfg(not(no_global_oom_handling))]\n impl<T: Clone> ArcFromSlice<T> for Arc<[T]> {\n     #[inline]\n     default fn from_slice(v: &[T]) -> Self {\n         unsafe { Self::from_iter_exact(v.iter().cloned(), v.len()) }\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n impl<T: Copy> ArcFromSlice<T> for Arc<[T]> {\n     #[inline]\n     fn from_slice(v: &[T]) -> Self {\n@@ -1341,6 +1362,7 @@ impl<T: Clone> Arc<T> {\n     /// assert_eq!(*data, 8);\n     /// assert_eq!(*other_data, 12);\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[inline]\n     #[stable(feature = \"arc_unique\", since = \"1.4.0\")]\n     pub fn make_mut(this: &mut Self) -> &mut T {\n@@ -2283,6 +2305,7 @@ impl<T> From<T> for Arc<T> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n impl<T: Clone> From<&[T]> for Arc<[T]> {\n     /// Allocate a reference-counted slice and fill it by cloning `v`'s items.\n@@ -2301,6 +2324,7 @@ impl<T: Clone> From<&[T]> for Arc<[T]> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n impl From<&str> for Arc<str> {\n     /// Allocate a reference-counted `str` and copy `v` into it.\n@@ -2319,6 +2343,7 @@ impl From<&str> for Arc<str> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n impl From<String> for Arc<str> {\n     /// Allocate a reference-counted `str` and copy `v` into it.\n@@ -2337,6 +2362,7 @@ impl From<String> for Arc<str> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n impl<T: ?Sized> From<Box<T>> for Arc<T> {\n     /// Move a boxed object to a new, reference-counted allocation.\n@@ -2355,6 +2381,7 @@ impl<T: ?Sized> From<Box<T>> for Arc<T> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n impl<T> From<Vec<T>> for Arc<[T]> {\n     /// Allocate a reference-counted slice and move `v`'s items into it.\n@@ -2408,6 +2435,7 @@ impl<T, const N: usize> TryFrom<Arc<[T]>> for Arc<[T; N]> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"shared_from_iter\", since = \"1.37.0\")]\n impl<T> iter::FromIterator<T> for Arc<[T]> {\n     /// Takes each element in the `Iterator` and collects it into an `Arc<[T]>`.\n@@ -2458,12 +2486,14 @@ trait ToArcSlice<T>: Iterator<Item = T> + Sized {\n     fn to_arc_slice(self) -> Arc<[T]>;\n }\n \n+#[cfg(not(no_global_oom_handling))]\n impl<T, I: Iterator<Item = T>> ToArcSlice<T> for I {\n     default fn to_arc_slice(self) -> Arc<[T]> {\n         self.collect::<Vec<T>>().into()\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n impl<T, I: iter::TrustedLen<Item = T>> ToArcSlice<T> for I {\n     fn to_arc_slice(self) -> Arc<[T]> {\n         // This is the case for a `TrustedLen` iterator."}, {"sha": "2e68161d260bdd5933fd3d4366e3cb9a890c3f5a", "filename": "library/alloc/src/vec/into_iter.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d620ae10709ca3669cda89db8b29afcd9accc188/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d620ae10709ca3669cda89db8b29afcd9accc188/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs?ref=d620ae10709ca3669cda89db8b29afcd9accc188", "patch": "@@ -94,6 +94,7 @@ impl<T, A: Allocator> IntoIter<T, A> {\n     /// (&mut into_iter).for_each(core::mem::drop);\n     /// unsafe { core::ptr::write(&mut into_iter, Vec::new().into_iter()); }\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     pub(super) fn forget_allocation_drop_remaining(&mut self) {\n         let remaining = self.as_raw_mut_slice();\n \n@@ -224,6 +225,7 @@ where\n     const MAY_HAVE_SIDE_EFFECT: bool = false;\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"vec_into_iter_clone\", since = \"1.8.0\")]\n impl<T: Clone, A: Allocator + Clone> Clone for IntoIter<T, A> {\n     #[cfg(not(test))]"}, {"sha": "1c33ff555d628fe10bbde22cfc043eb2d3910273", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 54, "deletions": 2, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d620ae10709ca3669cda89db8b29afcd9accc188/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d620ae10709ca3669cda89db8b29afcd9accc188/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=d620ae10709ca3669cda89db8b29afcd9accc188", "patch": "@@ -53,12 +53,16 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use core::cmp::{self, Ordering};\n+#[cfg(not(no_global_oom_handling))]\n+use core::cmp;\n+use core::cmp::Ordering;\n use core::convert::TryFrom;\n use core::fmt;\n use core::hash::{Hash, Hasher};\n use core::intrinsics::{arith_offset, assume};\n-use core::iter::{self, FromIterator};\n+use core::iter;\n+#[cfg(not(no_global_oom_handling))]\n+use core::iter::FromIterator;\n use core::marker::PhantomData;\n use core::mem::{self, ManuallyDrop, MaybeUninit};\n use core::ops::{self, Index, IndexMut, Range, RangeBounds};\n@@ -76,54 +80,72 @@ pub use self::drain_filter::DrainFilter;\n \n mod drain_filter;\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n pub use self::splice::Splice;\n \n+#[cfg(not(no_global_oom_handling))]\n mod splice;\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n pub use self::drain::Drain;\n \n mod drain;\n \n+#[cfg(not(no_global_oom_handling))]\n mod cow;\n \n+#[cfg(not(no_global_oom_handling))]\n pub(crate) use self::into_iter::AsIntoIter;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::into_iter::IntoIter;\n \n mod into_iter;\n \n+#[cfg(not(no_global_oom_handling))]\n use self::is_zero::IsZero;\n \n mod is_zero;\n \n+#[cfg(not(no_global_oom_handling))]\n mod source_iter_marker;\n \n mod partial_eq;\n \n+#[cfg(not(no_global_oom_handling))]\n use self::spec_from_elem::SpecFromElem;\n \n+#[cfg(not(no_global_oom_handling))]\n mod spec_from_elem;\n \n+#[cfg(not(no_global_oom_handling))]\n use self::set_len_on_drop::SetLenOnDrop;\n \n+#[cfg(not(no_global_oom_handling))]\n mod set_len_on_drop;\n \n+#[cfg(not(no_global_oom_handling))]\n use self::in_place_drop::InPlaceDrop;\n \n+#[cfg(not(no_global_oom_handling))]\n mod in_place_drop;\n \n+#[cfg(not(no_global_oom_handling))]\n use self::spec_from_iter_nested::SpecFromIterNested;\n \n+#[cfg(not(no_global_oom_handling))]\n mod spec_from_iter_nested;\n \n+#[cfg(not(no_global_oom_handling))]\n use self::spec_from_iter::SpecFromIter;\n \n+#[cfg(not(no_global_oom_handling))]\n mod spec_from_iter;\n \n+#[cfg(not(no_global_oom_handling))]\n use self::spec_extend::SpecExtend;\n \n+#[cfg(not(no_global_oom_handling))]\n mod spec_extend;\n \n /// A contiguous growable array type, written as `Vec<T>` and pronounced 'vector'.\n@@ -435,6 +457,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec.len(), 11);\n     /// assert!(vec.capacity() >= 11);\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[inline]\n     #[doc(alias = \"malloc\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -574,6 +597,7 @@ impl<T, A: Allocator> Vec<T, A> {\n     /// assert_eq!(vec.len(), 11);\n     /// assert!(vec.capacity() >= 11);\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[inline]\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     pub fn with_capacity_in(capacity: usize, alloc: A) -> Self {\n@@ -774,6 +798,7 @@ impl<T, A: Allocator> Vec<T, A> {\n     /// vec.reserve(10);\n     /// assert!(vec.capacity() >= 11);\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[doc(alias = \"realloc\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: usize) {\n@@ -800,6 +825,7 @@ impl<T, A: Allocator> Vec<T, A> {\n     /// vec.reserve_exact(10);\n     /// assert!(vec.capacity() >= 11);\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[doc(alias = \"realloc\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_exact(&mut self, additional: usize) {\n@@ -900,6 +926,7 @@ impl<T, A: Allocator> Vec<T, A> {\n     /// vec.shrink_to_fit();\n     /// assert!(vec.capacity() >= 3);\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[doc(alias = \"realloc\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n@@ -930,6 +957,7 @@ impl<T, A: Allocator> Vec<T, A> {\n     /// vec.shrink_to(0);\n     /// assert!(vec.capacity() >= 3);\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[doc(alias = \"realloc\")]\n     #[unstable(feature = \"shrink_to\", reason = \"new API\", issue = \"56431\")]\n     pub fn shrink_to(&mut self, min_capacity: usize) {\n@@ -962,6 +990,7 @@ impl<T, A: Allocator> Vec<T, A> {\n     /// let slice = vec.into_boxed_slice();\n     /// assert_eq!(slice.into_vec().capacity(), 3);\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_boxed_slice(mut self) -> Box<[T], A> {\n         unsafe {\n@@ -1299,6 +1328,7 @@ impl<T, A: Allocator> Vec<T, A> {\n     /// vec.insert(4, 5);\n     /// assert_eq!(vec, [1, 4, 2, 3, 5]);\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, index: usize, element: T) {\n         #[cold]\n@@ -1627,6 +1657,7 @@ impl<T, A: Allocator> Vec<T, A> {\n     /// vec.push(3);\n     /// assert_eq!(vec, [1, 2, 3]);\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push(&mut self, value: T) {\n@@ -1680,6 +1711,7 @@ impl<T, A: Allocator> Vec<T, A> {\n     /// assert_eq!(vec, [1, 2, 3, 4, 5, 6]);\n     /// assert_eq!(vec2, []);\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[inline]\n     #[stable(feature = \"append\", since = \"1.4.0\")]\n     pub fn append(&mut self, other: &mut Self) {\n@@ -1690,6 +1722,7 @@ impl<T, A: Allocator> Vec<T, A> {\n     }\n \n     /// Appends elements to `Self` from other buffer.\n+    #[cfg(not(no_global_oom_handling))]\n     #[inline]\n     unsafe fn append_elements(&mut self, other: *const [T]) {\n         let count = unsafe { (*other).len() };\n@@ -1827,6 +1860,7 @@ impl<T, A: Allocator> Vec<T, A> {\n     /// assert_eq!(vec, [1]);\n     /// assert_eq!(vec2, [2, 3]);\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[inline]\n     #[must_use = \"use `.truncate()` if you don't need the other half\"]\n     #[stable(feature = \"split_off\", since = \"1.4.0\")]\n@@ -1891,6 +1925,7 @@ impl<T, A: Allocator> Vec<T, A> {\n     /// vec.resize_with(4, || { p *= 2; p });\n     /// assert_eq!(vec, [2, 4, 8, 16]);\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[stable(feature = \"vec_resize_with\", since = \"1.33.0\")]\n     pub fn resize_with<F>(&mut self, new_len: usize, f: F)\n     where\n@@ -1926,6 +1961,7 @@ impl<T, A: Allocator> Vec<T, A> {\n     /// static_ref[0] += 1;\n     /// assert_eq!(static_ref, &[2, 2, 3]);\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[stable(feature = \"vec_leak\", since = \"1.47.0\")]\n     #[inline]\n     pub fn leak<'a>(self) -> &'a mut [T]\n@@ -2084,6 +2120,7 @@ impl<T: Clone, A: Allocator> Vec<T, A> {\n     /// vec.resize(2, 0);\n     /// assert_eq!(vec, [1, 2]);\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[stable(feature = \"vec_resize\", since = \"1.5.0\")]\n     pub fn resize(&mut self, new_len: usize, value: T) {\n         let len = self.len();\n@@ -2114,6 +2151,7 @@ impl<T: Clone, A: Allocator> Vec<T, A> {\n     /// ```\n     ///\n     /// [`extend`]: Vec::extend\n+    #[cfg(not(no_global_oom_handling))]\n     #[stable(feature = \"vec_extend_from_slice\", since = \"1.6.0\")]\n     pub fn extend_from_slice(&mut self, other: &[T]) {\n         self.spec_extend(other.iter())\n@@ -2135,6 +2173,7 @@ impl<T: Clone, A: Allocator> Vec<T, A> {\n     /// vec.extend_from_within(4..8);\n     /// assert_eq!(vec, [0, 1, 2, 3, 4, 2, 3, 4, 0, 1, 4, 2, 3, 4]);\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[stable(feature = \"vec_extend_from_within\", since = \"1.53.0\")]\n     pub fn extend_from_within<R>(&mut self, src: R)\n     where\n@@ -2188,6 +2227,7 @@ impl<T, F: FnMut() -> T> ExtendWith<T> for ExtendFunc<F> {\n }\n \n impl<T, A: Allocator> Vec<T, A> {\n+    #[cfg(not(no_global_oom_handling))]\n     /// Extend the vector by `n` values, using the given generator.\n     fn extend_with<E: ExtendWith<T>>(&mut self, n: usize, mut value: E) {\n         self.reserve(n);\n@@ -2245,12 +2285,14 @@ impl<T: PartialEq, A: Allocator> Vec<T, A> {\n ////////////////////////////////////////////////////////////////////////////////\n \n #[doc(hidden)]\n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn from_elem<T: Clone>(elem: T, n: usize) -> Vec<T> {\n     <T as SpecFromElem>::from_elem(elem, n, Global)\n }\n \n #[doc(hidden)]\n+#[cfg(not(no_global_oom_handling))]\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n pub fn from_elem_in<T: Clone, A: Allocator>(elem: T, n: usize, alloc: A) -> Vec<T, A> {\n     <T as SpecFromElem>::from_elem(elem, n, alloc)\n@@ -2331,6 +2373,7 @@ impl<T, A: Allocator> ops::DerefMut for Vec<T, A> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone, A: Allocator + Clone> Clone for Vec<T, A> {\n     #[cfg(not(test))]\n@@ -2397,6 +2440,7 @@ impl<T, I: SliceIndex<[T]>, A: Allocator> IndexMut<I> for Vec<T, A> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> FromIterator<T> for Vec<T> {\n     #[inline]\n@@ -2467,6 +2511,7 @@ impl<'a, T, A: Allocator> IntoIterator for &'a mut Vec<T, A> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, A: Allocator> Extend<T> for Vec<T, A> {\n     #[inline]\n@@ -2488,6 +2533,7 @@ impl<T, A: Allocator> Extend<T> for Vec<T, A> {\n impl<T, A: Allocator> Vec<T, A> {\n     // leaf method to which various SpecFrom/SpecExtend implementations delegate when\n     // they have no further optimizations to apply\n+    #[cfg(not(no_global_oom_handling))]\n     fn extend_desugared<I: Iterator<Item = T>>(&mut self, mut iterator: I) {\n         // This is the case for a general iterator.\n         //\n@@ -2543,6 +2589,7 @@ impl<T, A: Allocator> Vec<T, A> {\n     /// assert_eq!(v, &[7, 8, 3]);\n     /// assert_eq!(u, &[1, 2]);\n     /// ```\n+    #[cfg(not(no_global_oom_handling))]\n     #[inline]\n     #[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n     pub fn splice<R, I>(&mut self, range: R, replace_with: I) -> Splice<'_, I::IntoIter, A>\n@@ -2619,6 +2666,7 @@ impl<T, A: Allocator> Vec<T, A> {\n /// append the entire slice at once.\n ///\n /// [`copy_from_slice`]: slice::copy_from_slice\n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a, T: Copy + 'a, A: Allocator + 'a> Extend<&'a T> for Vec<T, A> {\n     fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n@@ -2713,6 +2761,7 @@ impl<T, A: Allocator> AsMut<[T]> for Vec<T, A> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> From<&[T]> for Vec<T> {\n     /// Allocate a `Vec<T>` and fill it by cloning `s`'s items.\n@@ -2732,6 +2781,7 @@ impl<T: Clone> From<&[T]> for Vec<T> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"vec_from_mut\", since = \"1.19.0\")]\n impl<T: Clone> From<&mut [T]> for Vec<T> {\n     /// Allocate a `Vec<T>` and fill it by cloning `s`'s items.\n@@ -2813,6 +2863,7 @@ impl<T, A: Allocator> From<Box<[T], A>> for Vec<T, A> {\n }\n \n // note: test pulls in libstd, which causes errors here\n+#[cfg(not(no_global_oom_handling))]\n #[cfg(not(test))]\n #[stable(feature = \"box_from_vec\", since = \"1.20.0\")]\n impl<T, A: Allocator> From<Vec<T, A>> for Box<[T], A> {\n@@ -2831,6 +2882,7 @@ impl<T, A: Allocator> From<Vec<T, A>> for Box<[T], A> {\n     }\n }\n \n+#[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl From<&str> for Vec<u8> {\n     /// Allocate a `Vec<u8>` and fill it with a UTF-8 string."}, {"sha": "50e1409610507e4e4bf05eaffce6aae99b92bffe", "filename": "library/alloc/src/vec/partial_eq.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d620ae10709ca3669cda89db8b29afcd9accc188/library%2Falloc%2Fsrc%2Fvec%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d620ae10709ca3669cda89db8b29afcd9accc188/library%2Falloc%2Fsrc%2Fvec%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fpartial_eq.rs?ref=d620ae10709ca3669cda89db8b29afcd9accc188", "patch": "@@ -1,4 +1,5 @@\n use crate::alloc::Allocator;\n+#[cfg(not(no_global_oom_handling))]\n use crate::borrow::Cow;\n \n use super::Vec;\n@@ -26,8 +27,11 @@ __impl_slice_eq1! { [A: Allocator] &[T], Vec<U, A>, #[stable(feature = \"partiale\n __impl_slice_eq1! { [A: Allocator] &mut [T], Vec<U, A>, #[stable(feature = \"partialeq_vec_for_ref_slice\", since = \"1.46.0\")] }\n __impl_slice_eq1! { [A: Allocator] Vec<T, A>, [U], #[stable(feature = \"partialeq_vec_for_slice\", since = \"1.48.0\")]  }\n __impl_slice_eq1! { [A: Allocator] [T], Vec<U, A>, #[stable(feature = \"partialeq_vec_for_slice\", since = \"1.48.0\")]  }\n+#[cfg(not(no_global_oom_handling))]\n __impl_slice_eq1! { [A: Allocator] Cow<'_, [T]>, Vec<U, A> where T: Clone, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n+#[cfg(not(no_global_oom_handling))]\n __impl_slice_eq1! { [] Cow<'_, [T]>, &[U] where T: Clone, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n+#[cfg(not(no_global_oom_handling))]\n __impl_slice_eq1! { [] Cow<'_, [T]>, &mut [U] where T: Clone, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n __impl_slice_eq1! { [A: Allocator, const N: usize] Vec<T, A>, [U; N], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n __impl_slice_eq1! { [A: Allocator, const N: usize] Vec<T, A>, &[U; N], #[stable(feature = \"rust1\", since = \"1.0.0\")] }"}, {"sha": "63f34594453690ad4fa323ad78a7bea5d21c49f1", "filename": "src/test/run-make-fulldeps/alloc-extern-crates/Makefile", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bacf770f2983a52f31e3537db5f0fe1ef2eaa874/src%2Ftest%2Frun-make-fulldeps%2Falloc-extern-crates%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/bacf770f2983a52f31e3537db5f0fe1ef2eaa874/src%2Ftest%2Frun-make-fulldeps%2Falloc-extern-crates%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Falloc-extern-crates%2FMakefile?ref=bacf770f2983a52f31e3537db5f0fe1ef2eaa874", "patch": "@@ -1,5 +0,0 @@\n--include ../tools.mk\n-\n-all:\n-\t$(RUSTC) fakealloc.rs\n-\t$(RUSTC) --edition=2018 --crate-type=rlib ../../../../library/alloc/src/lib.rs --cfg feature=\\\"external_crate\\\" --extern external=$(TMPDIR)/$(shell $(RUSTC) --print file-names fakealloc.rs)"}, {"sha": "d4612c325d5ac66f9077363118c16af3d7fe4208", "filename": "src/test/run-make-fulldeps/alloc-extern-crates/fakealloc.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bacf770f2983a52f31e3537db5f0fe1ef2eaa874/src%2Ftest%2Frun-make-fulldeps%2Falloc-extern-crates%2Ffakealloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacf770f2983a52f31e3537db5f0fe1ef2eaa874/src%2Ftest%2Frun-make-fulldeps%2Falloc-extern-crates%2Ffakealloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Falloc-extern-crates%2Ffakealloc.rs?ref=bacf770f2983a52f31e3537db5f0fe1ef2eaa874", "patch": "@@ -1,25 +0,0 @@\n-#![crate_type = \"rlib\"]\n-#![no_std]\n-\n-#[inline]\n-pub unsafe fn allocate(_size: usize, _align: usize) -> *mut u8 {\n-    core::ptr::null_mut()\n-}\n-\n-#[inline]\n-pub unsafe fn deallocate(_ptr: *mut u8, _old_size: usize, _align: usize) { }\n-\n-#[inline]\n-pub unsafe fn reallocate(_ptr: *mut u8, _old_size: usize, _size: usize, _align: usize) -> *mut u8 {\n-    core::ptr::null_mut()\n-}\n-\n-#[inline]\n-pub unsafe fn reallocate_inplace(_ptr: *mut u8, old_size: usize, _size: usize,\n-                                    _align: usize) -> usize { old_size }\n-\n-#[inline]\n-pub fn usable_size(size: usize, _align: usize) -> usize { size }\n-\n-#[inline]\n-pub fn stats_print() { }"}, {"sha": "c68ae40eb94e0d0afeff7e9941a6f39c6f45ea0b", "filename": "src/test/run-make-fulldeps/alloc-no-oom-handling/Makefile", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d620ae10709ca3669cda89db8b29afcd9accc188/src%2Ftest%2Frun-make-fulldeps%2Falloc-no-oom-handling%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/d620ae10709ca3669cda89db8b29afcd9accc188/src%2Ftest%2Frun-make-fulldeps%2Falloc-no-oom-handling%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Falloc-no-oom-handling%2FMakefile?ref=d620ae10709ca3669cda89db8b29afcd9accc188", "patch": "@@ -0,0 +1,4 @@\n+-include ../tools.mk\n+\n+all:\n+\t$(RUSTC) --edition=2018 --crate-type=rlib ../../../../library/alloc/src/lib.rs --cfg feature=\\\"external_crate\\\" --cfg no_global_oom_handling"}]}